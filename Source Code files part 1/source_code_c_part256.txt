enter the monitor to the same extent the SyncBlock would, if we returned
// through it (instead of throwing through it).  And we need to cancel the wait,
// if it didn't get notified away while we are processing the interrupt.
void PendingSync::Restore(BOOL bRemoveFromSB)
{
    _ASSERTE(m_EnterCount);

    Thread      *pCurThread = GetThread();

    _ASSERTE (pCurThread == m_OwnerThread);

    WaitEventLink *pRealWaitEventLink = m_WaitEventLink->m_Next;

    pRealWaitEventLink->m_RefCount --;
    if (pRealWaitEventLink->m_RefCount == 0)
    {
        if (bRemoveFromSB) {
            ThreadQueue::RemoveThread(pCurThread, pRealWaitEventLink->m_WaitSB);
        }
        if (pRealWaitEventLink->m_EventWait != pCurThread->m_EventWait) {
            // Put the event back to the pool.
            StoreEventToEventStore(pRealWaitEventLink->m_EventWait);
        }
        // Remove from the link.
        m_WaitEventLink->m_Next = m_WaitEventLink->m_Next->m_Next;
    }

    // Someone up the stack is responsible for keeping the syncblock alive by protecting
    // the object that owns it.  But this relies on assertions that EnterMonitor is only
    // called in cooperative mode.  Even though we are safe in preemptive, do the
    // switch.
    pCurThread->DisablePreemptiveGC();

    SyncBlock *psb = (SyncBlock*)((DWORD_PTR)pRealWaitEventLink->m_WaitSB & ~1);
    for (LONG i=0; i < m_EnterCount; i++)
         psb->EnterMonitor();

    pCurThread->EnablePreemptiveGC();
}



// This is the callback from the OS, when we queue an APC to interrupt a waiting thread.
// The callback occurs on the thread we wish to interrupt.  It is a STATIC method.
#ifdef _WIN64
void Thread::UserInterruptAPC(ULONG_PTR data)
#else // !_WIN64
void Thread::UserInterruptAPC(DWORD data)
#endif // _WIN64
{
    _ASSERTE(data == APC_Code);

    Thread *pCurThread = GetThread();
    if (pCurThread)
        // We should only take action if an interrupt is currently being
        // requested (our synchronization does not guarantee that we won't fire
        // spuriously). It's safe to check the m_UserInterrupt field and then
        // set TS_Interrupted in a non-atomic fashion because m_UserInterrupt is
        // only cleared in this thread's context (though it may be set from any
        // context).
        if (pCurThread->m_UserInterrupt)
            // Set bit to indicate this routine was called (as opposed to other
            // generic APCs).
            FastInterlockOr((ULONG *) &pCurThread->m_State, TS_Interrupted);
}

// This is the workhorse for Thread.Interrupt().
void Thread::UserInterrupt()
{
    // Transition from 0 to 1 implies we are responsible for queueing an APC.
    if ((FastInterlockExchange(&m_UserInterrupt, 1) == 0) &&
         GetThreadHandle() &&
         (m_State & TS_Interruptible))
    {
        ::QueueUserAPC(UserInterruptAPC, GetThreadHandle(), APC_Code);
    }
}

// Is the interrupt flag set?  Optionally, reset it
// @TODO -- add the InterruptRequested state & expose it through Thread.GetThreadState()
// @TODO -- don't use an exception to communicate the interrupt.  Just use the APC
//          mechanism and test for it in the blocking caller.
DWORD Thread::IsUserInterrupted(BOOL reset)
{
    LONG    state = (reset
                     ? FastInterlockExchange(&m_UserInterrupt, 0)
                     : m_UserInterrupt);

    return (state);
}

// Implementation of Thread.Sleep().
void Thread::UserSleep(INT32 time)
{
    _ASSERTE(!GetThread()->GCForbidden());

    THROWSCOMPLUSEXCEPTION();       // InterruptedException

    BOOL    alertable = (m_PreventAsync == 0);
    DWORD   res;

    EnablePreemptiveGC();

    if (alertable)
    {
        // A word about ordering for Interrupt.  If someone tries to interrupt a thread
        // that's in the interruptible state, we queue an APC.  But if they try to interrupt
        // a thread that's not in the interruptible state, we just record that fact.  So
        // we have to set TS_Interruptible before we test to see whether someone wants to
        // interrupt us or else we have a race condition that causes us to skip the APC.
        FastInterlockOr((ULONG *) &m_State, TS_Interruptible);

        // If someone has interrupted us, we should not enter the wait.
        if (IsUserInterrupted(TRUE /*=reset*/))
        {
            // It is safe to clear the following two bits of state while
            // m_UserInterrupt is clear since both bits are only manipulated
            // within the context of the thread (TS_Interrupted is set via APC,
            // but these are not half as asynchronous as their name implies). If
            // an APC was queued, it has either gone off (and set the
            // TS_Interrupted bit which we're about to clear) or will execute at
            // some arbitrary later time. This is OK. If it executes while an
            // interrupt is not being requested it will simply become a no-op.
            // Otherwise it will serve it's original intended purpose (we don't
            // care which APC matches up with which interrupt attempt).
            FastInterlockAnd((ULONG *) &m_State, ~(TS_Interruptible | TS_Interrupted));
            DisablePreemptiveGC();
            COMPlusThrow(kThreadInterruptedException);
        }
        // Safe to clear the interrupted state, no APC could have fired since we
        // reset m_UserInterrupt (which inhibits our APC callback from doing
        // anything).
        FastInterlockAnd((ULONG *) &m_State, ~TS_Interrupted);
    }

retry:

    BOOL blocked = FALSE;
    if (g_Win32Threadpool && (m_State & TS_ThreadPoolThread)) 
    {
        blocked = ThreadpoolMgr::ThreadAboutToBlock(this);    // inform the threadpool that this thread is about to block
    }
    res = ::SleepEx(time, alertable);
    if (blocked) 
    {
        ThreadpoolMgr::ThreadAboutToUnblock();  // inform the threadpool that a previously blocked thread is now ready to run
    }
    if (res == WAIT_IO_COMPLETION)
    {
        _ASSERTE(alertable);

        // We could be woken by some spurious APC or an EE APC queued to
        // interrupt us. In the latter case the TS_Interrupted bit will be set
        // in the thread state bits. Otherwise we just go back to sleep again.
        if (!(m_State & TS_Interrupted))
        {
            // Don't bother with accurate accounting here.  Just ensure we make progress.
            // Note that this is not us doing the APC.
            if (time == 0)
            {
                res = WAIT_TIMEOUT;
            }
            else
            {
                if (time != INFINITE)
                    time--;

                goto retry;
            }
        }
    }
    _ASSERTE(res == WAIT_TIMEOUT || res == WAIT_OBJECT_0 || res == WAIT_IO_COMPLETION);

    DisablePreemptiveGC();
    HandleThreadAbort();
    
    if (alertable)
    {
        FastInterlockAnd((ULONG *) &m_State, ~(TS_Interruptible | TS_Interrupted));

    // Make one last check to see if an interrupt request was made (and clear it
    // atomically). It's OK to clear the previous two bits first because they're
    // only accessed from this thread context.
    if (IsUserInterrupted(TRUE /*=reset*/))
        res = WAIT_IO_COMPLETION;

        if (res == WAIT_IO_COMPLETION)
            COMPlusThrow(kThreadInterruptedException);
    }
}

OBJECTREF Thread::GetExposedObjectRaw()
{
    return ObjectFromHandle(m_ExposedObject);
}
 
// Correspondence between an EE Thread and an exposed System.Thread:
OBJECTREF Thread::GetExposedObject()
{
    THROWSCOMPLUSEXCEPTION();
    Thread *pCurThread = GetThread();
    _ASSERTE (!(pCurThread == NULL || g_fProcessDetach));

    _ASSERTE(pCurThread->PreemptiveGCDisabled());

    if (ObjectFromHandle(m_ExposedObject) == NULL)
    {
        // Initialize ThreadNative::m_MT if it hasn't been done yet...
        ThreadNative::InitThread();

        // Allocate the exposed thread object.
        THREADBASEREF attempt = (THREADBASEREF) AllocateObject(ThreadNative::m_MT);
        GCPROTECT_BEGIN(attempt);

        BOOL fNeedThreadStore = (! ThreadStore::HoldingThreadStore(pCurThread));
        if (fNeedThreadStore) {
            // Take a lock to make sure that only one thread creates the object.
            pCurThread->EnablePreemptiveGC();
            ThreadStore::LockThreadStore();
            pCurThread->DisablePreemptiveGC();
        }

        // Check to see if another thread has not already created the exposed object.
        if (ObjectFromHandle(m_ExposedObject) == NULL)
        {
            // Keep a weak reference to the exposed object.
            StoreObjectInHandle(m_ExposedObject, (OBJECTREF) attempt);

            // Increase the external ref count. We can't call IncExternalCount because we
            // already hold the thread lock and IncExternalCount won't be able to take it.
            m_ExternalRefCount++;

            // Check to see if we need to store a strong pointer to the object.
            if (m_ExternalRefCount > 1)
                StoreObjectInHandle(m_StrongHndToExposedObject, (OBJECTREF) attempt);

            EE_TRY_FOR_FINALLY
            {
                // The exposed object keeps us alive until it is GC'ed.  This
                // doesn't mean the physical thread continues to run, of course.
                attempt->SetInternal(this);

                // Note that we are NOT calling the constructor on the Thread.  That's
                // because this is an internal create where we don't want a Start
                // address.  And we don't want to expose such a constructor for our
                // customers to accidentally call.  The following is in lieu of a true
                // constructor:
                attempt->InitExisting();
            }
            EE_FINALLY
            {
                if (GOT_EXCEPTION()) {
                    // Set both the weak and the strong handle's to NULL.
                    StoreObjectInHandle(m_ExposedObject, NULL);
                    StoreObjectInHandle(m_StrongHndToExposedObject, NULL);
                }
                // Now that we have stored the object in the handle we can release the lock.

                if (fNeedThreadStore)
                    ThreadStore::UnlockThreadStore();
            } EE_END_FINALLY;
        }
        else if (fNeedThreadStore)
            ThreadStore::UnlockThreadStore();

        GCPROTECT_END();
    }
    return ObjectFromHandle(m_ExposedObject);
}


// We only set non NULL exposed objects for unstarted threads that haven't exited 
// their constructor yet.  So there are no race conditions.
void Thread::SetExposedObject(OBJECTREF exposed)
{
    if (exposed != NULL)
    {
        _ASSERTE(IsUnstarted());
        _ASSERTE(ObjectFromHandle(m_ExposedObject) == NULL);
        // The exposed object keeps us alive until it is GC'ed.  This doesn't mean the
        // physical thread continues to run, of course.
        StoreObjectInHandle(m_ExposedObject, exposed);
        // This makes sure the contexts on the backing thread
        // and the managed thread start off in sync with each other.
        _ASSERTE(m_Context);
        ((THREADBASEREF)exposed)->SetExposedContext(m_Context->GetExposedObjectRaw());
        // BEWARE: the IncExternalCount call below may cause GC to happen.

        IncExternalCount();
    }
    else
    {
        // Simply set both of the handles to NULL. The GC of the old exposed thread
        // object will take care of decrementing the external ref count.
        StoreObjectInHandle(m_ExposedObject, NULL);
        StoreObjectInHandle(m_StrongHndToExposedObject, NULL);
    }
}


void Thread::SetLastThrownObject(OBJECTREF throwable) {

     if (m_LastThrownObjectHandle != NULL)
         DestroyHandle(m_LastThrownObjectHandle);

     if (throwable == NULL)
         m_LastThrownObjectHandle = NULL;
     else
     {
         _ASSERTE(this == GetThread());
         m_LastThrownObjectHandle = GetDomain()->CreateHandle(throwable);
     }
}


BOOL Thread::IsAtProcessExit()
{
    return ((g_pThreadStore->m_StoreState & ThreadStore::TSS_ShuttingDown) != 0);
}


// returns 0 if the thread is already marked to be aborted.
// else returns the new value of m_PendingExceptions
BOOL Thread::MarkThreadForAbort()
{

    size_t initialValue = m_State;
    size_t newValue;

    while (true)
    {
        if (initialValue & TS_AbortRequested)   // thread already marked for abort by someone else
            return FALSE;

        newValue = (initialValue | TS_AbortRequested);
        
        size_t oldValue = (size_t) FastInterlockCompareExchange((LPVOID*) &m_State,
                                         (LPVOID) newValue,
                                         (LPVOID) initialValue);
        if (initialValue  == oldValue)                              // exchange succeeded
            return TRUE;    
        else
            initialValue = oldValue;
    } 
}

void Thread::UserAbort(THREADBASEREF orThreadBase)
{
#ifdef _X86_
    THROWSCOMPLUSEXCEPTION();

    // We must set this before we start flipping thread bits to avoid races where
    // trap returning threads is already high due to other reasons.

    ThreadStore::TrapReturningThreads(TRUE);

    if (!MarkThreadForAbort()) { // the thread was already marked to be aborted
        ThreadStore::TrapReturningThreads(FALSE);
        return;
    }

    GCPROTECT_BEGIN(orThreadBase) {

    // else we are the first one to abort and there are no pending exceptions 
    if (this == GetThread())
    {
        SetAbortInitiated();
        // TrapReturningThreads will be decremented when the exception leaves managed code.
        COMPlusThrow(kThreadAbortException);
    }


    _ASSERTE(this != GetThread());      // Aborting another thread.
    FastInterlockOr((ULONG *) &m_State, TS_StopRequested);

#ifdef _DEBUG
    DWORD elapsed_time = 0;
#endif

    for (;;) {

        // Lock the thread store
        LOG((LF_SYNC, INFO3, "UserAbort obtain lock\n"));
        ThreadStore::LockThreadStore();     // GC can occur here.

        // Get the thread handle.
        HANDLE hThread = GetThreadHandle();

        if (hThread == INVALID_HANDLE_VALUE) {

            // Take a lock, and get the handle again.  This lock is necessary to syncronize 
            // with the startup code.
            orThreadBase->EnterObjMonitor();
            hThread = GetThreadHandle();
            DWORD state = m_State;
            orThreadBase->LeaveObjMonitor();

            // Could be unstarted, in which case, we just leave.
            if (hThread == INVALID_HANDLE_VALUE) {
                if (state & TS_Unstarted) {
                    // This thread is not yet started.  Leave the thread marked for abort, reset
                    // the trap returning count, and leave.
                    _ASSERTE(state & TS_AbortRequested);
                    ThreadStore::TrapReturningThreads(FALSE);
                    break;
                } else {
                    // Must be dead, or about to die.
                    if (state & TS_AbortRequested)
                        ThreadStore::TrapReturningThreads(FALSE);
                    break;
                }
            }
        }

        // Win32 suspend the thread, so it isn't moving under us.
        DWORD oldSuspendCount = ::SuspendThread(hThread);   // returns -1 on failure.

        _ASSERTE(oldSuspendCount != -1);

        // What if someone else has this thread suspended already?   It'll depend where the
        // thread got suspended.
        //
        // User Suspend:
        //     We'll just set the abort bit and hope for the best on the resume.
        //
        // GC Suspend:
        //    If it's suspended in jitted code, we'll hijack the IP.  [@TODO: Consider race
        //    w/ GC suspension].
        //    If it's suspended but not in jitted code, we'll get suspended for GC, the GC
        //    will complete, and then we'll abort the target thread.
        //

        // It's possible that the thread has completed the abort already.
        //
        if (!(m_State & TS_AbortRequested)) {
            ::ResumeThread(hThread);
            break;
        }

        _ASSERTE(m_State & TS_AbortRequested);

        // If a thread is Dead or Detached, abort is a NOP.
        //
        if (m_State & (TS_Dead | TS_Detached)) {
            ThreadStore::TrapReturningThreads(FALSE);
            ::ResumeThread(hThread);
            break;
        }

        // It's possible that some stub notices the AbortRequested bit -- even though we 
        // haven't done any real magic yet.  If the thread has already started it's abort, we're 
        // done.
        //
        // Two more cases can be folded in here as well.  If the thread is unstarted, it'll
        // abort when we start it.
        //
        // If the thread is user suspended (SyncSuspended) -- we're out of luck.  Set the bit and 
        // hope for the best on resume. 
        // 
        if (m_State & (TS_AbortInitiated | TS_Unstarted)) {
            _ASSERTE(m_State & TS_AbortRequested);
            ::ResumeThread(hThread);
            break;
        }

        if (m_State & TS_SyncSuspended) {
            ThreadStore::TrapReturningThreads(FALSE);
            ThreadStore::UnlockThreadStore();
            COMPlusThrow(kThreadStateException, IDS_EE_THREAD_ABORT_WHILE_SUSPEND);
            _ASSERTE(0); // NOT REACHED
        }

        // If the thread has no managed code on it's call stack, abort is a NOP.  We're about
        // to touch the unmanaged thread's stack -- for this to be safe, we can't be 
        // Dead/Detached/Unstarted.
        //
        _ASSERTE(!(m_State & (  TS_Dead 
                              | TS_Detached 
                              | TS_Unstarted 
                              | TS_AbortInitiated))); 

        if (    m_pFrame == FRAME_TOP 
            && GetFirstCOMPlusSEHRecord(this) == (LPVOID) -1) {
            FastInterlockAnd((ULONG *)&m_State, 
                             ((~TS_AbortRequested) & (~TS_AbortInitiated) & (~TS_StopRequested)));
            ThreadStore::TrapReturningThreads(FALSE);
            ::ResumeThread(hThread);
            break;
        }

        // If an exception is currently being thrown, one of two things will happen.  Either, we'll
        // catch, and notice the abort request in our end-catch, or we'll not catch [in which case
        // we're leaving managed code anyway.  The top-most handler is responsible for resetting
        // the bit.
        //
        if (GetThrowable() != NULL) {
            ::ResumeThread(hThread);
            break;
        }

        // If the thread is in sleep, wait, or join interrupt it
        // However, we do NOT want to interrupt if the thread is already processing an exception
        if (m_State & TS_Interruptible) {
            UserInterrupt();        // if the user wakes up because of this, it will read the 
                                    // abort requested bit and initiate the abort
            ::ResumeThread(hThread);
            break;


        } else if (m_fPreemptiveGCDisabled) {
            // If the thread is suspended inside jitted code, we can use ResumeUnderControl to
            // force the abort.
            CONTEXT ctx;
            ctx.ContextFlags = CONTEXT_CONTROL;
            BOOL success = EEGetThreadContext(this, &ctx);
            _ASSERTE((success || RunningOnWin95()) && "Thread::UserAbort : Failed to get thread context");
            if (success) {
                ICodeManager *pMgr = ExecutionManager::FindCodeMan((SLOT)GetIP(&ctx));
                if (pMgr) {
                    ResumeUnderControl();
                    break;
                }
            } else {
                // Resume the thread and try again from the beginning, we should
                // eventually get a good thread context.
                ::ResumeThread(hThread);
                ThreadStore::UnlockThreadStore();
                continue;
            }
        } else {
            _ASSERTE(!m_fPreemptiveGCDisabled);
            if (   m_pFrame != FRAME_TOP
                && m_pFrame->IsTransitionToNativeFrame()
                && ((size_t) GetFirstCOMPlusSEHRecord(this) > ((size_t) m_pFrame) - 20)
                ) {
                // If the thread is running outside the EE, and is behind a stub that's going
                // to catch...
                ::ResumeThread(hThread);
                break;
            } 
        }

        // Ok.  It's not in managed code, nor safely out behind a stub that's going to catch
        // it on the way in.  We have to poll.

        ::ResumeThread(hThread);
        ThreadStore::UnlockThreadStore();

        // Don't do a Sleep.  It's possible that the thread we are trying to abort is
        // stuck in unmanaged code trying to get into the apartment that we are supposed
        // to be pumping!  Instead, ping the current thread's handle.  Obviously this
        // will time out, but it will pump if we need it to.
        // ::Sleep(ABORT_POLL_TIMEOUT);
        {
            Thread *pCurThread = GetThread();  // not the thread we are aborting!
            HANDLE  h = pCurThread->GetThreadHandle();
            pCurThread->DoAppropriateWait(1, &h, FALSE, ABORT_POLL_TIMEOUT, TRUE, NULL);
        }



#ifdef _DEBUG
        elapsed_time += ABORT_POLL_TIMEOUT;
        _ASSERTE(elapsed_time < ABORT_FAIL_TIMEOUT);
#endif

    } // for(;;)

    } GCPROTECT_END(); // orThreadBase

    _ASSERTE(ThreadStore::HoldingThreadStore());
    ThreadStore::UnlockThreadStore();

#elif defined(CHECK_PLATFORM_BUILD)
    #error "Platform NYI"
#else
    _ASSERTE(!"Platform NYI");
#endif
}


void Thread::UserResetAbort()
{
    _ASSERTE(this == GetThread());
    _ASSERTE(IsAbortRequested());
    _ASSERTE(!IsDead());

    ThreadStore::TrapReturningThreads(FALSE);
    FastInterlockAnd((ULONG *)&m_State, ((~TS_AbortRequested) & (~TS_AbortInitiated) & (~TS_StopRequested)));
    GetHandlerInfo()->ResetIsInUnmanagedHandler();
}


// The debugger needs to be able to perform a UserStop on a runtime
// thread. Since this will only ever happen from the helper thread, we
// can't call the normal UserStop, since that can throw a COM+
// exception. This is a minor variant on UserStop that does the same
// thing.
//
// See the notes in UserStop() above for more details on what this is
// doing.
void Thread::UserStopForDebugger()
{
    // Note: this can only happen from the debugger helper thread.
    _ASSERTE(dbgOnly_IsSpecialEEThread());
    
    UserSuspendThread();
    FastInterlockOr((ULONG *) &m_State, TS_StopRequested);
    UserResumeThread();
}

// No longer attempt to Stop this thread.
void Thread::ResetStopRequest()
{
    FastInterlockAnd((ULONG *) &m_State, ~TS_StopRequested);
}

// Throw a thread stop request when a suspended thread is resumed. Make sure you know what you
// are doing when you call this routine.
void Thread::SetStopRequest()
{
    FastInterlockOr((ULONG *) &m_State, TS_StopRequested);
}

// Throw a thread abort request when a suspended thread is resumed. Make sure you know what you
// are doing when you call this routine.
void Thread::SetAbortRequest()
{
    MarkThreadForAbort();
    SetStopRequest();

    // @TODO: We need to reconsider this for V.next (where we have a Postponed
    // Raid entry).  In V1, this is the most expedient way to deal with
    // threads in managed blocking operations that would otherwise prevent
    // an Unload.  The unfortunate side effect is that, after we abort a thread, it
    // may later interrupt itself out of a blocking operation.
    if (m_State & TS_Interruptible)
        UserInterrupt();

    ThreadStore::TrapReturningThreads(TRUE);
}

// Background threads must be counted, because the EE should shut down when the
// last non-background thread terminates.  But we only count running ones.
void Thread::SetBackground(BOOL isBack)
{
    // booleanize IsBackground() which just returns bits
    if (isBack == !!IsBackground())
        return;

    LOG((LF_SYNC, INFO3, "SetBackground obtain lock\n"));
    ThreadStore::LockThreadStore();

    if (IsDead())
    {
        // This can only happen in a race condition, where the correct thing to do
        // is ignore it.  If it happens without the race condition, we throw an
        // exception.
    }
    else
    if (isBack)
    {
        if (!IsBackground())
        {
            FastInterlockOr((ULONG *) &m_State, TS_Background);

            // unstarted threads don't contribute to the background count
            if (!IsUnstarted())
                g_pThreadStore->m_BackgroundThreadCount++;

            // If we put the main thread into a wait, until only background threads exist,
            // then we make that
            // main thread a background thread.  This cleanly handles the case where it
            // may or may not be one as it enters the wait.

            // One of the components of OtherThreadsComplete() has changed, so check whether
            // we should now exit the EE.
            ThreadStore::CheckForEEShutdown();
        }
    }
    else
    {
        if (IsBackground())
        {
            FastInterlockAnd((ULONG *) &m_State, ~TS_Background);

            // unstarted threads don't contribute to the background count
            if (!IsUnstarted())
                g_pThreadStore->m_BackgroundThreadCount--;

            _ASSERTE(g_pThreadStore->m_BackgroundThreadCount >= 0);
            _ASSERTE(g_pThreadStore->m_BackgroundThreadCount <= g_pThreadStore->m_ThreadCount);
        }
    }

    ThreadStore::UnlockThreadStore();
}

// Retrieve the apartment state of the current thread. There are three possible
// states: thread hosts an STA, thread is part of the MTA or thread state is
// undecided. The last state may indicate that the apartment has not been set at
// all (nobody has called CoInitializeEx) or that the EE does not know the
// current state (EE has not called CoInitializeEx).
Thread::ApartmentState Thread::GetApartment()
{
    _ASSERTE(!((m_State & TS_InSTA) && (m_State & TS_InMTA)));

    ApartmentState as = (m_State & TS_InSTA) ? AS_InSTA :
                        (m_State & TS_InMTA) ? AS_InMTA :
                        AS_Unknown;    

    if (RunningOnWinNT5() && m_ThreadId == ::GetCurrentThreadId())
    {
#ifdef CUSTOMER_CHECKED_BUILD
        CustomerDebugHelper *pCdh = NULL;

        // Without notifications from OLE32, we cannot know when the apartment state of a
        // thread changes.  But we have cached this fact and depend on it for all our
        // blocking and COM Interop behavior to work correctly.  Assert that it is not
        // changing underneath us, on those platforms where it is relatively cheap for
        // us to do so.
        if (as != AS_Unknown)
        {
            THDTYPE tempType;
            HRESULT hr = GetCurrentThreadTypeNT5(&tempType);
            if (hr == S_OK)
            {
                if (tempType == THDTYPE_PROCESSMESSAGES && as == AS_InMTA)
                {
                    pCdh = CustomerDebugHelper::GetCustomerDebugHelper();
                    if (pCdh->IsProbeEnabled(CustomerCheckedBuildProbe_Apartment))
                        CCBApartmentProbeOutput(pCdh, m_ThreadId, as, FALSE);
                }
                else if (tempType == THDTYPE_BLOCKMESSAGES && as == AS_InSTA)
                {
                    pCdh = CustomerDebugHelper::GetCustomerDebugHelper();
                    if (pCdh->IsProbeEnabled(CustomerCheckedBuildProbe_Apartment))
                        CCBApartmentProbeOutput(pCdh, m_ThreadId, as, FALSE);
                }
            }
        }
#endif  // CUSTOMER_CHECKED_BUILD

        if (as == AS_Unknown)
        {
            THDTYPE type;
            HRESULT hr = GetCurrentThreadTypeNT5(&type);
            if (hr == S_OK)
            {
                as = (type == THDTYPE_PROCESSMESSAGES)  ? AS_InSTA : AS_InMTA;
            }        
            if (as == AS_InSTA)
            {
#ifdef CUSTOMER_CHECKED_BUILD
                if (!g_fEEShutDown && !(m_State & TS_InSTA || m_State & TS_InMTA))
                {
                    if (pCdh == NULL)
                        pCdh = CustomerDebugHelper::GetCustomerDebugHelper();

                    if (pCdh->IsProbeEnabled(CustomerCheckedBuildProbe_Apartment))
                    {
                        CQuickArray<WCHAR>  strMsg;
                        CQuickArray<WCHAR>  strTmp;

                        static WCHAR        szTemplateMsg[]     = {L"Runtime is initializing %s to STA."};
                        static WCHAR        szStartedThread[]   = {L"uninitialized thread (0x%lx)"};
                        static WCHAR        szUnstartedThread[] = {L"unstarted thread"};

                        if (m_ThreadId != 0)
                        {
                            strTmp.Alloc(lengthof(szStartedThread) + MAX_UINT32_HEX_CHAR_LEN);
                            Wszwsprintf(strTmp.Ptr(), szStartedThread, m_ThreadId);
                        }
                        else
                        {
                            strTmp.Alloc(lengthof(szUnstartedThread));
                            Wszwsprintf(strTmp.Ptr(), szUnstartedThread);
                        }

                        strMsg.Alloc(lengthof(szTemplateMsg) + strTmp.Size());
                        Wszwsprintf(strMsg.Ptr(), szTemplateMsg, strTmp.Ptr());
                        pCdh->LogInfo(strMsg.Ptr(), CustomerCheckedBuildProbe_Apartment);
                    }
                }
#endif // CUSTOMER_CHECKED_BUILD

                FastInterlockOr((ULONG *) &m_State, TS_InSTA);
            }
        }      
    }
    return as;
}

Thread::ApartmentState Thread::GetFinalApartment()
{

    _ASSERTE(this == GetThread());
        
    ApartmentState as = AS_Unknown;
    if (g_fEEShutDown)
    {
        // On shutdown, do not use cached value.  Someone might have called
        // CoUnitialize.
        FastInterlockAnd ((ULONG *) &m_State, ~TS_InSTA & ~TS_InMTA);
    }

    as = GetApartment();
    if (as == AS_Unknown)
    {
        if (RunningOnWinNT5())
        {
            // If we are running on Win2k and above, then GetApartment will only return
            // AS_Unknown if CoInitialize hasn't been called on the current thread.
            // In that case we can simply assume MTA. However we cannot cache this
            // value in the Thread because if a CoInitialize does occur, then the
            // thread state might change.
            as = AS_InMTA;
        }
        else
        {
            // Try CoInitializing to see if somebody has already done 
            // a CoInitialize, if nobody else has done it, let us
            // remove our CoInitialize and assume MTA for now.            
            HRESULT hr = ::CoInitializeEx(NULL, COINIT_MULTITHREADED);
            if (SUCCEEDED(hr)) 
            {
                    // get rid of the CoInitialize we did
                    ::CoUninitialize();
                    as = AS_InMTA;
            }
            else
            {
                    // We didn't manage to enforce the requested apartment state, but at least
                    // we can work out what the state is now.  No need to actually do the CoInit --
                    // obviously someone else already took care of that.
                    _ASSERTE(hr == RPC_E_CHANGED_MODE);
                    if (hr == RPC_E_CHANGED_MODE)
                            FastInterlockOr((ULONG *) &m_State, TS_InSTA);
                    as = AS_InSTA;
            }        
        }
    }
    return as;

}

// when we get apartment tear-down notification,
// we want reset the apartment state we cache on the thread
VOID Thread::ResetApartment()
{
    // reset the TS_InSTA bit and TS_InMTA bit
    ThreadState t_State = (ThreadState)(~(TS_InSTA | TS_InMTA));
    FastInterlockAnd((ULONG *) &m_State, t_State);
}

// Attempt to set current thread's apartment state. The actual apartment state
// achieved is returned and may differ from the input state if someone managed
// to call CoInitializeEx on this thread first (note that calls to SetApartment
// made before the thread has started are guaranteed to succeed).
// Note that even if we fail to set the requested state, we will still addref
// COM by calling CoInitializeEx again with the other state.
Thread::ApartmentState Thread::SetApartment(ApartmentState state)
{
    // reset any bits that request for CoInitialize
    ResetRequiresCoInitialize();

    // Allow state to be set to AS_Unknown (really just an explicit way of
    // saying that neither the STA or MTA model is preferred).
    if (state == AS_Unknown)
        return GetApartment();

    _ASSERTE((state == AS_InSTA) || (state == AS_InMTA));

    // Don't attempt to call CoInitializeEx if we've already done so.
    if (m_State & TS_CoInitialized)
        return GetApartment();

    // Reject attempts to change the state after it's set.
    if (((m_State & TS_InSTA) && (state == AS_InMTA)) ||
        ((m_State & TS_InMTA) && (state == AS_InSTA)))
    {
#ifdef CUSTOMER_CHECKED_BUILD
        CustomerDebugHelper *pCdh = CustomerDebugHelper::GetCustomerDebugHelper();

        if (pCdh->IsProbeEnabled(CustomerCheckedBuildProbe_Apartment))
            CCBApartmentProbeOutput(pCdh, m_ThreadId, state, TRUE);
#endif // CUSTOMER_CHECKED_BUILD

        return GetApartment();
    }

    // If the thread isn't even started yet, we mark the state bits without
    // calling CoInitializeEx (since we're obviously not in the correct thread
    // context yet). We'll retry this call when the thread is started.
    // Don't use the TS_Unstarted state bit to check for this, it's cleared far
    // too late in the day for us. Instead check whether we're in the correct
    // thread context.
    if (m_ThreadId != ::GetCurrentThreadId()) {
        FastInterlockOr((ULONG *) &m_State, (state == AS_InSTA) ?
                        TS_InSTA : TS_InMTA);
        return state;
    }

    // Attempt to set apartment by calling CoInitializeEx. This may fail if
    // another caller (outside EE) beat us to it.
    HRESULT hr = ::CoInitializeEx(NULL, (state == AS_InSTA) ?
                                  COINIT_APARTMENTTHREADED :
                                  COINIT_MULTITHREADED);
    if (SUCCEEDED(hr)) {
        FastInterlockOr((ULONG *) &m_State, TS_CoInitialized |
                        ((state == AS_InSTA) ? TS_InSTA : TS_InMTA));
        return GetApartment();
    }

    // We didn't manage to enforce the requested apartment state, but at least
    // we can work out what the state is now.  No need to actually do the CoInit --
    // obviously someone else already took care of that.
    _ASSERTE(hr == RPC_E_CHANGED_MODE);
    if (hr == RPC_E_CHANGED_MODE)
    {
        FastInterlockOr((ULONG *) &m_State, ((state == AS_InSTA) ? TS_InMTA : TS_InSTA));

#ifdef CUSTOMER_CHECKED_BUILD
        CustomerDebugHelper *pCdh = CustomerDebugHelper::GetCustomerDebugHelper();

        if (pCdh->IsProbeEnabled(CustomerCheckedBuildProbe_Apartment))
            CCBApartmentProbeOutput(pCdh, m_ThreadId, state, TRUE);
#endif // CUSTOMER_CHECKED_BUILD
    }

    return GetApartment();
}


// When the thread starts running, make sure it is running in the correct apartment
// and context.
BOOL Thread::PrepareApartmentAndContext()
{
    // Be very careful in here because we haven't set up e.g. TLS yet.

    ApartmentState aState;

    m_ThreadId = ::GetCurrentThreadId();

    // The thread may have been marked to run in an apartment.
    if (m_State & TS_InSTA) {
        aState = SetApartment(AS_InSTA);
        _ASSERTE(aState == AS_InSTA);
    } else if (m_State & TS_InMTA) {
        aState = SetApartment(AS_InMTA);
        _ASSERTE(aState == AS_InMTA);
    }

    // In the case where we own the thread and we have switched it to a different
    // starting context, it is the responsibility of the caller (KickOffThread())
    // to notice that the context changed, and to adjust the delegate that it will
    // dispatch on, as appropriate.
    return TRUE;
}


// THE FOLLOWING SERVICES HAVE NOT BEEN IMPLEMENTED YET.
Thread *Thread::CreateNewApartment()
{
    // @TODO context cwb: NYI!
    _ASSERTE(!"NYI: CreateNewApartment()");
    return 0;
}
Thread *Thread::GetCommunalApartment()
{
    // @TODO context cwb: NYI!
    _ASSERTE(!"NYI: GetCommunalApartment()");
    return 0;
}
void Thread::PumpApartment()
{
    // @TODO context cwb: NYI!
    _ASSERTE(!"NYI: PumpApartment()");
}


//----------------------------------------------------------------------------
//
//    ThreadStore Implementation
//
//----------------------------------------------------------------------------

ThreadStore::ThreadStore()
           : m_Crst("ThreadStore", CrstThreadStore),
             m_HashCrst("ThreadDLStore", CrstThreadDomainLocalStore),
             m_ThreadCount(0),
             m_UnstartedThreadCount(0),
             m_BackgroundThreadCount(0),
             m_DeadThreadCount(0),
             m_PendingThreadCount(0),
             m_HoldingThread(0),
             m_StoreState(TSS_Normal),
             m_GuidCreated(FALSE),
             m_holderthreadid(NULL),
             m_dwIncarnation(0)
{
    m_TerminationEvent = ::WszCreateEvent(NULL, TRUE, FALSE, NULL);
    _ASSERTE(m_TerminationEvent != INVALID_HANDLE_VALUE);
}


BOOL ThreadStore::InitThreadStore()
{
    g_pThreadStore = new ThreadStore;

    g_pThinLockThreadIdDispenser = new IdDispenser();

    BOOL fInited = ((g_pThreadStore != NULL) && 
                    (g_pThinLockThreadIdDispenser != NULL) &&
                    (g_pThreadStore->m_TerminationEvent != NULL));
    
    return fInited;
}


#ifdef SHOULD_WE_CLEANUP
void ThreadStore::ReleaseExposedThreadObjects()
{
    Thread *prev;
    Thread *next;

    LOG((LF_SYNC, INFO3, "ReleaseExposedThreadObjects Locking thread store\n"));
    g_pThreadStore->Enter();                                            // Doesn't enable Preemptive GC
        g_pThreadStore->m_HoldingThread = GetThread();  
    LOG((LF_SYNC, INFO3, "ReleaseExposedThreadObjects Locked thread store\n"));

    for (prev = GetAllThreadList(NULL, 0, 0); prev; prev = next)
    {
        next = GetAllThreadList(prev, 0, 0);        // Before 'prev' goes away
        prev->SetExposedObject(NULL);
        prev->ClearContext();
    }

    LOG((LF_SYNC, INFO3, "ReleaseExposedThreadObjects Unlocking thread store\n"));
        g_pThreadStore->m_HoldingThread = NULL;
    g_pThreadStore->Leave();
    LOG((LF_SYNC, INFO3, "ReleaseExposedThreadObjects Unlocked thread store\n"));
}
#endif /* SHOULD_WE_CLEANUP */


#ifdef SHOULD_WE_CLEANUP
void ThreadStore::TerminateThreadStore()
{    
    if (g_pThreadStore)
    {
        g_pThreadStore->Shutdown();
        delete g_pThreadStore;
        g_pThreadStore = NULL;
    }
}
#endif /* SHOULD_WE_CLEANUP */


#ifdef SHOULD_WE_CLEANUP
void ThreadStore::Shutdown()
{
    Thread      *prev, *next;
    Thread      *hold = NULL;
    Thread      *pCurThread = GetThread();

    LOG((LF_SYNC, INFO3, "Shutdown Locking thread store\n"));
    Enter();                                                                            // Doesn't enable Preemptive GC
        g_pThreadStore->m_HoldingThread = pCurThread;
    LOG((LF_SYNC, INFO3, "Shutdown Locked thread store\n"));

    m_StoreState = TSS_ShuttingDown;

    for (prev = GetAllThreadList(NULL, 0, 0); prev; prev = next)
    {
        next = GetAllThreadList(prev, 0, 0);        // before 'prev' goes away

        // save the currently executing thread for last
        if (prev == pCurThread)
            hold = prev;
        else
            prev->OnThreadTerminate(TRUE);
    }

    if (hold)
        hold->OnThreadTerminate(TRUE);

    if (s_hAbortEvtCache != NULL)
    {
        CloseHandle(s_hAbortEvtCache);
        s_hAbortEvtCache = NULL;
        s_hAbortEvt = NULL;
    }

    LOG((LF_SYNC, INFO3, "Shutdown Unlocking thread store\n"));
    g_pThreadStore->m_HoldingThread = NULL;
    Leave();
    LOG((LF_SYNC, INFO3, "Shutdown Unlocked thread store\n"));

    delete g_pThinLockThreadIdDispenser;
}
#endif /* SHOULD_WE_CLEANUP */

void ThreadStore::LockThreadStore(GCHeap::SUSPEND_REASON reason,
                                  BOOL threadCleanupAllowed)
{
    // There's a nasty problem here.  Once we start shutting down because of a
    // process detach notification, threads are disappearing from under us.  There
    // are a surprising number of cases where the dying thread holds the ThreadStore
    // lock.  For example, the finalizer thread holds this during startup in about
    // 10 of our COM BVTs.
    if (!g_fProcessDetach)
    {
        Thread *pCurThread = GetThread();
        // During ShutDown, the shutdown thread suspends EE. Then it pretends that
        // FinalizerThread is the one to suspend EE.
        // We should allow Finalizer thread to grab ThreadStore lock.
        if (g_fFinalizerRunOnShutDown
            && pCurThread == g_pGCHeap->GetFinalizerThread()) {
            return;
        }
        BOOL gcOnTransitions = GC_ON_TRANSITIONS(FALSE);                // dont do GC for GCStress 3
        BOOL toggleGC = (   pCurThread != NULL 
                         && pCurThread->PreemptiveGCDisabled()
                         && reason != GCHeap::SUSPEND_FOR_GC);

        // Note: there is logic in gc.cpp surrounding suspending all
        // runtime threads for a GC that depends on the fact that we
        // do an EnablePreemptiveGC and a DisablePreemptiveGC around
        // taking this lock.
        if (toggleGC)
            pCurThread->EnablePreemptiveGC();

        LOG((LF_SYNC, INFO3, "Locking thread store\n"));

        // Any thread that holds the thread store lock cannot be stopped by unmanaged breakpoints and exceptions when
        // we're doing managed/unmanaged debugging. Calling SetDebugCantStop(true) on the current thread helps us
        // remember that.
        if (pCurThread)
            pCurThread->SetDebugCantStop(true);

        // This is used to avoid thread starvation if non-GC threads are competing for
        // the thread store lock when there is a real GC-thread waiting to get in.
        // This is initialized lazily when the first non-GC thread backs out because of
        // a waiting GC thread.
        if (s_hAbortEvt != NULL &&
            !(reason == GCHeap::SUSPEND_FOR_GC || reason == GCHeap::SUSPEND_FOR_GC_PREP) &&
            g_pGCHeap->GetGCThreadAttemptingSuspend() != NULL &&
            g_pGCHeap->GetGCThreadAttemptingSuspend() != pCurThread)
        {
            HANDLE hAbortEvt = s_hAbortEvt;

            if (hAbortEvt != NULL)
            {
                LOG((LF_SYNC, INFO3, "Performing suspend abort wait.\n"));
                WaitForSingleObject(hAbortEvt, INFINITE);
                LOG((LF_SYNC, INFO3, "Release from suspend abort wait.\n"));
            }
        }
    
        g_pThreadStore->Enter();

        _ASSERTE(g_pThreadStore->m_holderthreadid == 0);
        g_pThreadStore->m_holderthreadid = ::GetCurrentThreadId();
        
        LOG((LF_SYNC, INFO3, "Locked thread store\n"));

        // Established after we obtain the lock, so only useful for synchronous tests.
        // A thread attempting to suspend us asynchronously already holds this lock.
        g_pThreadStore->m_HoldingThread = pCurThread;

        if (toggleGC)
            pCurThread->DisablePreemptiveGC();

        GC_ON_TRANSITIONS(gcOnTransitions);

        //
        // See if there are any detached threads which need cleanup. Only do this on
        // real EE threads.
        //

        if (Thread::m_DetachCount && threadCleanupAllowed && GetThread() != NULL)
            Thread::CleanupDetachedThreads(reason);
    }
#ifdef _DEBUG
    else
        LOG((LF_SYNC, INFO3, "Locking thread store skipped upon detach\n"));
#endif
}

    
void ThreadStore::UnlockThreadStore()
{
    // There's a nasty problem here.  Once we start shutting down because of a
    // process detach notification, threads are disappearing from under us.  There
    // are a surprising number of cases where the dying thread holds the ThreadStore
    // lock.  For example, the finalizer thread holds this during startup in about
    // 10 of our COM BVTs.
    if (!g_fProcessDetach)
    {
        Thread *pCurThread = GetThread();
        // During ShutDown, the shutdown thread suspends EE. Then it pretends that
        // FinalizerThread is the one to suspend EE.
        // We should allow Finalizer thread to grab ThreadStore lock.
        if (g_fFinalizerRunOnShutDown
            && pCurThread == g_pGCHeap->GetFinalizerThread ()) {
            return;
        }
        LOG((LF_SYNC, INFO3, "Unlocking thread store\n"));
        _ASSERTE(GetThread() == NULL || g_pThreadStore->m_HoldingThread == GetThread());

        g_pThreadStore->m_HoldingThread = NULL;
        g_pThreadStore->m_holderthreadid = 0;
        g_pThreadStore->Leave();

        // We're out of the critical area for managed/unmanaged debugging.
        if (pCurThread)
            pCurThread->SetDebugCantStop(false);
    }
#ifdef _DEBUG
    else
        LOG((LF_SYNC, INFO3, "Unlocking thread store skipped upon detach\n"));
#endif
}


void ThreadStore::LockDLSHash()
{
    if (!g_fProcessDetach)
    {
        LOG((LF_SYNC, INFO3, "Locking thread DLS hash\n"));
        g_pThreadStore->EnterDLSHashLock();
    }
#ifdef _DEBUG
    else
        LOG((LF_SYNC, INFO3, "Locking thread DLS hash skipped upon detach\n"));
#endif
}

void ThreadStore::UnlockDLSHash()
{
    if (!g_fProcessDetach)
    {
        LOG((LF_SYNC, INFO3, "Unlocking thread DLS hash\n"));
        g_pThreadStore->LeaveDLSHashLock();
    }

#ifdef _DEBUG
    else
        LOG((LF_SYNC, INFO3, "Unlocking thread DLS hash skipped upon detach\n"));
#endif
}

// AddThread adds 'newThread' to m_ThreadList
void ThreadStore::AddThread(Thread *newThread)
{
    LOG((LF_SYNC, INFO3, "AddThread obtain lock\n"));

    LockThreadStore();

    g_pThreadStore->m_ThreadList.InsertTail(newThread);
    g_pThreadStore->m_ThreadCount++;
    if (newThread->IsUnstarted())
        g_pThreadStore->m_UnstartedThreadCount++;

    _ASSERTE(!newThread->IsBackground());
    _ASSERTE(!newThread->IsDead());

    g_pThreadStore->m_dwIncarnation++;

    UnlockThreadStore();
}


// Whenever one of the components of OtherThreadsComplete() has changed in the
// correct direction, see whether we can now shutdown the EE because only background
// threads are running.
void ThreadStore::CheckForEEShutdown()
{
    if (g_fWeControlLifetime && g_pThreadStore->OtherThreadsComplete())
    {
#ifdef _DEBUG
        BOOL bRet =
#endif
        ::SetEvent(g_pThreadStore->m_TerminationEvent);
        _ASSERTE(bRet);
    }
}


BOOL ThreadStore::RemoveThread(Thread *target)
{
    BOOL    found;
    Thread *ret;

    _ASSERTE(g_pThreadStore->m_Crst.GetEnterCount() > 0 || g_fProcessDetach);
    _ASSERTE(g_pThreadStore->DbgFindThread(target));
    ret = g_pThreadStore->m_ThreadList.FindAndRemove(target);
    _ASSERTE(ret && ret == target);
    found = (ret != NULL);

    if (found)
    {
        g_pThreadStore->m_ThreadCount--;

        if (target->IsDead())
            g_pThreadStore->m_DeadThreadCount--;

        // Unstarted threads are not in the Background count:
        if (target->IsUnstarted())
            g_pThreadStore->m_UnstartedThreadCount--;
        else
        if (target->IsBackground())
            g_pThreadStore->m_BackgroundThreadCount--;


        _ASSERTE(g_pThreadStore->m_ThreadCount >= 0);
        _ASSERTE(g_pThreadStore->m_BackgroundThreadCount >= 0);
        _ASSERTE(g_pThreadStore->m_ThreadCount >= g_pThreadStore->m_BackgroundThreadCount);
        _ASSERTE(g_pThreadStore->m_ThreadCount >= g_pThreadStore->m_UnstartedThreadCount);
        _ASSERTE(g_pThreadStore->m_ThreadCount >= g_pThreadStore->m_DeadThreadCount);

        // One of the components of OtherThreadsComplete() has changed, so check whether
        // we should now exit the EE.
        CheckForEEShutdown();

        g_pThreadStore->m_dwIncarnation++;
    }
    return found;
}


// When a thread is created as unstarted.  Later it may get started, in which case
// someone calls Thread::HasStarted() on that physical thread.  This completes
// the Setup and calls here.
void ThreadStore::TransferStartedThread(Thread *thread)
{
    _ASSERTE(GetThread() == NULL);
    TlsSetValue(gThreadTLSIndex, (VOID*)thread);
    TlsSetValue(gAppDomainTLSIndex, (VOID*)thread->m_pDomain);

    LOG((LF_SYNC, INFO3, "TransferUnstartedThread obtain lock\n"));
    LockThreadStore();

    _ASSERTE(g_pThreadStore->DbgFindThread(thread));
    _ASSERTE(thread->GetThreadHandle() != INVALID_HANDLE_VALUE);
    _ASSERTE(thread->m_State & Thread::TS_WeOwn);
    _ASSERTE(thread->IsUnstarted());
    _ASSERTE(!thread->IsDead());

    // Of course, m_ThreadCount is already correct since it includes started and
    // unstarted threads.

    g_pThreadStore->m_UnstartedThreadCount--;

    // We only count background threads that have been started
    if (thread->IsBackground())
        g_pThreadStore->m_BackgroundThreadCount++;

    _ASSERTE(g_pThreadStore->m_PendingThreadCount > 0);
    FastInterlockDecrement(&g_pThreadStore->m_PendingThreadCount);

    // As soon as we erase this bit, the thread becomes eligible for suspension,
    // stopping, interruption, etc.
    FastInterlockAnd((ULONG *) &thread->m_State, ~Thread::TS_Unstarted);
    FastInterlockOr((ULONG *) &thread->m_State, Thread::TS_LegalToJoin);

    // One of the components of OtherThreadsComplete() has changed, so check whether
    // we should now exit the EE.
    CheckForEEShutdown();

    g_pThreadStore->m_dwIncarnation++;

    UnlockThreadStore();
}


// Access the list of threads.  You must be inside a critical section, otherwise
// the "cursor" thread might disappear underneath you.  Pass in NULL for the
// cursor to begin at the start of the list.
Thread *ThreadStore::GetAllThreadList(Thread *cursor, ULONG mask, ULONG bits)
{
    _ASSERTE(g_pThreadStore->m_Crst.GetEnterCount() > 0 || g_fProcessDetach || g_fRelaxTSLRequirement);

    while (TRUE)
    {
        cursor = (cursor
                  ? g_pThreadStore->m_ThreadList.GetNext(cursor)
                  : g_pThreadStore->m_ThreadList.GetHead());

        if (cursor == NULL)
            break;

        if ((cursor->m_State & mask) == bits)
            return cursor;
    }
    return NULL;
}

// Iterate over the threads that have been started
Thread *ThreadStore::GetThreadList(Thread *cursor)
{
    return GetAllThreadList(cursor, (Thread::TS_Unstarted | Thread::TS_Dead), 0);
}


// We shut down the EE only when all the non-background threads have terminated
// (unless this is an exceptional termination).  So the main thread calls here to
// wait before tearing down the EE.
void ThreadStore::WaitForOtherThreads()
{
    CHECK_ONE_STORE();

    Thread      *pCurThread = GetThread();

    // Regardless of whether the main thread is a background thread or not, force
    // it to be one.  This simplifies our rules for counting non-background threads.
    pCurThread->SetBackground(TRUE);

    LOG((LF_SYNC, INFO3, "WaitForOtherThreads obtain lock\n"));
    LockThreadStore();
    if (!OtherThreadsComplete())
    {
        UnlockThreadStore();

        FastInterlockOr((ULONG *) &pCurThread->m_State, Thread::TS_ReportDead);
#ifdef _DEBUG
        DWORD   ret =
#endif
        pCurThread->DoAppropriateWait(1, &m_TerminationEvent, FALSE, INFINITE, TRUE, NULL);
        _ASSERTE(ret == WAIT_OBJECT_0);
    }
    else
        UnlockThreadStore();
}


// Every EE process can lazily create a GUID that uniquely identifies it (for
// purposes of remoting).
const GUID &ThreadStore::GetUniqueEEId()
{
    if (!m_GuidCreated)
    {
        LockThreadStore();
        if (!m_GuidCreated)
        {
            HRESULT hr = ::CoCreateGuid(&m_EEGuid);

            _ASSERTE(SUCCEEDED(hr));
            if (SUCCEEDED(hr))
                m_GuidCreated = TRUE;
        }
        UnlockThreadStore();

        if (!m_GuidCreated)
            return IID_NULL;
    }
    return m_EEGuid;
}


DWORD ThreadStore::GetIncarnation()
{
    return g_pThreadStore->m_dwIncarnation;
}


#ifdef _DEBUG
BOOL ThreadStore::DbgFindThread(Thread *target)
{
    CHECK_ONE_STORE();

    // Clear the poisoned flag for g_TrapReturningThreads.
    g_TrapReturningThreadsPoisoned = false;
    
#if 0 // g_TrapReturningThreads debug code.
        int             iRetry = 0;
Retry:
#endif // g_TrapReturningThreads debug code.
    BOOL    found = FALSE;
    Thread *cur = NULL;
    LONG    cnt = 0;
    LONG    cntBack = 0;
    LONG    cntUnstart = 0;
    LONG    cntDead = 0;
    LONG    cntReturn = 0;

    while ((cur = GetAllThreadList(cur, 0, 0)) != NULL)
    {
        cnt++;

        if (cur->IsDead())
            cntDead++;

        // Unstarted threads do not contribute to the count of background threads
        if (cur->IsUnstarted())
            cntUnstart++;
        else
        if (cur->IsBackground())
            cntBack++;

        if (cur == target)
            found = TRUE;

        // Note that (DebugSuspendPending | SuspendPending) implies a count of 2.
        // We don't count GCPending because a single trap is held for the entire
        // GC, instead of counting each interesting thread.
        if (cur->m_State & Thread::TS_DebugSuspendPending)
            cntReturn++;

        if (cur->m_State & Thread::TS_UserSuspendPending)
            cntReturn++;

        if (cur->m_TraceCallCount > 0)
            cntReturn++;

        if (cur->IsAbortRequested())
            cntReturn++;
    }

    _ASSERTE(cnt == m_ThreadCount);
    _ASSERTE(cntUnstart == m_UnstartedThreadCount);
    _ASSERTE(cntBack == m_BackgroundThreadCount);
    _ASSERTE(cntDead == m_DeadThreadCount);
    _ASSERTE(0 <= m_PendingThreadCount);

#if 0 // g_TrapReturningThreads debug code.
    if (cntReturn != g_TrapReturningThreads /*&& !g_fEEShutDown*/)
    {       // If count is off, try again, to account for multiple threads.
        if (iRetry < 4)
        {
            //              printf("Retry %d.  cntReturn:%d, gReturn:%d\n", iRetry, cntReturn, g_TrapReturningThreads);
            ++iRetry;
            goto Retry;
        }
        printf("cnt:%d, Un:%d, Back:%d, Dead:%d, cntReturn:%d, TrapReturn:%d, eeShutdown:%d, threadShutdown:%d\n", 
               cnt,cntUnstart,cntBack,cntDead,cntReturn,g_TrapReturningThreads, g_fEEShutDown, Thread::IsAtProcessExit());
        LOG((LF_CORDB, LL_INFO1000,
             "SUSPEND: cnt:%d, Un:%d, Back:%d, Dead:%d, cntReturn:%d, TrapReturn:%d, eeShutdown:%d, threadShutdown:%d\n", 
             cnt,cntUnstart,cntBack,cntDead,cntReturn,g_TrapReturningThreads, g_fEEShutDown, Thread::IsAtProcessExit()) );

        //_ASSERTE(cntReturn + 2 >= g_TrapReturningThreads);
    }
    if (iRetry > 0 && iRetry < 4)
    {
        printf("%d retries to re-sync counted TrapReturn with global TrapReturn.\n", iRetry);
    }
#endif // g_TrapReturningThreads debug code.

    // Because of race conditions and the fact that the GC places its
    // own count, I can't assert this precisely.  But I do want to be
    // sure that this count isn't wandering ever higher -- with a
    // nasty impact on the performance of GC mode changes and method
    // call chaining!
    //
    // We don't bother asserting this during process exit, because
    // during a shutdown we will quietly terminate threads that are
    // being waited on.  (If we aren't shutting down, we carefully
    // decrement our counts and alert anyone waiting for us to
    // return).
    //
    // Note: we don't actually assert this if
    // g_TrapReturningThreadsPoisoned is true. It is set to true when
    // ever a thread bumps g_TrapReturningThreads up, and it is set to
    // false on entry into this routine. Therefore, if its true, it
    // indicates that a thread has bumped the count up while we were
    // counting, which will throw out count off.
        
    _ASSERTE((cntReturn + 2 >= g_TrapReturningThreads) ||
             g_fEEShutDown ||
             g_TrapReturningThreadsPoisoned);
        
    return found;
}

#endif // _DEBUG



//----------------------------------------------------------------------------
//
// Suspending threads, rendezvousing with threads that reach safe places, etc.
//
//----------------------------------------------------------------------------

// A note on SUSPENSIONS.
//
// We must not suspend a thread while it is holding the ThreadStore lock, or
// the lock on the thread.  Why?  Because we need those locks to resume the
// thread (and to perform a GC, use the debugger, spawn or kill threads, etc.)
//
// There are two types of suspension we must consider to enforce the above
// rule.  Synchronous suspensions are where we persuade the thread to suspend
// itself.  This is CommonTripThread and its cousins.  In other words, the
// thread toggles the GC mode, or it hits a hijack, or certain opcodes in the
// interpreter, etc.  In these cases, the thread can simply check whether it
// is holding these locks before it suspends itself.
//
// The other style is an asynchronous suspension.  This is where another
// thread looks to see where we are.  If we are in a fully interruptible region
// of JIT code, we will be left suspended.  In this case, the thread performing
// the suspension must hold the locks on the thread and the threadstore.  This
// ensures that we aren't suspended while we are holding these locks.
//
// Note that in the asynchronous case it's not enough to just inspect the thread
// to see if it's holding these locks.  Since the thread must be in preemptive
// mode to block to acquire these locks, and since there will be a few inst-
// ructions between acquiring the lock and noting in our state that we've
// acquired it, then there would be a window where we would seem eligible for
// suspension -- but in fact would not be.

//----------------------------------------------------------------------------

// We can't leave preemptive mode and enter cooperative mode, if a GC is
// currently in progress.  This is the situation when returning back into
// the EE from outside.  See the comments in DisablePreemptiveGC() to understand
// why we Enable GC here!
void Thread::RareDisablePreemptiveGC()
{
#ifdef _DEBUG
    extern int gc_count;            // used for the GC stress call below
    extern volatile LONG m_GCLock;   
#endif

    // This should NEVER be called if the TSNC_UnsafeSkipEnterCooperative bit is set!
    _ASSERTE(!(m_StateNC & TSNC_UnsafeSkipEnterCooperative) && "DisablePreemptiveGC called while the TSNC_UnsafeSkipEnterCooperative bit is set");

    STRESS_LOG1(LF_SYNC, LL_INFO1000, "RareDisablePremptiveGC: entering. Thread state = %x\n", m_State);
    if ((g_pGCHeap->IsGCInProgress() && (this != g_pGCHeap->GetGCThread())) ||
        (m_State & (TS_UserSuspendPending | TS_DebugSuspendPending)))
    {
        if (!ThreadStore::HoldingThreadStore(this) || g_fRelaxTSLRequirement)
        {
            do
            {
                EnablePreemptiveGC();
            
                // just wait until the GC is over.
                if (this != g_pGCHeap->GetGCThread())
                {
#ifdef PROFILING_SUPPORTED
                    // If profiler desires GC events, notify it that this thread is waiting until the GC is over
                    // Do not send suspend notifications for debugger suspensions
                    if (CORProfilerTrackSuspends() && !(m_State & TS_DebugSuspendPending))
                    {
                        g_profControlBlock.pProfInterface->RuntimeThreadSuspended((ThreadID)this, (ThreadID)this);
                    }
#endif // PROFILING_SUPPORTED


                        // thread -- they had better not be fiberizing something from the threadpool!

                        // First, check to see if there's an IDbgThreadControl interface that needs
                        // notification of the suspension
                        if (m_State & TS_DebugSuspendPending)
                        {
                            IDebuggerThreadControl *pDbgThreadControl = CorHost::GetDebuggerThreadControl();

                            if (pDbgThreadControl)
                                pDbgThreadControl->ThreadIsBlockingForDebugger();

                        }

                        // If not, check to see if there's an IGCThreadControl interface that needs
                        // notification of the suspension
                        IGCThreadControl *pGCThreadControl = CorHost::GetGCThreadControl();

                        if (pGCThreadControl)
                            pGCThreadControl->ThreadIsBlockingForSuspension();

                        g_pGCHeap->WaitUntilGCComplete();


#ifdef PROFILING_SUPPORTED
                    // Let the profiler know that this thread is resuming
                    if (CORProfilerTrackSuspends())
                        g_profControlBlock.pProfInterface->RuntimeThreadResumed((ThreadID)this, (ThreadID)this);
#endif // PROFILING_SUPPORTED
                }
    
                m_fPreemptiveGCDisabled = 1;

                // The fact that we check whether 'this' is the GC thread may seem
                // strange.  After all, we determined this before entering the method.
                // However, it is possible for the current thread to become the GC
                // thread while in this loop.  This happens if you use the COM+
                // debugger to suspend this thread and then release it.

            } while ((g_pGCHeap->IsGCInProgress() && (this != g_pGCHeap->GetGCThread())) ||
                     (m_State & (TS_UserSuspendPending | TS_DebugSuspendPending)));
        }
    }
    STRESS_LOG0(LF_SYNC, LL_INFO1000, "RareDisablePremptiveGC: leaving\n");
}

void Thread::HandleThreadAbort ()
{
    // Sometimes we call this without any CLR SEH in place.  An example is UMThunkStubRareDisableWorker.
    // That's okay since COMPlusThrow will eventually erect SEH around the RaiseException,
    // but it prevents us from stating THROWSCOMPLUSEXCEPTION here.
    //THROWSCOMPLUSEXCEPTION();
    DEBUG_SAFE_TO_THROW_IN_THIS_BLOCK;

    if ((m_State & TS_AbortRequested) && 
        !(m_State & TS_AbortInitiated) &&
        (! IsExceptionInProgress() || m_handlerInfo.IsInUnmanagedHandler()))
    { // generate either a ThreadAbort exception
        STRESS_LOG1(LF_APPDOMAIN, LL_INFO100, "Thread::HandleThreadAbort throwing abort for %x\n", GetThreadId());
        SetAbortInitiated();
        ResetStopRequest();
        // if an abort and interrupt happen at the same time (e.g. on a sleeping thread),
        // the abort is favored. But we do need to reset the interrupt bits. 
        FastInterlockAnd((ULONG *) &m_State, ~(TS_Interruptible | TS_Interrupted));
        IsUserInterrupted(TRUE /*=reset*/);
        COMPlusThrow(kThreadAbortException);
    }    
}

#ifdef _DEBUG
#define MAXSTACKBYTES 0x800*sizeof(PVOID)             // two pages
void CleanStackForFastGCStress ()
{
    size_t nBytes = (size_t)&nBytes - (size_t) ((struct _NT_TIB *)NtCurrentTeb())->StackLimit;
    nBytes &= ~sizeof (size_t);
    size_t maxBytes = MAXSTACKBYTES;   // max two pages
    if (nBytes > MAXSTACKBYTES) {
        nBytes = MAXSTACKBYTES;
    }
    size_t* buffer = (size_t*) _alloca (nBytes);
    memset(buffer, 0, nBytes);
    GetThread()->m_pCleanedStackBase = &nBytes;
}

void Thread::ObjectRefFlush(Thread* thread) {
    _ASSERTE(thread->PreemptiveGCDisabled());  // Should have been in managed code     
    memset(thread->dangerousObjRefs, 0, sizeof(thread->dangerousObjRefs));
    CLEANSTACKFORFASTGCSTRESS ();
}
#endif

#if defined(STRESS_HEAP)

PtrHashMap *g_pUniqueStackMap = NULL;
Crst *g_pUniqueStackCrst = NULL;

#define UniqueStackDepth 8

BOOL StackCompare (UPTR val1, UPTR val2)
{
    size_t *p1 = (size_t *)(val1 << 1);
    size_t *p2 = (size_t *)val2;
    if (p1[0] != p2[0]) {
        return FALSE;
    }
    size_t nElem = p1[0];
    if (nElem >= UniqueStackDepth) {
        nElem = UniqueStackDepth;
    }
    p1 ++;
    p2 ++;

    for (UINT n = 0; n < nElem; n ++) {
        if (p1[n] != p2[n]) {
            return FALSE;
        }
    }

    return TRUE;
}

void StartUniqueStackMap ()
{
    static long fUniqueStackInit = 0;
    if (FastInterlockExchange ((long *)&fUniqueStackInit, 1) == 0) {
        _ASSERTE (g_pUniqueStackMap == NULL);
        g_pUniqueStackCrst = ::new Crst ("HashMap", CrstUniqueStack, TRUE, FALSE);
        PtrHashMap *map = new (SystemDomain::System()->GetLowFrequencyHeap()) PtrHashMap ();
        LockOwner lock = {g_pUniqueStackCrst, IsOwnerOfCrst};
        map->Init (32, StackCompare, TRUE, &lock);
        g_pUniqueStackMap = map;
    }
    else
    {
        while (g_pUniqueStackMap == NULL) {
            __SwitchToThread (0);
        }
    }
}

#ifdef SHOULD_WE_CLEANUP
void StopUniqueStackMap ()
{
    if (g_pUniqueStackMap) {
        delete g_pUniqueStackMap;
    }

    if (g_pUniqueStackCrst) {
        ::delete g_pUniqueStackCrst;
    }
}
#endif /* SHOULD_WE_CLEANUP */

extern size_t StressHeapPreIP;
extern size_t StressHeapPostIP;

/***********************************************************************/
size_t getStackHash(size_t* stackTrace, size_t* stackStop, size_t stackBase, size_t stackLimit) {

    // return a hash of every return address found between 'stackTop' (the lowest address)
    // and 'stackStop' (the highest address)

    size_t hash = 0;
    size_t dummy;

    static size_t moduleBase = -1;
    static size_t moduleTop = -1;
    if (moduleTop == -1) {
        MEMORY_BASIC_INFORMATION mbi;

        if (VirtualQuery(getStackHash, &mbi, sizeof(mbi))) {
            moduleBase = (size_t)mbi.AllocationBase;
            moduleTop = (size_t)mbi.BaseAddress + mbi.RegionSize;
        } else {
            // way bad error, probably just assert and exit
            _ASSERTE (!"VirtualQuery failed");
            moduleBase = 0;
            moduleTop = 0;
        }   
    }
    int idx = 0;
    BOOL fSkip = TRUE;
    size_t* stackTop = stackTrace;
    while (stackTop < stackStop) {
            // weed out things that point to stack, as those can't be return addresses
        if (*stackTop > moduleBase && *stackTop < moduleTop)
            if (isRetAddr(*stackTop, &dummy)) {
                if (fSkip) {
                    if (*stackTop < StressHeapPostIP && *stackTop > StressHeapPreIP) {
                        fSkip = FALSE;
                    }
                    stackTop ++;
                    continue;
                }
                hash = ((hash << 3) + hash) ^ *stackTop;

                // If there is no jitted code of the stack, then just use the
                // top 16 frames as the context.  
                idx++;
                if (idx <= UniqueStackDepth) {
                    stackTrace [idx] = *stackTop;
                }
            }
        stackTop++;
            }

    stackTrace [0] = idx;
    return(hash);
}

/***********************************************************************/
/* returns true if this stack has not been seen before, useful for
   running tests only once per stack trace */

BOOL Thread::UniqueStack() {
    if (g_pUniqueStackMap == NULL) {
        StartUniqueStackMap ();
    }

    size_t stackTrace[UniqueStackDepth+1] = {0};

        // stackTraceHash represents a hash of entire stack at the time we make the call,   
        // We insure at least GC per unique stackTrace.  What information is contained in 
        // 'stackTrace' is somewhat arbitrary.  We choose it to mean all functions live
        // on the stack up to the first jitted function.  

    size_t stackTraceHash;
    size_t* hashSlot = 0;
    Thread* pThread = GetThread();
    
    void* stopPoint = pThread->m_CacheStackBase; 
    // Find the stop point (most jitted function)
    Frame* pFrame = pThread->GetFrame();
    for(;;) {       // skip GC frames
        if (pFrame == 0 || pFrame == (Frame*) -1)
            break;
        pFrame->GetFunction();      // This insures that helper frames are inited
            
        if (pFrame->GetReturnAddress() != 0) {
            stopPoint = pFrame; 
            break;
        }
        pFrame = pFrame->Next();
    }
    
    // Get hash of all return addresses between here an the top most jitted function
    stackTraceHash = getStackHash (stackTrace, (size_t*) stopPoint, 
        size_t(pThread->m_CacheStackBase), size_t(pThread->m_CacheStackLimit)); 

    if (g_pUniqueStackMap->LookupValue (stackTraceHash, stackTrace) != (LPVOID)INVALIDENTRY) {
        return FALSE;
    }
    BOOL fUnique = FALSE;
    g_pUniqueStackCrst->Enter();
    __try 
    {
        if (g_pUniqueStackMap->LookupValue (stackTraceHash, stackTrace) != (LPVOID)INVALIDENTRY) {
            fUnique = FALSE;
        }
        else
        {
            fUnique = TRUE;
            size_t nElem = stackTrace[0];
            if (nElem >= UniqueStackDepth) {
                nElem = UniqueStackDepth;
            }
            size_t *stackTraceInMap = (size_t *) SystemDomain::System()->GetLowFrequencyHeap()
                                        ->AllocMem(sizeof(size_t *) * (nElem + 1));
            memcpy (stackTraceInMap, stackTrace, sizeof(size_t *) * (nElem + 1));
            g_pUniqueStackMap->InsertValue(stackTraceHash, stackTraceInMap);
        }
    }
    __finally
    {
        g_pUniqueStackCrst->Leave();
    }

#ifdef _DEBUG
    static int fCheckStack = -1;
    if (fCheckStack == -1) {
        fCheckStack = g_pConfig->GetConfigDWORD(L"FastGCCheckStack", 0);
    }
    if (fCheckStack && pThread->m_pCleanedStackBase > stackTrace
        && pThread->m_pCleanedStackBase - stackTrace > MAXSTACKBYTES) {
        _ASSERTE (!"Garbage on stack");
    }
#endif
    return fUnique;
}

#if defined(_DEBUG)

// This function is for GC stress testing.  Before we enable preemptive GC, let us do a GC
// because GC may happen while the thread is in preemptive GC mode.
void Thread::PerformPreemptiveGC()
{
    if (g_fProcessDetach)
        return;
    
    if (!(g_pConfig->GetGCStressLevel() & EEConfig::GCSTRESS_TRANSITION))
        return;

    if (!m_GCOnTransitionsOK
        || GCForbidden() 
        || g_fEEShutDown 
        || g_pGCHeap->IsGCInProgress() 
        || GCHeap::GetGcCount() == 0    // Need something that works for isolated heap.
        || ThreadStore::HoldingThreadStore()) 
        return;
    
#ifdef DEBUGGING_SUPPORTED
    // Don't collect if the debugger is attach and either 1) there
    // are any threads held at unsafe places or 2) this thread is
    // under the control of the debugger's dispatch logic (as
    // evidenced by having a non-NULL filter context.)
    if ((CORDebuggerAttached() &&
        (g_pDebugInterface->ThreadsAtUnsafePlaces() ||
        (GetFilterContext() != NULL)))) 
        return;
#endif // DEBUGGING_SUPPORTED

    _ASSERTE(m_fPreemptiveGCDisabled == false);     // we are in preemtive mode when we call this
    
    m_GCOnTransitionsOK = FALSE;
    DisablePreemptiveGC();
    g_pGCHeap->StressHeap();
    EnablePreemptiveGC();
    m_GCOnTransitionsOK = TRUE; 
}
#endif  // DEBUG
#endif // STRESS_HEAP

// To leave cooperative mode and enter preemptive mode, if a GC is in progress, we
// no longer care to suspend this thread.  But if we are trying to suspend the thread
// for other reasons (e.g. Thread.Suspend()), now is a good time.
//
// Note that it is possible for an N/Direct call to leave the EE without explicitly
// enabling preemptive GC.
void Thread::RareEnablePreemptiveGC()
{
#if defined(STRESS_HEAP) && defined(_DEBUG)
    if (!IsDetached())
        PerformPreemptiveGC();
#endif

    STRESS_LOG1(LF_SYNC, LL_INFO1000, "RareEnablePremptiveGC: entering. Thread state = %x\n", m_State);
    if (!ThreadStore::HoldingThreadStore(this) || g_fRelaxTSLRequirement)
    {
        // Remove any hijacks we might have.
        UnhijackThread();

        // wake up any threads waiting to suspend us, like the GC thread.
        SetSafeEvent();

        // for GC, the fact that we are leaving the EE means that it no longer needs to
        // suspend us.  But if we are doing a non-GC suspend, we need to block now.
        // Give the debugger precedence over user suspensions:
        while (m_State & (TS_DebugSuspendPending | TS_UserSuspendPending))
        {
            BOOL threadStoreLockOwner = FALSE;
            
#ifdef DEBUGGING_SUPPORTED
            if (m_State & TS_DebugWillSync)
            {
                _ASSERTE(m_State & TS_DebugSuspendPending);

                FastInterlockAnd((ULONG *) &m_State, ~TS_DebugWillSync);

                LOG((LF_CORDB, LL_INFO1000, "[0x%x] SUSPEND: sync reached.\n", m_ThreadId));

                if (FastInterlockDecrement(&m_DebugWillSyncCount) < 0)
                {
                    LOG((LF_CORDB, LL_INFO1000, "[0x%x] SUSPEND: complete.\n", m_ThreadId));

                    // We need to know if this thread is going to be blocking while holding the thread store lock
                    // below. If that's the case, we'll actually wake the thread up in SysResumeFromDebug even though is
                    // is supposed to be suspended. (See comments in SysResumeFromDebug.)
                    SetThreadStateNC(TSNC_DebuggerUserSuspendSpecial);
                    
                    threadStoreLockOwner = g_pDebugInterface->SuspendComplete(FALSE);

                    LOG((LF_CORDB, LL_INFO1000, "[0x%x] SUSPEND: owns TS: %d\n", m_ThreadId, threadStoreLockOwner));
                }
            }
            
            // Check to see if there's an IDbgThreadControl interface that needs
            // notification of the suspension
            if (m_State & TS_DebugSuspendPending)
            {
                IDebuggerThreadControl *pDbgThreadControl = CorHost::GetDebuggerThreadControl();

                if (pDbgThreadControl)
                    pDbgThreadControl->ThreadIsBlockingForDebugger();

            }
#endif // DEBUGGING_SUPPORTED

#ifdef LOGGING
            if (!CorHost::IsDebuggerSpecialThread(m_ThreadId))
                LOG((LF_CORDB, LL_INFO1000, "[0x%x] SUSPEND: suspended while enabling gc.\n", m_ThreadId));

            else
                LOG((LF_CORDB, LL_INFO1000,
                     "[0x%x] ALERT: debugger special thread did not suspend while enabling gc.\n", m_ThreadId));
#endif

            WaitSuspendEvent(); // sets bits, too

            // We no longer have to worry about this thread blocking with the thread store lock held, so remove the
            // bit. (Again, see comments in SysResumeFromDebug.)
            ResetThreadStateNC(TSNC_DebuggerUserSuspendSpecial);

            // If we're the holder of the thread store lock after a SuspendComplete from above, then release the thread
            // store lock here. We're releasing after waiting, which means this thread holds the thread store lock the
            // entire time the Runtime is stopped.
            if (threadStoreLockOwner)
            {
                // If this thread is marked as debugger suspended and its the holder of the thread store lock, then
                // clear the suspend event and let us loop around to block again, this time without the thread store
                // lock held. This ensures that if this thread is marked by the debugger as suspended (while the runtime
                // is stopped), that it will release the thread store lock when the process is resumed but still
                // continue waiting.
                if (m_StateNC & TSNC_DebuggerUserSuspend)
                {
                    // We can assert this because we're holding the thread store lock, so we know that no one can reset
                    // this flag on us.
                    _ASSERTE(m_State & TS_DebugSuspendPending);
                    
                    ClearSuspendEvent();
                }

                LOG((LF_CORDB, LL_INFO1000, "[0x%x] SUSPEND: releasing thread store lock.\n", m_ThreadId));

                ThreadStore::UnlockThreadStore();
            }
            else
            {
                LOG((LF_CORDB, LL_INFO1000, "[0x%x] SUSPEND: not releasing thread store lock.\n", m_ThreadId));
            }
        }
    }
    STRESS_LOG0(LF_SYNC, LL_INFO1000, " RareEnablePremptiveGC: leaving.\n");
}


// Called out of CommonTripThread, we are passing through a Safe spot.  Do the right
// thing with this thread.  This may involve waiting for the GC to complete, or
// performing a pending suspension.
void Thread::PulseGCMode()
{
    _ASSERTE(this == GetThread());

    if (PreemptiveGCDisabled() && CatchAtSafePoint())
    {
        EnablePreemptiveGC();
        DisablePreemptiveGC();
    }
}


// Indicate whether threads should be trapped when returning to the EE (i.e. disabling
// preemptive GC mode)
void ThreadStore::TrapReturningThreads(BOOL yes)
{
    if (yes)
    {
#ifdef _DEBUG
        g_TrapReturningThreadsPoisoned = true;
#endif
        
        FastInterlockIncrement(&g_TrapReturningThreads);
        _ASSERTE(g_TrapReturningThreads > 0);
    }
    else
    {
        FastInterlockDecrement(&g_TrapReturningThreads);
        _ASSERTE(g_TrapReturningThreads >= 0);
    }
}


// Grab a consistent snapshot of the thread's state, for reporting purposes only.
Thread::ThreadState Thread::GetSnapshotState()
{
    ThreadState     res = m_State;

    if (res & TS_ReportDead)
        res = (ThreadState) (res | TS_Dead);

    return res;
}

//-----------------------
// Return the upper bound of the threads stack space.
//

/* static */
void * Thread::GetStackUpperBound() 
        {

#ifdef PLATFORM_WIN32
    return ((struct _NT_TIB *)NtCurrentTeb())->StackBase;
#else
    _ASSERTE("NYI for this platform");
    return 0;
#endif
}

//-------------------------------------------------------
// Returns the lower bound of the stack space.  Note -- the pratcial bound
// is two pages greater than this value -- these two pages are reserved for
// a stack overflow exception processing.
//

/* static */
void * Thread::GetStackLowerBound() {

    MEMORY_BASIC_INFORMATION meminfo;
    SIZE_T dwRes = VirtualQuery((const void *)&meminfo, &meminfo, sizeof(meminfo));
    _ASSERTE(dwRes == sizeof(meminfo) && "VirtualQuery failed.");

    return (void *) meminfo.AllocationBase;
}

//-----------------------------------------------------------------------------
// Returns TRUE iff the thread is still protected from stack overflows.
// 
BOOL Thread::GuardPageOK() {

    // Get the page permissions for the guard page.
    MEMORY_BASIC_INFORMATION meminfo;
    LPBYTE GuardPageBase = (LPBYTE) m_CacheStackLimit + PAGE_SIZE;
    DWORD dwRes = VirtualQuery((const void *)GuardPageBase, &meminfo, sizeof(meminfo));
    _ASSERTE(dwRes == sizeof(meminfo) && "VirtualQuery failed.");

    // First, check State.  If page is not comitted, then we've never used it.
    if (meminfo.State != MEM_COMMIT)
        return TRUE;

    // If the page has been committed ... then check the access bits.
    if (!RunningOnWinNT()) {
        return ((meminfo.AllocationProtect & PAGE_NOACCESS) != 0);
    } else {
        return ((meminfo.AllocationProtect & PAGE_GUARD) != 0);
    }
}

VOID 
Thread::FixGuardPage() {
    if (GuardPageOK())
        return;

    LPBYTE GuardPageBase = (LPBYTE) m_CacheStackLimit + PAGE_SIZE;
    if (GetSP() < GuardPageBase + 2 * PAGE_SIZE)
        FailFast(this, FatalStackOverflow);

    DWORD flOldProtect;
    BOOL fResetFailed;

    if (!RunningOnWinNT()) {

        fResetFailed = !VirtualProtect(GuardPageBase, OS_PAGE_SIZE,
            PAGE_NOACCESS, &flOldProtect);

    } else {

        fResetFailed = !VirtualProtect(GuardPageBase, OS_PAGE_SIZE,
            PAGE_READWRITE | PAGE_GUARD, &flOldProtect);

    }

    _ASSERTE(!fResetFailed);
}

//****************************************************************************************
// This will return the remaining stack space for a suspended thread,
// excluding the guard pages
//
size_t Thread::GetRemainingStackSpace(size_t esp)
{
#ifndef _WIN64
    _ASSERTE(GetThread() != this);

#ifdef _DEBUG
    // Make sure it's suspended
    DWORD __suspendCount = ::SuspendThread(GetThreadHandle());
    _ASSERTE(__suspendCount >= 1);
    ::ResumeThread(GetThreadHandle());
#endif

    MEMORY_BASIC_INFORMATION memInfo;
    size_t dwRes = VirtualQuery((const void *)esp, &memInfo, sizeof(memInfo));
    _ASSERTE(dwRes == sizeof(memInfo) && "VirtualQuery failed.");

    if (dwRes != sizeof(memInfo))
        return (0);

    _ASSERTE((esp - ((size_t)(memInfo.AllocationBase) + (2 * PAGE_SIZE))) >= 0);
    return (esp - ((size_t)(memInfo.AllocationBase) + (2 * PAGE_SIZE)));
#else // _WIN64
    _ASSERTE(!"@TODO IA64 - port");
    return 0;
#endif // !_WIN64
}

// Doesn't matter what this fucntion does, so long as it induces a stack overflow exception.
#pragma warning(disable:4717)   // Stack overflow warning
static 
void __stdcall InduceStackOverflowHelper() {
    char c[1024];
    c[0] = 0;
    InduceStackOverflowHelper();
}
#pragma warning(default:4717)  



//****************************************************************************************
// This will check who caused the exception.  If it was caused by the the redirect function,
// the reason is to resume the thread back at the point it was redirected in the first
// place.  If the exception was not caused by the function, then it was caused by the call
// out to the I[GC|Debugger]ThreadControl client and we need to determine if it's an
// exception that we can just eat and let the runtime resume the thread, or if it's an
// uncatchable exception that we need to pass on to the runtime.
//
int RedirectedHandledJITCaseExceptionFilter(
    PEXCEPTION_POINTERS pExcepPtrs,     // Exception data
    RedirectedThreadFrame *pFrame,      // Frame on stack
    BOOL fDone,                         // Whether redirect completed without exception
    CONTEXT *pCtx)                      // Saved context
{
#ifdef _X86_
    // Get the thread handle
    Thread *pThread = GetThread();
    _ASSERTE(pThread);


    STRESS_LOG1(LF_SYNC, LL_INFO100, "In RedirectedHandledJITCaseExceptionFilter fDone = %d\n", fDone);

    // If we get here via COM+ exception, gc-mode is unknown.  We need it to
    // be cooperative for this function.
    if (!pThread->PreemptiveGCDisabled())
        pThread->DisablePreemptiveGC();

    // If the exception was due to the called client, then we need to figure out if it
    // is an exception that can be eaten or if it needs to be handled elsewhere.
    if (!fDone)
    {

        // Get the latest thrown object
        OBJECTREF throwable = pThread->LastThrownObject();

        // If this is an uncatchable exception, then let the exception be handled elsewhere
        if (IsUncatchable(&throwable))
        {
            pThread->EnablePreemptiveGC();
            return (EXCEPTION_CONTINUE_SEARCH);
        }
    }
#ifdef _DEBUG
    else
        _ASSERTE(pExcepPtrs->ExceptionRecord->ExceptionCode == EXCEPTION_COMPLUS);
#endif

    // Unlink the frame in preparation for resuming in managed code
    pFrame->Pop();

    // Copy the saved context record into the EH context;
    ReplaceExceptionContextRecord(pExcepPtrs->ContextRecord, pCtx);

    // Free the context struct if we already have one cached
    if (pThread->GetSavedRedirectContext())
        delete pCtx;

    // Save it for future use to avoid repeatedly new'ing
    else
        pThread->SetSavedRedirectContext(pCtx);

    /////////////////////////////////////////////////////////////////////////////
    // NOTE: Ugly, ugly hack.
    // We need to resume the thread into the managed code where it was redirected,
    // and the corresponding ESP is below the current one.  But C++ expects that
    // on an EXCEPTION_CONTINUE_EXECUTION that the ESP will be above where it has
    // installed the SEH handler.  To solve this, we need to remove all handlers
    // that reside above the resumed ESP, but we must leave the OS-installed
    // handler at the top, so we grab the top SEH handler, call
    // PopSEHRecords which will remove all SEH handlers above the target ESP and
    // then link the OS handler back in with SetCurrentSEHRecord.

    // Get the special OS handler and save it until PopSEHRecords is done
    EXCEPTION_REGISTRATION_RECORD *pCurSEH =
        (EXCEPTION_REGISTRATION_RECORD *)GetCurrentSEHRecord();

    // Unlink all records above the target resume ESP
    PopSEHRecords((LPVOID)(size_t)pCtx->Esp);

    // Link the special OS handler back in to the top
    pCurSEH->Next = (EXCEPTION_REGISTRATION_RECORD *)GetCurrentSEHRecord();

    // Register the special OS handler as the top handler with the OS
    SetCurrentSEHRecord((LPVOID)pCurSEH);

    // Resume execution at point where thread was originally redirected
    return (EXCEPTION_CONTINUE_EXECUTION);
#else
    _ASSERTE(!"TODO Alpha.  Should never have got here.");
    return (EXCEPTION_CONTINUE_SEARCH);
#endif
}

void __stdcall Thread::RedirectedHandledJITCase(SuspendReason reason) 
{
    // This will indicate to the exception filter whether or not the exception is caused
    // by us or the client.
    BOOL fDone = FALSE;
    int filter_count = 0;       // A counter to avoid a nasty case where an
                                // up-stack filter throws another exception
                                // causing our filter to be run again for
                                // some unrelated exception.

    STRESS_LOG1(LF_SYNC, LL_INFO1000, "In RedirectedHandledJITcase reasion 0x%x\n", reason);

    // Get the saved context
    Thread *pThread = GetThread();
    _ASSERTE(pThread);
    CONTEXT *pCtx = pThread->GetSavedRedirectContext();
    _ASSERTE(pCtx);

    // Create a frame on the stack
    RedirectedThreadFrame frame(pCtx);

    __try
    {
        // Make sure this thread doesn't reuse the context memory in re-entrancy cases
        _ASSERTE(pThread->GetSavedRedirectContext() != NULL);
        pThread->SetSavedRedirectContext(NULL);

        // Link in the frame
        frame.Push();

        // Enable PGC before calling out to the client to allow runtime suspend to finish
        pThread->EnablePreemptiveGC();

        // @TODO: Is this necessary?  Does debugger wait on the events, or does it just
        //        poll every so often?
        // Notify the thread that is performing the suspension that this thread
        // is now in PGC mode and that it can remove this thread from the list of
        // threads it needs to wait for.
        pThread->SetSafeEvent();

        // Notify the interface of the pending suspension
        switch (reason) {
        case GCSuspension:
            if (CorHost::GetGCThreadControl())
                CorHost::GetGCThreadControl()->ThreadIsBlockingForSuspension();
            break;
        case DebugSuspension:
            if (CorHost::GetDebuggerThreadControl() && CorHost::IsDebuggerSpecialThread(pThread->m_ThreadId))
                CorHost::GetDebuggerThreadControl()->ThreadIsBlockingForDebugger();
            break;
        case UserSuspend:
            // Do nothing;
            break;
        default:
            _ASSERTE(!"Invalid suspend reason");
            break;
        }

        // Disable preemptive GC so we can unlink the frame
        pThread->DisablePreemptiveGC();

        pThread->HandleThreadAbort();        // Might throw an exception.

        // Indicate that the call to the service went without an exception, and that
        // we're raising our own exception to resume the thread to where it was
        // redirected from
        fDone = TRUE;
        RaiseException(EXCEPTION_COMPLUS, 0, 0, NULL);
    }
    __except (++filter_count == 1
        ? RedirectedHandledJITCaseExceptionFilter(GetExceptionInformation(), &frame, fDone, pCtx)
        : EXCEPTION_CONTINUE_SEARCH)
    {
        _ASSERTE(!"Reached body of __except in RedirectedHandledJITCaseForDbgThreadControl");
    }
}
//****************************************************************************************
// This helper is called when a thread suspended in managed code at a sequence point while
// suspending the runtime and there is a client interested in re-assigning the thread to
// do interesting work while the runtime is suspended.  This will call into the client
// notifying it that the thread will be suspended for a runtime suspension.
//
void __stdcall Thread::RedirectedHandledJITCaseForDbgThreadControl()
{
    RedirectedHandledJITCase(DebugSuspension);
}


//****************************************************************************************
// This helper is called when a thread suspended in managed code at a sequence point when
// suspending the runtime.
//
// We do this because the obvious code sequence:
//
//      SuspendThread(t1);
//      GetContext(t1, &ctx);
//      ctx.Ecx = <some new value>;
//      SetContext(t1, &ctx);
//      ResumeThread(t1);
//
// simply does not work due to  a nasty race with exception handling in the OS.  If the
// thread that is suspended has just faulted, then the update can disappear without ever
// modifying the real thread ... and there is no way to tell.
//
// Updating the EIP may not work ... but when it doens't, we're ok ... an exception ends
// up getting dispatched anyway.
//
// If the host is interested in getting control, then we give control to the host.  If the
// host is not interested in getting control, then we call out to the host.  After that,
// we raise an exception and will end up waiting for the GC to finish inside the filter.
//
void __stdcall Thread::RedirectedHandledJITCaseForGCThreadControl()
{
    RedirectedHandledJITCase(GCSuspension);
}

//***********************
// Like the above, but called for a UserSuspend.
//
void __stdcall Thread::RedirectedHandledJITCaseForUserSuspend() 
{
    RedirectedHandledJITCase(UserSuspend);
}

//****************************************************************************************
// This will take a thread that's been suspended in managed code at a sequence point and
// will Redirect the thread. It will save all register information, build a frame on the
// thread's stack, put a pointer to the frame at the top of the stack and set the IP of
// the thread to pTgt.  pTgt is then responsible for unlinking the thread, 
//
// NOTE: Cannot play with a suspended thread's stack memory, since the OS will use the
// top of the stack to store information.  The thread must be resumed and play with it's
// own stack.
//

#define CONTEXT_COMPLETE (CONTEXT_FULL | CONTEXT_FLOATING_POINT |       \
                          CONTEXT_DEBUG_REGISTERS | CONTEXT_EXTENDED_REGISTERS)

BOOL Thread::RedirectThreadAtHandledJITCase(PFN_REDIRECTTARGET pTgt)
{
    _ASSERTE(HandledJITCase());
    _ASSERTE(GetThread() != this);

#ifdef _X86_

    ////////////////////////////////////////////////////////////////
    // Allocate a context structure to save the thread state into

    // Check to see if we've already got memory allocated for this purpose.
    CONTEXT *pCtx = GetSavedRedirectContext();

    // If we've never allocated a context for this thread, do so now
    if (!pCtx)
    {
        pCtx = new CONTEXT;
        _ASSERTE(pCtx && "Out of memory allocating context - aborting redirect.");

        if (!pCtx)
            return (FALSE);

        // Always get complete context
        pCtx->ContextFlags = CONTEXT_COMPLETE;

        // Save the pointer for the redirect function
        _ASSERTE(GetSavedRedirectContext() == NULL);
        SetSavedRedirectContext(pCtx);
    }
    _ASSERTE(pCtx && pCtx->ContextFlags == CONTEXT_COMPLETE);

    //////////////////////////////////////
    // Get and save the thread's context

    BOOL bRes = EEGetThreadContext(this, pCtx);
    _ASSERTE((bRes || RunningOnWin95()) && "Failed to GetThreadContext in RedirectThreadAtHandledJITCase - aborting redirect.");

    if (!bRes)
        return (FALSE);

    ///////////////////////////////////////////////////////////////////////
    // Make sure there's enough space on the stack to complete redirecting

    size_t dwStackSpaceLeft = GetRemainingStackSpace(pCtx->Esp);

    // In theory, we never run jitted code when the guard page is gone ... so, 
    // we don't have to deal with the case that a stack overflow exception
    // is being processed at the time we're in HandledJITCase().
    _ASSERTE(GuardPageOK());

    // Pick a size that's reasonable to assume won't work well if it's any less
    if (dwStackSpaceLeft < PAGE_SIZE)
    {
        // Hijack to induced stack overflow instead.

        pTgt = &InduceStackOverflowHelper;
        SetThrowControlForThread(InducedStackOverflow);
    }

    ////////////////////////////////////////////////////
    // Now redirect the thread to the helper function

    // Temporarily set the IP of the context to the target for SetThreadContext
    DWORD dwOrigEip = pCtx->Eip;
    pCtx->Eip = (DWORD)(size_t)pTgt;

    STRESS_LOG3(LF_SYNC, LL_INFO10000, "Redirecting thread tid=%x from address 0x%08x to address 0x%08x\n",
        this->GetThreadId(), dwOrigEip, pTgt);
         
    bRes = EESetThreadContext(this, pCtx);
    _ASSERTE(bRes && "Failed to SetThreadContext in RedirectThreadAtHandledJITCase - aborting redirect.");

    // Restore original IP
    pCtx->Eip = dwOrigEip;

    //////////////////////////////////////////////////
    // Indicate whether or not the redirect succeeded

    return (bRes);
#elif defined(CHECK_PLATFORM_BUILD)
    #error "Platform NYI"
#else
    _ASSERTE(!"Platform NYI");
    return (false);
#endif
}

BOOL Thread::CheckForAndDoRedirect(PFN_REDIRECTTARGET pRedirectTarget)
{
    _ASSERTE(this != GetThread());
    _ASSERTE(PreemptiveGCDisabledOther());
    _ASSERTE(IsAddrOfRedirectFunc(pRedirectTarget));

    BOOL fRes = FALSE;
    fRes = RedirectThreadAtHandledJITCase(pRedirectTarget);
    _ASSERTE((fRes || RunningOnWin95()) && "Redirect of thread in managed code failed.");
    LOG((LF_GC, LL_INFO1000, "%s.\n", fRes ? "SUCCEEDED" : "FAILED")); 

    return (fRes);
}

//************************************************************************
// Exception handling needs to special case the redirection. So provide
// a helper to identify redirection targets and keep the exception
// checks in sync with the redirection here.
// See CPFH_AdjustContextForThreadSuspensionRace for details.
BOOL Thread::IsAddrOfRedirectFunc(void * pFuncAddr)
{
    return
        (pFuncAddr == &Thread::RedirectedHandledJITCaseForGCThreadControl) ||
        (pFuncAddr == &Thread::RedirectedHandledJITCaseForDbgThreadControl) ||
        (pFuncAddr == &Thread::RedirectedHandledJITCaseForUserSuspend);
}

//************************************************************************
// Redirect thread at a GC suspension.
BOOL Thread::CheckForAndDoRedirectForGC()
{
    LOG((LF_GC, LL_INFO1000, "Redirecting thread %08x for GCThreadSuspension", m_ThreadId)); 
    return CheckForAndDoRedirect(&RedirectedHandledJITCaseForGCThreadControl);
}

//************************************************************************
// Redirect thread at a debug suspension.
BOOL Thread::CheckForAndDoRedirectForDbg()
{
    LOG((LF_CORDB, LL_INFO1000, "Redirecting thread %08x for DebugSuspension", m_ThreadId)); 
    return CheckForAndDoRedirect(&RedirectedHandledJITCaseForDbgThreadControl);
}

//*************************************************************************
// Redirect thread at a usur suspend.
BOOL Thread::CheckForAndDoRedirectForUserSuspend()
{
    LOG((LF_CORDB, LL_INFO1000, "Redirecting thread %08x for UserSuspension", m_ThreadId)); 
    return CheckForAndDoRedirect(&RedirectedHandledJITCaseForUserSuspend);
}

//************************************************************************************
// The basic idea is to make a first pass while the threads are suspended at the OS
// level.  This pass marks each thread to indicate that it is requested to get to a
// safe spot.  Then the threads are resumed.  In a second pass, we actually wait for
// the threads to get to their safe spot and rendezvous with us.
HRESULT Thread::SysSuspendForGC(GCHeap::SUSPEND_REASON reason)
{
    Thread  *pCurThread = GetThread();
    Thread  *thread = NULL;
    LONG     countThreads = 0;
    LONG     iCount = 0, i;
    HANDLE   ThreadEventArray[MAX_WAIT_OBJECTS];
    Thread  *ThreadArray[MAX_WAIT_OBJECTS];
    DWORD    res;

    // Caller is expected to be holding the ThreadStore lock.  Also, caller must
    // have set GcInProgress before coming here, or things will break;
    _ASSERTE(ThreadStore::HoldingThreadStore() || g_fProcessDetach);
    _ASSERTE(g_pGCHeap->IsGCInProgress());

    STRESS_LOG1(LF_SYNC, LL_INFO1000, "Suspending EE for reasion 0x%x\n", reason);

#ifdef PROFILING_SUPPORTED
    // If the profiler desires information about GCs, then let it know that one
    // is starting.
    if (CORProfilerTrackSuspends())
    {
        _ASSERTE(reason != GCHeap::SUSPEND_FOR_DEBUGGER);

        g_profControlBlock.pProfInterface->RuntimeSuspendStarted(
            (COR_PRF_SUSPEND_REASON)reason,
            (ThreadID)pCurThread);

        if (pCurThread)
        {
            // Notify the profiler that the thread that is actually doing the GC is 'suspended',
            // meaning that it is doing stuff other than run the managed code it was before the
            // GC started.
            g_profControlBlock.pProfInterface->RuntimeThreadSuspended((ThreadID)pCurThread, (ThreadID)pCurThread);
        }        
    }
#endif // PROFILING_SUPPORTED

    // NOTE::NOTE::NOTE::NOTE::NOTE
    // This function has parallel logic in SysStartSuspendForDebug.  Please make
    // sure to make appropriate changes there as well.

    if (pCurThread)     // concurrent GC occurs on threads we don't know about
    {
        _ASSERTE(pCurThread->m_Priority == INVALID_THREAD_PRIORITY);
        DWORD priority = GetThreadPriority(pCurThread->GetThreadHandle());
        if (priority < THREAD_PRIORITY_NORMAL)
        {
            pCurThread->m_Priority = priority;
            SetThreadPriority(pCurThread->GetThreadHandle(),THREAD_PRIORITY_NORMAL);
        }
    }
    while ((thread = ThreadStore::GetThreadList(thread)) != NULL)
    {
        if (thread == pCurThread)
            continue;
        
        STRESS_LOG3(LF_SYNC, LL_INFO10000, "    Inspecting thread 0x%x ID 0x%x coop mode = %d\n", 
            thread, thread->GetThreadId(), thread->m_fPreemptiveGCDisabled);

        // Nothing confusing left over from last time.
        _ASSERTE((thread->m_State & TS_GCSuspendPending) == 0);

        // Threads can be in Preemptive or Cooperative GC mode.  Threads cannot switch
        // to Cooperative mode without special treatment when a GC is happening.
        if (thread->m_fPreemptiveGCDisabled)
        {
            // Check a little more carefully.  Threads might sneak out without telling
            // us, because we haven't marked them, or because of inlined N/Direct.
    RetrySuspension:
            DWORD dwSuspendCount = ::SuspendThread(thread->GetThreadHandle());

            if (thread->m_fPreemptiveGCDisabled)
            {
                // Only check for HandledJITCase if we actually suspended the thread.
                if ((dwSuspendCount != -1) && thread->HandledJITCase())
                {
                    // Redirect thread so we can capture a good thread context
                    // (GetThreadContext is not sufficient, due to an OS bug).
                    // If we don't succeed (should only happen on Win9X, due to
                    // a different OS bug), we must resume the thread and try
                    // again. 
                    if (!thread->CheckForAndDoRedirectForGC())
                    {
                        _ASSERTE(RunningOnWin95());
                        ::ResumeThread(thread->GetThreadHandle());
                        goto RetrySuspension;
                    }
                }

                // We clear the event here, and we'll set it in any of our
                // rendezvous points when the thread is ready for us.
                //
                // GCSuspendPending and UserSuspendPending both use the SafeEvent.
                // We are inside the protection of the ThreadStore lock in both
                // cases.  But don't let one use interfere with the other:
                //
                // NOTE: we do this even if we've failed to suspend the thread above!
                // This ensures that we wait for the thread below.
                //
                if ((thread->m_State & TS_UserSuspendPending) == 0)
                    thread->ClearSafeEvent();

                FastInterlockOr((ULONG *) &thread->m_State, TS_GCSuspendPending);

                countThreads++;

                // Only resume if we actually suspended the thread above.
                if (dwSuspendCount != -1)
                    ::ResumeThread(thread->GetThreadHandle());
                STRESS_LOG1(LF_SYNC, LL_INFO1000, "    Thread 0x%x is in cooperative needs to rendezvous\n", thread);
            }
            else if (dwSuspendCount != -1)
            {
                STRESS_LOG1(LF_SYNC, LL_WARNING, "    Inspecting thread 0x%x was in cooperative, but now is not\n", thread);
                // Oops.
                ::ResumeThread(thread->GetThreadHandle());
            }
            else {
                STRESS_LOG2(LF_SYNC, LL_ERROR, "    ERROR: Could not suspend thread 0x%x lastError = 0x%x\n", thread, GetLastError());
            }
        }
    }

#ifdef _DEBUG

    {
        int     countCheck = 0;
        Thread *InnerThread = NULL;

        while ((InnerThread = ThreadStore::GetThreadList(InnerThread)) != NULL)
        {
            if (InnerThread != pCurThread &&
                (InnerThread->m_State & TS_GCSuspendPending) != 0)
            {
                countCheck++;
            }
        }
        _ASSERTE(countCheck == countThreads);
    }

#endif

    // Pass 2: Whip through the list again.

    _ASSERTE(thread == NULL);

    while (countThreads)
    {
        STRESS_LOG1(LF_SYNC, LL_INFO1000, "    A total of %d threads need to rendezvous\n", countThreads);
        thread = ThreadStore::GetThreadList(thread);

        if (thread == pCurThread)
            continue;

        if ((thread->m_State & TS_GCSuspendPending) == 0)
            continue;

        if (thread->m_fPreemptiveGCDisabled)
        {
            ThreadArray[iCount] = thread;
            ThreadEventArray[iCount] = thread->m_SafeEvent;
            iCount++;
        }
        else
        {
            // Inlined N/Direct can sneak out to preemptive without actually checking.
            // If we find one, we can consider it suspended (since it can't get back in).
            STRESS_LOG1(LF_SYNC, LL_INFO1000, "    Thread %x is preemptive we can just let him go\n", thread);
            countThreads--;
        }

        if ((iCount >= MAX_WAIT_OBJECTS) || (iCount == countThreads))
        {
#ifdef _DEBUG
            DWORD dbgTotalTimeout = 0;
#endif
            while (iCount)
            {
                // If another thread is trying to do a GC, there is a chance of deadlock
                // because this thread holds the threadstore lock and the GC thread is stuck
                // trying to get it, so this thread must bail and do a retry after the GC completes.
                if (g_pGCHeap->GetGCThreadAttemptingSuspend() != NULL && g_pGCHeap->GetGCThreadAttemptingSuspend() != pCurThread)
                {
#ifdef PROFILING_SUPPORTED
                    // Must let the profiler know that this thread is aborting it's attempt at suspending
                    if (CORProfilerTrackSuspends())
                    {
                        g_profControlBlock.pProfInterface->RuntimeSuspendAborted((ThreadID)thread);                            
                    }
#endif // PROFILING_SUPPORTED

                    return (ERROR_TIMEOUT);
                }

                res = ::WaitForMultipleObjects(iCount, ThreadEventArray,
                                               FALSE /*Any one is fine*/, PING_JIT_TIMEOUT);

                if (res == WAIT_TIMEOUT || res == WAIT_IO_COMPLETION)
                {
                    STRESS_LOG1(LF_SYNC, LL_INFO1000, "    Timed out waiting for rendezvous event %d threads remaining\n", countThreads);
#ifdef _DEBUG
                    if ((dbgTotalTimeout += PING_JIT_TIMEOUT) > DETECT_DEADLOCK_TIMEOUT)
                    {
                        // Do not change this to _ASSERTE.
                        // We want to catch the state of the machine at the
                        // time when we can not suspend some threads.
                        // It takes too long for _ASSERTE to stop the process.
                        DebugBreak();
                        _ASSERTE(!"Timed out trying to suspend EE due to thread");
                        char message[256];
                        for (int i = 0; i < iCount; i ++)
                        {
                            sprintf (message, "Thread %x cannot be suspended",
                                     ThreadArray[i]->GetThreadId());
                            DbgAssertDialog(__FILE__, __LINE__, message);
                        }
                    }
#endif
                    // all these threads should be in cooperative mode unless they have
                    // set their SafeEvent on the way out.  But there's a race between
                    // when we time out and when they toggle their mode, so sometimes
                    // we will suspend a thread that has just left.
                    for (i=0; i<iCount; i++)
                    {
                        Thread  *InnerThread;

                        InnerThread = ThreadArray[i];

                        // If the thread is gone, do not wait for it.
                        if (res == WAIT_TIMEOUT)
                        {
                            if (WaitForSingleObject (InnerThread->GetThreadHandle(), 0)
                                != WAIT_TIMEOUT)
                            {
                                // The thread is not there.
                                iCount--;
                                countThreads--;
                                
                                STRESS_LOG2(LF_SYNC, LL_INFO1000, "    Thread %x died GetLastError 0x%x\n", ThreadArray[i], GetLastError());
                                ThreadEventArray[i] = ThreadEventArray[iCount];
                                ThreadArray[i] = ThreadArray[iCount];
                                continue;
                            }
                        }

                    RetrySuspension2:
                        DWORD dwSuspendCount = ::SuspendThread(InnerThread->GetThreadHandle());

                        // Only check HandledJITCase if we actually suspended the thread.
                        if ((dwSuspendCount != -1) && InnerThread->HandledJITCase())
                        {
                            // Redirect thread so we can capture a good thread context
                            // (GetThreadContext is not sufficient, due to an OS bug).
                            // If we don't succeed (should only happen on Win9X, due to
                            // a different OS bug), we must resume the thread and try
                            // again. 
                            if (!InnerThread->CheckForAndDoRedirectForGC())
                            {
                                _ASSERTE(RunningOnWin95());
                                ::ResumeThread(InnerThread->GetThreadHandle());
                                goto RetrySuspension2;
                            }
                        }

                        // If the thread was redirected, then keep track of it like any other
                        // thread that's in cooperative mode that can't be suspended.  It will
                        // eventually go into preemptive mode which will allow the runtime
                        // suspend to complete.
                        if (!InnerThread->m_fPreemptiveGCDisabled)
                        {
                            iCount--;
                            countThreads--;

                            STRESS_LOG1(LF_SYNC, LL_INFO1000, "    Thread %x went preemptive it is at a GC safe point\n", ThreadArray[i]);
                            ThreadEventArray[i] = ThreadEventArray[iCount];
                            ThreadArray[i] = ThreadArray[iCount];
                        }

                        // Whether in cooperative mode & stubborn, or now in
                        // preemptive mode because of inlined N/Direct, let this
                        // thread go.
                        if (dwSuspendCount != -1)
                            ::ResumeThread(InnerThread->GetThreadHandle());
                    }
                }
                else
                if ((res >= WAIT_OBJECT_0) && (res < WAIT_OBJECT_0 + (DWORD)iCount))
                {
                    // A dying thread will signal us here, too.
                    iCount--;
                    countThreads--;

                    STRESS_LOG1(LF_SYNC, LL_INFO1000, "    Thread %x triggered its rendezvous event\n", ThreadArray[res]);
                    ThreadEventArray[res] = ThreadEventArray[iCount];
                    ThreadArray[res] = ThreadArray[iCount];
                }
                else
                {
                    // No WAIT_FAILED, WAIT_ABANDONED, etc.
                    _ASSERTE(!"unexpected wait termination during gc suspension");
                }
            }
        }
    }

#if 0
#ifdef _DEBUG
    // Does it look like everyone was cleanly suspended?  This assert will blow up,
    // even for legitimate situations.  So it cannot normally be enabled.
    thread = NULL;
    while ((thread = ThreadStore::GetThreadList(thread)) != NULL)
    {
        _ASSERTE(thread == pCurThread ||
                 (thread->m_fPreemptiveGCDisabled == 0));
    }
#endif
#endif

    // Alert the host that a GC is starting, in case the host is scheduling threads
    // for non-runtime tasks during GC.
    IGCThreadControl    *pGCThreadControl = CorHost::GetGCThreadControl();

    if (pGCThreadControl)
        pGCThreadControl->SuspensionStarting();

#ifdef PROFILING_SUPPORTED
    // If a profiler is keeping track of GC events, notify it
    if (CORProfilerTrackSuspends())
        g_profControlBlock.pProfInterface->RuntimeSuspendFinished((ThreadID)pCurThread);
#endif // PROFILING_SUPPORTED

#ifdef _DEBUG
    if (reason == GCHeap::SUSPEND_FOR_GC) {
        thread = NULL;
        while ((thread = ThreadStore::GetThreadList(thread)) != NULL)
        {
            thread->DisableStressHeap();
        }
    }
#endif

    STRESS_LOG0(LF_SYNC, LL_INFO1000, "Successfully completed EE suspension\n");
    return S_OK;
}

#ifdef _DEBUG
void EnableStressHeapHelper()
{
    ENABLESTRESSHEAP();
}
#endif

// We're done with our GC.  Let all the threads run again
void Thread::SysResumeFromGC(BOOL bFinishedGC, BOOL SuspendSucceded)
{
    Thread  *thread = NULL;
    Thread  *pCurThread = GetThread();

#ifdef PROFILING_SUPPORTED
    // If a profiler is keeping track suspend events, notify it

    if (CORProfilerTrackSuspends())
    {
        g_profControlBlock.pProfInterface->RuntimeResumeStarted((ThreadID)pCurThread);
    }
#endif // PROFILING_SUPPORTED

    // Caller is expected to be holding the ThreadStore lock.  But they must have
    // reset GcInProgress, or threads will continue to suspend themselves and won't
    // be resumed until the next GC.
    _ASSERTE(ThreadStore::HoldingThreadStore());
    _ASSERTE(!g_pGCHeap->IsGCInProgress());

    // Alert the host that a GC is ending, in case the host is scheduling threads
    // for non-runtime tasks during GC.
    IGCThreadControl    *pGCThreadControl = CorHost::GetGCThreadControl();

    if (pGCThreadControl)
    {
        // If we the suspension was for a GC, tell the host what generation GC.
        DWORD   Generation = (bFinishedGC
                              ? g_pGCHeap->GetCondemnedGeneration()
                              : ~0U);

        pGCThreadControl->SuspensionEnding(Generation);
    }
    
    while ((thread = ThreadStore::GetThreadList(thread)) != NULL)
    {
#ifdef _DEBUG
        if (SuspendSucceded && ((thread->m_State & TS_Hijacked) && thread->PreemptiveGCDisabledOther())) 
            DebugBreak();
#endif

        if (thread->m_State & TS_Hijacked)
            thread->UnhijackThread();

        FastInterlockAnd((ULONG *) &thread->m_State, ~TS_GCSuspendPending);
    }

#ifdef PROFILING_SUPPORTED
    // Need to give resume event for the GC thread
    if (CORProfilerTrackSuspends())
    {
        if (pCurThread)
        {
            g_profControlBlock.pProfInterface->RuntimeThreadResumed(
                (ThreadID)pCurThread, (ThreadID)pCurThread);
        }

        // If a profiler is keeping track suspend events, notify it
        if (CORProfilerTrackSuspends())
        {
            g_profControlBlock.pProfInterface->RuntimeResumeFinished((ThreadID)pCurThread);
        }
    }
#endif // PROFILING_SUPPORTED
    
    g_profControlBlock.inprocState = ProfControlBlock::INPROC_PERMITTED;
    ThreadStore::UnlockThreadStore();

    if (pCurThread)
    {
        if (pCurThread->m_Priority != INVALID_THREAD_PRIORITY)
        {
            SetThreadPriority(pCurThread->GetThreadHandle(),pCurThread->m_Priority);
            pCurThread->m_Priority = INVALID_THREAD_PRIORITY;
        }

    }
}


// Resume a thread at this location, to persuade it to throw a ThreadStop.  The
// exception handler needs a reasonable idea of how large this method is, so don't
// add lots of arbitrary code here.
void
ThrowControlForThread()
{
    Thread *pThread = GetThread();
    _ASSERTE(pThread);
    _ASSERTE(pThread->m_OSContext);

    FaultingExceptionFrame fef;
    fef.InitAndLink(pThread->m_OSContext);

    CalleeSavedRegisters *pRegs = fef.GetCalleeSavedRegisters();
    pRegs->edi = 0;     // Enregisters roots need to be nuked ... this may not have been a gc-safe
    pRegs->esi = 0;     // point.
    pRegs->ebx = 0;

    // Here we raise an exception.
    RaiseException(EXCEPTION_COMPLUS,
                   0, 
                   0,
                   NULL);

}

// Threads suspended by the Win32 ::SuspendThread() are resumed in two ways.  If we
// suspended them in error, they are resumed via the Win32 ::ResumeThread().  But if
// this is the HandledJIT() case and the thread is in fully interruptible code, we
// can resume them under special control.  SysResumeFromGC and UserResume are cases
// of this.
//
// The suspension has done its work (e.g. GC or user thread suspension).  But during
// the resumption we may have more that we want to do with this thread.  For example,
// there may be a pending ThreadStop request.  Instead of resuming the thread at its
// current EIP, we tweak its resumption point via the thread context.  Then it starts
// executing at a new spot where we can have our way with it.
void Thread::ResumeUnderControl()
{

    LOG((LF_APPDOMAIN, LL_INFO100, "ResumeUnderControl %x\n", GetThreadId()));
    if (m_State & TS_StopRequested)
    {
        if (m_OSContext == NULL) 
            m_OSContext = new CONTEXT;
        
        if (m_OSContext == NULL)
        {
            _ASSERTE(!"Out of memory -- Stop Request delayed");
            goto exit;  
        }
        REGDISPLAY  rd;

        if (InitRegDisplay(&rd, m_OSContext, FALSE))
        {
#ifdef _X86_
            _ASSERTE(rd.pPC == (SLOT*)&(m_OSContext->Eip));
            _ASSERTE(m_OSContext->Eip == *(DWORD*)rd.pPC);
            _ASSERTE(m_OSContext->Esp == (DWORD)rd.Esp);
            _ASSERTE(m_OSContext->Ebp == (DWORD)*rd.pEbp);
            _ASSERTE(m_OSContext->Ebx == (DWORD)*rd.pEbx);
            _ASSERTE(m_OSContext->Esi == (DWORD)*rd.pEsi);
            _ASSERTE(m_OSContext->Edi == (DWORD)*rd.pEdi);
#endif //_X86_

            DWORD resumePC;
            resumePC = *(DWORD*)rd.pPC;
            *rd.pPC = (SLOT) &ThrowControlForThread;
            SetThrowControlForThread(InducedThreadStop);
            EESetThreadContext(this, m_OSContext);
#ifdef _X86_
            m_OSContext->Eip = resumePC;
#else //!_X86_
            _ASSERTE(!"@TODO Alpha - ResumeControlEIP (Threads.cpp)");
//?            _ASSERTE(rd.pPC == &ctx.Fir);

#endif

        }
#if _DEBUG
        else
            _ASSERTE(!"Couldn't obtain thread context -- StopRequest delayed");
#endif
    }
exit:
    ::ResumeThread(GetThreadHandle());
}

//****************************************************************************
//
//****************************************************************************
bool Thread::SysStartSuspendForDebug(AppDomain *pAppDomain)
{
    Thread  *pCurThread = GetThread();
    Thread  *thread = NULL;

    if (g_fProcessDetach)
    {
        LOG((LF_CORDB, LL_INFO1000,
             "SUSPEND: skipping suspend due to process detach.\n"));
        return true;
    }

    LOG((LF_CORDB, LL_INFO1000, "[0x%x] SUSPEND: starting suspend.  Trap count: %d\n",
         pCurThread ? pCurThread->m_ThreadId : -1, g_TrapReturningThreads)); 

    // Caller is expected to be holding the ThreadStore lock
    _ASSERTE(ThreadStore::HoldingThreadStore() || g_fProcessDetach);

    // If there is a debugging thread control object, tell it we're suspending the Runtime.
    IDebuggerThreadControl *pDbgThreadControl = CorHost::GetDebuggerThreadControl();
    
    if (pDbgThreadControl)
        pDbgThreadControl->StartBlockingForDebugger(0);
    
    // NOTE::NOTE::NOTE::NOTE::NOTE
    // This function has parallel logic in SysSuspendForGC.  Please make
    // sure to make appropriate changes there as well.

    _ASSERTE(m_DebugWillSyncCount == -1);
    m_DebugWillSyncCount++;
    
    
    while ((thread = ThreadStore::GetThreadList(thread)) != NULL)
    {
/*  @todo APPD This needs to be finished, replaced, or yanked --MiPanitz
        if (m_DebugAppDomainTarget != NULL &&
            thread->GetDomain() != m_DebugAppDomainTarget)
        {
            continue;
        } */
    
        // Don't try to suspend threads that you've left suspended.
        if (thread->m_StateNC & TSNC_DebuggerUserSuspend)
            continue;
        
        if (thread == pCurThread)
        {
            LOG((LF_CORDB, LL_INFO1000,
                 "[0x%x] SUSPEND: marking current thread.\n",
                 thread->m_ThreadId));

            _ASSERTE(!thread->m_fPreemptiveGCDisabled);
            
            // Mark this thread so it trips when it tries to re-enter
            // after completing this call.
            thread->ClearSuspendEvent();
            thread->MarkForSuspension(TS_DebugSuspendPending);
            
            continue;
        }

        // Threads can be in Preemptive or Cooperative GC mode.
        // Threads cannot switch to Cooperative mode without special
        // treatment when a GC is happening.  But they can certainly
        // switch back and forth during a debug suspension -- until we
        // can get their Pending bit set.
    RetrySuspension:
        DWORD dwSuspendCount = ::SuspendThread(thread->GetThreadHandle());

        if (thread->m_fPreemptiveGCDisabled && dwSuspendCount != -1)
        {
            if (thread->HandledJITCase())
            {
                // Redirect thread so we can capture a good thread context
                // (GetThreadContext is not sufficient, due to an OS bug).
                // If we don't succeed (should only happen on Win9X, due to
                // a different OS bug), we must resume the thread and try
                // again. 
                if (!thread->CheckForAndDoRedirectForDbg())
                {
                    _ASSERTE(RunningOnWin95());
                    ::ResumeThread(thread->GetThreadHandle());
                    goto RetrySuspension;
                }
            }

            // When the thread reaches a safe place, it will wait
            // on the SuspendEvent which clients can set when they
            // want to release us.
            thread->ClearSuspendEvent();

            // Remember that this thread will be running to a safe point
            FastInterlockIncrement(&m_DebugWillSyncCount);
            thread->MarkForSuspension(TS_DebugSuspendPending |
                                      TS_DebugWillSync);

            // Resume the thread and let it run to a safe point
            ::ResumeThread(thread->GetThreadHandle());

            LOG((LF_CORDB, LL_INFO1000, 
                 "[0x%x] SUSPEND: gc disabled - will sync.\n",
                 thread->m_ThreadId));
        }
        else if (dwSuspendCount != -1)
        {
            // Mark threads that are outside the Runtime so that if
            // they attempt to re-enter they will trip.
            thread->ClearSuspendEvent();
            thread->MarkForSuspension(TS_DebugSuspendPending);

            ::ResumeThread(thread->GetThreadHandle());

            LOG((LF_CORDB, LL_INFO1000,
                 "[0x%x] SUSPEND: gc enabled.\n", thread->m_ThreadId));
        }
    }

    //
    // Return true if all threads are synchronized now, otherwise the
    // debugge must wait for the SuspendComplete, called from the last
    // thread to sync.
    //

    if (FastInterlockDecrement(&m_DebugWillSyncCount) < 0)
    {
        LOG((LF_CORDB, LL_INFO1000,
             "SUSPEND: all threads sync before return.\n")); 
        return true;
    }
    else
        return false;
}

//
// This method is called by the debugger helper thread when it times out waiting for a set of threads to
// synchronize. Its used to chase down threads that are not syncronizing quickly. It returns true if all the threads are
// now synchronized and we sent a sync compelte event up. This also means that we own the thread store lock.
//
// If forceSync is true, then we're going to force any thread that isn't at a safe place to stop anyway, thus completing
// the sync. This is used when we've been waiting too long while in interop debugging mode to force a sync in the face
// of deadlocks.
//
bool Thread::SysSweepThreadsForDebug(bool forceSync)
{
    Thread *thread = NULL;

    // NOTE::NOTE::NOTE::NOTE::NOTE
    // This function has parallel logic in SysSuspendForGC.  Please make
    // sure to make appropriate changes there as well.

    // This must be called from the debugger helper thread.
    _ASSERTE(dbgOnly_IsSpecialEEThread());

    ThreadStore::LockThreadStore(GCHeap::SUSPEND_FOR_DEBUGGER, FALSE);

    // Loop over the threads...
    while (((thread = ThreadStore::GetThreadList(thread)) != NULL) && (m_DebugWillSyncCount >= 0))
    {
        // Skip threads that we aren't waiting for to sync.
        if ((thread->m_State & TS_DebugWillSync) == 0)
            continue;

        // Suspend the thread
    RetrySuspension:
        DWORD dwSuspendCount = ::SuspendThread(thread->GetThreadHandle());

        if (dwSuspendCount == -1)
        {
            // If the thread has gone, we can't wait on it.
            if (FastInterlockDecrement(&m_DebugWillSyncCount) < 0)
                // We own the thread store lock. We return true now, which indicates this to the caller.
                return true;
            continue;
        }

        if (thread->HandledJITCase())
        {
            // Redirect thread so we can capture a good thread context
            // (GetThreadContext is not sufficient, due to an OS bug).
            // If we don't succeed (should only happen on Win9X, due to
            // a different OS bug), we must resume the thread and try
            // again. 
            if (!thread->CheckForAndDoRedirectForDbg())
            {
                _ASSERTE(RunningOnWin95());
                ::ResumeThread(thread->GetThreadHandle());
                goto RetrySuspension;
            }
        }

        // If the thread isn't at a safe place now, and if we're forcing a sync, then we mark the thread that we're
        // leaving it at a potentially bad place and leave it suspended.
        if (forceSync)
        {
            // Remove the will sync bit and mark that we're leaving it suspended specially.
            thread->UnmarkForSuspension(~TS_DebugSuspendPending);
            thread->SetSuspendEvent();
            FastInterlockAnd((ULONG *) &thread->m_State, ~(TS_DebugWillSync));

            // Note: we're adding bits into m_stateNC. The only reason we can do this is because we know the following:
            // 1) only the thread in question will modify bits besides this routine and SysResumeFromDebug. 2) the
            // thread is suspended and it will remain suspended until we remove these bits. This ensures that even if we
            // suspend this thread while its attempting to modify these bits that no bits will be lost.  Note also that
            // we mark that the thread is stopped in Runtime impl.
            thread->SetThreadStateNC(Thread::TSNC_DebuggerForceStopped);
            thread->SetThreadStateNC(Thread::TSNC_DebuggerStoppedInRuntime);
            
            LOG((LF_CORDB, LL_INFO1000, "Suspend Complete due to Force Sync case for tid=0x%x.\n", thread->m_ThreadId));
        }
        else
        {
            // If we didn't take the thread out of the set then resume it and give it another chance to reach a safe
            // point.
            ::ResumeThread(thread->GetThreadHandle());
            continue;
        }
        
        // Decrement the sync count. If we have no more threads to wait for, then we're done, so send SuspendComplete.
        if (FastInterlockDecrement(&m_DebugWillSyncCount) < 0)
        {
            // We own the thread store lock. We return true now, which indicates this to the caller.
            return true;
        }
    }

    ThreadStore::UnlockThreadStore();

    return false;
}

void Thread::SysResumeFromDebug(AppDomain *pAppDomain)
{
    Thread  *thread = NULL;

    if (g_fProcessDetach)
    {
        LOG((LF_CORDB, LL_INFO1000,
             "RESUME: skipping resume due to process detach.\n"));
        return;
    }

    LOG((LF_CORDB, LL_INFO1000, "RESUME: starting resume AD:0x%x.\n", pAppDomain)); 

    // Notify the client that it should release any threads that it had doing work
    // while the runtime was debugger-suspended.
    IDebuggerThreadControl *pIDTC = CorHost::GetDebuggerThreadControl();
    if (pIDTC)
    {
        LOG((LF_CORDB, LL_INFO1000, "RESUME: notifying IDebuggerThreadControl client.\n")); 
        pIDTC->ReleaseAllRuntimeThreads();
    }

    // Make sure we completed the previous sync
    _ASSERTE(m_DebugWillSyncCount == -1);

    // Caller is expected to be holding the ThreadStore lock
    _ASSERTE(ThreadStore::HoldingThreadStore() || g_fProcessDetach || g_fRelaxTSLRequirement);

    while ((thread = ThreadStore::GetThreadList(thread)) != NULL)
    {
        // Only consider resuming threads if they're in the correct appdomain
        if (pAppDomain != NULL && thread->GetDomain() != pAppDomain)
        {
            LOG((LF_CORDB, LL_INFO1000, "RESUME: Not resuming thread 0x%x, since it's "
                "in appdomain 0x%x.\n", thread, pAppDomain)); 
            continue;
        }
    
        // If the user wants to keep the thread suspended, then
        // don't release the thread.
        if (!(thread->m_StateNC & TSNC_DebuggerUserSuspend))
        {
            // If we are still trying to suspend this thread, forget about it.
            if (thread->m_State & TS_DebugSuspendPending)
            {
                LOG((LF_CORDB, LL_INFO1000,
                     "[0x%x] RESUME: TS_DebugSuspendPending was set, but will be removed\n",
                     thread->m_ThreadId));

                // Note: we unmark for suspension _then_ set the suspend event.
                thread->UnmarkForSuspension(~TS_DebugSuspendPending);
                thread->SetSuspendEvent();
            }

            // If this thread was forced to stop with PGC disabled then resume it.
            if (thread->m_StateNC & TSNC_DebuggerForceStopped)
            {
                LOG((LF_CORDB, LL_INFO1000, "[0x%x] RESUME: resuming force sync suspension.\n", thread->m_ThreadId));

                thread->ResetThreadStateNC(Thread::TSNC_DebuggerForceStopped);
                thread->ResetThreadStateNC(Thread::TSNC_DebuggerStoppedInRuntime);

                // Don't go through ResumeUnderControl.  If the thread is single-stepping
                // in managed code, we don't want it to suddenly be executing code in our
                // ThrowControl method.
                ::ResumeThread(thread->GetThreadHandle());
            }
        }
        else
        {
            // Thread will remain suspended due to a request from the debugger.
            
            LOG((LF_CORDB,LL_INFO10000,"Didn't unsuspend thread 0x%x"
                "(ID:0x%x)\n", thread, thread->GetThreadId()));
            LOG((LF_CORDB,LL_INFO10000,"Suspending:0x%x\n",
                thread->m_State & TS_DebugSuspendPending));
            _ASSERTE((thread->m_State & TS_DebugWillSync) == 0);

            // If the thread holds the thread store lock and is blocking in RareEnablePreemptiveGC, then we have to wake
            // the thread up and let it release the lock. If we don't do this, then we leave a thread suspended while
            // holding the thread store lock and we can't stop the runtime again later.
            if ((thread->m_State & TS_DebugSuspendPending) &&
                (g_pThreadStore->m_HoldingThread == thread) &&
                (thread->m_StateNC & TSNC_DebuggerUserSuspendSpecial))
                thread->SetSuspendEvent();
        }
    }

    LOG((LF_CORDB, LL_INFO1000, "RESUME: resume complete. Trap count: %d\n", g_TrapReturningThreads)); 
}


// Suspend a thread at the system level.  We distinguish between user suspensions,
// and system suspensions so that a VB program cannot resume a thread we have
// suspended for GC.
//
// This service won't return until the suspension is complete.  This deserves some
// explanation.  The thread is considered to be suspended if it can make no further
// progress within the EE.  For example, a thread that has exited the EE via
// COM Interop or N/Direct is considered suspended -- if we've arranged it so that
// the thread cannot return back to the EE without blocking.
void Thread::UserSuspendThread()
{
    BOOL    mustUnlock = TRUE;

    // Read the general comments on thread suspension earlier, to understand why we
    // take these locks.

    // GC can occur in here:
    STRESS_LOG0(LF_SYNC, LL_INFO100, "UserSuspendThread obtain lock\n");
    ThreadStore::LockThreadStore();

    // User suspensions (e.g. from VB and C#) are distinguished from internal
    // suspensions so a poorly behaved program cannot resume a thread that the system
    // has suspended for GC.
    if (m_State & TS_UserSuspendPending)
    {
        // This thread is already experiencing a user suspension, so ignore the
        // new request.
        _ASSERTE(!ThreadStore::HoldingThreadStore(this));
    }
    else
    if (this != GetThread())
    {
        // First suspension of a thread other than the current one.
        if (m_State & TS_Unstarted)
        {
            // There is an important window in here.  T1 can call T2.Start() and then
            // T2.Suspend().  Suspend is disallowed on an unstarted thread.  But from T1's
            // point of view, T2 is started.  In reality, T2 hasn't been scheduled by the
            // OS, so it is still an unstarted thread.  We don't want to perform a normal
            // suspension on it in this case, because it is currently contributing to the
            // PendingThreadCount.  We want to get it fully started before we suspend it.
            // This is particularly important if its background status is changing
            // underneath us because otherwise we might not detect that the process should
            // be exited at the right time.
            //
            // It turns out that this is a simple situation to implement.  We are holding
            // the ThreadStoreLock.  TransferStartedThread will likewise acquire that
            // lock.  So if we detect it, we simply set a bit telling the thread to
            // suspend itself.  This is NOT the normal suspension request because we don't
            // want the thread to suspend until it has fully started.
            FastInterlockOr((ULONG *) &m_State, TS_SuspendUnstarted);
        }
        else
        {
            // Pause it so we can operate on it without it squirming under us.
        RetrySuspension:
            DWORD dwSuspendCount = ::SuspendThread(GetThreadHandle());

            // The only safe place to suspend a thread asynchronously is if it is in
            // fully interruptible cooperative JIT code.  Preemptive mode can hold all
            // kinds of locks that make it unsafe to suspend.  All other cases are
            // handled somewhat synchronously (e.g. through hijacks, GC mode toggles, etc.)
            //
            // For example, on a SMP if the thread is blocked waiting for the ThreadStore
            // lock, it can cause a deadlock if we suspend it (even though it is in
            // preemptive mode).
            //
            // If a thread is in preemptive mode (including the tricky optimized N/Direct
            // case), we can just mark it for suspension.  It will make no further progress
            // in the EE.
            if (dwSuspendCount == -1)
            {
                // Nothing to do if the thread has already terminated.
            }
            else if (!m_fPreemptiveGCDisabled)
            {
                // Clear the events for thread suspension and reaching a safe spot.
                ClearSuspendEvent();
    
                // GCSuspendPending and UserSuspendPending both use the SafeEvent.
                // We are inside the protection of the ThreadStore lock in both
                // cases.  But don't let one use interfere with the other:
                if ((m_State & TS_GCSuspendPending) == 0)
                    ClearSafeEvent();
    
                // We just want to trap this thread if it comes back into cooperative mode
                MarkForSuspension(TS_UserSuspendPending);
    
                // Let the thread run until it reaches a safe spot.
                ::ResumeThread(GetThreadHandle());
            }
            else
            {
                if (HandledJITCase())
                {
                    _ASSERTE(m_fPreemptiveGCDisabled);
                    // Redirect thread so we can capture a good thread context
                    // (GetThreadContext is not sufficient, due to an OS bug).
                    // If we don't succeed (should only happen on Win9X, due to
                    // a different OS bug), we must resume the thread and try
                    // again. 
                    if (!CheckForAndDoRedirectForUserSuspend())
                    {
                        _ASSERTE(RunningOnWin95());
                        ::ResumeThread(GetThreadHandle());
                        goto RetrySuspension;
                    }
                }
                // Clear the events for thread suspension and reaching a safe spot.
                ClearSuspendEvent();
    
                // GCSuspendPending and UserSuspendPending both use the SafeEvent.
                // We are inside the protection of the ThreadStore lock in both
                // cases.  But don't let one use interfere with the other:
                if ((m_State & TS_GCSuspendPending) == 0)
                    ClearSafeEvent();
    
                // Thread is executing in cooperative mode.  We're going to have to
                // move it to a safe spot.
                MarkForSuspension(TS_UserSuspendPending);
    
                // Let the thread run until it reaches a safe spot.
                ::ResumeThread(GetThreadHandle());
    
                // wait until it leaves cooperative GC mode or is JIT suspended
                FinishSuspendingThread();
            }
        }
    }
    else
    {
        // first suspension of the current thread
        BOOL    ToggleGC = PreemptiveGCDisabled();

        if (ToggleGC)
            EnablePreemptiveGC();

        ClearSuspendEvent();
        MarkForSuspension(TS_UserSuspendPending);

        // prepare to block ourselves
        ThreadStore::UnlockThreadStore();
        mustUnlock = FALSE;
        _ASSERTE(!ThreadStore::HoldingThreadStore(this));

        WaitSuspendEvent();

        if (ToggleGC)
            DisablePreemptiveGC();
    }

    if (mustUnlock)
        ThreadStore::UnlockThreadStore();
}


// if the only suspension of this thread is user imposed, resume it.  But don't
// resume from any system suspensions (like GC).
BOOL Thread::UserResumeThread()
{
    // If we are attempting to resume when we aren't in a user suspension,
    // its an error.
    BOOL    res = FALSE;

    // Note that the model does not count.  In other words, you can call Thread.Suspend()
    // five times and Thread.Resume() once.  The result is that the thread resumes.

    STRESS_LOG0(LF_SYNC, INFO3, "UserResumeThread obtain lock\n");
    ThreadStore::LockThreadStore();

    // If we have marked a thread for suspension, while that thread is still starting
    // up, simply remove the bit to resume it.
    if (m_State & TS_SuspendUnstarted)
    {
        _ASSERTE((m_State & TS_UserSuspendPending) == 0);
        FastInterlockAnd((ULONG *) &m_State, ~TS_SuspendUnstarted);
        res = TRUE;
    }

    // If we are still trying to suspend the thread, forget about it.
    if (m_State & TS_UserSuspendPending)
    {
        UnmarkForSuspension(~TS_UserSuspendPending);
        SetSuspendEvent();
        SetSafeEvent();
        res = TRUE;
    }

    ThreadStore::UnlockThreadStore();
    return res;
}


// We are asynchronously trying to suspend this thread.  Stay here until we achieve
// that goal (in fully interruptible JIT code), or the thread dies, or it leaves
// the EE (in which case the Pending flag will cause it to synchronously suspend
// itself later, or if the thread tells us it is going to synchronously suspend
// itself because of hijack activity, etc.
void Thread::FinishSuspendingThread()
{
    DWORD   res;

    // There are two threads of interest -- the current thread and the thread we are
    // going to wait for.  Since the current thread is about to wait, it's important
    // that it be in preemptive mode at this time.

#if _DEBUG
    DWORD   dbgTotalTimeout = 0;
#endif

    // Wait for us to enter the ping period, then check if we are in interruptible
    // JIT code.
    while (TRUE)
    {
        ThreadStore::UnlockThreadStore();
        res = ::WaitForSingleObject(m_SafeEvent, PING_JIT_TIMEOUT);
        STRESS_LOG0(LF_SYNC, INFO3, "FinishSuspendingThread obtain lock\n");
        ThreadStore::LockThreadStore();

        if (res == WAIT_TIMEOUT)
        {
#ifdef _DEBUG
            if ((dbgTotalTimeout += PING_JIT_TIMEOUT) >= DETECT_DEADLOCK_TIMEOUT)
            {
                _ASSERTE(!"Timeout detected trying to synchronously suspend a thread");
                dbgTotalTimeout = 0;
            }
#endif
            // Suspend the thread and see if we are in interruptible code (placing
            // a hijack if warranted).
        RetrySuspension:
            DWORD dwSuspendCount = ::SuspendThread(GetThreadHandle());

            if (m_fPreemptiveGCDisabled && dwSuspendCount != -1)
            {
                if (HandledJITCase())
                {

                    _ASSERTE(m_State & TS_UserSuspendPending);
                    // Redirect thread so we can capture a good thread context
                    // (GetThreadContext is not sufficient, due to an OS bug).
                    // If we don't succeed (should only happen on Win9X, due to
                    // a different OS bug), we must resume the thread and try
                    // again. 
                    if (!CheckForAndDoRedirectForUserSuspend())
                    {
                        _ASSERTE(RunningOnWin95());
                        ::ResumeThread(GetThreadHandle());
                        goto RetrySuspension;
                    }
                }
                // Keep trying...
                ::ResumeThread(GetThreadHandle());
            }
            else if (dwSuspendCount != -1)
            {
                // The thread has transitioned out of the EE.  It can't get back in
                // without synchronously suspending itself.  We can now return to our
                // caller since this thread cannot make further progress within the
                // EE.
                ::ResumeThread(GetThreadHandle());
                break;
            }
        }
        else
        {
            // SafeEvent has been set so we don't need to actually suspend.  Either
            // the thread died, or it will enter a synchronous suspension based on
            // the UserSuspendPending bit.
            _ASSERTE(res == WAIT_OBJECT_0);
            _ASSERTE(!ThreadStore::HoldingThreadStore(this));
            break;
        }
    }
}


void Thread::SetSafeEvent()
{
        if (m_SafeEvent != INVALID_HANDLE_VALUE)
                ::SetEvent(m_SafeEvent);
}


void Thread::ClearSafeEvent()
{
    _ASSERTE(g_fProcessDetach || ThreadStore::HoldingThreadStore());
    ::ResetEvent(m_SafeEvent);
}


void Thread::SetSuspendEvent()
{
    FastInterlockAnd((ULONG *) &m_State, ~TS_SyncSuspended);
    ::SetEvent(m_SuspendEvent);
}


void Thread::ClearSuspendEvent()
{
    ::ResetEvent(m_SuspendEvent);
}

// There's a bit of a hack here
void Thread::WaitSuspendEvent(BOOL fDoWait)
{
    _ASSERTE(!PreemptiveGCDisabled());
    _ASSERTE((m_State & TS_SyncSuspended) == 0);

    // Let us do some useful work before suspending ourselves.

    // If we're required to perform a wait, do so.  Typically, this is
    // skipped if this thread is a Debugger Special Thread.
    if (fDoWait)
    {
        //
        // We set these bits so that we can make a reasonable statement
        // about the state of the thread for COM+ users. We don't really
        // use these for synchronizaiton or control.
        //
        FastInterlockOr((ULONG *) &m_State, TS_SyncSuspended);

        ::WaitForSingleObject(m_SuspendEvent, INFINITE);

        // Bits are reset right here so that we can report our state properly.
        FastInterlockAnd((ULONG *) &m_State, ~TS_SyncSuspended);
    }
}


//
// InitRegDisplay: initializes a REGDISPLAY for a thread. If validContext
// is false, pRD is filled from the current context of the thread. The
// thread's current context is also filled in pctx. If validContext is true,
// pctx should point to a valid context and pRD is filled from that.
//
bool Thread::InitRegDisplay(const PREGDISPLAY pRD, PCONTEXT pctx,
                            bool validContext)
{
#ifdef _X86_
    if (!validContext)
    {
        if (GetFilterContext() != NULL)
            pctx = GetFilterContext();
        else
        {
            pctx->ContextFlags = CONTEXT_FULL;

            BOOL ret = EEGetThreadContext(this, pctx);
            if (!ret)
            {
                pctx->Eip = 0;
                pRD->pPC  = (SLOT*)&(pctx->Eip);

                return false;
            }
        }
    }

    pRD->pContext = pctx;

    pRD->pEdi = &(pctx->Edi);
    pRD->pEsi = &(pctx->Esi);
    pRD->pEbx = &(pctx->Ebx);
    pRD->pEbp = &(pctx->Ebp);
    pRD->pEax = &(pctx->Eax);
    pRD->pEcx = &(pctx->Ecx);
    pRD->pEdx = &(pctx->Edx);
    pRD->Esp = pctx->Esp;
    pRD->pPC  = (SLOT*)&(pctx->Eip);

    return true;

#else // !_X86_
    _ASSERTE(!"@TODO Alpha - InitRegDisplay (Threads.cpp)");
    return false;
#endif // _X86_
}


// Access the base and limit of this stack.  (I.e. the memory ranges that the thread
// has reserved for its stack).
//
// Note that we only have to check against the thread we are currently crawling.  It
// would be illegal for us to have a ByRef from someone else's stack.  And this will
// be asserted if we pass this reference to the heap as a potentially interior pointer.
//
// But the thread we are currently crawling is not the currently executing thread (in
// the general case).  We rely on fragile caching of the interesting thread, in a
// call to UpdateCachedStackInfo(), which happens as we start a crawl in GcScanRoots().
//
/*static*/ void *Thread::GetNonCurrentStackBase(ScanContext *sc)
{
    _ASSERTE(sc->thread_under_crawl->m_CacheStackBase != 0);
    return sc->thread_under_crawl->m_CacheStackBase;
}

/*static*/ void *Thread::GetNonCurrentStackLimit(ScanContext *sc)
{
    _ASSERTE(sc->thread_under_crawl->m_CacheStackLimit != 0);
    return sc->thread_under_crawl->m_CacheStackLimit;
}

void Thread::UpdateCachedStackInfo(ScanContext *sc)
{
    sc->thread_under_crawl = this;
}


//                      Trip Functions
//                      ==============
// When a thread reaches a safe place, it will rendezvous back with us, via one of
// the following trip functions:

void __cdecl CommonTripThread()
{
    THROWSCOMPLUSEXCEPTION();

    Thread  *thread = GetThread();
    TRIGGERSGC();

    thread->HandleThreadAbort ();
    
    if (thread->CatchAtSafePoint() && !g_fFinalizerRunOnShutDown)
    {
        _ASSERTE(!ThreadStore::HoldingThreadStore(thread));
        thread->UnhijackThread();

        // Give stopping a thread preference over suspending it (obviously).
        // Give stopping a thread preference over starting a GC, because we will
        // have one less stack to crawl.
        if ((thread->m_PreventAsync == 0) &&
            (thread->m_State & Thread::TS_StopRequested) != 0)
        {
            thread->ResetStopRequest();
            if (!(thread->m_State & Thread::TS_AbortRequested))
                    COMPlusThrow(kThreadStopException);
            // else must be a thread abort. Check that we are not already processing an abort
            // and that there are no pending exceptions
            if (!(thread->m_State & Thread::TS_AbortInitiated) &&   
                    (thread->GetThrowable() == NULL))
            {
                thread->SetAbortInitiated();
                COMPlusThrow(kThreadAbortException);
            }
        }
        // Trap
        thread->PulseGCMode();
    }
}


// A stub is returning an ObjectRef to its caller
void * __cdecl OnStubObjectWorker(OBJECTREF oref)
{
    void    *retval;

    GCPROTECT_BEGIN(oref)
    {
#ifdef _DEBUG
        BOOL GCOnTransition = FALSE;
        if (g_pConfig->FastGCStressLevel()) {
            GCOnTransition = GC_ON_TRANSITIONS (FALSE);
        }
#endif
        CommonTripThread();
#ifdef _DEBUG
        if (g_pConfig->FastGCStressLevel()) {
            GC_ON_TRANSITIONS (GCOnTransition);
        }
#endif

        // we can't return an OBJECTREF, or in the checked build it will return a
        // struct as a secret argument.
        retval = *((void **) &oref);
    }
    GCPROTECT_END();        // trashes oref here!

    return retval;
}


#ifndef _ALPHA_ // Alpha doesn't understand naked
__declspec(naked)
#endif // _ALPHA_
VOID OnStubObjectTripThread()
{
#ifdef _X86_
    __asm
    {
        push    eax         // pass the OBJECTREF
        call    OnStubObjectWorker
        add     esp, 4      // __cdecl
        ret
    }
    // returns with the OBJECTREF in EAX after the GC
#else // !_X86_
    _ASSERTE(!"@TODO Alpha - OnStubObjectTripThread (Threads.cpp)");
#endif // _X86_
}


// A stub is returning an ObjectRef to its caller
void * __cdecl OnStubInteriorPointerWorker(void* addr)
{
    void    *retval;

    GCPROTECT_BEGININTERIOR(addr)
    {
#ifdef _DEBUG
        BOOL GCOnTransition = FALSE;
        if (g_pConfig->FastGCStressLevel()) {
            GCOnTransition = GC_ON_TRANSITIONS (FALSE);
        }
#endif
        CommonTripThread();
#ifdef _DEBUG
        if (g_pConfig->FastGCStressLevel()) {
            GC_ON_TRANSITIONS (GCOnTransition);
        }
#endif

        // we can't return an OBJECTREF, or in the checked build it will return a
        // struct as a secret argument.
        retval = addr;
    }
    GCPROTECT_END();        // trashes oref here!

    return retval;
}


#ifndef _ALPHA_ // Alpha doesn't understand naked
__declspec(naked)
#endif // _ALPHA_
VOID OnStubInteriorPointerTripThread()
{
#ifdef _X86_
    __asm
    {
        push    eax         // pass the byref pointer
        call    OnStubInteriorPointerWorker
        add     esp, 4      // __cdecl
        ret
    }
    // returns with the byref pointer in EAX after the GC
#else // !_X86_
    _ASSERTE(!"@TODO Alpha - OnStubInteriorPointerTripThread (Threads.cpp)");
#endif // _X86_
}


// A stub is returning something other than an ObjectRef to its caller
// @TODO cwb: floating point args on the FPU are not handled.
VOID OnStubScalarTripThread()
{
#ifdef _X86_
    INT32   hi, lo;

    __asm
    {
        mov     [lo], eax;
        mov     [hi], edx;
    }

#ifdef _DEBUG
    BOOL GCOnTransition;
    if (g_pConfig->FastGCStressLevel()) {
        GCOnTransition = GC_ON_TRANSITIONS (FALSE);
    }
#endif
    CommonTripThread();
#ifdef _DEBUG
    if (g_pConfig->FastGCStressLevel()) {
        GC_ON_TRANSITIONS (GCOnTransition);
    }
#endif

    __asm
    {
        mov     eax, [lo]
        mov     edx, [hi]
    }
#else // !_X86_
    _ASSERTE(!"@TODO Alpha - OnStubScalarTripThread (Threads.cpp)");
#endif // _X86_
}


//
// Either the interpreter is executing a break opcode or a break instruction
// has been caught by the exception handling. In either case, we want to
// have this thread wait before continuing to execute. We do this with a
// PulseGCMode, which will trip the tread and leave it waiting on its suspend
// event. This case does not call CommonTripThread because we don't want
// to give the thread the chance to exit or otherwise suspend itself.
//
VOID OnDebuggerTripThread(void)
{
    Thread  *thread = GetThread();

    if (thread->m_State & thread->TS_DebugSuspendPending)
    {
        _ASSERTE(!ThreadStore::HoldingThreadStore(thread));
        thread->PulseGCMode();
    }
}


//                      Hijacking JITted calls
//                      ======================

// State of execution when we suspend a thread
struct ExecutionState
{
    BOOL            m_FirstPass;
    BOOL            m_IsJIT;            // are we executing JITted code?
    MethodDesc   *m_pFD;              // current function/method we're executing
    VOID          **m_ppvRetAddrPtr;    // pointer to return address in frame
    DWORD           m_RelOffset;        // relative offset at which we're currently executing in this fcn
    IJitManager    *m_pJitManager;  
    METHODTOKEN     m_MethodToken;
    BOOL            m_IsInterruptible;  // is this code interruptible?

    ExecutionState() : m_FirstPass(TRUE) { }
};


// Client is responsible for suspending the thread before calling
void Thread::HijackThread(VOID *pvHijackAddr, ExecutionState *esb)
{

#ifdef _DEBUG
    static int  EnterCount = 0;
    _ASSERTE(EnterCount++ == 0);
#endif

    // Don't hijack if are in the first level of running a filter/finally/catch.
    // This is because they share ebp with their containing function further down the
    // stack and we will hijack their containing function incorrectly
    if (IsInFirstFrameOfHandler(this, esb->m_pJitManager, esb->m_MethodToken, esb->m_RelOffset))
    {
        _ASSERTE(--EnterCount == 0);
        return;
    }

    IS_VALID_CODE_PTR((FARPROC) pvHijackAddr);

    if (m_State & TS_Hijacked)
        UnhijackThread();

    // Obtain the location of the return address in the currently executing stack frame
    m_ppvHJRetAddrPtr = esb->m_ppvRetAddrPtr;

    // Remember the place that the return would have gone
    m_pvHJRetAddr = *esb->m_ppvRetAddrPtr;

    _ASSERTE(isLegalManagedCodeCaller(m_pvHJRetAddr));
    STRESS_LOG1(LF_SYNC, LL_INFO100, "Hijacking return address 0x%x\n", m_pvHJRetAddr);

    // Remember the method we're executing
    m_HijackedFunction = esb->m_pFD;

    // Bash the stack to return to one of our stubs
    *esb->m_ppvRetAddrPtr = pvHijackAddr;
    FastInterlockOr((ULONG *) &m_State, TS_Hijacked);

#ifdef _DEBUG
    _ASSERTE(--EnterCount == 0);
#endif
}


// Client is responsible for suspending the thread before calling
void Thread::UnhijackThread()
{
    if (m_State & TS_Hijacked)
    {
        IS_VALID_WRITE_PTR(m_ppvHJRetAddrPtr, sizeof(DWORD));
        IS_VALID_CODE_PTR((FARPROC) m_pvHJRetAddr);

        // Can't make the following assertion, because sometimes we unhijack after
        // the hijack has tripped (i.e. in the case we actually got some value from
        // it.
//       _ASSERTE(*m_ppvHJRetAddrPtr == OnHijackObjectTripThread ||
//                *m_ppvHJRetAddrPtr == OnHijackScalarTripThread);

        // restore the return address and clear the flag
        *m_ppvHJRetAddrPtr = m_pvHJRetAddr;
        FastInterlockAnd((ULONG *) &m_State, ~TS_Hijacked);

        // But don't touch m_pvHJRetAddr.  We may need that to resume a thread that
        // is currently hijacked!
    }
}


// Get the ExecutionState for the specified *SUSPENDED* thread.  Note that this is
// a 'StackWalk' call back (PSTACKWALKFRAMESCALLBACK).
StackWalkAction SWCB_GetExecutionState(CrawlFrame *pCF, VOID *pData)
{
    ExecutionState  *pES = (ExecutionState *) pData;
    StackWalkAction  action = SWA_ABORT;

    if (pES->m_FirstPass)
    {
        // If we're jitted code at the top of the stack, grab everything
        if (pCF->IsFrameless() && pCF->IsActiveFunc())
        {
#if defined(STRESS_HEAP) && defined(_DEBUG)
                // I have not decided if this is a hack or not.  The problem
                // is that there is a bug in SetThreadContext.  When an async
                // exception happens, the state is saved, but that state is 
                // not updated by 'SetThreadContext'.  We can work around this
                // for GCStress 4 by making believe that if we are at the halt
                // instruction that we are really in the handler (and not in 
                // jitted code).  
            if (g_pConfig->GetGCStressLevel() & EEConfig::GCSTRESS_INSTR) {
                BYTE* instrPtr = (BYTE*) (*pCF->GetRegisterSet()->pPC);
                if (*instrPtr == 0xF4 || *instrPtr == 0xFA || *instrPtr == 0xFB) {
                    pES->m_IsJIT = FALSE;
                    return(action);
                }
            }
#endif

            pES->m_IsJIT = TRUE;
            pES->m_pFD = pCF->GetFunction();
            pES->m_MethodToken = pCF->GetMethodToken();
            pES->m_ppvRetAddrPtr = 0;
            pES->m_IsInterruptible = pCF->IsGcSafe();
            pES->m_RelOffset = pCF->GetRelOffset();
            pES->m_pJitManager = pCF->GetJitManager();

            STRESS_LOG3(LF_SYNC, LL_INFO1000, "Stopped in Jitted code at EIP = %x ESP = %x fullyInt=%d\n", 
                (*pCF->GetRegisterSet()->pPC), pCF->GetRegisterSet()->Esp, pES->m_IsInterruptible);

            // if we're not interruptible right here, we need to determine the
            // return address for hijacking.
            if (!pES->m_IsInterruptible)
            {
                // peel off the next frame to expose the return address on the stack
                pES->m_FirstPass = FALSE;
                action = SWA_CONTINUE;
            }
            // else we are successfully out of here with SWA_ABORT
        }
        else
        {
            STRESS_LOG2(LF_SYNC, LL_INFO1000, "Not in Jitted code at EIP = %x, &EIP = %x\n", 
                *pCF->GetRegisterSet()->pPC, pCF->GetRegisterSet()->pPC);

            // Not JITted case:
            pES->m_IsJIT = FALSE;
#ifdef _DEBUG
            pES->m_pFD = (MethodDesc *)POISONC;
            pES->m_ppvRetAddrPtr = (void **)POISONC;
            pES->m_IsInterruptible = FALSE;
#endif
        }
    }
    else
    {
        // Second pass, looking for the address of the return address so we can
        // hijack:

        PREGDISPLAY     pRDT = pCF->GetRegisterSet();

        if (pRDT != NULL)
        {
            // pPC points to the return address sitting on the stack, as our
            // current EIP for the penultimate stack frame.
            pES->m_ppvRetAddrPtr = (void **) pRDT->pPC;

            STRESS_LOG2(LF_SYNC, LL_INFO1000, "Partially Int case hijack address = 0x%x val = 0x%x\n", pRDT->pPC, *pRDT->pPC);
        }
    }

    return action;
}

void Thread::SetFilterContext(CONTEXT *pContext) 
{ 
    m_debuggerWord1 = pContext;
}

CONTEXT *Thread::GetFilterContext(void)
{
   return (CONTEXT*)m_debuggerWord1;
}

void Thread::SetDebugCantStop(bool fCantStop) 
{ 
    if (fCantStop)
    {
        m_debuggerCantStop++;
    }
    else
    {
        m_debuggerCantStop--;
    }
}

bool Thread::GetDebugCantStop(void) 
{
    return m_debuggerCantStop != 0;
}

// Called while the thread is suspended.  If we aren't in JITted code, this isn't
// a JITCase and we return FALSE.  If it is a JIT case and we are in interruptible
// code, then we are handled.  Our caller has found a good spot and can keep us
// suspended.  If we aren't in interruptible code, then we aren't handled.  So we
// pick a spot to hijack the return address and our caller will wait to get us
// somewhere safe.
BOOL Thread::HandledJITCase()
{
    BOOL            ret = FALSE;
    ExecutionState  esb;
    StackWalkAction action;

    // We are never in interruptible code if there if a filter context put in place by the debugger.
    if (GetFilterContext() != NULL)
        return FALSE;

    // If we are running under the control of a managed debugger that may have placed breakpoints in the code stream,
    // then there is a special case that we need to check. See the comments in debugger.cpp for more information.
    if (CORDebuggerAttached() && (g_pDebugInterface->IsThreadContextInvalid(this)))
        return FALSE;

    // Walk one or two frames of the stack...    
    CONTEXT ctx;
    REGDISPLAY rd;

    if (!InitRegDisplay(&rd, &ctx, FALSE))
        return FALSE;

    action = StackWalkFramesEx(&rd, SWCB_GetExecutionState, &esb, QUICKUNWIND, NULL);
    
    //
    // action should either be SWA_ABORT, in which case we properly walked
    // the stack frame and found out wether this is a JIT case, or
    // SWA_FAILED, in which case the walk couldn't even be started because
    // there are no stack frames, which also isn't a JIT case.
    //
    if (action == SWA_ABORT && esb.m_IsJIT)
    {
        // If we are interrzuptible and we are in cooperative mode, our caller can
        // just leave us suspended.
        if (esb.m_IsInterruptible && m_fPreemptiveGCDisabled)
        {
            _ASSERTE(!ThreadStore::HoldingThreadStore(this));
            ret = TRUE;
        }
        else
        if (esb.m_ppvRetAddrPtr)
        {
            // we need to hijack the return address.  Base this on whether or not
            // the method returns an object reference, so we know whether to protect
            // it or not.
            VOID *pvHijackAddr = OnHijackScalarTripThread;
            if (esb.m_pFD)
            {
                MethodDesc::RETURNTYPE type = esb.m_pFD->ReturnsObject();
                if (type == MethodDesc::RETOBJ)
                    pvHijackAddr = OnHijackObjectTripThread;
                else if (type == MethodDesc::RETBYREF)
                    pvHijackAddr = OnHijackInteriorPointerTripThread;
            }
            
            HijackThread(pvHijackAddr, &esb);
        }
    }
    // else it's not even a JIT case

    STRESS_LOG1(LF_SYNC, LL_INFO10000, "    HandledJitCase returning %d\n", ret);
    return ret;
}


#ifdef _X86_

struct HijackArgs
{
    DWORD Edi;
    DWORD Esi;
    DWORD Ebx;
    DWORD Edx;
    DWORD Ecx;
    DWORD Eax;

    DWORD Ebp;
    DWORD Eip;
};

struct HijackObjectArgs : public HijackArgs
{
};
struct HijackScalarArgs : public HijackArgs
{
};


// A JITted method's return address was hijacked to return to us here.  What we do
// is make a __cdecl call with 2 ints.  One is the return value we wish to preserve.
// The other is space for our real return address.
__declspec(naked) VOID OnHijackObjectTripThread()
{
    __asm
    {
        // Don't fiddle with this unless you change HijackFrame::UpdateRegDisplay
        // and HijackObjectArgs
        push    eax         // make room for the real return address (Eip)
        push    ebp
        push    eax
        push    ecx
        push    edx
        push    ebx
        push    esi
        push    edi
        call    OnHijackObjectWorker  // this is OK on WinCE, where __cdecl == __stdcall
        pop     edi
        pop     esi
        pop     ebx
        pop     edx
        pop     ecx
        pop     eax
        pop     ebp
        ret                 // return to the correct place, adjusted by our caller
    }
}

__declspec(naked) VOID OnHijackInteriorPointerTripThread()
{
    __asm
    {
        // Don't fiddle with this unless you change HijackFrame::UpdateRegDisplay
        // and HijackObjectArgs
        push    eax         // make room for the real return address (Eip)
        push    ebp
        push    eax
        push    ecx
        push    edx
        push    ebx
        push    esi
        push    edi
        call    OnHijackInteriorPointerWorker  // this is OK on WinCE, where __cdecl == __stdcall
        pop     edi
        pop     esi
        pop     ebx
        pop     edx
        pop     ecx
        pop     eax
        pop     ebp
        ret                 // return to the correct place, adjusted by our caller
    }
}

// @TODO -- fpu support.
__declspec(naked) VOID OnHijackScalarTripThread()
{
    __asm
    {
        // Don't fiddle with this unless you change HijackFrame::UpdateRegDisplay
        // and HijackScalarArgs
        push    eax         // make room for the real return address (Eip)
        push    ebp
        push    eax
        push    ecx
        push    edx
        push    ebx
        push    esi
        push    edi
        call    OnHijackScalarWorker
        pop     edi
        pop     esi
        pop     ebx
        pop     edx
        pop     ecx
        pop     eax
        pop     ebp
        ret                 // return to the correct place, adjusted by our caller
    }
}

// The HijackFrame has to know the registers that are pushed by OnHijackObjectTripThread
// and OnHijackScalarTripThread, so all three are implemented together.
void HijackFrame::UpdateRegDisplay(const PREGDISPLAY pRD)
{
    // This only describes the top-most frame
    pRD->pContext = NULL;

    pRD->pEdi = &m_Args->Edi;
    pRD->pEsi = &m_Args->Esi;
    pRD->pEbx = &m_Args->Ebx;
    pRD->pEdx = &m_Args->Edx;
    pRD->pEcx = &m_Args->Ecx;
    pRD->pEax = &m_Args->Eax;
    
    pRD->pEbp = &m_Args->Ebp;
    pRD->pPC  = (SLOT*)&m_Args->Eip;
    pRD->Esp  = (DWORD)(size_t)pRD->pPC + (DWORD)sizeof(void *);
}

#else   // not _X86_

// @TODO -- this isn't going to correctly preserve the return value from the method
// we are trapping.

struct HijackArgs
{
};
struct HijackObjectArgs : public HijackArgs
{
};
struct HijackScalarArgs : public HijackArgs
{
};

VOID OnHijackObjectTripThread()
{
    _ASSERTE(!"Non-X86 platforms not handled yet.");
    CommonTripThread();
}

// @TODO -- fpu support.
VOID OnHijackScalarTripThread()
{
    _ASSERTE(!"Non-X86 platforms not handled yet.");
    CommonTripThread();
}

VOID OnHijackInteriorPointerTripThread()
{
    _ASSERTE(!"Non-X86 platforms not handled yet.");
    CommonTripThread();
}

void HijackFrame::UpdateRegDisplay(const PREGDISPLAY pRD)
{
    _ASSERTE(!"Non-X86 platforms not handled yet.");
}

#endif


HijackFrame::HijackFrame(LPVOID returnAddress, Thread *thread, HijackArgs *args)
           : m_ReturnAddress(returnAddress),
             m_Thread(thread),
             m_Args(args)
{
    _ASSERTE(m_Thread == GetThread());

    m_Next = m_Thread->GetFrame();
    m_Thread->SetFrame(this);
}


// A hijacked method is returning an ObjectRef to its caller.  Note that we bash the
// return address as an int on the stack.  Since this is cdecl, our caller gets the
// bashed value.  This is not intuitive for C programmers!
void __cdecl OnHijackObjectWorker(HijackObjectArgs args)
{
#ifdef _X86_
    Thread         *thread = GetThread();
    OBJECTREF       or(ObjectToOBJECTREF(*(Object **) &args.Eax));

    FastInterlockAnd((ULONG *) &thread->m_State, ~Thread::TS_Hijacked);

    // Fix up our caller's stack, so it can resume from the hijack correctly
    args.Eip = (DWORD)(size_t)thread->m_pvHJRetAddr;

    // Build a frame so that stack crawling can proceed from here back to where
    // we will resume execution.
    HijackFrame     frame((void *)(size_t)args.Eip, thread, &args);

    GCPROTECT_BEGIN(or)
    {
#ifdef _DEBUG
        BOOL GCOnTransition = FALSE;
        if (g_pConfig->FastGCStressLevel()) {
            GCOnTransition = GC_ON_TRANSITIONS (FALSE);
        }
#endif
        CommonTripThread();
#ifdef _DEBUG
        if (g_pConfig->FastGCStressLevel()) {
            GC_ON_TRANSITIONS (GCOnTransition);
        }
#endif
        *((OBJECTREF *) &args.Eax) = or;
    }
    GCPROTECT_END();        // trashes or here!

    frame.Pop();
#elif defined(CHECK_PLATFORM_BUILD)
    #error "Platform NYI"
#else
    _ASSERTE(!"Platform NYI");
#endif
}


// A hijacked method is returning a BYREF to its caller.  Note that we bash the
// return address as an int on the stack.  Since this is cdecl, our caller gets the
// bashed value.  This is not intuitive for C programmers!
void __cdecl OnHijackInteriorPointerWorker(HijackObjectArgs args)
{
#ifdef _X86_
    Thread         *thread = GetThread();
    void* ptr = (void*)(size_t)(args.Eax);

    FastInterlockAnd((ULONG *) &thread->m_State, ~Thread::TS_Hijacked);

    // Fix up our caller's stack, so it can resume from the hijack correctly
    args.Eip = (DWORD)(size_t)thread->m_pvHJRetAddr;

    // Build a frame so that stack crawling can proceed from here back to where
    // we will resume execution.
    HijackFrame     frame((void *)(size_t)args.Eip, thread, &args);

    GCPROTECT_BEGININTERIOR(ptr)
    {
#ifdef _DEBUG
        BOOL GCOnTransition = FALSE;
        if (g_pConfig->FastGCStressLevel()) {
            GCOnTransition = GC_ON_TRANSITIONS (FALSE);
        }
#endif
        CommonTripThread();
#ifdef _DEBUG
        if (g_pConfig->FastGCStressLevel()) {
            GC_ON_TRANSITIONS (GCOnTransition);
        }
#endif
        args.Eax = (DWORD)(size_t)ptr;
    }
    GCPROTECT_END();        // trashes or here!

    frame.Pop();
#elif defined(CHECK_PLATFORM_BUILD)
    #error "Platform NYI"
#else
    _ASSERTE(!"Platform NYI");
#endif
}


// A hijacked method is returning a scalar to its caller.  Note that we bash the
// return address as an int on the stack.  Since this is cdecl, our caller gets the
// bashed value.  This is not intuitive for C programmers!
void __cdecl OnHijackScalarWorker(HijackScalarArgs args)
{
#ifdef _X86_
    Thread         *thread = GetThread();

    FastInterlockAnd((ULONG *) &thread->m_State, ~Thread::TS_Hijacked);

    // Fix up our caller's stack, so it can resume from the hijack correctly
    args.Eip = (DWORD)(size_t)thread->m_pvHJRetAddr;

    // Build a frame so that stack crawling can proceed from here back to where
    // we will resume execution.
    HijackFrame     frame((void *)(size_t)args.Eip, thread, &args);

#ifdef _DEBUG
    BOOL GCOnTransition = FALSE;
    if (g_pConfig->FastGCStressLevel()) {
        GCOnTransition = GC_ON_TRANSITIONS (FALSE);
    }
#endif
    CommonTripThread();
#ifdef _DEBUG
    if (g_pConfig->FastGCStressLevel()) {
        GC_ON_TRANSITIONS (GCOnTransition);
    }
#endif

    frame.Pop();
#elif defined(CHECK_PLATFORM_BUILD)
    #error "Platform NYI"
#else
    _ASSERTE(!"Platform NYI");
#endif
}


#ifdef _DEBUG
VOID Thread::ValidateThrowable()
{
    OBJECTREF throwable = GetThrowable();
    if (throwable != NULL)
    {
        EEClass* pClass = throwable->GetClass();
        while (pClass != NULL)
        {
            if (pClass == g_pExceptionClass->GetClass())
            {
                return;
            }
            pClass = pClass->GetParentClass();
        }
    }
}
#endif


// Some simple helpers to keep track of the threads we are waiting for
void Thread::MarkForSuspension(ULONG bit)
{
    _ASSERTE(bit == TS_DebugSuspendPending ||
             bit == (TS_DebugSuspendPending | TS_DebugWillSync) ||
             bit == TS_UserSuspendPending);

    _ASSERTE(g_fProcessDetach || g_fRelaxTSLRequirement || ThreadStore::HoldingThreadStore());

    _ASSERTE((m_State & bit) == 0);

    FastInterlockOr((ULONG *) &m_State, bit);
    ThreadStore::TrapReturningThreads(TRUE);
}

void Thread::UnmarkForSuspension(ULONG mask)
{
    _ASSERTE(mask == ~TS_DebugSuspendPending ||
             mask == ~TS_UserSuspendPending);

    _ASSERTE(g_fProcessDetach || g_fRelaxTSLRequirement || ThreadStore::HoldingThreadStore());

    _ASSERTE((m_State & ~mask) != 0);

    FastInterlockAnd((ULONG *) &m_State, mask);
    ThreadStore::TrapReturningThreads(FALSE);
}

void Thread::SetExposedContext(Context *c)
{
    // Set the ExposedContext ... 
    
    // Note that we use GetxxRaw() here to cover our bootstrap case 
    // for AppDomain proxy creation
    // Leaving the exposed object NULL lets us create the default
    // managed context just before we marshal a new AppDomain in 
    // RemotingServices::CreateProxyForDomain.
    
    Thread* pThread = GetThread();
    if (!pThread)
        return;

    BEGIN_ENSURE_COOPERATIVE_GC();

    if(m_ExposedObject != NULL) {
        THREADBASEREF threadObj = (THREADBASEREF) ObjectFromHandle(m_ExposedObject);
        if(threadObj != NULL)
        if (!c)
            threadObj->SetExposedContext(NULL);
        else
            threadObj->SetExposedContext(c->GetExposedObjectRaw());
    
    }

    END_ENSURE_COOPERATIVE_GC();
}


void Thread::InitContext()
{
    // this should only be called when initializing a thread
    _ASSERTE(m_Context == NULL);
    _ASSERTE(m_pDomain == NULL);

    m_Context = SystemDomain::System()->DefaultDomain()->GetDefaultContext();
    SetExposedContext(m_Context);
    m_pDomain = m_Context->GetDomain();
    _ASSERTE(m_pDomain);
    m_pDomain->ThreadEnter(this, NULL);
}

void Thread::ClearContext()
{
    // if one is null, both must be
    _ASSERTE(m_pDomain && m_Context || ! (m_pDomain && m_Context));

    if (!m_pDomain)
        return;

    m_pDomain->ThreadExit(this, NULL);

    // must set exposed context to null first otherwise object verification
    // checks will fail AV when m_Context is null
    SetExposedContext(NULL);
    m_pDomain = NULL;
    m_Context = NULL;
    m_ADStack.ClearDomainStack();
}

// If we are entering from default context of default domain, we do not enter
// pContext as requested by the caller. Instead we enter the default context of the target
// domain and let the actuall call perform the context transition if any. This is done to
// prevent overhead of app-domain transition for thread-pool threads that actually have no domain to start with
void Thread::DoADCallBack(Context *pContext, LPVOID pTarget, LPVOID args)
{
    THROWSCOMPLUSEXCEPTION();

#ifdef _DEBUG
    int espVal;
    _asm mov espVal, esp

    LOG((LF_APPDOMAIN, LL_INFO100, "Thread::DoADCallBack Calling %8.8x at esp %8.8x in [%d]\n", 
            pTarget, espVal, pContext->GetDomain()->GetId()));
#endif
    _ASSERTE(GetThread()->GetContext() != pContext);
    Thread* pThread  = GetThread();

    if (pThread->GetContext() == SystemDomain::System()->DefaultDomain()->GetDefaultContext())
    {
        // use the target domain's default context as the target context
        // so that the actual call to a transparent proxy would enter the object into the correct context.
        Context* newContext = pContext->GetDomain()->GetDefaultContext();
        _ASSERTE(newContext);
        DECLARE_ALLOCA_CONTEXT_TRANSITION_FRAME(pFrame);
        pThread->EnterContext(newContext, pFrame, TRUE);
         ((Context::ADCallBackFcnType)pTarget)(args);
        // unloadBoundary is cleared by ReturnToContext, so get it now.
        Frame *unloadBoundaryFrame = pThread->GetUnloadBoundaryFrame();
        pThread->ReturnToContext(pFrame, TRUE);            

        // if someone caught the abort before it got back out to the AD transition (like DispatchEx_xxx does) 
        // then need to turn the abort into an unload, as they're gonna keep seeing it anyway
        if (pThread->ShouldChangeAbortToUnload(pFrame, unloadBoundaryFrame))
        {
            LOG((LF_APPDOMAIN, LL_INFO10, "Thread::DoADCallBack turning abort into unload\n"));
            COMPlusThrow(kAppDomainUnloadedException, L"Remoting_AppDomainUnloaded_ThreadUnwound");
        }
    }
    else
    {

        Context::ADCallBackArgs callTgtArgs = {(Context::ADCallBackFcnType)pTarget, args};
        Context::CallBackInfo callBackInfo = {Context::ADTransition_callback, (void*) &callTgtArgs};
        Context::RequestCallBack(pContext, (void*) &callBackInfo);
    }
    LOG((LF_APPDOMAIN, LL_INFO100, "Thread::DoADCallBack Done at esp %8.8x\n", espVal));
}

void Thread::EnterContext(Context *pContext, Frame *pFrame, BOOL fLinkFrame)
{
    EnterContextRestricted(pContext, pFrame, fLinkFrame);
}

void Thread::EnterContextRestricted(Context *pContext, Frame *pFrame, BOOL fLinkFrame)
{
    THROWSCOMPLUSEXCEPTION();   // Might throw OutOfMemory.

    _ASSERTE(GetThread() == this);
    _ASSERTE(pContext);     // should never enter a null context
    _ASSERTE(m_Context);    // should always have a current context    

    pFrame->SetReturnContext(m_Context);
    pFrame->SetReturnLogicalCallContext(NULL);
    pFrame->SetReturnIllogicalCallContext(NULL);

    if (m_Context == pContext) {
        _ASSERTE(m_Context->GetDomain() == pContext->GetDomain());
        return;
    }

    BEGIN_ENSURE_COOPERATIVE_GC();

    AppDomain *pDomain = pContext->GetDomain();
    // and it should always have an AD set
    _ASSERTE(pDomain);

    if (m_pDomain != pDomain && !pDomain->CanThreadEnter(this))
    {
        DEBUG_SAFE_TO_THROW_IN_THIS_BLOCK;
        pFrame->SetReturnContext(NULL);
        COMPlusThrow(kAppDomainUnloadedException);
    }


    LOG((LF_APPDOMAIN, LL_INFO1000, "%s Thread::EnterContext from (%8.8x) [%d] (count %d)\n", 
            GCHeap::IsCurrentThreadFinalizer() ? "FT:" : "",
            m_Context, m_Context->GetDomain()->GetId(), 
            m_Context->GetDomain()->GetThreadEnterCount()));
    LOG((LF_APPDOMAIN, LL_INFO1000, "                     into (%8.8x) [%d] (count %d)\n", pContext, 
                m_Context->GetDomain()->GetId(),
                pContext->GetDomain()->GetThreadEnterCount()));

#ifdef _DEBUG_ADUNLOAD
    printf("Thread::EnterContext %x from (%8.8x) [%d]\n", GetThreadId(), m_Context, 
        m_Context ? m_Context->GetDomain()->GetId() : -1);
    printf("                     into (%8.8x) [%d] %S\n", pContext, 
                pContext->GetDomain()->GetId());
#endif

    m_Context = pContext;

    if (m_pDomain != pDomain)
    {
        _ASSERTE(pFrame);

        m_ADStack.PushDomain(pDomain);

        //
        // Push logical call contexts into frame to avoid leaks
        //

        if (IsExposedObjectSet())
        {
            THREADBASEREF ref = (THREADBASEREF) ObjectFromHandle(m_ExposedObject);
            _ASSERTE(ref != NULL);
            if (ref->GetLogicalCallContext() != NULL)
            {
                pFrame->SetReturnLogicalCallContext(ref->GetLogicalCallContext());
                ref->SetLogicalCallContext(NULL);
            }

            if (ref->GetIllogicalCallContext() != NULL)
            {
                pFrame->SetReturnIllogicalCallContext(ref->GetIllogicalCallContext());
                ref->SetIllogicalCallContext(NULL);
            }
        }

        if (fLinkFrame)
        {
            pFrame->Push();

            if (pFrame->GetVTablePtr() == ContextTransitionFrame::GetMethodFrameVPtr())
            {
                ((ContextTransitionFrame *)pFrame)->InstallExceptionHandler();
            }
        }

#ifdef _DEBUG_ADUNLOAD
        printf("Thread::EnterContext %x,%8.8x push? %d current frame is %8.8x\n", GetThreadId(), this, fLinkFrame, GetFrame());
#endif

        pDomain->ThreadEnter(this, pFrame);

        // Make the static data storage point to the current domain's storage
        SetStaticData(pDomain, NULL, NULL);

        m_pDomain = pDomain;
        TlsSetValue(gAppDomainTLSIndex, (VOID*) m_pDomain);
    }

    SetExposedContext(pContext);

    // Store off the Win32 Fusion context
    //
    pFrame->SetWin32Context(NULL);
    IApplicationContext* pFusion32 = m_pDomain->GetFusionContext();
    if(pFusion32) 
    {
        ULONG_PTR cookie;
        if(SUCCEEDED(pFusion32->SxsActivateContext(&cookie))) 
            pFrame->SetWin32Context(cookie);
    }

    END_ENSURE_COOPERATIVE_GC();
}

// main difference between EnterContext and ReturnToContext is that are allowed to return
// into a domain that is unloading but cannot enter a domain that is unloading
void Thread::ReturnToContext(Frame *pFrame, BOOL fLinkFrame)
{
    CANNOTTHROWCOMPLUSEXCEPTION();

    _ASSERTE(GetThread() == this);

    Context *pReturnContext = pFrame->GetReturnContext();
    _ASSERTE(pReturnContext);

    if (m_Context == pReturnContext) 
    {
        _ASSERTE(m_Context->GetDomain() == pReturnContext->GetDomain());
        return;
    }

    //
    // Return the Win32 Fusion Context
    //
    IApplicationContext* pFusion32 = m_pDomain->GetFusionContext();
    if(pFusion32 && pFrame) {
        ULONG_PTR cookie = pFrame->GetWin32Context();
        if(cookie != NULL) 
            pFusion32->SxsDeactivateContext(cookie);
    }

    BEGIN_ENSURE_COOPERATIVE_GC();

    LOG((LF_APPDOMAIN, LL_INFO1000, "%s Thread::ReturnToContext from (%8.8x) [%d](count %d)\n", 
                GCHeap::IsCurrentThreadFinalizer() ? "FT:" : "",
                m_Context, m_Context->GetDomain()->GetId(), 
                m_Context->GetDomain()->GetThreadEnterCount()));
    LOG((LF_APPDOMAIN, LL_INFO1000, "                        into (%8.8x) [%d] (count %d)\n", pReturnContext, 
                m_Context->GetDomain()->GetId(),
                pReturnContext->GetDomain()->GetThreadEnterCount()));

#ifdef _DEBUG_ADUNLOAD
    printf("Thread::ReturnToContext %x from (%8.8x) [%d]\n", GetThreadId(), m_Context, 
                m_Context->GetDomain()->GetId(),
    printf("                        into (%8.8x) [%d]\n", pReturnContext, 
                pReturnContext->GetDomain()->GetId(),
                m_Context->GetDomain()->GetThreadEnterCount());
#endif

    m_Context = pReturnContext;
    SetExposedContext(pReturnContext);

    AppDomain *pReturnDomain = pReturnContext->GetDomain();

    if (m_pDomain != pReturnDomain)
    {

        if (fLinkFrame && pFrame->GetVTablePtr() == ContextTransitionFrame::GetMethodFrameVPtr())
        {
            ((ContextTransitionFrame *)pFrame)->UninstallExceptionHandler();
        }

        AppDomain *pADOnStack = m_ADStack.PopDomain();
        _ASSERTE(!pADOnStack || pADOnStack == m_pDomain);

        _ASSERTE(pFrame);
        //_ASSERTE(!fLinkFrame || pThread->GetFrame() == pFrame);

        // Set the static data store to point to the returning domain's store
        SafeSetStaticData(pReturnDomain, NULL, NULL);

        AppDomain *pCurrentDomain = m_pDomain;
        m_pDomain = pReturnDomain;
        TlsSetValue(gAppDomainTLSIndex, (VOID*) pReturnDomain);

        if (fLinkFrame)
        {
            if (pFrame == m_pUnloadBoundaryFrame)
                m_pUnloadBoundaryFrame = NULL;
            pFrame->Pop();
        }

        //
        // Pop logical call contexts from frame if applicable
        //

        if (IsExposedObjectSet())
        {
            THREADBASEREF ref = (THREADBASEREF) ObjectFromHandle(m_ExposedObject);
            _ASSERTE(ref != NULL);
            ref->SetLogicalCallContext(pFrame->GetReturnLogicalCallContext());
            ref->SetIllogicalCallContext(pFrame->GetReturnIllogicalCallContext());
        }

        // Do this last so that thread is not labeled as out of the domain until all cleanup is done.
        pCurrentDomain->ThreadExit(this, pFrame);

#ifdef _DEBUG_ADUNLOAD
        printf("Thread::ReturnToContext %x,%8.8x pop? %d current frame is %8.8x\n", GetThreadId(), this, fLinkFrame, GetFrame());
#endif
    }

    END_ENSURE_COOPERATIVE_GC();
    return;
}

struct FindADCallbackType {
    AppDomain *pSearchDomain;
    AppDomain *pPrevDomain;
    Frame *pFrame;
    int count;
    enum TargetTransition 
        {fFirstTransitionInto, fMostRecentTransitionInto} 
    fTargetTransition;

    FindADCallbackType() : pSearchDomain(NULL), pPrevDomain(NULL), pFrame(NULL) {}
};

StackWalkAction StackWalkCallback_FindAD(CrawlFrame* pCF, void* data)
{
    FindADCallbackType *pData = (FindADCallbackType *)data;

    Frame *pFrame = pCF->GetFrame();
    
    if (!pFrame)
        return SWA_CONTINUE;

    AppDomain *pReturnDomain = pFrame->GetReturnDomain();
    if (!pReturnDomain || pReturnDomain == pData->pPrevDomain)
        return SWA_CONTINUE;

    LOG((LF_APPDOMAIN, LL_INFO100, "StackWalkCallback_FindAD transition frame %8.8x into AD [%d]\n", 
            pFrame, pReturnDomain->GetId()));

    if (pData->pPrevDomain == pData->pSearchDomain) {
                ++pData->count;
        // this is a transition into the domain we are unloading, so save it in case it is the first
        pData->pFrame = pFrame;
        if (pData->fTargetTransition == FindADCallbackType::fMostRecentTransitionInto)
            return SWA_ABORT;   // only need to find last transition, so bail now
    }

    pData->pPrevDomain = pReturnDomain;
    return SWA_CONTINUE;
}

// This determines if a thread is running in the given domain at any point on the stack
Frame *Thread::IsRunningIn(AppDomain *pDomain, int *count)
{
    FindADCallbackType fct;
    fct.pSearchDomain = pDomain;
    // set prev to current so if are currently running in the target domain, 
    // we will detect the transition
    fct.pPrevDomain = m_pDomain;
    fct.fTargetTransition = FindADCallbackType::fMostRecentTransitionInto;
    fct.count = 0;

    // when this returns, if there is a transition into the AD, it will be in pFirstFrame
    StackWalkAction res = StackWalkFrames(StackWalkCallback_FindAD, (void*) &fct);
    if (count)
        *count = fct.count;
    return fct.pFrame;
}

// This finds the very first frame on the stack where the thread transitioned into the given domain
Frame *Thread::GetFirstTransitionInto(AppDomain *pDomain, int *count)
{
    FindADCallbackType fct;
    fct.pSearchDomain = pDomain;
    // set prev to current so if are currently running in the target domain, 
    // we will detect the transition
    fct.pPrevDomain = m_pDomain;
    fct.fTargetTransition = FindADCallbackType::fFirstTransitionInto;
    fct.count = 0;

    // when this returns, if there is a transition into the AD, it will be in pFirstFrame
    StackWalkAction res = StackWalkFrames(StackWalkCallback_FindAD, (void*) &fct);
    if (count)
        *count = fct.count;
    return fct.pFrame;
}

// Get outermost (oldest) AppDomain for this thread (not counting the default
// domain every one starts in).
AppDomain *Thread::GetInitialDomain()
{
    AppDomain *pDomain = m_pDomain;
    AppDomain *pPrevDomain = NULL;
    Frame *pFrame = GetFrame();
    while (pFrame != FRAME_TOP)
    {
        if (pFrame->GetVTablePtr() == ContextTransitionFrame::GetMethodFrameVPtr())
        {
            if (pPrevDomain)
                pDomain = pPrevDomain;
            pPrevDomain = pFrame->GetReturnDomain();
        }
        pFrame = pFrame->Next();
    }
    return pDomain;
}

BOOL Thread::ShouldChangeAbortToUnload(Frame *pFrame, Frame *pUnloadBoundaryFrame)
{
    if (! pUnloadBoundaryFrame)
        pUnloadBoundaryFrame = GetUnloadBoundaryFrame();

    // turn the abort request into an AD unloaded exception when go past the boundary.
    if (pFrame != pUnloadBoundaryFrame)
        return FALSE;

    // Only time have an unloadboundaryframe is when have specifically marked that thread for aborting
    // during unload processing, so this won't trigger UnloadedException if have simply thrown a ThreadAbort 
    // past an AD transition frame
    if (IsAbortRequested())
    {
        UserResetAbort();
        return TRUE;
    }

    // abort may have been reset, so check for AbortException as a backup
    OBJECTREF pThrowable = GetThrowable();

    if (pThrowable == NULL)
        return FALSE;

    DefineFullyQualifiedNameForClass();
    LPUTF8 szClass = GetFullyQualifiedNameForClass(pThrowable->GetClass());
    if (szClass && strcmp(g_ThreadAbortExceptionClassName, szClass) == 0)
        return TRUE;

    return FALSE;

}


BOOL Thread::HaveExtraWorkForFinalizer()
{
    return m_ThreadTasks || GCInterface::IsCacheCleanupRequired();
}

void Thread::DoExtraWorkForFinalizer()
{
    _ASSERTE(GetThread() == this);
    _ASSERTE(this == GCHeap::GetFinalizerThread());

    if (RequiresCoInitialize())
    {
        SetApartment(AS_InMTA);
    }
    if (RequireSyncBlockCleanup())
    {
        SyncBlockCache::GetSyncBlockCache()->CleanupSyncBlocks();
    }
    if (GCInterface::IsCacheCleanupRequired() && GCHeap::GetCondemnedGeneration()==1) {
        GCInterface::CleanupCache();
    }
}



//+----------------------------------------------------------------------------
//
//  Method:     Thread::GetStaticFieldAddress   private
//
//  Synopsis:   Get the address of the field relative to the current thread.
//              If an address has not been assigned yet then create one.
//
//  History:    15-Feb-2000   TarunA      Created
//
//+----------------------------------------------------------------------------
LPVOID Thread::GetStaticFieldAddress(FieldDesc *pFD)
{
    THROWSCOMPLUSEXCEPTION();
    
    BOOL fThrow = FALSE;
    THREADBASEREF orThread = NULL;    
    STATIC_DATA *pData;
    LPVOID pvAddress = NULL;
    MethodTable *pMT = pFD->GetMethodTableOfEnclosingClass();
    BOOL fIsShared = pMT->IsShared();
    WORD wClassOffset = pMT->GetClass()->GetThreadStaticOffset();
    WORD currElem = 0; 
    Thread *pThread = GetThread();
     
    // NOTE: if you change this method, you must also change
    // GetStaticFieldAddrForDebugger below.
   
    _ASSERTE(NULL != pThread);
    if(!fIsShared)
    {
        pData = pThread->GetUnsharedStaticData();
    }
    else
    {
        pData = pThread->GetSharedStaticData();
    }
    

    if(NULL != pData)
    {
        currElem = pData->cElem;
    }

    // Check whether we have allocated space for storing a pointer to
    // this class' thread static store    
    if(wClassOffset >= currElem)
    {
        // Allocate space for storing pointers 
        WORD wNewElem = (currElem == 0 ? 4 : currElem*2);

        // Ensure that we grow to a size beyond the index we intend to use
        while (wNewElem <= wClassOffset)
        {
            wNewElem = wNewElem*2;
        }

        STATIC_DATA *pNew = (STATIC_DATA *)new BYTE[sizeof(STATIC_DATA) + wNewElem*sizeof(LPVOID)];
        if(NULL != pNew)
        {
            memset(pNew, 0x00, sizeof(STATIC_DATA) + wNewElem*sizeof(LPVOID));
            if(NULL != pData)
            {
                // Copy the old data into the new data
                memcpy(pNew, pData, sizeof(STATIC_DATA) + currElem*sizeof(LPVOID));
            }
            pNew->cElem = wNewElem;

            // Delete the old data
            delete pData;

            // Update the locals
            pData = pNew;

            // Reset the pointers in the thread object to point to the 
            // new memory
            if(!fIsShared)
            {
                pThread->SetStaticData(pThread->GetDomain(), NULL, pData);
            }
            else
            {
                pThread->SetStaticData(pThread->GetDomain(), pData, NULL);
            }            
        }
        else
        {
            fThrow = TRUE;
        }
    }

    // Check whether we have to allocate space for 
    // the thread local statics of this class
    if(!fThrow && (NULL == pData->dataPtr[wClassOffset]))        
    {
        // Allocate memory for thread static fields with extra space in front for the class owning the storage.
        // We stash the class at the front of the allocated storage so that we can use
        // it to interpret the data on unload in DeleteThreadStaticClassData.
        pData->dataPtr[wClassOffset] = (LPVOID)(new BYTE[pMT->GetClass()->GetThreadStaticsSize()+sizeof(EEClass*)] + sizeof(EEClass*));
        if(NULL != pData->dataPtr[wClassOffset])
        {
            // Initialize the memory allocated for the fields
            memset(pData->dataPtr[wClassOffset], 0x00, pMT->GetClass()->GetThreadStaticsSize());
            *(EEClass**)((BYTE*)(pData->dataPtr[wClassOffset]) - sizeof(EEClass*)) = pMT->GetClass();
        }
        else
        {
            fThrow = TRUE;
        }
    }

    if(!fThrow)
    {
        _ASSERTE(NULL != pData->dataPtr[wClassOffset]);
        // We have allocated static storage for this data
        // Just return the address by getting the offset into the data
        pvAddress = (LPVOID)((LPBYTE)pData->dataPtr[wClassOffset] + pFD->GetOffset());

        // For object and value class fields we have to allocate storage in the
        // __StaticContainer class in the managed heap. Instead of pvAddress being
        // the actual address of the static, for such objects it holds the slot index
        // to the location in the __StaticContainer member.
        if(pFD->IsObjRef() || pFD->IsByValue())
        {
            // _ASSERTE(FALSE);
            // in this case *pvAddress == bucket|index
            int *pSlot = (int*)pvAddress;
            pvAddress = NULL;

            fThrow = GetStaticFieldAddressSpecial(pFD, pMT, pSlot, &pvAddress);

            if (pFD->IsByValue())
            {
                _ASSERTE(pvAddress != NULL);
                pvAddress = (*((OBJECTREF*)pvAddress))->GetData();
            }

            // ************************************************
            // ************** WARNING *************************
            // Do not provoke GC from here to the point JIT gets
            // pvAddress back
            // ************************************************
            _ASSERTE(*pSlot > 0);
        }
    }
    else
    {
        COMPlusThrowOM();
    }

    _ASSERTE(NULL != pvAddress);

    return pvAddress;
}

//+----------------------------------------------------------------------------
//       
//  Method:     Thread::GetStaticFieldAddrForDebugger   private
//
//  Synopsis:   Get the address of the field relative to the current thread.
//              If an address has not been assigned, return NULL.
//              No creating is allowed.
//
//  History:    04-Apr-2000   MikeMAg      Created
//
//+----------------------------------------------------------------------------
LPVOID Thread::GetStaticFieldAddrForDebugger(FieldDesc *pFD)
{
    STATIC_DATA *pData;
    LPVOID pvAddress = NULL;
    MethodTable *pMT = pFD->GetMethodTableOfEnclosingClass();
    BOOL fIsShared = pMT->IsShared();
    WORD wClassOffset = pMT->GetClass()->GetThreadStaticOffset();

    // Note: this function operates on 'this' Thread, not the
    // 'current' thread.

    // NOTE: if you change this method, you must also change
    // GetStaticFieldAddress above.
   
    if (!fIsShared)
        pData = GetUnsharedStaticData();
    else
        pData = GetSharedStaticData();


    if (NULL != pData)
    {
        // Check whether we have allocated space for storing a pointer
        // to this class' thread static store.
        if ((wClassOffset < pData->cElem) && (NULL != pData->dataPtr[wClassOffset]))
        {
            // We have allocated static storage for this data.  Just
            // return the address by getting the offset into the data.
            pvAddress = (LPVOID)((LPBYTE)pData->dataPtr[wClassOffset] + pFD->GetOffset());

            // For object and value class fields we have to allocate
            // storage in the __StaticContainer class in the managed
            // heap. If its not already allocated, return NULL
            // instead.
            if (pFD->IsObjRef() || pFD->IsByValue())
            {
                // if *pvAddress == NULL, it means we have to reserve a slot
                // for this static in the managed array. 
                // (Slot #0 is never assigned to any static to support this.)
                if (NULL == *(LPVOID *)pvAddress)
                {
                    pvAddress = NULL;
                    LOG((LF_SYNC, LL_ALWAYS, "dbgr: pvAddress = NULL"));
                }
                else
                {
                    pvAddress = CalculateAddressForManagedStatic(*(int*)pvAddress, this);
                    LOG((LF_SYNC, LL_ALWAYS, "dbgr: pvAddress = %lx", pvAddress));
                    if (pFD->IsByValue())
                    {
                        _ASSERTE(pvAddress != NULL);
                        pvAddress = (*((OBJECTREF*)pvAddress))->GetData();
                    }
                }
            }
        }                
    }

    return pvAddress;
}

//+----------------------------------------------------------------------------
//
//  Method:     Thread::AllocateStaticFieldObjRefPtrs   private
//
//  Synopsis:   Allocate an entry in the __StaticContainer class in the
//              managed heap for static objects and value classes
//
//  History:    28-Feb-2000   TarunA      Created
//
//+----------------------------------------------------------------------------
void Thread::AllocateStaticFieldObjRefPtrs(FieldDesc *pFD, MethodTable *pMT, LPVOID pvAddress)
{
    THROWSCOMPLUSEXCEPTION();

    // Retrieve the object ref pointers from the app domain.
    OBJECTREF *pObjRef = NULL;

    // Reserve some object ref pointers.
    GetAppDomain()->AllocateStaticFieldObjRefPtrs(1, &pObjRef);


    // to a boxed version of the value class.  This allows the standard GC
    // algorithm to take care of internal pointers in the value class.
    if (pFD->IsByValue())
    {

        // Extract the type of the field
        TypeHandle  th;        
        PCCOR_SIGNATURE pSig;
        DWORD       cSig;
        pFD->GetSig(&pSig, &cSig);
        FieldSig sig(pSig, pFD->GetModule());

        OBJECTREF throwable = NULL;
        GCPROTECT_BEGIN(throwable);
        th = sig.GetTypeHandle(&throwable);
        if (throwable != NULL)
            COMPlusThrow(throwable);
        GCPROTECT_END();

        OBJECTREF obj = AllocateObject(th.AsClass()->GetMethodTable());
        SetObjectReference( pObjRef, obj, GetAppDomain() );                      
    }

    *(ULONG_PTR *)pvAddress =  (ULONG_PTR)pObjRef;
}


MethodDesc* Thread::GetMDofReserveSlot()
{
    if (s_pReserveSlotMD == NULL)
    {
        s_pReserveSlotMD = g_Mscorlib.GetMethod(METHOD__THREAD__RESERVE_SLOT);
    }
    _ASSERTE(s_pReserveSlotMD != NULL);
    return s_pReserveSlotMD;
}

// This is used for thread relative statics that are object refs
// These are stored in a structure in the managed thread. The first
// time over an index and a bucket are determined and subsequently
// remembered in the location for the field in the per-thread-per-class
// data structure.
// Here we map back from the index to the address of the object ref.

LPVOID Thread::CalculateAddressForManagedStatic(int slot, Thread *pThread)
{
    OBJECTREF *pObjRef;
    BEGINFORBIDGC();
    _ASSERTE(slot > 0);
    // Now determine the address of the static field
    PTRARRAYREF bucketRef = NULL;
    THREADBASEREF threadRef = NULL;
    if (pThread == NULL)
    {
        // pThread is NULL except when the debugger calls this on behalf of
        // some thread
        pThread = GetThread();
        _ASSERTE(pThread!=NULL);
    }
    // We come here only after a slot is allocated for the static
    // which means we have already faulted in the exposed thread object
    threadRef = (THREADBASEREF) pThread->GetExposedObjectRaw();
    _ASSERTE(threadRef != NULL);

    bucketRef = threadRef->GetThreadStaticsHolder();
    _ASSERTE(bucketRef != NULL);
    pObjRef = ((OBJECTREF*)bucketRef->GetDataPtr())+slot;
    ENDFORBIDGC();
    return (LPVOID) pObjRef;
}

// This is called during AD unload to set the bit corresponding to the managed
// thread static slot that has been freed. This way we can reassign the freed
// entry when some other domain needs one.
void Thread::FreeThreadStaticSlot(int slot, Thread *pThread)
{
    BEGINFORBIDGC();
    // Slot #0 is never assigned 
    _ASSERTE(slot > 0);
    _ASSERTE(pThread != NULL);
    I4ARRAYREF bitArrayRef = NULL;
    THREADBASEREF threadRef = (THREADBASEREF)pThread->GetExposedObjectRaw();
    _ASSERTE(threadRef != NULL);

    bitArrayRef = threadRef->GetThreadStaticsBits();
    _ASSERTE(bitArrayRef != NULL);

    // Get to the correct set of 32 bits
    int *p32Bits = (slot/32 + (int*) bitArrayRef->GetDataPtr());
    // Turn on the bit corresponding to this slot
    *p32Bits |= (1<<slot%32);
    ENDFORBIDGC();
}

//+----------------------------------------------------------------------------
//
//  Method:     Thread::GetStaticFieldAddressSpecial private
//
//  Synopsis:   Allocate an entry in the __StaticContainer class in the
//              managed heap for static objects and value classes
//
//  History:    28-Feb-2000   TarunA      Created
//
//+----------------------------------------------------------------------------

// NOTE: At one point we used to allocate these in the long lived handle table
// which is per-appdomain. However, that causes them to get rooted and not 
// cleaned up until the appdomain gets unloaded. This is not very desirable 
// since a thread static object may hold a reference to the thread itself 
// causing a whole lot of garbage to float around.
// Now (2/13/01) these are allocated from a managed structure rooted in each
// managed thread.

BOOL Thread::GetStaticFieldAddressSpecial(
    FieldDesc *pFD, MethodTable *pMT, int *pSlot, LPVOID *ppvAddress)
{
    BOOL fThrow = FALSE;

    BEGINCANNOTTHROWCOMPLUSEXCEPTION();    

    COMPLUS_TRY 
    {
        OBJECTREF *pObjRef = NULL;
        Thread *pThread = GetThread();
        _ASSERTE(pThread != NULL);
        BOOL bNewSlot = (*pSlot == 0);
        if (bNewSlot)
        {
            // ! this line will trigger a GC, don't move it down
            // ! without protecting the args[] and other OBJECTREFS
            MethodDesc * pMD = GetMDofReserveSlot();
            
            // We need to assign a location for this static field. 
            // Call the managed helper
            INT64 args[1] = {
                ObjToInt64(GetThread()->GetExposedObject())
            };

            _ASSERTE(args[0] != 0);

            *pSlot = (int) pMD->Call(
                            args, 
                            METHOD__THREAD__RESERVE_SLOT);

            _ASSERTE(*pSlot>0);

            // to a boxed version of the value class.  This allows the standard GC
            // algorithm to take care of internal pointers in the value class.
            if (pFD->IsByValue())
            {
                // Extract the type of the field
                TypeHandle  th;        
                PCCOR_SIGNATURE pSig;
                DWORD       cSig;
                pFD->GetSig(&pSig, &cSig);
                FieldSig sig(pSig, pFD->GetModule());
    
                OBJECTREF throwable = NULL;
                GCPROTECT_BEGIN(throwable);
                th = sig.GetTypeHandle(&throwable);
                if (throwable != NULL)
                    COMPlusThrow(throwable);
                GCPROTECT_END();

                OBJECTREF obj = AllocateObject(th.AsClass()->GetMethodTable());
                pObjRef = (OBJECTREF*)CalculateAddressForManagedStatic(*pSlot, NULL);
                SetObjectReference( pObjRef, obj, GetAppDomain() );                      
            }
            else
            {
                pObjRef = (OBJECTREF*)CalculateAddressForManagedStatic(*pSlot, NULL);
            }
        }
        else
        {
            // If the field already has a location assigned we go through here
            pObjRef = (OBJECTREF*)CalculateAddressForManagedStatic(*pSlot, NULL);
        }
        *(ULONG_PTR *)ppvAddress =  (ULONG_PTR)pObjRef;
    } 
    COMPLUS_CATCH
    {
        fThrow = TRUE;
    }            
    COMPLUS_END_CATCH

    ENDCANNOTTHROWCOMPLUSEXCEPTION();

    return fThrow;
}


 
//+----------------------------------------------------------------------------
//
//  Method:     Thread::SetStaticData   private
//
//  Synopsis:   Finds or creates an entry in the list which has the same domain
//              as the one given. These entries have pointers to the thread 
//              local static data in each appdomain.
//              This function is called in two situations
//              (1) We are switching domains and need to set the pointers
//              to the static storage for the domain we are entering.
//              (2) We are accessing thread local storage for the current
//              domain and we need to set the pointer to the static storage
//              that we have created.
//
//  History:    28-Feb-2000   TarunA      Created
//
//+----------------------------------------------------------------------------
STATIC_DATA_LIST *Thread::SetStaticData(AppDomain *pDomain, STATIC_DATA *pSharedData,
                                        STATIC_DATA *pUnsharedData)
{   
    THROWSCOMPLUSEXCEPTION();

    // we need to make sure no preemptive mode threads get in here. Otherwise an appdomain unload
    // cannot simply stop the EE and delete entries from this list, assuming there are no threads 
    // touching these structures. If preemptive mode threads get in here, we will have to do a 
    // deferred cleanup like for the codemanager.
    _ASSERTE (GetThread()->PreemptiveGCDisabled());

    STATIC_DATA_LIST *pNode=NULL;

    // First, check to make sure that we have a hash
    if( m_pStaticDataHash == NULL ) {
        m_pStaticDataHash = new EEPtrHashTable();
        if( m_pStaticDataHash == NULL ) {
            COMPlusThrowOM(); // out of memory
        }
        // CheckThreadSafety is FALSE because we ensure that it is always safe
        // operate on the hash without taking a lock. The potential race is 
        // between a DeleteThreadStaticData and SetStaticData or reading the 
        // static data. Reading is fine (see the EEHashTable implementation).
        // Delete is safe since the two cases where it is called are:1) Appdomain unload 
        // where we have done an EESuspend and 2) Thread exit (possibly due to a thread detach)
        // in which case we have taken the thread store lock. 
        // The original linked list implementation was also lock-free. The change to 
        // a hash table preserves that semantics, this comment is merely to document the rationale.
       
        m_pStaticDataHash->Init( 4, NULL, NULL, FALSE /* CheckThreadSafety */);
    }

    // We have a hash, check to see if this appDom has an entry
    else {
        m_pStaticDataHash->GetValue( (void *)pDomain, (void **)&pNode );
    }

    // If we haven't found the data, then we need to create it and remember it
    if( pNode == NULL ) {

        pNode = new STATIC_DATA_LIST();

        if(NULL == pNode)
        {
            COMPlusThrowOM();
        }

        m_pSharedStaticData = pNode->m_pSharedStaticData = pSharedData;
        m_pUnsharedStaticData = pNode->m_pUnsharedStaticData = pUnsharedData;
        
        // Add to the hash
        m_pStaticDataHash->InsertValue( (void *)pDomain, (void *)pNode );
    }
    else {
        if(NULL == pSharedData)
        {
            m_pSharedStaticData = pNode->m_pSharedStaticData;
        }
        else
        {
            m_pSharedStaticData = pNode->m_pSharedStaticData = pSharedData;
        }

        if(NULL == pUnsharedData)
        {
            m_pUnsharedStaticData = pNode->m_pUnsharedStaticData;
        }
        else
        {
            m_pUnsharedStaticData = pNode->m_pUnsharedStaticData = pUnsharedData;
        }
    }

    return pNode;
}

// A version of SetStaticData that is guaranteed not to throw.  This can be used in
// ReturnToContext where we're sure we don't have to allocate.
STATIC_DATA_LIST *Thread::SafeSetStaticData(AppDomain *pDomain, STATIC_DATA *pSharedData,
                                        STATIC_DATA *pUnsharedData)
{   
    STATIC_DATA_LIST *result;

    BEGINCANNOTTHROWCOMPLUSEXCEPTION();

    COMPLUS_TRY
    {
        result = SetStaticData(pDomain, pSharedData, pUnsharedData);
    }
    COMPLUS_CATCH
    {
        _ASSERTE(!"Thread::SafeSetStaticData() got an unexpected exception");
        result = 0;
    }
    COMPLUS_END_CATCH

    ENDCANNOTTHROWCOMPLUSEXCEPTION();

    return result;
}

//+----------------------------------------------------------------------------
//
//  Method:     Thread::DeleteThreadStaticData   private
//
//  Synopsis:   Delete the static data for each appdomain that this thread
//              visited.
//              
//
//  History:    28-Feb-2000   TarunA      Created
//
//+----------------------------------------------------------------------------
void Thread::DeleteThreadStaticData()
{
    STATIC_DATA             *shared;
    STATIC_DATA             *unshared;

    shared = m_pSharedStaticData;
    unshared = m_pUnsharedStaticData;

    if( m_pStaticDataHash != NULL ) {

        EEHashTableIteration    iterator;
        STATIC_DATA_LIST        *pNode=NULL;

        memset(&iterator, 0x00, sizeof(EEHashTableIteration));
    
        m_pStaticDataHash->IterateStart( &iterator );
        while ( m_pStaticDataHash->IterateNext( &iterator ) ) {

            pNode = (STATIC_DATA_LIST*)m_pStaticDataHash->IterateGetValue( &iterator );

            if (pNode->m_pSharedStaticData == shared) 
                shared = NULL;
            
            DeleteThreadStaticClassData((_STATIC_DATA*)pNode->m_pSharedStaticData, FALSE);

            if (pNode->m_pUnsharedStaticData == unshared) 
                unshared = NULL;
            
            DeleteThreadStaticClassData((_STATIC_DATA*)pNode->m_pUnsharedStaticData, FALSE);

            delete pNode;
        }

        delete m_pStaticDataHash;
        m_pStaticDataHash = NULL;
    }

    delete shared;
    delete unshared;
    
    m_pSharedStaticData = NULL;
    m_pUnsharedStaticData = NULL;

    return;
}

//+----------------------------------------------------------------------------
//
//  Method:     Thread::DeleteThreadStaticData   protected
//
//  Synopsis:   Delete the static data for the given appdomain. This is called
//              when the appdomain unloads.
//              
//
//  History:    28-Feb-2000   TarunA      Created
//
//+----------------------------------------------------------------------------
void Thread::DeleteThreadStaticData(AppDomain *pDomain)
{
    if( m_pStaticDataHash == NULL ) return;

    STATIC_DATA_LIST *pNode=NULL;

    m_pStaticDataHash->GetValue( (void *)pDomain, (void **)&pNode );

    // If we find the data node, then delete the
    // contents and then remove from the hash
    if( pNode != NULL ) {
        
            // Delete the shared static data
            if(pNode->m_pSharedStaticData == m_pSharedStaticData)
                m_pSharedStaticData = NULL;

            DeleteThreadStaticClassData((_STATIC_DATA*)pNode->m_pSharedStaticData, TRUE);
            
            // Delete the unshared static data
            if(pNode->m_pUnsharedStaticData == m_pUnsharedStaticData)
                m_pUnsharedStaticData = NULL;

            DeleteThreadStaticClassData((_STATIC_DATA*)pNode->m_pUnsharedStaticData, TRUE);

            // Remove the entry from the hash
            m_pStaticDataHash->DeleteValue( (void *)pDomain );

            // delete the given domain's entry
            delete pNode;
    }

}

// for valuetype and reference thread statics, we use the entry in the pData->dataPtr array for
// the class to hold an index of a slot to index into the managed array hung off the thread where
// such statics are rooted. We need to find those objects and null out their slots so that they
// will be collected properly on an unload.
void Thread::DeleteThreadStaticClassData(_STATIC_DATA* pData, BOOL fClearFields)
{
    if (pData == NULL)
        return;

    for(WORD i = 0; i < pData->cElem; i++)
    {
        void *dataPtr = (void *)pData->dataPtr[i];
        if (! dataPtr)
            continue;

        // if thread doesn't have an ExposedObject (eg. could be dead), then nothing to clean up.
        if (fClearFields && GetExposedObjectRaw() != NULL)
        {
            EEClass *pClass = *(EEClass**)(((BYTE*)dataPtr) - sizeof(EEClass*));
            _ASSERTE(pClass->GetMethodTable()->GetClass() == pClass);

            // iterate through each static field and get it's address in the managed thread 
            // structure and clear it out.

            // get a field iterator
            FieldDescIterator fdIterator(pClass, FieldDescIterator::STATIC_FIELDS);
            FieldDesc *pFD;

            while ((pFD = fdIterator.Next()) != NULL)
            {        
                if (! (pFD->IsThreadStatic() && (pFD->IsObjRef() || pFD->IsByValue())))
                    continue;

                int *pSlot = (int*)((LPBYTE)dataPtr + pFD->GetOffset());
                if (*pSlot == 0)
                    continue;

                // clear out the object in the managed structure rooted in the thread.
                OBJECTREF *pObjRef = (OBJECTREF*)CalculateAddressForManagedStatic(*pSlot, this);
                _ASSERT(pObjRef != 0);
                SetObjectReferenceUnchecked( pObjRef, NULL);
                // set the bit corresponding to this slot
                FreeThreadStaticSlot(*pSlot, this);
            }
        }
        delete ((BYTE*)(dataPtr) - sizeof(EEClass*));
    }
    delete pData;
}


// @todo - these GetUICulture*() are just stubs that will
// always return english.
// See Description in UtilCode.h for details on interface.
#define PROP_CULTURE_NAME "Name"
#define PROP_THREAD_UI_CULTURE "CurrentUICulture"
#define PROP_THREAD_CULTURE "CurrentCulture"
#define PROP_CULTURE_ID "LCID"

INT64 Thread::CallPropertyGet(BinderMethodID id, OBJECTREF pObject) 
{
    if (!pObject) {
        return 0;
    }

    MethodDesc *pMD;

    GCPROTECT_BEGIN(pObject);
    pMD = g_Mscorlib.GetMethod(id);
    GCPROTECT_END();

    // Set up the Stack.
    INT64 pNewArgs = ObjToInt64(pObject);

    // Make the actual call.
    INT64 retVal = pMD->Call(&pNewArgs, id);

    return retVal;
}

INT64 Thread::CallPropertySet(BinderMethodID id, OBJECTREF pObject, OBJECTREF pValue) 
{
    if (!pObject) {
        return 0;
    }

    MethodDesc *pMD;

    GCPROTECT_BEGIN(pObject);
    GCPROTECT_BEGIN(pValue);
    pMD = g_Mscorlib.GetMethod(id);
    GCPROTECT_END();
    GCPROTECT_END();

    // Set up the Stack.
    INT64 pNewArgs[] = {
        ObjToInt64(pObject),
        ObjToInt64(pValue)
    };

    // Make the actual call.
    INT64 retVal = pMD->Call(pNewArgs, id);

    return retVal;
}

OBJECTREF Thread::GetCulture(BOOL bUICulture)
{

    FieldDesc *         pFD;

    _ASSERTE(PreemptiveGCDisabled());

    // This is the case when we're building mscorlib and haven't yet created
    // the system assembly.
    if (SystemDomain::System()->SystemAssembly()==NULL || g_fFatalError) {
        return NULL;
    }

    // Get the actual thread culture.
    OBJECTREF pCurThreadObject = GetExposedObject();
    _ASSERTE(pCurThreadObject!=NULL);

    THREADBASEREF pThreadBase = (THREADBASEREF)(pCurThreadObject);
    OBJECTREF pCurrentCulture = bUICulture ? pThreadBase->GetCurrentUICulture() : pThreadBase->GetCurrentUserCulture();

    if (pCurrentCulture==NULL) {
        GCPROTECT_BEGIN(pThreadBase); 
        if (bUICulture) {
            // Call the Getter for the CurrentUICulture.  This will cause it to populate the field.
            INT64 retVal = CallPropertyGet(METHOD__THREAD__GET_UI_CULTURE,
                                           (OBJECTREF)pThreadBase);
            pCurrentCulture = Int64ToObj(retVal);
        } else {
            //This is  faster than calling the property, because this is what the call does anyway.
            pFD = g_Mscorlib.GetField(FIELD__CULTURE_INFO__CURRENT_CULTURE);
            _ASSERTE(pFD);
            pCurrentCulture = pFD->GetStaticOBJECTREF();
            _ASSERTE(pCurrentCulture!=NULL);
        }
        GCPROTECT_END();
    }

    return pCurrentCulture;
}



// copy culture name into szBuffer and return length
int Thread::GetParentCultureName(LPWSTR szBuffer, int length, BOOL bUICulture)
{
    // This is the case when we're building mscorlib and haven't yet created
    // the system assembly.
    if (SystemDomain::System()->SystemAssembly()==NULL) {
        WCHAR *tempName = L"en";
        INT32 tempLength = (INT32)wcslen(tempName);
        _ASSERTE(length>=tempLength);
        memcpy(szBuffer, tempName, tempLength*sizeof(WCHAR));
        return tempLength;
    }

    INT64 Result = 0;
    INT32 retVal=0;
    Thread *pCurThread=NULL;
    WCHAR *buffer=NULL;
    INT32 bufferLength=0;
    STRINGREF cultureName = NULL;

    pCurThread = GetThread();
    BOOL    toggleGC = !(pCurThread->PreemptiveGCDisabled());
    if (toggleGC) {
        pCurThread->DisablePreemptiveGC();
    }

    OBJECTREF pCurrentCulture = NULL;
    OBJECTREF pParentCulture = NULL;
    GCPROTECT_BEGIN(pCurrentCulture)
    {
        COMPLUS_TRY
        {
            pCurrentCulture = GetCulture(bUICulture);
            if (pCurrentCulture != NULL)
                Result = CallPropertyGet(METHOD__CULTURE_INFO__GET_PARENT, pCurrentCulture);
                
        }
        COMPLUS_CATCH 
        {
        }
        COMPLUS_END_CATCH
    }
    GCPROTECT_END();

    if (Result==0) {
        retVal = 0;
        goto Exit;
    }

    GCPROTECT_BEGIN(pParentCulture)
    {
        COMPLUS_TRY
        {
            pParentCulture = (OBJECTREF)(Int64ToObj(Result));
            if (pParentCulture != NULL)
            {
                Result = 0;
                Result = CallPropertyGet(METHOD__CULTURE_INFO__GET_NAME, pParentCulture);
            }
                
        }
        COMPLUS_CATCH 
        {
        }
        COMPLUS_END_CATCH
    }
    GCPROTECT_END();

    if (Result==0) {
        retVal = 0;
        goto Exit;
    }


    // Extract the data out of the String.
    cultureName = (STRINGREF)(Int64ToObj(Result));
    RefInterpretGetStringValuesDangerousForGC(cultureName, (WCHAR**)&buffer, &bufferLength);

    if (bufferLength<length) {
        memcpy(szBuffer, buffer, bufferLength * sizeof (WCHAR));
        szBuffer[bufferLength]=0;
        retVal = bufferLength;
    }

 Exit:
    if (toggleGC) {
        pCurThread->EnablePreemptiveGC();
    }

    return retVal;
}




// copy culture name into szBuffer and return length
int Thread::GetCultureName(LPWSTR szBuffer, int length, BOOL bUICulture)
{
    // This is the case when we're building mscorlib and haven't yet created
    // the system assembly.
    if (SystemDomain::System()->SystemAssembly()==NULL || g_fFatalError) {
        WCHAR *tempName = L"en-US";
        INT32 tempLength = (INT32)wcslen(tempName);
        _ASSERTE(length>=tempLength);
        memcpy(szBuffer, tempName, tempLength*sizeof(WCHAR));
        return tempLength;
    }

    INT64 Result = 0;
    INT32 retVal=0;
    Thread *pCurThread=NULL;
    WCHAR *buffer=NULL;
    INT32 bufferLength=0;
    STRINGREF cultureName = NULL;

    pCurThread = GetThread();
    BOOL    toggleGC = !(pCurThread->PreemptiveGCDisabled());
    if (toggleGC) {
        pCurThread->DisablePreemptiveGC();
    }

    OBJECTREF pCurrentCulture = NULL;
    GCPROTECT_BEGIN(pCurrentCulture)
    {
        COMPLUS_TRY
        {
            pCurrentCulture = GetCulture(bUICulture);
            if (pCurrentCulture != NULL)
                Result = CallPropertyGet(METHOD__CULTURE_INFO__GET_NAME, pCurrentCulture);
        }
        COMPLUS_CATCH 
        {
        }
        COMPLUS_END_CATCH
    }
    GCPROTECT_END();

    if (Result==0) {
        retVal = 0;
        goto Exit;
    }

    // Extract the data out of the String.
    cultureName = (STRINGREF)(Int64ToObj(Result));
    RefInterpretGetStringValuesDangerousForGC(cultureName, (WCHAR**)&buffer, &bufferLength);

    if (bufferLength<length) {
        memcpy(szBuffer, buffer, bufferLength * sizeof (WCHAR));
        szBuffer[bufferLength]=0;
        retVal = bufferLength;
    }

 Exit:
    if (toggleGC) {
        pCurThread->EnablePreemptiveGC();
    }

    return retVal;
}

// Return a language identifier.
LCID Thread::GetCultureId(BOOL bUICulture)
{
    // This is the case when we're building mscorlib and haven't yet created
    // the system assembly.
    if (SystemDomain::System()->SystemAssembly()==NULL || g_fFatalError) {
        return UICULTUREID_DONTCARE;
    }

    INT64 Result=UICULTUREID_DONTCARE;
    Thread *pCurThread=NULL;

    pCurThread = GetThread();
    BOOL    toggleGC = !(pCurThread->PreemptiveGCDisabled());
    if (toggleGC) {
        pCurThread->DisablePreemptiveGC();
    }

    OBJECTREF pCurrentCulture = NULL;
    GCPROTECT_BEGIN(pCurrentCulture)
    {
        COMPLUS_TRY
        {
            pCurrentCulture = GetCulture(bUICulture);
            if (pCurrentCulture != NULL)
                Result = CallPropertyGet(METHOD__CULTURE_INFO__GET_ID, pCurrentCulture);
        }
        COMPLUS_CATCH 
        {
        }
        COMPLUS_END_CATCH
    }
    GCPROTECT_END();

    if (toggleGC) {
        pCurThread->EnablePreemptiveGC();
    }

    return (INT32)Result;
}

void Thread::SetCultureId(LCID lcid, BOOL bUICulture)
{
    OBJECTREF CultureObj = NULL;
    GCPROTECT_BEGIN(CultureObj)
    {
        // Convert the LCID into a CultureInfo.
        GetCultureInfoForLCID(lcid, &CultureObj);

        // Set the newly created culture as the thread's culture.
        SetCulture(CultureObj, bUICulture);
    }
    GCPROTECT_END();
}

void Thread::SetCulture(OBJECTREF CultureObj, BOOL bUICulture)
{
    // Retrieve the exposed thread object.
    OBJECTREF pCurThreadObject = GetExposedObject();
    _ASSERTE(pCurThreadObject!=NULL);

    // Set the culture property on the thread.
    THREADBASEREF pThreadBase = (THREADBASEREF)(pCurThreadObject);
    CallPropertySet(bUICulture 
                    ? METHOD__THREAD__SET_UI_CULTURE
                    : METHOD__THREAD__SET_CULTURE,
                    (OBJECTREF)pThreadBase, CultureObj);
}

// The DLS hash lock should already have been taken before this call
LocalDataStore *Thread::RemoveDomainLocalStore(int iAppDomainId)
{
    HashDatum Data = NULL;
    if (m_pDLSHash) {
        if (m_pDLSHash->GetValue(iAppDomainId, &Data))
            m_pDLSHash->DeleteValue(iAppDomainId);
    }

    return (LocalDataStore*) Data;
}

void Thread::RemoveAllDomainLocalStores()
{
    // Don't bother cleaning this up if we're detaching
    if (!g_fProcessDetach)
    {
        Thread *pCurThread = GetThread();
        BOOL toggleGC = pCurThread->PreemptiveGCDisabled();
        
        if (toggleGC)
            pCurThread->EnablePreemptiveGC();
    
        ThreadStore::LockDLSHash();

        if (toggleGC)
            pCurThread->DisablePreemptiveGC();

        if (!m_pDLSHash) {
            ThreadStore::UnlockDLSHash();
            return;
        }
    }
    // The 'if' if we are in a process detach
    if (!m_pDLSHash)
        return;

    EEHashTableIteration iter;
    m_pDLSHash->IterateStart(&iter);
    while (m_pDLSHash->IterateNext(&iter))
    {
        LocalDataStore* pLDS = (LocalDataStore*) m_pDLSHash->IterateGetValue(&iter);
         _ASSERTE(pLDS);
         if (!g_fProcessDetach)
            RemoveDLSFromList(pLDS);
         delete pLDS;
    }
        
    delete m_pDLSHash;
    m_pDLSHash = NULL;

    if (!g_fProcessDetach)
        ThreadStore::UnlockDLSHash();
}

// The DLS hash lock should already have been taken before this call
void Thread::RemoveDLSFromList(LocalDataStore* pLDS)
{
    THROWSCOMPLUSEXCEPTION();

    MethodDesc *removeThreadDLStoreMD = NULL;

    if (!g_fProcessDetach)
    {
        INT64 args[1] = {
            ObjToInt64(pLDS->GetRawExposedObject())
        };
        if (!removeThreadDLStoreMD)
            removeThreadDLStoreMD = g_Mscorlib.GetMethod(METHOD__THREAD__REMOVE_DLS);
        _ASSERTE(removeThreadDLStoreMD);
        removeThreadDLStoreMD->Call(args, METHOD__THREAD__REMOVE_DLS);
    }
}

void Thread::SetHasPromotedBytes ()
{
    m_fPromoted = TRUE;

    _ASSERTE(g_pGCHeap->IsGCInProgress() && 
             (g_pGCHeap->GetGCThread() == GetThread() ||  // either Concurrent GC or server GC
              GetThread() == NULL ||
              dbgOnly_IsSpecialEEThread())); // or a regular gc thread can call this API.

    if (!m_fPreemptiveGCDisabled)
    {
        if (FRAME_TOP == GetFrame())
            m_fPromoted = FALSE;
    }
}

BOOL ThreadStore::HoldingThreadStore(Thread *pThread)
{
    if (pThread)
    {
        return pThread == g_pThreadStore->m_HoldingThread
            || (g_fFinalizerRunOnShutDown
                && pThread == g_pGCHeap->GetFinalizerThread());
    }
    else
    {
        return g_pThreadStore->m_holderthreadid == GetCurrentThreadId();
    }
}



#ifdef CUSTOMER_CHECKED_BUILD

void CCBApartmentProbeOutput(CustomerDebugHelper *pCdh, DWORD threadID, Thread::ApartmentState state, BOOL fAlreadySet)
{
    CQuickArray<WCHAR> strMsg;
    CQuickArray<WCHAR> strTmp;

    static WCHAR       szStartedThread[]      = {L"Thread (0x%lx)"};
    static WCHAR       szUnstartedThread[]    = {L"Unstarted thread"};
    static WCHAR       szTemplateMsgSet[]     = {L"%s is trying to set the apartment state to %s, but it has already been set to %s."};
    static WCHAR       szTemplateMsgChanged[] = {L"%s used to be in %s, but the application has CoUninitialized and the thread is now in %s."};

    static const WCHAR szSTA[] = {L"STA"};
    static const WCHAR szMTA[] = {L"MTA"};

    static const WCHAR szInSTA[] = {L"a STA"};
    static const WCHAR szInMTA[] = {L"the MTA"};

    if (threadID != 0)
    {
        strTmp.Alloc(lengthof(szStartedThread) + MAX_UINT32_HEX_CHAR_LEN);
        Wszwsprintf(strTmp.Ptr(), szStartedThread, threadID);
    }
    else
    {
        strTmp.Alloc(lengthof(szStartedThread));
        Wszwsprintf(strTmp.Ptr(), szUnstartedThread);
    }

    if (fAlreadySet)
    {
        strMsg.Alloc(lengthof(szTemplateMsgSet) + (UINT)strTmp.Size() + wcslen(szSTA) + wcslen(szMTA));
        if (state == Thread::ApartmentState::AS_InSTA)
            Wszwsprintf(strMsg.Ptr(), szTemplateMsgSet, strTmp.Ptr(), szSTA, szMTA);
        else
            Wszwsprintf(strMsg.Ptr(), szTemplateMsgSet, strTmp.Ptr(), szMTA, szSTA);
    }
    else
    {
        strMsg.Alloc(lengthof(szTemplateMsgChanged) + (UINT)strTmp.Size() + wcslen(szInSTA) + wcslen(szInMTA));
        if (state == Thread::ApartmentState::AS_InSTA)
            Wszwsprintf(strMsg.Ptr(), szTemplateMsgChanged, strTmp.Ptr(), szInSTA, szInMTA);
        else
            Wszwsprintf(strMsg.Ptr(), szTemplateMsgChanged, strTmp.Ptr(), szInMTA, szInSTA);
    }
    pCdh->LogInfo(strMsg.Ptr(), CustomerCheckedBuildProbe_Apartment);
}

#endif // CUSTOMER_CHECKED_BUILD
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\tpoolwrap.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/**
 * tpoolwrap.cpp
 * 
 * Wrapper for all threadpool functions. 
 * 
*/

#include "common.h"
#include "EEConfig.h"
#include "Win32ThreadPool.h"

typedef VOID (__stdcall *WAITORTIMERCALLBACK)(PVOID, BOOL); 


//+------------------------------------------------------------------------
//
//  Define inline functions which call through the global functions. The
//  functions are defined from entries in tpoolfns.h.
//
//-------------------------------------------------------------------------

#define STRUCT_ENTRY(FnName, FnType, FnParamList, FnArgs)   \
        FnType COM##FnName FnParamList                      \
        {                                                   \
            return ThreadpoolMgr::##FnName FnArgs;          \
        }                                                   \

#include "tpoolfnsp.h"

#undef STRUCT_ENTRY
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\tls.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
// TLS.H -
//
// Encapsulates TLS access for maximum performance. 
//


#ifndef __tls_h__
#define __tls_h__



// Pointer to a function that retrives the TLS data for a specific index.
typedef LPVOID (*POPTIMIZEDTLSGETTER)();




//---------------------------------------------------------------------------
// Creates a platform-optimized version of TlsGetValue compiled
// for a particular index. 
//
// LIMITATION: We make the client provide the function ("pGenericGetter") when the 
// access mode is TLSACCESS_GENERIC (all it has to do is call TlsGetValue
// for the specific TLS index.) This is because the generic getter has to
// be platform independent and the TLS manager can't create that at runtime.
// While it's possible to simulate these, it requires more machinery and code
// than is worth given that this service has only one or two clients.
//---------------------------------------------------------------------------
POPTIMIZEDTLSGETTER MakeOptimizedTlsGetter(DWORD tlsIndex, POPTIMIZEDTLSGETTER pGenericGetter);


//---------------------------------------------------------------------------
// Frees a function created by MakeOptimizedTlsGetter(). If the access
// mode was TLSACCESS_GENERIC, this function safely does nothing since
// the function was actually provided by the client.
//
// You must pass in the original TLS index used for the MakeOptimizedTlsGetter()
// call. This information is necessary because the tlsaccessmode is index-specific.
//---------------------------------------------------------------------------
VOID FreeOptimizedTlsGetter(DWORD tlsIndex, POPTIMIZEDTLSGETTER pOptimzedTlsGetter);



//---------------------------------------------------------------------------
// For ASM stub generators that want to inline Thread access for efficiency,
// the Thread manager uses these constants to define how to access the Thread.
//---------------------------------------------------------------------------
enum TLSACCESSMODE {
   TLSACCESS_GENERIC      = 1,   // Make no platform assumptions: use the API
#ifdef _X86_
   TLSACCESS_X86_W95      = 2,   // Assume X86, Win95-style TLS
   TLSACCESS_X86_WNT      = 3,   // Assume X86, WinNT-style TLS
   TLSACCESS_X86_WNT_HIGH = 4,   // Assume X86, WinNT5-style TLS, slot > 63
#endif // _X86_
};


//---------------------------------------------------------------------------
// Win95 and WinNT store the TLS in different places relative to the
// fs:[0]. This api reveals which. Can also return TLSACCESS_GENERIC if
// no info is available about the Thread location (you have to use the TlsGetValue
// api.) This is intended for use by stub generators that want to inline TLS
// access.
//---------------------------------------------------------------------------
TLSACCESSMODE GetTLSAccessMode(DWORD tlsIndex);   



#ifdef _X86_

//---------------------------------------------------------------------------
// Some OS-specific offsets.
//---------------------------------------------------------------------------
#define WINNT_TLS_OFFSET    0xe10     // TLS[0] at fs:[WINNT_TLS_OFFSET]
#define WINNT5_TLSEXPANSIONPTR_OFFSET 0xf94 // TLS[64] at [fs:[WINNT5_TLSEXPANSIONPTR_OFFSET]]
#define WIN95_TLSPTR_OFFSET 0x2c      // TLS[0] at [fs:[WIN95_TLSPTR_OFFSET]]

#endif // _X86_





#endif // __tls_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\tpoolwrap.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/**
 * tpoolwrap.h
 * 
 * Wrapper for all threadpool functions. 
 * 
*/

#include "common.h"

bool InitTpoolPlatformVariables();
void FreeTPoolPlatformVariables();
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\typehash.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//
// File: typehash.cpp
//
#include "common.h"
#include "excep.h"
#include "typehash.h"
#include "wsperf.h"


// ============================================================================
// Constructed type hash table methods
// ============================================================================
void *EETypeHashTable::operator new(size_t size, LoaderHeap *pHeap, DWORD dwNumBuckets)
{
    BYTE *              pMem;
    EETypeHashTable *  pThis;

    WS_PERF_SET_HEAP(LOW_FREQ_HEAP);    
    pMem = (BYTE *) pHeap->AllocMem(size + dwNumBuckets*sizeof(EETypeHashEntry_t*));
    if (pMem == NULL)
        return NULL;
    WS_PERF_UPDATE_DETAIL("EETypeHashTable new", size + dwNumBuckets*sizeof(EETypeHashEntry_t*), pMem);
    pThis = (EETypeHashTable *) pMem;

#ifdef _DEBUG
    pThis->m_dwDebugMemory = (DWORD)(size + dwNumBuckets*sizeof(EETypeHashEntry_t*));
#endif

    pThis->m_dwNumBuckets = dwNumBuckets;
    pThis->m_dwNumEntries = 0;
    pThis->m_pBuckets = (EETypeHashEntry_t**) (pMem + size);
    pThis->m_pHeap    = pHeap;

    // Don't need to memset() since this was VirtualAlloc()'d memory
    // memset(pThis->m_pBuckets, 0, dwNumBuckets*sizeof(EETypeHashEntry_t*));

    return pThis;
}


// Do nothing - heap allocated memory
void EETypeHashTable::operator delete(void *p)
{
}


// Do nothing - heap allocated memory
EETypeHashTable::~EETypeHashTable()
{
}


// Empty constructor
EETypeHashTable::EETypeHashTable()
{
}


EETypeHashEntry_t *EETypeHashTable::AllocNewEntry()
{
#ifdef _DEBUG
    m_dwDebugMemory += sizeof(EETypeHashEntry);
#endif
    WS_PERF_SET_HEAP(LOW_FREQ_HEAP);    

    EETypeHashEntry_t *pTmp = (EETypeHashEntry_t *) m_pHeap->AllocMem(sizeof(EETypeHashEntry));
    WS_PERF_UPDATE_DETAIL("EETypeHashTable:AllocNewEntry:sizeofEETypeHashEntry", sizeof(EETypeHashEntry), pTmp);
    WS_PERF_UPDATE_COUNTER (EECLASSHASH_TABLE, LOW_FREQ_HEAP, 1);
    WS_PERF_UPDATE_COUNTER (EECLASSHASH_TABLE_BYTES, LOW_FREQ_HEAP, sizeof(EETypeHashEntry));

    return pTmp;
}


//
// This function gets called whenever the class hash table seems way too small.
// Its task is to allocate a new bucket table that is a lot bigger, and transfer
// all the entries to it.
// 
void EETypeHashTable::GrowHashTable()
{
    THROWSCOMPLUSEXCEPTION();

    // Make the new bucket table 4 times bigger
    DWORD dwNewNumBuckets = m_dwNumBuckets * 4;
    EETypeHashEntry_t **pNewBuckets = (EETypeHashEntry_t **)m_pHeap->AllocMem(dwNewNumBuckets*sizeof(pNewBuckets[0]));

    if (pNewBuckets == NULL)
    {
        COMPlusThrowOM();
    }
    
    // Don't need to memset() since this was VirtualAlloc()'d memory
    // memset(pNewBuckets, 0, dwNewNumBuckets*sizeof(pNewBuckets[0]));

    // Run through the old table and transfer all the entries

    // Be sure not to mess with the integrity of the old table while
    // we are doing this, as there can be concurrent readers!  Note that
    // it is OK if the concurrent reader misses out on a match, though -
    // they will have to acquire the lock on a miss & try again.

    for (DWORD i = 0; i < m_dwNumBuckets; i++)
    {
        EETypeHashEntry_t * pEntry = m_pBuckets[i];

        // Try to lock out readers from scanning this bucket.  This is
        // obviously a race which may fail. However, note that it's OK
        // if somebody is already in the list - it's OK if we mess
        // with the bucket groups, as long as we don't destroy
        // anything.  The lookup function will still do appropriate
        // comparison even if it wanders aimlessly amongst entries
        // while we are rearranging things.  If a lookup finds a match
        // under those circumstances, great.  If not, they will have
        // to acquire the lock & try again anyway.

        m_pBuckets[i] = NULL;
        while (pEntry != NULL)
        {
            DWORD dwNewBucket = pEntry->dwHashValue % dwNewNumBuckets;
            EETypeHashEntry_t * pNextEntry  = pEntry->pNext;

            pEntry->pNext = pNewBuckets[dwNewBucket];
            pNewBuckets[dwNewBucket] = pEntry;

            pEntry = pNextEntry;
        }
    }

    // Finally, store the new number of buckets and the new bucket table
    m_dwNumBuckets = dwNewNumBuckets;
    m_pBuckets = pNewBuckets;
}


  // Calculate a hash value for a constructed type key
DWORD EETypeHashTable::Hash(NameHandle* pName)
{
    DWORD dwHash = 5381;

    dwHash = ((dwHash << 5) + dwHash) ^ pName->Key1;
    dwHash = ((dwHash << 5) + dwHash) ^ pName->Key2;

    return  dwHash;
}


EETypeHashEntry_t *EETypeHashTable::InsertValue(NameHandle* pName, HashDatum Data)
{
    _ASSERTE(m_dwNumBuckets != 0);
    _ASSERTE(pName->IsConstructed());

    DWORD           dwHash = Hash(pName);
    DWORD           dwBucket = dwHash % m_dwNumBuckets;
    EETypeHashEntry_t * pNewEntry;

    if (NULL == (pNewEntry = AllocNewEntry()))
        return NULL;

    pNewEntry->pNext     = m_pBuckets[dwBucket];
    m_pBuckets[dwBucket] = pNewEntry;

    pNewEntry->Data         = Data;
    pNewEntry->dwHashValue  = dwHash;
    pNewEntry->m_Key1          = pName->Key1;
    pNewEntry->m_Key2          = pName->Key2;

    m_dwNumEntries++;
    if  (m_dwNumEntries > m_dwNumBuckets*2)
        GrowHashTable();

    return pNewEntry;
}


EETypeHashEntry_t *EETypeHashTable::FindItem(NameHandle* pName)
{
    _ASSERTE(m_dwNumBuckets != 0);

    DWORD           dwHash = Hash(pName);
    DWORD           dwBucket = dwHash % m_dwNumBuckets;
    EETypeHashEntry_t * pSearch;

    for (pSearch = m_pBuckets[dwBucket]; pSearch; pSearch = pSearch->pNext)
    {
        if (pSearch->dwHashValue == dwHash && pSearch->m_Key1 == pName->Key1 && pSearch->m_Key2 == pName->Key2) {
                    return pSearch;
            }
    }

    return NULL;
}


EETypeHashEntry_t * EETypeHashTable::GetValue(NameHandle *pName, HashDatum *pData)
{
    EETypeHashEntry_t *pItem = FindItem(pName);

    if (pItem)
        *pData = pItem->Data;

    return pItem;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\typehandle.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
// ===========================================================================
// File: TYPEHANDLE.H
//n
// ===========================================================================

#ifndef TYPEHANDLE_H
#define TYPEHANDLE_H

#include <member-offset-info.h>

/*************************************************************************/
// A TypeHandle is the FUNDAMENTAL concept of type identity in the COM+
// runtime.  That is two types are equal if and only if their type handles
// are equal.  A TypeHandle, is a pointer sized struture that encodes 
// everything you need to know to figure out what kind of type you are
// actually dealing with.  

// At the present time a TypeHandle can point at two possible things
//
//      1) A MethodTable    (in the case where 'normal' class with an unshared method table). 
//      2) A TypeDesc       (all other cases)  
//
// TypeDesc in turn break down into several variants.  To the extent
// possible, you should probably be using TypeHandles, and only use
// TypeDesc* when you are 'deconstructing' a type into its component parts. 
//

class TypeDesc;
class ArrayTypeDesc;
class MethodTable;
class EEClass;
class Module;
class ExpandSig;
class Assembly;
class ReflectClass;
class BaseDomain;

#ifndef DEFINE_OBJECTREF
#define DEFINE_OBJECTREF
#ifdef _DEBUG
class OBJECTREF;
#else
class Object;
typedef Object *        OBJECTREF;
#endif
#endif

class TypeHandle 
{
public:
    TypeHandle() { 
        m_asPtr = 0; 
    }

    explicit TypeHandle(void* aPtr)     // somewhat unsafe, would be nice to get rid of
    { 
        m_asPtr = aPtr; 
        INDEBUG(Verify());
    }  

    TypeHandle(MethodTable* aMT) {
        m_asMT = aMT; 
        INDEBUG(Verify());
    }

    TypeHandle(EEClass* aClass);

    TypeHandle(TypeDesc *aType) {
        m_asInt = (((INT_PTR) aType) | 2); 
        INDEBUG(Verify());
    }

    int operator==(const TypeHandle& typeHnd) const {
        return(m_asPtr == typeHnd.m_asPtr);
    }

    int operator!=(const TypeHandle& typeHnd) const {
        return(m_asPtr != typeHnd.m_asPtr);
    }

        // Methods for probing exactly what kind of a type handle we have
    BOOL IsNull() const { 
        return(m_asPtr == 0); 
    }
    FORCEINLINE BOOL IsUnsharedMT() const {
        return((m_asInt & 2) == 0); 
    }
    BOOL IsTypeDesc() const  {
        return(!IsUnsharedMT());
    }

    BOOL IsEnum();

        // Methods to allow you get get a the two possible representations
    MethodTable* AsMethodTable() {        
        // ******************TEMPORARILY COMMENTED OUT. TarunA to fix it.
        //_ASSERTE(IsUnsharedMT());
        //_ASSERTE(m_asMT == NULL || m_asMT == m_asMT->GetClass()->GetMethodTable());
        return(m_asMT);
    }

    TypeDesc* AsTypeDesc() {
        _ASSERTE(IsTypeDesc());
        return (TypeDesc*) (m_asInt & ~2);
    }

    // To the extent possible, you should try to use methods like the ones
    // below that treat all types uniformly.

    // Gets the size that this type would take up embedded in another object
    // thus objects all return sizeof(void*).  
    unsigned GetSize();

    // Store the full, correct, name for this type into the given buffer.  
    unsigned GetName(char* buff, unsigned buffLen);

        // Returns the ELEMENT_TYPE_* that you would use in a signature
    CorElementType GetSigCorElementType() {
        if (IsEnum())
            return(ELEMENT_TYPE_VALUETYPE);
        return(GetNormCorElementType());
        }
        
        // This version normalizes enum types to be their underlying type
    CorElementType GetNormCorElementType(); 

        // returns true of 'this' can be cast to 'type' 
    BOOL CanCastTo(TypeHandle type);
    
        // get the parent (superclass) of this type
    TypeHandle GetParent(); 

        // Unlike the AsMethodTable, GetMethodTable, will get the method table
        // of the type, regardless of whether it is an array etc. Note, however
        // this method table may be shared, and some types (like TypeByRef), have
        // no method table 
    MethodTable* GetMethodTable();

    Module* GetModule();

    Assembly* GetAssembly();

    EEClass* GetClass();

        // Shortcuts
    BOOL IsArray();
    BOOL IsByRef();
    BOOL IsRestored();
    void CheckRestore();

    // Not clear we should have this.  
    ArrayTypeDesc* AsArray();

    EEClass* AsClass();                // Try not to use this one too much

    void* AsPtr() {                     // Please don't use this if you can avoid it
        return(m_asPtr); 
    }

    INDEBUG(BOOL Verify();)             // DEBUGGING Make certain this is a valid type handle 

#if CHECK_APP_DOMAIN_LEAKS
    BOOL IsAppDomainAgile();
    BOOL IsCheckAppDomainAgile();

    BOOL IsArrayOfElementsAppDomainAgile();
    BOOL IsArrayOfElementsCheckAppDomainAgile();
#endif

    EEClass* GetClassOrTypeParam();

    OBJECTREF CreateClassObj();
    
    static TypeHandle MergeArrayTypeHandlesToCommonParent(
        TypeHandle ta, TypeHandle tb);

    static TypeHandle MergeTypeHandlesToCommonParent(
        TypeHandle ta, TypeHandle tb);

private:
    union 
    {
        INT_PTR         m_asInt;        // we look at the low order bits 
        void*           m_asPtr;
        TypeDesc*       m_asTypeDesc;
        MethodTable*    m_asMT;
    };
};


/*************************************************************************/
/* TypeDesc is a discriminated union of all types that can not be directly
   represented by a simple MethodTable*.  These include all parameterized 
   types, as well as others.    The discrimintor of the union at the present
   time is the CorElementType numeration.  The subclass of TypeDesc are
   the possible variants of the union.  
*/ 

class TypeDesc {
    friend struct MEMBER_OFFSET_INFO(TypeDesc);
public:
    TypeDesc(CorElementType type) { 
        m_Type = type;
        INDEBUG(m_IsParamDesc = 0;)
    }

    // This is the ELEMENT_TYPE* that would be used in the type sig for this type
    // For enums this is the uderlying type
    CorElementType GetNormCorElementType() { 
        return (CorElementType) m_Type;
    }

    // Get the parent (superclass) of this type  
    TypeHandle GetParent();

    // Returns the name of the array.  Note that it returns
    // the length of the returned string 
    static unsigned ConstructName(CorElementType kind, TypeHandle param, int rank, 
                                  char* buff, unsigned buffLen);
    unsigned GetName(char* buff, unsigned buffLen);

    BOOL CanCastTo(TypeHandle type);

    BOOL TypeDesc::IsByRef() {              // BYREFS are often treated specially 
        return(GetNormCorElementType() == ELEMENT_TYPE_BYREF);
    }



    Module* GetModule();

    Assembly* GetAssembly();

    MethodTable*  GetMethodTable();         // only meaningful for ParamTypeDesc
    TypeHandle GetTypeParam();              // only meaningful for ParamTypeDesc
    BaseDomain *GetDomain();                // only meaningful for ParamTypeDesc

protected:
    // Strike needs to be able to determine the offset of certain bitfields.
    // Bitfields can't be used with /offsetof/.
    // Thus, the union/structure combination is used to determine where the
    // bitfield begins, without adding any additional space overhead.
    union
        {
        unsigned char m_Type_begin;
        struct
            {
            // This is used to discriminate what kind of TypeDesc we are
            CorElementType  m_Type : 8;
            INDEBUG(unsigned m_IsParamDesc : 1;)    // is a ParamTypeDesc
                // unused bits  
            };
        };
};

/*************************************************************************/
// This variant is used for parameterized types that have exactly one argument
// type.  This includes arrays, byrefs, pointers.  

class ParamTypeDesc : public TypeDesc {
    friend class TypeDesc;
    friend class JIT_TrialAlloc;
    friend struct MEMBER_OFFSET_INFO(ParamTypeDesc);

public:
    ParamTypeDesc(CorElementType type, MethodTable* pMT, TypeHandle arg) 
        : TypeDesc(type), m_TemplateMT(pMT), m_Arg(arg), m_ReflectClassObject(NULL) {
        INDEBUG(m_IsParamDesc = 1;)
        INDEBUG(Verify());
    }

    INDEBUG(BOOL Verify();)

    OBJECTREF CreateClassObj();
    ReflectClass* GetReflectClassIfExists() { return m_ReflectClassObject; }

    friend class StubLinkerCPU;
protected:
        // the m_Type field in TypeDesc tell what kind of parameterized type we have
    MethodTable*    m_TemplateMT;       // The shared method table, some variants do not use this field (it is null)
    TypeHandle      m_Arg;              // The type that is being modifiedj
    ReflectClass    *m_ReflectClassObject;    // pointer back to the internal reflection Type object
};

/*************************************************************************/
/* represents a function type.  */

class FunctionTypeDesc : public TypeDesc {
public:
    FunctionTypeDesc(CorElementType type, ExpandSig* sig) 
        : TypeDesc(type), m_Sig(sig) {
        _ASSERTE(type == ELEMENT_TYPE_FNPTR);   // At the moment only one possibile function type
    }
    ExpandSig* GetSig()     { return(m_Sig); }
    
protected:
    ExpandSig* m_Sig;       // Signature for function type
};

#endif TYPEHANDLE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\util.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
// ===========================================================================
// File: UTIL.CPP
// 
// 
// ===========================================================================

#include "common.h"
#include "excep.h"
#include <shfolder.h>

#ifdef _DEBUG
#include <winbase.h>
#endif

#define MESSAGE_LENGTH       1024

// Helper function that encapsulates the parsing rules.
//
// Called first with *pdstout == NULL to figure out how many args there are
// and the size of the required destination buffer.
//
// Called again with a nonnull *pdstout to fill in the actual buffer.
//
// Returns the # of arguments.
static UINT ParseCommandLine(LPCWSTR psrc, LPWSTR *pdstout)
{
    UINT    argcount = 1;       // discovery of arg0 is unconditional, below
    LPWSTR  pdst     = *pdstout;
    BOOL    fDoWrite = (pdst != NULL);

    BOOL    fInQuotes;
    int     iSlash;

    /* A quoted program name is handled here. The handling is much
       simpler than for other arguments. Basically, whatever lies
       between the leading double-quote and next one, or a terminal null
       character is simply accepted. Fancier handling is not required
       because the program name must be a legal NTFS/HPFS file name.
       Note that the double-quote characters are not copied, nor do they
       contribute to numchars.
         
       This "simplification" is necessary for compatibility reasons even
       though it leads to mishandling of certain cases.  For example,
       "c:\tests\"test.exe will result in an arg0 of c:\tests\ and an
       arg1 of test.exe.  In any rational world this is incorrect, but
       we need to preserve compatibility.
    */

    LPCWSTR pStart = psrc;
    BOOL    skipQuote = FALSE;

    if (*psrc == L'\"')
    {
        // scan from just past the first double-quote through the next
        // double-quote, or up to a null, whichever comes first
        while ((*(++psrc) != L'\"') && (*psrc != L'\0'))
            continue;

        skipQuote = TRUE;
    }
    else
    {
        /* Not a quoted program name */

        while (!ISWWHITE(*psrc) && *psrc != L'\0')
            psrc++;
    }

    // We have now identified arg0 as pStart (or pStart+1 if we have a leading
    // quote) through psrc-1 inclusive
    if (skipQuote)
        pStart++;
    while (pStart < psrc)
    {
        if (fDoWrite)
            *pdst = *pStart;

        pStart++;
        pdst++;
    }

    // And terminate it.
    if (fDoWrite)
        *pdst = L'\0';

    pdst++;

    // if we stopped on a double-quote when arg0 is quoted, skip over it
    if (skipQuote && *psrc == L'\"')
        psrc++;

    while ( *psrc != L'\0')
    {
LEADINGWHITE:

        // The outofarg state.
        while (ISWWHITE(*psrc))
            psrc++;

        if (*psrc == L'\0')
            break;
        else
        if (*psrc == L'#')
        {
            while (*psrc != L'\0' && *psrc != L'\n')
                psrc++;     // skip to end of line

            goto LEADINGWHITE;
        }

        argcount++;
        fInQuotes = FALSE;

        while ((!ISWWHITE(*psrc) || fInQuotes) && *psrc != L'\0')
        {
            switch (*psrc)
            {
            case L'\\':
                iSlash = 0;
                while (*psrc == L'\\')
                {
                    iSlash++;
                    psrc++;
                }

                if (*psrc == L'\"')
                {
                    for ( ; iSlash >= 2; iSlash -= 2)
                    {
                        if (fDoWrite)
                            *pdst = L'\\';

                        pdst++;
                    }

                    if (iSlash & 1)
                    {
                        if (fDoWrite)
                            *pdst = *psrc;

                        psrc++;
                        pdst++;
                    }
                    else
                    {
                        fInQuotes = !fInQuotes;
                        psrc++;
                    }
                }
                else
                    for ( ; iSlash > 0; iSlash--)
                    {
                        if (fDoWrite)
                            *pdst = L'\\';

                        pdst++;
                    }

                break;

            case L'\"':
                fInQuotes = !fInQuotes;
                psrc++;
                break;

            default:
                if (fDoWrite)
                    *pdst = *psrc;

                psrc++;
                pdst++;
            }
        }

        if (fDoWrite)
            *pdst = L'\0';

        pdst++;
    }


    _ASSERTE(*psrc == L'\0');
    *pdstout = pdst;
    return argcount;
}


// Function to parse apart a command line and return the 
// arguments just like argv and argc
// This function is a little funky because of the pointer work
// but it is cool because it allows the recipient of the char**
// to only have to do a single delete []
LPWSTR* CommandLineToArgvW(LPWSTR lpCmdLine, DWORD *pNumArgs)
{

    DWORD argcount = 0;
    LPWSTR retval = NULL;
    LPWSTR *pslot;
    DWORD* slot = 0;
    // First we need to find out how many strings there are in the command line
    _ASSERTE(lpCmdLine);
    _ASSERTE(pNumArgs);

    LPWSTR pdst = NULL;
    argcount = ParseCommandLine(lpCmdLine, &pdst);

    // This check is because on WinCE the Application Name is not passed in as an argument to the app!
    if (argcount == 0)
    {
        *pNumArgs = 0;
        return NULL;
    }

    // Now we need alloc a buffer the size of the command line + the number of strings * DWORD
    retval = new (nothrow) WCHAR[(argcount*sizeof(WCHAR*))/sizeof(WCHAR) + (pdst - (LPWSTR)NULL)];
    if(!retval)
        return NULL;

    pdst = (LPWSTR)( argcount*sizeof(LPWSTR*) + (BYTE*)retval );
    ParseCommandLine(lpCmdLine, &pdst);
    pdst = (LPWSTR)( argcount*sizeof(LPWSTR*) + (BYTE*)retval );
    pslot = (LPWSTR*)retval;
    for (DWORD i = 0; i < argcount; i++)
    {
        *(pslot++) = pdst;
        while (*pdst != L'\0')
        {
            pdst++;
        }
        pdst++;
    }

    

    *pNumArgs = argcount;
    return (LPWSTR*)retval;

}




//************************************************************************
// CQuickHeap
//
// A fast non-multithread-safe heap for short term use.
// Destroying the heap frees all blocks allocated from the heap.
// Blocks cannot be freed individually.
//
// The heap uses COM+ exceptions to report errors.
//
// The heap does not use any internal synchronization so it is not
// multithreadsafe.
//************************************************************************
CQuickHeap::CQuickHeap()
{
    m_pFirstQuickBlock    = NULL;
    m_pFirstBigQuickBlock = NULL;
    m_pNextFree           = NULL;
}

CQuickHeap::~CQuickHeap()
{
    QuickBlock *pQuickBlock = m_pFirstQuickBlock;
    while (pQuickBlock) {
        QuickBlock *ptmp = pQuickBlock;
        pQuickBlock = pQuickBlock->m_next;
        delete [] (BYTE*)ptmp;
    }

    pQuickBlock = m_pFirstBigQuickBlock;
    while (pQuickBlock) {
        QuickBlock *ptmp = pQuickBlock;
        pQuickBlock = pQuickBlock->m_next;
        delete [] (BYTE*)ptmp;
    }
}




LPVOID CQuickHeap::Alloc(UINT sz)
{
    THROWSCOMPLUSEXCEPTION();

    sz = (sz+7) & ~7;

    if ( sz > kBlockSize ) {

        QuickBlock *pQuickBigBlock = (QuickBlock*) new BYTE[sz + sizeof(QuickBlock) - 1];
        if (!pQuickBigBlock) {
            COMPlusThrowOM();
        }
        pQuickBigBlock->m_next = m_pFirstBigQuickBlock;
        m_pFirstBigQuickBlock = pQuickBigBlock;

        return pQuickBigBlock->m_bytes;


    } else {
        if (m_pNextFree == NULL || sz > (UINT)( &(m_pFirstQuickBlock->m_bytes[kBlockSize]) - m_pNextFree )) {
            QuickBlock *pQuickBlock = (QuickBlock*) new BYTE[kBlockSize + sizeof(QuickBlock) - 1];
            if (!pQuickBlock) {
                COMPlusThrowOM();
            }
            pQuickBlock->m_next = m_pFirstQuickBlock;
            m_pFirstQuickBlock = pQuickBlock;
            m_pNextFree = pQuickBlock->m_bytes;
        }
        LPVOID pv = m_pNextFree;
        m_pNextFree += sz;
        return pv;
    }
}

//----------------------------------------------------------------------------
//
// ReserveAlignedMemory - Reserves aligned address space.
//
// This routine assumes it is passed reasonable align and size values.
// Not much error checking is performed...
//
// NOTE: This routine uses a static which is not synchronized.  This is OK.
//
//----------------------------------------------------------------------------

LPVOID _ReserveAlignedMemoryWorker(LPVOID lpvAddr, LPVOID lpvTop, DWORD dwAlign, DWORD dwSize)
{
    // precompute some alignment helpers
    size_t dwAlignRound = dwAlign - 1;
    size_t dwAlignMask = ~dwAlignRound;

    // to avoid overflow, diminish the 
    lpvTop = (LPVOID)((size_t)lpvTop - dwAlignRound);

    while (lpvAddr <= lpvTop)
    {
        MEMORY_BASIC_INFORMATION mbe;

        // align the query address
        lpvAddr = (LPVOID)(((size_t)lpvAddr + dwAlignRound) & dwAlignMask);

        // query the region's charactersitics
        if (!VirtualQuery((LPCVOID)lpvAddr, &mbe, sizeof(mbe)))
            break;

        // see if this is a suitable region - if so then try to grab it
        if ((lpvAddr != 0) && (mbe.State == MEM_FREE) && (mbe.RegionSize >= dwSize) &&
            VirtualAlloc(lpvAddr, dwSize, MEM_RESERVE, PAGE_NOACCESS))
        {
            // ok we got it
            return lpvAddr;
        }

        // skip ahead to the next region
        lpvAddr = (LPVOID)((size_t)lpvAddr + mbe.RegionSize);
    }

    return 0;
}

LPCVOID ReserveAlignedMemory(DWORD dwAlign, DWORD dwSize)
{
    // preinit our hint address to just after the start of the NULL region
    static LPVOID lpvAddrHint = (LPVOID)1;

    // scan the address space from our hint point to the top
    LPVOID lpvAddr = _ReserveAlignedMemoryWorker(lpvAddrHint, (LPVOID) 0xFFFFFFFFFFFFFFFF, dwAlign, dwSize);

    // if that failed then scan from the bottom up to our hint point
    if (!lpvAddr)
        lpvAddr = _ReserveAlignedMemoryWorker(0, lpvAddrHint, dwAlign, dwSize);

    // update the hint to one byte after dwAddr (which may be zero)
    lpvAddrHint = (LPVOID)(((size_t)lpvAddr) + 1);

    // return the base address of the memory we reserved
    return (LPCVOID)lpvAddr;
}


//----------------------------------------------------------------------------
// Figure out what kind of process we are running in by looking at the PE
// header for the EXE which kicked us off.
//----------------------------------------------------------------------------
DWORD RootImageType()
{
    // Get the EXE's base address from Win32, then go to the NT header to find
    // the subsystem field which tells us what we have.  Note that we are
    // asking for the handle for this process which can't ever come back NULL
    // or you are seriously messed up.  Assert that this works correctly instead
    // if adding failure logic.
    HMODULE hExe = WszGetModuleHandle(NULL);
    _ASSERTE(hExe != NULL);

    IMAGE_DOS_HEADER *pDOS = (IMAGE_DOS_HEADER*) hExe;
    IMAGE_NT_HEADERS *pNT = (IMAGE_NT_HEADERS*) (pDOS->e_lfanew + (UINT_PTR) hExe);

    // Sanity check we have a real header and didn't mess up this parsing.
    _ASSERTE((pNT->Signature == IMAGE_NT_SIGNATURE) &&
        (pNT->FileHeader.SizeOfOptionalHeader == IMAGE_SIZEOF_NT_OPTIONAL_HEADER) &&
        (pNT->OptionalHeader.Magic == IMAGE_NT_OPTIONAL_HDR_MAGIC));
    
    // Return the subsystem type.
    return (pNT->OptionalHeader.Subsystem);
}


//----------------------------------------------------------------------------
// Output functions that avoid the crt's.
//----------------------------------------------------------------------------

#ifdef PLATFORM_WIN32
static
void NPrintToHandleA(HANDLE Handle, const char *pszString, size_t BytesToWrite)
{
    if (Handle == INVALID_HANDLE_VALUE || Handle == NULL)
        return;

    BOOL success;
    DWORD   dwBytesWritten;
    const int maxWriteFileSize = 32767; // This is somewhat arbitrary limit, but 2**16-1 doesn't work

    while (BytesToWrite > 0) {
        DWORD dwChunkToWrite = (DWORD) min(BytesToWrite, maxWriteFileSize);
        if (dwChunkToWrite < BytesToWrite) {
            // must go by char to find biggest string that will fit, taking DBCS chars into account
            dwChunkToWrite = 0;
            const char *charNext = pszString;
            while (dwChunkToWrite < maxWriteFileSize-2 && charNext) {
                charNext = CharNextExA(0, pszString+dwChunkToWrite, 0);
                dwChunkToWrite = (DWORD)(charNext - pszString);
            }
        }
        
        // Try to write to handle.  If this is not a CUI app, then this is probably
        // not going to work unless the dev took special pains to set their own console
        // handle during CreateProcess.  So try it, but don't yell if it doesn't work in
        // that case.  Also, if we redirect stdout to a pipe then the pipe breaks (ie, we 
        // write to something like the UNIX head command), don't complain.
        success = WriteFile(Handle, pszString, dwChunkToWrite, &dwBytesWritten, NULL);
        if (!success)
        {
            HRESULT hr = GetLastError();
#ifdef _DEBUG
            // This can happen if stdout is a closed pipe.  This might not help
            // much, but we'll have half a chance of seeing this.
            OutputDebugStringA("Writing out an unhandled exception to stdout failed!\n");
            OutputDebugStringA(pszString);
#endif
            _ASSERTE((RootImageType() != IMAGE_SUBSYSTEM_WINDOWS_CUI) ||
                     hr == ERROR_BROKEN_PIPE || hr == ERROR_NO_DATA);
            break;
        }
        else {
            _ASSERTE(dwBytesWritten == dwChunkToWrite);
        }
        pszString = pszString + dwChunkToWrite;
        BytesToWrite -= dwChunkToWrite;
    }

}

static 
void PrintToHandleA(HANDLE Handle, const char *pszString)
{
    size_t len = strlen(pszString);
    NPrintToHandleA(Handle, pszString, len);
}

#endif // !PLATFORM_WIN32

void PrintToStdOutA(const char *pszString) {
#ifdef PLATFORM_WIN32
    HANDLE  Handle = GetStdHandle(STD_OUTPUT_HANDLE);
    PrintToHandleA(Handle, pszString);
#else // !PLATFORM_WIN32
    printf (pszString) ;
#endif // !PLATFORM_WIN32
}


void PrintToStdOutW(const WCHAR *pwzString)
{
#ifdef PLATFORM_WIN32
    MAKE_MULTIBYTE_FROMWIDE_BESTFIT(pStr, pwzString, GetConsoleOutputCP());
    PrintToStdOutA(pStr);
#else // !PLATFORM_WIN32
    wprintf(pwzString);
#endif // !PLATFORM_WIN32
}

void PrintToStdErrA(const char *pszString) {
#ifdef PLATFORM_WIN32
    HANDLE  Handle = GetStdHandle(STD_ERROR_HANDLE);
    PrintToHandleA(Handle, pszString);
#else // !PLATFORM_WIN32
    fprintf (stderr, pszString) ;
#endif // !PLATFORM_WIN32
}


void PrintToStdErrW(const WCHAR *pwzString)
{
#ifdef PLATFORM_WIN32
    MAKE_MULTIBYTE_FROMWIDE_BESTFIT(pStr, pwzString, GetConsoleOutputCP());
    PrintToStdErrA(pStr);
#else // !PLATFORM_WIN32
    fwprintf(stderr, pwzString);
#endif // !PLATFORM_WIN32
}



void NPrintToStdOutA(const char *pszString, size_t nbytes) {
#ifdef PLATFORM_WIN32
    HANDLE  Handle = GetStdHandle(STD_OUTPUT_HANDLE);
    NPrintToHandleA(Handle, pszString, nbytes);
#else // !PLATFORM_WIN32
    fwrite(pwzString, 1, nbytes, stderr);
#endif // !PLATFORM_WIN32
}


void NPrintToStdOutW(const WCHAR *pwzString, size_t nchars)
{
#ifdef PLATFORM_WIN32
    LPSTR pStr;
    MAKE_MULTIBYTE_FROMWIDEN_BESTFIT(pStr, pwzString, (int)nchars, nbytes, GetConsoleOutputCP());
    NPrintToStdOutA(pStr, nbytes);
#else // !PLATFORM_WIN32
    _ASSERTE(!"Platform NYI");
#endif // !PLATFORM_WIN32
}

void NPrintToStdErrA(const char *pszString, size_t nbytes) {
#ifdef PLATFORM_WIN32
    HANDLE  Handle = GetStdHandle(STD_ERROR_HANDLE);
    NPrintToHandleA(Handle, pszString, nbytes);
#else // !PLATFORM_WIN32
    fwrite(pwzString, 1, nbytes, stderr);
#endif // !PLATFORM_WIN32
}


void NPrintToStdErrW(const WCHAR *pwzString, size_t nchars)
{
#ifdef PLATFORM_WIN32
    LPSTR pStr;
    MAKE_MULTIBYTE_FROMWIDEN_BESTFIT(pStr, pwzString, (int)nchars, nbytes, GetConsoleOutputCP());
    NPrintToStdErrA(pStr, nbytes);
#else // !PLATFORM_WIN32
    _ASSERTE(!"Platform NYI");
#endif // !PLATFORM_WIN32
}
//----------------------------------------------------------------------------





//+--------------------------------------------------------------------------
//
//  Microsoft Confidential.
//  
//  Function:   VMDebugOutputA( . . . . )
//              VMDebugOutputW( . . . . )
//  
//  Synopsis:   Output a message formatted in printf fashion to the debugger.
//              ANSI and wide character versions are both provided.  Only 
//              present in debug builds (i.e. when _DEBUG is defined).
//
//  Arguments:  [format]     ---   ANSI or Wide character format string
//                                 in printf/OutputDebugString-style format.
// 
//              [ ... ]      ---   Variable length argument list compatible
//                                 with the format string.
//
//  Returns:    Nothing.
//
//  History:    5/27/1998  JerryK  Created
// 
//  Notes:      Has internal static sized character buffer of 
//              width specified by the preprocessor constant DEBUGOUT_BUFSIZE.
//
//---------------------------------------------------------------------------
#ifdef _DEBUG

#define DEBUGOUT_BUFSIZE 1024

void __cdecl VMDebugOutputA(LPSTR format, ...)
{
    va_list     argPtr;
    va_start(argPtr, format);

    char szBuffer[DEBUGOUT_BUFSIZE];

    if(_vsnprintf(szBuffer, DEBUGOUT_BUFSIZE-1, format, argPtr) > 0)
        OutputDebugStringA(szBuffer);
    va_end(argPtr);
}

void __cdecl VMDebugOutputW(LPWSTR format, ...)
{
    va_list     argPtr;
    va_start(argPtr, format);
    
    WCHAR wszBuffer[DEBUGOUT_BUFSIZE];

    if(_vsnwprintf(wszBuffer, DEBUGOUT_BUFSIZE-2, format, argPtr) > 0)
        WszOutputDebugString(wszBuffer);
    va_end(argPtr);
}

#endif   // #ifdef _DEBUG

//*****************************************************************************
// Compare VarLoc's
//*****************************************************************************

bool operator ==(const ICorDebugInfo::VarLoc &varLoc1,
                 const ICorDebugInfo::VarLoc &varLoc2)
{
    if (varLoc1.vlType != varLoc2.vlType)
        return false;

    switch(varLoc1.vlType)
    {
    case ICorDebugInfo::VLT_REG:
        return varLoc1.vlReg.vlrReg == varLoc2.vlReg.vlrReg;

    case ICorDebugInfo::VLT_STK: 
        return varLoc1.vlStk.vlsBaseReg == varLoc2.vlStk.vlsBaseReg &&
               varLoc1.vlStk.vlsOffset  == varLoc2.vlStk.vlsOffset;

    case ICorDebugInfo::VLT_REG_REG:
        return varLoc1.vlRegReg.vlrrReg1 == varLoc2.vlRegReg.vlrrReg1 &&
               varLoc1.vlRegReg.vlrrReg2 == varLoc2.vlRegReg.vlrrReg2;

    case ICorDebugInfo::VLT_REG_STK:
        return varLoc1.vlRegStk.vlrsReg == varLoc2.vlRegStk.vlrsReg &&
               varLoc1.vlRegStk.vlrsStk.vlrssBaseReg == varLoc2.vlRegStk.vlrsStk.vlrssBaseReg &&
               varLoc1.vlRegStk.vlrsStk.vlrssOffset == varLoc2.vlRegStk.vlrsStk.vlrssOffset;

    case ICorDebugInfo::VLT_STK_REG:
        return varLoc1.vlStkReg.vlsrStk.vlsrsBaseReg == varLoc2.vlStkReg.vlsrStk.vlsrsBaseReg &&
               varLoc1.vlStkReg.vlsrStk.vlsrsOffset == varLoc2.vlStkReg.vlsrStk.vlsrsBaseReg &&
               varLoc1.vlStkReg.vlsrReg == varLoc2.vlStkReg.vlsrReg;

    case ICorDebugInfo::VLT_STK2:
        // @TODO : VLT_STK(2) is overloaded to also indicate valueclasses 
        // which should be VLT_STK_n. Just have a parameterized VLT_STK_n.
        return varLoc1.vlStk2.vls2BaseReg == varLoc1.vlStk2.vls2BaseReg &&
               varLoc1.vlStk2.vls2Offset == varLoc1.vlStk2.vls2Offset;

    case ICorDebugInfo::VLT_FPSTK:
        return varLoc1.vlFPstk.vlfReg == varLoc1.vlFPstk.vlfReg;

    default:
        _ASSERTE(!"Bad vlType"); return false;
    }
}

//*****************************************************************************
// Size of the variable represented by NativeVarInfo
//*****************************************************************************

SIZE_T  NativeVarSize(const ICorDebugInfo::VarLoc & varLoc)
{
    switch(varLoc.vlType)
    {
    case ICorDebugInfo::VLT_REG:
        return sizeof(DWORD);

    case ICorDebugInfo::VLT_STK: 
        return sizeof(DWORD);

    case ICorDebugInfo::VLT_REG_REG:
    case ICorDebugInfo::VLT_REG_STK:
    case ICorDebugInfo::VLT_STK_REG:
        return 2*sizeof(DWORD);

    case ICorDebugInfo::VLT_STK2:
        // @TODO : VLT_STK(2) is overloaded to also indicate valueclasses 
        // which should be VLT_STK_n. Just have a parameterized VLT_STK_n.
        return 2*sizeof(DWORD);

    case ICorDebugInfo::VLT_FPSTK:
        return 2*sizeof(DWORD);

    default:
        _ASSERTE(!"Bad vlType"); return false;
    }
}

//*****************************************************************************
// The following are used to read and write data given NativeVarInfo
// for primitive types. For ValueClasses, FALSE will be returned.
//*****************************************************************************

SIZE_T  GetRegOffsInCONTEXT(ICorDebugInfo::RegNum regNum)
{
#ifdef _X86_
    switch(regNum)
    {
    case ICorDebugInfo::REGNUM_EAX: return offsetof(CONTEXT,Eax);
    case ICorDebugInfo::REGNUM_ECX: return offsetof(CONTEXT,Ecx);
    case ICorDebugInfo::REGNUM_EDX: return offsetof(CONTEXT,Edx);
    case ICorDebugInfo::REGNUM_EBX: return offsetof(CONTEXT,Ebx);
    case ICorDebugInfo::REGNUM_ESP: return offsetof(CONTEXT,Esp);
    case ICorDebugInfo::REGNUM_EBP: return offsetof(CONTEXT,Ebp);
    case ICorDebugInfo::REGNUM_ESI: return offsetof(CONTEXT,Esi);
    case ICorDebugInfo::REGNUM_EDI: return offsetof(CONTEXT,Edi);
    default: _ASSERTE(!"Bad regNum"); return -1;
    }
#else //!_X86_
    _ASSERT(!"@TODO Alpha - GetRegOffsInCONTEXT (util.cpp)");
    return -1;
#endif //_X86_
}


// Returns the location at which the variable
// begins.  Returns NULL for register vars.  For reg-stack
// split, it'll return the addr of the stack part.
// This also works for VLT_REG (a single register).
DWORD *NativeVarStackAddr(const ICorDebugInfo::VarLoc &   varLoc, 
                          PCONTEXT                        pCtx)
{
    DWORD *dwAddr = NULL;
    
    switch(varLoc.vlType)
    {
        SIZE_T          regOffs;
        const BYTE *    baseReg;

    case ICorDebugInfo::VLT_REG:       
        regOffs = GetRegOffsInCONTEXT(varLoc.vlReg.vlrReg);
        dwAddr = (DWORD *)(regOffs + (BYTE*)pCtx);
        LOG((LF_CORDB, LL_INFO100, "NVSA: STK_REG @ 0x%x\n", dwAddr));
        break;
        
    case ICorDebugInfo::VLT_STK:       
        regOffs = GetRegOffsInCONTEXT(varLoc.vlStk.vlsBaseReg);
        baseReg = (const BYTE *)*(size_t *)(regOffs + (BYTE*)pCtx);
        dwAddr  = (DWORD *)(baseReg + varLoc.vlStk.vlsOffset);

        LOG((LF_CORDB, LL_INFO100, "NVSA: VLT_STK @ 0x%x\n",dwAddr));
        break;

    case ICorDebugInfo::VLT_STK2:      
        // @TODO : VLT_STK2 is overloaded to also mean VLT_STK_n.
        // return FALSE if n > 2;

        regOffs = GetRegOffsInCONTEXT(varLoc.vlStk2.vls2BaseReg);
        baseReg = (const BYTE *)*(size_t *)(regOffs + (BYTE*)pCtx);
        dwAddr = (DWORD *)(baseReg + varLoc.vlStk2.vls2Offset);
        LOG((LF_CORDB, LL_INFO100, "NVSA: VLT_STK_2 @ 0x%x\n",dwAddr));
        break;

    case ICorDebugInfo::VLT_REG_STK:   
        regOffs = GetRegOffsInCONTEXT(varLoc.vlRegStk.vlrsStk.vlrssBaseReg);
        baseReg = (const BYTE *)*(size_t *)(regOffs + (BYTE*)pCtx);
        dwAddr = (DWORD *)(baseReg + varLoc.vlRegStk.vlrsStk.vlrssOffset);
        LOG((LF_CORDB, LL_INFO100, "NVSA: REG_STK @ 0x%x\n",dwAddr));
        break;

    case ICorDebugInfo::VLT_STK_REG:
        regOffs = GetRegOffsInCONTEXT(varLoc.vlStkReg.vlsrStk.vlsrsBaseReg);
        baseReg = (const BYTE *)*(size_t *)(regOffs + (BYTE*)pCtx);
        dwAddr = (DWORD *)(baseReg + varLoc.vlStkReg.vlsrStk.vlsrsOffset);
        LOG((LF_CORDB, LL_INFO100, "NVSA: STK_REG @ 0x%x\n",dwAddr));
        break;

    case ICorDebugInfo::VLT_REG_REG:   
    case ICorDebugInfo::VLT_FPSTK:     
         _ASSERTE(!"NYI"); break;

    default:            
         _ASSERTE(!"Bad locType"); break;
    }

    return dwAddr;

}

bool    GetNativeVarVal(const ICorDebugInfo::VarLoc &   varLoc, 
                        PCONTEXT                        pCtx,
                        DWORD                       *   pVal1, 
                        DWORD                       *   pVal2)
{

    switch(varLoc.vlType)
    {
        SIZE_T          regOffs;

    case ICorDebugInfo::VLT_REG:       
        *pVal1  = *NativeVarStackAddr(varLoc,pCtx);
        break;

    case ICorDebugInfo::VLT_STK:       
        *pVal1  = *NativeVarStackAddr(varLoc,pCtx);
        break;

    case ICorDebugInfo::VLT_STK2:      
        *pVal1  = *NativeVarStackAddr(varLoc,pCtx);
        *pVal2  = *(NativeVarStackAddr(varLoc,pCtx)+ 1);
        break;

    case ICorDebugInfo::VLT_REG_REG:   
        regOffs = GetRegOffsInCONTEXT(varLoc.vlRegReg.vlrrReg1);
        *pVal1 = *(DWORD *)(regOffs + (BYTE*)pCtx);
        LOG((LF_CORDB, LL_INFO100, "GNVV: STK_REG_REG 1 @ 0x%x\n",
            (DWORD *)(regOffs + (BYTE*)pCtx)));
            
        regOffs = GetRegOffsInCONTEXT(varLoc.vlRegReg.vlrrReg2);
        *pVal2 = *(DWORD *)(regOffs + (BYTE*)pCtx);
        LOG((LF_CORDB, LL_INFO100, "GNVV: STK_REG_REG 2 @ 0x%x\n",
            (DWORD *)(regOffs + (BYTE*)pCtx)));
        break;

    case ICorDebugInfo::VLT_REG_STK:   
        regOffs = GetRegOffsInCONTEXT(varLoc.vlRegStk.vlrsReg);
        *pVal1 = *(DWORD *)(regOffs + (BYTE*)pCtx);
        LOG((LF_CORDB, LL_INFO100, "GNVV: STK_REG_STK reg @ 0x%x\n",
            (DWORD *)(regOffs + (BYTE*)pCtx)));
        *pVal2 = *NativeVarStackAddr(varLoc,pCtx);
        break;

    case ICorDebugInfo::VLT_STK_REG:
        *pVal1 = *NativeVarStackAddr(varLoc,pCtx);
        regOffs = GetRegOffsInCONTEXT(varLoc.vlStkReg.vlsrReg);
        *pVal2 = *(DWORD *)(regOffs + (BYTE*)pCtx);
        LOG((LF_CORDB, LL_INFO100, "GNVV: STK_STK_REG reg @ 0x%x\n",
            (DWORD *)(regOffs + (BYTE*)pCtx)));
        break;

    case ICorDebugInfo::VLT_FPSTK:     
         _ASSERTE(!"NYI"); break;

    default:            
         _ASSERTE(!"Bad locType"); break;
    }

    return true;
}


bool    SetNativeVarVal(const ICorDebugInfo::VarLoc &   varLoc, 
                        PCONTEXT                        pCtx,
                        DWORD                           val1, 
                        DWORD                           val2)
{
    switch(varLoc.vlType)
    {
        SIZE_T          regOffs;

    case ICorDebugInfo::VLT_REG:       
        *NativeVarStackAddr(varLoc,pCtx) = val1;
        break;

    case ICorDebugInfo::VLT_STK:       
        *NativeVarStackAddr(varLoc,pCtx)= val1;
        break;

    case ICorDebugInfo::VLT_STK2:      
        *NativeVarStackAddr(varLoc,pCtx) = val1;
        *(NativeVarStackAddr(varLoc,pCtx)+ 1) = val2;
        break;

    case ICorDebugInfo::VLT_REG_REG:   
        regOffs = GetRegOffsInCONTEXT(varLoc.vlRegReg.vlrrReg1);
        *(DWORD *)(regOffs + (BYTE*)pCtx) = val1;
        LOG((LF_CORDB, LL_INFO100, "SNVV: STK_REG_REG 1 @ 0x%x\n",
            (DWORD *)(regOffs + (BYTE*)pCtx)));
            
        regOffs = GetRegOffsInCONTEXT(varLoc.vlRegReg.vlrrReg2);
        *(DWORD *)(regOffs + (BYTE*)pCtx) = val2;
        LOG((LF_CORDB, LL_INFO100, "SNVV: STK_REG_REG 2 @ 0x%x\n",
            (DWORD *)(regOffs + (BYTE*)pCtx)));
        break;

    case ICorDebugInfo::VLT_REG_STK:   
        regOffs = GetRegOffsInCONTEXT(varLoc.vlRegStk.vlrsReg);
        *(DWORD *)(regOffs + (BYTE*)pCtx) = val1;
        LOG((LF_CORDB, LL_INFO100, "SNVV: STK_REG_STK reg @ 0x%x\n",
            (DWORD *)(regOffs + (BYTE*)pCtx)));
        *NativeVarStackAddr(varLoc,pCtx) = val2;
        break;

    case ICorDebugInfo::VLT_STK_REG:
        *NativeVarStackAddr(varLoc,pCtx) = val1;
        regOffs = GetRegOffsInCONTEXT(varLoc.vlStkReg.vlsrReg);
        *(DWORD *)(regOffs + (BYTE*)pCtx) = val2;
        LOG((LF_CORDB, LL_INFO100, "SNVV: STK_STK_REG reg @ 0x%x\n",
            (DWORD *)(regOffs + (BYTE*)pCtx)));
        break;

    case ICorDebugInfo::VLT_FPSTK:     
         _ASSERTE(!"NYI"); break;

    default:            
         _ASSERTE(!"Bad locType"); break;
    }

    return true;
}

//
// Wrap around WszCreateFile to be GC-friendly.
// Trying to create a file on a nonexistent drive will hang GC.
// Before we call WszCreateFile, we will toggle GC mode.
//

HANDLE VMWszCreateFile(
    LPCWSTR pwszFileName,   // pointer to name of the file 
    DWORD dwDesiredAccess,  // access (read-write) mode 
    DWORD dwShareMode,  // share mode 
    LPSECURITY_ATTRIBUTES lpSecurityAttributes, // pointer to security descriptor 
    DWORD dwCreationDistribution,   // how to create 
    DWORD dwFlagsAndAttributes, // file attributes 
    HANDLE hTemplateFile )  // handle to file with attributes to copy  
{
    // We need to enable preemptive GC, so pwszFileName can not be inside
    // GC heap.
    _ASSERTE (!g_pGCHeap->IsHeapPointer((BYTE*)pwszFileName) ||
              ! "pwszFileName can not be inside GC Heap");
    
    Thread  *pCurThread = GetThread();
    BOOL toggleGC=FALSE;

    //We may be called during certain security shutdown scenarios (mainly when creating a new
    //security db) where threads aren't there and can't readily be init'd.  VMWszCreateFile is
    //sufficiently straightforward that we'll just not do any GC work if threads aren't enabled.
    if (pCurThread) { 
        toggleGC = pCurThread->PreemptiveGCDisabled();
    }

    if (toggleGC)
        pCurThread->EnablePreemptiveGC();
    
    HANDLE hReturn =
        WszCreateFile(
            pwszFileName,
            dwDesiredAccess,
            dwShareMode,
            lpSecurityAttributes,
            dwCreationDistribution,
            dwFlagsAndAttributes,
            hTemplateFile );
    if (toggleGC)
        pCurThread->DisablePreemptiveGC();
    return hReturn;
}

HANDLE VMWszCreateFile(
    STRINGREF sFileName,   // pointer to STRINGREF containing file name
    DWORD dwDesiredAccess,  // access (read-write) mode 
    DWORD dwShareMode,  // share mode 
    LPSECURITY_ATTRIBUTES lpSecurityAttributes, // pointer to security descriptor 
    DWORD dwCreationDistribution,   // how to create 
    DWORD dwFlagsAndAttributes, // file attributes 
    HANDLE hTemplateFile )  // handle to file with attributes to copy  
{
    // We need to enable preemptive GC, so we will create a pinning handle.
    // Thus sFileName must be inside GC heap.
    _ASSERTE (g_pGCHeap->IsHeapPointer((BYTE*)sFileName->GetBuffer()) ||
              ! "sFileName must be inside GC Heap");

    OBJECTHANDLE hnd = GetAppDomain()->CreatePinningHandle((OBJECTREF)sFileName);
    Thread  *pCurThread = GetThread();
    BOOL     toggleGC = pCurThread->PreemptiveGCDisabled();

    LPWSTR pwszBuffer = sFileName->GetBuffer();
    if (toggleGC)
        pCurThread->EnablePreemptiveGC();
    
    HANDLE hReturn =
        WszCreateFile(
            pwszBuffer,
            dwDesiredAccess,
            dwShareMode,
            lpSecurityAttributes,
            dwCreationDistribution,
            dwFlagsAndAttributes,
            hTemplateFile );
    if (toggleGC)
        pCurThread->DisablePreemptiveGC();

    DestroyPinningHandle(hnd);
    
    return hReturn;
}

void VMDumpCOMErrors(HRESULT hrErr)
{
    IErrorInfo  *   pIErr = NULL;          // Error interface.
    BSTR            bstrDesc = NULL;        // Description text.
    WCHAR szBuffer[MESSAGE_LENGTH];
    // Try to get an error info object and display the message.
    if (GetErrorInfo(0, &pIErr) == S_OK &&
        pIErr->GetDescription(&bstrDesc) == S_OK &&
        LoadStringRC(IDS_FATAL_ERROR, szBuffer, MESSAGE_LENGTH, true) == S_OK)
    {
        WszMessageBoxInternal(NULL, bstrDesc, szBuffer, MB_OK | MB_ICONEXCLAMATION);
    }
    // Just give out the failed hr return code.
    else
    {
        CorMessageBox(NULL, IDS_COMPLUS_ERROR, IDS_FATAL_ERROR, MB_OK | MB_ICONEXCLAMATION, TRUE /* show file name */, hrErr);
    }
    
    // Free the string if we got one.
    if (bstrDesc != NULL)
        SysFreeString(bstrDesc);

    SysFreeString(bstrDesc); // OK to free NULL Bstring
    // Free the error interface.
    if (pIErr)
        pIErr->Release();
}

//-----------------------------------------------------------------------------
// WszSHGetFolderPath
//
// @func takes the CSIDL of a folder and returns the path name
//
// @rdesc Result Handle
//-----------------------------------------------------------------------------------
HRESULT WszSHGetFolderPath(HWND hwndOwner, int nFolder, HANDLE hToken, DWORD dwFlags, LPWSTR pszwPath)
{
    HRESULT hr = E_FAIL;
    LPSTR   pszPath;
    ULONG maxLength = MAX_PATH;
    HMODULE _hmodShell32 = 0;
    HMODULE _hmodSHFolder = 0;
    
    if (UseUnicodeAPI())
    {
        typedef HRESULT (*PFNSHGETFOLDERPATH_W) (HWND hwndOwner, int nFolder, HANDLE hToken, DWORD dwFlags, LPWSTR pszPath);
        static PFNSHGETFOLDERPATH_W pfnW = NULL;
        if (NULL == pfnW)
        {
            _hmodShell32 = WszLoadLibrary(L"shell32.dll");
    
            if (NULL != _hmodShell32)
                pfnW = (PFNSHGETFOLDERPATH_W)GetProcAddress(_hmodShell32, "SHGetFolderPathW");
        }
        if (NULL == pfnW)
        {
            if (NULL == _hmodSHFolder)
                _hmodSHFolder = WszLoadLibrary(L"shfolder.dll");
            if (NULL != _hmodSHFolder)
            {
                pfnW = (PFNSHGETFOLDERPATH_W)GetProcAddress(_hmodSHFolder, "SHGetFolderPathW");
            }
        }
        if (NULL != pfnW)
            hr = pfnW(hwndOwner, nFolder, hToken, dwFlags, pszwPath);
    }
    else
    {
        // No Unicode Support
        typedef HRESULT (*PFNSHGETFOLDERPATH_A) (HWND hwndOwner, int nFolder, HANDLE hToken, DWORD dwFlags, LPSTR pszPath);
        static PFNSHGETFOLDERPATH_A pfnA = NULL;
        if (NULL == pfnA)
        {
            _hmodShell32 = WszLoadLibrary(L"shell32.dll");
    
            if (NULL != _hmodShell32)
                pfnA = (PFNSHGETFOLDERPATH_A)GetProcAddress(_hmodShell32, "SHGetFolderPathA");
        }
        if (NULL == pfnA)
        {
            if (NULL == _hmodSHFolder)
                _hmodSHFolder = WszLoadLibrary(L"shfolder.dll");
            if (NULL != _hmodSHFolder)
            {
                pfnA = (PFNSHGETFOLDERPATH_A)GetProcAddress(_hmodSHFolder, "SHGetFolderPathA");
            }
        }
        if (NULL != pfnA)
        {
            pszPath = new char [maxLength * DBCS_MAXWID];
            if (pszPath)
            {
                if (SUCCEEDED(pfnA(hwndOwner, nFolder, hToken, dwFlags, pszPath)))
                {
                    if (SUCCEEDED(WszConvertToUnicode(pszPath, -1, &pszwPath, &maxLength, FALSE)))
                        hr = S_OK;
                }
                delete[] pszPath;
            }
        }
    }
    
    // NOTE: We leak the module handles and let the OS gather them at process shutdown.

    return hr;
}

#define FOLDER_LOCAL_SETTINGS_W    L"Local Settings"
#define FOLDER_APP_DATA_W          L"\\Application Data"
#define FOLDER_APP_DATA             "\\Application Data"

// Gets the location for roaming and local AppData
BOOL GetUserDir( WCHAR * buffer, size_t bufferCount, BOOL fRoaming, BOOL fTryDefault)
{
    HRESULT hr;

    // In Windows ME, there is currently a bug that makes local appdata and roaming appdata 
    // point to the same location, so we've decided to "do our own thing" and add \Local Settings before \Application Data 
    if (!fRoaming) {
        WCHAR appdatafolder[MAX_PATH];
        hr = WszSHGetFolderPath(NULL, CSIDL_APPDATA|CSIDL_FLAG_CREATE, NULL, 0, appdatafolder);
        if (FAILED(hr))
        {
            if (!fTryDefault || FAILED(WszSHGetFolderPath(NULL, CSIDL_APPDATA|CSIDL_FLAG_CREATE, NULL, 1, appdatafolder)))
                return FALSE;
        }
        hr = WszSHGetFolderPath(NULL, CSIDL_LOCAL_APPDATA|CSIDL_FLAG_CREATE, NULL, 0, buffer);
        if (FAILED(hr))
        {
            if (!fTryDefault || FAILED(WszSHGetFolderPath(NULL, CSIDL_LOCAL_APPDATA|CSIDL_FLAG_CREATE, NULL, 1, buffer)))
                return FALSE;
        }
        // folders are the same or failed to get local folder

        if (!wcscmp(appdatafolder, buffer)) 
        {
            WCHAR tempPartialPath[MAX_PATH];
            ULONG slen = (ULONG)wcslen(buffer);

            if (buffer[slen - 1] == L'\\')
            {
                --slen;
            }

            // Search for the parent directory.

            WCHAR* parentDirectoryEnd = &buffer[slen - 1];
            tempPartialPath[0] = L'\0';

            for (ULONG index = slen - 1; index > 0; --index)
            {
                if (buffer[index] == L'\\')
                {
                    if (wcslen(&buffer[index]) >= NumItems(tempPartialPath))
                    {
                        _ASSERTE(!"Buffer not large enough");
                        return FALSE;
                    }
                    wcscpy( tempPartialPath, &buffer[index] );
                    parentDirectoryEnd = &buffer[index+1];
                    break;
                }
            }

            // Create the intermediate directory if it is not present
            if ((parentDirectoryEnd + wcslen(FOLDER_LOCAL_SETTINGS_W)) >= (buffer + bufferCount))
            {
                _ASSERTE(!"Buffer not large enough");
                return FALSE;
            }
            wcscpy(parentDirectoryEnd, FOLDER_LOCAL_SETTINGS_W);

            LONG  lresult;
        
            // Check if the directory is already present
            lresult = WszGetFileAttributes(buffer);
        
            if (lresult == -1)
            {
                if (!WszCreateDirectory(buffer, NULL) &&
                    !(WszGetFileAttributes(buffer) & FILE_ATTRIBUTE_DIRECTORY))
                    return FALSE;
            }
            else if ((lresult & FILE_ATTRIBUTE_DIRECTORY) == 0)
            {
                return FALSE;
            }

            if ((bufferCount - wcslen(buffer)) <= wcslen(tempPartialPath))
            {
                _ASSERTE(!"Buffer not large enough");
                return FALSE;
            }
            wcscat(buffer, tempPartialPath);
        }
    }    
    else {
        hr = WszSHGetFolderPath(NULL, CSIDL_APPDATA|CSIDL_FLAG_CREATE, NULL, 0, buffer);
        if (FAILED(hr))
        {
            if (!fTryDefault || FAILED(WszSHGetFolderPath(NULL, CSIDL_APPDATA|CSIDL_FLAG_CREATE, NULL, 1, buffer )))
                return FALSE;
        }
    }

    return TRUE;
}

BOOL GetInternetCacheDir( WCHAR * buffer, size_t bufferCount)
{
	_ASSERTE( bufferCount == MAX_PATH && "You should pass in a buffer of size MAX_PATH" );

    if (FAILED(WszSHGetFolderPath( NULL, CSIDL_INTERNET_CACHE, NULL, 0, buffer )))
    {
        return FAILED(WszSHGetFolderPath( NULL, CSIDL_INTERNET_CACHE, NULL, 1, buffer ));
    }

    return TRUE;

}
#ifdef _X86_

ProcessorFeatures::PIPFP ProcessorFeatures::m_pIsProcessorFeaturePresent = NULL;


/*static*/ BOOL ProcessorFeatures::Init() //One-time initialization
{
    m_pIsProcessorFeaturePresent = NULL;
    HINSTANCE hInst = WszGetModuleHandle(L"kernel32");
    if (hInst) {
        m_pIsProcessorFeaturePresent = (PIPFP)GetProcAddress(hInst, "IsProcessorFeaturePresent");
    }

    return TRUE;

}

// Calls IsProcessorFeature() on Winnt/2000, etc.
// If on Win9x or other OS that doesn't implement this api,
// returns the value "fDefault."
/*static*/ BOOL ProcessorFeatures::SafeIsProcessorFeaturePresent(DWORD pf, BOOL fDefault)
{
    if (pf == PF_COMPARE_EXCHANGE_DOUBLE && 
        ( (!m_pIsProcessorFeaturePresent) || !(m_pIsProcessorFeaturePresent(pf)) ))
    {
        // Win9x exposes this api but it lies - so if the api tells us 
        // the instruction isn't present, check it for ourselves.

        static BOOL fCached = FALSE;
        static BOOL fCachedResult;

        if (!fCached)
        {
            __int64 newvalue = 0x1122334455667788L;
            __int64 x = 0x123456789abcdefL;

            fCachedResult = TRUE;
            __try
            {
                __asm
                {
                    push esi
                    push ebx

                    ;; load old value (comparator)
                    mov  eax, dword ptr [x]
                    mov  edx, dword ptr [x+4]

                    ;; load new value
                    mov  ebx, dword ptr [newvalue]
                    mov  ecx, dword ptr [newvalue+4]

                    lea  esi, dword ptr [x]
                    cmpxchg8b qword ptr [esi]
                    pop  ebx
                    pop  esi
                }
            }
            __except (COMPLUS_EXCEPTION_EXECUTE_HANDLER)
            {
                fCachedResult = FALSE;
            }

            if (x != newvalue)
            {
                _ASSERTE(!"cmpxchg8b test failed. This appears to be an X86-clone CPU that doesn't support cmpxchg8b but doesn't trap an illegal opcode for it either.");
                fCachedResult = FALSE;
            }

            fCached = TRUE;

        }
        return fCachedResult;
    }


    return m_pIsProcessorFeaturePresent ? m_pIsProcessorFeaturePresent(pf) : fDefault;
}

//-----------------------------------------------------------------------------
// Wrap registry functions to use CQuickString to allocate space. This does it
// in a stack friendly manner.
//-----------------------------------------------------------------------------
LONG UtilRegEnumKey(HKEY hKey,            // handle to key to query
                    DWORD dwIndex,        // index of subkey to query
                    CQuickString* lpName) // buffer for subkey name
{
    DWORD size = lpName->MaxSize();
    LONG result = WszRegEnumKeyEx(hKey,
                                  dwIndex,
                                  lpName->String(),
                                  &size,
                                  NULL,
                                  NULL,
                                  NULL,
                                  NULL);

	if (result == ERROR_SUCCESS || result == ERROR_MORE_DATA) {

        // Grow or shrink buffer to correct size
        if (lpName->ReSize(size+1) != NOERROR)
            result = ERROR_NOT_ENOUGH_MEMORY;

        if (result == ERROR_MORE_DATA) {
            size = lpName->MaxSize();
            result = WszRegEnumKeyEx(hKey,
                                     dwIndex,
                                     lpName->String(),
                                     &size,
                                     NULL,
                                     NULL,
                                     NULL,
                                     NULL);
        }
    }

    return result;
}

LONG UtilRegQueryStringValueEx(HKEY hKey,           // handle to key to query
                               LPCWSTR lpValueName, // address of name of value to query
                               LPDWORD lpReserved,  // reserved
                               LPDWORD lpType,      // address of buffer for value type
                               CQuickString* lpData)// data buffer
{
    DWORD size = lpData->MaxSize();
    LONG result = WszRegQueryValueEx(hKey,
                                     lpValueName,
                                     lpReserved,
                                     lpType,
                                     (LPBYTE) lpData->Ptr(),
                                     &size);

	if (result == ERROR_SUCCESS || result == ERROR_MORE_DATA) {

        // Grow or shrink buffer to correct size
        if (lpData->ReSize(size+1) != NOERROR)
            result = ERROR_NOT_ENOUGH_MEMORY;

        if (result == ERROR_MORE_DATA) {
            size = lpData->MaxSize();
            result = WszRegQueryValueEx(hKey,
                                        lpValueName,
                                        lpReserved,
                                        lpType,
                                        (LPBYTE) lpData->Ptr(),
                                        &size);
        }
    }
    
    return result;
}


//---------------------------------------------------------------------
// Splits a command line into argc/argv lists, using the VC7 parsing rules.
//
// This functions interface mimics the CommandLineToArgvW api.
//
// If function fails, returns NULL.
//
// If function suceeds, call delete [] on return pointer when done.
//
//---------------------------------------------------------------------
LPWSTR *SegmentCommandLine(LPCWSTR lpCmdLine, DWORD *pNumArgs)
{
    int nch = (int)wcslen(lpCmdLine);

    // Calculate the worstcase storage requirement. (One pointer for
    // each argument, plus storage for the arguments themselves.)
    int cbAlloc = (nch+1)*sizeof(LPWSTR) + sizeof(WCHAR)*(nch + 1);
    LPWSTR pAlloc = new (nothrow) WCHAR[cbAlloc / sizeof(WCHAR)];
    if (!pAlloc)
        return NULL;

    *pNumArgs = 0;

    LPWSTR *argv = (LPWSTR*) pAlloc;  // We store the argv pointers in the first halt
    LPWSTR  pdst = (LPWSTR)( ((BYTE*)pAlloc) + sizeof(LPWSTR)*(nch+1) ); // A running pointer to second half to store arguments
    LPCWSTR psrc = lpCmdLine;
    WCHAR   c;
    BOOL    inquote;
    BOOL    copychar;
    int     numslash;

    // First, parse the program name (argv[0]). Argv[0] is parsed under
    // special rules. Anything up to the first whitespace outside a quoted
    // subtring is accepted. Backslashes are treated as normal characters.
    argv[ (*pNumArgs)++ ] = pdst;
    inquote = FALSE;
    do {
        if (*psrc == L'"' )
        {
            inquote = !inquote;
            c = *psrc++;
            continue;
        }
        *pdst++ = *psrc;

        c = *psrc++;

    } while ( (c != L'\0' && (inquote || (c != L' ' && c != L'\t'))) );

    if ( c == L'\0' ) {
        psrc--;
    } else {
        *(pdst-1) = L'\0';
    }

    inquote = FALSE;



    /* loop on each argument */
    for(;;)
    {
        if ( *psrc )
        {
            while (*psrc == L' ' || *psrc == L'\t')
            {
                ++psrc;
            }
        }

        if (*psrc == L'\0')
            break;              /* end of args */

        /* scan an argument */
        argv[ (*pNumArgs)++ ] = pdst;

        /* loop through scanning one argument */
        for (;;)
        {
            copychar = 1;
            /* Rules: 2N backslashes + " ==> N backslashes and begin/end quote
               2N+1 backslashes + " ==> N backslashes + literal "
               N backslashes ==> N backslashes */
            numslash = 0;
            while (*psrc == L'\\')
            {
                /* count number of backslashes for use below */
                ++psrc;
                ++numslash;
            }
            if (*psrc == L'"')
            {
                /* if 2N backslashes before, start/end quote, otherwise
                   copy literally */
                if (numslash % 2 == 0)
                {
                    if (inquote)
                    {
                        if (psrc[1] == L'"')
                        {
                            psrc++;    /* Double quote inside quoted string */
                        }
                        else
                        {
                            /* skip first quote char and copy second */
                            copychar = 0;
                        }
                    }
                    else
                    {
                        copychar = 0;       /* don't copy quote */
                    }
                    inquote = !inquote;
                }
                numslash /= 2;          /* divide numslash by two */
            }
    
            /* copy slashes */
            while (numslash--)
            {
                *pdst++ = L'\\';
            }
    
            /* if at end of arg, break loop */
            if (*psrc == L'\0' || (!inquote && (*psrc == L' ' || *psrc == L'\t')))
                break;
    
            /* copy character into argument */
            if (copychar)
            {
                *pdst++ = *psrc;
            }
            ++psrc;
        }

        /* null-terminate the argument */

        *pdst++ = L'\0';          /* terminate string */
    }

    /* We put one last argument in -- a null ptr */
    argv[ (*pNumArgs) ] = NULL;

    // If we hit this assert, we overwrote our destination buffer and
    // bunged up the heap. Since we're supposed to allocate for the worst
    // case, either the parsing rules have changed or our worse case
    // formula is wrong.
    _ASSERTE((BYTE*)pdst <= (BYTE*)pAlloc + cbAlloc);
    return argv;
}



#endif //_X86_


void * 
EEQuickBytes::Alloc(SIZE_T iItems) {
    void *p = CQuickBytes::Alloc(iItems);
    if (p)
        return p;

    FailFast(GetThread(), FatalOutOfMemory);
    return 0;
}



VOID __FreeBuildDebugBreak()
{
    if (REGUTIL::GetConfigDWORD(L"BreakOnRetailAssert", 0))
    {
        DebugBreak();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\typehash.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//
// File: typehash.h
//
#ifndef _TYPE_HASH_H
#define _TYPE_HASH_H

//============================================================================
// This is the hash table used by class loaders to look up type handles
// associated with constructed types (arrays and pointer types). 
//============================================================================

class ClassLoader;
class NameHandle;

// The "blob" you get to store in the hash table

typedef void* HashDatum;


// One of these is present for each element in the table

typedef struct EETypeHashEntry
{
    struct EETypeHashEntry *pNext;
    DWORD               dwHashValue;
    HashDatum           Data;
    
    // For details of the reps used here, see NameHandle in clsload.hpp
    INT_PTR m_Key1;
    INT_PTR m_Key2;
} EETypeHashEntry_t;


// Type hashtable.
class EETypeHashTable 
{
    friend class ClassLoader;

protected:
    EETypeHashEntry_t **m_pBuckets;    // Pointer to first entry for each bucket
    DWORD           m_dwNumBuckets;
    DWORD           m_dwNumEntries;

public:
    LoaderHeap *    m_pHeap;

#ifdef _DEBUG
    DWORD           m_dwDebugMemory;
#endif

public:
    EETypeHashTable();
    ~EETypeHashTable();
    void *             operator new(size_t size, LoaderHeap *pHeap, DWORD dwNumBuckets);
    void               operator delete(void *p);
    EETypeHashEntry_t * InsertValue(NameHandle* pName, HashDatum Data);
    EETypeHashEntry_t *GetValue(NameHandle* pName, HashDatum *pData);
    EETypeHashEntry_t *AllocNewEntry();

private:
    EETypeHashEntry_t * FindItem(NameHandle* pName);
    void            GrowHashTable();
    static DWORD Hash(NameHandle* pName);
};



#endif /* _TYPE_HASH_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\util.hpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//
// util.hpp
//
// Miscellaneous useful functions
//
#ifndef _H_UTIL
#define _H_UTIL

#include <objbase.h>
#include <basetsd.h>

//#ifdef _DEBUG
//#include <crtdbg.h>
//#undef _ASSERTE    // utilcode defines a custom _ASSERTE
//#endif

#define MAX_UINT32_HEX_CHAR_LEN 8 // max number of chars representing an unsigned int32, not including terminating null char.
#define MAX_INT32_DECIMAL_CHAR_LEN 11 // max number of chars representing an int32, including sign, not including terminating null char.

void FatalOutOfMemoryError(void);
#define ALLOC_FAILURE_ACTION FatalOutOfMemoryError();

#include "utilcode.h"



//========================================================================
// More convenient names for integer types of a guaranteed size.
//========================================================================
typedef unsigned __int64 UINT64;
typedef __int64 INT64;

#ifndef _BASETSD_H_
typedef unsigned __int32 UINT32;
typedef __int32 INT32;
typedef __int16 INT16;
typedef __int8  INT8;
typedef unsigned __int16 UINT16;
typedef unsigned __int8  UINT8;
#endif // !_BASETSD_H_

typedef __int8              I1;
typedef unsigned __int8     U1;
typedef __int16             I2;
typedef unsigned __int16    U2;
typedef __int32             I4;
typedef unsigned __int32    U4;
typedef __int64             I8;
typedef unsigned __int64    U8;
typedef float               R4;
typedef double              R8;


// Based on whether we are running on a Uniprocessor or Multiprocessor machine,
// set up a bunch of services that are correct / efficient.  These are initialized
// in InitFastInterlockOps().

typedef void   (__fastcall *BitFieldOps) (DWORD * const Target, const int Bits);
typedef LONG   (__fastcall *XchgOps)     (LONG *Target, LONG Value);
typedef void  *(__fastcall *CmpXchgOps)  (void **Destination, void *Exchange, void *Comperand);
typedef LONG   (__fastcall *XchngAddOps) (LONG *Traget, LONG Value);
typedef LONG   (__fastcall *IncDecOps)   (LONG *Target);
typedef UINT64  (__fastcall *IncDecLongOps) (UINT64 *Target);


extern BitFieldOps FastInterlockOr;
extern BitFieldOps FastInterlockAnd;

extern XchgOps     FastInterlockExchange;
extern CmpXchgOps  FastInterlockCompareExchange;
extern XchngAddOps FastInterlockExchangeAdd;

// So that we can run on Win95 386, which lacks the xadd instruction, the following
// services return zero or a positive or negative number only.  Do not rely on
// values -- only on the sign of the return.
extern IncDecOps   FastInterlockIncrement;
extern IncDecOps   FastInterlockDecrement;
extern IncDecLongOps FastInterlockIncrementLong;
extern IncDecLongOps FastInterlockDecrementLong;



// Copied from malloc.h: don't want to bring in the whole header file.
void * __cdecl _alloca(size_t);

// Function to parse apart a command line and return the 
// arguments just like argv and argc
LPWSTR* CommandLineToArgvW(LPWSTR lpCmdLine, DWORD *pNumArgs);
#define ISWWHITE(x) ((x)==L' ' || (x)==L'\t' || (x)==L'\n' || (x)==L'\r' )

class util
{
public:
    static DWORD FourBytesToU4(const BYTE *pBytes)
    {
#ifdef _X86_
        return *(const DWORD *) pBytes;
#else
        return pBytes[0] | (pBytes[1] << 8) | (pBytes[2] << 16) | (pBytes[3] << 24);
#endif
    }

    static DWORD TwoBytesToU4(const BYTE *pBytes)
    {
        return pBytes[0] | (pBytes[1] << 8);
    }
};





BOOL inline FitsInI1(__int64 val)
{
    return val == (__int64)(__int8)val;
}

BOOL inline FitsInI2(__int64 val)
{
    return val == (__int64)(__int16)val;
}

BOOL inline FitsInI4(__int64 val)
{
    return val == (__int64)(__int32)val;
}

//************************************************************************
// EEQuickBytes
//
// A wrapper of CQuickBytes that fails fast if we don't get our memory.
//
// GetLastError() can be used to determine the failure reason.  In some
// cases, a stack overflow is the cause.
//
//
class EEQuickBytes : public CQuickBytes {
public:
    void* Alloc(SIZE_T iItems);
};


// returns FALSE if overflow: otherwise, (*pa) is incremented by b
BOOL inline SafeAddUINT16(UINT16 *pa, ULONG b)
{
    UINT16 a = *pa;
    if ( ((UINT16)b) != b )
    {
        return FALSE;
    }
    if ( ((UINT16)(a + ((UINT16)b))) < a)
    {
        return FALSE;
    }
    (*pa) += (UINT16)b;
    return TRUE;
}


// returns FALSE if overflow: otherwise, (*pa) is incremented by b
BOOL inline SafeAddUINT32(UINT32 *pa, UINT32 b)
{
    UINT32 a = *pa;
    if ( ((UINT32)(a + b)) < a)
    {
        return FALSE;
    }
    (*pa) += b;
    return TRUE;
}

// returns FALSE if overflow: otherwise, (*pa) is multiplied by b
BOOL inline SafeMulSIZE_T(SIZE_T *pa, SIZE_T b)
{
#ifdef _DEBUG
    {
        //Make sure SIZE_T is unsigned
        SIZE_T m = ((SIZE_T)(-1));
        SIZE_T z = 0;
        _ASSERTE(m > z);
    }
#endif


    SIZE_T a = *pa;
    const SIZE_T m = ((SIZE_T)(-1));
    if ( (m / b) < a )
    {
        return FALSE;
    }
    (*pa) *= b;
    return TRUE;
}



//************************************************************************
// CQuickHeap
//
// A fast non-multithread-safe heap for short term use.
// Destroying the heap frees all blocks allocated from the heap.
// Blocks cannot be freed individually.
//
// The heap uses COM+ exceptions to report errors.
//
// The heap does not use any internal synchronization so it is not
// multithreadsafe.
//************************************************************************
class CQuickHeap
{
    public:
        CQuickHeap(); 
        ~CQuickHeap();

        //---------------------------------------------------------------
        // Allocates a block of "sz" bytes. If there's not enough
        // memory, throws an OutOfMemoryError.
        //---------------------------------------------------------------
        LPVOID Alloc(UINT sz);


    private:
        enum {
#ifdef _DEBUG
            kBlockSize = 24
#else
            kBlockSize = 1024
#endif
        };

        // The QuickHeap allocates QuickBlock's as needed and chains
        // them in a single-linked list. Most QuickBlocks have a size
        // of kBlockSize bytes (not counting m_next), and individual
        // allocation requests are suballocated from them.
        // Allocation requests of greater than kBlockSize are satisfied
        // by allocating a special big QuickBlock of the right size.
        struct QuickBlock
        {
            QuickBlock  *m_next;
            BYTE         m_bytes[1];
        };


        // Linked list of QuickBlock's.
        QuickBlock      *m_pFirstQuickBlock;

        // Offset to next available byte in m_pFirstQuickBlock.
        LPBYTE           m_pNextFree;

        // Linked list of big QuickBlock's
        QuickBlock      *m_pFirstBigQuickBlock;

};

//======================================================================
// String Helpers
//
//
//
ULONG StringHashValueW(LPWSTR wzString);
ULONG StringHashValueA(LPCSTR szString);


LPCVOID ReserveAlignedMemory(DWORD dwAlign, DWORD dwSize);
DWORD RootImageType();
void PrintToStdOutA(const char *pszString);
void PrintToStdOutW(const WCHAR *pwzString);
void PrintToStdErrA(const char *pszString);
void PrintToStdErrW(const WCHAR *pwzString);
void NPrintToStdOutA(const char *pszString, size_t nbytes);
void NPrintToStdOutW(const WCHAR *pwzString, size_t nchars);
void NPrintToStdErrA(const char *pszString, size_t nbytes);
void NPrintToStdErrW(const WCHAR *pwzString, size_t nchars);


//=====================================================================
// Function for formatted text output to the debugger
//
//
void __cdecl VMDebugOutputA(LPSTR format, ...);
void __cdecl VMDebugOutputW(LPWSTR format, ...);


//=====================================================================
// Displays the messaage box or logs the message, corresponding to the last COM+ error occured
void VMDumpCOMErrors(HRESULT hrErr);

// Gets the user directory
HRESULT WszSHGetFolderPath(HWND hwndOwner, int nFolder, HANDLE hToken, DWORD dwFlags, LPWSTR pszwPath);
BOOL GetUserDir( WCHAR * buffer, size_t bufferCount, BOOL fRoaming, BOOL fTryDefault = TRUE);
BOOL GetInternetCacheDir( WCHAR * buffer, size_t bufferCount );
    
//=====================================================================
// Switches on different code paths in checked builds for code coverage.
#ifdef _DEBUG

inline WORD GetDayOfWeek()
{
    SYSTEMTIME st;
    GetSystemTime(&st);
    return st.wDayOfWeek;
}

#define DAYOFWEEKDEBUGHACKSENABLED TRUE

#define MonDebugHacksOn() (DAYOFWEEKDEBUGHACKSENABLED && 1 == GetDayOfWeek())
#define TueDebugHacksOn() (DAYOFWEEKDEBUGHACKSENABLED && 2 == GetDayOfWeek())
#define WedDebugHacksOn() (DAYOFWEEKDEBUGHACKSENABLED && 3 == GetDayOfWeek())
#define ThuDebugHacksOn() (DAYOFWEEKDEBUGHACKSENABLED && 4 == GetDayOfWeek())
#define FriDebugHacksOn() (DAYOFWEEKDEBUGHACKSENABLED && 5 == GetDayOfWeek())


#else

#define MonDebugHacksOn() FALSE
#define TueDebugHacksOn() FALSE
#define WedDebugHacksOn() FALSE
#define ThuDebugHacksOn() FALSE
#define FriDebugHacksOn() FALSE


#endif

#include "NativeVarAccessors.h"

#ifdef _DEBUG
#define INDEBUG(x)          x
#define INDEBUG_COMMA(x)    x,
#else
#define INDEBUG(x)
#define INDEBUG_COMMA(x)
#endif


#ifdef _X86_
class ProcessorFeatures
{
    public:
        static BOOL Init(); //One-time initialization

        // Calls IsProcessorFeature() on Winnt/2000, etc.
        // If on Win9x or other OS that doesn't implement this api,
        // returns the value "fDefault."
        static BOOL SafeIsProcessorFeaturePresent(DWORD pf, BOOL fDefault);

    private:
        typedef BOOL (WINAPI * PIPFP)(DWORD);

        static PIPFP m_pIsProcessorFeaturePresent;
};
#endif

LPWSTR *SegmentCommandLine(LPCWSTR lpCmdLine, DWORD *pNumArgs);

//======================================================================
// Stack friendly registry helpers
//
LONG UtilRegEnumKey(HKEY hKey,            // handle to key to query
                    DWORD dwIndex,        // index of subkey to query
                    CQuickString* lpName);// buffer for subkey name

LONG UtilRegQueryStringValueEx(HKEY hKey,            // handle to key to query
                               LPCWSTR lpValueName,  // address of name of value to query
                               LPDWORD lpReserved,   // reserved
                               LPDWORD lpType,       // address of buffer for value type
                               CQuickString* lpData);// data buffer

//======================================================================
// This function returns true, if it can determine that the instruction pointer
// refers to a code address that belongs in the range of the given image.
inline BOOL
IsIPInModule(HINSTANCE hModule, BYTE *ip)
{
    __try {
        
        BYTE *pBase = (BYTE *)hModule;
        
        IMAGE_DOS_HEADER *pDOS = (IMAGE_DOS_HEADER *)pBase;
        if (pDOS->e_magic != IMAGE_DOS_SIGNATURE ||
            pDOS->e_lfanew == 0) {
            __leave;
        }
        IMAGE_NT_HEADERS *pNT = (IMAGE_NT_HEADERS*)(pBase + pDOS->e_lfanew);
        if (pNT->Signature != IMAGE_NT_SIGNATURE ||
            pNT->FileHeader.SizeOfOptionalHeader != IMAGE_SIZEOF_NT_OPTIONAL_HEADER ||
            pNT->OptionalHeader.Magic != IMAGE_NT_OPTIONAL_HDR_MAGIC
            ) 
        {
            __leave;
        }

        if (ip >= pBase && ip < pBase + pNT->OptionalHeader.SizeOfImage) 
        {
            return true;
        }
    
    } __except(EXCEPTION_EXECUTE_HANDLER) {
    }
    return false;
}

#define AUTO_COOPERATIVE_GC() AutoCooperativeGC __autoGC;
#define MAYBE_AUTO_COOPERATIVE_GC(__flag) AutoCooperativeGC __autoGC(__flag);

#define AUTO_PREEMPTIVE_GC() AutoPreemptiveGC __autoGC;
#define MAYBE_AUTO_PREEMPTIVE_GC(__flag) AutoPreemptiveGC __autoGC(__flag);

typedef BOOL (*FnLockOwner)(LPVOID);
struct LockOwner
{
    LPVOID lock;
    FnLockOwner lockOwnerFunc;
};
#endif /* _H_UTIL */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\vars.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//
// vars.cpp - Global Var definitions
//

#include "common.h"
#include "vars.hpp"
#include "cordbpriv.h"
#include "EEProfInterfaces.h"
#include "minidumppriv.h"

//---------------------------------------------------------
// IMPORTANT:
// If you add a global variable you must clean it up in 
// CoUninitializeEE and set it back to NULL:


// For [<I1, etc. up to and including [Object
ArrayTypeDesc *         g_pPredefinedArrayTypes[ELEMENT_TYPE_MAX];
HINSTANCE            g_pMSCorEE;
GCHeap *             g_pGCHeap;
ThreadStore *        g_pThreadStore;
IdDispenser *        g_pThinLockThreadIdDispenser;
LONG                 g_TrapReturningThreads;
#ifdef _DEBUG
bool                 g_TrapReturningThreadsPoisoned;

char *               g_ExceptionFile;   // Source of the last thrown exception (COMPLUSThrow())
DWORD                g_ExceptionLine;   // ... ditto ...
void *               g_ExceptionEIP;    // Managed EIP of the last guy to call JITThrow.

#endif
EEConfig*            g_pConfig = NULL;          // configuration data (from the registry)

MethodTable *        g_pObjectClass;
MethodTable *        g_pStringClass;
MethodTable *        g_pByteArrayClass;
MethodTable *        g_pArrayClass;
MethodTable *        g_pExceptionClass;
MethodTable *        g_pThreadStopExceptionClass = NULL;
MethodTable *        g_pThreadAbortExceptionClass = NULL;
MethodTable *        g_pOutOfMemoryExceptionClass;
MethodTable *        g_pStackOverflowExceptionClass;
MethodTable *        g_pExecutionEngineExceptionClass;
MethodTable *        g_pDateClass;
MethodTable *        g_pDelegateClass;
MethodTable *        g_pMultiDelegateClass;
MethodTable *        g_pValueTypeClass;
MethodTable *        g_pEnumClass;
MethodTable *        g_pSharedStaticsClass = NULL;
MethodTable *        g_pThreadClass = NULL;

// @TODO Remove eventually - determines whether the verifier throws an exception when something fails
bool                g_fVerifierOff;

// @TODO - PROMOTE.
OBJECTHANDLE         g_pPreallocatedOutOfMemoryException;
OBJECTHANDLE         g_pPreallocatedStackOverflowException;
OBJECTHANDLE         g_pPreallocatedExecutionEngineException;

MethodTable *        g_pFreeObjectMethodTable;
// Global SyncBlock cache

SyncTableEntry *     g_pSyncTable;

// Global RCW cleanup list
ComPlusWrapperCleanupList *g_pRCWCleanupList = NULL;

// Hash of method names used while building method tables
MethodNameCache     *g_pMethodNameCache = NULL;

// 
//
// Global System Info
//
SYSTEM_INFO g_SystemInfo;
bool        g_SystemLoad;               // Indicates the system class libraries are loading
LONG        g_RefCount = 0;             // Global counter for EE initialization.


// support for IPCManager 
IPCWriterInterface* g_pIPCManagerInterface = NULL;

#ifdef DEBUGGING_SUPPORTED
//
// Support for the COM+ Debugger.
//
DebugInterface *     g_pDebugInterface            = NULL;
EEDbgInterfaceImpl*  g_pEEDbgInterfaceImpl        = NULL;
DWORD                g_CORDebuggerControlFlags    = 0;
HINSTANCE            g_pDebuggerDll               = NULL;
#endif // DEBUGGING_SUPPORTED

#ifdef PROFILING_SUPPORTED
// Profiling support
ProfilerStatus      g_profStatus = profNone;
ProfControlBlock    g_profControlBlock;
#endif // PROFILING_SUPPORTED

// Global variable to determine which threadpool implementation is being used
BOOL g_Win32Threadpool = FALSE;


// Global default for Concurrent GC. The default is value is 1
int g_IGCconcurrent = 1;

//
// Global state variable indicating if the EE is in its init phase.
//
bool g_fEEInit = false;

//
// Two globals that are used as dummy placements for new(throws) and new(nothrow)
//
const Throws throws;
const NoThrow nothrow;

//
// Global state variables indicating which stage of shutdown we are in
//
DWORD g_fEEShutDown = 0;
bool g_fForbidEnterEE = false;
bool g_fFinalizerRunOnShutDown = false;
bool g_fProcessDetach = false;
bool g_fManagedAttach = false;
bool g_fNoExceptions = false;
bool g_fFatalError = false;

//
// Global state variable indicating that thread store lock requirements may be relaxed in certian special places.
//
bool g_fRelaxTSLRequirement = false;

DWORD g_dwGlobalSharePolicy = BaseDomain::SHARE_POLICY_UNSPECIFIED;

//
// Do we own the lifetime of the process, ie. is it an EXE?
//
bool g_fWeControlLifetime = false;

#ifdef _DEBUG
// The following should only be used for assertions.  (Famous last words).
bool dbg_fDrasticShutdown = false;
#endif
bool g_fInControlC = false;

// A hash of all function type descs on the system (to maintain type desc
// identity).
EEFuncTypeDescHashTable g_sFuncTypeDescHash;
CRITICAL_SECTION g_sFuncTypeDescHashLock;

//
// This structure contains data needed to complete a managed minidump
//
MiniDumpInternalData g_miniDumpData;

// host configuration file. If set, it is added to every AppDomain (fusion context)
LPCWSTR g_pszHostConfigFile = NULL;
DWORD   g_dwHostConfigFile = 0;

//
// Meta-Sig
//
#define DEFINE_METASIG(varname, sig)
#define DEFINE_METASIG_PARAMS_1(varname, p1)                     static const USHORT gparams_ ## varname [1] = { CLASS__ ## p1 };
#define DEFINE_METASIG_PARAMS_2(varname, p1, p2)                 static const USHORT gparams_ ## varname [2] = { CLASS__ ## p1, CLASS__ ## p2 };
#define DEFINE_METASIG_PARAMS_3(varname, p1, p2, p3)             static const USHORT gparams_ ## varname [3] = { CLASS__ ## p1, CLASS__ ## p2, CLASS__ ## p3 };
#define DEFINE_METASIG_PARAMS_4(varname, p1, p2, p3, p4)         static const USHORT gparams_ ## varname [4] = { CLASS__ ## p1, CLASS__ ## p2, CLASS__ ## p3, CLASS__ ## p4 };
#define DEFINE_METASIG_PARAMS_5(varname, p1, p2, p3, p4, p5)     static const USHORT gparams_ ## varname [5] = { CLASS__ ## p1, CLASS__ ## p2, CLASS__ ## p3, CLASS__ ## p4, CLASS__ ## p5 };
#define DEFINE_METASIG_PARAMS_6(varname, p1, p2, p3, p4, p5, p6) static const USHORT gparams_ ## varname [6] = { CLASS__ ## p1, CLASS__ ## p2, CLASS__ ## p3, CLASS__ ## p4, CLASS__ ## p5, CLASS__ ## p6 };

#include "metasig.h"

#define DEFINE_METASIG(varname, sig)                             HardCodedMetaSig gsig_ ## varname = { sig, NULL, FALSE, NULL, 0};
#define DEFINE_METASIG_T(varname, sig, params)                   HardCodedMetaSig gsig_ ## varname = { sig, gparams_ ## params, FALSE, NULL, 0};

#include "metasig.h"



#ifdef DEBUG_FLAGS
DWORD                g_DebugFlags;
#endif

//----------------------------------------------------------
// Huge macro to reinitialize all the global binary sigs
//----------------------------------------------------------
#ifdef SHOULD_WE_CLEANUP
/*static*/ void HardCodedMetaSig::Reinitialize()
{
#undef  DEFINE_METASIG
#define DEFINE_METASIG(varname, sig)  gsig_ ## varname.m_fConverted = FALSE;
#include "metasig.h"
}
#endif /* SHOULD_WE_CLEANUP */

#ifndef GOLDEN
#include "version\corver.ver"
char g_Version[] = VER_PRODUCTVERSION_STR;
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\validator.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*
 *
 * Purpose: Provide IValidate implementation.
 *          IValidate is used to validate PE stub, Metadata and IL.
 *
 * Author:  Shajan Dasan
 * Specs :  http://Lightning/Specs/Security
 *
 * Date created : 14 March 2000
 * 
 */

#include "common.h"

#include "CorError.h"
#include "VerError.h"
#include "ivalidator.h"
#include "permset.h"
#include "corhost.h"
#include "PEVerifier.h"
#include "Verifier.hpp"
#include "COMString.h"
#include "ComCallWrapper.h"

// @Todo : remove duplicate code from Assembly.cpp or make that work with this
class CValidator
{
public:
    CValidator(MethodDesc **ppMD, IVEHandler *veh) : m_ppMD(ppMD), m_veh(veh) {}
    HRESULT VerifyAllMethodsForClass(Module *pModule, mdTypeDef cl, 
        ClassLoader *pClassLoader);
    HRESULT VerifyAllGlobalFunctions(Module *pModule);
    HRESULT VerifyAssembly(Assembly *pAssembly);
    HRESULT VerifyModule(Module* pModule);
    HRESULT ReportError(HRESULT hr, mdToken tok=0);

private:
    MethodDesc **m_ppMD;
    IVEHandler *m_veh;
};

HRESULT CValidator::ReportError(HRESULT hr, mdToken tok /* = 0 */)
{
    if (m_veh == NULL)
        return hr;

    VEContext vec;

    memset(&vec, 0, sizeof(VEContext));

    if (tok != 0)
    {
        vec.flags = VER_ERR_TOKEN;
        vec.Token = tok;
    }

    return m_veh->VEHandler(hr, vec, NULL);
}

HRESULT CValidator::VerifyAllMethodsForClass(Module *pModule, mdTypeDef cl, ClassLoader *pClassLoader)
{
    HRESULT hr = S_OK;
    EEClass *pClass;
     
    // In the case of COR_GLOBAL_PARENT_TOKEN (i.e. global functions), it is guaranteed
    // that the module has a method table or our caller will have skipped this step.
    NameHandle name(pModule, cl);
    pClass = (cl == COR_GLOBAL_PARENT_TOKEN
              ? pModule->GetMethodTable()->GetClass()
              : (pClassLoader->LoadTypeHandle(&name)).GetClass());

    if (pClass == NULL)
    {
        hr = ReportError(VER_E_TYPELOAD, cl);
        goto Exit;
    }

    g_fVerifierOff = false;

    // Verify all methods in class - excluding inherited methods
    for (int i=0; i<pClass->GetNumMethodSlots(); ++i)
    {
        *m_ppMD = pClass->GetUnknownMethodDescForSlot(i);   

        if (m_ppMD && 
            ((*m_ppMD)->GetClass() == pClass) &&
            (*m_ppMD)->IsIL() && 
            !(*m_ppMD)->IsAbstract() && 
            !(*m_ppMD)->IsUnboxingStub())
        {

            COR_ILMETHOD_DECODER ILHeader((*m_ppMD)->GetILHeader(), 
                (*m_ppMD)->GetMDImport()); 

            hr = Verifier::VerifyMethod(
                *m_ppMD, &ILHeader, m_veh, VER_FORCE_VERIFY);

            if (FAILED(hr))
                hr = ReportError(hr);

            if (FAILED(hr))
                goto Exit;
        }
    }

Exit:
    *m_ppMD = NULL;
    return hr;
}

// Helper function to verify the global functions
HRESULT CValidator::VerifyAllGlobalFunctions(Module *pModule)
{
    // Is there anything worth verifying?
    if (pModule->GetMethodTable())
        return VerifyAllMethodsForClass(pModule, COR_GLOBAL_PARENT_TOKEN,
                                      pModule->GetClassLoader());
    return S_OK;
}

HRESULT CValidator::VerifyModule(Module* pModule)
{
    // Get a count of all the classdefs and enumerate them.
    HRESULT   hr;
    mdTypeDef td;
    HENUMInternal      hEnum;
    IMDInternalImport *pMDI;

    if (pModule == NULL)
    {
        hr = ReportError(VER_E_BAD_MD);
        goto Exit;
    }

    pMDI = pModule->GetMDImport();

    if (pMDI == NULL)
    {
        hr = ReportError(VER_E_BAD_MD);
        goto Exit;
    }

    hr = pMDI->EnumTypeDefInit(&hEnum);

    if (FAILED(hr))
    {
        hr = ReportError(hr);
        goto Exit;
    }

    // First verify all global functions - if there are any
    hr = VerifyAllGlobalFunctions(pModule);

    if (FAILED(hr))
        goto Cleanup;
    
    while (pModule->GetMDImport()->EnumTypeDefNext(&hEnum, &td))
    {
        hr = VerifyAllMethodsForClass(pModule, td, pModule->GetClassLoader());

        if (FAILED(hr))
            goto Cleanup;
    }

Cleanup:
    pModule->GetMDImport()->EnumTypeDefClose(&hEnum);

Exit:
    return hr;
}

HRESULT CValidator::VerifyAssembly(Assembly *pAssembly)
{
    HRESULT hr;
    mdToken mdFile;
    Module* pModule;
    HENUMInternal phEnum;

    _ASSERTE(pAssembly->IsAssembly());
    _ASSERTE(pAssembly->GetManifestImport());

    // Verify the module containing the manifest. There is no
    // FileRefence so will no show up in the list.
    hr = VerifyModule(pAssembly->GetSecurityModule());

    if (FAILED(hr))
        goto Exit;

    hr = pAssembly->GetManifestImport()->EnumInit(mdtFile, mdTokenNil, &phEnum);

    if (FAILED(hr)) 
    {
        hr = ReportError(hr);
        goto Exit;
    }

    while(pAssembly->GetManifestImport()->EnumNext(&phEnum, &mdFile)) 
    {
        hr = pAssembly->FindInternalModule(mdFile,  tdNoTypes, &pModule, NULL);

        if (FAILED(hr)) 
        {
            hr = ReportError(hr, mdFile);

            if (FAILED(hr))
                goto Exit;
        }
        else if (hr != S_FALSE) 
        {
            hr = VerifyModule(pModule);

            if (FAILED(hr)) 
                goto Exit;
        }
    }

Exit:
    return hr;
}

struct ValidateWorker_Args {
    PEFile *pFile;
    CValidator *val;
    HRESULT hr;
};

static void ValidateWorker(ValidateWorker_Args *args)
{
    Module* pModule = NULL;
    Assembly* pAssembly = NULL;
    AppDomain *pDomain = GetThread()->GetDomain();

    args->hr = pDomain->LoadAssembly(args->pFile, 
                                     NULL,
                                     &pModule, 
                                     &pAssembly,
                                     NULL,
                                     FALSE,
                                     NULL);

    if (SUCCEEDED(args->hr)) 
    {
        if (pAssembly->IsAssembly())
            args->hr = args->val->VerifyAssembly(pAssembly);
        else
            args->hr = args->val->VerifyModule(pModule);
    }
}

struct AddAppBase_Args {
    PEFile *pFile;
    HRESULT hr;
};

HRESULT CorHost::Validate(
        IVEHandler        *veh,
        IUnknown          *pAppDomain,
        unsigned long      ulFlags,
        unsigned long      ulMaxError,
        unsigned long      token,
        LPWSTR             fileName,
        byte               *pe,
        unsigned long      ulSize)
{
    m_pValidatorMethodDesc = 0;

    if (pe == NULL)
        return E_POINTER;

    BOOL    fWasGCEnabled;
    Thread  *pThread;
    PEFile  *pFile;
    Module  *pModule = NULL;
    HRESULT hr = S_OK;

    OBJECTREF  objref = NULL;
    AppDomain  *pDomain = NULL;
    HCORMODULE pHandle;

    CValidator val((MethodDesc **)(&m_pValidatorMethodDesc), veh);

    // Verify the PE header / native stubs first
    if (!PEVerifier::Check(pe, ulSize))
    {
        hr = val.ReportError(VER_E_BAD_PE);

        if (FAILED(hr))
            goto Exit;
    }
    
    pThread = GetThread();
    
    fWasGCEnabled = !pThread->PreemptiveGCDisabled();
    if (fWasGCEnabled)
        pThread->DisablePreemptiveGC();
    
    // Get the current domain
    COMPLUS_TRY {

        // First open it and force a non system load
        hr = CorMap::OpenRawImage(pe, ulSize, fileName, &pHandle);

        if (FAILED(hr)) 
        {
            hr = val.ReportError(hr);
            goto End;
        }

        // WARNING: this skips PE header error detection - if the
        // PE headers are corrupted this will trash memory.
        // 
        // The proper thing to do is pass the byte array into the destination
        // app domain and call PEFile::Create on the bytes.

        hr = PEFile::CreateImageFile(pHandle, NULL, &pFile);
        
        if (FAILED(hr))
        {
            hr = val.ReportError(hr);
            goto End;
        }

        if (pAppDomain == NULL)
        {
            pDomain = AppDomain::CreateDomainContext((WCHAR*) pFile->GetFileName());
            pDomain->SetCompilationDomain();
        }
        else
        {
            GCPROTECT_BEGIN(objref);
            objref = GetObjectRefFromComIP(pAppDomain);
            if (objref != NULL) {
                Context* pContext = ComCallWrapper::GetExecutionContext(objref, NULL);
                if(pContext)
                    pDomain = pContext->GetDomain();
            }
            GCPROTECT_END();
        }
        
        if(pDomain == NULL)
        {
            hr = VER_E_BAD_APPDOMAIN;
        }

        if (FAILED(hr))
        {
            hr = val.ReportError(hr);
            delete pFile;
            goto End;
        }

        ValidateWorker_Args args;
        args.pFile = pFile; 
        args.val   = &val;
        args.hr    = S_OK;

        if (pDomain != pThread->GetDomain())
        {
            pThread->DoADCallBack(
                pDomain->GetDefaultContext(), ValidateWorker, &args);
        }
        else
        {
            ValidateWorker(&args);
        }

        if (FAILED(args.hr))
            hr = val.ReportError(args.hr);

        // Only Unload the domain if we created it.
        if (pAppDomain == NULL)
            pDomain->Unload(TRUE);
End:;

    }
    COMPLUS_CATCH 
    {
        hr = SecurityHelper::MapToHR(GETTHROWABLE());
        hr = val.ReportError(hr);
    }
    COMPLUS_END_CATCH

    if (fWasGCEnabled)
        pThread->EnablePreemptiveGC();

Exit:
    return hr;
}

HRESULT CorHost::FormatEventInfo(
        HRESULT            hVECode,
        VEContext          Context,
        LPWSTR             msg,
        unsigned long      ulMaxLength,
        SAFEARRAY         *psa)
{
    VerError err;
    memcpy(&err, &Context, sizeof(VerError));

    Verifier::GetErrorMsg(hVECode, err, 
            (MethodDesc*)m_pValidatorMethodDesc, msg, ulMaxLength);

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\vars.hpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//
// vars.hpp
//
// Global variables
//
#ifndef _VARS_HPP
#define _VARS_HPP

// This will need ifdefs for non-x86 processors (ia64 is pointer to 128bit instructions)!
#define SLOT    PBYTE

/* Define the implementation dependent size types */

#ifndef _INTPTR_T_DEFINED
#ifdef  _WIN64
typedef __int64             intptr_t;
#else
typedef int                 intptr_t;
#endif
#define _INTPTR_T_DEFINED
#endif

#ifndef _UINTPTR_T_DEFINED
#ifdef  _WIN64
typedef unsigned __int64    uintptr_t;
#else
typedef unsigned int        uintptr_t;
#endif
#define _UINTPTR_T_DEFINED
#endif

#ifndef _PTRDIFF_T_DEFINED
#ifdef  _WIN64
typedef __int64             ptrdiff_t;
#else
typedef int                 ptrdiff_t;
#endif
#define _PTRDIFF_T_DEFINED
#endif


#ifndef _SIZE_T_DEFINED
#ifdef  _WIN64
typedef unsigned __int64 size_t;
#else
typedef unsigned int     size_t;
#endif
#define _SIZE_T_DEFINED
#endif


#ifndef _WCHAR_T_DEFINED
typedef unsigned short wchar_t;
#define _WCHAR_T_DEFINED
#endif

#include "util.hpp"
#include <corpriv.h>
#include <cordbpriv.h>
#include "eeprofinterfaces.h"
#include "profilepriv.h"
#include "eehash.h"

class ClassLoader;
class LoaderHeap;
class GCHeap;
class Object;
class Object;
class StringObject;
class EEClass;
class ArrayClass;
class MethodTable;
class SyncBlockCache;
class SyncTableEntry;
class ThreadStore;
class IPCWriterInterface;
class DebugInterface;
class EEDbgInterfaceImpl;
class EECodeManager;
class Crst;
class MethodNameCache;
struct MiniDumpInternalData;
class ComPlusWrapperCleanupList;

//
// object handles are opaque types that track object pointers
//
DECLARE_HANDLE(OBJECTHANDLE);


//
// _UNCHECKED_OBJECTREF is for code that can't deal with DEBUG OBJECTREFs
//
typedef Object * _UNCHECKED_OBJECTREF;

#ifndef DEFINE_OBJECTREF
#define DEFINE_OBJECTREF
#ifdef _DEBUG
class OBJECTREF;
#else
class Object;
typedef Object *        OBJECTREF;
#endif
#endif


#ifdef _DEBUG


//=========================================================================
// In the retail build, OBJECTREF is typedef'd to "Object*".
// In the debug build, we use operator overloading to detect
// common programming mistakes that create GC holes. The critical
// rules are:
//
//   1. Your thread must have disabled preemptive GC before
//      reading or writing any OBJECTREF. When preemptive GC is enabled,
//      another other thread can suspend you at any time and
//      move or discard objects.
//   2. You must guard your OBJECTREF's using a root pointer across
//      any code that might trigger a GC.
//
// Each of the overloads validate that:
//
//   1. Preemptive GC is currently disabled
//   2. The object looks consistent (checked by comparing the
//      object's methodtable pointer with that of the class.)
//
// Limitations:
//    - Can't say
//
//          if (or) {}
//
//      must say
//
//          if (or != NULL) {}
//
//
//=========================================================================
class OBJECTREF {
    private:
        // Holds the real object pointer.
        // The union gives us better debugger pretty printing
    union {
        Object *m_asObj;
        class StringObject* m_asString;
        class ArrayBase* m_asArray;
        class PtrArray* m_asPtrArray;
    };

    public:
        //-------------------------------------------------------------
        // Default constructor, for non-initializing declarations:
        //
        //      OBJECTREF or;
        //-------------------------------------------------------------
        OBJECTREF();

        //-------------------------------------------------------------
        // Copy constructor, for passing OBJECTREF's as function arguments.
        //-------------------------------------------------------------
        OBJECTREF(const OBJECTREF & objref);

        //-------------------------------------------------------------
        // To allow NULL to be used as an OBJECTREF. 
        //-------------------------------------------------------------
        OBJECTREF(size_t nul);

        //-------------------------------------------------------------
        // Test against NULL.
        //-------------------------------------------------------------
        int operator!() const;

        //-------------------------------------------------------------
        // Compare two OBJECTREF's.
        //-------------------------------------------------------------
        int operator==(const OBJECTREF &objref) const;

        //-------------------------------------------------------------
        // Compare two OBJECTREF's.
        //-------------------------------------------------------------
        int operator!=(const OBJECTREF &objref) const;

        //-------------------------------------------------------------
        // Forward method calls.
        //-------------------------------------------------------------
        Object* operator->();
        const Object* operator->() const;

        //-------------------------------------------------------------
        // Assignment. We don't validate the destination so as not
        // to break the sequence:
        //
        //      OBJECTREF or;
        //      or = ...;
        //-------------------------------------------------------------
        OBJECTREF& operator=(const OBJECTREF &objref);
        OBJECTREF& operator=(int nul);

            // allow explict casts
        explicit OBJECTREF(Object *pObject);
};

//-------------------------------------------------------------
//  template class REF for different types of REF class to be used 
//  in the debug mode
//  Template type should be a class that extends Object
//-------------------------------------------------------------



template <class T> 
class REF : public OBJECTREF
{
    public:
        
        //-------------------------------------------------------------
        // Default constructor, for non-initializing declarations:
        //
        //      OBJECTREF or;
        //-------------------------------------------------------------
      REF() :OBJECTREF ()
        { 
            // no op
        }

        //-------------------------------------------------------------
        // Copy constructor, for passing OBJECTREF's as function arguments.
        //-------------------------------------------------------------
      explicit REF(const OBJECTREF& objref) : OBJECTREF(objref)
        {
            //no op
        }


        //-------------------------------------------------------------
        // To allow NULL to be used as an OBJECTREF.
        //-------------------------------------------------------------
      REF(size_t nul) : OBJECTREF (nul)
        {
            // no op
        }

      explicit REF(T* pObject) : OBJECTREF(pObject) 
        { 
            // no op
        }
        
        //-------------------------------------------------------------
        // Forward method calls.
        //-------------------------------------------------------------
        T* operator->()
        {
            return (T *)OBJECTREF::operator->();
        }

        const T* operator->() const
        {
            return (const T *)OBJECTREF::operator->();
        }

        //-------------------------------------------------------------
        // Assignment. We don't validate the destination so as not
        // to break the sequence:
        //
        //      OBJECTREF or;
        //      or = ...;
        //-------------------------------------------------------------
        REF<T> &operator=(OBJECTREF &objref)
        {
            return (REF<T>&)OBJECTREF::operator=(objref);
        }

};

#define VALIDATEOBJECTREF(objref) ((objref)->Validate())

#define ObjectToOBJECTREF(obj)     (OBJECTREF(obj))
#define OBJECTREFToObject(objref)  (*( (Object**) &(objref) ))
#define ObjectToSTRINGREF(obj)     (STRINGREF(obj))

#else   //_DEBUG

// If you are wondering why this is typed to Object rather than Object, it's
// because services like GetOffset32 and SetOffset8 are introduced on Object, since
// their implementation is based on m_Data.
typedef Object *        OBJECTREF;


#define VALIDATEOBJECTREF(objref);

#define ObjectToOBJECTREF(obj)    ((Object*) (obj))
#define OBJECTREFToObject(objref) ((Object*) (objref))
#define ObjectToSTRINGREF(obj)    ((StringObject*) (obj))

#endif //_DEBUG


// EEClass Needed Defines 
// @todo: Get rid of these!  Don't use them any more!
#define MAX_CLASSNAME_LENGTH    1024
#define MAX_NAMESPACE_LENGTH    1024

class EEConfig;
class ClassLoaderList;
class Module;
class ArrayTypeDesc;

#define EXTERN extern

// For [<I1, etc. up to and including [Object
EXTERN ArrayTypeDesc *     g_pPredefinedArrayTypes[ELEMENT_TYPE_MAX];
EXTERN HINSTANCE            g_pMSCorEE;
EXTERN GCHeap *             g_pGCHeap;
EXTERN ThreadStore *        g_pThreadStore;
EXTERN LONG                 g_TrapReturningThreads;
#ifdef _DEBUG
EXTERN bool                 g_TrapReturningThreadsPoisoned;
EXTERN char *               g_ExceptionFile;
EXTERN DWORD                g_ExceptionLine;
EXTERN void *               g_ExceptionEIP;
#endif
EXTERN EEConfig*            g_pConfig;          // configuration data (from the registry)
// EXTERN CtxMgr *             g_pCtxMgr;
EXTERN LONG                 g_RefCount;
EXTERN MethodTable *        g_pObjectClass;
EXTERN MethodTable *        g_pStringClass;
EXTERN MethodTable *        g_pByteArrayClass;
EXTERN MethodTable *        g_pArrayClass;
EXTERN MethodTable *        g_pExceptionClass;
EXTERN MethodTable *        g_pThreadStopExceptionClass;
EXTERN MethodTable *        g_pThreadAbortExceptionClass;
EXTERN MethodTable *        g_pOutOfMemoryExceptionClass;
EXTERN MethodTable *        g_pStackOverflowExceptionClass;
EXTERN MethodTable *        g_pExecutionEngineExceptionClass;
EXTERN MethodTable *        g_pDelegateClass;
EXTERN MethodTable *        g_pMultiDelegateClass;
EXTERN MethodTable *        g_pFreeObjectMethodTable;
EXTERN MethodTable *        g_pValueTypeClass;
EXTERN MethodTable *        g_pEnumClass;
EXTERN MethodTable *        g_pThreadClass;

MethodTable *        TheSByteClass();
MethodTable *        TheInt16Class();
MethodTable *        TheInt32Class();

MethodTable *        TheByteClass();
MethodTable *        TheUInt16Class();
MethodTable *        TheUInt32Class();

MethodTable *        TheBooleanClass();
MethodTable *        TheSingleClass();
MethodTable *        TheDoubleClass();

MethodTable *        TheIntPtrClass();
MethodTable *        TheUIntPtrClass();

// @TODO Remove eventually - determines whether the verifier throws an exception when something fails
EXTERN bool                 g_fVerifierOff;

// Global System Information
extern SYSTEM_INFO g_SystemInfo;
extern bool        g_SystemLoad; // Indicates the system class libraries are loading

// @TODO - PROMOTE.
EXTERN OBJECTHANDLE         g_pPreallocatedOutOfMemoryException;
EXTERN OBJECTHANDLE         g_pPreallocatedStackOverflowException;
EXTERN OBJECTHANDLE         g_pPreallocatedExecutionEngineException;

// Global SyncBlock cache
EXTERN SyncTableEntry *     g_pSyncTable;

// Global RCW cleanup list
EXTERN ComPlusWrapperCleanupList *g_pRCWCleanupList;

// support for IPCManager 
EXTERN IPCWriterInterface*  g_pIPCManagerInterface;

#ifdef DEBUGGING_SUPPORTED
//
// Support for the COM+ Debugger.
//
EXTERN DebugInterface *     g_pDebugInterface;
EXTERN EEDbgInterfaceImpl*  g_pEEDbgInterfaceImpl;
EXTERN DWORD                g_CORDebuggerControlFlags;
EXTERN HINSTANCE            g_pDebuggerDll;
#endif // DEBUGGING_SUPPORTED

// Global variable to determine which threadpool implementation is being used
EXTERN BOOL g_Win32Threadpool;

// Global default for Concurrent GC. The default is on (value 1)
EXTERN int g_IGCconcurrent;
//
// Can we run managed code?
//
bool CanRunManagedCode(void);

//
// Global state variable indicating if the EE is in its init phase.
//
EXTERN bool g_fEEInit;

extern BOOL g_fEEStarted;

//
// Global state variables indicating which stage of shutdown we are in
//
EXTERN DWORD g_fEEShutDown;
extern BOOL g_fSuspendOnShutdown;
EXTERN bool g_fForbidEnterEE;
EXTERN bool g_fFinalizerRunOnShutDown;
EXTERN bool g_fProcessDetach;
EXTERN bool g_fManagedAttach;
EXTERN bool g_fNoExceptions;
EXTERN bool g_fFatalError;

//
// Global state variable indicating that thread store lock requirements may be relaxed in certian special places.
//
EXTERN bool g_fRelaxTSLRequirement;

//
// Default install library
//
__declspec(selectany) EXTERN const WCHAR g_pwBaseLibrary[] = L"mscorlib.dll";
__declspec(selectany) EXTERN const WCHAR g_pwBaseLibraryName[] = L"mscorlib";
__declspec(selectany) EXTERN const WCHAR g_pwBaseLibraryTLB[] = L"mscorlib.tlb";
__declspec(selectany) EXTERN const char g_psBaseLibrary[] = "mscorlib.dll";
__declspec(selectany) EXTERN const char g_psBaseLibraryName[] = "mscorlib";
__declspec(selectany) EXTERN const char g_psBaseLibraryTLB[] = "mscorlib.tlb";

EXTERN DWORD g_dwGlobalSharePolicy;

//
// Do we own the lifetime of the process, ie. is it an EXE?
//
EXTERN bool g_fWeControlLifetime;

#ifdef _DEBUG
// The following should only be used for assertions.  (Famous last words).
EXTERN bool dbg_fDrasticShutdown;
#endif
EXTERN bool g_fInControlC;

EXTERN BOOL                 g_fExceptionsOK;

// There is a global table of prime numbers that's available for e.g. hashing
extern const DWORD g_rgPrimes[70];

// A hash of all function type descs on the system (to maintain type desc
// identity).
extern EEFuncTypeDescHashTable g_sFuncTypeDescHash;
extern CRITICAL_SECTION g_sFuncTypeDescHashLock;

#ifdef DEBUGGING_SUPPORTED
//
// This structure contains data needed to complete a managed minidump
//
extern MiniDumpInternalData g_miniDumpData;

//
// Host configuration file. One per process.
//
extern LPCWSTR g_pszHostConfigFile;
extern DWORD   g_dwHostConfigFile;

//
// Macros to check debugger and profiler settings.
//
#define CORDebuggerAttached() (g_CORDebuggerControlFlags & DBCF_ATTACHED)

#define CORDebuggerTrackJITInfo(dwDebuggerBits)                    \
    (((dwDebuggerBits) & DACF_TRACK_JIT_INFO)                      \
     ||                                                            \
     ((g_CORDebuggerControlFlags & DBCF_GENERATE_DEBUG_CODE) &&    \
      !((dwDebuggerBits) & DACF_USER_OVERRIDE)))
     
#define CORDebuggerAllowJITOpts(dwDebuggerBits)                    \
    (((dwDebuggerBits) & DACF_ALLOW_JIT_OPTS)                      \
     ||                                                            \
     ((g_CORDebuggerControlFlags & DBCF_ALLOW_JIT_OPT) &&          \
      !((dwDebuggerBits) & DACF_USER_OVERRIDE)))
    
#define CORDebuggerEnCMode(dwDebuggerBits)                         \
    ((dwDebuggerBits) & DACF_ENC_ENABLED)
     
#define CORDebuggerTraceCall() \
    (CORDebuggerAttached() && GetThread()->IsTraceCall())

#define CORActivateRemoteDebugging()    \
    (g_CORDebuggerControlFlags & DBCF_ACTIVATE_REMOTE_DEBUGGING)

#define CORLaunchedByDebugger() \
    (g_CORDebuggerControlFlags & DBCF_GENERATE_DEBUG_CODE)

#else

#define CORDebuggerEnCMode(dwDebuggerBits) (0)

#endif // DEBUGGING_SUPPORTED

        
#define DEFINE_METASIG(varname, sig)                                extern HardCodedMetaSig gsig_ ## varname;
#include "metasig.h"


#ifdef DEBUG_FLAGS
extern DWORD                g_DebugFlags;
#endif



#define NEWCALLINGCONVENTION 1
#ifdef NEWCALLINGCONVENTION

#define NEEDSCALLINGCONVENTIONWORK(funcname) _ASSERTE(!(#funcname ": This code path hasn't been updated to work with alternate calling conventions."))

#else

#define NEEDSCALLINGCONVENTIONWORK(funcname)

#endif


// @todo: Undefine this once our native calling convention follows VC style
// of returned values and passed arguments containing garbage in unused
// high bits.
#define WRONGCALLINGCONVENTIONHACK

// This tests for valid variants coming in from COM on debug builds.
#if defined(_DEBUG)
#define CHECK_FOR_VALID_VARIANTS
#endif

EXTERN MethodNameCache      *g_pMethodNameCache;


// Switch to enable IClassFactory2 support (will remove variable when support is completely working)
extern BOOL g_EnableLicensingInterop;


#endif /* _VARS_HPP */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\verbblock.hpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//
// verbblock.hpp
//
// Verifier basic block class
//
#ifndef _H_BBLOCK
#define _H_BBLOCK


//
// An EntryState is a set of constraints that must be met before entering a basic block.
//
// When the verifier enters a basic block for the first time, it stores its current state
// (stack and locals) in the basic block's EntryState.
//
// If the verifier subsequently enters the same basic block, it will check that its state
// is compatible with the EntryState - if so, it will not re-evaluate the block.  If not,
// it will further constrain EntryState by "AND"ing together its current state with
// EntryState, and will then re-evaluate the block.
//
// For example, the first time the BB is entered, "LocVar #1=I4" is stored in the EntryState,
// but the second time the BB is entered, LocVar#1 is uninitialised - therefore the EntryState
// will be amended to note that "LocVar #1=DEAD".  
//
// An EntryState comprises the following, in the following order:
//
// 1. Declared data members (m_StackSlot)
//
// 2. Liveness table for primitive local variables
//    (memsize == Verifier::m_PrimitiveLocVarBitmapMemSize)
//
// 3. Non-primitive object types, each of which is an Item 
//    Data starts at (BYTE*) &EntryState + m_NonPrimitiveLocVarOffset
//
// 4. If this is a value class constructor method, then there is a bitmap with a bit
//    for each field, indicating whether it has been initialised.
//
// 5. Contents of the stack, each element is an Item.  There are m_StackSlot elements.
//    Data starts at (BYTE*) &EntryState + m_StackItemOffset
//
// Example:
// m_Slot = 0  ==> non-primitive local variable, index 0
// m_Slot = 1  ==> non-primitive local variable, index 1
// m_Slot = 2  ==> non-primitive local variable, index 2
// m_Slot = -1 ==> primitive local variable, bit #0 
// m_Slot = -2 ==> primitive local variable, bit #1 
// m_Slot = -3 ==> primitive local variable, bit #2 
//
#define MAX_ENTRYSTATE_REFCOUNT 255

//
// This flag indicates that argument slot 0 contains an uninitialised object.
//
#define ENTRYSTATE_FLAG_ARGSLOT0_UNINIT 1


// implied: #define UNINIT_OBJ_LOCAL_MASK   0x0000

#pragma pack(push,4)
typedef struct 
{
public:
    //
    // Number of references to this EntryState.
    //
    // When a control flow instruction is seen, the verifier will create a single EntryState for 
    // all unvisited destination basic blocks.  If this EntryState must be modified and 
    // m_Refcount > 1, then it must first be cloned.
    //
    BYTE            m_Refcount;

    //
    // See above.  Currently used only to indicate whether argument #0 is uninitialised (which
    // can happen only in a constructor)
    //
    BYTE            m_Flags;

    // Stack size in # slots
    WORD            m_StackSlot;
    
    //
    // Bitmap of *primitive types* local variable liveness.
    //
    // Consult m_pLocVarTypeList to convert a local variable # to a slot # for bitmap lookup.
    //
    // This structure is allocated such that this array really has
    // Verifier::m_NumPrimitiveLocVarBitmapArrayElements elements.
    //
    DWORD           m_PrimitiveLocVarLiveness[1];

    //
    // The state of non-primitive (object etc.) types is directly after the above, as a set
    // of Items (total size m_NonPrimitiveLocVarMemSize in bytes, m_NumNonPrimitiveLocVars elements)
    //

    //
    // Then, if this is a value class constructor, there is a bitmap indicating which fields
    // of the value class have been initialised.
    //

    //
    // The contents of the stack appear directly after the above array, as an array of Items
    //
    // There are EntryState_t->m_StackSlot elements.
    //
} EntryState_t;
#pragma pack(pop)


#define VER_BB_NONE ((DWORD) -1)

//
// BasicBlocks can have multiple states.
//
// Eg. Basic Blocks of Finally, which could have multiple states
//      depending on the number of leave destinations.
//
//
// One ExtendedState can be used for each leave destinations.
// dwInfo can be used to store the leave destination
// pInfo can point to the exception record
//
typedef struct
{
    // Initial state (will be NULL if never visited)
    EntryState_t    *m_pInitialState;

    // Location of first instruction in this block
    DWORD            m_StartPC;          

    ///////////////////////////////////////////////////////////////////////
    //
    // The fields below are used only in a finally block with leave targets
    //
    // This special state is only used for processing leave instructions
    // in finally blocks. Finally blocks have two basic states.
    // 1. The normal state like any other blocks
    // 2. When this finally is entered as the result of a leave instruction.
    //      Each leave destination will have it's own state.
    //
    ///////////////////////////////////////////////////////////////////////

    VerExceptionInfo  *m_pException;       // The exception record for finally

    union
    {
        // free this pointer to m_pDirtyBitmap and m_pExtendedState
        BYTE       *m_pAlloc; 

        // dirty / clean BB bitmap for extended
        DWORD      *m_pExtendedDirtyBitmap;   

    };

    EntryState_t     **m_ppExtendedState;  // One entry state pointer per BB

    BOOL AllocExtendedState(DWORD dwSize)
    {
        _ASSERTE(m_pAlloc == NULL);

        // One Alloc is done for ExtendedState & DirtyBitmap;

        DWORD dwBitmapSize = NUM_DWORD_BITMAPS(dwSize) * sizeof(DWORD);
        DWORD dwTotalSize  = dwBitmapSize + 
                             sizeof(EntryState_t *) * dwSize;

        m_pAlloc = new BYTE[dwTotalSize];

        if (m_pAlloc == NULL)
            return FALSE;

        // Don't need to do this assignment.
        // m_pExtendedDirtyBitmap = (DWORD*) m_pAlloc;

        m_ppExtendedState = (EntryState_t**)((PBYTE)(m_pAlloc + dwBitmapSize));

        memset(m_pAlloc, 0, dwTotalSize); 

        return TRUE;
    }

} BasicBlock;


#endif /* _H_BBLOCK */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\veropcodes.hpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//
// veropcodes.hpp
//
// Declares the enumeration of the opcodes and the decoding tables.
//
#include "openum.h"

#define HackInlineAnnData  0x7F

#ifdef DECLARE_DATA
#define OPDEF(c,s,pop,push,args,type,l,s1,s2,ctrl) s,

char *ppOpcodeNameList[] =
{
#include "opcode.def"
};

#undef OPDEF
#define OPDEF(c,s,pop,push,args,type,l,s1,s2,ctrl) args,

// Whether opcode is Inline0 etc.
BYTE OpcodeData[] =
{
#include "opcode.def"
     0 /* for CEE_COUNT */
};

#undef OPDEF

#else /* !DECLARE_DATA */

extern char *ppOpcodeNameList[];

extern BYTE OpcodeData[];

#endif /* DECLARE_DATA */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\verifier.hpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//
// verifier.hpp
//
// Contact : Shajan Dasan [shajand@microsoft.com]
// Specs   : http://Lightning/Specs/Security
//
// Dead code verification is for supporting FJIT. If FJIT gets fixed so that it
// can handle dead code, remove code #ifdefed in _VER_VERIFY_DEAD_CODE
//

#ifndef _VERIFIER_HPP
#define _VERIFIER_HPP

#define _VER_VERIFY_DEAD_CODE   1       // Verifies dead code

#include "IVEHandler.h"
#include "VerError.h"

class Verifier;

#define VER_FORCE_VERIFY        0x0001      // Fail even for fully trusted code
#define VER_STOP_ON_FIRST_ERROR 0x0002      // Tools can handle multiple errors 

// Extensions to ELEMENT_TYPE_* enumeration in cor.h

// Any objref
#define VER_ELEMENT_TYPE_OBJREF         (ELEMENT_TYPE_MAX)

// Any value class
#define VER_ELEMENT_TYPE_VALUE_CLASS    (ELEMENT_TYPE_MAX+1)

// A by-ref anything
#define VER_ELEMENT_TYPE_BYREF          (ELEMENT_TYPE_MAX+2)

// Unknown/invalid type
#define VER_ELEMENT_TYPE_UNKNOWN        (ELEMENT_TYPE_MAX+3)

// Sentinel value (stored at slots -1 and -2 of the stack to catch stack overflow)
#define VER_ELEMENT_TYPE_SENTINEL       (ELEMENT_TYPE_MAX+4)

#define VER_LAST_BASIC_TYPE             (ELEMENT_TYPE_MAX+4)

#define VER_ARG_RET     VER_ERR_ARG_RET
#define VER_NO_ARG      VER_ERR_NO_ARG

// NUM_DWORD_BITMAP : Given the number of bits (n), gives the minimum number
// of DWORDS required to represent n bits.
// 
// Minimum number of DWORDS required.
// 
// Bits         # DWORDS
// -------------------
// 1 ..32   ->    1
// 33..64   ->    2
//
// Number of bits in a DWORD == 32
// 
// ==> n/32 ; if n is fully divisible by 32
//	   n/32 + 1 ; if n % 32 has a reminder
//
// ==> (n + 32 - 1)/32
//
// ==> (n + 31) >> 5	; since (x/32) == (x >> 5) ; 32 == Bin(100000)
//
#define NUM_DWORD_BITMAPS(n) (((n) + 31) >> 5)

// Set the n'th bit (of a bitmap represented by an array of DWORDS)
#define SET_BIT_IN_DWORD_BMP(pdw, n) pdw[(n) >> 5] |= (1 << ((n) & 31))

// Reset the n'th bit (of a bitmap represented by an array of DWORDS)
#define RESET_BIT_IN_DWORD_BMP(pdw, n) pdw[(n) >> 5] &= ~(1 << ((n) & 31))

// Is the n'th bit set (of a bitmap represented by an array of DWORD)
#define IS_SET_BIT_IN_DWORD_BMP(pdw, n) (pdw[((n) >> 5)] & (1 << ((n) & 31)))


#include <stdio.h>
#include "cor.h"
#include "veropcodes.hpp"
#include "util.hpp"
#include "veritem.hpp"
#include "versig.h"


#define MAX_SIGMSG_LENGTH 100
#define MAX_FAILMSG_LENGTH 384 + MAX_SIGMSG_LENGTH


//#define VERIFY_LINKTIME_SECURITY
// Moved LinkTimeChecks to JIT Time


// Max # of stack slots and local variables
// The EntryState uses a WORD to hold the max stack value.
#define MAX_STACK_SLOTS 0xFFFF
#define MAX_LOCALS      32767

struct VerExceptionInfo;
struct VerExceptionBlock;
class  Verifier;

struct VerExceptionInfo
{
    // XX because initially these are all PC values.  
    // However, we call RewriteExceptionList() to convert
    // them to Basic Block numbers later.

    DWORD               dwTryXX;                // Try Start
    DWORD               dwTryEndXX;             // Actual Try End + 1
    VerExceptionBlock  *pTryBlock;              // position in BlockTree

    // This node is the Equivalent Head block of pTryBlock.
    // In this case pTryBlock is not the head node of this linked list.
    // pTryEquivalentHeadNode will be the first node in the linked list, which
    // contains pTryBlock.
    VerExceptionBlock  *pTryEquivalentHeadNode;

    DWORD               dwHandlerXX;            // Handler Start
    DWORD               dwHandlerEndXX;         // Actual Handler End + 1
    VerExceptionBlock  *pHandlerBlock;          // position in BlockTree

    // FilterEnd is not available from metadata. 
    // It is filled in during first pass.

    DWORD               dwFilterXX;             // Filter start
    DWORD               dwFilterEndXX;          // Actual FilterEnd + 1 
    VerExceptionBlock  *pFilterBlock;           // position in BlockTree

    TypeHandle          thException;            // Type filter of CATCH
    CorExceptionFlag    eFlags;                 // FILTER / FAULT / FINALLY
};

#include "verbblock.hpp"

typedef enum
{
    eVerTry        = 0,      // try Block
    eVerHandler    = 1,      // handler Block (catch, finally, fault)
    eVerFilter     = 2       // filter Block
} eVerEBlockType;

struct VerExceptionBlock
{
    DWORD               StartBB;
    DWORD               EndBB;          // End is the last BB in this block

    VerExceptionInfo    *pException;    // Pointer to the exception Info

    VerExceptionBlock   *pSibling;      // Sibling relation
    VerExceptionBlock   *pChild;        // Contains relation
    VerExceptionBlock   *pEquivalent;   // Same Start, end

    eVerEBlockType      eType;          // eTry / eHandler / eFilter
    

    // Inserts node into the tree starting at ppRoot
    // This function may modify root to point to Node, thus making Node
    // the new root.

    static BOOL Insert(
                    VerExceptionBlock **ppRoot, 
                    VerExceptionBlock *pNode,
                    VerExceptionBlock **ppEquivalentHeadNode,
                    Verifier          *pVerifier);

    // Modifies *ppRoot to point to pNode, thus making pNode the new root.
    // Makes **pRoot the child of *pNode.
    // The siblings to the right of **ppRoot, are made the sibling of
    // *pNode if they are not a children of *pNode.

    static BOOL InsertParent(
                    VerExceptionBlock **ppRoot, 
                    VerExceptionBlock *pNode);

    // Given a node which contains BB, finds the next inner node that 
    // contains BB. returns NULL if there is no such node.

    static VerExceptionBlock* FindNext(
                    VerExceptionBlock *pNode, 
                    DWORD               BB);

    // Given a node, find it's parent
    // returns NULL if child is the root node

    static VerExceptionBlock* FindParent(
                    VerExceptionBlock *pChild, 
                    VerExceptionBlock *pRoot);
};

// Check if a VerBasicBlock contains a Basic Block
#define VER_BLOCK_CONTAINS_BB(pb, BB) \
    ((pb)->StartBB <= (BB) && (pb)->EndBB >= (BB))

#ifdef _DEBUG
// The verifier moves from one state to the next in the order
// of the following enums.
typedef enum
{
    verUninit            = 0,    // Members don't have any useful value
    verExceptListCreated = 1,    // ExceptionList created
    verPassOne           = 2,    // In PassOne 
    verExceptToBB        = 3,    // ExceptionList is converted to Basic Block
    verExceptTreeCreated = 4,    // Exception Tree is created
    verPassTwo           = 5     // In PassTwo
} verState;
#endif

//
// These macros are used to get information about local variables and arguments, which are treated similarly.
// The types of arguments are always fixed, and therefore they are not never tracked.  The only argument state
// which is tracked is whether the "this" pointer is uninitialised (m_fThisUninit).  Otherwise the current
// value of an argument can be assumed to be its global type.
//

//
// Convert a negative slot number (which indicates only live-dead tracking) to a zero-based bit number
//
// For example, if a local says it is at slot -5, it really means that it is bit #4 in the liveness bitmap.
//
#define LIVEDEAD_NEGATIVE_SLOT_TO_BITNUM(slot) (-(slot) -1)

//
// Does a given slot carry only live/dead information (i.e. all other information is fixed)?
//
// Negative slots mean it carries only live/dead information.
//
#define LIVEDEAD_TRACKING_ONLY_FOR_SLOT(slot) ((slot) < 0)


//
// This structure is used globally to hold the type of each local variable and argument.
//
// For a given EntryPoint it is not enough to know the liveness of a local variable/arg, since
// local variables/args can be reused for different object types.  A lookup on the LocVarInfo table
// returns an m_Slot, which, if positive, is the index of this variable's Item structure after 
// the local variable liveness and stack state entries in the EntryState_t.
//
// Items which are primitive types will have negative m_Slots (-1, -2, ...).  This mapping is
// used to get the bit number to use for the liveness bitmap, which is used only for primitive 
// types.  
//
// See verbblock.hpp for more info.
//
// Arguments are logically treated as local variables, starting at m_MaxLocals
//
typedef struct
{
    Item    m_Item; // Full type info
    long    m_Slot; // Slot number
} LocArgInfo_t;


// These are the ways control can pass out of a basic block
typedef enum
{
    eVerFallThru,           // includes fallthru of a conditional branch
    eVerRet,
    eVerBranch,
    eVerThrow,
    eVerReThrow,
    eVerLeave,
    eVerEndFinally,
    eVerEndFilter
} eVerControlFlow;

class Verifier
{
    friend class VerSig;
    friend class Item;

private:
    const BYTE *    m_pCode;            // IL code
    MethodDesc *    m_pMethodDesc;      // Method we're verifying
    COR_ILMETHOD_DECODER *m_pILHeader;
    DWORD           m_CodeSize;         // Size of IL code in bytes
    DWORD           m_MaxLocals;        // Max # local variables
    PCCOR_SIGNATURE m_LocalSig;         // The signature of the local var frame
    Item            m_ReturnValue;      // Return value item
    DWORD           m_NumArgs;          // Number of arguments
    BOOL            m_fInClassConstructorMethod; // Is the method we're verifying a class constructor?
    BOOL            m_fInConstructorMethod; // Is the method we're verifying a constructor?
    BOOL            m_fInValueClassConstructor;
    BOOL            m_fIsVarArg;        // This method has a Var Arg signature
    BOOL            m_fHasFinally;      // This method has finally blocks

    BasicBlock *    m_pBasicBlockList;  // Array of basic blocks, in order
    DWORD           m_NumBasicBlocks;   // # basic blocks in this list
    DWORD *         m_pDirtyBasicBlockBitmap; // which basic blocks need to be visited
    DWORD           m_NumDirtyBasicBlockBitmapDwords;

    // If a bit is set for a local, it means that its type is pinned, and that whenever we load
    // out of it, we get its global type, not its "current" type.
    // We do this for objref locals which we took the address of.
    DWORD *         m_pLocalHasPinnedType; 
    DWORD           m_dwLocalHasPinnedTypeBitmapMemSize;

    // size in bytes of primitive local var bitmap used in EntryState_t
    // no space is allocated for args, since primitive args are always live
    DWORD           m_PrimitiveLocVarBitmapMemSize; 

    // size in DWORDs of primitive local var bitmap used in EntryState_t
    DWORD           m_NumPrimitiveLocVarBitmapArrayElements;

    // size in bytes of non-primitive local/arg Item list used in EntryState_t
    DWORD           m_NonPrimitiveLocArgMemSize;

    // offset in bytes from start of EntryState_t to non-primitive Item list
    DWORD           m_NonPrimitiveLocArgOffset;

    // offset in bytes from start of EntryState_t to stack Item list
    DWORD           m_StackItemOffset;

    // number of non-primitive local variables
    DWORD           m_NumNonPrimitiveLocVars;

    // the "global" type of each local variable (I4,F4,...,object) and argument
    // arguments come after locals
    LocArgInfo_t *  m_pLocArgTypeList;  

    // max # slots on stack
    DWORD           m_MaxStackSlots;    

    // If verifying a value class constructor, this is the number of instance fields in the value class
    DWORD           m_dwValueClassInstanceFields;
    DWORD           m_dwNumValueClassFieldBitmapDwords;

    // offset in bytes from start of EntryState_t to value class field bitmap
    DWORD           m_dwValueClassFieldBitmapOffset;

    // the current state...
    DWORD           m_StackSlot;        // current number of entities on the stack
    DWORD *         m_pPrimitiveLocVarLiveness; // bitmap of primitive local variables which are live (primitive args are always live)
    Item *          m_pStack;           // pointer to stack
    Item *          m_pNonPrimitiveLocArgs; // Item list of non-primitive local variables and arguments
    DWORD *         m_pValueClassFieldsInited; // if in a value class constructor, bitmap of instance field initialised
    // Is the "this" pointer uninitialised? (only possible when verifying a ctor method)
    BOOL            m_fThisUninit;
    // end ... current state

    // If this is in a try block, then we must record the initial state of the primitive local and args at
    // the beginning of the basic block, and AND'd together state of the object locals throughout the
    // entire basic block.
    DWORD *         m_pExceptionPrimitiveLocVarLiveness;
    Item *          m_pExceptionNonPrimitiveLocArgs;

    // for accessing metadata
    IMDInternalImport *m_pInternalImport;
    Module *        m_pModule;

    VerExceptionInfo *m_pExceptionList;
    DWORD           m_NumExceptions;

    VerExceptionBlock *m_pExceptionBlockArray;  // An array of blocks
    VerExceptionBlock *m_pExceptionBlockRoot;   // Tree Structure.

#ifdef _DEBUG
    DWORD           m_nExceptionBlocks;
#endif

    HRESULT         m_hrLastError;              // The last Error
    VerError        m_sError;                   // More info on the error

    WORD            m_wFlags;                   // Verification flags
    IVEHandler     *m_IVEHandler;               // Error Callback

    ClassLoader *   m_pClassLoader;

    // Keep track of exceptions thrown during verification
    OBJECTHANDLE    m_hThrowable ;


#ifdef _DEBUG
    // m_verState will be updated to the state the verifier is in.
    // some methods in the Verifier class can be called only when the
    // verifier is in certain state. Assert that the verifier is in the
    // desired stated before executing the method.
    verState        m_verState;

    BOOL            m_fDebugBreak;
    BOOL            m_fDebugBreakOnError;
#endif

    // instruction & basic block boundary bitvector
    DWORD          *m_pInstrBoundaryList;

    // the basic block boundary bitvector (points into m_pInstrBoundaryList)
    DWORD          *m_pBasicBlockBoundaryList;

public:
    static TypeHandle s_th_System_RuntimeTypeHandle;
    static TypeHandle s_th_System_RuntimeMethodHandle;
    static TypeHandle s_th_System_RuntimeFieldHandle;
    static TypeHandle s_th_System_RuntimeArgumentHandle;
    static TypeHandle s_th_System_TypedReference;
    static void     InitStaticTypeHandles();

public:
    Verifier(WORD wFlags, IVEHandler *veh);
    ~Verifier();
    void            Cleanup();
    BOOL            Init(MethodDesc *pMethodDesc, COR_ILMETHOD_DECODER* ILHeader);
#ifdef _VER_VERIFY_DEAD_CODE
    HRESULT Verify(DWORD CurBBNumber);
#else
    HRESULT Verify();
#endif
    OBJECTREF       GetException () { return ObjectFromHandle (m_hThrowable) ; }
    static HRESULT  VerifyMethodNoException(MethodDesc *pMethodDesc, COR_ILMETHOD_DECODER* ILHeader);
    static HRESULT  VerifyMethod(MethodDesc *pMethodDesc, COR_ILMETHOD_DECODER* ILHeader, IVEHandler *veh, WORD wFlags);
    static OPCODE   DecodeOpcode(const BYTE *pCode, DWORD *pdwLen);
    static OPCODE   SafeDecodeOpcode(const BYTE *pCode, DWORD BytesAvail, DWORD *pdwLen);
    static BOOL     CanCast(CorElementType el1, CorElementType el2);

private:
    HRESULT FindBasicBlockBoundaries(
        const BYTE *pILCode, 
        DWORD       cbILCodeSize, 
        DWORD       MaxLocals, 
        DWORD *     BasicBlockCount, 
        DWORD *     pAddressTakenOfLocals   // Bitmap must already be zeroed!
    );

    HRESULT         GenerateBasicBlockList();
    DWORD           FindBasicBlock(DWORD FindPC);
    BOOL            CheckStateMatches(EntryState_t *pEntryState);
    BOOL            DequeueBB(DWORD *pBBNumber, 
                              BOOL *pfExtendedState, 
                              DWORD *pDestBB);

    void            CreateStateFromEntryState(const EntryState_t *pEntryState);
    EntryState_t *  MakeEntryStateFromState();
    BOOL            MergeEntryState(BasicBlock *pBB,
                                    BOOL fExtendedState, DWORD DestBB);
    BOOL            AssignLocalVariableAndArgSlots();

    // Exception related
    BOOL            CreateExceptionList(const COR_ILMETHOD_SECT_EH* ehInfo);
    BOOL            MarkExceptionBasicBlockBoundaries(
										DWORD *NumBasicBlocks,
                                        DWORD *pnFilter);
    void            RewriteExceptionList();
    BOOL            CreateExceptionTree();
    BOOL            PropagateCurrentStateToFilterHandler(DWORD HandlerBB);
    BOOL            PropagateCurrentStateToExceptionHandlers(DWORD CurBB);
    void            MergeObjectLocalForTryBlock(DWORD dwSlot, Item *pItem);
    void            RecordCurrentLocVarStateForExceptions();

    // Find the inner and outer most blocks that contain BB, null if not found.
    // fInTryBlock is set if an of the containing blocks is a try block.
    // This function is overloaded for performance reasons.
    void            FindExceptionBlockAndCheckIfInTryBlock(
                                        DWORD BB, 
                                        VerExceptionBlock **ppOuter, 
                                        VerExceptionBlock **ppInner, 
                                        BOOL *pfInTryBlock) const;

    // Checks if exception handlers are shared, filters have trys etc..
    BOOL            VerifyLexicalNestingOfExceptions();

#ifdef _DEBUG
    static void     AssertExceptionTreeIsValid(VerExceptionBlock *pRoot);
#endif

    // Checks for branch in and out of exception blocks.
    // This function should also be used for checking fall thru conditions.
    BOOL            IsControlFlowLegal(
                            DWORD FromBB,     
                            VerExceptionBlock *pFromOuter, 
                            VerExceptionBlock *pFromInner, 
                            DWORD ToBB,     
                            VerExceptionBlock *pToOuter,
                            VerExceptionBlock *pToInner,
                            eVerControlFlow   eBranchType,
                            DWORD dwPCAtStartOfInstruction);

    // Checks if the given Basic Block is the start of a catch or filter handler
    // Of the given ExceptionBlock
    BOOL            IsBadControlFlowToStartOfCatchOrFilterHandler(
                            eVerControlFlow   eBranchType,
                            DWORD             BB, 
                            VerExceptionBlock *pException);

    BOOL            AddLeaveTargetToFinally(DWORD leavePC, DWORD destPC);
    BOOL            AddEndFilterPCToFilterBlock(DWORD pc);

    BOOL            CreateFinallyState(DWORD eIndex, 
                                       DWORD curBB, 
                                       DWORD leaveBB,
                                       EntryState_t **ppEntryState);

    BOOL            CreateLeaveState(DWORD leaveBB, 
                                     EntryState_t **ppEntryState);

    BOOL            HandleDestBasicBlock(DWORD        BBNumber, 
                                         EntryState_t **ppEntryState,
                                         BOOL         fExtendedState,
                                         DWORD        DestBB);

    BOOL            GetArrayItemFromOperationString(LPCUTF8 *ppszOperation, Item *pItem);

    // Slot must be valid for these functions
    // These functions work on PRIMITIVE locals only
    // Note that the slot is NOT the same as the local variable number
    DWORD           IsLocVarLiveSlot(DWORD slot);
    void            SetLocVarLiveSlot(DWORD slot);
    void            SetLocVarDeadSlot(DWORD slot);

    // There are 2 types of BasicBlocks.
    // One for normal blocks including normal exception handlers & finally
    // blocks. The second Basic block bitmap is used for tracking finally
    // block with leave targets.
    // Finally blocks have multiple states. One which gets executed when an 
    // exception occurs and others that gets executed when a leave instruction 
    // is executed. This transfer control into the finally block(s) and then 
    // into the leave destination.

    BOOL            SetBasicBlockDirty(DWORD BasicBlockNumber, 
                                       BOOL fExtendedState, 
                                       DWORD DestBB);
    void            SetBasicBlockClean(DWORD BasicBlockNumber, 
                                       BOOL fExtendedState, 
                                       DWORD DestBB);
    DWORD           IsBasicBlockDirty(DWORD BasicBlockNumber, 
                                      BOOL fExtendedState, 
                                      DWORD DestBB);

    void            SetValueClassFieldInited(FieldDesc *pFieldDesc);
    void            SetValueClassFieldInited(DWORD dwInstanceFieldNum);
    BOOL            IsValueClassFieldInited(DWORD dwInstanceFieldNum);
    BOOL            AreAllValueClassFieldsInited();
    void            SetAllValueClassFieldsInited();
    long            FieldDescToFieldNum(FieldDesc *pFieldDesc);
    void            PropagateThisPtrInit();
    void            PropagateIsInitialised(Item *pItem);
    void            InitialiseLocalViaByRef(DWORD dwLocVar, Item *pItem);
    DWORD           DoesLocalHavePinnedType(DWORD dwLocVar);

    BOOL            PushPrimitive(DWORD Type);
    BOOL            Push(const Item *pItem);
    BOOL            Pop(DWORD Type);
    BOOL            FastPop(DWORD Type);
    BOOL            CheckTopStack(DWORD Type);
    BOOL            FastCheckTopStack(DWORD Type);
    BOOL            CheckStack(DWORD Slot, DWORD Type);
    Item *          GetTopStack(); 
    Item *          GetStack(DWORD Slot);
    Item *          PopItem();
    Item *          FastPopItem();
    void            FastPush(DWORD Type);
    BOOL            RemoveItemsFromStack(DWORD NumItems);

    HRESULT         ResolveFieldRef(mdMemberRef mr, 
                                    FieldDesc **ppFieldDesc, 
                                    PCCOR_SIGNATURE *ppSig, 
                                    DWORD *pcSig, 
                                    Module **ppModule);

    ArrayClass *    GetArrayClass(LPCUTF8 pszClassName);
    HRESULT         VerifyMethodCall(DWORD dwPCAtStartOfInstruction, 
                                     mdMemberRef mrMemberRef, 
                                     OPCODE dwOpcode,
                                     BOOL   fTailCall, 
                                     OBJECTREF *pThrowable);

    LocArgInfo_t *  GetGlobalLocVarTypeInfo(DWORD dwLocVarNum);
    LocArgInfo_t *  GetGlobalArgTypeInfo(DWORD dwArgNum);
    Item            GetCurrentValueOfLocal(DWORD dwLocNum);
    Item            GetCurrentValueOfArgument(DWORD dwArgNum);
    Item *          GetCurrentValueOfNonPrimitiveArg(DWORD dwArg);

    // Returns the position of the first set bit in an array of DWORDS
    // cArray is the length of the DWORD array
    // Returns FALSE if not set.
    static BOOL     FindFirstSetBit(DWORD *pArray, DWORD cArray, DWORD *pIndex);
    static void     ExchangeDWORDArray(DWORD *pArray1, DWORD *pArray2, DWORD dwCount);
    static void     ExchangeItemArray(Item *pArray1, Item *pArray2, DWORD dwCount);
    static DWORD    OperationStringTypeToElementType(char c);
    static long     TryConvertPrimitiveValueClassToType(TypeHandle th);


public:
    // Returns true if verification can continue
    bool            SetErrorAndContinue(HRESULT hError);
    static WCHAR*   GetErrorMsg(
                        HRESULT hError, 
                        VerError err, 
                        MethodDesc *pMethodDesc, 
                        WCHAR *wszMsg, 
                        int len);

private:
#ifdef _DEBUG
    void            PrintState();
    void            PrintStackState();
    void            PrintLocVarState();
    void            PrintQueue();
    void            PrintInitedFieldState();
    void            PrintExceptionTree();
    void            PrintExceptionTree(
                                VerExceptionBlock   *pe, 
                                int                 indent);
    void            PrintExceptionBlock(
                                VerExceptionBlock   *pOuter, 
                                VerExceptionBlock   *pInner);
    void            CrossCheckVertable();
#endif
};

#endif /* _VERIFIER_HPP */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\veritem.hpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//
// veritem.hpp
//
// Contact : Shajan Dasan [shajand@microsoft.com]
// Specs   : http://Lightning/Specs/Security
//
// Declares the Item class, which represents entities on the stack.
//
#ifndef _H_VERITEM
#define _H_VERITEM

#include "class.h"
#include "COMVariant.h"

// Flags: LLLLLLLLLLLLLLLLffffffffffTTTTTT
//
// L = local var # or instance field #
// x = unused
// f = flags
// T = type
//

// The lower bits are used to store the type component, and may be one of:
// ELEMENT_TYPE_* (primitive)     - see cor.h for enumeration
// VER_ELEMENT_TYPE_VALUE_CLASS
// VER_ELEMENT_TYPE_OBJREF        - used for objrefs of any type (including arrays and null objref)
// VER_ELEMENT_TYPE_UNKNOWN
//
// NOTE carefully that BYREF info is not stored here.  You will never see a VER_ELEMENT_TYPE_BYREF in this
// component.  For example, the type component of a "byref ELEMENT_TYPE_I4" is ELEMENT_TYPE_I4.
#define VER_FLAG_DATA_BITS              6
#define VER_FLAG_DATA_MASK              ((1 << VER_FLAG_DATA_BITS)-1)

// Flag indicating this item is uninitialised
// Note that if UNINIT and BYREF are both set, it means byref (uninit x) - i.e. we are pointing to an uninit <something>
#define VER_FLAG_UNINIT                 0x00000040

// Flag indicating this item is a byref <something>
// Note that if UNINIT and BYREF are both set, it means byref (uninit x) - i.e. we are pointing to an uninit <something>
#define VER_FLAG_BYREF                  0x00000080

// Flag indicating this item is a byref <local#> (VER_FLAG_BYREF must also be set)
// The local# is stored in the upper 2 bytes
#define VER_FLAG_BYREF_LOCAL            0x00000100

// Flag indicating this item is a byref <instance field# of this class>
// This is only important when verifying value class constructors.  In that case, we must verify
// that all instance fields are initialised.  However, if some fields are value class fields
// themselves, then they would be initialised via ldflda, call <ctor>, so we have to track that
// a field on the stack is a particular instance field of this class.
// VER_FLAG_BYREF must also be set 
#define VER_FLAG_BYREF_INSTANCE_FIELD   0x00000200

// This item has an array component (compact type component will be VER_ELEMENT_TYPE_OBJREF)
// However, this item may not BE an array - if VER_FLAG_BYREF is set, this item is a byref arrayref
// Note, I don't think it's possible or legal to actually create such a thing though.
#define VER_FLAG_ARRAY                  0x00000400

// This item is the NULL objref (compact type component will be VER_ELEMENT_TYPE_OBJREF)
// In theory this could be a byref null objref, so check VER_FLAG_BYREF also.
#define VER_FLAG_NULL_OBJREF            0x00000800

// This item contains the 'this' pointer (used for tracking)
#define VER_FLAG_THIS_PTR               0x00001000

// This item is a byref to something which has a permanent home (e.g. a static field, or instance
// field, as opposed to the stack or a local variable).
// VER_FLAG_BYREF must also be set
// @TODO: Use this flag
#define VER_FLAG_BYREF_PERMANENT_HOME   0x00002000

// This item has a method descriptor
// m_pMethod is to be used.
#define VER_FLAG_METHOD                 0x00004000

// Unused flag.
#define VER_FLAG_NOT_USED               0x00008000

// Number of bits local var # is shifted
#define VER_FLAG_LOCAL_VAR_SHIFT       16
#define VER_FLAG_LOCAL_VAR_MASK        0xFFFF0000

// Field info uses the same space as the local info
#define VER_FLAG_FIELD_SHIFT           VER_FLAG_LOCAL_VAR_SHIFT
#define VER_FLAG_FIELD_MASK            VER_FLAG_LOCAL_VAR_MASK

//
// An item can be one of several types:
// - A primitive type (I4,I8,R4,R8,I)
// - A Function Pointer (m_pMethod)
// - An array of <something>
// - A type handle (m_th describes the type)
// - A byref type <something> (byref flag set, otherwise the same as the above), never uninitialised
// - A byref local variable (byref and byref local flags set), can be uninitialised
//
// The reason that there can be 2 types of byrefs (general byrefs, and byref locals) is that byref
// locals initially point to uninitialised items.  Therefore these byrefs must be tracked specially.
//
class Item
{
private:
    // Provides most info about this item
    DWORD           m_dwFlags;

    // @Todo : move m_th & m_pMethod into the union if we can get TypeHandle 
    // without a constructor

    // May be unset - only look at this data if we're a
    // VER_ELEMENT_TYPE_OBJREF. this value will be NULL if VER_FLAG_NULL_OBJREF 
    // is also set.  Otherwise it points to a valid type handle.
    TypeHandle     m_th;


    // Valid only when VER_FLAG_METHOD is set 
    MethodDesc*    m_pMethod;

public:

    Item() : m_dwFlags(0), m_pMethod(0) {}

    /////////////////////////////////////////////////////////////////////////
    // Setters
    /////////////////////////////////////////////////////////////////////////

    // This will set the type without any checks.
    // Do not use this other than for logging purposes.
    void SetRawType(DWORD dwType)
    {
        if (dwType == ELEMENT_TYPE_BYREF)
            m_dwFlags |= VER_FLAG_BYREF;
        else
            m_dwFlags = dwType;

        /* m_th, m_pMethod unset */
    }

    // Set this item to a primitive type
    void SetType(DWORD dwType)
    {
        _ASSERTE(dwType != VER_ELEMENT_TYPE_OBJREF);
        _ASSERTE(dwType != VER_ELEMENT_TYPE_BYREF);
        _ASSERTE(dwType != VER_ELEMENT_TYPE_VALUE_CLASS);

        _ASSERTE(dwType <= VER_FLAG_DATA_MASK);

        m_dwFlags = dwType;

        /* m_th, m_pMethod unset */
    }

    void SetMethodDesc(MethodDesc *pMethod)
    {
        m_pMethod = pMethod;
        m_dwFlags = VER_FLAG_METHOD;

        /* m_th unset */
    }

    // Use this method only for the globaly known classes like g_pObjectClass
    // which are known to be a non array class and non enums and non value class
    void SetKnownClass(MethodTable *pMT)
    {
        _ASSERTE(pMT != NULL);
        _ASSERTE(!pMT->GetClass()->IsArrayClass());
        _ASSERTE(!pMT->IsValueClass());

        m_th      = TypeHandle(pMT);
        m_dwFlags = VER_ELEMENT_TYPE_OBJREF;

        /* m_pMethod unset */
    }

    BOOL SetType(mdTypeDef cl, Module* pModule)
    {
        if (TypeFromToken(cl) != mdtTypeRef &&
            TypeFromToken(cl) != mdtTypeDef &&
            TypeFromToken(cl) != mdtTypeSpec)
        {
            SetDead();
            return FALSE;
        }

        NameHandle name(pModule, cl);
        TypeHandle th = pModule->GetClassLoader()->LoadTypeHandle(&name);

        if (th.IsNull())
        {
            SetDead();
            return FALSE;
        }

        return SetTypeHandle(th);
    }

    BOOL SetTypeHandle(TypeHandle th)
    {
        _ASSERTE(!th.IsNull());

        m_th = th;

        if (th.IsArray())
        {
            m_dwFlags = (VER_FLAG_ARRAY | VER_ELEMENT_TYPE_OBJREF);
        }
        else
        {
            CorElementType et = th.GetNormCorElementType();

            if (et == ELEMENT_TYPE_PTR || et == ELEMENT_TYPE_FNPTR)
            {
                SetDead();
                return FALSE;
            }

            MethodTable *pMT = th.GetMethodTable();

            if (pMT == NULL)
            {
                SetDead();
                return FALSE;
            }

            if (pMT->IsValueClass())
            {
                m_dwFlags = VER_ELEMENT_TYPE_VALUE_CLASS;
    
                // Convert System.Int32 -> I4, System.UInt16 -> I2 ...
                if (!th.IsEnum())
                    NormaliseToPrimitiveType();
            }
            else if (pMT == g_pArrayClass)
            {
                // th.IsArray() returns FALSE for System.Array
                m_dwFlags = (VER_FLAG_ARRAY | VER_ELEMENT_TYPE_OBJREF);
            }
            else
            {
                m_dwFlags = VER_ELEMENT_TYPE_OBJREF;
            }
        }

        return TRUE;
    }

    BOOL SetArray(mdMemberRef mr, Module* pModule, IMDInternalImport *pMDI)
    {
        if ((TypeFromToken(mr) != mdtMemberRef) && (TypeFromToken(mr) != mdtMethodDef))
        {
            SetDead();
            return FALSE;
        }

        mdTypeRef  tk;
        TypeHandle th;
        HRESULT    hr;

        hr = pMDI->GetParentToken(mr, &tk); 

        if (FAILED(hr))
        {
            SetDead();
            return FALSE;   
        }

        NameHandle name(pModule, tk);
        th = pModule->GetClassLoader()->LoadTypeHandle(&name);

        return SetArray(th);
    }

    BOOL SetArray(mdTypeDef cl, Module* pModule)
    {
        if ((TypeFromToken(cl) != mdtTypeRef) && (TypeFromToken(cl) != mdtTypeDef))
        {
            SetDead();
            return FALSE;
        }

        NameHandle name(pModule, cl);
        TypeHandle th = pModule->GetClassLoader()->LoadTypeHandle(&name);

        return SetArray(th);
    }

    BOOL SetArray(TypeHandle thArray)
    {
        if (thArray.IsNull() || !thArray.IsArray())
        {
            SetDead();
            return FALSE;
        }

        m_th      = thArray;
        m_dwFlags = VER_FLAG_ARRAY | VER_ELEMENT_TYPE_OBJREF;

        return TRUE;

        /* other fields unset */
    }


    // Set this item to a null objref
    void SetToNullObjRef()
    {
        m_dwFlags   = VER_FLAG_NULL_OBJREF | VER_ELEMENT_TYPE_OBJREF;

        /* other fields unset */
    }

    // Must be for a local which is an object type (i.e. has a slot >= 0)
    // For primitive locals, use the liveness bitmap instead.
    void SetDead()
    {
        SetType(VER_ELEMENT_TYPE_UNKNOWN);
    }

    void SetIsThisPtr()
    {
        m_dwFlags |= VER_FLAG_THIS_PTR;
    }

    void SetIsPermanentHomeByRef()
    {
        _ASSERTE(IsByRef());
        m_dwFlags |= VER_FLAG_BYREF_PERMANENT_HOME;
    }

    // Set that this item is uninitialised.  
    // Must be an objref or a value class or a byref (if it a byref is uninit, it means the byref is pointing
    // to an uninit something).
    void SetUninitialised()
    {
        //_ASSERTE((IsObjRef() || IsValueClass() || IsByRef()) && !IsArray());
        m_dwFlags |= VER_FLAG_UNINIT;
    }

    // Set that this item is initialised.
    void SetInitialised()
    {
        //_ASSERTE((IsObjRef() || IsValueClass() || IsByRef()) && !IsArray());
        m_dwFlags &= ~VER_FLAG_UNINIT;
    }

    // Only type information will be preserved. All other information will be
    // removed.
    void RemoveAllNonTypeInformation()
    {
        m_dwFlags &= ~( VER_FLAG_THIS_PTR|
                        VER_FLAG_BYREF_PERMANENT_HOME);
    }

    void _SetItem(_VerItem _item)
    {
        m_dwFlags = _item.dwFlags;

        if (ContainsTypeHandle())
            m_th = TypeHandle(_item.pv);
        else if (IsMethod())
            m_pMethod = (MethodDesc*) _item.pv;
        else
            m_th = TypeHandle((void *)0);
    }

    /////////////////////////////////////////////////////////////////////////
    // Getters
    /////////////////////////////////////////////////////////////////////////

    // Returns a _VerItem, which is a void *, DWORD structure
    _VerItem _GetItem()
    {
        _VerItem _item;
        _item.dwFlags = m_dwFlags;
        if (ContainsTypeHandle())
            _item.pv = m_th.AsPtr();
        else if (IsMethod())
            _item.pv = (void *)m_pMethod;
        else
            _item.pv = NULL;

        return _item;
    }

    // Returns whether this is an objref
    // A byref objref is NOT an objref.
    BOOL IsObjRef() const
    {
        return (m_dwFlags & (VER_FLAG_DATA_MASK|VER_FLAG_BYREF)) == VER_ELEMENT_TYPE_OBJREF;
    }

    // Returns whether this is a by-ref
    BOOL IsByRef() const
    {
        return (m_dwFlags & VER_FLAG_BYREF);
    }

    // Returns whether this is the this pointer
    BOOL IsThisPtr() const
    {
        return (m_dwFlags & VER_FLAG_THIS_PTR);
    }

    BOOL IsPermanentHomeByRef() const
    {
        return (m_dwFlags & VER_FLAG_BYREF_PERMANENT_HOME);
    }

    // Returns whether this is an array of some kind.
    // A byref array is NOT an array.
    BOOL IsArray() const
    {
        return (m_dwFlags & (VER_FLAG_ARRAY|VER_FLAG_BYREF)) == VER_FLAG_ARRAY;
    }

    // Returns whether this is a method desc
    BOOL IsMethod() const
    {
        return (m_dwFlags & VER_FLAG_METHOD);
    }

    BOOL IsSingleDimensionalArrayOfPointerTypes()
    {
        if (!IsArray())
            return FALSE;

		if (m_th == TypeHandle(g_pArrayClass))
			return FALSE;

        ArrayTypeDesc* ptd = m_th.AsArray();
        TypeHandle el = ptd->GetElementTypeHandle();

        return (IsPointerType(el.GetSigCorElementType()) && (ptd->GetRank() == 1));
    }

    BOOL IsValueClassWithPointerToStack() const
    {
        if (IsValueClass())
        {
            TypeHandle th = GetTypeHandle();
            return (th.GetClass()->ContainsStackPtr());
        }

        return FALSE;
    }

    static BOOL IsPointerType(CorElementType t)
    {
        return (CorTypeInfo::IsObjRef(t));
    }

    BOOL IsSingleDimensionalArray()
    {
        if (!IsArray())
            return FALSE;
		
		if (m_th == TypeHandle(g_pArrayClass))
			return FALSE;

        return (m_th.AsArray()->GetRank() == 1);
    }

    BOOL HasPointerToStack() const
    {
#ifdef _VER_ALLOW_PERMANENT_HOME_BYREF
        return ((IsByRef() && !IsPermanentHomeByRef()) ||
                IsValueClassWithPointerToStack());
#else
        return (IsByRef() || IsValueClassWithPointerToStack());
#endif
    }

    void Box()
    {
        _ASSERTE((m_dwFlags & ~VER_FLAG_DATA_MASK) == 0);
    
        // Check for primitive types (I4, R etc..)
        if (m_dwFlags != VER_ELEMENT_TYPE_VALUE_CLASS)
        {
            _ASSERTE((m_dwFlags >= ELEMENT_TYPE_BOOLEAN && m_dwFlags <= ELEMENT_TYPE_R8) || (m_dwFlags == ELEMENT_TYPE_I));
            // Box primitive types
            m_th = ElementTypeToTypeHandle((const CorElementType)m_dwFlags);
        }
    
        m_dwFlags = VER_ELEMENT_TYPE_OBJREF;
    }

//
// Given that this item is an array such as Foo[], Foo[][], Foo[,,,,](,,,) etc., dereference off
// the specified first set of brackets; i.e. Foo, Foo[], Foo(,,,) for the above examples.
//
// This may become a non-array class; e.g. Int32[] --> Int32
// Also, Integer1[] --> Integer1.  We do not normalise to a stack slot size in this function.

    BOOL DereferenceArray();
    void NormaliseToPrimitiveType();

    // Returns whether this item is a given primitive type
    BOOL IsGivenPrimitiveType(DWORD Type) const
    {
        _ASSERTE(Type != VER_ELEMENT_TYPE_OBJREF && Type != VER_ELEMENT_TYPE_BYREF && Type != VER_ELEMENT_TYPE_VALUE_CLASS);
        return (m_dwFlags & (VER_FLAG_DATA_MASK|VER_FLAG_BYREF)) == Type;
    }

    // Returns whether this item is a byref <Type>
    // If Type is VER_ELEMENT_TYPE_OBJREF, returns whether we are a byref to some objref/array/value class type
    BOOL IsByRefOfType(DWORD Type) const
    {
        return (m_dwFlags & (VER_FLAG_DATA_MASK|VER_FLAG_BYREF)) == (Type | VER_FLAG_BYREF);
    }

    BOOL IsByRefValueClass() const
    {
        return (m_dwFlags & (VER_FLAG_BYREF|VER_FLAG_DATA_MASK)) == (VER_FLAG_BYREF|VER_ELEMENT_TYPE_VALUE_CLASS);
    }

    BOOL IsByRefObjRef() const
    {
        return (m_dwFlags & (VER_FLAG_BYREF|VER_FLAG_DATA_MASK)) == (VER_FLAG_BYREF|VER_ELEMENT_TYPE_OBJREF);
    }

    void DereferenceByRefObjRef()
    {
        // Might as well kill off the byref local and field info too, it serves no useful purpose now
        m_dwFlags &= ~(VER_FLAG_BYREF|VER_FLAG_BYREF_LOCAL|VER_FLAG_BYREF_INSTANCE_FIELD);
    }

    // A byref value class is NOT a value class
    // Value class or primitive types
    BOOL IsValueClass() const
    {
        return (m_dwFlags & (VER_FLAG_DATA_MASK|VER_FLAG_BYREF)) == VER_ELEMENT_TYPE_VALUE_CLASS;
    }

    BOOL IsValueClassOrPrimitive() const
    {
        return (IsValueClass() || IsPrimitiveType());
    }

    // Byref Value class or byref primitive types
    BOOL IsByRefValueClassOrByRefPrimitiveValueClass() const
    {
        return (IsByRefValueClass() || IsByRefPrimitiveType());
    }

    // Returns whether this is an integer or real number
    // NOTE: Use NormaliseToPrimitiveType() if you think you may have a System.Int32 etc.,
    //       because those types are not considered number types by this function.
    BOOL IsOnStackNumberType() const
    {
        // I1, I2, Boolean, character etc. cannot exist nakedly - everything is at least an I4
        return IsNormalisedPrimitiveType(GetType());
    }

    BOOL IsOnStackInt()
    {
        DWORD Type = GetType();

        return ((Type == ELEMENT_TYPE_I4) || (Type == ELEMENT_TYPE_I8));

    }

    BOOL IsOnStackReal()
    {
        return (GetType() == ELEMENT_TYPE_R8);
    }

    // Get this item's type
    // If primitive, returns the primitive type (ELEMENT_TYPE_*)
    // If not primitive, returns:
    //  - ELEMENT_TYPE_BYREF if a byref anything
    //  - VER_ELEMENT_TYPE_OBJREF if a class or array or null
    //  - VER_ELEMENT_TYPE_VALUE_CLASS if a value class
    DWORD GetType() const
    {
        if (m_dwFlags & VER_FLAG_BYREF)
            return ELEMENT_TYPE_BYREF;
        else
            return (m_dwFlags & VER_FLAG_DATA_MASK); // objref/array/null (objref), value class, ptr, primitive
    }

    DWORD GetTypeOfByRef() const
    {
        _ASSERTE(IsByRef());
        return m_dwFlags & VER_FLAG_DATA_MASK;
    }

    TypeHandle GetTypeHandle()  const
    {
        _ASSERTE(ContainsTypeHandle());
        return m_th;
    }


    MethodDesc* GetMethod()  const
    {
        _ASSERTE(IsMethod());
        return m_pMethod;
    }

    // Returns whether this item is the base Object
    BOOL IsBaseObject()  const
    {
        return IsObjRef() && ContainsTypeHandle() && 
            (m_th == TypeHandle(g_pObjectClass));
    }

    // Returns whether this item is an interface
    BOOL IsInterface()
    {
        return IsObjRef() && ContainsTypeHandle() && 
            m_th.GetMethodTable()->IsInterface();
    }

    // Returns whether this item is compatible with the template given by pParent
    DWORD CompatibleWith(Item *pParent, ClassLoader *pLoader);
    DWORD CompatibleWith(Item *pParent, ClassLoader *pLoader, BOOL fSubclassRelationshipOK);

#ifdef _DEBUG
    DWORD DBGCompatibleWith(Item *pParent, ClassLoader *pLoader, BOOL fSubclassRelationshipOK);
#endif

    // Returns whether this is a primitive type (not a byref, objref, array, null, value class, invalid value)
    // May Need to normalise first (m/r/I4 --> I4)
    BOOL IsPrimitiveType() const
    {
        return IsPrimitiveType(GetType());
    }

    // May Need to normalise first (m/r/I4 --> I4)
    BOOL IsNormalisedByRefPrimitiveType() const
    {
        if (IsByRef() == FALSE)
            return FALSE;

        return  IsNormalisedPrimitiveType(m_dwFlags & VER_FLAG_DATA_MASK);
    }
    
    BOOL IsByRefPrimitiveType() const
    {
        if (IsByRef() == FALSE)
            return FALSE;
        
        // boolean, char, u1,u2 never appear on the operand stack
        return  IsPrimitiveType(m_dwFlags & VER_FLAG_DATA_MASK);
    }

    static BOOL IsPrimitiveType(DWORD Type)
    {
        // boolean, char, u1,u2 never appear on the operand stack
        return (Type == ELEMENT_TYPE_I1) || (Type == ELEMENT_TYPE_I2) ||
               (Type == ELEMENT_TYPE_I4) || (Type == ELEMENT_TYPE_I8) ||
               (Type == ELEMENT_TYPE_R4) || (Type == ELEMENT_TYPE_R8) || 
               (Type == ELEMENT_TYPE_I);

    }

    static BOOL IsNormalisedPrimitiveType(DWORD Type)
    {
        return ((Type == ELEMENT_TYPE_I4) || 
                (Type == ELEMENT_TYPE_I8) || 
                (Type == ELEMENT_TYPE_R8));
    }

    // Returns whether this is the null objref
    BOOL IsNullObjRef() const
    {
        return (m_dwFlags & VER_FLAG_NULL_OBJREF);
    }

    // Returns whether m_th is valid - i.e. this item has some type of class component.
    // Array classes, object references which are not null, value classes, and byref <X>
    // where X is one of the previous items, all have an EEClass component.
    BOOL ContainsTypeHandle() const
    {
        if ((m_dwFlags & VER_FLAG_ARRAY) && !m_th.IsNull())
            return TRUE; // arrays always have a TypeHandle

        // It's an objref or value class, and not the null objref (which has no EEClass)
        DWORD dwTemp = (m_dwFlags & (VER_FLAG_DATA_MASK | VER_FLAG_NULL_OBJREF));
        
        return dwTemp == VER_ELEMENT_TYPE_OBJREF || dwTemp == VER_ELEMENT_TYPE_VALUE_CLASS;

    }

    // must be for a local which is an object type (i.e. has a slot >= 0)
    // for primitive locals, use the liveness bitmap instead
    BOOL IsDead() const
    {
        return IsGivenPrimitiveType(VER_ELEMENT_TYPE_UNKNOWN);
    }

    // It is ok to call this routine on primitive types or arrays (which are never uninitialised)
    BOOL IsUninitialised() const
    {
        return m_dwFlags & VER_FLAG_UNINIT;
    }

#ifdef _DEBUG
    BOOL DBGMergeToCommonParent(Item *pSrc);
#endif

    BOOL MergeToCommonParent(Item *pSrc);

    static BOOL EquivalentMethodSig(MethodDesc *pMethDescA, MethodDesc *pMethDescB)
    {
        _ASSERTE(pMethDescA != NULL && pMethDescB != NULL);

        if (pMethDescA == pMethDescB)
            return TRUE;

        Module *pModA, *pModB; 
        PCCOR_SIGNATURE pSigA, pSigB; 
        DWORD dwSigA, dwSigB;

        pMethDescA->GetSig(&pSigA, &dwSigA);
        pMethDescB->GetSig(&pSigB, &dwSigB);

        pModA = pMethDescA->GetModule();
        pModB = pMethDescB->GetModule();

        MetaSig SigA(pSigA, pModA);
        MetaSig SigB(pSigB, pModB);

        // check everyting CompareMethodSigs() does not check
        if (SigA.GetCallingConventionInfo() != SigB.GetCallingConventionInfo())
            return FALSE;

        if (SigA.NumFixedArgs() != SigB.NumFixedArgs())
            return FALSE;

        MethodTable *pMTA, *pMTB;

        pMTA = pMethDescA->GetMethodTable();
        pMTB = pMethDescB->GetMethodTable();

        // @Todo : Is SubClass OK ?
        if (pMTA != pMTB)
        {
            return FALSE;
        }

        return MetaSig::CompareMethodSigs(pSigA, dwSigA, pModA, pSigB, dwSigB, pModB);
    }

    // We have a byref X, so dereference it to X and promote it to the stack, turning I1/I2/U4's into I4's etc.
    // e.g. byref I1 -> I4
    void DereferenceByRefAndNormalise()
    {
        //_ASSERTE(IsByRef());

        m_dwFlags &= (~(VER_FLAG_BYREF|VER_FLAG_BYREF_LOCAL));

        NormaliseForStack();
    }

    void MakeByRef()
    {
        //_ASSERTE(!IsByRef());
        m_dwFlags |= VER_FLAG_BYREF;
    }

    // Mark that this item is a byref, and a byref of a particular local variable
    void MakeByRefLocal(DWORD dwLocVarNumber)
    {
        //_ASSERTE(!IsByRef());
        m_dwFlags |= ((VER_FLAG_BYREF | VER_FLAG_BYREF_LOCAL) | (dwLocVarNumber << VER_FLAG_LOCAL_VAR_SHIFT));
    }

    void MakeByRefInstanceField(DWORD dwFieldNumber)
    {
        _ASSERTE(!HasByRefLocalInfo());
        m_dwFlags |= ((VER_FLAG_BYREF | VER_FLAG_BYREF_INSTANCE_FIELD) | (dwFieldNumber << VER_FLAG_FIELD_SHIFT));
    }

    DWORD HasByRefLocalInfo() const
    {
        return (m_dwFlags & VER_FLAG_BYREF_LOCAL);
    }

    DWORD GetByRefLocalInfo() const
    {
        _ASSERTE(HasByRefLocalInfo());
        return m_dwFlags >> VER_FLAG_LOCAL_VAR_SHIFT;
    }

    DWORD HasByRefFieldInfo() const
    {
        return (m_dwFlags & VER_FLAG_BYREF_INSTANCE_FIELD);
    }

    DWORD GetByRefFieldInfo() const
    {
        _ASSERTE(HasByRefFieldInfo());
        return m_dwFlags >> VER_FLAG_FIELD_SHIFT;
    }

    //
    // I1,I2,U1,U2,CHAR,BOOL etc. --> I4
    // U4 -> I4
    // U8 -> I8
    // objref, arrays, byrefs, value classes are unchanged
    //
    void NormaliseForStack()
    {
        BOOL fUninit;

        fUninit = IsUninitialised();

        switch (GetType())
        {
        // On the stack, treating I as I4 works on 64 & 32 bit machines.
        //      On 32 bit machines, I4 is I
        // I4 can be used anywhere an I is expected.
        //      On 64 bit machines, all Ix are impleneted as I8, hence I4 is I
        // I can be used where I4 is expected
        //      On 64 bit machines, I and I4 are implemented as I8
            case ELEMENT_TYPE_U:
            case ELEMENT_TYPE_I:

            case ELEMENT_TYPE_I1:
            case ELEMENT_TYPE_U1:
            case ELEMENT_TYPE_I2:
            case ELEMENT_TYPE_U2:
            case ELEMENT_TYPE_CHAR:
            case ELEMENT_TYPE_BOOLEAN:
            case ELEMENT_TYPE_U4:
            {
                SetType(ELEMENT_TYPE_I4);
                break;
            }

            case ELEMENT_TYPE_U8:
            {
                SetType(ELEMENT_TYPE_I8);
                break;
            }

            case ELEMENT_TYPE_R4:
            {
                SetType(ELEMENT_TYPE_R8);
                break;
            }
        }

        if (fUninit)
            SetUninitialised();
    }

    static BOOL PrimitiveValueClassToTypeConversion(Item *pSource, Item *pDest);

    // This function is used for the purposes of generating a human-readable string which will
    // become part of an exception thrown
    void ToString(char *str, DWORD cString)
    {
        char *      p = "";
        DWORD       Type;

        // Need some minimum amount of space
        _ASSERTE(cString >= 32);

        *str = '\0';

        if (IsMethod())
        {
            EEClass* pClass = m_pMethod->GetClass();

            if (pClass != NULL)
            {
                DefineFullyQualifiedNameForClass();
                GetFullyQualifiedNameForClass(pClass);
                strncpy(str, _szclsname_, cString - 3);

                str[cString - 3] = 0;   // strncpy() will not null terminate if 
                                        // strlen(_szclsname_) >= (cString - 3).
                strcat(str, "::");
            }
            else
            {
                strcpy(str, "<Global>::");
            }

            strncat(str, m_pMethod->GetName(), cString - strlen(str));
            return;
        }

        Type = GetType();

        if (m_dwFlags & VER_FLAG_BYREF)
            strcat(str, "address of ");

        if (IsUninitialised())
            strcat(str, "<uninitialized> ");

        switch (m_dwFlags & VER_FLAG_DATA_MASK)
        {
            default:
                _ASSERTE(!"Internal error");
                strcpy(str, "<error>");
                return;

            case VER_ELEMENT_TYPE_SENTINEL:
                p = "<Stack empty>";
                break;

            case VER_ELEMENT_TYPE_OBJREF:
                if (!m_th.IsNull() && m_th.GetClass()->IsValueClass())
                    p = "[box]";
                break;

            case VER_ELEMENT_TYPE_VALUE_CLASS:
                p = "";
                break;

            case VER_ELEMENT_TYPE_UNKNOWN:
                p = "UNKNOWN";
                break;

            case ELEMENT_TYPE_BYREF:
                p = "<ByRef>";
                break;

            case ELEMENT_TYPE_VOID:
                p = "void";
                break;

            case ELEMENT_TYPE_I4:
                p = "Int32";
                break;

            case ELEMENT_TYPE_I8:
                p = "Int64";
                break;

            case ELEMENT_TYPE_R4:
                p = "Single";
                break;

            case ELEMENT_TYPE_R8:
                p = "Double";
                break;

            case ELEMENT_TYPE_BOOLEAN:
                p = "Boolean";
                break;

            case ELEMENT_TYPE_CHAR:
                p = "Char";
                break;

            case ELEMENT_TYPE_I:
                p = "Int";
                break;

            case ELEMENT_TYPE_U:
                p = "UInt";
                break;

            // valid only for array types
            case ELEMENT_TYPE_I1:
                p = "SByte";
                break;

            // valid only for array types
            case ELEMENT_TYPE_I2:
                p = "Int16";
                break;
        }

        strcat(str, p);

        if (ContainsTypeHandle())
        {
            DefineFullyQualifiedNameForClass();


            if (IsArray())
            {
                strcat(str, "array class ");
				
				if (m_th == TypeHandle(g_pArrayClass))
					goto printClass;
				
				TypeDesc *td = m_th.AsTypeDesc();
				
				if (td != NULL)
					td->GetName(_szclsname_, MAX_CLASSNAME_LENGTH);
					

                if (strlen(str) + strlen(_szclsname_) >= cString)
                {
                    strcpy(str, "<string to long>");
                    return;
                }

                strcat(str, _szclsname_);
            }
            else
            {
                if (m_th.IsNull())
                {
                    strcat(str, "?");
                }
                else if (m_th.IsTypeDesc()) 
                {
                    TypeDesc *td = m_th.AsTypeDesc();

                    if (td == NULL)
                        strcat(str, "?");
                    else
                    {
                        if (IsThisPtr())
                            strcat(str, "('this' ptr) ");

                        td->GetName(_szclsname_, MAX_CLASSNAME_LENGTH);
                    }
                }
                else
                {
printClass:
                    EEClass *pClass = m_th.GetClass();

                    if (pClass == NULL)
                        strcat(str, "?");
                    else
                    {
                        if (pClass->IsValueClass())
                            strcat(str, "value class ");
                        else
                            strcat(str, "objref ");

                        if (IsThisPtr())
                            strcat(str, "('this' ptr) ");

                        GetFullyQualifiedNameForClass(pClass);
                    }
                }

                if (strlen(_szclsname_) + 40 >= cString)
                {
                    strcpy(str, "<string to long>");
                    return;
                }

                strcat(str, "'");
                strcat(str, _szclsname_);
                strcat(str, "'");
            }
        }
        else if (m_dwFlags & VER_FLAG_NULL_OBJREF)
        {
            strcat(str, "objref 'NullReference'");
        }
    }

#ifdef _DEBUG
    //
    // DEBUGGING
    //
    char *ToStaticString()
    {
        static char str[MAX_CLASSNAME_LENGTH];
        char *      p = "";
        DWORD       Type;

        strcpy(str, "");

        if (IsMethod())
        {
            EEClass* pClass = m_pMethod->GetClass();

            if (pClass != NULL)
            {
                DefineFullyQualifiedNameForClass();
                GetFullyQualifiedNameForClass(pClass);
                strncpy(str, _szclsname_, MAX_CLASSNAME_LENGTH - 3);
                strcat(str, "::");
            }
            else
            {
                strcpy(str, "<Global>::");
            }

            strncat(str, m_pMethod->GetName(), 
                MAX_CLASSNAME_LENGTH - strlen(str));
            return str;
        }

        Type = GetType();

        if (m_dwFlags & VER_FLAG_BYREF)
            strcat(str, "&");

        switch (m_dwFlags & VER_FLAG_DATA_MASK)
        {
            default:
                p = "<<internal error>>";
                _ASSERTE(0);
                break;

            case VER_ELEMENT_TYPE_SENTINEL:
                p = "<Stack empty>";
                break;

            case VER_ELEMENT_TYPE_OBJREF:
                if (!m_th.IsNull() && m_th.GetClass()->IsValueClass())
                    p = "[box]";
                break;

            case VER_ELEMENT_TYPE_VALUE_CLASS:
                p = "";
                break;

            case VER_ELEMENT_TYPE_UNKNOWN:
                p = "UNKNOWN";
                break;

            case ELEMENT_TYPE_BYREF:
                p = "<ByRef>";
                break;

            case ELEMENT_TYPE_VOID:
                p = "VOID";
                break;

            case ELEMENT_TYPE_BOOLEAN:
                p = "Boolean";
                break;

            case ELEMENT_TYPE_CHAR:
                p = "Char";
                break;

            case ELEMENT_TYPE_I4:
                p = "I4";
                break;

            case ELEMENT_TYPE_I8:
                p = "I8";
                break;

            case ELEMENT_TYPE_R4:
                p = "F4";
                break;

            case ELEMENT_TYPE_R8:
                p = "F8";
                break;

            // valid only for array types
            case ELEMENT_TYPE_I1:
                p = "I1";
                break;
            
            case ELEMENT_TYPE_I:
                p = "I";
                break;

            case ELEMENT_TYPE_U:
                p = "U";
                break;

            // valid only for array types
            case ELEMENT_TYPE_I2:
                p = "I2";
                break;
        }

        strcat(str, p);

        if (ContainsTypeHandle())
        {
            if (m_th.IsNull())
            {
                strcat(str, "?");
            }
            else if (m_th.IsTypeDesc())
            {
                TypeDesc *td = m_th.AsTypeDesc();
                
                if (td != NULL)
                    td->GetName((str + strlen(str)), (unsigned)(MAX_CLASSNAME_LENGTH - strlen(str)));
                else
                    strcat(str, "?");
            }
            else
            {
                EEClass *pClass = m_th.GetClass();
                if (pClass != NULL)
                    strcat(str, pClass->m_szDebugClassName);
                else
                    strcat(str, "?");
            }
        }
        else if (m_dwFlags & VER_FLAG_NULL_OBJREF)
        {
            strcat(str, "nullref");
        }

        if (IsUninitialised())
            strcat(str, " <uninit>");

        if (IsPermanentHomeByRef())
            strcat(str, " <permanent home>");

        if (IsThisPtr())
            strcat(str, " <this>");

        if (HasByRefLocalInfo())
        {
            sprintf(&str[ strlen(str) ], "(local %d)", GetByRefLocalInfo());
        }

        if (HasByRefFieldInfo())
        {
            sprintf(&str[ strlen(str) ], "(field %d)", GetByRefFieldInfo());
        }

        return str;
    }

    void Dump();
#endif
};

#endif /* _H_VERITEM */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\versig.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//
// versig.cpp
//
// For parsing metadata signatures
//
#include "common.h"

#include "verifier.hpp"
#include "ceeload.h"
#include "clsload.hpp"
#include "method.hpp"
#include "vars.hpp"
#include "object.h"
#include "field.h"
#include "versig.h"

#define g_szBadSig "bad signature"

// Read NumArgs, calling convention
BOOL VerSig::Init()
{
    if (m_pCurPos + 1 > m_pEndSig)
        goto Error;

    if ((m_dwSigType & VERSIG_TYPE_MASK) == VERSIG_TYPE_FIELD_SIG)
    {
        if (!isCallConv(CorSigUncompressCallingConv(m_pCurPos), IMAGE_CEE_CS_CALLCONV_FIELD))
            goto Error;
    }
    else if ((m_dwSigType & VERSIG_TYPE_MASK) == VERSIG_TYPE_LOCAL_SIG)
    {
        if (*m_pCurPos != IMAGE_CEE_CS_CALLCONV_LOCAL_SIG)
            goto Error;

        m_pCurPos++;

        if (!GetData(&m_dwNumArgs))
            goto Error;
    }
    else
    {
        m_bCallingConvention = (BYTE) CorSigUncompressCallingConv(m_pCurPos);

        if (isCallConv(m_bCallingConvention, IMAGE_CEE_CS_CALLCONV_DEFAULT) ||
            isCallConv(m_bCallingConvention, IMAGE_CEE_CS_CALLCONV_VARARG))
        {
            if (!GetData(&m_dwNumArgs))
                goto Error;
        }
        else
        {
            m_pVerifier->m_sError.dwFlags = m_dwErrorFlags;
            m_pVerifier->m_sError.bCallConv = m_bCallingConvention;
            m_pVerifier->m_sError.dwArgNumber = VER_ERR_NO_ARG;
            m_pVerifier->m_sError.dwOffset  = m_dwOffset;
            return (m_pVerifier->SetErrorAndContinue(VER_E_SIG_CALLCONV));
        }
    }

    return TRUE;

Error:

    m_pVerifier->m_sError.dwFlags = (VER_ERR_FATAL|m_dwErrorFlags);
    m_pVerifier->m_sError.dwArgNumber = VER_ERR_NO_ARG;
    m_pVerifier->m_sError.dwOffset = m_dwOffset;
    m_pVerifier->SetErrorAndContinue(VER_E_SIG);

    return FALSE;
}


//
// Resolve the next signature component to an Item.
//
// The Item returned is set up for stack use - that is, bytes, booleans, chars and shorts are
// promoted to I4.
//
// i1/u1/i2/u2/i4/u4/bool/char -> TYPE_I4
// void   -> TYPE_VOID
// [i1    -> TYPE_I4, dimension 1
// [bool  -> TYPE_I1, dimension 1
// [byte  -> TYPE_I1, dimension 1
// [short -> TYPE_I2, dimension 1
// [char  -> TYPE_I2, dimension 1
//
// If fAllowVoid is FALSE, then an error is returned if a "V" (void) item is encountered.
//
BOOL VerSig::ParseNextComponentToItem(Item *pItem, BOOL fAllowVoid, BOOL fAllowVarArg, OBJECTHANDLE *hThrowable, DWORD dwArgNum, BOOL fNormaliseForStack)
{
    OBJECTREF throwable = NULL;
    BOOL fSuccess = FALSE;
    GCPROTECT_BEGIN(throwable);

    fSuccess = ParseHelper(pItem, fAllowVoid, fAllowVarArg, FALSE, FALSE, &throwable, dwArgNum);

    if (throwable != NULL)
    {
        _ASSERTE(!fSuccess);
        StoreObjectInHandle(*hThrowable, throwable);
    }
    GCPROTECT_END();
    
    if (fSuccess && fNormaliseForStack)
        pItem->NormaliseForStack();
    
    return fSuccess;
}


BOOL VerSig::SkipNextItem()
{
    Item TempItem;

    return ParseHelper(&TempItem, TRUE, TRUE, FALSE, TRUE, NULL, 0);
}



//
// Parses the next item in the signature to pItem.  
//
// I1/U1      -> I1
// I4/U4      -> I4
// I8/U8      -> I8
// bool/I1/U1 -> I1
// char/I2/U2 -> I2
//
// If fAllowVoid is set and a void type is seen, returns FALSE.
//
// If fFollowsByRef it means that somewhere previously in this signature, we've seen a byref.  Therefore,
// we don't allow another byref.
//
// If fSkip is true, don't fill out pItem - just advance
//
BOOL VerSig::ParseHelper(Item *pItem, BOOL fAllowVoid, BOOL fAllowVarArg, BOOL fFollowsByRef, BOOL fSkip, OBJECTREF *pThrowable, DWORD dwArgNum)
{
    while (m_pCurPos < m_pEndSig)
    {
        BYTE bType = *m_pCurPos++;

        switch (bType)
        {
            case ELEMENT_TYPE_R:
            default:
            {
                LOG((LF_VERIFIER, LL_INFO10, "Verifier: Unknown elementtype in signature (0x%x)\n", (DWORD)bType));
                m_pVerifier->m_sError.dwFlags = m_dwErrorFlags;
                m_pVerifier->m_sError.elem = (CorElementType) bType;
                m_pVerifier->m_sError.dwArgNumber = dwArgNum;
                m_pVerifier->m_sError.dwOffset = m_dwOffset;
                if (m_pVerifier->SetErrorAndContinue(VER_E_SIG_ELEMTYPE))
                {
                    pItem->SetDead();
                    break;   // verifier will exit, validator to continue.
                }
                return FALSE;
            }

            case ELEMENT_TYPE_PTR:
            {
                m_pVerifier->m_sError.dwFlags = m_dwErrorFlags;
                m_pVerifier->m_sError.dwArgNumber = dwArgNum;
                m_pVerifier->m_sError.dwOffset = m_dwOffset;
                if (m_pVerifier->SetErrorAndContinue(VER_E_SIG_ELEM_PTR) == false)
                    return FALSE;   // The verifier will exit. 

                // Recursively parse the next piece of the signature
                // PTRS will be treated as BYREF in the validator mode
                if (!ParseHelper(pItem, fAllowVoid, fAllowVarArg, fFollowsByRef, fSkip, pThrowable, dwArgNum))
                    return FALSE;

				if (!pItem->IsByRef())
					pItem->MakeByRef();

                return TRUE;
            }

            case ELEMENT_TYPE_CMOD_REQD:
            case ELEMENT_TYPE_CMOD_OPT:
                DWORD      dw;
                mdToken    tk;

                dw = CorSigUncompressToken(m_pCurPos, &tk);

                if (m_pCurPos + dw > m_pEndSig)
                    goto Error;

                m_pCurPos += dw;
                // Don't break here

            case ELEMENT_TYPE_PINNED:
                break;


            case ELEMENT_TYPE_SENTINEL:
            {
                if (fAllowVarArg)
                {
                    fAllowVarArg = FALSE;
                    break;
                }

                m_pVerifier->m_sError.dwFlags = m_dwErrorFlags;
                m_pVerifier->m_sError.dwArgNumber = dwArgNum;
                m_pVerifier->m_sError.dwOffset = m_dwOffset;
                if (m_pVerifier->SetErrorAndContinue(VER_E_SIG_VARARG))
                    break;
                return FALSE;
            }

            case ELEMENT_TYPE_BYREF:
            {
                // Can't have a byref ... byref
                if (fFollowsByRef)
                {
                    m_pVerifier->m_sError.dwFlags = m_dwErrorFlags;
                    m_pVerifier->m_sError.dwArgNumber = dwArgNum;
                    m_pVerifier->m_sError.dwOffset = m_dwOffset;
                    if (m_pVerifier->SetErrorAndContinue(VER_E_SIG_BYREF_BYREF) == false)
                        return FALSE;
                }

                // Recursively parse the next piece of the signature
                // Can't have a byref void
                if (!ParseHelper(pItem, FALSE, fAllowVarArg, TRUE, fSkip, pThrowable, dwArgNum))
                    return FALSE;

                if (pItem->IsValueClassWithPointerToStack())
                {
                    m_pVerifier->m_sError.dwFlags = m_dwErrorFlags;
                    m_pVerifier->m_sError.dwArgNumber = dwArgNum;
                    m_pVerifier->m_sError.dwOffset = m_dwOffset;
                    if (m_pVerifier->SetErrorAndContinue(VER_E_SIG_BYREF_TB_AH) == false)
                        return FALSE;
                }

                if (!pItem->IsByRef())
                    pItem->MakeByRef();

                return TRUE;
            }

            case ELEMENT_TYPE_TYPEDBYREF:
            {
                Verifier::InitStaticTypeHandles();

                pItem->SetTypeHandle(Verifier::s_th_System_TypedReference);

                return TRUE;
            }

            case ELEMENT_TYPE_VOID:
            {
                if (!fAllowVoid)
                {
                    m_pVerifier->m_sError.dwFlags = m_dwErrorFlags;
                    m_pVerifier->m_sError.dwArgNumber = dwArgNum;
                    m_pVerifier->m_sError.dwOffset = m_dwOffset;
                    if (m_pVerifier->SetErrorAndContinue(VER_E_SIG_VOID) == false)
                        return FALSE;
                }

                pItem->SetType(ELEMENT_TYPE_VOID);
                return TRUE;
            }

            case ELEMENT_TYPE_I4:
            case ELEMENT_TYPE_U4:
            {
                // The verifier does not differentiate between I4/U4
                pItem->SetType(ELEMENT_TYPE_I4); 
                return TRUE;
            }

            case ELEMENT_TYPE_I8:
            case ELEMENT_TYPE_U8:
            {
                pItem->SetType(ELEMENT_TYPE_I8);
                return TRUE;
            }

            case ELEMENT_TYPE_I:
            case ELEMENT_TYPE_U:
            {
                pItem->SetType(ELEMENT_TYPE_I);
                return TRUE;
            }

            case ELEMENT_TYPE_R4:
            case ELEMENT_TYPE_R8:
            {
                pItem->SetType(bType);
                return TRUE;
            }             

            // The verifier does not differentiate between I2/U2/Char
            case ELEMENT_TYPE_I2:
            case ELEMENT_TYPE_U2:
            case ELEMENT_TYPE_CHAR:
            {
                pItem->SetType(ELEMENT_TYPE_I2);
                return TRUE;
            }

            // The verifier does not differentiate between I1/U1/Boolean
            case ELEMENT_TYPE_I1:
            case ELEMENT_TYPE_U1:
            case ELEMENT_TYPE_BOOLEAN:
            {
                pItem->SetType(ELEMENT_TYPE_I1);
                return TRUE;
            }

            case ELEMENT_TYPE_STRING:
            {
                pItem->SetKnownClass(g_pStringClass);
                return TRUE;
            }

            case ELEMENT_TYPE_OBJECT:
            {
                pItem->SetKnownClass(g_pObjectClass);
                return TRUE;
            }

            case ELEMENT_TYPE_CLASS:
            case ELEMENT_TYPE_VALUETYPE:
            {
                mdToken    tk;
                TypeHandle th;
                DWORD      dw;

                dw = CorSigUncompressToken(m_pCurPos, &tk);

                if (m_pCurPos + dw > m_pEndSig)
                    goto Error;

                m_pCurPos += dw;

                if (tk == 0)
                {
                    if (fSkip)
                        return TRUE;
                    else
                        goto Error;
                }

                if (!fSkip)
                {
                    ClassLoader* pLoader = m_pModule->GetClassLoader();
                    _ASSERTE(pLoader);
                    NameHandle name(m_pModule, tk);
                    th = pLoader->LoadTypeHandle(&name, pThrowable);

                    if (th.IsNull())
                    {
                        m_pVerifier->m_sError.dwFlags = 
                            (m_dwErrorFlags|VER_ERR_FATAL|VER_ERR_TOKEN);
                        m_pVerifier->m_sError.token = tk;
                        m_pVerifier->m_sError.dwArgNumber = dwArgNum;
                        m_pVerifier->m_sError.dwOffset = m_dwOffset;
                        m_pVerifier->SetErrorAndContinue(VER_E_TOKEN_RESOLVE);
                        return FALSE;
                    }

                    if (bType == ELEMENT_TYPE_VALUETYPE)
                    {
                        // If this is an enum type, treat it it's basic type.
                        long lType = Verifier::TryConvertPrimitiveValueClassToType(th);
                        if (lType != 0)
                        {
                            pItem->SetType(lType);
                            return TRUE;
                        }
                    }

                    pItem->SetTypeHandle(th);

                    // Illegal to delcare E_T_CLASS <valueClassToken>
                    // and E_T_VALUECLASS <gcType>

                    if (pItem->IsValueClass())
                    {
                        if (bType == ELEMENT_TYPE_CLASS)
                        {
                            m_pVerifier->m_sError.dwFlags = m_dwErrorFlags;
                            m_pVerifier->m_sError.dwArgNumber = dwArgNum;
                            m_pVerifier->m_sError.dwOffset = m_dwOffset;
                            if (m_pVerifier->SetErrorAndContinue(VER_E_SIG_C_VC) == false)
                                return FALSE;
                        }
                    }
                    else
                    {
                        if (bType == ELEMENT_TYPE_VALUETYPE)
                        {
                            m_pVerifier->m_sError.dwFlags = m_dwErrorFlags;
                            m_pVerifier->m_sError.dwArgNumber = dwArgNum;
                            m_pVerifier->m_sError.dwOffset = m_dwOffset;
                            if (m_pVerifier->SetErrorAndContinue(VER_E_SIG_VC_C) == false)
                                return FALSE;
                        }
                    }

                }

                return TRUE;
            }


            case ELEMENT_TYPE_VALUEARRAY:
            case ELEMENT_TYPE_ARRAY:
            case ELEMENT_TYPE_SZARRAY:
            {

                SigPointer      sigArray((PCCOR_SIGNATURE)(m_pCurPos - 1));
                TypeHandle      thArray;

                if (!VerifyArraySig((CorElementType)bType, fSkip, FALSE, dwArgNum))
                    return FALSE;

                if (fSkip)
                    return TRUE;

                thArray = sigArray.GetTypeHandle(m_pModule, NULL);

                if (thArray.IsNull())
                {
                    m_pVerifier->m_sError.dwFlags = (m_dwErrorFlags|VER_ERR_FATAL);
                    m_pVerifier->m_sError.dwArgNumber = dwArgNum;
                    m_pVerifier->m_sError.dwOffset = m_dwOffset;
                    m_pVerifier->SetErrorAndContinue(VER_E_SIG_ARRAY);
                    return FALSE;
                }

                return pItem->SetArray(thArray);

            }

        }
    }

Error:
    m_pVerifier->m_sError.dwFlags = m_dwErrorFlags;
    m_pVerifier->m_sError.dwArgNumber = dwArgNum;
    m_pVerifier->m_sError.dwOffset = m_dwOffset;
    m_pVerifier->SetErrorAndContinue(VER_E_SIG);
    // pSig >= pEndSig
    return FALSE;
}

BOOL VerSig::VerifyArraySig(CorElementType ArrayType, BOOL fSkip, BOOL fFollowsArray, DWORD dwArgNum)
{
    /*
        ELEM    ::= I1 | U1 | .... | STRING
                    CLASS | VALUE_CLASS
                    ARRAY | SZARRAY | GENERIC

        ARRAY   ::= ELEM
                    rank
                    nSize
                    {size1, size2.. sizen}
                    nBound
                    {bound1, bound2.. boundn}

        SZARRAY ::= ELEM

        GENERIC ::= ELEM

        SDARRAY ::= ELEM
                    nSize

        VALUE   ::= ELEM
                    nSize
    */

    CorElementType  elem;
    mdToken         tk;
    DWORD           dwSig, dwData, dwRank;


    if (m_pCurPos + 1 > m_pEndSig)
        goto Error;

    elem = (CorElementType) *m_pCurPos++;

    switch (elem)
    {
        case ELEMENT_TYPE_R:
        default:
        {
            LOG((LF_VERIFIER, LL_INFO10, "Verifier: Unknown elementtype in signature (0x%x)\n", (DWORD)elem));

            m_pVerifier->m_sError.dwFlags = m_dwErrorFlags;
            m_pVerifier->m_sError.elem = elem;
            m_pVerifier->m_sError.dwArgNumber = dwArgNum;
            m_pVerifier->m_sError.dwOffset = m_dwOffset;
            if (m_pVerifier->SetErrorAndContinue(VER_E_SIG_ELEMTYPE))
                break;   // verifier will exit, validator to continue.
            return FALSE;
        }

        case ELEMENT_TYPE_TYPEDBYREF:
        case ELEMENT_TYPE_BYREF:
        case ELEMENT_TYPE_PTR:
        {
            m_pVerifier->m_sError.dwFlags = m_dwErrorFlags;
            m_pVerifier->m_sError.dwArgNumber = dwArgNum;
            m_pVerifier->m_sError.dwOffset = m_dwOffset;
            if (m_pVerifier->SetErrorAndContinue(
                (elem == ELEMENT_TYPE_PTR) ? 
                VER_E_SIG_ARRAY_PTR : VER_E_SIG_ARRAY_BYREF) == false)
                return FALSE;   // The verifier will exit. 

            // Recursively parse the next piece of the signature
            // PTRS will be treated as BYREF in the validator mode

            if (!VerifyArraySig(ArrayType, fSkip, TRUE, dwArgNum))
                return FALSE;

            break;
        }

        case ELEMENT_TYPE_CLASS:
        case ELEMENT_TYPE_VALUETYPE:
        {
            dwSig = CorSigUncompressToken(m_pCurPos, &tk);

            if (m_pCurPos + dwSig > m_pEndSig)
                goto Error;

            m_pCurPos += dwSig;

            if (tk == 0)
            {
                if (fSkip)
                    return TRUE;
                else
                    goto Error;
            }

            // Check for Array of ArgHandle
            Item item;
            TypeHandle th;
            ClassLoader* pLoader = m_pModule->GetClassLoader();
            _ASSERTE(pLoader);
            NameHandle name(m_pModule, tk);
            th = pLoader->LoadTypeHandle(&name, NULL);

            if (th.IsNull())
                break;   // This is not an ArgHandle.

            item.SetTypeHandle(th);

            if (item.IsValueClassWithPointerToStack())
            {
                m_pVerifier->m_sError.dwFlags = m_dwErrorFlags;
                m_pVerifier->m_sError.dwArgNumber = dwArgNum;
                m_pVerifier->m_sError.dwOffset = m_dwOffset;
                if (m_pVerifier->SetErrorAndContinue(VER_E_SIG_ARRAY_TB_AH) == false)
                    return FALSE;
            }

            break;
        }

        case ELEMENT_TYPE_SZARRAY:
        case ELEMENT_TYPE_ARRAY:
        case ELEMENT_TYPE_VALUEARRAY:
        {
            if (!VerifyArraySig(elem, fSkip, TRUE, dwArgNum))
                return FALSE;

            break;
        }

        case ELEMENT_TYPE_CHAR:
        case ELEMENT_TYPE_BOOLEAN:
        case ELEMENT_TYPE_I1:
        case ELEMENT_TYPE_U1:
        case ELEMENT_TYPE_I2:
        case ELEMENT_TYPE_U2:
        case ELEMENT_TYPE_I4:
        case ELEMENT_TYPE_U4:
        case ELEMENT_TYPE_I8:
        case ELEMENT_TYPE_U8:
        case ELEMENT_TYPE_I:
        case ELEMENT_TYPE_U:
        case ELEMENT_TYPE_R4:
        case ELEMENT_TYPE_R8:
        case ELEMENT_TYPE_STRING:
        case ELEMENT_TYPE_OBJECT:
        {
            break;
        }
    }

    switch (ArrayType)
    {
        default:
        {
            _ASSERTE(!"Should never reach here !");
            goto Error;
        }

        case ELEMENT_TYPE_SZARRAY:
        {
            break;
        }

        case ELEMENT_TYPE_ARRAY:
        {
            if (!GetData(&dwRank))
                goto Error;

            if (dwRank > 0)
            {
                DWORD dw;

                if (!GetData(&dwData))      // nSize
                    goto Error;

                if (dwData < 0)
                    goto Error;

                while (dwData-- > 0)
                {
                    if (!GetData(&dw))
                        goto Error;
                }

                if (!GetData(&dwData))      // nSize
                    goto Error;

                if (dwData < 0)
                    goto Error;

                while (dwData-- > 0)
                {
                    if (!GetData(&dw))
                        goto Error;
                }
            }

            break;
        }

        case ELEMENT_TYPE_VALUEARRAY:
        {
            dwRank = 0;
            if (!GetData(&dwData))
                goto Error;

            break;
        }
    }

    return TRUE;

Error:
    m_pVerifier->m_sError.dwFlags = (m_dwErrorFlags|VER_ERR_FATAL);
    m_pVerifier->m_sError.dwArgNumber = dwArgNum;
    m_pVerifier->m_sError.dwOffset = m_dwOffset;
    m_pVerifier->SetErrorAndContinue(VER_E_SIG);

    return FALSE;
}

BOOL VerSig::GetData(DWORD* pdwData)
{
    DWORD dwSig;

    dwSig = CorSigUncompressData(m_pCurPos, pdwData);

    if (m_pCurPos + dwSig > m_pEndSig)
        return FALSE;

    m_pCurPos += dwSig;

    return TRUE;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\verifier.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//
// verifier.cpp
//
// Contact : Shajan Dasan [shajand@microsoft.com]
// Specs   : http://Lightning/Specs/Security
//
// Registry / Environment settings :
//
//      Create registry entries in CURRENT_USER\Software\Microsoft\.NETFramework
//      or set environment variables COMPlus_* with the names given below. 
//      Environment settings override registry settings.
//
//      For breaking into the debugger / Skipping verification :
//          (available only in the debug build).
//
//      VerBreakOnError  [STRING]    Break into the debugger on error. Set to 1
//      VerSkip          [STRING]    method names (case sensitive)
//      VerBreak         [STRING]    method names (case sensitive)
//      VerOffset        [STRING]    Offset in the method in hex
//      VerPass          [STRING]    1 / 2 ==> First pass, second pass
//      VerMsgMethodInfoOff [STRING]    Print method / module info on error
//
//      NOTE : If there are more than one methods in the list and an offset
//      is specified, this offset is applicable to all methods in the list
//    
//      NOTE : Verifier should be enabled for this to work.
//
//      To Swith the verifier Off (Default is On) :
//          (available on all builds).
//
//      VerifierOff     [STRING]    1 ==> Verifier is Off, 0 ==> Verifier is On 
//
//      [See EEConfig.h / EEConfig.cpp]
//
//
// Meaning of code marked with @XXX
//
//      @VER_ASSERT : Already verified.
//      @VER_IMPL   : Verification rules implemented here.
//      @DEBUG      : To be removed/commented before checkin.
//

#include "common.h"

#include "verifier.hpp"

#include "ceeload.h"
#include "clsload.hpp"
#include "method.hpp"
#include "vars.hpp"
#include "object.h"
#include "field.h"
#include "comdelegate.h"
#include "security.h"
#include "dbginterface.h"
#include "permset.h"
#include "eeconfig.h"


// For performance #s on upfront Security Policy Resolution Vs Verification
// #define _VERIFIER_TEST_PERF_ 1

// Verify delegate .ctor opcode sequence
// object on stack, dup, ldvirtftn, call dlgt::.ctor(Object, ftn)
// for function pointers obtained using ldvirtftn opcode
#define _VER_DLGT_CTOR_OPCODE_SEQUENCE 1 // (Enable in 2nd CLR Integration)

// Disalow multiple inits in ctors
// #define _VER_DISALLOW_MULTIPLE_INITS 1

// Disabling tracking of local types for V.1
// Enable reuse of locals declared as object type.
// The last type assigned to the local is the type of the local.
// #ifdef _VER_TRACK_LOCAL_TYPE

#ifdef _VERIFIER_TEST_PERF_
BOOL g_fVerPerfPolicyResolveNoVerification;
DWORD g_timeStart; // Not thread safe, but ok for perf testing
DWORD g_timeEnd;
#endif

// Enforce declaration of innermost exception blocks first
#define _VER_DECLARE_INNERMOST_EXCEPTION_BLOCK_FIRST 1

// This flag is usefull for Tools & Compiler Developers.
// They can set this flag thru EEconfig Variable "VerForceVerify". 
// If this flag is set, Modules are verified even if they have fully trust.
#ifdef _DEBUG
BOOL g_fVerForceVerifyInited = FALSE;
BOOL g_fVerForceVerify;
#endif

// Detailed error message
BOOL g_fVerMsgMethodInfoOff = FALSE;

#define VER_NO_BB (DWORD)(-1)

// the bit location of the first set bit in a nibble (0 == no bits)
const BYTE g_FirstOneBit[16] =
{
    0,  // 0000
    1,  // 0001
    2,  // 0010
    1,  // 0011
    3,  // 0100
    1,  // 0101
    2,  // 0110
    1,  // 0111
    4,  // 1000
    1,  // 1001
    2,  // 1010
    1,  // 1011
    3,  // 1100
    1,  // 1101
    2,  // 1110
    1   // 1111
};


#define SIZEOF_ENDFILTER_INSTRUCTION 2
#define SIZEOF_LDFTN_INSTRUCTION 2
#define SIZEOF_LDVIRTFTN_INSTRUCTION 2
#define SIZEOF_DUP_INSTRUCTION 1
#define SIZEOF_METHOD_TOKEN 4

#define VER_NAME_INFO_SIZE  128

#define VER_MAX_ERROR_MSG_LEN 1024

#define Pop0        0
#define Pop1        1
#define PopI4       1
#define PopI8       1
#define PopI        1
#define PopRef      1
#define PopR4       1
#define PopR8       1
#define VarPop      0x7f

#define Push0       0
#define Push1       1
#define PushI4      1
#define PushI8      1
#define PushI       1
#define PushRef     1
#define PushR4      1
#define PushR8      1
#define VarPush     0x7f


#define SIZEOF_ENDFILTER_INSTRUCTION 2
#define SIZEOF_LDFTN_INSTRUCTION 2
#define SIZEOF_LDVIRTFTN_INSTRUCTION 2
#define SIZEOF_DUP_INSTRUCTION 1
#define SIZEOF_METHOD_TOKEN 4

#define VER_NAME_INFO_SIZE  128

#define VER_MAX_ERROR_MSG_LEN 1024

#define OPDEF(c,s,pop,push,args,type,l,s1,s2,ctrl) ( ( (push)==VarPush || (pop)==VarPop ) ? VarPush : (push)-(pop) ),


// Net # items pushed on stack (VarPush if indeterminate, e.g. CEE_CALL)
const __int8 OpcodeNetPush[] =
{
#include "opcode.def"
     VarPush /* for CEE_COUNT */
};
#undef OPDEF


#undef Pop0    
#undef Pop1    
#undef PopI4   
#undef PopI8   
#undef PopI    
#undef PopRef  
#undef PopR4   
#undef PopR8   
#undef VarPop  

#undef Push0   
#undef Push1   
#undef PushI4  
#undef PushI8  
#undef PushI   
#undef PushRef 
#undef PushR4  
#undef PushR8  

// Set that "loc" is an instruction boundary
#define SET_INSTR_BOUNDARY(pos) SET_BIT_IN_DWORD_BMP(m_pInstrBoundaryList, pos)

// Returns whether "loc" is on an instruction boundary
#define ON_INSTR_BOUNDARY(pos) IS_SET_BIT_IN_DWORD_BMP(m_pInstrBoundaryList, pos)

// Un-Set the "loc" is the start of a basic block
#define RESET_BB_BOUNDARY(pos) RESET_BIT_IN_DWORD_BMP(m_pBasicBlockBoundaryList, pos)

// Set that "loc" is the start of a basic block
#define SET_BB_BOUNDARY(pos) SET_BIT_IN_DWORD_BMP(m_pBasicBlockBoundaryList, pos)

// Returns whether "loc" is the start of a basic block
#define ON_BB_BOUNDARY(pos) IS_SET_BIT_IN_DWORD_BMP(m_pBasicBlockBoundaryList, pos)

// Macro to detect runoff.
#define RUNS_OFF_END(/*DWORD*/ iPos, /*DWORD*/incr, /*DWORD*/cbILCodeSize) \
    ( ((iPos) + (incr)) > (cbILCodeSize)  ||  ((iPos) + (incr)) < iPos )

//
// Macro to read 4 bytes from the code
//
#define SAFE_READU4(pCode, CodeSize, ipos, fError, result) \
{ \
    if (ipos + 4 > CodeSize) \
    { \
        fError = TRUE; \
    } \
    else \
    { \
        result = (pCode[ipos] + (pCode[ipos+1]<<8) + (pCode[ipos+2]<<16) + (pCode[ipos+3]<<24)); \
        ipos += 4; \
    } \
}


//
// Macro to read 2 bytes from the code
//
#define SAFE_READU2(pCode, CodeSize, ipos, fError, result) \
{ \
    if (ipos + 2 > CodeSize) \
    { \
        fError = TRUE; \
    } \
    else \
    { \
        result = (pCode[ipos] + (pCode[ipos+1]<<8)); \
        ipos += 2; \
    } \
}

//
// Macro to read 1 byte from the code
//
#define SAFE_READU1(pCode, CodeSize, ipos, fError, result) \
{ \
    if (ipos >= CodeSize) \
        fError = TRUE; \
    else \
        result = pCode[ipos++]; \
}

//
// Reads 1 byte and sign extends it to a long
//
#define SAFE_READI1_TO_I4(pCode, CodeSize, ipos, fError, result) \
{ \
    if (ipos >= CodeSize) \
        fError = TRUE; \
    else \
        result = (long) ((char) pCode[ipos++]); \
}

//
// Read 4 bytes with no error checking
//
#define READU4(Code, ipos, result) \
{ \
    result = (Code[ipos] + (Code[ipos+1]<<8) + (Code[ipos+2]<<16) + (Code[ipos+3]<<24)); \
    ipos += 4; \
}

//
// Read 2 bytes with no error checking
//
#define READU2(Code, ipos, result) \
{ \
    result = (Code[ipos] + (Code[ipos+1]<<8)); \
    ipos += 2; \
}

//
// Read 1 byte with no error checking
//
#define READU1(Code, ipos, result) result = Code[ipos++];

//
// Reads 1 byte and sign extends it to a long, no error checking
//
#define READI1_TO_I4(Code, ipos, result) result = (long) ((char) Code[ipos++]);

const char *g_pszVerifierOperation[] =
{
#define VEROPCODE(name, operation) operation,
#include "vertable.h"
};
#undef VEROPCODE

#ifdef _DEBUG
const DWORD g_VerifierInstructionCheck[] =
{
#define VEROPCODE(name, operation) name,
#include "vertable.h"
};
#undef VEROPCODE
#endif

TypeHandle Verifier::s_th_System_RuntimeTypeHandle;
TypeHandle Verifier::s_th_System_RuntimeMethodHandle;
TypeHandle Verifier::s_th_System_RuntimeFieldHandle;
TypeHandle Verifier::s_th_System_RuntimeArgumentHandle;
TypeHandle Verifier::s_th_System_TypedReference;


#define SET_ERR_OPCODE_OFFSET() {                                           \
        m_sError.opcode = opcode;                                           \
        m_sError.dwOffset = dwPCAtStartOfInstruction; }

#define SET_ERR_OM() {                                                      \
        m_sError.dwFlags = VER_ERR_FATAL;                                   \
        SetErrorAndContinue(COR_E_OUTOFMEMORY); }

#define FAILMSG_STACK_EMPTY() {                                             \
        m_sError.dwFlags = (VER_ERR_FATAL|VER_ERR_OPCODE_OFFSET);           \
        SET_ERR_OPCODE_OFFSET();                                            \
        SetErrorAndContinue(VER_E_STACK_EMPTY); }

#define FAILMSG_PC_STACK_OVERFLOW() {                                       \
        m_sError.dwFlags = (VER_ERR_FATAL|VER_ERR_OPCODE_OFFSET);           \
        SET_ERR_OPCODE_OFFSET();                                            \
        SetErrorAndContinue(VER_E_STACK_OVERFLOW); }

#define FAILMSG_PC_STACK_UNDERFLOW() {                                      \
        m_sError.dwFlags = (VER_ERR_FATAL|VER_ERR_OPCODE_OFFSET);           \
        SET_ERR_OPCODE_OFFSET();                                            \
        SetErrorAndContinue(VER_E_STACK_UNDERFLOW); }

#define FAILMSG_TOKEN(tok, err) {                                           \
        m_sError.dwFlags = (VER_ERR_FATAL|VER_ERR_TOKEN|VER_ERR_OPCODE_OFFSET);\
        m_sError.token = tok;                                               \
        SET_ERR_OPCODE_OFFSET();                                            \
        SetErrorAndContinue(err); }

#define FAILMSG_TOKEN_RESOLVE(tok) { FAILMSG_TOKEN(tok, VER_E_TOKEN_RESOLVE); }

#define FAILMSG_STACK_EXPECTED_I4_FOUND_SOMETHING_ELSE() {                  \
        m_sError.dwFlags =                                                  \
        (VER_ERR_FATAL|VER_ERR_ITEM_F|VER_ERR_ITEM_E|VER_ERR_OPCODE_OFFSET);\
        m_sError.sItemFound = m_pStack[m_StackSlot]._GetItem();             \
        m_sError.sItemExpected.dwFlags = ELEMENT_TYPE_I4;                   \
        m_sError.sItemExpected.pv = NULL;                                   \
        SET_ERR_OPCODE_OFFSET(); }

// Copies the error message to the input char*
WCHAR* Verifier::GetErrorMsg(
        HRESULT hrError,
        VerError err,
        MethodDesc *pMethodDesc,        // Can be null
        WCHAR *wszMsg, 
        int len)
{
    int rem = len;
    int cw = 0;
    int cs = 0;

    if (pMethodDesc)
    {

#define VER_BUF_LEN  MAX_CLASSNAME_LENGTH + 1024

        CQuickBytes qb;
        LPSTR buff = (LPSTR) qb.Alloc((VER_BUF_LEN+1)* sizeof(CHAR));
        EEClass *pClass;

        wcsncpy(wszMsg, L"[", rem);
        wcsncat(wszMsg, pMethodDesc->GetModule()->GetFileName(), rem - 1);
        cw = (int)wcslen(wszMsg);
        rem = len - cw;

        if (rem <= 0)
            goto exit;

        pClass = pMethodDesc->GetClass();

        if (pClass != NULL)
        {
            DefineFullyQualifiedNameForClass();
            GetFullyQualifiedNameForClassNestedAware(pClass);
            strncpy(buff, " : ", VER_BUF_LEN);
            strncat(buff, _szclsname_, VER_BUF_LEN - (cs + 3));
        }
        else
        {
            strncpy(buff, " : <GlobalFunction>", VER_BUF_LEN);
        }

        cs = (int)strlen(buff);

        strncat(buff, "::", VER_BUF_LEN - cs);

        cs += 2;
        cs = (cs > VER_BUF_LEN) ? VER_BUF_LEN : cs;

        strncat(buff,
            pMethodDesc->GetModule()->GetMDImport()->GetNameOfMethodDef(
            pMethodDesc->GetMemberDef()),
            VER_BUF_LEN - cs);

        cs = WszMultiByteToWideChar(CP_UTF8, 0, buff, -1, &wszMsg[cw], rem);

        if (cs <= 0)
        {
            wcsncpy(&wszMsg[cw], L"] [EEInternal : MultiByteToWideChar error]", rem);
            cw = (int)wcslen(wszMsg);
            rem = len - cw;
        }
        else
        {
            cw += (cs - 1);     // cs now inclues the null char.
            rem = len - cw;

            if (rem <= 0)
                goto exit;

            wcsncpy(&wszMsg[cw], L"]", rem);
            ++cw;
            cw = (cw > len) ? len : cw;
            rem = len - cw;

            if (rem <= 0)
                goto exit;

        }
    }
    else
    {
        wszMsg[0] = 0;
    }

    // Fill In the details
#define VER_SMALL_BUF_LEN 256
    WCHAR wBuff[VER_SMALL_BUF_LEN + 1];
    WCHAR wBuff1[VER_SMALL_BUF_LEN + 100 + 1];
    CHAR  sBuff[VER_SMALL_BUF_LEN + 1];

    wBuff[0] = L' ';    // The leading space

#define VER_PRINT()                                             \
    {                                                           \
        wBuff1[VER_SMALL_BUF_LEN] = 0;                          \
        wcsncpy(&wszMsg[cw], wBuff1, rem);                      \
                                                                \
        cw = (int)wcslen(wszMsg);                               \
        rem = len - cw;                                         \
                                                                \
        if (rem <= 0)                                           \
            goto exit;                                          \
    }
    
#define VER_LD_RES(e, fld)                                      \
    {                                                           \
        if (SUCCEEDED(LoadStringRC(e, &wBuff[1], VER_SMALL_BUF_LEN))) \
        {                                                       \
            wBuff[VER_SMALL_BUF_LEN] = 0;                       \
            swprintf(wBuff1, wBuff, err.##fld);                 \
            VER_PRINT();                                        \
        }                                                       \
    }

#define VER_LD_ITEM(fld)                                        \
    {                                                           \
        Item item;                                              \
        item._SetItem(err.##fld);                               \
        item.ToString(sBuff, VER_SMALL_BUF_LEN);                \
    }


    // Create the generic error fields

    if (err.dwFlags & VER_ERR_OFFSET)
        VER_LD_RES(VER_E_OFFSET, dwOffset);

    if (err.dwFlags & VER_ERR_OPCODE)
    {
        if (SUCCEEDED(LoadStringRC(VER_E_OPCODE, &wBuff[1], VER_SMALL_BUF_LEN)))
        {
            wBuff[VER_SMALL_BUF_LEN] = 0;
            swprintf(wBuff1, wBuff, ppOpcodeNameList[err.opcode]);

            VER_PRINT();
        }
    }

    if (err.dwFlags & VER_ERR_OPERAND)
        VER_LD_RES(VER_E_OPERAND, dwOperand);

    if (err.dwFlags & VER_ERR_TOKEN)
        VER_LD_RES(VER_E_TOKEN, token);

    if (err.dwFlags & VER_ERR_EXCEP_NUM_1)
        VER_LD_RES(VER_E_EXCEPT, dwException1);

    if (err.dwFlags & VER_ERR_EXCEP_NUM_2)
        VER_LD_RES(VER_E_EXCEPT, dwException2);

    if (err.dwFlags & VER_ERR_STACK_SLOT)
        VER_LD_RES(VER_E_STACK_SLOT, dwStackSlot);

    if ((err.dwFlags & VER_ERR_SIG_MASK) == VER_ERR_LOCAL_SIG)
    {
        if (err.dwVarNumber != VER_ERR_NO_LOC)
            VER_LD_RES(VER_E_LOC, dwVarNumber);
    }

    if ((err.dwFlags & VER_ERR_SIG_MASK) == VER_ERR_FIELD_SIG)
    {
        if (SUCCEEDED(LoadStringRC(VER_E_FIELD_SIG, &wBuff[1], VER_SMALL_BUF_LEN)))
        {
            wBuff[VER_SMALL_BUF_LEN] = 0;
            swprintf(wBuff1, L" %s", wBuff);
            VER_PRINT();
        }
    }

    if (((err.dwFlags & VER_ERR_SIG_MASK) == VER_ERR_METHOD_SIG) ||
        ((err.dwFlags & VER_ERR_SIG_MASK) == VER_ERR_CALL_SIG))
    {
        if (err.dwArgNumber != VER_ERR_NO_ARG)
        {
            if (err.dwArgNumber != VER_ERR_ARG_RET)
            {
                VER_LD_RES(VER_E_ARG, dwArgNumber);
            }
            else if (SUCCEEDED(LoadStringRC(VER_E_RET_SIG, &wBuff[1], VER_SMALL_BUF_LEN)))
            {
                wBuff[VER_SMALL_BUF_LEN] = 0;
                swprintf(wBuff1, L" %s", wBuff);
                VER_PRINT();
            }
        }
    }

    if (err.dwFlags & VER_ERR_ITEM_1)
    {
        VER_LD_ITEM(sItem1);
        swprintf(wBuff1, L" %S", sBuff);
        VER_PRINT();
    }

    if (err.dwFlags & VER_ERR_ITEM_2)
    {
        VER_LD_ITEM(sItem2);
        swprintf(wBuff1, L" %S", sBuff);
        VER_PRINT();
    }

    if (err.dwFlags & VER_ERR_ITEM_F)
    {
        VER_LD_ITEM(sItemFound);

        if (SUCCEEDED(LoadStringRC(VER_E_FOUND, &wBuff[1], VER_SMALL_BUF_LEN)))
        {
            wBuff[VER_SMALL_BUF_LEN] = 0;
            swprintf(wBuff1, wBuff, sBuff);
            VER_PRINT();
        }
    }

    if (err.dwFlags & VER_ERR_ITEM_E)
    {
        VER_LD_ITEM(sItemExpected);

        if (SUCCEEDED(LoadStringRC(VER_E_EXPECTED, &wBuff[1], VER_SMALL_BUF_LEN)))
        {
            wBuff[VER_SMALL_BUF_LEN] = 0;
            swprintf(wBuff1, wBuff, sBuff);
            VER_PRINT();
        }
    }

    //  Handle the special cases
    switch (hrError)
    {
    case VER_E_UNKNOWN_OPCODE:
        VER_LD_RES(VER_E_UNKNOWN_OPCODE, opcode);
        break;

    case VER_E_SIG_CALLCONV:
        VER_LD_RES(VER_E_SIG_CALLCONV, bCallConv);
        break;

    case VER_E_SIG_ELEMTYPE:
        VER_LD_RES(VER_E_SIG_ELEMTYPE, elem);
        break;

    case HRESULT_FROM_WIN32(ERROR_BAD_FORMAT):
        hrError = VER_E_PE_LOAD;
        // no break on purpose.

    default :
        if (cw > 0) { wszMsg[cw++] = L' '; --rem; }
    
        if (HRESULT_FACILITY(hrError) == FACILITY_URT)
        {
            if (FAILED(LoadStringRC(hrError, &wszMsg[cw], rem, TRUE)))
            {
                goto print_hr;
            }
        }
        else
        {
print_hr:
            WCHAR* win32Msg = NULL;
            BOOL useWin32Msg = WszFormatMessage( FORMAT_MESSAGE_ALLOCATE_BUFFER | 
                                   FORMAT_MESSAGE_FROM_SYSTEM | 
                                   FORMAT_MESSAGE_IGNORE_INSERTS,
                                   NULL,
                                   hrError,
                                   MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
                                   (LPTSTR) &win32Msg,
                                   0,
                                   NULL );
                
            if (SUCCEEDED(LoadStringRC(VER_E_HRESULT, &wBuff[1], VER_SMALL_BUF_LEN)))
            {
                wBuff[VER_SMALL_BUF_LEN] = 0;
                swprintf(wBuff1, wBuff, hrError, win32Msg);

                if (useWin32Msg)
                {
                    if (wcslen( win32Msg ) + wcslen( wBuff1 ) + wcslen( L" - " ) - 1 > VER_SMALL_BUF_LEN )
                    {
                        _ASSERTE( false && "The buffer is not large enough for this error message" );
                        LocalFree( win32Msg );
                        win32Msg = NULL;
                    }
                    else
                    {
                        wcscat( wBuff1, L" - " );
                        wcscat( wBuff1, win32Msg );
                    }
                }
    
                wBuff1[VER_SMALL_BUF_LEN] = 0;
                wcsncpy(&wszMsg[cw], wBuff1, rem);
            }

            if (win32Msg != NULL)
                LocalFree( win32Msg );
        }
    }

exit:
    wszMsg[len-1] = 0;
    return wszMsg;
}

// Assumes that m_sError is already set
bool Verifier::SetErrorAndContinue(HRESULT hrError)
{
#ifdef _DEBUG
    // "COMPlus_VerBreakOnError==1" EnvVar or VerBreakOnError RegKey 
    if (m_fDebugBreakOnError)
    {
        DebugBreak();
    }
#endif

    if ((m_wFlags & VER_STOP_ON_FIRST_ERROR) || (m_IVEHandler == NULL))
    {
        m_hrLastError = hrError;
        return false;           // Stop, do not continue.
    }

    bool retVal;
    VEContext vec;

    // We have asserted that they have the same size
    memcpy(&vec, &m_sError, sizeof(VEContext));

    retVal = (m_IVEHandler->VEHandler(hrError, vec, NULL) == S_OK);

    // Reset the error
    m_sError.dwFlags = 0;
    return retVal;
}


LocArgInfo_t *  Verifier::GetGlobalLocVarTypeInfo(DWORD dwLocVarNum)
{
    _ASSERTE(dwLocVarNum < m_MaxLocals);
    return &m_pLocArgTypeList[dwLocVarNum];
}

LocArgInfo_t *  Verifier::GetGlobalArgTypeInfo(DWORD dwArgNum)
{
    _ASSERTE(dwArgNum < m_NumArgs);
    return &m_pLocArgTypeList[m_MaxLocals + dwArgNum];
}

// Works on both primitive and non-primitive locals
Item Verifier::GetCurrentValueOfLocal(DWORD dwLocNum)
{
    _ASSERTE(dwLocNum < m_MaxLocals);

    LocArgInfo_t *pInfo = GetGlobalLocVarTypeInfo(dwLocNum);
    long          slot  = pInfo->m_Slot;
    Item          Value;

    if (LIVEDEAD_TRACKING_ONLY_FOR_SLOT(slot))
    {
        // If it's a primitive slot, the only current type information kept is whether it is live or dead
        if (IsLocVarLiveSlot(LIVEDEAD_NEGATIVE_SLOT_TO_BITNUM(slot)))
        {
            Value = pInfo->m_Item;
        }
        else
        {
            if (pInfo->m_Item.IsValueClass())
            {
                Value = pInfo->m_Item;
                Value.SetUninitialised();
            }
            else
                Value.SetDead();
        }
    }
    else
    {
#ifdef _VER_TRACK_LOCAL_TYPE
        if (DoesLocalHavePinnedType(dwLocNum))
        {
            Item cur = m_pNonPrimitiveLocArgs[slot];

            if (cur.IsDead())
                Value = cur;
            else 
                Value = pInfo->m_Item;
        }
        else
        {
            Value = m_pNonPrimitiveLocArgs[slot];
        }
#else
        Value = pInfo->m_Item;
#endif
    }

    return Value;
}

// Takes into account that the "this" pointer might be uninitialised
Item Verifier::GetCurrentValueOfArgument(DWORD dwArgNum)
{
    _ASSERTE(dwArgNum < m_NumArgs);

    // Make a copy
    Item Value = GetGlobalArgTypeInfo(dwArgNum)->m_Item;

    if (m_fThisUninit && dwArgNum == 0)
        Value.SetUninitialised();

    return Value;
}

Item* Verifier::GetCurrentValueOfNonPrimitiveArg(DWORD dwArg)
{
    _ASSERTE(dwArg < m_NumArgs);
    long slot = GetGlobalArgTypeInfo(dwArg)->m_Slot;
    _ASSERTE(!LIVEDEAD_TRACKING_ONLY_FOR_SLOT(slot));
    return &m_pNonPrimitiveLocArgs[slot];
}

//
// Decode an opcode from pCode, and return it.  Return the length of the opcode in pdwLen.
//
// cBytesAvail is the number of input bytes available from pCode, and must be > 0.
//
// Returns CEE_COUNT (which is an invalid opcode) to indicate an error condition, such as
// insufficient bytes available.
//
// This function is used on the first pass of the verifier, where it is determining the
// basic blocks.
//
OPCODE Verifier::SafeDecodeOpcode(const BYTE *pCode, DWORD cBytesAvail, DWORD *pdwLen)
{
    OPCODE opcode;

    *pdwLen = 1;
    opcode = OPCODE(pCode[0]);
    switch (opcode) {
        case CEE_PREFIX1:
            if (cBytesAvail < 2)
                return CEE_COUNT;
            opcode = OPCODE(pCode[1] + 256);
            *pdwLen = 2;
            if (opcode < 0 || opcode >= CEE_COUNT)
                return CEE_COUNT;

#ifdef DEBUGGING_SUPPORTED
            if ((opcode == CEE_BREAK) && (CORDebuggerAttached()))
            {
                _ASSERTE(!"Debugger only works with reference encoding!");
                return CEE_COUNT;
            }
#endif //DEBUGGING_SUPPORTED

            return opcode;

        case CEE_PREFIXREF:
        case CEE_PREFIX2:
        case CEE_PREFIX3:
        case CEE_PREFIX4:
        case CEE_PREFIX5:
        case CEE_PREFIX6:
        case CEE_PREFIX7:
            *pdwLen = 2;
            return CEE_COUNT;
    }

    _ASSERTE((opcode >= 0) && (opcode <= CEE_COUNT));

    return opcode;
}

//
// Like the above routine, except that no checks are made on running out of input.
//
// This is used on the second pass of the verifier when it actually executes the code.
//
OPCODE Verifier::DecodeOpcode(const BYTE *pCode, DWORD *pdwLen)
{
    OPCODE opcode;

    *pdwLen = 1;
    opcode = OPCODE(pCode[0]);
    switch(opcode) {
        case CEE_PREFIX1:
            opcode = OPCODE(pCode[1] + 256);
            *pdwLen = 2;

#ifdef DEBUGGING_SUPPORTED
            if ((opcode == CEE_BREAK) && (CORDebuggerAttached()))
                _ASSERTE(!"Debugger only works with reference encoding!");
#endif // DEBUGGING_SUPPORTED

            break;
        }
    return opcode;
}


// This routine is for primitive types only
// Slot is a primitive slot number >= 0
// Use for local variables only - primitive arguments are always live, and therefore not included in the bitmap
void Verifier::SetLocVarLiveSlot(DWORD slot)
{
    _ASSERTE((slot >> 5) < m_NumPrimitiveLocVarBitmapArrayElements);
    m_pPrimitiveLocVarLiveness[slot >> 5] |= (1 << (slot & 31));
}

// this routine is for primitive types only
// slot is a primitive slot number >= 0
// Use for local variables only - primitive arguments are always live, and therefore not included in the bitmap
void Verifier::SetLocVarDeadSlot(DWORD slot)
{
    _ASSERTE((slot >> 5) < m_NumPrimitiveLocVarBitmapArrayElements);
    m_pPrimitiveLocVarLiveness[slot >> 5] &= ~(1 << (slot & 31));
}

// this routine is for primitive types only
// slot is a primitive slot number >= 0
// returns zero if dead or non-zero (not necessarily "TRUE") if live
// Use for local variables only - primitive arguments are always live, and therefore not included in the bitmap
DWORD Verifier::IsLocVarLiveSlot(DWORD slot)
{
    _ASSERTE((slot >> 5) < m_NumPrimitiveLocVarBitmapArrayElements);
    return (m_pPrimitiveLocVarLiveness[slot >> 5] & (1 << (slot & 31)));
}

BOOL Verifier::SetBasicBlockDirty(DWORD BasicBlockNumber, BOOL fExtendedState, 
    DWORD DestBB)
{
    _ASSERTE(BasicBlockNumber < m_NumBasicBlocks);
    if (fExtendedState)
    {
        _ASSERTE(m_fHasFinally);

        if (m_pBasicBlockList[BasicBlockNumber].m_pAlloc == NULL)
        {
            if (!m_pBasicBlockList[BasicBlockNumber].
                AllocExtendedState(m_NumBasicBlocks))
            {
                SET_ERR_OM();
                return FALSE;
            }
        }

        m_pBasicBlockList[BasicBlockNumber].
            m_pExtendedDirtyBitmap[DestBB >> 5] |= (1 << (DestBB & 31));
    }
    else
        m_pDirtyBasicBlockBitmap[BasicBlockNumber >> 5] |= (1 << (BasicBlockNumber & 31));

    return TRUE;
}

void Verifier::SetBasicBlockClean(DWORD BasicBlockNumber, BOOL fExtendedState,
    DWORD DestBB)
{
    _ASSERTE(BasicBlockNumber < m_NumBasicBlocks);
    if (fExtendedState)
    {
        _ASSERTE(m_fHasFinally);
        _ASSERTE(m_pBasicBlockList[BasicBlockNumber].m_pAlloc != NULL);

        m_pBasicBlockList[BasicBlockNumber].
            m_pExtendedDirtyBitmap[DestBB >> 5] &= ~(1 << (DestBB & 31));
    }
    else
        m_pDirtyBasicBlockBitmap[BasicBlockNumber >> 5] &= ~(1 << (BasicBlockNumber & 31));
}

// returns non-zero (not necessarily TRUE) if basic block dirty
DWORD Verifier::IsBasicBlockDirty(DWORD BasicBlockNumber, BOOL fExtendedState,
    DWORD DestBB)
{
    _ASSERTE(BasicBlockNumber < m_NumBasicBlocks);
    if (fExtendedState)
    {
        _ASSERTE(m_fHasFinally);

        if (m_pBasicBlockList[BasicBlockNumber].m_pAlloc == NULL)
            return 0;

        return m_pBasicBlockList[BasicBlockNumber].
            m_pExtendedDirtyBitmap[DestBB >> 5] & (1 << (DestBB & 31));
    }
    else
        return m_pDirtyBasicBlockBitmap[BasicBlockNumber >> 5] & (1 << (BasicBlockNumber & 31));
}

//
// Pops a given primitive type from the stack.
//
// Doesn't check for m_StackSlot < 0 - assumes Type will miscompare against the sentinel value
// stored before the beginning of the stack.
//
BOOL Verifier::FastPop(DWORD Type)
{
    return (m_pStack[--m_StackSlot].IsGivenPrimitiveType(Type));
}

//
// Checks that a given primitive type is on the stack.
//
// Doesn't check for m_StackSlot < 0 - assumes Type will miscompare against the sentinel value
// stored before the beginning of the stack.
//
BOOL Verifier::FastCheckTopStack(DWORD Type)
{
    return (m_pStack[m_StackSlot - 1].IsGivenPrimitiveType(Type));
}

//
// Pushes a primitive type on the stack.
//
// Doesn't check for overflow - use this function if you've just popped something from the stack,
// and therefore know that the push cannot fail.
//
void Verifier::FastPush(DWORD Type)
{
    m_pStack[m_StackSlot++].SetType(Type);
}


// Initialise the verifier to verify the provided method
//
BOOL Verifier::Init(
    MethodDesc *pMethodDesc,                     
    COR_ILMETHOD_DECODER* ILHeader
)
{
    DWORD           i;
    BOOL            fSuccess = FALSE;
    DWORD           CurArg;
    PCCOR_SIGNATURE pSig;   
    DWORD           cSig;   

#ifdef _DEBUG

    // To cross check the hardcoded size of 
    // ENDFILTER, LD(VIRT)FTN, DUP instructions
    static const __int8 opcodeSize[] =
    {
#define OPDEF(c,s,pop,push,args,type,l,s1,s2,ctrl) l,
#include "opcode.def"
       0x0F     // A large number
#undef OPDEF
    };

    static BOOL fFirstTime = TRUE;

    if (fFirstTime)
    {
        fFirstTime = FALSE;
        // Verify that the instructions are in the correct order
        for (i = 0; i < (sizeof(g_VerifierInstructionCheck)/sizeof(g_VerifierInstructionCheck[0])); i++)
        {
            _ASSERTE(g_VerifierInstructionCheck[i] == i);
        }

        CrossCheckVertable();

        // Assert the hardcoded opcode size
        _ASSERTE(SIZEOF_ENDFILTER_INSTRUCTION == opcodeSize[CEE_ENDFILTER]);
        _ASSERTE(SIZEOF_LDFTN_INSTRUCTION == opcodeSize[CEE_LDFTN]);
        _ASSERTE(SIZEOF_LDVIRTFTN_INSTRUCTION == opcodeSize[CEE_LDVIRTFTN]);
        _ASSERTE(SIZEOF_DUP_INSTRUCTION == opcodeSize[CEE_DUP]);

        // VerItem.hpp makes an assumption on ELEMENT_TYPE_MAX
        _ASSERTE(VER_FLAG_DATA_MASK >= VER_LAST_BASIC_TYPE);

        // VerError.h makes two structures, one for internal use (VerError) and
        // one for the always crying idl compiler.. Make sure that the two 
        // structures have the same size.

        _ASSERTE(sizeof(VerError) == sizeof(_VerError));

    }
    
    if (g_pConfig->IsVerifierBreakOnErrorEnabled())
    {
        m_fDebugBreakOnError = true;
    }
    
        // Print method & module information on error. default is ON
        g_fVerMsgMethodInfoOff = g_pConfig->IsVerifierMsgMethodInfoOff();
    //
    // Break here if this method is listed in the registry / env "VerBreak"
    // and no offset is specified
    // NOTE : verifier should be enabled for this to work.
    //
    if (g_pConfig->ShouldVerifierBreak(pMethodDesc))
    {
        m_fDebugBreak = true;
        
        if (g_pConfig->IsVerifierBreakOffsetEnabled() == false)
            DebugBreak();
    }
    
// @DEBUG InitializeLogging(); 

#endif

#ifdef _VERIFIER_TEST_PERF_
    g_fVerPerfPolicyResolveNoVerification
        = (g_pConfig->GetConfigDWORD(L"VerPerfPolicyOnly", 0) == 1);
#endif

#ifdef _DEBUG
    if (!g_fVerForceVerifyInited)
    {
        // if g_fVerForceVerify is set, Verification will not be skipped even
        // for fully trusted code.
        g_fVerForceVerify = 
                (g_pConfig->GetConfigDWORD(L"VerForceVerify", 0) == 1);

        g_fVerForceVerifyInited = TRUE;
    }
#endif

    // copy to member variables
    m_MaxStackSlots      = ILHeader->MaxStack;  
    m_LocalSig           = ILHeader->LocalVarSig;   
    m_MaxLocals          = 0;
    m_CodeSize           = ILHeader->CodeSize;  
    m_pMethodDesc        = pMethodDesc;
    m_pILHeader          = ILHeader;
    m_pModule            = pMethodDesc->GetModule();
    m_pClassLoader       = m_pModule->GetClassLoader();

    m_pCode              = ILHeader->Code;
    m_fIsVarArg          = pMethodDesc->IsVarArg();

#ifdef _DEBUG
    LOG((LF_VERIFIER, LL_INFO10000, "---------- Verifying %s::%s ---------- \n", m_pMethodDesc->m_pszDebugClassName, m_pMethodDesc->GetName()));
    LOG((LF_VERIFIER, LL_INFO10000, "MaxStack=%d, CodeSize=%d\n", m_MaxStackSlots, m_CodeSize));
#endif

    m_pBasicBlockList           = NULL;
    m_pDirtyBasicBlockBitmap    = NULL;

    m_pExceptionList            = NULL;
    m_pExceptionBlockRoot       = NULL;
    m_pExceptionBlockArray      = NULL;
#ifdef _DEBUG
    m_nExceptionBlocks          = 0;
#endif

    m_fHasFinally               = FALSE;
    m_pInternalImport           = m_pModule->GetMDImport();

    if (m_pInternalImport != NULL)
        m_pInternalImport->AddRef();

    if (IsMdRTSpecialName(pMethodDesc->GetAttrs()))
    {
        m_fInClassConstructorMethod = IsMdStatic(pMethodDesc->GetAttrs());
        m_fInConstructorMethod      = !m_fInClassConstructorMethod;
    }
    else
    {
        m_fInClassConstructorMethod = FALSE;
        m_fInConstructorMethod      = FALSE;
    }

    if (m_fInConstructorMethod)
        m_fInValueClassConstructor = pMethodDesc->GetClass()->IsValueClass();
    else
        m_fInValueClassConstructor = FALSE;

    m_pInstrBoundaryList        = NULL;
    m_pBasicBlockBoundaryList   = NULL;

    if (m_MaxStackSlots >= MAX_STACK_SLOTS)
    {
        m_sError.dwFlags = VER_ERR_FATAL;
        SetErrorAndContinue(VER_E_STACK_TOO_LARGE);
        return FALSE;
    }

    if (m_CodeSize == 0)
    {
        m_sError.dwFlags = VER_ERR_FATAL;
        SetErrorAndContinue(VER_E_CODE_SIZE_ZERO);
        return FALSE;
    }

    // read exception structure
    if (!CreateExceptionList(ILHeader->EH))
        return FALSE;

    // If we're verifying a constructor, then argument 0 slot contained the "this" pointer, which
    // is considered to be uninitialised until the superclass constructor is called.
    //
    // If we're verifying Object, the "this" pointer is already initialised.
    // If we're verifying a value class, then the "this" pointer is also already initialised - however in
    // this case we must check that a store is performed into all fields of the value class in the ctor.
    m_fThisUninit = FALSE;

/*
    if (m_fInConstructorMethod)
    {
        if (m_fInValueClassConstructor)
        {
            if (0 != pMethodDesc->GetClass()->GetNumInstanceFields())
            {
                m_fThisUninit = TRUE;
            }
        }
        else if (!pMethodDesc->GetClass()->IsObjectClass())
            m_fThisUninit = TRUE;
    }
*/
    if (m_fInConstructorMethod && 
        !m_fInValueClassConstructor && 
        !pMethodDesc->GetClass()->IsObjectClass())
    {
        m_fThisUninit = TRUE;
    }

    // Determine # args
    m_pMethodDesc->GetSig(&pSig, &cSig);
    VerSig sig(this, m_pModule, pSig, cSig, VERSIG_TYPE_METHOD_SIG, 0); // method sig

    // Something about the signature was not valid
    if (!sig.Init())
    {
        goto exit;
    }

    if (sig.IsVarArg() != m_fIsVarArg)
    {
        m_sError.dwFlags = VER_ERR_METHOD_SIG;
        if (!SetErrorAndContinue(VER_E_BAD_VARARG))
            goto exit;
    }

    m_NumArgs = sig.GetNumArgs();

    // Include the "this" pointer
    if (!m_pMethodDesc->IsStatic())
        m_NumArgs++;

    // Init global typed knowledge of the args
    // Parse return value - void ok
    if (!sig.ParseNextComponentToItem(&m_ReturnValue, TRUE, FALSE, &m_hThrowable, VER_ARG_RET, TRUE))
    {
        goto exit;
    }

    if (m_ReturnValue.IsByRef() || m_ReturnValue.HasPointerToStack())
    {
        m_sError.dwFlags = VER_ERR_METHOD_SIG;
        if (!SetErrorAndContinue(VER_E_RET_PTR_TO_STACK))
            goto exit;
    }

    if (m_LocalSig) 
    {   
        ULONG cSig;

        cSig = 0;

        m_pInternalImport->GetSigFromToken(ILHeader->LocalVarSigTok, &cSig);

        VerSig sig(this, m_pModule, m_LocalSig, cSig, VERSIG_TYPE_LOCAL_SIG, 0);

        // Something about the signature was not valid  
        if (!sig.Init())
        {
            return FALSE;
        }

        m_MaxLocals = sig.GetNumArgs();

        // Allocate an array of types for the local variables and arguments
        m_pLocArgTypeList = new LocArgInfo_t[m_MaxLocals + m_NumArgs];
        if (m_pLocArgTypeList == NULL)
        {
            SET_ERR_OM();
            goto exit;
        }

        for (i = 0; i < m_MaxLocals; i++)
        {
            if (!sig.ParseNextComponentToItem(&m_pLocArgTypeList[i].m_Item, FALSE, FALSE, &m_hThrowable, i, FALSE /*don't normaliseforstack*/))
            {
                return FALSE;
            }

            _ASSERTE(!(m_wFlags & VER_STOP_ON_FIRST_ERROR) || !m_pLocArgTypeList[i].m_Item.IsDead());
        }
    }
    else
    {
        m_MaxLocals = 0;

        // Allocate an array of types for the local variables and arguments
        m_pLocArgTypeList = new LocArgInfo_t[m_NumArgs];
        if (m_pLocArgTypeList == NULL)
        {
            SET_ERR_OM();
            goto exit;
        }
    }

    if (m_MaxLocals > 0)
    {
        m_dwLocalHasPinnedTypeBitmapMemSize = NUM_DWORD_BITMAPS(m_MaxLocals);
        m_pLocalHasPinnedType = new DWORD[m_dwLocalHasPinnedTypeBitmapMemSize];

        // Convert the number of DWORDS to MemSize

        m_dwLocalHasPinnedTypeBitmapMemSize *= sizeof(DWORD);
        if (m_pLocalHasPinnedType == NULL)
        {
            SET_ERR_OM();
            goto exit;
        }

        memset(m_pLocalHasPinnedType, 0, m_dwLocalHasPinnedTypeBitmapMemSize);
    }
    else
    {
        m_pLocalHasPinnedType = NULL;
    }

    CurArg = 0;

    // For instance methods, the first argument is the "this" pointer
    // If a value class, the first argument is a "byref value class"
    if (!m_pMethodDesc->IsStatic())
    {
        Item *pGlobalArg0Type = &GetGlobalArgTypeInfo(0)->m_Item;

        pGlobalArg0Type->SetTypeHandle(TypeHandle(m_pMethodDesc->GetMethodTable()));
        
        // Make into byref if a value class
        if (m_pMethodDesc->GetClass()->IsValueClass())
        {
            pGlobalArg0Type->MakeByRef();
            pGlobalArg0Type->SetIsPermanentHomeByRef();
        }

        // For non-constructor methods, we don't care about tracking the "this" pointer.
        // Also, it would prevent someone from storing a different objref into argument slot 0,
        // because that objref would not have the "this ptr" flag, and would fail the
        // CompatibleWith() test
        if (m_fInConstructorMethod)
            pGlobalArg0Type->SetIsThisPtr();

        CurArg++;
    }

    while (CurArg < m_NumArgs)
    {
        Item *pItem = &GetGlobalArgTypeInfo(CurArg)->m_Item;

        // void parameter not ok
        if (!sig.ParseNextComponentToItem(pItem, FALSE, FALSE, &m_hThrowable, CurArg, FALSE))
        {
            return FALSE;
        }

        // We don't set the IsPermanentHomeByRef flag here, because this is the global type of
        // the argument.  If we did this, then any attempt to store something which did not have
        // a permanent home, into the argument, would not be allowed (because of the way which
        // CompatibleWith() works).

        CurArg++;
    } 

    // Allocate 2 sentinel nodes before the beginning of the stack, so that if we attempt to
    // Pop(Type), we don't need to check for overflow - the sentinel value will get it.
    m_pStack = new Item[m_MaxStackSlots + 2];
    
    if (m_pStack == NULL)
    {
        SET_ERR_OM();
        goto exit;
    }

    // advance pointer
    m_pStack += 2;

    // set sentinel values
    m_pStack[-1].SetType(VER_ELEMENT_TYPE_SENTINEL);
    m_pStack[-2].SetType(VER_ELEMENT_TYPE_SENTINEL);

    // current position in stack
    m_StackSlot     = 0;

    fSuccess = TRUE;

exit:
    if (!fSuccess)
    {
        if (m_pStack != NULL)
        {
            // -2 because m_pStack points into the middle of the array - there are two sentinel
            // values before it
            delete [] (m_pStack - 2);
            m_pStack = NULL;
        }

        if (m_pLocArgTypeList != NULL)
        {
            delete(m_pLocArgTypeList);
            m_pLocArgTypeList = NULL;
        }
    }

    return fSuccess;
}

//
// FindBasicBlockBoundaries()
//
// This method performs the following tasks:
// - Computes basic block boundaries and marks them in a bitmap
// - Computes instruction start points and marks them in a bitmap
// - Computes count of basic blocks
// - Determines which locals we take the address of (if someone takes the address of an objref
//      local anywhere in the method, then we "pin" the type of the local to its declared type,
//      to avoid the aliasing issue)
//
HRESULT Verifier::FindBasicBlockBoundaries(
    const BYTE *pILCode, 
    DWORD       cbILCodeSize, 
    DWORD       MaxLocals, 
    DWORD *     BasicBlockCount, 
    DWORD *     pAddressTakenOfLocals   // Bitmap must already be zeroed!
)
{
    HRESULT     return_hr       = E_FAIL;
    DWORD       ipos            = 0;                    // instruction position
    DWORD       NumBasicBlocks  = 1;
    BOOL        fError          = FALSE;                // for SAFE_READU4() and SAFE_READU1()
    DWORD       dwPCAtStartOfInstruction = 0;
    BOOL        fTailCall       = FALSE;
    BOOL        fVolatile       = FALSE;
    BOOL        fUnaligned      = FALSE;
    OPCODE      opcode = CEE_COUNT, prefixOpcode = CEE_COUNT;


    _ASSERTE(cbILCodeSize > 0);

#ifdef _DEBUG
    _ASSERTE(m_verState == verExceptListCreated);
    m_verState = verPassOne;
#endif

    SET_BB_BOUNDARY(0);

    while (ipos < cbILCodeSize)
    {
        DWORD   offset = 0;
        DWORD   OpcodeLen;
        DWORD   DestInstrPos;
        DWORD   inline_operand = 0;

        // record that an instruction starts here
        SET_INSTR_BOUNDARY(ipos);

        dwPCAtStartOfInstruction = ipos;

        opcode = Verifier::SafeDecodeOpcode(&pILCode[ipos], cbILCodeSize - ipos, &OpcodeLen);

        ipos += OpcodeLen;

#ifdef _DEBUG
        if (m_fDebugBreak)
        {
            if (g_pConfig->IsVerifierBreakOffsetEnabled() &&
                (g_pConfig->GetVerifierBreakOffset() == 
                (int) dwPCAtStartOfInstruction) &&
                (!g_pConfig->IsVerifierBreakPassEnabled() ||
                (g_pConfig->GetVerifierBreakPass() == 1)))
            {
                DebugBreak();
            }
        }
#endif

        _ASSERTE(!(m_wFlags & VER_STOP_ON_FIRST_ERROR) || !fTailCall);
        _ASSERTE(!(m_wFlags & VER_STOP_ON_FIRST_ERROR) || !fUnaligned);
        _ASSERTE(!(m_wFlags & VER_STOP_ON_FIRST_ERROR) || !fVolatile);

        switch (opcode)
        {
            // Do not add a case CEE_CALL, CEE_CALLVIRT, CEE_CALLI
            // If one is introduced, modify code in CEE_TAIL to handle this.

            // Check for error
            case CEE_COUNT:
            case CEE_ILLEGAL:
            {
                m_sError.dwFlags = VER_ERR_OFFSET; // opcode is non-standard
                SET_ERR_OPCODE_OFFSET();
                SetErrorAndContinue(VER_E_UNKNOWN_OPCODE);
                goto exit;
            }

            // Check for prefix opcodes
            case CEE_TAILCALL:
            {
                if (ipos >= cbILCodeSize)
                {
                    goto tail_call_error;
                }
    
                // Parse a new instruction after a 'tailcall'. we do not mark 
                // the pc as an instruction boundary.
                // Do not do a SET_INSTR_BOUNDARY for the calls.

                opcode = Verifier::SafeDecodeOpcode(&pILCode[ipos], cbILCodeSize - ipos, &OpcodeLen);

                if (opcode != CEE_CALL && 
                    opcode != CEE_CALLVIRT && 
                    opcode != CEE_CALLI)
                {
tail_call_error:
                    m_sError.dwFlags = VER_ERR_OPCODE_OFFSET;
                    SET_ERR_OPCODE_OFFSET();
                    if (SetErrorAndContinue(VER_E_TAIL_CALL))
                        break;
                    goto exit;
                }
    
                dwPCAtStartOfInstruction = ipos;
                ipos += OpcodeLen;

                fTailCall = TRUE;

                break;
            }

            // The unaligned. and volatile. prefixes may be combined in either 
            // order. They must immediately precede a ldind, stind, ldfld, 
            // stfld,  ldobj, stobj, initblk, or cpblk instruction.
            // Only the volatile. prefix is allowed for the ldsfld and stsfld 
            // instructions.

            case CEE_VOLATILE:
            {
start_volatile:
                if (fVolatile)
                    goto volatile_unaligned_error;
                fVolatile = TRUE;
                goto start_common;
            }

            case CEE_UNALIGNED:
            {
start_unaligned:
                if (fUnaligned)
                    goto volatile_unaligned_error;
                fUnaligned = TRUE;

                // Read U1
                SAFE_READU1(pILCode, cbILCodeSize, ipos, fError, inline_operand);
                if (fError)
                    goto operand_missing_error;

start_common:
                prefixOpcode = opcode;
                if (ipos >= cbILCodeSize)
                {
volatile_unaligned_error:
                    m_sError.dwFlags  = VER_ERR_OPCODE_OFFSET;
                    m_sError.opcode   = prefixOpcode;
                    m_sError.dwOffset = dwPCAtStartOfInstruction;
                    if (SetErrorAndContinue((prefixOpcode == CEE_VOLATILE) ? VER_E_VOLATILE : VER_E_UNALIGNED))
                    {
                        _ASSERTE((m_wFlags & VER_STOP_ON_FIRST_ERROR) == 0);
                        fVolatile = FALSE;
                        fUnaligned = FALSE;
                        break;
                    }
                    goto exit;
                }
    
                // Parse a new instruction after a '.volatile/.unaligned'. 
                // we do not mark the pc as an instruction boundary.
                // Do not do a SET_INSTR_BOUNDARY for the calls.

                opcode = Verifier::SafeDecodeOpcode(&pILCode[ipos], cbILCodeSize - ipos, &OpcodeLen);

                switch (opcode)
                {
                case CEE_LDIND_I1:
                case CEE_LDIND_U1:
                case CEE_LDIND_I2:
                case CEE_LDIND_U2:
                case CEE_LDIND_I4:
                case CEE_LDIND_U4:
                case CEE_LDIND_I8:
                case CEE_LDIND_I:
                case CEE_LDIND_R4:
                case CEE_LDIND_R8:
                case CEE_LDIND_REF:
                case CEE_STIND_REF:
                case CEE_STIND_I1:
                case CEE_STIND_I2:
                case CEE_STIND_I4:
                case CEE_STIND_I8:
                case CEE_STIND_R4:
                case CEE_STIND_R8:
                case CEE_STIND_I:
                case CEE_LDFLD:
                case CEE_STFLD:
                case CEE_LDOBJ:
                case CEE_STOBJ:
                case CEE_INITBLK:
                case CEE_CPBLK:
                    break;

                case CEE_VOLATILE:
                    dwPCAtStartOfInstruction = ipos;
                    ipos += OpcodeLen;
                    goto start_volatile;

                case CEE_UNALIGNED:
                    dwPCAtStartOfInstruction = ipos;
                    ipos += OpcodeLen;
                    goto start_unaligned;

                case CEE_LDSFLD:
                case CEE_STSFLD:
                    if (!fUnaligned)
                        break;
                    // else follow thru to error case;
                    prefixOpcode = CEE_UNALIGNED;

                default:    // error case
                    goto volatile_unaligned_error;
                }
    
                dwPCAtStartOfInstruction = ipos;
                ipos += OpcodeLen;

                fVolatile = FALSE;
                fUnaligned = FALSE;

                break;
            }

            case CEE_ENDFILTER:
            {
                if (!AddEndFilterPCToFilterBlock(dwPCAtStartOfInstruction))
                {
                    m_sError.dwFlags = VER_ERR_OPCODE_OFFSET;
                    SET_ERR_OPCODE_OFFSET();
                    if (!SetErrorAndContinue(VER_E_ENDFILTER))
                        goto exit;
                }
                // don't break here
            }

            // For tracking the last instruction in the method.
            case CEE_RET:
            case CEE_THROW:
            case CEE_RETHROW:
            case CEE_ENDFINALLY:
            {
handle_ret:
                // Mark that a basic block starts at the instruction after the RET/THROW.
                // It is ok if we are at the last instruction in the method - we allocated enough space
                // to mark a BB starting @ m_CodeSize
                if (ON_BB_BOUNDARY(ipos) == 0)
                {
                    SET_BB_BOUNDARY(ipos);
                    NumBasicBlocks++;
                }

                continue;   // No further processing of this instruction is required.
            }
        }

        switch (OpcodeData[opcode])
        {
            case InlineNone:
                break;

            case ShortInlineVar:    
            case ShortInlineI:    
                SAFE_READU1(pILCode, cbILCodeSize, ipos, fError, inline_operand);
                if (fError)
                {
operand_missing_error:
                    m_sError.dwFlags = (VER_ERR_FATAL|VER_ERR_OPCODE_OFFSET);
                    SET_ERR_OPCODE_OFFSET();
                    SetErrorAndContinue(VER_E_METHOD_END);
                    goto exit;
                }
                break;

            case InlineVar:    
                SAFE_READU2(pILCode, cbILCodeSize, ipos, fError, inline_operand);
                if (fError)
                    goto operand_missing_error;
                break;

            case InlineField:   
            case InlineType:   
            case InlineMethod:   
            case InlineTok:   
                SAFE_READU4(pILCode, cbILCodeSize, ipos, fError, inline_operand);
                if (fError)
                    goto operand_missing_error;

                if (!m_pInternalImport->IsValidToken(inline_operand))
                {
                    FAILMSG_TOKEN_RESOLVE(inline_operand);
                    goto exit;
                }

                break;

            case InlineI:   
            case ShortInlineR:   
            case InlineRVA:   
            case InlineString:   
            case InlineSig:
                SAFE_READU4(pILCode, cbILCodeSize, ipos, fError, inline_operand);
                if (fError)
                    goto operand_missing_error;
                break;

            case InlineI8:    
            case InlineR:    
                if (RUNS_OFF_END(ipos, 8, cbILCodeSize))
                    goto operand_missing_error;

                ipos += 8;
                break;

            case HackInlineAnnData:
                SAFE_READU4(pILCode, cbILCodeSize, ipos, fError, inline_operand);

                if ((fError) || 
                    (RUNS_OFF_END(ipos, inline_operand, cbILCodeSize)))
                    goto operand_missing_error;

                ipos += inline_operand;
                break;

            case InlinePhi:
                SAFE_READU1(pILCode, cbILCodeSize, ipos, fError, inline_operand);

                if ((fError) ||
                    (RUNS_OFF_END(ipos, inline_operand * 2, cbILCodeSize)))
                    goto operand_missing_error;

                ipos += (inline_operand * 2);
                break;


            default:
                m_sError.dwFlags = VER_ERR_OFFSET; // opcode is non-standard
                SET_ERR_OPCODE_OFFSET();
                SetErrorAndContinue(VER_E_UNKNOWN_OPCODE);
                goto exit;

            case ShortInlineBrTarget:   
                SAFE_READI1_TO_I4(pILCode, cbILCodeSize, ipos, fError, offset);
                if (fError)
                    goto operand_missing_error;
                goto handle_branch;

            case InlineBrTarget:   

                SAFE_READU4(pILCode, cbILCodeSize, ipos, fError, offset);
                if (fError)
                    goto operand_missing_error;
handle_branch:
                // checks that ipos+dest >= 0 && ipos+dest < m_CodeSize
                DestInstrPos = ipos + offset;
                if (DestInstrPos >= cbILCodeSize)
                {
branch_error:
                    m_sError.dwFlags = 
                        (VER_ERR_FATAL|VER_ERR_OPERAND|VER_ERR_OPCODE_OFFSET);
                    m_sError.dwOperand = offset;
                    SET_ERR_OPCODE_OFFSET();
                    SetErrorAndContinue(VER_E_BAD_BRANCH);
                    goto exit;
                }

                // if we haven't already marked the destination as being the start of a basic
                // block, do so now, and update # basic blocks
                if (ON_BB_BOUNDARY(DestInstrPos) == 0)
                {
                    SET_BB_BOUNDARY(DestInstrPos);
                    NumBasicBlocks++;
                }
                
                if (ipos >= cbILCodeSize && 
                    opcode != CEE_BR     && opcode != CEE_BR_S &&
                    opcode != CEE_LEAVE  && opcode != CEE_LEAVE_S) 
                {
                    m_sError.dwFlags = VER_ERR_OPCODE_OFFSET;
                    SET_ERR_OPCODE_OFFSET();
                    if (SetErrorAndContinue(VER_E_FALLTHRU))
                        goto exit;
                }

                // handle "fallthrough" basic block case (even if an unconditional branch).

                // if we haven't already marked the fallthrough case as being the start of a basic
                // block, do so now, and update # basic blocks
                if (ON_BB_BOUNDARY(ipos) == 0)
                {
                    SET_BB_BOUNDARY(ipos);
                    NumBasicBlocks++;
                }

                break;

            case InlineSwitch:
            {
                DWORD       NumCases = 0;
                DWORD       i;
                SAFE_READU4(pILCode, cbILCodeSize, ipos, fError, NumCases);

                if (fError)
                    goto operand_missing_error;

                DWORD NextInstrPC = ipos + 4*NumCases;
                // @FUTURE: can optimise this by moving the EOF check inside SAFE_READU4() outside of 
                // the loop, but be careful about overflow (e.g. NumCases == 0xFFFFFFFF)
                for (i = 0; i <= NumCases; i++)
                {
                    if (i == NumCases)
                    {
                        DestInstrPos = ipos;
                    }
                    else
                    {
                        SAFE_READU4(pILCode, cbILCodeSize, ipos, fError, offset);
                        if (fError)
                        {
                            goto operand_missing_error;
                        }

                        DestInstrPos = NextInstrPC + offset;
                    }

                    // checks that ipos+dest >= 0 && ipos+dest < m_CodeSize
                    if (DestInstrPos >= cbILCodeSize)
                    {
                        goto branch_error;
                    }

                    // if we haven't already marked the destination as being the start of a basic
                    // block, do so now, and update # basic blocks
                    if (ON_BB_BOUNDARY(DestInstrPos) == 0)
                    {
                        SET_BB_BOUNDARY(DestInstrPos);
                        NumBasicBlocks++;
                    }
                }
                break;

            } /* end InlineSwitch */

        } /* end switch */

        // Handle all special cases
        switch (opcode)
        {
            case CEE_LDLOCA:
            case CEE_LDLOCA_S:
            {
                if (inline_operand < MaxLocals)
                    pAddressTakenOfLocals[inline_operand >> 5] |= (1 << (inline_operand & 31));

                break;
            }

            // handle suffix
            case CEE_CALL:
            case CEE_CALLVIRT:
            case CEE_CALLI:
            {
                // if this is a tail call, then a return should follow.

                if (!fTailCall)
                    break;

                fTailCall = FALSE;

                if (ipos >= cbILCodeSize)
                {
                    m_sError.dwFlags = VER_ERR_OPCODE_OFFSET;
                    SET_ERR_OPCODE_OFFSET();
                    if (!SetErrorAndContinue(VER_E_TAIL_RET))
                        goto exit;
                }
    
                // Ok to mark this return as an instruction boundary.

                SET_INSTR_BOUNDARY(ipos);

                opcode = Verifier::SafeDecodeOpcode(&pILCode[ipos], cbILCodeSize - ipos, &OpcodeLen);

                if (opcode != CEE_RET)
                {
                    m_sError.dwFlags = VER_ERR_OPCODE_OFFSET;
                    SET_ERR_OPCODE_OFFSET();
                    if (!SetErrorAndContinue(VER_E_TAIL_RET))
                        goto exit;
                }
                else
                {
                    dwPCAtStartOfInstruction = ipos;
                    ipos += OpcodeLen;
                    
                    goto handle_ret;
                }
            }
        }
    }
    

    // ensure we reached the CodeSize exactly, and didn't overshoot it
    if (ipos != cbILCodeSize)
    {
        m_sError.dwFlags = (VER_ERR_FATAL|VER_ERR_OPCODE_OFFSET);
        SET_ERR_OPCODE_OFFSET();
        SetErrorAndContinue(VER_E_FALLTHRU);
        goto exit;
    }

    // If there was a br, ret, throw, etc. as the last instruction, it would put a basic block
    // right after that instruction, @ m_CodeSize.  So if we don't have a basic block there, then
    // we can fall off the end of the code.
    if (ON_BB_BOUNDARY(cbILCodeSize) == 0)
    {
        m_sError.dwFlags = (VER_ERR_FATAL|VER_ERR_OFFSET|VER_ERR_OPCODE);
        SET_ERR_OPCODE_OFFSET();
        SetErrorAndContinue(VER_E_FALLTHRU);
        goto exit;
    }

    // Remove that fake basic block from the end
    RESET_BB_BOUNDARY(cbILCodeSize);
    NumBasicBlocks--;

    *BasicBlockCount = NumBasicBlocks;

    // success

    return_hr = S_OK;

exit:
    return return_hr;
}

/*
 *  Construct m_pExceptionList, an array of VerExceptionInfo objects, one
 *  for each exception clause, and verify the structural integrity of the 
 *  list of exceptions.
 *
 *  This function is called before the first pass. The filter block size is 
 *  not known at this time. Set filter end = filter start for now. Filter end 
 *  will be set in the first pass.
 *
 *  An exception is one of the following :
 *      Catch   : try, catch_handler
 *      Filter  : try, filter, filter_handler
 *      Finally : try, finally_handler
 *
 *  Exception clause consist of :
 *      flag : Catch / Filter / Finally
 *      try_start
 *      try_length
 *      filter_start
 *      handler_start
 *      handler_length
 *
 *  Exception Structural checks (1) :
 *      tryStart     <= tryEnd     <= CodeSize
 *      handlerStart <= handlerEnd <= CodeSize
 *      filterStart  <  CodeSize
 *
 */

BOOL Verifier::CreateExceptionList(const COR_ILMETHOD_SECT_EH* ehInfo)
{
    DWORD i;
    mdTypeRef tok;      // ClassToken for the Catch clause

    m_pExceptionList = NULL;    
    m_NumExceptions = 0;

    if (ehInfo == 0 || ((m_NumExceptions = ehInfo->EHCount()) == 0))  
        goto success;

    m_pExceptionList = new VerExceptionInfo[m_NumExceptions];

    if (m_pExceptionList == NULL)
    {
        SET_ERR_OM();
        goto error;
    }

    for (i = 0; i < m_NumExceptions; i++)
    {
        VerExceptionInfo& c = m_pExceptionList[i];

        IMAGE_COR_ILMETHOD_SECT_EH_CLAUSE_FAT ehBuff; 
        const IMAGE_COR_ILMETHOD_SECT_EH_CLAUSE_FAT* ehClause = 
            ehInfo->EHClause(i, &ehBuff); 

        c.dwTryXX           = ehClause->TryOffset;
        c.dwTryEndXX        = ehClause->TryOffset + ehClause->TryLength;
        c.dwHandlerXX       = ehClause->HandlerOffset;
        c.dwHandlerEndXX    = ehClause->HandlerOffset + ehClause->HandlerLength;
        c.eFlags            = ehClause->Flags;
        
        tok                 = ehClause->ClassToken;

        if (c.eFlags & COR_ILEXCEPTION_CLAUSE_FILTER)
        {
            // FilterEndXX is set to 0 for now.
            // Verify this after the first pass, where FilterEnd will
            // get set. FilterEnd is mandatory and unique for a filter block.

            // try.. filter ... handler
            c.dwFilterXX = ehClause->FilterOffset;
            c.dwFilterEndXX = 0;

        }
        else if (c.eFlags & COR_ILEXCEPTION_CLAUSE_FINALLY)
        {
            // try.. finally
            m_fHasFinally = TRUE;
            c.thException = TypeHandle(g_pObjectClass); 
        }
        else if (c.eFlags & COR_ILEXCEPTION_CLAUSE_FAULT)
        {
            // try.. fault
            c.thException = TypeHandle(g_pObjectClass); 
        }
        else 
        {
            // try.. catch
            
            NameHandle name(m_pModule, tok);

            if (TypeFromToken(tok) != mdtTypeRef &&
                TypeFromToken(tok) != mdtTypeDef &&
                TypeFromToken(tok) != mdtTypeSpec)
                goto BadToken;

            if (!m_pInternalImport->IsValidToken(tok))
                goto BadToken;

            c.thException = m_pClassLoader->LoadTypeHandle(&name);

            if (c.thException.IsNull())
            {
BadToken:
                m_sError.dwFlags = (VER_ERR_EXCEP_NUM_1|VER_ERR_TOKEN);
                m_sError.token = tok;
                m_sError.dwException1 = i;
                if (!SetErrorAndContinue(VER_E_TOKEN_RESOLVE))
                    goto error;
                c.thException = TypeHandle(g_pObjectClass);
            }

            if (c.thException.GetMethodTable()->IsValueClass())
            {
                m_sError.dwFlags = VER_ERR_EXCEP_NUM_1;
                m_sError.dwException1 = i;
                if (!SetErrorAndContinue(VER_E_CATCH_VALUE_TYPE))
                    goto error;
            }
        }

#if 0
        LOG((LF_VERIFIER, LL_INFO10, "Exception: try PC [0x%x...0x%x], ",
            c.dwTryXX,
            c.dwTryEndXX
        ));

        if (c.eFlags & COR_ILEXCEPTION_CLAUSE_FILTER)
        {            
            LOG((LF_VERIFIER, LL_INFO10, 
                "filter PC 0x%x, handler PC [0x%x, 0x%x]\n",
                c.dwFilterXX, c.dwHandlerXX, c.dwHandlerEndXX));

        }
        else if (c.eFlags & COR_ILEXCEPTION_CLAUSE_FAULT)
        {
            LOG((LF_VERIFIER, LL_INFO10, 
                "fault handler PC [0x%x, 0x%x]\n",
                c.dwHandlerXX, c.dwHandlerEndXX));

        }
        else if (c.eFlags & COR_ILEXCEPTION_CLAUSE_FINALLY)
        {
            LOG((LF_VERIFIER, LL_INFO10, 
                "finally handler PC [0x%x, 0x%x]\n",
                c.dwHandlerXX, c.dwHandlerEndXX));

        }
        else
        {
            LOG((LF_VERIFIER, LL_INFO10, 
                "catch %s, handler PC [0x%x, 0x%x]\n",
                c.thException.GetClass()->m_szDebugClassName,
                c.dwHandlerXX, c.dwHandlerEndXX));
        }
#endif


       /*
        *  Exception Structural checks (1) :
        *
        *      tryStart     <= tryEnd     <= CodeSize
        *      handlerStart <= handlerEnd <= CodeSize
        *      filterStart  <  CodeSize
        *
        *
        *   NOTE : filterEnd is not known at this time
        *
        *   During first pass, filterEnd will be set to something <= CodeSize
        *   and > filterStart. At the end of first pass, it is sufficient to 
        *   see if filterEnd is != 0 to verify :
        *
        *   filterStart <= filterEnd <= CodeSize.
        *
        *   See : AddEndFilterPCToFilterBlock()
        * 
        */

        if (c.dwTryXX >= c.dwTryEndXX)
        {
            m_sError.dwFlags = VER_ERR_EXCEP_NUM_1|VER_ERR_FATAL;
            m_sError.dwException1 = i;
            SetErrorAndContinue(VER_E_TRY_GTEQ_END);
            goto error;
        }

        if (c.dwTryEndXX > m_CodeSize)
        {
            m_sError.dwFlags = VER_ERR_EXCEP_NUM_1|VER_ERR_FATAL;
            m_sError.dwException1 = i;
            SetErrorAndContinue(VER_E_TRYEND_GT_CS);
            goto error;
        }

        if (c.dwHandlerXX >= c.dwHandlerEndXX)
        {
            m_sError.dwFlags = VER_ERR_EXCEP_NUM_1|VER_ERR_FATAL;
            m_sError.dwException1 = i;
            SetErrorAndContinue(VER_E_HND_GTEQ_END);
            goto error;
        }

        if (c.dwHandlerEndXX > m_CodeSize)
        {
            m_sError.dwFlags = VER_ERR_EXCEP_NUM_1|VER_ERR_FATAL;
            m_sError.dwException1 = i;
            SetErrorAndContinue(VER_E_HNDEND_GT_CS);
            goto error;
        }

        if ((c.eFlags & COR_ILEXCEPTION_CLAUSE_FILTER) &&
            (c.dwFilterXX >= m_CodeSize))
        {
            m_sError.dwFlags = VER_ERR_EXCEP_NUM_1|VER_ERR_FATAL;
            m_sError.dwException1 = i;
            SetErrorAndContinue(VER_E_FIL_GTEQ_CS);
            goto error;
        }
    }

success:

#ifdef _DEBUG
    _ASSERTE(m_verState == verUninit);
    m_verState = verExceptListCreated;
#endif
    return TRUE;

error:

    return FALSE;
}

/*
 * endfilter instruction marks the end of a filter block.
 *
 * There should be only one endfilter instruction in a filter block.
 * On failure, *pcError is set to the pc where an unexpected endfilter 
 * was found. This handles the case when a method has no exceptions declared.
 *
 * FilterEnd / FilterLength is not supplied by MetaData, hence this function.
 *
 * Set all Filters that are "likely" to be associated with this endfilter.
 * Earlier sets will be reset if pc is closer to the previous entry stored.
 *
 * This function will detect the case where there is more than one endfilter
 * for a handler if the endfilters are added in the order in which they are
 * seen in the IL (added in the first pass).
 *
 * However, it won't catch the case where an end filter is shared between
 * handlers starting at different locations.
 *
 */
BOOL Verifier::AddEndFilterPCToFilterBlock(DWORD pc)
{
    _ASSERTE(m_verState == verPassOne);

    BOOL  fFoundAtleaseOne = FALSE;

    /*
     * Find the FilterStart that starts just before this filterEnd.
     * Filters of different trys should be the same or disjoint.
     *
     * filterStart ... endfilter ... filterStart ... endfilter
     *
     * There should be one and only one endfilter instruction between
     * two filterStart blocks.
     *
     * If dwFilterEndXX is already set, that implies that there was another
     * endfilter closer than this one since this function is called in the
     * first pass, where instructions are scaned in the order in which they
     * appear in the IL stream.
     *
     * This search is N*N on the number of exceptions in a method.
     *
     */
    for (DWORD i=0; i<m_NumExceptions; ++i)
    {
        VerExceptionInfo& e = m_pExceptionList[i];

        // If there is a filter handler that starts before 'pc' and it's
        // corresponding endfilter is not yet set, then this one is the
        // endfilter that will be nearest to it

        if (( e.eFlags & COR_ILEXCEPTION_CLAUSE_FILTER) &&
            ( e.dwFilterXX <= pc) &&
            ( e.dwFilterEndXX == 0))
        {
            e.dwFilterEndXX = pc + SIZEOF_ENDFILTER_INSTRUCTION;
            fFoundAtleaseOne = TRUE;
        }
    }

    return fFoundAtleaseOne;
}

/*
 * Marks the exception block start/end as basic block boundaries.
 *
 *  Exception Structural checks (2) :
 *
 *      try / handler / filter blocks of the same exception should be disjoint
 *
 *      The order in which exceptions are declared in metadata should be
 *      inner most try block first.
 *
 *      Exception blocks should either be disjoint or one should fully contain
 *      the other.
 *
 *      A try block cannot appear within a filter block.
 *
 *
 */
BOOL Verifier::MarkExceptionBasicBlockBoundaries(
                                   DWORD *pNumBasicBlocks,
                                   DWORD *pnFilter)
{
    // This method is called only after Instruction boundaries are marked
    // by the first pass.

    DWORD BasicBlockCount = *pNumBasicBlocks;
    DWORD nFilter = 0;

    _ASSERTE(m_verState < verExceptToBB);
    
    // Add exception handlers and try blocks to basic block list

    /*  Control flow for exceptions
     *
     *  1.  try     { .. leave <offset> | throw .. }
     *      catch   { .. leave <offset> | throw | rethrow .. }
     *
     *  2.  try     { .. leave <offset> | throw .. }
     *      fault   { .. leave <offset> | throw | rethrow .. | endfinally }
     *
     *  3.  try     { .. leave <offset> | throw .. }
     *      finally { .. endfinally .. }
     *
     *  4.  try     { .. leave <offset> | throw .. }
     *      filter  { .. endfilter }
     *      catch   { .. leave <offset> | throw | rethrow .. }
     *
     */
    for (DWORD i = 0; i <m_NumExceptions; i++)
    {
        VerExceptionInfo& e = m_pExceptionList[i];

        // Try Start
        if (ON_BB_BOUNDARY(e.dwTryXX) == 0)
        {
            SET_BB_BOUNDARY(e.dwTryXX);
            BasicBlockCount++;
        }

        // Try End begins another block (which may not be visited in Pass II)
        // if there is no control flow to it.
        if (ON_BB_BOUNDARY(e.dwTryEndXX) == 0)
        {
            if (e.dwTryEndXX != m_CodeSize)
            {
                SET_BB_BOUNDARY(e.dwTryEndXX);
                BasicBlockCount++;
            }
        }

        // catch / finally / fault handler
        if (ON_BB_BOUNDARY(e.dwHandlerXX) == 0)
        {
            SET_BB_BOUNDARY(e.dwHandlerXX);
            BasicBlockCount++;
        }

        // catch / finally / fault handler end
        if (ON_BB_BOUNDARY(e.dwHandlerEndXX) == 0)
        {
            if (e.dwHandlerEndXX != m_CodeSize)
            {
                SET_BB_BOUNDARY(e.dwHandlerEndXX);
                BasicBlockCount++;
            }
        }

        // filter ends with a unique endfilter instruction which is found
        // in this pass.
        if (e.eFlags & COR_ILEXCEPTION_CLAUSE_FILTER)
        {
            ++nFilter;

            // dwFilterEndXX is found during the first pass.
            // If present, it is verified to be on or after FilterStart
            // and before CodeSize.

            if (e.dwFilterEndXX == 0)
            {
                m_sError.dwFlags = VER_ERR_EXCEP_NUM_1;
                m_sError.dwException1 = i;
                SetErrorAndContinue(VER_E_ENDFILTER_MISSING);
                goto error;
            }

            // filter start
            if (ON_BB_BOUNDARY(e.dwFilterXX) == 0)
            {
                SET_BB_BOUNDARY(e.dwFilterXX);
                BasicBlockCount++;
            }

            // filter end
            if (ON_BB_BOUNDARY(e.dwFilterEndXX) == 0)
            {
                if (e.dwFilterEndXX != m_CodeSize)
                {
                    SET_BB_BOUNDARY(e.dwFilterEndXX);
                    BasicBlockCount++;
                }
            }
        }

        // CreateExceptionList() already verified that all exceptions are 
        // bounded within the code size, so we can look at the bitmap without 
        // bounds checking.
        // try ... filter ... handler are in a contiguous block of IL 
        // instructions. This was also verified by CreateExceptionList().

#ifdef _DEBUG
        if (m_wFlags & VER_STOP_ON_FIRST_ERROR)
        {
            _ASSERTE(e.dwTryXX        <  e.dwTryEndXX);
            _ASSERTE(e.dwTryEndXX     <= m_CodeSize);
            _ASSERTE(e.dwHandlerXX    <  e.dwHandlerEndXX);
            _ASSERTE(e.dwHandlerEndXX <= m_CodeSize);
        }
#endif

        // It is already verified that the exception StartPC, filter StartPC, 
        // handler StartPC  are on an instruction boundary.

#ifdef _DEBUG
        // These will be checked later in free build.
        if (!ON_INSTR_BOUNDARY(e.dwTryXX))
        {
            m_sError.dwFlags = VER_ERR_EXCEP_NUM_1;
            m_sError.dwException1 = i;
            if (!SetErrorAndContinue(VER_E_TRY_START))
                goto error;
        }

        if (!ON_INSTR_BOUNDARY(e.dwHandlerXX))
        {
            m_sError.dwFlags = VER_ERR_EXCEP_NUM_1;
            m_sError.dwException1 = i;
            if (!SetErrorAndContinue(VER_E_HND_START))
                goto error;
        }

        if (e.eFlags & COR_ILEXCEPTION_CLAUSE_FILTER)
        {
            _ASSERTE(e.dwFilterXX    <  e.dwFilterEndXX);
            _ASSERTE(e.dwFilterEndXX <= m_CodeSize);

            if (!ON_INSTR_BOUNDARY(e.dwFilterXX))
            {
                m_sError.dwFlags = VER_ERR_EXCEP_NUM_1;
                m_sError.dwException1 = i;
                if (!SetErrorAndContinue(VER_E_FIL_START))
                    goto error;
            }
        }

        LOG((LF_VERIFIER, LL_INFO10000, 
            "Exception: try PC [0x%x...0x%x], ", e.dwTryXX, e.dwTryEndXX));

        if (e.eFlags & COR_ILEXCEPTION_CLAUSE_FILTER)
        {            
            LOG((LF_VERIFIER, LL_INFO10000, 
                "filter PC [0x%x, 0x%x], handler PC [0x%x, 0x%x]\n",
                e.dwFilterXX, e.dwFilterEndXX, e.dwHandlerXX,
                e.dwHandlerEndXX));

        }
        else if (e.eFlags & COR_ILEXCEPTION_CLAUSE_FAULT)
        {
            LOG((LF_VERIFIER, LL_INFO10000,  "fault handler PC [0x%x, 0x%x]\n", 
                e.dwHandlerXX, e.dwHandlerEndXX));

        }
        else if (e.eFlags & COR_ILEXCEPTION_CLAUSE_FINALLY)
        {
            LOG((LF_VERIFIER, LL_INFO10000,  "finally handler PC [0x%x, 0x%x]\n", 
                e.dwHandlerXX, e.dwHandlerEndXX));

        }
        else
        {
            LOG((LF_VERIFIER, LL_INFO10000, "catch %s, handler PC [0x%x, 0x%x]\n",
                e.thException.GetClass()->m_szDebugClassName,
                e.dwHandlerXX, e.dwHandlerEndXX));
        }
#endif
    }

    *pNumBasicBlocks = BasicBlockCount;
    *pnFilter = nFilter;

    return TRUE;

error:

    return FALSE;
}


// Convert exception list PC values to Basic Block values.
// EndPC becomes a non-inclusive BasicBlock number.
void Verifier::RewriteExceptionList()
{
    _ASSERTE(m_verState < verExceptToBB);

    for (DWORD i = 0; i < m_NumExceptions; i++)
    {
        VerExceptionInfo& e = m_pExceptionList[i];

        e.dwTryXX     = FindBasicBlock(e.dwTryXX);

        if (e.dwTryEndXX == m_CodeSize)
            e.dwTryEndXX = m_NumBasicBlocks;
        else
            e.dwTryEndXX = FindBasicBlock(e.dwTryEndXX);

        e.dwHandlerXX   = FindBasicBlock(e.dwHandlerXX);

        if (e.dwHandlerEndXX == m_CodeSize)
            e.dwHandlerEndXX = m_NumBasicBlocks;
        else
            e.dwHandlerEndXX = FindBasicBlock(e.dwHandlerEndXX);

        if ((e.eFlags & COR_ILEXCEPTION_CLAUSE_FILTER))
        {
            e.dwFilterXX    = FindBasicBlock(e.dwFilterXX);

            if (e.dwFilterEndXX == m_CodeSize)
                e.dwFilterEndXX = m_NumBasicBlocks;
            else
                e.dwFilterEndXX = FindBasicBlock(e.dwFilterEndXX);
        }
    }

#ifdef _DEBUG
    m_verState = verExceptToBB;
#endif
}


// An Exception block represents the set of basic blocks in a try / filter / 
// handler block.
//
// @VER_ASSERT a try / filter / handler is composed of contigious stream of IL.
//
//
// An exception block tree is used to assist in verifying the structural 
// soundness of exception blocks.
//
// Eg. (1)
//
// tryA { tryB { } catchB { } } filterA { } catchA { } tryC { } catchC { }
//
// [Verifier::m_pExceptionBlockRoot]
//              |
//              |
//              |
//              V
//          [ tryA ]--------->[ filterA ]--->[ catchA ]--->[tryC]--->[catchC]
//              |      sibling 
//              |
//              | c
//              | h
//              | i
//              | l
//              | d
//              |
//              V
//          [ tryB ]--->[ catchB ]
//
//
// Eg. (2)
//
//      try {
//
//      } catchA {
//
//      } catchB {
//
//      }
//
//  Meta declares 2 try blocks for this language structure.
//
//      tryA, tryB {
//
//      } 
//
//      catchA {
//
//      } 
//
//      catchB {
//
//      }
//
// [Verifier::m_pExceptionBlockRoot]
//              |
//              |
//              |
//              V
//          [ tryA (equivalent head node) ]--------->[ catchA ]--->[ catchB ]
//              |                           sibling 
//              |
//              | e
//              | q
//              | i
//              | v
//              | a
//              | l
//              | e
//              | n
//              | t
//              |
//              V
//          [ tryB ]
//
//

BOOL Verifier::CreateExceptionTree()
{
    _ASSERTE(m_verState >= verExceptToBB);
    _ASSERTE(m_pExceptionBlockRoot == NULL);

    DWORD nBlock = 0;
    VerExceptionBlock *pNode;
    VerExceptionBlock *pEqHead;

    for (DWORD i=0; i<m_NumExceptions; i++)
    {
        VerExceptionInfo& e = m_pExceptionList[i];

        // Insert the try block
        pNode             = &m_pExceptionBlockArray[nBlock++];
        pNode->eType      = eVerTry;
        pNode->StartBB    = e.dwTryXX;
        pNode->EndBB      = e.dwTryEndXX - 1; // converted to the real end here.
        pNode->pException = &e;
        e.pTryBlock       = pNode;

        if (!VerExceptionBlock::Insert(&m_pExceptionBlockRoot, pNode, &pEqHead, this))
        {
            m_sError.dwFlags = VER_ERR_EXCEP_NUM_1;
            m_sError.dwException1 = i;
            if (!SetErrorAndContinue(VER_E_TRY_OVERLAP))
                return FALSE;
        }

        //  Equivalent nodes are a singly linked list of nodes which have the 
        //  same startBB and EndBB. Equivalent-Head-Node is is the head node of
        //  this list.
        //
        //  This list will be complete only when all exception blocks are 
        //  entered into the exception tree.
        //
        //  VerExceptionBlock::Insert(pNode, , ppEqHead) setting ppEqHead to
        //  NULL does not imply that pNode will not have Equivalent nodes. If 
        //  pNode will have Equivalent nodes after adding more nodes to the 
        //  exception tree, pNode will be the head node of it's equivalent nodes
        //  list.

        if (pEqHead)
        {
            // @VER_IMPL handler blocks cannot be shared

            if (pEqHead->eType != eVerTry)
            {
                m_sError.dwFlags = VER_ERR_EXCEP_NUM_1;
                m_sError.dwException1 = i;
                if (!SetErrorAndContinue(VER_E_TRY_EQ_HND_FIL))
                    return FALSE;
            }

            // @VER_IMPL trys of finally and fault blocks cannot be shared

            if (((e.eFlags|pEqHead->pException->eFlags) &
                 (COR_ILEXCEPTION_CLAUSE_FINALLY|COR_ILEXCEPTION_CLAUSE_FAULT))
                != 0)
            {
                m_sError.dwFlags = VER_ERR_EXCEP_NUM_1;
                m_sError.dwException1 = i;
                if (!SetErrorAndContinue(VER_E_TRY_SHARE_FIN_FAL))
                    return FALSE;
            }
        }

        // This assignment is required even if pEqHead is NULL because
        // VerExceptionInfo.pXXXExceptionBlock is not initialized to zero for
        // performance reasons.

        e.pTryEquivalentHeadNode = pEqHead;

        // Insert the handler
        pNode             = &m_pExceptionBlockArray[nBlock++];
        pNode->eType      = eVerHandler;
        pNode->StartBB    = e.dwHandlerXX;
        pNode->EndBB      = e.dwHandlerEndXX - 1;
        pNode->pException = &e;
        e.pHandlerBlock   = pNode;

        if (!VerExceptionBlock::Insert(&m_pExceptionBlockRoot, pNode, &pEqHead, this))
        {
            m_sError.dwFlags = VER_ERR_EXCEP_NUM_1;
            m_sError.dwException1 = i;
            if (!SetErrorAndContinue(VER_E_HND_OVERLAP))
                return FALSE;
        }

        if (pEqHead)
        {
            // @VER_IMPL handler blocks cannot be shared

            m_sError.dwFlags = VER_ERR_EXCEP_NUM_1;
            m_sError.dwException1 = i;
            if (!SetErrorAndContinue(VER_E_HND_EQ))
                return FALSE;
        }

        if (e.eFlags & COR_ILEXCEPTION_CLAUSE_FILTER)
        {
            // Insert the filter
            pNode             = &m_pExceptionBlockArray[nBlock++];
            pNode->eType      = eVerFilter;
            pNode->StartBB    = e.dwFilterXX;
            pNode->EndBB      = e.dwFilterEndXX - 1;
            pNode->pException = &e;
            e.pFilterBlock    = pNode;

            // Filter end is where the handler start.
            if (e.dwFilterEndXX != e.dwHandlerXX)
            {
                m_sError.dwFlags = VER_ERR_EXCEP_NUM_1;
                m_sError.dwException1 = i;
                if (!SetErrorAndContinue(VER_E_FIL_PRECEED_HND))
                    return FALSE;
            }

            if (!VerExceptionBlock::Insert(&m_pExceptionBlockRoot, pNode, &pEqHead, this)) 
            {
                m_sError.dwFlags = VER_ERR_EXCEP_NUM_1;
                m_sError.dwException1 = i;
                if (!SetErrorAndContinue(VER_E_FIL_OVERLAP))
                    return FALSE;
            }

            if (pEqHead)
            {
                // @VER_IMPL handler blocks cannot be shared
    
                m_sError.dwFlags = VER_ERR_EXCEP_NUM_1;
                m_sError.dwException1 = i;
                if (!SetErrorAndContinue(VER_E_FIL_EQ))
                    return FALSE;
            }
        }
    }

    _ASSERTE(nBlock == m_nExceptionBlocks);

#ifdef _DEBUG
    m_verState = verExceptTreeCreated;
    PrintExceptionTree();
#endif

    return TRUE;
}

/*

    The root node could be changed by this method.

    Returns FALSE if node cannot be a sibling, child or equivalent of another
    node in the tree.

    Sets ppEquivalentHead node to NULL if Node is not part of an Equivalent
    nodes list.

    node is inserted to 

        (a) right       of root (root.right       <-- node)
        (b) left        of root (node.right       <-- root; node becomes root)
        (c) child       of root (root.child       <-- node)
        (d) parent      of root (node.child       <-- root; node becomes root)
        (e) equivalent  of root (root.equivalent  <-- node)

    such that siblings are ordered from left to right
    child parent relationship and equivalence relationship are not violated
    

    Here is a list of all possible cases

    Case 1 2 3 4 5 6 7 8 9 10 11 12 13

         | | | | |
         | | | | |
    .......|.|.|.|..................... [ root start ] .....
    |        | | | |             |  |
    |        | | | |             |  |
   r|        | | | |          |  |  |
   o|          | | |          |     |
   o|          | | |          |     |
   t|          | | |          |     |
    |          | | | |     |  |     |
    |          | | | |     |        |
    |..........|.|.|.|.....|........|.. [ root end ] ........
                 | | | |
                 | | | | |
                 | | | | |

        |<-- - - - n o d e - - - -->|


   Case Operation
   --------------
    1    (b)
    2    Error
    3    Error
    4    (d)
    5    (d)
    6    (d)
    7    Error
    8    Error
    9    (a)
    10   (c)
    11   (c)
    12   (c)
    13   (e)


*/

/* static */
BOOL VerExceptionBlock::Insert( 
        VerExceptionBlock **ppRoot, 
        VerExceptionBlock *pNode,
        VerExceptionBlock **ppEquivalentHeadNode,
        Verifier          *pVerifier)
{
    _ASSERTE(pNode->pSibling    == NULL);
    _ASSERTE(pNode->pChild      == NULL);
    _ASSERTE(pNode->pEquivalent == NULL);

    DWORD rStart;
    DWORD rEnd;

    DWORD nStart = pNode->StartBB;
    DWORD nEnd   = pNode->EndBB;
    
    *ppEquivalentHeadNode = NULL;

    _ASSERTE(nStart <= nEnd);

    // Using while loop instead of reccursion for perf.
    while (1)
    {
        // If Root is null, make Node the Root.
        if (*ppRoot == NULL)
        {
            *ppRoot = pNode;
            break;
        }

        rStart = (*ppRoot)->StartBB;
        rEnd   = (*ppRoot)->EndBB;
    
        _ASSERTE(rStart <= rEnd);
    
        // Case 1, 2, 3, 4, 5
        if (nStart < rStart)
        {
            // Case 1
            if (nEnd < rStart)
            {
//[LeftSibling]
                pNode->pSibling = *ppRoot;
                *ppRoot         = pNode;
                break;
            }
    
            // Case 2, 3
            if (nEnd < rEnd)
//[Error]
                return FALSE;
    
            // Case 4, 5
//[Parent]
            return InsertParent(ppRoot, pNode);
        }
    
        // Case 6, 7, 8, 9
        if (nEnd > rEnd)
        {
            // Case 9
            if (nStart > rEnd)
            {
//[RightSibling]

                // Reccurse with Root.Sibling as the new root
                ppRoot = &((*ppRoot)->pSibling);
                continue;
            }

            // Case 6
            if (nStart == rStart)
            {
//[Parent]
                // non try blocks are not allowed to start at the same offset
                if (((*ppRoot)->eType == eVerTry) || (pNode->eType == eVerTry))
                    return InsertParent(ppRoot, pNode);
            }

            // Case 7, 8
//[Error]
            return FALSE;
        }

        // Case 10, 11, 12
        if ((nStart != rStart) || (nEnd != rEnd))
        {
//[Child]
#ifdef _VER_DECLARE_INNERMOST_EXCEPTION_BLOCK_FIRST
            if (!pVerifier->SetErrorAndContinue(VER_E_INNERMOST_FIRST))
                return FALSE;
#endif
            // Case 12 (nStart == rStart)
            // non try blocks are not allowed to start at the same offset
            if ((nStart == rStart) && 
                ((*ppRoot)->eType != eVerTry) && (pNode->eType != eVerTry))
                return FALSE;

            // Reccurse with Root.Child as the new root
            ppRoot = &((*ppRoot)->pChild);
            continue;
        }

        // Case 13
//[Equivalent]
        pNode->pEquivalent     = (*ppRoot)->pEquivalent;
        (*ppRoot)->pEquivalent = pNode;

        // The head of an equivalent list is always the same even if the nodes
        // child / parent / siblings change.

        *ppEquivalentHeadNode = *ppRoot;   

        break;
    }

    return TRUE;
}


/* 
 *  Modifies *ppRoot to point to pNode, thus making pNode the new root.
 *  Makes **pRoot the child of *pNode.
 *  The siblings to the right of **ppRoot, are made the sibling of
 *  *pNode if they are not a children of *pNode.
 */
/* static */
BOOL VerExceptionBlock::InsertParent(
        VerExceptionBlock **ppRoot, 
        VerExceptionBlock *pNode)
{
    _ASSERTE(pNode->pSibling == NULL);
    _ASSERTE(pNode->pChild == NULL);

    // Assert that Root is a child of Node
    _ASSERTE(pNode->StartBB <= (*ppRoot)->StartBB);
    _ASSERTE(pNode->EndBB   >= (*ppRoot)->EndBB);

    // Assert that Root is not the same as Node
    _ASSERTE(pNode->StartBB != (*ppRoot)->StartBB || pNode->EndBB != (*ppRoot)->EndBB);

    // Find the sibling of Root that is a not a child of Node and
    // make it the first sibling of Node.

    VerExceptionBlock *pLastChild = NULL;
    VerExceptionBlock *pSibling   = (*ppRoot)->pSibling;

    while (pSibling)
    {
        // siblings are ordered left to right, largest right.
        // nodes have a width of atleast one.
        // Hence pSibling start will always be after Node start.

        _ASSERTE(pSibling->StartBB > pNode->StartBB);

        // disjoint
        if (pSibling->StartBB > pNode->EndBB)
            break;

        // partial containment.
        if (pSibling->EndBB > pNode->EndBB)
            return FALSE;

        // Sibling is a child of node.

        pLastChild = pSibling;
        pSibling = pSibling->pSibling;
    }

    // All siblings of Root upto and including pLastChild will continue to be 
    // siblings of Root (and children of Node). The node to the right of 
    // pLastChild will become the first sibling of Node.

    if (pLastChild)
    {
        // Node has more than one child including Root

        pNode->pSibling      = pLastChild->pSibling;
        pLastChild->pSibling = NULL;
    }
    else
    {
        // Root is the only child of Node
        pNode->pSibling      = (*ppRoot)->pSibling;
        (*ppRoot)->pSibling  = NULL;
    }

    // make Root the child of Node and Node the new Root 

    pNode->pChild = *ppRoot;
    *ppRoot       = pNode;

    return TRUE;
}

// Given a node which contains BB, finds the next inner node that 
// contains BB. returns NULL if there is no such node.

/* static */
VerExceptionBlock* VerExceptionBlock::FindNext(
                            VerExceptionBlock *pNode, 
                            DWORD BB)
{
    _ASSERTE(VER_BLOCK_CONTAINS_BB(pNode, BB));

    pNode = pNode->pChild;

    while (pNode)
    {
        if (VER_BLOCK_CONTAINS_BB(pNode, BB))
        {
            break;
        }

        pNode = pNode->pSibling;
    }

    return pNode;
}

// Given a node find it's parent, in the tree rooted at 'root'

/* static */
VerExceptionBlock* VerExceptionBlock::FindParent(
                            VerExceptionBlock *pChild, VerExceptionBlock *pRoot)
{

/* 
    This is an expensive call, to make this faster, we need a parent 
    pointer for each node.
    Walk all nodes from Root to child, along the Childs StartBB.
*/

    _ASSERTE(pRoot && pChild);

    if (pRoot == pChild)
        return NULL;

    DWORD BB = pChild->StartBB;
    VerExceptionBlock *pParent = NULL;

    do
    {
        pParent = pRoot;
        pRoot   = FindNext(pRoot, BB);
    }
    while (pRoot != pChild);

    return pParent;
}

// Checks for the following conditions.
//
// 1. Overlapping of blocks not allowed. (except trys of fault blocks).
// 2. Handler blocks cannot be shared between different try blocks.
// 3. Try blocks with Finally / Fault blocks cannot have other handlers.
// 4. If block A contains block B, A should also contain B's try/filter/handler.
// 5. A block cannot contain it's related try/filter/handler.
// 6. A filter block cannot contain another block.
//
//

BOOL Verifier::VerifyLexicalNestingOfExceptions()
{
    // @VER_ASSERT Case 1, 2, 3 Implemented in Verifier::CreateExceptionTree()

    _ASSERTE(m_verState >= verExceptTreeCreated);

#ifdef _DEBUG
    if ((m_NumExceptions > 0) && (m_wFlags & VER_STOP_ON_FIRST_ERROR))
        AssertExceptionTreeIsValid(m_pExceptionBlockRoot);
#endif

    VerExceptionBlock *p1, *p2, *p3, *pTmp;
    DWORD nSiblingRelations;

    for (DWORD i=0; i<m_NumExceptions; i++)
    {
        VerExceptionInfo& e = m_pExceptionList[i];

        // If related exceptions are siblings, Case 4 & 5 are met.
        // [Siblings are children of the same parent.]
    
        p1 = (e.pTryEquivalentHeadNode) ? 
                e.pTryEquivalentHeadNode : e.pTryBlock;

        p2 = e.pHandlerBlock;

        nSiblingRelations = 0;

        // Case 6
        if (e.eFlags & COR_ILEXCEPTION_CLAUSE_FILTER)
        {
            if (e.pFilterBlock->pChild != NULL)
            {
                if (e.pFilterBlock->pChild->eType == eVerTry)
                {
                    m_sError.dwFlags = VER_ERR_EXCEP_NUM_1;
                    m_sError.dwException1 = i;
                    if (!SetErrorAndContinue(VER_E_FIL_CONT_TRY))
                        return FALSE;
                }
                else if (e.pFilterBlock->pChild->eType == eVerHandler)
                {
                    m_sError.dwFlags = VER_ERR_EXCEP_NUM_1;
                    m_sError.dwException1 = i;
                    if (!SetErrorAndContinue(VER_E_FIL_CONT_HND))
                        return FALSE;
                }
                else
                {
                    m_sError.dwFlags = VER_ERR_EXCEP_NUM_1;
                    m_sError.dwException1 = i;
                    if (!SetErrorAndContinue(VER_E_FIL_CONT_FIL))
                        return FALSE;
                }
            }

            p3 = e.pFilterBlock;

            // Case 4, 5 with filter blocks.
            // Try to find 2 sibling relations

            // Make p1 the left most node.

            if ((p2->StartBB < p1->StartBB) && (p2->StartBB < p3->StartBB))
            {
                // exchange p1, p2
                pTmp = p1; p1 = p2; p2 = pTmp;
            }
            else if ((p3->StartBB < p1->StartBB) && (p3->StartBB < p2->StartBB))
            {
                // exchange p1, p3
                pTmp = p1; p1 = p3; p3 = pTmp;
            }
    
            do
            {
                p1 = p1->pSibling;
    
                if (p1 == p2)
                    ++nSiblingRelations;
                else if (p1 == p3)
                    ++nSiblingRelations;
    
            } while ((p1 != NULL) && (nSiblingRelations < 2));

            if (nSiblingRelations != 2)
            {
                goto error_lexical_nesting;
            }
        }
        else
        {
            // Case 4, 5 with no filter block.
            // Sibling test is trivial if no filter block is present.
            // Make p1 the left most node.

            if (p2->StartBB < p1->StartBB)
            {
                // exchange p1, p2
                pTmp = p1; p1 = p2; p2 = pTmp;
            }

            // Check if p2 is a sibling of p1

            do {
                p1 = p1->pSibling;

                if (p1 == p2)
                {
                    ++nSiblingRelations;
                    break;
                }
            } while (p1 != NULL);

            if (nSiblingRelations != 1)
            {
error_lexical_nesting:
                m_sError.dwFlags = VER_ERR_EXCEP_NUM_1;
                m_sError.dwException1 = i;
                if (!SetErrorAndContinue(VER_E_LEXICAL_NESTING))
                    return FALSE;
            }
        }
    }

    return TRUE;
}

#ifdef _DEBUG
/* reccursive */
/* static */
void Verifier::AssertExceptionTreeIsValid(VerExceptionBlock *pRoot)
{
    _ASSERTE(pRoot);
    _ASSERTE(pRoot->StartBB <= pRoot->EndBB);

    VerExceptionInfo  *pExcep;
    VerExceptionBlock *pBlock;

    pExcep = pRoot->pException;

    if (pRoot->eType == eVerTry)
    {
        _ASSERTE(pRoot == pExcep->pTryBlock);

        if (pExcep->eFlags &
            (COR_ILEXCEPTION_CLAUSE_FAULT|COR_ILEXCEPTION_CLAUSE_FINALLY))
        {
            _ASSERTE(pRoot->pEquivalent == NULL);
        }
        else
        {
            pBlock = pRoot->pEquivalent;

            while (pBlock)
            {
                pExcep = pBlock->pException;
                _ASSERTE(pBlock->StartBB == pRoot->StartBB);
                _ASSERTE(pBlock->EndBB == pRoot->EndBB);

                _ASSERTE(pBlock->eType == eVerTry);
                _ASSERTE(pBlock == pBlock->pException->pTryBlock);

                _ASSERTE(pExcep->pTryEquivalentHeadNode == pRoot);
                _ASSERTE((pExcep->eFlags & (COR_ILEXCEPTION_CLAUSE_FAULT|COR_ILEXCEPTION_CLAUSE_FINALLY)) == 0);
                pBlock = pBlock->pEquivalent;
            }
        }
    }
    else if (pRoot->eType == eVerHandler)
    {
        _ASSERTE(pRoot == pExcep->pHandlerBlock);
        _ASSERTE(pRoot->pEquivalent == NULL);
    }
    else
    {
        _ASSERTE(pRoot->eType == eVerFilter);
        _ASSERTE(pExcep->eFlags & COR_ILEXCEPTION_CLAUSE_FILTER);
        _ASSERTE(pRoot == pExcep->pFilterBlock);
        _ASSERTE(pRoot->pEquivalent == NULL);
    }

    if (pRoot->pChild)
    {
        _ASSERTE(pRoot->pChild->StartBB >= pRoot->StartBB);
        _ASSERTE(pRoot->pChild->EndBB <= pRoot->EndBB);

        if (pRoot->pChild->StartBB == pRoot->StartBB)
            _ASSERTE(pRoot->pChild->EndBB != pRoot->EndBB);

        AssertExceptionTreeIsValid(pRoot->pChild);
    }

    if (pRoot->pSibling)
    {
        _ASSERTE(pRoot->pSibling->StartBB > pRoot->EndBB);
        AssertExceptionTreeIsValid(pRoot->pSibling);
    }
}
#endif

// Srouce & Destination of branch needs to be checked
//
// 1. Allow branch out of an exception block to a different block
//      (a) using leave instruction from try / catch
//      (b) fall thru from a try block
//      (c) endfilter from a filter block
//      (d) endfinally from a finally block or fault block
//
// 2. Allow branch into an exception block from another block
//      (a) into the first instruction of a try block.
//      (b) from catch block to it's try block using leave.
//      (c) from an inner block.
//
BOOL Verifier::IsControlFlowLegal(
                            DWORD FromBB,     
                            VerExceptionBlock *pFromOuter, 
                            VerExceptionBlock *pFromInner, 
                            DWORD ToBB,     
                            VerExceptionBlock *pToOuter,
                            VerExceptionBlock *pToInner,
                            eVerControlFlow   eBranchType,
                            DWORD dwPCAtStartOfInstruction)
{
    _ASSERTE(m_verState >= verExceptTreeCreated);

    // Don't call this function for "eVerThrow" for performance.
    _ASSERTE(eBranchType != eVerThrow);

    // if eBranchType is ret, rethrow etc.. pToInner must be null.
    _ASSERTE(eBranchType != eVerRet        || pToInner == NULL);
    _ASSERTE(eBranchType != eVerReThrow    || pToInner == NULL);
    _ASSERTE(eBranchType != eVerEndFinally || pToInner == NULL);
    _ASSERTE(eBranchType != eVerEndFilter  || pToInner == NULL);

    // Both NULL or in the same inner exception Block is ok. for branch, leave
    // and fallthru. Both NULL ok for return.
    if ((pFromInner == pToInner) &&
        (eBranchType == eVerRet      ||
         eBranchType == eVerFallThru ||
         eBranchType == eVerBranch   ||
         eBranchType == eVerLeave))
    {
        // Branch/leave to the start of a catch or filter handler is illegal
        if (IsBadControlFlowToStartOfCatchOrFilterHandler(
                eBranchType, ToBB, pToInner))
        {
            m_sError.dwFlags = VER_ERR_OFFSET;
            m_sError.dwOffset = dwPCAtStartOfInstruction;
            if (!SetErrorAndContinue(VER_E_BR_TO_EXCEPTION))
                return FALSE;
        }

        return TRUE;
    }

#ifdef _DEBUG
    LOG((LF_VERIFIER, LL_INFO10000, "[0x%x] ", dwPCAtStartOfInstruction));
    switch (eBranchType)
    {
    case eVerFallThru :
        LOG((LF_VERIFIER, LL_INFO10000, "fallthru"));
        break;
    case eVerRet :
        LOG((LF_VERIFIER, LL_INFO10000, "return"));
        break;
    case eVerBranch :
        LOG((LF_VERIFIER, LL_INFO10000, "branch"));
        break;
    case eVerThrow :
        LOG((LF_VERIFIER, LL_INFO10000, "throw"));
        break;
    case eVerReThrow :
        LOG((LF_VERIFIER, LL_INFO10000, "rethrow"));
        break;
    case eVerLeave :
        LOG((LF_VERIFIER, LL_INFO10000, "leave"));
        break;
    case eVerEndFinally :
        LOG((LF_VERIFIER, LL_INFO10000, "endfinally"));
        break;
    case eVerEndFilter :
        LOG((LF_VERIFIER, LL_INFO10000, "endfilter"));
        break;
    }
    if (FromBB != VER_NO_BB)
    {
        LOG((LF_VERIFIER, LL_INFO10000, " From 0x%x", 
            m_pBasicBlockList[FromBB].m_StartPC));
    }
    if (ToBB != VER_NO_BB)
    {
        LOG((LF_VERIFIER, LL_INFO10000, " To 0x%x", 
            m_pBasicBlockList[ToBB].m_StartPC));
    }
    LOG((LF_VERIFIER, LL_INFO10000, "\n")); 
#endif

    VerExceptionBlock *pTmp;

    switch (eBranchType)
    {
    default: 
        _ASSERTE(!"Not expected !");
        return FALSE;

    case eVerFallThru:
        // From : NULL
        // To   : NULL
        //        OR a try block

        _ASSERTE(pFromInner != pToInner);

        // "From" case

        while (pFromOuter)
        {
            // Do not allow falling off the end of a handler/filter block.
    
            if ((pFromOuter->EndBB == FromBB) 
                /* && (pFromOuter->eType != eVerTry) */)
            {
                // Since end of filter blocks are found during pass 1
                // endfilter will be the last instruction of a filter block.

                _ASSERTE(pFromOuter->eType != eVerFilter);

                m_sError.dwFlags = VER_ERR_OFFSET;
                m_sError.dwOffset = dwPCAtStartOfInstruction;
                if (!SetErrorAndContinue(VER_E_FALLTHRU_EXCEP))
                    return FALSE;
            }

            // FromOuter >>--[FromBB]--> FromInner
            pFromOuter = VerExceptionBlock::FindNext(pFromOuter, FromBB);
        }

        // "To" case

        while (pToOuter)
        {
            // Do not allow falling into a handler/filter block.
    
            if ((pToOuter->StartBB == ToBB) && (pToOuter->eType != eVerTry))
            {
                if (pToOuter->eType == eVerHandler)
                {
                    m_sError.dwFlags = VER_ERR_OFFSET;
                    m_sError.dwOffset = dwPCAtStartOfInstruction;
                    if (!SetErrorAndContinue(VER_E_FALLTHRU_INTO_HND))
                        return FALSE;
                }
                else
                {
                    m_sError.dwFlags = VER_ERR_OFFSET;
                    m_sError.dwOffset = dwPCAtStartOfInstruction;
                    if (!SetErrorAndContinue(VER_E_FALLTHRU_INTO_FIL))
                        return FALSE;
                }
            }

            // ToOuter >>--[ToBB]--> ToInner
            pToOuter = VerExceptionBlock::FindNext(pToOuter, ToBB);
        }

        break;

    case eVerLeave:
        // From : inside a try/catch
        // To   : NULL
        //        OR The first block of a try block
        //        OR An outer block
        //        OR if From is a catch block, it's corresponding try block. 
        //        OR If from / to have common parents, find the fist node in the
        //           path of Outer ==> Inner of from and To that differ.
        //           All nodes from here to ToInner along ToBB should be try 
        //           blocks which have StartBB == ToBB.

        _ASSERTE(pFromInner != pToInner);

        if (pFromInner == NULL)
            goto leave_to;

        if ((pFromInner->eType == eVerFilter) ||
            ((pFromInner->eType == eVerHandler) && 
             ((pFromInner->pException->eFlags & 
                (COR_ILEXCEPTION_CLAUSE_FAULT|COR_ILEXCEPTION_CLAUSE_FINALLY))
                != 0)))
        {
            m_sError.dwFlags = VER_ERR_OFFSET;
            m_sError.dwOffset = dwPCAtStartOfInstruction;
            if (!SetErrorAndContinue(VER_E_LEAVE))
                return FALSE;
        }

        // Leave to non exception block is allowed

        if (pToInner == NULL)
        {
            // Make sure that only try / catch blocks are left.
            // All nodes from FromOuter >>--[FromBB]--> FromInner should be
            // try or catch blocks

            while (pFromInner != pFromOuter)
            {
                if (pFromOuter->eType == eVerFilter)
                    goto LeaveError;

                if ((pFromOuter->eType != eVerTry) &&
                    ((pFromOuter->eType == eVerHandler) && 
                    ((pFromOuter->pException->eFlags & 
                     (COR_ILEXCEPTION_CLAUSE_FAULT|
                      COR_ILEXCEPTION_CLAUSE_FINALLY)) != 0)))
                {
LeaveError:
                    m_sError.dwFlags = VER_ERR_OFFSET;
                    m_sError.dwOffset = dwPCAtStartOfInstruction;
                    if (!SetErrorAndContinue(VER_E_LEAVE))
                        return FALSE;
                }

                pFromOuter = VerExceptionBlock::FindNext(pFromOuter, FromBB);
            }

            LOG((LF_VERIFIER, LL_INFO10000, "leave to non exception block\n")); 
            break;
        }

        // leave from a catch to it's try block is allowed.

        if ((pFromInner->eType == eVerHandler) &&
            ((pFromInner->pException->eFlags &
            (COR_ILEXCEPTION_CLAUSE_FAULT|COR_ILEXCEPTION_CLAUSE_FINALLY))
            == 0) &&
            (pToInner->eType == eVerTry))
        {
            pTmp = pToInner;

            // See if pToInner or one if it's equivalents correspond
            // to pFromInner->pException.

            do {
                _ASSERTE(pTmp->eType == eVerTry);

                if (pTmp->pException == pFromInner->pException)
                {
                    LOG((LF_VERIFIER, LL_INFO10000, 
                        "leave from catch to try\n"));
                    break;
                }

                pTmp = pTmp->pEquivalent;

            } while (pTmp);

            if (pTmp)
                break;  // Success
        }


        if (VER_BLOCK_CONTAINS_BB(pToInner, FromBB))
        {
            // leaving into an outer block.
            // FromInner is a child of ToInner

            // Make sure that only try / catch blocks are left.
            // All nodes from ToInner + 1 >>---[FromBB]---> FromInner should be 
            // try or catch blocks

            while (pToInner != pFromInner)
            {
                pToInner = VerExceptionBlock::FindNext(pToInner, FromBB);

                _ASSERTE(pToInner->eType != eVerFilter);

                if ((pToInner->eType == eVerTry) ||
                    ((pToInner->eType == eVerHandler) && 
                    ((pToInner->pException->eFlags & 
                     (COR_ILEXCEPTION_CLAUSE_FAULT|
                      COR_ILEXCEPTION_CLAUSE_FINALLY)) == 0)))
                    continue;

                m_sError.dwFlags = VER_ERR_OFFSET;
                m_sError.dwOffset = dwPCAtStartOfInstruction;
                if (!SetErrorAndContinue(VER_E_LEAVE))
                    return FALSE;
            }

            LOG((LF_VERIFIER, LL_INFO10000, "leave to outer block\n")); 
            break; // Success
        }

        if (VER_BLOCK_CONTAINS_BB(pFromInner, ToBB))
        {
            // ToInner is a child of FromInner

            // Side Effect.
            // ToOuter is the second node in the path 
            // FromInner >>---[ToBB]--> ToInner
            // This is done to save some time for the "To" check where
            // all node in the path ToOuter >>----[ToBB]---> ToInner
            // should be try blocks and their StartBB == ToBB.

            pToOuter = VerExceptionBlock::FindNext(pFromInner, ToBB);

            _ASSERTE(pToOuter);

            LOG((LF_VERIFIER, LL_INFO10000, "leave to inner block\n")); 
        }
        else
        {
            // pToInner is not a child of pFromInner

            // Walk ToOuter >>--[ToBB]--> ToInner,
            // Walk FromOuter >>--[FromBB]--> FromInner,
            // upto the point where FromOuter and ToOuter are different.
            // If they have common parents, the Outer most parents will be
            // the same.
    
            while (pToOuter == pFromOuter)
            {
                pTmp = VerExceptionBlock::FindNext(pToOuter, ToBB);

                if (pTmp == NULL)
                {
                    _ASSERTE(pToOuter == pToInner);
                    break;
                }

                pToOuter = pTmp;

                pTmp = VerExceptionBlock::FindNext(pFromOuter, FromBB);

                if (pTmp == NULL)
                {
                    _ASSERTE(pFromOuter == pFromInner);
                    break;
                }

                pFromOuter = pTmp;
            }
        }

leave_to:

        // All nodes in the path ToOuter >>--[ToBB]--> ToInner should be
        // try blocks with StartBB == ToBB

        do
        {
            if ((pToOuter->eType != eVerTry) ||
                (pToOuter->StartBB != ToBB))
            {
                if (pToOuter->eType == eVerTry)
                {
                    m_sError.dwFlags = VER_ERR_OFFSET;
                    m_sError.dwOffset = dwPCAtStartOfInstruction;
                    if (!SetErrorAndContinue(VER_E_BR_INTO_TRY))
                        return FALSE;
                }
                else if (pToOuter->eType == eVerHandler)
                {
                    m_sError.dwFlags = VER_ERR_OFFSET;
                    m_sError.dwOffset = dwPCAtStartOfInstruction;
                    if (!SetErrorAndContinue(VER_E_BR_INTO_HND))
                        return FALSE;
                }
                else
                {
                    m_sError.dwFlags = VER_ERR_OFFSET;
                    m_sError.dwOffset = dwPCAtStartOfInstruction;
                    if (!SetErrorAndContinue(VER_E_BR_INTO_FIL))
                        return FALSE;
                }
            }

            pToOuter = VerExceptionBlock::FindNext(pToOuter, ToBB);

        } while (pToOuter);

        break;

    case eVerBranch:
        // From : NULL
        //        OR a parent of To
        // To   : NULL
        //        OR the first basic block of a try block.

        _ASSERTE(pFromInner != pToInner);

        // "To" should be null or child of "From"

        if (pFromInner != NULL)
        {
            // See if pFromInner is a parent of pToInner
    
            if (VER_BLOCK_CONTAINS_BB(pFromInner, ToBB))
            {
                // Side Effect.
                // pToOuter is the second node in the path 
                // pFromInner >>---[ToBB]--> pToInner
                // This is done to save some time for the "To" check where
                // all node in the path pToOuter >>----[ToBB]---> pToInner
                // should be try blocks and their StartBB == ToBB.

                pToOuter = VerExceptionBlock::FindNext(pFromInner, ToBB);

                _ASSERTE(pToOuter);

                LOG((LF_VERIFIER, LL_INFO10000, 
                    "branch into inner exception block\n")); 
            }
            else
            {
                if (pFromInner->eType == eVerTry)
                {
                    m_sError.dwFlags = VER_ERR_OFFSET;
                    m_sError.dwOffset = dwPCAtStartOfInstruction;
                    if (!SetErrorAndContinue(VER_E_BR_OUTOF_TRY))
                        return FALSE;
                }
                else if (pFromInner->eType == eVerHandler)
                {
                    m_sError.dwFlags = VER_ERR_OFFSET;
                    m_sError.dwOffset = dwPCAtStartOfInstruction;
                    if (!SetErrorAndContinue(VER_E_BR_OUTOF_HND))
                        return FALSE;
                }
                else
                {
                    m_sError.dwFlags = VER_ERR_OFFSET;
                    m_sError.dwOffset = dwPCAtStartOfInstruction;
                    if (!SetErrorAndContinue(VER_E_BR_OUTOF_FIL))
                        return FALSE;
                }
            }
        }

        // "To" should be the first BB of a try block.
        // All nodes in the path ToOuter >>--[ToBB]--> ToInner should be
        // try blocks with StartBB == ToBB

        while (pToOuter)
        {
            if ((pToOuter->eType != eVerTry) ||
                (pToOuter->StartBB != ToBB))
            {
                if (pToOuter->eType == eVerTry)
                {
                    m_sError.dwFlags = VER_ERR_OFFSET;
                    m_sError.dwOffset = dwPCAtStartOfInstruction;
                    if (!SetErrorAndContinue(VER_E_BR_INTO_TRY))
                        return FALSE;
                }
                else if (pToOuter->eType == eVerHandler)
                {
                    m_sError.dwFlags = VER_ERR_OFFSET;
                    m_sError.dwOffset = dwPCAtStartOfInstruction;
                    if (!SetErrorAndContinue(VER_E_BR_INTO_HND))
                        return FALSE;
                }
                else
                {
                    m_sError.dwFlags = VER_ERR_OFFSET;
                    m_sError.dwOffset = dwPCAtStartOfInstruction;
                    if (!SetErrorAndContinue(VER_E_BR_INTO_FIL))
                        return FALSE;
                }
            }

            pToOuter = VerExceptionBlock::FindNext(pToOuter, ToBB);
        }

        break;

    case eVerRet:

        // Cannot return from inside exception blocks.
        _ASSERTE(pFromInner != NULL);

        if (pFromInner->eType == eVerTry)
        {
            m_sError.dwFlags = VER_ERR_OFFSET;
            m_sError.dwOffset = dwPCAtStartOfInstruction;
            if (!SetErrorAndContinue(VER_E_RET_FROM_TRY))
                return FALSE;
        }
        else if (pFromInner->eType == eVerHandler)
        {
            m_sError.dwFlags = VER_ERR_OFFSET;
            m_sError.dwOffset = dwPCAtStartOfInstruction;
            if (!SetErrorAndContinue(VER_E_RET_FROM_HND))
                return FALSE;
        }
        else
        {
            m_sError.dwFlags = VER_ERR_OFFSET;
            m_sError.dwOffset = dwPCAtStartOfInstruction;
            if (!SetErrorAndContinue(VER_E_RET_FROM_FIL))
                return FALSE;
        }
    
        break;

    case eVerReThrow:

        // From : only from inside a catch handler

/*
        // Atleast one of the blocks that contain FromBB should be a 
        // catch handler.

        while (pFromOuter)
        {
            if ((pFromOuter->eType == eVerHandler) &&
                ((pFromOuter->pException->eFlags & 
                    (COR_ILEXCEPTION_CLAUSE_FINALLY|
                     COR_ILEXCEPTION_CLAUSE_FAULT)) == 0))
                break;

            pFromOuter = VerExceptionBlock::FindNext(pFromOuter, FromBB);
        }

        if (pFromOuter == NULL)
        {
            m_sError.dwFlags = VER_ERR_OFFSET;
            m_sError.dwOffset = dwPCAtStartOfInstruction;
            if (!SetErrorAndContinue(VER_E_RETHROW))
                return FALSE;
        }
*/
        // From : only from inside a catch handler
        // Or a try inside a catch handler.
        // Not allowed in filnally/fault/filter nested in a catch

        if ((pFromInner == NULL) ||
            (pFromInner->eType == eVerFilter) ||
            ((pFromInner->eType == eVerHandler) && 
                (pFromInner->pException->eFlags & 
                (COR_ILEXCEPTION_CLAUSE_FINALLY|
                 COR_ILEXCEPTION_CLAUSE_FAULT)) != 0))
        {
            m_sError.dwFlags = VER_ERR_OFFSET;
            m_sError.dwOffset = dwPCAtStartOfInstruction;
            if (!SetErrorAndContinue(VER_E_RETHROW))
                return FALSE;
            break;
        }

        while (pFromInner->eType == eVerTry)
        {
            // All nodes in the path FromInner >>--[*]--> FromOuter
            // Should be a try Or if it is a catch handler, the success 
            // condition is reached. If no catch handler is peresent, fail.

            pFromInner = VerExceptionBlock::FindParent(pFromInner, pFromOuter);

            if ((pFromInner == NULL) ||
                (pFromInner->eType == eVerFilter) ||
                ((pFromInner->eType == eVerHandler) && 
                    (pFromInner->pException->eFlags & 
                    (COR_ILEXCEPTION_CLAUSE_FINALLY|
                    COR_ILEXCEPTION_CLAUSE_FAULT)) != 0))
            {
                m_sError.dwFlags = VER_ERR_OFFSET;
                m_sError.dwOffset = dwPCAtStartOfInstruction;
                return SetErrorAndContinue(VER_E_RETHROW);
            }
        }

        _ASSERTE(pFromInner);
        _ASSERTE(pFromInner->eType == eVerHandler);
        _ASSERTE((pFromInner->pException->eFlags & (COR_ILEXCEPTION_CLAUSE_FINALLY|COR_ILEXCEPTION_CLAUSE_FAULT)) == 0);

        break;

    case eVerEndFinally:

        // From : inside a finally block

        if ((pFromInner == NULL) || (pFromInner->eType != eVerHandler) ||
            ((pFromInner->pException->eFlags & 
                (COR_ILEXCEPTION_CLAUSE_FINALLY|COR_ILEXCEPTION_CLAUSE_FAULT))
                    == 0))
        {
            m_sError.dwFlags = VER_ERR_OFFSET;
            m_sError.dwOffset = dwPCAtStartOfInstruction;
            if (!SetErrorAndContinue(VER_E_ENDFINALLY))
                return FALSE;
        }

        break;

    case eVerEndFilter:

        // From : inside a filter block

        if ((pFromInner == NULL) ||
            (pFromInner->eType != eVerFilter))
        {
            m_sError.dwFlags = VER_ERR_OFFSET;
            m_sError.dwOffset = dwPCAtStartOfInstruction;
            if (!SetErrorAndContinue(VER_E_ENDFILTER))
                return FALSE;
        }

        break;
    }

    return TRUE;
}

// Checks if the given Basic Block is the start of a catch or filter handler
// Of the given ExceptionBlock
BOOL Verifier::IsBadControlFlowToStartOfCatchOrFilterHandler(
                                            eVerControlFlow   eBranchType,
                                            DWORD             BB,
                                            VerExceptionBlock *pEBlock)
{
    if ((eBranchType == eVerBranch) || (eBranchType == eVerLeave))
    {
        if ((pEBlock == NULL) || (pEBlock->StartBB != BB))
            return FALSE;   // Not the first basic block
    
        if (pEBlock->eType == eVerTry)
            return FALSE;   // start of a Try block
    
        if ((pEBlock->pException->eFlags &
            (COR_ILEXCEPTION_CLAUSE_FINALLY|COR_ILEXCEPTION_CLAUSE_FAULT)) != 0)
            return FALSE;   // start of a Fault or finally handler

        return TRUE;
    }

    return FALSE;
}

// Find the inner and outer most blocks that contain BB, null if not found.
// fInTryBlock is set if an of the containing blocks is a try block.
// This function is overloaded for performance reasons.
void Verifier::FindExceptionBlockAndCheckIfInTryBlock(
                        DWORD BB, 
                        VerExceptionBlock **ppOuter, 
                        VerExceptionBlock **ppInner, 
                        BOOL *pfInTryBlock) const
{
    _ASSERTE(m_verState >= verExceptTreeCreated);

    VerExceptionBlock *pRet  = NULL;
    VerExceptionBlock *pRoot = m_pExceptionBlockRoot;

    *ppOuter         = NULL;
    *ppInner         = NULL;

    if (pfInTryBlock)
        *pfInTryBlock = FALSE;

    while (pRoot)
    {
        if (VER_BLOCK_CONTAINS_BB(pRoot, BB))
        {
            // Found one which contains BB
            if (*ppOuter == NULL)
                *ppOuter = pRoot;

            if ((pfInTryBlock) && (pRoot->eType == eVerTry))
                *pfInTryBlock = TRUE;   // Ok to set multiple times.

            // Not finished yet. We need to find out if any of the children of 
            // Root contain BB (since we are also interested in the innermost 
            // block that contains BB).

            *ppInner = pRoot;

            // Root contains this block
            // Since siblings of root are ordered and disjoint, siblings
            // of Root will not contain BB

            pRoot = pRoot->pChild;
        }
        else
        {
            // Not in this node (and it's children), check the sibling
            pRoot = pRoot->pSibling;
        }
    }
}

//
// Determine the basic blocks, and check that all jumps are to basic block boundaries.
//
// Also determine the types of all local variables.
//
HRESULT Verifier::GenerateBasicBlockList()
{
    HRESULT hr;
    DWORD   ipos = 0;                   // instruction position
    DWORD   NumBitmapDwords;            // # DWORDs in m_pInstrBoundaryList 
                                        // and m_pBasicBlockBoundaryList arrays
    DWORD   NumBasicBlocks = 1;         // this includes the basic block which 
                                        // starts at PC = 0
    DWORD   CurBlock;                   // current basic block
    DWORD   nFilter;                    // Number of Filters
    DWORD   nExceptionBlocks;           // Number of exception blocks
    DWORD   i;

    // bitmap of instruction boundaries (bit set means an instruction starts here)
    NumBitmapDwords = 1 + NUM_DWORD_BITMAPS(m_CodeSize);

    m_pInstrBoundaryList = new DWORD[NumBitmapDwords*2];
    if (m_pInstrBoundaryList == NULL)
    {
        SET_ERR_OM();
        hr = E_OUTOFMEMORY;
        goto error;
    }
    

    // bitmap of basic block boundaries (bit set means a basic block starts here)
    m_pBasicBlockBoundaryList = &m_pInstrBoundaryList[NumBitmapDwords];

    // initialise both bitmaps - no instructions yet
    memset(m_pInstrBoundaryList, 0, 2 * NumBitmapDwords * sizeof(DWORD));

    // Compute basic block boundaries, number of basic blocks, and which locals we took the address of.
    // We will later pare down m_pLocalHasPinnedType so that we only have bits set for the locals 
    // which are objrefs.
    hr = FindBasicBlockBoundaries( 
        m_pCode, 
        m_CodeSize, 
        m_MaxLocals, 
        &NumBasicBlocks, 
        m_pLocalHasPinnedType  // was already zeroed after we allocated it
    );

    if (FAILED(hr))
        goto error; // error message already filled out

    if (!MarkExceptionBasicBlockBoundaries(&NumBasicBlocks, &nFilter))
    {
        hr = E_FAIL;
        goto error;
    }

    // one for each try, one for each handler and one for each filter.
    nExceptionBlocks = 2 * m_NumExceptions + nFilter;

#ifdef _DEBUG
    m_nExceptionBlocks = nExceptionBlocks;
#endif

    // bitmap size for dirty basic blocks
    m_NumDirtyBasicBlockBitmapDwords = NUM_DWORD_BITMAPS(NumBasicBlocks);

    // allocate the basic block list and the dirty basic block 
    // bitmap, since we already know how many basic blocks there are
    // Also allocate the ExceptionBlock

    m_pDirtyBasicBlockBitmap = (DWORD *) new BYTE[ 
        m_NumDirtyBasicBlockBitmapDwords * sizeof(DWORD) +
        sizeof(BasicBlock) * NumBasicBlocks +
        sizeof(VerExceptionBlock) * nExceptionBlocks];

    if (m_pDirtyBasicBlockBitmap == NULL)
    {
        SET_ERR_OM();
        hr = E_OUTOFMEMORY;
        goto error;
    }

    // point to after the bitmap
    m_pBasicBlockList = (BasicBlock *) 
        &m_pDirtyBasicBlockBitmap[m_NumDirtyBasicBlockBitmapDwords];

    // ExceptionBlocks are the last in this array
    if (nExceptionBlocks != 0)
    {
        m_pExceptionBlockArray = (VerExceptionBlock *)
            ((PBYTE)m_pDirtyBasicBlockBitmap +
            m_NumDirtyBasicBlockBitmapDwords * sizeof(DWORD) +
            sizeof(BasicBlock) * NumBasicBlocks);
    }

    // set all basic blocks to NOT be dirty - we mark them dirty as we 
    // traverse them and see that m_pEntryState == NULL
    memset(m_pDirtyBasicBlockBitmap, 0, 
        m_NumDirtyBasicBlockBitmapDwords * sizeof(DWORD) +
        sizeof(BasicBlock) * NumBasicBlocks +
        sizeof(VerExceptionBlock) * nExceptionBlocks);

    // fill out the basic blocks, and check that all basic blocks start on an 
    // instruction boundary
    CurBlock = 0;

    for (i = 0; i < NumBitmapDwords; i++)
    {
        DWORD b = m_pBasicBlockBoundaryList[i];

        // any basic blocks declared?
        if (b != 0)
        {
            DWORD count;

            // check that all basic blocks start on an instruction boundary

            // This is the "invalid" case we need to check for
            //                       |
            //                      \|/
            // InstrBoundaryList:  0 0 1 1
            // BasicBlockBitmap:   0 1 0 1
            //
            // ~InstrBoundaryList: 1 1 0 0
            // ===========================
            // b & (~IBL)          0 1 0 0
            if ((b & (~m_pInstrBoundaryList[i])) != 0)
            {
                m_sError.dwFlags = VER_ERR_FATAL;
                SetErrorAndContinue(VER_E_BAD_JMP_TARGET);
                hr = E_FAIL;
                goto error;
            }

            // create entries for the BBs
            count = 0;

            while ((b & 255) == 0)
            {
                b >>= 8;
                count += 8;
            }

            do
            {
                BYTE lowest = g_FirstOneBit[b & 15];

                if (lowest != 0)
                {
                    b >>= lowest;
                    count += lowest;

                    _ASSERTE(CurBlock < NumBasicBlocks);
                    m_pBasicBlockList[CurBlock++].m_StartPC = (i * 32) + (count - 1);
                }
                else
                {
                    b >>= 4;
                    count += 4;
                }
            } while (b != 0);
        }
    }

    _ASSERTE(CurBlock == NumBasicBlocks);
    
    m_NumBasicBlocks = NumBasicBlocks;

    // Convert PCs to basic blocks
    RewriteExceptionList();

    if (!CreateExceptionTree())
    {
        hr = E_FAIL;
        goto error;
    }

    // success
    return S_OK;

error:
    return hr;
}


//
// Return the index of the BasicBlock starting at FindPC.
//
DWORD Verifier::FindBasicBlock(DWORD FindPC)
{
    DWORD   Low     = 0;
    DWORD   High    = m_NumBasicBlocks;
    DWORD   Mid;

    do
    {
        Mid = (Low + High) >> 1;

        if (m_pBasicBlockList[Mid].m_StartPC == FindPC)
            break;
        else if (m_pBasicBlockList[Mid].m_StartPC > FindPC)
            High = Mid-1;
        else // m_pBasicBlockList[Mid].m_StartPC < FindPC
            Low = Mid+1;
    } while (Low <= High);

    _ASSERTE(m_pBasicBlockList[Mid].m_StartPC == FindPC);
    return Mid;
}


//
// Given an EntryState, recreate the state from it.
//
void Verifier::CreateStateFromEntryState(const EntryState_t *pEntryState)
{
    // copy liveness table for primitive local variables
    // args are always live (whether primitive or non-primitive) so we don't store their state
    memcpy(
        m_pPrimitiveLocVarLiveness, 
        pEntryState->m_PrimitiveLocVarLiveness, 
        m_PrimitiveLocVarBitmapMemSize
    );

    // copy the non-primitive local variables and arguments types
    memcpy(
        m_pNonPrimitiveLocArgs,
        (BYTE *) pEntryState + m_NonPrimitiveLocArgOffset,
        m_NonPrimitiveLocArgMemSize
    );

    if (m_fInValueClassConstructor)
    {
        memcpy(
            m_pValueClassFieldsInited,
            (BYTE *) pEntryState + m_dwValueClassFieldBitmapOffset,
            m_dwNumValueClassFieldBitmapDwords * sizeof(DWORD)
        );
    }

    // copy the stack
    if (pEntryState->m_StackSlot != 0)
    {
        memcpy(
            m_pStack, 
            (BYTE *) pEntryState + m_StackItemOffset, 
            sizeof(Item) * pEntryState->m_StackSlot
        );
    }

    m_StackSlot = pEntryState->m_StackSlot;

    // Set the state of argument slot 0, if it contained an uninitialised object reference
    if (pEntryState->m_Flags & ENTRYSTATE_FLAG_ARGSLOT0_UNINIT)
        m_fThisUninit = TRUE;
    else
        m_fThisUninit = FALSE;
}


//
// Given the current state, create an EntryState from it
//
// Sets m_Refcount to 1 by default.
//
// If fException is TRUE, it means that we want to create a state for an exception handler,
// which means that pExceptionOnStack (if not NULL) should be set to be the only element on the stack.  
// If pExceptionOnStack is NULL, we're in a finally clause, so clear the stack.
//
// Otherwise, if fException is FALSE, proceed normally, and store the stack contents.
//
EntryState_t *Verifier::MakeEntryStateFromState()
{
    EntryState_t *pEntryState;

    pEntryState = (EntryState_t *) new BYTE[ 
        sizeof(EntryState_t) + m_StackItemOffset + (m_StackSlot * sizeof(Item))
    ];

    if (pEntryState == NULL)
    {
        SET_ERR_OM();
        return NULL;
    }

    pEntryState->m_Refcount = 1;

    // copy liveness table for primitive local variables (NOT args)
    memcpy(pEntryState->m_PrimitiveLocVarLiveness, m_pPrimitiveLocVarLiveness, m_PrimitiveLocVarBitmapMemSize);

    // copy the non-primitive local variables and arguments
    memcpy(
        (BYTE *) pEntryState + m_NonPrimitiveLocArgOffset,
        m_pNonPrimitiveLocArgs,
        m_NonPrimitiveLocArgMemSize
    );

    pEntryState->m_StackSlot = (WORD) m_StackSlot;

    if (m_StackSlot != 0)
    {
        memcpy(
            (BYTE *) pEntryState + m_StackItemOffset, 
            m_pStack,
            m_StackSlot * sizeof(Item)
        );
    }

    if (m_fInValueClassConstructor)
    {
        memcpy(
            (BYTE *) pEntryState + m_dwValueClassFieldBitmapOffset,
            m_pValueClassFieldsInited, 
            m_dwNumValueClassFieldBitmapDwords*sizeof(DWORD)
        );
    }

    pEntryState->m_Flags = 0;

    if (m_fThisUninit)
        pEntryState->m_Flags |= ENTRYSTATE_FLAG_ARGSLOT0_UNINIT;

    return pEntryState;
}


//
// Merge the current state onto the EntryState of the provided basic block (which must
// already exist).
//
// If this EntryState was shared with other basic blocks, then clone it first.
//
// Return FALSE if the states cannot be merged (e.g. stack depth inconsistent), or some error occurs.
//
// If fExceptionHandler is TRUE, then this basic block is an exception handler, so completely ignore
// the stack.
//
BOOL Verifier::MergeEntryState(BasicBlock *pBB, BOOL fExtendedState, 
        DWORD DestBB)
{
    EntryState_t *  pEntryState;
    DWORD           i;

    if (fExtendedState)
    {
        _ASSERTE(m_fHasFinally);
        pEntryState = pBB->m_ppExtendedState[DestBB];
    }
    else
    {
        pEntryState = pBB->m_pInitialState;
    }

    _ASSERTE(pEntryState != NULL);

    if (pEntryState->m_Refcount > 1)
    {
        EntryState_t *  pNewEntryState;
        DWORD           EntryStateSize;

        EntryStateSize = sizeof(EntryState_t) + m_StackItemOffset + (pEntryState->m_StackSlot * sizeof(Item));

        // another BB is using this EntryState, so clone it
        pNewEntryState = (EntryState_t *) new BYTE[EntryStateSize];

        if (pNewEntryState == NULL)
        {
            SET_ERR_OM();
            return FALSE;
        }

        // decrement refcount of old entry state
        pEntryState->m_Refcount--;

        // copy contents of shared entry state onto new entry state
        memcpy(
            pNewEntryState, 
            pEntryState, 
            EntryStateSize
        );

        // set basic block to point to the new entry state
        if (fExtendedState)
            pBB->m_ppExtendedState[DestBB] = pNewEntryState;
        else
            pBB->m_pInitialState = pNewEntryState;

        // only one reference to this entry state now
        pNewEntryState->m_Refcount = 1;

        pEntryState = pNewEntryState;
    }

    // primitive locvars (NOT args)
    for (i = 0; i < m_NumPrimitiveLocVarBitmapArrayElements; i++)
        pEntryState->m_PrimitiveLocVarLiveness[i] &= m_pPrimitiveLocVarLiveness[i];

    if (m_fInValueClassConstructor)
    {
        DWORD *pEntryStateFieldBitmap = (DWORD *) ((BYTE *) pEntryState + m_dwValueClassFieldBitmapOffset);

        for (i = 0; i < m_dwNumValueClassFieldBitmapDwords; i++)
            pEntryStateFieldBitmap[i] &= m_pValueClassFieldsInited[i];
    }
  
    // non-primitive locvars
    Item *pLocArg = (Item *) ((BYTE *) pEntryState + m_NonPrimitiveLocArgOffset);
    for (i = 0; i < m_NumNonPrimitiveLocVars; i++, pLocArg++)
    {
        // Dead is OK for locals.
        if (pLocArg->IsDead())
            continue;

        if (m_pNonPrimitiveLocArgs[i].IsDead())
        {
            pLocArg->SetDead();
            continue;
        }

        BOOL fSuccess = pLocArg->MergeToCommonParent(&m_pNonPrimitiveLocArgs[i]);
        if (!fSuccess)
        {
            m_sError.dwFlags = 
                (VER_ERR_LOCAL_VAR|VER_ERR_ITEM_1|VER_ERR_ITEM_2|VER_ERR_OFFSET);
            m_sError.dwVarNumber = i;
            m_sError.sItem1 = pLocArg->_GetItem();
            m_sError.sItem2 = m_pNonPrimitiveLocArgs[i]._GetItem();
            m_sError.dwOffset = pBB->m_StartPC;
            if (!SetErrorAndContinue(VER_E_PATH_LOC))
                return FALSE;

            // In validator mode.. Reset the Merge
            _ASSERTE((m_wFlags & VER_STOP_ON_FIRST_ERROR) == 0);

            *pLocArg = m_pNonPrimitiveLocArgs[i];
        }
    }

    // stack size must be constant
    if (m_StackSlot != pEntryState->m_StackSlot)
    {
        m_sError.dwFlags = (VER_ERR_FATAL|VER_ERR_OFFSET);
        m_sError.dwOffset = pBB->m_StartPC;
        SetErrorAndContinue(VER_E_PATH_STACK_DEPTH);
        return FALSE;
    }

    // this may make some stack entries "dead"
    Item *pEntryStack = (Item *) ((BYTE *) pEntryState + m_StackItemOffset);
    for (i = 0; i < pEntryState->m_StackSlot; i++)
    {
        BOOL fSuccess = pEntryStack->MergeToCommonParent(&m_pStack[i]);
        if (!fSuccess)
        {
            m_sError.dwFlags = 
                (VER_ERR_STACK_SLOT|VER_ERR_ITEM_1|VER_ERR_ITEM_2|VER_ERR_OFFSET);
            m_sError.dwStackSlot = i;
            m_sError.sItem1 = pEntryStack->_GetItem();
            m_sError.sItem2 = m_pStack[i]._GetItem();
            m_sError.dwOffset = pBB->m_StartPC;
            if (!SetErrorAndContinue(VER_E_PATH_STACK))
                return FALSE;

            // In validator mode.. Reset the Merge
            _ASSERTE((m_wFlags & VER_STOP_ON_FIRST_ERROR) == 0);

            *pEntryStack = m_pStack[i];
        }
        pEntryStack++;
    }


#ifdef _VER_DISALLOW_MULTIPLE_INITS 

    // The states must have the same state (init/uninit) for argument slot 0

    if (((pEntryState->m_Flags & ENTRYSTATE_FLAG_ARGSLOT0_UNINIT) == 0) !=
        (!m_fThisUninit))
    {
        m_sError.dwFlags = VER_ERR_OFFSET;
        m_sError.dwOffset = pBB->m_StartPC;
        if (!SetErrorAndContinue(VER_E_PATH_THIS))
            return FALSE;
    }

#else   //_VER_DISALLOW_MULTIPLE_INITS 

    // Ok to call .ctor more than once.

    // Merge ThisPtr(Uninit, Init) ==> ThisPtr(Uninit)

    if (m_fThisUninit)
        pEntryState->m_Flags |= ENTRYSTATE_FLAG_ARGSLOT0_UNINIT;

#endif // _VER_DISALLOW_MULTIPLE_INITS 

    return TRUE;
}

/*
 *   Finds the index of the first set bit in an array of DWORDS.
 */
BOOL Verifier::FindFirstSetBit(DWORD *pArray, DWORD cArray, DWORD *pIndex)
{
    DWORD i, elem, index;
    BYTE  firstOneBit;

    // For each element in the array
    for (i=0; i<cArray; ++i)
    {
        elem  = pArray[i];

        // Check if we have atleast one bit set in this element
        if (elem != 0)
        {
            index = i << 5;     // index is i * 32 + x

            // Skip bytes that are all zeroes
            while ((elem & 255) == 0)
            {
                elem >>= 8;
                index += 8;
            }

            do
            {
                // Find the first set bit in the last 4 bytes
                firstOneBit = g_FirstOneBit[elem & 15];

                if (firstOneBit != 0)
                {
                    // Found !

                    // (firstOneBit - 1) gives the zero based index
                    *pIndex = (index + firstOneBit - 1);

                    return TRUE;
                }

                // Skip these 4 bits
                elem >>= 4;
                index += 4;

            } while (elem != 0);
        }
    }

    return FALSE;
}

//
// Get the next BB to verify, return its index in ppBBNumber, and copy its initial state into 
// the current state.
//
// Return FALSE if no more basic blocks to verify.
//
BOOL Verifier::DequeueBB(DWORD *pBBNumber, BOOL *fExtendedState, DWORD *pDestBB)
{

    EntryState_t *pEntryState;

    // First see if any normal blocks are available
    if (FindFirstSetBit(m_pDirtyBasicBlockBitmap, 
        m_NumDirtyBasicBlockBitmapDwords, pBBNumber))
    {
        *pDestBB        = VER_BB_NONE;
        *fExtendedState = FALSE;
        pEntryState     = m_pBasicBlockList[*pBBNumber].m_pInitialState;

        goto Success;
    }

    if (m_fHasFinally)
    {
        // See if any of the extended blocks are dirty
        for (DWORD i=0; i<m_NumBasicBlocks; ++i)
        {
            if ((m_pBasicBlockList[i].m_pExtendedDirtyBitmap != NULL) &&
                FindFirstSetBit(m_pBasicBlockList[i].m_pExtendedDirtyBitmap,
                    m_NumDirtyBasicBlockBitmapDwords, pDestBB))
            {
                *pBBNumber      = i;
                *fExtendedState = TRUE;
    
                pEntryState = m_pBasicBlockList[i].m_ppExtendedState[*pDestBB];
    
                goto Success;
            }
        }
    }

    return FALSE;

Success:

    _ASSERTE(pEntryState);

    SetBasicBlockClean(*pBBNumber, *fExtendedState, *pDestBB);

    return TRUE;
}


//
// Check that the current state is compatible with the initial state of the basic block pBB.
//
// That is, if the basic block's initial state claims that locvar X is live, but it is not live
// in pState, then the states are not compatible, and FALSE is returned.  Similarly for the 
// state of the stack.  In addition, the types of the data on the stack must be checked.
//
BOOL Verifier::CheckStateMatches(EntryState_t *pEntryState)
{
    DWORD i;

    // Primitive local variables
    // For liveness information, the state must have a bit set for each bit in the BB's liveness table
    for (i = 0; i < m_NumPrimitiveLocVarBitmapArrayElements; i++)
    {
        // Check if all live vars in the previous state are live in the current state.
        // It is OK if more are live in the current state.
        if ((m_pPrimitiveLocVarLiveness[i] & pEntryState->m_PrimitiveLocVarLiveness[i]) != pEntryState->m_PrimitiveLocVarLiveness[i])
            return FALSE;
    }

    if (m_fInValueClassConstructor)
    {
        DWORD *pEntryStateFieldBitmap = (DWORD *) ((BYTE *) pEntryState + m_dwValueClassFieldBitmapOffset);

        for (i = 0; i < m_dwNumValueClassFieldBitmapDwords; i++)
        {
            if ((m_pValueClassFieldsInited[i] & pEntryStateFieldBitmap[i]) != pEntryStateFieldBitmap[i])
                return FALSE;
        }
    }

    // For non-primitive local variables
    Item *pLocArg = (Item *) ((BYTE *) pEntryState + m_NonPrimitiveLocArgOffset);
    for (i = 0; i < m_NumNonPrimitiveLocVars; i++, pLocArg++)
    {
        //
        // Verify that the state's local/arg is the same as or a subclass of the basic block's
        // entrypoint state.
        //

        // If the local/arg is unused in the basic block, then we are automatically compatible
        if (pLocArg->IsDead())
            continue;

        if (!m_pNonPrimitiveLocArgs[i].CompatibleWith(pLocArg, m_pClassLoader))
            return FALSE;

    }

    // Check that the stacks match
    if (pEntryState->m_StackSlot != m_StackSlot)
        return FALSE;

    Item *pEntryStack = (Item *) ((BYTE *) pEntryState + m_StackItemOffset);
    for (i = 0; i < m_StackSlot; i++, pEntryStack++)
    {
        // Check that the state's stack element is the same as or a subclass of the basic block's
        // entrypoint state
        if (!m_pStack[i].CompatibleWith(pEntryStack, m_pClassLoader))
            return FALSE;

    }


    // Verify that the initialisation status of the 'this' pointer is the same
    if (pEntryState->m_Flags & ENTRYSTATE_FLAG_ARGSLOT0_UNINIT)
    {
        if (!m_fThisUninit)
            return FALSE;
    }
#ifdef _VER_DISALLOW_MULTIPLE_INITS 
    else
    {
        if (m_fThisUninit)
            return FALSE;
    }
#endif // _VER_DISALLOW_MULTIPLE_INITS

    return TRUE;
}


void Verifier::ExchangeDWORDArray(DWORD *pArray1, DWORD *pArray2, DWORD dwCount)
{
    while (dwCount > 0)
    {
        DWORD dwTemp;
        
        dwTemp      = *pArray1;
        *pArray1++  = *pArray2;
        *pArray2++  = dwTemp;

        dwCount--;
    }
}


// @FUTURE: This is not very efficient
void Verifier::ExchangeItemArray(Item *pArray1, Item *pArray2, DWORD dwCount)
{
    while (dwCount > 0)
    {
        Item Temp;
        
        Temp        = *pArray1;
        *pArray1++  = *pArray2;
        *pArray2++  = Temp;

        dwCount--;
    }
}


// This function is called on the end of a filter.
// The state is propated to the filter handler.
BOOL Verifier::PropagateCurrentStateToFilterHandler(DWORD HandlerBB)
{
    _ASSERTE(m_verState >= verExceptToBB);

    Item    BackupSlotZeroStackItem;
    DWORD   BackupStackSize;
    BasicBlock *pBB;

#ifdef _DEBUG
    BOOL  fSetBBDirtyResult;
#endif

    // Make a backup of the state info we'll be trashing.

    BackupStackSize = m_StackSlot;

    if (m_StackSlot != 0)
        BackupSlotZeroStackItem = m_pStack[0]; // Slot 0 is NOT necessarily the top of the stack!

    if (m_MaxStackSlots < 1)
    {
        if (!SetErrorAndContinue(VER_E_STACK_EXCEPTION))
            return FALSE;
    }

    m_StackSlot = 1;

    m_pStack[0].SetKnownClass(g_pObjectClass);

    pBB = &m_pBasicBlockList[HandlerBB];

    if (pBB->m_pInitialState == NULL)
    {
        // create a new state
        pBB->m_pInitialState = MakeEntryStateFromState();

        if (pBB->m_pInitialState == NULL)
            return FALSE;

#ifdef _DEBUG
        fSetBBDirtyResult = 
#endif
        SetBasicBlockDirty(HandlerBB, FALSE, VER_BB_NONE);
        _ASSERTE(fSetBBDirtyResult);
    }
    else if (!CheckStateMatches(pBB->m_pInitialState))
    {
        // We've been there before, and the states don't match so merge
        if (!MergeEntryState(pBB, FALSE, VER_BB_NONE))
            return FALSE;

#ifdef _DEBUG
        fSetBBDirtyResult = 
#endif
        SetBasicBlockDirty(HandlerBB, FALSE, VER_BB_NONE);
        _ASSERTE(fSetBBDirtyResult);
    }

    // Restore stack state
    m_StackSlot = BackupStackSize;

    if (m_StackSlot != 0)
        m_pStack[0] = BackupSlotZeroStackItem;

    return TRUE;
}

//
// We're about to leave our current basic block and enter a new one, so take our current state
// and AND it with any stored entry state which may be attached to any exception handlers for this
// block.
//
BOOL Verifier::PropagateCurrentStateToExceptionHandlers(DWORD CurBB)
{

    _ASSERTE(m_verState >= verExceptToBB);


    Item    BackupSlotZeroStackItem;
    DWORD   BackupStackSize;
    DWORD   HandlerBB;
    DWORD   i;
    BasicBlock *pBB;
#ifdef _DEBUG
    BOOL  fSetBBDirtyResult;
#endif

#ifdef _VER_DISALLOW_MULTIPLE_INITS

    // If there are any locals (or arg slot 0) containing uninit vars, it is illegal to be
    // in a try block.  It's ok to have uninit vars on the stack, however, since the stack is
    // cleared upon entry to a catch.
    if (m_fThisUninit)
    {
        m_sError.dwFlags = VER_ERR_OFFSET;
        m_sError.dwOffset = m_pBasicBlockList[CurBB].m_StartPC;
        if (!SetErrorAndContinue(VER_E_THIS_UNINIT_EXCEP))
            return FALSE;
    }

#endif // _VER_DISALLOW_MULTIPLE_INITS

    //
    // This part is a bit narly.
    //
    // We want to use the MergeEntryState() and MakeEntryStateFromState() functions.  However, those
    // functions operate on the current verifier state only.  Therefore, we must backup the current
    // verifier state, then set up the state such that we are using the ExceptionLocVarLiveness
    // tables for liveness, and have nothing on the stack other than the exception we want to catch.
    //

    // Make a backup of the state info we'll be trashing.

    BackupStackSize = m_StackSlot;

    if (m_StackSlot != 0)
        BackupSlotZeroStackItem = m_pStack[0]; // Slot 0 is NOT necessarily the top of the stack!

    ExchangeDWORDArray(
        m_pExceptionPrimitiveLocVarLiveness, 
        m_pPrimitiveLocVarLiveness, 
        m_PrimitiveLocVarBitmapMemSize/sizeof(DWORD)
    );

    ExchangeItemArray(
        m_pExceptionNonPrimitiveLocArgs, 
        m_pNonPrimitiveLocArgs, 
        m_NonPrimitiveLocArgMemSize/sizeof(Item)
    );

    // Don't need to worry about value class field bitmap - we don't trash it


    // Search through all exception handlers for the ones which cover this block
    for (i = 0; i < m_NumExceptions; i++)
    {
        // If the exception starts before us, and after us, it applies to us.
        // m_dwTryEndXX is non-inclusive, so if it == CurBB then it does not apply to us.
        if (m_pExceptionList[i].dwTryXX <= CurBB && m_pExceptionList[i].dwTryEndXX > CurBB)
        {
            if (m_pExceptionList[i].eFlags & 
                (COR_ILEXCEPTION_CLAUSE_FINALLY|COR_ILEXCEPTION_CLAUSE_FAULT))
            {
                m_StackSlot = 0;
            }
            else
            {
                // There will be one exception on the stack
                m_StackSlot = 1;
            }

            if (m_MaxStackSlots < m_StackSlot)
            {
                if (!SetErrorAndContinue(VER_E_STACK_EXCEPTION))
                    return FALSE;
            }

            if ((m_pExceptionList[i].eFlags & COR_ILEXCEPTION_CLAUSE_FILTER) != 0)
            {
                // When an exception occurs, control is transfered to the 
                // filter, not the handler. The filter state is propagated to
                // it's handler when the filter ends with an endfilter.

                HandlerBB = m_pExceptionList[i].dwFilterXX;
                pBB = &m_pBasicBlockList[HandlerBB];
                m_pStack[0].SetKnownClass(g_pObjectClass);
            }
            else
            {
                HandlerBB = m_pExceptionList[i].dwHandlerXX;
                pBB = &m_pBasicBlockList[HandlerBB];

                if (m_StackSlot != 0)
                {
                    _ASSERTE(!m_pExceptionList[i].thException.IsNull());
                    m_pStack[0].SetTypeHandle(m_pExceptionList[i].thException);
                }
            }

            if (pBB->m_pInitialState == NULL)
            {
                // create a new state
                pBB->m_pInitialState = MakeEntryStateFromState();
                if (pBB->m_pInitialState == NULL)
                    return FALSE;
#ifdef _DEBUG
                fSetBBDirtyResult = 
#endif
                SetBasicBlockDirty(HandlerBB, FALSE, VER_BB_NONE);
                _ASSERTE(fSetBBDirtyResult);
            }
            else if (!CheckStateMatches(pBB->m_pInitialState))
            {
                // We've been there before and states don't match, so merge
                if (!MergeEntryState(pBB, FALSE, VER_BB_NONE))
                    return FALSE;
#ifdef _DEBUG
                fSetBBDirtyResult = 
#endif
                SetBasicBlockDirty(HandlerBB, FALSE, VER_BB_NONE);
                _ASSERTE(fSetBBDirtyResult);
            }
        }
    }

    // Restore stack state
    m_StackSlot  = BackupStackSize;

    if (m_StackSlot != 0)
        m_pStack[0] = BackupSlotZeroStackItem;

    // Get back our locvar arrays (we can trash the ExceptionPrimitive arrays)
    memcpy(m_pPrimitiveLocVarLiveness, m_pExceptionPrimitiveLocVarLiveness, m_PrimitiveLocVarBitmapMemSize);
    memcpy(m_pNonPrimitiveLocArgs, m_pExceptionNonPrimitiveLocArgs, m_NonPrimitiveLocArgMemSize);

    return TRUE;
}

/*
 *
 * Finally blocks have a special state called the FinallyState.
 * On processing a finally state, if the endfinally instruction is reached,
 * all leave destinations from the finally state is given a snap shot of the
 * current state.
 *
 * CreateLeaveState() creates a state with the current state of locals with
 * an empty stack. It restores the stack once a snapshot of the current 
 * state is taken.
 *
 */
BOOL Verifier::CreateLeaveState(DWORD leaveBB, EntryState_t **ppEntryState)
{

#ifdef _VER_DISALLOW_MULTIPLE_INITS

    // If there are any locals (or arg slot 0) containing uninit vars, it is 
    // illegal to be in a try block.  It's ok to have uninit vars on the stack,
    // since the stack is cleared upon entry to a finally.
    if (m_fThisUninit)
    {
        m_sError.dwFlags = VER_ERR_OFFSET;
        m_sError.dwOffset = m_pBasicBlockList[leaveBB].m_StartPC;
        if (!SetErrorAndContinue(VER_E_THIS_UNINIT_EXCEP))
            return FALSE;
    }

#endif _VER_DISALLOW_MULTIPLE_INITS

    // Control will go next to a leave target.

    DWORD               BackupStackSize;

    _ASSERTE(m_verState >= verExceptToBB);

    // Make a backup of the state info we'll be trashing.
    BackupStackSize = m_StackSlot;

    if (!HandleDestBasicBlock(leaveBB, ppEntryState, FALSE, VER_BB_NONE))
    {
       return FALSE;
    }

    // Restore stack state
    m_StackSlot = BackupStackSize;

    return TRUE;
}

/*
 *
 * Finally blocks have a special state called the FinallyState.
 * This is different from it's normal state.
 *
 * FinallyState is created on a leave instruction.
 * FinallyState is terminated on an endfilter.
 *
 * Controll cannot leave out of a finally state other than by an endfinally.
 *
 * CreateFinallyState() creates a state with the current state of locals with
 * an empty stack. It restores the stack once a snapshot of the current 
 * state is taken.
 *
 */
BOOL Verifier::CreateFinallyState(DWORD eIndex, 
                                  DWORD CurBB, 
                                  DWORD leaveBB,
                                  EntryState_t **ppEntryState)
{
#ifdef _VER_DISALLOW_MULTIPLE_INITS

    // If there are any locals (or arg slot 0) containing uninit vars, it is 
    // illegal to be in a try block.  It's ok to have uninit vars on the stack,
    // since the stack is cleared upon entry to a finally.
    if (m_fThisUninit)
    {
        m_sError.dwFlags = VER_ERR_OFFSET;
        m_sError.dwOffset = m_pBasicBlockList[CurBB].m_StartPC;
        if (!SetErrorAndContinue(VER_E_THIS_UNINIT_EXCEP))
            return FALSE;
    }

#endif // _VER_DISALLOW_MULTIPLE_INITS

    // Control will go next to a finally.
    // Add this state to the finally handler.

    DWORD             BackupStackSize;
    VerExceptionInfo *e       = &m_pExceptionList[eIndex];
    BasicBlock       *pBB     = &m_pBasicBlockList[e->dwHandlerXX];

    _ASSERTE(m_verState >= verExceptToBB);


    if (pBB->m_pAlloc == NULL && !pBB->AllocExtendedState(m_NumBasicBlocks))
    {
        SET_ERR_OM();
        return FALSE;
    }

    if (pBB->m_pException == NULL)
    {
        pBB->m_pException = e;
    }
    else
    {
        if (pBB->m_pException != e)
        {
            m_sError.dwFlags = VER_ERR_EXCEP_NUM_1;
            m_sError.dwException1 = eIndex;
            if (!SetErrorAndContinue(VER_E_FIN_OVERLAP))
                return FALSE;
        }
    }

    // Make a backup of the state info we'll be trashing.
    BackupStackSize = m_StackSlot;

    if (!HandleDestBasicBlock(e->dwHandlerXX, ppEntryState, TRUE, leaveBB))
    {
       return FALSE;
    }

    // Restore stack state
    m_StackSlot = BackupStackSize;

    return TRUE;
}


//
// We've done a STLOC.PTR while inside a try block, so AND the new state of that local
// with its current running state inside our basic block (may become dead).
//
// dwSlot is an index into the non-primitive local variable list
// pItem is the new contents of the local
//
void Verifier::MergeObjectLocalForTryBlock(DWORD dwSlot, Item *pItem)
{
    m_pExceptionNonPrimitiveLocArgs[dwSlot].MergeToCommonParent(pItem);
}


//
// Record the initial state of locals at the beginning of this basic block.
//
void Verifier::RecordCurrentLocVarStateForExceptions()
{
    memcpy(m_pExceptionPrimitiveLocVarLiveness, m_pPrimitiveLocVarLiveness, m_PrimitiveLocVarBitmapMemSize);
    memcpy(m_pExceptionNonPrimitiveLocArgs, m_pNonPrimitiveLocArgs, m_NonPrimitiveLocArgMemSize);
}


/*
 * Handle state queueing, checking, merging.
 *
 * If we have not been to the basic block before, set that it is dirty, 
 * and propagate our current state to it.  
 *
 * If we have been there before, check that our state matches that of the basic
 * block. 
 *
 * If not, merge states and set the basic block dirty.
 *
 * If *ppEntryState is not NULL, it is a shared EntryState to use if we have not
 * visited the basic block before, and create a new state.
 *
 * If a new EntryState is created, *ppEntryState is set to point to it.
 *
 * ppEntryState can be NULL, which causes the above to be ignored.
 *
 * Return FALSE for any fatal error that will make verification fail - states 
 * cannot be merged, out of memory, etc.
 *
 * If (pE != NULL) use leave state, else use the normal state.
 *
 */
BOOL Verifier::HandleDestBasicBlock(DWORD BBNumber, 
                                    EntryState_t **ppEntryState,
                                    BOOL fExtendedState,
                                    DWORD DestBB)
{
    BasicBlock *pBB = &m_pBasicBlockList[BBNumber];

    EntryState_t *  pEntryState;

    LOG((LF_VERIFIER, LL_INFO10000, "Handling dest BB Starting at PC 0x%x - ", 
        m_pBasicBlockList[BBNumber].m_StartPC));

    if (fExtendedState)
    {
        _ASSERTE(m_fHasFinally);

        LOG((LF_VERIFIER, LL_INFO10000,  "extended [0x%x] - ", 
            m_pBasicBlockList[DestBB].m_StartPC));

        if ((pBB->m_pAlloc == NULL) &&
            !pBB->AllocExtendedState(m_NumBasicBlocks))
        {
            SET_ERR_OM();
            return FALSE;
        }

        pEntryState = pBB->m_ppExtendedState[DestBB];

    }
    else
    {
        pEntryState = pBB->m_pInitialState;
    }

    LOG((LF_VERIFIER, LL_INFO10000, "\n"));

    // Have we been to the BB before?
    if (pEntryState == NULL)
    {
        LOG((LF_VERIFIER, LL_INFO10000, "have not been there before, "));

        // No, since it doesn't have an initial state
        if (!SetBasicBlockDirty(BBNumber, fExtendedState, DestBB))
            return FALSE;

        if (ppEntryState != NULL && *ppEntryState != NULL && 
            ((*ppEntryState)->m_Refcount < MAX_ENTRYSTATE_REFCOUNT))
        {
            LOG((LF_VERIFIER, LL_INFO10000, "refcounting provided state\n"));

            // refcount the state given to us
            if (fExtendedState)
                pBB->m_ppExtendedState[DestBB] = *ppEntryState;
            else
                pBB->m_pInitialState = *ppEntryState;

            (*ppEntryState)->m_Refcount++;
        }
        else
        {
            LOG((LF_VERIFIER, LL_INFO10000, "making new state\n"));

            // Create an initial state from our current state

            pEntryState = MakeEntryStateFromState();

            if (fExtendedState)
                pBB->m_ppExtendedState[DestBB] = pEntryState;
            else
                pBB->m_pInitialState = pEntryState;

            if (pEntryState == NULL)
                return FALSE; 

            if (ppEntryState != NULL)
                *ppEntryState = pEntryState;
        }
    }
    else if (!CheckStateMatches(pEntryState))
    {
        LOG((LF_VERIFIER, LL_INFO10000, "been there before, state does not match\n"));

        // We have been to the dest BB before, but our state doesn't match
        if (!MergeEntryState(pBB, fExtendedState, DestBB))
        {
            LOG((LF_VERIFIER, LL_INFO10000, "states incompatible for merge\n"));
            return FALSE;
        }

        if (!SetBasicBlockDirty(BBNumber, fExtendedState, DestBB))
            return FALSE;
    }
    else
    {
        LOG((LF_VERIFIER, LL_INFO10000, "been there before, state matches\n"));
    }

    return TRUE;
}


//
// Handles primitive arrays only - the operation string cannot specify object arrays
//
BOOL Verifier::GetArrayItemFromOperationString(LPCUTF8 *ppszOperation, Item *pItem)
{
    CorElementType el;

    switch (**ppszOperation)
    {
        default : 
            (*ppszOperation)++; 
            return FALSE;

        case '1': el = ELEMENT_TYPE_I1; break;
        case '2': el = ELEMENT_TYPE_I2; break;
        case '4': el = ELEMENT_TYPE_I4; break;
        case '8': el = ELEMENT_TYPE_I8; break;
        case 'r': el = ELEMENT_TYPE_R4; break;
        case 'd': el = ELEMENT_TYPE_R8; break;
        case 'i': el = ELEMENT_TYPE_I;  break;
    }

    (*ppszOperation)++;

    return pItem->SetArray(m_pClassLoader->FindArrayForElem(ElementTypeToTypeHandle(el), ELEMENT_TYPE_SZARRAY));
}


DWORD Verifier::OperationStringTypeToElementType(char c)
{
    switch (c)
    {
        default:
        {
            _ASSERTE(!"Verifier table error");
            return ELEMENT_TYPE_I4;
        }

        case '1': return ELEMENT_TYPE_I1;
        case '2': return ELEMENT_TYPE_I2;
        case '4': return ELEMENT_TYPE_I4;
        case '8': return ELEMENT_TYPE_I8;
        case 'r': return ELEMENT_TYPE_R4;
        case 'd': return ELEMENT_TYPE_R8;
        case 'i': return ELEMENT_TYPE_I;
    }
}


// Returns -1 if not found
// Converts a FieldDesc to an instance field number
long Verifier::FieldDescToFieldNum(FieldDesc *pFieldDesc)
{
    // Turn this FieldDesc into a FieldNum
    EEClass *   pClass = pFieldDesc->GetEnclosingClass();
    DWORD       dwNum = 0;

    FieldDescIterator fdIterator(pClass, FieldDescIterator::ALL_FIELDS);
    FieldDesc *pFD;
    while ((pFD = fdIterator.Next()) != NULL)
    {
        if (pFD == pFieldDesc)
            return (long) dwNum;

        if (!pFD->IsStatic())
            dwNum++;
    }

    return -1;
}

void Verifier::SetValueClassFieldInited(FieldDesc *pFieldDesc)
{
    long FieldNum = FieldDescToFieldNum(pFieldDesc);

    if (FieldNum < 0)
    {
        _ASSERTE(!"Fatal error, field not found");
    }
    else
    {
        SetValueClassFieldInited((DWORD) FieldNum);
    }
}

void Verifier::SetValueClassFieldInited(DWORD dwInstanceFieldNum)
{
    _ASSERTE(dwInstanceFieldNum < m_dwValueClassInstanceFields);
    m_pValueClassFieldsInited[dwInstanceFieldNum >> 5] |= (1 << (dwInstanceFieldNum & 31));
}

BOOL Verifier::IsValueClassFieldInited(DWORD dwInstanceFieldNum)
{
    _ASSERTE(dwInstanceFieldNum < m_dwValueClassInstanceFields);

    return (m_pValueClassFieldsInited[dwInstanceFieldNum >> 5] & (1 << (dwInstanceFieldNum & 31)));
}

BOOL Verifier::AreAllValueClassFieldsInited()
{
    DWORD i;

    for (i = 0; i < m_dwValueClassInstanceFields; i++)
    {
        if ((m_pValueClassFieldsInited[i >> 5] & (1 << (i & 31))) == 0)
            return FALSE;
    }

    return TRUE;
}

void Verifier::SetAllValueClassFieldsInited()
{
    DWORD i;

    for (i = 0; i < m_dwValueClassInstanceFields; i++)
        m_pValueClassFieldsInited[i >> 5] |= (1 << (i & 31));
}


DWORD Verifier::DoesLocalHavePinnedType(DWORD dwLocVar)
{
    _ASSERTE(dwLocVar < m_MaxLocals);
    return (m_pLocalHasPinnedType[dwLocVar >> 5] & (1 << (dwLocVar & 31)));
}



//
// Verify the provided code
//
#ifdef _VER_VERIFY_DEAD_CODE
HRESULT Verifier::Verify(DWORD CurBBNumber)
#else
HRESULT Verifier::Verify()
#endif
{
    HRESULT     hr;
    HRESULT     return_hr = E_FAIL; // default error condition
    DWORD       ipos;
    DWORD       NextBBStartPC;      // Starting PC of next basic block
    DWORD       DestBB          =   VER_BB_NONE;
    BOOL        fExtendedState  =   FALSE;
    BOOL        fFallThru       =   FALSE;
    BOOL        fInTryBlock;

    VerExceptionBlock *pTmpOuter = NULL, *pTmpInner = NULL;
    VerExceptionBlock *pOuterExceptionBlock = NULL;
    VerExceptionBlock *pInnerExceptionBlock = NULL;

    // If a Basic Block is part of multiple try / handlers, pInnerExceptionBlock
    // will  point to the innermost Exception block in the exception block tree.
    // pOuterExceptionBlock will point to the outermost block in the exception 
    // block tree.

#ifdef _VER_VERIFY_DEAD_CODE
// A little bit of perf here if dead code verification is not enabled..

#define _CurBBNumber CurBBNumber

    m_StackSlot         = 0;    // Reset the stack

#else

#define _CurBBNumber 0

    DWORD CurBBNumber   = 0;

#endif

    // The actual entry point.
    // Skip this step if we are verifying dead code
    if (_CurBBNumber == 0)
    {
        // First find the basic blocks
        hr = GenerateBasicBlockList();
        if (FAILED(hr))
            goto exit; // error message already set
    
        // Check the lexical nesting of exceptions.
        if (!VerifyLexicalNestingOfExceptions())
            goto exit; // error message already set
    
        // Assign slot #s to local variables and determine the size of an EntryState
        if (!AssignLocalVariableAndArgSlots())
        {
            SET_ERR_OM();
            return_hr = E_OUTOFMEMORY;
            goto exit;
        }
    }

#ifdef _VER_VERIFY_DEAD_CODE
    ipos = m_pBasicBlockList[_CurBBNumber].m_StartPC;
#else
    ipos = 0;    // Next instruction pointer
#endif

    // Set initial state of first basic block from current state (which was already set up before
    // we got into this function)
    m_pBasicBlockList[_CurBBNumber].m_pInitialState = MakeEntryStateFromState();
    if (m_pBasicBlockList[_CurBBNumber].m_pInitialState == NULL)
    {
        SET_ERR_OM();
        return_hr = E_OUTOFMEMORY;
        goto exit;
    }


    FindExceptionBlockAndCheckIfInTryBlock(_CurBBNumber, 
        &pOuterExceptionBlock, &pInnerExceptionBlock, &fInTryBlock);

    // Make sure we are not falling into an exception handler / filter
    if (!IsControlFlowLegal(
                VER_NO_BB,
                NULL,
                NULL,
                _CurBBNumber,
                pOuterExceptionBlock,
                pInnerExceptionBlock,
                eVerFallThru,
                0))
        goto exit;

    if (fInTryBlock)
    {
        // Record which primitive local variables are live at the beginning of this BB,
        // and the contents of all object local variables.  As we STLOC into the locals,
        // we will "and" together their contents to be conservative for the catch/finally block.
        RecordCurrentLocVarStateForExceptions();
    }

    // Get PC value for next basic block "transition"
    // If there is no "next" basic block, then pretend the next basic block starts at m_CodeSize
    if (m_NumBasicBlocks > (_CurBBNumber + 1))
        NextBBStartPC = m_pBasicBlockList[_CurBBNumber + 1].m_StartPC;
    else
        NextBBStartPC = m_CodeSize;


    LOG((LF_VERIFIER, LL_INFO10000, "----- Verifying BB starting at 0x%x ", 
        m_pBasicBlockList[_CurBBNumber].m_StartPC));

#ifdef _DEBUG
    PrintExceptionBlock(pOuterExceptionBlock, pInnerExceptionBlock);
#endif

    // This is the main loop
    while (1)
    {
        OPCODE  opcode;
        DWORD   OpcodeLen;
        BOOL    fStatic;
        BOOL    fLoadAddress;
        DWORD   Type;
        char    ch;
        const char *pszOperation;
        DWORD   inline_operand = 0;
        DWORD   dwPCAtStartOfInstruction = 0;
        Item *  pLastPoppedWhenParsing = NULL;
        DWORD   StackSlotAtStartOfInstruction;
        DWORD   PredictedStackSlotAtEndOfInstruction = 0;
#ifdef _DEBUG
        BOOL    fStaticStackCheckPossible = FALSE;
#endif

        // Have we fallen through to the next BB?  It is possible to do this without a control 
        // flow instruction if the exception handler changes.
        // A forward conditional branch could make us fall thru to the next BB.
        if (ipos >= NextBBStartPC)
        {
            // If we were in a try block, we've been accumulating a conservative list of the
            // contents of the local variables (AND'd together over the lifetime of the try
            // block), which we will now propagate to the catch/finally handler as its entry
            // state.
            if (fInTryBlock)
            {
                if (!PropagateCurrentStateToExceptionHandlers(CurBBNumber))
                    goto exit;
            }

            // Fall through to next BB
            CurBBNumber++; 
            
            LOG((LF_VERIFIER, LL_INFO10000, "Falling through to BB #%d\n", CurBBNumber));
            
            FindExceptionBlockAndCheckIfInTryBlock(CurBBNumber,
                &pTmpOuter, &pTmpInner, &fInTryBlock);

            // Make sure we are not falling into/out of an exception handler / filter
            if (!IsControlFlowLegal(
                        CurBBNumber - 1,
                        pOuterExceptionBlock,
                        pInnerExceptionBlock,
                        CurBBNumber,
                        pTmpOuter,
                        pTmpInner,
                        eVerFallThru,
                        dwPCAtStartOfInstruction))
                goto exit;

            if (!HandleDestBasicBlock(CurBBNumber, NULL, fExtendedState, DestBB))
                goto exit;

    
            if (!IsBasicBlockDirty(CurBBNumber, fExtendedState, DestBB))
                goto dequeueBB;

            fFallThru = TRUE;

            // Set up this basic block

setupCurBB:
            LOG((LF_VERIFIER, LL_INFO10000, "----- Verifying BB starting at 0x%x ",
                m_pBasicBlockList[CurBBNumber].m_StartPC));
        
#ifdef _DEBUG
            if (fExtendedState)
            {
                LOG((LF_VERIFIER, LL_INFO10000,  "extended [0x%x] ", 
                    m_pBasicBlockList[DestBB].m_StartPC));
        
            }
#endif

            if (fFallThru)
            {
                fFallThru = FALSE;
                pOuterExceptionBlock = pTmpOuter;
                pInnerExceptionBlock = pTmpInner;
            }
            else
            {
                FindExceptionBlockAndCheckIfInTryBlock(CurBBNumber, 
                    &pOuterExceptionBlock, &pInnerExceptionBlock, &fInTryBlock);
            }

#ifdef _DEBUG
            PrintExceptionBlock(pOuterExceptionBlock, pInnerExceptionBlock);
#endif

            // This code is called a few places.  It sets up the current state to verify basic block 
            // #CurBBNumber.  CurBBNumber must already have a state associated with it.
            SetBasicBlockClean(CurBBNumber, fExtendedState, DestBB);
            ipos = m_pBasicBlockList[CurBBNumber].m_StartPC;


            // Create current state from state stored with the basic block
            if (fExtendedState)
            {
                _ASSERTE(m_pBasicBlockList[CurBBNumber].m_ppExtendedState[DestBB] != NULL);
                CreateStateFromEntryState(m_pBasicBlockList[CurBBNumber].
                    m_ppExtendedState[DestBB]);
            }
            else
            {
                // The basic block must have a state associated with it
                _ASSERTE(m_pBasicBlockList[CurBBNumber].m_pInitialState != NULL);
                CreateStateFromEntryState(m_pBasicBlockList[CurBBNumber].
                    m_pInitialState);
            }


            if (fInTryBlock)
            {
                // Record which primitive local variables are live at the beginning of this BB,
                // and the contents of all object local variables.
                RecordCurrentLocVarStateForExceptions();

                // It is illegal to have a non empty stack on entering a 
                // try block. Check if this is the start of a try block.
                // Testing the inner exception block is sufficient. 
                // If a try and and inner handler block start at the same 
                // location, IsControlFlowLeagal() would have caught this.

                _ASSERTE(pInnerExceptionBlock);

                if ((m_StackSlot != 0) &&
                    (pInnerExceptionBlock->StartBB == CurBBNumber) &&
                    (pInnerExceptionBlock->eType == eVerTry))
                {
                    m_sError.dwFlags = VER_ERR_OFFSET;
                    m_sError.dwOffset = ipos;
                    if (!SetErrorAndContinue(VER_E_TRY_N_EMPTY_STACK))
                        goto exit;
                }
            }

            // if we are at the end of the code, there is no next BB
            if (CurBBNumber + 1 >= m_NumBasicBlocks)
                NextBBStartPC = m_CodeSize;
            else
                NextBBStartPC = m_pBasicBlockList[CurBBNumber+1].m_StartPC;
        }

        // Record ipos at the beginning of the instruction, for the purpose of error messages
        dwPCAtStartOfInstruction = ipos;
        opcode = DecodeOpcode(&m_pCode[ipos], &OpcodeLen);

#ifdef _DEBUG
        if (m_fDebugBreak)
        {
            if (g_pConfig->IsVerifierBreakOffsetEnabled() &&
                (g_pConfig->GetVerifierBreakOffset() == 
                (int) dwPCAtStartOfInstruction) &&
                (!g_pConfig->IsVerifierBreakPassEnabled() ||
                (g_pConfig->GetVerifierBreakPass() == 2)))
            {
                DebugBreak();
            }
        }

        LOG((LF_VERIFIER, LL_INFO10000, "\n"));
        PrintQueue();
        PrintState();
        LOG((LF_VERIFIER, LL_INFO10000, "%04x: %s ", ipos, ppOpcodeNameList[opcode]));
#endif

        ipos += OpcodeLen;

        // This should never happen, because we already checked this on the first pass
        _ASSERTE(opcode < CEE_COUNT);


        // Save away current stackpointer.
        StackSlotAtStartOfInstruction = m_StackSlot;
        PredictedStackSlotAtEndOfInstruction = (DWORD) (StackSlotAtStartOfInstruction + OpcodeNetPush[opcode]);

#ifdef _DEBUG

        fStaticStackCheckPossible = OpcodeNetPush[opcode] != VarPush;

        // Leave clears the stack
        if ((opcode == CEE_LEAVE) || (opcode == CEE_LEAVE_S) || 
            (opcode == CEE_ENDFINALLY))
            fStaticStackCheckPossible = FALSE;

#endif // _DEBUG

        if (PredictedStackSlotAtEndOfInstruction > m_MaxStackSlots && OpcodeNetPush[opcode] != VarPush)
        {
            if (OpcodeNetPush[opcode] > 0)
            {
                FAILMSG_PC_STACK_OVERFLOW();
            }
            else
            {
                FAILMSG_PC_STACK_UNDERFLOW();
            }
            goto exit;
        }

        switch (OpcodeData[opcode])
        {
            // Handle InlineSwitch, specially
            case InlineSwitch:
            case InlineNone:
                LOG((LF_VERIFIER, LL_INFO10000, "\n"));
                break;

            case ShortInlineVar:    
            case ShortInlineI:    
                READU1(m_pCode, ipos, inline_operand);
                LOG((LF_VERIFIER, LL_INFO10000, "0x%x\n", inline_operand));
                break;

            case ShortInlineBrTarget:
                READU1(m_pCode, ipos, inline_operand);
                break;

            case InlineVar:    
                READU2(m_pCode, ipos, inline_operand);
                LOG((LF_VERIFIER, LL_INFO10000, "0x%x\n", inline_operand));
                break;

            case InlineI:   
            case ShortInlineR:   
                READU4(m_pCode, ipos, inline_operand);
                LOG((LF_VERIFIER, LL_INFO10000, "0x%x\n", inline_operand));
                break;

            case InlineBrTarget:
            case InlineField:   
            case InlineString:   
            case InlineType:   
            case InlineTok:   
            case InlineRVA:   
            case InlineMethod:   
            case InlineSig:
                READU4(m_pCode, ipos, inline_operand);
                break;
                
            case InlineI8:    
            case InlineR:
                // We don't need to read this value...
                ipos += 8;
                LOG((LF_VERIFIER, LL_INFO10000, "0x(some value)\n"));
                break;

            case HackInlineAnnData:
                READU4(m_pCode, ipos, inline_operand);
                ipos += inline_operand;
                LOG((LF_VERIFIER, LL_INFO10000, "0x%x\n", inline_operand));
                break;
        }

        // Get the operation string for this opcode
        pszOperation = g_pszVerifierOperation[opcode];
        ch = *pszOperation++;

        // Read operation string, popping stack as required
        pLastPoppedWhenParsing = NULL;

        // Keep going until we hit : (meaning, stop popping the stack), or !
        while (ch != ':' && ch != '!')
        {
            // Ensure we didn't hit the end of the string
            _ASSERTE(ch != '\0');
            
            Item *pItem = PopItem();
            if (pItem == NULL)
            {
                FAILMSG_PC_STACK_UNDERFLOW();
                goto exit;
            }

            Type = pItem->GetType();

            switch (ch)
            {
                default:
                {
                    _ASSERTE(!"Unhandled verifier case");
                    m_sError.dwFlags = (VER_ERR_FATAL|VER_ERR_OPCODE_OFFSET);
                    SET_ERR_OPCODE_OFFSET();
                    SetErrorAndContinue(VER_E_INTERNAL);
                    goto exit;
                }

                case '!':
                {
                    break;
                }

                case '=':
                {
                    // Pop an item off the stack, and it must be the same type as the last item

                    // &foo &bar are NOT the same
                    // foo and bar are the same if they are both object refs
                    _ASSERTE(pLastPoppedWhenParsing != NULL);

                    // Don't allow subclass relationship (that's the reason for the FALSE parameter)
                    // However, DO allow System/Int32 and I4 to be interchangeable.
                    // Also need to nix the particular object type if an objref
                    if (pItem->IsObjRef())
                    {
                        if (!pLastPoppedWhenParsing->IsObjRef())
                        {
eq_error:
                            m_sError.dwFlags = (VER_ERR_ITEM_1|VER_ERR_ITEM_2|
                                            VER_ERR_OPCODE_OFFSET);
                            m_sError.sItem1 = pItem->_GetItem();
                            m_sError.sItem2 = pLastPoppedWhenParsing->_GetItem();
                            SET_ERR_OPCODE_OFFSET();
                            if (!SetErrorAndContinue(VER_E_STACK_NOT_EQ))
                                goto exit;
                        }

                        // They're both objrefs, that's good enough
                    }
                    else
                    {
                        // Handle other combinations
                        pLastPoppedWhenParsing->NormaliseToPrimitiveType();
                        pItem->NormaliseToPrimitiveType();

                        if (!pItem->CompatibleWith(pLastPoppedWhenParsing, m_pClassLoader, FALSE))
                        {
                            goto eq_error;
                        }
                    }

                    break;
                }

                case 'C':
                {
                    // "CE:.." and "CG:.." operations
                    //
                    // CE ==> Equal (and Not Equal) operations
                    //      {beq,   bne.un,   ceq,
                    //       beq.s, bne.un.s, cgt.un}
                    //
                    //       cgt.un is for bool f = X isinst T
                    //          ==> ldloc X, isinst T, cgt.un, stloc f
                    //
                    // CG ==> Greater / Lesser than operations
                    //      {bge,   bge.un,   bgt,   bgt.un,   ble,   ble.un, 
                    //       bge.s, bge.un.s, bgt.s, bgt.un.s, ble.s, ble.un.s, 
                    //       blt,   blt.un,   cgt,   clt,      clt.un,
                    //       blt.s, blt.un.s}
                    //
                    // All operations are allowed if the base types are the same
                    // number type
                    // Eg. (I4, I4), (F, F)
                    //
                    // All operations are allowed on BYREFS
                    // (BYREF, BYREF)
                    //
                    // Objectref are allowed only Equals operations
                    // (OBJREF, OBJREF)
                    //
                    // Value Types are not allowed.

                    ch = *pszOperation++;

                    Item *pItem2 = PopItem();

                    if (pItem2 == NULL)
                    {
                        FAILMSG_PC_STACK_UNDERFLOW();
                        goto exit;
                    }

                    // Convert &System/Int32 to &I4, &System/Char to &I2 etc.
                    pItem->NormaliseToPrimitiveType();
                    pItem2->NormaliseToPrimitiveType();

                    if (pItem->IsUninitialised() || pItem2->IsUninitialised())
                    {
                        m_sError.dwFlags = VER_ERR_OPCODE_OFFSET;
                        SET_ERR_OPCODE_OFFSET();
                        if (!SetErrorAndContinue(VER_E_STACK_UNINIT))
                            goto exit;
                    }

                    Type = pItem->GetType();

                    if (Type != pItem2->GetType())
                    {
                        m_sError.dwFlags = (VER_ERR_ITEM_1|VER_ERR_ITEM_2|
                                VER_ERR_OPCODE_OFFSET);
                        m_sError.sItem1 = pItem->_GetItem();
                        m_sError.sItem2 = pItem2->_GetItem();
                        SET_ERR_OPCODE_OFFSET();
                        if (!SetErrorAndContinue(VER_E_STACK_NOT_EQ))
                            goto exit;
                    }

                    if (pItem->IsOnStackNumberType() || 
                        (Type == ELEMENT_TYPE_BYREF))
                    {
                        // We pass
                        break;
                    }

                    // Method pointers are OK.

                    // Otherwise Item is something other than an integer 
                    // or real number. It could be a Value type, Objectref or
                    // a dead node.

                    if ((Type != VER_ELEMENT_TYPE_OBJREF) || (ch != 'E'))
                    {
                        m_sError.dwFlags = 
                            (VER_ERR_ITEM_1|VER_ERR_ITEM_2|VER_ERR_OPCODE_OFFSET);
                        m_sError.sItem1 = pItem->_GetItem();
                        m_sError.sItem2 = pItem2->_GetItem();
                        SET_ERR_OPCODE_OFFSET();
                        if (!SetErrorAndContinue(VER_E_STACK_UNEXPECTED))
                            goto exit;
                    }

                    break;
                }

                case 'I':
                {
                    // Convert System/Int32 to I4, Char to I2 etc.
                    pItem->NormaliseToPrimitiveType();

                    if (!pItem->IsOnStackInt())
                    {
                        m_sError.dwFlags = (VER_ERR_ITEM_F|VER_ERR_OPCODE_OFFSET);
                        m_sError.sItemFound = pItem->_GetItem();
                        SET_ERR_OPCODE_OFFSET();
                        if (!SetErrorAndContinue(VER_E_STACK_I_I4_I8))
                            goto exit;
                    }

                    break;
                }

                case 'R':
                {
                    // Convert System/Int32 to I4, Char to I2 etc.
                    pItem->NormaliseToPrimitiveType();

                    if (!pItem->IsOnStackReal())
                    {
                        m_sError.dwFlags = (VER_ERR_ITEM_F|VER_ERR_OPCODE_OFFSET);
                        m_sError.sItemFound = pItem->_GetItem();
                        SET_ERR_OPCODE_OFFSET();
                        if (!SetErrorAndContinue(VER_E_STACK_R_R4_R8))
                            goto exit;
                    }

                    break;
                }

                case 'N':
                case 'Q':
                {
                    // Convert System/Int32 to I4, Char to I2 etc.
                    pItem->NormaliseToPrimitiveType();

                    // Must be an integer, or a single, or a double
                    if (!pItem->IsOnStackNumberType())
                    {
                        m_sError.dwFlags = (VER_ERR_ITEM_F|VER_ERR_OPCODE_OFFSET);
                        m_sError.sItemFound = pItem->_GetItem();
                        SET_ERR_OPCODE_OFFSET();
                        if (!SetErrorAndContinue(VER_E_STACK_NUMERIC))
                            goto exit;
                    }

                    break;
                }

                // Anything
                case 'A':
                {
                    // Convert System/Int32 to I4, Char to I2 etc.
                    pItem->NormaliseToPrimitiveType();
                    break;
                }
    


                // Integer (I1,..4, 8), unmanaged pointer, managed pointer, objref
                case 'Y': 
                {
                    // Convert System/Int32 to I4, Char to I2 etc.
                    pItem->NormaliseToPrimitiveType();

                    if (pItem->IsValueClass())
                    {
                        m_sError.dwFlags = (VER_ERR_ITEM_F|VER_ERR_OPCODE_OFFSET);
                        m_sError.sItemFound = pItem->_GetItem();
                        SET_ERR_OPCODE_OFFSET();
                        if (!SetErrorAndContinue(VER_E_STACK_NO_VALCLASS))
                            goto exit;
                    }

                    Type = pItem->GetType();

                    if (Type == ELEMENT_TYPE_R8)
                    {
                        m_sError.dwFlags = (VER_ERR_ITEM_F|VER_ERR_OPCODE_OFFSET);
                        m_sError.sItemFound = pItem->_GetItem();
                        SET_ERR_OPCODE_OFFSET();
                        if (!SetErrorAndContinue(VER_E_STACK_NO_R_I8))
                            goto exit;
                    }

                    break;
                }

                case '4':
                case '8':
                {
                    if (Type != OperationStringTypeToElementType(ch))
                    {
                        m_sError.dwFlags = (VER_ERR_ITEM_F|VER_ERR_ITEM_E|
                                VER_ERR_OPCODE_OFFSET);
                        m_sError.sItemFound = pItem->_GetItem();
                        m_sError.sItemExpected.dwFlags = 
                            OperationStringTypeToElementType(ch);
                        m_sError.sItemExpected.pv = NULL;
                        SET_ERR_OPCODE_OFFSET();
                        if (!SetErrorAndContinue(VER_E_STACK_UNEXPECTED))
                            goto exit;
                    }
                    break;
                }

                case 'r':
                case 'd':
                {
                    // R4 & R8 are allowed to be used in place of each other.
                    if (Type != ELEMENT_TYPE_R8)
                    {
                        m_sError.dwFlags = (VER_ERR_ITEM_F|VER_ERR_ITEM_E|
                                VER_ERR_OPCODE_OFFSET);
                        m_sError.sItemFound = pItem->_GetItem();
                        m_sError.sItemExpected.dwFlags = ELEMENT_TYPE_R8;
                        m_sError.sItemExpected.pv = NULL;
                        SET_ERR_OPCODE_OFFSET();
                        if (!SetErrorAndContinue(VER_E_STACK_UNEXPECTED))
                            goto exit;
                    }
                    break;

                }

                case 'o': // must be objref
                {
                    if (!pItem->IsObjRef())
                    {
                        m_sError.dwFlags = (VER_ERR_ITEM_F|VER_ERR_OPCODE_OFFSET);
                        m_sError.sItemFound = pItem->_GetItem();
                        SET_ERR_OPCODE_OFFSET();
                        if (!SetErrorAndContinue(VER_E_STACK_OBJREF))
                            goto exit;
                    }

                    if (pItem->IsUninitialised())
                    {
                        m_sError.dwFlags = VER_ERR_OPCODE_OFFSET;
                        SET_ERR_OPCODE_OFFSET();
                        if (!SetErrorAndContinue(VER_E_STACK_UNINIT))
                            goto exit;
                    }

                    break;
                }

                // Platform indepdent size number
                // I4/R4/U4 on 32-bit, I8/R8/U8 on 64 bit, "ptr" on either machine type
                // Objref NOT allowed
                case 'i':
                {
                    // I == I4 on 32 bit machines
                    // I4 and I are implemented as I8 on 64 bit machines
                    if (Type != ELEMENT_TYPE_I4)
                    {
                        m_sError.dwFlags = (VER_ERR_ITEM_F|VER_ERR_ITEM_E|
                            VER_ERR_OPCODE_OFFSET);
                        m_sError.sItemFound = pItem->_GetItem();
                        m_sError.sItemExpected.dwFlags = ELEMENT_TYPE_I4;
                        m_sError.sItemExpected.pv = NULL;
                        SET_ERR_OPCODE_OFFSET();
                        if (!SetErrorAndContinue(VER_E_STACK_UNEXPECTED))
                            goto exit;
                    }
                    break;
                }

                case '&': // byref
                {
                    Item DesiredItem;

                    if (Type != ELEMENT_TYPE_BYREF)
                    {
                        m_sError.dwFlags = (VER_ERR_ITEM_F|VER_ERR_OPCODE_OFFSET);
                        m_sError.sItemFound = pItem->_GetItem();
                        SET_ERR_OPCODE_OFFSET();
                        if (!SetErrorAndContinue(VER_E_STACK_BYREF))
                            goto exit;
                    }

                    ch = *pszOperation++;

                    // &U2 or &System/Char could be on the stack, etc.
                    DesiredItem.SetType(OperationStringTypeToElementType(ch));
                    DesiredItem.MakeByRef();

                    if (!pItem->CompatibleWith(&DesiredItem, m_pClassLoader))
                    {
                        m_sError.dwFlags = (VER_ERR_ITEM_F|VER_ERR_ITEM_E|
                                VER_ERR_OPCODE_OFFSET);
                        m_sError.sItemFound = pItem->_GetItem();
                        m_sError.sItemExpected = DesiredItem._GetItem();
                        SET_ERR_OPCODE_OFFSET();
                        if (!SetErrorAndContinue(VER_E_STACK_UNEXPECTED))
                            goto exit;
                    }

                    break;
                }

                case '[': // SD array of...
                {
                    // Guaranteed to be primitive array (i.e. not objref or value class)

                    // Null is always acceptable as an SD array of something
                    if (pItem->IsNullObjRef() || 
                        pItem->IsSingleDimensionalArray())
                    {
                        Item DesiredArrayItem;

                        // We have an array on the stack
                        // If we are parsing [* it means an SD array of anything is ok
                        if (*pszOperation == '*')
                        {
                            pszOperation++;
                        }
                        else
                        {
                            // What type of array did we want?
                            if (!GetArrayItemFromOperationString(&pszOperation, &DesiredArrayItem))
                            {
                                m_sError.dwFlags = (VER_ERR_FATAL|VER_ERR_OPCODE_OFFSET);
                                SET_ERR_OPCODE_OFFSET();
                                SetErrorAndContinue(VER_E_INTERNAL);
                                goto exit;
                            }
                
                            // The array class must be what we were expecting
                            if (!pItem->CompatibleWith(&DesiredArrayItem, m_pClassLoader))
                            {
                                m_sError.dwFlags = (VER_ERR_ITEM_F|VER_ERR_ITEM_E|
                                        VER_ERR_OPCODE_OFFSET);
                                m_sError.sItemFound = pItem->_GetItem();
                                m_sError.sItemExpected = DesiredArrayItem._GetItem();
                                SET_ERR_OPCODE_OFFSET();
                                if (!SetErrorAndContinue(VER_E_STACK_UNEXPECTED))
                                    goto exit;
                            }
                        }
                    }
                    else
                    {
                        m_sError.dwFlags = (VER_ERR_FATAL|VER_ERR_ITEM_F|VER_ERR_OPCODE_OFFSET);
                        m_sError.sItemFound = pItem->_GetItem();
                        SET_ERR_OPCODE_OFFSET();
                        SetErrorAndContinue(VER_E_STACK_ARRAY_SD);
                        goto exit;
                    }

                    break;
                }
            }

            ch = *pszOperation++;
            pLastPoppedWhenParsing = pItem;
        } 

        if (ch != '!')
        {
            // Now handle pushing things onto the stack, branches, and operand checks
            while (1)
            {
                ch = *pszOperation++;
                if (ch == '\0' || ch == '!')
                    break;

                DWORD Type;

                switch (ch)
                {
                    default:
                    {
                        _ASSERTE(!"Error in verifier operation string");
                        m_sError.dwFlags = (VER_ERR_FATAL|VER_ERR_OPCODE_OFFSET);
                        SET_ERR_OPCODE_OFFSET();
                        SetErrorAndContinue(VER_E_INTERNAL);
                        goto exit;
                    }

                    case '-':
                    {
                        // Undo the last stack pop
                        m_StackSlot++;
                        break;
                    }

                    case '#':
                    {
                        // Get inline operand (#0-#9 max) from table
                        _ASSERTE(*pszOperation >= '0' && *pszOperation <= '9');
                        inline_operand = (*pszOperation - '0');
                        pszOperation++;
                        break;
                    }

                    case 'A':
                    {
                        // Verify operand is a valid argument number
                        if (inline_operand >= m_NumArgs)
                        {
                            m_sError.dwFlags = (VER_ERR_FATAL|VER_ERR_ARGUMENT|VER_ERR_OPCODE_OFFSET);
                            m_sError.dwArgNumber = inline_operand;
                            SET_ERR_OPCODE_OFFSET();
                            SetErrorAndContinue(VER_E_ARG_NUM);
                            goto exit;
                        }

                        break;
                    }

                    case 'L':
                    {
                        // Verify operand is a valid local variable
                        if (inline_operand >= m_MaxLocals)
                        {
                            m_sError.dwFlags = (VER_ERR_FATAL|VER_ERR_LOCAL_VAR|VER_ERR_OPCODE_OFFSET);
                            m_sError.dwVarNumber = inline_operand;
                            SET_ERR_OPCODE_OFFSET();
                            SetErrorAndContinue(VER_E_LOC_NUM);
                            goto exit;
                        }

                        break;
                    }

                    case 'i':
                        // I == I4 on 32 bit machines
                        // I4 and I are implemented as I8 on 64 bit machines
                    case '4':
                    {
                        Type = ELEMENT_TYPE_I4;
push_primitive:
                        if (!PushPrimitive(Type)) 
                        { 
                            FAILMSG_PC_STACK_OVERFLOW();
                            goto exit; 
                        }   
                        break;
                    }

                    case '8':
                        Type = ELEMENT_TYPE_I8;
                        goto push_primitive;

                    case 'r':
                        // R4s are promoted to R8 on the stack
                    case 'd':
                        Type = ELEMENT_TYPE_R8;
                        goto push_primitive;


                    case 'n':
                    {
                        Item item;
                        
                        item.SetToNullObjRef();
                        if (!Push(&item)) 
                        { 
                            FAILMSG_PC_STACK_OVERFLOW();
                            goto exit; 
                        }   
                        break;
                    }

                    case '[':
                    {
                        // Guaranteed to be primitive array
                        Item        NewArray;

                        if (!GetArrayItemFromOperationString(&pszOperation, &NewArray))
                        {
                            m_sError.dwFlags = (VER_ERR_FATAL|VER_ERR_OPCODE_OFFSET);
                            SET_ERR_OPCODE_OFFSET();
                            SetErrorAndContinue(VER_E_INTERNAL);
                            goto exit;
                        }

                        if (!Push(&NewArray))
                        {
                            FAILMSG_PC_STACK_OVERFLOW();
                            goto exit;
                        }

                        break;
                    }

                    case 'b': // conditional branch
                    case 'u': // unconditional branch
                    case 'l': // leave
                    {
                        long        offset;
                        DWORD       DestPC;
                        DWORD       DestBBNumber;
                        EntryState_t *pCreatedState;

                        // Read branch type
                        if (*pszOperation == '1')
                        {
                            // Sign extend
                            offset = (long) ((char) inline_operand);
                        }
                        else
                        {
                            _ASSERTE(*pszOperation == '4');
                            offset = (long) (inline_operand);
                        }

                        pszOperation++;

                        DestPC = ipos + offset;

                        LOG((LF_VERIFIER, LL_INFO10000, "0x%x (rel %i)\n", DestPC, offset));

#ifdef _VER_DISALLOW_MULTIPLE_INITS

                        if ((m_fThisUninit) && (DestPC < ipos))
                        {
                            m_sError.dwFlags = VER_ERR_OPCODE_OFFSET;
                            SET_ERR_OPCODE_OFFSET();
                            if (!SetErrorAndContinue(VER_E_THIS_UNINIT_BR))
                                goto exit;
                        }

#endif // _VER_DISALLOW_MULTIPLE_INITS

                        if (fInTryBlock)
                        {
                            LOG((LF_VERIFIER, LL_INFO10000, "In try block - propagating current state to exception handlers\n"));

                            if (!PropagateCurrentStateToExceptionHandlers(CurBBNumber))
                                goto exit;
                        }

                        // find destination basic block
                        DestBBNumber = FindBasicBlock(DestPC);

                        FindExceptionBlockAndCheckIfInTryBlock(DestBBNumber, 
                            &pTmpOuter, &pTmpInner, NULL);

                        if (!IsControlFlowLegal(
                                    CurBBNumber,
                                    pOuterExceptionBlock,
                                    pInnerExceptionBlock,
                                    DestBBNumber,
                                    pTmpOuter,
                                    pTmpInner,
                                    (ch == 'l') ? eVerLeave : eVerBranch,
                                    dwPCAtStartOfInstruction))
                            goto exit;

                        pCreatedState = NULL;

                        if (ch == 'b')
                        {
                            // Conditional branch

                            // Check the fall thru case
                            FindExceptionBlockAndCheckIfInTryBlock(
                                CurBBNumber+1, &pTmpOuter, &pTmpInner, NULL);

                            if (!IsControlFlowLegal(
                                        CurBBNumber,
                                        pOuterExceptionBlock,
                                        pInnerExceptionBlock,
                                        CurBBNumber + 1,
                                        pTmpOuter,
                                        pTmpInner,
                                        eVerFallThru,
                                        dwPCAtStartOfInstruction))
                                goto exit;

                            // Fallthrough case
                            if (!HandleDestBasicBlock(CurBBNumber+1, &pCreatedState, fExtendedState, DestBB))
                                goto exit;

                            // allow the dest BB to refcount the fallthrough BB's entrystate if necessary
                            if (!HandleDestBasicBlock(DestBBNumber, &pCreatedState, fExtendedState, DestBB))
                                goto exit;

                            // Now visit a BB
                            if (IsBasicBlockDirty(CurBBNumber+1, fExtendedState, DestBB))
                            {
                                CurBBNumber++; // advance to fallthrough BB
                                goto setupCurBB;
                            }

                            // Fall through...
                        }
                        else if (ch == 'u') // unconditional branch
                        {
                            // Handle path merging etc.
                            if (!HandleDestBasicBlock(DestBBNumber, NULL, fExtendedState, DestBB))
                                goto exit;
                        }
                        else
                        {
                            _ASSERTE(ch == 'l'); // leave

                            // Leave clears the stack.
#ifdef _DEBUG
                            if (m_StackSlot != 0)
                            {
                                LOG((LF_VERIFIER, LL_INFO10000, 
                                    "Clearing 0x%x stack entries on leave\n", 
                                    m_StackSlot));
                            }
#endif
                            m_StackSlot = 0;

                            // Check if this "leave" is guarded by a finally.
                            // If so, and if the destination is outside the
                            // scope of that finally, then control goes to
                            // the finally. Otherwise, treat this as an expensive
                            // branch.

                            if (fInTryBlock)
                            {
                                // Find the "finally" that guards us.
                            
                                /*
                                 * Handling leave - finally
                                 *
                                 * Find the first (innermost) finally that gets 
                                 * executed before leave reaches it's 
                                 * destination. Merge current state to that 
                                 * finally's "Special state" the leave 
                                 * destinations from the finally are available
                                 * in VerExceptionInfo (obtained during the 
                                 * first pass). When the finally's endfinally 
                                 * is hit, the next outer finally in the code 
                                 * path will process the resulting state...., 
                                 * before this state reaches the final leave 
                                 * destination.
                                 *
                                 */

                                for (DWORD i=0; i<m_NumExceptions; i++)
                                {
                                    VerExceptionInfo & e = m_pExceptionList[i];
                            
                                    // Try blocks are listed innermost first.
                                    // The first enclosing block will be the 
                                    // innermost block.
                            
                                    if (e.eFlags & 
                                        COR_ILEXCEPTION_CLAUSE_FINALLY &&
                                        e.dwTryXX <= CurBBNumber && 
                                        e.dwTryEndXX > CurBBNumber)
                                    {
                                        // There is at least one "finally" 
                                        // guarding the "leave." Is the
                                        // destination guarded by the same 
                                        // "finally?"

                                        if ((e.dwTryXX    <= DestBBNumber) && 
                                            (e.dwTryEndXX >  DestBBNumber))
                                        {
                                            // No finally is involved here.
                                            break;
                                        }
                            
                                        LOG((LF_VERIFIER, LL_INFO10000,
                                        "Creating extended state from BB 0x%x to BB 0x%x\n",
                                        m_pBasicBlockList[CurBBNumber].m_StartPC,
                                        m_pBasicBlockList[DestBBNumber].m_StartPC));

                                        if (!CreateFinallyState(i, CurBBNumber, 
                                            DestBBNumber, NULL))
                                        {
                                            goto exit;
                                        }
                            
                                        // Added this leave target to the 
                                        // nearest finally handler
                                        goto dequeueBB;
                                    }
                                }
                            
                                // If we got here, we're guarded by something
                                // but not a "finally". Fall thru to "normal 
                                // branch" case.
                            }


                            // This "leave" is to be handled as a normal branch. 
                            if (!HandleDestBasicBlock(DestBBNumber, NULL, fExtendedState, DestBB))
                                goto exit;
                        }


                        if (IsBasicBlockDirty(DestBBNumber, fExtendedState, DestBB))
                        {
                            CurBBNumber = DestBBNumber;
                            goto setupCurBB;
                        }
                        else
                        {
                            // don't need to visit either BB, so dequeue next BB
                            goto dequeueBB;
                        }
                    }
                }
            } /* end while */
        } /* end ... if (ch != '!') */

        if (ch != '!')
        {
            // Reached end of operation string - we've fully handled the instruction already
            _ASSERTE(ch == '\0');
            continue;
        }

        // Handle all remaining individual instructions specially
        switch (opcode)
        {
            default:
            {
                m_sError.dwFlags = VER_ERR_OFFSET; // opcode is non-standard
                SET_ERR_OPCODE_OFFSET();
                SetErrorAndContinue(VER_E_UNKNOWN_OPCODE);
                goto exit;
            }

            case CEE_CALLI:
            case CEE_JMP:
            case CEE_CPBLK:
            case CEE_INITBLK:
            case CEE_LOCALLOC:
            {
                m_sError.dwFlags = VER_ERR_OPCODE_OFFSET;
                SET_ERR_OPCODE_OFFSET();
                if (!SetErrorAndContinue(VER_E_UNVERIFIABLE))
                    goto exit;
                break;
            }

            case CEE_MKREFANY:
            {
                Item DesiredItem, NewItem;
                Item *pItem = PopItem();

                if (pItem == NULL)
                {
                    FAILMSG_PC_STACK_UNDERFLOW();
                    goto exit;
                }

                if (!DesiredItem.SetType(inline_operand, m_pModule))
                {
                    FAILMSG_TOKEN_RESOLVE(inline_operand);
                    goto exit;
                }

                // BYREF of RuntimeArgHandle / TypedByref could lead to
                // a pointer into the stack living longer than the stack.
                if (DesiredItem.IsValueClassWithPointerToStack())
                {
                    m_sError.dwFlags = VER_ERR_OPCODE_OFFSET;
                    SET_ERR_OPCODE_OFFSET();
                    if (!SetErrorAndContinue(VER_E_RA_PTR_TO_STACK))
                        goto exit;
                }

                DesiredItem.MakeByRef();

                if (!(pItem->CompatibleWith(&DesiredItem, m_pClassLoader, FALSE)))
                {
                    m_sError.dwFlags = 
                        (VER_ERR_ITEM_F|VER_ERR_ITEM_E|VER_ERR_OPCODE_OFFSET);
                    m_sError.sItemFound = pItem->_GetItem();
                    m_sError.sItemExpected = DesiredItem._GetItem();
                    SET_ERR_OPCODE_OFFSET();
                    if (!SetErrorAndContinue(VER_E_STACK_UNEXPECTED))
                        goto exit;
                }

                if (s_th_System_TypedReference.IsNull())
                    s_th_System_TypedReference = TypeHandle(g_Mscorlib.GetClass(CLASS__TYPED_REFERENCE));

                _ASSERTE(!s_th_System_TypedReference.IsNull());

                NewItem.SetTypeHandle(s_th_System_TypedReference);
                (void) Push(&NewItem);

                break;
            }

            case CEE_REFANYTYPE:
            {
                Item    DesiredItem, item;
                Item   *pItem = PopItem();

                if (pItem == NULL)
                {
                    FAILMSG_PC_STACK_UNDERFLOW();
                    goto exit;
                }

                if (s_th_System_TypedReference.IsNull())
                    s_th_System_TypedReference = TypeHandle(g_Mscorlib.GetClass(CLASS__TYPED_REFERENCE));

                _ASSERTE(!s_th_System_TypedReference.IsNull());

                DesiredItem.SetTypeHandle(s_th_System_TypedReference);

                if (!(pItem->CompatibleWith(&DesiredItem, m_pClassLoader)))
                {
                    m_sError.dwFlags = 
                        (VER_ERR_ITEM_F|VER_ERR_ITEM_E|VER_ERR_OPCODE_OFFSET);
                    m_sError.sItemFound = pItem->_GetItem();
                    m_sError.sItemExpected = DesiredItem._GetItem();
                    SET_ERR_OPCODE_OFFSET();
                    if (!SetErrorAndContinue(VER_E_STACK_UNEXPECTED))
                        goto exit;
                }

                if (s_th_System_RuntimeTypeHandle.IsNull())
                    s_th_System_RuntimeTypeHandle = TypeHandle(g_Mscorlib.GetClass(CLASS__TYPE_HANDLE));

                _ASSERTE(!s_th_System_RuntimeTypeHandle.IsNull());

                item.SetTypeHandle(s_th_System_RuntimeTypeHandle);

                (void) Push(&item);

                break;
            }

            case CEE_REFANYVAL:
            {
                Item    DesiredItem, item;
                Item   *pItem = PopItem();

                if (pItem == NULL)
                {
                    FAILMSG_PC_STACK_UNDERFLOW();
                    goto exit;
                }

                if (s_th_System_TypedReference.IsNull())
                    s_th_System_TypedReference = TypeHandle(g_Mscorlib.GetClass(CLASS__TYPED_REFERENCE));

                _ASSERTE(!s_th_System_TypedReference.IsNull());

                DesiredItem.SetTypeHandle(s_th_System_TypedReference);

                if (!(pItem->CompatibleWith(&DesiredItem, m_pClassLoader)))
                {
                    m_sError.dwFlags = 
                        (VER_ERR_ITEM_F|VER_ERR_ITEM_E|VER_ERR_OPCODE_OFFSET);
                    m_sError.sItemFound = pItem->_GetItem();
                    m_sError.sItemExpected = DesiredItem._GetItem();
                    SET_ERR_OPCODE_OFFSET();
                    if (!SetErrorAndContinue(VER_E_STACK_UNEXPECTED))
                        goto exit;
                }

                if (!item.SetType(inline_operand, m_pModule))
                {
                    FAILMSG_TOKEN_RESOLVE(inline_operand);
                    goto exit;
                }

                item.MakeByRef();
               
                (void) Push(&item);

                break;
            }

            case CEE_SIZEOF:
            {
                Item item;

                if (!item.SetType(inline_operand, m_pModule))
                {
                    FAILMSG_TOKEN_RESOLVE(inline_operand);
                    goto exit;
                }

                if (!item.IsValueClassOrPrimitive())
                {
                    m_sError.dwFlags = (VER_ERR_ITEM_F|VER_ERR_OPCODE_OFFSET);
                    m_sError.sItemFound = item._GetItem();
                    SET_ERR_OPCODE_OFFSET();
                    if (!SetErrorAndContinue(VER_E_VALCLASS))
                        goto exit;
                }

                // Stack overflow condition is already tested soon after we
                // decoded this. [PredictedStackSlotAtEndOfInstruction]
                FastPush(ELEMENT_TYPE_I4);

                break;
            }

            case CEE_LDSTR: 
            {
                if (!m_pModule->IsValidStringRef(inline_operand))
                {
                    m_sError.dwFlags = 
                        (VER_ERR_OPERAND|VER_ERR_OPCODE_OFFSET);
                    m_sError.dwOperand = inline_operand;
                    SET_ERR_OPCODE_OFFSET();
                    if (!SetErrorAndContinue(VER_E_LDSTR_OPERAND))
                        goto exit;
                }

                Item    StrItem;
                StrItem.SetKnownClass(g_pStringClass);

                if (!Push(&StrItem))
                {
                    FAILMSG_PC_STACK_OVERFLOW();
                    goto exit; 
                }

                break;
            }

            //
            // LDARG_*
            //
            case CEE_LDARG_0: // Uses "#" directive in vertable.h to get inline operand
            case CEE_LDARG_1:
            case CEE_LDARG_2:
            case CEE_LDARG_3:
            case CEE_LDARG:
            case CEE_LDARG_S:
            {
                Item item;

                item = GetCurrentValueOfArgument(inline_operand);

                _ASSERTE(!(m_wFlags & VER_STOP_ON_FIRST_ERROR) || !item.IsDead());

                item.NormaliseForStack();

                // If we're in a ctor and "this" is uninit, we will be pushing an uninit obj
                if (!Push(&item))
                {
                    FAILMSG_PC_STACK_OVERFLOW();
                    goto exit;
                }

                break;
            }

            //
            // STARG_*
            //
            case CEE_STARG:
            case CEE_STARG_S:
            {
                Item *pStackItem = PopItem();
                if (pStackItem == NULL)
                {
                    FAILMSG_PC_STACK_UNDERFLOW();
                    goto exit;
                }

                if (pStackItem->IsUninitialised())
                {
                    m_sError.dwFlags = VER_ERR_OPCODE_OFFSET;
                    SET_ERR_OPCODE_OFFSET();
                    if (!SetErrorAndContinue(VER_E_STACK_UNINIT))
                        goto exit;
                }

                // Make sure stack item is compatible with global type of this argument
                Item item = GetGlobalArgTypeInfo(inline_operand)->m_Item;
                item.NormaliseForStack();

                if (!pStackItem->CompatibleWith(&item, m_pClassLoader))
                {
                    m_sError.dwFlags = 
                        (VER_ERR_ITEM_F|VER_ERR_ITEM_E|VER_ERR_OPCODE_OFFSET);
                    m_sError.sItemFound = pStackItem->_GetItem();
                    m_sError.sItemExpected = item._GetItem();
                    SET_ERR_OPCODE_OFFSET();
                    if (!SetErrorAndContinue(VER_E_STACK_UNEXPECTED))
                        goto exit;
                }

                if (inline_operand == 0 && m_fInConstructorMethod)
                {
                    // Any easy way to prevent potentially dangerous situations (e.g. confused initialisation status)
                    m_sError.dwFlags = VER_ERR_OPCODE_OFFSET;
                    SET_ERR_OPCODE_OFFSET();
                    if (!SetErrorAndContinue(VER_E_THIS_UNINIT_STORE))
                        goto exit;
                }

                // No need to merge for try block - argument state is constant
                break;
            }

            //
            // RET_*
            //
            case CEE_RET:
            {
                if (!IsControlFlowLegal(
                            CurBBNumber,
                            pOuterExceptionBlock,
                            pInnerExceptionBlock,
                            VER_NO_BB,
                            NULL,
                            NULL,
                            eVerRet,
                            dwPCAtStartOfInstruction))
                    goto exit;

                // Constructors have a void return type, but we must ensure that our object has been
                // initialised (by calling its superclass constructor).  
                if (m_fThisUninit)
                {
                    m_sError.dwFlags = VER_ERR_OPCODE_OFFSET;
                    SET_ERR_OPCODE_OFFSET();
                    if (!SetErrorAndContinue(VER_E_THIS_UNINIT_RET))
                        goto exit;
                }

                // For void return, ensure that nothing is on the stack
                // For non-void return, ensure that correct type is on the stack
                if (m_ReturnValue.IsGivenPrimitiveType(ELEMENT_TYPE_VOID))
                {
                    if (GetTopStack() != NULL)
                    {
                        m_sError.dwFlags = VER_ERR_OPCODE_OFFSET;
                        SET_ERR_OPCODE_OFFSET();
                        if (!SetErrorAndContinue(VER_E_RET_VOID))
                            goto exit;
                    }
                }
                else
                {
                    Item *pItem = PopItem();
                    if (pItem == NULL)
                    {
                        m_sError.dwFlags = (VER_ERR_FATAL|VER_ERR_OPCODE_OFFSET);
                        SET_ERR_OPCODE_OFFSET();
                        SetErrorAndContinue(VER_E_RET_MISSING);
                        goto exit;
                    }


                    if (GetTopStack() != NULL)
                    {
                        m_sError.dwFlags = VER_ERR_OPCODE_OFFSET;
                        SET_ERR_OPCODE_OFFSET();
                        if (!SetErrorAndContinue(VER_E_RET_EMPTY))
                            goto exit;
                    }


                    if (pItem->IsUninitialised())
                    {
                        m_sError.dwFlags = VER_ERR_OPCODE_OFFSET;
                        m_sError.dwVarNumber = inline_operand;
                        SET_ERR_OPCODE_OFFSET();
                        if (!SetErrorAndContinue(VER_E_RET_UNINIT))
                            goto exit;
                    }
 
                    if (!pItem->CompatibleWith(&m_ReturnValue, m_pClassLoader))
                    {
                        m_sError.dwFlags = 
                            (VER_ERR_ITEM_F|VER_ERR_ITEM_E|VER_ERR_OPCODE_OFFSET);
                        m_sError.sItemFound = pItem->_GetItem();
                        m_sError.sItemExpected = m_ReturnValue._GetItem();
                        SET_ERR_OPCODE_OFFSET();
                        if (!SetErrorAndContinue(VER_E_STACK_UNEXPECTED))
                            goto exit;
                    }

                    if (pItem->HasPointerToStack())
                    {
                        m_sError.dwFlags = VER_ERR_OPCODE_OFFSET;
                        SET_ERR_OPCODE_OFFSET();
                        if (!SetErrorAndContinue(VER_E_RET_PTR_TO_STACK))
                            goto exit;
                    }

                    Push(pItem); // The stack state is really irrelevant at this point
                                 // but since RET is considered not to alter the
                                 // stack, undo the pop in order to avoid firing
                                 // asserts.

                }

#if 0
                if (m_fInValueClassConstructor)
                {
                    if (!AreAllValueClassFieldsInited())
                    {
                        m_sError.dwFlags = VER_ERR_OPCODE_OFFSET;
                        SET_ERR_OPCODE_OFFSET();
                        if (!SetErrorAndContinue(VER_E_THIS_UNINIT_V_RET))
                            goto exit;
                    }
                }
#endif


                // Don't fall through to next instruction - dequeue the next basic block
                // Note that other code jumps to the dequeueBB label.
dequeueBB:

     
                _ASSERTE(m_StackSlot == PredictedStackSlotAtEndOfInstruction || !fStaticStackCheckPossible);

                if (fInTryBlock)
                {
                    if (!PropagateCurrentStateToExceptionHandlers(CurBBNumber))
                        goto exit;
                }

                if (!DequeueBB(&CurBBNumber, &fExtendedState, &DestBB))
                {
                    LOG((LF_VERIFIER, LL_INFO10000, "No more BBs to dequeue\n"));
                    goto done;
                }

                LOG((LF_VERIFIER, LL_INFO10000, "\n-----\n"));
                LOG((LF_VERIFIER, LL_INFO10000, "Dequeued basic block 0x%x",
                    m_pBasicBlockList[CurBBNumber].m_StartPC));

#ifdef _DEBUG
                if (fExtendedState)
                {
                    LOG((LF_VERIFIER, LL_INFO10000, " extended [0x%x]",
                        m_pBasicBlockList[DestBB].m_StartPC));
                
                }
#endif
                LOG((LF_VERIFIER, LL_INFO10000, "\n"));

                goto setupCurBB;
            }

            //
            // LDLOC_*
            //
            case CEE_LDLOC_0: // Uses "#" directive in vertable.h to get inline operand
            case CEE_LDLOC_1:
            case CEE_LDLOC_2:
            case CEE_LDLOC_3:
            case CEE_LDLOC:
            case CEE_LDLOC_S:
            {
                // All verifiable methods with one or more locals should
                // set init locals.
                if ((m_pILHeader->Flags & CorILMethod_InitLocals) == 0)
                {
                    m_sError.dwFlags = VER_ERR_OPCODE_OFFSET;
                    SET_ERR_OPCODE_OFFSET();
                    if (!SetErrorAndContinue(VER_E_INITLOCALS))
                        goto exit;
                }
            
                Item item;

                item = GetCurrentValueOfLocal(inline_operand);

                if (item.IsDead())
                {
                    m_sError.dwFlags = (VER_ERR_LOCAL_VAR|VER_ERR_OPCODE_OFFSET);
                    m_sError.dwVarNumber = inline_operand;
                    SET_ERR_OPCODE_OFFSET();
                    if (!SetErrorAndContinue(VER_E_LOC_DEAD))
                        goto exit;
                }

                item.NormaliseForStack();

                if (!Push(&item))
                {
                    FAILMSG_PC_STACK_OVERFLOW();
                    goto exit;
                }

                break;
            }

            //
            // STLOC_*
            //
            case CEE_STLOC_0: // Uses "#" directive in vertable.h to get inline operand
            case CEE_STLOC_1:
            case CEE_STLOC_2:
            case CEE_STLOC_3:
            case CEE_STLOC:
            case CEE_STLOC_S:
            {
                Item *pStackItem;

                // Pop what we are storing
                pStackItem = PopItem();
                if (pStackItem == NULL)
                {
                    FAILMSG_PC_STACK_UNDERFLOW();
                    goto exit;
                }

                long slot = GetGlobalLocVarTypeInfo(inline_operand)->m_Slot;
                Item item = GetGlobalLocVarTypeInfo(inline_operand)->m_Item;

                // Object Refs can have what ever is stored into it, regardless
                // of what it's declared type is.
                if (LIVEDEAD_TRACKING_ONLY_FOR_SLOT(slot) || 
                        DoesLocalHavePinnedType(inline_operand)     || 
                        !item.IsObjRef()                  ||
                        !pStackItem->IsObjRef())
                {

                    BOOL fUninit = FALSE;

                    // You can uninitialised items into local variables, but they're not tracked
                    if (pStackItem->IsUninitialised())
                    {
                        fUninit = TRUE;

                        // Set init so that CompatibleWith() doesn't fail the check
                        pStackItem->SetInitialised();
                    }

                    // Make sure stack item is compatible with global type of this local

                    item.NormaliseForStack();
                    
                    
                    if (!pStackItem->CompatibleWith(&item, m_pClassLoader))
                    {
                        m_sError.dwFlags = 
                            (VER_ERR_ITEM_F|VER_ERR_ITEM_E|VER_ERR_OPCODE_OFFSET);
                        m_sError.sItemFound = pStackItem->_GetItem();
                        m_sError.sItemExpected = item._GetItem();
                        SET_ERR_OPCODE_OFFSET();
                        if (!SetErrorAndContinue(VER_E_STACK_UNEXPECTED))
                            goto exit;
                    }
                    
                    if (fUninit)
                        pStackItem->SetUninitialised();

                }
                
                if (LIVEDEAD_TRACKING_ONLY_FOR_SLOT(slot))
                {
                    // @VER_ASSERT cannot have a dead item of
                    // Primitive type on the stack.
                    _ASSERTE(!(m_wFlags & VER_STOP_ON_FIRST_ERROR) || !pStackItem->IsDead());
                    // If the local variable was primitive, set that it is now live
                    SetLocVarLiveSlot(LIVEDEAD_NEGATIVE_SLOT_TO_BITNUM(slot));
                }
                else
                {
#ifdef _VER_TRACK_LOCAL_TYPE

                    // If a null is set to a local slot, set the slot to
                    // be an instance of the declared type. This is closer
                    // to higher level language data flow rules.

                    if (pStackItem->IsNullObjRef())
                        *pStackItem = item;

                    m_pNonPrimitiveLocArgs[slot] = *pStackItem;
                    
                    if (fInTryBlock)
                        MergeObjectLocalForTryBlock(slot, pStackItem);

#else   // _VER_TRACK_LOCAL_TYPE

                    if (!pStackItem->CompatibleWith(&item, m_pClassLoader))
                    {
                        m_sError.dwFlags = 
                            (VER_ERR_ITEM_F|VER_ERR_ITEM_E|VER_ERR_OPCODE_OFFSET);
                        m_sError.sItemFound = pStackItem->_GetItem();
                        m_sError.sItemExpected = item._GetItem();
                        SET_ERR_OPCODE_OFFSET();
                        if (!SetErrorAndContinue(VER_E_STACK_UNEXPECTED))
                            goto exit;
                    }
#endif  // _VER_TRACK_LOCAL_TYPE
                }

                break;
            }

            case CEE_DUP:
            {
                Item *pTop = GetTopStack();
                if (pTop == NULL)
                {
                    FAILMSG_PC_STACK_UNDERFLOW();
                    goto exit;
                }

                // You can duplicate an uninitialised stack item, but it is not guaranteed to be tracked
                if (!Push(pTop))
                {
                    FAILMSG_PC_STACK_OVERFLOW();
                    goto exit;
                }

                break;
            }

            case CEE_SWITCH:
            {
                EntryState_t *  pSharedEntryState = NULL;
                DWORD           NumCases;
                DWORD           DestBBNumber;
                DWORD           i;

                READU4(m_pCode, ipos, NumCases);

                if (!FastPop(ELEMENT_TYPE_I4))
                {
                    m_sError.dwFlags = 
                        (VER_ERR_FATAL|VER_ERR_ITEM_F|VER_ERR_ITEM_E|VER_ERR_OPCODE_OFFSET);
                    m_sError.sItemFound = m_pStack[m_StackSlot]._GetItem();
                    m_sError.sItemExpected.dwFlags = ELEMENT_TYPE_I4;
                    m_sError.sItemExpected.pv = NULL;
                    SET_ERR_OPCODE_OFFSET();
                    SetErrorAndContinue(VER_E_STACK_UNEXPECTED);
                    goto exit;
                }

                LOG((LF_VERIFIER, LL_INFO10000, "\n"));

                DWORD NextInstrPC = ipos + 4*NumCases;

                if (fInTryBlock)
                {
                    if (!PropagateCurrentStateToExceptionHandlers(CurBBNumber))
                        goto exit;
                }

                for (i = 0; i < NumCases; i++)
                {
                    DWORD       offset;
                    DWORD       DestPC;

                    READU4(m_pCode, ipos, offset);
                
                    DestPC = NextInstrPC + offset;

                    LOG((LF_VERIFIER, LL_INFO10000, "0x%x (rel 0x%x)\n", DestPC, offset));

#ifdef _VER_DISALLOW_MULTIPLE_INITS

                    if ((m_fThisUninit > 0) && (DestPC < NextInstrPC))
                    {
                        m_sError.dwFlags = VER_ERR_OPCODE_OFFSET;
                        SET_ERR_OPCODE_OFFSET();
                        if (!SetErrorAndContinue(VER_E_THIS_UNINIT_BR))
                            goto exit;
                    }

#endif // _VER_DISALLOW_MULTIPLE_INITS

                    // find destination basic block
                    DestBBNumber = FindBasicBlock(DestPC);

                    // If a new state is created, it will be shared across all unvisited basic blocks
                    // in the switch.
                    if (!HandleDestBasicBlock(DestBBNumber, &pSharedEntryState, fExtendedState, DestBB))
                        goto exit;

                    FindExceptionBlockAndCheckIfInTryBlock(DestBBNumber, 
                        &pTmpOuter, &pTmpInner, NULL);
        
                    if (!IsControlFlowLegal(
                                CurBBNumber,
                                pOuterExceptionBlock,
                                pInnerExceptionBlock,
                                DestBBNumber,
                                pTmpOuter,
                                pTmpInner,
                                eVerBranch,
                                dwPCAtStartOfInstruction))
                        goto exit;
                }

                // default fallthrough case
                LOG((LF_VERIFIER, LL_INFO10000, "default: 0x%x\n", ipos));

                DestBBNumber = FindBasicBlock(ipos);
                if (!HandleDestBasicBlock(DestBBNumber, &pSharedEntryState, fExtendedState, DestBB))
                    goto exit;

                FindExceptionBlockAndCheckIfInTryBlock(DestBBNumber, 
                    &pTmpOuter, &pTmpInner, NULL);
    
                if (!IsControlFlowLegal(
                            CurBBNumber,
                            pOuterExceptionBlock,
                            pInnerExceptionBlock,
                            DestBBNumber,
                            pTmpOuter,
                            pTmpInner,
                            eVerBranch,  /* Branch / FallThru ? */
                            dwPCAtStartOfInstruction))
                    goto exit;

                goto dequeueBB;
            }

            case CEE_NEWARR:
            {
                Item        NewArray;
                TypeHandle  thArray;

                if (!FastPop(ELEMENT_TYPE_I4))
                {
                    m_sError.dwFlags = 
                        (VER_ERR_FATAL|VER_ERR_ITEM_F|VER_ERR_ITEM_E|VER_ERR_OPCODE_OFFSET);
                    m_sError.sItemFound = m_pStack[m_StackSlot]._GetItem();
                    m_sError.sItemExpected.dwFlags = ELEMENT_TYPE_I4;
                    m_sError.sItemExpected.pv = NULL;
                    SET_ERR_OPCODE_OFFSET();
                    SetErrorAndContinue(VER_E_STACK_UNEXPECTED);
                    goto exit;
                }

                DefineFullyQualifiedNameForClass();

                mdToken mdToken = inline_operand;
                Module *pModule = m_pModule;
                ClassLoader *pLoader = m_pClassLoader;
                if (TypeFromToken(inline_operand) == mdtTypeSpec)
                {
                    ULONG cSig;
                    PCCOR_SIGNATURE pSig;
                    Item element;

                    m_pInternalImport->GetTypeSpecFromToken(inline_operand, &pSig, &cSig);
                    VerSig sig(this, m_pModule, pSig, cSig, VERSIG_TYPE_LOCAL_SIG, 0);

/* Don't do this
                    // Something about the signature was not valid
                    if (!sig.Init())
                    {
                        goto exit;
                    }
*/

                    // Parse the sig to an item
                    // The second parameter being FALSE means "don't allow void".
                    if (!sig.ParseNextComponentToItem(&element, FALSE, FALSE, 
                        &m_hThrowable, VER_NO_ARG, TRUE))
                    {
                        goto exit;
                    }

                    if (element.IsByRef())
                    {
                        m_sError.dwFlags = VER_ERR_FATAL|VER_ERR_OPCODE_OFFSET;
                        SET_ERR_OPCODE_OFFSET();
                        SetErrorAndContinue(VER_E_SIG_ARRAY);
                        goto exit;
                    }

                    SigPointer sigptr(pSig);

                    TypeHandle typeHnd = sigptr.GetTypeHandle(m_pModule);
                    if (typeHnd.IsNull() ||
                        (typeHnd.GetName(_szclsname_, MAX_CLASSNAME_LENGTH) 
                        == 0))
                        goto error_bad_token;
                    
                    EEClass *pNestedClass = typeHnd.GetClassOrTypeParam();
                    if (pNestedClass->IsNested()) {
                        mdToken = pNestedClass->GetCl();
                        pModule = pNestedClass->GetModule();
                    }
                    else
                        pModule = NULL;

                    pLoader = typeHnd.GetModule()->GetClassLoader();
                }
                else if (!ClassLoader::GetFullyQualifiedNameOfClassRef(m_pModule, inline_operand, _szclsname_))
                {
error_bad_token:
                    FAILMSG_TOKEN_RESOLVE(inline_operand);
                    goto exit;
                }

                if (strlen(_szclsname_) + 2 >= MAX_CLASSNAME_LENGTH)
                {
                    m_sError.dwFlags = VER_ERR_OPCODE_OFFSET;
                    SET_ERR_OPCODE_OFFSET();
                    if (!SetErrorAndContinue(VER_E_ARRAY_NAME_LONG))
                        goto exit;
                }

                strcat(_szclsname_, "[]");

#ifdef _DEBUG
                LOG((LF_VERIFIER, LL_INFO10000, "%s\n", _szclsname_));
#endif


                if (TypeFromToken(mdToken) == mdtTypeRef) {
                    // Find the assembly to which this TR resolves
                    NameHandle typeName(pModule, mdToken);
                    TypeHandle typeHnd = m_pClassLoader->LoadTypeHandle(&typeName, NULL);
                    if (typeHnd.IsNull())
                        pLoader = NULL;
                    else
                        pLoader = typeHnd.GetModule()->GetClassLoader();
                }


                if (pLoader) {
                    NameHandle typeName(_szclsname_);
                    typeName.SetTypeToken(pModule, mdToken);
                    thArray = pLoader->FindTypeHandle(&typeName, NULL);
                }

                if (! (pLoader && NewArray.SetArray(thArray)) )
                {
                    FAILMSG_TOKEN_RESOLVE(inline_operand);
                    goto exit;
                }

                Item  ArrayElement = NewArray;
                if (!ArrayElement.DereferenceArray() || ArrayElement.IsValueClassWithPointerToStack())
                {
                    m_sError.dwFlags = VER_ERR_OPCODE_OFFSET;
                    SET_ERR_OPCODE_OFFSET();
                    if (!SetErrorAndContinue(VER_E_SIG_ARRAY_TB_AH))
                        goto exit;
                }

                (void) Push(&NewArray);

                break;
            }

            case CEE_LDELEM_REF:
            {
                Item *  pArrayItem;

                // index
                if (!FastPop(ELEMENT_TYPE_I4))
                {
                    FAILMSG_STACK_EXPECTED_I4_FOUND_SOMETHING_ELSE();
                    if (!SetErrorAndContinue(VER_E_STACK_UNEXPECTED))
                        goto exit;
                }

                // get, don't pop, the top stack element
                pArrayItem = GetTopStack();
                if (pArrayItem == NULL)
                {
                    FAILMSG_STACK_EMPTY();
                    goto exit;
                }

                // the item on the stack must be an array of pointer types, or null
                // (e.g. int[] is illegal, because it is an array of primitive types)
                if (pArrayItem->IsNullObjRef())
                {
                    // Leave a "null" on the stack as what happens when we dereference a null array
                    // access - in reality, we will get a NullPointerException at run time.
                }
                else
                {
                    // Stack element must be a single dimensional array of object types
                    if (!pArrayItem->IsSingleDimensionalArrayOfPointerTypes())
                    {
                        m_sError.dwFlags = VER_ERR_OPCODE_OFFSET;
                        SET_ERR_OPCODE_OFFSET();
                        if (!SetErrorAndContinue(VER_E_ARRAY_SD_PTR))
                            goto exit;
                    }

                    if (pArrayItem->IsArray() && !pArrayItem->DereferenceArray())
                    {
                        m_sError.dwFlags = VER_ERR_OPCODE_OFFSET;
                        SET_ERR_OPCODE_OFFSET();
                        if (!SetErrorAndContinue(VER_E_ARRAY_ACCESS))
                            goto exit;
                    }
                }

                break;
            }

            case CEE_STELEM_REF:
            {
                Item *  pArrayItem;
                Item *  pValueItem;
                
                // value
                pValueItem = PopItem();
                if (pValueItem == NULL)
                {
                    FAILMSG_STACK_EMPTY();
                    goto exit;
                }

                // index
                if (!FastPop(ELEMENT_TYPE_I4))
                {
                    FAILMSG_STACK_EXPECTED_I4_FOUND_SOMETHING_ELSE();
                    if (!SetErrorAndContinue(VER_E_STACK_UNEXPECTED))
                        goto exit;
                }

                // array
                pArrayItem = PopItem();
                if (pArrayItem == NULL)
                {
                    FAILMSG_STACK_EMPTY();
                    goto exit;
                }

                // must be an array of pointer types, or null
                if (pArrayItem->IsNullObjRef())
                {
                    // If our array is a null pointer, just check that we're storing an objref
                    // into it, because we will get the null pointer exception at runtime.
                    if (!pValueItem->IsObjRef())
                    {
                        m_sError.dwFlags = VER_ERR_OPCODE_OFFSET;
                        SET_ERR_OPCODE_OFFSET();
                        if (!SetErrorAndContinue(VER_E_ARRAY_V_STORE))
                            goto exit;
                    }
                }
                else
                {
                    // Stack element must be a single dimensional array of object types
                    if (!pArrayItem->IsSingleDimensionalArrayOfPointerTypes())
                    {
                        m_sError.dwFlags = VER_ERR_OPCODE_OFFSET;
                        SET_ERR_OPCODE_OFFSET();
                        if (!SetErrorAndContinue(VER_E_ARRAY_SD_PTR))
                            goto exit;
                    }

                    //
                    // The value we are attempting to store in the array must be compatible with
                    // an object that is the array type with one dimension removed (e.g. we can
                    // store a subclass, or an Object in the array).
                    //

                    // Deference the array to remove a dimension; [Foo -> Foo, [[Foo -> [Foo
                    if (pArrayItem->IsArray() && !pArrayItem->DereferenceArray())
                    {
                        m_sError.dwFlags = VER_ERR_OPCODE_OFFSET;
                        SET_ERR_OPCODE_OFFSET();
                        if (!SetErrorAndContinue(VER_E_ARRAY_ACCESS))
                            goto exit;
                    }

                    // There is a runtime check that catches bad object type
                    // assignment to arrays. It is sufficient to check if
                    // ValueItem is an Object type if the ArrayItem is 
                    // Object type.

                    if (pArrayItem->IsObjRef())
                    {
                        // This will prevent Value Types, and Value types with
                        // pointer to stack case to be caught.
                        pArrayItem->SetKnownClass(g_pObjectClass);
                    }

                    if (!pValueItem->CompatibleWith(pArrayItem, m_pClassLoader))
                    {
                        m_sError.dwFlags = 
                            (VER_ERR_ITEM_F|VER_ERR_ITEM_E|VER_ERR_OPCODE_OFFSET);
                        m_sError.sItemFound = pValueItem->_GetItem();
                        m_sError.sItemExpected = pArrayItem->_GetItem();
                        SET_ERR_OPCODE_OFFSET();
                        if (!SetErrorAndContinue(VER_E_STACK_UNEXPECTED))
                            goto exit;
                    }
                }

                break;
            }

            case CEE_LDELEMA:
            {
                Item    DesiredItem;
                Item *  pArrayItem;

                // Declared type
                if (!DesiredItem.SetType(inline_operand, m_pModule))
                {
                    FAILMSG_TOKEN_RESOLVE(inline_operand);
                    goto exit;
                }

                // index
                if (!FastPop(ELEMENT_TYPE_I4))
                {
                    FAILMSG_STACK_EXPECTED_I4_FOUND_SOMETHING_ELSE();
                    if (!SetErrorAndContinue(VER_E_STACK_UNEXPECTED))
                        goto exit;
                }

                // get, don't pop, the top stack element
                pArrayItem = GetTopStack();
                if (pArrayItem == NULL)
                {
                    FAILMSG_STACK_EMPTY();
                    goto exit;
                }

                // the item on the stack must be an SD array or null
                // (e.g. int[] is illegal, because it is an array of primitive types)
                if (pArrayItem->IsNullObjRef())
                {
                    // Dereferencing a null array at runtime, will result in
                    // a NullPointerException, We make this a BYREF null.
                    pArrayItem->MakeByRef();
                }
                else
                {
                    // Stack element must be a single dimensional array of object types
                    if (!pArrayItem->IsSingleDimensionalArray())
                    {
                        m_sError.dwFlags = VER_ERR_OPCODE_OFFSET;
                        SET_ERR_OPCODE_OFFSET();
                        if (!SetErrorAndContinue(VER_E_ARRAY_SD))
                            goto exit;
                    }

                    if (pArrayItem->IsArray() && !pArrayItem->DereferenceArray())
                    {
                        m_sError.dwFlags = VER_ERR_OPCODE_OFFSET;
                        SET_ERR_OPCODE_OFFSET();
                        if (!SetErrorAndContinue(VER_E_ARRAY_ACCESS))
                            goto exit;
                    }

                    // The types have to match excatly, subclass not OK.
                    if (!pArrayItem->CompatibleWith(&DesiredItem, 
                        m_pClassLoader, FALSE))
                    {
                        m_sError.dwFlags = 
                            (VER_ERR_ITEM_F|VER_ERR_ITEM_E|VER_ERR_OPCODE_OFFSET);
                        m_sError.sItemFound = pArrayItem->_GetItem();
                        m_sError.sItemExpected = DesiredItem._GetItem();
                        SET_ERR_OPCODE_OFFSET();
                        if (!SetErrorAndContinue(VER_E_STACK_UNEXP_ARRAY))
                            goto exit;
                    }

                    pArrayItem->MakeByRef();
                    pArrayItem->SetIsPermanentHomeByRef();
                }

                break;
            }

            case CEE_ARGLIST:
            {
                // arglist instruction can be executed only in a method
                // which takes a vararg.

                if (!m_fIsVarArg)
                {
                    m_sError.dwFlags = VER_ERR_OPCODE_OFFSET;
                    SET_ERR_OPCODE_OFFSET();
                    if (!SetErrorAndContinue(VER_E_ARGLIST))
                        goto exit;
                }

                if (s_th_System_RuntimeArgumentHandle.IsNull())
                    s_th_System_RuntimeArgumentHandle = TypeHandle(g_Mscorlib.GetClass(CLASS__ARGUMENT_HANDLE));

                _ASSERTE(!s_th_System_RuntimeArgumentHandle.IsNull());

                Item item;

                item.SetTypeHandle(s_th_System_RuntimeArgumentHandle);
                
                if (!Push(&item))
                {
                    FAILMSG_PC_STACK_OVERFLOW();
                    goto exit; 
                }

                break;
            }

            case CEE_LDTOKEN:
            {
                TypeHandle         th;

                // Make sure that the token is present in the metadata table. 

                // The token could be a TypeDef/Ref, MethodDef/Ref FieldDef/Ref
                switch (TypeFromToken(inline_operand))
                {
                    default:
                    {
                        FAILMSG_TOKEN_RESOLVE(inline_operand);
                        goto exit;
                    }

                    case mdtTypeSpec:
                    case mdtTypeRef:
                    case mdtTypeDef:
                    {
                        if (s_th_System_RuntimeTypeHandle.IsNull())
                            s_th_System_RuntimeTypeHandle = TypeHandle(g_Mscorlib.GetClass(CLASS__TYPE_HANDLE));
                        _ASSERTE(!s_th_System_RuntimeTypeHandle.IsNull());
                        th = s_th_System_RuntimeTypeHandle;

                        break;
                    }
                
                    case mdtMemberRef:
                    {
                        // OK, we have to look at the metadata to see if it's a field or method                      
                        PCCOR_SIGNATURE pSig;
                        ULONG cSig;
                        m_pInternalImport->GetNameAndSigOfMemberRef(inline_operand, &pSig, &cSig);
                        if (isCallConv(MetaSig::GetCallingConventionInfo(0, pSig), IMAGE_CEE_CS_CALLCONV_FIELD))
                            goto DO_FIELD;
                    }
                        /* FALL THROUGH */

                    case mdtMethodDef:
                    {
                        if (s_th_System_RuntimeMethodHandle.IsNull())
                            s_th_System_RuntimeMethodHandle = TypeHandle(g_Mscorlib.GetClass(CLASS__METHOD_HANDLE));
                        _ASSERTE(!s_th_System_RuntimeMethodHandle.IsNull());
                        th = s_th_System_RuntimeMethodHandle;

                        break;
                    }


                    case mdtFieldDef:
                    {
                    DO_FIELD:
                        if (s_th_System_RuntimeFieldHandle.IsNull())
                            s_th_System_RuntimeFieldHandle = TypeHandle(g_Mscorlib.GetClass(CLASS__FIELD_HANDLE));
        
                        _ASSERTE(!s_th_System_RuntimeFieldHandle.IsNull());
                        th = s_th_System_RuntimeFieldHandle;

                        break;
                    }
                }

                Item item;

                item.SetTypeHandle(th);

                if (!Push(&item))
                {
                    FAILMSG_PC_STACK_OVERFLOW();
                    goto exit; 
                }
               
                break;
            }


            case CEE_ISINST:
            case CEE_CASTCLASS:
            {
                Item* pItem;

                pItem = GetTopStack();
                if (pItem == NULL)
                {
                    FAILMSG_PC_STACK_UNDERFLOW();
                    goto exit;
                }

                if (!pItem->IsObjRef())
                {
                    m_sError.dwFlags = VER_ERR_OPCODE_OFFSET;
                    SET_ERR_OPCODE_OFFSET();
                    if (!SetErrorAndContinue(VER_E_STACK_OBJREF))
                        goto exit;
                }

                if (pItem->IsUninitialised())
                {
                    m_sError.dwFlags = VER_ERR_OPCODE_OFFSET;
                    SET_ERR_OPCODE_OFFSET();
                    if (!SetErrorAndContinue(VER_E_STACK_UNINIT))
                        goto exit;
                }

                // change the item on the top of the stack - allow arrays
                if (!pItem->SetType(inline_operand, m_pModule))
                {
                    FAILMSG_TOKEN_RESOLVE(inline_operand);
                    goto exit;
                }

                // If stack contains value type, pushed boxed instance
                if (pItem->IsValueClassOrPrimitive())
                {
                    pItem->Box();
                }

#ifdef _DEBUG
                LOG((LF_VERIFIER, LL_INFO10000, "%s\n", pItem->GetTypeHandle().GetClass()->m_szDebugClassName));
#endif

                break;
            }

            case CEE_LDVIRTFTN:
            case CEE_LDFTN:
            {
                Item MethodItem;
                mdMethodDef mr;
                MethodDesc *pMethod;        // Function / Method
                EEClass    *pInstanceClass; // Used for checkin family access

                mr = (mdMethodDef) inline_operand;

                if (TypeFromToken(mr) != mdtMemberRef && TypeFromToken(mr) != mdtMethodDef)
                {
                    FAILMSG_TOKEN(mr, VER_E_TOKEN_TYPE_MEMBER);
                    goto exit;
                }

                OBJECTREF refThrowable = NULL;

                GCPROTECT_BEGIN(refThrowable);

                hr = EEClass::GetMethodDescFromMemberRef(m_pModule, mr, &pMethod, &refThrowable);

                if (FAILED(hr) && (refThrowable != NULL))
                    StoreObjectInHandle(m_hThrowable, refThrowable);

                GCPROTECT_END();

                if (FAILED(hr))
                {
                    FAILMSG_TOKEN_RESOLVE(mr);
                    goto exit;
                }

                _ASSERTE(pMethod);

                if (IsMdRTSpecialName(pMethod->GetAttrs()))
                {
                    m_sError.dwFlags = VER_ERR_OPCODE_OFFSET;
                    SET_ERR_OPCODE_OFFSET();
                    if (!SetErrorAndContinue(VER_E_LDFTN_CTOR))
                        goto exit;
                }

                if (opcode == CEE_LDVIRTFTN)
                {
                    Item DesiredItem;
                    Item *pInstance = PopItem();

                    if (pInstance == NULL)
                    {
                        FAILMSG_PC_STACK_UNDERFLOW();
                        goto exit;
                    }

                    if (!pInstance->IsObjRef())
                    {
                        m_sError.dwFlags = VER_ERR_OPCODE_OFFSET;
                        SET_ERR_OPCODE_OFFSET();
                        SetErrorAndContinue(VER_E_STACK_OBJREF);
                        goto exit;
                    }

                    if (pInstance->IsUninitialised())
                    {
                        m_sError.dwFlags = VER_ERR_OPCODE_OFFSET;
                        SET_ERR_OPCODE_OFFSET();
                        if (!SetErrorAndContinue(VER_E_STACK_UNINIT))
                            goto exit;
                    }


                    if (pMethod->IsStatic())
                    {
                        m_sError.dwFlags = VER_ERR_OPCODE_OFFSET;
                        SET_ERR_OPCODE_OFFSET();
                        if (!SetErrorAndContinue(VER_E_LDVIRTFTN_STATIC))
                            return E_FAIL;
                    }

                    DesiredItem.SetTypeHandle(pMethod->GetMethodTable());

                    if (DesiredItem.IsValueClassOrPrimitive() && 
                        !DesiredItem.IsValueClassWithPointerToStack() &&
                        !pInstance->IsValueClassOrPrimitive())
                    {
                        // ldftn should work only on boxed value types on stack.
                        DesiredItem.Box();
                    }

                    if (!pInstance->CompatibleWith(&DesiredItem, m_pClassLoader))
                    {
                        m_sError.dwFlags = 
                            (VER_ERR_ITEM_F|VER_ERR_ITEM_E|VER_ERR_OPCODE_OFFSET);
                        m_sError.sItemFound = pInstance->_GetItem();
                        m_sError.sItemExpected = DesiredItem._GetItem();
                        SET_ERR_OPCODE_OFFSET();
                        if (!SetErrorAndContinue(VER_E_STACK_UNEXPECTED))
                            goto exit;
                    }


                    if (pInstance->IsNullObjRef())
                    {
                        pInstanceClass = m_pMethodDesc->GetClass();

                        // Use instance to get the target class. This is to 
                        // verify family access restrictions.
                        // NOTE : the instance used for this test is different
                        // from the one used above. This is to allow NULL_OBJREF
                        // to pass since this will generate a NULL reference 
                        // exception at runtime.
                    }
                    else
                        pInstanceClass = pInstance->GetTypeHandle().GetClass();
                }
                else
                {
#if 0 // this will cause an exception at runtime if we call on this ftn.
                    // LDFTN on an abstract method is illegal, however LDVIRTFTN is ok
                    // since we don't allow creation of instances of abstract types.
                    if (pMethod->IsAbstract())
                    {
                        m_sError.dwFlags = VER_ERR_OPCODE_OFFSET;
                        SET_ERR_OPCODE_OFFSET();
                        if (!SetErrorAndContinue(VER_E_FTN_ABSTRACT))
                            return E_FAIL;
                    }
#endif

                    pInstanceClass = m_pMethodDesc->GetClass();
                }

                // Check access (public / private / family ...).

                if (!ClassLoader::CanAccess(
                        m_pMethodDesc->GetClass(),
                        m_pClassLoader->GetAssembly(), 
                        pMethod->GetClass(),
                        pMethod->GetModule()->GetAssembly(),
                        pInstanceClass, 
                        pMethod->GetAttrs()))
                {
                    m_sError.dwFlags = VER_ERR_OPCODE_OFFSET;
                    SET_ERR_OPCODE_OFFSET();
                    if (!SetErrorAndContinue(VER_E_METHOD_ACCESS))
                        goto exit;
                }

                MethodItem.SetMethodDesc(pMethod);

                if (!Push(&MethodItem))
                {
                    FAILMSG_PC_STACK_OVERFLOW();
                    goto exit;
                }

                break;
            }

            case CEE_NEWOBJ:
            case CEE_CALLVIRT:
            case CEE_CALL:
            {

                BOOL fTailCall = FALSE;

                if (!ON_INSTR_BOUNDARY(dwPCAtStartOfInstruction))
                {
                    // This is a prefixed CALL.

                    // For now, the only legal prefix is "TAILCALL", and the
                    // syntactic phase has already guaranteed that there's
                    // no other way we could get here. So for now, the code
                    // to parse backward to fetch the prefix can be a debug assert.
#ifdef _DEBUG
                    {
                        DWORD ipos2 = dwPCAtStartOfInstruction;
                        while (ipos2 >= 0 && !ON_INSTR_BOUNDARY(ipos2))
                        {
                            _ASSERTE(!ON_BB_BOUNDARY(ipos2));
                            ipos2--;
                        }
                        _ASSERTE(ON_INSTR_BOUNDARY(ipos2));

                        DWORD prefixopcode, prefixopcodelen;
                        prefixopcode = DecodeOpcode(&m_pCode[ipos2], &prefixopcodelen);
                        _ASSERTE(prefixopcode == CEE_TAILCALL);

                    }
                    
#endif
                    fTailCall = TRUE;
                }



                OBJECTREF   refThrowable = NULL ;
                mdMemberRef mr; // member reference

                mr = (mdMemberRef) inline_operand;

                GCPROTECT_BEGIN (refThrowable) ;
                hr = VerifyMethodCall(dwPCAtStartOfInstruction, mr, opcode, fTailCall, &refThrowable);
                if (FAILED(hr) && refThrowable != NULL)
                {
                    StoreObjectInHandle (m_hThrowable, refThrowable) ;
                }
                GCPROTECT_END () ;

                if (FAILED(hr))
                    goto exit;


                break;
            }

            case CEE_INITOBJ:
            {
                Item *pItem = PopItem();
                Item DesiredItem;

                if (pItem == NULL)
                {
                    FAILMSG_PC_STACK_UNDERFLOW();
                    goto exit;
                }

                if (!pItem->IsByRefValueClassOrByRefPrimitiveValueClass())
                {
                    m_sError.dwFlags = VER_ERR_OPCODE_OFFSET;
                    SET_ERR_OPCODE_OFFSET();
                    if (!SetErrorAndContinue(VER_E_STACK_P_VALCLASS))
                        goto exit;
                }
                
                if (!DesiredItem.SetType(inline_operand, m_pModule))
                {
                    FAILMSG_TOKEN_RESOLVE(inline_operand);
                    goto exit;
                }

                if (pItem->IsUninitialised())
                {
                    DesiredItem.SetUninitialised();
                }

                // &ValueClass
                DesiredItem.MakeByRef();

                if (!pItem->CompatibleWith(&DesiredItem, m_pClassLoader, FALSE /*subclasses NOT compatible!*/))
                {
                    m_sError.dwFlags = 
                        (VER_ERR_ITEM_F|VER_ERR_ITEM_E|VER_ERR_OPCODE_OFFSET);
                    m_sError.sItemFound = pItem->_GetItem();
                    m_sError.sItemExpected = DesiredItem._GetItem();
                    SET_ERR_OPCODE_OFFSET();
                    if (!SetErrorAndContinue(VER_E_STACK_UNEXPECTED))
                        goto exit;
                }
                
                pItem->SetInitialised();

                // If our destination happened to be the address of a local variable, then mark
                // the local as inited
                PropagateIsInitialised(pItem);

                break;
            }

            case CEE_LDOBJ: // &valueclass -> valueclass
            {
                Item  DesiredItem;

                if (!DesiredItem.SetType(inline_operand, m_pModule))
                {
                    FAILMSG_TOKEN_RESOLVE(inline_operand);
                    goto exit;
                }

#ifdef _DEBUG
                DesiredItem.Dump();
#endif

                if (!DesiredItem.IsValueClassOrPrimitive())
                {
                    m_sError.dwFlags = VER_ERR_OPCODE_OFFSET;
                    SET_ERR_OPCODE_OFFSET();
                    if (!SetErrorAndContinue(VER_E_VALCLASS))
                        goto exit;
                }

                // We want a &valueclass on the stack
                DesiredItem.MakeByRef();

                // Get, don't pop, the stack
                Item *pItem = GetTopStack();
                if (pItem == NULL)
                {
                    FAILMSG_PC_STACK_UNDERFLOW();
                    goto exit;
                }

                if (pItem->IsUninitialised())
                {
                    m_sError.dwFlags = VER_ERR_OPCODE_OFFSET;
                    SET_ERR_OPCODE_OFFSET();
                    if (!SetErrorAndContinue(VER_E_STACK_UNINIT))
                        goto exit;
                }

                // Class must be exactly the same -we don't allow subclass relationships here,
                // hence the FALSE parameter.
                if (!pItem->CompatibleWith(&DesiredItem, m_pClassLoader, FALSE))
                {
                    m_sError.dwFlags = 
                        (VER_ERR_ITEM_F|VER_ERR_ITEM_E|VER_ERR_OPCODE_OFFSET);
                    m_sError.sItemFound = pItem->_GetItem();
                    m_sError.sItemExpected = DesiredItem._GetItem();
                    SET_ERR_OPCODE_OFFSET();
                    if (!SetErrorAndContinue(VER_E_STACK_UNEXPECTED))
                        goto exit;
                }

                pItem->DereferenceByRefAndNormalise();
                break;
            }

            case CEE_BOX: // byref valueclass -> object
            {
                Item DesiredItem, ValueClass;

                if (!DesiredItem.SetType(inline_operand, m_pModule))
                {
                    FAILMSG_TOKEN_RESOLVE(inline_operand);
                    goto exit;
                }

#ifdef _DEBUG
                DesiredItem.Dump();
#endif

                if (!DesiredItem.IsValueClassOrPrimitive())
                {
                    m_sError.dwFlags = VER_ERR_OPCODE_OFFSET;
                    SET_ERR_OPCODE_OFFSET();
                    if (!SetErrorAndContinue(VER_E_VALCLASS))
                        goto exit;
                }

                Item *pItem = PopItem();
                if (pItem == NULL)
                {
                    FAILMSG_PC_STACK_UNDERFLOW();
                    goto exit;
                }

                if (pItem->IsUninitialised())
                {
                    m_sError.dwFlags = VER_ERR_OPCODE_OFFSET;
                    SET_ERR_OPCODE_OFFSET();
                    if (!SetErrorAndContinue(VER_E_STACK_UNINIT))
                        goto exit;
                }

                ValueClass = DesiredItem;
                // Make System.Char, System.Int16 .. etc to I4
                
                DesiredItem.NormaliseToPrimitiveType();
                DesiredItem.NormaliseForStack();

                // Boxing of RuntimeArgHandle / TypedByref could lead to
                // a pointer into the stack living longer than the stack.
                if (DesiredItem.IsValueClassWithPointerToStack())
                {
                    m_sError.dwFlags = VER_ERR_OPCODE_OFFSET;
                    SET_ERR_OPCODE_OFFSET();
                    if (!SetErrorAndContinue(VER_E_BOX_PTR_TO_STACK))
                        goto exit;
                }

                // stack item must by a byref <valueclass> exactly (no subclass relationship allowed)
                if (!pItem->CompatibleWith(&DesiredItem, m_pClassLoader, FALSE))
                {
                    m_sError.dwFlags = 
                        (VER_ERR_ITEM_F|VER_ERR_ITEM_E|VER_ERR_OPCODE_OFFSET);
                    m_sError.sItemFound = pItem->_GetItem();
                    m_sError.sItemExpected = DesiredItem._GetItem();
                    SET_ERR_OPCODE_OFFSET();
                    if (!SetErrorAndContinue(VER_E_STACK_UNEXPECTED))
                        goto exit;
                }

                // If this is not a value class or primitive type
                // The error was already reproted and the client chose to 
                // continue and find more errors. 
                if (ValueClass.IsValueClassOrPrimitive())
                    ValueClass.Box();

                (void) Push(&ValueClass);
                break;
            }

            // object -> byref valueclass
            // Unboxing of certain value classes is special cased:
            // unbox System/Boolean -> &I1
            // unbox System/Byte    -> &I1
            // unbox System/Char    -> &I2
            // unbox System/Int16-> &I2
            // unbox System/Int32-> &I4
            // unbox System/Int64-> &I8
            // unbox System/Single  -> &R4
            // unbox System/Double  -> &R8
            //
            case CEE_UNBOX: 
            {
                Item     DestItem;
                
                Item *pItem = PopItem();
                if (pItem == NULL)
                {
                    FAILMSG_PC_STACK_UNDERFLOW();
                    goto exit;
                }

                if (!pItem->IsObjRef())
                {
                    m_sError.dwFlags = VER_ERR_OPCODE_OFFSET;
                    SET_ERR_OPCODE_OFFSET();
                    if (!SetErrorAndContinue(VER_E_STACK_OBJREF))
                        goto exit;
                }
            
                if (!DestItem.SetType(inline_operand, m_pModule))
                {
                    FAILMSG_TOKEN_RESOLVE(inline_operand);
                    goto exit;
                }

                if (!DestItem.IsValueClassOrPrimitive())
                {
                    m_sError.dwFlags = VER_ERR_OPCODE_OFFSET;
                    SET_ERR_OPCODE_OFFSET();
                    if (!SetErrorAndContinue(VER_E_VALCLASS))
                        goto exit;
                }

/*  
We don't have to do this. 
There is a runtime check for this operation.

                // Subclass relationship not OK.
                if (!pItem->CompatibleWith(&DestItem, m_pClassLoader, FALSE))
                {
                    m_sError.dwFlags = 
                        (VER_ERR_ITEM_F|VER_ERR_ITEM_E|VER_ERR_OPCODE_OFFSET);
                    m_sError.sItemFound = pItem->_GetItem();
                    m_sError.sItemExpected = DesiredItem._GetItem();
                    SET_ERR_OPCODE_OFFSET();
                    if (!SetErrorAndContinue(VER_E_STACK_UNEXPECTED))
                        goto exit;
                }
*/

                // Make into a byref
                DestItem.MakeByRef();
                (void) Push(&DestItem);
                break;
            }

            case CEE_STOBJ:
            {
                // Copy a value class onto the stack
                Item  RefItem, RefOnStack;

                Item *pSrcItem = PopItem();

                if (pSrcItem == NULL)
                {
                    FAILMSG_PC_STACK_UNDERFLOW();
                    goto exit;
                }

                if (!pSrcItem->IsValueClassOrPrimitive())
                {
                    m_sError.dwFlags = VER_ERR_OPCODE_OFFSET;
                    SET_ERR_OPCODE_OFFSET();
                    if (!SetErrorAndContinue(VER_E_STACK_VALCLASS))
                        goto exit;
                }

                if (pSrcItem->IsUninitialised())
                {
                    m_sError.dwFlags = VER_ERR_OPCODE_OFFSET;
                    SET_ERR_OPCODE_OFFSET();
                    if (!SetErrorAndContinue(VER_E_STACK_UNINIT))
                        goto exit;
                }

                // Resolve the inline token
                if (!RefItem.SetType(inline_operand, m_pModule))
                {
                    FAILMSG_TOKEN_RESOLVE(inline_operand);
                    goto exit;
                }

                if (!RefItem.IsValueClassOrPrimitive())
                {
                    m_sError.dwFlags = VER_ERR_OPCODE_OFFSET;
                    SET_ERR_OPCODE_OFFSET();
                    if (!SetErrorAndContinue(VER_E_VALCLASS))
                        goto exit;
                }

                // SrcItem is on stack, which is normalised for stack
                // so do the same for the RefItem, so that compatible does
                // not fail for (I2 - I4) case

                RefOnStack = RefItem;

                RefOnStack.NormaliseForStack();

                if (!pSrcItem->CompatibleWith(&RefOnStack, m_pClassLoader, 
                        FALSE /*subclasses NOT compatible!*/))
                {
                    m_sError.dwFlags = 
                        (VER_ERR_ITEM_F|VER_ERR_ITEM_E|VER_ERR_OPCODE_OFFSET);
                    m_sError.sItemFound = pSrcItem->_GetItem();
                    m_sError.sItemExpected = RefItem._GetItem();
                    SET_ERR_OPCODE_OFFSET();
                    if (!SetErrorAndContinue(VER_E_STACK_UNEXPECTED))
                        goto exit;
                }

                RefItem.MakeByRef();
                
                Item *pDestItem = PopItem();
                if (pDestItem == NULL)
                {
                    FAILMSG_PC_STACK_UNDERFLOW();
                    goto exit;
                }
                
                if (!pDestItem->IsByRefValueClassOrByRefPrimitiveValueClass())
                {
                    m_sError.dwFlags = VER_ERR_OPCODE_OFFSET;
                    SET_ERR_OPCODE_OFFSET();
                    if (!SetErrorAndContinue(VER_E_STACK_P_VALCLASS))
                        goto exit;
                }
                
                pDestItem->SetInitialised();

                if (!pDestItem->CompatibleWith(&RefItem, m_pClassLoader, 
                        FALSE /*subclasses NOT compatible!*/))
                {
                    m_sError.dwFlags = 
                        (VER_ERR_ITEM_F|VER_ERR_ITEM_E|VER_ERR_OPCODE_OFFSET);
                    m_sError.sItemFound = pDestItem->_GetItem();
                    m_sError.sItemExpected = RefItem._GetItem();
                    SET_ERR_OPCODE_OFFSET();
                    if (!SetErrorAndContinue(VER_E_STACK_UNEXPECTED))
                        goto exit;
                }

                // If our destination happened to be the address of a local variable, then mark
                // the local as inited
                PropagateIsInitialised(pDestItem);
                break;
            }


            case CEE_CPOBJ:
            {
                // Copy a value class onto the stack
                Item     RefItem;
                
                Item *pSrcItem = PopItem();
                if (pSrcItem == NULL)
                {
                    FAILMSG_PC_STACK_UNDERFLOW();
                    goto exit;
                }

                if (!pSrcItem->IsByRefValueClassOrByRefPrimitiveValueClass())
                {
                    m_sError.dwFlags = VER_ERR_OPCODE_OFFSET;
                    SET_ERR_OPCODE_OFFSET();
                    if (!SetErrorAndContinue(VER_E_STACK_P_VALCLASS))
                        goto exit;
                }

                if (pSrcItem->IsUninitialised())
                {
                    m_sError.dwFlags = VER_ERR_OPCODE_OFFSET;
                    SET_ERR_OPCODE_OFFSET();
                    if (!SetErrorAndContinue(VER_E_STACK_UNINIT))
                        goto exit;
                }

                Item *pDestItem = PopItem();
                if (pDestItem == NULL)
                {
                    FAILMSG_PC_STACK_UNDERFLOW();
                    goto exit;
                }

                if (!pDestItem->IsByRefValueClassOrByRefPrimitiveValueClass())
                {
                    m_sError.dwFlags = VER_ERR_OPCODE_OFFSET;
                    SET_ERR_OPCODE_OFFSET();
                    if (!SetErrorAndContinue(VER_E_STACK_P_VALCLASS))
                        goto exit;
                }

                // Resolve the inline token
                if (!RefItem.SetType(inline_operand, m_pModule))
                {
                    FAILMSG_TOKEN_RESOLVE(inline_operand);
                    goto exit;
                }

                if (!RefItem.IsValueClassOrPrimitive())
                {
                    m_sError.dwFlags = VER_ERR_OPCODE_OFFSET;
                    SET_ERR_OPCODE_OFFSET();
                    if (!SetErrorAndContinue(VER_E_VALCLASS))
                        goto exit;
                }

                RefItem.MakeByRef();

                // We already know the source is initialised
                // Make the destination initialised as well (because it will be after this
                // operation) otherwise CompatibleWith() will return FALSE
                if (!pSrcItem->CompatibleWith(&RefItem, m_pClassLoader))
                {
                    m_sError.dwFlags = 
                        (VER_ERR_ITEM_F|VER_ERR_ITEM_E|VER_ERR_OPCODE_OFFSET);
                    m_sError.sItemFound = pSrcItem->_GetItem();
                    m_sError.sItemExpected = RefItem._GetItem();
                    SET_ERR_OPCODE_OFFSET();
                    if (!SetErrorAndContinue(VER_E_STACK_UNEXPECTED))
                        goto exit;
                }

                pDestItem->SetInitialised();

                if (!pDestItem->CompatibleWith(&RefItem, m_pClassLoader))
                {
                    m_sError.dwFlags = 
                        (VER_ERR_ITEM_F|VER_ERR_ITEM_E|VER_ERR_OPCODE_OFFSET);
                    m_sError.sItemFound = pDestItem->_GetItem();
                    m_sError.sItemExpected = RefItem._GetItem();
                    SET_ERR_OPCODE_OFFSET();
                    if (!SetErrorAndContinue(VER_E_STACK_UNEXPECTED))
                        goto exit;
                }

                // If our destination happened to be the address of a local variable, then mark
                // the local as inited
                PropagateIsInitialised(pDestItem);
                break;
            }

            case CEE_LDIND_REF:
            {
                Item *pItem = GetTopStack();
                if (pItem == NULL)
                {
                    FAILMSG_PC_STACK_UNDERFLOW();
                    goto exit;
                }

                if (!pItem->IsByRefObjRef())
                {
                    m_sError.dwFlags = VER_ERR_OPCODE_OFFSET;
                    SET_ERR_OPCODE_OFFSET();
                    if (!SetErrorAndContinue(VER_E_STACK_OBJREF))
                        goto exit;
                }

                if (pItem->IsUninitialised())
                {
                    m_sError.dwFlags = VER_ERR_OPCODE_OFFSET;
                    SET_ERR_OPCODE_OFFSET();
                    if (!SetErrorAndContinue(VER_E_STACK_UNINIT))
                        goto exit;
                }

                pItem->DereferenceByRefObjRef();
                break;
            }


            case CEE_STIND_REF:
            {
                Item SrcItem;

                Item *pItem = PopItem();
                if (pItem == NULL)
                {
                    FAILMSG_PC_STACK_UNDERFLOW();
                    goto exit;
                }
                SrcItem = *pItem;

                if (!SrcItem.IsObjRef())
                {
                    m_sError.dwFlags = VER_ERR_OPCODE_OFFSET;
                    SET_ERR_OPCODE_OFFSET();
                    if (!SetErrorAndContinue(VER_E_STACK_OBJREF))
                        goto exit;
                }

                pItem = PopItem();
                if (pItem == NULL)
                {
                    FAILMSG_PC_STACK_UNDERFLOW();
                    goto exit;
                }

                if (!pItem->IsByRefObjRef())
                {
                    m_sError.dwFlags = VER_ERR_OPCODE_OFFSET;
                    SET_ERR_OPCODE_OFFSET();
                    if (!SetErrorAndContinue(VER_E_STACK_P_OBJREF))
                        goto exit;
                }

                pItem->SetInitialised();
                PropagateIsInitialised(pItem);

                pItem->DereferenceByRefObjRef();

                // pItem may contain information like the field #, local var #,
                // permanent home information etc, that could make the type 
                // check below fail. At this point, we are interested only in
                // the 'type' compatiblility of SrcItem and pItem. So strip
                // pItem of all the irrelavant information.

                pItem->RemoveAllNonTypeInformation();

                if (!(SrcItem.CompatibleWith(pItem, m_pClassLoader)))
                {
                    m_sError.dwFlags = 
                        (VER_ERR_ITEM_F|VER_ERR_ITEM_E|VER_ERR_OPCODE_OFFSET);
                    m_sError.sItemFound = SrcItem._GetItem();
                    m_sError.sItemExpected = pItem->_GetItem();
                    SET_ERR_OPCODE_OFFSET();
                    if (!SetErrorAndContinue(VER_E_STACK_UNEXPECTED))
                        goto exit;
                }


                break;

            }


            // You always get the signature-declared type back out (there is no "current type").
            case CEE_LDARGA:
            case CEE_LDARGA_S:
            {
                // Load the address of an argument
                // The arg can be a primitive type, value class, or objref
                // Pushes a "byref <x>" onto the stack, where x is the globally known type of the arg.
                LocArgInfo_t *pGlobalArgType;

                // Get the global type of the arg
                pGlobalArgType = GetGlobalArgTypeInfo(inline_operand);

                Item CopyOfGlobalArgItem = pGlobalArgType->m_Item;

                if (
#if 0 // @Review
                    CopyOfGlobalArgItem.IsValueClassWithPointerToStack() ||
#endif
                    CopyOfGlobalArgItem.IsByRef())
                {
                    m_sError.dwFlags = VER_ERR_OPCODE_OFFSET;
                    SET_ERR_OPCODE_OFFSET();
                    if (!SetErrorAndContinue(VER_E_ADDR_BYREF))
                        goto exit;
                }

                // The only time an argument can contain an uninitialised value is when the
                // "this" pointer is uninitialised, in slot 0
                if (m_fThisUninit && inline_operand == 0)
                    CopyOfGlobalArgItem.SetUninitialised();

                // Mark that this item is a byref
                CopyOfGlobalArgItem.MakeByRef();

                // This could push an UnInitialized item ?
                if (!Push(&CopyOfGlobalArgItem))
                {
                    FAILMSG_PC_STACK_OVERFLOW();
                    goto exit;
                }

                break;
            }

            case CEE_LDLOCA_S:
            case CEE_LDLOCA:
            {
                // All verifiable methods with one or more locals should
                // set init locals.
                if ((m_pILHeader->Flags & CorILMethod_InitLocals) == 0)
                {
                    m_sError.dwFlags = VER_ERR_OPCODE_OFFSET;
                    SET_ERR_OPCODE_OFFSET();
                    if (!SetErrorAndContinue(VER_E_INITLOCALS))
                        goto exit;
                }
            
                // Load the address of a local
                // Pushes a "byref <x>" onto the stack, where x is the current type of the local.
                Item            item;

/****************************************************************************/
#if 0   // This one needs a complete rewrite.. leaving the code in #if 0 for retaining history.
                // Check that we are allowed to ldloc this local (use global type info, because the 
                // current local may be dead if it's a value class and no one has initialised it yet)
                LocArgInfo_t *  pGlobalInfo;
                Item *          pGlobalLocVarType;
                long            slot;

                pGlobalInfo         = GetGlobalLocVarTypeInfo(inline_operand);
                pGlobalLocVarType   = &pGlobalInfo->m_Item;
                slot                = pGlobalInfo->m_Slot;
               
                if (pGlobalLocVarType->IsObjRef())
                {
                    // You can take the address of an objref local, but only if it contains initialised data.
                    item = GetCurrentValueOfLocal(inline_operand);
                    if (item.IsDead() /* || item.IsUninitialised() */)
                    {
                        m_sError.dwFlags = VER_ERR_OPCODE_OFFSET;
                        SET_ERR_OPCODE_OFFSET();
                        if (!SetErrorAndContinue(VER_E_LOC_DEAD))
                            goto exit;
                    }
                }
// Locals are never BYREFS in verifiable code
                else if (!pGlobalLocVarType->IsValueClass() && !pGlobalLocVarType->IsPrimitiveType())
                {
                    // This also catches trying to ldloca when the local itself is a byref
                    m_sError.dwFlags = VER_ERR_OPCODE_OFFSET;
                    SET_ERR_OPCODE_OFFSET();
                    if (!SetErrorAndContinue(VER_E_ADDR))
                        goto exit;
                }


                if (LIVEDEAD_TRACKING_ONLY_FOR_SLOT(slot))
                {
                    // If we only keep live-dead information for this local, then get its global type
                    // and set the uninitialised flag if it is dead (since we will be pushing a pointer
                    // to an uninitialised item).
                    item = *pGlobalLocVarType;

                    // Mark that this item is a byref, and of a particular local
                    item.MakeByRefLocal(inline_operand);


#if 0
                    if (!IsLocVarLiveSlot(LIVEDEAD_NEGATIVE_SLOT_TO_BITNUM(slot)))
                        item.SetUninitialised();
#else
                    // The JIT always zero-initializes GC-refs inside any local whose
                    // address is taken. Thus, we can treat this local as live from hereon.
                    SetLocVarLiveSlot(LIVEDEAD_NEGATIVE_SLOT_TO_BITNUM(slot));
#endif
                }
                else
                {
                    // Otherwise this local has full type information tracked with it
                    item = m_pNonPrimitiveLocArgs[slot];
/*
                    if (item.IsDead() || item.IsUninitialised())
                    {
                        m_sError.dwFlags = VER_ERR_OPCODE_OFFSET;
                        SET_ERR_OPCODE_OFFSET();
                        if (!SetErrorAndContinue(VER_E_DEAD))
                            goto exit;
                    }
*/

                    // Mark that this item is a byref, and of a particular local
                    item.MakeByRefLocal(inline_operand);
                }
#endif // if 0 This one needs a complete rewrite.. leaving the code in #if 0 for retaining history.
/****************************************************************************/

                item = GetCurrentValueOfLocal(inline_operand);

                // OK to take address of Uninitialised var
                // for using as 'this' pointer to call initobj 

                if (item.IsDead() /* || item.IsUninitialised() */)
                {
                    m_sError.dwFlags = VER_ERR_OPCODE_OFFSET;
                    SET_ERR_OPCODE_OFFSET();
                    if (!SetErrorAndContinue(VER_E_DEAD))
                        goto exit;
                }

                if (item.IsByRef())
                {
                    m_sError.dwFlags = VER_ERR_OPCODE_OFFSET;
                    SET_ERR_OPCODE_OFFSET();
                    if (!SetErrorAndContinue(VER_E_ADDR_BYREF))
                        goto exit;
                }

                item.MakeByRefLocal(inline_operand);

                if (!Push(&item))
                {
                    FAILMSG_PC_STACK_OVERFLOW();
                    goto exit;
                }

                break;
            }

            //
            // Fields
            //

            // Loading the address of a field
            case CEE_LDFLDA:
                fLoadAddress    = TRUE;
                fStatic         = FALSE;
                goto handle_ldfld;

            case CEE_LDSFLDA:
                fLoadAddress    = TRUE;
                fStatic         = TRUE;
                goto handle_ldfld;

            // Loading a field
            case CEE_LDSFLD:
                fLoadAddress    = FALSE;
                fStatic         = TRUE;
                goto handle_ldfld;

            case CEE_LDFLD:
            {
                EEClass *       pRefClass;
                EEClass *       pInstanceClass;
                FieldDesc *     pFieldDesc;
                DWORD           dwAttrs;
                PCCOR_SIGNATURE pSig;
                DWORD           cSig;
                Module *        pModuleForSignature;
                Item *          pInstance;

                fLoadAddress    = FALSE;
                fStatic         = FALSE;

handle_ldfld:
                Item            FieldItem; 
                pInstance       = NULL;

                // Resolve this field reference to a FieldDesc and FieldRef signature, and the Module in which
                // the signature is scoped.  The signature is that of the original field as declared, not the reference
                // in the opcode stream (although they should be effectively the same, scoped tokens notwithstanding).

                hr = ResolveFieldRef((mdMemberRef) inline_operand, &pFieldDesc, 
                        &pSig, &cSig, &pModuleForSignature);

                if (FAILED(hr))
                {
                    m_sError.dwFlags = (VER_ERR_FATAL|VER_ERR_TOKEN|VER_ERR_OPCODE_OFFSET);
                    SET_ERR_OPCODE_OFFSET();
                    m_sError.token = inline_operand;
                    SetErrorAndContinue(hr);
                    goto exit;
                }

#ifdef _DEBUG
                LOG((LF_VERIFIER, LL_INFO10000, "%s::%s\n", pFieldDesc->GetEnclosingClass()->m_szDebugClassName, pFieldDesc->GetName()));
#endif

                VerSig sig(this, pModuleForSignature, pSig, cSig, 
                    (VERSIG_TYPE_FIELD_SIG|VER_ERR_OFFSET), 
                    dwPCAtStartOfInstruction);

                if (!sig.Init())
                {
                    goto exit;
                }

                // Parse the next component in the sig to an item.
                // The second parameter being FALSE means "don't allow void".
                if (!sig.ParseNextComponentToItem(&FieldItem, FALSE, FALSE, &m_hThrowable, VER_NO_ARG, !fLoadAddress))
                {
                    goto exit;
                }

                pRefClass = pFieldDesc->GetEnclosingClass();

                // Get attributes for this field
                dwAttrs = pFieldDesc->GetAttributes();

                if (!fStatic)
                {
                    Item        RefItem;

#if 0 // Ok to do ldfld(a) on static fields. instance will be ignored.
                    // Field must not be static
                    if (IsFdStatic(dwAttrs))
                    {
                        m_sError.dwFlags = VER_ERR_OPCODE_OFFSET;
                        SET_ERR_OPCODE_OFFSET();
                        if (!SetErrorAndContinue(VER_E_FIELD_NO_STATIC))
                            goto exit;
                    }
#endif // Ok to do ldfld(a) on static fields. instance will be ignored.

                    if (pRefClass->IsArrayClass())
                    {
                        m_sError.dwFlags = VER_ERR_OPCODE_OFFSET;
                        SET_ERR_OPCODE_OFFSET();
                        if (!SetErrorAndContinue(VER_E_ARRAY_FIELD))
                            goto exit;
                    }

                    // The instance on the stack must be same or subclass of memberref class type
                    // e.g. if "ldfld Object::HashValue" then we must have a subclass of Object on the stack

                    RefItem.SetTypeHandle(pRefClass->GetMethodTable());

                    // Make into a &valueclass if a value class
                    if (pRefClass->IsValueClass())
                        RefItem.MakeByRef();

                    pInstance = PopItem();
                    if (pInstance == NULL)
                    {
                        FAILMSG_PC_STACK_UNDERFLOW();
                        goto exit;
                    }

                    // ldfld(a) on static fields. instance will be ignored.
                    if (IsFdStatic(dwAttrs))
                        goto ldfld_set_instance_for_static;

                    if (pInstance->IsUninitialised())
                    {
                        // Ok to load Address of 'this' ptr

                        // In a value class .ctor, it is ok to use an 
                        // instance field that was initialized.

                        // It is ok to ld/store a field in a .ctor
                        if (fLoadAddress ||
                            (pInstance->IsThisPtr() &&
                            ((m_fInConstructorMethod && !m_fInValueClassConstructor) ||
                             (m_fInValueClassConstructor && IsValueClassFieldInited(FieldDescToFieldNum(pFieldDesc)))
                            )))
                        {
                            RefItem.SetUninitialised();
                        }
                        else
                        {
                            m_sError.dwFlags = VER_ERR_OPCODE_OFFSET;
                            SET_ERR_OPCODE_OFFSET();
                            if (!SetErrorAndContinue(VER_E_STACK_UNINIT))
                                goto exit;
                        }
                    }

                    // null ok (will cause a runtime null pointer exception)
                    if (!pInstance->CompatibleWith(&RefItem, m_pClassLoader))
                    {
                        m_sError.dwFlags = 
                            (VER_ERR_ITEM_F|VER_ERR_ITEM_E|VER_ERR_OPCODE_OFFSET);
                        m_sError.sItemFound = pInstance->_GetItem();
                        m_sError.sItemExpected = RefItem._GetItem();
                        SET_ERR_OPCODE_OFFSET();
                        if (!SetErrorAndContinue(VER_E_STACK_UNEXPECTED))
                            goto exit;
                    }

                    if (pInstance->ContainsTypeHandle())
                        pInstanceClass = pInstance->GetTypeHandle().GetClass();
                    else
                        pInstanceClass = m_pMethodDesc->GetClass();
                }
                else
                {
                    // field must be static
                    if (!IsFdStatic(dwAttrs))
                    {
                        m_sError.dwFlags = VER_ERR_OPCODE_OFFSET;
                        SET_ERR_OPCODE_OFFSET();
                        if (!SetErrorAndContinue(VER_E_FIELD_STATIC))
                            goto exit;
                    }

ldfld_set_instance_for_static:
                    pInstanceClass = m_pMethodDesc->GetClass(); 
                }

                // Enforce access rules
                // Check access (public / private / family ...).

                if (!ClassLoader::CanAccess(
                        m_pMethodDesc->GetClass(),
                        m_pClassLoader->GetAssembly(), 
                        pRefClass,
                        pRefClass->GetAssembly(),
                        pInstanceClass,
                        pFieldDesc->GetFieldProtection()))
                {
                    m_sError.dwFlags = VER_ERR_OPCODE_OFFSET;
                    SET_ERR_OPCODE_OFFSET();
                    if (!SetErrorAndContinue(VER_E_FIELD_ACCESS))
                        goto exit;
                }

                if (fLoadAddress)
                {
                    // Turn foo -> &foo
                    FieldItem.MakeByRef();

                    if (fStatic)
                    {
                        // If doing a ldsflda, we are guaranteed that this item has a permanent home
                        FieldItem.SetIsPermanentHomeByRef();
                    }
                    else
                    {
                        // Otherwise we were doing a ldflda.  If we did this on an objref instance, we
                        // have a permanent home.  If we did this on a value class, we only have a 
                        // permanent home if the value class we loaded from did.
                        _ASSERTE(pInstance != NULL);

                        if (pInstance->IsObjRef() ||
                            (pInstance->
                                IsByRefValueClassOrByRefPrimitiveValueClass() &&
                            pInstance->IsPermanentHomeByRef()))
                        {
                            FieldItem.SetIsPermanentHomeByRef();
                        }

#if 0 // We allow this
                        if (pInstance->IsUninitialised())
                        {
                            FieldItem.SetUninitialised();
                        }
#endif

                        if (m_fInValueClassConstructor)
                        {
                            // what if we had an instance of 
                            // the same class in the constructor ?

                            // Is this one of our own instance fields?
                            if (pRefClass == m_pMethodDesc->GetClass())
                            {
                                // Set that we have the address of a particular instance field on the stack, so that
                                // we can track when the field is initialised, via a call <ctor>
                                FieldItem.MakeByRefInstanceField(FieldDescToFieldNum(pFieldDesc));
                            }
                        }
                    }

                    // Check InitOnly rules
                    if (IsFdInitOnly(dwAttrs))
                    {
                        if (pRefClass != m_pMethodDesc->GetClass())
                        {
                            m_sError.dwFlags = VER_ERR_OPCODE_OFFSET;
                            SET_ERR_OPCODE_OFFSET();
                            if (!SetErrorAndContinue(VER_E_INITONLY))
                                goto exit;
                        }
                        
                        if (fStatic) 
                        {
                            if (!m_fInClassConstructorMethod)
                            {
                                m_sError.dwFlags = VER_ERR_OPCODE_OFFSET;
                                SET_ERR_OPCODE_OFFSET();
                                if (!SetErrorAndContinue(VER_E_INITONLY))
                                    goto exit;
                            }
                        }
                        else
                        {
                            if (!m_fInConstructorMethod)
                            {
                                m_sError.dwFlags = VER_ERR_OPCODE_OFFSET;
                                SET_ERR_OPCODE_OFFSET();
                                if (!SetErrorAndContinue(VER_E_INITONLY))
                                    goto exit;
                            }
                        }
                    }

                    if (IsFdHasFieldRVA(dwAttrs))
                    {
                         m_sError.dwFlags = VER_ERR_OPCODE_OFFSET;
                         SET_ERR_OPCODE_OFFSET();
                         if (!SetErrorAndContinue(VER_E_WRITE_RVA_STATIC))
                               goto exit;
                    }
                    
                    if (IsFdLiteral(dwAttrs))
                    {
                        m_sError.dwFlags = VER_ERR_OPCODE_OFFSET;
                        SET_ERR_OPCODE_OFFSET();
                        if (!SetErrorAndContinue(VER_E_ADDR_LITERAL))
                            goto exit;
                    }
                }

                if (!fLoadAddress)
                    FieldItem.NormaliseForStack();

                // Push field type
                if (!Push(&FieldItem))
                {
                    FAILMSG_PC_STACK_OVERFLOW();
                    goto exit; 
                };
                break;
            }

            // storing static fields
            case CEE_STSFLD:
                fStatic = TRUE;
                goto handle_stfld;

            // storing instance fields
            case CEE_STFLD:
            {
                EEClass *   pRefClass;
                EEClass *   pInstanceClass;   // Used for family access check
                FieldDesc * pFieldDesc;
                DWORD       dwAttrs;
                Item *      pVal;
                PCCOR_SIGNATURE pSig;
                DWORD       cSig;
                Module *    pModuleForSignature;

                fStatic = FALSE;

handle_stfld:
                Item        FieldItem; 

                hr = ResolveFieldRef((mdMemberRef) inline_operand, &pFieldDesc, 
                        &pSig, &cSig, &pModuleForSignature);

                if (FAILED(hr))
                {
                    m_sError.dwFlags = (VER_ERR_FATAL|VER_ERR_TOKEN|VER_ERR_OPCODE_OFFSET);
                    SET_ERR_OPCODE_OFFSET();
                    m_sError.token = inline_operand;
                    SetErrorAndContinue(hr);
                    goto exit;
                }

#ifdef _DEBUG
                LOG((LF_VERIFIER, LL_INFO10000, "%s::%s\n", pFieldDesc->GetEnclosingClass()->m_szDebugClassName, pFieldDesc->GetName()));
#endif

                VerSig sig(this, pModuleForSignature, pSig, cSig,
                    (VERSIG_TYPE_FIELD_SIG|VER_ERR_OFFSET), 
                    dwPCAtStartOfInstruction);

                if (!sig.Init())
                {
                    goto exit;
                }

                // Parse the sig to an item
                // The second parameter being FALSE means "don't allow void".
                if (!sig.ParseNextComponentToItem(&FieldItem, FALSE, FALSE, &m_hThrowable, VER_NO_ARG, TRUE))
                {
                    goto exit;
                }

                // Owner class for this field
                pRefClass = pFieldDesc->GetEnclosingClass();

                // get attributes for this field
                dwAttrs = pFieldDesc->GetAttributes();

                // pop value
                pVal = PopItem();
                if (pVal == NULL)
                {
                    FAILMSG_PC_STACK_UNDERFLOW();
                    goto exit;
                }

                // check that the value on the stack is of correct type
                // the type that we're storing in the field, must be the same as or a subclass of 
                // the field type
                if (!pVal->CompatibleWith(&FieldItem, m_pClassLoader))
                {
                    m_sError.dwFlags = 
                        (VER_ERR_ITEM_F|VER_ERR_ITEM_E|VER_ERR_OPCODE_OFFSET);
                    m_sError.sItemFound = pVal->_GetItem();
                    m_sError.sItemExpected = FieldItem._GetItem();
                    SET_ERR_OPCODE_OFFSET();
                    if (!SetErrorAndContinue(VER_E_STACK_UNEXPECTED))
                        goto exit;
                }

                if (!fStatic)
                {
                    Item *      pInstanceItem;
                    Item        RefItem;

#if 0 // Ok to do stfld on static fields. instance will be ignored.
                    // field must not be static
                    if (IsFdStatic(dwAttrs))
                    {
                        m_sError.dwFlags = VER_ERR_OPCODE_OFFSET;
                        SET_ERR_OPCODE_OFFSET();
                        if (!SetErrorAndContinue(VER_E_FIELD_NO_STATIC))
                            goto exit;
                    }
#endif // Ok to do stfld on static fields. instance will be ignored.

                    pInstanceItem = PopItem();

                    if (pInstanceItem == NULL)
                    {
                        FAILMSG_PC_STACK_UNDERFLOW();
                        goto exit;
                    }

                    // stfld on static fields. instance will be ignored.
                    if (IsFdStatic(dwAttrs))
                        goto stfld_set_instance_for_static;

                    if (pInstanceItem->IsUninitialised())
                    {
                        // Constructors are allowed to access it's fields even
                        // if "this" is not initialised.
                        if (m_fInConstructorMethod  &&
                            pInstanceItem->IsThisPtr() &&
                            pFieldDesc->GetEnclosingClass() == m_pMethodDesc->GetClass())
                        {
                        // If we are verifying a value class constructor, and we are doing a stfld
                        // on one of our own instance fields, then it is allowed.
                            if (m_fInValueClassConstructor)
                            {
                                SetValueClassFieldInited(pFieldDesc);
                                if (AreAllValueClassFieldsInited())
                                    PropagateThisPtrInit();

                            }

                            pInstanceClass = m_pMethodDesc->GetClass();

                            goto skip_some_stfld_checks;
                        }

                        m_sError.dwFlags = VER_ERR_OPCODE_OFFSET;
                        SET_ERR_OPCODE_OFFSET();
                        if (!SetErrorAndContinue(VER_E_STACK_UNINIT))
                            goto exit;
                    }

                    if (pRefClass->IsArrayClass())
                    {
                        m_sError.dwFlags = VER_ERR_OPCODE_OFFSET;
                        SET_ERR_OPCODE_OFFSET();
                        if (!SetErrorAndContinue(VER_E_ARRAY_FIELD))
                            goto exit;
                    }

                    RefItem.SetTypeHandle(pRefClass->GetMethodTable());

                    if (pRefClass->IsValueClass())
                        RefItem.MakeByRef();

                    // item on stack must be same or subclass of memberref class type
                    if (!pInstanceItem->CompatibleWith(&RefItem, m_pClassLoader))
                    {
                        m_sError.dwFlags = 
                            (VER_ERR_ITEM_F|VER_ERR_ITEM_E|VER_ERR_OPCODE_OFFSET);
                        m_sError.sItemFound = pInstanceItem->_GetItem();
                        m_sError.sItemExpected = RefItem._GetItem();
                        SET_ERR_OPCODE_OFFSET();
                        if (!SetErrorAndContinue(VER_E_STACK_UNEXPECTED))
                            goto exit;
                    }

                    if (pInstanceItem->ContainsTypeHandle())
                        pInstanceClass = pInstanceItem->GetTypeHandle().GetClass();
                    else
                        pInstanceClass = m_pMethodDesc->GetClass();

                }
                else
                {
                    // field must be static
                    if (!IsFdStatic(dwAttrs))
                    {
                        m_sError.dwFlags = VER_ERR_OPCODE_OFFSET;
                        SET_ERR_OPCODE_OFFSET();
                        if (!SetErrorAndContinue(VER_E_FIELD_STATIC))
                            goto exit;
                    }

stfld_set_instance_for_static:
                    pInstanceClass = m_pMethodDesc->GetClass();
                }

skip_some_stfld_checks:

                // Check InitOnly rules
                if (IsFdInitOnly(dwAttrs))
                {
                    if (pRefClass != m_pMethodDesc->GetClass())
                    {
                        m_sError.dwFlags = VER_ERR_OPCODE_OFFSET;
                        SET_ERR_OPCODE_OFFSET();
                        if (!SetErrorAndContinue(VER_E_INITONLY))
                            goto exit;
                    }
                    
                    if (fStatic) 
                    {
                        if (!m_fInClassConstructorMethod)
                        {
                            m_sError.dwFlags = VER_ERR_OPCODE_OFFSET;
                            SET_ERR_OPCODE_OFFSET();
                            if (!SetErrorAndContinue(VER_E_INITONLY))
                                goto exit;
                        }
                    }
                    else
                    {
                        if (!m_fInConstructorMethod)
                        {
                            m_sError.dwFlags = VER_ERR_OPCODE_OFFSET;
                            SET_ERR_OPCODE_OFFSET();
                            if (!SetErrorAndContinue(VER_E_INITONLY))
                                goto exit;
                        }
                    }
                }

                if (IsFdHasFieldRVA(dwAttrs))
                {
                     m_sError.dwFlags = VER_ERR_OPCODE_OFFSET;
                     SET_ERR_OPCODE_OFFSET();
					 if (!SetErrorAndContinue(VER_E_WRITE_RVA_STATIC))
                           goto exit;
                }

                if (IsFdLiteral(dwAttrs))
                {
                    m_sError.dwFlags = VER_ERR_OPCODE_OFFSET;
                    SET_ERR_OPCODE_OFFSET();
                    if (!SetErrorAndContinue(VER_E_ADDR_LITERAL))
                        goto exit;
                }

                // Enforce access rules
                // Check access (public / private / family ...).

                if (!ClassLoader::CanAccess(
                        m_pMethodDesc->GetClass(),
                        m_pClassLoader->GetAssembly(), 
                        pRefClass, 
                        pRefClass->GetAssembly(), 
                        pInstanceClass,
                        pFieldDesc->GetFieldProtection()))
                {
                    m_sError.dwFlags = VER_ERR_OPCODE_OFFSET;
                    SET_ERR_OPCODE_OFFSET();
                    if (!SetErrorAndContinue(VER_E_FIELD_ACCESS))
                        goto exit;
                }

                break;
            }

            case CEE_THROW:
            {
                Item *pItem = PopItem();
                if (pItem == NULL)
                {
                    FAILMSG_PC_STACK_UNDERFLOW();
                    goto exit;
                }

                if (!pItem->IsObjRef())
                {
                    m_sError.dwFlags = VER_ERR_OPCODE_OFFSET;
                    SET_ERR_OPCODE_OFFSET();
                    if (!SetErrorAndContinue(VER_E_STACK_OBJREF))
                        goto exit;
                }

                if (pItem->IsUninitialised())
                {
                    m_sError.dwFlags = VER_ERR_OPCODE_OFFSET;
                    SET_ERR_OPCODE_OFFSET();
                    if (!SetErrorAndContinue(VER_E_STACK_UNINIT))
                        goto exit;
                }

#if 0  // Any object can be thrown.

                // Verify that the object is a subclass of Exception, or null

                if (!pItem->IsNullObjRef() && 
                    !ClassLoader::StaticCanCastToClassOrInterface(
                        pItem->GetTypeHandle().GetClass(), g_pExceptionClass))
                {
                    m_sError.dwFlags = (VER_ERR_ITEM_F|VER_ERR_OPCODE_OFFSET);
                    m_sError.sItemFound = pItem->_GetItem();
                    SET_ERR_OPCODE_OFFSET();
                    if (!SetErrorAndContinue(VER_E_THROW))
                        goto exit;
                }
#endif

                // don't fall through to next instruction - dequeue next basic block
                goto dequeueBB;
            }

            case CEE_RETHROW:
            {
                // @VER_ASSERT rethrow allowed only in a catch block
                if (!IsControlFlowLegal(
                            CurBBNumber,
                            pOuterExceptionBlock,
                            pInnerExceptionBlock,
                            VER_NO_BB,
                            NULL,
                            NULL,
                            eVerReThrow,
                            dwPCAtStartOfInstruction))
                    goto exit;

                goto dequeueBB;
            }

            case CEE_ENDFILTER:
            {
                if (GetTopStack() != NULL)
                {
                    m_sError.dwFlags = VER_ERR_OPCODE_OFFSET;
                    SET_ERR_OPCODE_OFFSET();
                    if (!SetErrorAndContinue(VER_E_ENDFILTER_STACK))
                        goto exit;
                }

                // endfilter returns to the EE's SEH mechanism, which in
                // turn transfers control to the handler depending on the value
                // returned on the stack

                if (!IsControlFlowLegal(
                            CurBBNumber,
                            pOuterExceptionBlock,
                            pInnerExceptionBlock,
                            VER_NO_BB,
                            NULL,
                            NULL,
                            eVerEndFilter,
                            dwPCAtStartOfInstruction))
                    goto exit;

                // Propagate current state to the filter handler.

                if (!pInnerExceptionBlock || 
                    !PropagateCurrentStateToFilterHandler(
                        pInnerExceptionBlock->pException->dwHandlerXX))
                    goto exit;

                goto dequeueBB;
            }

            case CEE_ENDFINALLY:
            {
#if 0   // Post V.1
                if (GetTopStack() != NULL)
                {
                    m_sError.dwFlags = VER_ERR_OPCODE_OFFSET;
                    SET_ERR_OPCODE_OFFSET();
                    if (!SetErrorAndContinue(VER_E_ENDFILTER_STACK))
                        goto exit;
                }
#else

                // Clear the stack

                m_StackSlot = 0;
#endif

                // endfinally returns to the EE's SEH mechanism, which in
                // turn transfers control to the next finally.
                //
                // therefore, don't fall through to next instruction - dequeue next basic block.
                // if we're guarded by another finally in the current method,
                // the automatic propagation of state will simulate this "branch"
                // for us.
                //

                if (!IsControlFlowLegal(
                            CurBBNumber,
                            pOuterExceptionBlock,
                            pInnerExceptionBlock,
                            VER_NO_BB,
                            NULL,
                            NULL,
                            eVerEndFinally,
                            dwPCAtStartOfInstruction))
                    goto exit;

                if (fInTryBlock)
                {
                    if (!PropagateCurrentStateToExceptionHandlers(CurBBNumber))
                        goto exit;
                }

                if (fExtendedState)
                {
                    // @ASSERT Finally is the only extended state
                    /*
                     * Control will now go to the leave destinations
                     * OR other finally blocks that need to be visited
                     * before reaching the leave destination.
                     *
                     * Find the nearest parent of the try block of this
                     * finally block, which has a finally block.
                     *
                     * Confused ? See if there are other finally's that
                     * could get controll on leaving this finally.
                     *
                     * Finding the first parent listed will be sufficient since
                     * exceptions are listed inner most first (inner most try).

                       ....
                       ....
                       try 
                       {
                           ....
                           ....
                           try 
                           {
                               ....
                               ....
                               try 
                               {
                                   ....
                                   leave _two_levels // Start
                                   ....
                               } 
                               finally 
                               {
                                   ....
                                   endfinally   // We are here.
                                   ....
                               }

                               ....
                               ....

                               try 
                               {
                                   ....
                                   ....
                               } 
                               finally 
                               {
                                   ....
                                   ....
                               }
                               ....
                               ....
                           } 
                           finally 
                           {
                               // This one is next
                               ....
                               ....
                           }

                           ....
                           _two_levels:
                           ....

                       } 
                       finally 
                       {
                           ....
                           ....
                       }
                       ....
                       ....
                     *
                     */

                    VerExceptionInfo *pE = NULL;
                    BasicBlock       *pBB = NULL;

                    // There could be many BBs in the finally block.
                    // First find the Starting Finally BB that we belong to.
                    // Get the exception & leave destination information.
                    // Exception & leave information is not propagated to all 
                    // basic blocks in this finally block.
                    //
                    // Walking back to BB 0 from here will get us there.
                    //
                    // @VER_ASSERT : Finally blocks cannot nest.
                    // @VER_ASSERT : Finally blocks are disjoint
                    // @VER_ASSERT : endfinally is the only way to leave a
                    //               finally block

                    for (int b=CurBBNumber; b>=0; b--)
                    {
                        if (m_pBasicBlockList[b].m_pException != NULL)
                        {
                            pBB = &m_pBasicBlockList[b];
                            pE  = pBB->m_pException;

                            _ASSERTE(pE->dwHandlerXX == (DWORD)b);
                            _ASSERTE((pE->eFlags & COR_ILEXCEPTION_CLAUSE_FINALLY) != 0);
                            break;
                        }
                    }

                    if (pBB == NULL)
                    {
                        m_sError.dwFlags = VER_ERR_OPCODE_OFFSET;
                        SET_ERR_OPCODE_OFFSET();
                        if (!SetErrorAndContinue(VER_E_BR_OUTOF_FIN))
                            goto exit;
                    }

                    DWORD iParent = 0;
                    VerExceptionInfo *pParent     = NULL;  
                    EntryState_t     *pEntryState = NULL;

                    // Find the first try block that contains us.
                    // If the leave triggers another finally(s),
                    // this should be the first one.
                    // @VER_ASSERT : try blocks must be listed inner
                    //               most first
                    for (DWORD i=0; i<m_NumExceptions; i++)
                    {
                        VerExceptionInfo& e = m_pExceptionList[i];

                        if ((e.eFlags & COR_ILEXCEPTION_CLAUSE_FINALLY) &&
                            (e.dwTryXX    <= pE->dwTryXX) &&
                            (e.dwTryEndXX >= pE->dwTryEndXX))
                        {
                            if (pE == &e)
                                continue; // The same

                            // cache this in the first pass ?
                            pParent = &e;   
                            iParent = i;

                            break;
                        }
                    }

                    _ASSERTE(DestBB != VER_BB_NONE);

                    // leave into the first instruction ?
                    // of a try block. from inside a try block.
                    // Does that trigger a finally ?
                    // This code assumes that it does.

                    if ((pParent != NULL) &&
                        ((DestBB <= pParent->dwTryXX) ||
                         (DestBB >= pParent->dwTryEndXX)))
                    {
                        LOG((LF_VERIFIER, LL_INFO10000,
                        "Creating extended state from (extended) BB 0x%x to 0x%x\n",
                        m_pBasicBlockList[CurBBNumber].m_StartPC,
                        m_pBasicBlockList[DestBB].m_StartPC));

                        if (!CreateFinallyState(iParent, CurBBNumber, 
                            DestBB, &pEntryState))
                        {
                            goto exit;
                        }

                        goto dequeueBB;
                    }

                    LOG((LF_VERIFIER, LL_INFO10000, 
                        "Creating leave state from (extended) BB 0x%x to 0x%x\n", 
                         m_pBasicBlockList[CurBBNumber].m_StartPC,
                         m_pBasicBlockList[DestBB].m_StartPC));

                    if (!CreateLeaveState(DestBB, &pEntryState))
                    {
                        goto exit;
                    }
                }

                goto dequeueBB;
            }
        }

        _ASSERTE(m_StackSlot == PredictedStackSlotAtEndOfInstruction || !fStaticStackCheckPossible);

    }

done:
    return_hr = S_OK;

exit:
    return return_hr;
}


// push a primitive type
BOOL Verifier::PushPrimitive(DWORD Type)
{
    if (m_StackSlot >= m_MaxStackSlots)
        return FALSE;

    m_pStack[m_StackSlot++].SetType(Type);
    return TRUE;
}


BOOL Verifier::Push(const Item *pItem)
{
    if (m_StackSlot >= m_MaxStackSlots)
        return FALSE;

    m_pStack[m_StackSlot++] = *pItem;
    return TRUE;
}

// pop an item from the stack and ensure that it is of the correct type
BOOL Verifier::Pop(DWORD Type)
{
    if (m_StackSlot == 0)
        return FALSE;

    return (m_pStack[--m_StackSlot].GetType() == Type);
}

// pop an item from the stack, return NULL if stack empty
Item *Verifier::PopItem()
{
    if (m_StackSlot == 0)
        return NULL;

    return &m_pStack[--m_StackSlot];
}

// pop an item from the stack, possibly overflowing the stack (however, we have 2 sentinel 
// values before the beginning of the stack)
Item *Verifier::FastPopItem()
{
    return &m_pStack[--m_StackSlot];
}

// check that the entry at the top of the stack is of type Type
BOOL Verifier::CheckTopStack(DWORD Type)
{
    if (m_StackSlot == 0)
        return FALSE;

    return (m_pStack[m_StackSlot - 1].GetType() == Type);
}

// check that the entry at Slot slots from the top, is of type Type
BOOL Verifier::CheckStack(DWORD Slot, DWORD Type)
{
    if (m_StackSlot <= Slot)
        return FALSE;

    return (m_pStack[m_StackSlot - Slot - 1].GetType() == Type);
}

// return the item at the top of the stack, or NULL if an empty stack
Item *Verifier::GetTopStack()
{
    if (m_StackSlot == 0)
        return NULL;

    return &m_pStack[m_StackSlot - 1];
}

// return the item at Slot slots from the top of the stack, or NULL if the stack is not large enough
Item *Verifier::GetStack(DWORD Slot)
{
    if (m_StackSlot <= Slot)
        return NULL;

    return &m_pStack[m_StackSlot - Slot - 1];
}


// remove multiple items from the stack
BOOL Verifier::RemoveItemsFromStack(DWORD NumItems)
{
    if (m_StackSlot < NumItems)
        return FALSE;

    m_StackSlot -= NumItems;
    return TRUE;
}


// Turn a fieldref into a pClass, and get fieldref's signature - return the Module* in which this signature is scoped
HRESULT Verifier::ResolveFieldRef(mdMemberRef mr, FieldDesc **ppFieldDesc, PCCOR_SIGNATURE *ppSig, DWORD *pcSig, Module **ppModule)
{
    HRESULT hr;
    PCCOR_SIGNATURE pSig;
    ULONG cSig;

    if (TypeFromToken(mr) == mdtMemberRef)
    {
        m_pInternalImport->GetNameAndSigOfMemberRef(mr, &pSig, &cSig);
        if (!isCallConv(MetaSig::GetCallingConventionInfo(0, pSig), 
            IMAGE_CEE_CS_CALLCONV_FIELD))
            return VER_E_TOKEN_TYPE_FIELD;
    }
    // Ensure we have a field token or a memberref token
    else if (TypeFromToken(mr) != mdtFieldDef)
        return VER_E_TOKEN_TYPE_FIELD;

    hr = EEClass::GetFieldDescFromMemberRef(m_pModule, mr, ppFieldDesc);

    if (FAILED(hr))
        return VER_E_TOKEN_RESOLVE;

    *ppModule = (*ppFieldDesc)->GetModule();
    (*ppFieldDesc)->GetSig(ppSig, pcSig);

    return S_OK;
}


//
// Set this item as initialised.  If this was a byref local/field, then set the
// appropriate linked items as initialised.  If this is an uninitialised "this" pointer
// then propagate the appropriate information.
//
void Verifier::PropagateIsInitialised(Item *pItem)
{
    pItem->SetInitialised();

    if (pItem->IsByRef())
    {
        if (pItem->HasByRefLocalInfo())
        {
            // If the current value of the local isn't dead, or a type that can't be 
            // initialised (e.g. an arrayref), then set that it is initialised
            DWORD dwLocVar = pItem->GetByRefLocalInfo();

            InitialiseLocalViaByRef(dwLocVar, pItem);
        }
        else if (pItem->HasByRefFieldInfo() && m_fThisUninit)
        {
            // The only way we can have byref field info is if it's one of our own
            // instance fields

            // We had the address of one of our class's value class fields on the stack.
            // If we're a value class constructor, we have to track this.
            if (m_fInValueClassConstructor)
            {
                SetValueClassFieldInited(pItem->GetByRefFieldInfo());

                if (AreAllValueClassFieldsInited())
                    PropagateThisPtrInit();
            }
        }
    }

    if (m_fThisUninit && pItem->IsThisPtr())
        PropagateThisPtrInit();
}



//
// We had a byref to a local variable somewhere (e.g. on the stack), and we are initialising that
// stack entry.  Now set the local to be initialised.
//
// If the local has only live-dead information, set the live bit.
// If the local has fully tracked type information, fill out that information.
//
// It is assumed by this function that pItem is a valid type to store into the local.
//
void Verifier::InitialiseLocalViaByRef(DWORD dwLocVar, Item *pItem)
{
    long slot = GetGlobalLocVarTypeInfo(dwLocVar)->m_Slot;
    if (LIVEDEAD_TRACKING_ONLY_FOR_SLOT(slot))
    {
        SetLocVarLiveSlot(LIVEDEAD_NEGATIVE_SLOT_TO_BITNUM(slot));
    }
    else
    {
        // Set the current type of the local to that of the globally declared type, rather than
        // simply setting the current type to initialised.
        // When we support byref objrefs, this may have to change -but maybe not.
        m_pNonPrimitiveLocArgs[slot] = GetGlobalLocVarTypeInfo(dwLocVar)->m_Item;
    }
}


//
// Returns S_OK for success, E_FAIL for general verification failures,
//
// dwOpcode can be CALL, CALLVIRT, NEWOBJ or CALLI
//
HRESULT Verifier::VerifyMethodCall(DWORD dwPCAtStartOfInstruction, 
                                   mdMemberRef mrMemberRef,
                                   OPCODE opcode,
                                   BOOL   fTailCall,
                                   OBJECTREF *pThrowable)
{
    long        ArgNum;
    DWORD       NumArgs;
    MethodDesc *pMethodDesc = NULL;
    PCCOR_SIGNATURE pSignature; // The signature of the found method
    DWORD       cSignature;
    Item        ArgItem;        // For parsing arguments
    Item        ReturnValueItem;
    DWORD       dwMethodAttrs;  // Method attributes
    bool        fDelegateCtor=false;// for calls to delegate .ctor
    bool        fVarArg=false;  // Is the called function of VarArg type
    bool        fGlobal=false;  // Global function?
    bool        fArray=false;   // Is the called function an array method
    EEClass     *pInstanceClass;// For checking public / private / family access
    EEClass     *pClassOfMethod;// Class of the called method
    EEClass     *pParentClass;  // Parent class of the called method

    HRESULT     hr;

#if 0
    if (opcode == CEE_CALLI)
    {
        Item  *pMethodItem;   // MethodDesc on the stack

        // Ensure we have a signature token.
        if (TypeFromToken(mrMemberRef) != mdtSignature)
        {
            FAILMSG_TOKEN(mrMemberRef, VER_E_TOKEN_TYPE_SIG);
            return E_FAIL;
        }
    
        pMethodItem = PopItem();

        if (pMethodItem == NULL)
        {
            FAILMSG_PC_STACK_UNDERFLOW();
            return E_FAIL;
        }

        if (!pMethodItem->IsMethod())
        {
            m_sError.dwFlags = (VER_ERR_FATAL|VER_ERR_ITEM_F|VER_ERR_OPCODE_OFFSET);
            m_sError.sItemFound = pMethodItem->_GetItem();
            SET_ERR_OPCODE_OFFSET();
            SetErrorAndContinue(VER_E_STACK_METHOD);
            return E_FAIL;
        }

        pMethodDesc = pMethodItem->GetMethod();

        // Calli can be used only on static functions safely.
        // Allowing calli on virtual functions can break typesafety.
        // Eg. ldftn can be done on a virtual base class function, (with an 
        // overriding implementation in the derived class) and the
        // instance passed as arg 0 can be of type base class.

        if (pMethodDesc->IsVirtual())
        {
            m_sError.dwFlags = (VER_ERR_ITEM_F|VER_ERR_OPCODE_OFFSET);
            m_sError.sItemFound = pMethodItem->_GetItem();
            SET_ERR_OPCODE_OFFSET();
            if (!SetErrorAndContinue(VER_E_CALLI_VIRTUAL))
                return E_FAIL;
        }

    }
    else
#endif
    {
        // Ensure we have a method token or a memberref token
        if (TypeFromToken(mrMemberRef) != mdtMemberRef && TypeFromToken(mrMemberRef) != mdtMethodDef)
        {
            FAILMSG_TOKEN(mrMemberRef, VER_E_TOKEN_TYPE_MEMBER);
            return E_FAIL;
        }
    
        // Note, we might resolve and have a global function
        hr = EEClass::GetMethodDescFromMemberRef(m_pModule, mrMemberRef, 
            &pMethodDesc, pThrowable);

        if (FAILED(hr) || pMethodDesc == NULL)
        {
            FAILMSG_TOKEN_RESOLVE(mrMemberRef);
            return E_FAIL;
        }
    }

    _ASSERTE(pMethodDesc);

    pClassOfMethod = pMethodDesc->GetClass();

    _ASSERTE(pClassOfMethod);

    pParentClass = pClassOfMethod->GetParentClass();

    // Get attributes of method/function we're calling
    dwMethodAttrs = pMethodDesc->GetAttrs();

    if (pMethodDesc->IsVarArg())
        fVarArg = true;

    if (pClassOfMethod->GetCl() == COR_GLOBAL_PARENT_TOKEN)
        fGlobal = true;

    if (pClassOfMethod->IsArrayClass())
        fArray = true;

    if (IsMdRTSpecialName(dwMethodAttrs) &&
        pParentClass != NULL &&
        pParentClass->IsAnyDelegateExact())
        fDelegateCtor = true;

    if (TypeFromToken(mrMemberRef) == mdtMemberRef)
    {
        m_pInternalImport->
            GetNameAndSigOfMemberRef(mrMemberRef,  &pSignature, &cSignature);
    }
    else if (TypeFromToken(mrMemberRef) == mdtMethodDef)
    {
        pSignature = m_pInternalImport->
            GetSigOfMethodDef(mrMemberRef, &cSignature);
    }
    else
    {
        _ASSERTE(TypeFromToken(mrMemberRef) == mdtSignature);
        pSignature = m_pInternalImport->
            GetSigFromToken((mdSignature)mrMemberRef, &cSignature);
    }
    
    if (pSignature == NULL)
    {
        FAILMSG_TOKEN_RESOLVE(mrMemberRef);
        return E_FAIL;
    }

    // verify Array Sigs. ?
    if (!fArray)
    {
        PCCOR_SIGNATURE  pSigItem;  // Actual sig of MethodDescs
        DWORD            cSigItem;
    
        pMethodDesc->GetSig(&pSigItem, &cSigItem);
        
        // Verify that the actual sig of the method is compatible with the
        // declared one.
        if (!MetaSig::CompareMethodSigs(pSignature, cSignature, m_pModule, 
            pSigItem, cSigItem, pMethodDesc->GetModule()))
        {
            m_sError.dwFlags = VER_ERR_OPCODE_OFFSET;
            SET_ERR_OPCODE_OFFSET();
            if (!SetErrorAndContinue(VER_E_CALL_SIG))
                return E_FAIL;
        }
    }

#ifdef _DEBUG
    {
        CHAR* pDbgClassName = "<global>";

        if (fArray)
            pDbgClassName = "<Array>";
        else
            pDbgClassName = pMethodDesc->m_pszDebugClassName;

        LOG((LF_VERIFIER, LL_INFO10000, "%s::%s\n", pDbgClassName, pMethodDesc->GetName()));
    }
#endif


    switch (opcode)
    {
    case CEE_CALLVIRT:
        if (pClassOfMethod->IsValueClass())
        {
            m_sError.dwFlags = VER_ERR_OPCODE_OFFSET;
            SET_ERR_OPCODE_OFFSET();
            if (!SetErrorAndContinue(VER_E_CALLVIRT_VALCLASS))
                return E_FAIL;
        }

        if (pMethodDesc->IsStatic())
        {
            m_sError.dwFlags = VER_ERR_OPCODE_OFFSET;
            SET_ERR_OPCODE_OFFSET();
            if (!SetErrorAndContinue(VER_E_CALLVIRT_STATIC))
                return E_FAIL;
        }

        break;

    case CEE_NEWOBJ: 
        // If we're doing NEWOBJ, it has to be on an instance constructor
        if (!IsMdRTSpecialName(dwMethodAttrs) && 
            (strcmp(pMethodDesc->GetName(), COR_CTOR_METHOD_NAME) != 0))
        {
            m_sError.dwFlags = VER_ERR_FATAL|VER_ERR_OPCODE_OFFSET;
            SET_ERR_OPCODE_OFFSET();
            SetErrorAndContinue(VER_E_CTOR);
            return E_FAIL;
        }

        if (IsMdStatic(dwMethodAttrs))
        {
            m_sError.dwFlags = VER_ERR_OPCODE_OFFSET;
            SET_ERR_OPCODE_OFFSET();
            if (!SetErrorAndContinue(VER_E_CTOR))
                return E_FAIL;
        }

        if (IsMdAbstract(dwMethodAttrs))
        {
            m_sError.dwFlags = VER_ERR_OPCODE_OFFSET;
            SET_ERR_OPCODE_OFFSET();
            if (!SetErrorAndContinue(VER_E_CTOR))
                return E_FAIL;
        }

        // no break here on purpose.

    default:

        _ASSERTE(opcode != CEE_CALLVIRT);

        if (pMethodDesc->IsAbstract())
        {
            m_sError.dwFlags = VER_ERR_OPCODE_OFFSET;
            SET_ERR_OPCODE_OFFSET();
            if (!SetErrorAndContinue(VER_E_CALL_ABSTRACT))
                return E_FAIL;
        }

        break;
    }

    if (fGlobal)
    {
        // We're calling a function desc (i.e. a global function)
        if (!IsMdStatic(dwMethodAttrs))
        {
            m_sError.dwFlags = VER_ERR_OPCODE_OFFSET;
            SET_ERR_OPCODE_OFFSET();
            if (!SetErrorAndContinue(VER_E_CALL_STATIC))
                return E_FAIL;
        }
    }

    // Check arguments of method against what we have on the stack
    VerSig sig(this, m_pModule, pSignature, cSignature,
                    (VERSIG_TYPE_CALL_SIG|VER_ERR_OFFSET), 
                    dwPCAtStartOfInstruction);

    if (!sig.Init())
    {
        return E_FAIL;
    }

    NumArgs = sig.GetNumArgs();

    // Parse return type
#if 0
    // If this is an array class, and we're doing LoadElementAddress(), we return a "&valueclass".
    // We have to special case this, since there is no metadata token in the signature.
    if (fArray)
    {

        // Array class
        if (!strcmp( ((ArrayECallMethodDesc*) pMethodDesc)->m_pszArrayClassMethodName, "Address"))
        {
            // It's LoadElementAddress!
            // Manufacture the return type
            if (!ReturnValueItem.SetArray(mrMemberRef, m_pModule, m_pInternalImport))
                return E_FAIL;

            // Memberref said Foo[], Foo[][], Foo[,] etc.
            // We want it to now say &Foo, &Foo[], or &Foo respectively

            // We want to take the element type of the array, and make a &ElementType

            // The way we're doing it here is to take the array name (e.g. Foo[,,](,)), and
            // dereference off the first set of brackets --> Foo(,)
            if (!ReturnValueItem.DereferenceArray())
                return E_FAIL;

            ReturnValueItem.MakeByRef();
            ReturnValueItem.SetIsPermanentHomeByRef();

            if (!sig.SkipNextItem())
                return E_FAIL;
        }
        else if (!strcmp( ((ArrayECallMethodDesc*) pMethodDesc)->m_pszArrayClassMethodName, "Get"))
        {
            // Manufacture the return type
            if (!ReturnValueItem.SetArray(mrMemberRef, m_pModule, m_pInternalImport))
                return E_FAIL;

            // The way we're doing it here is to take the array name (e.g. Foo[,,](,)), and
            // dereference off the first set of brackets --> Foo(,)
            if (!ReturnValueItem.DereferenceArray())
                return E_FAIL;


            if (!sig.SkipNextItem())
                return E_FAIL;
        }
        else
        {
            // Regular code path
            if (!sig.ParseNextComponentToItem(&ReturnValueItem, TRUE, FALSE, &m_hThrowable, VER_ARG_RET, TRUE))
            {
                return E_FAIL;
            }
        }

    }
    else
#endif
    {
        // Not an array class
        if (!sig.ParseNextComponentToItem(&ReturnValueItem, TRUE, FALSE, &m_hThrowable, VER_ARG_RET, TRUE))
        {
            return E_FAIL;
        }
    }


    // Methods can only return byrefs with permanent homes.
    if (ReturnValueItem.IsByRef())
    {
        ReturnValueItem.SetIsPermanentHomeByRef();
    }


    // Return type of tail calls should be compatible with that of
    // of this method.
    if (fTailCall)
    {
        if (m_ReturnValue.IsGivenPrimitiveType(ELEMENT_TYPE_VOID))
        {
            if (!ReturnValueItem.IsGivenPrimitiveType(ELEMENT_TYPE_VOID))
            {
                m_sError.dwFlags = VER_ERR_OPCODE_OFFSET;
                SET_ERR_OPCODE_OFFSET();
                if (!SetErrorAndContinue(VER_E_TAIL_RET_VOID))
                    return E_FAIL;
            }
        }
        else
        {
            Item Desired = m_ReturnValue;

            Desired.NormaliseForStack();

            if (!ReturnValueItem.CompatibleWith(&Desired, m_pClassLoader))
            {
                m_sError.dwFlags = (VER_ERR_ITEM_F|VER_ERR_ITEM_E|VER_ERR_OPCODE_OFFSET);
                m_sError.sItemFound = ReturnValueItem._GetItem();
                m_sError.sItemExpected = m_ReturnValue._GetItem();
                SET_ERR_OPCODE_OFFSET();
                if (!SetErrorAndContinue(VER_E_TAIL_RET_TYPE))
                    return E_FAIL;
            }
        }
    }

    ArgNum = NumArgs;

    while (ArgNum > 0)
    {
        Item *  pStackItem;

        ArgNum--;

        if (!sig.ParseNextComponentToItem(&ArgItem, FALSE, fVarArg, &m_hThrowable, ArgNum, 
            /* Don't normalize for first argument 0 of delegate ctor */ 
            (!fDelegateCtor || (ArgNum != 0))))
        {
            return E_FAIL;
        }

        pStackItem = GetStack(ArgNum);

        if (pStackItem == NULL)
        {
            FAILMSG_STACK_EMPTY();
            return E_FAIL;
        }

        // We allow the address of some uninitialised value classes/primitive types to be passed as parameters
        // to methods.  They are assumed to be out parameters.  As long as the value classes didn't contain
        // any pointers, there's no verification hole.
        if (pStackItem->IsUninitialised())
        {
            // Are we a byref value class with no dangerous fields?
            if (pStackItem->IsByRefValueClass())
            {
                EEClass *pClass;
                pClass = pStackItem->GetTypeHandle().GetClass();
                _ASSERTE(pClass != NULL);

                if (pClass->HasFieldsWhichMustBeInited())
                {
error_uninit:
                    m_sError.dwFlags = VER_ERR_OPCODE_OFFSET;
                    SET_ERR_OPCODE_OFFSET();
                    if (!SetErrorAndContinue(VER_E_STACK_UNINIT))
                        return E_FAIL;
                }
            }
            else if (!pStackItem->IsNormalisedByRefPrimitiveType())
            {
                goto error_uninit;
            }

            // What if the callee does nothing, just returns ?
            // Set that this stack item is inited, but more importantly, if this was the address
            // of a local or field, init it
            PropagateIsInitialised(pStackItem);
        }

        if (fDelegateCtor)
        {
            // To patch a type hole in the managed delegate .ctor
            // The last param is a function pointer
            if (ArgNum == 0)
            {
                if (ArgItem.GetType() != ELEMENT_TYPE_I)
                {
                    // This makes sure that delegate .ctor is what the runtime expects.
                    m_sError.dwFlags = (VER_ERR_ITEM_F|VER_ERR_OPCODE_OFFSET);
                    m_sError.sItemFound = ArgItem._GetItem();
                    SET_ERR_OPCODE_OFFSET();
                    if (!SetErrorAndContinue(VER_E_DLGT_SIG_I))
                        return E_FAIL;
                }

                if (!pStackItem->IsMethod())
                {
                    // This makes sure that bad ints are not passed into
                    // the delegate constructor
                    m_sError.dwFlags = (VER_ERR_FATAL|
                        VER_ERR_ITEM_F|VER_ERR_OPCODE_OFFSET);
                    m_sError.sItemFound = pStackItem->_GetItem();
                    SET_ERR_OPCODE_OFFSET();
                    SetErrorAndContinue(VER_E_STACK_METHOD);
                    return E_FAIL;
                }

                // Don't do the type compatibility check in this case
                goto skip_compat_check;
            }
            else if (!ArgItem.IsObjRef())
            {
                // This makes sure that delegate .ctor is what the runtime expects.
                m_sError.dwFlags = (VER_ERR_ITEM_F|VER_ERR_OPCODE_OFFSET);
                m_sError.sItemFound = ArgItem._GetItem();
                SET_ERR_OPCODE_OFFSET();
                if (!SetErrorAndContinue(VER_E_DLGT_SIG_O))
                    return E_FAIL;
            }
        }

        if (!pStackItem->CompatibleWith(&ArgItem, m_pClassLoader))
        {
            m_sError.dwFlags = 
                (VER_ERR_ITEM_F|VER_ERR_ITEM_E|VER_ERR_OPCODE_OFFSET);
            m_sError.sItemFound = pStackItem->_GetItem();
            m_sError.sItemExpected = ArgItem._GetItem();
            SET_ERR_OPCODE_OFFSET();
            if (!SetErrorAndContinue(VER_E_STACK_UNEXPECTED))
                return E_FAIL;
        }
skip_compat_check:

        if (fTailCall)
        {
            // cannot allow passing byrefs to tailcall.
            // We could relax this a bit.
            if (pStackItem->HasPointerToStack())
            {
                m_sError.dwFlags = VER_ERR_OPCODE_OFFSET;
                SET_ERR_OPCODE_OFFSET();
                if (!SetErrorAndContinue(VER_E_TAIL_BYREF))
                    return E_FAIL;
            }
        }
    }

    //
    // Verify delegate .ctor
    //

    if (fDelegateCtor)
    {
        EEClass    *pDlgtInstancePtr; // Instance pointer for delegate .ctor
        MethodDesc *pFtn = 0;         // Function pointer used in delegate .ctor


        // If we are calling a delegate .ctors, we will have 2 args
        if (NumArgs != 2)
            goto DlgtCtorError;

        Item * pInstance = GetStack(1);   // Get the instance pointer

        if (pInstance->IsNullObjRef())
            pDlgtInstancePtr = NULL;
        else if (pInstance->ContainsTypeHandle())
            pDlgtInstancePtr = pInstance->GetTypeHandle().GetClass();
        else
            goto DlgtCtorError;

        Item * pStackItem = GetStack(0);   // Get the method pointer

        pFtn = pStackItem->GetMethod();

        _ASSERTE(pFtn != NULL);

        if (!COMDelegate::ValidateCtor(pFtn, pClassOfMethod, pDlgtInstancePtr))
        {
DlgtCtorError:
            // This makes sure that bad ints are not passed into
            // the delegate constructor
            m_sError.dwFlags = VER_ERR_OPCODE_OFFSET|VER_ERR_FATAL;
            SET_ERR_OPCODE_OFFSET();
            SetErrorAndContinue(VER_E_DLGT_CTOR);
            return E_FAIL;
        }

        if (!ClassLoader::CanAccess(
                m_pMethodDesc->GetClass(),
                m_pClassLoader->GetAssembly(),
                pFtn->GetClass(),
                pFtn->GetModule()->GetAssembly(),
                (pFtn->IsStatic() || pInstance->IsNullObjRef()) ? m_pMethodDesc->GetClass()
                                                                : pInstance->GetTypeHandle().GetClass(),
                pFtn->GetAttrs()))
        {
            m_sError.dwFlags = VER_ERR_OPCODE_OFFSET;
            SET_ERR_OPCODE_OFFSET();
            if (!SetErrorAndContinue(VER_E_METHOD_ACCESS))
                return E_FAIL;
        }

#ifdef _VER_DLGT_CTOR_OPCODE_SEQUENCE 

        // For virtual methods, the instance from which the function pointer
        // was obtained should be the same as the one passed into the delegate
        // .ctor. If the function pointer represents a virtual method and the 
        // function pointer was obtained by  a ldvirtftn instruction, the 
        // following code sequence should be enforced. 
        // Start with an object on stack, 
        // dup, ldvirtftn, call dlgt::.ctor()
        // 
        // Why is this a problem ?
        //
        // A Delegate instance stores an a function pointer and an instance that
        // goes with the function pointer. The Invoke method of a delegate will 
        // mimic a call to the method represented by the function pointer. When 
        // the Invoke method is called on the delegate object, it pushes the 
        // internal instance it has and then calls into the function pointer. 
        // The delegate Invoke method signature will be compatible with the 
        // function pointer, hence the normal call verification rules will 
        // be sufficient at delegate Invoke time.
        //
        // Consider this: A is a base type, B extends A, D is a Delegate.
        //      a() is a virtual method implemented in A and B 
        //
        //  class A 
        //  {
        //      int i;
        //      virtual void a() { i = 1; }
        //  }
        //
        //  class B : extends A
        //  {
        //      int j;
        //      virtual void a() { j = 1; }
        //  }
        //
        //  class D : extends System.Delegate [runtime implemented type]
        //  {
        //      void .ctor(Object, ftn)     [runtime implemented method]
        //      virtual void Invoke()       [runtime implemented method]
        //  }
        //
        //  void Foo(A a1, A a2) 
        //  {
        //      ldarg a1
        //      ldarg a2
        //      ldvirtftn void A::a()
        //      newobj void D::.ctor(Object, ftn)
        //      call D::Invoke()
        //  }
        //
        //  void Bar()
        //  {
        //      newobj void A::.ctor()
        //      newobj void A::.ctor()
        //      call void Foo(A, A)     /* No problem here */
        //
        //      newobj void A::.ctor()
        //      newobj void B::.ctor()
        //      call void Foo(A, A)     
        //
        //      /* Error ! instance is A, and ftn is B::a() ! */
        //      /* B::a() will corrupt the GC heap, when it writes to j */
        //
        //  }
        //
        // Verification Rule :
        // 
        // 1. Allow non virtual functions to pass
        //      ldvirtftn on a non virtual method is allowed
        // 
        // 2. call dlgt::.ctor should not be the first instruction in this BB
        //      No branch into the call instruction
        // 
        // 3. The previous instruction should be a ldftn or ldvirtftn
        //      No padding with other instrucitons like nop, (ldc.i4.0, pop) etc
        // 
        // 4. Allow ldftn to pass
        //      ldftn on a virtual function will get the function specified
        // 
        // 5. ldvirtftn should be preceeded by a dup instruction
        //      the same instance is used to obtain the funtion pointer and
        //      used in the delegate .ctor
        // 
        // 6. dup, ldvirtftn, call should all be in the same BB
        //      no branch into the middle of this sequence
        //

        if (pFtn->IsVirtual())
        {
            OPCODE  op;             // previous opcodes
            DWORD   dwOpcodeLen;
            DWORD   ipos;           // instruction pointer for backtracking

            // Make sure that the there is no branch into the call instruction
            if (ON_BB_BOUNDARY(dwPCAtStartOfInstruction))
            {
                m_sError.dwFlags = VER_ERR_OPCODE_OFFSET;
                SET_ERR_OPCODE_OFFSET();
                if (!SetErrorAndContinue(VER_E_DLGT_BB))
                    return E_FAIL;
            }

            // The previous opcode should be a ldftn or ldvirtftn instruciton
            // decode the previous opcode

            _ASSERTE(SIZEOF_LDFTN_INSTRUCTION == SIZEOF_LDVIRTFTN_INSTRUCTION);

            ipos = (dwPCAtStartOfInstruction - 
                    (SIZEOF_LDFTN_INSTRUCTION + SIZEOF_METHOD_TOKEN));

            // Make sure that this is where an instruction starts
            if ((dwPCAtStartOfInstruction < 
                (SIZEOF_LDFTN_INSTRUCTION + SIZEOF_METHOD_TOKEN)) ||
                !ON_INSTR_BOUNDARY(ipos))
            {
                goto missing_ldftn;
            }

            op = DecodeOpcode(&m_pCode[ipos], &dwOpcodeLen);

            if (op == CEE_LDVIRTFTN)
            {
                // make sure that the there is no branch into the ldvirtftn
                if (ON_BB_BOUNDARY(ipos))
                {
                    goto missing_dup;
                }

                // check if the previous instruction was dup
                ipos -= SIZEOF_DUP_INSTRUCTION;

                if ((dwPCAtStartOfInstruction <
                        (SIZEOF_LDFTN_INSTRUCTION + SIZEOF_METHOD_TOKEN +
                        SIZEOF_DUP_INSTRUCTION)) ||
                    !ON_INSTR_BOUNDARY(ipos))
                {
                    goto missing_dup;
                }

                op = DecodeOpcode(&m_pCode[ipos], &dwOpcodeLen);
    
                if (op != CEE_DUP)
                {
missing_dup:
                    m_sError.dwFlags = VER_ERR_OPCODE_OFFSET;
                    SET_ERR_OPCODE_OFFSET();
                    if (!SetErrorAndContinue(VER_E_DLGT_PATTERN))
                        return E_FAIL;
                }
            }
            else if (op != CEE_LDFTN)
            {
missing_ldftn:
                m_sError.dwFlags = VER_ERR_OPCODE_OFFSET;
                SET_ERR_OPCODE_OFFSET();
                if (!SetErrorAndContinue(VER_E_DLGT_LDFTN))
                    return E_FAIL;
            }
        }
#endif
    }

    // Pop all the arguments from stack
    if (!RemoveItemsFromStack(NumArgs))
    {
        FAILMSG_STACK_EMPTY();
        return E_FAIL;
    }

    // Now handle the "this" pointer
    // This code is a little tricky, it'd be nice to simplify it
    if (!IsMdStatic(dwMethodAttrs))
    {
        // If an instance method...
        Item    *pThisPtrItem;

        TypeHandle typeOfMethodWeAreCalling;
        if (fArray)
        {
            mdTypeRef  tk;

            if (FAILED(m_pInternalImport->GetParentToken(mrMemberRef, &tk)))
            {
                FAILMSG_TOKEN_RESOLVE(mrMemberRef);
                return E_FAIL;
            }

            NameHandle name(m_pModule, tk);
            typeOfMethodWeAreCalling = m_pClassLoader->LoadTypeHandle(&name);

            if (typeOfMethodWeAreCalling.IsNull())
            {
                FAILMSG_TOKEN_RESOLVE(tk);
                return E_FAIL;
            }
        }
        else
        {
            typeOfMethodWeAreCalling = TypeHandle(pMethodDesc->GetMethodTable());
        }

        // Note: pThisPtrItem could be anything at all; an I4, a &R4, a &Variant, an objref, an array
        // Don't make any assumptions about its contents!
        pThisPtrItem = GetTopStack();
        if ((pThisPtrItem == NULL) && (opcode != CEE_NEWOBJ))
        {
            m_sError.dwFlags = VER_ERR_OPCODE_OFFSET;
            SET_ERR_OPCODE_OFFSET();
            SetErrorAndContinue(VER_E_THIS);
            return E_FAIL;
        }

        if (opcode != CEE_NEWOBJ)
        {
            (void) PopItem();
            if (pThisPtrItem->ContainsTypeHandle())
                pInstanceClass = pThisPtrItem->GetTypeHandle().GetClass();
            else
                pInstanceClass = m_pMethodDesc->GetClass();

            if (fTailCall)
            {
                // cannot allow passing byrefs to tailcall.
                // We could relax this a bit.
                if (pThisPtrItem->HasPointerToStack())
                {
                    m_sError.dwFlags = VER_ERR_OPCODE_OFFSET;
                    SET_ERR_OPCODE_OFFSET();
                    if (!SetErrorAndContinue(VER_E_TAIL_BYREF))
                        return E_FAIL;
                }
            }
        }
        else
        {
            pInstanceClass = pClassOfMethod;
        }

        if (IsMdRTSpecialName(dwMethodAttrs)
            || !strcmp(pMethodDesc->GetName(), COR_CTOR_METHOD_NAME))
        {
            // We're calling an instance constructor
            if (opcode != CEE_NEWOBJ)
            {
                Item RefItem;


                // We're calling a constructor method, so check that we are using CALL, not CALLVIRT
                if (opcode != CEE_CALL)
                {
                    m_sError.dwFlags = VER_ERR_OPCODE_OFFSET;
                    SET_ERR_OPCODE_OFFSET();
                    if (!SetErrorAndContinue(VER_E_CTOR_VIRT))
                        return E_FAIL;
                }

                // M = The method we're verifying
                // S = The type of the objref/byref value class on the stack

                // We're calling a constructor method using a CALL instruction, which can happen only
                // in one of two situations:
                //
                // 1) We are constructing our 'this' pointer.
                //    S is an objref or byref value class of type M, M is a constructor, and we are calling 
                //    M.super or an alternate M.init.  Furthermore, S contains the 'this' pointer
                //    (in the value class case, an uninitialised S may not correspond to our 'this' pointer,
                //    it could be a static field, or local).
                //
                // 2) S is a byref value class of any type.
                //    S could be an instance field of the current class, a local, a static field, etc.
                //
                //    In the case where S is an instance field of class type M, and M is a value class 
                //    constructor, we have to track which field was inited.

                // Whichever case this is, first make sure S is compatible with the method we are calling
                RefItem.SetTypeHandle(typeOfMethodWeAreCalling);
                if (RefItem.IsValueClassOrPrimitive())
                    RefItem.MakeByRef();

                // In either case, first make sure S is generally compatible with the method we are calling.  
                // For now, don't require an exact match (subclass relationship is ok).
                
                // CompatibleWith() fails if the initialisation status is not the same.  Trash the
                // init status.

                // where are we restoring it ?
                pThisPtrItem->SetInitialised();

                if (!pThisPtrItem->CompatibleWith(&RefItem, m_pClassLoader, TRUE))
                {
                    m_sError.dwFlags = 
                        (VER_ERR_ITEM_F|VER_ERR_ITEM_E|VER_ERR_OPCODE_OFFSET);
                    m_sError.sItemFound = pThisPtrItem->_GetItem();
                    m_sError.sItemExpected = RefItem._GetItem();
                    SET_ERR_OPCODE_OFFSET();
                    if (!SetErrorAndContinue(VER_E_STACK_UNEXPECTED))
                        return E_FAIL;
                }

                // Determine whether we are case #1 or case #2
                if (m_fInConstructorMethod && pThisPtrItem->IsThisPtr())
                {
                    // Case 1
                    EEClass *pThisClass = m_pMethodDesc->GetClass();

                    // Make sure we are calling M.init or M.super
                    if (pClassOfMethod != pThisClass)
                    {
                        if (pClassOfMethod != pThisClass->GetParentClass())
                        {
                            // Internal ComWrapper class System.__ComObject is 
                            // inserted  by the runtime for COM classes.
                            // It is OK not to call System.__ComObject::.ctor()

                            if ((pClassOfMethod != g_pObjectClass->GetClass()) ||
                                (!pThisClass->GetMethodTable()->IsComObjectType()))
                            {
                                m_sError.dwFlags = VER_ERR_OPCODE_OFFSET;
                                SET_ERR_OPCODE_OFFSET();
                                if (!SetErrorAndContinue(VER_E_CTOR_OR_SUPER))
                                    return E_FAIL;
                            }
                        }
                    }
                    
#ifdef _VER_DISALLOW_MULTIPLE_INITS 
                    // It is Ok to call base class .ctor more than once.

                    // If an objref, make sure that the globally known state of the 'this' pointer
                    // was uninitialised - it is illegal to construct 'this' twice.  Should be ok
                    // to look at pThisPtrItem->IsInitialised() [but we already trashed that]
                    if (pThisPtrItem->IsObjRef())
                    {
                        if (!m_fThisUninit)
                        {
                            m_sError.dwFlags = VER_ERR_OPCODE_OFFSET;
                            SET_ERR_OPCODE_OFFSET();
                            if (!SetErrorAndContinue(VER_E_CTOR_MUL_INIT))
                                return E_FAIL;
                        }
                    }
#endif // _VER_DISALLOW_MULTIPLE_INITS 

                    PropagateThisPtrInit();

                }
                else
                {
                    // Otherwise we're case #2, which means we must be initing a value class (e.g.
                    // one of our value class locals).
                    if (!pThisPtrItem->IsByRefValueClass())
                    {
                        if (pThisPtrItem->IsByRefPrimitiveType())
                        {
                            if (!CanCast((CorElementType)pThisPtrItem->GetTypeOfByRef(),
                                typeOfMethodWeAreCalling.GetNormCorElementType()))
                            {
                                goto error_bad_type;
                            }
                        }                        
                        else
                        {
                            m_sError.dwFlags = VER_ERR_OPCODE_OFFSET;
                            SET_ERR_OPCODE_OFFSET();
                            if (!SetErrorAndContinue(VER_E_CALL_CTOR))
                                return E_FAIL;
                        }

                    }

                    // Make sure S matches the method we are calling exactly
                    else if (typeOfMethodWeAreCalling != pThisPtrItem->GetTypeHandle())
                    {
error_bad_type:
                        m_sError.dwFlags = (VER_ERR_ITEM_F|VER_ERR_ITEM_E|
                                VER_ERR_OPCODE_OFFSET);
                        m_sError.sItemFound = pThisPtrItem->_GetItem();
                        m_sError.sItemExpected = RefItem._GetItem();
                        SET_ERR_OPCODE_OFFSET();
                        if (!SetErrorAndContinue(VER_E_STACK_UNEXPECTED))
                            return E_FAIL;
                    }

                    // If the stack item is also byref to a local, initialise the local
                    if (pThisPtrItem->HasByRefLocalInfo())
                    {
                        DWORD dwLocVar = pThisPtrItem->GetByRefLocalInfo();

                        InitialiseLocalViaByRef(dwLocVar, pThisPtrItem);
                    }
                    else if (pThisPtrItem->HasByRefFieldInfo() && m_fThisUninit)
                    {
                        // We had the address of one of our class's value class fields on the stack.
                        // If we're a value class constructor, we have to track this.
                        if (m_fInValueClassConstructor)
                        {
                            SetValueClassFieldInited(pThisPtrItem->GetByRefFieldInfo());

                            if (AreAllValueClassFieldsInited())
                                PropagateThisPtrInit();
                        }
                    }
                }
            } /* end ... if (a CALL instruction) */
        }
        else /* not calling a constructor */
        {
            // We know we didn't get here via a NEWOBJ opcode
            _ASSERTE(opcode != CEE_NEWOBJ);

            // Make sure this pointer is compatible with method we're calling
            Item RefItem;

            if (fArray)
            {
                if (!RefItem.SetArray(mrMemberRef, m_pModule, m_pInternalImport))
                {
                    FAILMSG_TOKEN_RESOLVE(mrMemberRef);
                    return E_FAIL;
                }
            }
            else
            {
                RefItem.SetTypeHandle(typeOfMethodWeAreCalling);
                if (RefItem.IsValueClassOrPrimitive())
                {
                    // Make RefItem into a &valueclass.  For example, if we are calling
                    // Variant.<init>(), make RefItem a "&Variant" 
                    RefItem.MakeByRef();
                }
            }

            if (!pThisPtrItem->CompatibleWith(&RefItem, m_pClassLoader))
            {
                m_sError.dwFlags = 
                    (VER_ERR_ITEM_F|VER_ERR_ITEM_E|VER_ERR_OPCODE_OFFSET);
                m_sError.sItemFound = pThisPtrItem->_GetItem();
                m_sError.sItemExpected = RefItem._GetItem();
                SET_ERR_OPCODE_OFFSET();
                if (!SetErrorAndContinue(VER_E_STACK_UNEXPECTED))
                    return E_FAIL;
            }

        }

    } /* end ... if (not calling a static method) */
    else
    {
        pInstanceClass = m_pMethodDesc->GetClass();
    }

    // Verify access
    if (!ClassLoader::CanAccess(
            m_pMethodDesc->GetClass(),
            m_pClassLoader->GetAssembly(), 
            pClassOfMethod,
            pMethodDesc->GetModule()->GetAssembly(),
            pInstanceClass,
            pMethodDesc->GetAttrs()))
    {
        Item methodItem;
        methodItem.SetMethodDesc(pMethodDesc);

        m_sError.dwFlags = VER_ERR_ITEM_1|VER_ERR_OPCODE_OFFSET;
        m_sError.sItem1 = methodItem._GetItem();
        SET_ERR_OPCODE_OFFSET();
        if (!SetErrorAndContinue(VER_E_METHOD_ACCESS))
            return E_FAIL;
    }


    if (fTailCall && GetTopStack() != NULL)
    {
        m_sError.dwFlags = VER_ERR_OPCODE_OFFSET;
        SET_ERR_OPCODE_OFFSET();
        if (!SetErrorAndContinue(VER_E_TAIL_STACK_EMPTY))
            return E_FAIL;
    }


    // Push return value on the stack
    if (opcode == CEE_NEWOBJ)
    {
        // constructors are declared returning void, but they push an instance on the stack
        if (fArray)
        {
            if (!ReturnValueItem.SetArray(mrMemberRef, m_pModule, m_pInternalImport))
            {
                FAILMSG_TOKEN_RESOLVE(mrMemberRef);
                return E_FAIL;
            }

            Item  ArrayElement = ReturnValueItem;
            if (!ArrayElement.DereferenceArray() || ArrayElement.IsValueClassWithPointerToStack())
            {
                m_sError.dwFlags = VER_ERR_OPCODE_OFFSET;
                SET_ERR_OPCODE_OFFSET();
                if (!SetErrorAndContinue(VER_E_SIG_ARRAY_TB_AH))
                    return E_FAIL;
            }
        }
        else
        {
            ReturnValueItem.SetTypeHandle(TypeHandle(pClassOfMethod->GetMethodTable()));
        }

        ReturnValueItem.NormaliseForStack();

        if (!Push(&ReturnValueItem))
        {
            FAILMSG_PC_STACK_OVERFLOW();
            return E_FAIL;
        }
    }
    else
    {
        if (ReturnValueItem.GetType() != ELEMENT_TYPE_VOID)
        {
            ReturnValueItem.NormaliseForStack();

            if (!Push(&ReturnValueItem))
            {
                FAILMSG_PC_STACK_OVERFLOW();
                return E_FAIL;
            }
        }
    }

    return S_OK;
}


//
// Set that the this pointer is initialised, and propagate this information to all
// copies of the this pointer present on the stack, in locals, and in args.
//
// Also set the init status of all the fields to TRUE, if this is a value class
// constructor.
//
void Verifier::PropagateThisPtrInit()
{
    DWORD i;

    m_fThisUninit = FALSE;

    for (i = 0; i < m_StackSlot; i++)
    {
        if (m_pStack[i].IsThisPtr())
            m_pStack[i].SetInitialised();
    }

    // Propagate to local variables
    for (i = 0; i < m_NumNonPrimitiveLocVars; i++)
    {
        if (m_pNonPrimitiveLocArgs[i].IsThisPtr())
            m_pNonPrimitiveLocArgs[i].SetInitialised();
    }

    if (m_fInValueClassConstructor)
        SetAllValueClassFieldsInited();
}


//
// Create the "local variable to slot" mapping
//
// Primitive types and value class locals require only liveness info, since their actual
// types cannot change in the method.  This liveness info is mapped to a single bit.  
//
// These are assigned negative slot numbers.  For example "-1" means bit #0 in the liveness bitmap,
// "-2" means bit #1, "-3" means bit #2, etc.
//
// Object types and byref locals are mapped onto an Item, and are assigned positive slot numbers.  In an
// EntryState, there is an Item present for each object type.
//
BOOL Verifier::AssignLocalVariableAndArgSlots()
{
    long    CurrentPrimitiveSlot = -1;
    DWORD   NumLocVarPrimitiveSlot;
    DWORD   i;

    m_NumNonPrimitiveLocVars    = 0;

#ifdef _DEBUG
    if (m_pILHeader->Flags & CorILMethod_InitLocals)
        LOG((LF_VERIFIER, LL_INFO10000, "ZeroInitLocals\n"));
#endif

    // For arguments, types and liveness are not tracked, except for the "this" pointer
    for (i = 0; i < m_MaxLocals; i++)
    {
        LocArgInfo_t *pInfo = &m_pLocArgTypeList[i];

#ifdef _DEBUG
        LOG((LF_VERIFIER, LL_INFO10000, 
            "Local #%d = %s%s\n", 
            i, 
            m_pLocArgTypeList[i].m_Item.ToStaticString(),
            DoesLocalHavePinnedType(i) ? " (pinned type)" : ""
        ));
#endif
        //
        // If it's a primitive type or value class, assign it a negative slot, otherwise 
        // assign it a positive slot
        //
        if (pInfo->m_Item.IsValueClassOrPrimitive())
        {
            pInfo->m_Slot = CurrentPrimitiveSlot--;
        }
        else
        {
            // Non-primitive local
            pInfo->m_Slot = m_NumNonPrimitiveLocVars++;
            // m_Item is never used
        }
    }

    // convert negative primitive slot number to # primitive slots
    NumLocVarPrimitiveSlot = (DWORD)(long)(-CurrentPrimitiveSlot-1);

    // determine the offsets and sizes of the various arrays in the EntryState structure

    // EntryState:
    // <primitive loc var bitmap>
    // <non-primitive loc vars and args>
    // <value class field bitmap> (if a value class constructor)
    // <stack data> (Item * MaxStackSlots)
    m_NumPrimitiveLocVarBitmapArrayElements = NUM_DWORD_BITMAPS(NumLocVarPrimitiveSlot); // does not include args
    m_PrimitiveLocVarBitmapMemSize = m_NumPrimitiveLocVarBitmapArrayElements * sizeof(DWORD); // does not include args
    m_NonPrimitiveLocArgMemSize    = (m_NumNonPrimitiveLocVars * sizeof(Item)); // includes args

    // offsets are from the beginning of the EntryState
    m_NonPrimitiveLocArgOffset  = sizeof(EntryState_t) + m_PrimitiveLocVarBitmapMemSize;

    if (m_fInValueClassConstructor)
    {
        m_dwValueClassInstanceFields = m_pMethodDesc->GetClass()->GetNumInstanceFields();
        m_dwNumValueClassFieldBitmapDwords = NUM_DWORD_BITMAPS(m_dwValueClassInstanceFields);

        m_pValueClassFieldsInited = new DWORD[m_dwNumValueClassFieldBitmapDwords];
        if (m_pValueClassFieldsInited == NULL)
        {
            SET_ERR_OM();
            return FALSE;
        }

        memset(m_pValueClassFieldsInited, 0, m_dwNumValueClassFieldBitmapDwords*sizeof(DWORD));
        m_dwValueClassFieldBitmapOffset = m_NonPrimitiveLocArgOffset + m_NonPrimitiveLocArgMemSize;
        m_StackItemOffset               = m_dwValueClassFieldBitmapOffset + m_dwNumValueClassFieldBitmapDwords*sizeof(DWORD);
    }
    else
    {
        m_StackItemOffset               = m_NonPrimitiveLocArgOffset + m_NonPrimitiveLocArgMemSize;
    }

    // Now that we know how many primitive local variables there are, allocate a liveness
    // table for them
    if (m_MaxLocals == 0)
    {
        m_pPrimitiveLocVarLiveness = NULL;
        m_pExceptionPrimitiveLocVarLiveness = NULL;
    }
    else
    {
        // Allocate two arrays - the second is for exceptions
        m_pPrimitiveLocVarLiveness = new DWORD[m_NumPrimitiveLocVarBitmapArrayElements*2];
        
        if (m_pPrimitiveLocVarLiveness == NULL)
        {
            SET_ERR_OM();
            return FALSE;
        }

        m_pExceptionPrimitiveLocVarLiveness = &m_pPrimitiveLocVarLiveness[m_NumPrimitiveLocVarBitmapArrayElements];


#ifdef _VER_JIT_DOES_NOT_INIT_LOCALS
        // Don't need to init exception bitmap info
        if (m_pILHeader->Flags & CorILMethod_InitLocals)
        {
            // Set all locals to live
            memset(m_pPrimitiveLocVarLiveness, 0xFF, m_PrimitiveLocVarBitmapMemSize);
        }
        else
        {
            // Set all locals to be not live
            memset(m_pPrimitiveLocVarLiveness, 0, m_PrimitiveLocVarBitmapMemSize);
        }
#else 
        // All locals are inited by jit compilers before they are used
        // Set all locals to live
        memset(m_pPrimitiveLocVarLiveness, 0xFF, m_PrimitiveLocVarBitmapMemSize);
#endif
    }

    // Allocate two arrays - the second is for exceptions
    m_pNonPrimitiveLocArgs = new Item[1 + (m_NumNonPrimitiveLocVars)*2];
    if (m_pNonPrimitiveLocArgs == NULL)
    {
        SET_ERR_OM();
        return FALSE;
    }

    // Don't need to init exception info now - this is inited when it is used
    m_pExceptionNonPrimitiveLocArgs = &m_pNonPrimitiveLocArgs[m_NumNonPrimitiveLocVars];

    // For our current state, set that each local which requires more than simple live-dead 
    // tracking, currently contains a null for object refs and uninit for other types.
    for (i = 0; i < m_MaxLocals; i++)
    {
        long slot = GetGlobalLocVarTypeInfo(i)->m_Slot;
        
        // Livedead tracking is for primitive types and value classes
        if (LIVEDEAD_TRACKING_ONLY_FOR_SLOT(slot))
            continue;

#ifdef _VER_TRACK_LOCAL_TYPE
        // Otherwise we have an objref
        Item *pGlobalTypeInfo = &GetGlobalLocVarTypeInfo(i)->m_Item;

        // Set local type
        m_pNonPrimitiveLocArgs[slot].SetDead(); // Nothing assigned here yet

        if (pGlobalTypeInfo->IsObjRef())
        {
            // If we have a local which is an objref and we are zero-initing all locals,
            // then set the current value of the local to the null objref.  If the type of
            // the local is pinned, then set it to that type instead.
            
            // JIT zero initialises all ObjectRefs 
            // if (m_pILHeader->Flags & CorILMethod_InitLocals)
            if (DoesLocalHavePinnedType(i))
            {
                m_pNonPrimitiveLocArgs[slot] = *pGlobalTypeInfo;
            }
            else
            {
                // JIT null initialises all local Objectrefs
                m_pNonPrimitiveLocArgs[slot].SetToNullObjRef();
            }
        }
#else
        m_pNonPrimitiveLocArgs[slot] = GetGlobalLocVarTypeInfo(i)->m_Item;
#endif
    }

    return TRUE;
}

BOOL Item::DereferenceArray()
{
    _ASSERTE(IsArray());

    if (m_th == TypeHandle(g_pArrayClass))
        return FALSE;

    TypeHandle th = (m_th.AsArray())->GetElementTypeHandle();

    if (th.IsNull())
        return FALSE;

    long lType = Verifier::TryConvertPrimitiveValueClassToType(th);

    if (lType != 0)
    {
        m_dwFlags = lType;
        m_th      = TypeHandle();
    }
    else
    {
        SetTypeHandle(th);
    }

    return TRUE;
}


//
// If an item is a System/Integer1 etc., turn it into an ELEMENT_TYPE_I1
//
// System/Byte       --> ELEMENT_TYPE_I1
// System/Char  --> ELEMENT_TYPE_I2
// &System/Byte      --> &ELEMENT_TYPE_I1
// &System/Char --> &ELEMENT_TYPE_I2
//
// Handle byref etc. as appropriate
//
void Item::NormaliseToPrimitiveType()
{
    // Check whether we're a value class, or a byref value class
    if ((m_dwFlags & VER_FLAG_DATA_MASK) == VER_ELEMENT_TYPE_VALUE_CLASS)
    {
        _ASSERTE(ContainsTypeHandle());

        long lType = Verifier::TryConvertPrimitiveValueClassToType(m_th);
        if (lType != 0)
        {
            // It's a value class corresponding to a primitive type
            // Remove the value class part, and put the type part in there
            m_dwFlags &= (~VER_FLAG_DATA_MASK);
            m_dwFlags |= lType;
        }
    }
}

/* static */ void Verifier::InitStaticTypeHandles()
{
    static fInited = false;

    if (fInited)
        return;

    if (s_th_System_RuntimeTypeHandle.IsNull())
        s_th_System_RuntimeTypeHandle = TypeHandle(g_Mscorlib.GetClass(CLASS__TYPE_HANDLE));

    if (s_th_System_RuntimeFieldHandle.IsNull())
        s_th_System_RuntimeFieldHandle = TypeHandle(g_Mscorlib.GetClass(CLASS__FIELD_HANDLE));

    if (s_th_System_RuntimeMethodHandle.IsNull())
        s_th_System_RuntimeMethodHandle = TypeHandle(g_Mscorlib.GetClass(CLASS__METHOD_HANDLE));

    if (s_th_System_RuntimeArgumentHandle.IsNull())
        s_th_System_RuntimeArgumentHandle = TypeHandle(g_Mscorlib.GetClass(CLASS__ARGUMENT_HANDLE));

    if (s_th_System_TypedReference.IsNull())
        s_th_System_TypedReference = TypeHandle(g_Mscorlib.GetClass(CLASS__TYPED_REFERENCE));

    fInited = true;
}

//
// If pClass is one of the known value class equivalents of a primitive type, converts it to that type
// (e.g. System/Int32 -> I4).  If not, returns 0.
//
/* static */ long Verifier::TryConvertPrimitiveValueClassToType(TypeHandle th)
{
    switch (th.GetNormCorElementType())
    {
    case ELEMENT_TYPE_I1:
    case ELEMENT_TYPE_U1:
    case ELEMENT_TYPE_BOOLEAN:
        return ELEMENT_TYPE_I1;

    case ELEMENT_TYPE_I2:
    case ELEMENT_TYPE_U2:
    case ELEMENT_TYPE_CHAR:
        return ELEMENT_TYPE_I2;

    case ELEMENT_TYPE_I4:
    case ELEMENT_TYPE_U4:
        return ELEMENT_TYPE_I4;

    case ELEMENT_TYPE_I8:
    case ELEMENT_TYPE_U8:
        return ELEMENT_TYPE_I8;

    case ELEMENT_TYPE_I:
        // RuntimeTypeHandle, RuntimeMethodHandle, RuntimeArgHandle etc
        // Are disguised as ELEMENT_TYPE_I. Catch it here.
        InitStaticTypeHandles();

        if ((th == s_th_System_RuntimeTypeHandle)  ||
            (th == s_th_System_RuntimeFieldHandle) ||
            (th == s_th_System_RuntimeMethodHandle)||
            (th == s_th_System_RuntimeArgumentHandle))
            return 0;
    
    case ELEMENT_TYPE_U:
        return ELEMENT_TYPE_I;

    case ELEMENT_TYPE_R4:
        return ELEMENT_TYPE_R4;

    case ELEMENT_TYPE_R8:
        return ELEMENT_TYPE_R8;

    }

    return 0;
}


/* static */ BOOL Item::PrimitiveValueClassToTypeConversion(Item *pSource, Item *pDest)
{
    long lType;

    _ASSERTE(pSource->ContainsTypeHandle());

    lType = Verifier::TryConvertPrimitiveValueClassToType(pSource->GetTypeHandle());
    if (lType == 0)
        return FALSE; // not a primitive type equivalent, so not compatible

    // preserve everything (byref, uninit, array info, ...) except the data mask (type)
    *pDest = *pSource;
    pDest->m_dwFlags &= (~VER_FLAG_DATA_MASK);
    pDest->m_dwFlags |= lType;
    return TRUE;
}



//
// Verify this item is compatible with the template pParent.  Basically, that this item
// is a "subclass" of pParent -it can be substituted for pParent anywhere.  Note that if
// pParent contains fancy flags, such as "uninitialised", "is this ptr", or 
// "has byref local/field" info, then "this" must also contain those flags, otherwise 
// FALSE will be returned!
//
// Rules for determining compatibility:
//
// If pParent is a primitive type or value class, then this item must be the same primitive 
// type or value class.  The exception is that the built in value classes 
// System/Boolean etc. are treated as synonyms for ELEMENT_TYPE_I1 etc.
//
// If pParent is a byref of a primitive type or value class, then this item must be a
// byref of the same (rules same as above case).
//
// Byrefs are compatible only with byrefs.
//
// If pParent is an object, this item must be a subclass of it, implement it (if it is an
// interface), or be null.
//
// If pParent is an array, this item must be the same or subclassed array.
//
// If pParent is a null objref, only null is compatible with it.
//
// If the "uninitialised", "by ref local/field", "this pointer" or other flags are different, 
// the items are incompatible.
//
// pParent CANNOT be an undefined (dead) item - this will cause an assertion failure.
//
//
DWORD Item::CompatibleWith(Item *pParent, ClassLoader *pLoader)
{
    return CompatibleWith(pParent, pLoader, TRUE);
}

#ifdef _DEBUG
DWORD Item::CompatibleWith(Item *pParent, ClassLoader *pLoader, BOOL fSubclassRelationshipOK)
{
/* @DEBUG
    Item a = *this;
    Item b = *pParent;
*/

    LOG((LF_VERIFIER, LL_INFO100000, "Compatible [{%s},",  this->ToStaticString()));
    if (fSubclassRelationshipOK)
        LOG((LF_VERIFIER, LL_INFO100000, " {%s}] -> ",    pParent->ToStaticString()));
    else
        LOG((LF_VERIFIER, LL_INFO100000, " {%s}] => ",    pParent->ToStaticString()));

    BOOL bRet = DBGCompatibleWith(pParent, pLoader, fSubclassRelationshipOK);

    if (bRet)
        LOG((LF_VERIFIER, LL_INFO100000, "{%s} true\n", this->ToStaticString()));
    else
        LOG((LF_VERIFIER, LL_INFO100000, "{%s} false\n", this->ToStaticString()));

/* @DEBUG
    if ((m_dwFlags == pParent->m_dwFlags) && (m_dwFlags == VER_ELEMENT_TYPE_OBJREF))
    {
        if ((m_th == TypeHandle((void *)0)) || (pParent->m_th == TypeHandle((void *)0)))
            DebugBreak();
    }
*/

    return bRet;
}

DWORD Item::DBGCompatibleWith(Item *pParent, ClassLoader *pLoader, BOOL fSubclassRelationshipOK)
#else   // _DEBUG
DWORD Item::CompatibleWith(Item *pParent, ClassLoader *pLoader, BOOL fSubclassRelationshipOK)
#endif  // _DEBUG
{
    //_ASSERTE(!pParent->IsDead());

    DWORD dwChild   = this->m_dwFlags;
    DWORD dwParent  = pParent->m_dwFlags;
    DWORD dwDelta   = (dwChild ^ dwParent);


    if (dwDelta == 0)
        goto EndOfDeltaCheck;

    // If the byrefness, init or method flags differ, fail now.
    if (dwDelta & (VER_FLAG_UNINIT|VER_FLAG_BYREF|VER_FLAG_METHOD))
        return FALSE;

    // Check compact type info are the same
    // Compact type info carries such info as objref, value class, or a primitive type
    if (dwDelta & VER_FLAG_DATA_MASK)
    {
        // Could be because we are trying to check &I4 compatible with &System/Int32,
        // or I4 with System/Int32.  If so, normalise to I4 and retry.

        // This must always be a one way conversion so that we can't recurse forever
        if (pParent->ContainsTypeHandle() && ((dwParent & VER_FLAG_DATA_MASK) == VER_ELEMENT_TYPE_VALUE_CLASS))
        {
            Item        retry;

            if (!PrimitiveValueClassToTypeConversion(pParent, &retry))
                return FALSE; // not a primitive type equivalent, so not compatible

            return this->CompatibleWith(&retry, pLoader, fSubclassRelationshipOK);
        }
        else if (this->ContainsTypeHandle() && ((dwChild & VER_FLAG_DATA_MASK) == VER_ELEMENT_TYPE_VALUE_CLASS))
        {
            // Vice versa of the above
            Item        retry;

            if (!PrimitiveValueClassToTypeConversion(this, &retry))
                return FALSE; // not a primitive type equivalent, so not compatible

            return retry.CompatibleWith(pParent, pLoader, fSubclassRelationshipOK);
        }

        return FALSE;
    }

    // From this point on we already know that the objref-ness is the same, and the
    // byref-ness is the same.

    // If parent has a local var number, then this must have the same number
    if (dwDelta & (VER_FLAG_BYREF_LOCAL|VER_FLAG_LOCAL_VAR_MASK))
    {
        if (dwParent & VER_FLAG_BYREF_LOCAL)
            return FALSE;
    }

    // If parent has a field number, then this must have the same number
    if (dwDelta & (VER_FLAG_BYREF_INSTANCE_FIELD|VER_FLAG_FIELD_MASK))
    {
        if (dwParent & VER_FLAG_BYREF_INSTANCE_FIELD)
            return FALSE;
    }

    // If parent was the this pointer, then this must also
    if (dwDelta & VER_FLAG_THIS_PTR)
    {
        if (dwParent & VER_FLAG_THIS_PTR)
            return FALSE;
    }

    // If parent had a permanent home, then this must also
    if (dwDelta & VER_FLAG_BYREF_PERMANENT_HOME)
    {
        if (dwParent & VER_FLAG_BYREF_PERMANENT_HOME)
            return FALSE;
    }

EndOfDeltaCheck:
    // If parent is null or byref null, only null or byref-null (respectively) fits the template
    if (dwParent & VER_FLAG_NULL_OBJREF)
        return (dwChild & VER_FLAG_NULL_OBJREF);

    // If this is null/byref-null, it is compatible with any objref/byref-objref respectively
    if (dwChild & VER_FLAG_NULL_OBJREF)
        return TRUE; // we already that the "objrefs-ness" must be the same if we got here

    // If parent was array, then this must also (using dwDelta for perf)
    if (dwDelta & VER_FLAG_ARRAY)
    {
        if (dwParent & VER_FLAG_ARRAY)
            return FALSE;
    }

    // We know that the compact type info is the same (primitive, value class, objref).
    // If a value class or objref, methodesc, we have to handle specially - otherwise we're already done
    // This handles by-ref <primitive> as well as the non byref case
    if (((dwChild & VER_FLAG_METHOD) == 0) &&
        ((dwChild & VER_FLAG_DATA_MASK) != VER_ELEMENT_TYPE_OBJREF) &&
        ((dwChild & VER_FLAG_DATA_MASK) != VER_ELEMENT_TYPE_VALUE_CLASS))
        return TRUE;

    // Now we know we are either an methodesc OR objref, arrayref, value class, either byref or not
    // Since the byref-ness already matches, we can compare the other components separately and completely
    // ignore the byref-ness
    if (dwParent & VER_FLAG_ARRAY)
    {
        if (fSubclassRelationshipOK)
        {
            if (pParent->m_th == TypeHandle(g_pArrayClass))
                return TRUE;
            else if (m_th == TypeHandle(g_pArrayClass))
                return (pParent->m_th == TypeHandle(g_pArrayClass));

            CorElementType elThis = ((m_th.AsArray())->GetElementTypeHandle()).GetNormCorElementType();
            CorElementType elParent = (((pParent->m_th).AsArray())->GetElementTypeHandle()).GetNormCorElementType();

            if (Verifier::CanCast(elThis, elParent))
                return TRUE;

            return m_th.CanCastTo(pParent->m_th);
        }

        return (m_th == pParent->m_th);
    }

    if (dwParent & VER_FLAG_METHOD) 
    {
        if (this->m_pMethod == pParent->m_pMethod)
            return TRUE;

        // CALLI cannot be used with function pointers to virtual methods.
        // Disallow virtual methods
        if (this->m_pMethod->IsVirtual() || pParent->m_pMethod->IsVirtual())
            return FALSE;

        // both methods need to have the same signature.
        return EquivalentMethodSig(this->m_pMethod, pParent->m_pMethod);
    }

    // Parent is regular objref (not array), or value class
    // Subclass relation ship is NOT OK for byrefs.
    // @ASSERT byrefness is same here.

    if (fSubclassRelationshipOK && ((dwParent & VER_FLAG_BYREF) == 0))
        return m_th.CanCastTo(pParent->m_th);
    else
        return (m_th == pParent->m_th);
}


// If this one returns FALSE, additional checks are needed.
/* static */ BOOL Verifier::CanCast(CorElementType el1, CorElementType el2)
{
    if (el1 == el2) // CorIsPrimitiveType does not include ELEMENT_TYPE_I
        return (CorIsPrimitiveType(el1) || (el1 == ELEMENT_TYPE_I));

    switch (el1)
    {
    case ELEMENT_TYPE_I1:
    case ELEMENT_TYPE_U1:
    case ELEMENT_TYPE_BOOLEAN:
        return (el2 == ELEMENT_TYPE_I1 || 
                el2 == ELEMENT_TYPE_U1 || 
                el2 == ELEMENT_TYPE_BOOLEAN);

    case ELEMENT_TYPE_I2:
    case ELEMENT_TYPE_U2:
    case ELEMENT_TYPE_CHAR:
        return (el2 == ELEMENT_TYPE_I2 || 
                el2 == ELEMENT_TYPE_U2 || 
                el2 == ELEMENT_TYPE_CHAR);

    case ELEMENT_TYPE_I4:
    case ELEMENT_TYPE_U4:
        return (el2 == ELEMENT_TYPE_I4 ||
                el2 == ELEMENT_TYPE_U4);

    case ELEMENT_TYPE_I8:
    case ELEMENT_TYPE_U8:
        return (el2 == ELEMENT_TYPE_I8 ||
                el2 == ELEMENT_TYPE_U8);

    case ELEMENT_TYPE_I:
    case ELEMENT_TYPE_U:
        return  (el2 == ELEMENT_TYPE_I || 
                 el2 == ELEMENT_TYPE_U);

    }

    return FALSE;
}

//
// Merge this and pSrc to find some commonality (e.g. a common parent).
// Copy the result to this item, marking it dead if no commonality can be found.
//
// null ^ null                  -> null
// Object ^ null                -> Object
// [I4 ^ null                   -> [I4
// InputStream ^ OutputStream   -> Stream
// InputStream ^ NULL           -> InputStream
// [I4 ^ Object                 -> Object
// [I4 ^ [Object                -> Array
// [I4 ^ [R8                    -> Array
// [Foo ^ I4                    -> DEAD
// [Foo ^ [I1                   -> Array
// [InputStream ^ [OutputStream -> Array
// DEAD ^ X                     -> DEAD
// [Intfc ^ [OutputStream       -> Array
// Intf ^ [OutputStream         -> Object
// [[InStream ^ [[OutStream     -> Array
// [[InStream ^ [OutStream      -> Array
// [[Foo ^ [Object              -> Array
//
// Importantly:
// [I1 ^ [U1                    -> either [I1 or [U1
// etc.
//
// Also, System/Int32 and I4 merge -> I4, etc.
//
// Returns FALSE if the merge was completely incompatible (i.e. the item became dead).
//
#ifdef _DEBUG
BOOL Item::MergeToCommonParent(Item *pSrc)
{
/* @DEBUG
    Item a = *this;
    Item b = *pSrc;
*/

    LOG((LF_VERIFIER, LL_INFO100000, "Merge [{%s},",  this->ToStaticString()));
    LOG((LF_VERIFIER, LL_INFO100000, " {%s}] => ",    pSrc->ToStaticString()));

    BOOL bRet = DBGMergeToCommonParent(pSrc);

    if (bRet)
        LOG((LF_VERIFIER, LL_INFO100000, "{%s} pass\n", this->ToStaticString()));
    else
        LOG((LF_VERIFIER, LL_INFO100000, "{%s} fail\n", this->ToStaticString()));

/* @DEBUG
    if ((m_dwFlags == pSrc->m_dwFlags) && (m_dwFlags == VER_ELEMENT_TYPE_OBJREF))
    {
        if ((m_th == TypeHandle((void *)0)) || (pSrc->m_th == TypeHandle((void *)0)))
            DebugBreak();
    }
*/

    return bRet;
}

BOOL Item::DBGMergeToCommonParent(Item *pSrc)
#else   // _DEBUG
BOOL Item::MergeToCommonParent(Item *pSrc)
#endif  // _DEBUG
{
    DWORD dwSrc = pSrc->m_dwFlags;
    DWORD dwFlagsXor;

    // If byref local or byref field info does not match, remove it
    if ((dwSrc ^ m_dwFlags) & (VER_FLAG_BYREF_LOCAL | VER_FLAG_BYREF_INSTANCE_FIELD | VER_FLAG_LOCAL_VAR_MASK | VER_FLAG_FIELD_MASK))
    {
        // Byref local/field info occupies the same space, so we remove them both
        m_dwFlags &= (~(VER_FLAG_BYREF_LOCAL | VER_FLAG_BYREF_INSTANCE_FIELD | VER_FLAG_LOCAL_VAR_MASK | VER_FLAG_FIELD_MASK));
    }

    // If this pointer info does not match, remove it
    if ((dwSrc ^ m_dwFlags) & VER_FLAG_THIS_PTR)
        m_dwFlags &= (~VER_FLAG_THIS_PTR);

    // If permanent home information does not match, remove it
    if ((dwSrc ^ m_dwFlags) & VER_FLAG_BYREF_PERMANENT_HOME)
        m_dwFlags &= (~VER_FLAG_BYREF_PERMANENT_HOME);

    // Check that uninit, byref, flags are the same, and that the compact type info is the same.  
    // The compact type info contains all the info needed for primitive types, as well as whether it is a value class or objref
    dwFlagsXor = ((dwSrc ^ m_dwFlags) & (VER_FLAG_UNINIT | VER_FLAG_BYREF | VER_FLAG_METHOD | VER_FLAG_DATA_MASK));
    if (dwFlagsXor != 0)
    {
        // There was some mismatch
        if (dwFlagsXor == VER_FLAG_UNINIT)
        {
            // Everything was the same, except that one item was init and one was uninit.
            // If both items are value classes, or byref value classes, of the same type, then this is 
            // ok - the result is an uninitialised value class, or a pointer to the same.  
            // Value classes can be initialised multiple times.
            if (IsByRefValueClassOrByRefPrimitiveValueClass() || 
                IsValueClassOrPrimitive())
            {
                // Set that we're uninitialised (to be conservative)
                SetUninitialised();
                goto Continue;
            }
        }

        if (dwFlagsXor & VER_FLAG_DATA_MASK)
        {
            // Could be a value class <-> primitive type mismatch
            // e.g. System/Int32 doesn't match ELEMENT_TYPE_I4
            // Normalise to the ELEMENT_TYPE_ enumeration, so that we do match such cases

            // This must always be a one way conversion so that we can't recurse forever
            if (pSrc->IsValueClass())
            {
                Item    retry;

                if (!PrimitiveValueClassToTypeConversion(pSrc, &retry))
                {
                    SetDead();
                    return FALSE;
                }

                return MergeToCommonParent(&retry);
            }
            else if (this->IsValueClass())
            {
                Item    retry;

                if (!PrimitiveValueClassToTypeConversion(this, &retry))
                {
                    SetDead();
                    return FALSE;
                }

                *this = retry; // Might as well trash "this", we were going to make it dead anyway
                return MergeToCommonParent(pSrc);
            }
        }

        SetDead();
        return FALSE;
    }

Continue:

    // Now handle the null objref specially.  We do not allow null and an uninit objref to be merged - but since
    // null can never have the uninit flag set, we already handle that case above

    // If one is the null objref and the other is an object, become the object
    if (dwSrc & VER_FLAG_NULL_OBJREF)
    {
        _ASSERTE(IsObjRef());
        return TRUE;
    }

    if (m_dwFlags & VER_FLAG_NULL_OBJREF)
    {
        // Become the object
        _ASSERTE(pSrc->IsObjRef());
        _ASSERTE(!pSrc->IsByRef());
        *this = *pSrc;
        return TRUE;
    }

    // If there is no objref, value class or method, we're already done 
    // - we had primitive types, or byrefs to primitive types
    if (((dwSrc & VER_FLAG_DATA_MASK) != VER_ELEMENT_TYPE_OBJREF) && 
        ((dwSrc & VER_FLAG_DATA_MASK) != VER_ELEMENT_TYPE_VALUE_CLASS) &&
        ((dwSrc & VER_FLAG_METHOD) == 0))
        return TRUE;

    // Both are objects/arrays, or value classes, or by-ref of the same
    // Since the by-refness is the same, we're going to ignore the byref flag

    // Is the array-ness the same?
    if ((dwSrc ^ m_dwFlags) & VER_FLAG_ARRAY)
    {
        // One item is an array, and the other is not, so merge to Object
        m_th = TypeHandle(g_pObjectClass);
        m_dwFlags &= (~VER_FLAG_ARRAY);
        return TRUE;
    }

    // Either both are arrays or neither is an array
    if (this->IsArray())
    {
        TypeHandle th = TypeHandle::MergeArrayTypeHandlesToCommonParent(m_th, pSrc->m_th);

        _ASSERTE(!th.IsNull());

        m_th = th;

        _ASSERTE((m_dwFlags == (VER_FLAG_ARRAY|VER_ELEMENT_TYPE_OBJREF)));

/*
        if (!th.IsArray())
            m_dwFlags  &= (~VER_FLAG_ARRAY);
*/
    }
    // Either both are methods or neither is a method
    else if (this->IsMethod())
    {
        if (m_pMethod != pSrc->m_pMethod)
        {
            // CALLI cannot be used with function pointers to virtual methods.
            // Disallow virtual methods
            // Both methods need to have the same signature.
            if (m_pMethod->IsVirtual() || pSrc->m_pMethod->IsVirtual() ||
                (!EquivalentMethodSig(m_pMethod, pSrc->m_pMethod)))
            {
                SetDead();
                return FALSE;
            }
        }
    }
    else
    {
        // Handle value class
        if ((dwSrc & VER_FLAG_DATA_MASK) == VER_ELEMENT_TYPE_VALUE_CLASS)
        {
            if (this->GetTypeHandle() == pSrc->GetTypeHandle())
                return TRUE;

            SetDead();
            return FALSE;
        }

        // Neither is an array or method
        m_th = TypeHandle::MergeTypeHandlesToCommonParent(this->GetTypeHandle(), pSrc->GetTypeHandle());
    }

    return TRUE;
}


HRESULT Verifier::VerifyMethodNoException(
    MethodDesc *pMethodDesc,                               
    COR_ILMETHOD_DECODER* ILHeader
)
{
    HRESULT hr = S_OK;
    COMPLUS_TRY {
        hr = VerifyMethod(pMethodDesc,ILHeader, NULL, VER_STOP_ON_FIRST_ERROR);
    }
    COMPLUS_CATCH 
    {
        HRESULT hr2 = SecurityHelper::MapToHR(GETTHROWABLE());
        if(FAILED(hr2)) hr = hr2;
        if(SUCCEEDED(hr)) hr = E_FAIL;
    }
    COMPLUS_END_CATCH

    return hr;
}

HRESULT Verifier::VerifyMethod(
    MethodDesc *pMethodDesc,
    COR_ILMETHOD_DECODER* ILHeader,
    IVEHandler *veh,
    WORD wFlags
)
{
    THROWSCOMPLUSEXCEPTION();

#ifdef _DEBUG
    //
    // Skip verification if this method is listed in 
    // registry / env "VerSkip"
    //
    // NOTE : env is COMPlus_VerSkip
    if (g_pConfig->ShouldVerifierSkip(pMethodDesc))
    {
        DefineFullyQualifiedNameForClass();
        EEClass *pClass = pMethodDesc->GetClass();

        if (pClass != NULL)
        {
            GetFullyQualifiedNameForClassNestedAware(pClass);
        }
        else
            strcpy(_szclsname_, "<GlobalFunction>");

        LOG((LF_VERIFIER,
            LL_INFO10000,
            "Verifier: Skipping (%ws:%s.%s)\n",
            pMethodDesc->GetModule()->GetFileName(),
            _szclsname_,
            pMethodDesc->m_pszDebugMethodName));

        return S_FALSE;
    }
#endif

    Verifier *  v = new Verifier(wFlags, veh);


    HRESULT hr;

    if (v == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }


    if (!v->Init(pMethodDesc, ILHeader))
    {
        hr = E_FAIL;
        goto exit;
    }

#ifdef _VERIFIER_TEST_PERF_
    if (g_fVerPerfPolicyResolveNoVerification)
    {
        goto  exit;
    }
    else
    {
        g_timeStart = GetTickCount();
    }
#endif

#ifdef _VER_VERIFY_DEAD_CODE
    DWORD  i, j;
    // First verify the real code.
    hr = v->Verify(0);

    if (FAILED(hr))
        goto exit;

#ifdef _DEBUG
    // The default behavior is to do dead code verification.
    // In the debug build, disable this by config setting "VerDeadCode"
    if (g_pConfig->GetConfigDWORD(L"VerDeadCode",1) == 0)
        goto exit;
#endif

    // If there is any basic block that is not visited (dead code),
    // verify each one of them.

    BOOL bLocVarsInitedForDeadCodeVerification;

    bLocVarsInitedForDeadCodeVerification = FALSE;

    for (i=1; i<v->m_NumBasicBlocks; ++i)
    {
        if (v->m_pBasicBlockList[i].m_pInitialState == NULL)
        {
            LOG((LF_VERIFIER, LL_INFO10000,
                "---------- Dead code PC 0x%x ---------\n",
                v->m_pBasicBlockList[i].m_StartPC));

            if (!bLocVarsInitedForDeadCodeVerification)
            {
                bLocVarsInitedForDeadCodeVerification = TRUE;

                // Set all the loc var as live in all basic blocks.
                for (j=0; j<v->m_NumBasicBlocks; ++j)
                {
                    if (v->m_pBasicBlockList[j].m_pInitialState)
                    {
                        memset(v->m_pBasicBlockList[j].
                            m_pInitialState->m_PrimitiveLocVarLiveness, 0xFF, 
                            v->m_PrimitiveLocVarBitmapMemSize);

                    }
                }

                memset(v->m_pPrimitiveLocVarLiveness, 0xFF, 
                    v->m_PrimitiveLocVarBitmapMemSize);
            }

            hr = v->Verify(i);

            if (FAILED(hr))
                goto exit;
        }
    }
#else
    hr = v->Verify();
#endif

exit:

#ifdef _VERIFIER_TEST_PERF_
    if (g_fVerPerfPolicyResolveNoVerification)
    {
        g_timeStart = GetTickCount();
        Security::CanSkipVerification(pMethodDesc->GetModule());
        g_timeEnd = GetTickCount();
    }
    else
    {
        g_timeEnd = GetTickCount();
    }

    double diff = (double)(g_timeEnd - g_timeStart) / 1000;

    if (g_fVerPerfPolicyResolveNoVerification)
    {
        printf("Policy %4.4f seconds [%d, %d].\n", 
            diff, g_timeStart, g_timeEnd);
    }
    else
    {
        printf("Verify %4.4f seconds [%d, %d] size - %d [%s].\n",
            diff, g_timeStart, g_timeEnd, 
            v->m_CodeSize, pMethodDesc->GetName());
    }
#endif

    if (v != NULL)
    {
        if (FAILED(hr))
        {
            if (v->m_wFlags & VER_STOP_ON_FIRST_ERROR)
            {
                WCHAR wszErrorMsg[VER_MAX_ERROR_MSG_LEN];
#ifdef _DEBUG
                CHAR  szErrorMsg[VER_MAX_ERROR_MSG_LEN];
                GetErrorMsg(v->m_hrLastError, v->m_sError, v->m_pMethodDesc, 
                    wszErrorMsg, VER_MAX_ERROR_MSG_LEN);

                if (WszWideCharToMultiByte(CP_ACP, 0, wszErrorMsg, -1,
                    szErrorMsg, VER_MAX_ERROR_MSG_LEN-1, 0, NULL) == 0)
                {
                    strcpy(szErrorMsg, "WideCharToMultiByte error");
                }
#endif

                // This forces a policy resolution if this is not
                // already done.
    
#ifdef _DEBUG
                _ASSERTE(g_fVerForceVerifyInited);

                if (!g_fVerForceVerify && ((wFlags & VER_FORCE_VERIFY) == 0) && 
                    Security::CanSkipVerification(pMethodDesc->GetModule()))
#else
                if (((wFlags & VER_FORCE_VERIFY) == 0) && 
                    Security::CanSkipVerification(pMethodDesc->GetModule()))
#endif
                {
                    // Verification failed, but the Assembly has permission
                    // to skip verification.
    

                    LOG((LF_VERIFIER, LL_INFO10,
                         "Verifier: Trusted assembly %s\n", szErrorMsg));

                    hr = S_FALSE;
                    goto skip;
                }
    
    
                {
                    LOG((LF_VERIFIER, LL_INFO10, "Verifier: %s\n", szErrorMsg));
#ifndef _DEBUG
                    // in retail build, this step is done upfront
                    GetErrorMsg(v->m_hrLastError, v->m_sError, v->m_pMethodDesc,
                        wszErrorMsg, VER_MAX_ERROR_MSG_LEN);
#endif
        
                    OBJECTREF refThrowable = v->GetException () ;
                    
                    GCPROTECT_BEGIN (refThrowable) ;
                    
                    delete(v);
        
                    if (refThrowable != NULL)
                        COMPlusThrow (refThrowable) ;
                    else
                    {
                        COMPlusThrowNonLocalized(
                            kVerificationException,
                            wszErrorMsg
                        );
                    }
        
                    GCPROTECT_END () ;
                }
            }
#ifdef _DEBUG
            else
            {
                LOG((LF_VERIFIER, LL_INFO100, 
                    "Verification of %ws::%s.%s failed\n",
                    pMethodDesc->GetModule()->GetFileName(),
                    pMethodDesc->m_pszDebugClassName,
                    pMethodDesc->GetName()
                ));

                if ((hr == E_FAIL) &&
                    (v->m_IVEHandler != NULL) &&
                    ((wFlags & VER_FORCE_VERIFY) != 0))
                {
                    hr = S_FALSE;
                }
            }
#endif
        }
#ifdef _DEBUG
        else
        {
            LOG((LF_VERIFIER, LL_INFO10000, 
                "Verification of %ws::%s.%s succeeded\n",
                pMethodDesc->GetModule()->GetFileName(),
                pMethodDesc->m_pszDebugClassName,
                pMethodDesc->GetName()
            ));
        }
#endif

skip:
        delete(v);
    }

    return hr;
}


Verifier::Verifier(WORD wFlags, IVEHandler *veh)
{
    m_wFlags                    = wFlags;
    m_IVEHandler                = veh;
    m_pStack                    = NULL;
    m_pNonPrimitiveLocArgs      = NULL;
    m_pLocArgTypeList           = NULL;
    m_pPrimitiveLocVarLiveness  = NULL;
    m_pBasicBlockList           = NULL;
    m_pDirtyBasicBlockBitmap    = NULL;
    m_pExceptionList            = NULL;
    m_pExceptionBlockRoot       = NULL;
    m_pExceptionBlockArray      = NULL;
    m_pLocalHasPinnedType       = NULL;
    m_pExceptionPrimitiveLocVarLiveness = NULL;
    m_pExceptionNonPrimitiveLocArgs = NULL;
    m_pValueClassFieldsInited   = NULL;
    m_NumBasicBlocks            = 0;

    m_hrLastError               = S_OK;
    m_sError.dwFlags            = 0;

    m_hThrowable                = GetAppDomain()->CreateHandle (NULL) ;
    m_pInstrBoundaryList        = NULL;
    m_pBasicBlockBoundaryList   = NULL;
    m_pInternalImport           = NULL;

#ifdef _DEBUG
    m_nExceptionBlocks          = 0;
    m_fDebugBreak               = false;
    m_fDebugBreakOnError        = false;
    m_verState                  = verUninit;
#endif
}


Verifier::~Verifier()
{
    Cleanup();
}


//
// Clean up and free memory used for the verifying the method.
//
void Verifier::Cleanup()
{
    if (m_pLocalHasPinnedType != NULL)
    {
        delete(m_pLocalHasPinnedType);
        m_pLocalHasPinnedType = NULL;
    }

    if (m_pExceptionList != NULL)
    {
        delete(m_pExceptionList);
        m_pExceptionList = NULL;
    }

    if (m_pLocArgTypeList != NULL)
    {
        delete(m_pLocArgTypeList);
        m_pLocArgTypeList = NULL;
    }

    if (m_pPrimitiveLocVarLiveness != NULL)
    {
        delete(m_pPrimitiveLocVarLiveness);
        m_pPrimitiveLocVarLiveness = NULL;
    }

    if (m_pNonPrimitiveLocArgs != NULL)
    {
        delete(m_pNonPrimitiveLocArgs);
        m_pNonPrimitiveLocArgs = NULL;
    }

    if (m_pValueClassFieldsInited != NULL)
    {
        delete(m_pValueClassFieldsInited);
        m_pValueClassFieldsInited = NULL;
    }

    if (m_pStack != NULL)
    {
        // -2 because m_pStack points into the middle of the array - there are two sentinel
        // values before it
        delete [] (m_pStack - 2);
        m_pStack = NULL;
    }

    // delete basic blocks and associated data
    if (m_pBasicBlockList != NULL)
    {
        // DO NOT delete(m_pBasicBlockList) - it is a pointer to some memory allocated after
        // m_pDirtyBasicBlockBitmap
        DWORD i, j;
        EntryState_t *es, *es1;

        for (i = 0; i < m_NumBasicBlocks; i++)
        {
            es = m_pBasicBlockList[i].m_pInitialState;

            if (es != NULL)
            {
                _ASSERTE(es->m_Refcount > 0);
                es->m_Refcount--;

                if (es->m_Refcount == 0)
                    delete(es);
            }

            // Free the Extended State if one exists.
            if (m_pBasicBlockList[i].m_pAlloc != NULL)
            {
                _ASSERTE(m_fHasFinally);

                for (j = 0; j < m_NumBasicBlocks; j++)
                {
                    es1 = m_pBasicBlockList[i].m_ppExtendedState[j];

                    if (es1 != NULL)
                    {
                        _ASSERTE(es1->m_Refcount > 0);
                        es1->m_Refcount--;
        
                        if (es1->m_Refcount == 0)
                            delete(es1);
                    }
                }

                // Deleting m_pAlloc will free all the memory
                // DO NOT delete(m_ppExtendedState) - it is a pointer to some 
                // memory allocated in m_pAlloc

                delete(m_pBasicBlockList[i].m_pAlloc);
            }
        }
    }

    if (m_pDirtyBasicBlockBitmap != NULL)
    {
        // Frees m_pBasicBlockList also
        delete(m_pDirtyBasicBlockBitmap);
        m_pDirtyBasicBlockBitmap = NULL;
    }

    if (m_hThrowable != NULL)
    {
        DestroyHandle (m_hThrowable) ;
    }

    if (m_pInternalImport != NULL)
    {
        m_pInternalImport->Release();
        m_pInternalImport = NULL;
    }

    delete [] m_pInstrBoundaryList;
}


////////////////////////////////////////////////////////////////////////////////////////////////
//
// DEBUGGING ROUTINES
//
////////////////////////////////////////////////////////////////////////////////////////////////
#ifdef _DEBUG
void Verifier::PrintStackState()
{
    DWORD i;
    if (!LoggingOn(LF_VERIFIER, LL_INFO10000))
        return;

    if (m_StackSlot != 0)
    {
        LOG((LF_VERIFIER, LL_INFO10000, "Stack: "));

        for (i = 0; i < m_StackSlot; i++)
            m_pStack[i].Dump();

        LOG((LF_VERIFIER, LL_INFO10000, "\n"));
    }
}

void Verifier::PrintInitedFieldState()
{
    if (!LoggingOn(LF_VERIFIER, LL_INFO10000))
        return;

    if (m_fInValueClassConstructor)
    {
        DWORD i = 0;

        LOG((LF_VERIFIER, LL_INFO10000, "Initialization status of value class fields:\n"));

        FieldDescIterator fdIterator(m_pMethodDesc->GetClass(), FieldDescIterator::ALL_FIELDS);
        FieldDesc *pDesc;
        while ((pDesc = fdIterator.Next()) != NULL)
        {
            LOG((LF_VERIFIER, LL_INFO10000, 
                "  %s: '%s'\n", 
                (m_pValueClassFieldsInited[i >> 5] & (1 << (i & 31))) ? "yes" : " NO",
                pDesc->GetName()));
            ++i;
        }
        _ASSERTE(i == m_dwValueClassInstanceFields);
    }
}

void Verifier::PrintLocVarState()
{
    DWORD i;
    BOOL  fAnyPrinted = FALSE;
    if (!LoggingOn(LF_VERIFIER, LL_INFO10000))
        return;

    for (i = 0; i < m_MaxLocals; i++)
    {
        LocArgInfo_t *  pLocVarInfo = &m_pLocArgTypeList[i];
        long            slot = pLocVarInfo->m_Slot;
        Item *          pItem;

        if (pLocVarInfo->m_Item.GetType() == VER_ELEMENT_TYPE_UNKNOWN)
            continue;

        if (LIVEDEAD_TRACKING_ONLY_FOR_SLOT(slot))
        {
            slot = LIVEDEAD_NEGATIVE_SLOT_TO_BITNUM(slot);

            // Is a primitive type
            if ((m_pPrimitiveLocVarLiveness[slot >> 5] & (1 << (slot & 31))) == 0)
                continue;

            pItem = &m_pLocArgTypeList[i].m_Item;
        }
        else
        {
            pItem = &m_pNonPrimitiveLocArgs[slot];
        }

        if (pItem->GetType() == VER_ELEMENT_TYPE_UNKNOWN)
            continue;

        LOG((LF_VERIFIER, LL_INFO10000, "Local%d= ", i));
        pItem->Dump();
        LOG((LF_VERIFIER, LL_INFO10000, " "));

        fAnyPrinted = TRUE;
    }

    if (fAnyPrinted)
        LOG((LF_VERIFIER, LL_INFO10000, "\n"));
}

void Verifier::PrintState()
{
    if (!LoggingOn(LF_VERIFIER, LL_INFO10000))
        return;
    PrintStackState();
    PrintLocVarState();
    PrintInitedFieldState();

    if (m_fThisUninit)
        LOG((LF_VERIFIER, LL_INFO10000, "arg 0 is uninit\n"));
}


//
// Print everything in the queue
//
void Verifier::PrintQueue()
{
    DWORD   i, j;
    BOOL    fPrintedDirtyList = FALSE;
    if (!LoggingOn(LF_VERIFIER, LL_INFO10000))
        return;

    for (i = 0; i < m_NumBasicBlocks; i++)
    {
        if (IsBasicBlockDirty(i, FALSE, VER_BB_NONE) != 0)
        {
            if (!fPrintedDirtyList)
            {
                fPrintedDirtyList = TRUE;
                LOG((LF_VERIFIER, LL_INFO10000, "Queued basic blocks: "));
            }
    
            if (IsBasicBlockDirty(i, FALSE, VER_BB_NONE))
            {
                if (m_pBasicBlockList[i].m_pInitialState == NULL)
                {
                    _ASSERTE(!"Dirty with no state !");
                    LOG((LF_VERIFIER, LL_INFO10000, 
                    "(null 0x%x)", m_pBasicBlockList[i].m_StartPC));
                }
                else
                {
                    LOG((LF_VERIFIER, LL_INFO10000, 
                    "(0x%x)", m_pBasicBlockList[i].m_StartPC));
                }
            }
        }

        if (m_pBasicBlockList[i].m_pAlloc != NULL)
        {
            _ASSERTE(m_fHasFinally);

            for (j = 0; j < m_NumBasicBlocks; j++)
            {
                if (IsBasicBlockDirty(i, TRUE, j))
                {
                    if (!fPrintedDirtyList)
                    {
                        fPrintedDirtyList = TRUE;
                        LOG((LF_VERIFIER, LL_INFO10000, "Queued basic blocks: "));
                    }
    
                    if (m_pBasicBlockList[i].m_ppExtendedState[j] == NULL)
                    {
                        _ASSERTE(!"Dirty with no state !");
                        LOG((LF_VERIFIER, LL_INFO10000, 
                            "(extended null 0x%x [0x%x])", 
                            m_pBasicBlockList[i].m_StartPC,
                            m_pBasicBlockList[j].m_StartPC));
                    }
                    else
                    {
                        LOG((LF_VERIFIER, LL_INFO10000, 
                            "(extended 0x%x [0x%x])", 
                            m_pBasicBlockList[i].m_StartPC,
                            m_pBasicBlockList[j].m_StartPC));
                    }
                }
            }
        }
    }

    if (fPrintedDirtyList)
        LOG((LF_VERIFIER, LL_INFO10000, "\n"));
}

void Verifier::PrintExceptionTree()
{
    if (!LoggingOn(LF_VERIFIER, LL_INFO10000))
        return;

    _ASSERTE(m_verState >= verExceptTreeCreated);
    PrintExceptionTree(m_pExceptionBlockRoot, 0);
}

static char *s_eBlockName[] = {"Try", "Handler", "Filter"};

void Verifier::PrintExceptionTree(VerExceptionBlock *pe, int indent)
{
    if (pe == NULL)
        return;

    char * pIndent = new char[indent + 1];
    memset(pIndent, ' ', indent);
    pIndent[indent] = '\0';
 
    while (pe)
    {
        LOG((LF_VERIFIER, LL_INFO10000,  "%s%s (0x%x - 0x%x)\n",
            pIndent,  s_eBlockName[pe->eType],
            m_pBasicBlockList[pe->StartBB].m_StartPC,
            (pe->EndBB + 1 == m_NumBasicBlocks) ? m_CodeSize :
                m_pBasicBlockList[pe->EndBB + 1].m_StartPC));

        PrintExceptionTree(pe->pEquivalent, indent);
        PrintExceptionTree(pe->pChild, indent + 1);

        pe = pe->pSibling;
    }

    delete [] pIndent;
}

void Verifier::PrintExceptionBlock(
                        VerExceptionBlock *pOuter, 
                        VerExceptionBlock *pInner)
{
    if (!LoggingOn(LF_VERIFIER, LL_INFO10000))
        return;

    if (pOuter == NULL)
        goto exit;

    if (pOuter != pInner)
        LOG((LF_VERIFIER, LL_INFO10000,  "Outer "));

    LOG((LF_VERIFIER, LL_INFO10000,  "%s (0x%x - 0x%x)",
        s_eBlockName[pOuter->eType],
        m_pBasicBlockList[pOuter->StartBB].m_StartPC,
        (pOuter->EndBB + 1 == m_NumBasicBlocks) ? m_CodeSize :
            m_pBasicBlockList[pOuter->EndBB + 1].m_StartPC));

    if (pOuter != pInner)
    {
        LOG((LF_VERIFIER, LL_INFO10000,  " Inner %s (0x%x - 0x%x)",
            s_eBlockName[pInner->eType],
            m_pBasicBlockList[pInner->StartBB].m_StartPC,
            (pInner->EndBB + 1 == m_NumBasicBlocks) ? m_CodeSize :
            m_pBasicBlockList[pInner->EndBB + 1].m_StartPC));
    }

exit:
    LOG((LF_VERIFIER, LL_INFO10000, "\n"));
}

void Item::Dump()
{
    if (!LoggingOn(LF_VERIFIER, LL_INFO10000))
        return;
    LOG((LF_VERIFIER, LL_INFO10000, "{%s}", ToStaticString()));
}

void Verifier::CrossCheckVertable()
{

    static BOOL fFirstTime = TRUE;
    if (!fFirstTime)
    {
        return;
    }
    fFirstTime = FALSE;

    for (DWORD i = 0; i < sizeof(g_pszVerifierOperation)/sizeof(g_pszVerifierOperation[0]); i++)
    {
        INT netpush = 0;
        const CHAR *p = g_pszVerifierOperation[i];

        while (*p != ':' && *p != '!')
        {
            netpush--;
            switch (*p)
            {
                case '=':
                case 'I':
                case 'R':
                case 'N':
                case 'Q':
                //Obsolete case 'X':
                case 'A':
                case 'Y':
                case '4':
                case '8':
                case 'r':
                case 'd':
                case 'o':
                case 'i':
                case 'p':
                    break;

                case 'C':
                    p++;
                    netpush--;
                    break;

                case '&':
                case '[':
                    p++;
                    break;

                default:
                    _ASSERTE(!"Bad verop string.");
            }
            p++;
        }

        if (*p != '!')
        {
            p++;
            while (*p != '\0' && *p != '!')
            {
                switch (*p)
                {
                    case '-':
                    case '4':
                    case '8':
                    case 'r':
                    case 'd':
                    case 'i':
                    case 'n':
                    case '[':
                        netpush++;
                        break;

                    case 'A':
                    case 'L':
                        break;

                    case '#':
                    case 'b':
                    case 'u':
                    case 'l':
                        p++;
                        break;

                    default:
                        _ASSERTE(!"Bad verop string.");
                }
                p++;
            }
        }

        if (*p == '!')
        {
            // Coded manually - can't autocheck.
        }
        else
        {
            _ASSERTE(*p == '\0');
            if (OpcodeNetPush[i] != VarPush &&
                OpcodeNetPush[i] != netpush)
            {
                _ASSERTE(!"Vertable opcode string and opcode.def push/pop stats disagree.");
            }
        }



    }
}

#endif  // _DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\versig.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//
// versig.h
//
// For parsing metadata signatures
//
#ifndef _H_VERSIG
#define _H_VERSIG

class Verifier;

#define VERSIG_TYPE_MASK        VER_ERR_SIG_MASK
#define VERSIG_TYPE_METHOD_SIG  VER_ERR_METHOD_SIG 
#define VERSIG_TYPE_FIELD_SIG   VER_ERR_FIELD_SIG 
#define VERSIG_TYPE_LOCAL_SIG   VER_ERR_LOCAL_SIG 
#define VERSIG_TYPE_CALL_SIG    VER_ERR_CALL_SIG 

class VerSig
{
private:
    PCCOR_SIGNATURE m_pCurPos;
    PCCOR_SIGNATURE m_pEndSig;
    Module *    m_pModule;
    Verifier *  m_pVerifier;
    DWORD       m_dwNumArgs;
    BYTE        m_bCallingConvention;

    union {
        DWORD       m_dwSigType;
        DWORD       m_dwErrorFlags;
    };

    DWORD       m_dwOffset;

public:

    // Binary sig
    VerSig(Verifier *pVerifier, Module *pModule, PCCOR_SIGNATURE pSig, 
        DWORD cSig, DWORD dwSigType, DWORD dwOffset)
    {
        m_pVerifier     = pVerifier;
        m_pModule       = pModule;
        m_pCurPos       = pSig;
        m_pEndSig       = pSig + cSig;
        m_bCallingConvention = IMAGE_CEE_CS_CALLCONV_DEFAULT;
        m_dwSigType     = dwSigType;
        m_dwOffset      = dwOffset;
    }

    DWORD GetNumArgs()
    {
        _ASSERTE((m_dwSigType & VERSIG_TYPE_MASK) != VERSIG_TYPE_FIELD_SIG);

        return m_dwNumArgs;
    }

    BOOL IsVarArg()
    {
        _ASSERTE((m_dwSigType & VERSIG_TYPE_MASK) !=  VERSIG_TYPE_FIELD_SIG);
        _ASSERTE((m_dwSigType & VERSIG_TYPE_MASK) !=  VERSIG_TYPE_LOCAL_SIG);

        return ((m_bCallingConvention & IMAGE_CEE_CS_CALLCONV_VARARG) != 0);
    }

    BOOL    Init();

    BOOL    ParseNextComponentToItem(Item *pItem, BOOL fAllowVoid, BOOL fAllowVarArg, OBJECTHANDLE *hThrowable, DWORD dwArgNum, BOOL fNormaliseForStack);
    BOOL    SkipNextItem();

private:
    BOOL    ParseHelper(Item *pItem, BOOL fAllowVoid, BOOL fAllowVarArg, BOOL fFollowsByRef, BOOL fSkip, OBJECTREF *pThrowable, DWORD dwArgNum);
    BOOL    VerifyArraySig(CorElementType ArrayType, BOOL fSkip, BOOL fFollowsArray, DWORD dwArgNum);
    BOOL    GetData(DWORD* pdwData);
};

#endif /* _H_VERSIG */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\win32threadpool.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*++

Module Name:

    Win32ThreadPool.cpp

Abstract:

    This module implements Threadpool support using Win32 APIs


Revision History:
    December 1999 - Sanjay Bhansali (sanjaybh) - Created

--*/

#include "common.h"
#include "log.h"
#include "Win32ThreadPool.h"
#include "DelegateInfo.h"
#include "EEConfig.h"
#include "DbgInterface.h"
#include "utilcode.h"

// Function pointers for all Win32 APIs that are not available on Win95 and/or Win98
HANDLE (WINAPI *g_pufnCreateIoCompletionPort)(HANDLE FileHandle,
                                              HANDLE ExistingCompletionPort,  
                                              unsigned long* CompletionKey,        
                                              DWORD NumberOfConcurrentThreads) =0;


int (WINAPI *g_pufnNtQueryInformationThread) (HANDLE ThreadHandle,
                                              THREADINFOCLASS ThreadInformationClass,
                                              PVOID ThreadInformation,
                                              ULONG ThreadInformationLength,
                                              PULONG ReturnLength) =0;

int (WINAPI * g_pufnNtQuerySystemInformation) ( SYSTEM_INFORMATION_CLASS SystemInformationClass,
                                                PVOID SystemInformation,
                                                ULONG SystemInformationLength,
                                                PULONG ReturnLength OPTIONAL) =0;

int (WINAPI * g_pufnNtQueryEvent) ( HANDLE EventHandle,
									EVENT_INFORMATION_CLASS EventInformationClass,
									PVOID EventInformation,
									ULONG EventInformationLength,
									PULONG ReturnLength OPTIONAL) =0;

BOOL (WINAPI *g_pufnInitCritSectionSpin) ( LPCRITICAL_SECTION lpCriticalSection, 
                                           DWORD dwSpinCount) =0;

BOOL DoubleWordSwapAvailable = FALSE;

#define SPIN_COUNT 4000

#define INVALID_HANDLE ((HANDLE) -1)
#define NEW_THREAD_THRESHOLD            7       // Number of requests outstanding before we start a new thread

long ThreadpoolMgr::BeginInitialization=0;				
BOOL ThreadpoolMgr::Initialized=0; // indicator of whether the threadpool is initialized.
int ThreadpoolMgr::NumWorkerThreads=0;          // total number of worker threads created
int ThreadpoolMgr::MinLimitTotalWorkerThreads;              // = MaxLimitCPThreadsPerCPU * number of CPUS
int ThreadpoolMgr::MaxLimitTotalWorkerThreads;              // = MaxLimitCPThreadsPerCPU * number of CPUS
int ThreadpoolMgr::NumRunningWorkerThreads=0;   // = NumberOfWorkerThreads - no. of blocked threads
int ThreadpoolMgr::NumIdleWorkerThreads=0;
int ThreadpoolMgr::NumQueuedWorkRequests=0;     // number of queued work requests
int ThreadpoolMgr::LastRecordedQueueLength;	    // captured by GateThread, used on Win9x to detect thread starvation 
unsigned int ThreadpoolMgr::LastDequeueTime;	// used to determine if work items are getting thread starved 
unsigned int ThreadpoolMgr::LastCompletionTime;	// used to determine if io completions are getting thread starved 
BOOL ThreadpoolMgr::MonitorWorkRequestsQueue=0; // if 1, the gate thread monitors progress of WorkRequestQueue to prevent starvation due to blocked worker threads


WorkRequest* ThreadpoolMgr::WorkRequestHead=NULL;        // Head of work request queue
WorkRequest* ThreadpoolMgr::WorkRequestTail=NULL;        // Head of work request queue

//unsigned int ThreadpoolMgr::LastCpuSamplingTime=0;	//  last time cpu utilization was sampled by gate thread
unsigned int ThreadpoolMgr::LastWorkerThreadCreation=0;	//  last time a worker thread was created
unsigned int ThreadpoolMgr::LastCPThreadCreation=0;		//  last time a completion port thread was created
unsigned int ThreadpoolMgr::NumberOfProcessors; // = NumberOfWorkerThreads - no. of blocked threads


CRITICAL_SECTION ThreadpoolMgr::WorkerCriticalSection;
HANDLE ThreadpoolMgr::WorkRequestNotification;
HANDLE ThreadpoolMgr::RetiredWakeupEvent;


CRITICAL_SECTION ThreadpoolMgr::WaitThreadsCriticalSection;
ThreadpoolMgr::LIST_ENTRY ThreadpoolMgr::WaitThreadsHead;

CRITICAL_SECTION ThreadpoolMgr::EventCacheCriticalSection;
ThreadpoolMgr::LIST_ENTRY ThreadpoolMgr::EventCache;                       // queue of cached events
DWORD ThreadpoolMgr::NumUnusedEvents=0;                                    // number of events in cache

CRITICAL_SECTION ThreadpoolMgr::TimerQueueCriticalSection;
ThreadpoolMgr::LIST_ENTRY ThreadpoolMgr::TimerQueue;                       // queue of timers
DWORD ThreadpoolMgr::NumTimers=0;                                          // number of timers in timer queue
HANDLE ThreadpoolMgr::TimerThread=NULL;
DWORD ThreadpoolMgr::LastTickCount;                                                                            

BOOL ThreadpoolMgr::InitCompletionPortThreadpool = FALSE;
HANDLE ThreadpoolMgr::GlobalCompletionPort;                 // used for binding io completions on file handles
int   ThreadpoolMgr::NumCPThreads;                          // number of completion port threads
long  ThreadpoolMgr::MaxLimitTotalCPThreads = 1000;                // = MaxLimitCPThreadsPerCPU * number of CPUS
long  ThreadpoolMgr::CurrentLimitTotalCPThreads;            // current limit on total number of CP threads
long  ThreadpoolMgr::MinLimitTotalCPThreads;                // = MinLimitCPThreadsPerCPU * number of CPUS
int   ThreadpoolMgr::NumFreeCPThreads;                      // number of cp threads waiting on the port
int   ThreadpoolMgr::MaxFreeCPThreads;                      // = MaxFreeCPThreadsPerCPU * Number of CPUS
int   ThreadpoolMgr::NumRetiredCPThreads;
long  ThreadpoolMgr::GateThreadCreated=0;                   // Set to 1 after the thread is created
long  ThreadpoolMgr::cpuUtilization=0;
	
unsigned ThreadpoolMgr::MaxCachedRecyledLists=40;			// don't cache freed memory after this (40 is arbitrary)
ThreadpoolMgr::RecycledListInfo ThreadpoolMgr::RecycledList[ThreadpoolMgr::MEMTYPE_COUNT];

LPVOID  __fastcall FastDoubleWordSwap(BYTE* swapLocation); // forward declaration



// Macros for inserting/deleting from doubly linked list

#define InitializeListHead(ListHead) (\
    (ListHead)->Flink = (ListHead)->Blink = (ListHead))

#define RemoveHeadList(ListHead,FirstEntry) \
    {\
    FirstEntry = (LIST_ENTRY*) (ListHead)->Flink;\
    ((LIST_ENTRY*)FirstEntry->Flink)->Blink = (ListHead);\
    (ListHead)->Flink = FirstEntry->Flink;\
    }

#define RemoveEntryList(Entry) {\
    LIST_ENTRY* _EX_Entry;\
        _EX_Entry = (Entry);\
        ((LIST_ENTRY*) _EX_Entry->Blink)->Flink = _EX_Entry->Flink;\
        ((LIST_ENTRY*) _EX_Entry->Flink)->Blink = _EX_Entry->Blink;\
    }

#define InsertTailList(ListHead,Entry) \
    (Entry)->Flink = (ListHead);\
    (Entry)->Blink = (ListHead)->Blink;\
    ((LIST_ENTRY*)(ListHead)->Blink)->Flink = (Entry);\
    (ListHead)->Blink = (Entry);

#define InsertHeadList(ListHead,Entry) {\
    LIST_ENTRY* _EX_Flink;\
    LIST_ENTRY* _EX_ListHead;\
    _EX_ListHead = (LIST_ENTRY*)(ListHead);\
    _EX_Flink = (LIST_ENTRY*) _EX_ListHead->Flink;\
    (Entry)->Flink = _EX_Flink;\
    (Entry)->Blink = _EX_ListHead;\
    _EX_Flink->Blink = (Entry);\
    _EX_ListHead->Flink = (Entry);\
    }

#define IsListEmpty(ListHead) \
    ((ListHead)->Flink == (ListHead))
/************************************************************************/
void ThreadpoolMgr::EnsureInitialized()
{
	if (Initialized)
		return;
	
	if (InterlockedCompareExchange(&BeginInitialization, 1, 0) == 0)
	{
		Initialize();
		Initialized = TRUE;
	}
	else // someone has already begun initializing. 
	{
		// just wait until it finishes
		while (!Initialized)
			::SwitchToThread();
	}
}
//#define PRIVATE_BUILD 

void ThreadpoolMgr::Initialize()
{
    NumberOfProcessors = GetCurrentProcessCpuCount(); 
	InitPlatformVariables();

#ifndef PLATFORM_CE
	if (g_pufnInitCritSectionSpin)
	{
		(*g_pufnInitCritSectionSpin) (&WorkerCriticalSection,      SPIN_COUNT);
		(*g_pufnInitCritSectionSpin) (&WaitThreadsCriticalSection, SPIN_COUNT);
		(*g_pufnInitCritSectionSpin) (&EventCacheCriticalSection,  SPIN_COUNT);
		(*g_pufnInitCritSectionSpin) (&TimerQueueCriticalSection,  SPIN_COUNT);
	}
	else
	{
		InitializeCriticalSection( &WorkerCriticalSection );
		InitializeCriticalSection( &WaitThreadsCriticalSection );
		InitializeCriticalSection( &EventCacheCriticalSection );
		InitializeCriticalSection( &TimerQueueCriticalSection );
	}

    // initialize WaitThreadsHead
    WaitThreadsHead.Flink = &WaitThreadsHead;
    WaitThreadsHead.Blink = &WaitThreadsHead;

    // initialize EventCache
    EventCache.Flink = &EventCache;
    EventCache.Blink = &EventCache;


    // initialize TimerQueue
    TimerQueue.Flink = &TimerQueue;
    TimerQueue.Blink = &TimerQueue;

    WorkRequestNotification = WszCreateEvent(NULL, // security attributes
                                          TRUE, // manual reset
                                          FALSE, // initial state
                                          NULL);
    _ASSERTE(WorkRequestNotification != NULL);
    if (!WorkRequestNotification) 
    {
        FailFast(GetThread(), FatalOutOfMemory);
    }

    RetiredWakeupEvent = WszCreateEvent(NULL, // security attributes
                                          FALSE, // auto reset
                                          FALSE, // initial state
                                          NULL);
    _ASSERTE(RetiredWakeupEvent != NULL);
    if (!RetiredWakeupEvent) 
    {
        FailFast(GetThread(), FatalOutOfMemory);
    }

    // initialize Worker and CP thread settings
#ifdef _DEBUG
    MaxLimitTotalCPThreads = EEConfig::GetConfigDWORD(L"MaxThreadpoolThreads",MaxLimitTotalCPThreads);
#endif
    MinLimitTotalCPThreads = NumberOfProcessors; // > 1 ? NumberOfProcessors : 2;
    MinLimitTotalWorkerThreads = NumberOfProcessors;
    MaxLimitTotalWorkerThreads = NumberOfProcessors*MaxLimitThreadsPerCPU;

#ifdef PRIVATE_BUILD
	MinLimitTotalCPThreads = EEConfig::GetConfigDWORD(L"MinWorkerThreads", NumberOfProcessors );
	MinLimitTotalWorkerThreads = MinLimitTotalCPThreads;
#endif 

    CurrentLimitTotalCPThreads = 0;

    MaxFreeCPThreads = NumberOfProcessors*MaxFreeCPThreadsPerCPU;
    NumCPThreads = 0;
    NumFreeCPThreads = 0;
    NumRetiredCPThreads = 0;
    LastCompletionTime = GetTickCount();

	// initialize recyleLists
	for (unsigned i = 0; i < MEMTYPE_COUNT; i++)
	{
		RecycledList[i].root   = NULL;
        RecycledList[i].tag    = 0;
        RecycledList[i].count  = 0;
	}
    MaxCachedRecyledLists *= NumberOfProcessors;

    if (g_pufnCreateIoCompletionPort != NULL)
    {
        GlobalCompletionPort = (*g_pufnCreateIoCompletionPort)(INVALID_HANDLE_VALUE,
                                                      NULL,
                                                      0,        /*ignored for invalid handle value*/
                                                      0);
    }
#endif // !PLATFORM_CE
}


#ifdef SHOULD_WE_CLEANUP
void ThreadpoolMgr::Terminate()
{
	if (!Initialized)
		return;

#ifndef PLATFORM_CE
    DeleteCriticalSection( &WorkerCriticalSection );
    DeleteCriticalSection( &WaitThreadsCriticalSection );
    CleanupEventCache();
    DeleteCriticalSection( &EventCacheCriticalSection );
    CleanupTimerQueue();
    DeleteCriticalSection( &TimerQueueCriticalSection );
    
    // Kill off the WaitThreadInfos, ThreadCBs, and and WaitInfos we have
    PLIST_ENTRY  WTItodelete = (PLIST_ENTRY)WaitThreadsHead.Flink;
    PLIST_ENTRY WItodelete;
    PLIST_ENTRY temp, temp2;

    // Cycle through all the WaitThreadInfos
    while(WTItodelete != (PLIST_ENTRY)&WaitThreadsHead)
    {
        temp = WTItodelete->Flink;
        ThreadCB * tcb = ((WaitThreadInfo*)WTItodelete)->threadCB;

        // Now kill off all the WaitInfo's we have stored in the CB Threads
        for(int j=0; j<tcb->NumActiveWaits; j++)
        {
            WItodelete = (PLIST_ENTRY)(tcb->waitPointer[j].Flink);
            
            while(WItodelete != (PLIST_ENTRY)&(tcb->waitPointer[j]))
            {
                temp2 = WItodelete->Flink;
                DeleteWait((WaitInfo*) WItodelete);

                WItodelete = temp2;
            }
        }
        delete tcb;
        delete (WaitThreadInfo*) WTItodelete;
        WTItodelete = temp;
    }

    // And last but not least, let's get rid of the work requests
    // **NOTE: This should only be done during shutdown. If this destructor is
    // ever called during appdomain unloading, the following code should not be executed
    WorkRequest* wr = WorkRequestHead;
    WorkRequest* tmp;
    while (wr != NULL)
    {
        tmp = wr->next;
        if (wr->Function == ThreadpoolMgr::AsyncCallbackCompletion) {
            AsyncCallback *async = (AsyncCallback*) wr->Context;
            delete async;
        }
#if 0
        else if (wr->Function == QueueUserWorkItemCallback) {
            DelegateInfo *delegate = (DelegateInfo*) wr->Context;
            delete delegate;
        }
        else if (wr->Function == timerDeleteWorkItem) {
            TimerDeleteInfo *timer = (TimerDeleteInfo*) wr->Context;
            delete timer;
        }
        else {
            _ASSERTE (!"unknown Function");
        }
#endif
        delete wr;
        wr = tmp;
    }
	// delete the recycle lists

	wr = (WorkRequest*) RecycledList[MEMTYPE_WorkRequest].root;
	while (wr)
	{
		LPVOID tmp = *(LPVOID*) wr;
		delete wr;
		wr = (WorkRequest*) tmp;
	}

	DelegateInfo* di = (DelegateInfo*) RecycledList[MEMTYPE_DelegateInfo].root;
	while (di)
	{
		LPVOID tmp = *(LPVOID*) di;
		delete di;
		di = (DelegateInfo*) tmp;
	}

	AsyncCallback* acb = (AsyncCallback*) RecycledList[MEMTYPE_AsyncCallback].root;
	while (acb)
	{
		LPVOID tmp = *(LPVOID*) acb;
		delete acb;
		acb = (AsyncCallback*) tmp;
	}

#endif // !PLATFORM_CE
}
#endif /* SHOULD_WE_CLEANUP */


void ThreadpoolMgr::InitPlatformVariables()
{


#ifdef PLATFORM_WIN32

    HINSTANCE  hInst = WszLoadLibrary(L"kernel32.dll"); 

#else // !PLATFORM_WIN32
    
    ASSERT("NYI for this platform");

#endif // !PLATFORM_WIN32

    _ASSERTE(hInst);

	g_pufnCreateIoCompletionPort = (HANDLE (WINAPI*) (HANDLE FileHandle,
														HANDLE ExistingCompletionPort,  
														unsigned long* CompletionKey,        
														DWORD NumberOfConcurrentThreads))
									GetProcAddress(hInst,"CreateIoCompletionPort");

	if (RunningOnWinNT())
	{
		HINSTANCE  hInst2 = WszLoadLibrary(L"ntdll.dll");
		_ASSERTE(hInst2);

		g_pufnNtQueryInformationThread = (int (WINAPI *)(HANDLE ThreadHandle,
													  THREADINFOCLASS ThreadInformationClass,
													  PVOID ThreadInformation,
													  ULONG ThreadInformationLength,
													  PULONG ReturnLength))
									GetProcAddress(hInst2,"NtQueryInformationThread");

		g_pufnNtQuerySystemInformation = (int (WINAPI *) ( SYSTEM_INFORMATION_CLASS SystemInformationClass,
														   PVOID SystemInformation,
														   ULONG SystemInformationLength,
														   PULONG ReturnLength OPTIONAL))
									GetProcAddress(hInst2,"NtQuerySystemInformation");

		g_pufnNtQueryEvent = (int (WINAPI *) (  HANDLE EventHandle,
												EVENT_INFORMATION_CLASS EventInformationClass,
												PVOID EventInformation,
												ULONG EventInformationLength,
												PULONG ReturnLength OPTIONAL))
									GetProcAddress(hInst2,"NtQueryEvent");

		g_pufnInitCritSectionSpin = (BOOL (WINAPI *) ( LPCRITICAL_SECTION lpCriticalSection, 
                                                       DWORD dwSpinCount))
									GetProcAddress(hInst,"InitializeCriticalSectionAndSpinCount");

        DoubleWordSwapAvailable = ProcessorFeatures::SafeIsProcessorFeaturePresent(PF_COMPARE_EXCHANGE_DOUBLE,FALSE);
	}
#ifdef _X86_
	if (NumberOfProcessors !=1)
	{
		DWORD oldProt;
		if (!VirtualProtect((void *) FastDoubleWordSwap,
                    (((DWORD)(size_t)FastDoubleWordSwap + 0x18) - (DWORD)(size_t)FastDoubleWordSwap),
                    PAGE_EXECUTE_READWRITE, &oldProt))
        {
            _ASSERTE(!"VirtualProtect of code page failed");
        }
				// patch the lock prefix
		BYTE* loc = (BYTE*)(&FastDoubleWordSwap) + 0x12;
        _ASSERTE(*loc == 0x90); 
        *loc = 0xF0;

		if (!VirtualProtect((void *) FastDoubleWordSwap,
                            (((DWORD)(size_t)FastDoubleWordSwap + 0x18) - (DWORD)(size_t)FastDoubleWordSwap), oldProt, &oldProt))
        {
            _ASSERTE(!"VirtualProtect of code page failed");
        }
	}
#endif
}


BOOL ThreadpoolMgr::SetMaxThreadsHelper(DWORD MaxWorkerThreads,
                                        DWORD MaxIOCompletionThreads)
{
       BOOL result;

        // doesn't need to be WorkerCS, but using it to avoid race condition between setting min and max, and didn't want to create a new CS.
        EnterCriticalSection (&WorkerCriticalSection);
        
        if (MaxWorkerThreads >= (DWORD) NumWorkerThreads &&     // these first two conditions are not guaranteed, but don't hurt so leaving as-is. rmm
           MaxIOCompletionThreads >= (DWORD) NumCPThreads &&
           MaxWorkerThreads >= (DWORD)MinLimitTotalWorkerThreads &&
           MaxIOCompletionThreads >= (DWORD)MinLimitTotalCPThreads)
        {
            MaxLimitTotalWorkerThreads = MaxWorkerThreads;
            MaxLimitTotalCPThreads     = MaxIOCompletionThreads;
            result = TRUE;
        }
        else
        {
            result = FALSE;
        }

        LeaveCriticalSection(&WorkerCriticalSection);

        return result;
 }


/************************************************************************/
BOOL ThreadpoolMgr::SetMaxThreads(DWORD MaxWorkerThreads, 
                                     DWORD MaxIOCompletionThreads)
{

    if (Initialized)
    {
        return SetMaxThreadsHelper(MaxWorkerThreads, MaxIOCompletionThreads);
    }

	if (InterlockedCompareExchange(&BeginInitialization, 1, 0) == 0)
	{
		Initialize();

        BOOL result;
        result = SetMaxThreadsHelper(MaxWorkerThreads, MaxIOCompletionThreads);
        
		Initialized = TRUE;

        return result;
	}
    else // someone else is initializing. Too late, return false
    {
        return FALSE;
    }

}

BOOL ThreadpoolMgr::GetMaxThreads(DWORD* MaxWorkerThreads, 
                                     DWORD* MaxIOCompletionThreads)
{
    if (Initialized)
    {
        *MaxWorkerThreads = MaxLimitTotalWorkerThreads;
        *MaxIOCompletionThreads = MaxLimitTotalCPThreads;
    }
    else
    {
        NumberOfProcessors = GetCurrentProcessCpuCount(); 
        *MaxWorkerThreads = NumberOfProcessors*MaxLimitThreadsPerCPU;
        *MaxIOCompletionThreads = MaxLimitTotalCPThreads;
    }
    return TRUE;
}
    
BOOL ThreadpoolMgr::SetMinThreads(DWORD MinWorkerThreads, 
                                     DWORD MinIOCompletionThreads)
{
    if (!Initialized)
    {
        if (InterlockedCompareExchange(&BeginInitialization, 1, 0) == 0)
        {
            Initialize();
            Initialized = TRUE;
        }
    }

    if (Initialized)
    {
        // doesn't need to be WorkerCS, but using it to avoid race condition between setting min and max, and didn't want to create a new CS.
        EnterCriticalSection (&WorkerCriticalSection);

        BOOL result;

        if (MinWorkerThreads >= 0 && MinIOCompletionThreads >= 0 &&
            MinWorkerThreads <= (DWORD) MaxLimitTotalWorkerThreads &&
            MinIOCompletionThreads <= (DWORD) MaxLimitTotalCPThreads)
        {
            MinLimitTotalWorkerThreads = MinWorkerThreads;
            MinLimitTotalCPThreads     = MinIOCompletionThreads;
            result = TRUE;
        }
        else
        {
            result = FALSE;
        }
        LeaveCriticalSection (&WorkerCriticalSection);
        return result;
    }
    // someone else is initializing. Too late, return false
    return FALSE;

}

BOOL ThreadpoolMgr::GetMinThreads(DWORD* MinWorkerThreads, 
                                     DWORD* MinIOCompletionThreads)
{
    if (Initialized)
    {
        *MinWorkerThreads = MinLimitTotalWorkerThreads;
        *MinIOCompletionThreads = MinLimitTotalCPThreads;
    }
    else
    {
        NumberOfProcessors = GetCurrentProcessCpuCount(); 
        *MinWorkerThreads = NumberOfProcessors;
        *MinIOCompletionThreads = NumberOfProcessors;
    }
    return TRUE;
}

BOOL ThreadpoolMgr::GetAvailableThreads(DWORD* AvailableWorkerThreads, 
                                        DWORD* AvailableIOCompletionThreads)
{
    if (Initialized)
    {
        *AvailableWorkerThreads = (MaxLimitTotalWorkerThreads - NumWorkerThreads)  /*threads yet to be created */
                                   + NumIdleWorkerThreads;
        *AvailableIOCompletionThreads = (MaxLimitTotalCPThreads - NumCPThreads) /*threads yet to be created */
                                   + NumFreeCPThreads;
    }
    else
    {
        GetMaxThreads(AvailableWorkerThreads,AvailableIOCompletionThreads);
    }
    return TRUE;
}


/************************************************************************/

BOOL ThreadpoolMgr::QueueUserWorkItem(LPTHREAD_START_ROUTINE Function, 
                                      PVOID Context,
                                      DWORD Flags)
{
#ifdef PLATFORM_CE
    ::SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return FALSE;
#else // !PLATFORM_CE

	EnsureInitialized();

    BOOL status;
    BOOL bEnqueueSuccess = FALSE;

    	

    if (Flags == CALL_OR_QUEUE)
    {
        // we've been asked to call this directly if the thread pressure is not too high

        int MinimumAvailableCPThreads = (NumberOfProcessors < 3) ? 3 : NumberOfProcessors;
        // It would be nice to assert that this is a completion port thread, but
        // there is no easy way to do that. 
        if ((MaxLimitTotalCPThreads - NumCPThreads) >= MinimumAvailableCPThreads )
        {
            __try 
            {
		        LOG((LF_THREADPOOL ,LL_INFO100 ,"Calling work request (Function= %x, Context = %x)\n", Function, Context));

                (Function)(Context);

		        LOG((LF_THREADPOOL ,LL_INFO100 ,"Returned from work request (Function= %x, Context = %x)\n", Function, Context));
                
            }
            __except(COMPLUS_EXCEPTION_EXECUTE_HANDLER)
            {
		        LOG((LF_THREADPOOL ,LL_INFO100 ,"Unhandled exception from work request (Function= %x, Context = %x)\n", Function, Context));
            }
            return TRUE;
        }
        
    }

    LOCKCOUNTINCL("QueueUserWorkItem in win32ThreadPool.h");                        
    EnterCriticalSection (&WorkerCriticalSection) ;

    status = EnqueueWorkRequest(Function, Context);

    if (status)
    {
        _ASSERTE(NumQueuedWorkRequests > 0);

    	bEnqueueSuccess = TRUE;
    	
        // see if we need to grow the worker thread pool, but don't bother if GC is in progress
        if (ShouldGrowWorkerThreadPool() &&
            !(g_pGCHeap->IsGCInProgress()
#ifdef _DEBUG
#ifdef STRESS_HEAP
              && g_pConfig->GetGCStressLevel() == 0
#endif
#endif
              ))
        {
            status = CreateWorkerThread();
        }
        else
        // else we did not grow the worker pool, so make sure there is a gate thread
        // that monitors the WorkRequest queue and spawns new threads if no progress is
        // being made
        {
            if (!GateThreadCreated)
                CreateGateThread();
            MonitorWorkRequestsQueue = 1;
        }
    }


    LeaveCriticalSection (&WorkerCriticalSection) ;
    if (bEnqueueSuccess)
        SetEvent(WorkRequestNotification);
    LOCKCOUNTDECL("QueueUserWorkItem in win32ThreadPool.h");                        

    return status;
#endif // !PLATFORM_CE
}

#ifndef PLATFORM_CE

//************************************************************************
BOOL ThreadpoolMgr::EnqueueWorkRequest(LPTHREAD_START_ROUTINE Function, 
                                       PVOID Context)
{
    WorkRequest* workRequest = MakeWorkRequest(Function, Context);
    if (workRequest == NULL)
        return FALSE;
	LOG((LF_THREADPOOL ,LL_INFO100 ,"Enqueue work request (Function= %x, Context = %x)\n", Function, Context));
    AppendWorkRequest(workRequest);
    return TRUE;
}

WorkRequest* ThreadpoolMgr::DequeueWorkRequest()
{
    WorkRequest* entry = RemoveWorkRequest();
    if (NumQueuedWorkRequests == 0)
        ResetEvent(WorkRequestNotification);
	if (entry)
	{
		LastDequeueTime = GetTickCount();
#ifdef _DEBUG
		LOG((LF_THREADPOOL ,LL_INFO100 ,"Dequeue work request (Function= %x, Context = %x)\n", entry->Function, entry->Context));
#endif
	}
    return entry;
}

void ThreadpoolMgr::ExecuteWorkRequest(WorkRequest* workRequest)
{
    LPTHREAD_START_ROUTINE wrFunction = workRequest->Function;
    LPVOID                 wrContext  = workRequest->Context;

    __try 
    {
        // First delete the workRequest then call the function to 
        // prevent leaks in apps that call functions that never return

		LOG((LF_THREADPOOL ,LL_INFO100 ,"Starting work request (Function= %x, Context = %x)\n", wrFunction, wrContext));

        RecycleMemory((LPVOID*)workRequest, MEMTYPE_WorkRequest); //delete workRequest;
        (wrFunction)(wrContext);

		LOG((LF_THREADPOOL ,LL_INFO100 ,"Finished work request (Function= %x, Context = %x)\n", wrFunction, wrContext));
    }
    __except(COMPLUS_EXCEPTION_EXECUTE_HANDLER)
    {
		LOG((LF_THREADPOOL ,LL_INFO100 ,"Unhandled exception from work request (Function= %x, Context = %x)\n", wrFunction, wrContext));
        //_ASSERTE(!"FALSE");
    }
}

#ifdef _X86_
LPVOID __declspec(naked) __fastcall FastDoubleWordSwap(BYTE* swapLocation)
{
	_asm {
			push edi		// callee saved registers
			push ebx
			mov	edi, ecx
tryAgain:	mov	eax, dword ptr[edi]
			test eax, eax
			jz	failed
			mov edx, dword ptr[edi+4]
			mov	ebx, dword ptr [eax]
			mov ecx, edx 
			inc	ecx
			nop
			cmpxchg8b qword ptr[edi]
			jnz		tryAgain
failed:		pop		ebx
			pop		edi
			ret
	}
}
#endif

// Remove a block from the appropriate recycleList and return.
// If recycleList is empty, fall back to new.
LPVOID ThreadpoolMgr::GetRecycledMemory(enum MemType memType)
{
#ifdef _X86_
	if (DoubleWordSwapAvailable)
	{
		BYTE* swapLocation = (BYTE*) &(RecycledList[memType].root);
		LPVOID result = FastDoubleWordSwap(swapLocation);
		
		if (result)
		{
			RecycledList[memType].count--;
			return result;
		}
		// else we failed, make sure the count is zero and fall back to new
		RecycledList[memType].count = 0;
    }
#endif
    switch (memType)
    {
        case MEMTYPE_DelegateInfo: 
            return new DelegateInfo;
        case MEMTYPE_AsyncCallback:
            return new AsyncCallback;
        case MEMTYPE_WorkRequest:
            return new WorkRequest;
        default:
            _ASSERTE(!"Unknown Memtype");
            return 0;
	}
}

// Insert freed block in recycle list. If list is full, return to system heap
void ThreadpoolMgr::RecycleMemory(LPVOID* mem, enum MemType memType)
{
	if (DoubleWordSwapAvailable)
	{
		while (RecycledList[memType].count < MaxCachedRecyledLists)
		{
			void* originalValue = RecycledList[memType].root;
			*mem = RecycledList[memType].root;
#ifdef _WIN64
            if (InterlockedCompareExchange((void**)&(RecycledList[memType].root), 
						                   (void*)mem, 
											originalValue)  == originalValue)
#else // !_WIN64
			if (FastInterlockCompareExchange((void**)&(RecycledList[memType].root), 
						                     (void*)mem, 
											 originalValue) == originalValue)
#endif // _WIN64

			{
				RecycledList[memType].count++;
				return;
			}

		}
	}

    switch (memType)
    {
        case MEMTYPE_DelegateInfo: 
            delete (DelegateInfo*) mem;
            break;
        case MEMTYPE_AsyncCallback:
            delete (AsyncCallback*) mem;
            break;
        case MEMTYPE_WorkRequest:
            delete (WorkRequest*) mem;
            break;
        default:
            _ASSERTE(!"Unknown Memtype");

    }
}

//************************************************************************


BOOL ThreadpoolMgr::ShouldGrowWorkerThreadPool()
{
    // we only want to grow the worker thread pool if there are less than n threads, where n= no. of processors
    // and more requests than the number of idle threads and GC is not in progress
    return (NumRunningWorkerThreads < MinLimitTotalWorkerThreads&& //(int) NumberOfProcessors &&
            NumIdleWorkerThreads < NumQueuedWorkRequests &&
            NumWorkerThreads < MaxLimitTotalWorkerThreads); 

}

/* If threadId is the id of a worker thread, reduce the number of running worker threads,
   grow the threadpool if necessary, and return TRUE. Otherwise do nothing and return false*/
BOOL  ThreadpoolMgr::ThreadAboutToBlock(Thread* pThread)
{
    BOOL isWorkerThread = pThread->IsWorkerThread();

    if (isWorkerThread)
    {
        LOCKCOUNTINCL("ThreadAboutToBlock in win32ThreadPool.h");                       \
		LOG((LF_THREADPOOL ,LL_INFO1000 ,"Thread about to block\n"));
    
        EnterCriticalSection (&WorkerCriticalSection) ;

        _ASSERTE(NumRunningWorkerThreads > 0);
        NumRunningWorkerThreads--;
        if (ShouldGrowWorkerThreadPool())
        {
            DWORD status = CreateWorkerThread();
        }
        LeaveCriticalSection(&WorkerCriticalSection) ;

        LOCKCOUNTDECL("ThreadAboutToBlock in win32ThreadPool.h");
    }
    
    return isWorkerThread;

}

/* Must be balanced by a previous call to ThreadAboutToBlock that returned TRUE*/
void ThreadpoolMgr::ThreadAboutToUnblock()
{
    LOCKCOUNTINCL("ThreadAboutToUnBlock in win32ThreadPool.h");  \
    EnterCriticalSection (&WorkerCriticalSection) ;
    _ASSERTE(NumRunningWorkerThreads < NumWorkerThreads);
    NumRunningWorkerThreads++;
    LeaveCriticalSection(&WorkerCriticalSection) ;
    LOCKCOUNTDECL("ThreadAboutToUnBlock in win32ThreadPool.h"); \
	LOG((LF_THREADPOOL ,LL_INFO1000 ,"Thread unblocked\n"));

}

#define THROTTLE_RATE  0.10 /* rate by which we increase the delay as number of threads increase */

// This is a heuristic: if the cpu utilization is low and the number of worker
// requests > 0, the running threads have blocked (outside the runtime). 
// Similarly if the cpu utilization is very high and the number of worker 
// requests>0, the running threads are blocked on infinite computations.  
// In the first cases add another worker thread. Second case...?
// 
void ThreadpoolMgr::GrowWorkerThreadPoolIfStarvation(long cpuUtilization)
{
    if (NumQueuedWorkRequests == 0 || 
        NumWorkerThreads == MaxLimitTotalWorkerThreads)
        return;
    	
    
	if (cpuUtilization > CpuUtilizationLow)
	{
		unsigned curTime = GetTickCount();
		if (!SufficientDelaySinceLastDequeue() ||
			!SufficientDelaySinceLastSample(LastWorkerThreadCreation,NumWorkerThreads, THROTTLE_RATE))
			return;
	}

    // else cpuUtilization is low or workitems are getting starved  
	// also, we have queued work items, and we haven't
    // hit the upper limit on the number of worker threads
    LOCKCOUNTINCL("GrowWorkerThreadPoolIfStarvation in win32ThreadPool.h");                     \
    EnterCriticalSection (&WorkerCriticalSection) ;
    if (((NumQueuedWorkRequests > 0) || (NumWorkerThreads < MaxLimitTotalWorkerThreads)) &&
		 (NumIdleWorkerThreads == 0))
        CreateWorkerThread();
    LeaveCriticalSection(&WorkerCriticalSection) ;
    LOCKCOUNTDECL("GrowWorkerThreadPoolIfStarvation in win32ThreadPool.h");                     \

}

// On Win9x, there are no apis to get cpu utilization, so we fall back on 
// other heuristics
void ThreadpoolMgr::GrowWorkerThreadPoolIfStarvation_Win9x()
{

	if (NumQueuedWorkRequests == 0 ||
        NumWorkerThreads == MaxLimitTotalWorkerThreads)
        return;

	int  lastQueueLength = LastRecordedQueueLength;
	LastRecordedQueueLength = NumQueuedWorkRequests;

	// else, we have queued work items, and we haven't
	// hit the upper limit on the number of worker threads

	// if the queue length has decreased since our last time
	// or not enough delay since we last created a worker thread
	if ((NumQueuedWorkRequests < lastQueueLength) ||
		!SufficientDelaySinceLastSample(LastWorkerThreadCreation,NumWorkerThreads, THROTTLE_RATE))
		return;


	LOCKCOUNTINCL("GrowWorkerThreadPoolIfStarvation in win32ThreadPool.h");						\
	EnterCriticalSection (&WorkerCriticalSection) ;
	if ((NumQueuedWorkRequests >= lastQueueLength) && (NumWorkerThreads < MaxLimitTotalWorkerThreads))
		CreateWorkerThread();
	LeaveCriticalSection(&WorkerCriticalSection) ;
	LOCKCOUNTDECL("GrowWorkerThreadPoolIfStarvation in win32ThreadPool.h");						\

}

HANDLE ThreadpoolMgr::CreateUnimpersonatedThread(LPTHREAD_START_ROUTINE lpStartAddress, LPVOID lpArgs)
{
	DWORD threadId;
	HANDLE token;
	HANDLE threadHandle = NULL;

	if (RunningOnWinNT() && 
		OpenThreadToken(GetCurrentThread(),	// we are assuming that if this call fails, 
                        TOKEN_IMPERSONATE,     // we are not impersonating. There is no win32
                        TRUE,					// api to figure this out. The only alternative 
                        &token))				// is to use NtCurrentTeb->IsImpersonating().
	{
		BOOL reverted = RevertToSelf();
		_ASSERTE(reverted);
		if (reverted)
		{
			threadHandle = CreateThread(NULL,                // security descriptor
										0,                   // default stack size
										lpStartAddress,       
										lpArgs,     // arguments
										CREATE_SUSPENDED,    // start immediately
										&threadId);

			SetThreadToken(NULL, token);
		}

		CloseHandle(token);
		return threadHandle;
	}

	// else, either we are on Win9x or we are not impersonating, so just create the thread

	return CreateThread(NULL,                // security descriptor
                        0,                   // default stack size
                        lpStartAddress,   // 
                        lpArgs,                //arguments
                        CREATE_SUSPENDED,    // start immediately
                        &threadId);

}

BOOL ThreadpoolMgr::CreateWorkerThread()
{
    HANDLE threadHandle = CreateUnimpersonatedThread(WorkerThreadStart, NULL);

    if (threadHandle)
    {
		LastWorkerThreadCreation = GetTickCount();	// record this for use by logic to spawn additional threads

        _ASSERTE(NumWorkerThreads >= NumRunningWorkerThreads);
        NumRunningWorkerThreads++;
        NumWorkerThreads++;
        NumIdleWorkerThreads++;
		LOG((LF_THREADPOOL ,LL_INFO100 ,"Worker thread created (NumWorkerThreads=%d\n)",NumWorkerThreads));


        DWORD status = ResumeThread(threadHandle);
        _ASSERTE(status != (DWORD) (-1));
        CloseHandle(threadHandle);          // we don't need this anymore
    }
    // dont return failure if we have at least one running thread, since we can service the request 
    return (NumRunningWorkerThreads > 0);
}

#pragma warning(disable:4702)
DWORD  ThreadpoolMgr::WorkerThreadStart(LPVOID lpArgs)
{
    #define IDLE_WORKER_TIMEOUT (40*1000) // milliseonds
    #define NOWORK_TIMEOUT (10*1000) // milliseonds    
    
    DWORD SleepTime = IDLE_WORKER_TIMEOUT;

    unsigned int LastThreadDequeueTime = GetTickCount();

    LOG((LF_THREADPOOL ,LL_INFO1000 ,"Worker thread started\n"));

    CoInitializeEx(NULL, COINIT_MULTITHREADED);
    for (;;)
    {
        _ASSERTE(NumRunningWorkerThreads > 0);
        DWORD status = WaitForSingleObject(WorkRequestNotification,SleepTime);
        _ASSERTE(status == WAIT_TIMEOUT || status == WAIT_OBJECT_0);
        
        BOOL shouldTerminate = FALSE;

        if ( status == WAIT_TIMEOUT )
        {
        // The thread terminates if there are > 1 threads and the queue is small
        // OR if there is only 1 thread and there is no request pending
            if (NumWorkerThreads > 1)
            {
                ULONG Threshold = NEW_THREAD_THRESHOLD * (NumRunningWorkerThreads-1);


                if (NumQueuedWorkRequests < (int) Threshold)
                {
                    shouldTerminate = !IsIoPending(); // do not terminate if there is pending io on this thread
                }
                else
                {
                    SleepTime <<= 1 ;
                    SleepTime += 1000; // to prevent wraparound to 0
                }
            }   
            else // this is the only worker thread
            {
                if (NumQueuedWorkRequests == 0)
                {
                    // delay termination of last thread
                    if (SleepTime < 4*IDLE_WORKER_TIMEOUT) 
                    {
                        SleepTime <<= 1 ;
                        SleepTime += 1000; // to prevent wraparound to 0
                    }
                    else
                    {
                        shouldTerminate = !IsIoPending(); // do not terminate if there is pending io on this thread
                    }
                }
            }


            if (shouldTerminate)
            {   // recheck NumQueuedWorkRequest since a new one may have arrived while we are checking it
                LOCKCOUNTINCL("WorkerThreadStart in win32ThreadPool.h");                        \
                EnterCriticalSection (&WorkerCriticalSection) ;
                if (NumQueuedWorkRequests == 0)
                {   
                    // it really is zero, so terminate this thread
                    NumRunningWorkerThreads--;
                    NumWorkerThreads--;     // protected by WorkerCriticalSection
                    NumIdleWorkerThreads--; //   ditto
                    _ASSERTE(NumRunningWorkerThreads >= 0 && NumWorkerThreads >= 0 && NumIdleWorkerThreads >= 0);

                    LeaveCriticalSection(&WorkerCriticalSection);
                    LOCKCOUNTDECL("WorkerThreadStart in win32ThreadPool.h");                        \

					LOG((LF_THREADPOOL ,LL_INFO100 ,"Worker thread terminated (NumWorkerThreads=%d)\n",NumWorkerThreads));

                    CoUninitialize();
                    ExitThread(0);
                }
                else
                {
                    LeaveCriticalSection (&WorkerCriticalSection) ;
                    LOCKCOUNTDECL("WorkerThreadStart in win32ThreadPool.h");                        \

                    continue;
                }
            }
        }
        else
        {
            // woke up because of a new work request arrival
            WorkRequest* workRequest;
            LOCKCOUNTINCL("WorkerThreadStart in win32ThreadPool.h");                        \
            EnterCriticalSection (&WorkerCriticalSection) ;

            if ( ( workRequest = DequeueWorkRequest() ) != NULL)
            {
                _ASSERTE(NumIdleWorkerThreads > 0);
                NumIdleWorkerThreads--; // we found work, decrease the number of idle threads
            }

            // the dequeue operation also resets the WorkRequestNotification event

            LeaveCriticalSection(&WorkerCriticalSection);
            LOCKCOUNTDECL("WorkerThreadStart in win32ThreadPool.h");                        \

            if (!workRequest)
            {
                // we woke up, but there was no work
                if (GetTickCount() - LastThreadDequeueTime >= (NOWORK_TIMEOUT))
                {
                    // if we haven't done anything useful for a while, terminate
                    if (!IsIoPending())
                    {
                        LOCKCOUNTINCL("WorkerThreadStart in win32ThreadPool.h");                        \
                        EnterCriticalSection (&WorkerCriticalSection) ;
                        NumRunningWorkerThreads--;
                        NumWorkerThreads--;     // protected by WorkerCriticalSection
                        NumIdleWorkerThreads--; //   ditto
                        LeaveCriticalSection(&WorkerCriticalSection);
                        LOCKCOUNTDECL("WorkerThreadStart in win32ThreadPool.h");                        \
                        _ASSERTE(NumRunningWorkerThreads >= 0 && NumWorkerThreads >= 0 && NumIdleWorkerThreads >= 0);
                        LOG((LF_THREADPOOL ,LL_INFO100 ,"Worker thread terminated (NumWorkerThreads=%d)\n",NumWorkerThreads));
                        CoUninitialize();
                        ExitThread(0);
                    }
                }
            }

            while (workRequest)
            {
                ExecuteWorkRequest(workRequest);
                LastThreadDequeueTime = GetTickCount();

                LOCKCOUNTINCL("WorkerThreadStart in win32ThreadPool.h");                        \
                EnterCriticalSection (&WorkerCriticalSection) ;

                workRequest = DequeueWorkRequest();
                // the dequeue operation resets the WorkRequestNotification event

                if (workRequest == NULL)
                {
                    NumIdleWorkerThreads++; // no more work, increase the number of idle threads
                }

                LeaveCriticalSection(&WorkerCriticalSection);
                LOCKCOUNTDECL("WorkerThreadStart in win32ThreadPool.h");                        \

            }
        }

    } // for(;;)

    CoUninitialize();
    return 0;

}
#pragma warning(default:4702)

#endif // !PLATFORM_CE
/************************************************************************/

BOOL ThreadpoolMgr::RegisterWaitForSingleObject(PHANDLE phNewWaitObject,
                                                HANDLE hWaitObject,
                                                WAITORTIMERCALLBACK Callback,
                                                PVOID Context,
                                                ULONG timeout,
                                                DWORD dwFlag )
{
#ifdef PLATFORM_CE
    ::SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return FALSE;
#else // !PLATFORM_CE
	EnsureInitialized();

    LOCKCOUNTINCL("RegisterWaitForSingleObject in win32ThreadPool.h");                      \
    EnterCriticalSection(&WaitThreadsCriticalSection);

    ThreadCB* threadCB = FindWaitThread();
        
    LeaveCriticalSection(&WaitThreadsCriticalSection);
    LOCKCOUNTDECL("RegisterWaitForSingleObject in win32ThreadPool.h");                      \

    *phNewWaitObject = NULL;

    if (threadCB)
    {
        WaitInfo* waitInfo = new WaitInfo;
        
        if (waitInfo == NULL)
            return FALSE;

        waitInfo->waitHandle = hWaitObject;
        waitInfo->Callback = Callback;
        waitInfo->Context = Context;
        waitInfo->timeout = timeout;
        waitInfo->flag = dwFlag;
        waitInfo->threadCB = threadCB;
        waitInfo->state = 0;
		waitInfo->refCount = 1;     // safe to do this since no wait has yet been queued, so no other thread could be modifying this
        waitInfo->CompletionEvent = INVALID_HANDLE;
        waitInfo->PartialCompletionEvent = INVALID_HANDLE;

        waitInfo->timer.startTime = ::GetTickCount();
		waitInfo->timer.remainingTime = timeout;

        *phNewWaitObject = waitInfo;

		LOG((LF_THREADPOOL ,LL_INFO100 ,"Registering wait for handle %x, Callback=%x, Context=%x \n",
			                            hWaitObject, Callback, Context));

		QueueUserAPC((PAPCFUNC)InsertNewWaitForSelf, threadCB->threadHandle, (size_t) waitInfo);
        
        return TRUE;
    }
    return FALSE;
#endif // !PLATFORM_CE
}

#ifndef PLATFORM_CE
// Returns a wait thread that can accomodate another wait request. The 
// caller is responsible for synchronizing access to the WaitThreadsHead 
ThreadpoolMgr::ThreadCB* ThreadpoolMgr::FindWaitThread()
{
    do 
    {
        for (LIST_ENTRY* Node = (LIST_ENTRY*) WaitThreadsHead.Flink ; 
             Node != &WaitThreadsHead ; 
             Node = (LIST_ENTRY*)Node->Flink) 
        {
            _ASSERTE(offsetof(WaitThreadInfo,link) == 0);

            ThreadCB*  threadCB = ((WaitThreadInfo*) Node)->threadCB;
        
            if (threadCB->NumWaitHandles < MAX_WAITHANDLES)         // the test and
            {
                InterlockedIncrement((LPLONG) &threadCB->NumWaitHandles);       // increment are protected by WaitThreadsCriticalSection.
                                                                        // but there might be a concurrent decrement in DeactivateWait, hence the interlock
                return threadCB;
            }
        }

        // if reached here, there are no wait threads available, so need to create a new one
        if (!CreateWaitThread())
            return NULL;


        // Now loop back
    } while (TRUE);

}

BOOL ThreadpoolMgr::CreateWaitThread()
{
    DWORD threadId;

    WaitThreadInfo* waitThreadInfo = new WaitThreadInfo;
    if (waitThreadInfo == NULL)
        return FALSE;
        
    ThreadCB* threadCB = new ThreadCB;

    if (threadCB == NULL)
    {
        delete waitThreadInfo;
        return FALSE;
    }

    HANDLE threadHandle = CreateThread(NULL,                // security descriptor
                                       0,                   // default stack size
                                       WaitThreadStart,     // 
                                       (LPVOID) threadCB,   // thread control block is passed as argument
                                       CREATE_SUSPENDED,    // start immediately
                                       &threadId);

    if (threadHandle == NULL)
    {
        return FALSE;
    }

    threadCB->threadHandle = threadHandle;      
    threadCB->threadId = threadId;              // may be useful for debugging otherwise not used
    threadCB->NumWaitHandles = 0;
    threadCB->NumActiveWaits = 0;
    for (int i=0; i< MAX_WAITHANDLES; i++)
    {
        InitializeListHead(&(threadCB->waitPointer[i]));
    }

    waitThreadInfo->threadCB = threadCB;

    InsertHeadList(&WaitThreadsHead,&waitThreadInfo->link);

    DWORD status = ResumeThread(threadHandle);
    _ASSERTE(status != (DWORD) (-1));

	LOG((LF_THREADPOOL ,LL_INFO100 ,"Created wait thread \n"));

    return (status != (DWORD) (-1));

}

// Executed as an APC on a WaitThread. Add the wait specified in pArg to the list of objects it is waiting on
void ThreadpoolMgr::InsertNewWaitForSelf(WaitInfo* pArgs)
{
	WaitInfo* waitInfo = pArgs;

    // the following is safe since only this thread is allowed to change the state
    if (!(waitInfo->state & WAIT_DELETE))
    {
        waitInfo->state =  (WAIT_REGISTERED | WAIT_ACTIVE);
    }
    else 
    {
        // some thread unregistered the wait  
        DeleteWait(waitInfo);
        return;
    }

 
    ThreadCB* threadCB = waitInfo->threadCB;

    _ASSERTE(threadCB->NumActiveWaits < threadCB->NumWaitHandles);

    int index = FindWaitIndex(threadCB, waitInfo->waitHandle);
    _ASSERTE(index >= 0 && index <= threadCB->NumActiveWaits);

    if (index == threadCB->NumActiveWaits)
    {
        threadCB->waitHandle[threadCB->NumActiveWaits] = waitInfo->waitHandle;
        threadCB->NumActiveWaits++;
    }

    _ASSERTE(offsetof(WaitInfo, link) == 0);
    InsertTailList(&(threadCB->waitPointer[index]), (&waitInfo->link));
    
    return;
}

// returns the index of the entry that matches waitHandle or next free entry if not found
int ThreadpoolMgr::FindWaitIndex(const ThreadCB* threadCB, const HANDLE waitHandle)
{
	for (int i=0;i<threadCB->NumActiveWaits; i++)
		if (threadCB->waitHandle[i] == waitHandle)
			return i;

    // else not found
    return threadCB->NumActiveWaits;
}


// if no wraparound that the timer is expired if duetime is less than current time
// if wraparound occurred, then the timer expired if dueTime was greater than last time or dueTime is less equal to current time
#define TimeExpired(last,now,duetime) (last <= now ? \
                                       duetime <= now : \
                                       (duetime >= last || duetime <= now))

#define TimeInterval(end,start) ( end > start ? (end - start) : ((0xffffffff - start) + end + 1)   )

// Returns the minimum of the remaining time to reach a timeout among all the waits
DWORD ThreadpoolMgr::MinimumRemainingWait(LIST_ENTRY* waitInfo, unsigned int numWaits)
{
    unsigned int min = (unsigned int) -1;
    DWORD currentTime = ::GetTickCount();

    for (unsigned i=0; i < numWaits ; i++)
    {
        WaitInfo* waitInfoPtr = (WaitInfo*) (waitInfo[i].Flink);
        PVOID waitInfoHead = &(waitInfo[i]);
        do
        {
            if (waitInfoPtr->timeout != INFINITE)
            {
                // compute remaining time
                DWORD elapsedTime = TimeInterval(currentTime,waitInfoPtr->timer.startTime );

                __int64 remainingTime = (__int64) (waitInfoPtr->timeout) - (__int64) elapsedTime;

                // update remaining time
                waitInfoPtr->timer.remainingTime =  remainingTime > 0 ? (int) remainingTime : 0; 
                
                // ... and min
                if (waitInfoPtr->timer.remainingTime < min)
                    min = waitInfoPtr->timer.remainingTime;
            }

            waitInfoPtr = (WaitInfo*) (waitInfoPtr->link.Flink);

        } while ((PVOID) waitInfoPtr != waitInfoHead);

    } 
    return min;
}

#ifdef _WIN64
#pragma warning (disable : 4716)
#else
#pragma warning (disable : 4715)
#endif
DWORD ThreadpoolMgr::WaitThreadStart(LPVOID lpArgs)
{
    ThreadCB* threadCB = (ThreadCB*) lpArgs;
    // wait threads never die. (Why?)
    for (;;) 
    {
        DWORD status;
        DWORD timeout = 0;

        if (threadCB->NumActiveWaits == 0)
        {
            // @Consider doing a sleep for an idle period and terminating the thread if no activity
            status = SleepEx(INFINITE,TRUE);

            _ASSERTE(status == WAIT_IO_COMPLETION);
        }
        else
        {
            // compute minimum timeout. this call also updates the remainingTime field for each wait
            timeout = MinimumRemainingWait(threadCB->waitPointer,threadCB->NumActiveWaits);

            status = WaitForMultipleObjectsEx(  threadCB->NumActiveWaits,
                                                threadCB->waitHandle,
                                                FALSE,                      // waitall
                                                timeout,
                                                TRUE  );                    // alertable

            _ASSERTE( (status == WAIT_TIMEOUT) ||
                      (status == WAIT_IO_COMPLETION) ||
                      (status >= WAIT_OBJECT_0 && status < (WAIT_OBJECT_0 + threadCB->NumActiveWaits))  ||
                      (status == WAIT_FAILED));
        }

        if (status == WAIT_IO_COMPLETION)
            continue;

        if (status == WAIT_TIMEOUT)
        {
            for (int i=0; i< threadCB->NumActiveWaits; i++)
            {
                WaitInfo* waitInfo = (WaitInfo*) (threadCB->waitPointer[i]).Flink;
                PVOID waitInfoHead = &(threadCB->waitPointer[i]);
                    
                do 
                {
                    _ASSERTE(waitInfo->timer.remainingTime >= timeout);

                    WaitInfo* wTemp = (WaitInfo*) waitInfo->link.Flink;

                    if (waitInfo->timer.remainingTime == timeout)
                    {
                        ProcessWaitCompletion(waitInfo,i,TRUE); 
                    }

                    waitInfo = wTemp;

                } while ((PVOID) waitInfo != waitInfoHead);
            }
        }
        else if (status >= WAIT_OBJECT_0 && status < (WAIT_OBJECT_0 + threadCB->NumActiveWaits))
        {
            unsigned index = status - WAIT_OBJECT_0;
            WaitInfo* waitInfo = (WaitInfo*) (threadCB->waitPointer[index]).Flink;
            PVOID waitInfoHead = &(threadCB->waitPointer[index]);
			BOOL isAutoReset;
			if (g_pufnNtQueryEvent)
			{
				EVENT_BASIC_INFORMATION      EventInfo;
				int                     Status;

				Status = (*g_pufnNtQueryEvent) ( threadCB->waitHandle[index],
										EventBasicInformation,
										&EventInfo,
										sizeof(EventInfo),
										NULL);
				if (Status >= 0)
				{
					isAutoReset = (EventInfo.EventState != SynchronizationEvent);
				}
				else
					isAutoReset = TRUE;		// this is safer, (though inefficient, since we will re-enter the wait
				                            // and release the next waiter, and so on.) 

			}
			else // On Win9x
				isAutoReset = (WaitForSingleObject(threadCB->waitHandle[index],0) == WAIT_TIMEOUT);
            do 
            {
                WaitInfo* wTemp = (WaitInfo*) waitInfo->link.Flink;
                ProcessWaitCompletion(waitInfo,index,FALSE);
				
                waitInfo = wTemp;

            } while (((PVOID) waitInfo != waitInfoHead) && !isAutoReset);

			// If an app registers a recurring wait for an event that is always signalled (!), 
			// then no apc's will be executed since the thread never enters the alertable state.
			// This can be fixed by doing the following:
			//     SleepEx(0,TRUE);
			// However, it causes an unnecessary context switch. It is not worth penalizing well
			// behaved apps to protect poorly written apps. 
				

        }
        else
        {
            _ASSERTE(status == WAIT_FAILED);
            // wait failed: application error 
            // find out which wait handle caused the wait to fail
            for (int i = 0; i < threadCB->NumActiveWaits; i++)
            {
                DWORD subRet = WaitForSingleObject(threadCB->waitHandle[i], 0);

                if (subRet != WAIT_FAILED)
                    continue;

                // remove all waits associated with this wait handle

                WaitInfo* waitInfo = (WaitInfo*) (threadCB->waitPointer[i]).Flink;
                PVOID waitInfoHead = &(threadCB->waitPointer[i]);

                do
                {
                    WaitInfo* temp  = (WaitInfo*) waitInfo->link.Flink;

                    DeactivateNthWait(waitInfo,i);


		    // Note, we cannot cleanup here since there is no way to suppress finalization
		    // we will just leak, and rely on the finalizer to clean up the memory
                    //if (InterlockedDecrement((LPLONG) &waitInfo->refCount ) == 0)
                    //    DeleteWait(waitInfo);


                    waitInfo = temp;

                } while ((PVOID) waitInfo != waitInfoHead);

                break;
            }
        }
    }
}
#ifdef _WIN64
#pragma warning (default : 4716)
#else
#pragma warning (default : 4715)
#endif

void ThreadpoolMgr::ProcessWaitCompletion(WaitInfo* waitInfo,
                                          unsigned index,
                                          BOOL waitTimedOut
                                         )
{
    if ( waitInfo->flag & WAIT_SINGLE_EXECUTION) 
    {
        DeactivateNthWait (waitInfo,index) ;
    }
    else
    {   // reactivate wait by resetting timer
        waitInfo->timer.startTime = GetTickCount();
    }

    AsyncCallback* asyncCallback = MakeAsyncCallback();
    if (asyncCallback)
    {
        asyncCallback->wait = waitInfo;
        asyncCallback->waitTimedOut = waitTimedOut;

        InterlockedIncrement((LPLONG) &waitInfo->refCount ) ;

        if (FALSE == QueueUserWorkItem(AsyncCallbackCompletion,asyncCallback,0))
        {
            RecycleMemory((LPVOID*)asyncCallback, MEMTYPE_AsyncCallback); //delete asyncCallback;

            if (InterlockedDecrement((LPLONG) &waitInfo->refCount ) == 0)
                DeleteWait(waitInfo);

        }
    }
}


DWORD ThreadpoolMgr::AsyncCallbackCompletion(PVOID pArgs)
{
    AsyncCallback* asyncCallback = (AsyncCallback*) pArgs;

    WaitInfo* waitInfo = asyncCallback->wait;

	LOG((LF_THREADPOOL ,LL_INFO100 ,"Doing callback, Function= %x, Context= %x, Timeout= %2d\n",
		waitInfo->Callback, waitInfo->Context,asyncCallback->waitTimedOut));

    ((WAITORTIMERCALLBACKFUNC) waitInfo->Callback) 
                                ( waitInfo->Context, asyncCallback->waitTimedOut);

    RecycleMemory((LPVOID*) asyncCallback, MEMTYPE_AsyncCallback); //delete asyncCallback;

	// if this was a single execution, we now need to stop rooting registeredWaitHandle  
	// in a GC handle. This will cause the finalizer to pick it up and call the cleanup
	// routine.
	if ( (waitInfo->flag & WAIT_SINGLE_EXECUTION)  && (waitInfo->flag & WAIT_FREE_CONTEXT))
	{

		DelegateInfo* pDelegate = (DelegateInfo*) waitInfo->Context;
		
		_ASSERTE(pDelegate->m_registeredWaitHandle);
		
		if (SystemDomain::GetAppDomainAtId(pDelegate->m_appDomainId))
			// if no domain then handle already gone or about to go.
			StoreObjectInHandle(pDelegate->m_registeredWaitHandle, NULL);
	}

    if (InterlockedDecrement((LPLONG) &waitInfo->refCount ) == 0)
	{
		// the wait has been unregistered, so safe to delete it
        DeleteWait(waitInfo);
	}

    return 0; // ignored
}

void ThreadpoolMgr::DeactivateWait(WaitInfo* waitInfo)
{
    ThreadCB* threadCB = waitInfo->threadCB;
    DWORD endIndex = threadCB->NumActiveWaits-1;
    DWORD index;

    for (index = 0;  index <= endIndex; index++) 
    {
        LIST_ENTRY* head = &(threadCB->waitPointer[index]);
        LIST_ENTRY* current = head;
        do {
            if (current->Flink == (PVOID) waitInfo)
                goto FOUND;

            current = (LIST_ENTRY*) current->Flink;

        } while (current != head);
    }

FOUND:
    _ASSERTE(index <= endIndex);

    DeactivateNthWait(waitInfo, index);
}


void ThreadpoolMgr::DeactivateNthWait(WaitInfo* waitInfo, DWORD index)
{

    ThreadCB* threadCB = waitInfo->threadCB;

    if (waitInfo->link.Flink != waitInfo->link.Blink)
    {
        RemoveEntryList(&(waitInfo->link));
    }
    else
    {

        ULONG EndIndex = threadCB->NumActiveWaits -1;

        // Move the remaining ActiveWaitArray left.

        ShiftWaitArray( threadCB, index+1, index,EndIndex - index ) ;

        // repair the blink and flink of the first and last elements in the list
        for (unsigned int i = 0; i< EndIndex-index; i++)
        {
            WaitInfo* firstWaitInfo = (WaitInfo*) threadCB->waitPointer[index+i].Flink;
            WaitInfo* lastWaitInfo = (WaitInfo*) threadCB->waitPointer[index+i].Blink;
            firstWaitInfo->link.Blink =  &(threadCB->waitPointer[index+i]);
            lastWaitInfo->link.Flink =  &(threadCB->waitPointer[index+i]);
        }
        // initialize the entry just freed
        InitializeListHead(&(threadCB->waitPointer[EndIndex]));

        threadCB->NumActiveWaits-- ;
        InterlockedDecrement((LPLONG) &threadCB->NumWaitHandles ) ;
    }

    waitInfo->state &= ~WAIT_ACTIVE ;

}

void ThreadpoolMgr::DeleteWait(WaitInfo* waitInfo)
{
    HANDLE hCompletionEvent = waitInfo->CompletionEvent;
    if(waitInfo->Context && (waitInfo->flag & WAIT_FREE_CONTEXT)) {
        DelegateInfo* pDelegate = (DelegateInfo*) waitInfo->Context;
        pDelegate->Release();
        RecycleMemory((LPVOID*)pDelegate, MEMTYPE_DelegateInfo); //delete pDelegate;
    }
    
    delete waitInfo;

    if (hCompletionEvent!= INVALID_HANDLE)
        SetEvent(hCompletionEvent);

}


#endif // !PLATFORM_CE
/************************************************************************/

BOOL ThreadpoolMgr::UnregisterWaitEx(HANDLE hWaitObject,HANDLE Event)
{
#ifdef PLATFORM_CE
    ::SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return FALSE;
#else // !PLATFORM_CE
	
	_ASSERTE(Initialized);				// cannot call unregister before first registering

    const BOOL NonBlocking = ( Event != (HANDLE) -1 ) ;
    const BOOL Blocking = (Event == (HANDLE) -1);
    WaitInfo* waitInfo = (WaitInfo*) hWaitObject;
    WaitEvent* CompletionEvent = NULL; 
    WaitEvent* PartialCompletionEvent = NULL; // used to wait until the wait has been deactivated

    if (!hWaitObject)
    {
        return FALSE;
    }

    // we do not allow callbacks to run in the wait thread, hence the assert
    _ASSERTE(GetCurrentThreadId() != waitInfo->threadCB->threadId);


    if (Blocking) 
    {
        // Get an event from the event cache
        CompletionEvent = GetWaitEvent() ;  // get event from the event cache

        if (!CompletionEvent) 
        {
            return FALSE ;
        }
    } 

    waitInfo->CompletionEvent = CompletionEvent
                                ? CompletionEvent->Handle
                                : (Event ? Event : INVALID_HANDLE) ;

    if (NonBlocking)
    {
        // we still want to block until the wait has been deactivated
        PartialCompletionEvent = GetWaitEvent () ;
        if (!PartialCompletionEvent) 
        {
            return FALSE ;
        }
        waitInfo->PartialCompletionEvent = PartialCompletionEvent->Handle;
    }
    else
    {
        waitInfo->PartialCompletionEvent = INVALID_HANDLE;
    }

	LOG((LF_THREADPOOL ,LL_INFO1000 ,"Unregistering wait, waitHandle=%x, Context=%x\n",
			waitInfo->waitHandle, waitInfo->Context));


	BOOL status = QueueUserAPC((PAPCFUNC)DeregisterWait,
                               waitInfo->threadCB->threadHandle,
                               (size_t) waitInfo);

    if (status == 0)
    {
        if (CompletionEvent) FreeWaitEvent(CompletionEvent);
        if (PartialCompletionEvent) FreeWaitEvent(PartialCompletionEvent);
		return FALSE;
    }

    if (NonBlocking) 
    {
        WaitForSingleObject(PartialCompletionEvent->Handle, INFINITE ) ;
        FreeWaitEvent(PartialCompletionEvent);
    } 
    
    else        // i.e. blocking
    {
        _ASSERTE(CompletionEvent);
        WaitForSingleObject(CompletionEvent->Handle, INFINITE ) ;
        FreeWaitEvent(CompletionEvent);
    }
    return TRUE;
#endif  // !PLATFORM_CE
}


#ifndef PLATFORM_CE
void ThreadpoolMgr::DeregisterWait(WaitInfo* pArgs)
{
	WaitInfo* waitInfo = pArgs;

    if ( ! (waitInfo->state & WAIT_REGISTERED) ) 
    {
        // set state to deleted, so that it does not get registered
        waitInfo->state |= WAIT_DELETE ;
        
        // since the wait has not even been registered, we dont need an interlock to decrease the RefCount
        waitInfo->refCount--;

        if ( waitInfo->PartialCompletionEvent != INVALID_HANDLE) 
        {
            SetEvent( waitInfo->PartialCompletionEvent ) ;
        }
        return;
    }

    if (waitInfo->state & WAIT_ACTIVE) 
    {
        DeactivateWait(waitInfo);
    }

    if ( waitInfo->PartialCompletionEvent != INVALID_HANDLE) 
    {
        SetEvent( waitInfo->PartialCompletionEvent ) ;
    }

    if (InterlockedDecrement ((LPLONG) &waitInfo->refCount) == 0 ) 
    {
        DeleteWait(waitInfo);
    }
    return;
}


/* This gets called in a finalizer thread ONLY IF an app does not deregister the 
   the wait. Note that just because the registeredWaitHandle is collected by GC
   does not mean it is safe to delete the wait. The refcount tells us when it is 
   safe.
*/
void ThreadpoolMgr::WaitHandleCleanup(HANDLE hWaitObject)
{
    WaitInfo* waitInfo = (WaitInfo*) hWaitObject;
    _ASSERTE(waitInfo->refCount > 0);

    QueueUserAPC((PAPCFUNC)DeregisterWait, 
                     waitInfo->threadCB->threadHandle,
					 (size_t) waitInfo);
}


ThreadpoolMgr::WaitEvent* ThreadpoolMgr::GetWaitEvent()
{
    WaitEvent* waitEvent;

    LOCKCOUNTINCL("GetWaitEvent in win32ThreadPool.h");                     \
    EnterCriticalSection(&EventCacheCriticalSection);

    if (!IsListEmpty (&EventCache)) 
    {
        LIST_ENTRY* FirstEntry;

        RemoveHeadList (&EventCache, FirstEntry);
        
        waitEvent = (WaitEvent*) FirstEntry ;

        NumUnusedEvents--;

        LeaveCriticalSection(&EventCacheCriticalSection);
        LOCKCOUNTDECL("GetWaitEvent in win32ThreadPool.h");                     \

    }
    else
    {
        LeaveCriticalSection(&EventCacheCriticalSection);
        LOCKCOUNTDECL("GetWaitEvent in win32ThreadPool.h");                     \

        waitEvent = new WaitEvent;
        
        if (waitEvent == NULL)
            return NULL;

        waitEvent->Handle = WszCreateEvent(NULL,TRUE,FALSE,NULL);

        if (waitEvent->Handle == NULL)
        {
            delete waitEvent;
            return NULL;
        }
    }
    return waitEvent;
}

void ThreadpoolMgr::FreeWaitEvent(WaitEvent* waitEvent)
{
    ResetEvent(waitEvent->Handle);
    LOCKCOUNTINCL("FreeWaitEvent in win32ThreadPool.h");                        \
    EnterCriticalSection(&EventCacheCriticalSection);

    if (NumUnusedEvents < MAX_CACHED_EVENTS)
    {
        InsertHeadList (&EventCache, &waitEvent->link) ;

        NumUnusedEvents++;

    }
    else
    {
        CloseHandle(waitEvent->Handle);
        delete waitEvent;
    }

    LeaveCriticalSection(&EventCacheCriticalSection);
    LOCKCOUNTDECL("FreeWaitEvent in win32ThreadPool.h");                        \

}

void ThreadpoolMgr::CleanupEventCache()
{
    for (LIST_ENTRY* Node = (LIST_ENTRY*) EventCache.Flink ; 
         Node != &EventCache ; 
         )
    {
        WaitEvent* waitEvent = (WaitEvent*) Node;
        CloseHandle(waitEvent->Handle);
        Node = (LIST_ENTRY*)Node->Flink;
        delete waitEvent;
    }
}

#endif // !PLATFORM_CE
/************************************************************************/

#ifndef PLATFORM_CE
BOOL ThreadpoolMgr::BindIoCompletionCallback(HANDLE FileHandle,
                                            LPOVERLAPPED_COMPLETION_ROUTINE Function,
                                            ULONG Flags )
{
    if (!RunningOnWinNT())
    {
        ::SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
        return FALSE;
    }

	EnsureInitialized();

    _ASSERTE(GlobalCompletionPort != NULL);

    // there could be a race here, but at worst we will have N threads starting up where N = number of CPUs
    if (!InitCompletionPortThreadpool)
    {
        InitCompletionPortThreadpool = TRUE;
        CreateCompletionPortThread(NULL);
        CreateGateThread();
    }
    else
    {
        GrowCompletionPortThreadpoolIfNeeded();
    }

    

    HANDLE h = (*g_pufnCreateIoCompletionPort)(FileHandle,
                                               GlobalCompletionPort,
                                               (unsigned long*) Function,
                                               0);

    if (h == NULL) 
        return FALSE;

    _ASSERTE(h == GlobalCompletionPort);

	LOG((LF_THREADPOOL ,LL_INFO1000 ,"Bind IOCompletion callback, fileHandle=%x, Function=%x\n",
			FileHandle, Function));

    return TRUE;
}


BOOL ThreadpoolMgr::CreateCompletionPortThread(LPVOID lpArgs)
{
    HANDLE threadHandle = CreateUnimpersonatedThread(CompletionPortThreadStart, lpArgs);

    if (threadHandle)
    {
		LastCPThreadCreation = GetTickCount();			// record this for use by logic to spawn additional threads
        InterlockedIncrement((LPLONG) &NumCPThreads);

		LOG((LF_THREADPOOL ,LL_INFO100 ,"Completion port thread created (NumCPThreads=%d\n)",NumCPThreads));

        DWORD status = ResumeThread(threadHandle);
        _ASSERTE(status != (DWORD) (-1));
        CloseHandle(threadHandle);          // we don't need this anymore
        return TRUE;
    }


    return FALSE;
}

DWORD ThreadpoolMgr::CompletionPortThreadStart(LPVOID lpArgs)
{

    BOOL status;
    DWORD numBytes;
    size_t key;
    LPOVERLAPPED pOverlapped;
    DWORD errorCode;

    #define CP_THREAD_WAIT 15000 /* milliseconds */
    #define CP_THREAD_PENDINGIO_WAIT 5000
    #define CP_THREAD_POOL_TIMEOUT  600000  // 10 minutes
    
    _ASSERTE(GlobalCompletionPort != NULL);

	LOG((LF_THREADPOOL ,LL_INFO1000 ,"Completion port thread started\n"));
        
    CoInitializeEx(NULL, COINIT_MULTITHREADED);


    for (;; )
    {

        InterlockedIncrement((LPLONG) &NumFreeCPThreads);

        errorCode = S_OK;

        if (lpArgs == NULL)
        {
        status = GetQueuedCompletionStatus(
                    GlobalCompletionPort,
                    &numBytes,
                    (PULONG_PTR)&key,
                    &pOverlapped,
                    CP_THREAD_WAIT
                    );
        }
        else
        {
            status = 1;     // non-0 equals success

            QueuedStatus *CompletionStatus = (QueuedStatus*)lpArgs;
            numBytes = CompletionStatus->numBytes;
            key = (size_t)CompletionStatus->key;
            pOverlapped = CompletionStatus->pOverlapped;
            errorCode = CompletionStatus->errorCode;
            delete CompletionStatus;
            lpArgs = NULL;  // one-time deal for initial CP packet
        }

        InterlockedDecrement((LPLONG)&NumFreeCPThreads);

        // Check if the thread needs to exit
        if (status == 0)
        {
            errorCode = GetLastError();
        }

        if (errorCode == WAIT_TIMEOUT)
        {
            if (ShouldExitThread())
            {
                // if I'm the last thread, don't die until no activity for certain time period
                if (NumCPThreads == 1 && ((GetTickCount() - LastCompletionTime) < CP_THREAD_POOL_TIMEOUT))
                {
                    continue;   // put back into rotation
                }
                break;  // exit thread
            }

            // the fact that we're here means we can't exit due to pending io, or we're not the last real thread
            // (there may be retired threads sitting around).  If there are other available threads able to pick
            // up a request, then we'll retire, otherwise put back into rotation.
            if (NumFreeCPThreads == 0)
                continue;

            BOOL bExit = FALSE;
            InterlockedIncrement((LPLONG)&NumRetiredCPThreads);
            for (;;)
            {
                // now in "retired mode" waiting for pending io to complete
                status = WaitForSingleObject(RetiredWakeupEvent, CP_THREAD_PENDINGIO_WAIT);
                _ASSERTE(status == WAIT_TIMEOUT || status == WAIT_OBJECT_0);

                if (status == WAIT_TIMEOUT)
                {
                    if (ShouldExitThread())
                    {
                        // if I'm the last thread, don't die
                        if (NumCPThreads > 1) 
                            bExit = TRUE;
                        else
                            bExit = FALSE;
                        InterlockedDecrement((LPLONG)&NumRetiredCPThreads);
                        break; // inner for
                    }
                    else
                        continue;   // keep waiting
                }
                else
                {
                    // put back into rotation -- we need a thread
                    bExit = FALSE;
                    InterlockedDecrement((LPLONG)&NumRetiredCPThreads);
                    break; // inner for
                }

            }

            if (bExit == TRUE)
            {
                break; // outer for, exit thread
            }
            else continue;  // outer for, wait for new work
           
        }

        // *pOverlapped should not be null. We assert in debug mode, but ignore it otherwise
        _ASSERTE(pOverlapped != NULL);

        if (pOverlapped != NULL)
        {
            _ASSERTE(key != 0);  // should be a valid function address

            if (key != 0)
            {   
                GrowCompletionPortThreadpoolIfNeeded();
		
				LastCompletionTime = GetTickCount();

				LOG((LF_THREADPOOL ,LL_INFO1000 ,"Doing IO completion callback, function = %x\n", key));

                ((LPOVERLAPPED_COMPLETION_ROUTINE) key)(errorCode, numBytes, pOverlapped);

				LOG((LF_THREADPOOL ,LL_INFO1000 ,"Returned from IO completion callback, function = %x\n", key));
            }
            else 
            {
                // Application bug - can't do much, just ignore it
            }

        }
    }   // for (;;)

    // exiting, so decrement target number of threads
    if (CurrentLimitTotalCPThreads >= NumCPThreads)
    {
        SSIZE_T limit = CurrentLimitTotalCPThreads;
#ifdef _WIN64
        InterlockedCompareExchange(&CurrentLimitTotalCPThreads, limit-1, limit);
#else // !_WIN64
        FastInterlockCompareExchange((void**)&CurrentLimitTotalCPThreads, (void*)(limit-1), (void*)limit);
#endif // _WIN64
    }

    InterlockedDecrement((LPLONG) &NumCPThreads);

    CoUninitialize();
    ExitThread(0); 
}

// On NT4 and Win2K returns true if there is pending io on the thread.
// On Win9x return false (since there is on OS support for checking it)
BOOL ThreadpoolMgr::IsIoPending()
{

    int Status;
    ULONG IsIoPending;

    if (g_pufnNtQueryInformationThread)
    {
        Status =(int) (*g_pufnNtQueryInformationThread)(GetCurrentThread(),
                                          ThreadIsIoPending,
                                          &IsIoPending,
                                          sizeof(IsIoPending),
                                          NULL);


        if ((Status < 0) || IsIoPending)
            return TRUE;
    }
    return FALSE;
}

BOOL ThreadpoolMgr::ShouldExitThread()
{

    if (IsIoPending())

        return FALSE;

    else
//        return ((NumCPThreads > CurrentLimitTotalCPThreads) || (NumFreeCPThreads > MaxFreeCPThreads));
        return TRUE;


}


void ThreadpoolMgr::GrowCompletionPortThreadpoolIfNeeded()
{
    if (NumFreeCPThreads == 0)
    {
        // adjust limit if neeeded

        if (NumRetiredCPThreads == 0 && NumCPThreads >= CurrentLimitTotalCPThreads)
        {
            SSIZE_T limit = CurrentLimitTotalCPThreads;

            if (limit < MaxLimitTotalCPThreads && cpuUtilization < CpuUtilizationLow) // || SufficientDelaySinceLastCompletion()))

            {
                // add one more check to make sure that we haven't fired off a new
                // thread since the last time time we checked the cpu utilization.
                // However, don't bother if we haven't reached the MinLimit (2*number of cpus)
                if ((NumCPThreads < MinLimitTotalCPThreads) ||
					SufficientDelaySinceLastSample(LastCPThreadCreation,NumCPThreads))
                {
#ifdef _WIN64
                    InterlockedCompareExchange(&CurrentLimitTotalCPThreads, limit+1, limit);
#else // !_WIN64
					FastInterlockCompareExchange((void**)&CurrentLimitTotalCPThreads, (void*)(limit+1), (void*)limit);
#endif // _WIN64
                }
            }
        }

        // create new CP thread if under limit, but don't bother if gc in progress
        if (!g_pGCHeap->IsGCInProgress()) {
            if (NumCPThreads < CurrentLimitTotalCPThreads)
            {
                CreateCompletionPortThread(NULL);
            }
            else if (NumRetiredCPThreads > 0)
            {
                // wakeup retired thread instead
                SetEvent(RetiredWakeupEvent);
            }
        }
            
    }
}


BOOL ThreadpoolMgr::CreateGateThread()
{
    DWORD threadId;

#ifdef _WIN64
    if (InterlockedCompareExchange(&GateThreadCreated, 
                                   1, 
                                   0) == 1)
#else // !_WIN64
    if (FastInterlockCompareExchange((LPVOID *)&GateThreadCreated, 
                                   (LPVOID) 1, 
                                   (LPVOID) 0) == (LPVOID)1)
#endif // _WIN64
    {
       return TRUE;
    }

    HANDLE threadHandle = CreateThread(NULL,                // security descriptor
                                       0,                   // default stack size
                                       GateThreadStart, // 
                                       NULL,                //no arguments
                                       CREATE_SUSPENDED,    // start immediately
                                       &threadId);

    if (threadHandle)
    {
        DWORD status = ResumeThread(threadHandle);
        _ASSERTE(status != (DWORD) -1);

		LOG((LF_THREADPOOL ,LL_INFO100 ,"Gate thread started\n"));

        CloseHandle(threadHandle);  //we don't need this anymore
        return TRUE;
    }

    return FALSE;
}


#ifdef _WIN64
#pragma warning (disable : 4716)
#else
#pragma warning (disable : 4715)
#endif

__int64 ThreadpoolMgr::GetCPUBusyTime_NT(SYSTEM_PROCESSOR_PERFORMANCE_INFORMATION** pOldInfo)
{
 
    int infoSize = NumberOfProcessors * sizeof(SYSTEM_PROCESSOR_PERFORMANCE_INFORMATION);

    SYSTEM_PROCESSOR_PERFORMANCE_INFORMATION *pNewInfo = (SYSTEM_PROCESSOR_PERFORMANCE_INFORMATION *)alloca(infoSize);
    
    if (pNewInfo == NULL)
        ExitThread(0);
            
    (*g_pufnNtQuerySystemInformation)(SystemProcessorPerformanceInformation, pNewInfo, infoSize, NULL);
    
    __int64 cpuIdleTime = 0, cpuUserTime = 0, cpuKernelTime = 0;
    __int64 cpuBusyTime, cpuTotalTime;

    for (unsigned int i = 0; i < NumberOfProcessors; i++) 
    {
        cpuIdleTime   += (pNewInfo[i].IdleTime   - (*pOldInfo)[i].IdleTime);
        cpuUserTime   += (pNewInfo[i].UserTime   - (*pOldInfo)[i].UserTime);
        cpuKernelTime += (pNewInfo[i].KernelTime - (*pOldInfo)[i].KernelTime);
    }

    // Preserve reading
    memcpy(*pOldInfo, pNewInfo, infoSize);

    cpuTotalTime  = cpuUserTime + cpuKernelTime;
    cpuBusyTime   = cpuTotalTime - cpuIdleTime;

    __int64 reading = ((cpuBusyTime * 100) / cpuTotalTime);
        
    return reading;
    
}

#define GATE_THREAD_DELAY 500 /*milliseconds*/


DWORD ThreadpoolMgr::GateThreadStart(LPVOID lpArgs)
{
    __int64         prevCpuBusyTime = 0;
    SYSTEM_PROCESSOR_PERFORMANCE_INFORMATION    *prevCPUInfo;

    // Get first reading
    if (RunningOnWinNT())
    {
        int infoSize = NumberOfProcessors * sizeof(SYSTEM_PROCESSOR_PERFORMANCE_INFORMATION);

        prevCPUInfo = (SYSTEM_PROCESSOR_PERFORMANCE_INFORMATION *)alloca(infoSize);

        memset(prevCPUInfo,0,infoSize);


        GetCPUBusyTime_NT(&prevCPUInfo);            // ignore return value the first time
    }

    BOOL IgnoreNextSample = FALSE;
    
    for (;;)
    {

        Sleep(GATE_THREAD_DELAY);
		
        // if we are stopped at a debug breakpoint, go back to sleep
        if (CORDebuggerAttached() && g_pDebugInterface->IsStopped())
            continue;

        if (RunningOnWinNT())
        {
            if (!g_pGCHeap->IsGCInProgress())
            {
                if (IgnoreNextSample)
                {
                    IgnoreNextSample = FALSE;
                    GetCPUBusyTime_NT(&prevCPUInfo);            // updates prevCPUInfo as side effect
                    cpuUtilization = CpuUtilizationLow + 1;                    
                }
                else
                    cpuUtilization = (long) GetCPUBusyTime_NT(&prevCPUInfo);            // updates prevCPUInfo as side effect                    
            }
            else
            {
                GetCPUBusyTime_NT(&prevCPUInfo);            // updates prevCPUInfo as side effect
                cpuUtilization = CpuUtilizationLow + 1;
                IgnoreNextSample = TRUE;
            }

            SSIZE_T oldLimit = CurrentLimitTotalCPThreads;
            SSIZE_T newLimit = CurrentLimitTotalCPThreads;

            // don't mess with CP thread pool settings if not initialized yet
            if (InitCompletionPortThreadpool)
            {

                if (NumFreeCPThreads == 0 && 
                    NumRetiredCPThreads == 0 &&
                    NumCPThreads < MaxLimitTotalCPThreads)
                {
                    BOOL status;
                    DWORD numBytes;
                    size_t key;
                    LPOVERLAPPED pOverlapped;
                    DWORD errorCode;

                    errorCode = S_OK;

                    status = GetQueuedCompletionStatus(
                                GlobalCompletionPort,
                                &numBytes,
                                (PULONG_PTR)&key,
                                &pOverlapped,
                                0 // immediate return
                                );

                    if (status == 0)
                    {
                        errorCode = GetLastError();
                    }

                    if (errorCode != WAIT_TIMEOUT)
                    {
                        // make sure to free mem later in thread
                        QueuedStatus *CompletionStatus = new QueuedStatus;
                        CompletionStatus->numBytes = numBytes;
                        CompletionStatus->key = (PULONG_PTR)key;
                        CompletionStatus->pOverlapped = pOverlapped;
                        CompletionStatus->errorCode = errorCode;

                        CreateCompletionPortThread((LPVOID)CompletionStatus);
                        // increment after thread start to reduce chance of extra thread creation
#ifdef _WIN64
                        InterlockedCompareExchange(&CurrentLimitTotalCPThreads, oldLimit+1, oldLimit);
#else // !_WIN64
                        FastInterlockCompareExchange((void**)&CurrentLimitTotalCPThreads, (void*)(oldLimit+1), (void*)oldLimit);
#endif // _WIN64
                    }
                }

                else if (cpuUtilization > CpuUtilizationHigh)
                {
                    if (oldLimit > MinLimitTotalCPThreads)
                        newLimit = oldLimit-1;
                }
                else if (cpuUtilization < CpuUtilizationLow)
                {
                    // this could be an indication that threads might be getting blocked or there is no work
                    if (oldLimit < MaxLimitTotalCPThreads &&    // don't go beyond the hard upper limit
                        NumFreeCPThreads == 0 &&                // don't bump the limit if there are already free threads
                        NumCPThreads >= oldLimit)               // don't bump the limit if the number of threads haven't caught up to the old limit yet
                    {
                        // if we need to add a new thread, wake up retired threads instead of creating new ones
                        if (NumRetiredCPThreads > 0)
                            SetEvent(RetiredWakeupEvent);
                        else
                            newLimit = oldLimit+1;
                    }
                }

                if (newLimit != oldLimit)
                {
#ifdef _WIN64
                    InterlockedCompareExchange(&CurrentLimitTotalCPThreads, newLimit, oldLimit);
#else // !_WIN64
                    FastInterlockCompareExchange((LPVOID *)&CurrentLimitTotalCPThreads, (LPVOID)newLimit, (LPVOID)oldLimit);
#endif // _WIN64
                }

                if (newLimit > oldLimit ||
                    NumCPThreads < oldLimit)
                {
                    GrowCompletionPortThreadpoolIfNeeded();
                }
            }
        }

        if (MonitorWorkRequestsQueue)
		{
			if (RunningOnWinNT())
			{
            GrowWorkerThreadPoolIfStarvation(cpuUtilization);
			}
			else
			{
				GrowWorkerThreadPoolIfStarvation_Win9x();
			}
		}
    }       // for (;;)
}

// called by logic to spawn a new completion port thread.
// return false if not enough time has elapsed since the last
// time we sampled the cpu utilization. 
BOOL ThreadpoolMgr::SufficientDelaySinceLastSample(unsigned int LastThreadCreationTime, 
												   unsigned NumThreads,	 // total number of threads of that type (worker or CP)
												   double    throttleRate // the delay is increased by this percentage for each extra thread
												   )
{

	unsigned dwCurrentTickCount =  GetTickCount();
	
	unsigned delaySinceLastThreadCreation = dwCurrentTickCount - LastThreadCreationTime;

	unsigned minWaitBetweenThreadCreation =  GATE_THREAD_DELAY;

	if (throttleRate > 0.0)
	{
		_ASSERTE(throttleRate <= 1.0);

		unsigned adjustedThreadCount = NumThreads > NumberOfProcessors ? (NumThreads - NumberOfProcessors) : 0;

		minWaitBetweenThreadCreation = (unsigned) (GATE_THREAD_DELAY * pow((1.0 + throttleRate),(double)adjustedThreadCount));
	}
	// the amount of time to wait should grow up as the number of threads is increased
    
	return (delaySinceLastThreadCreation > minWaitBetweenThreadCreation); 

}

/*
BOOL ThreadpoolMgr::SufficientDelaySinceLastCompletion()
{
    #define DEQUEUE_DELAY_THRESHOLD (GATE_THREAD_DELAY * 2)
	
	unsigned delay = GetTickCount() - LastCompletionTime;

	unsigned tooLong = NumCPThreads * DEQUEUE_DELAY_THRESHOLD; 

	return (delay > tooLong);

}
*/

// called by logic to spawn new worker threads, return true if it's been too long
// since the last dequeue operation - takes number of worker threads into account
// in deciding "too long"
BOOL ThreadpoolMgr::SufficientDelaySinceLastDequeue()
{
    #define DEQUEUE_DELAY_THRESHOLD (GATE_THREAD_DELAY * 2)
	
	unsigned delay = GetTickCount() - LastDequeueTime;

	unsigned tooLong = NumWorkerThreads * DEQUEUE_DELAY_THRESHOLD; 

	return (delay > tooLong);

}

#ifdef _WIN64
#pragma warning (default : 4716)
#else
#pragma warning (default : 4715)
#endif


#endif // !PLATFORM_CE

/************************************************************************/

BOOL ThreadpoolMgr::CreateTimerQueueTimer(PHANDLE phNewTimer,
                                          WAITORTIMERCALLBACK Callback,
                                          PVOID Parameter,
                                          DWORD DueTime,
                                          DWORD Period,
                                          ULONG Flag)
{
#ifdef PLATFORM_CE
    ::SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return FALSE;
#else // !PLATFORM_CE

	EnsureInitialized();
  
    // For now we use just one timer thread. Consider using multiple timer threads if 
    // number of timers in the queue exceeds a certain threshold. The logic and code 
    // would be similar to the one for creating wait threads.
    if (NULL == TimerThread)
    {
        LOCKCOUNTINCL("CreateTimerQueueTimer in win32ThreadPool.h");                        \
        EnterCriticalSection(&TimerQueueCriticalSection);

        // check again
        if (NULL == TimerThread)
        {
            DWORD threadId;
            TimerThread = CreateThread(NULL,                // security descriptor
                                       0,                   // default stack size
                                       TimerThreadStart,        // 
                                       NULL,    // thread control block is passed as argument
                                       0,   
                                       &threadId);
            if (TimerThread == NULL)
            {
                LeaveCriticalSection(&TimerQueueCriticalSection);
                LOCKCOUNTDECL("CreateTimerQueueTimer in win32ThreadPool.h"); \
                return FALSE;
            }

			LOG((LF_THREADPOOL ,LL_INFO100 ,"Timer thread started\n"));
        }
        LeaveCriticalSection(&TimerQueueCriticalSection);
        LOCKCOUNTDECL("CreateTimerQueueTimer in win32ThreadPool.h");                        \

    }


    TimerInfo* timerInfo = new TimerInfo;
    *phNewTimer = (HANDLE) timerInfo;

    if (NULL == timerInfo)
        return FALSE;

    timerInfo->FiringTime = DueTime;
    timerInfo->Function = Callback;
    timerInfo->Context = Parameter;
    timerInfo->Period = Period;
    timerInfo->state = 0;
    timerInfo->flag = Flag;

	BOOL status = QueueUserAPC((PAPCFUNC)InsertNewTimer,TimerThread,(size_t)timerInfo);
    if (FALSE == status)
        return FALSE;

    return TRUE;
#endif // !PLATFORM_CE
}

#ifndef PLATFORM_CE
#ifdef _WIN64
#pragma warning (disable : 4716)
#else
#pragma warning (disable : 4715)
#endif
DWORD ThreadpoolMgr::TimerThreadStart(LPVOID args)
{
    _ASSERTE(NULL == args);
    
    // Timer threads never die

    LastTickCount = GetTickCount();

    DWORD timeout = (DWORD) -1; // largest possible value


    CoInitializeEx(NULL,COINIT_MULTITHREADED);

    for (;;)
    {
        DWORD timeout = FireTimers();

        LastTickCount = GetTickCount();

        DWORD status = SleepEx(timeout, TRUE);

        // the thread could wake up either because an APC completed or the sleep timeout
        // in both case, we need to sweep the timer queue, firing timers, and readjusting 
        // the next firing time


    }
}
#ifdef _WIN64
#pragma warning (default : 4716)
#else
#pragma warning (default : 4715)
#endif

// Executed as an APC in timer thread
void ThreadpoolMgr::InsertNewTimer(TimerInfo* pArg)
{
    _ASSERTE(pArg);
	TimerInfo * timerInfo = pArg;

    if (timerInfo->state & TIMER_DELETE)
    {   // timer was deleted before it could be registered
        DeleteTimer(timerInfo);
        return;
    }

    // set the firing time = current time + due time (note initially firing time = due time)
    DWORD currentTime = GetTickCount();
    if (timerInfo->FiringTime == -1)
    {
        timerInfo->state = TIMER_REGISTERED;
        timerInfo->refCount = 1;

    }
    else
    {
        timerInfo->FiringTime += currentTime;

        timerInfo->state = (TIMER_REGISTERED | TIMER_ACTIVE);
        timerInfo->refCount = 1;

        // insert the timer in the queue
        InsertTailList(&TimerQueue,(&timerInfo->link));
    }

	LOG((LF_THREADPOOL ,LL_INFO1000 ,"Timer created, period= %x, Function = %x\n",
		          timerInfo->Period, timerInfo->Function));

    return;
}


// executed by the Timer thread
// sweeps through the list of timers, readjusting the firing times, queueing APCs for
// those that have expired, and returns the next firing time interval
DWORD ThreadpoolMgr::FireTimers()
{

    DWORD currentTime = GetTickCount();

    DWORD nextFiringInterval = (DWORD) -1;

    for (LIST_ENTRY* node = (LIST_ENTRY*) TimerQueue.Flink;
         node != &TimerQueue;
        )
    {
        TimerInfo* timerInfo = (TimerInfo*) node;
        node = (LIST_ENTRY*) node->Flink;

        if (TimeExpired(LastTickCount, currentTime, timerInfo->FiringTime))
        {
            if (timerInfo->Period == 0 || timerInfo->Period == -1)
            {
                DeactivateTimer(timerInfo);
            }

            InterlockedIncrement((LPLONG) &timerInfo->refCount ) ;

            QueueUserWorkItem(AsyncTimerCallbackCompletion,
                              timerInfo,
                              0 /* TimerInfo take care of deleting*/);
                
            timerInfo->FiringTime = currentTime+timerInfo->Period;

            if ((timerInfo->Period != 0) && (timerInfo->Period != -1) && (nextFiringInterval > timerInfo->Period))
                nextFiringInterval = timerInfo->Period;
        }

        else
        {
            DWORD firingInterval = TimeInterval(timerInfo->FiringTime,currentTime);
            if (firingInterval < nextFiringInterval)
                nextFiringInterval = firingInterval; 
        }
    }

    return nextFiringInterval;
}

DWORD ThreadpoolMgr::AsyncTimerCallbackCompletion(PVOID pArgs)
{
    TimerInfo* timerInfo = (TimerInfo*) pArgs;
    ((WAITORTIMERCALLBACKFUNC) timerInfo->Function) (timerInfo->Context, TRUE) ;

    if (InterlockedDecrement((LPLONG) &timerInfo->refCount) == 0)
        DeleteTimer(timerInfo);

    return 0; /* ignored */
}


// removes the timer from the timer queue, thereby cancelling it
// there may still be pending callbacks that haven't completed
void ThreadpoolMgr::DeactivateTimer(TimerInfo* timerInfo)
{
    RemoveEntryList((LIST_ENTRY*) timerInfo);

    timerInfo->state = timerInfo->state & ~TIMER_ACTIVE;
}

void ThreadpoolMgr::DeleteTimer(TimerInfo* timerInfo)
{
    _ASSERTE((timerInfo->state & TIMER_ACTIVE) == 0);

    if (timerInfo->Context && (timerInfo->flag & WAIT_FREE_CONTEXT)) 
        delete timerInfo->Context;

    if (timerInfo->CompletionEvent != INVALID_HANDLE)
        SetEvent(timerInfo->CompletionEvent);

    delete timerInfo;
}

#endif // !PLATFORM_CE
/************************************************************************/
BOOL ThreadpoolMgr::ChangeTimerQueueTimer(
                                        HANDLE Timer,
                                        ULONG DueTime,
                                        ULONG Period)
{
	THROWSCOMPLUSEXCEPTION();
#ifdef PLATFORM_CE
    ::SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return FALSE;
#else // !PLATFORM_CE
	_ASSERTE(Initialized);
    _ASSERTE(Timer);                    // not possible to give invalid handle in managed code

    TimerUpdateInfo* updateInfo = new TimerUpdateInfo;
	if (NULL == updateInfo)
		COMPlusThrow(kOutOfMemoryException);

    updateInfo->Timer = (TimerInfo*) Timer;
    updateInfo->DueTime = DueTime;
    updateInfo->Period = Period;

	BOOL status = QueueUserAPC((PAPCFUNC)UpdateTimer,
                               TimerThread,
                               (size_t) updateInfo);

    return status;
#endif // !PLATFORM_CE
}

#ifndef PLATFORM_CE
void ThreadpoolMgr::UpdateTimer(TimerUpdateInfo* pArgs)
{
    TimerUpdateInfo* updateInfo = (TimerUpdateInfo*) pArgs;
    TimerInfo* timerInfo = updateInfo->Timer;

    timerInfo->Period = updateInfo->Period;

    if (updateInfo->DueTime == -1)
    {
        if (timerInfo->state & TIMER_ACTIVE)
        {
            DeactivateTimer(timerInfo);
        }
        // else, noop (the timer was already inactive)
        _ASSERTE((timerInfo->state & TIMER_ACTIVE) == 0);
	    LOG((LF_THREADPOOL ,LL_INFO1000 ,"Timer inactive, period= %x, Function = %x\n",
		         timerInfo->Period, timerInfo->Function));
        
        delete updateInfo;
        return;
    }

    DWORD currentTime = GetTickCount();
    timerInfo->FiringTime = currentTime + updateInfo->DueTime;

    delete updateInfo;
    
    if (! (timerInfo->state & TIMER_ACTIVE))
    {
        // timer not active (probably a one shot timer that has expired), so activate it
        timerInfo->state |= TIMER_ACTIVE;
        _ASSERTE(timerInfo->refCount >= 1);
        // insert the timer in the queue
        InsertTailList(&TimerQueue,(&timerInfo->link));
        
    }

	LOG((LF_THREADPOOL ,LL_INFO1000 ,"Timer changed, period= %x, Function = %x\n",
		     timerInfo->Period, timerInfo->Function));

    return;
}
#endif // !PLATFORM_CE
/************************************************************************/
BOOL ThreadpoolMgr::DeleteTimerQueueTimer(
                                        HANDLE Timer,
                                        HANDLE Event)
{
#ifdef PLATFORM_CE
    ::SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return FALSE;
#else // !PLATFORM_CE

    _ASSERTE(Initialized);       // cannot call delete before creating timer

    _ASSERTE(Timer);                    // not possible to give invalid handle in managed code

    WaitEvent* CompletionEvent = NULL; 

    if (Event == (HANDLE) -1)
    {
        CompletionEvent = GetWaitEvent();
    }

    TimerInfo* timerInfo = (TimerInfo*) Timer;

    timerInfo->CompletionEvent = CompletionEvent ? CompletionEvent->Handle : Event;

	BOOL status = QueueUserAPC((PAPCFUNC)DeregisterTimer,
                               TimerThread,
                               (size_t) timerInfo);

    if (FALSE == status)
    {
        if (CompletionEvent)
            FreeWaitEvent(CompletionEvent);
        return FALSE;
    }

    if (CompletionEvent)
    {
        WaitForSingleObject(CompletionEvent->Handle,INFINITE);
        FreeWaitEvent(CompletionEvent);
    }
    return status;
#endif // !PLATFORM_CE
}

#ifndef PLATFORM_CE

void ThreadpoolMgr::DeregisterTimer(TimerInfo* pArgs)
{

    TimerInfo* timerInfo = (TimerInfo*) pArgs;

    if (! (timerInfo->state & TIMER_REGISTERED) )
    {
        // set state to deleted, so that it does not get registered
        timerInfo->state |= WAIT_DELETE ;
        
        // since the timer has not even been registered, we dont need an interlock to decrease the RefCount
        timerInfo->refCount--;

        return;
    }

    if (timerInfo->state & WAIT_ACTIVE) 
    {
        DeactivateTimer(timerInfo);
    }

	LOG((LF_THREADPOOL ,LL_INFO1000 ,"Timer deregistered\n"));

    if (InterlockedDecrement ((LPLONG) &timerInfo->refCount) == 0 ) 
    {
        DeleteTimer(timerInfo);
    }
    return;
}

void ThreadpoolMgr::CleanupTimerQueue()
{

}
#endif // !PLATFORM_CE
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\win32threadpool.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*++

Module Name:

    Win32ThreadPool.h

Abstract:

    This module is the header file for thread pools using Win32 APIs. 

Revision History:

    Dec 1999 - Sanjay Bhansali - Created

--*/
//#include <windows.h>
//#include <CRTDBG.H>

#ifndef _WIN32THREADPOOL_H
#define _WIN32THREADPOOL_H

#include "delegateinfo.h"
#include <member-offset-info.h>

typedef VOID (*WAITORTIMERCALLBACK)(PVOID, BOOL); 

#define MAX_WAITHANDLES 64

#define MAX_CACHED_EVENTS 40        // upper limit on number of wait events cached 

#define WAIT_REGISTERED     0x01
#define WAIT_ACTIVE         0x02
#define WAIT_DELETE         0x04

#define TIMER_REGISTERED    0x01
#define TIMER_ACTIVE        0x02
#define TIMER_DELETE        0x04

const int MaxLimitThreadsPerCPU=25;               //  upper limit on number of cp threads per CPU
const int MinLimitCPThreadsPerCPU=0;
const int MaxFreeCPThreadsPerCPU=2;                 //  upper limit on number of  free cp threads per CPU

const int CpuUtilizationHigh=95;                    // remove threads when above this
const int CpuUtilizationLow =80;                    // inject more threads if below this
const int CpuUtilizationVeryLow =20;                // start shrinking threadpool below this


/* THREADINFOCLASS, SYSTEMINFORMATIONCLASS, and SYSTEM_PROCESSOR_PERFORMANCE_INFORMATION
 * have been copied from ntexapi.h
 * @TODO: need some way of making sure that these structures are in sync with the 
 * definitions in those files. Ideally, this header file should be included in our build.
 */
extern HANDLE (WINAPI *g_pufnCreateIoCompletionPort)(HANDLE FileHandle,
                                              HANDLE ExistingCompletionPort,  
                                              unsigned long* CompletionKey,        
                                              DWORD NumberOfConcurrentThreads);

typedef enum _THREADINFOCLASS {
    ThreadBasicInformation,
    ThreadTimes,
    ThreadPriority,
    ThreadBasePriority,
    ThreadAffinityMask,
    ThreadImpersonationToken,
    ThreadDescriptorTableEntry,
    ThreadEnableAlignmentFaultFixup,
    ThreadEventPair_Reusable,
    ThreadQuerySetWin32StartAddress,
    ThreadZeroTlsCell,
    ThreadPerformanceCount,
    ThreadAmILastThread,
    ThreadIdealProcessor,
    ThreadPriorityBoost,
    ThreadSetTlsArrayAddress,
    ThreadIsIoPending,
    ThreadHideFromDebugger,
    MaxThreadInfoClass
    } THREADINFOCLASS;

extern int (WINAPI *g_pufnNtQueryInformationThread) (HANDLE ThreadHandle,
                                              THREADINFOCLASS ThreadInformationClass,
                                              PVOID ThreadInformation,
                                              ULONG ThreadInformationLength,
                                              PULONG ReturnLength);
typedef enum _SYSTEM_INFORMATION_CLASS {
    SystemBasicInformation,
    SystemProcessorInformation,             
    SystemPerformanceInformation,
    SystemTimeOfDayInformation,
    SystemPathInformation,
    SystemProcessInformation,
    SystemCallCountInformation,
    SystemDeviceInformation,
    SystemProcessorPerformanceInformation,
    SystemFlagsInformation,
    SystemCallTimeInformation,
    SystemModuleInformation,
    SystemLocksInformation,
    SystemStackTraceInformation,
    SystemPagedPoolInformation,
    SystemNonPagedPoolInformation,
    SystemHandleInformation,
    SystemObjectInformation,
    SystemPageFileInformation,
    SystemVdmInstemulInformation,
    SystemVdmBopInformation,
    SystemFileCacheInformation,
    SystemPoolTagInformation,
    SystemInterruptInformation,
    SystemDpcBehaviorInformation,
    SystemFullMemoryInformation,
    SystemLoadGdiDriverInformation,
    SystemUnloadGdiDriverInformation,
    SystemTimeAdjustmentInformation,
    SystemSummaryMemoryInformation,
    SystemMirrorMemoryInformation,
    SystemPerformanceTraceInformation,
    SystemCrashDumpInformation,
    SystemExceptionInformation,
    SystemCrashDumpStateInformation,
    SystemKernelDebuggerInformation,
    SystemContextSwitchInformation,
    SystemRegistryQuotaInformation,
    SystemExtendServiceTableInformation,
    SystemPrioritySeperation,
    SystemVerifierAddDriverInformation,
    SystemVerifierRemoveDriverInformation,
    SystemProcessorIdleInformation,
    SystemLegacyDriverInformation,
    SystemCurrentTimeZoneInformation,
    SystemLookasideInformation,
    SystemTimeSlipNotification,
    SystemSessionCreate,
    SystemSessionDetach,
    SystemSessionInformation,
    SystemRangeStartInformation,
    SystemVerifierInformation,
    SystemVerifierThunkExtend,
    SystemSessionProcessInformation,
    SystemLoadGdiDriverInSystemSpace,
    SystemNumaProcessorMap,
    SystemPrefetcherInformation,
    SystemExtendedProcessInformation,
    SystemRecommendedSharedDataAlignment
} SYSTEM_INFORMATION_CLASS;

typedef struct _SYSTEM_PROCESSOR_PERFORMANCE_INFORMATION {
    __int64 IdleTime;
    __int64 KernelTime;
    __int64 UserTime;
    __int64 DpcTime;          
    __int64 InterruptTime;    
    ULONG InterruptCount;
} SYSTEM_PROCESSOR_PERFORMANCE_INFORMATION;

extern int (WINAPI * g_pufnNtQuerySystemInformation) (SYSTEM_INFORMATION_CLASS SystemInformationClass,
                                                      PVOID SystemInformation,
                                                      ULONG SystemInformationLength,
                                                      PULONG ReturnLength OPTIONAL);

typedef enum _EVENT_TYPE {
    NotificationEvent,
    SynchronizationEvent
    } EVENT_TYPE;

typedef struct _EVENT_BASIC_INFORMATION {
    EVENT_TYPE EventType;
    LONG EventState;
} EVENT_BASIC_INFORMATION, *PEVENT_BASIC_INFORMATION;

typedef enum _EVENT_INFORMATION_CLASS {
    EventBasicInformation
    } EVENT_INFORMATION_CLASS;

extern int (WINAPI * g_pufnNtQueryEvent) (HANDLE EventHandle,
										  EVENT_INFORMATION_CLASS EventInformationClass,
										  PVOID EventInformation,
										  ULONG EventInformationLength,
										  PULONG ReturnLength OPTIONAL);

#define FILETIME_TO_INT64(t) (*(__int64*)&(t))
#define MILLI_TO_100NANO(x)  (x * 10000)        // convert from milliseond to 100 nanosecond unit

/**
 * This type is supposed to be private to ThreadpoolMgr.
 * It's at global scope because Strike needs to be able to access its
 * definition.
 */
struct WorkRequest {
    WorkRequest*            next;
    LPTHREAD_START_ROUTINE  Function; 
    PVOID                   Context;

};

class ThreadpoolMgr
{
    friend struct DelegateInfo;
    friend struct MEMBER_OFFSET_INFO(ThreadpoolMgr);
public:

   	// enumeration of different kinds of memory blocks that are recycled
	enum MemType
	{
		MEMTYPE_AsyncCallback   = 0,
		MEMTYPE_DelegateInfo	= 1,
		MEMTYPE_WorkRequest		= 2,
		MEMTYPE_COUNT			= 3,
	};

	static void Initialize();
#ifdef SHOULD_WE_CLEANUP
    static void Terminate();
#endif /* SHOULD_WE_CLEANUP */

    static BOOL SetMaxThreadsHelper(DWORD MaxWorkerThreads,
                                        DWORD MaxIOCompletionThreads);

    static BOOL SetMaxThreads(DWORD MaxWorkerThreads, 
                              DWORD MaxIOCompletionThreads);

    static BOOL GetMaxThreads(DWORD* MaxWorkerThreads, 
                              DWORD* MaxIOCompletionThreads);
    
    static BOOL SetMinThreads(DWORD MinWorkerThreads, 
                              DWORD MinIOCompletionThreads);

    static BOOL GetMinThreads(DWORD* MinWorkerThreads, 
                              DWORD* MinIOCompletionThreads);

    static BOOL GetAvailableThreads(DWORD* AvailableWorkerThreads, 
                                 DWORD* AvailableIOCompletionThreads);

    static BOOL QueueUserWorkItem(LPTHREAD_START_ROUTINE Function, 
                                  PVOID Context,
                                  ULONG Flags);

    static BOOL RegisterWaitForSingleObject(PHANDLE phNewWaitObject,
                                            HANDLE hWaitObject,
                                            WAITORTIMERCALLBACK Callback,
                                            PVOID Context,
                                            ULONG timeout,
                                            DWORD dwFlag);

    static BOOL UnregisterWaitEx(HANDLE hWaitObject,HANDLE CompletionEvent);
    static void WaitHandleCleanup(HANDLE hWaitObject);

#ifndef PLATFORM_CE
    static BOOL BindIoCompletionCallback(HANDLE FileHandle,
                                            LPOVERLAPPED_COMPLETION_ROUTINE Function,
                                            ULONG Flags );
#endif // !PLATFORM_CE

    static BOOL CreateTimerQueueTimer(PHANDLE phNewTimer,
                                        WAITORTIMERCALLBACK Callback,
                                        PVOID Parameter,
                                        DWORD DueTime,
                                        DWORD Period,
                                        ULONG Flags);

    static BOOL ChangeTimerQueueTimer(HANDLE Timer,
                                      ULONG DueTime,
                                      ULONG Period);


    static BOOL DeleteTimerQueueTimer(HANDLE Timer,
                                      HANDLE CompletionEvent);

    static BOOL ThreadAboutToBlock(Thread* pThread);    // Informs threadpool that a threadpool thread is about to block

    static void ThreadAboutToUnblock();             // Informs threadpool that a threadpool thread is about to unblock

   	static void RecycleMemory(LPVOID* mem, enum MemType memType);

private:
		
    // private types
    inline static WorkRequest* MakeWorkRequest(LPTHREAD_START_ROUTINE  function, PVOID context)
    {
        WorkRequest* wr = (WorkRequest*) GetRecycledMemory(MEMTYPE_WorkRequest);
        _ASSERTE(wr);
		if (NULL == wr)
			return NULL;
        wr->Function = function;
        wr->Context = context;
        wr->next = NULL;
        return wr;
    }

    typedef struct {
        DWORD numBytes;
        PULONG_PTR key;
        LPOVERLAPPED pOverlapped;
        DWORD errorCode;
    } QueuedStatus;

    typedef struct {
        PVOID       Flink;
        PVOID       Blink;
    } LIST_ENTRY;

    struct WaitInfo;

    typedef struct {
        HANDLE          threadHandle;
        DWORD           threadId;
        int             NumWaitHandles;                 // number of wait objects registered to the thread <=64
        int             NumActiveWaits;                 // number of objects, thread is actually waiting on (this may be less than
                                                           // NumWaitHandles since the thread may not have activated some waits
        HANDLE          waitHandle[MAX_WAITHANDLES];    // array of wait handles (copied from waitInfo since 
                                                           // we need them to be contiguous)
        LIST_ENTRY      waitPointer[MAX_WAITHANDLES];   // array of doubly linked list of corresponding waitinfo 
    } ThreadCB;


    typedef struct {
        ULONG               startTime;          // time at which wait was started
                                                // endTime = startTime+timeout
        ULONG               remainingTime;      // endTime - currentTime
    } WaitTimerInfo;

    struct  WaitInfo {
        LIST_ENTRY          link;               // Win9x does not allow duplicate waithandles, so we need to
                                                // group all waits on a single waithandle using this linked list
        HANDLE              waitHandle;
        WAITORTIMERCALLBACK Callback;
        PVOID               Context;
        ULONG               timeout;                
        WaitTimerInfo       timer;              
        DWORD               flag;
        ThreadCB*           threadCB;
        DWORD               state;
        DWORD               refCount;                // when this reaches 0, the waitInfo can be safely deleted
        HANDLE              CompletionEvent;         // signalled when all callbacks have completed (refCount=0)
        HANDLE              PartialCompletionEvent;  // used to synchronize deactivation of a wait
    } ;

    // structure used to maintain global information about wait threads. Protected by WaitThreadsCriticalSection
    typedef struct WaitThreadTag {
        LIST_ENTRY      link;
        ThreadCB*       threadCB;   
    } WaitThreadInfo;


    struct AsyncCallback{
        WaitInfo*   wait;
        BOOL        waitTimedOut;

    } ;
    inline static AsyncCallback* MakeAsyncCallback()
    {
        return (AsyncCallback*) GetRecycledMemory(MEMTYPE_AsyncCallback);
    }

    typedef struct {
        LIST_ENTRY link ;
        HANDLE Handle ;
    
    } WaitEvent ;

        // Timer 

    typedef struct {
        LIST_ENTRY  link;           // doubly linked list of timers
        ULONG FiringTime;           // TickCount of when to fire next
        PVOID Function ;            // Function to call when timer fires
        PVOID Context ;             // Context to pass to function when timer fires
        ULONG Period ; 
        DWORD flag;                 // How do we deal with the context
        DWORD state;
        DWORD refCount;
        HANDLE CompletionEvent;
        
    } TimerInfo;

    typedef struct {
        TimerInfo* Timer;           // timer to be updated
        ULONG DueTime ;             // new due time
        ULONG Period ;              // new period
    } TimerUpdateInfo;

	// Definitions and data structures to support recycling of high-frequency 
	// memory blocks. We use a blocking-free implementation that uses a 
	// cmpxchg8b operation for delete


	typedef struct {
		void*	root;			// ptr to first element of recycled list
		DWORD   tag;			// cyclic ctr to makes sure we don't have the ABA problem
		                        // while deleting from the list  
		DWORD   count;			// approx. count of number of elements in the list (approx. because not thread safe)
	} RecycledListInfo;



    // Private methods
#ifndef PLATFORM_CE
    static BOOL ShouldGrowWorkerThreadPool();

	static HANDLE CreateUnimpersonatedThread(LPTHREAD_START_ROUTINE lpStartAddress, LPVOID lpArgs);

    static BOOL CreateWorkerThread();

    static BOOL EnqueueWorkRequest(LPTHREAD_START_ROUTINE Function, 
                                   PVOID Context);

    static WorkRequest* DequeueWorkRequest();

    static void ExecuteWorkRequest(WorkRequest* workRequest);

    inline static void AppendWorkRequest(WorkRequest* entry)
    {
        if (WorkRequestTail)
        {
            _ASSERTE(WorkRequestHead != NULL && NumQueuedWorkRequests >= 0);
            WorkRequestTail->next = entry;
        }
        else
        {
            _ASSERTE(WorkRequestHead == NULL && NumQueuedWorkRequests == 0);
            WorkRequestHead = entry;
        }

        WorkRequestTail = entry;
        _ASSERTE(WorkRequestTail->next == NULL);

        NumQueuedWorkRequests++;
    }

    inline static WorkRequest* RemoveWorkRequest()
    {
        WorkRequest* entry = NULL;
        if (WorkRequestHead)
        {
            entry = WorkRequestHead;
            WorkRequestHead = entry->next;
            if (WorkRequestHead == NULL)
                WorkRequestTail = NULL;
            _ASSERTE(NumQueuedWorkRequests > 0);
            NumQueuedWorkRequests--;
        }
        return entry;
    }


	static void EnsureInitialized();
	static void InitPlatformVariables();

    static void GrowWorkerThreadPoolIfStarvation(long cpuUtilization);
    static void GrowWorkerThreadPoolIfStarvation_Win9x();

    static DWORD WorkerThreadStart(LPVOID lpArgs);

    static BOOL AddWaitRequest(HANDLE waitHandle, WaitInfo* waitInfo);


    static ThreadCB* FindWaitThread();              // returns a wait thread that can accomodate another wait request

    static BOOL CreateWaitThread();

	static void InsertNewWaitForSelf(WaitInfo* pArg);

    static int FindWaitIndex(const ThreadCB* threadCB, const HANDLE waitHandle);

    static DWORD MinimumRemainingWait(LIST_ENTRY* waitInfo, unsigned int numWaits);

    static void ProcessWaitCompletion( WaitInfo* waitInfo,
                                unsigned index,      // array index 
                                BOOL waitTimedOut);

    static DWORD WaitThreadStart(LPVOID lpArgs);

    static DWORD AsyncCallbackCompletion(PVOID pArgs);

    static void DeactivateWait(WaitInfo* waitInfo);
    static void DeactivateNthWait(WaitInfo* waitInfo, DWORD index);

    static void DeleteWait(WaitInfo* waitInfo);


    inline static void ShiftWaitArray( ThreadCB* threadCB, 
                                       ULONG SrcIndex, 
                                       ULONG DestIndex, 
                                       ULONG count)
    {
        memcpy(&threadCB->waitHandle[DestIndex],
               &threadCB->waitHandle[SrcIndex],
               count * sizeof(HANDLE));
        memcpy(&threadCB->waitPointer[DestIndex],
               &threadCB->waitPointer[SrcIndex],
               count * sizeof(LIST_ENTRY));
    }

	static void DeregisterWait(WaitInfo* pArgs);

    static BOOL CreateCompletionPortThread(LPVOID lpArgs);
    static DWORD CompletionPortThreadStart(LPVOID lpArgs);
    static BOOL IsIoPending();


    static BOOL ShouldExitThread();
    static void GrowCompletionPortThreadpoolIfNeeded();
    static BOOL CreateGateThread();
    static DWORD GateThreadStart(LPVOID lpArgs);
    static BOOL SufficientDelaySinceLastSample(unsigned int LastThreadCreationTime, 
		                                       unsigned NumThreads,	        // total number of threads of that type (worker or CP)
					                           double   throttleRate=0.0    // the delay is increased by this percentage for each extra thread
											   );
    static BOOL SufficientDelaySinceLastDequeue();
    //static BOOL SufficientDelaySinceLastCompletion();


    static __int64 GetCPUBusyTime_NT(SYSTEM_PROCESSOR_PERFORMANCE_INFORMATION** pOldInfo);
    static __int64 GetCPUBusyTime_Win32(__int64 *pOldCpuBusyTime);

    static LPVOID   GetRecycledMemory(enum MemType memType);

    static WaitEvent* GetWaitEvent();
    static void FreeWaitEvent(WaitEvent* waitEvent);
    static void CleanupEventCache();

    static DWORD TimerThreadStart(LPVOID args);
	static void InsertNewTimer(TimerInfo* pArg);
    static DWORD FireTimers();
    static DWORD AsyncTimerCallbackCompletion(PVOID pArgs);
    static void DeactivateTimer(TimerInfo* timerInfo);
    static void DeleteTimer(TimerInfo* timerInfo);
	static void UpdateTimer(TimerUpdateInfo* pArgs);

	static void DeregisterTimer(TimerInfo* pArgs);
    static void CleanupTimerQueue();

#endif // !PLATFORM_CE

    // Private variables

	static long BeginInitialization;				
	static BOOL Initialized;						// indicator of whether the threadpool is initialized.

    static int NumWorkerThreads;                    // total number of worker threads created
    static int MinLimitTotalWorkerThreads;          // same as MinLimitTotalCPThreads
    static int MaxLimitTotalWorkerThreads;          // same as MaxLimitTotalCPThreads
    static int NumRunningWorkerThreads;             // = NumberOfWorkerThreads - no. of blocked threads
    static int NumIdleWorkerThreads;                // Threads waiting for work

    static BOOL MonitorWorkRequestsQueue;           // indicator to gate thread to monitor progress of WorkRequestQueue to prevent starvation due to blocked worker threads



    static int NumQueuedWorkRequests;               // number of queued work requests
    static int LastRecordedQueueLength;				// captured by GateThread, used on Win9x to detect thread starvation 
	static unsigned int LastDequeueTime;			// used to determine if work items are getting thread starved 
    static unsigned int LastCompletionTime;			// used to determine if last thread can be terminated 
    static WorkRequest* WorkRequestHead;            // Head of work request queue
    static WorkRequest* WorkRequestTail;            // Head of work request queue


    //static unsigned int LastCpuSamplingTime;		// last time cpu utilization was sampled by gate thread
    static unsigned int LastWorkerThreadCreation;   // last time a worker thread was created
    static unsigned int LastCPThreadCreation;		// last time a completion port thread was created
    static unsigned int NumberOfProcessors;         // = NumberOfWorkerThreads - no. of blocked threads


    static CRITICAL_SECTION WorkerCriticalSection;
    static HANDLE WorkRequestNotification;
    static HANDLE RetiredWakeupEvent;    

    static CRITICAL_SECTION WaitThreadsCriticalSection;
    static LIST_ENTRY WaitThreadsHead;                  // queue of wait threads, each thread can handle upto 64 waits

    static CRITICAL_SECTION EventCacheCriticalSection;
    static LIST_ENTRY EventCache;                      // queue of cached events
    static DWORD NumUnusedEvents;                      // number of events in cache

    static CRITICAL_SECTION TimerQueueCriticalSection;  // critical section to synchronize timer queue access
    static LIST_ENTRY TimerQueue;                       // queue of timers
    static DWORD NumTimers;                             // number of timers in queue
    static HANDLE TimerThread;                          // Currently we only have one timer thread
    static DWORD LastTickCount;                         // the count just before timer thread goes to sleep

    static BOOL InitCompletionPortThreadpool;           // flag indicating whether completion port threadpool has been initialized
    static HANDLE GlobalCompletionPort;                 // used for binding io completions on file handles
    static int    NumCPThreads;                         // number of completion port threads

    static long   MaxLimitTotalCPThreads;               // = MaxLimitCPThreadsPerCPU * number of CPUS
    static long   CurrentLimitTotalCPThreads;           // current limit on total number of CP threads
    static long   MinLimitTotalCPThreads;               // = MinLimitCPThreadsPerCPU * number of CPUS

    static int    NumFreeCPThreads;                     // number of cp threads waiting on the port
    static int    MaxFreeCPThreads;                     // = MaxFreeCPThreadsPerCPU * Number of CPUS
    static int    NumRetiredCPThreads;              // number of threads in "retired" pool with pending io
    static long   GateThreadCreated;                    // Set to 1 after the thread is created
    static long   cpuUtilization;                       // as a percentage

	static unsigned MaxCachedRecyledLists;				// don't cache freed memory after this 
	static			RecycledListInfo RecycledList[MEMTYPE_COUNT];

};




#endif // _WIN32THREADPOOL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\vertable.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*
 * Types for pop stack/push stack
 * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 * 1  I1/U1
 * 2  I2/U2
 * 4  I4/U4
 * 8  I8/U8
 * r  R4
 * d  R8
 * o  objref (can be an array or null)
 * [  single dimensional array of (prefix)
 * &  byref/managed ptr (prefix)
 *
 * Pop only
 * ~~~~~~~~
 * R  real number
 * N  number -any integer or real number
 * Q  number or unmanaged pointer
 * X  number, unmanaged pointer, managed pointer, or objref [Obsolete]
 * Y  integer (I1..I4), unmanaged pointer, managed pointer, or objref
 * I  Integral type (1, 2, 4, or 8 byte, or platform-independent integer type)
 * A  Anything
 *
 * CE "ceq" semantics - pop 2 arguments, do type checking as if for "ceq" instruction:
 *                      Integer     Real     ManagedPtr     UnmanagedPtr   Objref
 *       Integer           y               
 *       Real                        y
 *       ManagedPtr                             y                             y
 *       UnmanagedPtr                                            y
 *       Objref                                 y                             y
 *
 * CG "cgt" semantics - pop 2 arguments, do type checking as if for "cgt" instruction:
 *                      Integer     Real     ManagedPtr     UnmanagedPtr   Objref
 *       Integer           y               
 *       Real                        y
 *       ManagedPtr                                                           y
 *       UnmanagedPtr                                            
 *       Objref                                 y                             
 * 
 * =  Pop another item off the stack, and it must be the same type (int,real,objref,etc.) as the 
 *    last item popped (note, System.Int32 <-> I4 etc. are allowed).  Other value 
 *    classes are NOT allowed.
 *
 * i  (deprecated) Platform independent size value, but NOT an objref (I4/R4/ptr on 32-bit, I8/R8/ptr on 64-bit)
 * p  (deprecated) Platform independent size value OR objref 
 * *  (deprecated) anything

 * Push only
 * ~~~~~~~~~
 * n  null objref (valid for push only)
 * -  Rewind the stack to undo the last pop (you cannot have trashed that location, though)
 *
 * Usage: <pop stack> : <operand checks> <push stack> <branches> <!>
 *
 * Order is important!  Operand checks come after pop stack and before push stack.
 * For example, to check the operand being a valid local variable number (only), do ":L"
 *
 * If there is a "!" at the end, it means the instruction is either invalid, not supported, or that
 * there is a case statement to handle the instruction.  If no case statement exists, the verifier
 * will fail verification of the method.
 *
 * ! can be used to perform some operand checks and/or stack pops/pushes, while still allowing specific
 * behavior; e.g. verifying that the inline operand is a valid local variable number.
 *
 * <operand checks>
 * ~~~~~~~~~~~~~~~~
 * #d Overwrite inline operand with digit "d" (must be in 0...9 range)
 * L  Check that the operand is a valid local variable number.
 * A  Check that the operand is a valid argument number.
 *
 * <branches>
 * ~~~~~~~~~~
 * b1 - one byte conditional branch
 * b4 - four byte conditional branch
 * u1 - one byte unconditional branch
 * u4 - four byte unconditional branch
 * l1 - one byte leave
 * l4 - one byte leave
 *
 */

VEROPCODE(CEE_NOP,                      ":")
VEROPCODE(CEE_BREAK,                    ":")
VEROPCODE(CEE_LDARG_0,                  ":#0A!")
VEROPCODE(CEE_LDARG_1,                  ":#1A!")
VEROPCODE(CEE_LDARG_2,                  ":#2A!")
VEROPCODE(CEE_LDARG_3,                  ":#3A!")
VEROPCODE(CEE_LDLOC_0,                  ":#0L!")
VEROPCODE(CEE_LDLOC_1,                  ":#1L!")
VEROPCODE(CEE_LDLOC_2,                  ":#2L!")
VEROPCODE(CEE_LDLOC_3,                  ":#3L!")
VEROPCODE(CEE_STLOC_0,                  ":#0L!")
VEROPCODE(CEE_STLOC_1,                  ":#1L!")
VEROPCODE(CEE_STLOC_2,                  ":#2L!")
VEROPCODE(CEE_STLOC_3,                  ":#3L!")
VEROPCODE(CEE_LDARG_S,                  ":A!")
VEROPCODE(CEE_LDARGA_S,                 ":A!")
VEROPCODE(CEE_STARG_S,                  ":A!")
VEROPCODE(CEE_LDLOC_S,                  ":L!")
VEROPCODE(CEE_LDLOCA_S,                 ":L!")
VEROPCODE(CEE_STLOC_S,                  ":L!")
VEROPCODE(CEE_LDNULL,                   ":n")
VEROPCODE(CEE_LDC_I4_M1,                ":4")
VEROPCODE(CEE_LDC_I4_0,                 ":4")
VEROPCODE(CEE_LDC_I4_1,                 ":4")
VEROPCODE(CEE_LDC_I4_2,                 ":4")
VEROPCODE(CEE_LDC_I4_3,                 ":4")
VEROPCODE(CEE_LDC_I4_4,                 ":4")
VEROPCODE(CEE_LDC_I4_5,                 ":4")
VEROPCODE(CEE_LDC_I4_6,                 ":4")
VEROPCODE(CEE_LDC_I4_7,                 ":4")
VEROPCODE(CEE_LDC_I4_8,                 ":4")
VEROPCODE(CEE_LDC_I4_S,                 ":4")
VEROPCODE(CEE_LDC_I4,                   ":4")
VEROPCODE(CEE_LDC_I8,                   ":8")
VEROPCODE(CEE_LDC_R4,                   ":r")
VEROPCODE(CEE_LDC_R8,                   ":d")
VEROPCODE(CEE_UNUSED49,                 "!") 
VEROPCODE(CEE_DUP,                      "!")
VEROPCODE(CEE_POP,                      "A:")
VEROPCODE(CEE_JMP,                      "!")            // Unverifiable !
VEROPCODE(CEE_CALL,                     "!")
VEROPCODE(CEE_CALLI,                    "!")
VEROPCODE(CEE_RET,                      "!")
VEROPCODE(CEE_BR_S,                     ":u1")
VEROPCODE(CEE_BRFALSE_S,                "Y:b1")
VEROPCODE(CEE_BRTRUE_S,                 "Y:b1")
VEROPCODE(CEE_BEQ_S,                    "CE:b1")
VEROPCODE(CEE_BGE_S,                    "CG:b1")
VEROPCODE(CEE_BGT_S,                    "CG:b1")
VEROPCODE(CEE_BLE_S,                    "CG:b1")
VEROPCODE(CEE_BLT_S,                    "CG:b1")
VEROPCODE(CEE_BNE_UN_S,                 "CE:b1")
VEROPCODE(CEE_BGE_UN_S,                 "CG:b1")
VEROPCODE(CEE_BGT_UN_S,                 "CG:b1")
VEROPCODE(CEE_BLE_UN_S,                 "CG:b1")
VEROPCODE(CEE_BLT_UN_S,                 "CG:b1")
VEROPCODE(CEE_BR,                       ":u4")
VEROPCODE(CEE_BRFALSE,                  "Y:b4")
VEROPCODE(CEE_BRTRUE,                   "Y:b4")
VEROPCODE(CEE_BEQ,                      "CE:b4")
VEROPCODE(CEE_BGE,                      "CG:b4")
VEROPCODE(CEE_BGT,                      "CG:b4")
VEROPCODE(CEE_BLE,                      "CG:b4")
VEROPCODE(CEE_BLT,                      "CG:b4")
VEROPCODE(CEE_BNE_UN,                   "CE:b4")
VEROPCODE(CEE_BGE_UN,                   "CG:b4")
VEROPCODE(CEE_BGT_UN,                   "CG:b4")
VEROPCODE(CEE_BLE_UN,                   "CG:b4")
VEROPCODE(CEE_BLT_UN,                   "CG:b4")
VEROPCODE(CEE_SWITCH,                   "!")
VEROPCODE(CEE_LDIND_I1,                 "&1:4")
VEROPCODE(CEE_LDIND_U1,                 "&1:4")
VEROPCODE(CEE_LDIND_I2,                 "&2:4")
VEROPCODE(CEE_LDIND_U2,                 "&2:4")
VEROPCODE(CEE_LDIND_I4,                 "&4:4")
VEROPCODE(CEE_LDIND_U4,                 "&4:4")
VEROPCODE(CEE_LDIND_I8,                 "&8:8")
VEROPCODE(CEE_LDIND_I,                  "&i:i") // @todo : not correct on 64 bit
VEROPCODE(CEE_LDIND_R4,                 "&r:r")
VEROPCODE(CEE_LDIND_R8,                 "&d:d")
VEROPCODE(CEE_LDIND_REF,                "!")
VEROPCODE(CEE_STIND_REF,                "!")
VEROPCODE(CEE_STIND_I1,                 "4&1:")
VEROPCODE(CEE_STIND_I2,                 "4&2:")
VEROPCODE(CEE_STIND_I4,                 "4&4:")
VEROPCODE(CEE_STIND_I8,                 "8&8:")
VEROPCODE(CEE_STIND_R4,                 "r&r:")
VEROPCODE(CEE_STIND_R8,                 "d&d:")
VEROPCODE(CEE_ADD,                      "N=:-")
VEROPCODE(CEE_SUB,                      "N=:-")
VEROPCODE(CEE_MUL,                      "N=:-")
VEROPCODE(CEE_DIV,                      "N=:-")
VEROPCODE(CEE_DIV_UN,                   "I=:-")
VEROPCODE(CEE_REM,                      "N=:-")
VEROPCODE(CEE_REM_UN,                   "I=:-")
VEROPCODE(CEE_AND,                      "I=:-")
VEROPCODE(CEE_OR,                       "I=:-")
VEROPCODE(CEE_XOR,                      "I=:-")
VEROPCODE(CEE_SHL,                      "4I:-")
VEROPCODE(CEE_SHR,                      "4I:-")
VEROPCODE(CEE_SHR_UN,                   "4I:-")
VEROPCODE(CEE_NEG,                      "N:-")
VEROPCODE(CEE_NOT,                      "I:-")
VEROPCODE(CEE_CONV_I1,                  "Q:4")
VEROPCODE(CEE_CONV_I2,                  "Q:4")
VEROPCODE(CEE_CONV_I4,                  "Q:4")
VEROPCODE(CEE_CONV_I8,                  "Q:8")
VEROPCODE(CEE_CONV_R4,                  "N:r")
VEROPCODE(CEE_CONV_R8,                  "N:d")
VEROPCODE(CEE_CONV_U4,                  "Q:4")
VEROPCODE(CEE_CONV_U8,                  "Q:8")
VEROPCODE(CEE_CALLVIRT,                 "!")
VEROPCODE(CEE_CPOBJ,                    "!")
VEROPCODE(CEE_LDOBJ,                    "!")
VEROPCODE(CEE_LDSTR,                    "!")
VEROPCODE(CEE_NEWOBJ,                   "!")
VEROPCODE(CEE_CASTCLASS,                "!")
VEROPCODE(CEE_ISINST,                   "!")
VEROPCODE(CEE_CONV_R_UN,                "Q:r")
VEROPCODE(CEE_UNUSED58,                 "!")
VEROPCODE(CEE_UNUSED1,                  "!")
VEROPCODE(CEE_UNBOX,                    "!")
VEROPCODE(CEE_THROW,                    "!")
VEROPCODE(CEE_LDFLD,                    "!")
VEROPCODE(CEE_LDFLDA,                   "!")
VEROPCODE(CEE_STFLD,                    "!")
VEROPCODE(CEE_LDSFLD,                   "!")
VEROPCODE(CEE_LDSFLDA,                  "!")
VEROPCODE(CEE_STSFLD,                   "!")
VEROPCODE(CEE_STOBJ,                    "!")
VEROPCODE(CEE_CONV_OVF_I1_UN,           "Q:4")
VEROPCODE(CEE_CONV_OVF_I2_UN,           "Q:4")
VEROPCODE(CEE_CONV_OVF_I4_UN,           "Q:4")
VEROPCODE(CEE_CONV_OVF_I8_UN,           "Q:8")
VEROPCODE(CEE_CONV_OVF_U1_UN,           "Q:4")
VEROPCODE(CEE_CONV_OVF_U2_UN,           "Q:4")
VEROPCODE(CEE_CONV_OVF_U4_UN,           "Q:4")
VEROPCODE(CEE_CONV_OVF_U8_UN,           "Q:8")
VEROPCODE(CEE_CONV_OVF_I_UN,            "Q:i")
VEROPCODE(CEE_CONV_OVF_U_UN,            "Q:i")
VEROPCODE(CEE_BOX,                      "!")
VEROPCODE(CEE_NEWARR,                   "!")
VEROPCODE(CEE_LDLEN,                    "[*:4")
VEROPCODE(CEE_LDELEMA,                  "!")
VEROPCODE(CEE_LDELEM_I1,                "4[1:4")
VEROPCODE(CEE_LDELEM_U1,                "4[1:4")
VEROPCODE(CEE_LDELEM_I2,                "4[2:4")
VEROPCODE(CEE_LDELEM_U2,                "4[2:4")
VEROPCODE(CEE_LDELEM_I4,                "4[4:4")
VEROPCODE(CEE_LDELEM_U4,                "4[4:4")
VEROPCODE(CEE_LDELEM_I8,                "4[8:8")
VEROPCODE(CEE_LDELEM_I,                 "4[i:i")
VEROPCODE(CEE_LDELEM_R4,                "4[r:r")
VEROPCODE(CEE_LDELEM_R8,                "4[d:d")
VEROPCODE(CEE_LDELEM_REF,               "!")
VEROPCODE(CEE_STELEM_I,                 "i4[i:")
VEROPCODE(CEE_STELEM_I1,                "44[1:")
VEROPCODE(CEE_STELEM_I2,                "44[2:")
VEROPCODE(CEE_STELEM_I4,                "44[4:")
VEROPCODE(CEE_STELEM_I8,                "84[8:")
VEROPCODE(CEE_STELEM_R4,                "r4[r:")
VEROPCODE(CEE_STELEM_R8,                "d4[d:")
VEROPCODE(CEE_STELEM_REF,               "!")
VEROPCODE(CEE_UNUSED2,                  "!")
VEROPCODE(CEE_UNUSED3,                  "!")
VEROPCODE(CEE_UNUSED4,                  "!")
VEROPCODE(CEE_UNUSED5,                  "!")
VEROPCODE(CEE_UNUSED6,                  "!")
VEROPCODE(CEE_UNUSED7,                  "!")
VEROPCODE(CEE_UNUSED8,                  "!")
VEROPCODE(CEE_UNUSED9,                  "!")
VEROPCODE(CEE_UNUSED10,                 "!")
VEROPCODE(CEE_UNUSED11,                 "!")
VEROPCODE(CEE_UNUSED12,                 "!")
VEROPCODE(CEE_UNUSED13,                 "!")
VEROPCODE(CEE_UNUSED14,                 "!")
VEROPCODE(CEE_UNUSED15,                 "!")
VEROPCODE(CEE_UNUSED16,                 "!")
VEROPCODE(CEE_UNUSED17,                 "!")
VEROPCODE(CEE_CONV_OVF_I1,              "Q:4")
VEROPCODE(CEE_CONV_OVF_U1,              "Q:4")
VEROPCODE(CEE_CONV_OVF_I2,              "Q:4")
VEROPCODE(CEE_CONV_OVF_U2,              "Q:4")
VEROPCODE(CEE_CONV_OVF_I4,              "Q:4")
VEROPCODE(CEE_CONV_OVF_U4,              "Q:4")
VEROPCODE(CEE_CONV_OVF_I8,              "Q:8")
VEROPCODE(CEE_CONV_OVF_U8,              "Q:8")
VEROPCODE(CEE_UNUSED50,                 "!")
VEROPCODE(CEE_UNUSED18,                 "!")
VEROPCODE(CEE_UNUSED19,                 "!")
VEROPCODE(CEE_UNUSED20,                 "!")
VEROPCODE(CEE_UNUSED21,                 "!")
VEROPCODE(CEE_UNUSED22,                 "!")
VEROPCODE(CEE_UNUSED23,                 "!")
VEROPCODE(CEE_REFANYVAL,                "!")
VEROPCODE(CEE_CKFINITE,                 "R:-")
VEROPCODE(CEE_UNUSED24,                 "!")
VEROPCODE(CEE_UNUSED25,                 "!")
VEROPCODE(CEE_MKREFANY,                 "!")
VEROPCODE(CEE_UNUSED59,                 "!")
VEROPCODE(CEE_UNUSED60,                 "!")
VEROPCODE(CEE_UNUSED61,                 "!")
VEROPCODE(CEE_UNUSED62,                 "!")
VEROPCODE(CEE_UNUSED63,                 "!")
VEROPCODE(CEE_UNUSED64,                 "!")
VEROPCODE(CEE_UNUSED65,                 "!")
VEROPCODE(CEE_UNUSED66,                 "!")
VEROPCODE(CEE_UNUSED67,                 "!")
VEROPCODE(CEE_LDTOKEN,                  "!")
VEROPCODE(CEE_CONV_U2,                  "Q:4")
VEROPCODE(CEE_CONV_U1,                  "Q:4")
VEROPCODE(CEE_CONV_I,                   "Q:i")
VEROPCODE(CEE_CONV_OVF_I,               "Q:i")
VEROPCODE(CEE_CONV_OVF_U,               "Q:i")
VEROPCODE(CEE_ADD_OVF,                  "I=:-")
VEROPCODE(CEE_ADD_OVF_UN,               "I=:-")
VEROPCODE(CEE_MUL_OVF,                  "I=:-")
VEROPCODE(CEE_MUL_OVF_UN,               "I=:-")
VEROPCODE(CEE_SUB_OVF,                  "I=:-")
VEROPCODE(CEE_SUB_OVF_UN,               "I=:-")
VEROPCODE(CEE_ENDFINALLY,               "!")
VEROPCODE(CEE_LEAVE,                    ":l4")
VEROPCODE(CEE_LEAVE_S,                  ":l1")
VEROPCODE(CEE_STIND_I,                  "i&i:") // @Todo : 64 bit
VEROPCODE(CEE_CONV_U,                   "Q:i")
VEROPCODE(CEE_UNUSED26,                 "!")
VEROPCODE(CEE_UNUSED27,                 "!")
VEROPCODE(CEE_UNUSED28,                 "!")
VEROPCODE(CEE_UNUSED29,                 "!")
VEROPCODE(CEE_UNUSED30,                 "!")
VEROPCODE(CEE_UNUSED31,                 "!")
VEROPCODE(CEE_UNUSED32,                 "!")
VEROPCODE(CEE_UNUSED33,                 "!")
VEROPCODE(CEE_UNUSED34,                 "!")
VEROPCODE(CEE_UNUSED35,                 "!")
VEROPCODE(CEE_UNUSED36,                 "!")
VEROPCODE(CEE_UNUSED37,                 "!")
VEROPCODE(CEE_UNUSED38,                 "!")
VEROPCODE(CEE_UNUSED39,                 "!")
VEROPCODE(CEE_UNUSED40,                 "!")
VEROPCODE(CEE_UNUSED41,                 "!")
VEROPCODE(CEE_UNUSED42,                 "!")
VEROPCODE(CEE_UNUSED43,                 "!")
VEROPCODE(CEE_UNUSED44,                 "!")
VEROPCODE(CEE_UNUSED45,                 "!")
VEROPCODE(CEE_UNUSED46,                 "!")
VEROPCODE(CEE_UNUSED47,                 "!")
VEROPCODE(CEE_UNUSED48,                 "!")
VEROPCODE(CEE_PREFIX7,                  "!")
VEROPCODE(CEE_PREFIX6,                  "!")
VEROPCODE(CEE_PREFIX5,                  "!")
VEROPCODE(CEE_PREFIX4,                  "!")
VEROPCODE(CEE_PREFIX3,                  "!")
VEROPCODE(CEE_PREFIX2,                  "!")
VEROPCODE(CEE_PREFIX1,                  "!")
VEROPCODE(CEE_PREFIXREF,                "!")
VEROPCODE(CEE_ARGLIST,                  "!")
VEROPCODE(CEE_CEQ,                      "CE:4")
VEROPCODE(CEE_CGT,                      "CG:4")
VEROPCODE(CEE_CGT_UN,                   "CE:4")
VEROPCODE(CEE_CLT,                      "CG:4")
VEROPCODE(CEE_CLT_UN,                   "CG:4")
VEROPCODE(CEE_LDFTN,                    "!")
VEROPCODE(CEE_LDVIRTFTN,                "!")
VEROPCODE(CEE_UNUSED56,                 "!") 
VEROPCODE(CEE_LDARG,                    ":A!")
VEROPCODE(CEE_LDARGA,                   ":A!")
VEROPCODE(CEE_STARG,                    ":A!")
VEROPCODE(CEE_LDLOC,                    ":L!")
VEROPCODE(CEE_LDLOCA,                   ":L!")
VEROPCODE(CEE_STLOC,                    ":L!")
VEROPCODE(CEE_LOCALLOC,                 "i:i!")     // Unverifiable !
VEROPCODE(CEE_UNUSED57,                 "!")
VEROPCODE(CEE_ENDFILTER,                "4:!")
VEROPCODE(CEE_UNALIGNED,                ":")
VEROPCODE(CEE_VOLATILE,                 ":")
VEROPCODE(CEE_TAILCALL,                 ":")
VEROPCODE(CEE_INITOBJ,                  "!")
VEROPCODE(CEE_UNUSED68,                 "!")
VEROPCODE(CEE_CPBLK,                    "ii4:!")    // Unverifiable !
VEROPCODE(CEE_INITBLK,                  "i44:!")    // Unverifiable !
VEROPCODE(CEE_UNUSED69,                 "!")
VEROPCODE(CEE_RETHROW,                  "!")
VEROPCODE(CEE_UNUSED51,                 "!")
VEROPCODE(CEE_SIZEOF,                   "!")
VEROPCODE(CEE_REFANYTYPE,               "!")
VEROPCODE(CEE_UNUSED52,                 "!")
VEROPCODE(CEE_UNUSED53,                "!")
VEROPCODE(CEE_UNUSED54,                 "!")
VEROPCODE(CEE_UNUSED55,                 "!")
VEROPCODE(CEE_UNUSED70,                 "!")
VEROPCODE(CEE_ILLEGAL,                  "!")
VEROPCODE(CEE_MACRO_END,                "!")
VEROPCODE(CEE_COUNT,            		"!")
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\zapmonitor.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#ifndef _ZAPMONITOR_H_
#define _ZAPMONITOR_H_

#if ZAPMONITOR_ENABLED

#include <imagehlp.h>
#include "rangetree.h"
#include "memorypool.h"

class ZapMonitor
{
 public:
    enum
    {
        CONTENTS_CODE,
        CONTENTS_GC_INFO,
        CONTENTS_EXCEPTION,
        CONTENTS_CODE_MANAGER,
        CONTENTS_IMPORTS,
        CONTENTS_INFO,
        CONTENTS_METADATA,
        CONTENTS_MODULE,
        CONTENTS_METHODTABLE,
        CONTENTS_EECLASS,
        CONTENTS_METHODDESC,
        CONTENTS_METHODDESC_DATA,
        CONTENTS_FIELDDESC,
        CONTENTS_FIELD_STATIC_DATA,
        CONTENTS_EE_IMAGE,
        CONTENTS_IL,
        CONTENTS_RELOCS,
        CONTENTS_RESOURCES,
        CONTENTS_COUNT
    };

  private:

    struct Contents
    {
        RangeTree::Node node;
        int             type;
        mdToken         token;
    };

    struct Frame
    {
        CHAR            name[256];
        PCHAR           file;
        DWORD           lineNumber;
    };

    struct Page
    {
        SIZE_T          base;
        BOOL            prot;
        BOOL            touched;
        DWORD           oldProtection;
        BYTE            contentsKind[CONTENTS_COUNT];

        Contents        *firstTouchedContents;
        Frame           *stack;
        SIZE_T          stackCount;

        RangeTree       contents;
    };

    PEFile              *m_module;
    IMDInternalImport   *m_pImport;
    BYTE                *m_baseAddress;
    SIZE_T              m_imageSize;
    BYTE                *m_pageBase;
    SIZE_T              m_pageSize;
    Page                *m_pages;
    MemoryPool          m_nodes;
    ZapMonitor          *m_next;
    BOOL                m_enabled;

    SIZE_T              m_rsrc;
    SIZE_T              m_rsrcSize;

    static ZapMonitor *m_monitors;

    //
    // We don't want to link with imagehlp, so load stuff dynamically.
    //

    static HMODULE  m_imagehlp;
    static BOOL     (*m_pStackWalk)(DWORD MachineType,
                                    HANDLE hProcess,
                                    HANDLE hThread,
                                    LPSTACKFRAME StackFrame,
                                    PVOID ContextRecord,
                                    PREAD_PROCESS_MEMORY_ROUTINE ReadMemoryRoutine,
                                    PFUNCTION_TABLE_ACCESS_ROUTINE FunctionTableAccessRoutine,
                                    PGET_MODULE_BASE_ROUTINE GetModuleBaseRoutine,
                                    PTRANSLATE_ADDRESS_ROUTINE TranslateAddress);

    static DWORD    (*m_pUnDecorateSymbolName)(PCSTR DecoratedName,  
                                               PSTR UnDecoratedName,  
                                               DWORD UndecoratedLength,  
                                               DWORD Flags);           

    static BOOL     (*m_pSymInitialize)(HANDLE hProcess,     
                                        PSTR UserSearchPath,  
                                        BOOL fInvadeProcess);  
    static DWORD    (*m_pSymSetOptions)(DWORD SymOptions);  
    static BOOL     (*m_pSymCleanup)(HANDLE hProcess);
    static BOOL     (*m_pSymGetLineFromAddr)(HANDLE hProcess,
                                             DWORD dwAddr,
                                             PDWORD pdwDisplacement,
                                             PIMAGEHLP_LINE Line);
    static BOOL     (*m_pSymGetSymFromAddr)(HANDLE hProcess,
                                            DWORD dwAddr,
                                            PDWORD pdwDisplacement,
                                            PIMAGEHLP_SYMBOL Symbol);
    static PVOID    (*m_pSymFunctionTableAccess)(HANDLE hProcess,
                                                 DWORD AddrBase);
    static DWORD    (*m_pSymGetModuleBase)(HANDLE hProcess,
                                           DWORD Address);
    static BOOL     m_symInit;

  public:

    static void Init(BOOL stackTraceSupport);
    static void Uninit();

    static BOOL HandleAccessViolation(byte* address, CONTEXT *pContext);

    static void ReportAll(LPCSTR message, BOOL printPages = TRUE, BOOL printCleanPages = FALSE);
    static void ResetAll();
    static void DisableAll();
    static void SuspendAll();
    static void ResumeAll();

    ZapMonitor(PEFile *pFile, IMDInternalImport *pMDImport);
    ~ZapMonitor();

    void Reset();
    void PrintReport(BOOL printPages, BOOL printCleanPages);

 private:
    BOOL Trigger(BYTE* address, CONTEXT *pContext);
    void AddContents(SIZE_T start, SIZE_T size, int type, mdToken token);
    void ProtectPages();
    void UnprotectPages();
    void SuspendPages();
    void ResumePages();
    void ProtectPage(Page *p);
    void UnprotectPage(Page *p);
    void PrintStackTrace(Frame *stack, SIZE_T count, int indent);
    void PrintContents(Contents *c, int indent);
    void PrintContentsType(int contentsType);
    static void PrintPageContentsCallback(RangeTree::Node *pNode);
    void PrintPage(Page *p);
};

#endif // ZAPMONITOR_ENABLED

#endif // _ZAPMONITOR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\wrappers.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#ifndef _WRAPPERS_H_
#define _WRAPPERS_H_

#include "windows.h"

//-------------------------
// Critial section wrappers
// ------------------------
class CriticalSectionTaker {
    CRITICAL_SECTION *m_pCS;

#ifdef _DEBUG
    char * m_pszDescription;
#endif

public:
    CriticalSectionTaker(CRITICAL_SECTION* pCS) : m_pCS(pCS) {
        m_pCS = pCS;
#ifdef _DEBUG
        m_pszDescription = "No Info";
        LOCKCOUNTINCL(m_pszDescription);
#endif
        EnterCriticalSection(pCS);
    }

#ifdef _DEBUG
    CriticalSectionTaker(CRITICAL_SECTION* pCS, char* pszDescription) : m_pCS(pCS) {
        m_pszDescription = pszDescription;
        LOCKCOUNTINC(m_pszDescription);
        EnterCriticalSection(pCS);
    }
#endif

    ~CriticalSectionTaker() {
        LeaveCriticalSection(m_pCS);
#ifdef _DEBUG
        LOCKCOUNTDEC(m_pszDescription);
#endif
    }
};

#ifdef _DEBUG
#define CLR_CRITICAL_SECTION(cs) CriticalSectionTaker __cst(cs, __FILE__)
#else
#define CLR_CRITICAL_SECTION(cs) CriticalSectionTaker __cst(cs)
#endif

#define CLR_CRITICAL_SECTION_BEGIN(cs)                           \
        LOCKCOUNTINCL(__FILE__);                                 \
        EnterCriticalSection(cs);                                \
        __try {

#define CLR_CRITICAL_SECTION_END(cs)        \
        } __finally {                       \
            LeaveCriticalSection(cs);       \
            LOCKCOUNTDEC(__FILE__);         \
        }

class CriticalSectionHolderNoDtor {
    CRITICAL_SECTION *m_pCS;
    DWORD m_held;
public:
    CriticalSectionHolderNoDtor(CRITICAL_SECTION* pCS) : m_pCS(pCS), m_held(FALSE) {
    }

    void Enter() {
        _ASSERTE(m_pCS && !m_held);
        LOCKCOUNTINC("No Info");
        EnterCriticalSection(m_pCS);
        m_held = TRUE;
    }

    void Leave() {
        _ASSERTE(m_pCS && m_held);
        LeaveCriticalSection(m_pCS);
        m_held = FALSE;
        LOCKCOUNTDEC("No Info");
    }

    BOOL IsHeld() {
        return m_held;
    }

    void Destroy() {
        if (m_held) {
            _ASSERTE(m_pCS);
            LeaveCriticalSection(m_pCS);
            LOCKCOUNTDEC("No Info");
        }
        m_held = FALSE;
    }

    void SetCriticalSection(CRITICAL_SECTION *pCS) {
        _ASSERTE(pCS != NULL);
        _ASSERTE(m_held == FALSE);
        m_pCS = pCS;
    }

};

class CriticalSectionHolder : public CriticalSectionHolderNoDtor {
public:
    CriticalSectionHolder(CRITICAL_SECTION* pCS) : CriticalSectionHolderNoDtor(pCS) { }
    ~CriticalSectionHolder() { Destroy(); }
};

#define CRITICAL_SECTION_HOLDER(holder, cs)             \
    CriticalSectionHolder holder(cs);

#define CRITICAL_SECTION_HOLDER_BEGIN(holder, cs)       \
    CriticalSectionHolderNoDtor holder(cs);             \
    __try {

#define CRITICAL_SECTION_HOLDER_END(holder)             \
    } __finally {                                       \
        holder.Destroy();                               \
    }


//-------------------------------------------------------------------------
// Macro for declaring a generic holder class.  Methods on the holder have
// the same names as the methods on the underlying objects.
// 
// It declares 3 classes:
//      Class##Taker
//      Class##HolderNoDtor
//      Class##Holder
//-------------------------------------------------------------------------
#define DECLARE_SIMPLE_WRAPPER_CLASSES(Class, fEnter, fExit)                            \
class Class##Taker {                                                                    \
    Class *m_pObject;                                                                   \
public:                                                                                 \
    Class##Taker(Class* pObj) : m_pObject(pObj) { m_pObject->fEnter(); }                \
    ~Class##Taker() { m_pObject->fExit(); }                                             \
};                                                                                      \
                                                                                        \
class Class##HolderNoDtor {                                                             \
    Class *m_pObject;                                                                   \
    DWORD m_held;                                                                       \
public:                                                                                 \
    Class##HolderNoDtor(Class* pObj) : m_pObject(pObj), m_held(FALSE) { }               \
                                                                                        \
    void fEnter() {                                                                     \
        _ASSERTE(!m_held);                                                              \
        m_pObject->fEnter();                                                            \
        m_held = TRUE;                                                                  \
    }                                                                                   \
                                                                                        \
    void fExit() {                                                                      \
        _ASSERTE(m_held);                                                               \
        m_pObject->fExit();                                                             \
        m_held = FALSE;                                                                 \
    }                                                                                   \
                                                                                        \
    BOOL IsHeld() {                                                                     \
        return m_held;                                                                  \
    }                                                                                   \
                                                                                        \
    void Destroy() {                                                                    \
        if (m_held)                                                                     \
            m_pObject->fExit();                                                         \
        m_held = FALSE;                                                                 \
    }                                                                                   \
};                                                                                      \
                                                                                        \
class Class##Holder : public Class##HolderNoDtor {                                      \
public:                                                                                 \
    Class##Holder(Class* pObj) : Class##HolderNoDtor(pObj) { }                          \
    ~Class##Holder() { Destroy(); }                                                     \
};


//-------------------------------------------------------------------------------------
// When a single class has multiple resources that you want to create wrappers for,
// you need an extra argument to create unique wrapper class names.  This macro creates
// those unique names by taking an extra argument that is appended to the class
// name.
// 
// It declares classes called:
//      Class##Style##Taker
//      Class##Style##HolderNoDtor
//      Class##Style##Holder
//-------------------------------------------------------------------------------------

#define DECLARE_WRAPPER_CLASSES(Class, Style, fEnter, fExit)                            \
class Class##Style##Taker {                                                             \
    Class *m_pObject;                                                                   \
public:                                                                                 \
    Class##Style##Taker(Class* pObj) : m_pObject(pObj) { m_pObject->fEnter(); }         \
    ~Class##Style##Taker() { m_pObject->fExit(); }                                      \
};                                                                                      \
                                                                                        \
class Class##Style##HolderNoDtor {                                                      \
    Class *m_pObject;                                                                   \
    DWORD m_held;                                                                       \
public:                                                                                 \
    Class##Style##HolderNoDtor(Class* pObj) : m_pObject(pObj), m_held(FALSE) { }        \
                                                                                        \
    void fEnter() {                                                                     \
        _ASSERTE(!m_held);                                                              \
        m_pObject->fEnter();                                                            \
        m_held = TRUE;                                                                  \
    }                                                                                   \
                                                                                        \
    void fExit() {                                                                      \
        _ASSERTE(m_held);                                                               \
        m_pObject->fExit();                                                             \
        m_held = FALSE;                                                                 \
    }                                                                                   \
                                                                                        \
    BOOL IsHeld() {                                                                     \
        return m_held;                                                                  \
    }                                                                                   \
                                                                                        \
    void Destroy() {                                                                    \
        if (m_held)                                                                     \
            m_pObject->fExit();                                                         \
        m_held = FALSE;                                                                 \
    }                                                                                   \
};                                                                                      \
                                                                                        \
class Class##Style##Holder : public Class##Style##HolderNoDtor {                        \
public:                                                                                 \
    Class##Style##Holder(Class* pObj) : Class##Style##HolderNoDtor(pObj) { }            \
    ~Class##Style##Holder() { Destroy(); }                                              \
};


//-------------------------------------------
// This variant supports Enter/TryEnter/Exit.  It also has a "style" parameter that
// is used to create the name.  It declares classes called:
//      Class##Style##Taker
//      Class##Style##HolderNoDtor
//      Class##Style##Holder
//-------------------------------------------

#define DECLARE_WRAPPER_CLASSES_WITH_TRY(Class, Style, fEnter, fTryEnter, fExit)        \
class Class##Style##Taker {                                                             \
    Class *m_pObject;                                                                   \
public:                                                                                 \
    Class##Style##Taker(Class* pObj) : m_pObject(pObj) { m_pObject->fEnter(); }         \
    ~Class##Style##Taker() { m_pObject->fExit(); }                                      \
};                                                                                      \
                                                                                        \
class Class##Style##HolderNoDtor {                                                      \
    Class *m_pObject;                                                                   \
    DWORD m_held;                                                                       \
public:                                                                                 \
    Class##Style##HolderNoDtor(Class* pObj) : m_pObject(pObj), m_held(FALSE) { }        \
                                                                                        \
    void fEnter() {                                                                     \
        _ASSERTE(!m_held);                                                              \
        m_pObject->fEnter();                                                            \
        m_held = TRUE;                                                                  \
    }                                                                                   \
                                                                                        \
    BOOL fTryEnter() {                                                                  \
        _ASSERTE(!m_held);                                                              \
        BOOL ret = m_pObject->fTryEnter();                                              \
        if (ret)                                                                        \
            m_held = TRUE;                                                              \
        return ret;                                                                     \
    }                                                                                   \
                                                                                        \
    void fExit() {                                                                      \
        _ASSERTE(m_held);                                                               \
        m_pObject->fExit();                                                             \
        m_held = FALSE;                                                                 \
    }                                                                                   \
                                                                                        \
    BOOL IsHeld() {                                                                     \
        return m_held;                                                                  \
    }                                                                                   \
                                                                                        \
    void Destroy() {                                                                    \
        if (m_held)                                                                     \
            m_pObject->fExit();                                                         \
        m_held = FALSE;                                                                 \
    }                                                                                   \
};                                                                                      \
                                                                                        \
class Class##Style##Holder : public Class##Style##HolderNoDtor {                        \
public:                                                                                 \
    Class##Style##Holder(Class* pObj) : Class##Style##HolderNoDtor(pObj) { }     \
    ~Class##Style##Holder() { Destroy(); }                                              \
};

//------------------
// Wrappers for Crst
// -----------------
#include "crst.h"
DECLARE_SIMPLE_WRAPPER_CLASSES(Crst, Enter, Leave)
#define CLR_CRST(pCrst)                         CrstTaker _takeCrst(pCrst)
#define CLR_CRST_BEGIN(pCrst)                   pCrst->Enter(); __try {
#define CLR_CRST_END(pCrst)                     } __finally { pCrst->Leave(); }
#define CLR_CRST_HOLDER(holder, pCrst)          CrstHolder holder(pCrst);
#define CLR_CRST_HOLDER_BEGIN(holder, pCrst)    CrstHolderNoDtor(pCrst); __try {
#define CLR_CRST_HOLDER_END(holder)             } __finally { holder.Destroy(); }

//--------------------------
// Wrappers for AppDomain
//--------------------------
DECLARE_SIMPLE_WRAPPER_CLASSES(SystemDomain, Enter, Leave)
#define SYSTEMDOMAIN_LOCK()                       SystemDomainTaker _adTaker(SystemDomain::System());
#define SYSTEMDOMAIN_LOCK_BEGIN()                 (SystemDomain::System())->Enter(); __try {
#define SYSTEMDOMAIN_LOCK_END()                   } __finally { (SystemDomain::System())->Leave(); }
#define SYSTEMDOMAIN_LOCK_HOLDER(h)               SystemDomainHolder h(SystemDomain::System())
#define SYSTEMDOMAIN_LOCK_HOLDER_BEGIN(h)         SystemDomainHolderNoDtor h(SystemDomain::System()); __try {
#define SYSTEMDOMAIN_LOCK_HOLDER_END(h)           } __finally { h.Destroy(); }

DECLARE_SIMPLE_WRAPPER_CLASSES(AppDomain, EnterLock, LeaveLock)
#define APPDOMAIN_LOCK(pAppDomain)                AppDomainTaker _adTaker(pAppDomain);
#define APPDOMAIN_LOCK_BEGIN(pAppDoamin)          (pAppDomain)->EnterLock(); __try {
#define APPDOMAIN_LOCK_END(pAppDomain)            } __finally { (pAppDomain)->LeaveLock(); }
#define APPDOMAIN_LOCK_HOLDER(h,pAppDomain)       AppDomainHolder h(pAppDomain)
#define APPDOMAIN_LOCK_HOLDER_BEGIN(h,pAppDomain) AppDomainHolderNoDtor h(pAppDomain); __try {
#define APPDOMAIN_LOCK_HOLDER_END(h)              } __finally { h.Destroy(); }

DECLARE_WRAPPER_CLASSES(AppDomain, Cache, EnterCacheLock, LeaveCacheLock)
#define APPDOMAIN_CACHE_LOCK(pAppDomain)                AppDomainCacheTaker _adCTaker(pAppDomain);
#define APPDOMAIN_CACHE_LOCK_BEGIN(pAppDoamin)          (pAppDomain)->EnterCacheLock(); __try {
#define APPDOMAIN_CACHE_LOCK_END(pAppDomain)            } __finally { (pAppDomain)->LeaveWrite(); }
#define APPDOMAIN_CACHE_LOCK_HOLDER(h,pAppDomain)       AppDomainCacheHolder h(pAppDomain)
#define APPDOMAIN_CACHE_LOCK_HOLDER_BEGIN(h,pAppDomain) AppDomainCacheHolderNoDtor h(pAppDomain); __try {
#define APPDOMAIN_CACHE_LOCK_HOLDER_END(h)              } __finally { h.Destroy(); }

DECLARE_WRAPPER_CLASSES(AppDomain, Load, EnterLoadLock, LeaveLoadLock)
#define APPDOMAIN_LOAD_LOCK(pAppDomain)                AppDomainLoadTaker _adLLTaker(pAppDomain);
#define APPDOMAIN_LOAD_LOCK_BEGIN(pAppDoamin)          (pAppDomain)->EnterLoadLock(); __try {
#define APPDOMAIN_LOAD_LOCK_END(pAppDomain)            } __finally { (pAppDomain)->LeaveWrite(); }
#define APPDOMAIN_LOAD_LOCK_HOLDER(h,pAppDomain)       AppDomainLoadHolder h(pAppDomain)
#define APPDOMAIN_LOAD_LOCK_HOLDER_BEGIN(h,pAppDomain) AppDomainLoadHolderNoDtor h(pAppDomain); __try {
#define APPDOMAIN_LOAD_LOCK_HOLDER_END(h)              } __finally { h.Destroy(); }

DECLARE_WRAPPER_CLASSES(AppDomain, DomainLocalBlockLock, EnterDomainLocalBlockLock, LeaveDomainLocalBlockLock)
#define APPDOMAIN_DOMAIN_LOCAL_BLOCK_LOCK(pAppDomain)              AppDomainDomainLocalBlockLockTaker _adTaker(pAppDomain);
#define APPDOMAIN_DOMAIN_LOCAL_BLOCK_LOCK_BEGIN(pAppDomain)        (pAppDomain)->EnterDomainLocalBlockLock(); __try {
#define APPDOMAIN_DOMAIN_LOCAL_BLOCK_LOCK_END(pAppDomain)          } __finally { (pAppDomain)->LeaveDomainLocalBlockLock(); }
#define APPDOMAIN_DOMAIN_LOCAL_BLOCK_LOCK_HOLDER(h, pAppDomain)    AppDomainDomainLocalBlockLockHolder h(pAppDomain)
#define APPDOMAIN_DOMAIN_LOCAL_BLOCK_LOCK_HOLDER_BEGIN(h, pAppDomain)  AppDomainDomainLocalBlockLockHolderNoDtor h(pAppDomain); __try {
#define APPDOMAIN_DOMAIN_LOCAL_BLOCK_LOCK_HOLDER_END(h)             } __finally { h.Destroy(); }

DECLARE_WRAPPER_CLASSES(AppDomain, UnloadLock, SetUnloadInProgress, SetUnloadComplete)
#define APPDOMAIN_UNLOAD_LOCK(pAppDomain)              AppDomainUnloadLockTaker _adTaker(pAppDomain);
#define APPDOMAIN_UNLOAD_LOCK_BEGIN(pAppDomain)        (pAppDomain)->SetUnloadInProgress(); __try {
#define APPDOMAIN_UNLOAD_LOCK_END(pAppDomain)          } __finally { (pAppDomain)->SetUnloadComplete(); }
#define APPDOMAIN_UNLOAD_LOCK_HOLDER(h, pAppDomain)    AppDomainUnloadLockHolder h(pAppDomain)
#define APPDOMAIN_UNLOAD_LOCK_HOLDER_BEGIN(h, pAppDomain)  AppDomainUnloadLockHolderNoDtor h(pAppDomain); __try {
#define APPDOMAIN_UNLOAD_LOCK_HOLDER_END(h)             } __finally { h.Destroy(); }


//-------------------------------
// Wrappers for JitLock
//-------------------------------
DECLARE_SIMPLE_WRAPPER_CLASSES(ListLock, Enter, Leave)
#define CLR_LISTLOCK(pListLock)                 ListLockTaker _takeListLock(pListLock)
#define CLR_LISTLOCK_BEGIN(pListLock)           pListLock->Enter(); __try {
#define CLR_LISTLOCK_END(pListLock)             } __finally { pListLock->Leave(); }
#define CLR_LISTLOCK_HOLDER(holder, pListLock)  ListLockHolder holder(pListLock);
#define CLR_LISTLOCK_HOLDER_BEGIN(holder, pListLock)    ListLockHolderNoDtor holder(pListLock); __try {
#define CLR_LISTLOCK_HOLDER_END(holder)         } __finally { holder.Destroy(); }

#endif // _WRAPPERS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\zapmonitor.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#include "common.h"

#if ZAPMONITOR_ENABLED

#include "zapmonitor.h"
#include <imagehlp.h>
#include "field.h"
#include "eeconfig.h"
#include "corcompile.h"

ZapMonitor  *ZapMonitor::m_monitors = NULL;
HMODULE     ZapMonitor::m_imagehlp = NULL;
BOOL        ZapMonitor::m_symInit = FALSE;
BOOL        (*ZapMonitor::m_pStackWalk)(DWORD MachineType,
                                        HANDLE hProcess,
                                        HANDLE hThread,
                                        LPSTACKFRAME StackFrame,
                                        PVOID ContextRecord,
                                        PREAD_PROCESS_MEMORY_ROUTINE ReadMemoryRoutine,
                                        PFUNCTION_TABLE_ACCESS_ROUTINE FunctionTableAccessRoutine,
                                        PGET_MODULE_BASE_ROUTINE GetModuleBaseRoutine,
                                        PTRANSLATE_ADDRESS_ROUTINE TranslateAddress) = NULL;
DWORD       (*ZapMonitor::m_pUnDecorateSymbolName)(PCSTR DecoratedName,  
                                                   PSTR UnDecoratedName,  
                                                   DWORD UndecoratedLength,  
                                                   DWORD Flags) = NULL;        
BOOL        (*ZapMonitor::m_pSymInitialize)(HANDLE hProcess,     
                                            PSTR UserSearchPath,  
                                            BOOL fInvadeProcess);  
DWORD       (*ZapMonitor::m_pSymSetOptions)(DWORD SymOptions) = NULL;   
BOOL        (*ZapMonitor::m_pSymCleanup)(HANDLE hProcess) = NULL;
BOOL        (*ZapMonitor::m_pSymGetLineFromAddr)(HANDLE hProcess,
                                                 DWORD dwAddr,
                                                 PDWORD pdwDisplacement,
                                                 PIMAGEHLP_LINE Line) = NULL;
BOOL        (*ZapMonitor::m_pSymGetSymFromAddr)(HANDLE hProcess,
                                                DWORD dwAddr,
                                                PDWORD pdwDisplacement,
                                                PIMAGEHLP_SYMBOL Symbol);
PVOID       (*ZapMonitor::m_pSymFunctionTableAccess)(HANDLE hProcess,
                                                     DWORD AddrBase) = NULL;
DWORD       (*ZapMonitor::m_pSymGetModuleBase)(HANDLE hProcess,
                                               DWORD Address) = NULL;

void ZapMonitor::Init(BOOL stackTraceSupport)
{
    if (stackTraceSupport)
        m_imagehlp = LoadImageHlp();

    if (m_imagehlp)
    {
        m_pStackWalk = (BOOL(*)(DWORD MachineType,
                                        HANDLE hProcess,
                                        HANDLE hThread,
                                        LPSTACKFRAME StackFrame,
                                        PVOID ContextRecord,
                                        PREAD_PROCESS_MEMORY_ROUTINE ReadMemoryRoutine,
                                        PFUNCTION_TABLE_ACCESS_ROUTINE FunctionTableAccessRoutine,
                                        PGET_MODULE_BASE_ROUTINE GetModuleBaseRoutine,
                                        PTRANSLATE_ADDRESS_ROUTINE TranslateAddress))
          GetProcAddress(m_imagehlp, "StackWalk");
        m_pUnDecorateSymbolName = (DWORD (*)(PCSTR DecoratedName,    
                                             PSTR UnDecoratedName,  
                                             DWORD UndecoratedLength,    
                                             DWORD Flags))
          GetProcAddress(m_imagehlp, "UnDecorateSymbolName");
        m_pSymInitialize = (BOOL(*)(HANDLE hProcess,     
                                    PSTR UserSearchPath,  
                                    BOOL fInvadeProcess)) 
          GetProcAddress(m_imagehlp, "SymInitialize");
        m_pSymSetOptions = (DWORD(*)(DWORD SymOptions))
          GetProcAddress(m_imagehlp, "SymSetOptions");
        m_pSymCleanup = (BOOL(*)(HANDLE hProcess))
          GetProcAddress(m_imagehlp, "SymCleanup");
        m_pSymGetLineFromAddr = (BOOL(*)(HANDLE hProcess,
                                         DWORD dwAddr,
                                         PDWORD pdwDisplacement,
                                         PIMAGEHLP_LINE Line))
          GetProcAddress(m_imagehlp, "SymGetLineFromAddr");
        m_pSymGetSymFromAddr = (BOOL(*)(HANDLE hProcess,
                                        DWORD dwAddr,
                                        PDWORD pdwDisplacement,
                                        PIMAGEHLP_SYMBOL Symbol))
          GetProcAddress(m_imagehlp, "SymGetSymFromAddr");
        m_pSymFunctionTableAccess = (PVOID(*)(HANDLE hProcess,
                                              DWORD AddrBase))
          GetProcAddress(m_imagehlp, "SymFunctionTableAccess");
        m_pSymGetModuleBase = (DWORD(*)(HANDLE hProcess,
                                        DWORD Address))
          GetProcAddress(m_imagehlp, "SymGetModuleBase");

    }
};

void ZapMonitor::Uninit()
{
    if (m_monitors != NULL && m_monitors->m_enabled)
    {
        ReportAll("Shutting down",
                  g_pConfig->MonitorZapExecution() >= 2,
                  g_pConfig->MonitorZapExecution() >= 4);
    }

    ZapMonitor *z = m_monitors;
    while (z != NULL)
    {
        ZapMonitor *zNext = z->m_next;
        delete z;
        z = zNext;
    }
    m_monitors = NULL;

    if (m_imagehlp)
    {
        if (m_symInit)
            m_pSymCleanup(GetCurrentProcess());
        FreeLibrary(m_imagehlp);
        m_imagehlp = NULL;
    }
}

ZapMonitor::ZapMonitor(PEFile *pFile, IMDInternalImport *pImport)
  : m_nodes(sizeof(Contents))
{
    // Insert us in the list - this isn't threadsafe but who cares
    m_next = m_monitors;
    m_monitors = this;

    m_module = pFile;
    m_pImport = pImport;
    m_baseAddress = pFile->GetBase();
    
    IMAGE_NT_HEADERS *pNT = pFile->GetNTHeader();
    IMAGE_COR20_HEADER *pCor = pFile->GetCORHeader();

    CORCOMPILE_HEADER *pZap;

    if (pCor->ManagedNativeHeader.VirtualAddress == 0)
        pZap = NULL;
    else
        pZap = (CORCOMPILE_HEADER *)
          (pFile->GetBase() + pCor->ManagedNativeHeader.VirtualAddress);

    m_imageSize = pNT->OptionalHeader.SizeOfImage;

    m_enabled = FALSE;

    //
    // Allocate pages
    //

    m_pageBase = (BYTE*) (((SIZE_T)m_baseAddress)&~(OS_PAGE_SIZE-1));
    m_pageSize = ((((SIZE_T)(m_baseAddress + m_imageSize))+(OS_PAGE_SIZE-1))
                  &~(OS_PAGE_SIZE-1))
      - (SIZE_T)m_pageBase;

    m_pages = new Page [ m_pageSize / OS_PAGE_SIZE ];

    //
    // Notice .rsrc section & don't protect it (unmanaged code may access it, so page
    // protect causes problems.)
    //
    
    IMAGE_DATA_DIRECTORY *rsrc = 
      &pNT->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_RESOURCE];
    if (rsrc->Size > 0)
    {
        m_rsrc = (SIZE_T) m_baseAddress + rsrc->VirtualAddress;
        m_rsrcSize = rsrc->Size;
    }

    Page *p = m_pages;
    Page *pEnd = p + m_pageSize / OS_PAGE_SIZE;
    BYTE *base = m_pageBase;

    while (p < pEnd)
    {
        p->base = (SIZE_T)base;
        p->prot = FALSE;
        p->firstTouchedContents = NULL;
        p->stack = NULL;
        p->stackCount = 0;
        ZeroMemory(p->contentsKind, sizeof(p->contentsKind));

        new (&p->contents) RangeTree();

        p++;
        base += OS_PAGE_SIZE;
    }
    
    //
    // Mark the metadata
    //

    AddContents((SIZE_T)(pCor->MetaData.VirtualAddress + m_baseAddress),
                pCor->MetaData.Size, CONTENTS_METADATA, 0);

    //
    // Mark the base relocs
    //
    
    if (pNT->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].VirtualAddress != 0)
    {
        AddContents((SIZE_T)(pNT->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].VirtualAddress + m_baseAddress),
                    pNT->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].Size,
                    CONTENTS_RELOCS, 0);
    }
                    
    //
    // Mark the resources
    //
    
    if (pNT->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_RESOURCE].VirtualAddress != 0)
    {
        AddContents((SIZE_T)(pNT->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_RESOURCE].VirtualAddress + m_baseAddress),
                    pNT->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_RESOURCE].Size,
                    CONTENTS_RESOURCES, 0);
    }
                    
    if (pCor->Resources.VirtualAddress != 0)
    {
        AddContents((SIZE_T)(pCor->Resources.VirtualAddress + m_baseAddress),
                    pCor->Resources.Size, CONTENTS_RESOURCES, 0);
    }

    if (pZap)
    {
        //
        // Crack preload image & label the major pieces
        //

        AddContents((SIZE_T)(pZap->ModuleImage.VirtualAddress + m_baseAddress),
                    pZap->ModuleImage.Size, CONTENTS_EE_IMAGE, 0);

        Module *m = (Module *) (pZap->ModuleImage.VirtualAddress + m_baseAddress);
        AddContents((SIZE_T) m, sizeof(Module), CONTENTS_MODULE, 0);
        AddContents((SIZE_T) m->m_TypeDefToMethodTableMap.pTable, 
                    m->m_TypeDefToMethodTableMap.dwMaxIndex * sizeof(void*), 
                    CONTENTS_MODULE, 0);
        AddContents((SIZE_T) m->m_TypeRefToMethodTableMap.pTable, 
                    m->m_TypeRefToMethodTableMap.dwMaxIndex * sizeof(void*), 
                    CONTENTS_MODULE, 0);
        AddContents((SIZE_T) m->m_MethodDefToDescMap.pTable, 
                    m->m_MethodDefToDescMap.dwMaxIndex * sizeof(void*), 
                    CONTENTS_MODULE, 0);
        AddContents((SIZE_T) m->m_FieldDefToDescMap.pTable, 
                    m->m_FieldDefToDescMap.dwMaxIndex * sizeof(void*), 
                    CONTENTS_MODULE, 0);
        AddContents((SIZE_T) m->m_MemberRefToDescMap.pTable, 
                    m->m_MemberRefToDescMap.dwMaxIndex * sizeof(void*), 
                    CONTENTS_MODULE, 0);
        AddContents((SIZE_T) m->m_FileReferencesMap.pTable, 
                    m->m_FileReferencesMap.dwMaxIndex * sizeof(void*), 
                    CONTENTS_MODULE, 0);
        AddContents((SIZE_T) m->m_AssemblyReferencesMap.pTable, 
                    m->m_AssemblyReferencesMap.dwMaxIndex * sizeof(void*), 
                    CONTENTS_MODULE, 0);

        TypeHandle *types = (TypeHandle *) m->m_TypeDefToMethodTableMap.pTable;
        TypeHandle *typesEnd =  types + m->m_TypeDefToMethodTableMap.dwMaxIndex;
        while (types < typesEnd)
        {
            if ((*types) != TypeHandle())
            {
                MethodTable *pMT = (*types).AsMethodTable();
                if (pMT != NULL)
                {
                    EEClass *pClass = pMT->GetClass();
                    mdTypeDef token = pClass->GetCl();

                    BYTE *start, *end;
                    pMT->GetExtent(&start, &end);
                    AddContents((SIZE_T) start, end - start, CONTENTS_METHODTABLE, token);
                    AddContents((SIZE_T) pClass, sizeof(EEClass), CONTENTS_EECLASS, token);

                    MethodDescChunk *pChunk = pClass->GetChunk();
                    while (pChunk != NULL)
                    {
                        AddContents((SIZE_T) pChunk, pChunk->Sizeof(), 
                                    CONTENTS_METHODDESC, token);

                        if ((pChunk->GetKind()&mdcClassification) == mcNDirect)
                        {
                            for (UINT i = 0; i < pChunk->GetCount(); i++)
                            {
                                NDirectMethodDesc *pMD = (NDirectMethodDesc*) pChunk->GetMethodDescAt(i);
                                if (pMD->ndirect.m_pMLHeader != NULL)
                                    AddContents((SIZE_T)pMD->ndirect.m_pMLHeader, 1, // @nice: get size
                                                CONTENTS_METHODDESC_DATA, pMD->GetMemberDef());

                                if (pMD->ndirect.m_szLibName != NULL)
                                    AddContents((SIZE_T)pMD->ndirect.m_szLibName,
                                                strlen(pMD->ndirect.m_szLibName)+1,
                                                CONTENTS_METHODDESC_DATA, pMD->GetMemberDef());

                                if (pMD->ndirect.m_szEntrypointName != NULL)
                                    AddContents((SIZE_T)pMD->ndirect.m_szEntrypointName,
                                                strlen(pMD->ndirect.m_szEntrypointName)+1,
                                                CONTENTS_METHODDESC_DATA, pMD->GetMemberDef());
                            }
                        }

                        if ((pChunk->GetKind()&mdcClassification) == mcECall
                            || (pChunk->GetKind()&mdcClassification) == mcArray
                            || (pChunk->GetKind()&mdcClassification) == mcEEImpl)
                        {
                            for (UINT i = 0; i < pChunk->GetCount(); i++)
                            {
                                StoredSigMethodDesc *pMD = (StoredSigMethodDesc*) 
                                  pChunk->GetMethodDescAt(i);

                                _ASSERTE(pMD->HasStoredSig());

                                PCCOR_SIGNATURE pSig;
                                DWORD cSig;
                                pMD->GetSig(&pSig, &cSig);
                                
                                if (pSig != NULL)
                                    AddContents((SIZE_T)pSig, cSig,
                                                CONTENTS_METHODDESC_DATA, pMD->GetMemberDef());
                            }
                        }

                        pChunk = pChunk->GetNextChunk();
                    }

                    AddContents((SIZE_T) pClass->GetFieldDescListRaw(),
                                // Right now we just include statics, because we can't
                                // get the parent class to compute the number of 
                                // instance fields.
                                sizeof(FieldDesc) * pClass->GetNumStaticFields(),
                                CONTENTS_FIELDDESC, token);

                    FieldDesc *pFD = pClass->GetFieldDescListRaw();
                    FieldDesc *pFDEnd = pFD + pClass->GetNumStaticFields();

                    while (pFD < pFDEnd)
                    {
                        if (pFD->IsRVA())
                            AddContents((SIZE_T) pFD->GetStaticAddressHandle(NULL),
                                        1, // @nice: we'd get the size, but it barfs: pFD->GetSize(),
                                        CONTENTS_FIELD_STATIC_DATA, pFD->GetMemberDef());
                        pFD++;
                    }
                }
            }
            types++;
        }

        //
        // Add IP map, and locate code.
        //
    
        CORCOMPILE_CODE_MANAGER_ENTRY *codeMgr = (CORCOMPILE_CODE_MANAGER_ENTRY *) 
          (m_baseAddress + pZap->CodeManagerTable.VirtualAddress);

        AddContents(codeMgr->Table.VirtualAddress + (SIZE_T) m_baseAddress, codeMgr->Table.Size, 
                    CONTENTS_CODE_MANAGER, 0);

        DWORD *pNibbleMap = (DWORD *) (codeMgr->Table.VirtualAddress + (SIZE_T) m_baseAddress);
        DWORD *pNibbleMapEnd = (DWORD *) (codeMgr->Table.VirtualAddress + codeMgr->Table.Size + (SIZE_T) m_baseAddress);

        BYTE *pCode = (BYTE *) (codeMgr->Code.VirtualAddress + (SIZE_T) m_baseAddress);

        BYTE *firstGCInfo = NULL;
        BYTE *lastGCInfo = NULL;

        ICodeManager* pCM = ExecutionManager::GetJitForType(miManaged|miNative)->GetCodeManager();

        while (pNibbleMap < pNibbleMapEnd)
        {
            DWORD dword = *pNibbleMap++;

            int index = 0;
            while (dword != 0)
            {
                DWORD offset = dword >> 28;
                if (offset != 0)
                {
                    CORCOMPILE_METHOD_HEADER *pHeader = (CORCOMPILE_METHOD_HEADER *)
                      (pCode + index*32 + (offset-1)*4);

                    //
                    // Remember approximate range of GC info, since we don't know
                    // the sizes.
                    //

                    if (firstGCInfo == NULL || pHeader->gcInfo < firstGCInfo)
                        firstGCInfo = pHeader->gcInfo;
                    if (pHeader->gcInfo > lastGCInfo)
                        lastGCInfo = pHeader->gcInfo;

                    if (pHeader->exceptionInfo != NULL)
                    {
                        AddContents((SIZE_T) pHeader->exceptionInfo, 
                                    pHeader->exceptionInfo->DataSize, 
                            CONTENTS_EXCEPTION, 
                                    ((MethodDesc*)pHeader->methodDesc)->GetMemberDef());
                    }

                    if (pHeader->fixupList != NULL)
                    {
                        DWORD *fixups = (DWORD *) pHeader->fixupList;
                        while (*fixups++ != NULL)
                            ;

                        AddContents((SIZE_T) pHeader->fixupList,
                                    ((BYTE *) fixups) - pHeader->fixupList,
                                    CONTENTS_INFO, 
                                    ((MethodDesc*)pHeader->methodDesc)->GetMemberDef());
                    }
                        
                    AddContents((SIZE_T) pHeader, 
                                pCM->GetFunctionSize(pHeader->gcInfo) + sizeof(CORCOMPILE_METHOD_HEADER),
                                CONTENTS_CODE,
                                ((MethodDesc*)pHeader->methodDesc)->GetMemberDef());
                }
                
                index++;
                dword <<= 4;
            }

            pCode += 32*8;
        }

        //
        // Add approximate MIH range (this assumes they're all contiguous)
        //

        AddContents((SIZE_T) firstGCInfo,  lastGCInfo - firstGCInfo, CONTENTS_GC_INFO, 0);

        //
        // Add import blobs
        //

        CORCOMPILE_IMPORT_TABLE_ENTRY *pImport = 
          (CORCOMPILE_IMPORT_TABLE_ENTRY *) (pZap->ImportTable.VirtualAddress + m_baseAddress);
        CORCOMPILE_IMPORT_TABLE_ENTRY *pImportEnd = 
          (CORCOMPILE_IMPORT_TABLE_ENTRY *) (pZap->ImportTable.VirtualAddress + pZap->ImportTable.Size 
                                             + m_baseAddress);

        AddContents((SIZE_T) pImport, pZap->ImportTable.Size, 
                    CONTENTS_IMPORTS, 0);

        while (pImport < pImportEnd)
        {
            AddContents((SIZE_T) (pImport->Imports.VirtualAddress + m_baseAddress),
                        pImport->Imports.Size,
                        CONTENTS_IMPORTS, 0);
            pImport++;
        }

        //
        // Add delay load info
        //

        IMAGE_DATA_DIRECTORY *pInfo = 
          (IMAGE_DATA_DIRECTORY *) (pZap->DelayLoadInfo.VirtualAddress + m_baseAddress);
        IMAGE_DATA_DIRECTORY *pInfoEnd = 
          (IMAGE_DATA_DIRECTORY *) (pZap->DelayLoadInfo.VirtualAddress + pZap->DelayLoadInfo.Size
                                    + m_baseAddress);

        while (pInfo < pInfoEnd)
        {
            AddContents((SIZE_T) (pInfo->VirtualAddress + m_baseAddress),
                        pInfo->Size,
                        CONTENTS_INFO, 0);
            pInfo++;
        }
    }
    else
    {
        //
        // Mark IL methods
        //

        HENUMInternal i;
        mdMethodDef md;
        m_pImport->EnumAllInit(mdtMethodDef, &i);
        while (m_pImport->EnumNext(&i, &md))
        {
            ULONG rva;
            DWORD flags;
            m_pImport->GetMethodImplProps(md, &rva, &flags);
            if (IsMiIL(flags))
            {
                COR_ILMETHOD_DECODER header((COR_ILMETHOD*) (pFile->GetBase() + rva), m_pImport);

                AddContents((SIZE_T) header.Code, header.GetCodeSize(), 
                            CONTENTS_IL, md);

                const COR_ILMETHOD_SECT_EH *pException = header.EH;
                if (pException != NULL)
                    AddContents((SIZE_T) pException, 
                                pException->DataSize(), 
                                CONTENTS_EXCEPTION, md);
            }
        }
    }
}

ZapMonitor::~ZapMonitor()
{
    Page *p = m_pages;
    Page *pEnd = p + m_imageSize / OS_PAGE_SIZE;
    while (p < pEnd)
    {
        UnprotectPage(p);
        if (p->stack != NULL)
            delete [] p->stack;
        p++;
    }

    delete [] m_pages;
}

void ZapMonitor::Reset()
{
    Page *p = m_pages;
    Page *pEnd = p + m_imageSize / OS_PAGE_SIZE;
    while (p < pEnd)
    {
        if (p->touched)
        {
            p->touched = FALSE;
            p->firstTouchedContents = NULL;
            if (p->stack != NULL)
            {
                delete [] p->stack;
                p->stack = NULL;
                p->stackCount = 0;
            }
        }
        p++;
    }

    ProtectPages();
}

void ZapMonitor::AddContents(SIZE_T start, SIZE_T size, 
                             int type, mdToken token)
{
    if (size == 0)
        return;

    _ASSERTE(start >= (SIZE_T)m_baseAddress && start + size <= (SIZE_T)(m_baseAddress + m_imageSize));

    Page *startPage = &m_pages[(start - (SIZE_T)m_pageBase)/OS_PAGE_SIZE];
    Page *endPage = &m_pages[(start + size - 1 - (SIZE_T)m_pageBase)/OS_PAGE_SIZE];

    while (startPage <= endPage)
    {
        Contents *contents = (Contents *) m_nodes.AllocateElement();

        contents->node.Init(start, start + size);
        contents->type = type;
        contents->token = token;

        startPage->contents.AddNode(&contents->node);

        startPage->contentsKind[type] = TRUE;

        startPage++;
    }
}

void ZapMonitor::ProtectPages()
{
    Page *p = m_pages;
    Page *pEnd = p + m_imageSize / OS_PAGE_SIZE;
    while (p < pEnd)
    {
        ProtectPage(p);
        p++;
    }
    m_enabled = TRUE;
}

void ZapMonitor::UnprotectPages()
{
    Page *p = m_pages;
    Page *pEnd = p + m_imageSize / OS_PAGE_SIZE;
    while (p < pEnd)
    {
        UnprotectPage(p);
        p++;
    }
    m_enabled = FALSE;
}

void ZapMonitor::SuspendPages()
{
    Page *p = m_pages;
    Page *pEnd = p + m_imageSize / OS_PAGE_SIZE;
    while (p < pEnd)
    {
        if (p->prot)
        {
            UnprotectPage(p);
            p->prot = TRUE;
        }
        p++;
    }
    m_enabled = TRUE;
}

void ZapMonitor::ResumePages()
{
    Page *p = m_pages;
    Page *pEnd = p + m_imageSize / OS_PAGE_SIZE;
    while (p < pEnd)
    {
        if (p->prot)
        {
            p->prot = FALSE;
            ProtectPage(p);
        }
        p++;
    }
    m_enabled = TRUE;
}

void ZapMonitor::ProtectPage(Page *p)
{
    if (!p->prot 
        && p->base > (SIZE_T) m_baseAddress
        && p->base + OS_PAGE_SIZE <= ((SIZE_T)m_baseAddress + m_imageSize)
        && (p->base > m_rsrc + m_rsrcSize
            || p->base + OS_PAGE_SIZE <= m_rsrc))
    {
        p->prot = VirtualProtect((void *) p->base, OS_PAGE_SIZE, PAGE_NOACCESS, 
                                 &p->oldProtection);
    }
}

void ZapMonitor::UnprotectPage(Page *p)
{
    if (p->prot)
    {
        DWORD old;
        p->prot = !VirtualProtect((void *) p->base, OS_PAGE_SIZE, p->oldProtection, 
                                  &old);
    }
}

BOOL ZapMonitor::Trigger(BYTE* address, CONTEXT *pContext)
{
#ifdef _X86_
    if (address < m_baseAddress || address >= m_baseAddress + m_imageSize)
        return FALSE;

    Page *p = m_pages + ((address - m_pageBase)/OS_PAGE_SIZE);
    _ASSERTE((SIZE_T)address >= p->base && (SIZE_T)address < p->base + OS_PAGE_SIZE);

    if (!p->prot)
        return FALSE;

    UnprotectPage(p);

    p->touched = TRUE;

    RangeTree::Node *n = p->contents.Lookup((SIZE_T)address);
    if (n != NULL)
        p->firstTouchedContents = (Contents *) n;

    if (m_imagehlp != NULL && pContext != NULL)
    {
        if (!m_symInit)
        {
            UINT last = SetErrorMode(SEM_NOOPENFILEERRORBOX|SEM_FAILCRITICALERRORS);
            m_pSymInitialize(GetCurrentProcess(), NULL, TRUE);
            m_pSymSetOptions(SYMOPT_LOAD_LINES);
            SetErrorMode(last);

            m_symInit = TRUE;
        }

        STACKFRAME frame;
        DWORD frameCount = 0;

        ZeroMemory(&frame, sizeof(frame));
        frame.AddrPC.Offset       = pContext->Eip;
        frame.AddrPC.Mode         = AddrModeFlat;
        frame.AddrStack.Offset    = pContext->Esp;
        frame.AddrStack.Mode      = AddrModeFlat;
        frame.AddrFrame.Offset    = pContext->Ebp;
        frame.AddrFrame.Mode      = AddrModeFlat;   

#define FRAME_MAX 10

        while (frameCount < FRAME_MAX
               && m_pStackWalk(IMAGE_FILE_MACHINE_I386, 
                               GetCurrentProcess(), GetCurrentThread(),
                               &frame, 
                               NULL, NULL,
                               m_pSymFunctionTableAccess,
                               m_pSymGetModuleBase,
                               NULL))
        {
            if (frame.AddrFrame.Offset == 0)
                break;
            frameCount++;
        }

        p->stack = new Frame[frameCount];
        p->stackCount = frameCount;

        IMAGEHLP_LINE line;
        line.SizeOfStruct = sizeof(IMAGEHLP_LINE);
        struct {
            IMAGEHLP_SYMBOL symbol; 
            CHAR            space[255];
        } symbol;
        symbol.symbol.SizeOfStruct = sizeof(IMAGEHLP_SYMBOL);
        symbol.symbol.MaxNameLength = sizeof(symbol.space) + 1;

        DWORD frameIndex = 0;

        ZeroMemory(&frame, sizeof(frame));
        frame.AddrPC.Offset       = pContext->Eip;
        frame.AddrPC.Mode         = AddrModeFlat;
        frame.AddrStack.Offset    = pContext->Esp;
        frame.AddrStack.Mode      = AddrModeFlat;
        frame.AddrFrame.Offset    = pContext->Ebp;
        frame.AddrFrame.Mode      = AddrModeFlat;   

        while (frameIndex < FRAME_MAX
               && m_pStackWalk(IMAGE_FILE_MACHINE_I386, 
                               GetCurrentProcess(), GetCurrentThread(),
                               &frame, 
                               NULL, NULL,
                               m_pSymFunctionTableAccess,
                               m_pSymGetModuleBase,
                               NULL))
        {
            if (frame.AddrFrame.Offset == 0)
                break;

            DWORD displacement;

            Frame *current = &p->stack[frameIndex++];

            if (m_pSymGetLineFromAddr(GetCurrentProcess(), 
                                      frame.AddrPC.Offset, &displacement,
                                      &line))
            {
                current->file = line.FileName;
                current->lineNumber = line.LineNumber;
            }
            else
            {
                current->file = "<Unknown>";
                current->lineNumber = 0;
            }

            if (m_pSymGetSymFromAddr(GetCurrentProcess(), 
                                     frame.AddrPC.Offset, &displacement,
                                     &symbol.symbol))
            {
                m_pUnDecorateSymbolName(symbol.symbol.Name, 
                                        current->name, sizeof(current->name), 
                                        UNDNAME_NAME_ONLY);
            }
            else
                strcpy(current->name, "<Unknown>");
        }
    }

    return TRUE;
#else // !_X86_
    _ASSERTE(!"@TODO - Port");
    return FALSE;
#endif // _X86_
}

void ZapMonitor::PrintStackTrace(Frame *stack, SIZE_T count, int indent)
{
    Frame *pFrame = stack;
    Frame *pFrameEnd = stack + count;

    while (pFrame < pFrameEnd)
    {
        for (int i=0; i<indent; i++)
            printf("\t");
        printf("%s, %s line %d\n", pFrame->name, pFrame->file, pFrame->lineNumber);
        pFrame++;
    }
}

void ZapMonitor::PrintContentsType(int contentsType)
{
    static char *description[] =
    {
        "code",
        "GC info",
        "exception",
        "code manager",
        "prejit imports",
        "prejit fixups",
        "metadata",
        "Module",
        "MethodTable",
        "EEClass",
        "MethodDescs",
        "MethodDesc Data",
        "FieldDescs",
        "RVA Field Desc data",
        "Total EE image",
        "IL",
        "Base relocs",
        "Resources",
        "Unknown"
    };
    
    printf(description[contentsType]);
}

void ZapMonitor::PrintContents(Contents *c, int indent)
{
    for (int i=0; i<indent; i++)
        printf("\t");

    printf("%08X-%08X ", 
           c->node.GetStart() - (SIZE_T)m_baseAddress,
           c->node.GetEnd() - (SIZE_T)m_baseAddress);

    PrintContentsType(c->type);

    if (c->token != 0)
    {
        switch (TypeFromToken(c->token))
        {
        case mdtTypeDef:

            LPCSTR name;
            LPCSTR space;
            m_pImport->GetNameOfTypeDef(c->token, &name, &space);
            if (space == NULL || *space == 0)
                printf(" %s", name);
            else
                printf(" %s.%s", space, name);
            break;
            
        case mdtMethodDef:

            mdToken parent;
            m_pImport->GetParentToken(c->token, &parent);
            if (TypeFromToken(parent) == mdtTypeDef)
            {
                LPCSTR name;
                LPCSTR space;
                m_pImport->GetNameOfTypeDef(parent, &name, &space);
                if (space == NULL || *space == 0)
                    printf(" %s::", name);
                else
                    printf(" %s.%s::", space, name);
            }

            printf(" %s", m_pImport->GetNameOfMethodDef(c->token));
            break;
            
        }
    }
    printf("\n");
}

// HORRIBLE HACK - global var for callback
ZapMonitor *g_pMonitor = NULL;

void ZapMonitor::PrintPageContentsCallback(RangeTree::Node *pNode)
{
    g_pMonitor->PrintContents((Contents *) pNode, 1);
}

void ZapMonitor::PrintPage(Page *p)
{
    printf("** Page %08X-%08X ***************************************** %s **\n",
           p->base - (SIZE_T)m_baseAddress, p->base + OS_PAGE_SIZE - (SIZE_T)m_baseAddress,
           p->touched ? "DIRTY" : "CLEAN" );

    // Hack - this isn't threadsafe but who cares for now
    g_pMonitor = this;
    p->contents.Iterate(PrintPageContentsCallback);
    _ASSERTE(g_pMonitor == this);
    g_pMonitor = NULL;

    printf("****************************************************************************\n");

    if (p->touched)
    {
        if (p->firstTouchedContents != NULL)
        {
            printf("\t First touched at: ");
            PrintContents(p->firstTouchedContents, 0);
        }
        
        if (p->stack != NULL)
        {
            printf("\t First touched from:\n");
            PrintStackTrace(p->stack, p->stackCount, 1);
        }

        printf("****************************************************************************\n");
    }

}

void ZapMonitor::PrintReport(BOOL printPages, BOOL printCleanPages)
{
    SIZE_T kindCount[CONTENTS_COUNT+1] = {0};
    SIZE_T kindTouched[CONTENTS_COUNT+1] = {0};

    Page *p = m_pages;
    Page *pEnd = p + m_imageSize / OS_PAGE_SIZE;
    SIZE_T dirtyPages = 0;
    while (p < pEnd)
    {
        if (p->touched)
            dirtyPages++;

        BYTE *k = p->contentsKind;
        BYTE *kEnd = k + CONTENTS_COUNT;
        SIZE_T *c = kindCount;
        SIZE_T *t = kindTouched;
        BOOL found = FALSE;
        while (k < kEnd)
        {
           if (*k++)
           {
               (*c)++;
               if (p->touched)
                   (*t)++;
               found = TRUE;
           }
           c++;
           t++;
        }

        // Put pages with no kinds in the "other" category

        if (!found)
        {
            (*c)++;
            if (p->touched)
                (*t)++;
        }

        p++;
    }

    printf("%S:\n\t%d/%d pages touched.\n", 
           m_module->GetFileName(), dirtyPages, m_imageSize/OS_PAGE_SIZE);

    for (int i = 0; i < CONTENTS_COUNT+1; i++)
    {
        printf("\t %d/%d ", kindTouched[i], kindCount[i]);
        PrintContentsType(i);
        printf(" pages touched.\n"); 
    }
    
    if (printPages)
    {
        printf("****************************************************************************\n");

        p = m_pages;
        while (p < pEnd)
        {
            if (p->touched || printCleanPages)
                PrintPage(p);
            p++;
        }
    }
}

BOOL ZapMonitor::HandleAccessViolation(byte* address, CONTEXT *pContext)
{
    ZapMonitor *z = m_monitors;
    while (z != NULL)
    {
        if (z->Trigger(address, pContext))
            return TRUE;
        z = z->m_next;
    }

    return FALSE;
}

void ZapMonitor::ReportAll(LPCSTR message, BOOL printPages, BOOL printCleanPages)
{
    printf("****************************************************************************\n");
    printf("************************** Page Monitor Report *****************************\n");
    printf("****************************************************************************\n");
    printf("Status: %s.\n", message);

    ZapMonitor *z = m_monitors;
    while (z != NULL)
    {
        z->UnprotectPages();
        z = z->m_next;
    }
    
    z = m_monitors;
    while (z != NULL)
    {
        z->PrintReport(printPages, printCleanPages);
        printf("****************************************************************************\n");
        z = z->m_next;
    }
}

void ZapMonitor::ResetAll()
{
    ZapMonitor *z = m_monitors;
    while (z != NULL)
    {
        z->Reset();
        z = z->m_next;
    }
}

void ZapMonitor::DisableAll()
{
    ZapMonitor *z = m_monitors;
    while (z != NULL)
    {
        z->UnprotectPages();
        z = z->m_next;
    }
}

void ZapMonitor::SuspendAll()
{
    ZapMonitor *z = m_monitors;
    while (z != NULL)
    {
        z->SuspendPages();
        z = z->m_next;
    }
}

void ZapMonitor::ResumeAll()
{
    ZapMonitor *z = m_monitors;
    while (z != NULL)
    {
        z->ResumePages();
        z = z->m_next;
    }
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\i386\cgencpu.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
// CGENX86.H -
//
// Various helper routines for generating x86 assembly code.
//
// DO NOT INCLUDE THIS FILE DIRECTLY - ALWAYS USE CGENSYS.H INSTEAD
//


#ifndef _X86_
#error Should only include "cgenx86.h" for X86 builds
#endif

#ifndef __cgenx86_h__
#define __cgenx86_h__

#include "stublink.h"
#include "utilcode.h"

// FCALL is available on this platform
#define FCALLAVAILABLE 1


// preferred alignment for data
#define DATA_ALIGNMENT 4

class MethodDesc;
class FramedMethodFrame;
class Module;
struct ArrayOpScript;
struct DeclActionInfo;

// default return value type
typedef INT64 PlatformDefaultReturnType;

// CPU-dependent functions
extern "C" void __cdecl PreStubTemplate(void);
extern "C" INT64 __cdecl CallWorker_WilDefault(const BYTE  *pStubTarget, UINT32 numArgSlots, PCCOR_SIGNATURE pSig,
                                               Module *pmodule, const BYTE  *pArgsEnd, BOOL fIsStatic);
extern "C" INT64 __cdecl CallDllFunction(LPVOID pTarget, LPVOID pEndArguments, UINT32 numArgumentSlots, BOOL fThisCall);
extern "C" void __stdcall WrapCall(void *target);
extern "C" void CopyPreStubTemplate(Stub *preStub);
// Non-CPU-specific helper functions called by the CPU-dependent code
extern "C" VOID __stdcall ArgFiller_WilDefault(BOOL fIsStatic, PCCOR_SIGNATURE pSig, Module *pmodule, BYTE *psrc, BYTE *pdst);
extern "C" const BYTE * __stdcall PreStubWorker(PrestubMethodFrame *pPFrame);
extern "C" INT64 __stdcall NDirectGenericStubWorker(Thread *pThread, NDirectMethodFrame *pFrame);
extern "C" INT64 __stdcall ComPlusToComWorker(Thread *pThread, ComPlusMethodFrame* pFrame);

extern "C" DWORD __stdcall GetSpecificCpuType();

void *GetWrapCallFunctionReturn();



//**********************************************************************
// This structure captures the format of the METHOD_PREPAD area (behind
// the MethodDesc.)
//**********************************************************************
#pragma pack(push,1)

struct StubCallInstrs
{
    UINT16      m_wTokenRemainder;      //a portion of the methoddef token. The rest is stored in the chunk
    BYTE        m_chunkIndex;           //index to recover chunk

// This is a stable and efficient entrypoint for the method
    BYTE        m_op;                   //this is either a jump (0xe9) or a call (0xe8)
    UINT32      m_target;               //pc-relative target for jump or call
};

#pragma pack(pop)


#define METHOD_PREPAD                       8 // # extra bytes to allocate in addition to sizeof(Method)
#define METHOD_CALL_PRESTUB_SIZE            5 // x86: CALL(E8) xx xx xx xx
#define METHOD_ALIGN                        8 // required alignment for StubCallInstrs

#define JUMP_ALLOCATE_SIZE                  8 // # bytes to allocate for a jump instrucation
#define METHOD_DESC_CHUNK_ALIGNPAD_BYTES    4 // # bytes required to pad MethodDescChunk to correct size

//**********************************************************************
// Parameter size
//**********************************************************************

typedef INT32 StackElemType;
#define STACK_ELEM_SIZE sizeof(StackElemType)


// !! This expression assumes STACK_ELEM_SIZE is a power of 2.
#define StackElemSize(parmSize) (((parmSize) + STACK_ELEM_SIZE - 1) & ~((ULONG)(STACK_ELEM_SIZE - 1)))

// Get address of actual arg within widened arg
#define ArgTypeAddr(stack, type)      ((type *) ((BYTE*)stack + StackElemSize(sizeof(type)) - sizeof(type)))

// Get value of actual arg within widened arg
#define ExtractArg(stack, type)   (*(type *) ((BYTE*)stack + StackElemSize(sizeof(type)) - sizeof(type)))

#define CEE_PARM_SIZE(size) (max(size), sizeof(INT32))
#define CEE_SLOT_COUNT(size) ((max(size), sizeof(INT32))/INT32)

#define DECLARE_ECALL_DEFAULT_ARG(vartype, varname)   \
    vartype varname;

#define DECLARE_ECALL_OBJECTREF_ARG(vartype, varname)   \
    DECLARE_ECALL_DEFAULT_ARG(vartype, varname);

#define DECLARE_ECALL_PTR_ARG(vartype, varname)   \
    DECLARE_ECALL_DEFAULT_ARG(vartype, varname);

#define DECLARE_ECALL_I1_ARG(vartype, varname)   \
    DECLARE_ECALL_DEFAULT_ARG(vartype, varname);

#define DECLARE_ECALL_I2_ARG(vartype, varname)   \
    vartype varname;

#define DECLARE_ECALL_I4_ARG(vartype, varname)   \
    DECLARE_ECALL_DEFAULT_ARG(vartype, varname);

#define DECLARE_ECALL_R4_ARG(vartype, varname)   \
    DECLARE_ECALL_DEFAULT_ARG(vartype, varname);

#define DECLARE_ECALL_I8_ARG(vartype, varname)   \
    DECLARE_ECALL_DEFAULT_ARG(vartype, varname);

#define DECLARE_ECALL_R8_ARG(vartype, varname)   \
    DECLARE_ECALL_DEFAULT_ARG(vartype, varname);

inline BYTE *getStubCallAddr(MethodDesc *fd) {
    return ((BYTE*)fd) - METHOD_CALL_PRESTUB_SIZE;
}

inline BYTE *getStubCallTargetAddr(MethodDesc *fd) {
    return (BYTE*)((size_t)(*(UINT32*)((size_t)fd - 1)) + (size_t)fd);
}

inline void setStubCallTargetAddr(MethodDesc *fd, const BYTE *addr) {
    FastInterlockExchange((LONG*)fd - 1, (UINT32)((size_t)addr - (size_t)fd));
}

inline BYTE *getStubCallAddr(BYTE *pBuf) {
    return ((BYTE*)pBuf) + 3;   // have allocate 8 bytes, so go in 3 to find call instr point
}

inline BYTE *getStubJumpAddr(BYTE *pBuf) {
    return ((BYTE*)pBuf) + 3;   // have allocate 8 bytes, so go in 3 to find jmp instr point
}

//**********************************************************************
// Frames
//**********************************************************************
//--------------------------------------------------------------------
// This represents some of the TransitionFrame fields that are
// stored at negative offsets.
//--------------------------------------------------------------------
struct CalleeSavedRegisters {
    INT32       edi;
    INT32       esi;
    INT32       ebx;
    INT32       ebp;
};

//--------------------------------------------------------------------
// This represents the arguments that are stored in volatile registers.
// This should not overlap the CalleeSavedRegisters since those are already
// saved separately and it would be wasteful to save the same register twice.
// If we do use a non-volatile register as an argument, then the ArgIterator
// will probably have to communicate this back to the PromoteCallerStack
// routine to avoid a double promotion.
//
// @todo M6: It's silly for a method that has <N arguments to save N
// registers. A good perf item would be for the frame to save only
// the registers it actually needs. This means that NegSpaceSize()
// becomes a function of the callsig.
//--------------------------------------------------------------------
struct ArgumentRegisters {

#define DEFINE_ARGUMENT_REGISTER_BACKWARD(regname)  INT32 regname;
#include "eecallconv.h"

};

// Sufficient context for Try/Catch restoration.
struct EHContext {
    INT32       Eax;
    INT32       Ebx;
    INT32       Ecx;
    INT32       Edx;
    INT32       Esi;
    INT32       Edi;
    INT32       Ebp;
    INT32       Esp;
    INT32       Eip;
};


#define ARGUMENTREGISTERS_SIZE sizeof(ArgumentRegisters)


#define PLATFORM_FRAME_ALIGN(val) (val)

#ifdef _DEBUG

//-----------------------------------------------------------------------
// Under DEBUG, stubs push 8 additional bytes of info in order to
// allow the VC debugger to stacktrace through stubs. This info
// is pushed right after the callee-saved-registers. The stubs
// also must keep ebp pointed to this structure. Note that this
// precludes the use of ebp by the stub itself.
//-----------------------------------------------------------------------
struct VC5Frame
{
    INT32      m_savedebp;
    INT32      m_returnaddress;
};
#define VC5FRAME_SIZE   sizeof(VC5Frame)
#else
#define VC5FRAME_SIZE   0
#endif




#define DECLARE_PLATFORM_FRAME_INFO \
    UINT32      m_eip;              \
    UINT32      m_esp;              \
    UINT32 *getIPSaveAddr() {       \
        return &m_eip;              \
    }                               \
    UINT32 *getSPSaveAddr() {       \
        return &m_esp;              \
    }                               \
    UINT32 getIPSaveVal() {         \
        return m_eip;               \
    }                               \
    UINT32 getSPSaveVal() {         \
        return m_esp;               \
    }

//**********************************************************************
// Exception handling
//**********************************************************************

inline LPVOID GetIP(CONTEXT *context) {
    return (LPVOID)(size_t)(context->Eip);
}

inline void SetIP(CONTEXT *context, LPVOID eip) {
    context->Eip = (UINT32)(size_t)eip;
}

inline LPVOID GetSP(CONTEXT *context) {
    return (LPVOID)(size_t)(context->Esp);
}

inline LPVOID GetSP()
{
    LPVOID SPval;
    __asm mov SPval, esp
    return SPval;
}

inline void SetSP(LPVOID newSP)
{
    LPVOID newSPVal = newSP;
    __asm mov esp, newSPVal
}

inline void SetSP(CONTEXT *context, LPVOID esp) {
    context->Esp = (UINT32)(size_t)esp;
}
inline void SetFP(CONTEXT *context, LPVOID ebp) {
    context->Ebp = (UINT32)(size_t)ebp;
}

//
// Note: the debugger relies on the fact that the stub call is a CALL NEAR32
// with an opcode of 0xe8. See Debug\CorDB\Inprocess.cpp, function
// CorDBIsStubCall.
//
// -- mikemag Sun Jun 28 17:48:42 1998
//
inline void emitStubCall(MethodDesc *pFD, BYTE *stubAddr) {
    BYTE *target = getStubCallAddr(pFD);
    target[0] = 0xe8; // CALL NEAR32
    *((UINT32*)(target+1)) = (UINT32)(stubAddr - (BYTE*)pFD);
}

inline UINT32 getStubDisp(MethodDesc *fd) {
    return *( ((UINT32*)fd)-1);
}


inline void emitCall(LPBYTE pBuffer, LPVOID target)
{
    pBuffer[0] = 0xe8; //CALLNEAR32
    *((LPVOID*)(1+pBuffer)) = (LPVOID) (((LPBYTE)target) - (pBuffer+5));
}

inline LPVOID getCallTarget(const BYTE *pCall)
{
    _ASSERTE(pCall[0] == 0xe8);
    return (LPVOID) (pCall + 5 + *((UINT32*)(1 + pCall)));
}

inline void emitJump(LPBYTE pBuffer, LPVOID target)
{
    pBuffer[0] = 0xe9; //JUMPNEAR32
    *((LPVOID*)(1+pBuffer)) = (LPVOID) (((LPBYTE)target) - (pBuffer+5));
}

inline void updateJumpTarget(LPBYTE pBuffer, LPVOID target)
{
    pBuffer[0] = 0xe9; //JUMPNEAR32
    InterlockedExchange((long*)(1+pBuffer), (DWORD) (((LPBYTE)target) - (pBuffer+5)));
}

inline LPVOID getJumpTarget(const BYTE *pJump)
{
    _ASSERTE(pJump[0] == 0xe9);
    return (LPVOID) (pJump + 5 + *((UINT32*)(1 + pJump)));
}

inline SLOT setCallAddrInterlocked(SLOT *callAddr, SLOT stubAddr, 
                                     SLOT expectedStubAddr)
{
      SLOT result = (SLOT)
      FastInterlockCompareExchange((void **) callAddr, 
                                   (void *)(stubAddr - ((SIZE_T)callAddr + sizeof(SLOT))), 
                                   (void *)(expectedStubAddr - ((SIZE_T)callAddr + sizeof(SLOT)))) 
      + (SIZE_T)callAddr + sizeof(SLOT);

    // result is the previous value of the stub - 
    // instead return the current value of the stub

    if (result == expectedStubAddr)
        return stubAddr;
    else
        return result;
}

inline Stub *setStubCallPointInterlocked(MethodDesc *pFD, Stub *pStub, 
                                         Stub *pExpectedStub) {
    // The offset must be 32-bit aligned for atomicity to be guaranteed.
    _ASSERTE( 0 == (((size_t)pFD) & 3) );

    SLOT stubAddr = (SLOT)pStub->GetEntryPoint();
    SLOT expectedStubAddr = (SLOT)pExpectedStub->GetEntryPoint();

    SLOT newStubAddr = setCallAddrInterlocked((SLOT *)(((long*)pFD)-1), 
                                              stubAddr, expectedStubAddr);

    if (newStubAddr == stubAddr)
         return pStub;
    else
         return Stub::RecoverStub(newStubAddr);
}

inline const BYTE *getStubAddr(MethodDesc *fd) {
    return (const BYTE *)((size_t)getStubDisp(fd) + (size_t)fd);
}

//----------------------------------------------------------
// Marshalling Language support
//----------------------------------------------------------
typedef INT32 SignedParmSourceType;
typedef UINT32 UnsignedParmSourceType;
typedef float FloatParmSourceType;
typedef double DoubleParmSourceType;
typedef INT32 SignedI1TargetType;
typedef UINT32 UnsignedI1TargetType;
typedef INT32 SignedI2TargetType;
typedef UINT32 UnsignedI2TargetType;
typedef INT32 SignedI4TargetType;
typedef UINT32 UnsignedI4TargetType;


#define PTRDST(type)            ((type*)( ((BYTE*&)pdst) -= sizeof(LPVOID) ))

#define STDST(type,val)         (*((type*)( ((BYTE*&)pdst) -= sizeof(type) )) = (val))

#define STPTRDST(type, val)     STDST(type, val)
#define LDSTR4()                STDST(UINT32, (UINT32)LDSRC(UnsignedParmSourceType))
#define LDSTR8()                STDST(UNALIGNED UINT64, LDSRC(UNALIGNED UINT64))

	// This instruction API meaning is do whatever is needed to 
	// when you want to indicate to the CPU that your are busy waiting
	// (this is a good time for this CPU to give up any resources that other
	// processors might put to good use).   On many machines this is a nop.
FORCEINLINE void pause()
{
	__asm rep nop		// This is the intel pause 
}

inline MLParmSize(int parmSize)
{
    return ((parmSize + sizeof(INT32) - 1) & ~((ULONG)(sizeof(INT32) - 1)));
}


inline void setFPReturn(int fpSize, INT64 retVal)
{
    if (fpSize == 4) {
        __asm{
            lea eax, retVal
            fld dword ptr [eax]
        }
    } else if (fpSize == 8) {
        __asm{
            lea eax, retVal
            fld qword ptr [eax]
        }
    }
}

inline void getFPReturn(int fpSize, INT64 &retval)
{
   if (fpSize == 4) {
        __asm{
            mov eax, retval
            fstp dword ptr [eax]
        }
    } else if (fpSize == 8) {
        __asm{
            mov eax, retval
            fstp qword ptr [eax]
        }
    }
}

inline void getFPReturnSmall(INT32 *retval)
{
    __asm
    {
        mov   eax, retval
        fstp  dword ptr [eax]
    }
}

//----------------------------------------------------------------------
// Encodes X86 registers. The numbers are chosen to match Intel's opcode
// encoding.
//----------------------------------------------------------------------
enum X86Reg {
    kEAX = 0,
    kECX = 1,
    kEDX = 2,
    kEBX = 3,
    // kESP intentionally omitted because of its irregular treatment in MOD/RM
    kEBP = 5,
    kESI = 6,
    kEDI = 7

};


// Get X86Reg indexes of argument registers (indices start from 0).
X86Reg GetX86ArgumentRegister(unsigned int index);



//----------------------------------------------------------------------
// Encodes X86 conditional jumps. The numbers are chosen to match
// Intel's opcode encoding.
//----------------------------------------------------------------------
class X86CondCode {
    public:
        enum cc {
            kJA   = 0x7,
            kJAE  = 0x3,
            kJB   = 0x2,
            kJBE  = 0x6,
            kJC   = 0x2,
            kJE   = 0x4,
            kJZ   = 0x4,
            kJG   = 0xf,
            kJGE  = 0xd,
            kJL   = 0xc,
            kJLE  = 0xe,
            kJNA  = 0x6,
            kJNAE = 0x2,
            kJNB  = 0x3,
            kJNBE = 0x7,
            kJNC  = 0x3,
            kJNE  = 0x5,
            kJNG  = 0xe,
            kJNGE = 0xc,
            kJNL  = 0xd,
            kJNLE = 0xf,
            kJNO  = 0x1,
            kJNP  = 0xb,
            kJNS  = 0x9,
            kJNZ  = 0x5,
            kJO   = 0x0,
            kJP   = 0xa,
            kJPE  = 0xa,
            kJPO  = 0xb,
            kJS   = 0x8,
        };
};


//----------------------------------------------------------------------
// StubLinker with extensions for generating X86 code.
//----------------------------------------------------------------------
class StubLinkerCPU : public StubLinker
{
    public:
        VOID X86EmitAddReg(X86Reg reg, __int8 imm8);
        VOID X86EmitSubReg(X86Reg reg, __int8 imm8);
        VOID X86EmitPushReg(X86Reg reg);
        VOID X86EmitPopReg(X86Reg reg);
        VOID X86EmitPushRegs(unsigned regSet);
        VOID X86EmitPopRegs(unsigned regSet);
        VOID X86EmitPushImm32(UINT value);
        VOID X86EmitPushImm32(CodeLabel &pTarget);
        VOID X86EmitPushImm8(BYTE value);
        VOID X86EmitZeroOutReg(X86Reg reg);
        VOID X86EmitNearJump(CodeLabel *pTarget);
        VOID X86EmitCondJump(CodeLabel *pTarget, X86CondCode::cc condcode);
        VOID X86EmitCall(CodeLabel *target, int iArgBytes, BOOL returnLabel = FALSE);
        VOID X86EmitReturn(int iArgBytes);
        VOID X86EmitCurrentThreadFetch();
        VOID X86EmitTLSFetch(DWORD idx, X86Reg dstreg, unsigned preservedRegSet);
        VOID X86EmitSetupThread();
        VOID X86EmitIndexRegLoad(X86Reg dstreg, X86Reg srcreg, __int32 ofs);
        VOID X86EmitIndexRegStore(X86Reg dstreg, __int32 ofs, X86Reg srcreg);
        VOID X86EmitIndexPush(X86Reg srcreg, __int32 ofs);
        VOID X86EmitSPIndexPush(__int8 ofs);
        VOID X86EmitIndexPop(X86Reg srcreg, __int32 ofs);
        VOID X86EmitSubEsp(INT32 imm32);
        VOID X86EmitAddEsp(INT32 imm32);
        VOID X86EmitOffsetModRM(BYTE opcode, X86Reg altreg, X86Reg indexreg, __int32 ofs);
        VOID X86EmitEspOffset(BYTE opcode, X86Reg altreg, __int32 ofs);

        // These are used to emit calls to notify the profiler of transitions in and out of
        // managed code through COM->COM+ interop
        VOID EmitProfilerComCallProlog(PVOID pFrameVptr, X86Reg regFrame);
        VOID EmitProfilerComCallEpilog(PVOID pFrameVptr, X86Reg regFrame);



        // Emits the most efficient form of the operation:
        //
        //    opcode   altreg, [basereg + scaledreg*scale + ofs]
        //
        // or
        //
        //    opcode   [basereg + scaledreg*scale + ofs], altreg
        //
        // (the opcode determines which comes first.)
        //
        //
        // Limitations:
        //
        //    scale must be 0,1,2,4 or 8.
        //    if scale == 0, scaledreg is ignored.
        //    basereg and altreg may be equal to 4 (ESP) but scaledreg cannot
        //    for some opcodes, "altreg" may actually select an operation
        //      rather than a second register argument.
        //    

        VOID X86EmitOp(BYTE    opcode,
                       X86Reg  altreg,
                       X86Reg  basereg,
                       __int32 ofs = 0,
                       X86Reg  scaledreg = (X86Reg)0,
                       BYTE    scale = 0
                       );


        // Emits
        //
        //    opcode altreg, modrmreg
        //
        // or
        //
        //    opcode modrmreg, altreg
        //
        // (the opcode determines which one comes first)
        //
        // For single-operand opcodes, "altreg" actually selects
        // an operation rather than a register.

        VOID X86EmitR2ROp(BYTE opcode, X86Reg altreg, X86Reg modrmreg);



        VOID EmitEnable(CodeLabel *pForwardRef);
        VOID EmitRareEnable(CodeLabel *pRejoinPoint);

        VOID EmitDisable(CodeLabel *pForwardRef);
        VOID EmitRareDisable(CodeLabel *pRejoinPoint, BOOL bIsCallIn);
        VOID EmitRareDisableHRESULT(CodeLabel *pRejoinPoint, CodeLabel *pExitPoint);

        VOID X86EmitSetup(CodeLabel *pForwardRef);
        VOID EmitRareSetup(CodeLabel* pRejoinPoint);

        void EmitComMethodStubProlog(LPVOID pFrameVptr, CodeLabel** rgRareLabels,
                                     CodeLabel** rgRejoinLabels, LPVOID pSEHHandler,
                                     BOOL bShouldProfile);

        void EmitEnterManagedStubEpilog(LPVOID pFrameVptr, unsigned numStackBytes,
                    CodeLabel** rgRareLabels, CodeLabel** rgRejoinLabels,
                    BOOL bShouldProfile);

        void EmitComMethodStubEpilog(LPVOID pFrameVptr, unsigned numStackBytes,
                            CodeLabel** rgRareLabels, CodeLabel** rgRejoinLabels,
                            LPVOID pSEHHAndler, BOOL bShouldProfile);

        //========================================================================
        //  void StubLinkerCPU::EmitSEHProlog(LPVOID pvFrameHandler)
        //  Prolog for setting up SEH for stubs that enter managed code from unmanaged
        //  assumptions: esi has the current frame pointer
        void StubLinkerCPU::EmitSEHProlog(LPVOID pvFrameHandler);

        //===========================================================================
        //  void StubLinkerCPU::EmitUnLinkSEH(unsigned offset)
        //  negOffset is the offset from the current frame where the next exception record
        //  pointer is stored in the stack
        //  for e.g. COM to managed frames the pointer to next SEH record is in the stack
        //          after the ComMethodFrame::NegSpaceSize() + 4 ( address of handler)
        //
        //  also assumes ESI is pointing to the current frame
        void StubLinkerCPU::EmitUnLinkSEH(unsigned offset);

        VOID EmitMethodStubProlog(LPVOID pFrameVptr);
        VOID EmitMethodStubEpilog(__int16 numArgBytes, StubStyle style,
                                  __int16 shadowStackArgBytes = 0);

        VOID EmitUnboxMethodStub(MethodDesc* pRealMD);

        //----------------------------------------------------------------
        //
        // VOID EmitSharedMethodStubEpilog(StubStyle style,
        //                                             unsigned offsetRetThunk)
        //      shared epilog, uses a return thunk within the methoddesc
        //--------------------------------------------------------------------
        VOID EmitSharedMethodStubEpilog(StubStyle style,
                                        unsigned offsetRetThunk);

        //========================================================================
        //  shared Epilog for stubs that enter managed code from COM
        //  uses a return thunk within the method desc
        void EmitSharedComMethodStubEpilog(LPVOID pFrameVptr,
                                           CodeLabel** rgRareLabels,
                                           CodeLabel** rgRejoinLabels,
                                           unsigned offsetReturnThunk,
                                           BOOL bShouldProfile);

        //===========================================================================
        // Emits code to repush the original arguments in the virtual calling
        // convention format.
        VOID EmitShadowStack(MethodDesc *pMD);

        VOID EmitSecurityWrapperStub(__int16 numArgBytes, MethodDesc* pMD, BOOL fToStub, LPVOID pRealStub, DeclActionInfo *pActions);
        VOID EmitSecurityInterceptorStub(MethodDesc* pMD, BOOL fToStub, LPVOID pRealStub, DeclActionInfo *pActions);

        //===========================================================================
        // Emits code for MulticastDelegate.Invoke()
        VOID EmitMulticastInvoke(UINT32 sizeofactualfixedargstack, BOOL fSingleCast, BOOL fReturnFloat);

        //===========================================================================
        // Emits code to adjust for a static delegate target.
        VOID EmitShuffleThunk(struct ShuffleEntry *pShuffeEntryArray);

        //===========================================================================
        // Emits code to capture the lasterror code.
        VOID EmitSaveLastError();


        //===========================================================================
        // Emits code to do an array operation.
        VOID EmitArrayOpStub(const ArrayOpScript*);

        //===========================================================================
        // Emits code to throw a rank exception
        VOID EmitRankExceptionThrowStub(UINT cbFixedArgs);

        //===========================================================================
        // Emits code to touch pages
        // Inputs:
        //   eax = first byte of data
        //   edx = first byte past end of data
        //
        // Trashes eax, edx, ecx
        //
        // Pass TRUE if edx is guaranteed to be strictly greater than eax.
        VOID EmitPageTouch(BOOL fSkipNullCheck);


#ifdef _DEBUG
        VOID X86EmitDebugTrashReg(X86Reg reg);
#endif
    private:
        VOID X86EmitSubEspWorker(INT32 imm32);


};






#ifdef _DEBUG
//-------------------------------------------------------------------------
// This is a helper function that stubs in DEBUG go through to call
// outside code. This is only there to provide a code section return
// address because VC's stack tracing breaks otherwise.
//
// WARNING: Trashes ESI. This is not a C-callable function.
//-------------------------------------------------------------------------
VOID WrapCall(LPVOID pFunc);
#endif

//
// Routines used by debugger support functions such as codepatch.cpp or
// exception handling code.
//
// GetInstruction, InsertBreakpoint, and SetInstruction all operate on
// a _single_ byte of memory. This is really important. If you only
// save one byte from the instruction stream before placing a breakpoint,
// you need to make sure to only replace one byte later on.
//

inline DWORD CORDbgGetInstruction(const unsigned char* address)
{
    return *address; // retrieving only one byte is important
}

inline void CORDbgInsertBreakpoint(const unsigned char* address)
{
    *((unsigned char*)address) = 0xCC; // int 3 (single byte patch)
}

inline void CORDbgSetInstruction(const unsigned char* address,
                                 DWORD instruction)
{
    *((unsigned char*)address)
          = (unsigned char) instruction; // setting one byte is important
}

inline void CORDbgAdjustPCForBreakInstruction(CONTEXT* pContext)
{
    pContext->Eip -= 1;
}

#define CORDbg_BREAK_INSTRUCTION_SIZE 1


// Some platform-specific stuff in support of the "Contexts" feature:
//
// When we generate thunks for CtxProxy VTables, they look like:
//
//             MOV   EAX, <slot>
//             JMP   CtxProxy::HandleCall
//
#define ThunkChunk_ThunkSize    10      // size of the above code


// Adjust the generic interlocked operations for any platform specific ones we
// might have.
void InitFastInterlockOps();



// SEH info forward declarations

typedef struct _EXCEPTION_REGISTRATION_RECORD {
    struct _EXCEPTION_REGISTRATION_RECORD *Next;
    LPVOID Handler;
} EXCEPTION_REGISTRATION_RECORD;

typedef EXCEPTION_REGISTRATION_RECORD *PEXCEPTION_REGISTRATION_RECORD;

struct ComToManagedExRecord; // defined in cgenx86.cpp
// one of the internal exception SEH handlers
EXCEPTION_DISPOSITION __cdecl  ComToManagedExceptHandler (
                                 PEXCEPTION_RECORD pExcepRecord,
                                  ComToManagedExRecord* pEstFrame,
                                  PCONTEXT pContext,
                                  LPVOID    pDispatcherContext);

// Access to the TEB (TIB) from nti386.h
#if defined(MIDL_PASS) || !defined(_M_IX86)
struct _TEB *
NTAPI
NtCurrentTeb( void );
#else
#pragma warning (disable:4035)        // disable 4035 (function must return something)
#define PcTeb 0x18
_inline struct _TEB * NtCurrentTeb( void ) { __asm mov eax, fs:[PcTeb] }
#pragma warning (default:4035)        // reenable it
#endif // defined(MIDL_PASS) || defined(__cplusplus) || !defined(_M_IX86)


inline BOOL IsUnmanagedValueTypeReturnedByRef(UINT sizeofvaluetype) 
{
    return sizeofvaluetype > 8;
}

inline BOOL IsManagedValueTypeReturnedByRef(UINT sizeofvaluetype) 
{
    return TRUE;
}

#define X86_INSTR_HLT  0xf4    //opcode value of X86 HLT instruction

#endif // __cgenx86_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\i386\eecallconv.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==

//===================================================================
// EECALLCONV.H
//
//  This file can be included multiple times and is useful when you
//  need to write code that depends on details of the calling convention.
//
//  To learn how many registers are reserved for arguments, use the macro
//  NUM_ARGUMENT_REGISTERS
//
//  To enumerate the registers from the first (param #1 or "this") to last,
//
//      #define DEFINE_ARGUMENT_REGISTER(regname)  <expression using regname>
//      #include "eecallconv.h"
//
//  To enumerate the registers in reverse order
//
//      #define DEFINE_ARGUMENT_REGISTER_BACKWARD(regname)  <expression using regname>
//      #include "eecallconv.h"
//
//
//===================================================================


#ifndef NUM_ARGUMENT_REGISTERS
#define NUM_ARGUMENT_REGISTERS 2
#endif // !NUM_ARGUMENT_REGISTERS


//--------------------------------------------------------------------
// This defines one register guaranteed not to hold an argument.
//--------------------------------------------------------------------
#ifndef SCRATCH_REGISTER
#define SCRATCH_REGISTER EAX
#endif // !SCRATCH_REGISTER

#ifndef SCRATCH_REGISTER_X86REG
#define SCRATCH_REGISTER_X86REG kEAX
#endif // !SCRATCH_REGISTER_X86REG


#ifndef DEFINE_ARGUMENT_REGISTER
#ifndef DEFINE_ARGUMENT_REGISTER_BACKWARD
#ifndef DEFINE_ARGUMENT_REGISTER_BACKWARD_WITH_OFFSET
#ifndef DEFINE_ARGUMENT_REGISTER_NOTHING    // used to pick up NUM_ARGUMENT_REGISTERS above
#error  "You didn't pick any choices. Check your spelling."
#endif // !DEFINE_ARGUMENT_REGISTER_NOTHING
#endif // !DEFINE_ARGUMENT_REGISTER_BACKWARD_WITH_OFFSET
#endif // !DEFINE_ARGUMENT_REGISTER_BACKWARD
#endif // !DEFINE_ARGUMENT_REGISTER


//-----------------------------------------------------------------------
// Location of "this" argument.
//-----------------------------------------------------------------------
#ifndef THIS_REG
#define THIS_REG        ECX
#endif // !THIS_REG

#ifndef THIS_kREG
#define THIS_kREG       kECX
#endif // !THIS_kREG


#define ARGUMENT_REG1   ECX
#define ARGUMENT_REG2   EDX

//-----------------------------------------------------------------------
// List of registers in forward order. MUST KEEP ALL LISTS IN SYNC.
//-----------------------------------------------------------------------

#ifndef DEFINE_ARGUMENT_REGISTER
#define DEFINE_ARGUMENT_REGISTER(regname)
#endif // !DEFINE_ARGUMENT_REGISTER

DEFINE_ARGUMENT_REGISTER(  ECX  )
DEFINE_ARGUMENT_REGISTER(  EDX  )

#undef DEFINE_ARGUMENT_REGISTER



//-----------------------------------------------------------------------
// List of registers in backward order. MUST KEEP ALL LISTS IN SYNC.
//-----------------------------------------------------------------------

#ifndef DEFINE_ARGUMENT_REGISTER_BACKWARD
#define DEFINE_ARGUMENT_REGISTER_BACKWARD(regname)
#endif // !DEFINE_ARGUMENT_REGISTER_BACKWARD


DEFINE_ARGUMENT_REGISTER_BACKWARD(EDX)
DEFINE_ARGUMENT_REGISTER_BACKWARD(ECX)


#undef DEFINE_ARGUMENT_REGISTER_BACKWARD



//-----------------------------------------------------------------------
// List of registers in backward order with offsets. MUST KEEP ALL LISTS IN SYNC.
//-----------------------------------------------------------------------

#ifndef DEFINE_ARGUMENT_REGISTER_BACKWARD_WITH_OFFSET
#define DEFINE_ARGUMENT_REGISTER_BACKWARD_WITH_OFFSET(regname,ofs)
#endif // !DEFINE_ARGUMENT_REGISTER_BACKWARD_WITH_OFFSET


DEFINE_ARGUMENT_REGISTER_BACKWARD_WITH_OFFSET(EDX,0)
DEFINE_ARGUMENT_REGISTER_BACKWARD_WITH_OFFSET(ECX,4)


#undef DEFINE_ARGUMENT_REGISTER_BACKWARD_WITH_OFFSET
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\i386\excepcpu.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
// EXCEPX86.H -
//
// This header file is optionally included from Excep.h if the target platform is x86
//

#ifndef __excepx86_h__
#define __excepx86_h__

#include "CorError.h"  // HResults for the COM+ Runtime

#include "..\\dlls\\mscorrc\\resource.h"

class Thread;

// Insert a handler that will catch any exceptions prior to the COMPLUS_TRY handler and attempt
// to find a user-level handler first. In debug build, actualRecord will skip past stack overwrite
// barrier and in retail build it will be same as exRecord.
#define InsertCOMPlusFrameHandler(pExRecord)                                     \
    {                                                                           \
        void *actualExRecord = &((pExRecord)->m_pNext); /* skip overwrite barrier */  \
        _ASSERTE(actualExRecord < GetCurrentSEHRecord());                       \
        __asm                                                                   \
        {                                                                       \
            __asm mov edx, actualExRecord   /* edx<-address of EX record */     \
            __asm mov eax, fs:[0]           /* address of previous handler */   \
            __asm mov [edx], eax            /* save into our ex record */       \
            __asm mov fs:[0], edx           /* install new handler */           \
        }                                                                       \
    }

// Remove the handler from the list. 
#define RemoveCOMPlusFrameHandler(pExRecord)                                     \
    {                                                                           \
        void *actualExRecord = &((pExRecord)->m_pNext); /* skip overwrite barrier */  \
        __asm                                                                   \
        {                                                                       \
            __asm mov edx, actualExRecord   /* edx<-pExRecord */                \
            __asm mov edx, [edx]            /* edx<- address of prev handler */ \
            __asm mov fs:[0], edx           /* install prev handler */          \
        }                                                                       \
    }                                                                           \


// stackOverwriteBarrier is used to detect overwriting of stack which will mess up handler registration
#if defined(_DEBUG) && defined(_MSC_VER)
#define COMPLUS_TRY_DECLARE_EH_RECORD() \
    FrameHandlerExRecordWithBarrier *___pExRecord = (FrameHandlerExRecordWithBarrier *)_alloca(sizeof(FrameHandlerExRecordWithBarrier)); \
                    for (int ___i =0; ___i < STACK_OVERWRITE_BARRIER_SIZE; ___i++) \
                        ___pExRecord->m_StackOverwriteBarrier[___i] = STACK_OVERWRITE_BARRIER_VALUE; \
                    ___pExRecord->m_pNext = 0; \
                    ___pExRecord->m_pvFrameHandler = COMPlusFrameHandler; \
                    ___pExRecord->m_pEntryFrame = ___pCurThread->GetFrame();

#define COMPLUS_TRY_DEBUGVARS     \
                    LPVOID ___pPreviousSEH = 0; \
                    __int32 ___iPreviousTryLevel = 0; \


#define COMPLUS_TRY_DEBUGCHECKS()                                                              \
                    ___pPreviousSEH = ___pCurThread->GetComPlusTryEntrySEHRecord();     \
                    ___pCurThread->SetComPlusTryEntrySEHRecord(GetCurrentSEHRecord());         \
                    ___iPreviousTryLevel = ___pCurThread->GetComPlusTryEntryTryLevel(); \
                    ___pCurThread->SetComPlusTryEntryTryLevel( *((__int32*) (((LPBYTE)(GetCurrentSEHRecord())) + MSC_TRYLEVEL_OFFSET) ) );

#define COMPLUS_CATCH_DEBUGCHECKS()                                                     \
                     ___pCurThread->SetComPlusTryEntrySEHRecord(___pPreviousSEH);       \
                     ___pCurThread->SetComPlusTryEntryTryLevel (___iPreviousTryLevel);       

#define MSC_TRYLEVEL_OFFSET                     12

#else
#define COMPLUS_TRY_DECLARE_EH_RECORD() \
                    FrameHandlerExRecord *___pExRecord = (FrameHandlerExRecord *)_alloca(sizeof(FrameHandlerExRecord)); \
                    ___pExRecord->m_pNext = 0; \
                    ___pExRecord->m_pvFrameHandler = COMPlusFrameHandler; \
                    ___pExRecord->m_pEntryFrame = ___pCurThread->GetFrame(); 

#define COMPLUS_TRY_DEBUGCHECKS()
#define COMPLUS_TRY_DEBUGVARS    
#define COMPLUS_CATCH_DEBUGCHECKS()
#endif

LPVOID GetCurrentSEHRecord();
LPVOID GetFirstCOMPlusSEHRecord(Thread*);

// Determine the address of the instruction that made the current call. For X86, pass
// esp where it contains the return address and will adjust back 5 bytes for the call
inline
DWORD GetAdjustedCallAddress(DWORD* esp)
{
    return (*esp - 5);
}

#define INSTALL_EXCEPTION_HANDLING_RECORD(record)               \
    _ASSERTE((void*)record < GetCurrentSEHRecord());            \
    __asm {                                                     \
        __asm mov edx, record                                   \
        __asm mov eax, fs:[0]                                   \
        __asm mov [edx], eax                                    \
        __asm mov fs:[0], edx                                   \
    }

#define UNINSTALL_EXCEPTION_HANDLING_RECORD(record)             \
    __asm {                                                     \
        __asm mov edx, record                                   \
        __asm mov edx, [edx]                                    \
        __asm mov fs:[0], edx                                   \
    }                                                           

#define INSTALL_EXCEPTION_HANDLING_FUNCTION(handler)            \
  {                                                             \
    EXCEPTION_REGISTRATION_RECORD __er;                         \
    _ASSERTE((void*)&__er < GetCurrentSEHRecord());              \
    __er.Handler = (void*)handler;                              \
    __asm {                                                     \
        __asm lea edx, __er.Next                                \
        __asm mov eax, fs:[0]                                   \
        __asm mov [edx], eax                                    \
        __asm mov fs:[0], edx                                   \
    }

#define UNINSTALL_EXCEPTION_HANDLING_FUNCTION                   \
    __asm {                                                     \
        __asm lea edx, __er.Next                                \
        __asm mov edx, [edx]                                    \
        __asm mov fs:[0], edx                                   \
    }                                                           \
  } 
 
 
#define INSTALL_FRAME_HANDLING_FUNCTION(handler, frame_addr)          \
    __asm {                     /* Build EH record on stack */        \
        __asm push    dword ptr [frame_addr] /* frame */              \
        __asm push    offset handler  /* handler */                   \
        __asm push    FS:[0]          /* prev handler */              \
        __asm mov     FS:[0], ESP     /* install this handler */      \
    }

#define UNINSTALL_FRAME_HANDLING_FUNCTION                             \
    __asm {                                                           \
        __asm mov     ecx, [esp]      /* prev handler */              \
        __asm mov     fs:[0], ecx     /* install prev handler */      \
        __asm add     esp, 12         /* cleanup our record */        \
    }

#endif // __excepx86_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\i386\fptext.asm ===
; ==++==
; 
;   Copyright (c) Microsoft Corporation.  All rights reserved.
; 
; ==--==
	.386
	.model	flat

	option	casemap:none
	public	_DoubleToNumber,_NumberToDouble

; NUMBER structure

nPrecision	equ	(dword ptr 0)
nScale		equ	(dword ptr 4)
nSign		equ	(dword ptr 8)
nDigits		equ	(word ptr 12)

	.code

; Powers of 10 from 1.0E1 to 1.0E15 increasing by 1

Pow10By1	label	tbyte

	dt	1.0E1
	dt	1.0E2
	dt	1.0E3
	dt	1.0E4
	dt	1.0E5
	dt	1.0E6
	dt	1.0E7
	dt	1.0E8
	dt	1.0E9
	dt	1.0E10
	dt	1.0E11
	dt	1.0E12
	dt	1.0E13
	dt	1.0E14
	dt	1.0E15

; Powers of 10 from 1.0E16 to 1.0E336 increasing by 16

Pow10By16	label	tbyte

	dt	1.0E16
	dt	1.0E32
	dt	1.0E48
	dt	1.0E64
	dt	1.0E80
	dt	1.0E96
	dt	1.0E112
	dt	1.0E128
	dt	1.0E144
	dt	1.0E160
	dt	1.0E176
	dt	1.0E192
	dt	1.0E208
	dt	1.0E224
	dt	1.0E240
	dt	1.0E256
	dt	1.0E272
	dt	1.0E288
	dt	1.0E304
	dt	1.0E320
	dt	1.0E336

; Single precision constants

Single10	dd	10.0
SingleINF	dd	7F800000H

g_CwStd		dw	137fH		;Mask all errors, 64-bit, round near

; void _cdecl DoubleToNumber(double value, int precision, NUMBER* number)

_DoubleToNumber		proc

value		equ	(qword ptr [ebp+8])
precision	equ	(dword ptr [ebp+16])
number		equ	(dword ptr [ebp+20])
paramSize	=	16

cwsave		equ (word ptr [ebp-24])
digits		equ	(tbyte ptr [ebp-20])
temp		equ	(tbyte ptr [ebp-10])
localSize	=	24

	push	ebp
	mov	ebp,esp
	sub	esp,localSize
	push	edi
	push	ebx
	fnstcw  cwsave
	fldcw g_CwStd
	fld	value
	fstp	temp
	mov	edi,number
	mov	eax,precision
	mov	nPrecision[edi],eax
	movzx	eax,word ptr temp[8]
	mov	edx,eax
	shr	edx,15
	mov	nSign[edi],edx
	and	eax,7FFFH
	je	DN1
	cmp	eax,7FFFH
	jne	DN10
	mov	eax,80000000H
	cmp	dword ptr temp[4],eax
	jne	DN1
	cmp	dword ptr temp[0],0
	jne	DN1
	dec	eax
DN1:	mov	nScale[edi],eax
	mov	nDigits[edi],0
	jmp	DN30
DN10:	fld	value
	sub	eax,16382+58		;Remove bias and 58 bits
	imul	eax,19728		;log10(2) * 2^16 = .30103 * 65536
	add	eax,0FFFFH		;Round up
	sar	eax,16			;Only use high half
	lea	edx,[eax+18]
	mov	nScale[edi],edx
 	neg	eax
	call	ScaleByPow10
	fbstp	digits
	xor	eax,eax
	xor	ebx,ebx
	mov	ecx,precision
	inc	ecx
	mov	edx,8
	mov	al,byte ptr digits[8]
	test	al,0F0H
	jne	DN11
	dec	nScale[edi]
	jmp	DN12
DN11:	shr	al,4
	dec	ecx
	je	DN20
	add	al,'0'
	mov	nDigits[edi+ebx*2],ax
	inc	ebx
	mov	al,byte ptr digits[edx]
DN12:	and	al,0FH
	dec	ecx
	je	DN20
	add	al,'0'
	mov	nDigits[edi+ebx*2],ax
	inc	ebx
	dec	edx
	jl  DN22					; We've run out of digits & don't have a rounding digit, so we'll skip the rounding step.
	mov	al,byte ptr digits[edx]
	jmp	DN11
DN20:	cmp	al,5
	jb	DN22
DN21:	dec	ebx
	inc	nDigits[edi+ebx*2]
	cmp	nDigits[edi+ebx*2],'9'
	jbe	DN23
	or	ebx,ebx
	jne	DN21
	mov	nDigits[edi+ebx*2],'1'
	inc	nScale[edi]
	jmp	DN23
DN22:	dec	ebx
	cmp	nDigits[edi+ebx*2],'0'
	je	DN22
DN23:	mov	nDigits[edi+ebx*2+2],0
DN30:
	fldcw	cwsave			;;Restore original CW
	pop	ebx
	pop	edi
	mov	esp,ebp
	pop	ebp
	ret	;made _cdecl for WinCE paramSize

_DoubleToNumber		endp

; void _cdecl NumberToDouble(NUMBER* number, double* value)
_NumberToDouble		proc

number		equ	(dword ptr [ebp+8])
value		equ	(dword ptr [ebp+12])
paramSize	=	8

cwsave		equ (word  ptr [ebp-8])
temp		equ	(dword ptr [ebp-4])
localSize	=	8

	push	ebp     
	mov	ebp,esp					; Save the stack ptr
	sub	esp,localSize			;
	fnstcw  cwsave
	fldcw g_CwStd		
	fldz						; zero the register
	mov	ecx,number				; move precision into ecx
	xor	edx,edx					; clear edx
	cmp	dx,nDigits[ecx]			; if the first digit is 0 goto ND3
	je	SignResult
	mov	eax,nScale[ecx]			; store the scale in eax
	cmp	eax,-330				; if the scale is less than or equal to -330 goto ND4
	jle	Cleanup
	cmp	eax,310					; if the scale is less than 310, goto ND1
	jl	ParseDigits
	fstp	st(0)				; store value on the top of the floating point stack
	fld	SingleINF				; Load infinity
	jmp	SignResult				; Goto SignResult
ParseDigits:	
	movzx	eax,nDigits[ecx+edx*2]; load the character at nDigits[edx];
	sub	eax,'0'					; subtract '0'
	jc	ScaleResult				; jump to ScaleResult if this produces a negative value
	mov	temp,eax				; store the first digit in temp
	fmul	Single10			; Multiply by 10
	fiadd	temp				; Add the digit which we just found
	inc	edx						; increment the counter
	cmp	edx,18					; if (eax<18) goto ND1
	jb	ParseDigits
ScaleResult:	
	mov	eax,nScale[ecx]			; eax = scale
	sub	eax,edx					; scale -= (number of digits)
	call	ScaleByPow10		; multiply the result by 10^scale
SignResult:	
	cmp	nSign[ecx],0			; If the sign is 0 already go to ND4, otherwise change the sign.
	je	Cleanup
	fchs
Cleanup:	
	mov	edx,value				; store value in edx
	fstp	qword ptr [edx]		; copy from value to the fp stack
	fldcw	cwsave				; Restore original CW		
	mov	esp,ebp					; restore the stack frame & exit.
	pop	ebp
	ret	;Made _cdecl for WinCE  paramSize

_NumberToDouble		endp

; Scale st(0) by 10^eax
		
ScaleByPow10	proc
	test	eax,eax
	je	SP2
	jl	SP3
	mov	edx,eax
	and	edx,0FH
	je	SP1
	lea	edx,[edx+edx*4]
	fld	Pow10By1[edx*2-10]
	fmul
SP1:	mov	edx,eax
	shr	edx,4
	je	SP2
	lea	edx,[edx+edx*4]
	fld	Pow10By16[edx*2-10]
	fmul
SP2:	ret
SP3:	neg	eax
	mov	edx,eax
	and	edx,0FH
	je	SP4
	lea	edx,[edx+edx*4]
	fld	Pow10By1[edx*2-10]
	fdiv
SP4:	mov	edx,eax
	shr	edx,4
	je	SP5
	lea	edx,[edx+edx*4]
	fld	Pow10By16[edx*2-10]
	fdiv
SP5:	ret
ScaleByPow10	endp
		
	end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\i386\excepx86.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*  EXCEP.CPP:
 *
 */
#include "common.h"

#include "tls.h"
#include "frames.h"
#include "excep.h"
#include "object.h"
#include "COMString.h"
#include "field.h"
#include "DbgInterface.h"
#include "cgensys.h"
#include "gcscan.h"
#include "comutilnative.h"
#include "comsystem.h"
#include "commember.h"
#include "SigFormat.h"
#include "siginfo.hpp"
#include "gc.h"
#include "EEDbgInterfaceImpl.h" //so we can clearexception in COMPlusThrow
#include "PerfCounters.h"
#include "EEProfInterfaces.h"
#include "NExport.h"
#include "threads.h"
#include "GuardPageHelper.h"
#include "AppDomainHelper.h"
#include "EEConfig.h"
#include "vars.hpp"
#include "cgenx86.h"

#include "zapmonitor.h"

#include "threads.inl"

#define FORMAT_MESSAGE_BUFFER_LENGTH 1024

BOOL ComPlusStubSEH(EXCEPTION_REGISTRATION_RECORD*);
BOOL ComPlusFrameSEH(EXCEPTION_REGISTRATION_RECORD*);
BOOL IsContextTransitionFrameHandler(EXCEPTION_REGISTRATION_RECORD*);
LPVOID GetCurrentSEHRecord();
LPVOID GetPrevSEHRecord(EXCEPTION_REGISTRATION_RECORD*);


extern "C" void JIT_WriteBarrierStart();
extern "C" void JIT_WriteBarrierEnd();

static inline BOOL 
CPFH_ShouldUnwindStack(DWORD exceptionCode) {

    // We can only unwind those exceptions whose context/record we don't need for a 
    // rethrow.  This is complus, and stack overflow.  For all the others, we
    // need to keep the context around for a rethrow, which means they can't
    // be unwound.
    if (exceptionCode == EXCEPTION_COMPLUS || exceptionCode == STATUS_STACK_OVERFLOW)
        return TRUE;
    else 
        return FALSE;
}

static inline BOOL IsComPlusNestedExceptionRecord(EXCEPTION_REGISTRATION_RECORD* pEHR)
{
    if (pEHR->Handler == COMPlusNestedExceptionHandler)
        return TRUE;
    return FALSE;
}

EXCEPTION_REGISTRATION_RECORD *TryFindNestedEstablisherFrame(EXCEPTION_REGISTRATION_RECORD *pEstablisherFrame)
{
    while (pEstablisherFrame->Handler != COMPlusNestedExceptionHandler) {
        pEstablisherFrame = pEstablisherFrame->Next;
        if (pEstablisherFrame == (EXCEPTION_REGISTRATION_RECORD*)-1) return 0;
    }
    return pEstablisherFrame;
}

#ifdef _DEBUG
// stores last handler we went to in case we didn't get an endcatch and stack is
// corrupted we can figure out who did it.
static MethodDesc *gLastResumedExceptionFunc = NULL;
static DWORD gLastResumedExceptionHandler = 0;
#endif

VOID ResetCurrentContext()
{
    /* Clear the direction flag (used for rep instructions) */

    __asm cld

    /* Reset the FP stack */
    unsigned  ctrlWord;
    __asm { 
        fnstcw ctrlWord
        fninit                  // reset FPU
        and ctrlWord, 0xF00     // preserve precision and rounding control
        or  ctrlWord, 0x07F     // mask all exceptions
        fldcw ctrlWord          // preserve precision control (TODO should we?)
    }
}


//
// Link in a new frame
//
void FaultingExceptionFrame::InitAndLink(CONTEXT *pContext)
{
    CalleeSavedRegisters *pRegs = GetCalleeSavedRegisters();
    pRegs->ebp = pContext->Ebp;
    pRegs->ebx = pContext->Ebx;
    pRegs->esi = pContext->Esi;
    pRegs->edi = pContext->Edi;
    m_ReturnAddress = ::GetIP(pContext);
    m_Esp = (DWORD)(size_t)GetSP(pContext);
    Push();
}

extern "C" VOID __stdcall RtlUnwind(PVOID, PVOID, PVOID, PVOID);

BOOL __declspec(naked)
CallRtlUnwind(EXCEPTION_REGISTRATION_RECORD *pEstablisherFrame, void *callback, EXCEPTION_RECORD *pExceptionRecord, void *retVal)
{
    // In the checked version, we compile /GZ to check for imbalanced stacks and
    // uninitialized locals.  But RtlUnwind doesn't restore registers across a
    // call (it's more of a longjmp).  So make the call manually to defeat the
    // compiler's checking.

    // pRtlUnwind(pEstablisherFrame, RtlUnwindCallback, pExceptionRecord, retVal);
    __asm
    {
        push    ebp
        mov     ebp, esp
        
        push    ebx             // RtlUnwind trashes EBX, ESI, EDI.
        push    esi             // To avoid confusing VC, save them.
        push    edi
        push    dword ptr [retVal]
        push    dword ptr [pExceptionRecord]
        push    offset RtlUnwindCallback
        push    dword ptr [pEstablisherFrame]
        call    RtlUnwind
        pop     edi
        pop     esi
        pop     ebx
    // on x86 at least, RtlUnwind always returns
        push 1
        pop  eax

        leave
        ret 10h
    }
}

UnmanagedToManagedCallFrame* GetCurrFrame(ComToManagedExRecord *);

inline BOOL IsOneOfOurSEHHandlers(EXCEPTION_REGISTRATION_RECORD *pEstablisherFrame)
{
    return (   ComPlusFrameSEH(pEstablisherFrame) 
            || FastNExportSEH(pEstablisherFrame) 
            || ComPlusStubSEH(pEstablisherFrame) 
            || NExportSEH(pEstablisherFrame)
            || IsContextTransitionFrameHandler(pEstablisherFrame));
}

Frame *GetCurrFrame(EXCEPTION_REGISTRATION_RECORD *pEstablisherFrame)
{
    _ASSERTE(IsOneOfOurSEHHandlers(pEstablisherFrame));
    if (ComPlusFrameSEH(pEstablisherFrame) || FastNExportSEH(pEstablisherFrame))
        return ((FrameHandlerExRecord *)pEstablisherFrame)->GetCurrFrame();

    if (IsContextTransitionFrameHandler(pEstablisherFrame))
        return ContextTransitionFrame::CurrFrame(pEstablisherFrame);

    return GetCurrFrame((ComToManagedExRecord*)pEstablisherFrame);
}

LPVOID GetNextCOMPlusSEHRecord(EXCEPTION_REGISTRATION_RECORD* pRec) {
    if (pRec == (EXCEPTION_REGISTRATION_RECORD*) -1) 
        return (LPVOID) -1;

    do {
        _ASSERTE(pRec != 0);
        pRec = pRec->Next;
    } while (pRec != (EXCEPTION_REGISTRATION_RECORD*) -1 && !IsOneOfOurSEHHandlers(pRec));

    _ASSERTE(pRec == (EXCEPTION_REGISTRATION_RECORD*) -1 || IsOneOfOurSEHHandlers(pRec));
    return pRec;
}

inline BOOL IsRethrownException(ExInfo *pExInfo, CONTEXT *pContext)
{
    _ASSERTE(pExInfo);
    return pExInfo->IsRethrown();
}


//================================================================================

// There are some things that should never be true when handling an
// exception.  This function checks for them.  Will assert or trap
// if it finds an error.
static inline void 
CPFH_VerifyThreadIsInValidState(Thread* pThread, DWORD exceptionCode, EXCEPTION_REGISTRATION_RECORD *pEstablisherFrame) {

    if (   exceptionCode == STATUS_BREAKPOINT
        || exceptionCode == STATUS_SINGLE_STEP) {
        return;
    }

#ifdef _DEBUG
    // check for overwriting of stack
    CheckStackBarrier(pEstablisherFrame);
    // trigger check for bad fs:0 chain
    GetCurrentSEHRecord();
#endif

    if (!g_fEEShutDown) {
        // An exception on the GC thread will likely lock out the entire process.
        if (GetThread() == g_pGCHeap->GetGCThread())
        {
            _ASSERTE(!"Exception during garbage collection");
            if (g_pConfig->GetConfigDWORD(L"EHGolden", 0))
                DebugBreak();

            FatalInternalError();
        }
        if (ThreadStore::HoldingThreadStore())
        {
            _ASSERTE(!"Exception while holding thread store");
            if (g_pConfig->GetConfigDWORD(L"EHGolden", 0))
                DebugBreak();

            FatalInternalError();
        }
    }
}


// A wrapper for the profiler.  Various events to signal different phases of exception 
// handling.  
//
// @NICE ... be better if this was the primary Profiler interface, and used consistently 
// throughout the EE.
//
class Profiler {
public:

#ifdef PROFILING_SUPPORTED
    //
    // Exception creation
    //

    static inline void 
    ExceptionThrown(Thread *pThread)
    {
        if (CORProfilerTrackExceptions())
        {
            _ASSERTE(pThread->PreemptiveGCDisabled());

            // Get a reference to the object that won't move
            OBJECTREF thrown = pThread->GetThrowable();

            g_profControlBlock.pProfInterface->ExceptionThrown(
                reinterpret_cast<ThreadID>(pThread),
                reinterpret_cast<ObjectID>((*(BYTE **)&thrown)));
        }
    }

    //
    // Search phase
    //

    static inline void
    ExceptionSearchFunctionEnter(Thread *pThread, MethodDesc *pFunction)
    {
        // Notify the profiler of the function being searched for a handler.
        if (CORProfilerTrackExceptions())
            g_profControlBlock.pProfInterface->ExceptionSearchFunctionEnter(
                reinterpret_cast<ThreadID>(pThread),
                reinterpret_cast<FunctionID>(pFunction));
    }

    static inline void
    ExceptionSearchFunctionLeave(Thread *pThread)
    {
        // Notify the profiler of the function being searched for a handler.
        if (CORProfilerTrackExceptions())
            g_profControlBlock.pProfInterface->ExceptionSearchFunctionLeave(
                reinterpret_cast<ThreadID>(pThread));
    }

    static inline void
    ExceptionSearchFilterEnter(Thread *pThread, MethodDesc *pFunc)
    {
        // Notify the profiler of the filter.
        if (CORProfilerTrackExceptions())
            g_profControlBlock.pProfInterface->ExceptionSearchFilterEnter(
                reinterpret_cast<ThreadID>(pThread),
                reinterpret_cast<FunctionID>(pFunc));
    }

    static inline void
    ExceptionSearchFilterLeave(Thread *pThread)
    {
        // Notify the profiler of the filter.
        if (CORProfilerTrackExceptions())
            g_profControlBlock.pProfInterface->ExceptionSearchFilterLeave(
                reinterpret_cast<ThreadID>(pThread));
    }

    static inline void
    ExceptionSearchCatcherFound(Thread *pThread, MethodDesc *pFunc)
    {
        if (CORProfilerTrackExceptions())
            g_profControlBlock.pProfInterface->ExceptionSearchCatcherFound(
                reinterpret_cast<ThreadID>(pThread),
                reinterpret_cast<FunctionID>(pFunc));
    }

    static inline void
    ExceptionOSHandlerEnter(Thread *pThread, ThrowCallbackType *pData, MethodDesc *pFunc)
    {
        // If this is first managed function seen in this crawl, notify profiler.
        if (CORProfilerTrackExceptions())
        {
            if (pData->pProfilerNotify == NULL)
            {
                g_profControlBlock.pProfInterface->ExceptionOSHandlerEnter(
                    reinterpret_cast<ThreadID>(pThread),
                    reinterpret_cast<FunctionID>(pFunc));
            }
            pData->pProfilerNotify = pFunc;
        }
    }

    static inline void
    ExceptionOSHandlerLeave(Thread *pThread, ThrowCallbackType *pData)
    {
        if (CORProfilerTrackExceptions())
        {
            if (pData->pProfilerNotify != NULL)
            {
                g_profControlBlock.pProfInterface->ExceptionOSHandlerLeave(
                    reinterpret_cast<ThreadID>(pThread),
                    reinterpret_cast<FunctionID>(pData->pProfilerNotify));
            }
        }
    }

    //
    // Unwind phase
    //
    static inline void
    ExceptionUnwindFunctionEnter(Thread *pThread, MethodDesc *pFunc)
    {
        // Notify the profiler of the function being searched for a handler.
        if (CORProfilerTrackExceptions())
            g_profControlBlock.pProfInterface->ExceptionUnwindFunctionEnter(
                reinterpret_cast<ThreadID>(pThread),
                reinterpret_cast<FunctionID>(pFunc));
    }

    static inline void
    ExceptionUnwindFunctionLeave(Thread *pThread)
    {
        // Notify the profiler that searching this function is over.
        if (CORProfilerTrackExceptions())
            g_profControlBlock.pProfInterface->ExceptionUnwindFunctionLeave(
                reinterpret_cast<ThreadID>(pThread));
    }

    static inline void
    ExceptionUnwindFinallyEnter(Thread *pThread, MethodDesc *pFunc)
    {
        // Notify the profiler of the function being searched for a handler.
        if (CORProfilerTrackExceptions())
            g_profControlBlock.pProfInterface->ExceptionUnwindFinallyEnter(
                reinterpret_cast<ThreadID>(pThread),
                reinterpret_cast<FunctionID>(pFunc));
    }

    static inline void
    ExceptionUnwindFinallyLeave(Thread *pThread)
    {
        // Notify the profiler of the function being searched for a handler.
        if (CORProfilerTrackExceptions())
            g_profControlBlock.pProfInterface->ExceptionUnwindFinallyLeave(
                reinterpret_cast<ThreadID>(pThread));
    }

    static inline void
    ExceptionCatcherEnter(Thread *pThread, MethodDesc *pFunc)
    {
        // Notify the profiler.
        if (CORProfilerTrackExceptions())
        {
            // @TODO - remove the thrown variable as well as the 
            // gcprotect they are pointless.  Did not go an do it
            // because we are too close to RTM -vancem

            // Note that the callee must be aware that the ObjectID 
            // passed CAN change when gc happens. 
            OBJECTREF thrown = NULL;
            GCPROTECT_BEGIN(thrown);
            thrown = pThread->GetThrowable();

            g_profControlBlock.pProfInterface->ExceptionCatcherEnter(
                reinterpret_cast<ThreadID>(pThread),
                reinterpret_cast<FunctionID>(pFunc),
                reinterpret_cast<ObjectID>((*(BYTE **)&thrown)));

            GCPROTECT_END();
        }
    }

    static inline void
    ExceptionCatcherLeave(Thread *pThread)
    {
        // Notify the profiler of the function being searched for a handler.
        if (CORProfilerTrackExceptions())
            g_profControlBlock.pProfInterface->ExceptionCatcherLeave(
                reinterpret_cast<ThreadID>(pThread));
    }

    static inline void
    ExceptionCLRCatcherFound()
    {
        // Notify the profiler that the exception is being handled by the runtime
        if (CORProfilerTrackCLRExceptions())
            g_profControlBlock.pProfInterface->ExceptionCLRCatcherFound();
    }

    static inline void
    ExceptionCLRCatcherExecute()
    {
        // Notify the profiler that the exception is being handled by the runtime
        if (CORProfilerTrackCLRExceptions())
            g_profControlBlock.pProfInterface->ExceptionCLRCatcherExecute();
    }

#else // !PROFILING_SUPPORTED
    static inline void ExceptionThrown(Thread *pThread) {}
    static inline void ExceptionSearchFunctionEnter(Thread *pThread, MethodDesc *pFunction) {}
    static inline void ExceptionSearchFunctionLeave(Thread *pThread) {}
    static inline void ExceptionSearchFilterEnter(Thread *pThread, MethodDesc *pFunc) {}
    static inline void ExceptionSearchFilterLeave(Thread *pThread) {}
    static inline void ExceptionSearchCatcherFound(Thread *pThread, MethodDesc *pFunc) {}
    static inline void ExceptionOSHandlerEnter(Thread *pThread, ThrowCallbackType *pData, MethodDesc *pFunc) {}
    static inline void ExceptionOSHandlerLeave(Thread *pThread, ThrowCallbackType *pData) {}
    static inline void ExceptionUnwindFunctionEnter(Thread *pThread, MethodDesc *pFunc) {}
    static inline void ExceptionUnwindFunctionLeave(Thread *pThread) {}
    static inline void ExceptionUnwindFinallyEnter(Thread *pThread, MethodDesc *pFunc) {}
    static inline void ExceptionUnwindFinallyLeave(Thread *pThread) {}
    static inline void ExceptionCatcherEnter(Thread *pThread, MethodDesc *pFunc) {}
    static inline void ExceptionCatcherLeave(Thread *pThread) {}
    static inline void ExceptionCLRCatcherFound() {}
    static inline void ExceptionCLRCatcherExecute() {}
#endif // !PROFILING_SUPPORTED
}; // class Profiler

// This is so that this function can be called from other parts of code
void Profiler_ExceptionCLRCatcherExecute()
{
    Profiler::ExceptionCLRCatcherExecute();
}


// Did we hit an DO_A_GC_HERE marker in JITTed code?
static inline bool
CPFH_IsGcMarker(DWORD exceptionCode, CONTEXT *pContext) {
#if defined(STRESS_HEAP) && defined(_DEBUG)
    if (exceptionCode == STATUS_PRIVILEGED_INSTRUCTION) {
        if (OnGcCoverageInterrupt(pContext))
            return true;

        // Should never be in managed code.
        ICodeManager *pMgr = ExecutionManager::FindCodeMan((SLOT)GetIP(pContext));
        if (pMgr)
            _ASSERTE(!"Hit privileged instruction!");
    }
#endif
    return false;
}

// Return true if the access violation is well formed (has two info parameters
// at the end)
static inline BOOL
CPFH_IsWellFormedAV(EXCEPTION_RECORD *pExceptionRecord) {
    if (pExceptionRecord->NumberParameters == 2) {
        return TRUE;
    } else {        
        return FALSE;
    }
}

// Some page faults are handled by the GC.
static inline BOOL
CPFH_IsGcFault(EXCEPTION_RECORD* pExceptionRecord) {
    //get the fault address and hand it to GC. 
    void* f_address = (void*)pExceptionRecord->ExceptionInformation [1];
    if ( g_pGCHeap->HandlePageFault (f_address) ) {
        return true;
    } else {
        return false;
    }
}

// Some page faults are handled by perf monitors.
static inline BOOL
CPFH_IsMonitorFault(EXCEPTION_RECORD* pExceptionRecord, CONTEXT* pContext) {
    return COMPlusIsMonitorException(pExceptionRecord, pContext);
}

static inline void
CPFH_AdjustContextForThreadSuspensionRace(CONTEXT *pContext, Thread *pThread) {


    void* f_IP = GetIP(pContext);
    if (Thread::IsAddrOfRedirectFunc(f_IP)) {

        // This is a very rare case where we tried to redirect a thread that was
        // just about to dispatch an exception, and our update of EIP took, but
        // the thread continued dispatching the exception.  
        // 
        // If this should happen (very rare) then we fix it up here.
        // 
        _ASSERTE(pThread->GetSavedRedirectContext());
        SetIP(pContext, GetIP(pThread->GetSavedRedirectContext()));
        STRESS_LOG1(LF_EH, LL_INFO100, "CPFH_AdjustContextForThreadSuspensionRace: Case 1 setting IP = %x\n", pContext->Eip);
    }

// We have another even rarer race condition:
// - A) On thread A, Debugger puts an int 3 in the code stream at address X
// - A) We hit it and the begin an exception. The eip will be X + 1 (int3 is special)
// - B) Meanwhile, thread B redirects A's eip to Y. (Although A is really somewhere
// in the kernal, it looks like it's still in user code, so it can fall under the
// HandledJitCase and can be redirected)
// - A) The OS, trying to be nice, expects we have a breakpoint exception at X+1,
// but does -1 on the address since it knows int3 will leave the eip +1.
// So the context structure it will pass to the Handler is ideally (X+1)-1 = X
//
// ** Here's the race: Since thread B redirected A, the eip is actually Y (not X+1),
// but the kernel still touches it up to Y-1. So there's a window between when we hit a 
// bp and when the handler gets called that this can happen.
// This causes an unhandled BP (since the debugger doesn't recognize the bp at Y-1)
//
// So what to do: If we land at Y-1 (ie, if f_IP+1 is the addr of a Redirected Func),
// then restore the EIP back to X. This will skip the redirection. 
// Fortunately, this only occurs in cases where it's ok
// to skip. The debugger will recognize the patch and handle it.

    if (Thread::IsAddrOfRedirectFunc((BYTE*) f_IP + 1)) {
        _ASSERTE(pThread->GetSavedRedirectContext());
        SetIP(pContext, (BYTE*) GetIP(pThread->GetSavedRedirectContext()) - 1);
        STRESS_LOG1(LF_EH, LL_INFO100, "CPFH_AdjustContextForThreadSuspensionRace: Case 2 setting IP = %x\n", pContext->Eip);
    }
}

static inline void
CPFH_AdjustContextForWriteBarrier(CONTEXT *pContext) {
    void* f_IP = GetIP(pContext);
    if (f_IP >= JIT_WriteBarrierStart && f_IP <= JIT_WriteBarrierEnd ||
        f_IP >= (void *)JIT_WriteBarrier_Buf_Start && f_IP <= (void *)JIT_WriteBarrier_Buf_End) {
        // set the exception IP to be the instruction that called the write barrier
        SetIP(pContext, (void*)(size_t)GetAdjustedCallAddress((DWORD*)(size_t)pContext->Esp));
        // put ESP back to whatit was before the call.  
        pContext->Esp += sizeof(void*);     
    }
}


// We sometimes move a thread's execution so it will throw an exception for us.
// But then we have to treat the exception as if it came from the instruction
// the thread was originally running.
//
// NOTE: This code depends on the fact that there are no register-based data dependencies
// between a try block and a catch, fault, or finally block.  If there were, then we need 
// to preserve more of the register context.

static inline BOOL
CPFH_AdjustContextForThreadStop(CONTEXT *pContext, Thread *pThread) {
    if (pThread->ThrewControlForThread() == Thread::InducedThreadStop) {
        _ASSERTE(pThread->m_OSContext);
        SetIP(pContext, (void*)(size_t)pThread->m_OSContext->Eip);
        SetSP(pContext, (void*)(size_t)pThread->m_OSContext->Esp);
        if (pThread->m_OSContext->Ebp != 0)  // ebp = 0 implies that we got here with the right values for ebp
        {
            SetFP(pContext, (void*)(size_t)pThread->m_OSContext->Ebp);
        }
        
        // We might have been interrupted execution at a point where the jit has roots in
        // registers.  We just need to store a "safe" value in here so that the collector
        // doesn't trap.  We're not going to use these objects after the exception.
        //
        // Only callee saved registers are going to be reported by the faulting excepiton frame.
        // Ebx,esi,edi are important.  Eax,ecx,edx are not.
        pContext->Ebx = 0;
        pContext->Edi = 0;
        pContext->Esi = 0;
        
        pThread->ResetStopRequest();
        pThread->ResetThrowControlForThread();
        return true;
    } else {
        return false;
    }
}

static inline void
CPFH_AdjustContextForInducedStackOverflow(CONTEXT *pContext, Thread *pThread) {
    if (pThread->ThrewControlForThread() == Thread::InducedStackOverflow)
    {
        *pContext = *pThread->GetSavedRedirectContext();
    }
}


// We want to leave true null reference exceptions alone.  But if we are
// trashing memory, we don't want the application to swallow it.  The 0x100
// below will give us false positives for debugging, if the app is accessing
// a field more than 256 bytes down an object, where the reference is null.
// 
// Removed use of the IgnoreUnmanagedExceptions reg key...simply return false now.
//
static inline BOOL
CPFH_ShouldIgnoreException(EXCEPTION_RECORD *pExceptionRecord) {
     return FALSE;
}

static inline BOOL
CPFH_IsDebuggerFault(EXCEPTION_RECORD *pExceptionRecord,
                     CONTEXT *pContext,
                     DWORD exceptionCode,
                     Thread *pThread) {
#ifdef DEBUGGING_SUPPORTED
    // Is this exception really meant for the COM+ Debugger? Note: we will let the debugger have a chance if there is a
    // debugger attached to any part of the process. It is incorrect to consider whether or not the debugger is attached
    // the the thread's current app domain at this point.

    // Even if a debugger is not attached, we must let the debugger handle the exception in case 
    // it's coming from a patch-skipper.
    if (exceptionCode != EXCEPTION_COMPLUS &&
       
        g_pDebugInterface->FirstChanceNativeException(pExceptionRecord,
                                                 pContext,
                                                 exceptionCode,
                                                 pThread)) {
        LOG((LF_EH | LF_CORDB, LL_INFO1000, "CPFH_IsDebuggerFault - it's the debugger's fault\n"));
        return true;
    }
#endif // DEBUGGING_SUPPORTED
    return false;
}

static inline void
CPFH_UpdatePerformanceCounters() {
    COUNTER_ONLY(GetPrivatePerfCounters().m_Excep.cThrown++);
    COUNTER_ONLY(GetGlobalPerfCounters().m_Excep.cThrown++);
}

// allocate stack trace info. As each function is found in the stack crawl, it will be added
// to this list. If the list is too small, it is reallocated.
static inline void 
CPFH_AllocateStackTrace(ExInfo* pExInfo) {
    if (! pExInfo->m_pStackTrace) {
#ifdef _DEBUG
        pExInfo->m_cStackTrace = 2;    // make small to exercise realloc
#else
        pExInfo->m_cStackTrace = 30;
#endif
        pExInfo->m_pStackTrace = new (throws) SystemNative::StackTraceElement[pExInfo->m_cStackTrace];
    }
}


// Create a COM+ exception , stick it in the thread.
static inline OBJECTREF
CPFH_CreateCOMPlusExceptionObject(Thread *pThread, DWORD exceptionCode, BOOL bAsynchronousThreadStop) {

    OBJECTREF result;
    // Can we map this to a recognisable COM+ exception?
    DWORD COMPlusExceptionCode = (bAsynchronousThreadStop
                                 ? (pThread->IsAbortRequested() ? kThreadAbortException : kThreadStopException)
                                 : MapWin32FaultToCOMPlusException(exceptionCode));

    if (exceptionCode == STATUS_NO_MEMORY) {
        result = ObjectFromHandle(g_pPreallocatedOutOfMemoryException);
    } else if (exceptionCode == STATUS_STACK_OVERFLOW) {
        result = ObjectFromHandle(g_pPreallocatedStackOverflowException);
    } else {
        OBJECTREF pThrowable = NULL;

        GCPROTECT_BEGIN(pThrowable);
        CreateExceptionObject((RuntimeExceptionKind)COMPlusExceptionCode, &pThrowable);
        CallDefaultConstructor(pThrowable);
        result = pThrowable;
        GCPROTECT_END(); //Prot
    }
    return result;
}

static inline EXCEPTION_DISPOSITION __cdecl 
CPFH_RealFirstPassHandler(EXCEPTION_RECORD *pExceptionRecord, 
                          EXCEPTION_REGISTRATION_RECORD *pEstablisherFrame,
                          CONTEXT *pContext,
                          void *pDispatcherContext,
                          BOOL bAsynchronousThreadStop) 
{
#ifdef _DEBUG
    static int breakOnFirstPass = g_pConfig->GetConfigDWORD(L"BreakOnFirstPass", 0);
    if (breakOnFirstPass != 0)
        _ASSERTE(!"First pass exception handler");
    LOG((LF_EH, LL_INFO10, "CPFH_RealFirstPassHandler at EIP:0x%x\n", pContext->Eip));

#endif

    EXCEPTION_DISPOSITION retval;

    DWORD exceptionCode = pExceptionRecord->ExceptionCode;
    Thread *pThread = GetThread();

    static int breakOnAV = g_pConfig->GetConfigDWORD(L"BreakOnAV", 0);
    if (breakOnAV != 0 && exceptionCode == STATUS_ACCESS_VIOLATION)
#ifdef _DEBUG
        _ASSERTE(!"AV occured");
#else
        if (g_pConfig->GetConfigDWORD(L"EHGolden", 0))
            DebugBreak();
#endif

    // We always want to be in co-operative mode when we run this function and whenever we return
    // from it, want to go to pre-emptive mode because are returning to OS. 
    _ASSERTE(pThread->PreemptiveGCDisabled());

    BOOL bPopFaultingExceptionFrame = FALSE;
    BOOL bPopNestedHandlerExRecord = FALSE;
    LFH found;
    BOOL bRethrownException = FALSE;
    BOOL bNestedException = FALSE;
    OBJECTREF throwable = NULL;

    FaultingExceptionFrame faultingExceptionFrame;
    ExInfo *pExInfo = pThread->GetHandlerInfo();

    ThrowCallbackType tct;
    tct.pTopFrame = GetCurrFrame(pEstablisherFrame); // highest frame to search to
    
    if (bAsynchronousThreadStop)
        tct.bLastChance = FALSE;
#ifdef _DEBUG
    tct.pCurrentExceptionRecord = pEstablisherFrame;
    tct.pPrevExceptionRecord = GetPrevSEHRecord(pEstablisherFrame);
#endif

    ICodeManager *pMgr = ExecutionManager::FindCodeMan((SLOT)GetIP(pContext));
    
    // this establishes a marker so can determine if are processing a nested exception
    // don't want to use the current frame to limit search as it could have been unwound by
    // the time get to nested handler (ie if find an exception, unwind to the call point and
    // then resume in the catch and then get another exception) so make the nested handler
    // have the same boundary as this one. If nested handler can't find a handler, we won't 
    // end up searching this frame list twice because the nested handler will set the search 
    // boundary in the thread and so if get back to this handler it will have a range that starts
    // and ends at the same place.

    NestedHandlerExRecord nestedHandlerExRecord;
    nestedHandlerExRecord.Init(0, COMPlusNestedExceptionHandler, GetCurrFrame(pEstablisherFrame));

    InsertCOMPlusFrameHandler(&nestedHandlerExRecord);
    bPopNestedHandlerExRecord = TRUE;

    if (   pMgr 
        && (   pThread->m_pFrame == FRAME_TOP 
            || pThread->m_pFrame->GetVTablePtr() != FaultingExceptionFrame::GetMethodFrameVPtr()
            || (size_t)pThread->m_pFrame > (size_t)pEstablisherFrame
           )
       ) {
        // setup interrupted frame so that GC during calls to init won't collect the frames
        // only need it for non COM+ exceptions in managed code when haven't already
        // got one on the stack (will have one already if we have called rtlunwind because
        // the instantiation that called unwind would have installed one)
        faultingExceptionFrame.InitAndLink(pContext);
        bPopFaultingExceptionFrame = TRUE;
    }

    OBJECTREF e = pThread->LastThrownObject();
    STRESS_LOG3(LF_EH, LL_INFO100, "COMPlusFrameHandler: ExceptionCode = %x last thrown object = %p MT = %pT\n", 
        exceptionCode, OBJECTREFToObject(e), (e!=0)?e->GetMethodTable():0);

#ifdef LOGGING
    const char * eClsName = "!EXCEPTION_COMPLUS";
    if (exceptionCode == EXCEPTION_COMPLUS) {
        if (e != 0)
            eClsName = e->GetTrueMethodTable()->m_pEEClass->m_szDebugClassName;
    }
    LOG((LF_EH, LL_INFO100, "COMPlusFrameHandler: exception 0x%08x class %s at 0x%08x\n", exceptionCode, eClsName, pContext->Eip));
#endif

    EXCEPTION_POINTERS exceptionPointers = {pExceptionRecord, pContext};
    LOG((LF_EH, LL_INFO100, "COMPlusFrameHandler: setting boundaries m_pBottomMostHandler: 0x%08x\n", pExInfo->m_pBottomMostHandler));

    // here we are trying to decide if we are coming in as 1) first handler in a brand new exception or 
    // 2) a subsequent handler in an exception or 3) a nested exception.
    // m_pBottomMostHandler is the registration structure (establisher frame) for the very last (ie lowest in 
    // memory) non-nested handler that was installed  and pEstablisher frame is what the current handler 
    // was registered with. 
    // The OS calls each registered handler in the chain, passing its establisher frame to it.
    if (pExInfo->m_pBottomMostHandler != NULL && pEstablisherFrame > pExInfo->m_pBottomMostHandler) {
        // If the establisher frame of this handler is greater than the bottommost then it must have been
        // installed earlier and therefore we are case 2
        if (pThread->GetThrowable() == NULL) {
          // Bottommost didn't setup a throwable, so not exception not for us
            retval = ExceptionContinueSearch;
            goto exit;
        }        
        // setup search start point
        tct.pBottomFrame = pExInfo->m_pSearchBoundary;
        if (tct.pTopFrame == tct.pBottomFrame) {
            // this will happen if our nested handler already searched for us so we don't want
            // to search again
            retval = ExceptionContinueSearch;
            goto exit;
        }        
    } 
    // we are either case 1 or case 3
    else {
        // it's possible that the exception could be resumed and regenerate the same exception (either
        // through actual EXCEPTION_CONTINUE_EXECUTION or through letting debugger reexecute it)
        // in which case we'd not unwind but we'd come back through here and it would look like 
        // a rethrown exception, but it's really not.
        if (IsRethrownException(pExInfo, pContext) && pThread->LastThrownObject() != NULL) {
            pExInfo->ResetIsRethrown();
            bRethrownException = TRUE;
            if (bPopFaultingExceptionFrame) {
                // if we added a FEF, it will refer to the frame at the point of the original exception which is 
                // already unwound so don't want it.
                // If we rethrew the exception we have already added a helper frame for the rethrow, so don't 
                // need this one. If we didn't rethrow it, (ie rethrow from native) then there the topmost frame will
                // be a transition to native frame in which case we don't need it either
                faultingExceptionFrame.Pop();
                bPopFaultingExceptionFrame = FALSE;
            }
        }

        // if the establisher frame is less than the bottommost handler, then this is nested because the
        // establisher frame was installed after the bottommost
        if (pEstablisherFrame < pExInfo->m_pBottomMostHandler
            /* || IsComPlusNestedExceptionRecord(pEstablisherFrame) */ ) {
            bNestedException = TRUE;
            // case 3: this is a nested exception. Need to save and restore the thread info
            LOG((LF_EH, LL_INFO100, "COMPlusFrameHandler: detected nested exception 0x%08x < 0x%08x\n", pEstablisherFrame, pExInfo->m_pBottomMostHandler));


            EXCEPTION_REGISTRATION_RECORD* pNestedER = TryFindNestedEstablisherFrame(pEstablisherFrame);
            ExInfo *pNestedExInfo;

            if (!pNestedER || pNestedER >= pExInfo->m_pBottomMostHandler ) {
                // RARE CASE.  We've re-entered the EE from an unmanaged filter.
                void *limit = (void *) GetPrevSEHRecord(pExInfo->m_pBottomMostHandler);

                pNestedExInfo = new ExInfo();     // Very rare failure here; need robust allocator.
                pNestedExInfo->m_StackAddress = limit;
            } else {
                pNestedExInfo = &((NestedHandlerExRecord*)pNestedER)->m_handlerInfo;
            }

            _ASSERTE(pNestedExInfo);
            pNestedExInfo->m_pThrowable = NULL;
            *pNestedExInfo = *pExInfo; // does deep copy of handle, so don't lose it
            pExInfo->Init();           // clear out any fields 
            pExInfo->m_pPrevNestedInfo = pNestedExInfo;     // save at head of nested info chain
        }

        // case 1&3: this is the first time through of a new, nested, or rethrown exception, so see if we can find a handler. 
        // Only setup throwable if are bottommost handler
        if ((exceptionCode == EXCEPTION_COMPLUS) && (!bAsynchronousThreadStop)) {
            LPVOID pIP;

            // Verify by checking the ip of the raised exception that
            // it really came from the EE.
            pIP = GetIP(pContext);

            if ( pIP != gpRaiseExceptionIP ) {
                retval = ExceptionContinueSearch;
                goto exit;
            }

            OBJECTREF throwable = pThread->LastThrownObject();
            pThread->SetThrowable(throwable);

            if (IsExceptionOfType(kThreadStopException, &throwable))
                tct.bLastChance = FALSE;
            // now we've got a COM+ exception, fall through to so see if we handle it

            pExInfo->m_pBottomMostHandler = pEstablisherFrame;

        } else if (bRethrownException) {
            // if it was rethrown and not COM+, will still be the last one thrown. Either we threw it last
            // and stashed it here or someone else caught it and rethrew it, in which case it will still
            // have been originally stashed here.
            pThread->SetThrowable(pThread->LastThrownObject());

            pExInfo->m_pBottomMostHandler = pEstablisherFrame;
        } else {

            if (pMgr == NULL) {
                tct.bDontCatch = false;
            }

            if (exceptionCode == STATUS_BREAKPOINT) {
                // don't catch int 3
                retval = ExceptionContinueSearch;
                goto exit;
            }

            // We need to set m_pBottomMostHandler here, Thread::IsExceptionInProgress returns 1.
            // This is a necessary part of suppressing thread abort exceptions in the constructor
            // of any exception object we might create.
            pExInfo->m_pBottomMostHandler = pEstablisherFrame;

            OBJECTREF throwable = CPFH_CreateCOMPlusExceptionObject(
                    pThread, 
                    exceptionCode, 
                    bAsynchronousThreadStop);
            pThread->SetThrowable(throwable);

            // save it as current for rethrow
            pThread->SetLastThrownObject(throwable);

            // set the exception code
            EEClass *pClass = throwable->GetTrueClass();
            FieldDesc *pFD = g_Mscorlib.GetField(FIELD__EXCEPTION__XCODE);
            pFD->SetValue32(throwable, pExceptionRecord->ExceptionCode);

            // set the exception pointers
            pFD = g_Mscorlib.GetField(FIELD__EXCEPTION__XPTRS);
            pFD->SetValuePtr(throwable, (void*)&exceptionPointers);

        }

        LOG((LF_EH, LL_INFO100, "COMPlusFrameHandler: m_pBottomMostHandler is now 0x%08x\n", pExInfo->m_pBottomMostHandler));
        pExInfo->m_pExceptionRecord = pExceptionRecord;
        pExInfo->m_pContext = pContext;
        tct.pBottomFrame = pThread->GetFrame();

#ifdef DEBUGGING_SUPPORTED
        // If a debugger is attached, go ahead and notify it of this
        // exception.
        if (CORDebuggerAttached())
            g_pDebugInterface->FirstChanceManagedException(FALSE, pContext);
#endif // DEBUGGING_SUPPORTED

        Profiler::ExceptionThrown(pThread);
        CPFH_UpdatePerformanceCounters();
    }
    
    // Allocate storage for the stack trace.
    throwable = pThread->GetThrowable();
    if (throwable == ObjectFromHandle(g_pPreallocatedOutOfMemoryException) ||
        throwable == ObjectFromHandle(g_pPreallocatedStackOverflowException)) {
        tct.bAllowAllocMem = FALSE;
    } else {
        CPFH_AllocateStackTrace(pExInfo);
    }

    // Set up information for GetExceptionPointers()/GetExceptionCode() callback.
    pExInfo->m_pExceptionPointers = &exceptionPointers;
    pExInfo->m_ExceptionCode = exceptionCode;

    LOG((LF_EH, LL_INFO100, "In COMPlusFrameHandler looking for handler bottom %x, top %x\n", tct.pBottomFrame, tct.pTopFrame));

    found = LookForHandler(&exceptionPointers, pThread, &tct);

    // if this is a nested exception and it was rethrown, then we rethrew it, so need to skip one of the functions
    // in the stack trace otherwise catch and rethrow point will show up twice.
    SaveStackTraceInfo(&tct, pExInfo, pThread->GetThrowableAsHandle(), 
                       pExInfo->m_pBottomMostHandler == pEstablisherFrame && !bRethrownException, 
                       bRethrownException && bNestedException);


    // LookForHandler, above, handled the user exception
    // (actually, LFH alerted the right side & then trapped itself,
    // the debugger helper thread actually handled it, by calling
    // ClearThreadException at the user's request
    if (found == LFH_CONTINUE_EXECUTION)
    {
        retval = ExceptionContinueExecution;
        LOG((LF_EH, LL_INFO100, "COMPlusFrameHandler: CONTINUE_EXECUTION\n"));
        goto exit;
    }

    // We have searched this far.
    pExInfo->m_pSearchBoundary = tct.pTopFrame;

    if (found == LFH_NOT_FOUND) {

        LOG((LF_EH, LL_INFO100, "COMPlusFrameHandler: NOT_FOUND\n"));
        if (tct.pTopFrame == FRAME_TOP) {
            LOG((LF_EH, LL_INFO100, "COMPlusFrameHandler: NOT_FOUND at FRAME_TOP\n"));
        }
        retval = ExceptionContinueSearch;
        goto exit;
    }
    
    // so we are going to handle the exception

    // Remove the nested exception record -- before calling RtlUnwind.
    // The second-pass callback for a NestedExceptionRecord assumes that if it's
    // being unwound, it should pop one exception from the pExInfo chain.  This is
    // true for any older NestedRecords that might be unwound -- but not for the
    // new one we're about to add.  To avoid this, we remove the new record 
    // before calling Unwind.
    //
    // @NICE: This can probably be a little cleaner -- the nested record currently
    // is also used to guard the running of the filter code.  When we clean up the
    // behaviour of exceptions within filters, we should be able to get rid of this 
    // PUSH/POP/PUSH behaviour.
    _ASSERTE(bPopNestedHandlerExRecord);
    RemoveCOMPlusFrameHandler(&nestedHandlerExRecord);

    LOG((LF_EH, LL_INFO100, "COMPlusFrameHandler: handler found: %s\n", tct.pFunc->m_pszDebugMethodName));
    pThread->EnablePreemptiveGC();
    CallRtlUnwind((EXCEPTION_REGISTRATION_RECORD *)pEstablisherFrame, RtlUnwindCallback, 0, 0);
    // on x86 at least, RtlUnwind always returns

    // ... and now, put the nested record back on.
    _ASSERTE(bPopNestedHandlerExRecord);
    InsertCOMPlusFrameHandler(&nestedHandlerExRecord);

    pThread->DisablePreemptiveGC();
    tct.bIsUnwind = TRUE;
    tct.pProfilerNotify = NULL;

    // save catch handler of  catch so can unwind our nested handler info to the right spot if necessary
    pExInfo->m_pCatchHandler = pEstablisherFrame;

    LOG((LF_EH, LL_INFO100, "COMPlusFrameHandler: unwinding\n"));

    tct.bUnwindStack = CPFH_ShouldUnwindStack(exceptionCode);

    UnwindFrames(pThread, &tct);
    _ASSERTE(!"Should not get here");
    retval = ExceptionContinueSearch;
    goto exit;

exit:
    Profiler::ExceptionOSHandlerLeave(pThread, &tct);

    // If we got as far as saving pExInfo, save the context pointer so it's available for the unwind.
    if (pExInfo)
        pExInfo->m_pContext = pContext;
    if (bPopFaultingExceptionFrame)
        faultingExceptionFrame.Pop();
    if (bPopNestedHandlerExRecord)
        RemoveCOMPlusFrameHandler(&nestedHandlerExRecord);

    // we are not catching this exception in managed code.
    // IF: (a) this is the only exception we have (i.e. no other pending exceptions)
    //     (b) we have initiated an abort
    //     (c) we are going to continue searching 
    // THEN: it is possible that the next handler up the chain is an unmanaged one that
    //       swallows the Abort
    // To protect against that Set the AbortInitiated to FALSE and Set the stop bit so
    // the abort is re-initiated the next time the thread wanders into managed code
    if ((retval == ExceptionContinueSearch) &&
            pThread->IsAbortInitiated() &&
            pExInfo && pExInfo->m_pPrevNestedInfo == NULL
        )
    {
        pThread->ResetAbortInitiated();
        _ASSERTE(!pExInfo->IsInUnmanagedHandler());
        pExInfo->SetIsInUnmanagedHandler();
    }


    return retval;
}


struct SavedExceptionInfo {
    EXCEPTION_RECORD m_ExceptionRecord;
    CONTEXT m_ExceptionContext;
    Crst *m_pCrst;       

    void SaveExceptionRecord(EXCEPTION_RECORD *pExceptionRecord) {
        size_t erSize = (char*)&pExceptionRecord->ExceptionInformation[pExceptionRecord->NumberParameters]                  - (char*)&pExceptionRecord;
        memcpy(&m_ExceptionRecord, pExceptionRecord, erSize);

    }

    void SaveContext(CONTEXT *pContext) {
        size_t contextSize = offsetof(CONTEXT, ExtendedRegisters);
        if ((pContext->ContextFlags & CONTEXT_EXTENDED_REGISTERS) == CONTEXT_EXTENDED_REGISTERS)
            contextSize += sizeof(pContext->ExtendedRegisters);
        memcpy(&m_ExceptionContext, pContext, contextSize);
    }

    void Enter() {
        _ASSERTE(m_pCrst);
        m_pCrst->Enter();
    }

    void Leave() {
        m_pCrst->Leave();
    }

    void Init() {
        m_pCrst = ::new Crst("exception lock", CrstDummy);
    }

#ifdef SHOULD_WE_CLEANUP
    void Terminate() {
        if (m_pCrst)
            ::delete m_pCrst;
    }
#endif /* SHOULD_WE_CLEANUP */

};

SavedExceptionInfo g_SavedExceptionInfo;  // Globals are guaranteed zero-init;

BOOL InitializeExceptionHandling() {
    g_SavedExceptionInfo.Init();
    return TRUE;
}

#ifdef SHOULD_WE_CLEANUP
VOID TerminateExceptionHandling() {
    g_SavedExceptionInfo.Terminate();
}
#endif /* SHOULD_WE_CLEANUP */

static 
VOID FixContext(EXCEPTION_POINTERS *pExceptionPointers)
{
    // don't copy parm args as have already supplied them on the throw
    memcpy((void *)pExceptionPointers->ExceptionRecord,
           (void *)&g_SavedExceptionInfo.m_ExceptionRecord, 
           offsetof(EXCEPTION_RECORD, ExceptionInformation)
          );

    DWORD len;
#ifdef CONTEXT_EXTENDED_REGISTERS
    len = offsetof(CONTEXT, ExtendedRegisters);
    if (   (pExceptionPointers->ContextRecord->ContextFlags & CONTEXT_EXTENDED_REGISTERS) == CONTEXT_EXTENDED_REGISTERS
        && (g_SavedExceptionInfo.m_ExceptionContext.ContextFlags &  CONTEXT_EXTENDED_REGISTERS) == CONTEXT_EXTENDED_REGISTERS) {
        len += sizeof(g_SavedExceptionInfo.m_ExceptionContext.ExtendedRegisters);
    }
#else // !CONTEXT_EXTENDED_REGISTERS
    len = sizeof(CONTEXT);
#endif // !CONTEXT_EXTENDED_REGISTERS
    memcpy(pExceptionPointers->ContextRecord, &g_SavedExceptionInfo.m_ExceptionContext, len);
    g_SavedExceptionInfo.Leave();

    GetThread()->ResetThreadStateNC(Thread::TSNC_DebuggerIsManagedException);
}

VOID __fastcall
LinkFrameAndThrow(FaultingExceptionFrame* pFrame) {

    // It's possible for our filter to be called more than once if some other first-pass
    // handler lets an exception out.  We need to make sure we only fix the context for
    // the first exception we see.  Filter_count takes care of that.
    int filter_count = 0;

    *(void**)pFrame = FaultingExceptionFrame::GetMethodFrameVPtr();
    pFrame->Push();

    ULONG argcount = g_SavedExceptionInfo.m_ExceptionRecord.NumberParameters;
    ULONG flags = g_SavedExceptionInfo.m_ExceptionRecord.ExceptionFlags;
    ULONG code = g_SavedExceptionInfo.m_ExceptionRecord.ExceptionCode;
    ULONG_PTR *args = &g_SavedExceptionInfo.m_ExceptionRecord.ExceptionInformation[0];

    GetThread()->SetThreadStateNC(Thread::TSNC_DebuggerIsManagedException);

    __try {
        RaiseException(code, flags, argcount, args);
    } __except ((
                (++filter_count == 1 
                    ? FixContext(GetExceptionInformation())
                    : 0), 
                EXCEPTION_CONTINUE_SEARCH)) {
    }
}

// This is a helper that we use to raise the correct managed exception with
// the necessary frame (after taking a fault in jitted code).
//
// Inputs:
//      all registers still have the value
//      they had at the time of the fault, except
//              EIP points to this function
//              ECX contains the original EIP
//
// What it does:
//      The exception to be thrown is stored in m_pLastThrownObjectHandle.
//      We push a FaultingExcepitonFrame on the stack, and then we call
//      complus throw.
//
__declspec(naked)
VOID NakedThrowHelper(VOID) {
    // Erect a faulting Method Frame.  Layout is as follows ...
    __asm {
        mov edx, esp
        push ebp                // ebp
        push ebx                // ebx
        push esi                // esi
        push edi                // edi
        push edx                // original esp
        push ecx                // m_ReturnAddress (i.e. original IP)
        sub  esp,12             // m_Datum (trash)
                                // Next (filled in by LinkFrameAndThrow)
                                // FaultingExceptionFrame VFP (ditto)

        mov ecx, esp
        call LinkFrameAndThrow
    }
}



CPFH_HandleManagedFault(EXCEPTION_RECORD *pExceptionRecord,
                        EXCEPTION_REGISTRATION_RECORD *pEstablisherFrame,
                        CONTEXT *pContext,
                        DWORD exceptionCode,
                        Thread *pThread,
                        BOOL bAsynchronousThreadStop) {

    // If we get a faulting instruction inside managed code, we're going to
    //  1. Allocate the correct exception object, store it in the thread.
    //  2. Save the EIP in the thread.
    //  3. Change the EIP to our throw helper
    //  4. Resume execution.
    //
    //  The helper will push a frame for us, and then throw the correct managed exception.
    // 
    // Is this exception really meant for the COM+ Debugger? Note: we will let the debugger have a chance if there is a
    // debugger attached to any part of the process. It is incorrect to consider whether or not the debugger is attached
    // the the thread's current app domain at this point.


    // A managed exception never comes from managed code, and we can ignore all breakpoint
    // exceptions.
    if (   exceptionCode == EXCEPTION_COMPLUS
        || exceptionCode == STATUS_BREAKPOINT
        || exceptionCode == STATUS_SINGLE_STEP)
        return FALSE;

    // If there's any frame below the ESP of the exception, then we can forget it.
    if (pThread->m_pFrame < GetSP(pContext))
        return FALSE;

    // If we're a subsequent handler forget it.
    ExInfo* pExInfo = pThread->GetHandlerInfo();
    if (pExInfo->m_pBottomMostHandler != NULL && pEstablisherFrame > pExInfo->m_pBottomMostHandler)
        return FALSE;

    // If it's not a fault in jitted code, forget it.
    ICodeManager *pMgr = ExecutionManager::FindCodeMan((SLOT)GetIP(pContext));
    if (!pMgr) 
        return FALSE;

    // Ok.  Now we have a brand new fault in jitted code.
    g_SavedExceptionInfo.Enter();
    g_SavedExceptionInfo.SaveExceptionRecord(pExceptionRecord);
    g_SavedExceptionInfo.SaveContext(pContext);

    // Lock will be released by the throw helper.

    pContext->Ecx = (DWORD)(size_t)GetIP(pContext);            // ECX gets original IP.
    SetIP(pContext, (void*)(size_t)&NakedThrowHelper);

    return TRUE;        // caller should resume execution.
}


static inline EXCEPTION_DISPOSITION __cdecl 
CPFH_FirstPassHandler(EXCEPTION_RECORD *pExceptionRecord, 
                      EXCEPTION_REGISTRATION_RECORD *pEstablisherFrame,
                      CONTEXT *pContext,
                      void *pDispatcherContext)
{

    _ASSERTE (!(pExceptionRecord->ExceptionFlags & (EXCEPTION_UNWINDING | EXCEPTION_EXIT_UNWIND)));

    DWORD exceptionCode = pExceptionRecord->ExceptionCode;

    Thread *pThread = GetThread();
    ExInfo* pExInfo = pThread->GetHandlerInfo();
    pExInfo->ResetIsInUnmanagedHandler(); // thread abort logic depends on all managed handlers setting this on entry and resetting it on exit, 


    STRESS_LOG4(LF_EH, LL_INFO100, "In CPFH_FirstPassHandler EH_REG_RECORD = %x EH code = %x  EIP = %x with ESP = %x\n", pEstablisherFrame, exceptionCode, GetIP(pContext), pContext->Esp);


    // This demented piece of code is used to support a special form of
    // atomic updated used by PrestubWorker() on machines that don't
    // support the 8-byte cmpxchg instruction.
    //
    // This alternate method replaces the "call" instruction with a "hlt"
    // for the duration of the update. If another thread tries to execute
    // the same method during this window, it will get here. We will
    // yield our timeslice a few times to give the original thread time
    // to finish updating.
    //
    // If after a few attempts, the faulting IP still contains a "hlt",
    // we will assume this one is unrelated to the prestub and continue
    // processing as a normal exception.

    if (exceptionCode == STATUS_PRIVILEGED_INSTRUCTION)
    {
        BYTE *ip = (BYTE*)(size_t)(pContext->Eip);
        if (*ip == X86_INSTR_HLT)
        {
            int attempts = 10;
            while (attempts != 0 && *ip == X86_INSTR_HLT) {
                __SwitchToThread(0);
                attempts--;
            }
            if (*ip != X86_INSTR_HLT)
            {
                return ExceptionContinueExecution;
            }
        }
    }


    if (CPFH_IsGcMarker(exceptionCode, pContext))
        return(ExceptionContinueExecution);
    
    // We always want to be in co-operative mode when we run this function and whenever we return
    // from it, want to go to pre-emptive mode because are returning to OS. 
    BOOL disabled = pThread->PreemptiveGCDisabled();
    if (!disabled)
        pThread->DisablePreemptiveGC();

    BOOL bAsynchronousThreadStop = FALSE;
    EXCEPTION_DISPOSITION retval;

    CPFH_AdjustContextForThreadSuspensionRace(pContext, pThread);
    
    // Some other parts of the EE use exceptions in their
    // own nefarious ways.  We do some up-front processing
    // here to fix up the exception if needed.
    //
    if (exceptionCode == STATUS_ACCESS_VIOLATION) {

        if (CPFH_IsWellFormedAV(pExceptionRecord)) {

            if (   CPFH_IsGcFault(pExceptionRecord)
                || CPFH_IsMonitorFault(pExceptionRecord, pContext)) {
                retval = ExceptionContinueExecution;
                goto exit;
            }   

            CPFH_AdjustContextForWriteBarrier(pContext);

            BOOL InMscoree = IsIPInModule(g_pMSCorEE, (BYTE*)GetIP(pContext));

#ifndef ZAP_MONITOR
            if (InMscoree) {
                _ASSERTE(!"AV in mscoree");
                // If you're debugging, set the debugger to catch first-chance AV's, set IP to 
                // retval = ExceptionContinueExecution, above, and then continue.
                //
                // You'll stop at the AV.
                if (g_pConfig->GetConfigDWORD(L"EHGolden", 0))
                    DebugBreak();

                FatalInternalError();

                retval = ExceptionContinueSearch;
                goto exit;

            }
#endif
            if (InMscoree || CPFH_ShouldIgnoreException(pExceptionRecord)) {

                CPFH_VerifyThreadIsInValidState(pThread, exceptionCode, pEstablisherFrame);
                retval = ExceptionContinueSearch;
                goto exit;
            }


        }
    } else if (exceptionCode == EXCEPTION_COMPLUS) {
        if (CPFH_AdjustContextForThreadStop(pContext, pThread)) {

            // If we ever get here in preemptive mode, we're in trouble.  We've
            // changed the thread's IP to point at a little function that throws ... if
            // the thread were to be in preemptive mode and a GC occured, the stack
            // crawl would have been all messed up (becuase we have no frame that points
            // us back to the right place in managed code).
            _ASSERTE(disabled);

            // Should never get here if we're already throwing an exception.
            _ASSERTE(!pThread->IsExceptionInProgress());

            // Should never get here if we're already abort initiated.
            _ASSERTE(!pThread->IsAbortInitiated());

                if (pThread->IsAbortRequested())
                {
                    pThread->SetAbortInitiated();    // to prevent duplicate aborts
                }
                LOG((LF_EH, LL_INFO100, "CPFH_FirstPassHandler is Asynchronous Thread Stop or Abort\n"));
                bAsynchronousThreadStop = TRUE;
            }
    } else if (exceptionCode == STATUS_STACK_OVERFLOW) {
        // If this is managed code, we can handle it.  If not, we're going to assume the worst,
        // and take down the process.

        CPFH_AdjustContextForInducedStackOverflow(pContext, pThread);

        ICodeManager *pMgr = ExecutionManager::FindCodeMan((SLOT)GetIP(pContext));
        if (!pMgr) {
            FailFast(pThread, FatalStackOverflow, pExceptionRecord, pContext);
        }
        pThread->SetGuardPageGone();

    } else if (exceptionCode == BOOTUP_EXCEPTION_COMPLUS) {
        // Don't handle a boot exception
        retval = ExceptionContinueSearch;
        goto exit;
    }

    CPFH_VerifyThreadIsInValidState(pThread, exceptionCode, pEstablisherFrame);

    if (CPFH_HandleManagedFault(pExceptionRecord, 
                                pEstablisherFrame,
                                pContext, 
                                exceptionCode, 
                                pThread, 
                                bAsynchronousThreadStop)) {
        retval = ExceptionContinueExecution;
        goto exit;
    }

    if (CPFH_IsDebuggerFault(pExceptionRecord, 
                             pContext, 
                             exceptionCode, 
                             pThread)) {
        retval = ExceptionContinueExecution;
        goto exit;
    }

    // Handle a user breakpoint
    if (   exceptionCode == STATUS_BREAKPOINT
        || exceptionCode == STATUS_SINGLE_STEP) {
        EXCEPTION_POINTERS ep = {pExceptionRecord, pContext};
        if (UserBreakpointFilter(&ep) == EXCEPTION_CONTINUE_EXECUTION) {
            retval = ExceptionContinueExecution;
            goto exit;
        } else {
            TerminateProcess(GetCurrentProcess(), STATUS_BREAKPOINT);
        }
    }


    // OK.  We're finally ready to start the real work.  Nobody else grabbed
    // the exception in front of us.  Now we can get started.

    retval = CPFH_RealFirstPassHandler(pExceptionRecord, 
                                       pEstablisherFrame, 
                                       pContext, 
                                       pDispatcherContext,
                                       bAsynchronousThreadStop);
exit:
    if (retval != ExceptionContinueExecution || !disabled)
        pThread->EnablePreemptiveGC();
    STRESS_LOG1(LF_EH, LL_INFO100, "Leaving CPFH_FirstPassHandler with %d\n", retval);
    return retval;
}

static inline void 
CPFH_UnwindFrames1(Thread* pThread, EXCEPTION_REGISTRATION_RECORD* pEstablisherFrame) 
{
    // Ready to unwind the stack...
    ThrowCallbackType tct;
    tct.bIsUnwind = TRUE;
    tct.pTopFrame = GetCurrFrame(pEstablisherFrame); // highest frame to search to
    tct.pBottomFrame = pThread->GetFrame();  // always use top frame, lower will have been popped
#ifdef _DEBUG
    tct.pCurrentExceptionRecord = pEstablisherFrame;
    tct.pPrevExceptionRecord = GetPrevSEHRecord(pEstablisherFrame);
#endif
    UnwindFrames(pThread, &tct);

    ExInfo* pExInfo = pThread->GetHandlerInfo();
    if (   tct.pTopFrame == pExInfo->m_pSearchBoundary
        && !IsComPlusNestedExceptionRecord(pEstablisherFrame)) {

        // If this is the search boundary, and we're not a nested handler, then
        // this is the last time we'll see this exception.  Time to unwind our
        // exinfo.
        LOG((LF_EH, LL_INFO100, "Exception unwind -- unmanaged catcher detected\n"));
        UnwindExInfo(pExInfo, (VOID*)pEstablisherFrame);

    }

    // Notify the profiler that we are leaving this SEH entry
    Profiler::ExceptionOSHandlerLeave(GetThread(), &tct);
}

static inline EXCEPTION_DISPOSITION __cdecl 
CPFH_UnwindHandler(EXCEPTION_RECORD *pExceptionRecord, 
                   EXCEPTION_REGISTRATION_RECORD *pEstablisherFrame,
                   CONTEXT *pContext,
                   void *pDispatcherContext)
{
    _ASSERTE (pExceptionRecord->ExceptionFlags & (EXCEPTION_UNWINDING | EXCEPTION_EXIT_UNWIND));

    #ifdef _DEBUG
    static int breakOnSecondPass = g_pConfig->GetConfigDWORD(L"BreakOnSecondPass", 0);
    if (breakOnSecondPass != 0)
            _ASSERTE(!"Unwind handler");
    #endif


    DWORD exceptionCode = pExceptionRecord->ExceptionCode;
    Thread *pThread = GetThread();
    
    ExInfo* pExInfo = pThread->GetHandlerInfo();

    BOOL ExInUnmanagedHandler = pExInfo->IsInUnmanagedHandler();
    pExInfo->ResetIsInUnmanagedHandler();

    STRESS_LOG3(LF_EH, LL_INFO100, "In CPFH_UnwindHandler EHCode = %x EIP = %x with ESP = %x\n", exceptionCode, GetIP(pContext), pContext->Esp);

    // We always want to be in co-operative mode when we run this function.  Whenever we return
    // from it, want to go to pre-emptive mode because are returning to OS. 
    BOOL disabled = pThread->PreemptiveGCDisabled();
    if (!disabled)
        pThread->DisablePreemptiveGC();

    CPFH_VerifyThreadIsInValidState(pThread, exceptionCode, pEstablisherFrame);

    // on unwind, the context is for the unwind point, NOT the original
    // exception point, so used the save value from first pass if are unwinding. Don't care 
    // about context from the unwind point.
    if (pExInfo->m_pContext)
        pContext = pExInfo->m_pContext;

    // this establishes a marker so can determine if are processing a nested exception
    // don't want to use the current frame to limit search as it could have been unwound by
    // the time get to nested handler (ie if find an exception, unwind to the call point and
    // then resume in the catch and then get another exception) so make the nested handler
    // have the same boundary as this one. If nested handler can't find a handler, we won't 
    // end up searching this frame list twice because the nested handler will set the search 
    // boundary in the thread and so if get back to this handler it will have a range that starts
    // and ends at the same place.
    NestedHandlerExRecord nestedHandlerExRecord;
    nestedHandlerExRecord.Init(0, COMPlusNestedExceptionHandler, GetCurrFrame(pEstablisherFrame));
    InsertCOMPlusFrameHandler(&nestedHandlerExRecord);

    // Unwind the stack.  The establisher frame sets the boundary.
    CPFH_UnwindFrames1(pThread, pEstablisherFrame);

    // We're unwinding -- the bottom most handler is potentially off top-of-stack now.  If
    // it is, change it to the next COM+ frame.  (This one is not good, as it's about to
    // disappear.)
    if (   pExInfo->m_pBottomMostHandler 
        && pExInfo->m_pBottomMostHandler <= pEstablisherFrame) {
        pExInfo->m_pBottomMostHandler = (EXCEPTION_REGISTRATION_RECORD*)
                                                        GetNextCOMPlusSEHRecord(pEstablisherFrame);
        LOG((LF_EH, LL_INFO100, "COMPlusUnwindHandler: setting m_pBottomMostHandler to 0x%08x\n", pExInfo->m_pBottomMostHandler));
    }


    pThread->EnablePreemptiveGC();
    RemoveCOMPlusFrameHandler(&nestedHandlerExRecord);

    if (ExInUnmanagedHandler) {
        pExInfo->SetIsInUnmanagedHandler();  // restore the original value if we changed it
    }

    if (   pThread->IsAbortRequested()
        && GetNextCOMPlusSEHRecord(pEstablisherFrame) == (LPVOID) -1) {

        // Topmost handler and abort requested.
        pThread->UserResetAbort();
        LOG((LF_EH, LL_INFO100, "COMPlusUnwindHandler: topmost handler resets abort.\n"));
    }

    STRESS_LOG0(LF_EH, LL_INFO100, "Leaving COMPlusUnwindHandler with ExceptionContinueSearch\n");
    return ExceptionContinueSearch;
}

//-------------------------------------------------------------------------
// This is the first handler that is called iin the context of a
// COMPLUS_TRY. It is the first level of defense and tries to find a handler
// in the user code to handle the exception
//-------------------------------------------------------------------------
EXCEPTION_DISPOSITION __cdecl COMPlusFrameHandler(EXCEPTION_RECORD *pExceptionRecord, 
                         EXCEPTION_REGISTRATION_RECORD *pEstablisherFrame,
                         CONTEXT *pContext,
                         void *pDispatcherContext)
{
    if (g_fNoExceptions)
        return ExceptionContinueSearch; // No EH during EE shutdown.

    if (pExceptionRecord->ExceptionFlags & (EXCEPTION_UNWINDING | EXCEPTION_EXIT_UNWIND)) {
        return CPFH_UnwindHandler(pExceptionRecord, 
                                  pEstablisherFrame, 
                                  pContext, 
                                  pDispatcherContext);
    } else {
        /* Make no assumptions about the current machine state.
           @PERF: Only needs to be called by the very first handler invoked by SEH */
        ResetCurrentContext();

        return CPFH_FirstPassHandler(pExceptionRecord, 
                                     pEstablisherFrame, 
                                     pContext, 
                                     pDispatcherContext);
    }
}


//-------------------------------------------------------------------------
// This is called by the EE to restore the stack pointer if necessary. 
//-------------------------------------------------------------------------

DWORD COMPlusEndCatch( Thread *pThread, CONTEXT *pCtx, void *pSEH)
{
    LOG((LF_EH, LL_INFO1000, "COMPlusPEndCatch:called with "
        "pThread:0x%x\n",pThread));

    if (NULL == pThread )
    {
        _ASSERTE( pCtx == NULL );
        pThread = GetThread();
    }
    else
    {
        _ASSERTE( pCtx != NULL);
        _ASSERTE( pSEH != NULL);
    }

    // Notify the profiler that the catcher has finished running
    Profiler::ExceptionCatcherLeave(pThread);
        
    LOG((LF_EH, LL_INFO1000, "COMPlusPEndCatch:pThread:0x%x\n",pThread));
        
#ifdef NUKE_XPTRS
    OBJECTREF pExObject = pThread->GetThrowable();
    while (pExObject != NULL) {
        // could create a method for this, but don't want to do any jitting or
        // anything if have an OUTOFMEMORY or STACKOVERFLOW
        EEClass* pClass = pExObject->GetTrueClass();
        _ASSERTE(pClass != NULL);
        FieldDesc   *pFD = FindXptrsField(pClass);
        if(pFD != NULL)
        {
//            pFD->SetValue32(pExObject, 0);
            _ASSERTE( pExObject != NULL );
            void *pv = pFD->GetAddress(pExObject->GetAddress());
            _ASSERTE( pv != NULL);
            *(void**)pv = NULL;
        }

        pFD = FindInnerExceptionField(pClass);
        if(pFD != NULL)
        {
            void *pv = pFD->GetAddress(pExObject->GetAddress());
            pExObject = *(OBJECTREF*)pv;
        }
        else
        {
            pExObject = NULL;
        }
    }
#endif

#ifdef _DEBUG
    gLastResumedExceptionFunc = NULL;
    gLastResumedExceptionHandler = 0;
#endif
    // set the thrown object to null as no longer needed
    pThread->SetThrowable(NULL);        

    ExInfo *pExInfo = pThread->GetHandlerInfo();

    // reset the stashed exception info
    pExInfo->m_pExceptionRecord = NULL;
    pExInfo->m_pContext = NULL;
    pExInfo->m_pExceptionPointers = NULL;

    if  (pExInfo->m_pShadowSP) 
        *pExInfo->m_pShadowSP = 0;  // Reset the shadow SP
   
    // pExInfo->m_dEsp was set in ResumeAtJITEH(). It is the Esp of the
    // handler nesting level which catches the exception.
    DWORD dEsp = pExInfo->m_dEsp;
    
    UnwindExInfo(pExInfo, (VOID*)(size_t)dEsp);


    // this will set the last thrown to be either null if we have handled all the exceptions in 
    // the nested chain or to whatever the current exception is.  
    //
    // In a case when we're nested inside another catch block, the domain in which we're executing 
    // may not be the same as the one the domain of the last thrown object.
    // 
    pThread->SetLastThrownObject(NULL); // Causes the old handle to be freed.
    OBJECTHANDLE *pOH = pThread->GetThrowableAsHandle();
    if (pOH != NULL && *pOH != NULL) {
        pThread->SetLastThrownObjectHandleAndLeak(CreateDuplicateHandle(*pOH));
    }

    // We are going to resume at a handler nesting level whose esp is dEsp.
    // Pop off any SEH records below it. This would be the 
    // COMPlusNestedExceptionHandler we had inserted.
    if (pCtx == NULL)
    {
        PopSEHRecords((LPVOID)(size_t)dEsp);
    }
    else
    {
        _ASSERTE( pSEH != NULL);

        PopSEHRecords((LPVOID)(size_t)dEsp, pCtx, pSEH);
    }

    return dEsp;
}


// Check if there is a pending exception or the thread is already aborting. Returns 0 if yes. 
// Otherwise, sets the thread up for generating an abort and returns address of ThrowControlForThread
LPVOID __fastcall COMPlusCheckForAbort(LPVOID retAddress, DWORD esp, DWORD ebp)
{

    Thread* pThread = GetThread();
    
    if ((!pThread->IsAbortRequested()) ||         // if no abort has been requested
        (pThread->GetThrowable() != NULL) )  // or if there is a pending exception
        return 0;

    // else we must produce an abort
    if ((pThread->GetThrowable() == NULL) &&
        (pThread->IsAbortInitiated()))        
    {
        // Oops, we just swallowed an abort, must restart the process
        pThread->ResetAbortInitiated();   
    }

    // Question: Should we also check for (pThread->m_PreventAsync == 0)

    if(pThread->m_OSContext == NULL) 
        pThread->m_OSContext = new CONTEXT;
        
    if (pThread->m_OSContext == NULL)
    { 
        _ASSERTE(!"Out of memory -- Abort Request delayed");
        return 0;
    }

    pThread->m_OSContext->Eip = (DWORD)(size_t)retAddress;
    pThread->m_OSContext->Esp = esp; 
    pThread->m_OSContext->Ebp = ebp;        // this indicates that when we reach ThrowControlForThread, ebp will already be correct
    pThread->SetThrowControlForThread(Thread::InducedThreadStop);
    return (LPVOID) &ThrowControlForThread;

}

//-------------------------------------------------------------------------
// This is the filter that handles exceptions raised in the context of a
// COMPLUS_TRY. It will be called if the COMPlusFrameHandler can't find a 
// handler in the IL.
//-------------------------------------------------------------------------
LONG COMPlusFilter(const EXCEPTION_POINTERS *pExceptionPointers, DWORD fCatchFlag, void* limit)
{

    EXCEPTION_RECORD *pExceptionRecord = pExceptionPointers->ExceptionRecord;
    DWORD             exceptionCode    = pExceptionRecord->ExceptionCode;
    Thread *pThread = GetThread();


    if (   exceptionCode == STATUS_STACK_OVERFLOW 
        && fCatchFlag != COMPLUS_CATCH_NEVER_CATCH
        && limit < (LPBYTE)(pThread->GetCachedStackLimit()) + 4 * OS_PAGE_SIZE) {
        FailFast(pThread, FatalStackOverflow, pExceptionRecord, pExceptionPointers->ContextRecord);
    }

    if (exceptionCode == STATUS_BREAKPOINT || exceptionCode == STATUS_SINGLE_STEP) 
        return UserBreakpointFilter(const_cast<EXCEPTION_POINTERS*>(pExceptionPointers));

    if (fCatchFlag == COMPLUS_CATCH_NEVER_CATCH)
        return EXCEPTION_CONTINUE_SEARCH;


    LOG((LF_EH, LL_INFO100,
         "COMPlusFilter: exception 0x%08x at 0x%08x\n",
         exceptionCode, pExceptionPointers->ContextRecord->Eip));

    ExInfo* pExInfo = pThread->GetHandlerInfo();
    BOOL ExInUnmanagedHandler = pExInfo->IsInUnmanagedHandler();     // remember the state of this bit
    pExInfo->ResetIsInUnmanagedHandler();                            // reset the bit, to prevent async abort temporarily

    // need to be in co-operative mode because GetThrowable is accessing a managed object
    BOOL toggleGC = !pThread->PreemptiveGCDisabled();
    if (toggleGC)
        pThread->DisablePreemptiveGC();
    // we catch here if 
    // 1) COMPLUS_CATCH_ALWAYS_CATCH is passed
    // 2) COMPlusFrameHandler has already setup an exception object and 
    
    if (   fCatchFlag != COMPLUS_CATCH_ALWAYS_CATCH 
        && pThread->GetThrowable() == NULL)
    {
        if (toggleGC)
            pThread->EnablePreemptiveGC();
        LOG((LF_EH, LL_INFO100, "COMPlusFilter: Ignoring the exception\n"));
        if (ExInUnmanagedHandler)
            pExInfo->SetIsInUnmanagedHandler(); // set it back to the original value if we changed it
        return EXCEPTION_CONTINUE_SEARCH;
    }


    if (toggleGC)
        pThread->EnablePreemptiveGC();

    // We got a COM+ exception.
    LOG((LF_EH, LL_INFO100, "COMPlusFilter: Caught the exception\n"));

    if (ExInUnmanagedHandler)
        pExInfo->SetIsInUnmanagedHandler();     // set it back to the original value if we changed it
    
    // We detect an unmanaged catcher by looking at m_pSearchBoundary -- but this is
    // a special case -- the object is being caught in unmanaged code, but inside
    // a COMPLUS_CATCH.  We allow rethrow -- and will clean up.  Set m_pSearchBoundary
    // to NULL, so that we don't unwind our internal state before the catch.
    pExInfo->m_pSearchBoundary = NULL;

    // Notify the profiler that a native handler has been found.
    Profiler::ExceptionCLRCatcherFound();

    return EXCEPTION_EXECUTE_HANDLER;
}


BOOL ComPlusStubSEH(EXCEPTION_REGISTRATION_RECORD* pEHR)
{
    if (pEHR->Handler == ComToManagedExceptHandler)
        return TRUE;
    return FALSE;
}

BOOL IsContextTransitionFrameHandler(EXCEPTION_REGISTRATION_RECORD* pEHR)
{
    if (pEHR->Handler == ContextTransitionFrameHandler)
        return TRUE;
    return FALSE;
}


#pragma warning (disable : 4035)
LPVOID GetCurrentSEHRecord()
{
#ifndef _DEBUG
    __asm {
        mov eax, fs:[0]
    }
#else
    LPVOID fs0;
    __asm {
        mov eax, fs:[0]
        mov fs0, eax
    }
    EXCEPTION_REGISTRATION_RECORD *pEHR = (EXCEPTION_REGISTRATION_RECORD *)fs0;
    LPVOID spVal;
    __asm {
        mov spVal, esp
    }
    // check that all the eh frames are all greater than the current stack value. If not, the
    // stack has been updated somehow w/o unwinding the SEH chain.

    // LOG((LF_EH, LL_INFO1000000, "ER Chain:\n"));
    while (pEHR != NULL && pEHR != (void *)-1) {
        // LOG((LF_EH, LL_INFO1000000, "\t%08x: prev:%08x handler:%x\n", pEHR, pEHR->Next, pEHR->Handler));
        if (pEHR < spVal) {
            if (gLastResumedExceptionFunc != 0)
                _ASSERTE(!"Stack is greater than start of SEH chain - possible missing leave in handler. See gLastResumedExceptionHandler & gLastResumedExceptionFunc for info");
            else
                _ASSERTE(!"Stack is greater than start of SEH chain (FS:0)");
        }
        if (pEHR->Handler == (void *)-1)
            _ASSERTE(!"Handler value has been corrupted");

#ifdef _DEBUG
        // On Win95, when a debugger is present, this next assert fails.  Work around by
        // relaxing it on Win95.  Assuming everything else is correct ... this Win9X 
        // strangeness does not cause any additional problems.
        if(!RunningOnWin95())
            _ASSERTE(pEHR < pEHR->Next);
#endif

        pEHR = pEHR->Next;
    }
    return (EXCEPTION_REGISTRATION_RECORD*) fs0;
#endif
}
#pragma warning (default : 4035)

LPVOID GetFirstCOMPlusSEHRecord(Thread *pThread) {
    EXCEPTION_REGISTRATION_RECORD *pEHR = pThread->GetTEB()->ExceptionList;
    if (pEHR == (EXCEPTION_REGISTRATION_RECORD*) -1 || IsOneOfOurSEHHandlers(pEHR)) {
        return pEHR; 
    } else {
        return GetNextCOMPlusSEHRecord(pEHR);
    }
}
    

LPVOID GetPrevSEHRecord(EXCEPTION_REGISTRATION_RECORD *next) 
{
    _ASSERTE(IsOneOfOurSEHHandlers(next));

    EXCEPTION_REGISTRATION_RECORD *pEHR = (EXCEPTION_REGISTRATION_RECORD*)GetCurrentSEHRecord();
    _ASSERTE(pEHR != 0 && pEHR != (EXCEPTION_REGISTRATION_RECORD*)-1);

    EXCEPTION_REGISTRATION_RECORD *pBest = 0;
    while (pEHR != next) {
        if (IsOneOfOurSEHHandlers(pEHR))
            pBest = pEHR;
        pEHR = pEHR->Next;
        _ASSERTE(pEHR != 0 && pEHR != (EXCEPTION_REGISTRATION_RECORD*)-1);
    }
        
    return pBest;
}


VOID SetCurrentSEHRecord(LPVOID pSEH)
{
    __asm{
        mov eax, pSEH
        mov dword ptr fs:[0], eax
     }
}


//==========================================================================
// COMPlusThrowCallback
// 
//==========================================================================

StackWalkAction COMPlusThrowCallback (CrawlFrame *pCf, ThrowCallbackType *pData)
{
    
    THROWSCOMPLUSEXCEPTION();

    Frame *pFrame = pCf->GetFrame();
    MethodDesc *pFunc = pCf->GetFunction();

    STRESS_LOG3(LF_EH, LL_INFO100, "COMPlusUnwindCallback method = %pM Frame = %p Frame, FrameVtable = %pV\n", 
        pFunc, pFrame, pCf->IsFrameless()?0:(*(void**)pFrame));

    if (pFrame && pData->pTopFrame == pFrame)
        /* Don't look past limiting frame if there is one */
        return SWA_ABORT;

    if (!pFunc)
        return SWA_CONTINUE;

    LOG((LF_EH, LL_INFO100, "COMPlusThrowCallback for %s\n", pFunc->m_pszDebugMethodName));

    Thread *pThread = GetThread();

    ExInfo *pExInfo = pThread->GetHandlerInfo();

    _ASSERTE(!pData->bIsUnwind);
#ifdef _DEBUG
    // It SHOULD be the case that any frames we consider live between this exception
    // record and the previous one.
    if (!pExInfo->m_pPrevNestedInfo) {
        if (pData->pCurrentExceptionRecord) {
            if (pFrame) _ASSERTE(pData->pCurrentExceptionRecord > pFrame);
            if (pCf->IsFrameless()) _ASSERTE((DWORD)(size_t)(pData->pCurrentExceptionRecord) >= pCf->GetRegisterSet()->Esp);
        }
        if (pData->pPrevExceptionRecord) {
            // FCALLS have an extra SEH record in debug because of the desctructor 
            // associated with ForbidGC checking.  This is benign, so just ignore it.  
            if (pFrame) _ASSERTE(pData->pPrevExceptionRecord < pFrame || pFrame->GetVTablePtr() == HelperMethodFrame::GetMethodFrameVPtr());
            if (pCf->IsFrameless()) _ASSERTE((DWORD)(size_t)pData->pPrevExceptionRecord <= pCf->GetRegisterSet()->Esp);
        }
    }
#endif
    

    // save this function in the stack trace array, only build on first pass
    if (pData->bAllowAllocMem && pExInfo->m_dFrameCount >= pExInfo->m_cStackTrace) {
        void *tmp = new (throws) SystemNative::StackTraceElement[pExInfo->m_cStackTrace*2];
        memcpy(tmp, pExInfo->m_pStackTrace, pExInfo->m_cStackTrace * sizeof(SystemNative::StackTraceElement));
        delete [] pExInfo->m_pStackTrace;
        pExInfo->m_pStackTrace = tmp;
        pExInfo->m_cStackTrace *= 2;
    }
    // even if couldn't allocate memory, might still have some space here
    if (pExInfo->m_dFrameCount < pExInfo->m_cStackTrace) {
        SystemNative::StackTraceElement* pStackTrace = (SystemNative::StackTraceElement*)pExInfo->m_pStackTrace;
        pStackTrace[pExInfo->m_dFrameCount].pFunc = pFunc;
        if (pCf->IsFrameless()) {
            pStackTrace[pExInfo->m_dFrameCount].ip = *(pCf->GetRegisterSet()->pPC);
            pStackTrace[pExInfo->m_dFrameCount].sp = pCf->GetRegisterSet()->Esp;
        } else if (!InlinedCallFrame::FrameHasActiveCall(pFrame)) {
            pStackTrace[pExInfo->m_dFrameCount].ip = (SLOT)(pCf->GetFrame()->GetIP());
            pStackTrace[pExInfo->m_dFrameCount].sp = 0; //Don't have an SP to get.
        } else {
            // don't have the IP, SP for native code
            pStackTrace[pExInfo->m_dFrameCount].ip = 0; 
            pStackTrace[pExInfo->m_dFrameCount].sp = 0;
        }

        // This is a hack to fix the generation of stack traces from exception objects so that
        // they point to the line that actually generated the exception instead of the line
        // following.
        if (!(pCf->HasFaulted() || pCf->IsIPadjusted()) && pStackTrace[pExInfo->m_dFrameCount].ip != 0)
            pStackTrace[pExInfo->m_dFrameCount].ip -= 1;

        ++pExInfo->m_dFrameCount;
        COUNTER_ONLY(GetPrivatePerfCounters().m_Excep.cThrowToCatchStackDepth++);
        COUNTER_ONLY(GetGlobalPerfCounters().m_Excep.cThrowToCatchStackDepth++);
    }

    // now we've got the stack trace, if we aren't allowed to catch this and we're first pass, return
    if (pData->bDontCatch)
        return SWA_CONTINUE;
    
    if (!pCf->IsFrameless())
        return SWA_CONTINUE;

    // Let the profiler know that we are searching for a handler within this function instance
    Profiler::ExceptionSearchFunctionEnter(pThread, pFunc);

    IJitManager* pJitManager = pCf->GetJitManager();
    _ASSERTE(pJitManager);


    EH_CLAUSE_ENUMERATOR pEnumState;
    unsigned EHCount = pJitManager->InitializeEHEnumeration(pCf->GetMethodToken(), &pEnumState);
    if (EHCount == 0)
    {
        // Inform the profiler that we're leaving, and what pass we're on
        Profiler::ExceptionSearchFunctionLeave(pThread);
        return SWA_CONTINUE;
    }

    EEClass* thrownClass = NULL;
    // if we are being called on an unwind for an exception that we did not try to catch, eg.
    // an internal EE exception, then pThread->GetThrowable will be null
    if (pThread->GetThrowable() != NULL)
        thrownClass = pThread->GetThrowable()->GetTrueClass();
    PREGDISPLAY regs = pCf->GetRegisterSet();
    BYTE *pStack = (BYTE *) GetRegdisplaySP(regs);
    BYTE *pHandlerEBP   = *( (BYTE**) regs->pEbp );

    DWORD offs = (DWORD)pCf->GetRelOffset();  //= (BYTE*) (*regs->pPC) - (BYTE*) pCf->GetStartAddress();
    LOG((LF_EH, LL_INFO10000, "       offset is %d\n", offs));

    EE_ILEXCEPTION_CLAUSE EHClause, *EHClausePtr;

    unsigned start_adjust = !(pCf->HasFaulted() || pCf->IsIPadjusted());
    unsigned end_adjust = pCf->IsActiveFunc();

    for(ULONG i=0; i < EHCount; i++) 
    {  
         EHClausePtr = pJitManager->GetNextEHClause(pCf->GetMethodToken(),&pEnumState, &EHClause);
         _ASSERTE(IsValidClause(EHClausePtr));

        LOG((LF_EH, LL_INFO100, "       considering %s clause [%d,%d]\n",
                (IsFault(EHClausePtr) ? "fault" : (
                 IsFinally(EHClausePtr) ? "finally" : (
                 IsFilterHandler(EHClausePtr) ? "filter" : (
                 IsTypedHandler(EHClausePtr) ? "typed" : "unknown")))),
                EHClausePtr->TryStartPC,
                EHClausePtr->TryEndPC
                ));

        // Checking the exception range is a bit tricky because
        // on CPU faults (null pointer access, div 0, ..., the IP points
        // to the faulting instruction, but on calls, the IP points 
        // to the next instruction.   
        // This means that we should not include the start point on calls
        // as this would be a call just preceding the try block.
        // Also, we should include the end point on calls, but not faults.

        // If we're in the FILTER part of a filter clause, then we
        // want to stop crawling.  It's going to be caught in a
        // COMPLUS_CATCH just above us.  If not, the exception 
        if (   IsFilterHandler(EHClausePtr)
            && (   offs > EHClausePtr->FilterOffset
                || offs == EHClausePtr->FilterOffset && !start_adjust)
            && (   offs < EHClausePtr->HandlerStartPC
                || offs == EHClausePtr->HandlerStartPC && !end_adjust)) {

            LOG((LF_EH, LL_INFO100, "Fault inside filter\n"));
            return SWA_ABORT;
        }

        if ( (offs < EHClausePtr->TryStartPC) ||
             (offs > EHClausePtr->TryEndPC) ||
             (offs == EHClausePtr->TryStartPC && start_adjust) ||
             (offs == EHClausePtr->TryEndPC && end_adjust))
            continue;

        BOOL typeMatch = FALSE;
        //BOOL isFaultOrFinally = IsFaultOrFinally(EHClausePtr);
        BOOL isTypedHandler = IsTypedHandler(EHClausePtr);
        //BOOL hasCachedEEClass = HasCachedEEClass(EHClausePtr);
        if (isTypedHandler && thrownClass) {
            if ((mdToken)(size_t)EHClausePtr->pEEClass == mdTypeRefNil)
                // this is a catch(...)
                typeMatch = TRUE;
            else {
                if (! HasCachedEEClass(EHClausePtr))
                     pJitManager->ResolveEHClause(pCf->GetMethodToken(),&pEnumState,EHClausePtr);
                // if doesn't have cached class then class wasn't loaded so couldn't have been thrown
                typeMatch = HasCachedEEClass(EHClausePtr) && ExceptionIsOfRightType(EHClausePtr->pEEClass, thrownClass);
            }
        }

        // @PERF: Is this too expensive? Consider storing the nesting level
        // instead of the HandlerEndPC.

        // Determine the nesting level of EHClause. Just walk the table 
        // again, and find out how many handlers enclose it
        DWORD nestingLevel = 0;
          
        BOOL handleException = FALSE;
        if (IsFaultOrFinally(EHClausePtr))
            continue;
        if (isTypedHandler) 
        {   
            if (! typeMatch)
                continue;
        }
        else 
        {   
            if (pThread->IsGuardPageGone()) // Bypass filter if guard page is gone.
                continue;

            // Must be an exception filter (__except() part of __try{}__except(){}).
            _ASSERTE(EHClausePtr->HandlerEndPC != -1);  // TODO remove, protects against a deprecated convention
            nestingLevel = COMPlusComputeNestingLevel( pJitManager,
                pCf->GetMethodToken(),
                EHClausePtr->HandlerStartPC,
                false);

#ifdef DEBUGGING_SUPPORTED
            if (CORDebuggerAttached())
                g_pDebugInterface->ExceptionFilter(pHandlerEBP, pFunc, EHClausePtr->FilterOffset);
#endif // DEBUGGING_SUPPORTED
            
            // Let the profiler know we are entering a filter
            Profiler::ExceptionSearchFilterEnter(pThread, pFunc);
            
            COUNTER_ONLY(GetPrivatePerfCounters().m_Excep.cFiltersExecuted++);
            COUNTER_ONLY(GetGlobalPerfCounters().m_Excep.cFiltersExecuted++);
            
            int iFilt = 0;

            COMPLUS_TRY {
                iFilt = pJitManager->CallJitEHFilter(pCf, EHClausePtr, nestingLevel,
                                    pThread->GetThrowable());
            } COMPLUS_CATCH {
                // Swallow excepiton.  Treat as exception continue search.
                iFilt = EXCEPTION_CONTINUE_SEARCH;

            } COMPLUS_END_CATCH

            // Let the profiler know we are leaving a filter
            Profiler::ExceptionSearchFilterLeave(pThread);
        
            // If this filter didn't want the exception, keep looking.
            if (EXCEPTION_EXECUTE_HANDLER != iFilt)
                continue;
        }

        if (pThread->IsGuardPageGone()) {
            _ASSERTE(pCf->GetRegisterSet()->Esp == (DWORD)(size_t)pStack);
            if (!GuardPageHelper::CanResetStackTo(pStack-sizeof(NestedHandlerExRecord))) 
                continue;   // If I can't put the guard page back, can't catch.
        }

        // Record this location, to stop the unwind phase, later.
        pData->pFunc = pFunc;
        pData->dHandler = i;
        pData->pStack = pStack;

        // Notify the profiler that a catcher has been found
        Profiler::ExceptionSearchCatcherFound(pThread, pFunc);
        Profiler::ExceptionSearchFunctionLeave(pThread);

        return SWA_ABORT;
    }
    Profiler::ExceptionSearchFunctionLeave(pThread);
    return SWA_CONTINUE;
}


//==========================================================================
// COMPlusUnwindCallback
//==========================================================================

StackWalkAction COMPlusUnwindCallback (CrawlFrame *pCf, ThrowCallbackType *pData)
{

    _ASSERTE(pData->bIsUnwind);
    
    Frame *pFrame = pCf->GetFrame();
    MethodDesc *pFunc = pCf->GetFunction();

    STRESS_LOG3(LF_EH, LL_INFO100, "COMPlusUnwindCallback method = %pM Frame = %p Frame, FrameVtable = %pV\n", 
        pFunc, pFrame, pCf->IsFrameless()?0:(*(void**)pFrame));

    if (pFrame && pData->pTopFrame == pFrame)
        /* Don't look past limiting frame if there is one */
        return SWA_ABORT;

    if (!pFunc)
        return SWA_CONTINUE;

    LOG((LF_EH, LL_INFO100, "COMPlusUnwindCallback for %s\n", pFunc->m_pszDebugMethodName));

    Thread *pThread = GetThread();

    ExInfo *pExInfo = pThread->GetHandlerInfo();

    if (!pCf->IsFrameless()) 
        return SWA_CONTINUE;

    // Notify the profiler of the function we're dealing with in the unwind phase
    Profiler::ExceptionUnwindFunctionEnter(pThread, pFunc);
    
    IJitManager* pJitManager = pCf->GetJitManager();
    _ASSERTE(pJitManager);

    EH_CLAUSE_ENUMERATOR pEnumState;
    unsigned EHCount = pJitManager->InitializeEHEnumeration(pCf->GetMethodToken(), &pEnumState);
    if (EHCount == 0)
    {
        // Inform the profiler that we're leaving, and what pass we're on
        Profiler::ExceptionUnwindFunctionLeave(pThread);
        return SWA_CONTINUE;
    }

    EEClass* thrownClass = NULL;
    // if we are being called on an unwind for an exception that we did not try to catch, eg.
    // an internal EE exception, then pThread->GetThrowable will be null
    if (pThread->GetThrowable() != NULL)
        thrownClass = pThread->GetThrowable()->GetTrueClass();
    PREGDISPLAY regs = pCf->GetRegisterSet();
    BYTE *pStack        = (BYTE *) GetRegdisplaySP(regs);
    BYTE *pHandlerEBP   = *( (BYTE**) regs->pEbp );
        

    DWORD offs = (DWORD)pCf->GetRelOffset();  //= (BYTE*) (*regs->pPC) - (BYTE*) pCf->GetStartAddress();

    LOG((LF_EH, LL_INFO10000, "       offset is 0x%x, \n", offs));

    EE_ILEXCEPTION_CLAUSE EHClause, *EHClausePtr;

    unsigned start_adjust = !(pCf->HasFaulted() || pCf->IsIPadjusted());
    unsigned end_adjust = pCf->IsActiveFunc();

    for(ULONG i=0; i < EHCount; i++) 
    {  
         EHClausePtr = pJitManager->GetNextEHClause(pCf->GetMethodToken(),&pEnumState, &EHClause);
         _ASSERTE(IsValidClause(EHClausePtr));

        LOG((LF_EH, LL_INFO100, "       considering %s clause [0x%x,0x%x]\n",
                (IsFault(EHClausePtr) ? "fault" : (
                 IsFinally(EHClausePtr) ? "finally" : (
                 IsFilterHandler(EHClausePtr) ? "filter" : (
                 IsTypedHandler(EHClausePtr) ? "typed" : "unknown")))),
                EHClausePtr->TryStartPC,
                EHClausePtr->TryEndPC
                ));

        // Checking the exception range is a bit tricky because
        // on CPU faults (null pointer access, div 0, ..., the IP points
        // to the faulting instruction, but on calls, the IP points 
        // to the next instruction.   
        // This means that we should not include the start point on calls
        // as this would be a call just preceding the try block.
        // Also, we should include the end point on calls, but not faults.

        if (   IsFilterHandler(EHClausePtr)
            && (   offs > EHClausePtr->FilterOffset 
                || offs == EHClausePtr->FilterOffset && !start_adjust)
            && (   offs < EHClausePtr->HandlerStartPC 
                || offs == EHClausePtr->HandlerStartPC && !end_adjust)
            ) {
            LOG((LF_EH, LL_INFO100, "Fault inside filter\n"));
            return SWA_ABORT;
        }

        if ( (offs <  EHClausePtr->TryStartPC) ||
             (offs > EHClausePtr->TryEndPC) ||
             (offs == EHClausePtr->TryStartPC && start_adjust) ||
             (offs == EHClausePtr->TryEndPC && end_adjust))
            continue;

        BOOL typeMatch = FALSE;
        BOOL hasCachedEEClass = HasCachedEEClass(EHClausePtr);
        if ( IsTypedHandler(EHClausePtr) && thrownClass) {
            if ((mdToken)(size_t)EHClausePtr->pEEClass == mdTypeRefNil)
                // this is a catch(...)
                typeMatch = TRUE;
            else {
                if (! HasCachedEEClass(EHClausePtr))
                     pJitManager->ResolveEHClause(pCf->GetMethodToken(),&pEnumState,EHClausePtr);
                // if doesn't have cached class then class wasn't loaded so couldn't have been thrown
                typeMatch = HasCachedEEClass(EHClausePtr) && ExceptionIsOfRightType(EHClausePtr->pEEClass, thrownClass);
            }
        }

        // @PERF : Is this too expensive? Consider storing the nesting level
        // instead of the HandlerEndPC.

        // Determine the nesting level of EHClause. Just walk the table 
        // again, and find out how many handlers enclose it
          
        _ASSERTE(EHClausePtr->HandlerEndPC != -1);  // TODO remove, protects against a deprecated convention
        DWORD nestingLevel = COMPlusComputeNestingLevel( pJitManager,
                                                         pCf->GetMethodToken(),
                                                         EHClausePtr->HandlerStartPC,
                                                         false);
            
        if (IsFaultOrFinally(EHClausePtr))
        {
            // Another design choice: change finally to catch/throw model.  This
            // would allows them to be run under a stack overflow.
            if (pThread->IsGuardPageGone()) // Bypass finally/fault if guard page is gone.
                continue;

            COUNTER_ONLY(GetPrivatePerfCounters().m_Excep.cFinallysExecuted++);
            COUNTER_ONLY(GetGlobalPerfCounters().m_Excep.cFinallysExecuted++);

#ifdef DEBUGGING_SUPPORTED
        if (CORDebuggerAttached())
        {
            g_pDebugInterface->ExceptionHandle(pHandlerEBP, pFunc, EHClausePtr->HandlerStartPC);            
        }
#endif // DEBUGGING_SUPPORTED

            // Notify the profiler that we are about to execute the finally code
            Profiler::ExceptionUnwindFinallyEnter(pThread, pFunc);

            LOG((LF_EH, LL_INFO100, "COMPlusUnwindCallback finally - call\n"));
            pJitManager->CallJitEHFinally(pCf, EHClausePtr, nestingLevel);
            LOG((LF_EH, LL_INFO100, "COMPlusUnwindCallback finally - returned\n"));

            // Notify the profiler that we are done with the finally code
            Profiler::ExceptionUnwindFinallyLeave(pThread);

            continue;
        }
        // Current is not a finally, check if it's the catching handler (or filter).
        if (pData->pFunc != pFunc || (ULONG)(pData->dHandler) != i || pData->pStack != pStack)
            continue;

#ifdef _DEBUG
        gLastResumedExceptionFunc = pCf->GetFunction();
        gLastResumedExceptionHandler = i;
#endif

        // Notify the profiler that we are about to resume at the catcher
        Profiler::ExceptionCatcherEnter(pThread, pFunc);

#ifdef DEBUGGING_SUPPORTED
        if (CORDebuggerAttached())
        {
            g_pDebugInterface->ExceptionHandle(pHandlerEBP, pFunc, EHClausePtr->HandlerStartPC);            
        }
#endif // DEBUGGING_SUPPORTED

        pJitManager->ResumeAtJitEH(
            pCf,
            EHClausePtr, nestingLevel,
            pThread,
            pData->bUnwindStack);
        _ASSERTE(!"ResumeAtJitHander returned!");
    }
    STRESS_LOG1(LF_EH, LL_INFO100, "COMPlusUnwindCallback no handler found in method %pM\n", pFunc);

    Profiler::ExceptionUnwindFunctionLeave(pThread);
    return SWA_CONTINUE;
}



#pragma warning (disable : 4731)
void ResumeAtJitEH(CrawlFrame* pCf, BYTE* startPC, EE_ILEXCEPTION_CLAUSE *EHClausePtr, DWORD nestingLevel, Thread *pThread, BOOL unwindStack)
{
    EHContext context;
    PREGDISPLAY regs = pCf->GetRegisterSet();
    BYTE* resumePC = (BYTE*) (size_t(startPC) + EHClausePtr->HandlerStartPC);
    context.Eip = (ULONG)(size_t)resumePC;

    // EAX ECX EDX ar scratch
    context.Esp =  regs->Esp;
    context.Ebx = *regs->pEbx;
    context.Esi = *regs->pEsi;
    context.Edi = *regs->pEdi;
    context.Ebp = *regs->pEbp;

    size_t * pShadowSP = NULL; // Write Esp to *pShadowSP before jumping to handler
    size_t * pHandlerEnd = NULL;
    pCf->GetCodeManager()->FixContext(
        ICodeManager::CATCH_CONTEXT, &context, pCf->GetInfoBlock(),
        startPC, nestingLevel, pThread->GetThrowable(), pCf->GetCodeManState(),
        &pShadowSP, &pHandlerEnd);

    if (pHandlerEnd) *pHandlerEnd = EHClausePtr->HandlerEndPC;

    // save esp so that endcatch can restore it (it always restores, so want correct value)
    ExInfo * pExInfo = pThread->GetHandlerInfo();
    pExInfo->m_dEsp = context.Esp;
    
    NestedHandlerExRecord *pNestedHandlerExRecord;

    DWORD dEsp;
    __asm mov dEsp, esp

    if (!unwindStack) {
        _ASSERTE(!pThread->IsGuardPageGone());
        // so down below won't really update esp
        context.Esp = dEsp;
        pExInfo->m_pShadowSP = pShadowSP; // so that endcatch can zero it back
        if  (pShadowSP) 
            *pShadowSP = dEsp;
    } else {
        // so shadow SP has the real SP as we are going to unwind the stack
        dEsp = context.Esp;

        // BEGIN: UnwindExInfo(pExInfo, dEsp);
        ExInfo *pPrevNestedInfo = pExInfo->m_pPrevNestedInfo;
        while (pPrevNestedInfo && (DWORD)(size_t)pPrevNestedInfo->m_StackAddress < dEsp) {
            if (pPrevNestedInfo->m_pThrowable) {
                DestroyHandle(pPrevNestedInfo->m_pThrowable);
            }
            pPrevNestedInfo->FreeStackTrace();
            pPrevNestedInfo = pPrevNestedInfo->m_pPrevNestedInfo;
        }
        pExInfo->m_pPrevNestedInfo = pPrevNestedInfo;

        _ASSERTE(   pExInfo->m_pPrevNestedInfo == 0
                 || (DWORD)(size_t)pExInfo->m_pPrevNestedInfo->m_StackAddress >= dEsp);

        // Before we unwind the SEH records, get the Frame from the top-most nested exception record.
        Frame* pNestedFrame = GetCurrFrame(FindNestedEstablisherFrame((EXCEPTION_REGISTRATION_RECORD*)GetCurrentSEHRecord()));
        PopSEHRecords((LPVOID)(size_t)dEsp);

        EXCEPTION_REGISTRATION_RECORD* pNewBottomMostHandler = (EXCEPTION_REGISTRATION_RECORD*)GetCurrentSEHRecord();

        pExInfo->m_pShadowSP = pShadowSP;

        // The context and exception record are no longer any good.
        _ASSERTE((DWORD)(size_t)pExInfo->m_pContext < dEsp);   // It must be off the top of the stack.
        pExInfo->m_pContext = 0;                // Whack it.
        pExInfo->m_pExceptionRecord = 0;
        pExInfo->m_pExceptionPointers = 0;

        // We're going to put one nested record back on the stack before we resume.  This is
        // where it goes.
        pNestedHandlerExRecord = (NestedHandlerExRecord*)(size_t)(dEsp - sizeof(NestedHandlerExRecord));

        // The point of no return.  The next statement starts scribbling on the stack.  It's
        // deep enough that we won't hit our own locals.  (That's important, 'cuz we're still 
        // using them.)
        //
        _ASSERTE(dEsp > (DWORD)(size_t)&pCf);
        pNestedHandlerExRecord->m_handlerInfo.m_pThrowable=NULL; // This is random memory.  Handle
                                                                 // must be initialized to null before
                                                                 // calling Init(), as Init() will try
                                                                 // to free any old handle.
        pNestedHandlerExRecord->Init(0, COMPlusNestedExceptionHandler, pNestedFrame);
        InsertCOMPlusFrameHandler((pNestedHandlerExRecord));

        context.Esp = (DWORD)(size_t)pNestedHandlerExRecord;

        // We might have moved the bottommost handler.  The nested record itself is never
        // the bottom most handler -- it's pushed afte the fact.  So we have to make the
        // bottom-most handler the one BEFORE the nested record.
        if (pExInfo->m_pBottomMostHandler < pNewBottomMostHandler)
          pExInfo->m_pBottomMostHandler = pNewBottomMostHandler;

        if  (pShadowSP) 
            *pShadowSP = context.Esp;
    }

    STRESS_LOG3(LF_EH, LL_INFO100, "ResumeAtJitEH: resuming at EIP = %p  ESP = %p EBP = %p\n", context.Eip, context.Esp, context.Ebp);

    if (pThread->IsGuardPageGone()) {
        __asm mov     eax, context.Eax
        __asm mov     ebx, context.Ebx
        __asm mov     esi, context.Esi
        __asm mov     edi, context.Edi
        __asm mov     edx, context.Ebp    // save in temp since EBP is used to fectch local
        __asm mov     ecx, context.Eip    // save in temp for jump below
        __asm mov     esp, context.Esp    // locals are now DEAD!
        GuardPageHelper::ResetGuardPage(); // preserves EAX,EBX,ECX,EDX,ESI,EDI
        __asm mov     ebp, edx
        __asm jmp     ecx
        _ASSERTE(0);
    }

    __asm {
        mov     eax, context.Eax
        mov     ebx, context.Ebx
        mov     esi, context.Esi
        mov     edi, context.Edi
        mov     edx, context.Ebp    // save in temp since EBP is used to fectch local
        mov     ecx, context.Eip    // save in temp for jump below
        mov     esp, context.Esp    // will either really restore or be a no-op depending on unwindStack flag
        mov     ebp, edx
        jmp     ecx
    }

}

int CallJitEHFilter(CrawlFrame* pCf, BYTE* startPC, EE_ILEXCEPTION_CLAUSE *EHClausePtr, DWORD nestingLevel, OBJECTREF thrownObj)
{
    EHContext context;
    PREGDISPLAY regs = pCf->GetRegisterSet();
    BYTE* resumePC = (BYTE*) (size_t(startPC) + EHClausePtr->FilterOffset);
    context.Eip = (ULONG)(size_t)resumePC;
        // EAX ECX EDX ar scratch
    context.Esp =  regs->Esp;
    context.Ebx = *regs->pEbx;
    context.Esi = *regs->pEsi;
    context.Edi = *regs->pEdi;
    context.Ebp = *regs->pEbp;

    size_t * pShadowSP = NULL; // Write Esp to *pShadowSP before jumping to handler
    size_t * pEndFilter = NULL; // Write
    pCf->GetCodeManager()->FixContext(
        ICodeManager::FILTER_CONTEXT, &context, pCf->GetInfoBlock(),
        startPC, nestingLevel, thrownObj, pCf->GetCodeManState(),
        &pShadowSP, &pEndFilter);

    // End of the filter is the same as start of handler
    if (pEndFilter) *pEndFilter = EHClausePtr->HandlerStartPC;

    const int SHADOW_SP_IN_FILTER = int(ICodeManager::SHADOW_SP_IN_FILTER);
    int retVal = EXCEPTION_CONTINUE_SEARCH;

    __try
	{
        INSTALL_COMPLUS_EXCEPTION_HANDLER();
        
    __asm {
        push ebp

        mov     eax, pShadowSP      // Write esp-4 to the shadowSP slot
        test    eax, eax
        jz      DONE_SHADOWSP
        mov     ebx, esp
        sub     ebx, 4
        or      ebx, SHADOW_SP_IN_FILTER
        mov     [eax], ebx
    DONE_SHADOWSP:

        mov     eax, context.Eax
        mov     ebx, context.Ebx
        mov     esi, context.Esi
        mov     edi, context.Edi
        mov     edx, context.Ebp    // save in temp since EBP is used to fectch local
        mov     ecx, context.Eip    // save in temp for jump below
        mov     ebp, edx
        call    ecx
        INDEBUG(nop)                // Indicate that it is OK to call managed code directly from here
        pop     ebp
        mov     retVal, eax
		}
    
        UNINSTALL_COMPLUS_EXCEPTION_HANDLER();
	}
    __finally
    {
		// Mark the filter as having completed
		if (pShadowSP) *pShadowSP |= ICodeManager::SHADOW_SP_FILTER_DONE;
    }

    return retVal;
}


void CallJitEHFinally(CrawlFrame* pCf, BYTE* startPC, EE_ILEXCEPTION_CLAUSE *EHClausePtr, DWORD nestingLevel)
{
    EHContext context;
    PREGDISPLAY regs = pCf->GetRegisterSet();
    BYTE* resumePC = (BYTE*) (size_t(startPC) + EHClausePtr->HandlerStartPC);
    context.Eip = (ULONG)(size_t)resumePC;
    // EAX ECX EDX ar scratch
    context.Esp =  regs->Esp;
    context.Ebx = *regs->pEbx;
    context.Esi = *regs->pEsi;
    context.Edi = *regs->pEdi;
    context.Ebp = *regs->pEbp;

    size_t * pShadowSP = NULL; // Write Esp to *pShadowSP before jumping to handler
    size_t * pFinallyEnd = NULL;
    pCf->GetCodeManager()->FixContext(
        ICodeManager::FINALLY_CONTEXT, &context, pCf->GetInfoBlock(),
        startPC, nestingLevel, (OBJECTREF)(size_t)0, pCf->GetCodeManState(),
        &pShadowSP, &pFinallyEnd);

    if (pFinallyEnd) *pFinallyEnd = EHClausePtr->HandlerEndPC;

    __asm {
        push ebp

        mov     eax, pShadowSP      // Write esp-4 to the shadowSP slot
        test    eax, eax
        jz      DONE_SHADOWSP
        mov     ebx, esp
        sub     ebx, 4
        mov     [eax], ebx
    DONE_SHADOWSP:

        mov     eax, context.Eax
        mov     ebx, context.Ebx
        mov     esi, context.Esi
        mov     edi, context.Edi
        mov     edx, context.Ebp    // save in temp since EBP is used to fectch local
        mov     ecx, context.Eip    // save in temp for jump below
        mov     ebp, edx
        call    ecx
        INDEBUG(nop)                // Indicate that it is OK to call managed code directly from here
        pop     ebp
    }

    if (pShadowSP) *pShadowSP = 0;  // reset the shadowSP to 0
}
#pragma warning (default : 4731)


//=====================================================================
// *********************************************************************
//========================================================================
//  PLEASE READ, if you are using the following SEH setup functions in your stub
//  EmitSEHProlog :: is used for setting up SEH handler prolog
//  EmitSEHEpilog :: is used for setting up SEH handler epilog
//
//  The following exception record is pushed into the stack, the layout
//  is similar to NT's ExceptionRegistrationRecord,
//  from the pointer to the exception record, we can detect the beginning
//  of the frame which is at a well-known offset from the exception record
//
//  NT exception registration record looks as follows
//  typedef struct _EXCEPTION_REGISTRATION_RECORD {
//      struct _EXCEPTION_REGISTRATION_RECORD *Next;
//        PEXCEPTION_ROUTINE Handler;
//  } EXCEPTION_REGISTRATION_RECORD;
//
//  typedef EXCEPTION_REGISTRATION_RECORD *PEXCEPTION_REGISTRATION_RECORD;
//
//   But our exception records have extra information towards the end
//  struct CUSTOM_EXCEPTION_REGISTRATION_RECORD
//  {
//      PEXCEPTION_REGISTRATION_RECORD  m_pNext;
//      LPVOID                  m_pvFrameHandler;
//      .... frame specific data, the handler should know the offset to the frame
//  };
//
//========================================================================
// forward decls.

typedef VOID (__stdcall * TRtlUnwind)
        ( IN PVOID TargetFrame OPTIONAL,
    IN PVOID TargetIp OPTIONAL,
    IN PEXCEPTION_RECORD ExceptionRecord OPTIONAL,
    IN PVOID ReturnValue
    );

// global pointer to the RtlUnwind function
// fixed up when needed
TRtlUnwind pRtlUnwind = NULL;

/*
VOID
STDMETHODCALLTYPE
RtlUnwind (
    IN PVOID TargetFrame OPTIONAL,
    IN PVOID TargetIp OPTIONAL,
    IN PEXCEPTION_RECORD ExceptionRecord OPTIONAL,
    IN PVOID ReturnValue
    );
*/

//-------------------------------------------------------------------------
// Exception handler for COM to managed frame
//  and the layout of the exception registration record structure in the stack
//  the layout is similar to the NT's EXCEPTIONREGISTRATION record
//  followed by the UnmanagedToManagedCallFrame specific info

 struct ComToManagedExRecord
 {
    PEXCEPTION_REGISTRATION_RECORD  m_pPrev;
    LPVOID                  m_pvFrameHandler;

    // negative info stored in the UnmanagedToManagedCallFrame
    /*struct UnmanagedToManagedCallFrame::NegInfo
    {
        CleanupWorkList m_List;
        LPVOID      m_pArgs;
        ULONG       m_fGCEnabled;
    };*/

    UnmanagedToManagedCallFrame::NegInfo   info;

    #ifdef _DEBUG
    // VC trace info
    //  push eax        ;; push return address
    //  push ebp        ;; push previous ebp
    INT32                   m_vcJunk1;
    INT32                   m_vcJunk2;
    #endif

    INT32                   m_rEDI;     //saved reg edi
    INT32                   m_rESI;     //saved reg esi
    INT32                   m_rEBX;     //saved reg ebx
    INT32                   m_rEBP;     //saved reg ebp
    LPVOID                  m_pVtable;  // vtable of some derived class of UnmanagedToManagedCallFrame
    Frame*                  m_pPrevFrame;   // prev frame pointer
    INT32                   m_returnAddress;

    UnmanagedToManagedCallFrame*        GetCurrFrame()
    {
        return (UnmanagedToManagedCallFrame*)&m_pVtable;
    }
 };

UnmanagedToManagedCallFrame* GetCurrFrame(ComToManagedExRecord *pExRecord)
{
    return pExRecord->GetCurrFrame();
}


//======================================================
// HRESULT ComCallExceptionCleanup(ComToManagedExRecord* pEstFrame)
//  Cleanup for calls from Com to COM+
//
HRESULT ComCallExceptionCleanup(UnmanagedToManagedCallFrame* pCurrFrame)
{
    Thread* pThread = GetThread();
    _ASSERTE(pThread != NULL);

    // set up ErrorInfo and the get the hresult to return
    HRESULT hr = SetupErrorInfo(pThread->GetThrowable());
    _ASSERTE(hr != S_OK);

    return hr;
}

//---------------------------------------------------------------------
//  void RtlUnWindCallBack()
// call back function after global unwind, rtlunwind calls this function
//---------------------------------------------------------------------
void RtlUnWindCallBack()
{
        _ASSERTE(!"Should never get here");
}

#pragma warning (disable : 4731)
static void LocalUnwind(ComToManagedExRecord* pEstFrame)
{
    // global unwind is complete
    // let us preform the local unwind
    Thread* pThread = GetThread();
    _ASSERTE(pThread->PreemptiveGCDisabled());
    UnmanagedToManagedCallFrame* pFrame = (UnmanagedToManagedCallFrame*)pThread->GetFrame();
    CleanupWorkList* pList = pFrame->GetCleanupWorkList();
    _ASSERTE(pList != NULL);

    pList->Cleanup(TRUE);

    // pop the current frame
    pThread->SetFrame(*(Frame **)((LPVOID *)pFrame+1));

    INSTALL_NESTED_EXCEPTION_HANDLER(GetCurrFrame(pEstFrame));

    UINT rv = pFrame->ConvertComPlusException(pThread->GetThrowable());

    UNINSTALL_NESTED_EXCEPTION_HANDLER();

    // On last transition out of a thread that is aborted due to an AppDomain being unloaded, want to convert the 
    // thread abort into an AppDomainUnloadedException and reset the abort.
    if (pThread->ShouldChangeAbortToUnload(pFrame))
    {
        LOG((LF_APPDOMAIN, LL_INFO100, "ComToManageExceptHandler.LocalUnwind: first transition into unloading AD\n"));
        LOG((LF_EH, LL_INFO100, "ComToManageExceptHandler.LocalUnwind: first transition into unloading AD resets abort.\n"));

        rv = COR_E_APPDOMAINUNLOADED;
    } else if (   pThread->IsAbortRequested()
               && GetNextCOMPlusSEHRecord((EXCEPTION_REGISTRATION_RECORD*)pEstFrame) == (LPVOID)-1) {
        // If we're topmost, reset the abort.
        pThread->UserResetAbort();
        LOG((LF_EH, LL_INFO100, "ComToManageExceptHandler.LocalUnwind: topmost handler resets abort.\n"));
    }

    // need to pop off frame somehow
    if (pFrame->GetReturnContext())
        pThread->ReturnToContext(pFrame, FALSE);

    // set current SEH to be the previous SEH record in the stack
    SetCurrentSEHRecord(pEstFrame->m_pPrev);

    // Unwind our handler info.
    UnwindExInfo(pThread->GetHandlerInfo(), (VOID*) pEstFrame);

    // enable preemptive gc
    pThread->EnablePreemptiveGC();

    // NOTE: assumes __stdcall
    // compute the callee pop stack bytes
    UINT numArgStackBytes = pFrame->GetNumCallerStackBytes();
    unsigned frameSize = sizeof(Frame) + sizeof(LPVOID);
    LPBYTE iEsp = (((LPBYTE)pFrame) - PLATFORM_FRAME_ALIGN(sizeof(CalleeSavedRegisters) + VC5FRAME_SIZE));
    __asm
    {
        mov eax, rv
        mov ecx, frameSize
        mov edx, numArgStackBytes
        //*****************************************
        // reset the stack pointer
        // none of the locals above can be used in the asm below
        // if we wack the stack pointer
        mov esp, iEsp

        #ifdef _DEBUG
            add esp, SIZE VC5Frame
        #endif
        // pop callee saved registers
        pop edi
        pop esi
        pop ebx
        pop ebp
        add esp, ecx    ; // pop the frame and datum
        pop ecx         ; //return address
        // pop the callee cleanup stack args
        add esp, edx    ;// callee cleanup of args
        jmp ecx;        // jump to the address to continue execution
    }
}
#pragma warning (default : 4731)

EXCEPTION_DISPOSITION __cdecl  ComToManagedExceptHandler (
                                 PEXCEPTION_RECORD pExcepRecord,
                                  ComToManagedExRecord* pEstFrame,
                                  PCONTEXT pContext,
                                  LPVOID    pDispatcherContext)
{

    _ASSERTE(pExcepRecord != NULL);


    if ((pExcepRecord->ExceptionFlags & EXCEPTION_UNWIND) != 0)
    {
        // unwind in progress, okay this must be a non-complus
        // exception which we let pass by
        // do appropriate cleanup
        _ASSERTE(!"@BUG 59704, UNWIND cleanup in our frame handler");
        LOG((LF_EH, LL_INFO100, "Unwinding in ComToManagedExceptHandler with %x at %x with sp %x\n", pExcepRecord->ExceptionCode, GetIP(pContext), pContext->Esp));
        return COMPlusFrameHandler(pExcepRecord, (EXCEPTION_REGISTRATION_RECORD*)pEstFrame, pContext, pDispatcherContext);
    }
        LOG((LF_EH, LL_INFO100, "First-pass in ComToManagedExceptHandler with %x at %x with sp %x\n", pExcepRecord->ExceptionCode, GetIP(pContext), pContext->Esp));

    // run our ComPlus filter , this will handle the case of
    // any catch blocks present within COMPlus
    EXCEPTION_DISPOSITION edisp =
                COMPlusFrameHandler(pExcepRecord, (EXCEPTION_REGISTRATION_RECORD*)pEstFrame, pContext, pDispatcherContext);

    if (edisp == ExceptionContinueSearch)
    {
        // Ignore debugger exceptions.
        if (   pExcepRecord->ExceptionCode == STATUS_BREAKPOINT
            || pExcepRecord->ExceptionCode == STATUS_SINGLE_STEP) {
            return ExceptionContinueSearch;
        }

        // No one is prepared to handle it above us
        // let us just cleanup and return a bad HRESULT
        LOG((LF_EH, LL_INFO100, "ComToManagedExceptHandler, no handler\n"));

        Thread* pThread = GetThread();
        _ASSERTE(pThread != NULL);


        Profiler::ExceptionCLRCatcherFound();

        #ifdef DEBUGGING_SUPPORTED
        if (CORDebuggerAttached())
        {
            g_pDebugInterface->ExceptionCLRCatcherFound();
        }            

        #endif // DEBUGGING_SUPPORTED

        // We detect an unmanaged catcher by looking at m_pSearchBoundary -- but this is
        // a special case -- the object is being caught here.  Set m_pSearchBoundary
        // to NULL, so that we don't unwind our internal state before calling the
        // unwind pass below.
        ExInfo *pExInfo = pThread->GetHandlerInfo();
        pExInfo->m_pSearchBoundary = NULL;

        CallRtlUnwind((EXCEPTION_REGISTRATION_RECORD*)pEstFrame, RtlUnWindCallBack, pExcepRecord, 0);

        // unwind our COM+ frames
        pExcepRecord->ExceptionFlags &= EXCEPTION_UNWIND;
        COMPlusFrameHandler(pExcepRecord, (EXCEPTION_REGISTRATION_RECORD*)pEstFrame, pContext, pDispatcherContext);

        Profiler::ExceptionCLRCatcherExecute();

        pThread->DisablePreemptiveGC();

        // fixup the threads current frame
        UnmanagedToManagedCallFrame* pCurrFrame = pEstFrame->GetCurrFrame();
        pThread->SetFrame(pCurrFrame);

        LocalUnwind(pEstFrame);
        _ASSERTE(!"Should never reach here");
    }
    LOG((LF_EH, LL_INFO100, "ComToManagedExceptHandler, handler found\n"));
    return edisp;
}

#pragma warning (disable : 4731)
static void LocalUnwind(EXCEPTION_REGISTRATION_RECORD *pEstFrame, ContextTransitionFrame* pFrame)
{
    THROWSCOMPLUSEXCEPTION();

    // global unwind is complete
    // let us preform the local unwind
    Thread* pThread = GetThread();
    _ASSERTE(pThread->PreemptiveGCDisabled());


    AppDomain* pFromDomain = pThread->GetDomain();

    // @PERF: We're taking extra transitions in this code.  The CrossContextCopy at the 
    // bottom of this function is going to re-enter the from domain.  Better would be to 
    // have serialized the original exception before we left the from domain.

    _ASSERTE(pFrame->GetReturnContext());
    pThread->ReturnToContext(pFrame, FALSE);

    // set current SEH to be the previous SEH record in the stack
    SetCurrentSEHRecord(pEstFrame->Next);

    // Unwind our handler info.
    UnwindExInfo(pThread->GetHandlerInfo(), (void*)pEstFrame);

    // This frame is about to be popped.  If it's the unload boundary, we need to reset
    // the unload boundary to null.
    Frame* pUnloadBoundary = pThread->GetUnloadBoundaryFrame();
    if (pFrame == pUnloadBoundary)
        pThread->SetUnloadBoundaryFrame(NULL);
    pFrame->Pop();

    OBJECTREF throwable = pThread->LastThrownObject();
    GCPROTECT_BEGIN(throwable);

    // will throw a kAppDomainUnloadedException if necessary
    if (pThread->ShouldChangeAbortToUnload(pFrame, pUnloadBoundary))
        COMPlusThrow(kAppDomainUnloadedException, L"Remoting_AppDomainUnloaded_ThreadUnwound");

    // Can't marshal return value from unloaded appdomain.  Haven't
    // yet hit the boundary.  Throw a generic exception instead.
    // ThreadAbort is more consistent with what goes on elsewhere --
    // the AppDomainUnloaded is only introduced at the top-most boundary.
    //

    if (pFromDomain == SystemDomain::AppDomainBeingUnloaded())
        COMPlusThrow(kThreadAbortException);


    // There are a few classes that have the potential to create
    // infinite loops if we try to marshal them.  For ThreadAbort,
    // ThreadStop, ExecutionEngine, StackOverflow, and 
    // OutOfMemory, throw a new exception of the same type.
    //
    // @NICE: We lose the inner stack trace.  A little better
    // would be to at least check if the inner exceptions are
    // all the same type as the outer.  They could be
    // rethrown if this were true.
    // 
    _ASSERTE(throwable != NULL);
    MethodTable *throwableMT = throwable->GetTrueMethodTable();

    if (g_pThreadAbortExceptionClass == NULL)
    {
        g_pThreadAbortExceptionClass = g_Mscorlib.GetException(kThreadAbortException);
        g_pThreadStopExceptionClass = g_Mscorlib.GetException(kThreadStopException);
    }

    if (throwableMT == g_pThreadAbortExceptionClass) 
        COMPlusThrow(kThreadAbortException);

    if (throwableMT == g_pThreadStopExceptionClass)
        COMPlusThrow(kThreadStopException);
    
    if (throwableMT == g_pStackOverflowExceptionClass)
        COMPlusThrow(kStackOverflowException);

    if (throwableMT == g_pOutOfMemoryExceptionClass) 
        COMPlusThrowOM();

    if (throwableMT == g_pExecutionEngineExceptionClass)
        COMPlusThrow(kExecutionEngineException);

    // Marshal the object into the correct domain ...
    OBJECTREF pMarshaledThrowable = AppDomainHelper::CrossContextCopyFrom(pFromDomain, &throwable);

    // ... and throw it.
    COMPlusThrow(pMarshaledThrowable);

    GCPROTECT_END();
}
#pragma warning (default : 4731)

EXCEPTION_DISPOSITION __cdecl  ContextTransitionFrameHandler (
                                 PEXCEPTION_RECORD pExcepRecord,
                                  EXCEPTION_REGISTRATION_RECORD* pEstFrame,
                                  PCONTEXT pContext,
                                  LPVOID    pDispatcherContext)
{
    THROWSCOMPLUSEXCEPTION();

    // @TODO: Set the IsInUnmanagedHandler bits (aka IgnoreThreadAbort bits) appropriately.

    _ASSERTE(pExcepRecord != NULL);


    if ((pExcepRecord->ExceptionFlags & EXCEPTION_UNWIND) != 0)
    {
        // We always catch.  This can ONLY be the setjmp/longjmp case, where
        // we get a 2nd pass, but not a first one.
        _ASSERTE(!"@BUG 59704, UNWIND cleanup in our frame handler");
        LOG((LF_EH, LL_INFO100, "Unwinding in ContextTransitionFrameHandler with %x at %x with sp %x\n", pExcepRecord->ExceptionCode, GetIP(pContext), pContext->Esp));
        return COMPlusFrameHandler(pExcepRecord, (EXCEPTION_REGISTRATION_RECORD*)pEstFrame, pContext, pDispatcherContext);
    }
    LOG((LF_EH, LL_INFO100, "First-pass in ContextTransitionFrameHandler with %x at %x with sp %x\n", pExcepRecord->ExceptionCode, GetIP(pContext), pContext->Esp));

    // run our ComPlus filter , this will handle the case of
    // any catch blocks present within COMPlus
    EXCEPTION_DISPOSITION edisp =
                COMPlusFrameHandler(pExcepRecord, pEstFrame, pContext, pDispatcherContext);

    if (edisp != ExceptionContinueSearch)
    {
        LOG((LF_EH, LL_INFO100, "ContextTransitionFrameHandler, handler found\n"));
        return edisp;
    }

    // Ignore debugger exceptions.
    if (   pExcepRecord->ExceptionCode == STATUS_BREAKPOINT
        || pExcepRecord->ExceptionCode == STATUS_SINGLE_STEP) {
        return ExceptionContinueSearch;
    }

    // No one is prepared to handle it above us.  Need to catch and marshal the exception.

    // let us just cleanup and return a bad HRESULT
    LOG((LF_EH, LL_INFO100, "ContextTransitionFrameHandler, no handler\n"));

    Profiler::ExceptionCLRCatcherFound();

    Thread* pThread = GetThread();
    _ASSERTE(pThread != NULL);

    ContextTransitionFrame *pFrame = (ContextTransitionFrame*)((char *)pEstFrame - offsetof(ContextTransitionFrame, exRecord));
    _ASSERTE(pFrame->GetVTablePtr() == ContextTransitionFrame::GetMethodFrameVPtr());

    // We detect an unmanaged catcher by looking at m_pSearchBoundary -- but this is
    // a special case -- the object is being caught here.  Set m_pSearchBoundary
    // to NULL, so that we don't unwind our internal state before calling the
    // unwind pass below.
    ExInfo *pExInfo = pThread->GetHandlerInfo();
    pExInfo->m_pSearchBoundary = NULL;

    CallRtlUnwind((EXCEPTION_REGISTRATION_RECORD*)pEstFrame, RtlUnWindCallBack, pExcepRecord, 0);

    // unwind our COM+ frames
    pExcepRecord->ExceptionFlags &= EXCEPTION_UNWIND;
    COMPlusFrameHandler(pExcepRecord, (EXCEPTION_REGISTRATION_RECORD*)pEstFrame, pContext, pDispatcherContext);

    Profiler::ExceptionCLRCatcherExecute();

    pThread->DisablePreemptiveGC();

    // fixup the threads current frame
    pThread->SetFrame(pFrame);

    LocalUnwind(pEstFrame, pFrame);
    _ASSERTE(!"Should never reach here");
    return ExceptionContinueSearch;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\i386\cgenx86.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
// CGENX86.H -
//
// Various helper routines for generating x86 assembly code.
//
//

// Precompiled Header
#include "common.h"

#ifdef _X86_

#include "field.h"
#include "stublink.h"
#include "cgensys.h"
#include "tls.h"
#include "frames.h"
#include "excep.h"
#include "ndirect.h"
#include "log.h"
#include "security.h"
#include "comcall.h"
//#include "eecallconv.h"
#include "compluswrapper.h"
#include "COMDelegate.h"
#include "array.h"
#include "JITInterface.h"
#include "codeman.h"
#include "EjitMgr.h"
#include "remoting.h"
#include "DbgInterface.h"
#include "EEProfInterfaces.h"
#include "eeconfig.h"
#include "oletls.h"
#include "comcache.h"
#include "COMObject.h"
#include "olevariant.h"

extern "C" void JIT_UP_ByRefWriteBarrier();

//
// This assembly-level macro verifies that the pointer held in reg is 4-byte aligned
// and breaks into the debugger if the condition is not met
// Note: labels can't be used because multiple use of the macro would cause redefinition
//
#ifdef _DEBUG


// For some reason, CL uses the 6-byte encoding for IP-
// relative jumps, so we encode the jz $+3 ourselves so 
// that we don't break if CL decides to change the 
// encoding on us.  Of course, the encoding is actually 
// based on the IP of the *next* instruction, so our 
// target offset is only +1.  But since both MASM and 
// CL use the dollar sign to mean the IP of the 
// *current* instruction, that's the naming I used.
#define JZ_THIS_IP_PLUS_3   __asm _emit 0x74 __asm _emit 0x01

#define _ASSERT_ALIGNED_4_X86(reg) __asm    \
{                                           \
    __asm test reg, 3                       \
    JZ_THIS_IP_PLUS_3                       \
    __asm int 3                             \
}                                   

#define _ASSERT_ALIGNED_8_X86(reg) __asm  \
{										\
	__asm test reg, 7					\
	JZ_THIS_IP_PLUS_3					\
	__asm int 3							\
}


#else

#define _ASSERT_ALIGNED_4_X86(reg)
#define _ASSERT_ALIGNED_8_X86(reg)

#endif


// Uses eax, ebx registers
#define _UP_SPINLOCK_ENTER(X) 				\
_asm	push	ebx							\
_asm	mov 	ebx, 1						\
_asm	spin:								\
_asm	mov		eax, 0						\
_asm	cmpxchg X, ebx						\
_asm	jnz 	spin

#define _UP_SPINLOCK_EXIT(X)				\
_asm	mov		X, 0						\
_asm	pop		ebx

// Uses eax, ebx registers
#define _MP_SPINLOCK_ENTER(X)	_asm		\
_asm	push	ebx							\
_asm	mov		ebx, 1						\
_asm	spin:								\
_asm	mov		eax, 0						\
_asm	lock cmpxchg X, ebx					\
_asm	jnz		spin


// Uses ebx register
#define _MP_SPINLOCK_EXIT(X) 				\
_asm	mov		ebx, -1						\
_asm	lock xadd	X, ebx					\
_asm	pop		ebx		


// Prevent multiple threads from simultaneous interlocked in/decrementing
UINT	iSpinLock = 0;

//-----------------------------------------------------------------------
// InstructionFormat for near Jump and short Jump
//-----------------------------------------------------------------------
class X86NearJump : public InstructionFormat
{
    public:
        X86NearJump(UINT allowedSizes) : InstructionFormat(allowedSizes)
        {}

        virtual UINT GetSizeOfInstruction(UINT refsize, UINT variationCode)
        {
            return (refsize == k8 ? 2 : 5);
        }

        virtual VOID EmitInstruction(UINT refsize, __int64 fixedUpReference, BYTE *pOutBuffer, UINT variationCode, BYTE *pDataBuffer)
        {
            if (refsize == k8) {
                pOutBuffer[0] = 0xeb;
                *((__int8*)(pOutBuffer+1)) = (__int8)fixedUpReference;
            } else {
                pOutBuffer[0] = 0xe9;
                *((__int32*)(pOutBuffer+1)) = (__int32)fixedUpReference;
            }
        }
};




//-----------------------------------------------------------------------
// InstructionFormat for conditional jump. Set the variationCode
// to members of X86CondCode.
//-----------------------------------------------------------------------
class X86CondJump : public InstructionFormat
{
    public:
        X86CondJump(UINT allowedSizes) : InstructionFormat(allowedSizes)
        {}

        virtual UINT GetSizeOfInstruction(UINT refsize, UINT variationCode)
        {
            return (refsize == k8 ? 2 : 6);
        }

        virtual VOID EmitInstruction(UINT refsize, __int64 fixedUpReference, BYTE *pOutBuffer, UINT variationCode, BYTE *pDataBuffer)
        {
            if (refsize == k8) {
                pOutBuffer[0] = 0x70|variationCode;
                *((__int8*)(pOutBuffer+1)) = (__int8)fixedUpReference;
            } else {
                pOutBuffer[0] = 0x0f;
                pOutBuffer[1] = 0x80|variationCode;
                *((__int32*)(pOutBuffer+2)) = (__int32)fixedUpReference;
            }
        }


};




//-----------------------------------------------------------------------
// InstructionFormat for near call.
//-----------------------------------------------------------------------
class X86Call : public InstructionFormat
{
    public:
        X86Call(UINT allowedSizes) : InstructionFormat(allowedSizes)
        {}

        virtual UINT GetSizeOfInstruction(UINT refsize, UINT variationCode)
        {
            return 5;
        }

        virtual VOID EmitInstruction(UINT refsize, __int64 fixedUpReference, BYTE *pOutBuffer, UINT variationCode, BYTE *pDataBuffer)
        {
            pOutBuffer[0] = 0xe8;
            *((__int32*)(1+pOutBuffer)) = (__int32)fixedUpReference;
        }


};

//-----------------------------------------------------------------------
// InstructionFormat for push imm32.
//-----------------------------------------------------------------------
class X86PushImm32 : public InstructionFormat
{
    public:
        X86PushImm32(UINT allowedSizes) : InstructionFormat(allowedSizes)
        {}

        virtual UINT GetSizeOfInstruction(UINT refsize, UINT variationCode)
        {
            return 5;
        }

        virtual VOID EmitInstruction(UINT refsize, __int64 fixedUpReference, BYTE *pOutBuffer, UINT variationCode, BYTE *pDataBuffer)
        {
            pOutBuffer[0] = 0x68;
            // only support absolute pushimm32 of the label address. The fixedUpReference is
            // the offset to the label from the current point, so add to get address
            *((__int32*)(1+pOutBuffer)) = (__int32)(fixedUpReference);
        }


};

static X86NearJump gX86NearJump( InstructionFormat::k8|InstructionFormat::k32);
static X86CondJump gX86CondJump( InstructionFormat::k8|InstructionFormat::k32);
static X86Call     gX86Call(InstructionFormat::k32);
static X86PushImm32 gX86PushImm32(InstructionFormat::k32);


//---------------------------------------------------------------
// Emits:
//    PUSH <reg32>
//---------------------------------------------------------------
VOID StubLinkerCPU::X86EmitPushReg(X86Reg reg)
{
    THROWSCOMPLUSEXCEPTION();
    Emit8(0x50+reg);
    Push(4);
}


//---------------------------------------------------------------
// Emits:
//    POP <reg32>
//---------------------------------------------------------------
VOID StubLinkerCPU::X86EmitPopReg(X86Reg reg)
{
    THROWSCOMPLUSEXCEPTION();
    Emit8(0x58+reg);
    Pop(4);
}


//---------------------------------------------------------------
// Emits:
//    PUSH <imm32>
//---------------------------------------------------------------
VOID StubLinkerCPU::X86EmitPushImm32(UINT32 value)
{
    THROWSCOMPLUSEXCEPTION();
    Emit8(0x68);
    Emit32(value);
    Push(4);
}

//---------------------------------------------------------------
// Emits:
//    PUSH <imm32>
//---------------------------------------------------------------
VOID StubLinkerCPU::X86EmitPushImm32(CodeLabel &target)
{
    THROWSCOMPLUSEXCEPTION();
    EmitLabelRef(&target, gX86PushImm32, 0);
}

//---------------------------------------------------------------
// Emits:
//    PUSH <imm8>
//---------------------------------------------------------------
VOID StubLinkerCPU::X86EmitPushImm8(BYTE value)
{
    THROWSCOMPLUSEXCEPTION();
    Emit8(0x6a);
    Emit8(value);
    Push(4);
}


//---------------------------------------------------------------
// Emits:
//    XOR <reg32>,<reg32>
//---------------------------------------------------------------
VOID StubLinkerCPU::X86EmitZeroOutReg(X86Reg reg)
{
    Emit8(0x33);
    Emit8( 0xc0 | (reg << 3) | reg );
}


//---------------------------------------------------------------
// Emits:
//    JMP <ofs8>   or
//    JMP <ofs32}
//---------------------------------------------------------------
VOID StubLinkerCPU::X86EmitNearJump(CodeLabel *target)
{
    THROWSCOMPLUSEXCEPTION();
    EmitLabelRef(target, gX86NearJump, 0);
}


//---------------------------------------------------------------
// Emits:
//    Jcc <ofs8> or
//    Jcc <ofs32>
//---------------------------------------------------------------
VOID StubLinkerCPU::X86EmitCondJump(CodeLabel *target, X86CondCode::cc condcode)
{
    THROWSCOMPLUSEXCEPTION();
    EmitLabelRef(target, gX86CondJump, condcode);
}


//---------------------------------------------------------------
// Returns the type of CPU (the value of x of x86)
// (Please note, that it returns 6 for P5II)
// Also note that the CPU features are returned in the upper 16 bits.
//---------------------------------------------------------------
DWORD __stdcall GetSpecificCpuType()
{
    static DWORD val = 0;

    if (val)
        return(val);

    // See if the chip supports CPUID
    _asm {
        pushfd
        pop     eax           // Get the EFLAGS
        mov     ecx, eax      // Save for later testing.
        xor     eax, 0x200000 // Invert the ID bit.
        push    eax
        popfd                 // Save the updated flags.
        pushfd
        pop     eax           // Retrieve the updated flags
        xor     eax, ecx      // Test if it actually changed (bit set means yes).
        push    ecx
        popfd                 // Restore the flags.
        mov     val, eax
    }
    if (!(val & 0x200000))
        return 4;       // assume 486

    _asm {
        xor     eax, eax
        //push    ebx          -- Turns out to be unnecessary be VC is doing this in the prolog.
        cpuid        // CPUID0
        //pop     ebx
        mov     val, eax
    }

    // must at least allow CPUID1
    if (val < 1)
        return 4;       // assume 486

    _asm {
        mov     eax, 1
        //push    ebx
        cpuid       // CPUID1
        //pop     ebx
        shr     eax, 8
        and     eax, 0xf    // filter out family

        shl     edx, 16     // or in cpu features in upper 16 bits
        and     edx, 0xFFFF0000
        or      eax, edx

        mov     val, eax
    }
#ifdef _DEBUG
    const DWORD cpuDefault = 0xFFFFFFFF;
    static ConfigDWORD cpuFamily(L"CPUFamily", cpuDefault);
    if (cpuFamily.val() != cpuDefault)
    {
        assert((cpuFamily.val() & 0xF) == cpuFamily.val());
        val = (val & 0xFFFF0000) | cpuFamily.val();
    }

    static ConfigDWORD cpuFeatures(L"CPUFeatures", cpuDefault);
    if (cpuFeatures.val() != cpuDefault)
    {
        assert((cpuFeatures.val() & 0xFFFF) == cpuFeatures.val());
        val = (val & 0x0000FFFF) | (cpuFeatures.val() << 16);
    }
#endif
    return val;
}


//---------------------------------------------------------------
// Emits:
//    call <ofs32>
//---------------------------------------------------------------
VOID StubLinkerCPU::X86EmitCall(CodeLabel *target, int iArgBytes,
                                BOOL returnLabel)
{
    THROWSCOMPLUSEXCEPTION();
    EmitLabelRef(target, gX86Call, 0);
    if (returnLabel)
        EmitReturnLabel();

    INDEBUG(Emit8(0x90));       // Emit a nop after the call in debug so that
                                // we know that this is a call that can directly call 
                                // managed code

    Pop(iArgBytes);
}

//---------------------------------------------------------------
// Emits:
//    ret n
//---------------------------------------------------------------
VOID StubLinkerCPU::X86EmitReturn(int iArgBytes)
{
    THROWSCOMPLUSEXCEPTION();

    if (iArgBytes == 0)
        Emit8(0xc3);
    else
    {
        Emit8(0xc2);
        Emit16(iArgBytes);
    }

    Pop(iArgBytes);
}


VOID StubLinkerCPU::X86EmitPushRegs(unsigned regSet)
{
    for (X86Reg r = kEAX; r <= kEDI; r = (X86Reg)(r+1))
        if (regSet & (1U<<r))
            X86EmitPushReg(r);
}


VOID StubLinkerCPU::X86EmitPopRegs(unsigned regSet)
{
    for (X86Reg r = kEDI; r >= kEAX; r = (X86Reg)(r-1))
        if (regSet & (1U<<r))
            X86EmitPopReg(r);
}


//---------------------------------------------------------------
// Emit code to store the current Thread structure in dstreg
// preservedRegSet is a set of registers to be preserved
// TRASHES  EAX, EDX, ECX unless they are in preservedRegSet.
// RESULTS  dstreg = current Thread
//---------------------------------------------------------------
VOID StubLinkerCPU::X86EmitTLSFetch(DWORD idx, X86Reg dstreg, unsigned preservedRegSet)
{
    // It doesn't make sense to have the destination register be preserved
    _ASSERTE((preservedRegSet & (1<<dstreg)) == 0);

    THROWSCOMPLUSEXCEPTION();
    TLSACCESSMODE mode = GetTLSAccessMode(idx);

#ifdef _DEBUG
    {
        static BOOL f = TRUE;
        f = !f;
        if (f) {
           mode = TLSACCESS_GENERIC;
        }
    }
#endif

    switch (mode) {
        case TLSACCESS_X86_WNT: {
                unsigned __int32 tlsofs = WINNT_TLS_OFFSET + idx*4;

                // mov dstreg, fs:[OFS]
                Emit16(0x8b64);
                Emit8((dstreg<<3) + 0x5);
                Emit32(tlsofs);
            }
            break;

        case TLSACCESS_X86_W95: {
                // mov dstreg, fs:[2c]
                Emit16(0x8b64);
                Emit8((dstreg<<3) + 0x5);
                Emit32(WIN95_TLSPTR_OFFSET);

                // mov dstreg, [dstreg+OFS]
                X86EmitIndexRegLoad(dstreg, dstreg, idx*4);

            }
            break;

        case TLSACCESS_GENERIC:

            X86EmitPushRegs(preservedRegSet & ((1<<kEAX)|(1<<kEDX)|(1<<kECX)));

            X86EmitPushImm32(idx);

            // call TLSGetValue
            X86EmitCall(NewExternalCodeLabel(TlsGetValue), 4);  // in CE pop 4 bytes or args after the call

            // mov dstreg, eax
            Emit8(0x89);
            Emit8(0xc0 + dstreg);

            X86EmitPopRegs(preservedRegSet & ((1<<kEAX)|(1<<kEDX)|(1<<kECX)));

            break;

        default:
            _ASSERTE(0);
    }

#ifdef _DEBUG
    // Trash caller saved regs that we were not told to preserve, and that aren't the dstreg.
    preservedRegSet |= 1<<dstreg;
    if (!(preservedRegSet & (1<<kEAX)))
        X86EmitDebugTrashReg(kEAX);
    if (!(preservedRegSet & (1<<kEDX)))
        X86EmitDebugTrashReg(kEDX);
    if (!(preservedRegSet & (1<<kECX)))
        X86EmitDebugTrashReg(kECX);
#endif
}

//---------------------------------------------------------------
// Emit code to store the current Thread structure in ebx.
// TRASHES  eax
// RESULTS  ebx = current Thread
//---------------------------------------------------------------
VOID StubLinkerCPU::X86EmitCurrentThreadFetch()
{
    X86EmitTLSFetch(GetThreadTLSIndex(), kEBX, (1<<kEDX)|(1<<kECX));
}


// fwd decl
Thread* __stdcall CreateThreadBlock();

//---------------------------------------------------------------
// Emit code to store the setup current Thread structure in eax.
// TRASHES  eax,ecx&edx.
// RESULTS  ebx = current Thread
//---------------------------------------------------------------
VOID StubLinkerCPU::X86EmitSetupThread()
{
    THROWSCOMPLUSEXCEPTION();
    DWORD idx = GetThreadTLSIndex();
    TLSACCESSMODE mode = GetTLSAccessMode(idx);
    CodeLabel *labelThreadSetup;


#ifdef _DEBUG
    {
        static BOOL f = TRUE;
        f = !f;
        if (f) {
           mode = TLSACCESS_GENERIC;
        }
    }
#endif

    switch (mode) {
        case TLSACCESS_X86_WNT: {
                unsigned __int32 tlsofs = WINNT_TLS_OFFSET + idx*4;

                // "mov ebx, fs:[OFS]
                static BYTE code[] = {0x64,0xa1};
                EmitBytes(code, sizeof(code));
                Emit32(tlsofs);
            }
            break;

        case TLSACCESS_X86_W95: {
                // mov eax, fs:[2c]
                Emit16(0xa164);
                Emit32(WIN95_TLSPTR_OFFSET);

                // mov eax, [eax+OFS]
                X86EmitIndexRegLoad(kEAX, kEAX, idx*4);

            }
            break;

        case TLSACCESS_GENERIC:
            X86EmitPushImm32(idx);
            // call TLSGetValue
            X86EmitCall(NewExternalCodeLabel(TlsGetValue), 4); // in CE pop 4 bytes or args after the call
            break;
        default:
            _ASSERTE(0);
    }

    // tst eax,eax
    static BYTE code[] = {0x85, 0xc0};
    EmitBytes(code, sizeof(code));

    labelThreadSetup = NewCodeLabel();
    X86EmitCondJump(labelThreadSetup, X86CondCode::kJNZ);
    X86EmitCall(NewExternalCodeLabel(CreateThreadBlock), 0); // in CE pop no args to pop
    EmitLabel(labelThreadSetup);

#ifdef _DEBUG
    X86EmitDebugTrashReg(kECX);
    X86EmitDebugTrashReg(kEDX);
#endif

}

//---------------------------------------------------------------
// Emits:
//    mov <dstreg>, [<srcreg> + <ofs>]
//---------------------------------------------------------------
VOID StubLinkerCPU::X86EmitIndexRegLoad(X86Reg dstreg,
                                        X86Reg srcreg,
                                        __int32 ofs)
{
    THROWSCOMPLUSEXCEPTION();
    X86EmitOffsetModRM(0x8b, dstreg, srcreg, ofs);
}


//---------------------------------------------------------------
// Emits:
//    mov [<dstreg> + <ofs>],<srcreg>
//---------------------------------------------------------------
VOID StubLinkerCPU::X86EmitIndexRegStore(X86Reg dstreg,
                                         __int32 ofs,
                                         X86Reg srcreg)
{
    THROWSCOMPLUSEXCEPTION();
    X86EmitOffsetModRM(0x89, srcreg, dstreg, ofs);
}



//---------------------------------------------------------------
// Emits:
//    push dword ptr [<srcreg> + <ofs>]
//---------------------------------------------------------------
VOID StubLinkerCPU::X86EmitIndexPush(X86Reg srcreg, __int32 ofs)
{
    THROWSCOMPLUSEXCEPTION();
    X86EmitOffsetModRM(0xff, (X86Reg)0x6, srcreg, ofs);
    Push(4);
}


//---------------------------------------------------------------
// Emits:
//    push dword ptr [<srcreg> + <ofs>]
//---------------------------------------------------------------
VOID StubLinkerCPU::X86EmitSPIndexPush(__int8 ofs)
{
    THROWSCOMPLUSEXCEPTION();
    BYTE code[] = {0xff, 0x74, 0x24, ofs};
    EmitBytes(code, sizeof(code));
    Push(4);
}


//---------------------------------------------------------------
// Emits:
//    pop dword ptr [<srcreg> + <ofs>]
//---------------------------------------------------------------
VOID StubLinkerCPU::X86EmitIndexPop(X86Reg srcreg, __int32 ofs)
{
    THROWSCOMPLUSEXCEPTION();
    X86EmitOffsetModRM(0x8f, (X86Reg)0x0, srcreg, ofs);
    Pop(4);
}



//---------------------------------------------------------------
// Emits:
//   sub esp, IMM
//---------------------------------------------------------------
VOID StubLinkerCPU::X86EmitSubEsp(INT32 imm32)
{
    THROWSCOMPLUSEXCEPTION();
    if (imm32 < 0x1000-100) {
        // As long as the esp size is less than 1 page plus a small
        // safety fudge factor, we can just bump esp.
        X86EmitSubEspWorker(imm32);
    } else {
        // Otherwise, must touch at least one byte for each page.
        while (imm32 >= 0x1000) {

            X86EmitSubEspWorker(0x1000-4);
            X86EmitPushReg(kEAX);

            imm32 -= 0x1000;
        }
        if (imm32 < 500) {
            X86EmitSubEspWorker(imm32);
        } else {
            // If the remainder is large, touch the last byte - again,
            // as a fudge factor.
            X86EmitSubEspWorker(imm32-4);
            X86EmitPushReg(kEAX);
        }

    }

    Push(imm32);

}

//---------------------------------------------------------------
// Emits:
//   sub esp, IMM
//---------------------------------------------------------------
VOID StubLinkerCPU::X86EmitSubEspWorker(INT32 imm32)
{
    THROWSCOMPLUSEXCEPTION();

    // On Win32, stacks must be faulted in one page at a time.
    _ASSERTE(imm32 < 0x1000);

    if (!imm32) {
        // nop
    } else if (FitsInI1(imm32)) {
        Emit16(0xec83);
        Emit8((INT8)imm32);
    } else {
        Emit16(0xec81);
        Emit32(imm32);
    }
}

//---------------------------------------------------------------
// Emits:
//   add esp, IMM
//---------------------------------------------------------------
VOID StubLinkerCPU::X86EmitAddEsp(INT32 imm32)
{
    if (!imm32) {
        // nop
    } else if (FitsInI1(imm32)) {
        Emit16(0xc483);
        Emit8((INT8)imm32);
    } else {
        Emit16(0xc481);
        Emit32(imm32);
    }
    Pop(imm32);
}


VOID StubLinkerCPU::X86EmitAddReg(X86Reg reg, __int8 imm8)
{
    _ASSERTE((int) reg < 8);

    Emit8(0x83);
    Emit8(0xC0 | reg);
    Emit8(imm8);
}


VOID StubLinkerCPU::X86EmitSubReg(X86Reg reg, __int8 imm8)
{
    _ASSERTE((int) reg < 8);

    Emit8(0x83);
    Emit8(0xE8 | reg);
    Emit8(imm8);
}



//---------------------------------------------------------------
// Emits a MOD/RM for accessing a dword at [<indexreg> + ofs32]
//---------------------------------------------------------------
VOID StubLinkerCPU::X86EmitOffsetModRM(BYTE opcode, X86Reg opcodereg, X86Reg indexreg, __int32 ofs)
{
    THROWSCOMPLUSEXCEPTION();
    BYTE code[6];
    code[0] = opcode;
    BYTE modrm = (opcodereg << 3) | indexreg;
    if (ofs == 0 && indexreg != kEBP) {
        code[1] = modrm;
        EmitBytes(code, 2);
    } else if (FitsInI1(ofs)) {
        code[1] = 0x40|modrm;
        code[2] = (BYTE)ofs;
        EmitBytes(code, 3);
    } else {
        code[1] = 0x80|modrm;
        *((__int32*)(2+code)) = ofs;
        EmitBytes(code, 6);
    }
}



//---------------------------------------------------------------
// Emits the most efficient form of the operation:
//
//    opcode   altreg, [basereg + scaledreg*scale + ofs]
//
// or
//
//    opcode   [basereg + scaledreg*scale + ofs], altreg
//
// (the opcode determines which comes first.)
//
//
// Limitations:
//
//    scale must be 0,1,2,4 or 8.
//    if scale == 0, scaledreg is ignored.
//    basereg and altreg may be equal to 4 (ESP) but scaledreg cannot
//    for some opcodes, "altreg" may actually select an operation
//      rather than a second register argument.
//    if basereg is EBP, scale must be 0.
//
//---------------------------------------------------------------
VOID StubLinkerCPU::X86EmitOp(BYTE    opcode,
                              X86Reg  altreg,
                              X86Reg  basereg,
                              __int32 ofs /*=0*/,
                              X86Reg  scaledreg /*=0*/,
                              BYTE    scale /*=0*/)
{
    THROWSCOMPLUSEXCEPTION();

    _ASSERTE(scale == 0 || scale == 1 || scale == 2 || scale == 4 || scale == 8);
    _ASSERTE(scaledreg != (X86Reg)4);
    _ASSERTE(!(basereg == kEBP && scale != 0));

    _ASSERTE( ((UINT)basereg)   < 8 );
    _ASSERTE( ((UINT)scaledreg) < 8 );
    _ASSERTE( ((UINT)altreg)    < 8 );


    BYTE modrmbyte = altreg << 3;
    BOOL fNeedSIB  = FALSE;
    BYTE SIBbyte = 0;
    BYTE ofssize;
    BYTE scaleselect= 0;

    if (ofs == 0 && basereg != kEBP) {
        ofssize = 0; // Don't change this constant!
    } else if (FitsInI1(ofs)) {
        ofssize = 1; // Don't change this constant!
    } else {
        ofssize = 2; // Don't change this constant!
    }

    switch (scale) {
        case 1: scaleselect = 0; break;
        case 2: scaleselect = 1; break;
        case 4: scaleselect = 2; break;
        case 8: scaleselect = 3; break;
    }

    if (scale == 0 && basereg != (X86Reg)4 /*ESP*/) {
        // [basereg + ofs]
        modrmbyte |= basereg | (ofssize << 6);
    } else if (scale == 0) {
        // [esp + ofs]
        _ASSERTE(basereg == (X86Reg)4);
        fNeedSIB = TRUE;
        SIBbyte  = 0044;

        modrmbyte |= 4 | (ofssize << 6);
    } else {

        //[basereg + scaledreg*scale + ofs]

        modrmbyte |= 0004 | (ofssize << 6);
        fNeedSIB = TRUE;
        SIBbyte = ( scaleselect << 6 ) | (scaledreg << 3) | (basereg);

    }

    //Some sanity checks:
    _ASSERTE(!(fNeedSIB && basereg == kEBP)); // EBP not valid as a SIB base register.
    _ASSERTE(!( (!fNeedSIB) && basereg == (X86Reg)4 )) ; // ESP addressing requires SIB byte

    Emit8(opcode);
    Emit8(modrmbyte);
    if (fNeedSIB) {
        Emit8(SIBbyte);
    }
    switch (ofssize) {
        case 0: break;
        case 1: Emit8( (__int8)ofs ); break;
        case 2: Emit32( ofs ); break;
        default: _ASSERTE(!"Can't get here.");
    }
}



// Emits
//
//    opcode altreg, modrmreg
//
// or
//
//    opcode modrmreg, altreg
//
// (the opcode determines which one comes first)
//
// For single-operand opcodes, "altreg" actually selects
// an operation rather than a register.

VOID StubLinkerCPU::X86EmitR2ROp(BYTE opcode, X86Reg altreg, X86Reg modrmreg)
{
    THROWSCOMPLUSEXCEPTION();

    _ASSERTE( ((UINT)altreg) < 8 );
    _ASSERTE( ((UINT)modrmreg) < 8 );

    Emit8(opcode);
    Emit8(0300 | (altreg << 3) | modrmreg);
}


//---------------------------------------------------------------
// Emit a MOD/RM + SIB for accessing a DWORD at [esp+ofs32]
//---------------------------------------------------------------
VOID StubLinkerCPU::X86EmitEspOffset(BYTE opcode, X86Reg altreg, __int32 ofs)
{
    THROWSCOMPLUSEXCEPTION();

    BYTE code[7];

    code[0] = opcode;
    BYTE modrm = (altreg << 3) | 004;
    if (ofs == 0) {
        code[1] = modrm;
        code[2] = 0044;
        EmitBytes(code, 3);
    } else if (FitsInI1(ofs)) {
        code[1] = 0x40|modrm;
        code[2] = 0044;
        code[3] = (BYTE)ofs;
        EmitBytes(code, 4);
    } else {
        code[1] = 0x80|modrm;
        code[2] = 0044;
        *((__int32*)(3+code)) = ofs;
        EmitBytes(code, 7);
    }
}



/*
    This method is dependent on the StubProlog, therefore it's implementation
    is done right next to it.
*/
void FramedMethodFrame::UpdateRegDisplay(const PREGDISPLAY pRD)
{
#ifdef _X86_

    CalleeSavedRegisters* regs = GetCalleeSavedRegisters();
    MethodDesc * pFunc = GetFunction();


    // reset pContext; it's only valid for active (top-most) frame

    pRD->pContext = NULL;


    pRD->pEdi = (DWORD*) &regs->edi;
    pRD->pEsi = (DWORD*) &regs->esi;
    pRD->pEbx = (DWORD*) &regs->ebx;
    pRD->pEbp = (DWORD*) &regs->ebp;
    pRD->pPC  = (SLOT*) GetReturnAddressPtr();
    pRD->Esp  = (DWORD)((size_t)pRD->pPC + sizeof(void*));


    //@TODO: We still need to the following things:
    //          - figure out if we are in a hijacked slot
    //            (no adjustment of ESP necessary)
    //          - adjust ESP (popping the args)
    //          - figure out if the aborted flag is set

    if (pFunc)
    {
        pRD->Esp += (DWORD) pFunc->CbStackPop();
    }

#if 0
    /* this is the old code */
    if (sfType == SFT_JITTOVM)
        pRD->Esp += ((DWORD) this->GetMethodInfo() & ~0xC0000000);
    else if (sfType == SFT_FASTINTERPRETED)
        /* real esp is stored behind copy of return address */
        pRD->Esp = *((DWORD*) pRD->Esp);
    else if (sfType != SFT_JITHIJACK)
        pRD->Esp += (this->GetMethodInfo()->GetParamArraySize() * sizeof(DWORD));
#endif

#endif
}

void HelperMethodFrame::UpdateRegDisplay(const PREGDISPLAY pRD)
{
        _ASSERTE(m_MachState->isValid());               // InsureInit has been called

    // reset pContext; it's only valid for active (top-most) frame
    pRD->pContext = NULL;

    pRD->pEdi = (DWORD*) m_MachState->pEdi();
    pRD->pEsi = (DWORD*) m_MachState->pEsi();
    pRD->pEbx = (DWORD*) m_MachState->pEbx();
    pRD->pEbp = (DWORD*) m_MachState->pEbp();
    pRD->pPC  = (SLOT*)  m_MachState->pRetAddr();
    pRD->Esp  = (DWORD)(size_t)  m_MachState->esp();

        if (m_RegArgs == 0)
                return;

        // If we are promoting arguments, then we should do what the signature
        // tells us to do, instead of what the epilog tells us to do.
        // This is because the helper (and thus the epilog) may be shared and
        // can not pop off the correct number of arguments
    MethodDesc * pFunc = GetFunction();
    _ASSERTE(pFunc != 0);
    pRD->Esp  = (DWORD)(size_t)pRD->pPC + sizeof(void*) + pFunc->CbStackPop();
}


void FaultingExceptionFrame::UpdateRegDisplay(const PREGDISPLAY pRD)
{
    CalleeSavedRegisters* regs = GetCalleeSavedRegisters();
    MethodDesc * pFunc = GetFunction();

    // reset pContext; it's only valid for active (top-most) frame
    pRD->pContext = NULL;


    pRD->pEdi = (DWORD*) &regs->edi;
    pRD->pEsi = (DWORD*) &regs->esi;
    pRD->pEbx = (DWORD*) &regs->ebx;
    pRD->pEbp = (DWORD*) &regs->ebp;
    pRD->pPC  = (SLOT*) GetReturnAddressPtr();
    pRD->Esp = m_Esp;
}

void InlinedCallFrame::UpdateRegDisplay(const PREGDISPLAY pRD)
{
    DWORD *savedRegs = (DWORD*) &m_pCalleeSavedRegisters;
    DWORD stackArgSize = (DWORD)(size_t) m_Datum;
    NDirectMethodDesc * pMD;


    if (stackArgSize & ~0xFFFF)
    {
        pMD = (NDirectMethodDesc*)m_Datum;

        /* if this is not an NDirect frame, something is really wrong */

        _ASSERTE(pMD->IsNDirect());

        stackArgSize = pMD->ndirect.m_cbDstBufSize;
    }

    // reset pContext; it's only valid for active (top-most) frame
    pRD->pContext = NULL;


    pRD->pEdi = savedRegs++;
    pRD->pEsi = savedRegs++;
    pRD->pEbx = savedRegs++;
    pRD->pEbp = savedRegs++;

    /* The return address is just above the "ESP" */
    pRD->pPC  = (SLOT*) &m_pCallerReturnAddress;

    /* Now we need to pop off the outgoing arguments */
    pRD->Esp  = (DWORD)(size_t) m_pCallSiteTracker + stackArgSize;

}

//==========================
// Resumable Exception Frame
//
LPVOID* ResumableFrame::GetReturnAddressPtr() {
    return (LPVOID*) &m_Regs->Eip;
}

LPVOID ResumableFrame::GetReturnAddress() {
    return (LPVOID)(size_t) m_Regs->Eip;
}

void ResumableFrame::UpdateRegDisplay(const PREGDISPLAY pRD) {
    // reset pContext; it's only valid for active (top-most) frame
    pRD->pContext = NULL;

    pRD->pEdi = &m_Regs->Edi;
    pRD->pEsi = &m_Regs->Esi;
    pRD->pEbx = &m_Regs->Ebx;
    pRD->pEbp = &m_Regs->Ebp;
    pRD->pPC  = (SLOT*)&m_Regs->Eip;
    pRD->Esp  = m_Regs->Esp;

    pRD->pEax = &m_Regs->Eax;
    pRD->pEcx = &m_Regs->Ecx;
    pRD->pEdx = &m_Regs->Edx;
}


void PInvokeCalliFrame::UpdateRegDisplay(const PREGDISPLAY pRD)
{
    FramedMethodFrame::UpdateRegDisplay(pRD);

    VASigCookie *pVASigCookie = (VASigCookie *)NonVirtual_GetCookie();

    pRD->Esp += (pVASigCookie->sizeOfArgs+sizeof(int));
}

//===========================================================================
// Emits code to capture the lasterror code.
VOID StubLinkerCPU::EmitSaveLastError()
{
    THROWSCOMPLUSEXCEPTION();

    // push eax (must save return value)
    X86EmitPushReg(kEAX);

    // call GetLastError
    X86EmitCall(NewExternalCodeLabel(GetLastError), 0);

    // mov [ebx + Thread.m_dwLastError], eax
    X86EmitIndexRegStore(kEBX, offsetof(Thread, m_dwLastError), kEAX);

    // pop eax (restore return value)
    X86EmitPopReg(kEAX);
}


void UnmanagedToManagedFrame::UpdateRegDisplay(const PREGDISPLAY pRD)
{
#ifdef _X86_

    DWORD *savedRegs = (DWORD *)((size_t)this - (sizeof(CalleeSavedRegisters)));

    // reset pContext; it's only valid for active (top-most) frame

    pRD->pContext = NULL;

    pRD->pEdi = savedRegs++;
    pRD->pEsi = savedRegs++;
    pRD->pEbx = savedRegs++;
    pRD->pEbp = savedRegs++;
    pRD->pPC  = (SLOT*)((BYTE*)this + GetOffsetOfReturnAddress());
    pRD->Esp  = (DWORD)(size_t)pRD->pPC + sizeof(void*);

    pRD->Esp += (DWORD) GetNumCallerStackBytes();

#endif
}



//========================================================================
//  void StubLinkerCPU::EmitSEHProlog(LPVOID pvFrameHandler)
//  Prolog for setting up SEH for stubs that enter managed code from unmanaged
//  assumptions: esi has the current frame pointer
void StubLinkerCPU::EmitSEHProlog(LPVOID pvFrameHandler)
{
    // push UnmanagedToManagedExceptHandler
    X86EmitPushImm32((INT32)(size_t)pvFrameHandler); // function unmanaged
                                             // to managed handler

    // mov eax, fs:[0]
    static BYTE codeSEH1[] = { 0x64, 0xA1, 0x0, 0x0, 0x0, 0x0};
    EmitBytes(codeSEH1, sizeof(codeSEH1));
    // push eax
    X86EmitPushReg(kEAX);

    // mov dword ptr fs:[0], esp
    static BYTE codeSEH2[] = { 0x64, 0x89, 0x25, 0x0, 0x0, 0x0, 0x0};
    EmitBytes(codeSEH2, sizeof(codeSEH2));

}

//===========================================================================
//  void StubLinkerCPU::EmitUnLinkSEH(unsigned offset)
//  negOffset is the offset from the current frame where the next exception record
//  pointer is stored in the stack
//  for e.g. COM to managed frames the pointer to next SEH record is in the stack
//          after the ComMethodFrame::NegSpaceSize() + 4 ( address of handler)
//
//  also assumes ESI is pointing to the current frame
void StubLinkerCPU::EmitUnLinkSEH(unsigned offset)
{

    // mov ecx,[esi + offset]  ;;pointer to the next exception record
    X86EmitIndexRegLoad(kECX, kESI, offset);
    // mov dword ptr fs:[0], ecx
    static BYTE codeSEH[] = { 0x64, 0x89, 0x0D, 0x0, 0x0, 0x0, 0x0 };
    EmitBytes(codeSEH, sizeof(codeSEH));

}

//========================================================================
//  voidStubLinkerCPU::EmitComMethodStubProlog()
//  Prolog for entering managed code from COM
//  pushes the appropriate frame ptr
//  sets up a thread and returns a label that needs to be emitted by the caller
void StubLinkerCPU::EmitComMethodStubProlog(LPVOID pFrameVptr,
                                            CodeLabel** rgRareLabels,
                                            CodeLabel** rgRejoinLabels,
                                            LPVOID pSEHHandler,
                                            BOOL bShouldProfile)
{
    _ASSERTE(rgRareLabels != NULL);
    _ASSERTE(rgRareLabels[0] != NULL && rgRareLabels[1] != NULL && rgRareLabels[2] != NULL);
    _ASSERTE(rgRejoinLabels != NULL);
    _ASSERTE(rgRejoinLabels[0] != NULL && rgRejoinLabels[1] != NULL && rgRejoinLabels[2] != NULL);

    // push edx ;leave room for m_next (edx is an arbitrary choice)
    X86EmitPushReg(kEDX);

    // push IMM32 ; push Frame vptr
    X86EmitPushImm32((UINT32)(size_t)pFrameVptr);

    // push ebp     ;; save callee-saved register
    // push ebx     ;; save callee-saved register
    // push esi     ;; save callee-saved register
    // push edi     ;; save callee-saved register
    X86EmitPushReg(kEBP);
    X86EmitPushReg(kEBX);
    X86EmitPushReg(kESI);
    X86EmitPushReg(kEDI);

    // lea esi, [esp+0x10]  ;; set ESI -> new frame
    static BYTE code10[] = {0x8d, 0x74, 0x24, 0x10 };
    EmitBytes(code10 ,sizeof(code10));

#ifdef _DEBUG

    //======================================================================
    // Under DEBUG, set up just enough of a standard C frame so that
    // the VC debugger can stacktrace through stubs.
    //======================================================================


    //  mov eax, [esi+Frame.retaddr]
    static BYTE code20[] = {0x8b, 0x44, 0x24};
    EmitBytes(code20, sizeof(code20));
    Emit8(UnmanagedToManagedFrame::GetOffsetOfReturnAddress());

    //  push eax        ;; push return address
    //  push ebp        ;; push previous ebp
    X86EmitPushReg(kEAX);
    X86EmitPushReg(kEBP);

    // mov ebp,esp
    Emit8(0x8b);
    Emit8(0xec);


#endif

    // Emit Setup thread
    X86EmitSetup(rgRareLabels[0]);  // rareLabel for rare setup
    EmitLabel(rgRejoinLabels[0]); // rejoin label for rare setup

    // push auxilary information

    // xor eax, eax
    static BYTE b2[] = { 0x33, 0xC0 };
    EmitBytes(b2, sizeof (b2));

    // push eax ;push NULL for protected Marshalers
    X86EmitPushReg(kEAX);

    // push eax ;push null for GC flag
    X86EmitPushReg(kEAX);

    // push eax ;push null for ptr to args
    X86EmitPushReg(kEAX);

    // push eax ;push NULL for pReturnDomain
    X86EmitPushReg(kEAX);

    // push eax ;push NULL for CleanupWorkList->m_pnode
    X86EmitPushReg(kEAX);

    //-----------------------------------------------------------------------
    // Generate the inline part of disabling preemptive GC.  It is critical
    // that this part happen before we link in the frame.  That's because
    // we won't be able to unlink the frame from preemptive mode.  And during
    // shutdown, we cannot switch to cooperative mode under some circumstances
    //-----------------------------------------------------------------------
    EmitDisable(rgRareLabels[1]);        // rare disable gc
    EmitLabel(rgRejoinLabels[1]);        // rejoin for rare disable gc

     // mov edi,[ebx + Thread.GetFrame()]  ;; get previous frame
    X86EmitIndexRegLoad(kEDI, kEBX, Thread::GetOffsetOfCurrentFrame());

    // mov [esi + Frame.m_next], edi
    X86EmitIndexRegStore(kESI, Frame::GetOffsetOfNextLink(), kEDI);

    // mov [ebx + Thread.GetFrame()], esi
    X86EmitIndexRegStore(kEBX, Thread::GetOffsetOfCurrentFrame(), kESI);

#if _DEBUG
        // call LogTransition
    X86EmitPushReg(kESI);
    X86EmitCall(NewExternalCodeLabel(Frame::LogTransition), 4);
#endif

    if (pSEHHandler)
    {
        EmitSEHProlog(pSEHHandler);
    }

#ifdef PROFILING_SUPPORTED
    // If profiling is active, emit code to notify profiler of transition
    // Must do this before preemptive GC is disabled, so no problem if the
    // profiler blocks.
    if (CORProfilerTrackTransitions() && bShouldProfile)
    {
        EmitProfilerComCallProlog(pFrameVptr, /*Frame*/ kESI);
    }
#endif // PROFILING_SUPPORTED
}


//========================================================================
//  void StubLinkerCPU::EmitEnterManagedStubEpilog(unsigned numStackBytes,
//                      CodeLabel** rgRareLabels, CodeLabel** rgRejoinLabels)
//  Epilog for stubs that enter managed code from unmanaged
void StubLinkerCPU::EmitEnterManagedStubEpilog(LPVOID pFrameVptr, unsigned numStackBytes,
                        CodeLabel** rgRareLabel, CodeLabel** rgRejoinLabel,
                        BOOL bShouldProfile)
{
    _ASSERTE(rgRareLabel != NULL);
    _ASSERTE(rgRareLabel[0] != NULL && rgRareLabel[1] != NULL && rgRareLabel[2] != NULL);
    _ASSERTE(rgRejoinLabel != NULL);
    _ASSERTE(rgRejoinLabel[0] != NULL && rgRejoinLabel[1] != NULL && rgRejoinLabel[2] != NULL);

    // mov [ebx + Thread.GetFrame()], edi  ;; restore previous frame
    X86EmitIndexRegStore(kEBX, Thread::GetOffsetOfCurrentFrame(), kEDI);

    //-----------------------------------------------------------------------
    // Generate the inline part of disabling preemptive GC
    //-----------------------------------------------------------------------
    EmitEnable(rgRareLabel[2]); // rare gc
    EmitLabel(rgRejoinLabel[2]);        // rejoin for rare gc

#ifdef PROFILING_SUPPORTED
    // If profiling is active, emit code to notify profiler of transition
    if (CORProfilerTrackTransitions() && bShouldProfile)
    {
        EmitProfilerComCallEpilog(pFrameVptr, kESI);
    }
#endif // PROFILING_SUPPORTED

    #ifdef _DEBUG
        // add esp, SIZE VC5Frame     ;; pop the stacktrace info for VC5
        X86EmitAddEsp(sizeof(VC5Frame));
    #endif

    // pop edi        ; restore callee-saved registers
    // pop esi
    // pop ebx
    // pop ebp
    X86EmitPopReg(kEDI);
    X86EmitPopReg(kESI);
    X86EmitPopReg(kEBX);
    X86EmitPopReg(kEBP);

    // add esp,popstack     ; deallocate frame + MethodDesc
    unsigned popStack = sizeof(Frame) + sizeof(MethodDesc*);
    X86EmitAddEsp(popStack);

    //retn n
    X86EmitReturn(numStackBytes);

    //-----------------------------------------------------------------------
    // The out-of-line portion of enabling preemptive GC - rarely executed
    //-----------------------------------------------------------------------
    EmitLabel(rgRareLabel[2]);  // label for rare enable gc
    EmitRareEnable(rgRejoinLabel[2]); // emit rare enable gc

    //-----------------------------------------------------------------------
    // The out-of-line portion of disabling preemptive GC - rarely executed
    //-----------------------------------------------------------------------
    EmitLabel(rgRareLabel[1]);  // label for rare disable gc
    EmitRareDisable(rgRejoinLabel[1], /*bIsCallIn=*/TRUE); // emit rare disable gc

    //-----------------------------------------------------------------------
    // The out-of-line portion of setup thread - rarely executed
    //-----------------------------------------------------------------------
    EmitLabel(rgRareLabel[0]);  // label for rare setup thread
    EmitRareSetup(rgRejoinLabel[0]); // emit rare setup thread
}

//========================================================================
//  Epilog for stubs that enter managed code from COM
//
void StubLinkerCPU::EmitSharedComMethodStubEpilog(LPVOID pFrameVptr,
                                                  CodeLabel** rgRareLabel,
                                                  CodeLabel** rgRejoinLabel,
                                                  unsigned offsetRetThunk,
                                                  BOOL bShouldProfile)
{
    _ASSERTE(rgRareLabel != NULL);
    _ASSERTE(rgRareLabel[0] != NULL && rgRareLabel[1] != NULL && rgRareLabel[2] != NULL);
    _ASSERTE(rgRejoinLabel != NULL);
    _ASSERTE(rgRejoinLabel[0] != NULL && rgRejoinLabel[1] != NULL && rgRejoinLabel[2] != NULL);

    CodeLabel *NoEntryLabel;
    NoEntryLabel = NewCodeLabel();

    // unlink SEH
    EmitUnLinkSEH(0-(ComMethodFrame::GetNegSpaceSize()+8));

    // mov [ebx + Thread.GetFrame()], edi  ;; restore previous frame
    X86EmitIndexRegStore(kEBX, Thread::GetOffsetOfCurrentFrame(), kEDI);

    //-----------------------------------------------------------------------
    // Generate the inline part of enabling preemptive GC
    //-----------------------------------------------------------------------
    EmitEnable(rgRareLabel[2]);     // rare enable gc
    EmitLabel(rgRejoinLabel[2]);        // rejoin for rare enable gc

#ifdef PROFILING_SUPPORTED
    // If profiling is active, emit code to notify profiler of transition
    if (CORProfilerTrackTransitions() && bShouldProfile)
    {
        EmitProfilerComCallEpilog(pFrameVptr, kESI);
    }
#endif // PROFILING_SUPPORTED

    EmitLabel(NoEntryLabel);

    // reset esp
    // lea esp,[esi - PLATFORM_FRAME_ALIGN(sizeof(CalleeSavedRegisters) + VC5FRAME_SIZE)]
    X86EmitOffsetModRM(0x8d, (X86Reg)4 /*kESP*/, kESI, 0-PLATFORM_FRAME_ALIGN(sizeof(CalleeSavedRegisters) + VC5FRAME_SIZE));

    #ifdef _DEBUG
        // add esp, SIZE VC5Frame     ;; pop the stacktrace info for VC5
        X86EmitAddEsp(sizeof(VC5Frame));
    #endif

    // pop edi        ; restore callee-saved registers
    // pop esi
    // pop ebx
    // pop ebp
    X86EmitPopReg(kEDI);
    X86EmitPopReg(kESI);
    X86EmitPopReg(kEBX);
    X86EmitPopReg(kEBP);

    // add esp,12     ; deallocate frame
    X86EmitAddEsp(sizeof(Frame));

    // pop ecx
    X86EmitPopReg(kECX); // pop the MethodDesc*

    BYTE b[] = { 0x81, 0xC1 };
    // add ecx, offsetRetThunk
    EmitBytes(b, sizeof(b));
    Emit32(offsetRetThunk);

    // jmp ecx
    static BYTE bjmpecx[] = { 0xff, 0xe1 };
    EmitBytes(bjmpecx, sizeof(bjmpecx));

    //-----------------------------------------------------------------------
    // The out-of-line portion of enabling preemptive GC - rarely executed
    //-----------------------------------------------------------------------
    EmitLabel(rgRareLabel[2]);  // label for rare enable gc
    EmitRareEnable(rgRejoinLabel[2]); // emit rare enable gc

    //-----------------------------------------------------------------------
    // The out-of-line portion of disabling preemptive GC - rarely executed
    //-----------------------------------------------------------------------
    EmitLabel(rgRareLabel[1]);  // label for rare disable gc
    EmitRareDisableHRESULT(rgRejoinLabel[1], NoEntryLabel);

    //-----------------------------------------------------------------------
    // The out-of-line portion of setup thread - rarely executed
    //-----------------------------------------------------------------------
    EmitLabel(rgRareLabel[0]);  // label for rare setup thread
    EmitRareSetup(rgRejoinLabel[0]); // emit rare setup thread
}

//========================================================================
//  Epilog for stubs that enter managed code from COM
//
void StubLinkerCPU::EmitComMethodStubEpilog(LPVOID pFrameVptr,
                                            unsigned numStackBytes,
                                            CodeLabel** rgRareLabels,
                                            CodeLabel** rgRejoinLabels,
                                            LPVOID pSEHHandler,
                                            BOOL bShouldProfile)
{
    if (!pSEHHandler)
    {
        X86EmitAddEsp(sizeof(ComMethodFrame::NegInfo));
    }
    else
    {
        // oh well, if we are using exceptions, unlink the SEH and
        // just reset the esp to where EnterManagedStubEpilog likes it to be

                // unlink SEH
                EmitUnLinkSEH(0-(ComMethodFrame::GetNegSpaceSize()+8));

        // reset esp
        // lea esp,[esi - PLATFORM_FRAME_ALIGN(sizeof(CalleeSavedRegisters) + VC5FRAME_SIZE)]
        X86EmitOffsetModRM(0x8d, (X86Reg)4 /*kESP*/, kESI, 0-PLATFORM_FRAME_ALIGN(sizeof(CalleeSavedRegisters) + VC5FRAME_SIZE));
    }

    EmitEnterManagedStubEpilog(pFrameVptr, numStackBytes,
                              rgRareLabels, rgRejoinLabels, bShouldProfile);
}



/*
    If you make any changes to the prolog instruction sequence, be sure
    to update UpdateRegdisplay, too!!  This service should only be called from
    within the runtime.  It should not be called for any unmanaged -> managed calls in.
*/
VOID StubLinkerCPU::EmitMethodStubProlog(LPVOID pFrameVptr)
{
    THROWSCOMPLUSEXCEPTION();

    // push edx ;leave room for m_next (edx is an arbitrary choice)
    X86EmitPushReg(kEDX);

    // push Frame vptr
    X86EmitPushImm32((UINT)(size_t)pFrameVptr);

    // push ebp     ;; save callee-saved register
    // push ebx     ;; save callee-saved register
    // push esi     ;; save callee-saved register
    // push edi     ;; save callee-saved register
    X86EmitPushReg(kEBP);
    X86EmitPushReg(kEBX);
    X86EmitPushReg(kESI);
    X86EmitPushReg(kEDI);

    // lea esi, [esp+0x10]  ;; set ESI -> new frame
    static BYTE code10[] = {0x8d, 0x74, 0x24, 0x10 };
    EmitBytes(code10 ,sizeof(code10));

#ifdef _DEBUG

    //======================================================================
    // Under DEBUG, set up just enough of a standard C frame so that
    // the VC debugger can stacktrace through stubs.
    //======================================================================

    //  push dword ptr [esi+Frame.retaddr]
    X86EmitIndexPush(kESI, FramedMethodFrame::GetOffsetOfReturnAddress());

    //  push ebp
    X86EmitPushReg(kEBP);

    // mov ebp,esp
    Emit8(0x8b);
    Emit8(0xec);


#endif


    // Push & initialize ArgumentRegisters
#define DEFINE_ARGUMENT_REGISTER(regname) X86EmitPushReg(k##regname);
#include "eecallconv.h"

    // ebx <-- GetThread()
    X86EmitCurrentThreadFetch();

#if _DEBUG
        // call ObjectRefFlush
    X86EmitPushReg(kEBX);
    X86EmitCall(NewExternalCodeLabel(Thread::ObjectRefFlush), 4);
#endif

    // mov edi,[ebx + Thread.GetFrame()]  ;; get previous frame
    X86EmitIndexRegLoad(kEDI, kEBX, Thread::GetOffsetOfCurrentFrame());

    // mov [esi + Frame.m_next], edi
    X86EmitIndexRegStore(kESI, Frame::GetOffsetOfNextLink(), kEDI);

    // mov [ebx + Thread.GetFrame()], esi
    X86EmitIndexRegStore(kEBX, Thread::GetOffsetOfCurrentFrame(), kESI);

#if _DEBUG
        // call LogTransition
    X86EmitPushReg(kESI);
    X86EmitCall(NewExternalCodeLabel(Frame::LogTransition), 4);
#endif

    // OK for the debugger to examine the new frame now
    // (Note that if it's not OK yet for some stub, another patch label
    // can be emitted later which will override this one.)
    EmitPatchLabel();
}

VOID StubLinkerCPU::EmitMethodStubEpilog(__int16 numArgBytes, StubStyle style,
                                         __int16 shadowStackArgBytes)
{

    THROWSCOMPLUSEXCEPTION();

    _ASSERTE(style == kNoTripStubStyle ||
             style == kObjectStubStyle ||
             style == kScalarStubStyle ||
             style == kInteriorPointerStubStyle ||
             style == kInterceptorStubStyle);        // the only ones this code knows about.

    CodeLabel *labelStubTripped = NULL;
    CodeLabel *labelStubTrippedReturn = NULL;
    if (style != kNoTripStubStyle && style != kInterceptorStubStyle) {

        labelStubTripped = NewCodeLabel();

#ifdef _DEBUG
        CodeLabel *labelContinue = NewCodeLabel();

        // Make sure that the thread is in the correct GC mode as we unwind.  (Catch
        // bugs in JIT helpers, etc).
        // test byte ptr [ebx + Thread.m_fPreemptiveGCDisabled], TRUE
        Emit16(0x43f6);
        Emit8(Thread::GetOffsetOfGCFlag());
        Emit8(1);

        X86EmitCondJump(labelContinue, X86CondCode::kJNZ);

        Emit8(0xCC);        // int 3 -- poor man's assertion

        EmitLabel(labelContinue);
#endif

        // test byte ptr [ebx + Thread.m_State], TS_CatchAtSafePoint
        _ASSERTE(FitsInI1(Thread::TS_CatchAtSafePoint));
        Emit16(0x43f6);
        Emit8(Thread::GetOffsetOfState());
        Emit8(Thread::TS_CatchAtSafePoint);

        X86EmitCondJump(labelStubTripped, X86CondCode::kJNZ);
        labelStubTrippedReturn = EmitNewCodeLabel();
    }

    // mov [ebx + Thread.GetFrame()], edi  ;; restore previous frame
    X86EmitIndexRegStore(kEBX, Thread::GetOffsetOfCurrentFrame(), kEDI);

    X86EmitAddEsp(ARGUMENTREGISTERS_SIZE + shadowStackArgBytes);

#ifdef _DEBUG
    // add esp, SIZE VC5Frame     ;; pop the stacktrace info for VC5
    X86EmitAddEsp(sizeof(VC5Frame));
#endif



    // pop edi        ; restore callee-saved registers
    // pop esi
    // pop ebx
    // pop ebp
    X86EmitPopReg(kEDI);
    X86EmitPopReg(kESI);
    X86EmitPopReg(kEBX);
    X86EmitPopReg(kEBP);


    if (numArgBytes == -1) {
        // This stub is called for methods with varying numbers of bytes on the
        // stack.  The correct number to pop is expected to now be sitting on
        // the stack.
        //
        // shift the retaddr & stored EDX:EAX return value down on the stack
        // and then toss the variable number of args pushed by the caller.
        // Of course, the slide must occur backwards.

        // add     esp,8                ; deallocate frame
        // pop     ecx                  ; scratch register gets delta to pop
        // push    eax                  ; running out of registers!
        // mov     eax, [esp+4]         ; get retaddr
        // mov     [esp+ecx+4], eax     ; put it where it belongs
        // pop     eax                  ; restore retval
        // add     esp, ecx             ; pop all the args
        // ret

        X86EmitAddEsp(sizeof(Frame));

        X86EmitPopReg(kECX);
        X86EmitPushReg(kEAX);

        static BYTE arbCode1[] = { 0x8b, 0x44, 0x24, 0x04, // mov eax, [esp+4]
                                   0x89, 0x44, 0x0c, 0x04, // mov [esp+ecx+4], eax
                                 };

        EmitBytes(arbCode1, sizeof(arbCode1));
        X86EmitPopReg(kEAX);

        static BYTE arbCode2[] = { 0x03, 0xe1,             // add esp, ecx
                                   0xc3,                   // ret
                                 };

        EmitBytes(arbCode2, sizeof(arbCode2));
    }
    else {
        _ASSERTE(numArgBytes >= 0);

        // add esp,12     ; deallocate frame + MethodDesc
        X86EmitAddEsp(sizeof(Frame) + sizeof(MethodDesc*));

        if(style != kInterceptorStubStyle) {

            X86EmitReturn(numArgBytes);

            if (style != kNoTripStubStyle) {
                EmitLabel(labelStubTripped);
                VOID *pvHijackAddr = 0;
                if (style == kObjectStubStyle)
                    pvHijackAddr = OnStubObjectTripThread;
                else if (style == kScalarStubStyle)
                    pvHijackAddr = OnStubScalarTripThread;
                else if (style == kInteriorPointerStubStyle)
                    pvHijackAddr = OnStubInteriorPointerTripThread;
                else
                    _ASSERTE(!"Unknown stub style");
                X86EmitCall(NewExternalCodeLabel(pvHijackAddr), 0);  // in CE pop no args to pop
                X86EmitNearJump(labelStubTrippedReturn);
            }
        }
    }
}


//----------------------------------------------------------------
//
// VOID StubLinkerCPU::EmitSharedMethodStubEpilog(StubStyle style,
//                                                unsigned offsetRetThunk)
//              shared epilog, uses a return thunk within the methoddesc
//--------------------------------------------------------------------
VOID StubLinkerCPU::EmitSharedMethodStubEpilog(StubStyle style,
                                               unsigned offsetRetThunk)
{
    THROWSCOMPLUSEXCEPTION();

        // mov [ebx + Thread.GetFrame()], edi  ;; restore previous frame
    X86EmitIndexRegStore(kEBX, Thread::GetOffsetOfCurrentFrame(), kEDI);


    X86EmitAddEsp(ARGUMENTREGISTERS_SIZE); // pop off argument registers

#ifdef _DEBUG
    // add esp, SIZE VC5Frame     ;; pop the stacktrace info for VC5
    X86EmitAddEsp(sizeof(VC5Frame));
#endif

    // pop edi        ; restore callee-saved registers
    // pop esi
    // pop ebx
    // pop ebp
    X86EmitPopReg(kEDI);
    X86EmitPopReg(kESI);
    X86EmitPopReg(kEBX);
    X86EmitPopReg(kEBP);

        // add esp,12     ; deallocate frame
    X86EmitAddEsp(sizeof(Frame));
        // pop ecx
        X86EmitPopReg(kECX); // pop the MethodDesc*

        BYTE b[] = { 0x81, 0xC1 };
        // add ecx, offsetRetThunk
        EmitBytes(b, sizeof(b));
        Emit32(offsetRetThunk);

        // jmp ecx
        static BYTE bjmpecx[] = { 0xff, 0xe1 };
        EmitBytes(bjmpecx, sizeof(bjmpecx));
}


VOID StubLinkerCPU::EmitRareSetup(CodeLabel *pRejoinPoint)
{
    THROWSCOMPLUSEXCEPTION();

    X86EmitCall(NewExternalCodeLabel(CreateThreadBlock), 0);

    // mov ebx,eax
     Emit16(0xc389);
    X86EmitNearJump(pRejoinPoint);
}

//---------------------------------------------------------------
// Emit code to store the setup current Thread structure in eax.
// TRASHES  eax,ecx&edx.
// RESULTS  ebx = current Thread
//---------------------------------------------------------------
VOID StubLinkerCPU::X86EmitSetup(CodeLabel *pForwardRef)
{
    THROWSCOMPLUSEXCEPTION();
    DWORD idx = GetThreadTLSIndex();
    TLSACCESSMODE mode = GetTLSAccessMode(idx);


#ifdef _DEBUG
    {
        static BOOL f = TRUE;
        f = !f;
        if (f) {
           mode = TLSACCESS_GENERIC;
        }
    }
#endif

    switch (mode) {
        case TLSACCESS_X86_WNT: {
                unsigned __int32 tlsofs = WINNT_TLS_OFFSET + idx*4;

                // "mov ebx, fs:[OFS]
                static BYTE code[] = {0x64,0x8b,0x1d};
                EmitBytes(code, sizeof(code));
                Emit32(tlsofs);
            }
            break;

        case TLSACCESS_X86_W95: {
                // mov eax, fs:[2c]
                Emit16(0xa164);
                Emit32(WIN95_TLSPTR_OFFSET);

                // mov ebx, [eax+OFS]
                X86EmitIndexRegLoad(kEBX, kEAX, idx*4);


            }
            break;

        case TLSACCESS_GENERIC:
            X86EmitPushImm32(idx);

            // call TLSGetValue
            X86EmitCall(NewExternalCodeLabel(TlsGetValue), 4); // in CE pop 4 bytes or args after the call
            // mov ebx,eax
            Emit16(0xc389);
            break;
        default:
            _ASSERTE(0);
    }

  // cmp ebx, 0
   byte b[] = { 0x83, 0xFB, 0x0};

    EmitBytes(b, sizeof(b));

    // jz RarePath
    X86EmitCondJump(pForwardRef, X86CondCode::kJZ);

#ifdef _DEBUG
    X86EmitDebugTrashReg(kECX);
    X86EmitDebugTrashReg(kEDX);
#endif

}

// This method unboxes the THIS pointer and then calls pRealMD
#pragma warning(disable:4702)
VOID StubLinkerCPU::EmitUnboxMethodStub(MethodDesc* pUnboxMD)
{
    // unboxing a value class simply means adding 4 to the THIS pointer

    while(1)
    {
#define DEFINE_ARGUMENT_REGISTER(reg)  X86EmitAddReg(k##reg, 4); break;
#include "eecallconv.h"
    }

    // If it is an ECall, m_CodeOrIL does not reflect the correct address to
    // call to (which is an ECall stub).  Rather, it reflects the actual ECall
    // implementation.  Naturally, ECalls must always hit the stub first.
    // Along the same lines, perhaps the method isn't JITted yet.  The easiest
    // way to handle all this is to simply dispatch through the top of the MD.

    Emit8(0xB8);                                        // MOV EAX, pre stub call addr
    Emit32((__int32)(size_t) pUnboxMD - METHOD_CALL_PRESTUB_SIZE);
    Emit16(0xE0FF);                                     // JMP EAX
}
#pragma warning(default:4702)


//
// SecurityWrapper
//
// Wraps a real stub do some security work before the stub and clean up after. Before the
// real stub is called a security frame is added and declarative checks are performed. The
// Frame is added so declarative asserts and denies can be maintained for the duration of the
// real call. At the end the frame is simply removed and the wrapper cleans up the stack. The
// registers are restored.
//
VOID StubLinkerCPU::EmitSecurityWrapperStub(__int16 numArgBytes, MethodDesc* pMD, BOOL fToStub, LPVOID pRealStub, DeclActionInfo *pActions)
{
    THROWSCOMPLUSEXCEPTION();

    EmitMethodStubProlog(InterceptorFrame::GetMethodFrameVPtr());

    UINT32 negspacesize = InterceptorFrame::GetNegSpaceSize() -
                          FramedMethodFrame::GetNegSpaceSize();

    // make room for negspace fields of IFrame
    X86EmitSubEsp(negspacesize);

    // push method descriptor for DoDeclaritiveSecurity(MethodDesc*, InterceptorFrame*);
    X86EmitPushReg(kESI);            // push esi (push new frame as ARG)

    X86EmitPushImm32((UINT)(size_t)pActions);

    X86EmitPushImm32((UINT)(size_t)pMD);

#ifdef _DEBUG
    // push IMM32 ; push SecurityMethodStubWorker
    X86EmitPushImm32((UINT)(size_t)DoDeclarativeSecurity);

    X86EmitCall(NewExternalCodeLabel(WrapCall), 12); // in CE pop 4 bytes or args after the call
#else
    X86EmitCall(NewExternalCodeLabel(DoDeclarativeSecurity), 12); // in CE pop 4 bytes or args after the call
#endif

    // Copy the arguments, calculate the offset
    //     terminology:  opt.          - Optional
    //                   Sec. Desc.    - Security Descriptor
    //                   desc          - Descriptor
    //                   rtn           - Return
    //                   addr          - Address
    //
    //          method desc    <-- copied from below
    //         ------------
    //           rtn addr      <-- points back into the wrapper stub
    //         ------------
    //            copied       <-- copied from below
    //             args
    //         ------------   -|
    //          Sec. Desc      |
    //         ------------   -|
    //          Arg. Registers |
    //         ------------   -|
    //          S. Stack Ptr   |
    //         ------------   -|
    //             EBP (opt.)  |
    //             EAX (opt.)  |
    //         ------------    |- Security Negitive Space (for frame)
    //             EDI         |
    //             ESI         |
    //             EBX         |
    //             EBP         |
    //         ------------ -----                -
    //            vtable                         |
    //         ------------                      |
    //            next                           |-- Security Frame
    //         ------------   --                 |
    //          method desc    |                 |
    //         ------------    |                 |
    //           rtn addr <-|  |--Original Stack |
    //         ------------ |  |                 -
    //         | original | |  :
    //         |  args    | |
    //                      ------- Points to the real return addr.
    //
    //
    //

    // Offset from original args to new args. (see above). We are copying from
    // the bottom of the stack to top. The offset is calculated to repush the
    // the arguments on the stack.
    //
    // offset = Negitive Space + return addr + method des + next + vtable + size of args - 4
    // The 4 is subtracted because the esp is one slot below the start of the copied args.
    UINT32 offset = InterceptorFrame::GetNegSpaceSize() + sizeof(InterceptorFrame) - 4 + numArgBytes;

    // Convert bytes to number of slots
    int args  = numArgBytes >> 2;

    // Emit the required number of pushes to copy the arguments
    while(args) {
        X86EmitSPIndexPush(offset);
        args--;
    }

    // Add a jmp to the main call, this adds our current EIP+4 to the stack
    CodeLabel* mainCall;
    mainCall = NewCodeLabel();
    X86EmitCall(mainCall, 0);

    // Jump past the call into the real stub we have already been there
    // The return addr into the stub points to this jump statement
    //
    // @TODO: remove the jump and push return method desc then the return addr.
    CodeLabel* continueCall;
    continueCall = NewCodeLabel();
    X86EmitNearJump(continueCall);

    // Main Call label attached to the real stubs call
    EmitLabel(mainCall);

    // push the address of the method descriptor for the interpreted case only
    //  push dword ptr [esp+offset] and add four bytes for that case
    if(fToStub) {
        X86EmitSPIndexPush(offset);
        offset += 4;
    }

    // Set up for arguments in stack, offset is 8 bytes below base of frame.
    // Call GetOffsetOfArgumentRegisters to move back from base of frame
    offset = offset - 8 + InterceptorFrame::GetOffsetOfArgumentRegisters();

    // Move to the last register in the space used for registers
    offset += NUM_ARGUMENT_REGISTERS * sizeof(UINT32) - 4;

    // Push the args on the stack, as esp is incremented and the
    // offset stays the same all the register values are pushed on
    // the correct registers
    for(int i = 0; i < NUM_ARGUMENT_REGISTERS; i++)
        X86EmitSPIndexPush(offset);

    // This generates the appropriate pops into the registers specified in eecallconv.h
#define DEFINE_ARGUMENT_REGISTER_BACKWARD(regname) X86EmitPopReg(k##regname);
#include "eecallconv.h"

    // Add a jump to the real stub, we will return to
    // the jump statement added  above
    X86EmitNearJump(NewExternalCodeLabel(pRealStub));

    // we will continue on past the real stub
    EmitLabel(continueCall);

    // deallocate negspace fields of IFrame
    X86EmitAddEsp(negspacesize);

    // Return poping of the same number of bytes that
    // the real stub would have popped.
    EmitMethodStubEpilog(numArgBytes, kNoTripStubStyle);
}

//
// Security Filter, if no security frame is required because there are no declarative asserts or denies
// then the arguments do not have to be copied. This interceptor creates a temporary Security frame
// calls the declarative security return, cleans up the stack to the same state when the inteceptor
// was called and jumps into the real routine.
//
VOID StubLinkerCPU::EmitSecurityInterceptorStub(MethodDesc* pMD, BOOL fToStub, LPVOID pRealStub, DeclActionInfo *pActions)
{
    THROWSCOMPLUSEXCEPTION();

    if (pMD->IsComPlusCall())
    {
        // Generate label where non-remoting code will start executing
        CodeLabel *pPrologStart = NewCodeLabel();

        // mov eax, [ecx]
        X86EmitIndexRegLoad(kEAX, kECX, 0);

        // cmp eax, CTPMethodTable::s_pThunkTable
        Emit8(0x3b);
        Emit8(0x05);
        Emit32((DWORD)(size_t)CTPMethodTable::GetMethodTableAddr());

        // jne pPrologStart
        X86EmitCondJump(pPrologStart, X86CondCode::kJNE);

        // Add a jump to the real stub thus bypassing the security stack walk
        X86EmitNearJump(NewExternalCodeLabel(pRealStub));

        // emit label for non remoting case
        EmitLabel(pPrologStart);
    }

    EmitMethodStubProlog(InterceptorFrame::GetMethodFrameVPtr());

    UINT32 negspacesize = InterceptorFrame::GetNegSpaceSize() -
                          FramedMethodFrame::GetNegSpaceSize();

    // make room for negspace fields of IFrame
    X86EmitSubEsp(negspacesize);

    // push method descriptor for DoDeclaritiveSecurity(MethodDesc*, InterceptorFrame*);
    X86EmitPushReg(kESI);            // push esi (push new frame as ARG)
    X86EmitPushImm32((UINT)(size_t)pActions);
    X86EmitPushImm32((UINT)(size_t)pMD);

#ifdef _DEBUG
    // push IMM32 ; push SecurityMethodStubWorker
    X86EmitPushImm32((UINT)(size_t)DoDeclarativeSecurity);
    X86EmitCall(NewExternalCodeLabel(WrapCall), 12); // in CE pop 4 bytes or args after the call
#else
    X86EmitCall(NewExternalCodeLabel(DoDeclarativeSecurity), 12); // in CE pop 4 bytes or args after the call
#endif

    // Prototype for: push dword ptr[esp + offset], The last number will be the offset
    // At this point the esp should be pointing at top of the Interceptor frame
    UINT32 offset = InterceptorFrame::GetNegSpaceSize()+InterceptorFrame::GetOffsetOfArgumentRegisters() - 4;

    // Get the number arguments stored in registers. For now we are doing the
    // stupid approach of saving off all the registers and then poping them off.
    // This needs to be cleaned up for the real stubs or when CallDescr is done
    // correctly
    offset += NUM_ARGUMENT_REGISTERS * sizeof(UINT32);

    // Push the args on the stack and then pop them into
    // the correct registers
    for(int i = 0; i < NUM_ARGUMENT_REGISTERS; i++)
        X86EmitSPIndexPush(offset);

    // This generates the appropriate pops into the registers specified in eecallconv.h
#define DEFINE_ARGUMENT_REGISTER_BACKWARD(regname) X86EmitPopReg(k##regname);
#include "eecallconv.h"

    // Clean up security frame, this rips off the MD and gets the real return addr at the top of the stack
    X86EmitAddEsp(negspacesize);
    EmitMethodStubEpilog(0, kInterceptorStubStyle);

    // Add the phoney return address back on the stack so the real
    // stub can ignore it also.
    if(fToStub)
        X86EmitSubEsp(4);

    // Add a jump to the real stub
    X86EmitNearJump(NewExternalCodeLabel(pRealStub));
}



#ifdef _DEBUG
//---------------------------------------------------------------
// Emits:
//     mov <reg32>,0xcccccccc
//---------------------------------------------------------------
VOID StubLinkerCPU::X86EmitDebugTrashReg(X86Reg reg)
{
    THROWSCOMPLUSEXCEPTION();
    Emit8(0xb8|reg);
    Emit32(0xcccccccc);
}
#endif //_DEBUG



//===========================================================================
// Emits code to repush the original arguments in the virtual calling
// convention format.
VOID StubLinkerCPU::EmitShadowStack(MethodDesc *pMD)
{
    THROWSCOMPLUSEXCEPTION();

    MetaSig Sig(pMD->GetSig(),
                pMD->GetModule());
    ArgIterator argit(NULL, &Sig, pMD->IsStatic());
    int ofs;
    BYTE typ;
    UINT32 structSize;

    if (Sig.HasRetBuffArg()) {
        X86EmitIndexPush(kESI, argit.GetRetBuffArgOffset());
    }

    while (0 != (ofs = argit.GetNextOffset(&typ, &structSize))) {
        UINT cb = StackElemSize(structSize);
        _ASSERTE(0 == (cb % 4));
        while (cb) {
            cb -= 4;
            X86EmitIndexPush(kESI, ofs + cb);
        }
    }

    if (!(pMD->IsStatic())) {
        X86EmitIndexPush(kESI, argit.GetThisOffset());
    }
}

Thread* __stdcall CreateThreadBlock()
{
    //@todo fix this
        // This means that a thread is FIRST coming in from outside the EE.
        // There are a set of steps we need to do:
        // 1.  Setup the thread.
        // 2.  Send a notification that the EE has loaded. (if we haven't already).
        // 3.  Tell our outside consumers that the thread is first entering
        //     the EE, so that they can do appropriate work (set the URT half
        //     of the context, etc.
        Thread* pThread = SetupThread();
        if(pThread == NULL) return(pThread);

    return pThread;
}
#endif


// This hack handles arguments as an array of __int64's
INT64 MethodDesc::CallDescr(const BYTE *pTarget, Module *pModule, PCCOR_SIGNATURE pSig, BOOL fIsStatic, const __int64 *pArguments)
{
    MetaSig sig(pSig, pModule);
    return MethodDesc::CallDescr (pTarget, pModule, &sig, fIsStatic, pArguments);
}

INT64 MethodDesc::CallDescr(const BYTE *pTarget, Module *pModule, MetaSig* pMetaSigOrig, BOOL fIsStatic, const __int64 *pArguments)
{
    THROWSCOMPLUSEXCEPTION();

    // Make local copy as this function mutates iterator state.
    MetaSig msigCopy = pMetaSigOrig;
    MetaSig *pMetaSig = &msigCopy;


    _ASSERTE(GetAppDomain()->ShouldHaveCode());

#ifdef _DEBUG
    {
        // Check to see that any value type args have been restored.
        // This is because we may be calling a FramedMethodFrame which will use the sig
        // to trace the args, but if any are unloaded we will be stuck if a GC occurs.

        _ASSERTE(GetMethodTable()->IsRestored());
        CorElementType argType;
        while ((argType = pMetaSig->NextArg()) != ELEMENT_TYPE_END)
        {
            if (argType == ELEMENT_TYPE_VALUETYPE)
            {
                TypeHandle th = pMetaSig->GetTypeHandle(NULL, TRUE, TRUE);
                _ASSERTE(th.IsRestored());
            }
        }
        pMetaSig->Reset();
    }
#endif

    BYTE callingconvention = pMetaSig->GetCallingConvention();
    if (!isCallConv(callingconvention, IMAGE_CEE_CS_CALLCONV_DEFAULT))
    {
        _ASSERTE(!"This calling convention is not supported.");
        COMPlusThrow(kInvalidProgramException);
    }

#ifdef DEBUGGING_SUPPORTED
    if (CORDebuggerTraceCall())
        g_pDebugInterface->TraceCall(pTarget);
#endif // DEBUGGING_SUPPORTED

#if CHECK_APP_DOMAIN_LEAKS
    if (g_pConfig->AppDomainLeaks())
    {
        // See if we are in the correct domain to call on the object 
        if (!fIsStatic && !GetClass()->IsValueClass())
        {
            Object *pThis = *(Object**)&pArguments[0];
            if (pThis != NULL)
            {
                if (!pThis->AssignAppDomain(GetAppDomain()))
                    _ASSERTE(!"Attempt to call method on object in wrong domain");
            }
        }
    }
#endif

    DWORD   NumArguments = pMetaSig->NumFixedArgs();
        DWORD   arg = 0;

    UINT   nActualStackBytes = pMetaSig->SizeOfActualFixedArgStack(fIsStatic);

    // Create a fake FramedMethodFrame on the stack.
    LPBYTE pAlloc = (LPBYTE)_alloca(FramedMethodFrame::GetNegSpaceSize() + sizeof(FramedMethodFrame) + nActualStackBytes);

    LPBYTE pFrameBase = pAlloc + FramedMethodFrame::GetNegSpaceSize();

    if (!fIsStatic) {
        *((void**)(pFrameBase + FramedMethodFrame::GetOffsetOfThis())) = *((void **)&pArguments[arg++]);
    }

    UINT   nVirtualStackBytes = pMetaSig->SizeOfVirtualFixedArgStack(fIsStatic);
    arg += NumArguments;

    ArgIterator argit(pFrameBase, pMetaSig, fIsStatic);
    if (pMetaSig->HasRetBuffArg()) {
        *((LPVOID*) argit.GetRetBuffArgAddr()) = *((LPVOID*)&pArguments[arg]);
    }

    BYTE   typ;
    UINT32 structSize;
    int    ofs;
    while (0 != (ofs = argit.GetNextOffsetFaster(&typ, &structSize))) {
                arg--;
        switch (StackElemSize(structSize)) {
            case 4:
                *((INT32*)(pFrameBase + ofs)) = *((INT32*)&pArguments[arg]);

#if CHECK_APP_DOMAIN_LEAKS
                // Make sure the arg is in the right app domain
                if (g_pConfig->AppDomainLeaks() && typ == ELEMENT_TYPE_CLASS)
                    if (!(*(Object**)&pArguments[arg])->AssignAppDomain(GetAppDomain()))
                        _ASSERTE(!"Attempt to pass object in wrong app domain to method");
#endif

                break;

            case 8:
                *((INT64*)(pFrameBase + ofs)) = pArguments[arg];
                break;

            default: {
                // Not defined how to spread a valueclass into 64-bit buckets!
                _ASSERTE(!"NYI");
            }

        }
    }
    INT64 retval;

    INSTALL_COMPLUS_EXCEPTION_HANDLER();
    retval = CallDescrWorker(pFrameBase + sizeof(FramedMethodFrame) + nActualStackBytes,
                             nActualStackBytes / STACK_ELEM_SIZE,
                             (ArgumentRegisters*)(pFrameBase + FramedMethodFrame::GetOffsetOfArgumentRegisters()),
                             (LPVOID)pTarget);
    UNINSTALL_COMPLUS_EXCEPTION_HANDLER();

    getFPReturn(pMetaSig->GetFPReturnSize(), retval);
    return retval;

}


#ifdef _DEBUG
//-------------------------------------------------------------------------
// This is a special purpose function used only by the stubs.
// IT TRASHES ESI SO IT CANNOT SAFELY BE CALLED FROM C.
//
// Whenever a DEBUG stub wants to call an external function,
// it should go through WrapCall. This is because VC's stack
// tracing expects return addresses to point to code sections.
//
// WrapCall uses ESI to keep track of the original return address.
// ESI is the register used to point to the current Frame by the stub
// prolog. It is not currently needed in the epilog, so we chose
// to sacrifice that one for WrapCall's use.
//-------------------------------------------------------------------------

#define WRAP_CALL_FUNCTION_RETURN_OFFSET 1 + 1 + 2

__declspec(naked)
VOID WrapCall(LPVOID pFunc)
{
    __asm{

        pop     esi           ;; pop off return address
        pop     eax           ;; pop off function to call
        call    eax           ;; call it
        push    esi
        mov     esi, 0xccccccccc
        retn

    }
}

void *GetWrapCallFunctionReturn()
{
    return (void *) (((BYTE *) WrapCall) + WRAP_CALL_FUNCTION_RETURN_OFFSET);
}

#endif _DEBUG


#ifdef _DEBUG

//-------------------------------------------------------------------------
// This is a function which checks the debugger stub tracing capability
// when calling out to unmanaged code.
//
// IF YOU SEE STRANGE ERRORS CAUSED BY THIS CODE, it probably means that
// you have changed some exit stub logic, and not updated the corresponding
// debugger helper routines.  The debugger helper routines need to be able
// to determine
//
//      (a) the unmanaged address called by the stub
//      (b) the return address which the unmanaged code will return to
//      (c) the size of the stack pushed by the stub
//
// This information is necessary to allow the COM+ debugger to hand off
// control properly to an unmanaged debugger & manage the boundary between
// managed & unmanaged code.
//
// These are in XXXFrame::GetUnmanagedCallSite. (Usually
// with some help from the stub linker for generated stubs.)
//-------------------------------------------------------------------------

static void *PerformExitFrameChecks()
{
    Thread *thread = GetThread();
    Frame *frame = thread->GetFrame();

    void *ip, *returnIP, *returnSP;
    frame->GetUnmanagedCallSite(&ip, &returnIP, &returnSP);

    _ASSERTE(*(void**)returnSP == returnIP);

    return ip;
}

__declspec(naked)
void Frame::CheckExitFrameDebuggerCallsWrap()
{
    __asm
    {
        push    ecx
        call    PerformExitFrameChecks
        pop     ecx
        pop     esi
        push    eax
        push    esi
        jmp WrapCall
    }
}

__declspec(naked)
void Frame::CheckExitFrameDebuggerCalls()
{
    __asm
    {
        push    ecx
        call PerformExitFrameChecks
        pop     ecx
        jmp eax
    }
}

#endif



//---------------------------------------------------------
// Invokes a function given an array of arguments.
//---------------------------------------------------------

// This is used by NDirectFrameGeneric::GetUnmanagedCallSite

#define NDIRECT_CALL_DLL_FUNCTION_RETURN_OFFSET \
        1 + 2 + 3 + 3 + 3 + 2 + 3 + 2 + 1 + 2 + 4 + 2 + 1 + 6

#ifdef _DEBUG
// Assembler apparently doesn't understand C++ static member function syntax
static void *g_checkExit = (void*) Frame::CheckExitFrameDebuggerCalls;
#endif

__declspec(naked)
INT64 __cdecl CallDllFunction(LPVOID pTarget, LPVOID pEndArguments, UINT32 numArgumentSlots, BOOL fThisCall)
{
    __asm{
        push    ebp
        mov     ebp, esp   ;; set up ebp frame because pTarget may be cdecl or stdcall
        mov     ecx, numArgumentSlots
        mov     eax, pEndArguments
        cmp     ecx, 0
        jz      endloop
doloop:
        sub     eax, 4
        push    dword ptr [eax]
        dec     ecx
        jnz     doloop
endloop:
        cmp     dword ptr fThisCall, 0
        jz      docall
        pop     ecx
docall:

#if _DEBUG
        // Call through debugger logic to make sure it works
        call    [g_checkExit]
#else
        call    pTarget
#endif

;; Return value in edx::eax. This function has to work for both
;; stdcall and cdecl targets so at this point, cannot assume
;; value of esp.

        leave
        retn
    }
}

UINT NDirect::GetCallDllFunctionReturnOffset()
{
    return NDIRECT_CALL_DLL_FUNCTION_RETURN_OFFSET;
}

/*static*/ void NDirect::CreateGenericNDirectStubSys(CPUSTUBLINKER *psl)
{
    _ASSERTE(sizeof(CleanupWorkList) == sizeof(LPVOID));

    // push 00000000    ;; pushes a CleanupWorkList.
    psl->X86EmitPushImm32(0);

    psl->X86EmitPushReg(kESI);       // push esi (push new frame as ARG)
    psl->X86EmitPushReg(kEBX);       // push ebx (push current thread as ARG)

#ifdef _DEBUG
    // push IMM32 ; push NDirectMethodStubWorker
    psl->X86EmitPushImm32((UINT)(size_t)NDirectGenericStubWorker);
    psl->X86EmitCall(psl->NewExternalCodeLabel(WrapCall), 8); // in CE pop 8 bytes or args on return from call
#else

    psl->X86EmitCall(psl->NewExternalCodeLabel(NDirectGenericStubWorker), 8); // in CE pop 8 bytes or args on return from call
#endif

    // Pop off cleanup worker
    psl->X86EmitAddEsp(sizeof(CleanupWorkList));

}


// Atomic bit manipulations, with and without the lock prefix.  We initialize
// all consumers to go through the appropriate service at startup.

// First, the Uniprocessor (UP) versions.
__declspec(naked) void __fastcall OrMaskUP(DWORD * const p, const int msk)
{
    __asm
    {
        _ASSERT_ALIGNED_4_X86(ecx);
        or      dword ptr [ecx], edx
        ret
    }
}


__declspec(naked) void __fastcall AndMaskUP(DWORD * const p, const int msk)
{
    __asm
    {
        _ASSERT_ALIGNED_4_X86(ecx);
        and     dword ptr [ecx], edx
        ret
    }

}

__declspec(naked) LONG __fastcall ExchangeUP(LONG * Target, LONG Value)
{
    __asm
    {
        _ASSERT_ALIGNED_4_X86(ecx);
        mov     eax, [ecx]          ; attempted comparand
retry:
        cmpxchg [ecx], edx
        jne     retry1              ; predicted NOT taken
        ret
retry1:
        jmp     retry
    }
}

__declspec(naked) LONG __fastcall ExchangeAddUP(LONG *Target, LONG Value)
{
    __asm
    {
        _ASSERT_ALIGNED_4_X86(ecx);
        xadd    [ecx], edx         ; Add Value to Taget
        mov     eax, edx           ; move result
        ret
    }
}

__declspec(naked) void * __fastcall CompareExchangeUP(void **Destination,
                                          void *Exchange,
                                          void *Comparand)
{
    __asm
    {
        _ASSERT_ALIGNED_4_X86(ecx);
        mov     eax, [esp+4]        ; Comparand
        cmpxchg [ecx], edx
        ret     4                   ; result in EAX
    }
}

__declspec(naked) LONG __fastcall IncrementUP(LONG *Target)
{
    __asm
    {
        _ASSERT_ALIGNED_4_X86(ecx);
        mov     eax, 1
        xadd    [ecx], eax
        inc     eax                 ; return prior value, plus 1 we added
        ret
    }
}

__declspec(naked) UINT64 __fastcall IncrementLongUP(UINT64 *Target)
{
	_asm
	{
		_ASSERT_ALIGNED_4_X86(ecx) 
		
		_UP_SPINLOCK_ENTER(iSpinLock)
		
		add		dword ptr [ecx], 1
		adc		dword ptr [ecx+4], 0
		mov		eax, [ecx]
		mov		edx, [ecx+4]
		
		_UP_SPINLOCK_EXIT(iSpinLock)
		
		ret
	}
}

__declspec(naked) LONG __fastcall DecrementUP(LONG *Target)
{
    __asm
    {
        _ASSERT_ALIGNED_4_X86(ecx);
        mov     eax, -1
        xadd    [ecx], eax
        dec     eax                 ; return prior value, less 1 we removed
        ret
    }
}


__declspec(naked) UINT64 __fastcall DecrementLongUP(UINT64 *Target)
{
	__asm
	{
		_ASSERT_ALIGNED_4_X86(ecx);

		_UP_SPINLOCK_ENTER(iSpinLock)
			
		sub		dword ptr [ecx], 1
		sbb		dword ptr [ecx+4], 0
		mov		eax, [ecx]
		mov		edx, [ecx+4]
		
		_UP_SPINLOCK_EXIT(iSpinLock)

		ret
	}
}


// Then the Multiprocessor (MP) versions
__declspec(naked) void __fastcall OrMaskMP(DWORD * const p, const int msk)
{
    __asm
    {
    _ASSERT_ALIGNED_4_X86(ecx);
    lock or     dword ptr [ecx], edx
    ret
    }
}

__declspec(naked) void __fastcall AndMaskMP(DWORD * const p, const int msk)
{
    __asm
    {
    _ASSERT_ALIGNED_4_X86(ecx);
    lock and    dword ptr [ecx], edx
    ret
    }
}

__declspec(naked) LONG __fastcall ExchangeMP(LONG * Target, LONG Value)
{
    __asm
    {
    _ASSERT_ALIGNED_4_X86(ecx);
    mov     eax, [ecx]          ; attempted comparand
retry:
    lock cmpxchg [ecx], edx
    jne     retry1              ; predicted NOT taken
    ret
retry1:
    jmp     retry
    }
}

__declspec(naked) void * __fastcall CompareExchangeMP(void **Destination,
                                          void *Exchange,
                                          void *Comparand)
{
    __asm
    {
         _ASSERT_ALIGNED_4_X86(ecx);
         mov     eax, [esp+4]        ; Comparand
    lock cmpxchg [ecx], edx
         ret     4                   ; result in EAX
    }
}

__declspec(naked) LONG __fastcall ExchangeAddMP(LONG *Target, LONG Value)
{
    __asm
    {
        _ASSERT_ALIGNED_4_X86(ecx);
   lock xadd    [ecx], edx         ; Add Value to Taget
        mov     eax, edx           ; move result
        ret
    }
}

__declspec(naked) LONG __fastcall IncrementMP(LONG *Target)
{
    __asm
    {
        _ASSERT_ALIGNED_4_X86(ecx);
        mov     eax, 1
   lock xadd    [ecx], eax
        inc     eax                 ; return prior value, plus 1 we added
        ret
    }
}

__declspec(naked) UINT64 __fastcall IncrementLongMP8b(UINT64 *Target)
{

	_asm
	{
		//@todo port - ensure 8 byte alignment
		//_ASSERT_ALIGNED_8_X86(ecx)

		_ASSERT_ALIGNED_4_X86(ecx)
		
		push	esi
		push	ebx
		mov		esi, ecx
		
		mov		edx, 0
		mov		eax, 0
		mov		ecx, 0
		mov		ebx, 1

		lock cmpxchg8b	[esi]
		jz		done
		
preempted:
		mov		ecx, edx
		mov		ebx, eax
		add		ebx, 1
		adc		ecx, 0

		lock cmpxchg8b	[esi]
		jnz		preempted

done:
		mov		edx, ecx
		mov		eax, ebx

		pop		ebx
		pop		esi
		ret
	}
}

__declspec(naked) UINT64 __fastcall IncrementLongMP(UINT64 *Target)
{
	_asm
	{
        _ASSERT_ALIGNED_4_X86(ecx);

		_MP_SPINLOCK_ENTER(iSpinLock)
		
		add		dword ptr [ecx], 1
		adc		dword ptr [ecx+4], 0
		mov		eax, [ecx]
		mov		edx, [ecx+4]
		
		_MP_SPINLOCK_EXIT(iSpinLock)
		
		ret
	}
}


__declspec(naked) LONG __fastcall DecrementMP(LONG *Target)
{
    __asm
    {
        _ASSERT_ALIGNED_4_X86(ecx);
        mov     eax, -1
   lock xadd    [ecx], eax
        dec     eax                 ; return prior value, less 1 we removed
        ret
    }
}

__declspec(naked) UINT64 __fastcall DecrementLongMP8b(UINT64 *Target)
{
	_asm
	{
		//@todo port - ensure 8 byte alignment
		//_ASSERT_ALIGNED_8_X86(ecx)

		_ASSERT_ALIGNED_4_X86(ecx)

		push	esi
		push	ebx
		mov		esi, ecx

		mov		edx, 0		
		mov		eax, 0
		mov		ecx, 0xffffffff
		mov		ebx, 0xffffffff

		lock cmpxchg8b	[esi]
		jz		done
		
preempted:
		mov		ecx, edx
		mov		ebx, eax
		sub		ebx, 1
		sbb		ecx, 0

		lock cmpxchg8b	[esi]
		jnz		preempted

done:
		mov		edx, ecx
		mov		eax, ebx

		pop		ebx
		pop		esi
		ret
	}

}

__declspec(naked) UINT64 __fastcall DecrementLongMP(UINT64 *Target)
{
	__asm
	{
        _ASSERT_ALIGNED_4_X86(ecx);

		_MP_SPINLOCK_ENTER(iSpinLock)
		
		sub		dword ptr [ecx], 1
		sbb		dword ptr [ecx+4], 0
		mov		eax, [ecx]
		mov		edx, [ecx+4]
	
		_MP_SPINLOCK_EXIT(iSpinLock)
		
		ret
	}
}



// Here's the support for the interlocked operations.  The external view of them is
// declared in util.hpp.

BitFieldOps FastInterlockOr = OrMaskUP;
BitFieldOps FastInterlockAnd = AndMaskUP;

XchgOps     FastInterlockExchange = ExchangeUP;
CmpXchgOps  FastInterlockCompareExchange = CompareExchangeUP;
XchngAddOps FastInterlockExchangeAdd = ExchangeAddUP;

IncDecOps   FastInterlockIncrement = IncrementUP;
IncDecOps   FastInterlockDecrement = DecrementUP;
IncDecLongOps	FastInterlockIncrementLong = IncrementLongUP; 
IncDecLongOps	FastInterlockDecrementLong = DecrementLongUP;

// Adjust the generic interlocked operations for any platform specific ones we
// might have.
void InitFastInterlockOps()
{
    SYSTEM_INFO     sysInfo;

    ::GetSystemInfo(&sysInfo);

        //@todo: These don't support the 386, so make a final decision.
    if (sysInfo.dwNumberOfProcessors != 1)
    {
        FastInterlockOr  = OrMaskMP;
        FastInterlockAnd = AndMaskMP;

        FastInterlockExchange = ExchangeMP;
        FastInterlockCompareExchange = CompareExchangeMP;
        FastInterlockExchangeAdd = ExchangeAddMP;

        FastInterlockIncrement = IncrementMP;
        FastInterlockDecrement = DecrementMP;

        if (ProcessorFeatures::SafeIsProcessorFeaturePresent(PF_COMPARE_EXCHANGE_DOUBLE, FALSE) && !(DbgRandomOnExe(0.9)))
		{
			FastInterlockIncrementLong = IncrementLongMP8b; 
			FastInterlockDecrementLong = DecrementLongMP8b;
		}
		else
		{
			FastInterlockIncrementLong = IncrementLongMP; 
			FastInterlockDecrementLong = DecrementLongMP;
		}
    }
}



//---------------------------------------------------------
// Handles failed HR's.
//---------------------------------------------------------
VOID __stdcall ThrowBecauseOfFailedHRWorker(ComPlusMethodFrame* pFrame, HRESULT hr)
{
    THROWSCOMPLUSEXCEPTION();

    _ASSERTE(pFrame != NULL);
    _ASSERTE(FAILED(hr));
    
    Thread * pThread = GetThread();
    _ASSERTE(pThread->GetFrame() == pFrame);
    
    //get method descriptor
    ComPlusCallMethodDesc *pMD = (ComPlusCallMethodDesc*)(pFrame->GetFunction());
    
    IErrorInfo *pErrInfo = NULL;

    //verify the method desc belongs to a complus call
    if(pMD->IsComPlusCall())
    {   
        // Retrieve the interface method table.
        MethodTable *pItfMT = pMD->GetInterfaceMethodTable();

        // get 'this'
        OBJECTREF oref = pFrame->GetThis(); 
        _ASSERTE(oref != NULL);

        // Get IUnknown pointer for this interface on this object
        IUnknown* pUnk =  ComPlusWrapper::InlineGetComIPFromWrapper(oref, pMD->GetInterfaceMethodTable());
        _ASSERTE(pUnk != NULL);

        // Check to see if the component supports error information for this interface.
        IID ItfIID;
        pItfMT->GetClass()->GetGuid(&ItfIID, TRUE);
        GetSupportedErrorInfo(pUnk, ItfIID, &pErrInfo);
    
        DWORD cbRef = SafeRelease(pUnk);
        LogInteropRelease(pUnk, cbRef, "IUnk to QI for ISupportsErrorInfo");
    }
    else
    {
        _ASSERTE(pMD->IsNDirect());
        if (GetErrorInfo(0, &pErrInfo) != S_OK)
            pErrInfo = NULL;
    }
    COMPlusThrowHR(hr, pErrInfo);
}

__declspec(naked)
VOID __stdcall ThrowBecauseOfFailedHr()
{
    __asm {
        push eax
        push esi
        call ThrowBecauseOfFailedHRWorker
    }
}


//---------------------------------------------------------
// Handles Cleanup for a standalone stub that returns a gcref
//---------------------------------------------------------
LPVOID STDMETHODCALLTYPE DoCleanupWithGcProtection(CleanupWorkList *pCleanup, OBJECTREF oref)
{
    LPVOID pvret;
    GCPROTECT_BEGIN(oref);
    pCleanup->Cleanup(FALSE);
    *(OBJECTREF*)&pvret = oref;
    GCPROTECT_END();
    return pvret;
}



//---------------------------------------------------------
// Handles system specfic portion of fully optimized NDirect stub creation
//
// Results:
//     TRUE     - was able to create a standalone asm stub (generated into
//                psl)
//     FALSE    - decided not to create a standalone asm stub due to
//                to the method's complexity. Stublinker remains empty!
//
//     COM+ exception - error - don't trust state of stublinker.
//---------------------------------------------------------
/*static*/ BOOL NDirect::CreateStandaloneNDirectStubSys(const MLHeader *pheader, CPUSTUBLINKER *psl, BOOL fDoComInterop)
{
    THROWSCOMPLUSEXCEPTION();

    CodeLabel *pOleCtxNull = 0;
    CodeLabel *pOleCtxInited = 0;

    // Must first scan the ML stream to see if this method qualifies for
    // a standalone stub. Can't wait until we start generating because we're
    // supposed to leave psl empty if we return FALSE.
    if (0 != (pheader->m_Flags & ~(MLHF_SETLASTERROR|MLHF_THISCALL|MLHF_64BITMANAGEDRETVAL|MLHF_64BITUNMANAGEDRETVAL|MLHF_MANAGEDRETVAL_TYPECAT_MASK|MLHF_UNMANAGEDRETVAL_TYPECAT_MASK|MLHF_NATIVERESULT))) {
        return FALSE;
    }


    int i;
    BOOL fNeedsCleanup = FALSE;
    const MLCode *pMLCode = pheader->GetMLCode();
    MLCode mlcode;
    while (ML_INTERRUPT != (mlcode = *(pMLCode++))) {
        switch (mlcode) {
            case ML_COPY4: //intentional fallthru
            case ML_COPY8: //intentional fallthru
            case ML_PINNEDUNISTR_C2N: //intentional fallthru
            case ML_BLITTABLELAYOUTCLASS_C2N:
            case ML_CBOOL_C2N:
            case ML_COPYPINNEDGCREF:
                break;
            case ML_BUMPSRC:
            case ML_PINNEDISOMORPHICARRAY_C2N_EXPRESS:
                pMLCode += 2;
                break;
            case ML_REFBLITTABLEVALUECLASS_C2N:
                pMLCode += 4;
                break;

            case ML_BSTR_C2N:
                break;

            case ML_CSTR_C2N:
                pMLCode += 2; //go past bestfitmapping & throwonunmappable char vars.
                break;

            case ML_PUSHRETVALBUFFER1: //fallthru
            case ML_PUSHRETVALBUFFER2: //fallthru
            case ML_PUSHRETVALBUFFER4:
                break;

            case ML_HANDLEREF_C2N:
                break;

            case ML_CREATE_MARSHALER_CSTR: //fallthru
                pMLCode += (sizeof(UINT8) * 2);  //go past bestfitmapping & throwonunmappable char vars.
            case ML_CREATE_MARSHALER_BSTR: //fallthru
            case ML_CREATE_MARSHALER_WSTR:
                if (*pMLCode == ML_PRERETURN_C2N_RETVAL) {
                    pMLCode++;
                    break;
                } else {
                    return FALSE;
                }

            case ML_PUSHVARIANTRETVAL:
                break;

            default:
                return FALSE;
        }

                if (gMLInfo[mlcode].m_frequiresCleanup)
                {
                        fNeedsCleanup = TRUE;
                }

    }


    if (*(pMLCode) == ML_THROWIFHRFAILED) {
        pMLCode++;
    }

#if 0
    for (;;) {
        if (*pMLCode == ML_BYREF4POST) {
            pMLCode += 3;
        } else {
            break;
        }
    }
#endif


    if (*(pMLCode) == ML_SETSRCTOLOCAL) {
        pMLCode += 3;
    }

    mlcode = *(pMLCode++);
    if (!(mlcode == ML_END ||
         ( (mlcode == ML_RETURN_C2N_RETVAL && *(pMLCode+2) == ML_END) ) ||
         ( (mlcode == ML_OBJECTRETC2N_POST && *(pMLCode+2) == ML_END) ) ||
         ( (mlcode == ML_COPY4 ||
            mlcode == ML_COPY8 ||
            mlcode == ML_COPYI1 ||
            mlcode == ML_COPYU1 ||
            mlcode == ML_COPYI2 ||
            mlcode == ML_COPYU2 ||
            mlcode == ML_COPYI4 ||
            mlcode == ML_COPYU4 ||
            mlcode == ML_CBOOL_N2C ||
            mlcode == ML_BOOL_N2C) && *(pMLCode) == ML_END))) {
        return FALSE;
    }


    //-----------------------------------------------------------------------
    // Qualification stage done. If we've gotten this far, we MUST return
    // TRUE or throw an exception.
    //-----------------------------------------------------------------------

    //---------------------------------------------------------------------
    // Com interop stubs are used by remoting to redirect calls on proxies
    // Do this before setting up the frame as remoting sets up its own frame
    //---------------------------------------------------------------------
    if(fDoComInterop)
    {
        // If the this pointer points to a transparent proxy method table
        // then we have to redirect the call. We generate a check to do this.
        CRemotingServices::GenerateCheckForProxy(psl);
    }

    //-----------------------------------------------------------------------
    // Generate the standard prolog
    //-----------------------------------------------------------------------
        if (fDoComInterop)
        {
                psl->EmitMethodStubProlog(fNeedsCleanup ? ComPlusMethodFrameStandaloneCleanup::GetMethodFrameVPtr() : ComPlusMethodFrameStandalone::GetMethodFrameVPtr());
        }
        else
        {
                psl->EmitMethodStubProlog(fNeedsCleanup ? NDirectMethodFrameStandaloneCleanup::GetMethodFrameVPtr() : NDirectMethodFrameStandalone::GetMethodFrameVPtr());
        }

        //------------------------------------------------------------------------
        // If needs cleanup, reserve space for cleamup pointer.
        //------------------------------------------------------------------------
        if (fNeedsCleanup)
        {
                psl->X86EmitPushImm32(0);
        }


    //-----------------------------------------------------------------------
    // For interop, we need to reserve space on the stack to preserve the
    // 'this' pointer over the call (since we must Release it when we
    // obtained the IP via the cache miss path).
    //-----------------------------------------------------------------------
    if (fDoComInterop) {
        // Default is don't release IP after call
        psl->X86EmitPushImm8(0);
    }

    //-----------------------------------------------------------------------
    // Add space for locals
    //-----------------------------------------------------------------------
    psl->X86EmitSubEsp(pheader->m_cbLocals);

    if (fNeedsCleanup)
        {
                // push ebx // thread
                psl->X86EmitPushReg(kEBX);
                // push esi // frame
                psl->X86EmitPushReg(kESI);
                // call DoCheckPointForCleanup
                psl->X86EmitCall(psl->NewExternalCodeLabel(DoCheckPointForCleanup), 8);
        }

        INT32 locbase = 0-( (fNeedsCleanup ? NDirectMethodFrameEx::GetNegSpaceSize() : NDirectMethodFrame::GetNegSpaceSize()) + pheader->m_cbLocals + (fDoComInterop?4:0));

    INT32  locofs = locbase;
    UINT32 ofs;
    ofs = 0;

    UINT32 fBestFitMapping;
    UINT32 fThrowOnUnmappableChar;


    // CLR doesn't care about float point exception flags, but some legacy runtime 
    // uses the flag to see if there is any exception in float arithmetic. 
    // So we need to clear the exception flag before we call into legacy runtime.   
    if(fDoComInterop) 
    {
        static const BYTE b[] = { 0x9b, 0xdb, 0xe2 };
        psl->EmitBytes(b, sizeof(b));        
    }
    
    //-----------------------------------------------------------------------
    // Generate code to marshal each parameter.
    //-----------------------------------------------------------------------
    pMLCode = pheader->GetMLCode();
    while (ML_INTERRUPT != (mlcode = *(pMLCode++))) {
        switch (mlcode) {
            case ML_COPY4:
            case ML_COPYPINNEDGCREF:
                psl->X86EmitIndexPush(kESI, ofs);
                ofs += 4;
                break;

            case ML_COPY8:
                psl->X86EmitIndexPush(kESI, ofs+4);
                psl->X86EmitIndexPush(kESI, ofs);
                ofs += 8;
                break;

            case ML_HANDLEREF_C2N:
                psl->X86EmitIndexPush(kESI, ofs+4);
                ofs += 8;
                break;

            case ML_CBOOL_C2N:
                {
                    //    mov eax,[esi+ofs+4]
                    psl->X86EmitIndexRegLoad(kEAX, kESI, ofs+4);
                    //    xor  ecx,ecx
                    //    test al,al
                    //    setne cl
                    static const BYTE code[] = {0x33,0xc9,0x84,0xc0,0x0f,0x95,0xc1};
                    psl->EmitBytes(code, sizeof(code));
                    //    push ecx
                    psl->X86EmitPushReg(kECX);
                    ofs += 4;
                }
                break;

            case ML_REFBLITTABLEVALUECLASS_C2N:
                {
                    UINT32 cbSize = *((UINT32*&)pMLCode)++;

                    // mov eax, [esi+ofs]
                    psl->X86EmitOp(0x8b, kEAX, kESI, ofs);

                    // push eax
                    psl->X86EmitPushReg(kEAX);

                    ofs += sizeof(LPVOID);

#ifdef TOUCH_ALL_PINNED_OBJECTS
                    // lea edx [eax+IMM32]
                    psl->X86EmitOp(0x8d, kEDX, kEAX, cbSize);
                    psl->EmitPageTouch(TRUE);
#endif
                }
                break;


            case ML_PINNEDUNISTR_C2N: {


                // mov eax, [esi+OFS]
                psl->X86EmitIndexRegLoad(kEAX, kESI, ofs);
                // test eax,eax
                psl->Emit16(0xc085);
                CodeLabel *plabel = psl->NewCodeLabel();
                // jz LABEL
                psl->X86EmitCondJump(plabel, X86CondCode::kJZ);
                // add eax, BUFOFS
                psl->X86EmitAddReg(kEAX, (UINT8)(StringObject::GetBufferOffset()));


 #ifdef TOUCH_ALL_PINNED_OBJECTS
                // mov edx, eax
                psl->X86EmitR2ROp(0x8b, kEDX, kEAX);

                // mov ecx, dword ptr [eax - BUFOFS + STRINGLEN]
                psl->X86EmitOp(0x8b, kECX, kEAX, StringObject::GetStringLengthOffset_MaskOffHighBit() - StringObject::GetBufferOffset());

                // and ecx, 0x7fffffff
                psl->Emit16(0xe181);
                psl->Emit32(0x7fffffff);

                // lea edx, [eax + ecx*2 + 2]
                psl->X86EmitOp(0x8d, kEDX, kEAX, 2, kECX, 2);


                // touch all pages
                psl->EmitPageTouch(TRUE);

                // mov eax, [esi+OFS]
                psl->X86EmitIndexRegLoad(kEAX, kESI, ofs);

                // add eax, BUFOFS
                psl->X86EmitAddReg(kEAX, (UINT8)(StringObject::GetBufferOffset()));

#endif


                psl->EmitLabel(plabel);
                // push eax
                psl->X86EmitPushReg(kEAX);

                ofs += 4;
                }
                break;


            case ML_BLITTABLELAYOUTCLASS_C2N: {


                // mov eax, [esi+OFS]
                psl->X86EmitIndexRegLoad(kEAX, kESI, ofs);
                // test eax,eax
                psl->Emit16(0xc085);
                CodeLabel *plabel = psl->NewCodeLabel();
                psl->X86EmitCondJump(plabel, X86CondCode::kJZ);

#ifdef TOUCH_ALL_PINNED_OBJECTS
                // mov ecx, [eax]
                psl->X86EmitOp(0x8b, kECX, kEAX);
#endif



                // lea eax, [eax+DATAPTR]
                psl->X86EmitOp(0x8d, kEAX, kEAX, Object::GetOffsetOfFirstField());

#ifdef TOUCH_ALL_PINNED_OBJECTS
                // mov edx, eax
                psl->X86EmitR2ROp(0x8b, kEDX, kEAX);

                // add edx, dword ptr [ecx + MethodTable.cbNativeSize]
                psl->X86EmitOp(0x03, kEDX, kECX, MethodTable::GetOffsetOfNativeSize());

                // touch all pages
                psl->EmitPageTouch(TRUE);

                // mov eax, [esi+OFS]
                psl->X86EmitIndexRegLoad(kEAX, kESI, ofs);

                // lea eax, [eax+DATAPTR]
                psl->X86EmitOp(0x8d, kEAX, kEAX, Object::GetOffsetOfFirstField());
#endif



                // LABEL:
                psl->EmitLabel(plabel);
                psl->X86EmitPushReg(kEAX);


                ofs += 4;
            }
            break;


            case ML_BSTR_C2N:
            {
                    // push cleanup worklist
                    //   lea eax, [esi + NDirectMethodFrameEx.CleanupWorklist]
                    psl->X86EmitOp(0x8d, kEAX, kESI, NDirectMethodFrameEx::GetOffsetOfCleanupWorkList());
                    //   push eax
                    psl->X86EmitPushReg(kEAX);
                    //   push [esi + OFS]
                    psl->X86EmitIndexPush(kESI, ofs);

                    //   lea ecx, [esi + locofs]
                    psl->X86EmitOp(0x8d, kECX, kESI, locofs);

                    LPCWSTR (ML_BSTR_C2N_SR::*pfn)(STRINGREF, CleanupWorkList*) = ML_BSTR_C2N_SR::DoConversion;

                    //   call ML_BSTR_C2N_SR::DoConversion
                    psl->X86EmitCall(psl->NewExternalCodeLabel(*(LPVOID*)&pfn), 8);

                    //   push eax
                    psl->X86EmitPushReg(kEAX);
                    ofs += 4;
                    locofs += sizeof(ML_BSTR_C2N_SR);
            }
            break;


            case ML_CSTR_C2N:
            {
                    fBestFitMapping = (UINT32) ((*(UINT8*)pMLCode == 0) ? 0 : 1);
                    pMLCode += sizeof(UINT8);
                    fThrowOnUnmappableChar = (UINT32) ((*(UINT8*)pMLCode == 0) ? 0 : 1);
                    pMLCode += sizeof(UINT8);


                    // push cleanup worklist
                    //   lea eax, [esi + NDirectMethodFrameEx.CleanupWorklist]
                    psl->X86EmitOp(0x8d, kEAX, kESI, NDirectMethodFrameEx::GetOffsetOfCleanupWorkList());
                    //   push eax
                    psl->X86EmitPushReg(kEAX);

                    //  push    fThrowOnUnmappableChar
                    //  push    fBestFitMapping
                    psl->X86EmitPushImm32(fThrowOnUnmappableChar);
                    psl->X86EmitPushImm32(fBestFitMapping);
                    
                    //   push [esi + OFS]
                    psl->X86EmitIndexPush(kESI, ofs);

                    //   lea ecx, [esi + locofs]
                    psl->X86EmitOp(0x8d, kECX, kESI, locofs);

                    LPSTR (ML_CSTR_C2N_SR::*pfn)(STRINGREF, UINT32, UINT32, CleanupWorkList*) = ML_CSTR_C2N_SR::DoConversion;

                    //   call ML_CSTR_C2N_SR::DoConversion
                    psl->X86EmitCall(psl->NewExternalCodeLabel(*(LPVOID*)&pfn), 16);

                    //   push eax
                    psl->X86EmitPushReg(kEAX);
                    ofs += 4;
                    locofs += sizeof(ML_CSTR_C2N_SR);
            }
            break;

            case ML_BUMPSRC:
                ofs += *( (INT16*)pMLCode );
                pMLCode += 2;
                break;

            case ML_PINNEDISOMORPHICARRAY_C2N_EXPRESS:
                {
                    UINT16 dataofs = *( (INT16*)pMLCode );
                    pMLCode += 2;
                    _ASSERTE(dataofs);
#ifdef TOUCH_ALL_PINNED_OBJECTS
                    _ASSERTE(!"Not supposed to be here.");
#endif


                    // mov eax,[esi+ofs]
                    psl->X86EmitIndexRegLoad(kEAX, kESI, ofs);
                    // test eax,eax
                    psl->Emit16(0xc085);
                    CodeLabel *plabel = psl->NewCodeLabel();
                    // jz LABEL
                    psl->X86EmitCondJump(plabel, X86CondCode::kJZ);
                    // lea eax, [eax + dataofs]
                    psl->X86EmitOp(0x8d, kEAX, kEAX, (UINT32)dataofs);
    
                    psl->EmitLabel(plabel);
                    // push eax
                    psl->X86EmitPushReg(kEAX);

    
                    ofs += 4;

                }
                break;


            case ML_PUSHRETVALBUFFER1: //fallthru
            case ML_PUSHRETVALBUFFER2: //fallthru
            case ML_PUSHRETVALBUFFER4:
                // lea eax, [esi+locofs]
                // mov [eax],0
                // push eax

                psl->X86EmitOffsetModRM(0x8d, kEAX, kESI, locofs);
                psl->X86EmitOffsetModRM(0xc7, (X86Reg)0, kEAX, 0);
                psl->Emit32(0);
                psl->X86EmitPushReg(kEAX);

                locofs += 4;
                break;

            case ML_CREATE_MARSHALER_CSTR:
                fBestFitMapping = (UINT32) ((*(UINT8*)pMLCode == 0) ? 0 : 1);
                pMLCode += sizeof(UINT8);
                fThrowOnUnmappableChar = (UINT32) ((*(UINT8*)pMLCode == 0) ? 0 : 1);
                pMLCode += sizeof(UINT8);

                _ASSERTE(*pMLCode == ML_PRERETURN_C2N_RETVAL);

                //  push    fThrowOnUnmappableChar
                //  push    fBestFitMapping
                psl->X86EmitPushImm32(fThrowOnUnmappableChar);
                psl->X86EmitPushImm32(fBestFitMapping);
                
                //  lea     eax, [esi+locofs]
                //  push    eax       ;; push plocalwalk
                //  lea     eax, [esi + Frame.CleanupWorkList]
                //  push    eax       ;; push CleanupWorkList
                //  push    esi       ;; push Frame
                //  call    DoMLCreateMarshaler?Str

                //  push    edx       ;; push garbage (this will be overwritten by actual argument)
                //  push    esp       ;; push address of the garbage we just pushed
                //  lea     eax, [esi+locofs]
                //  push    eax       ;; push marshaler
                //  call    DoMLPrereturnC2N

                psl->X86EmitOffsetModRM(0x8d, kEAX, kESI, locofs);
                psl->X86EmitPushReg(kEAX);

                psl->X86EmitOp(0x8d, kEAX, kESI, NDirectMethodFrameEx::GetOffsetOfCleanupWorkList());
                psl->X86EmitPushReg(kEAX);

                psl->X86EmitPushReg(kESI);


                psl->X86EmitCall(psl->NewExternalCodeLabel(DoMLCreateMarshalerCStr), 20);


                psl->X86EmitPushReg(kEDX);
                psl->X86EmitPushReg((X86Reg)4 /*kESP*/);
                psl->X86EmitOffsetModRM(0x8d, kEAX, kESI, locofs);
                psl->X86EmitPushReg(kEAX);
                psl->X86EmitCall(psl->NewExternalCodeLabel(DoMLPrereturnC2N), 8);


                locofs += gMLInfo[mlcode].m_cbLocal;
                pMLCode++;

                break;

    

            case ML_CREATE_MARSHALER_BSTR:
            case ML_CREATE_MARSHALER_WSTR:
                _ASSERTE(*pMLCode == ML_PRERETURN_C2N_RETVAL);

                //  lea     eax, [esi+locofs]
                //  push    eax       ;; push plocalwalk
                //  lea     eax, [esi + Frame.CleanupWorkList]
                //  push    eax       ;; push CleanupWorkList
                //  push    esi       ;; push Frame
                //  call    DoMLCreateMarshaler?Str

                //  push    edx       ;; push garbage (this will be overwritten by actual argument)
                //  push    esp       ;; push address of the garbage we just pushed
                //  lea     eax, [esi+locofs]
                //  push    eax       ;; push marshaler
                //  call    DoMLPrereturnC2N

                psl->X86EmitOffsetModRM(0x8d, kEAX, kESI, locofs);
                psl->X86EmitPushReg(kEAX);

                psl->X86EmitOp(0x8d, kEAX, kESI, NDirectMethodFrameEx::GetOffsetOfCleanupWorkList());
                psl->X86EmitPushReg(kEAX);

                psl->X86EmitPushReg(kESI);
                switch (mlcode)
                {
                    case ML_CREATE_MARSHALER_BSTR:
                        psl->X86EmitCall(psl->NewExternalCodeLabel(DoMLCreateMarshalerBStr), 12);
                        break;
                    case ML_CREATE_MARSHALER_WSTR:
                        psl->X86EmitCall(psl->NewExternalCodeLabel(DoMLCreateMarshalerWStr), 12);
                        break;
                    default:
                        _ASSERTE(0);
                }
                psl->X86EmitPushReg(kEDX);
                psl->X86EmitPushReg((X86Reg)4 /*kESP*/);
                psl->X86EmitOffsetModRM(0x8d, kEAX, kESI, locofs);
                psl->X86EmitPushReg(kEAX);
                psl->X86EmitCall(psl->NewExternalCodeLabel(DoMLPrereturnC2N), 8);


                locofs += gMLInfo[mlcode].m_cbLocal;
                pMLCode++;

                break;

            case ML_PUSHVARIANTRETVAL:
                //  lea     eax, [esi+locofs]
                psl->X86EmitOffsetModRM(0x8d, kEAX, kESI, locofs);
                //  mov     word ptr [eax], VT_EMPTY
                _ASSERTE(VT_EMPTY == 0);
                psl->Emit32(0x0000c766);
                psl->Emit8(0x00);

                //  push    eax
                psl->X86EmitPushReg(kEAX);
                locofs += gMLInfo[mlcode].m_cbLocal;

                break;

            default:
                _ASSERTE(0);
        }
    }
    UINT32 numStackBytes;
    numStackBytes = pheader->m_cbStackPop;

    _ASSERTE(FitsInI1(MDEnums::MD_IndexOffset));
    _ASSERTE(FitsInI1(MDEnums::MD_SkewOffset));

    INT thisOffset = 0-(FramedMethodFrame::GetNegSpaceSize() + 4);
    if (fNeedsCleanup)
    {
        thisOffset -= sizeof(CleanupWorkList);
    }

    if (fDoComInterop) {

        CodeLabel *pCacheMiss = psl->NewCodeLabel();
        CodeLabel *pGotIt     = psl->NewCodeLabel();
        CodeLabel *pCmpNextEntry[INTERFACE_ENTRY_CACHE_SIZE];

        // Allocate the labels for the interface entry cache.
        for (i = 0; i < INTERFACE_ENTRY_CACHE_SIZE; i++)
            pCmpNextEntry[i] = psl->NewCodeLabel();

        // mov eax, [Frame.m_pMethod] // Get method desc pointer
        psl->X86EmitIndexRegLoad(kEAX, kESI, FramedMethodFrame::GetOffsetOfMethod());

        // mov ecx, [eax+offsetOf(ComPlusCallMethodDesc, compluscall.m_pInterfaceMT)]
        psl->X86EmitIndexRegLoad(kECX, kEAX, ComPlusCallMethodDesc::GetOffsetofInterfaceMTField());

        // mov eax, [Frame.m_This]
        psl->X86EmitIndexRegLoad(kEAX, kESI, FramedMethodFrame::GetOffsetOfThis());

        // mov eax, [eax + ComObject.m_pWrap]
        psl->X86EmitIndexRegLoad(kEAX, kEAX, offsetof(ComObject, m_pWrap));

        // on NT5 we need to check the context cookie also matches
        if (RunningOnWinNT5())
        {
            pOleCtxNull = psl->NewCodeLabel();
            pOleCtxInited = psl->NewCodeLabel();

            // mov edx, fs:[offsetof(_TEB, ReservedForOle)]
            //64 8B 15 xx xx 00 00 mov         edx,dword ptr fs:[234h]

            static const BYTE b[] = { 0x64, 0x8b, 0x15 };
            psl->EmitBytes(b, sizeof(b));
            psl->Emit32(offsetof(TEB, ReservedForOle));

            // test edx,edx
            psl->Emit16(0xd285); //@todo
            psl->X86EmitCondJump(pOleCtxNull, X86CondCode::kJZ);

            // if OleContext is NULL, we call out below and return here
            psl->EmitLabel(pOleCtxInited);

            // mov edx, [edx + offsetof(SOleTlsData, pCurrentCtx)]
            psl->X86EmitIndexRegLoad(kEDX, kEDX, offsetof(SOleTlsData, pCurrentCtx));

            // cmp edx, [eax + offsetof(ComPlusWrapper, m_UnkEntry) + offsetof(IUnkEntry, m_pCtxCookie)]
            psl->X86EmitOffsetModRM(0x3b, kEDX, kEAX, offsetof(ComPlusWrapper, m_UnkEntry) + offsetof(IUnkEntry, m_pCtxCookie));

            // jne CacheMiss
            psl->X86EmitCondJump(pCacheMiss, X86CondCode::kJNZ);
        }
        else 
        {
            // cmp ebx, [eax + offsetof(ComPlusWrapper, m_UnkEntry) + offsetof(IUnkEntry, m_pCtxCookie)]
            psl->X86EmitOffsetModRM(0x3b, kEBX, kEAX, offsetof(ComPlusWrapper, m_UnkEntry) + offsetof(IUnkEntry, m_pCtxCookie));

            // jne CacheMiss
            psl->X86EmitCondJump(pCacheMiss, X86CondCode::kJNZ);
        }

        // Emit the look up in the cache of interface entries.
        for (i = 0; i < INTERFACE_ENTRY_CACHE_SIZE; i++)
        {
            // cmp ecx, [eax + offsetof(ComPlusWrapper, m_aInterfaceEntries) + i * sizeof(InterfaceEntry) + offsetof(InterfaceEntry, m_pMT)]
            psl->X86EmitOffsetModRM(0x3b, kECX, kEAX, offsetof(ComPlusWrapper, m_aInterfaceEntries) + i * sizeof(InterfaceEntry) + offsetof(InterfaceEntry, m_pMT));

            // jne pCmpEntry2
            psl->X86EmitCondJump(pCmpNextEntry[i], X86CondCode::kJNZ);

            // mov ecx, [eax + offsetof(ComPlusWrapper, m_aInterfaceEntries) + i * sizeof(InterfaceEntry) + offsetof(InterfaceEntry, m_pUnknown)]
            psl->X86EmitIndexRegLoad(kECX, kEAX, offsetof(ComPlusWrapper, m_aInterfaceEntries) + i * sizeof(InterfaceEntry) + offsetof(InterfaceEntry, m_pUnknown));

            // mov eax, ecx
            psl->Emit16(0xc18b);

            // jmp GotIt
            psl->X86EmitNearJump(pGotIt);

            // CmpNextEntryX:
            psl->EmitLabel(pCmpNextEntry[i]);
        }

#ifdef _DEBUG
        CodeLabel *pItfOk = psl->NewCodeLabel();
        psl->Emit16(0xc085);
        psl->X86EmitCondJump(pItfOk, X86CondCode::kJNZ);
        psl->Emit8(0xcc);
        psl->EmitLabel(pItfOk);
#endif

        // CacheMiss:
        psl->EmitLabel(pCacheMiss);

        // mov eax, [Frame.m_pMethod] // Get method desc pointer
        psl->X86EmitIndexRegLoad(kEAX, kESI, FramedMethodFrame::GetOffsetOfMethod());

        // mov ecx, [eax+offsetOf(ComPlusCallMethodDesc, compluscall.m_pInterfaceMT)]
        psl->X86EmitIndexRegLoad(kECX, kEAX, ComPlusCallMethodDesc::GetOffsetofInterfaceMTField());

        // push ecx // methodtable for the interface
        psl->X86EmitPushReg(kECX);

        // push [Frame.m_This] // push oref as arg
        psl->X86EmitIndexPush(kESI, FramedMethodFrame::GetOffsetOfThis());

        // call GetComIPFromWrapperByMethodTable
        psl->X86EmitCall(psl->NewExternalCodeLabel((LPVOID)ComPlusWrapper::GetComIPFromWrapperEx), 8);

        // mov [esi+xx], eax // Store 'this' so we can perform a release after call
        psl->X86EmitIndexRegStore(kESI, thisOffset, kEAX);

        // GotIt:
        psl->EmitLabel(pGotIt);

        // push eax // IUnknown
        psl->X86EmitPushReg(kEAX);

        // mov edx, [Frame.m_pMethod]
        psl->X86EmitIndexRegLoad(kEDX, kESI, FramedMethodFrame::GetOffsetOfMethod());

        // mov ecx, [edx + ComPlusCallMethodDesc.m_cachedComSlot] get COM slot
        psl->X86EmitIndexRegLoad(kECX, kEDX, offsetof(ComPlusCallMethodDesc, compluscall.m_cachedComSlot));

        // mov edx, [eax] // Get vptr
        psl->X86EmitIndexRegLoad(kEDX, kEAX, 0);

        // push dword ptr [edx+ecx*4] // Push target address
        psl->Emit8(0xff);
        psl->Emit16(0x8a34);
        psl->Push(4);
    }


    CodeLabel *pRareEnable,  *pEnableRejoin;
    CodeLabel *pRareDisable, *pDisableRejoin;
    pRareEnable    = psl->NewCodeLabel();
    pEnableRejoin  = psl->NewCodeLabel();
    pRareDisable   = psl->NewCodeLabel();
    pDisableRejoin = psl->NewCodeLabel();

    //-----------------------------------------------------------------------
    // Generate the inline part of enabling preemptive GC
    //-----------------------------------------------------------------------
    psl->EmitEnable(pRareEnable);
    psl->EmitLabel(pEnableRejoin);

#ifdef PROFILING_SUPPORTED
    // Notify the profiler of a call out of managed code
    if (CORProfilerTrackTransitions())
    {
        // Save registers
        psl->X86EmitPushReg(kEAX);
        psl->X86EmitPushReg(kECX);
        psl->X86EmitPushReg(kEDX);

        psl->X86EmitPushImm32(COR_PRF_TRANSITION_CALL);     // Reason
        psl->X86EmitPushReg(kESI);                          // Frame*
        psl->X86EmitCall(psl->NewExternalCodeLabel(ProfilerManagedToUnmanagedTransition), 8);

        // Restore registers
        psl->X86EmitPopReg(kEDX);
        psl->X86EmitPopReg(kECX);
        psl->X86EmitPopReg(kEAX);
    }
#endif // PROFILING_SUPPORTED

    if (fDoComInterop) {
        //-----------------------------------------------------------------------
        // Invoke the classic COM method
        //-----------------------------------------------------------------------

        // pop eax
        psl->X86EmitPopReg(kEAX);

        if (pheader->m_Flags & MLHF_THISCALL) {

            if (pheader->m_Flags & MLHF_THISCALLHIDDENARG)
            {
                // pop edx
                psl->X86EmitPopReg(kEDX);
                // pop ecx
                psl->X86EmitPopReg(kECX);
                // push edx
                psl->X86EmitPushReg(kEDX);
            }
            else
            {
                // pop ecx
                psl->X86EmitPopReg(kECX);
            }
        }
#if _DEBUG
        // Call through debugger logic to make sure it works
        psl->X86EmitCall(psl->NewExternalCodeLabel(Frame::CheckExitFrameDebuggerCalls), 0, TRUE);
#else
        // call eax
        psl->Emit16(0xd0ff);
        psl->EmitReturnLabel();
#endif



    } else {
        //-----------------------------------------------------------------------
        // Invoke the DLL target.
        //-----------------------------------------------------------------------

        if (pheader->m_Flags & MLHF_THISCALL) {
            if (pheader->m_Flags & MLHF_THISCALLHIDDENARG)
            {
                // pop eax
                psl->X86EmitPopReg(kEAX);
                // pop ecx
                psl->X86EmitPopReg(kECX);
                // push eax
                psl->X86EmitPushReg(kEAX);
            }
            else
            {
                // pop ecx
                psl->X86EmitPopReg(kECX);
            }
        }

        //  mov eax, [CURFRAME.MethodDesc]
        psl->X86EmitIndexRegLoad(kEAX, kESI, FramedMethodFrame::GetOffsetOfMethod());

#if _DEBUG
        // Call through debugger logic to make sure it works
        psl->X86EmitCall(psl->NewExternalCodeLabel(Frame::CheckExitFrameDebuggerCalls), 0, TRUE);
#else
        //  call [eax + MethodDesc.NDirectTarget]
        psl->X86EmitOffsetModRM(0xff, (X86Reg)2, kEAX, NDirectMethodDesc::GetOffsetofNDirectTarget());
        psl->EmitReturnLabel();
#endif


        if (pheader->m_Flags & MLHF_SETLASTERROR) {
            psl->EmitSaveLastError();
        }
    }

#ifdef PROFILING_SUPPORTED
    // Notify the profiler of a return from a managed->unmanaged call
    if (CORProfilerTrackTransitions())
    {
        // Save registers
        psl->X86EmitPushReg(kEAX);
        psl->X86EmitPushReg(kECX);
        psl->X86EmitPushReg(kEDX);

        psl->X86EmitPushImm32(COR_PRF_TRANSITION_RETURN);   // Reason
        psl->X86EmitPushReg(kESI);                          // FrameID
        psl->X86EmitCall(psl->NewExternalCodeLabel(ProfilerUnmanagedToManagedTransition), 8);

        // Restore registers
        psl->X86EmitPopReg(kEDX);
        psl->X86EmitPopReg(kECX);
        psl->X86EmitPopReg(kEAX);
    }
#endif // PROFILING_SUPPORTED

    //-----------------------------------------------------------------------
    // For interop, release the IP we were using (only in the cache miss case
    // since it's not addref'd when taken from the cache). Do this before
    // disabling preemptive GC.
    //-----------------------------------------------------------------------
    if (fDoComInterop) 
    {
        CodeLabel *pReleaseEnd = psl->NewCodeLabel();

        // mov ecx, [esi+xx] // Retrieve 'this', skip release if NULL
        psl->X86EmitIndexRegLoad(kECX, kESI, thisOffset);

        // test ecx,ecx
        psl->Emit16(0xc985);

        // je ReleaseEnd
        psl->X86EmitCondJump(pReleaseEnd, X86CondCode::kJZ);

        // push eax // Save return code
        psl->X86EmitPushReg(kEAX);

        // push ecx // Push 'this'
        psl->X86EmitPushReg(kECX);

        // mov ecx, [ecx] // Get vptr
        psl->X86EmitIndexRegLoad(kECX, kECX, 0);

        // call [ecx + 8] // Call thru Release slot
        psl->X86EmitOffsetModRM(0xff, (X86Reg)2, kECX, 8);

        // pop eax // restore return code
        psl->X86EmitPopReg(kEAX);

        // ReleaseEnd:
        psl->EmitLabel(pReleaseEnd);
    }

    //-----------------------------------------------------------------------
    // Generate the inline part of disabling preemptive GC
    //-----------------------------------------------------------------------
    psl->EmitDisable(pRareDisable);
    psl->EmitLabel(pDisableRejoin);

    //-----------------------------------------------------------------------
    // Marshal the return value
    //-----------------------------------------------------------------------


    if (*pMLCode == ML_THROWIFHRFAILED) {
         pMLCode++;
         // test eax,eax
         psl->Emit16(0xc085);
         // js ThrowBecauseOfFailedHr
         psl->X86EmitCondJump(psl->NewExternalCodeLabel(ThrowBecauseOfFailedHr), X86CondCode::kJS);
    }

#if 0
    for (;;) {
        if (*pMLCode == ML_BYREF4POST) {

            // mov ecx, [esi+locbase.ML_BYREF_SR.ppRef]
            // mov ecx, [ecx]
            // push [esi+locofs.ML_BYREF_SR.ix]
            // pop  [ecx]

            pMLCode++;
            UINT16 bufidx = *((UINT16*)(pMLCode));
            pMLCode += 2;
            psl->X86EmitIndexRegLoad(kECX, kESI, locbase+bufidx+offsetof(ML_BYREF_SR,ppRef));
            psl->X86EmitIndexRegLoad(kECX, kECX, 0);
            psl->X86EmitIndexPush(kESI, locbase+bufidx+offsetof(ML_BYREF_SR,i8));
            psl->X86EmitOffsetModRM(0x8f, (X86Reg)0, kECX, 0);

        } else {
            break;
        }
    }
#endif

    if (*pMLCode == ML_SETSRCTOLOCAL) {
        pMLCode++;
        UINT16 bufidx = *((UINT16*)(pMLCode));
        pMLCode += 2;
        // mov eax, [esi + locbase + bufidx]
        psl->X86EmitIndexRegLoad(kEAX, kESI, locbase+bufidx);

    }


    switch (mlcode = *(pMLCode++)) {
        case ML_BOOL_N2C: {
                //    xor  ecx,ecx
                //    test eax,eax
                //    setne cl
                //    mov  eax,ecx

                static const BYTE code[] = {0x33,0xc9,0x85,0xc0,0x0f,0x95,0xc1,0x8b,0xc1};
                psl->EmitBytes(code, sizeof(code));
            }
            break;

        case ML_CBOOL_N2C: {
                //    xor  ecx,ecx
                //    test al,al
                //    setne cl
                //    mov  eax,ecx
    
                static const BYTE code[] = {0x33,0xc9,0x84,0xc0,0x0f,0x95,0xc1,0x8b,0xc1};
                psl->EmitBytes(code, sizeof(code));
            }
            break;

        case ML_COPY4: //fallthru
        case ML_COPY8: //fallthru
        case ML_COPYI4: //fallthru
        case ML_COPYU4:
        case ML_END:
            //do nothing
            break;

        case ML_COPYU1:
            // movzx eax,al
            psl->Emit8(0x0f);
            psl->Emit16(0xc0b6);
            break;


        case ML_COPYI1:
            // movsx eax,al
            psl->Emit8(0x0f);
            psl->Emit16(0xc0be);
            break;

        case ML_COPYU2:
            // movzx eax,ax
            psl->Emit8(0x0f);
            psl->Emit16(0xc0b7);
            break;

        case ML_COPYI2:
            // movsx eax,ax
            psl->Emit8(0x0f);
            psl->Emit16(0xc0bf);
            break;

        case ML_OBJECTRETC2N_POST:
            {
                UINT16 locidx = *((UINT16*)(pMLCode));
                pMLCode += 2;

                // lea        eax, [esi + locidx + locbase]
                // push       eax
                // call       OleVariant::MarshalObjectForOleVariantAndClear
                // ;; oret retval left in eax
                psl->X86EmitOffsetModRM(0x8d, kEAX, kESI, locbase+locidx);
                psl->X86EmitPushReg(kEAX);
                psl->X86EmitCall(psl->NewExternalCodeLabel(OleVariant::MarshalObjectForOleVariantAndClear), 4);

            }
            break;

        case ML_RETURN_C2N_RETVAL:
            {
                UINT16 locidx = *((UINT16*)(pMLCode));
                pMLCode += 2;

                // lea        eax, [esi + locidx + locbase]
                // push       eax  //push marshaler
                // call       DoMLReturnC2NRetVal   ;; returns oref in eax
                //


                psl->X86EmitOffsetModRM(0x8d, kEAX, kESI, locbase+locidx);
                psl->X86EmitPushReg(kEAX);

                psl->X86EmitCall(psl->NewExternalCodeLabel(DoMLReturnC2NRetVal), 4);



            }
            break;


        default:
            _ASSERTE(!"Can't get here.");
    }

        if (fNeedsCleanup)
        {
                if ( pheader->GetManagedRetValTypeCat() == MLHF_TYPECAT_GCREF )
                {
                    // push eax
                    // lea  eax, [esi + Frame.CleanupWorkList]
                    // push eax
                    // call DoCleanupWithGcProtection
                    // ;; (possibly promoted) objref left in eax
                    psl->X86EmitPushReg(kEAX);
                    psl->X86EmitOp(0x8d, kEAX, kESI, NDirectMethodFrameEx::GetOffsetOfCleanupWorkList());
                    psl->X86EmitPushReg(kEAX);
                    psl->X86EmitCall(psl->NewExternalCodeLabel(DoCleanupWithGcProtection), 8);

                }
                else
                {

                    // Do cleanup
    
                    // push eax             //save EAX
                    psl->X86EmitPushReg(kEAX);
    
                    // push edx             //save EDX
                    psl->X86EmitPushReg(kEDX);
    
    
                    // push 0               // FALSE
                    psl->Emit8(0x68);
                    psl->Emit32(0);
    
                    // lea ecx, [esi + Frame.CleanupWorkList]
                    psl->X86EmitOp(0x8d, kECX, kESI, NDirectMethodFrameEx::GetOffsetOfCleanupWorkList());
    
                    // call Cleanup
                    VOID (CleanupWorkList::*pfn)(BOOL) = CleanupWorkList::Cleanup;
                    psl->X86EmitCall(psl->NewExternalCodeLabel(*(LPVOID*)&pfn), 8);
    
    
    
                    // pop edx
                    psl->X86EmitPopReg(kEDX);
    
                    // pop eax
                    psl->X86EmitPopReg(kEAX);
                }
        }

    // must restore esp explicitly since we don't know whether the target
    // popped the args.
    // lea esp, [esi+xx]
    psl->X86EmitOffsetModRM(0x8d, (X86Reg)4 /*kESP*/, kESI, 0-FramedMethodFrame::GetNegSpaceSize());



    //-----------------------------------------------------------------------
    // Epilog
    //-----------------------------------------------------------------------
    psl->EmitMethodStubEpilog(numStackBytes, kNoTripStubStyle);


    //-----------------------------------------------------------------------
    // The out-of-line portion of enabling preemptive GC - rarely executed
    //-----------------------------------------------------------------------
    psl->EmitLabel(pRareEnable);
    psl->EmitRareEnable(pEnableRejoin);

    //-----------------------------------------------------------------------
    // The out-of-line portion of disabling preemptive GC - rarely executed
    //-----------------------------------------------------------------------
    psl->EmitLabel(pRareDisable);
    psl->EmitRareDisable(pDisableRejoin, /*bIsCallIn=*/FALSE);

    if (fDoComInterop && RunningOnWinNT5())
    {
        // Ole Context is NULL scenario
        psl->EmitLabel(pOleCtxNull);
        // we need to save the registers we are trashing
        // eax, ecx, edx, ebx
        psl->X86EmitPushReg(kEAX);
        psl->X86EmitPushReg(kEBX);
        psl->X86EmitPushReg(kECX);
        psl->X86EmitPushReg(kEDX);

        // call setup ole context
        extern LPVOID SetupOleContext();
        psl->X86EmitCall(psl->NewExternalCodeLabel(SetupOleContext), 0);
        psl->X86EmitPopReg(kEDX);

        // mov eax, edx
        psl->Emit16(0xd08b);

        psl->X86EmitPopReg(kECX);
        psl->X86EmitPopReg(kEBX);
        psl->X86EmitPopReg(kEAX);
        // jump to OleCtxInited
        psl->X86EmitNearJump(pOleCtxInited);
    }

    return TRUE;
}


// If we see an ML_BUMPSRC or ML_BUMPDST during compilation, we just make a note of it.
// There's no sense in generating any code for it unless we later do something at
// that adjusted offset.  This routine notices that pending state and adjusts us, just
// in time.
static void AdjustPending(CPUSTUBLINKER *psl, INT32 &PendingVal, X86Reg reg)
{
    if (PendingVal)
    {
        if (PendingVal > 0)
            psl->X86EmitAddReg(reg, PendingVal);
        else
            psl->X86EmitSubReg(reg, 0 - PendingVal);

        PendingVal = 0;
    }
}


//---------------------------------------------------------
// Compiles a little snippet of a ComCall marshaling stream.  This intentionally
// has no prolog or epilog, since it is called from a generic stub using an
// optimized calling convention.
//
// Results:
//     TRUE     - was able to create some asm (generated into psl)
//
//     FALSE    - decided not to create an asm snippet due to the method's
//                complexity. Stublinker remains empty!
//
//     COM+ exception - error - don't trust state of stublinker.
//
// This service is unusual in that it's called twice for each call we need to
// compile.  The first time, it validates that the entire stream is good and it
// generates code up to the INTERRUPT.  The second time, it (uselessly) validates
// from the INTERRUPT forwards and generates code for that second section.
//---------------------------------------------------------


// @perf cwb -- instead of using ADD and SUB instructions to move the source & dest
// pointers, investigate whether it is faster to just use indexed moves throughout.

/*static*/ BOOL ComCall::CompileSnippet(const ComCallMLStub *pheader, CPUSTUBLINKER *psl,
                                        void *state)
{
    THROWSCOMPLUSEXCEPTION();


    if ( ((ComCallMLStub*)pheader)->IsR4RetVal() || ((ComCallMLStub*)pheader)->IsR8RetVal())
    {
        return FALSE;
    }

    // Must first scan the ML stream to see if this method qualifies for
    // a standalone stub. Can't wait until we start generating because we're
    // supposed to leave psl empty if we return FALSE.

    const MLCode *pMLCode = pheader->GetMLCode();
    MLCode        mlcode;

    while (TRUE)
    {
        mlcode = *pMLCode++;
        _ASSERTE(mlcode != ML_INTERRUPT);

        if (mlcode == ML_END)
            break;

        switch (mlcode)
        {
        case ML_COPY4:              //fallthru
        case ML_COPYI1:             //fallthru
        case ML_COPYU1:             //fallthru
        case ML_COPYI2:             //fallthru
        case ML_COPYU2:             //fallthru
        case ML_COPYI4:             //fallthru
        case ML_COPYU4:             //fallthru
        case ML_R4_FROM_TOS:        //fallthru
        case ML_R8_FROM_TOS:        //fallthru
            break;

        case ML_BUMPSRC:            //fallthru
        case ML_BUMPDST:
            pMLCode += 2;
            break;

        default:
            return FALSE;
        }
    }


    //-----------------------------------------------------------------------
    // Qualification stage done. If we've gotten this far, we MUST return
    // TRUE or throw an exception.
    //-----------------------------------------------------------------------

    INT32  PendingBumpSrc = 0;
    INT32  PendingBumpDst = 0;

    //-----------------------------------------------------------------------
    // Generate code to marshal each parameter.
    //
    // Assumptions:
    //
    //      ECX    ->  source buffer
    //      EDX    ->  destination buffer
    //      EAX    ->  available as scratch
    //
    // There is no cleanup, presently, or we wouldn't have compiled the code.
    // Ditto for locals.
    //
    //-----------------------------------------------------------------------
    pMLCode = pheader->GetMLCode();

    while (TRUE)
    {
        mlcode = *pMLCode++;
        if (mlcode == ML_END)
            break;

        switch (mlcode)
        {
        case ML_COPYI1:             //fallthru
        case ML_COPYU1:             //fallthru
        case ML_COPYI2:             //fallthru
        case ML_COPYU2:             //fallthru
        case ML_COPYI4:             //fallthru
        case ML_COPYU4:             //fallthru
        case ML_COPY4:
            AdjustPending(psl, PendingBumpSrc, kECX);
            psl->X86EmitIndexRegLoad(kEAX, kECX, 0);
            // Instead of adding 4 to ECX, let's put it in the pending count.
            // The last one in the code stream will be eliminated, any any others
            // that are next to an ML_BUMPSRC opcode.
            PendingBumpSrc += 4;
            PendingBumpDst -= 4;
            AdjustPending(psl, PendingBumpDst, kEDX);
            psl->X86EmitIndexRegStore(kEDX, 0, kEAX);
            break;

        case ML_R4_FROM_TOS:
            PendingBumpDst -= 4;
            AdjustPending(psl, PendingBumpDst, kEDX);
            // fstp Dword ptr [edx]
            psl->Emit8(0xd9);
            psl->Emit8(0x1a);
            break;

        case ML_R8_FROM_TOS:
            PendingBumpDst -= 8;
            AdjustPending(psl, PendingBumpDst, kEDX);
            // fstp Qword ptr [edx]
            psl->Emit8(0xdd);
            psl->Emit8(0x1a);
            break;

        case ML_BUMPSRC:
            PendingBumpSrc += *( (INT16*)pMLCode );
            pMLCode += 2;
            break;

        case ML_BUMPDST:
            PendingBumpDst += *( (INT16*)pMLCode );
            pMLCode += 2;
            break;

        default:
            _ASSERTE(!"Can't get here");
        }
    }

    psl->X86EmitReturn(0);

    return TRUE;
}







static VOID StubRareEnableWorker(Thread *pThread)
{
    //printf("RareEnable\n");
    pThread->RareEnablePreemptiveGC();
}

__declspec(naked)
static VOID __cdecl StubRareEnable()
{
    __asm{
        push eax
        push edx

        push ebx
        call StubRareEnableWorker

        pop  edx
        pop  eax
        retn
    }
}


// I would prefer to define a unique HRESULT in our own facility, but we aren't
// supposed to create new HRESULTs this close to ship
#define E_PROCESS_SHUTDOWN_REENTRY    HRESULT_FROM_WIN32(ERROR_PROCESS_ABORTED)


// Disable when calling into managed code from a place that fails via HRESULT
HRESULT StubRareDisableHRWorker(Thread *pThread, Frame *pFrame)
{
    // WARNING!!!!
    // when we start executing here, we are actually in cooperative mode.  But we
    // haven't synchronized with the barrier to reentry yet.  So we are in a highly
    // dangerous mode.  If we call managed code, we will potentially be active in
    // the GC heap, even as GC's are occuring!

    // Do not add THROWSCOMPLUSEXCEPTION() here.  We haven't set up SEH.  We rely
    // on HandleThreadAbort dealing with this situation properly.

#ifdef DEBUGGING_SUPPORTED
    // If the debugger is attached, we use this opprotunity to see if
    // we're disabling preemptive GC on the way into the runtime from
    // unmanaged code. We end up here because
    // Increment/DecrementTraceCallCount() will bump
    // g_TrapReturningThreads for us.
    if (CORDebuggerTraceCall())
        g_pDebugInterface->PossibleTraceCall(NULL, pFrame);
#endif // DEBUGGING_SUPPORTED

    // Check for ShutDown scenario.  This happens only when we have initiated shutdown 
    // and someone is trying to call in after the CLR is suspended.  In that case, we
    // must either raise an unmanaged exception or return an HRESULT, depending on the
    // expectations of our caller.
    if (!CanRunManagedCode())
    {
        // DO NOT IMPROVE THIS EXCEPTION!  It cannot be a managed exception.  It
        // cannot be a real exception object because we cannot execute any managed
        // code here.
        pThread->m_fPreemptiveGCDisabled = 0;
        return E_PROCESS_SHUTDOWN_REENTRY;
    }

    // We must do the following in this order, because otherwise we would be constructing
    // the exception for the abort without synchronizing with the GC.  Also, we have no
    // CLR SEH set up, despite the fact that we may throw a ThreadAbortException.
    pThread->RareDisablePreemptiveGC();
    pThread->HandleThreadAbort();
    return S_OK;
}


// Disable when calling into managed code from a place that fails via Exceptions
VOID StubRareDisableTHROWWorker(Thread *pThread, Frame *pFrame)
{
    // WARNING!!!!
    // when we start executing here, we are actually in cooperative mode.  But we
    // haven't synchronized with the barrier to reentry yet.  So we are in a highly
    // dangerous mode.  If we call managed code, we will potentially be active in
    // the GC heap, even as GC's are occuring!
    
    // Do not add THROWSCOMPLUSEXCEPTION() here.  We haven't set up SEH.  We rely
    // on HandleThreadAbort and COMPlusThrowBoot dealing with this situation properly.

#ifdef DEBUGGING_SUPPORTED
    // If the debugger is attached, we use this opprotunity to see if
    // we're disabling preemptive GC on the way into the runtime from
    // unmanaged code. We end up here because
    // Increment/DecrementTraceCallCount() will bump
    // g_TrapReturningThreads for us.
    if (CORDebuggerTraceCall())
        g_pDebugInterface->PossibleTraceCall(NULL, pFrame);
#endif // DEBUGGING_SUPPORTED

    // Check for ShutDown scenario.  This happens only when we have initiated shutdown 
    // and someone is trying to call in after the CLR is suspended.  In that case, we
    // must either raise an unmanaged exception or return an HRESULT, depending on the
    // expectations of our caller.
    if (!CanRunManagedCode())
    {
        // DO NOT IMPROVE THIS EXCEPTION!  It cannot be a managed exception.  It
        // cannot be a real exception object because we cannot execute any managed
        // code here.
        pThread->m_fPreemptiveGCDisabled = 0;
        COMPlusThrowBoot(E_PROCESS_SHUTDOWN_REENTRY);
    }

    // We must do the following in this order, because otherwise we would be constructing
    // the exception for the abort without synchronizing with the GC.  Also, we have no
    // CLR SEH set up, despite the fact that we may throw a ThreadAbortException.
    pThread->RareDisablePreemptiveGC();
    pThread->HandleThreadAbort();
}

// Disable when calling from a place that is returning to managed code, not calling
// into it.
VOID StubRareDisableRETURNWorker(Thread *pThread, Frame *pFrame)
{
    // WARNING!!!!
    // when we start executing here, we are actually in cooperative mode.  But we
    // haven't synchronized with the barrier to reentry yet.  So we are in a highly
    // dangerous mode.  If we call managed code, we will potentially be active in
    // the GC heap, even as GC's are occuring!
    THROWSCOMPLUSEXCEPTION();

#ifdef DEBUGGING_SUPPORTED
    // If the debugger is attached, we use this opprotunity to see if
    // we're disabling preemptive GC on the way into the runtime from
    // unmanaged code. We end up here because
    // Increment/DecrementTraceCallCount() will bump
    // g_TrapReturningThreads for us.
    if (CORDebuggerTraceCall())
        g_pDebugInterface->PossibleTraceCall(NULL, pFrame);
#endif // DEBUGGING_SUPPORTED

    // Don't check for ShutDown scenario.  We are returning to managed code, not
    // calling into it.  The best we can do during shutdown is to deadlock and allow
    // the WatchDogThread to terminate the process on timeout.

    // We must do the following in this order, because otherwise we would be constructing
    // the exception for the abort without synchronizing with the GC.  Also, we have no
    // CLR SEH set up, despite the fact that we may throw a ThreadAbortException.
    pThread->RareDisablePreemptiveGC();
    pThread->HandleThreadAbort();
}

// Disable from a place that is calling into managed code via a UMEntryThunk.
VOID UMThunkStubRareDisableWorker(Thread *pThread, UMEntryThunk *pUMEntryThunk, Frame *pFrame)
{
    // WARNING!!!!
    // when we start executing here, we are actually in cooperative mode.  But we
    // haven't synchronized with the barrier to reentry yet.  So we are in a highly
    // dangerous mode.  If we call managed code, we will potentially be active in
    // the GC heap, even as GC's are occuring!

    // Do not add THROWSCOMPLUSEXCEPTION() here.  We haven't set up SEH.  We rely
    // on HandleThreadAbort and COMPlusThrowBoot dealing with this situation properly.

#ifdef DEBUGGING_SUPPORTED
    // If the debugger is attached, we use this opprotunity to see if
    // we're disabling preemptive GC on the way into the runtime from
    // unmanaged code. We end up here because
    // Increment/DecrementTraceCallCount() will bump
    // g_TrapReturningThreads for us.
    if (CORDebuggerTraceCall())
        g_pDebugInterface->PossibleTraceCall(pUMEntryThunk, pFrame);
#endif // DEBUGGING_SUPPORTED

    // Check for ShutDown scenario.  This happens only when we have initiated shutdown 
    // and someone is trying to call in after the CLR is suspended.  In that case, we
    // must either raise an unmanaged exception or return an HRESULT, depending on the
    // expectations of our caller.
    if (!CanRunManagedCode())
    {
        // DO NOT IMPROVE THIS EXCEPTION!  It cannot be a managed exception.  It
        // cannot be a real exception object because we cannot execute any managed
        // code here.
        pThread->m_fPreemptiveGCDisabled = 0;
        COMPlusThrowBoot(E_PROCESS_SHUTDOWN_REENTRY);
    }

    // We must do the following in this order, because otherwise we would be constructing
    // the exception for the abort without synchronizing with the GC.  Also, we have no
    // CLR SEH set up, despite the fact that we may throw a ThreadAbortException.
    pThread->RareDisablePreemptiveGC();
    pThread->HandleThreadAbort();
}

__declspec(naked)
static VOID __cdecl StubRareDisableHR()
{
    __asm{
        push edx

        push esi    // Frame
        push ebx    // Thread
        call StubRareDisableHRWorker

        pop  edx
        retn
    }
}

__declspec(naked)
static VOID __cdecl StubRareDisableTHROW()
{
    __asm{
        push eax
        push edx

        push esi    // Frame
        push ebx    // Thread
        call StubRareDisableTHROWWorker

        pop  edx
        pop  eax
        retn
    }
}

__declspec(naked)
static VOID __cdecl StubRareDisableRETURN()
{
    __asm{
        push eax
        push edx

        push esi    // Frame
        push ebx    // Thread
        call StubRareDisableRETURNWorker

        pop  edx
        pop  eax
        retn
    }
}

//-----------------------------------------------------------------------
// Generates the inline portion of the code to enable preemptive GC. Hopefully,
// the inline code is all that will execute most of the time. If this code
// path is entered at certain times, however, it will need to jump out to
// a separate out-of-line path which is more expensive. The "pForwardRef"
// label indicates the start of the out-of-line path.
//
// Assumptions:
//      ebx = Thread
// Preserves
//      all registers except ecx.
//
//-----------------------------------------------------------------------
VOID StubLinkerCPU::EmitEnable(CodeLabel *pForwardRef)
{
    THROWSCOMPLUSEXCEPTION();

    _ASSERTE(4 == sizeof( ((Thread*)0)->m_State ));
    _ASSERTE(4 == sizeof( ((Thread*)0)->m_fPreemptiveGCDisabled ));


    // move byte ptr [ebx + Thread.m_fPreemptiveGCDisabled],0
    X86EmitOffsetModRM(0xc6, (X86Reg)0, kEBX, offsetof(Thread, m_fPreemptiveGCDisabled));
    Emit8(0);

    _ASSERTE(FitsInI1(Thread::TS_CatchAtSafePoint));

    // test byte ptr [ebx + Thread.m_State], TS_CatchAtSafePoint
    X86EmitOffsetModRM(0xf6, (X86Reg)0, kEBX, offsetof(Thread, m_State));
    Emit8(Thread::TS_CatchAtSafePoint);

    // jnz RarePath
    X86EmitCondJump(pForwardRef, X86CondCode::kJNZ);

#ifdef _DEBUG
    X86EmitDebugTrashReg(kECX);
#endif



}



//-----------------------------------------------------------------------
// Generates the out-of-line portion of the code to enable preemptive GC.
// After the work is done, the code jumps back to the "pRejoinPoint"
// which should be emitted right after the inline part is generated.
//
// Assumptions:
//      ebx = Thread
// Preserves
//      all registers except ecx.
//
//-----------------------------------------------------------------------
VOID StubLinkerCPU::EmitRareEnable(CodeLabel *pRejoinPoint)
{
    THROWSCOMPLUSEXCEPTION();

    X86EmitCall(NewExternalCodeLabel(StubRareEnable), 0);
#ifdef _DEBUG
    X86EmitDebugTrashReg(kECX);
#endif
    X86EmitNearJump(pRejoinPoint);


}




//-----------------------------------------------------------------------
// Generates the inline portion of the code to disable preemptive GC. Hopefully,
// the inline code is all that will execute most of the time. If this code
// path is entered at certain times, however, it will need to jump out to
// a separate out-of-line path which is more expensive. The "pForwardRef"
// label indicates the start of the out-of-line path.
//
// Assumptions:
//      ebx = Thread
// Preserves
//      all registers except ecx.
//
//-----------------------------------------------------------------------
VOID StubLinkerCPU::EmitDisable(CodeLabel *pForwardRef)
{
    THROWSCOMPLUSEXCEPTION();

    _ASSERTE(4 == sizeof( ((Thread*)0)->m_fPreemptiveGCDisabled ));
    _ASSERTE(4 == sizeof(g_TrapReturningThreads));

    // move byte ptr [ebx + Thread.m_fPreemptiveGCDisabled],1
    X86EmitOffsetModRM(0xc6, (X86Reg)0, kEBX, offsetof(Thread, m_fPreemptiveGCDisabled));
    Emit8(1);

    // cmp dword ptr g_TrapReturningThreads, 0
    Emit16(0x3d83);
    EmitPtr(&g_TrapReturningThreads);
    Emit8(0);


    // jnz RarePath
    X86EmitCondJump(pForwardRef, X86CondCode::kJNZ);

#ifdef _DEBUG
    X86EmitDebugTrashReg(kECX);
#endif




}


//-----------------------------------------------------------------------
// Generates the out-of-line portion of the code to disable preemptive GC.
// After the work is done, the code jumps back to the "pRejoinPoint"
// which should be emitted right after the inline part is generated.  However,
// if we cannot execute managed code at this time, an exception is thrown
// which cannot be caught by managed code.
//
// Assumptions:
//      ebx = Thread
// Preserves
//      all registers except ecx, eax.
//
//-----------------------------------------------------------------------
VOID StubLinkerCPU::EmitRareDisable(CodeLabel *pRejoinPoint, BOOL bIsCallIn)
{
    THROWSCOMPLUSEXCEPTION();

    if (bIsCallIn)
        X86EmitCall(NewExternalCodeLabel(StubRareDisableTHROW), 0);
    else
        X86EmitCall(NewExternalCodeLabel(StubRareDisableRETURN), 0);

#ifdef _DEBUG
    X86EmitDebugTrashReg(kECX);
#endif
    X86EmitNearJump(pRejoinPoint);
}



//-----------------------------------------------------------------------
// Generates the out-of-line portion of the code to disable preemptive GC.
// After the work is done, the code normally jumps back to the "pRejoinPoint"
// which should be emitted right after the inline part is generated.  However,
// if we cannot execute managed code at this time, an HRESULT is returned
// via the ExitPoint.
//
// Assumptions:
//      ebx = Thread
// Preserves
//      all registers except ecx, eax.
//
//-----------------------------------------------------------------------
VOID StubLinkerCPU::EmitRareDisableHRESULT(CodeLabel *pRejoinPoint, CodeLabel *pExitPoint)
{
    THROWSCOMPLUSEXCEPTION();

    X86EmitCall(NewExternalCodeLabel(StubRareDisableHR), 0);

#ifdef _DEBUG
    X86EmitDebugTrashReg(kECX);
#endif

    // test eax,eax
    Emit16(0xc085);

    // JZ pRejoinPoint
    X86EmitCondJump(pRejoinPoint, X86CondCode::kJZ);

    X86EmitNearJump(pExitPoint);
}




//---------------------------------------------------------
// Performs a slim N/Direct call. This form can handle most
// common cases and is faster than the full generic version.
//---------------------------------------------------------

#define NDIRECT_SLIM_CBDSTMAX 32

struct NDirectSlimLocals
{
    Thread               *pThread;
    NDirectMethodFrameEx *pFrame;
    UINT32                savededi;

    NDirectMethodDesc    *pMD;
    const MLCode         *pMLCode;
    CleanupWorkList      *pCleanup;
    BYTE                 *pLocals;

    INT64                 nativeRetVal;
};

VOID __stdcall NDirectSlimStubWorker1(NDirectSlimLocals *pNSL)
{
    THROWSCOMPLUSEXCEPTION();

    pNSL->pMD                 = (NDirectMethodDesc*)(pNSL->pFrame->GetFunction());
    MLHeader *pheader         = pNSL->pMD->GetMLHeader();
    UINT32 cbLocals           = pheader->m_cbLocals;
    BYTE *pdst                = ((BYTE*)pNSL) - NDIRECT_SLIM_CBDSTMAX - cbLocals;
    pNSL->pLocals             = pdst + NDIRECT_SLIM_CBDSTMAX;
    VOID *psrc                = (VOID*)(pNSL->pFrame);
    pNSL->pCleanup            = pNSL->pFrame->GetCleanupWorkList();

    LOG((LF_STUBS, LL_INFO1000, "Calling NDirectSlimStubWorker1 %s::%s \n", pNSL->pMD->m_pszDebugClassName, pNSL->pMD->m_pszDebugMethodName));

    if (pNSL->pCleanup) {
        // Checkpoint the current thread's fast allocator (used for temporary
        // buffers over the call) and schedule a collapse back to the checkpoint in
        // the cleanup list. Note that if we need the allocator, it is
        // guaranteed that a cleanup list has been allocated.
        void *pCheckpoint = pNSL->pThread->m_MarshalAlloc.GetCheckpoint();
        pNSL->pCleanup->ScheduleFastFree(pCheckpoint);
        pNSL->pCleanup->IsVisibleToGc();
    }

#ifdef _DEBUG
    FillMemory(pdst, NDIRECT_SLIM_CBDSTMAX+cbLocals, 0xcc);
#endif

    pNSL->pMLCode = RunML(pheader->GetMLCode(),
                          psrc,
                          pdst + pheader->m_cbDstBuffer,
                          (UINT8*const)(pNSL->pLocals),
                          pNSL->pCleanup);

    pNSL->pThread->EnablePreemptiveGC();

#ifdef PROFILING_SUPPORTED
    // Notify the profiler of transitions out of the runtime
    if (CORProfilerTrackTransitions())
    {
        g_profControlBlock.pProfInterface->
            ManagedToUnmanagedTransition((FunctionID) pNSL->pMD,
                                               COR_PRF_TRANSITION_CALL);
    }
#endif // PROFILING_SUPPORTED
}


INT64 __stdcall NDirectSlimStubWorker2(const NDirectSlimLocals *pNSL)
{
    THROWSCOMPLUSEXCEPTION();

    LOG((LF_STUBS, LL_INFO1000, "Calling NDirectSlimStubWorker2 %s::%s \n", pNSL->pMD->m_pszDebugClassName, pNSL->pMD->m_pszDebugMethodName));

#ifdef PROFILING_SUPPORTED
    // Notify the profiler of transitions out of the runtime
    if (CORProfilerTrackTransitions())
    {
        g_profControlBlock.pProfInterface->
            UnmanagedToManagedTransition((FunctionID) pNSL->pMD,
                                               COR_PRF_TRANSITION_RETURN);
    }
#endif // PROFILING_SUPPORTED

    pNSL->pThread->DisablePreemptiveGC();
    pNSL->pThread->HandleThreadAbort();
    INT64 returnValue;



    RunML(pNSL->pMLCode,
          &(pNSL->nativeRetVal),
          ((BYTE*)&returnValue) + 4, // We don't slimstub 64-bit returns
          (UINT8*const)(pNSL->pLocals),
          pNSL->pFrame->GetCleanupWorkList());

    if (pNSL->pCleanup) {
        pNSL->pCleanup->Cleanup(FALSE);
    }

    return returnValue;
}


//---------------------------------------------------------
// Creates the slim NDirect stub.
//---------------------------------------------------------
/* static */
Stub* NDirect::CreateSlimNDirectStub(StubLinker *pstublinker, NDirectMethodDesc *pMD, UINT numStackBytes)
{
    THROWSCOMPLUSEXCEPTION();

    _ASSERTE (!pMD->IsVarArg());

    BOOL fSaveLastError = FALSE;

    // Putting this in a local block to prevent the code below from seeing
    // the header. Since we sharing stubs based on the return value, we can't
    // customize based on the header.
    {
        {
            MLHeader *pheader    = pMD->GetMLHeader();

            if ( !(((pheader->m_Flags & MLHF_MANAGEDRETVAL_TYPECAT_MASK) 
                    != MLHF_TYPECAT_GCREF) &&
                   0 == (pheader->m_Flags & ~(MLHF_SETLASTERROR)) &&
                   pheader->m_cbDstBuffer <= NDIRECT_SLIM_CBDSTMAX &&
                   pheader->m_cbLocals + pheader->m_cbDstBuffer   <= 0x1000-100) ) {
                return NULL;
            }

            if (pheader->m_Flags & MLHF_SETLASTERROR) {
                fSaveLastError = TRUE;
            }
        }
    }

    //printf("Generating slim.\n");


    UINT key           = numStackBytes << 1;
    if (fSaveLastError) {
        key |= 1;
    }
    Stub *pStub = m_pNDirectSlimStubCache->GetStub(key);
    if (pStub) {
        return pStub;
    } else {


        CPUSTUBLINKER *psl = (CPUSTUBLINKER*)pstublinker;

        psl->EmitMethodStubProlog(NDirectMethodFrameSlim::GetMethodFrameVPtr());

        // pushes a CleanupWorkList.
        psl->X86EmitPushImm32(0);

        // Reserve space for NDirectSlimLocals (note this actually reserves
        // more space than necessary.)
        psl->X86EmitSubEsp(sizeof(NDirectSlimLocals));

        // Allocate & initialize leading NDirectSlimLocals fields
        psl->X86EmitPushReg(kEDI); _ASSERTE(8==offsetof(NDirectSlimLocals, savededi));
        psl->X86EmitPushReg(kESI); _ASSERTE(4==offsetof(NDirectSlimLocals, pFrame));
        psl->X86EmitPushReg(kEBX); _ASSERTE(0==offsetof(NDirectSlimLocals, pThread));

        // Save pointer to NDirectSlimLocals in edi.
        // mov edi,esp
        psl->Emit16(0xfc8b);

        // Save space for destination & ML local buffer.
        //  mov edx, [CURFRAME.MethodDesc]
        psl->X86EmitIndexRegLoad(kEDX, kESI, FramedMethodFrame::GetOffsetOfMethod());

        //  mov ecx, [edx + NDirectMethodDesc.ndirect.m_pMLStub]
        psl->X86EmitIndexRegLoad(kECX, kEDX, NDirectMethodDesc::GetOffsetofMLHeaderField());

        _ASSERTE(2 == sizeof(((MLHeader*)0)->m_cbLocals));
        //  movzx eax, word ptr [ecx + Stub.m_cbLocals]
        psl->Emit8(0x0f);
        psl->X86EmitOffsetModRM(0xb7, kEAX, kECX, offsetof(MLHeader,m_cbLocals));

        //  add eax, NDIRECT_SLIM_CBDSTMAX
        psl->Emit8(0x05);
        psl->Emit32(NDIRECT_SLIM_CBDSTMAX);

        psl->Push(NDIRECT_SLIM_CBDSTMAX);

        //  sub esp, eax
        psl->Emit16(0xe02b);

        // Invoke the first worker, passing it the address of NDirectSlimLocals.
        // This will marshal the parameters into the dst buffer and enable gc.
        psl->X86EmitPushReg(kEDI);
        psl->X86EmitCall(psl->NewExternalCodeLabel(NDirectSlimStubWorker1), 4);

        // Invoke the DLL target.
        //  mov eax, [CURFRAME.MethodDesc]
        psl->X86EmitIndexRegLoad(kEAX, kESI, FramedMethodFrame::GetOffsetOfMethod());
#if _DEBUG
        // Call through debugger logic to make sure it works
        psl->X86EmitCall(psl->NewExternalCodeLabel(Frame::CheckExitFrameDebuggerCalls), 0, TRUE);
#else
        //  call [eax + MethodDesc.NDirectTarget]
        psl->X86EmitOffsetModRM(0xff, (X86Reg)2, kEAX, NDirectMethodDesc::GetOffsetofNDirectTarget());
        psl->EmitReturnLabel();
#endif

        // Emit our call site return label


        if (fSaveLastError) {
            psl->EmitSaveLastError();
        }



        // Save away the raw return value
        psl->X86EmitIndexRegStore(kEDI, offsetof(NDirectSlimLocals, nativeRetVal), kEAX);
        psl->X86EmitIndexRegStore(kEDI, offsetof(NDirectSlimLocals, nativeRetVal) + 4, kEDX);

        // Invoke the second worker, passing it the address of NDirectSlimLocals.
        // This will marshal the return value into eax, and redisable gc.
        psl->X86EmitPushReg(kEDI);
        psl->X86EmitCall(psl->NewExternalCodeLabel(NDirectSlimStubWorker2), 4);

        // DO NOT TRASH EAX FROM HERE OUT.

        // Restore edi.
        // mov edi, [edi + savededi]
        psl->X86EmitIndexRegLoad(kEDI, kEDI, offsetof(NDirectSlimLocals, savededi));

        // must restore esp explicitly since we don't know whether the target
        // popped the args.
        // lea esp, [esi+xx]
        psl->X86EmitOffsetModRM(0x8d, (X86Reg)4 /*kESP*/, kESI, 0-FramedMethodFrame::GetNegSpaceSize());


        // Tear down frame and exit.
        psl->EmitMethodStubEpilog(numStackBytes, kNoTripStubStyle);

        Stub *pCandidate = psl->Link(SystemDomain::System()->GetStubHeap());
        Stub *pWinner = m_pNDirectSlimStubCache->AttemptToSetStub(key,pCandidate);
        pCandidate->DecRef();
        if (!pWinner) {
            COMPlusThrowOM();
        }
        return pWinner;
    }

}

// Note that this logic is copied below, in PopSEHRecords
__declspec(naked)
VOID __cdecl PopSEHRecords(LPVOID pTargetSP)
{
    __asm{
        mov     ecx, [esp+4]        ;; ecx <- pTargetSP
        mov     eax, fs:[0]         ;; get current SEH record
  poploop:
        cmp     eax, ecx
        jge     done
        mov     eax, [eax]          ;; get next SEH record
        jmp     poploop
  done:
        mov     fs:[0], eax
        retn
    }
}

// This is implmeneted differently from the PopSEHRecords b/c it's called
// in the context of the DebuggerRCThread - don't mess with this w/o
// talking to MiPanitz or MikeMag.
VOID PopSEHRecords(LPVOID pTargetSP, CONTEXT *pCtx, void *pSEH)
{
#ifdef _DEBUG
    LOG((LF_CORDB,LL_INFO1000, "\nPrintSEHRecords:\n"));
    
    EXCEPTION_REGISTRATION_RECORD *pEHR = (EXCEPTION_REGISTRATION_RECORD *)(size_t)*(DWORD *)pSEH;
    
    // check that all the eh frames are all greater than the current stack value. If not, the
    // stack has been updated somehow w/o unwinding the SEH chain.
    while (pEHR != NULL && pEHR != (void *)-1) 
    {
        LOG((LF_EH, LL_INFO1000000, "\t%08x: next:%08x handler:%x\n", pEHR, pEHR->Next, pEHR->Handler));
        pEHR = pEHR->Next;
    }                
#endif

    DWORD dwCur = *(DWORD*)pSEH; // 'EAX' in the original routine
    DWORD dwPrev = (DWORD)(size_t)pSEH;

    while (dwCur < (DWORD)(size_t)pTargetSP)
    {
        // Watch for the OS handler
        // for nested exceptions, or any C++ handlers for destructors in our call
        // stack, or anything else.
        if (dwCur < pCtx->Esp)
            dwPrev = dwCur;
            
        dwCur = *(DWORD *)(size_t)dwCur;
        
        LOG((LF_CORDB,LL_INFO10000, "dwCur: 0x%x dwPrev:0x%x pTargetSP:0x%x\n", 
            dwCur, dwPrev, pTargetSP));
    }

    *(DWORD *)(size_t)dwPrev = dwCur;

#ifdef _DEBUG
    pEHR = (EXCEPTION_REGISTRATION_RECORD *)(size_t)*(DWORD *)pSEH;
    // check that all the eh frames are all greater than the current stack value. If not, the
    // stack has been updated somehow w/o unwinding the SEH chain.

    LOG((LF_CORDB,LL_INFO1000, "\nPopSEHRecords:\n"));
    while (pEHR != NULL && pEHR != (void *)-1) 
    {
        LOG((LF_EH, LL_INFO1000000, "\t%08x: next:%08x handler:%x\n", pEHR, pEHR->Next, pEHR->Handler));
        pEHR = pEHR->Next;
    }                
#endif
}

//////////////////////////////////////////////////////////////////////////////
//
// JITInterface
//
//////////////////////////////////////////////////////////////////////////////

/*********************************************************************/
#pragma warning(disable:4725)
float __stdcall JIT_FltRem(float divisor, float dividend)
{
    __asm {
        fld     divisor
        fld     dividend
fremloop:
        fprem
        fstsw   ax
        fwait
        sahf
        jp      fremloop    ; Continue while the FPU status bit C2 is set
        fstp    dividend
        fstp    ST(0)       ; Pop the divisor from the FP stack
    }
    return dividend;
}
#pragma warning(default:4725)

/*********************************************************************/
#pragma warning(disable:4725)
double __stdcall JIT_DblRem(double divisor, double dividend)
{
    __asm {
        fld     divisor
        fld     dividend
remloop:
        fprem
        fstsw   ax
        fwait
        sahf
        jp      remloop     ; Continue while the FPU status bit C2 is set
        fstp    dividend
        fstp    ST(0)       ; Pop the divisor from the FP stack
    }
    return dividend;
}
#pragma warning(default:4725)

/*********************************************************************/

#pragma warning (disable : 4731)
void ResumeAtJit(PCONTEXT pContext, LPVOID oldESP)
{
#ifdef _DEBUG
    DWORD curESP;
    __asm mov curESP, esp
#endif

    if (oldESP)
    {
        _ASSERTE(curESP < (DWORD)(size_t)oldESP);

        PopSEHRecords(oldESP);
    }

    // For the "push Eip, ..., ret"
    _ASSERTE(curESP < pContext->Esp - sizeof(DWORD));
    pContext->Esp -= sizeof(DWORD);

    __asm {
        mov     ebp, pContext

        // Push Eip onto the targetESP, so that the final "ret" will consume it
        mov     ecx, [ebp]CONTEXT.Esp
        mov     edx, [ebp]CONTEXT.Eip
        mov     [ecx], edx

        // Restore all registers except Esp, Ebp, Eip
        mov     eax, [ebp]CONTEXT.Eax
        mov     ebx, [ebp]CONTEXT.Ebx
        mov     ecx, [ebp]CONTEXT.Ecx
        mov     edx, [ebp]CONTEXT.Edx
        mov     esi, [ebp]CONTEXT.Esi
        mov     edi, [ebp]CONTEXT.Edi

        push    [ebp]CONTEXT.Esp  // pContext->Esp is (targetESP-sizeof(DWORD))
        push    [ebp]CONTEXT.Ebp
        pop     ebp
        pop     esp

        // esp is (targetESP-sizeof(DWORD)), and [esp] is the targetEIP.
        // The ret will set eip to targetEIP and esp will be automatically
        // incremented to targetESP

        ret
    }
}
#pragma warning (default : 4731)

/*********************************************************************/
// Get X86Reg indexes of argument registers (indices start from 0).
X86Reg GetX86ArgumentRegister(unsigned int index)
{
    _ASSERT(index >= 0 && index < NUM_ARGUMENT_REGISTERS);

    static X86Reg table[] = {
#define DEFINE_ARGUMENT_REGISTER(regname) k##regname,
#include "eecallconv.h"
    };
    return table[index];
}



// Get X86Reg indexes of argument registers based on offset into ArgumentRegister
X86Reg GetX86ArgumentRegisterFromOffset(size_t ofs)
{
#define DEFINE_ARGUMENT_REGISTER(reg) if (ofs == offsetof(ArgumentRegisters, reg)) return k##reg;
#include "eecallconv.h"
    _ASSERTE(0);//Can't get here.
    return kEBP;
}



static VOID LoadArgIndex(StubLinkerCPU *psl, ShuffleEntry *pShuffleEntry, size_t argregofs, X86Reg reg, UINT espadjust)
{
    THROWSCOMPLUSEXCEPTION();
    argregofs |= ShuffleEntry::REGMASK;

    while (pShuffleEntry->srcofs != ShuffleEntry::SENTINEL) {
        if ( pShuffleEntry->dstofs == argregofs) {
            if (pShuffleEntry->srcofs & ShuffleEntry::REGMASK) {

                psl->Emit8(0x8b);
                psl->Emit8(0300 |
                           (GetX86ArgumentRegisterFromOffset( pShuffleEntry->dstofs & ShuffleEntry::OFSMASK ) << 3) |
                           (GetX86ArgumentRegisterFromOffset( pShuffleEntry->srcofs & ShuffleEntry::OFSMASK )));

            } else {
                psl->X86EmitIndexRegLoad(reg, kEAX, pShuffleEntry->srcofs+espadjust);
            }
            break;
        }
        pShuffleEntry++;
    }
}

//===========================================================================
// Emits code to adjust for a static delegate target.
VOID StubLinkerCPU::EmitShuffleThunk(ShuffleEntry *pShuffleEntryArray)
{
    THROWSCOMPLUSEXCEPTION();

    UINT espadjust = 4;


    // save the real target on the stack (will jump to it later)
    // push [ecx + Delegate._methodptraux]
    X86EmitIndexPush(THIS_kREG, Object::GetOffsetOfFirstField() + COMDelegate::m_pFPAuxField->GetOffset());


    // mov SCRATCHREG,esp
    Emit8(0x8b);
    Emit8(0304 | (SCRATCH_REGISTER_X86REG << 3));

    // Load any enregistered arguments first. Order is important.
#define DEFINE_ARGUMENT_REGISTER(reg) LoadArgIndex(this, pShuffleEntryArray, offsetof(ArgumentRegisters, reg), k##reg, espadjust);
#include "eecallconv.h"


    // Now shift any nonenregistered arguments.
    ShuffleEntry *pWalk = pShuffleEntryArray;
    while (pWalk->srcofs != ShuffleEntry::SENTINEL) {
        if (!(pWalk->dstofs & ShuffleEntry::REGMASK)) {
            if (pWalk->srcofs & ShuffleEntry::REGMASK) {
                X86EmitPushReg( GetX86ArgumentRegisterFromOffset( pWalk->srcofs & ShuffleEntry::OFSMASK ) );
            } else {
                X86EmitIndexPush(kEAX, pWalk->srcofs+espadjust);
            }
        }

        pWalk++;
    }

    // Capture the stacksizedelta while we're at the end of the list.
    _ASSERTE(pWalk->srcofs == ShuffleEntry::SENTINEL);
    UINT16 stacksizedelta = pWalk->stacksizedelta;

    if (pWalk != pShuffleEntryArray) {
        do {
            pWalk--;
            if (!(pWalk->dstofs & ShuffleEntry::REGMASK)) {
                X86EmitIndexPop(kEAX, pWalk->dstofs+espadjust);
            }


        } while (pWalk != pShuffleEntryArray);
    }

    X86EmitPopReg(SCRATCH_REGISTER_X86REG);

    X86EmitAddEsp(stacksizedelta);
    // Now jump to real target
    //   JMP SCRATCHREG
    Emit16(0xe0ff | (SCRATCH_REGISTER_X86REG<<8));
}

//===========================================================================
VOID ECThrowNull()
{
    THROWSCOMPLUSEXCEPTION();
    COMPlusThrow(kNullReferenceException);
}

//===========================================================================
// Emits code for MulticastDelegate.Invoke()
VOID StubLinkerCPU::EmitMulticastInvoke(UINT32 sizeofactualfixedargstack, BOOL fSingleCast, BOOL fReturnFloat)
{
    THROWSCOMPLUSEXCEPTION();

    CodeLabel *pNullLabel = NewCodeLabel();

    _ASSERTE(THIS_kREG == kECX); //If this macro changes, have to change hardcoded emit below
    // cmp THISREG, 0
    Emit16(0xf983);
    Emit8(0);

    // jz null
    X86EmitCondJump(pNullLabel, X86CondCode::kJZ);


    if (fSingleCast)
    {
        _ASSERTE(COMDelegate::m_pFPField);
        _ASSERTE(COMDelegate::m_pORField);

        // mov SCRATCHREG, [THISREG + Delegate.FP]  ; Save target stub in register
        X86EmitIndexRegLoad(SCRATCH_REGISTER_X86REG, THIS_kREG, Object::GetOffsetOfFirstField() + COMDelegate::m_pFPField->GetOffset());
    
        // mov THISREG, [THISREG + Delegate.OR]  ; replace "this" pointer
        X86EmitIndexRegLoad(THIS_kREG, THIS_kREG, Object::GetOffsetOfFirstField() + COMDelegate::m_pORField->GetOffset());
    
        // discard unwanted MethodDesc
        X86EmitAddEsp(sizeof(MethodDesc*));
    
        // jmp SCRATCHREG
        Emit16(0xe0ff | (SCRATCH_REGISTER_X86REG<<8));

    }
    else 
    {

        _ASSERTE(COMDelegate::m_pFPField);
        _ASSERTE(COMDelegate::m_pORField);
        _ASSERTE(COMDelegate::m_pPRField);
    
    
        CodeLabel *pMultiCaseLabel = NewCodeLabel();


        // There is a dependency between this and the StubLinkStubManager - dont' change
        // this without fixing up that.     --MiPanitz
        // cmp dword ptr [THISREG + Delegate.PR], 0  ; multiple subscribers?
        X86EmitOffsetModRM(0x81, (X86Reg)7, THIS_kREG, Object::GetOffsetOfFirstField() + COMDelegate::m_pPRField->GetOffset());
        Emit32(0);
    
        // jnz MultiCase
        X86EmitCondJump(pMultiCaseLabel, X86CondCode::kJNZ);
    
        // Only one subscriber. Do the simple jump.
    
        // mov SCRATCHREG, [THISREG + Delegate.FP]  ; Save target stub in register
        X86EmitIndexRegLoad(SCRATCH_REGISTER_X86REG, THIS_kREG, Object::GetOffsetOfFirstField() + COMDelegate::m_pFPField->GetOffset());
    
        // mov THISREG, [THISREG + Delegate.OR]  ; replace "this" pointer
        X86EmitIndexRegLoad(THIS_kREG, THIS_kREG, Object::GetOffsetOfFirstField() + COMDelegate::m_pORField->GetOffset());
    
        // discard unwanted MethodDesc
        X86EmitAddEsp(sizeof(MethodDesc*));
    
        // jmp SCRATCHREG
        Emit16(0xe0ff | (SCRATCH_REGISTER_X86REG<<8));
    
    
        // The multiple subscriber case. Must create a frame to protect arguments during iteration.
        EmitLabel(pMultiCaseLabel);
    
    
        // Push a MulticastFrame on the stack.
        EmitMethodStubProlog(MulticastFrame::GetMethodFrameVPtr());
    
        // push edi     ;; Save EDI (want to use it as loop index)
        X86EmitPushReg(kEDI);
    
        // push ebx     ;; Save EBX (want to use it as tmp)
        X86EmitPushReg(kEBX);
    
        // xor edi,edi  ;; Loop counter: EDI=0,1,2...
        Emit16(0xff33);
    
        CodeLabel *pInvokeRecurseLabel = NewCodeLabel();
    
    
        // call InvokeRecurse               ;; start the recursion rolling
        X86EmitCall(pInvokeRecurseLabel, 0);
    
        // pop ebx     ;; Restore ebx
        X86EmitPopReg(kEBX);
    
        // pop edi     ;; Restore edi
        X86EmitPopReg(kEDI);
    
    
        // Epilog
        EmitMethodStubEpilog(sizeofactualfixedargstack, kNoTripStubStyle);
    
    
        // Entry:
        //   EDI == distance from head of delegate list
        // INVOKERECURSE:
    
        EmitLabel(pInvokeRecurseLabel);
    
        // This is disgusting. We can't use the current delegate pointer itself
        // as the recursion variable because gc can move it during the recursive call.
        // So we use the index itself and walk down the list from the promoted
        // head pointer each time.
    
    
        // mov SCRATCHREG, [esi + this]     ;; get head of list delegate
        X86EmitIndexRegLoad(SCRATCH_REGISTER_X86REG, kESI, MulticastFrame::GetOffsetOfThis());
    
        // mov ebx, edi
        Emit16(0xdf8b);
        CodeLabel *pLoop1Label = NewCodeLabel();
        CodeLabel *pEndLoop1Label = NewCodeLabel();
    
        // LOOP1:
        EmitLabel(pLoop1Label);
    
        // cmp ebx,0
        Emit16(0xfb83); Emit8(0);
    
        // jz ENDLOOP1
        X86EmitCondJump(pEndLoop1Label, X86CondCode::kJZ);
    
        // mov SCRATCHREG, [SCRATCHREG+Delegate._prev]
        X86EmitIndexRegLoad(SCRATCH_REGISTER_X86REG, SCRATCH_REGISTER_X86REG, Object::GetOffsetOfFirstField() + COMDelegate::m_pPRField->GetOffset());
    
        // dec ebx
        Emit8(0x4b);
    
        // jmp LOOP1
        X86EmitNearJump(pLoop1Label);
    
        //ENDLOOP1:
        EmitLabel(pEndLoop1Label);
    
        //    cmp SCRATCHREG,0      ;;done?
        Emit8(0x81);
        Emit8(0xf8 | SCRATCH_REGISTER_X86REG);
        Emit32(0);
    
    
        CodeLabel *pDoneLabel = NewCodeLabel();
    
        //    jz  done
        X86EmitCondJump(pDoneLabel, X86CondCode::kJZ);
    
        //    inc edi
        Emit8(0x47);
    
        //    call INVOKERECURSE    ;; cast to the tail
        X86EmitCall(pInvokeRecurseLabel, 0);
    
        //    dec edi
        Emit8(0x4f);
    
        // Gotta go retrieve the current delegate again.
    
        // mov SCRATCHREG, [esi + this]     ;; get head of list delegate
        X86EmitIndexRegLoad(SCRATCH_REGISTER_X86REG, kESI, MulticastFrame::GetOffsetOfThis());
    
        // mov ebx, edi
        Emit16(0xdf8b);
        CodeLabel *pLoop2Label = NewCodeLabel();
        CodeLabel *pEndLoop2Label = NewCodeLabel();
    
        // Loop2:
        EmitLabel(pLoop2Label);
    
        // cmp ebx,0
        Emit16(0xfb83); Emit8(0);
    
        // jz ENDLoop2
        X86EmitCondJump(pEndLoop2Label, X86CondCode::kJZ);
    
        // mov SCRATCHREG, [SCRATCHREG+Delegate._prev]
        X86EmitIndexRegLoad(SCRATCH_REGISTER_X86REG, SCRATCH_REGISTER_X86REG, Object::GetOffsetOfFirstField() + COMDelegate::m_pPRField->GetOffset());
    
        // dec ebx
        Emit8(0x4b);
    
        // jmp Loop2
        X86EmitNearJump(pLoop2Label);
    
        //ENDLoop2:
        EmitLabel(pEndLoop2Label);
    
    
        //    ..repush & reenregister args..
        INT32 ofs = sizeofactualfixedargstack + MulticastFrame::GetOffsetOfArgs();
        while (ofs != MulticastFrame::GetOffsetOfArgs())
        {
            ofs -= 4;
            X86EmitIndexPush(kESI, ofs);
        }
    
    #define DEFINE_ARGUMENT_REGISTER_BACKWARD_WITH_OFFSET(regname, regofs) if (k##regname != THIS_kREG) { X86EmitIndexRegLoad(k##regname, kESI, regofs + MulticastFrame::GetOffsetOfArgumentRegisters()); }
    #include "eecallconv.h"
    
        //    mov THISREG, [SCRATCHREG+Delegate.object]  ;;replace "this" poiner
        X86EmitIndexRegLoad(THIS_kREG, SCRATCH_REGISTER_X86REG, Object::GetOffsetOfFirstField() + COMDelegate::m_pORField->GetOffset());
    
        //    call [SCRATCHREG+Delegate.target] ;; call current subscriber
        X86EmitOffsetModRM(0xff, (X86Reg)2, SCRATCH_REGISTER_X86REG, Object::GetOffsetOfFirstField() + COMDelegate::m_pFPField->GetOffset());
		INDEBUG(Emit8(0x90));       // Emit a nop after the call in debug so that
                                    // we know that this is a call that can directly call 
                                    // managed code

        if (fReturnFloat) {
            // if the return value is a float/double check the value of EDI and if not 0 (not last call)
            // emit the pop of the float stack 
            // mov ebx, edi
            Emit16(0xdf8b);
            // cmp ebx,0
            Emit16(0xfb83); Emit8(0);
            // jnz ENDLoop2
            CodeLabel *pNoFloatStackPopLabel = NewCodeLabel();
            X86EmitCondJump(pNoFloatStackPopLabel, X86CondCode::kJZ);
            // fstp 0
            Emit16(0xd8dd);
            // NoFloatStackPopLabel:
            EmitLabel(pNoFloatStackPopLabel);
        }
        // The debugger may need to stop here, so grab the offset of this code.
        EmitDebuggerIntermediateLabel();
        //
        //
        //  done:
        EmitLabel(pDoneLabel);
    
        X86EmitReturn(0);


    }

    // Do a null throw
    EmitLabel(pNullLabel);
    EmitMethodStubProlog(ECallMethodFrame::GetMethodFrameVPtr());

    // We're going to be clever, in that we're going to record the offset of the last instruction,
    // and the diff between this and the call behind us
    EmitPatchLabel();

    X86EmitCall(NewExternalCodeLabel(ECThrowNull), 0);
}

//#define ARRAYOPACCUMOFS     0
//#define ARRAYOPMULTOFS      4
//#define ARRAYOPMETHODDESC   8
#define ARRAYOPLOCSIZE      12
// ARRAYOPACCUMOFS and ARRAYOPMULTOFS should have been popped by our callers.
#define ARRAYOPLOCSIZEFORPOP (ARRAYOPLOCSIZE-8)

VOID __cdecl InternalExceptionWorker();

// EAX -> number of caller arg bytes on the stack that we must remove before going
// to the throw helper, which assumes the stack is clean.
__declspec(naked)
VOID __cdecl ArrayOpStubNullException()
{
    __asm{
        add    esp, ARRAYOPLOCSIZEFORPOP
        pop    edx              // recover RETADDR
        add    esp, eax         // release caller's args
        push   edx              // restore RETADDR
        mov    ARGUMENT_REG1, CORINFO_NullReferenceException
        jmp    InternalExceptionWorker
    }
}


// EAX -> number of caller arg bytes on the stack that we must remove before going
// to the throw helper, which assumes the stack is clean.
__declspec(naked)
VOID __cdecl ArrayOpStubRangeException()
{
    __asm{
        add    esp, ARRAYOPLOCSIZEFORPOP
        pop    edx              // recover RETADDR
        add    esp, eax         // release caller's args
        push   edx              // restore RETADDR
        mov    ARGUMENT_REG1, CORINFO_IndexOutOfRangeException
        jmp    InternalExceptionWorker
    }
}

// EAX -> number of caller arg bytes on the stack that we must remove before going
// to the throw helper, which assumes the stack is clean.
__declspec(naked)
VOID __cdecl ArrayOpStubTypeMismatchException()
{
    __asm{
        add    esp, ARRAYOPLOCSIZEFORPOP
        pop    edx              // recover RETADDR
        add    esp, eax         // release caller's args
        push   edx              // restore RETADDR
        mov    ARGUMENT_REG1, CORINFO_ArrayTypeMismatchException
        jmp    InternalExceptionWorker
    }
}

//little helper to generate code to move nbytes bytes of non Ref memory
void generate_noref_copy (unsigned nbytes, StubLinkerCPU* sl)
{
        if ((nbytes & ~0xC) == 0)               // Is it 4, 8, or 12 ?
        {
                while (nbytes > 0)
                {
                        sl->Emit8(0xa5);        // movsd
                        nbytes -= 4;
                }
                return;
        }

    //copy the start before the first pointer site
    sl->Emit8(0xb8+kECX);
    if ((nbytes & 3) == 0)
    {               // move words
        sl->Emit32(nbytes / sizeof(void*)); // mov ECX, size / 4
        sl->Emit16(0xa5f3);                 // repe movsd
    }
    else
    {
        sl->Emit32(nbytes);     // mov ECX, size
        sl->Emit16(0xa4f3);     // repe movsb
    }
}

//===========================================================================
// This routine is called if the Array store needs a frame constructed
// in order to do the array check.  It should only be called from
// the array store check helpers.

HCIMPL2(BOOL, ArrayStoreCheck, Object** pElement, PtrArray** pArray)
    BOOL ret;
    HELPER_METHOD_FRAME_BEGIN_RET_ATTRIB_2(Frame::FRAME_ATTR_CAPUTURE_DEPTH_2 | Frame::FRAME_ATTR_EXACT_DEPTH, *pElement, *pArray);

#ifdef STRESS_HEAP
    // Force a GC on every jit if the stress level is high enough
    if (g_pConfig->GetGCStressLevel() != 0
#ifdef _DEBUG
        && !g_pConfig->FastGCStressLevel()
#endif
        )
        g_pGCHeap->StressHeap();
#endif

#if CHECK_APP_DOMAIN_LEAKS
    if (g_pConfig->AppDomainLeaks())
      (*pElement)->AssignAppDomain((*pArray)->GetAppDomain());
#endif
    
    ret = ObjIsInstanceOf(*pElement, (*pArray)->GetElementTypeHandle());
    
    HELPER_METHOD_FRAME_END();
    return(ret);
HCIMPLEND

//===========================================================================
// Emits code to do an array operation.
VOID StubLinkerCPU::EmitArrayOpStub(const ArrayOpScript* pArrayOpScript)
{
    THROWSCOMPLUSEXCEPTION();

    const UINT  locsize     = ARRAYOPLOCSIZE;
    const UINT  ofsadjust   = locsize - FramedMethodFrame::GetOffsetOfReturnAddress();

    // Working registers:
    //  THIS_kREG     (points to managed array)
    //  edi == total  (accumulates unscaled offset)
    //  esi == factor (accumulates the slice factor)
    const X86Reg kArrayRefReg = THIS_kREG;
    const X86Reg kTotalReg    = kEDI;
    const X86Reg kFactorReg   = kESI;
    extern BYTE JIT_UP_WriteBarrierReg_Buf[8][41];

    CodeLabel *Epilog = NewCodeLabel();
    CodeLabel *Inner_nullexception = NewCodeLabel();
    CodeLabel *Inner_rangeexception = NewCodeLabel();
    CodeLabel *Inner_typeMismatchexception = 0;

    // Preserve the callee-saved registers
    _ASSERTE(ARRAYOPLOCSIZE - sizeof(MethodDesc*) == 8);
    X86EmitPushReg(kTotalReg);
    X86EmitPushReg(kFactorReg);

    // Check for null.
        X86EmitR2ROp(0x85, kArrayRefReg, kArrayRefReg);                         //   TEST ECX, ECX
    X86EmitCondJump(Inner_nullexception, X86CondCode::kJZ);     //   jz  Inner_nullexception

    // Do Type Check if needed
    if (pArrayOpScript->m_flags & ArrayOpScript::NEEDSTYPECHECK) {
        // throw exception if failed
        Inner_typeMismatchexception = NewCodeLabel();
        if (pArrayOpScript->m_op == ArrayOpScript::STORE) {
                                // Get the value to be stored.
            X86EmitEspOffset(0x8b, kEAX, pArrayOpScript->m_fValLoc + ofsadjust);

            X86EmitR2ROp(0x85, kEAX, kEAX);                                     //   TEST EAX, EAX
            CodeLabel *CheckPassed = NewCodeLabel();
            X86EmitCondJump(CheckPassed, X86CondCode::kJZ);             // storing NULL is OK

                        X86EmitOp(0x8b, kEAX, kEAX, 0);                                         // mov EAX, [EAX]
                                                                                                                // cmp EAX, [ECX+m_ElementType];
            X86EmitOp(0x3b, kEAX, kECX, offsetof(PtrArray, m_ElementType));
            X86EmitCondJump(CheckPassed, X86CondCode::kJZ);             // Exact match is OK

                        Emit8(0xA1);                                                                            // mov EAX, [g_pObjectMethodTable]
                        Emit32((DWORD)(size_t) &g_pObjectClass);
            X86EmitOp(0x3b, kEAX, kECX, offsetof(PtrArray, m_ElementType));
            X86EmitCondJump(CheckPassed, X86CondCode::kJZ);             // Assigning to array of object is OK

                // TODO we can avoid calling the slow helper if the
                // object being assigned is not a COM object.

            X86EmitPushReg(kEDX);      // Save EDX
            X86EmitPushReg(kECX);      // pass array object

                                // get address of value to store
            X86EmitEspOffset(0x8d, kECX, pArrayOpScript->m_fValLoc + ofsadjust + 2*sizeof(void*));      // lea ECX, [ESP+offs]
                                // get address of 'this'
            X86EmitEspOffset(0x8d, kEDX, 0);    // lea EDX, [ESP]       (address of ECX)

            X86EmitCall(NewExternalCodeLabel(ArrayStoreCheck), 0);


            X86EmitPopReg(kECX);        // restore regs
            X86EmitPopReg(kEDX);

            X86EmitR2ROp(0x3B, kEAX, kEAX);                             //   CMP EAX, EAX
            X86EmitCondJump(Epilog, X86CondCode::kJNZ);         // This branch never taken, but epilog walker uses it

            X86EmitR2ROp(0x85, kEAX, kEAX);                             //   TEST EAX, EAX
            X86EmitCondJump(Inner_typeMismatchexception, X86CondCode::kJZ);

            EmitLabel(CheckPassed);
        }
        else if (pArrayOpScript->m_op == ArrayOpScript::LOADADDR) {
            // Load up the hidden type parameter into 'typeReg'

            X86Reg typeReg = kEAX;
            if (pArrayOpScript->m_typeParamReg != -1)
                typeReg = GetX86ArgumentRegisterFromOffset(pArrayOpScript->m_typeParamReg);
            else
                 X86EmitEspOffset(0x8b, kEAX, pArrayOpScript->m_typeParamOffs + ofsadjust);              // Guarenteed to be at 0 offset

            // EAX holds the typeHandle for the ARRAY.  This must be a ArrayTypeDesc*, so
            // mask off the low two bits to get the TypeDesc*
            X86EmitR2ROp(0x83, (X86Reg)4, kEAX);    //   AND EAX, 0xFFFFFFFC
            Emit8(0xFC);

            // Get the parameter of the parameterize type
            // move typeReg, [typeReg.m_Arg]
            X86EmitOp(0x8b, typeReg, typeReg, offsetof(ParamTypeDesc, m_Arg));

            // Compare this against the element type of the array.
            // cmp EAX, [ECX+m_ElementType];
            X86EmitOp(0x3b, typeReg, kECX, offsetof(PtrArray, m_ElementType));

            // Throw error if not equal
            X86EmitCondJump(Inner_typeMismatchexception, X86CondCode::kJNZ);
        }
    }

    CodeLabel* DoneCheckLabel = 0;
    if (pArrayOpScript->m_rank == 1 && pArrayOpScript->m_fHasLowerBounds) {
        DoneCheckLabel = NewCodeLabel();
        CodeLabel* NotSZArrayLabel = NewCodeLabel();

        // for rank1 arrays, we might actually have two different layouts depending on
        // if we are ELEMENT_TYPE_ARRAY or ELEMENT_TYPE_SZARRAY.

            // mov EAX, [ARRAY]          // EAX holds the method table
        X86EmitOp(0x8b, kEAX, kArrayRefReg);

        // cmp BYTE [EAX+m_NormType], ELEMENT_TYPE_SZARRAY
        static BYTE code[] = {0x80, 0x78, offsetof(MethodTable, m_NormType), ELEMENT_TYPE_SZARRAY };
        EmitBytes(code, sizeof(code));

            // jz NotSZArrayLabel
        X86EmitCondJump(NotSZArrayLabel, X86CondCode::kJNZ);

            //Load the passed-in index into the scratch register.
        const ArrayOpIndexSpec *pai = pArrayOpScript->GetArrayOpIndexSpecs();
        X86Reg idxReg = SCRATCH_REGISTER_X86REG;
        if (pai->m_freg)
            idxReg = GetX86ArgumentRegisterFromOffset(pai->m_idxloc);
        else
            X86EmitEspOffset(0x8b, SCRATCH_REGISTER_X86REG, pai->m_idxloc + ofsadjust);

            // cmp idxReg, [kArrayRefReg + LENGTH]
        X86EmitOp(0x3b, idxReg, kArrayRefReg, ArrayBase::GetOffsetOfNumComponents());

            // jae Inner_rangeexception
        X86EmitCondJump(Inner_rangeexception, X86CondCode::kJAE);

            // TODO if we cared efficiency of this, this move can be optimized
        X86EmitR2ROp(0x8b, kTotalReg, idxReg);

            // sub ARRAY. 8                  // 8 is accounts for the Lower bound and Dim count in the ARRAY
        X86EmitSubReg(kArrayRefReg, 8);      // adjust this pointer so that indexing works out for SZARRAY

        X86EmitNearJump(DoneCheckLabel);
        EmitLabel(NotSZArrayLabel);
    }

    if (pArrayOpScript->m_flags & ArrayOpScript::FLATACCESSOR) {
                // For the GetAt, SetAt, AddressAt accessors, we only have one index, and it is zero based

            //Load the passed-in index into the scratch register.
        const ArrayOpIndexSpec *pai = pArrayOpScript->GetArrayOpIndexSpecs();
        X86Reg idxReg = SCRATCH_REGISTER_X86REG;
        if (pai->m_freg)
            idxReg = GetX86ArgumentRegisterFromOffset(pai->m_idxloc);
        else
            X86EmitEspOffset(0x8b, SCRATCH_REGISTER_X86REG, pai->m_idxloc + ofsadjust);

            // cmp idxReg, [kArrayRefReg + LENGTH]
        X86EmitOp(0x3b, idxReg, kArrayRefReg, ArrayBase::GetOffsetOfNumComponents());

            // jae Inner_rangeexception
        X86EmitCondJump(Inner_rangeexception, X86CondCode::kJAE);

            // TODO if we cared efficiency of this, this move can be optimized
        X86EmitR2ROp(0x8b, kTotalReg, idxReg);
        }
        else {
                // For each index, range-check and mix into accumulated total.
                UINT idx = pArrayOpScript->m_rank;
                BOOL firstTime = TRUE;
                while (idx--) {
                        const ArrayOpIndexSpec *pai = pArrayOpScript->GetArrayOpIndexSpecs() + idx;

                        //Load the passed-in index into the scratch register.
                        if (pai->m_freg) {
                                X86Reg srcreg = GetX86ArgumentRegisterFromOffset(pai->m_idxloc);
                                X86EmitR2ROp(0x8b, SCRATCH_REGISTER_X86REG, srcreg);
                        } else {
                                X86EmitEspOffset(0x8b, SCRATCH_REGISTER_X86REG, pai->m_idxloc + ofsadjust);
                        }

                        // sub SCRATCH, [kArrayRefReg + LOWERBOUND]
                        if (pArrayOpScript->m_fHasLowerBounds) {
                                X86EmitOp(0x2b, SCRATCH_REGISTER_X86REG, kArrayRefReg, pai->m_lboundofs);
                        }

                        // cmp SCRATCH, [kArrayRefReg + LENGTH]
                        X86EmitOp(0x3b, SCRATCH_REGISTER_X86REG, kArrayRefReg, pai->m_lengthofs);

                        // jae Inner_rangeexception
                        X86EmitCondJump(Inner_rangeexception, X86CondCode::kJAE);


                        // SCRATCH == idx - LOWERBOUND
                        //
                        // imul SCRATCH, FACTOR
                        if (!firstTime) {  //Can skip the first time since FACTOR==1
                                Emit8(0x0f);        //prefix for IMUL
                                X86EmitR2ROp(0xaf, SCRATCH_REGISTER_X86REG, kFactorReg);
                        }

                        // TOTAL += SCRATCH
                        if (firstTime) {
                                // First time, we must zero-init TOTAL. Since
                                // zero-initing and then adding is just equivalent to a
                                // "mov", emit a "mov"
                                //    mov  TOTAL, SCRATCH
                                X86EmitR2ROp(0x8b, kTotalReg, SCRATCH_REGISTER_X86REG);
                        } else {
                                //    add  TOTAL, SCRATCH
                                X86EmitR2ROp(0x03, kTotalReg, SCRATCH_REGISTER_X86REG);
                        }

                        // FACTOR *= [kArrayRefReg + LENGTH]
                        if (idx != 0) {  // No need to update FACTOR on the last iteration
                                //  since we won't use it again

                                if (firstTime) {
                                        // must init FACTOR to 1 first: hence,
                                        // the "imul" becomes a "mov"
                                        // mov FACTOR, [kArrayRefReg + LENGTH]
                                        X86EmitOp(0x8b, kFactorReg, kArrayRefReg, pai->m_lengthofs);
                                } else {
                                        // imul FACTOR, [kArrayRefReg + LENGTH]
                                        Emit8(0x0f);        //prefix for IMUL
                                        X86EmitOp(0xaf, kFactorReg, kArrayRefReg, pai->m_lengthofs);
                                }
                        }

                        firstTime = FALSE;
                }
        }

    if (DoneCheckLabel != 0)
        EmitLabel(DoneCheckLabel);

    // Pass these values to X86EmitArrayOp() to generate the element address.
    X86Reg elemBaseReg   = kArrayRefReg;
    X86Reg elemScaledReg = kTotalReg;
    UINT32 elemScale     = pArrayOpScript->m_elemsize;
    UINT32 elemOfs       = pArrayOpScript->m_ofsoffirst;

    if (!(elemScale == 1 || elemScale == 2 || elemScale == 4 || elemScale == 8)) {
        switch (elemScale) {
            // No way to express this as a SIB byte. Fold the scale
            // into TOTAL.

            case 16:
                // shl TOTAL,4
                Emit8(0xc1);
                Emit8(0340|kTotalReg);
                Emit8(4);
                break;


            case 32:
                // shl TOTAL,5
                Emit8(0xc1);
                Emit8(0340|kTotalReg);
                Emit8(5);
                break;


            case 64:
                // shl TOTAL,6
                Emit8(0xc1);
                Emit8(0340|kTotalReg);
                Emit8(6);
                break;

            default:
                // imul TOTAL, elemScale
                X86EmitR2ROp(0x69, kTotalReg, kTotalReg);
                Emit32(elemScale);
                break;
        }
        elemScale = 1;
    }

    // Now, do the operation:

    switch (pArrayOpScript->m_op) {
        case pArrayOpScript->LOADADDR:
            // lea eax, ELEMADDR
            X86EmitOp(0x8d, kEAX, elemBaseReg, elemOfs, elemScaledReg, elemScale);
            break;


        case pArrayOpScript->LOAD:
            if (pArrayOpScript->m_flags & pArrayOpScript->HASRETVALBUFFER)
            {
                // Ensure that these registers have been saved!
                _ASSERTE(kTotalReg == kEDI);
                _ASSERTE(kFactorReg == kESI);

                //lea esi, ELEMADDR
                X86EmitOp(0x8d, kESI, elemBaseReg, elemOfs, elemScaledReg, elemScale);

                _ASSERTE(pArrayOpScript->m_fRetBufInReg);
                // mov edi, retbufptr
                X86EmitR2ROp(0x8b, kEDI, GetX86ArgumentRegisterFromOffset(pArrayOpScript->m_fRetBufLoc));

            COPY_VALUE_CLASS:
                {
                    int size = pArrayOpScript->m_elemsize;
                    int total = 0;
                    if(pArrayOpScript->m_gcDesc)
                    {
                        CGCDescSeries* cur = pArrayOpScript->m_gcDesc->GetHighestSeries();
                        // special array encoding
                        _ASSERTE(cur < pArrayOpScript->m_gcDesc->GetLowestSeries());
                        if ((cur->startoffset-elemOfs) > 0)
                            generate_noref_copy (cur->startoffset - elemOfs, this);
                        total += cur->startoffset - elemOfs;

                        int cnt = pArrayOpScript->m_gcDesc->GetNumSeries();

                        for (int __i = 0; __i > cnt; __i--)
                        {
                            unsigned skip =  cur->val_serie[__i].skip;
                            unsigned nptrs = cur->val_serie[__i].nptrs;
                            total += nptrs*sizeof (DWORD*);
                            do
                            {
                                X86EmitCall(NewExternalCodeLabel(JIT_UP_ByRefWriteBarrier), 0);
                            } while (--nptrs);
                            if (skip > 0)
                            {
                                //check if we are at the end of the series
                                if (__i == (cnt + 1))
                                    skip = skip - (cur->startoffset - elemOfs);
                                if (skip > 0)
                                    generate_noref_copy (skip, this);
                            }
                            total += skip;
                        }

                        _ASSERTE (size == total);
                    }
                    else
                    {
                        // no ref anywhere, just copy the bytes.
                        _ASSERTE (size);
                        generate_noref_copy (size, this);
                    }
                }
            }
            else
            {
                switch (pArrayOpScript->m_elemsize) {
                    case 1:
                        // mov[zs]x eax, byte ptr ELEMADDR
                        Emit8(0x0f);
                        X86EmitOp(pArrayOpScript->m_signed ? 0xbe : 0xb6, kEAX, elemBaseReg, elemOfs, elemScaledReg, elemScale);
                        break;

                    case 2:
                        // mov[zs]x eax, word ptr ELEMADDR
                        Emit8(0x0f);
                        X86EmitOp(pArrayOpScript->m_signed ? 0xbf : 0xb7, kEAX, elemBaseReg, elemOfs, elemScaledReg, elemScale);
                        break;

                    case 4:
                        if (pArrayOpScript->m_flags & pArrayOpScript->ISFPUTYPE) {
                            // fld dword ptr ELEMADDR
                            X86EmitOp(0xd9, (X86Reg)0, elemBaseReg, elemOfs, elemScaledReg, elemScale);
                        } else {
                            // mov eax, ELEMADDR
                            X86EmitOp(0x8b, kEAX, elemBaseReg, elemOfs, elemScaledReg, elemScale);
                        }
                        break;

                    case 8:
                        if (pArrayOpScript->m_flags & pArrayOpScript->ISFPUTYPE) {
                            // fld qword ptr ELEMADDR
                            X86EmitOp(0xdd, (X86Reg)0, elemBaseReg, elemOfs, elemScaledReg, elemScale);
                        } else {
                            // mov eax, ELEMADDR
                            X86EmitOp(0x8b, kEAX, elemBaseReg, elemOfs, elemScaledReg, elemScale);
                            // mov edx, ELEMADDR + 4
                            X86EmitOp(0x8b, kEDX, elemBaseReg, elemOfs + 4, elemScaledReg, elemScale);
                        }
                        break;


                    default:
                        _ASSERTE(0);
                }
            }

            break;

        case pArrayOpScript->STORE:
            _ASSERTE(!(pArrayOpScript->m_fValInReg)); // on x86, value will never get a register: so too lazy to implement that case

            switch (pArrayOpScript->m_elemsize) {

                case 1:
                    // mov SCRATCH, [esp + valoffset]
                    X86EmitEspOffset(0x8b, SCRATCH_REGISTER_X86REG, pArrayOpScript->m_fValLoc + ofsadjust);
                    // mov byte ptr ELEMADDR, SCRATCH.b
                    X86EmitOp(0x88, SCRATCH_REGISTER_X86REG, elemBaseReg, elemOfs, elemScaledReg, elemScale);
                    break;
                case 2:
                    // mov SCRATCH, [esp + valoffset]
                    X86EmitEspOffset(0x8b, SCRATCH_REGISTER_X86REG, pArrayOpScript->m_fValLoc + ofsadjust);
                    // mov word ptr ELEMADDR, SCRATCH.w
                    Emit8(0x66);
                    X86EmitOp(0x89, SCRATCH_REGISTER_X86REG, elemBaseReg, elemOfs, elemScaledReg, elemScale);
                    break;
                case 4:
                    // mov SCRATCH, [esp + valoffset]
                    X86EmitEspOffset(0x8b, SCRATCH_REGISTER_X86REG, pArrayOpScript->m_fValLoc + ofsadjust);
                    if (pArrayOpScript->m_flags & pArrayOpScript->NEEDSWRITEBARRIER) {
                        _ASSERTE(SCRATCH_REGISTER_X86REG == kEAX); // value to store is already in EAX where we want it.
                        // lea edx, ELEMADDR
                        X86EmitOp(0x8d, kEDX, elemBaseReg, elemOfs, elemScaledReg, elemScale);

                        // call JIT_UP_WriteBarrierReg_Buf[0] (== EAX)
                        X86EmitCall(NewExternalCodeLabel(JIT_UP_WriteBarrierReg_Buf), 0);
                    } else {
                        // mov ELEMADDR, SCRATCH
                        X86EmitOp(0x89, SCRATCH_REGISTER_X86REG, elemBaseReg, elemOfs, elemScaledReg, elemScale);
                    }
                    break;

                case 8:
                    if (!pArrayOpScript->m_gcDesc) {
                        // mov SCRATCH, [esp + valoffset]
                        X86EmitEspOffset(0x8b, SCRATCH_REGISTER_X86REG, pArrayOpScript->m_fValLoc + ofsadjust);
                        // mov ELEMADDR, SCRATCH
                        X86EmitOp(0x89, SCRATCH_REGISTER_X86REG, elemBaseReg, elemOfs, elemScaledReg, elemScale);
                        _ASSERTE(!(pArrayOpScript->m_fValInReg)); // on x86, value will never get a register: so too lazy to implement that case
                        // mov SCRATCH, [esp + valoffset + 4]
                        X86EmitEspOffset(0x8b, SCRATCH_REGISTER_X86REG, pArrayOpScript->m_fValLoc + ofsadjust + 4);
                        // mov ELEMADDR+4, SCRATCH
                        X86EmitOp(0x89, SCRATCH_REGISTER_X86REG, elemBaseReg, elemOfs+4, elemScaledReg, elemScale);
                        break;
                    }
                        // FALL THROUGH
                default:
                    // Ensure that these registers have been saved!
                    _ASSERTE(kTotalReg == kEDI);
                    _ASSERTE(kFactorReg == kESI);
                    // lea esi, [esp + valoffset]
                    X86EmitEspOffset(0x8d, kESI, pArrayOpScript->m_fValLoc + ofsadjust);
                    // lea edi, ELEMADDR
                    X86EmitOp(0x8d, kEDI, elemBaseReg, elemOfs, elemScaledReg, elemScale);
                    goto COPY_VALUE_CLASS;
            }
            break;

        default:
            _ASSERTE(0);
    }

        EmitLabel(Epilog);
    // Restore the callee-saved registers
    _ASSERTE(ARRAYOPLOCSIZE - sizeof(MethodDesc*) == 8);
    X86EmitPopReg(kFactorReg);
    X86EmitPopReg(kTotalReg);

    // Throw away methoddesc
    X86EmitPopReg(kECX); // junk register

    // ret N
    X86EmitReturn(pArrayOpScript->m_cbretpop);

   // Exception points must clean up the stack for all those extra args:
    EmitLabel(Inner_nullexception);
    Emit8(0xb8);        // mov EAX, <stack cleanup>
    Emit32(pArrayOpScript->m_cbretpop);
    // kFactorReg and kTotalReg could not have been modified, but let's pop
    // them anyway for consistency and to avoid future bugs.
    X86EmitPopReg(kFactorReg);
    X86EmitPopReg(kTotalReg);
    X86EmitNearJump(NewExternalCodeLabel(ArrayOpStubNullException));

    EmitLabel(Inner_rangeexception);
    Emit8(0xb8);        // mov EAX, <stack cleanup>
    Emit32(pArrayOpScript->m_cbretpop);
    X86EmitPopReg(kFactorReg);
    X86EmitPopReg(kTotalReg);
    X86EmitNearJump(NewExternalCodeLabel(ArrayOpStubRangeException));

    if (pArrayOpScript->m_flags & pArrayOpScript->NEEDSTYPECHECK) {
        EmitLabel(Inner_typeMismatchexception);
        Emit8(0xb8);        // mov EAX, <stack cleanup>
        Emit32(pArrayOpScript->m_cbretpop);
        X86EmitPopReg(kFactorReg);
        X86EmitPopReg(kTotalReg);
        X86EmitNearJump(NewExternalCodeLabel(ArrayOpStubTypeMismatchException));
    }
}

// EAX -> number of caller arg bytes on the stack that we must remove before going
// to the throw helper, which assumes the stack is clean.
__declspec(naked)
VOID __cdecl ThrowRankExceptionStub()
{
    __asm{
        pop    edx              // throw away methoddesc
        pop    edx              // recover RETADDR
        add    esp, eax         // release caller's args
        push   edx              // restore RETADDR
        mov    ARGUMENT_REG1, CORINFO_RankException
        jmp    InternalExceptionWorker
    }
}



//===========================================================================
// Emits code to throw a rank exception
VOID StubLinkerCPU::EmitRankExceptionThrowStub(UINT cbFixedArgs)
{
    THROWSCOMPLUSEXCEPTION();

    // mov eax, cbFixedArgs
    Emit8(0xb8 + kEAX);
    Emit32(cbFixedArgs);

    X86EmitNearJump(NewExternalCodeLabel(ThrowRankExceptionStub));
}




//===========================================================================
// Emits code to touch pages
// Inputs:
//   eax = first byte of data
//   edx = first byte past end of data
//
// Trashes eax, edx, ecx
//
// Pass TRUE if edx is guaranteed to be strictly greater than eax.
VOID StubLinkerCPU::EmitPageTouch(BOOL fSkipNullCheck)
{
    THROWSCOMPLUSEXCEPTION();


    CodeLabel *pEndLabel = NewCodeLabel();
    CodeLabel *pLoopLabel = NewCodeLabel();

    if (!fSkipNullCheck) {
        // cmp eax,edx
        X86EmitR2ROp(0x3b, kEAX, kEDX);

        // jnb EndLabel
        X86EmitCondJump(pEndLabel, X86CondCode::kJNB);
    }

    _ASSERTE(0 == (PAGE_SIZE & (PAGE_SIZE-1)));

    // and eax, ~(PAGE_SIZE-1)
    Emit8(0x25);
    Emit32( ~( ((UINT32)PAGE_SIZE) - 1 ));

    EmitLabel(pLoopLabel);
    // mov cl, [eax]
    X86EmitOp(0x8a, kECX, kEAX);
    // add eax, PAGESIZE
    Emit8(0x05);
    Emit32(PAGE_SIZE);
    // cmp eax, edx
    X86EmitR2ROp(0x3b, kEAX, kEDX);
    // jb LoopLabel
    X86EmitCondJump(pLoopLabel, X86CondCode::kJB);

    EmitLabel(pEndLabel);

}

VOID StubLinkerCPU::EmitProfilerComCallProlog(PVOID pFrameVptr, X86Reg regFrame)
{
    if (pFrameVptr == UMThkCallFrame::GetUMThkCallFrameVPtr())
    {
        // Save registers
        X86EmitPushReg(kEAX);
        X86EmitPushReg(kECX);
        X86EmitPushReg(kEDX);

        // Load the methoddesc into ECX (UMThkCallFrame->m_pvDatum->m_pMD)
        X86EmitIndexRegLoad(kECX, regFrame, UMThkCallFrame::GetOffsetOfDatum());
        X86EmitIndexRegLoad(kECX, kECX, UMEntryThunk::GetOffsetOfMethodDesc());

#ifdef PROFILING_SUPPORTED
        // Push arguments and notify profiler
        X86EmitPushImm32(COR_PRF_TRANSITION_CALL);    // Reason
        X86EmitPushReg(kECX);                           // MethodDesc*
        X86EmitCall(NewExternalCodeLabel(ProfilerUnmanagedToManagedTransitionMD), 8);
#endif // PROFILING_SUPPORTED

        // Restore registers
        X86EmitPopReg(kEDX);
        X86EmitPopReg(kECX);
        X86EmitPopReg(kEAX);
    }

    else if (pFrameVptr == ComMethodFrame::GetMethodFrameVPtr())
    {
        // Save registers
        X86EmitPushReg(kEAX);
        X86EmitPushReg(kECX);
        X86EmitPushReg(kEDX);

        // Load the methoddesc into ECX (Frame->m_pvDatum->m_pMD)
        X86EmitIndexRegLoad(kECX, regFrame, ComMethodFrame::GetOffsetOfDatum());
        X86EmitIndexRegLoad(kECX, kECX, ComCallMethodDesc::GetOffsetOfMethodDesc());

#ifdef PROFILING_SUPPORTED
        // Push arguments and notify profiler
        X86EmitPushImm32(COR_PRF_TRANSITION_CALL);      // Reason
        X86EmitPushReg(kECX);                           // MethodDesc*
        X86EmitCall(NewExternalCodeLabel(ProfilerUnmanagedToManagedTransitionMD), 8);
#endif // PROFILING_SUPPORTED

        // Restore registers
        X86EmitPopReg(kEDX);
        X86EmitPopReg(kECX);
        X86EmitPopReg(kEAX);
    }

    // Unrecognized frame vtbl
    else
    {
        _ASSERTE(!"Unrecognized vtble passed to EmitComMethodStubProlog with profiling turned on.");
    }
}

VOID StubLinkerCPU::EmitProfilerComCallEpilog(PVOID pFrameVptr, X86Reg regFrame)
{
    if (pFrameVptr == UMThkCallFrame::GetUMThkCallFrameVPtr())
    {
        // Save registers
        X86EmitPushReg(kEAX);
        X86EmitPushReg(kECX);
        X86EmitPushReg(kEDX);

        // Load the methoddesc into ECX (UMThkCallFrame->m_pvDatum->m_pMD)
        X86EmitIndexRegLoad(kECX, regFrame, UMThkCallFrame::GetOffsetOfDatum());
        X86EmitIndexRegLoad(kECX, kECX, UMEntryThunk::GetOffsetOfMethodDesc());

#ifdef PROFILING_SUPPORTED
        // Push arguments and notify profiler
        X86EmitPushImm32(COR_PRF_TRANSITION_RETURN);    // Reason
        X86EmitPushReg(kECX);                           // MethodDesc*
        X86EmitCall(NewExternalCodeLabel(ProfilerManagedToUnmanagedTransitionMD), 8);
#endif // PROFILING_SUPPORTED

        // Restore registers
        X86EmitPopReg(kEDX);
        X86EmitPopReg(kECX);
        X86EmitPopReg(kEAX);
    }

    else if (pFrameVptr == ComMethodFrame::GetMethodFrameVPtr())
    {
        // Save registers
        X86EmitPushReg(kEAX);
        X86EmitPushReg(kECX);
        X86EmitPushReg(kEDX);

        // Load the methoddesc into ECX (Frame->m_pvDatum->m_pMD)
        X86EmitIndexRegLoad(kECX, regFrame, ComMethodFrame::GetOffsetOfDatum());
        X86EmitIndexRegLoad(kECX, kECX, ComCallMethodDesc::GetOffsetOfMethodDesc());

#ifdef PROFILING_SUPPORTED
        // Push arguments and notify profiler
        X86EmitPushImm32(COR_PRF_TRANSITION_RETURN);    // Reason
        X86EmitPushReg(kECX);                           // MethodDesc*
        X86EmitCall(NewExternalCodeLabel(ProfilerManagedToUnmanagedTransitionMD), 8);
#endif // PROFILING_SUPPORTED

        // Restore registers
        X86EmitPopReg(kEDX);
        X86EmitPopReg(kECX);
        X86EmitPopReg(kEAX);
    }

    // Unrecognized frame vtbl
    else
    {
        _ASSERTE(!"Unrecognized vtble passed to EmitComMethodStubEpilog with profiling turned on.");
    }
}

#pragma warning(push)
#pragma warning(disable: 4035)
unsigned cpuid(int arg, unsigned char result[16])
{
    __asm
    {
        pushfd
        mov     eax, [esp]
        xor     dword ptr [esp], 1 shl 21 // Try to change ID flag
        popfd
        pushfd
        xor     eax, [esp]
        popfd
        and     eax, 1 shl 21             // Check whether ID flag changed
        je      no_cpuid                  // If not, 0 is an ok return value for us

        push    ebx
        push    esi
        mov     eax, arg
        cpuid
        mov     esi, result
        mov     [esi+ 0], eax
        mov     [esi+ 4], ebx
        mov     [esi+ 8], ecx
        mov     [esi+12], edx
        pop     esi
        pop     ebx
no_cpuid:
    }
}
#pragma warning(pop)

size_t GetL2CacheSize()
{
    unsigned char buffer[16];
    __try
    {
        int maxCpuId = cpuid(0, buffer);
        if (maxCpuId < 2)
            return 0;
        cpuid(2, buffer);
    }
    __except(COMPLUS_EXCEPTION_EXECUTE_HANDLER)
    {
        return 0;
    }

    size_t maxSize = 0;
    size_t size = 0;
    for (int i = buffer[0]; --i >= 0; )
    {
        int j;
        for (j = 3; j < 16; j += 4)
        {
            // if the information in a register is marked invalid, set to null descriptors
            if  (buffer[j] & 0x80)
            {
                buffer[j-3] = 0;
                buffer[j-2] = 0;
                buffer[j-1] = 0;
                buffer[j-0] = 0;
            }
        }

        for (j = 1; j < 16; j++)
        {
            switch  (buffer[j])
            {
                case    0x41:
                case    0x79:
                    size = 128*1024;
                    break;

                case    0x42:
                case    0x7A:
                case    0x82:
                    size = 256*1024;
                    break;

                case    0x22:
                case    0x43:
                case    0x7B:
                    size = 512*1024;
                    break;

                case    0x23:
                case    0x44:
                case    0x7C:
                case    0x84:
                    size = 1024*1024;
                    break;

                case    0x25:
                case    0x45:
                case    0x85:
                    size = 2*1024*1024;
                    break;

                case    0x29:
                    size = 4*1024*1024;
                    break;
            }
            if (maxSize < size)
                maxSize = size;
        }

        if  (i > 0)
            cpuid(2, buffer);
    }
//    printf("GetL2CacheSize returns %d\n", maxSize);
    return maxSize;
}

__declspec(naked) LPVOID __fastcall ObjectNative::FastGetClass(Object* vThisRef)
{
    __asm {
        //#ifdef _DEBUG
        // We dont do a null check for non-debug because jitted code does the null check before calling
        // this method. 
        // Check for null 'this'
        // @todo: the jitted code is not currently checking this.
        test ecx, ecx
        je throw_label
        //#endif
        // Get the method table 
        mov ecx, dword ptr [ecx]
        // Get the class
        mov ecx, dword ptr [ecx] MethodTable.m_pEEClass
        // Check if class is array, MarshalByRef, Contextful etc
        mov eax, dword ptr [ecx] EEClass.m_VMFlags
        test eax, VMFLAG_ARRAY_CLASS | VMFLAG_CONTEXTFUL | VMFLAG_MARSHALEDBYREF
        jne fail
        // Get the type object
        mov eax, dword ptr [ecx] EEClass.m_ExposedClassObject
        test eax, eax
        je exit
        mov eax, dword ptr [eax]
exit:
        ret
fail:
        xor eax, eax
        ret
//#ifdef _DEBUG
throw_label:
        push ecx
        push ecx
        push ecx
        push ecx
        push kNullReferenceException
        push offset ObjectNative::FastGetClass
        call __FCThrow
        jmp fail
//#endif
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\i386\jithelp.asm ===
; ==++==
; 
;   Copyright (c) Microsoft Corporation.  All rights reserved.
; 
; ==--==
; ***********************************************************************
; File: JIThelp.asm
;
; ***********************************************************************

; This contains JITinterface routines that are 100% x86 assembly

        .386
        OPTION  OLDSTRUCTS
;
; @TODO Switch to g_ephemeral_low and g_ephemeral_high
; @TODO instead of g_lowest_address, g_highest address
;

ARGUMENT_REG1           equ     ecx
ARGUMENT_REG2           equ     edx
g_ephemeral_low                 TEXTEQU <_g_ephemeral_low>
g_ephemeral_high                TEXTEQU <_g_ephemeral_high>
g_lowest_address        	TEXTEQU <_g_lowest_address>
g_highest_address               TEXTEQU <_g_highest_address>
g_card_table            	TEXTEQU <_g_card_table>
ifndef UNDER_CE
JIT_IsInstanceOfClassHelper     TEXTEQU <_JIT_IsInstanceOfClassHelper@0>
ChkCastAsserts                  TEXTEQU <?ChkCastAsserts@@YGXXZ>
JIT_IsInstanceOfClass           TEXTEQU <_JIT_IsInstanceOfClass@0>
JIT_Dbl2Lng			TEXTEQU	<_JIT_Dbl2Lng@8>
JIT_Dbl2IntSSE2                 TEXTEQU	<_JIT_Dbl2IntSSE2@8>
JIT_Dbl2LngP4x87                TEXTEQU	<_JIT_Dbl2LngP4x87@8>
JIT_LLsh                        TEXTEQU <_JIT_LLsh@0>
JIT_LRsh                        TEXTEQU <_JIT_LRsh@0>
JIT_LRsz                        TEXTEQU <_JIT_LRsz@0>
JIT_UP_WriteBarrierReg_PreGrow  TEXTEQU <_JIT_UP_WriteBarrierReg_PreGrow@0>
JIT_UP_WriteBarrierReg_PostGrow TEXTEQU <_JIT_UP_WriteBarrierReg_PostGrow@0>
JIT_TailCall                    TEXTEQU <_JIT_TailCall@0>
WriteBarrierAssert				TEXTEQU <_WriteBarrierAssert@4>
else
JIT_IsInstanceOfClassHelper     TEXTEQU <_JIT_IsInstanceOfClassHelper>
ChkCastAsserts                  TEXTEQU <_ChkCastAsserts>
JIT_IsInstanceOfClass           TEXTEQU <_JIT_IsInstanceOfClass>
JIT_LLsh                        TEXTEQU <_JIT_LLsh>
JIT_LRsh                        TEXTEQU <_JIT_LRsh>
JIT_LRsz                        TEXTEQU <_JIT_LRsz>
JIT_UP_WriteBarrierReg_PreGrow  TEXTEQU <_JIT_UP_WriteBarrierReg_PreGrow>
JIT_UP_WriteBarrierReg_PostGrow TEXTEQU <_JIT_UP_WriteBarrierReg_PostGrow>
JIT_TailCall                    TEXTEQU <_JIT_TailCall>
endif

JIT_TailCallHelper              TEXTEQU <_JIT_TailCallHelper>

EXTERN  g_ephemeral_low:DWORD
EXTERN  g_ephemeral_high:DWORD
EXTERN  g_lowest_address:DWORD
EXTERN  g_highest_address:DWORD
EXTERN  g_card_table:DWORD
EXTERN  JIT_IsInstanceOfClassHelper:PROC
EXTERN  JIT_TailCallHelper:PROC
ifdef _DEBUG
EXTERN  WriteBarrierAssert:PROC
EXTERN  ChkCastAsserts:PROC
endif



ifdef WRITE_BARRIER_CHECK 
ifndef SERVER_GC 
g_GCShadow  	          		TEXTEQU <?g_GCShadow@@3PAEA>
g_GCShadowEnd  	          		TEXTEQU <?g_GCShadowEnd@@3PAEA>
EXTERN  g_GCShadow:DWORD
EXTERN  g_GCShadowEnd:DWORD
endif
endif

.686P
.XMM
; The following macro is needed because of a MASM issue with the
; movsd mnemonic
; 
$movsd MACRO op1, op2
    LOCAL begin_movsd, end_movsd
begin_movsd:
    movupd op1, op2
end_movsd:
    org begin_movsd
    db 0F2h
    org end_movsd
ENDM
.386

_TEXT   SEGMENT PARA PUBLIC FLAT 'CODE'
        ASSUME  CS:FLAT, DS:FLAT, ES:FLAT, SS:FLAT, FS:NOTHING


;***
;JIT_WriteBarrier* - GC write barrier helper
;
;Purpose:
;   Helper calls in order to assign an object to a field
;   Enables book-keeping of the GC.
;
;Entry:
;   EDX - address of ref-field (assigned to)
;   the resp. other reg - RHS of assignment
;
;Exit:
;
;Uses:
;       EDX is destroyed.
;
;Exceptions:
;
;*******************************************************************************

;;@todo: WriteBarrier doesn't depend on proctype any longer, so remove it.
WriteBarrierHelper MACRO rg, proctype
        ALIGN 4

		;; The entry point is the fully 'safe' one in which we check if EDX (the REF
		;; begin updated) is actually in the GC heap

ifdef UNDER_CE
PUBLIC _JIT_&proctype&_CheckedWriteBarrier&rg
_JIT_&proctype&_CheckedWriteBarrier&rg PROC
else
PUBLIC _JIT_&proctype&_CheckedWriteBarrier&rg&@0
_JIT_&proctype&_CheckedWriteBarrier&rg&@0 PROC
endif
                 ;; check in the REF being updated is in the GC heap
 		cmp             edx, g_lowest_address
 		jb              @F
 		cmp             edx, g_highest_address
 		jae             @F

ifdef UNDER_CE
_JIT_&proctype&_CheckedWriteBarrier&rg ENDP
else
_JIT_&proctype&_CheckedWriteBarrier&rg&@0 ENDP
endif
		;; fall through	to unchecked routine
		;; note that its entry point also happens to be aligned

	;; This entry point is used when you know the REF pointer being updated
	;; is in the GC heap
ifdef UNDER_CE
PUBLIC _JIT_&proctype&_WriteBarrier&rg
_JIT_&proctype&_WriteBarrier&rg PROC
else
PUBLIC _JIT_&proctype&_WriteBarrier&rg&@0
_JIT_&proctype&_WriteBarrier&rg&@0 PROC
endif

ifdef _DEBUG
ifndef UNDER_CE 
		push 	edx
		push 	ecx
		push 	eax

		push 	edx
        call    WriteBarrierAssert

		pop 	eax
		pop 	ecx
		pop 	edx
endif ;UNDER_CE
endif ;_DEBUG

		;; ALSO update the shadow GC heap if that is enabled
ifdef WRITE_BARRIER_CHECK
ifndef SERVER_GC 
		push 	edx
        sub     edx, g_lowest_address   ; U/V
		jb NoShadow_&rg&proctype
		add		edx, [g_GCShadow]
		cmp		edx, [g_GCShadowEnd]
		ja NoShadow_&rg&proctype
        mov     DWORD PTR [edx], rg
NoShadow_&rg&proctype:
		pop edx
endif
endif

        cmp     rg, g_ephemeral_low
        jb      @F
        cmp     rg, g_ephemeral_high
        jae     @F
        mov     DWORD PTR [edx], rg

		shr		edx, 10
		add		edx, [g_card_table]
		mov		byte ptr [edx], 0FFh
        ret
@@:
        mov     DWORD PTR [edx], rg
		ret
ifdef UNDER_CE
_JIT_&proctype&_WriteBarrier&rg ENDP
else
_JIT_&proctype&_WriteBarrier&rg&@0 ENDP
endif



ENDM

;***
;JIT_ByRefWriteBarrier* - GC write barrier helper
;
;Purpose:
;   Helper calls in order to assign an object to a byref field
;   Enables book-keeping of the GC.
;
;Entry:
;   EDI - address of ref-field (assigned to)
;   ESI - address of the data  (source)
;   ECX can be trashed
;
;Exit:
;
;Uses:
;   EDI and ESI are incremented by a DWORD
;
;Exceptions:
;
;*******************************************************************************

;;@todo: WriteBarrier doesn't depend on proctype any longer, so remove it.
ByRefWriteBarrierHelper MACRO proctype
        ALIGN 4
ifdef UNDER_CE
PUBLIC _JIT_&proctype&_ByRefWriteBarrier
_JIT_&proctype&_ByRefWriteBarrier PROC
else
PUBLIC _JIT_&proctype&_ByRefWriteBarrier&@0
_JIT_&proctype&_ByRefWriteBarrier&@0 PROC
endif
        ;;test for dest in range
        mov     ecx, [esi] 
        cmp     edi, g_lowest_address
        jb      @F
        cmp     edi, g_highest_address
        jae     @F

		;; ALSO update the shadow GC heap if that is enabled
ifdef WRITE_BARRIER_CHECK
ifndef SERVER_GC 
		push 	edi
        sub     edi, g_lowest_address   ; U/V
		jb NoShadow_&rg&proctype
		add		edi, [g_GCShadow]
		cmp		edi, [g_GCShadowEnd]
		ja NoShadow_&rg&proctype
        mov     DWORD PTR [edi], ecx
NoShadow_&rg&proctype:
		pop 	edi
endif
endif
        ;;test for *src in range
        cmp     ecx, g_ephemeral_low
        jb      @F
        cmp     ecx, g_ephemeral_high
        jae     @F
 
        ;;write barrier
        mov     ecx, edi                ; U/V

		shr		ecx, 10
		add		ecx, [g_card_table]
		mov		byte ptr [ecx], 0FFh
@@:
        ;;*dest = *src
        ;;increment src and dest
        movsd
        ret
ifdef UNDER_CE
_JIT_&proctype&_ByRefWriteBarrier ENDP
else
_JIT_&proctype&_ByRefWriteBarrier&@0 ENDP
endif
ENDM

; WriteBarrierStart and WriteBarrierEnd are used to determine bounds of
; WriteBarrier functions so can determine if got AV in them. Assumes that bbt
; won't move them
ifdef UNDER_CE
PUBLIC _JIT_WriteBarrierStart
_JIT_WriteBarrierStart PROC
ret
_JIT_WriteBarrierStart ENDP
else
PUBLIC _JIT_WriteBarrierStart@0
_JIT_WriteBarrierStart@0 PROC
ret
_JIT_WriteBarrierStart@0 ENDP
endif

WriteBarrierHelper <EAX>, <UP>
WriteBarrierHelper <EBX>, <UP>
WriteBarrierHelper <ECX>, <UP>
WriteBarrierHelper <ESI>, <UP>
WriteBarrierHelper <EDI>, <UP>
WriteBarrierHelper <EBP>, <UP>

ByRefWriteBarrierHelper <UP>

ifdef UNDER_CE
PUBLIC _JIT_WriteBarrierEnd
_JIT_WriteBarrierEnd PROC
ret
_JIT_WriteBarrierEnd ENDP
else
PUBLIC _JIT_WriteBarrierEnd@0
_JIT_WriteBarrierEnd@0 PROC
ret
_JIT_WriteBarrierEnd@0 ENDP
endif

PUBLIC JIT_IsInstanceOfClass
JIT_IsInstanceOfClass PROC

ifdef _DEBUG
        call            ChkCastAsserts
endif ;_DEBUG
;       // Save off the instance in case it is a proxy.
        mov             eax, ARGUMENT_REG2

;       // Check if the instance is NULL
        test            ARGUMENT_REG2, ARGUMENT_REG2
        je              IsNullInst

;       // Get the method table for the instance.
        mov             ARGUMENT_REG2, dword ptr [ARGUMENT_REG2]

;       // Check if they are the same.
        cmp             ARGUMENT_REG1, ARGUMENT_REG2
        je              IsInst

;       // Call the worker for the more common case.
        jmp             JIT_IsInstanceOfClassHelper

;       // The instance was NULL so we failed to match.
IsNullInst:

;       // We matched the class.
;       // Since eax constains the instance (known not to be NULL, we are fine).
IsInst:
        ret

JIT_IsInstanceOfClass ENDP

;*********************************************************************/
;llshl - long shift left
;
;Purpose:
;   Does a Long Shift Left (signed and unsigned are identical)
;   Shifts a long left any number of bits.
;
;       NOTE:  This routine has been adapted from the Microsoft CRTs.
;
;Entry:
;   EDX:EAX - long value to be shifted
;       ECX - number of bits to shift by
;
;Exit:
;   EDX:EAX - shifted value
;
PUBLIC JIT_LLsh
JIT_LLsh PROC
; Handle shifts of between bits 0 and 31
        cmp     ecx, 32
        jae     short LLshMORE32
        shld    edx,eax,cl
        shl     eax,cl
        ret
; Handle shifts of between bits 32 and 63
LLshMORE32:
		; The x86 shift instructions only use the lower 5 bits.
        mov     edx,eax
        xor     eax,eax
        shl     edx,cl
        ret
JIT_LLsh ENDP


;*********************************************************************/
;LRsh - long shift right
;
;Purpose:
;   Does a signed Long Shift Right
;   Shifts a long right any number of bits.
;
;       NOTE:  This routine has been adapted from the Microsoft CRTs.
;
;Entry:
;   EDX:EAX - long value to be shifted
;       ECX - number of bits to shift by
;
;Exit:
;   EDX:EAX - shifted value
;
PUBLIC JIT_LRsh
JIT_LRsh PROC
; Handle shifts of between bits 0 and 31
        cmp     ecx, 32
        jae     short LRshMORE32
        shrd    eax,edx,cl
        sar     edx,cl
        ret
; Handle shifts of between bits 32 and 63
LRshMORE32:
		; The x86 shift instructions only use the lower 5 bits.
		mov     eax,edx
		sar		edx, 31 
        sar     eax,cl
        ret
JIT_LRsh ENDP


;*********************************************************************/
; LRsz:
;Purpose:
;   Does a unsigned Long Shift Right
;   Shifts a long right any number of bits.
;
;       NOTE:  This routine has been adapted from the Microsoft CRTs.
;
;Entry:
;   EDX:EAX - long value to be shifted
;       ECX - number of bits to shift by
;
;Exit:
;   EDX:EAX - shifted value
;
PUBLIC JIT_LRsz
JIT_LRsz PROC
; Handle shifts of between bits 0 and 31
        cmp     ecx, 32
        jae     short LRszMORE32
        shrd    eax,edx,cl
        shr     edx,cl
        ret
; Handle shifts of between bits 32 and 63
LRszMORE32:
		; The x86 shift instructions only use the lower 5 bits.
        mov     eax,edx
        xor     edx,edx
        shr     eax,cl
        ret
JIT_LRsz ENDP


;*********************************************************************/
; JIT_Dbl2Lng

;Purpose:
;   converts a double to a long truncating toward zero (C semantics)
;
;	uses stdcall calling conventions 
;
;   note that changing the rounding mode is very expensive.  This
;   routine basiclly does the truncation sematics without changing
;   the rounding mode, resulting in a win.
;
PUBLIC JIT_Dbl2Lng
JIT_Dbl2Lng PROC
	fld qword ptr[ESP+4]		; fetch arg
	lea ecx,[esp-8]
	sub esp,16 					; allocate frame
	and ecx,-8 					; align pointer on boundary of 8
	fld st(0)					; duplciate top of stack
	fistp qword ptr[ecx]		; leave arg on stack, also save in temp
	fild qword ptr[ecx]			; arg, round(arg) now on stack
	mov edx,[ecx+4] 			; high dword of integer
	mov eax,[ecx] 				; low dword of integer
	test eax,eax
	je integer_QNaN_or_zero

arg_is_not_integer_QNaN:
	fsubp st(1),st 				; TOS=d-round(d),
								; { st(1)=st(1)-st & pop ST }
	test edx,edx 				; what's sign of integer
	jns positive
								; number is negative
								; dead cycle
								; dead cycle
	fstp dword ptr[ecx]			; result of subtraction
	mov ecx,[ecx] 				; dword of difference(single precision)
	add esp,16
	xor ecx,80000000h
	add ecx,7fffffffh			; if difference>0 then increment integer
	adc eax,0 					; inc eax (add CARRY flag)
	adc edx,0					; propagate carry flag to upper bits
	ret 8

positive:
	fstp dword ptr[ecx]			;17-18 ; result of subtraction
	mov ecx,[ecx] 				; dword of difference (single precision)
	add esp,16
	add ecx,7fffffffh			; if difference<0 then decrement integer
	sbb eax,0 					; dec eax (subtract CARRY flag)
	sbb edx,0					; propagate carry flag to upper bits
	ret 8

integer_QNaN_or_zero:
	test edx,7fffffffh
	jnz arg_is_not_integer_QNaN
	fstp st(0)					;; pop round(arg)
	fstp st(0)					;; arg
	add esp,16
	ret 8
JIT_Dbl2Lng ENDP


;*********************************************************************/
; JIT_Dbl2LngP4x87

;Purpose:
;   converts a double to a long truncating toward zero (C semantics)
;
;	uses stdcall calling conventions 
;
;   This code is faster on a P4 than the Dbl2Lng code above, but is
;   slower on a PIII.  Hence we choose this code when on a P4 or above.
;
PUBLIC JIT_Dbl2LngP4x87
JIT_DBL2LngP4x87 PROC
arg1	equ	<[esp+0Ch]>

    sub 	esp, 8                  ; get some local space

    fld	qword ptr arg1              ; fetch arg
    fnstcw  word ptr arg1           ; store FPCW
    movzx   eax, word ptr arg1      ; zero extend - wide
    or	ah, 0Ch                     ; turn on OE and DE flags
    mov	dword ptr [esp], eax        ; store new FPCW bits
    fldcw   word ptr  [esp]         ; reload FPCW with new bits 
    fistp   qword ptr [esp]         ; convert
    mov	eax, dword ptr [esp]        ; reload FP result
    mov	edx, dword ptr [esp+4]      ;
    fldcw   word ptr arg1           ; reload original FPCW value

    add esp, 8                      ; restore stack

    ret	8
JIT_Dbl2LngP4x87 ENDP

;*********************************************************************/
; JIT_Dbl2IntSSE2

;Purpose:
;   converts a double to a long truncating toward zero (C semantics)
;
;	uses stdcall calling conventions 
;
;   This code is even faster than the P4 x87 code for Dbl2LongP4x87,
;   but only returns a 32 bit value (only good for int).
;
.686P
.XMM
PUBLIC JIT_Dbl2IntSSE2
JIT_DBL2IntSSE2 PROC
	$movsd	xmm0, [esp+4]
	cvttsd2si eax, xmm0
	cdq
	ret 8
JIT_Dbl2IntSSE2 ENDP
.386

;*********************************************************************/
; This is the small write barrier thunk we use when we know the
; ephemeral generation is higher in memory than older generations.
; The 0x0F0F0F0F values are bashed by the two functions above.
; This the generic version - wherever the code says ECX, 
; the specific register is patched later into a copy
; Note: do not replace ECX by EAX - there is a smaller encoding for
; the compares just for EAX, which won't work for other registers.
PUBLIC JIT_UP_WriteBarrierReg_PreGrow
JIT_UP_WriteBarrierReg_PreGrow PROC
        mov     DWORD PTR [edx], ecx
        cmp     ecx, 0F0F0F0F0h
        jb      NoWriteBarrierPre

        shr     edx, 10
        cmp     byte ptr [edx+0F0F0F0F0h], 0FFh
        jne     WriteBarrierPre
NoWriteBarrierPre:
        ret
WriteBarrierPre:
        mov     byte ptr [edx+0F0F0F0F0h], 0FFh
        ret
JIT_UP_WriteBarrierReg_PreGrow ENDP


;*********************************************************************/
; This is the larger write barrier thunk we use when we know that older
; generations may be higher in memory than the ephemeral generation
; The 0x0F0F0F0F values are bashed by the two functions above.
; This the generic version - wherever the code says ECX, 
; the specific register is patched later into a copy
; Note: do not replace ECX by EAX - there is a smaller encoding for
; the compares just for EAX, which won't work for other registers.
PUBLIC JIT_UP_WriteBarrierReg_PostGrow
JIT_UP_WriteBarrierReg_PostGrow PROC
        mov     DWORD PTR [edx], ecx
        cmp     ecx, 0F0F0F0F0h
        jb      NoWriteBarrierPost
        cmp     ecx, 0F0F0F0F0h
        jae     NoWriteBarrierPost

        shr     edx, 10
        cmp     byte ptr [edx+0F0F0F0F0h], 0FFh
        jne     WriteBarrierPost
NoWriteBarrierPost:
        ret
WriteBarrierPost:
        mov     byte ptr [edx+0F0F0F0F0h], 0FFh
        ret
JIT_UP_WriteBarrierReg_PostGrow ENDP


PUBLIC JIT_TailCall
JIT_TailCall PROC
        push    esp         ; TailCallArgs*

; Create a MachState struct on the stack 

; return address is already on the stack, but is separated from stack 
; arguments by the extra arguments of JIT_TailCall. So we cant use it directly

        push    0DDDDDDDDh

; Esp on unwind. Not needed as we it is deduced from the target method

        push    0CCCCCCCCh
        push    ebp 
        push    esp         ; pEbp
        push    ebx 
        push    esp         ; pEbx
        push    esi 
        push    esp         ; pEsi
        push    edi 
        push    esp         ; pEdi

        push    ecx         ; ArgumentRegisters
        push    edx

; JIT_TailCallHelper will do a "ret" at the end. This will match
; the "call" done by the JITed code keeping the call-ret count
; balanced. If we did a call here instead of the jmp, the
; balance would get out of whack.

        push    0DDDDDDDDh  ; Dummy return-address for JIT_TailCallHelper
        jmp     JIT_TailCallHelper
JIT_TailCall ENDP

_TEXT   ENDS
        END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\i386\jitinterfacex86.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
// ===========================================================================
// File: JITinterfaceX86.CPP
//
// ===========================================================================

// This contains JITinterface routines that are tailored for
// X86 platforms. Non-X86 versions of these can be found in
// JITinterfaceGen.cpp or JITinterfaceAlpha.cpp

#include "common.h"
#include "JITInterface.h"
#include "EEConfig.h"
#include "excep.h"
#include "COMString.h"
#include "COMDelegate.h"
#include "remoting.h" // create context bound and remote class instances
#include "field.h"
#include "tls.h"
#include "ecall.h"

// To test with MON_DEBUG off, comment out the following line. DO NOT simply define
// to be 0 as the checks are for #ifdef not #if 0. Also, if you are mucking around with
// something that requires you to test with MON_DEBUG off, you should also uncomment out 
// the #define MP_LOCKS below and test with that too as this also generates a different code 
// path that can break the synchronization code. Unfortunately this implies 4 different
// builds & test runs. But better that than a hot fix eh? (Voice of experience :( )
#ifdef _DEBUG
#define MON_DEBUG 1
#endif
//#define MP_LOCKS

class generation;
extern "C" generation generation_table[];

extern "C"
{
    VMHELPDEF hlpFuncTable[];
    VMHELPDEF utilFuncTable[];
    void __stdcall JIT_UP_WriteBarrierReg_PreGrow();// JIThelp.asm/JITinterfaceAlpha.cpp
}

#ifdef _DEBUG
extern "C" void __stdcall WriteBarrierAssert(BYTE* ptr) 
{
    _ASSERTE((g_lowest_address <= ptr && ptr < g_highest_address) ||
         ((size_t)ptr < MAX_UNCHECKED_OFFSET_FOR_NULL_OBJECT));
}

#endif


extern BYTE JIT_UP_WriteBarrierReg_Buf[8][41]; // Executed copy of the thunk.

#ifdef _DEBUG
BOOL SafeObjIsInstanceOf(Object *pElement, TypeHandle toTypeHnd) {
	BEGINFORBIDGC();
	BOOL ret = ObjIsInstanceOf(pElement, toTypeHnd);
	ENDFORBIDGC();
	return(ret);
}
#endif

/****************************************************************************/
/* assigns 'val to 'array[idx], after doing all the proper checks */
/* note that we can do almost as well in portable code, but this
   squezes the last little bit of perf out */

__declspec(naked) void __fastcall JIT_Stelem_Ref(PtrArray* array, unsigned idx, Object* val)
{
    enum { MTFlagsOffs = offsetof(MethodTable, m_wFlags),
           MTCOMFlags = MethodTable::enum_ComObjectMask |
                        MethodTable::enum_CtxProxyMask |
                        MethodTable::enum_flag_Array |
                        MethodTable::enum_TransparentProxy,
         };

    __asm {
        test ECX, ECX
        je ThrowNullReferenceException

        cmp EDX, [ECX+4];           // test if in bounds 
        jae ThrowIndexOutOfRangeException

        mov EAX, [ESP+4]            // EAX = val
        test EAX, EAX
        jz Assigning0

#if CHECK_APP_DOMAIN_LEAKS
        // Check if the instance is agile or check agile
        mov EAX,  [ECX+8]           // Get element th
        test EAX, 2                 // Check for non-MT
        jnz NoCheck
        // Check VMflags of element type
        mov EAX, [EAX]MethodTable.m_pEEClass
        mov EAX, dword ptr [EAX]EEClass.m_VMFlags
        test EAX, VMFLAG_APP_DOMAIN_AGILE|VMFLAG_CHECK_APP_DOMAIN_AGILE
        jnz IsComObject             // Jump to the generic case so we can do an app domain check
 NoCheck:
        mov EAX, [ESP+4]            // EAX = val
#endif

        mov EAX, [EAX]              // EAX = EAX->MT

        cmp EAX, [ECX + 8]          // do we have an exact match
        jne NotExactMatch
        mov EAX, [ESP+4]            // EAX = val
Assigning0:
        lea EDX, [ECX + 4*EDX + 12]
        call offset JIT_UP_WriteBarrierReg_Buf
        ret 4
    
NotExactMatch:
        mov EAX, [g_pObjectClass]
        cmp [ECX+8], EAX            // are we assigning to Array of objects
        jne NotObjectArray

        lea EDX, [ECX + 4*EDX + 12]
        mov EAX, [ESP+4]            // EAX = val
        call offset JIT_UP_WriteBarrierReg_Buf
        ret 4

NotObjectArray:
            // See if object being assigned is a com object, if it is we have to erect a frame (ug)
        mov EAX, [ESP+4]            // EAX = val
        mov EAX, [EAX]              // EAX = EAX->MT
        test dword ptr [EAX+MTFlagsOffs], MTCOMFlags
        jnz IsComObject

        lea EDX, [ECX + 4*EDX + 12] // save target
        push EDX
        
        push [ECX+8]                // element type handle
        push [ESP+4+8]              // object (+8 for the two pushes)
#ifdef _DEBUG
        call SafeObjIsInstanceOf
#else
        call ObjIsInstanceOf
#endif

        pop EDX                     // restore target
        test EAX, EAX
        je ThrowArrayTypeMismatchException

DoWrite:                            // EDX = target
        mov EAX, [ESP+4]            // EAX = val
        call offset JIT_UP_WriteBarrierReg_Buf
Epilog:
        ret 4

IsComObject:
            // Call the helper that knows how to erect a frame
        push EDX
        push ECX
        lea ECX, [ESP+12]               // ECX = address of object being stored
        lea EDX, [ESP]                  // EDX = address of array
        call ArrayStoreCheck

        pop ECX                         // these might have been updated!
        pop EDX

        cmp EAX, EAX                    // set zero flag        
        jnz Epilog                      // This jump never happens, it keeps the epilog walker happy

        lea EDX, [ECX + 4*EDX + 12]     // restore target
        test EAX, EAX                   
        jnz DoWrite

ThrowArrayTypeMismatchException:
        mov ECX, kArrayTypeMismatchException
        jmp Throw

ThrowNullReferenceException:
        mov ECX, kNullReferenceException
        jmp Throw

ThrowIndexOutOfRangeException:
        mov ECX, kIndexOutOfRangeException

Throw:
        push 0
        push 0
        push 0
        push 0
        push ECX
        push 0
        call        __FCThrow
        ret 4
    }
}


#ifdef MAXALLOC
extern AllocRequestManager g_gcAllocManager;

extern "C" BOOL CheckAllocRequest(size_t n)
{
    return g_gcAllocManager.CheckRequest(n);
}

extern "C" void UndoAllocRequest()
{
    g_gcAllocManager.UndoRequest();
}
#endif // MAXALLOC

#if CHECK_APP_DOMAIN_LEAKS
void * __stdcall SetObjectAppDomain(Object *pObject)
{
    pObject->SetAppDomain();
    return pObject;
}

#endif

// This is the ASM portion of JIT_IsInstanceOf.  For all the bizarre cases, it quickly
// fails and falls back on the JIT_IsInstanceOfBizarre helper.  So all failure cases take
// the slow path, too.
//
// ARGUMENT_REG1 = array or interface to check for.
// ARGUMENT_REG2 = instance to be cast.
enum
{
    sizeof_InterfaceInfo_t = sizeof(InterfaceInfo_t),
};

extern "C" int __declspec(naked) __stdcall JIT_IsInstanceOf()
{
    __asm
    {
        test    ARGUMENT_REG2, ARGUMENT_REG2
        jz      IsNullInst

        // Note that if ARGUMENT_REG1 is a typehandle to something other than the
        // MethodTable of an instance, it has some extra bits set and we won't find
        // it as an interface.  Thus, it falls into the bizarre case

        push    ebx
        mov     eax, [ARGUMENT_REG2]    // get MethodTable
        movzx   ebx, word ptr [eax]MethodTable.m_wNumInterface
        mov     eax, [eax]MethodTable.m_pIMap
        test    ebx, ebx
        jz      DoBizarre
    }
Top:
    __asm
    {
        // eax -> current InterfaceInfo_t entry in m_pIMap list
        cmp     ARGUMENT_REG1, [eax]InterfaceInfo_t.m_pMethodTable
        je      Found

        // Don't have to worry about dynamically added interfaces (where m_startSlot is
        // -1) because m_dwNumInterface doesn't include the dynamic count.
        add     eax, sizeof_InterfaceInfo_t
        dec     ebx
        jnz     Top

        // fall through to DoBizarre
    }

DoBizarre:
    __asm
    {
        pop     ebx
        jmp     dword ptr [utilFuncTable + JIT_UTIL_ISINSTANCEBIZARRE * SIZE VMHELPDEF]VMHELPDEF.pfnHelper
    }

Found:
    __asm
    {
        pop     ebx

        // fall through to IsNullInst, to return the successful object
    }

IsNullInst:
    __asm
    {
        mov     eax, ARGUMENT_REG2      // either null, or the successful instance
        ret
    }
}

// This is a helper used by IsInstanceOfClass below.  This is only called when
// the instance has already been determined to be a proxy.  Also, the EEClass
// must refer to a class (not an interface or array).
static Object* __stdcall JIT_IsInstanceOfClassWorker(OBJECTREF objref, EEClass *pClass, BOOL bThrow)
{
    HCIMPL_PROLOG(JIT_IsInstanceOfClassWorker);   // just make certain we don't do any GC's in here
    MethodTable *pMT = objref->GetMethodTable();

    _ASSERTE(pMT->IsThunking());
    _ASSERTE(!pClass->IsInterface());

	// Check whether the type represented by the proxy can be
	// cast to the given type
	HELPER_METHOD_FRAME_BEGIN_RET_1(objref);
	pClass->CheckRestore();
	if (!CRemotingServices::CheckCast(objref, pClass))
		objref = 0;
	HELPER_METHOD_FRAME_END();

	if (objref == 0 && bThrow)
		FCThrow(kInvalidCastException);
	return OBJECTREFToObject(objref);
}


// This is shared code between IsInstanceClass and ChkCastClass.  It assumes
// that the instance is in eax, the class is in ARGUMENT_REG1, the instances
// method table is in ARGUMENT_REG2 and  and that the instance is not NULL.
// It also assumes that there is not an exact match with the class.
extern "C" int /* OBJECTREF */ __declspec(naked) __stdcall JIT_IsInstanceOfClassHelper()
{
    enum 
    { 
        MTProxyFlags = MethodTable::enum_CtxProxyMask |
                       MethodTable::enum_TransparentProxy,
    };

    __asm {
        // Get the class ptrs from the method tables.
        mov             ARGUMENT_REG1, dword ptr [ARGUMENT_REG1]MethodTable.m_pEEClass
        mov             ARGUMENT_REG2, dword ptr [ARGUMENT_REG2]MethodTable.m_pEEClass

    // Check if the parent class matches.
    CheckParent:
        mov             ARGUMENT_REG2, dword ptr [ARGUMENT_REG2]EEClass.m_pParentClass
        cmp             ARGUMENT_REG1, ARGUMENT_REG2
        jne             CheckNull

        // We matched the class.
        // Since eax constains the instance (known not to be NULL, we are fine).
        ret

    // Check if we hit the top of the hierarchy.
    CheckNull:
        test            ARGUMENT_REG2, ARGUMENT_REG2
        jne             CheckParent

    // Check if the instance is a proxy.
        mov             ARGUMENT_REG2, [eax]
        mov             ARGUMENT_REG2, dword ptr [ARGUMENT_REG2]MethodTable.m_wFlags
        test            ARGUMENT_REG2, MTProxyFlags
        jne             IsProxy

    // It didn't match and it isn't a proxy.
        xor             eax, eax
        ret

    // Cast didn't match, so try the worker to check for the proxy case.
    IsProxy:
        pop edx
        push 0            // no throw
        push ARGUMENT_REG1
        push eax
        push edx
        jmp JIT_IsInstanceOfClassWorker
    }
}


static int /* OBJECTREF */ __declspec(naked) __stdcall JIT_IsInstanceOfClassHelperWithThrow()
{
    enum 
    { 
        MTProxyFlags = MethodTable::enum_CtxProxyMask |
                       MethodTable::enum_TransparentProxy,
    };

    __asm {
        // Get the class ptrs from the method tables.
        mov             ARGUMENT_REG1, dword ptr [ARGUMENT_REG1]MethodTable.m_pEEClass
        mov             ARGUMENT_REG2, dword ptr [ARGUMENT_REG2]MethodTable.m_pEEClass

    // Check if the parent class matches.
    CheckParent:
        mov             ARGUMENT_REG2, dword ptr [ARGUMENT_REG2]EEClass.m_pParentClass
        cmp             ARGUMENT_REG1, ARGUMENT_REG2
        jne             CheckNull

        // We matched the class.
        // Since eax constains the instance (known not to be NULL, we are fine).
        ret

    // Check if we hit the top of the hierarchy.
    CheckNull:
        test            ARGUMENT_REG2, ARGUMENT_REG2
        jne             CheckParent

    // Check if the instance is a proxy.
        mov             ARGUMENT_REG2, [eax]
        mov             ARGUMENT_REG2, dword ptr [ARGUMENT_REG2]MethodTable.m_wFlags
        test            ARGUMENT_REG2, MTProxyFlags
        jne             IsProxy

    // It didn't match and it isn't a proxy.
        mov             ARGUMENT_REG1, CORINFO_InvalidCastException
        jmp             dword ptr [hlpFuncTable + CORINFO_HELP_INTERNALTHROW * SIZE VMHELPDEF]VMHELPDEF.pfnHelper

    // Cast didn't match, so try the worker to check for the proxy case.
    IsProxy:
        pop edx
        push 1            // throw exception if we can not cast
        push ARGUMENT_REG1
        push eax
        push edx
        jmp JIT_IsInstanceOfClassWorker
    }
}


extern "C" int __declspec(naked) __stdcall JIT_ChkCastClass()
{
    __asm
    {
        // Prime eax with the instance.
        mov             eax, ARGUMENT_REG2

        // Check if the instance is NULL
        test            ARGUMENT_REG2, ARGUMENT_REG2
        je              IsNullInst

        // Get the method table for the instance.
        mov             ARGUMENT_REG2, dword ptr [ARGUMENT_REG2]

        // Check if they are the same.
        cmp             ARGUMENT_REG1, ARGUMENT_REG2
        je              IsInst

        // Check for type compatibility.
        jmp            JIT_IsInstanceOfClassHelperWithThrow

    IsInst:
    IsNullInst:
        ret
    }
}


// This is the ASM portion of JIT_ChkCast.  For all the bizarre cases, it quickly
// fails and falls back on the JIT_ChkCastBizarre helper.  So all failure cases take
// the slow path, too.
//
// ARGUMENT_REG1 = array or interface to check for.
// ARGUMENT_REG2 = instance to be cast.

extern "C" int __declspec(naked) __stdcall JIT_ChkCast()
{
    __asm
    {
        test    ARGUMENT_REG2, ARGUMENT_REG2
        jz      IsNullInst

        // Note that if ARGUMENT_REG1 is a typehandle to something other than the
        // MethodTable of an instance, it has some extra bits set and we won't find
        // it as an interface.  Thus, it falls into the bizarre case

        push    ebx
        mov     eax, [ARGUMENT_REG2]    // get MethodTable
        movzx   ebx, word ptr [eax]MethodTable.m_wNumInterface
        mov     eax, [eax]MethodTable.m_pIMap
        test    ebx, ebx
        jz      DoBizarre
    }
Top:
    __asm
    {
        // eax -> current InterfaceInfo_t entry in m_pIMap list
        cmp     ARGUMENT_REG1, [eax]InterfaceInfo_t.m_pMethodTable
        je      Found

        // Don't have to worry about dynamically added interfaces (where m_startSlot is
        // -1) because m_dwNumInterface doesn't include the dynamic count.
        add     eax, sizeof_InterfaceInfo_t
        dec     ebx
        jnz     Top

        // fall through to DoBizarre
    }

DoBizarre:
    __asm
    {
        pop     ebx
        jmp     dword ptr [utilFuncTable + JIT_UTIL_CHKCASTBIZARRE * SIZE VMHELPDEF]VMHELPDEF.pfnHelper
    }

Found:
    __asm
    {
        pop     ebx

        // fall through to IsNullInst, to return the successful object
    }

IsNullInst:
    __asm
    {
        mov     eax, ARGUMENT_REG2      // either null, or the successful instance
        ret
    }
}



#ifdef _DEBUG
// These are some asserts that the check cast & IsInst code below rely on.
void ChkCastAsserts()
{
    __asm 
    {
        push    ARGUMENT_REG1
        push    ARGUMENT_REG2
    }

    _ASSERTE(NUM_ARGUMENT_REGISTERS >= 2);

    __asm 
    {
        pop             ARGUMENT_REG2
        pop             ARGUMENT_REG1
    }
}
#endif // _DEBUG

/*********************************************************************/
// This is a frameless helper for entering a monitor on a object.
// The object is in ARGUMENT_REG1.  This tries the normal case (no
// blocking or object allocation) in line and calls a framed helper
// for the other cases.
// ***** NOTE: if you make any changes to this routine, build with MON_DEBUG undefined
// to make sure you don't break the non-debug build. This is very fragile code.
void __declspec(naked) __fastcall JIT_MonEnter(OBJECTREF or)
{
    enum 
    { 
        SyncBlockIndexOffset = sizeof(ObjHeader) - offsetof(ObjHeader, m_SyncBlockValue),
        MTCtxProxyFlag       = MethodTable::enum_CtxProxyMask,
    };

    __asm {
        // Check if the instance is NULL.
        test            ARGUMENT_REG1, ARGUMENT_REG1
        jz              NullInst

#ifdef MON_DEBUG
        // Get the method table.
        mov             eax, [ARGUMENT_REG1]

        // todo: The following two lines are legacy and should be removed. CtxProxy does not exist anymore.
		//       not doing it in v1 since this does not affect retail builds
        test            dword ptr [eax]MethodTable.m_wFlags, MTCtxProxyFlag
        jne             ProxyInst

        // Check to see if this is a value class.
        mov             eax, [eax]MethodTable.m_pEEClass
        mov             eax, [eax]EEClass.m_VMFlags
        test            eax, VMFLAG_VALUETYPE
        jnz             ValueClass
#endif // MON_DEBUG

        // Initialize delay value for retry with exponential backoff
        push            ebx
        mov             ebx, 50

        // We need yet another register to avoid refetching the thread object
        push            esi
        call            dword ptr [GetThread]
        mov             esi, eax
RetryThinLock:
        // Fetch the object header dword 
        mov             eax, dword ptr [ARGUMENT_REG1-SyncBlockIndexOffset]

        // Check whether we have the "thin lock" layout, the lock is free and the spin lock bit not set
        test            eax, BIT_SBLK_IS_SYNCBLOCKINDEX + BIT_SBLK_SPIN_LOCK + SBLK_MASK_LOCK_THREADID + SBLK_MASK_LOCK_RECLEVEL
        jnz             NeedMoreTests

        // Everything is fine - get the thread id to store in the lock
        mov             edx, [esi]Thread.m_dwThinLockThreadId

        // If the thread id is too large, we need a syncblock for sure
        cmp             edx, SBLK_MASK_LOCK_THREADID
        ja              CreateSyncBlock

        // We want to store a new value with the current thread id set in the low 10 bits
        or              edx, eax
        nop
        cmpxchg         dword ptr [ARGUMENT_REG1-SyncBlockIndexOffset], edx
        jnz             PrepareToWaitThinLock

        // Everything went fine and we're done
        inc             [esi]Thread.m_dwLockCount
        pop             esi
        pop             ebx
        ret

NeedMoreTests:
        // Ok, it's not the simple case - find out which case it is
        test            eax, BIT_SBLK_IS_SYNCBLOCKINDEX
        jnz             HaveSyncBlockIndex

        // The header is transitioning or the lock - treat this as if the lock was taken
        test            eax, BIT_SBLK_SPIN_LOCK
        jnz             PrepareToWaitThinLock

        // Here we know we have the "thin lock" layout, but the lock is not free.
        // It could still be the recursion case - compare the thread id to check
        mov             edx, eax
        and             edx, SBLK_MASK_LOCK_THREADID
        cmp             edx, [esi]Thread.m_dwThinLockThreadId
        jne             PrepareToWaitThinLock

        // Ok, the thread id matches, it's the recursion case.
        // Bump up the recursion level and check for overflow
        lea             edx, [eax+SBLK_LOCK_RECLEVEL_INC]
        test            edx, SBLK_MASK_LOCK_RECLEVEL
        jz              CreateSyncBlock

        // Try to put the new recursion level back. If the header was changed in the meantime,
        // we need a full retry, because the layout could have changed.
        nop
        cmpxchg         [ARGUMENT_REG1-SyncBlockIndexOffset], edx
        jnz             RetryHelperThinLock

        // Everything went fine and we're done
        pop             esi
        pop             ebx
        ret

PrepareToWaitThinLock:
        // If we are on an MP system, we try spinning for a certain number of iterations
        cmp             g_SystemInfo.dwNumberOfProcessors,1
        jle             CreateSyncBlock

        // exponential backoff: delay by approximately 2*ebx clock cycles (on a PIII)
        mov             eax, ebx
delayLoopThinLock:
		rep nop			// indicate to the CPU that we are spin waiting (useful for some Intel P4 multiprocs)
        dec             eax
        jnz             delayLoopThinLock

        // next time, wait 3 times as long
        imul            ebx, ebx, 3

        imul            eax, g_SystemInfo.dwNumberOfProcessors, 20000
        cmp             ebx, eax
        jle             RetryHelperThinLock    

        jmp             CreateSyncBlock

RetryHelperThinLock:
        jmp             RetryThinLock

HaveSyncBlockIndex:
        // Just and out the top bits and grab the syncblock index
        and             eax, MASK_SYNCBLOCKINDEX

        // Get the sync block pointer.
        mov             ARGUMENT_REG2, dword ptr [g_pSyncTable]
        mov             ARGUMENT_REG2, [ARGUMENT_REG2 + eax * SIZE SyncTableEntry]SyncTableEntry.m_SyncBlock;

        // Check if the sync block has been allocated.
        test            ARGUMENT_REG2, ARGUMENT_REG2
        jz              CreateSyncBlock

        // Get a pointer to the lock object.
        lea             ARGUMENT_REG2, [ARGUMENT_REG2]SyncBlock.m_Monitor

        // Attempt to acquire the lock.
    RetrySyncBlock:
        mov             eax, [ARGUMENT_REG2]AwareLock.m_MonitorHeld
        test            eax, eax
        jne             HaveWaiters

        // Common case, lock isn't held and there are no waiters. Attempt to
        // gain ownership ourselves.
        mov             ARGUMENT_REG1, 1
        nop
        cmpxchg         [ARGUMENT_REG2]AwareLock.m_MonitorHeld, ARGUMENT_REG1
        jnz             RetryHelperSyncBlock

        // Success. Save the thread object in the lock and increment the use count.
        mov             dword ptr [ARGUMENT_REG2]AwareLock.m_HoldingThread, esi
        inc             [esi]Thread.m_dwLockCount
        inc             [ARGUMENT_REG2]AwareLock.m_Recursion

#if defined(MON_DEBUG) && defined(TRACK_SYNC)
        push            ARGUMENT_REG2   // AwareLock
        push            [esp+4]         // return address
        call            EnterSyncHelper
#endif // _DEBUG && TRACK_SYNC

        pop             esi
        pop             ebx
        ret

        // It's possible to get here with waiters but no lock held, but in this
        // case a signal is about to be fired which will wake up a waiter. So
        // for fairness sake we should wait too.
        // Check first for recursive lock attempts on the same thread.
    HaveWaiters:

        // Is mutex already owned by current thread?
        cmp             [ARGUMENT_REG2]AwareLock.m_HoldingThread, esi
        jne             PrepareToWait

        // Yes, bump our use count.
        inc             [ARGUMENT_REG2]AwareLock.m_Recursion
#if defined(MON_DEBUG) && defined(TRACK_SYNC)
        push            ARGUMENT_REG2   // AwareLock
        push            [esp+4]         // return address
        call            EnterSyncHelper
#endif // _DEBUG && TRACK_SYNC
        pop             esi
        pop             ebx
        ret

    PrepareToWait:
        // If we are on an MP system, we try spinning for a certain number of iterations
        cmp             g_SystemInfo.dwNumberOfProcessors,1
        jle             HaveWaiters1

        // exponential backoff: delay by approximately 2*ebx clock cycles (on a PIII)
        mov             eax, ebx
    delayLoop:
		rep nop			// indicate to the CPU that we are spin waiting (useful for some Intel P4 multiprocs)
        dec             eax
        jnz             delayLoop

        // next time, wait 3 times as long
        imul            ebx, ebx, 3

        imul            eax, g_SystemInfo.dwNumberOfProcessors, 20000
        cmp             ebx, eax
        jle             RetrySyncBlock

HaveWaiters1:
        // Place AwareLock in arg1 and thread in arg2 then call contention helper.
        mov             ARGUMENT_REG1, ARGUMENT_REG2
        mov             ARGUMENT_REG2, esi
        pop             esi
        pop             ebx
        jmp             dword ptr [utilFuncTable + JIT_UTIL_MON_CONTENTION * SIZE VMHELPDEF]VMHELPDEF.pfnHelper

    RetryHelperSyncBlock:
        jmp             RetrySyncBlock

#ifdef MON_DEBUG
    ValueClass:
    ProxyInst:
        // Can't synchronize on value classes or proxy
        mov             ARGUMENT_REG1, CORINFO_ArgumentException
        jmp             dword ptr [hlpFuncTable + CORINFO_HELP_INTERNALTHROW * SIZE VMHELPDEF]VMHELPDEF.pfnHelper

#endif // MON_DEBUG

        // ARGUMENT_REG1 has the object to synchronize on
    CreateSyncBlock:
        pop             esi
        pop             ebx
        jmp             dword ptr [utilFuncTable + JIT_UTIL_MON_ENTER * SIZE VMHELPDEF]VMHELPDEF.pfnHelper

        // Throw a NULL argument exception.
    NullInst:
        mov             ARGUMENT_REG1, CORINFO_ArgumentNullException
        jmp             dword ptr [hlpFuncTable + CORINFO_HELP_INTERNALTHROW * SIZE VMHELPDEF]VMHELPDEF.pfnHelper
    }
}


/***********************************************************************/
// This is a frameless helper for trying to enter a monitor on a object.
// The object is in ARGUMENT_REG1 and a timeout in ARGUMENT_REG2. This tries the
// normal case (no object allocation) in line and calls a framed helper for the
// other cases.
// ***** NOTE: if you make any changes to this routine, build with MON_DEBUG undefined
// to make sure you don't break the non-debug build. This is very fragile code.

BOOL __declspec(naked) __fastcall JIT_MonTryEnter(OBJECTREF or)
{
    enum 
    { 
        SyncBlockIndexOffset = sizeof(ObjHeader) - offsetof(ObjHeader, m_SyncBlockValue),
        MTCtxProxyFlag       = MethodTable::enum_CtxProxyMask,
    };

    __asm {
        // Check if the instance is NULL.
        test            ARGUMENT_REG1, ARGUMENT_REG1
        jz              NullInst

        // Check if the timeout looks valid
        cmp             ARGUMENT_REG2, -1
        jl              InvalidTimeout

#ifdef MON_DEBUG
        // Get the method table.
        mov             eax, [ARGUMENT_REG1]

        // Test if this is a proxy.
        test            dword ptr [eax]MethodTable.m_wFlags, MTCtxProxyFlag
        jne             ProxyInst

        // Check to see if this is a value class.
        mov             eax, [eax]MethodTable.m_pEEClass
        mov             eax, [eax]EEClass.m_VMFlags
        test            eax, VMFLAG_VALUETYPE
        jnz             ValueClass
#endif // MON_DEBUG

        // Save the timeout parameter.
        push            ARGUMENT_REG2

        // The thin lock logic needs another register to store the thread
        push            esi

        // Get the thread right away, we'll need it in any case
        call            dword ptr [GetThread]
        mov             esi, eax

RetryThinLock:
        // Get the header dword and check its layout
        mov             eax, dword ptr [ARGUMENT_REG1-SyncBlockIndexOffset]

        // Check whether we have the "thin lock" layout, the spin lock bit is clear, and the lock is free
        test            eax, BIT_SBLK_IS_SYNCBLOCKINDEX + BIT_SBLK_SPIN_LOCK + SBLK_MASK_LOCK_THREADID + SBLK_MASK_LOCK_RECLEVEL
        jne             NeedMoreTests

        // Ok, everything is fine. Fetch the thread id and make sure it's small enough for thin locks
        mov             edx, [esi]Thread.m_dwThinLockThreadId
        cmp             edx, SBLK_MASK_LOCK_THREADID
        ja              CreateSyncBlock

        // Try to put our thread id in there
        or              edx, eax
        nop
        cmpxchg         [ARGUMENT_REG1-SyncBlockIndexOffset], edx
        jnz             RetryHelperThinLock

        // Got the lock - everything is fine
        inc             [esi]Thread.m_dwLockCount
        pop             esi

        // Timeout parameter not needed, ditch it from the stack.
        add             esp, 4

        mov             eax, 1
        ret

NeedMoreTests:
        // Ok, it's not the simple case - find out which case it is
        test            eax, BIT_SBLK_IS_SYNCBLOCKINDEX
        jnz             HaveSyncBlockIndex

        // The header is transitioning or the lock is taken
        test            eax, BIT_SBLK_SPIN_LOCK
        jnz             RetryHelperThinLock

        mov             edx, eax
        and             edx, SBLK_MASK_LOCK_THREADID
        cmp             edx, [esi]Thread.m_dwThinLockThreadId
        jne             WouldBlock

        // Ok, the thread id matches, it's the recursion case.
        // Bump up the recursion level and check for overflow
        lea             edx, [eax+SBLK_LOCK_RECLEVEL_INC]
        test            edx, SBLK_MASK_LOCK_RECLEVEL
        jz              CreateSyncBlock

        // Try to put the new recursion level back. If the header was changed in the meantime,
        // we need a full retry, because the header layout could have changed.
        nop
        cmpxchg         [ARGUMENT_REG1-SyncBlockIndexOffset], edx
        jnz             RetryHelperThinLock

        // Everything went fine and we're done
        pop             esi

        // Timeout parameter not needed, ditch it from the stack.
        add             esp, 4

        mov             eax, 1
        ret

RetryHelperThinLock:
        jmp             RetryThinLock


HaveSyncBlockIndex:
        // Just and out the top bits and grab the syncblock index
        and             eax, MASK_SYNCBLOCKINDEX

        // Get the sync block pointer.
        mov             ARGUMENT_REG2, dword ptr [g_pSyncTable]
        mov             ARGUMENT_REG2, [ARGUMENT_REG2 + eax * SIZE SyncTableEntry]SyncTableEntry.m_SyncBlock;

        // Check if the sync block has been allocated.
        test            ARGUMENT_REG2, ARGUMENT_REG2
        jz              CreateSyncBlock

        // Get a pointer to the lock object.
        lea             ARGUMENT_REG2, [ARGUMENT_REG2]SyncBlock.m_Monitor

        // We need another scratch register for what follows, so save EBX now so
        // we can use it for that purpose.
        push            ebx

        // Attempt to acquire the lock.
    RetrySyncBlock:
        mov             eax, [ARGUMENT_REG2]AwareLock.m_MonitorHeld
        test            eax, eax
        jne             HaveWaiters

        // Common case, lock isn't held and there are no waiters. Attempt to
        // gain ownership ourselves.
        mov             ebx, 1
        nop
        cmpxchg         [ARGUMENT_REG2]AwareLock.m_MonitorHeld, ebx
        jnz             RetryHelperSyncBlock

        pop             ebx

        // Success. Save the thread object in the lock and increment the use count.
        mov             dword ptr [ARGUMENT_REG2]AwareLock.m_HoldingThread, esi
        inc             [ARGUMENT_REG2]AwareLock.m_Recursion
        inc             [esi]Thread.m_dwLockCount

#if defined(MON_DEBUG) && defined(TRACK_SYNC)
        push            ARGUMENT_REG2   // AwareLock
        push            [esp+4]         // return address
        call            EnterSyncHelper
#endif // MON_DEBUG && TRACK_SYNC

        pop             esi

        // Timeout parameter not needed, ditch it from the stack.
        add             esp, 4

        mov             eax, 1
        ret

        // It's possible to get here with waiters but no lock held, but in this
        // case a signal is about to be fired which will wake up a waiter. So
        // for fairness sake we should wait too.
        // Check first for recursive lock attempts on the same thread.
    HaveWaiters:
        pop             ebx
        // Is mutex already owned by current thread?
        cmp             [ARGUMENT_REG2]AwareLock.m_HoldingThread, esi
        jne             WouldBlock

        // Yes, bump our use count.
        inc             [ARGUMENT_REG2]AwareLock.m_Recursion
#if defined(MON_DEBUG) && defined(TRACK_SYNC)
        push            ARGUMENT_REG2   // AwareLock
        push            [esp+4]         // return address
        call            EnterSyncHelper
#endif // MON_DEBUG && TRACK_SYNC
        pop             esi

        // Timeout parameter not needed, ditch it from the stack.
        add             esp, 4

        mov             eax, 1
        ret

        // We would need to block to enter the section. Return failure if
        // timeout is zero, else call the framed helper to do the blocking
        // form of TryEnter.
    WouldBlock:
        pop             esi
        pop             ARGUMENT_REG2
        test            ARGUMENT_REG2, ARGUMENT_REG2
        jnz             Block
        xor             eax, eax
        ret

    Block:
        // Arguments are already in correct registers, simply call the framed
        // version of TryEnter.
        jmp             dword ptr [utilFuncTable + JIT_UTIL_MON_TRY_ENTER * SIZE VMHELPDEF]VMHELPDEF.pfnHelper

    RetryHelperSyncBlock:
        jmp             RetrySyncBlock

#ifdef MON_DEBUG
    ValueClass:
    ProxyInst:
        // Can't synchronize on value classes.
        mov             ARGUMENT_REG1, CORINFO_ArgumentException
        jmp             dword ptr [hlpFuncTable + CORINFO_HELP_INTERNALTHROW * SIZE VMHELPDEF]VMHELPDEF.pfnHelper

#endif // MON_DEBUG

 
    CreateSyncBlock:
        // ARGUMENT_REG1 has the object to synchronize on, must retrieve the
        // timeout parameter from the stack.
        pop             esi
        pop             ARGUMENT_REG2
        jmp             dword ptr [utilFuncTable + JIT_UTIL_MON_TRY_ENTER * SIZE VMHELPDEF]VMHELPDEF.pfnHelper

    InvalidTimeout:
        // Throw an invalid argument exception.
        mov             ARGUMENT_REG1, CORINFO_ArgumentException
        jmp             dword ptr [hlpFuncTable + CORINFO_HELP_INTERNALTHROW * SIZE VMHELPDEF]VMHELPDEF.pfnHelper

    NullInst:
        // Throw a NULL argument exception.
        mov             ARGUMENT_REG1, CORINFO_ArgumentNullException
        jmp             dword ptr [hlpFuncTable + CORINFO_HELP_INTERNALTHROW * SIZE VMHELPDEF]VMHELPDEF.pfnHelper
    }
}


/*********************************************************************/
// This is a frameless helper for exiting a monitor on a object.
// The object is in ARGUMENT_REG1.  This tries the normal case (no
// blocking or object allocation) in line and calls a framed helper
// for the other cases.
// ***** NOTE: if you make any changes to this routine, build with MON_DEBUG undefined
// to make sure you don't break the non-debug build. This is very fragile code.
void __declspec(naked) __fastcall JIT_MonExit(OBJECTREF or)
{
    enum 
    { 
        SyncBlockIndexOffset = sizeof(ObjHeader) - offsetof(ObjHeader, m_SyncBlockValue),
        MTCtxProxyFlag       = MethodTable::enum_CtxProxyMask,
    };

    __asm {
        // Check if the instance is NULL.
        test            ARGUMENT_REG1, ARGUMENT_REG1
        jz              NullInst

        // The thin lock logic needs an additional register to hold the thread, unfortunately
        push            esi
        call            dword ptr [GetThread]
        mov             esi, eax

RetryThinLock:
        // Fetch the header dword and check its layout and the spin lock bit
        mov             eax, dword ptr [ARGUMENT_REG1-SyncBlockIndexOffset]
        test            eax, BIT_SBLK_IS_SYNCBLOCKINDEX + BIT_SBLK_SPIN_LOCK
        jnz             NeedMoreTests

        // Ok, we have a "thin lock" layout - check whether the thread id matches
        mov             edx, eax
        and             edx, SBLK_MASK_LOCK_THREADID
        cmp             edx, [esi]Thread.m_dwThinLockThreadId
        jne             JustLeave

        // Check the recursion level
        test            eax, SBLK_MASK_LOCK_RECLEVEL
        jne             DecRecursionLevel

        // It's zero - we're leaving the lock.
        // So try to put back a zero thread id.
        // edx and eax match in the thread id bits, and edx is zero elsewhere, so the xor is sufficient
        xor             edx, eax
        nop
        cmpxchg         [ARGUMENT_REG1-SyncBlockIndexOffset], edx
        jnz             RetryHelperThinLock

        // We're done
        dec             [esi]Thread.m_dwLockCount
        pop             esi
        ret

DecRecursionLevel:
        lea             edx, [eax-SBLK_LOCK_RECLEVEL_INC]
        nop
        cmpxchg         [ARGUMENT_REG1-SyncBlockIndexOffset], edx
        jnz             RetryHelperThinLock

        // We're done
        pop             esi
        ret

NeedMoreTests:
        test            eax, BIT_SBLK_SPIN_LOCK
        jnz             ThinLockHelper

        // Get the sync block index and use it to compute the sync block pointer
        mov             ARGUMENT_REG1, dword ptr [g_pSyncTable]
        and             eax, MASK_SYNCBLOCKINDEX
        mov             ARGUMENT_REG1, [ARGUMENT_REG1 + eax* SIZE SyncTableEntry]SyncTableEntry.m_SyncBlock

        // was there a sync block?
        test            ARGUMENT_REG1, ARGUMENT_REG1
        jz              LockError

        // Get a pointer to the lock object.
        lea             ARGUMENT_REG1, [ARGUMENT_REG1]SyncBlock.m_Monitor

        // Check if lock is held.
        cmp             [ARGUMENT_REG1]AwareLock.m_HoldingThread, esi
        // There's a strange case where we are waiting to enter a contentious region when
        // a Thread.Interrupt occurs.  The finally protecting the leave will attempt to
        // remove us from a region we never entered.  We don't have to worry about leaving
        // the wrong entry for a recursive case, because recursive cases can never be
        // contentious, so the Thread.Interrupt will never be serviced at that spot.
        jne             JustLeave

#if defined(MON_DEBUG) && defined(TRACK_SYNC)
        push            ARGUMENT_REG1   // preserve regs

        push            ARGUMENT_REG1   // AwareLock
        push            [esp+8]         // return address
        call            LeaveSyncHelper

        pop             ARGUMENT_REG1   // restore regs
#endif // MON_DEBUG && TRACK_SYNC

        // Reduce our recursion count.
        dec             [ARGUMENT_REG1]AwareLock.m_Recursion
        jz              LastRecursion

    JustLeave:
        pop             esi
        ret

RetryHelperThinLock:
        jmp             RetryThinLock

ThinLockHelper:
        pop             esi
        jmp             dword ptr [utilFuncTable + JIT_UTIL_MON_EXIT_THINLOCK * SIZE VMHELPDEF]VMHELPDEF.pfnHelper

        // This is the last count we held on this lock, so release the lock.
    LastRecursion:
#if defined(MON_DEBUG) && defined(TRACK_SYNC)
        mov             eax, [ARGUMENT_REG1]AwareLock.m_HoldingThread
#endif        
        dec             [esi]Thread.m_dwLockCount
        mov             dword ptr [ARGUMENT_REG1]AwareLock.m_HoldingThread, 0
        pop             esi

    Retry:
        mov             eax, [ARGUMENT_REG1]AwareLock.m_MonitorHeld
        lea             ARGUMENT_REG2, [eax-1]
        nop
        cmpxchg         [ARGUMENT_REG1]AwareLock.m_MonitorHeld, ARGUMENT_REG2
        jne             RetryHelper
        test            eax, 0xFFFFFFFE
        jne             MustSignal

        ret

    MustSignal:
        jmp             dword ptr [utilFuncTable + JIT_UTIL_MON_EXIT * SIZE VMHELPDEF]VMHELPDEF.pfnHelper

    RetryHelper:
        jmp             Retry

        // Throw a NULL argument exception.
    NullInst:
        mov             ARGUMENT_REG1, CORINFO_ArgumentNullException
        jmp             dword ptr [hlpFuncTable + CORINFO_HELP_INTERNALTHROW * SIZE VMHELPDEF]VMHELPDEF.pfnHelper

        // Throw a syncronization lock exception.
    LockError:
        pop             esi
        mov             ARGUMENT_REG1, CORINFO_SynchronizationLockException;
        jmp             dword ptr [hlpFuncTable + CORINFO_HELP_INTERNALTHROW * SIZE VMHELPDEF]VMHELPDEF.pfnHelper

    }
}

static Object* __stdcall JIT_AllocateObjectSpecial(CORINFO_CLASS_HANDLE typeHnd_)
{
    HCIMPL_PROLOG(JIT_AllocateObjectSpecial);   // just make certain we don't do any GC's in here
    TypeHandle typeHnd(typeHnd_);

    OBJECTREF newobj;
    HELPER_METHOD_FRAME_BEGIN_RET_0();    // Set up a frame
    __helperframe.SetFrameAttribs(Frame::FRAME_ATTR_RETURNOBJ);

    THROWSCOMPLUSEXCEPTION();
    _ASSERTE(typeHnd.IsUnsharedMT());                                   // we never use this helper for arrays
    MethodTable *pMT = typeHnd.AsMethodTable();
    pMT->CheckRestore();

	newobj = AllocateObjectSpecial(pMT);

    HELPER_METHOD_FRAME_END();
    return(OBJECTREFToObject(newobj));
}


static Object* __stdcall JIT_NewCrossContextHelper(CORINFO_CLASS_HANDLE typeHnd_)
{
    HCIMPL_PROLOG(JIT_NewCrossContextHelper);   // just make certain we don't do any GC's in here
    TypeHandle typeHnd(typeHnd_);

    OBJECTREF newobj;
    HELPER_METHOD_FRAME_BEGIN_RET_0();    // Set up a frame
    __helperframe.SetFrameAttribs(Frame::FRAME_ATTR_RETURNOBJ);

    THROWSCOMPLUSEXCEPTION();
    _ASSERTE(typeHnd.IsUnsharedMT());                                   // we never use this helper for arrays
    MethodTable *pMT = typeHnd.AsMethodTable();
    pMT->CheckRestore();

    // Remoting services determines if the current context is appropriate
    // for activation. If the current context is OK then it creates an object
    // else it creates a proxy.
    // Note: 3/20/03 Added fIsNewObj flag to indicate that CreateProxyOrObject 
    // is being called from Jit_NewObj ... the fIsCom flag is FALSE by default -
    // which used to be the case before this change as well.
    newobj = CRemotingServices::CreateProxyOrObject(pMT,FALSE /*fIsCom*/,TRUE/*fIsNewObj*/);

    HELPER_METHOD_FRAME_END();
    return(OBJECTREFToObject(newobj));
}

Object *AllocObjectWrapper(MethodTable *pMT)
{
    _ASSERTE(!CORProfilerTrackAllocationsEnabled());
    HCIMPL_PROLOG(AllocObjectWrapper);
    OBJECTREF newObj;
    HELPER_METHOD_FRAME_BEGIN_RET_0();    // Set up a frame
    __helperframe.SetFrameAttribs(Frame::FRAME_ATTR_RETURNOBJ);
    newObj = FastAllocateObject(pMT);
    HELPER_METHOD_FRAME_END();
    return OBJECTREFToObject(newObj);
}

__declspec(naked) Object* __fastcall JIT_NewCrossContextProfiler(CORINFO_CLASS_HANDLE typeHnd_)
{
    _asm
    {
        push ARGUMENT_REG1
        call JIT_NewCrossContextHelper
        ret
    }
}

/*********************************************************************/
// This is a frameless helper for allocating an object whose type derives
// from marshalbyref. We check quickly to see if it is configured to 
// have remote activation. If not, we use the superfast allocator to 
// allocate the object. Otherwise, we take the slow path of allocating
// the object via remoting services.
__declspec(naked) Object* __fastcall JIT_NewCrossContext(CORINFO_CLASS_HANDLE typeHnd_)

{
    _asm
    {
        // !!!!!!!!!!!!!WARNING!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
        // NOTE: We treat the type handle as a method table
        // If the semantics of the type handle change then we will fail here.
        //!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
        mov eax, [ARGUMENT_REG1]MethodTable.m_pEEClass;
        // Check if remoting has been configured
        push ARGUMENT_REG1  // save registers
        push eax
        call CRemotingServices::RequiresManagedActivation
        test eax, eax
        // Jump to the slow path
        jne SpecialOrXCtxHelper

#ifdef _DEBUG
        push LL_INFO10
        push LF_GCALLOC
        call LoggingOn
        test eax, eax
        jne AllocWithLogHelper
#endif

		// if the object doesn't have a finalizer and the size is small, jump to super fast asm helper
		mov		ARGUMENT_REG1, [esp]
		call	MethodTable::CannotUseSuperFastHelper
		test	eax, eax
		jne		FastHelper
		
		pop		ARGUMENT_REG1
	    // Jump to the super fast helper 
		jmp     dword ptr [hlpFuncTable + CORINFO_HELP_NEWSFAST * SIZE VMHELPDEF]VMHELPDEF.pfnHelper

FastHelper:
	    // Jump to the fast helper
		pop		ARGUMENT_REG1
        jmp dword ptr [hlpFuncTable + CORINFO_HELP_NEWFAST * SIZE VMHELPDEF]VMHELPDEF.pfnHelper


SpecialOrXCtxHelper:
		test	eax, ComObjectType		
		jz		XCtxHelper	
		call    JIT_AllocateObjectSpecial
		ret

XCtxHelper:
        call JIT_NewCrossContextHelper
        ret

#ifdef _DEBUG
AllocWithLogHelper:
        call AllocObjectWrapper
        ret
#endif
    }    
}

/*********************************************************************/
// This is a frameless helper for entering a static monitor on a class.
// The methoddesc is in ARGUMENT_REG1.  This tries the normal case (no
// blocking or object allocation) in line and calls a framed helper
// for the other cases.
// Note we are changing the methoddesc parameter to a pointer to the
// AwareLock.
// ***** NOTE: if you make any changes to this routine, build with MON_DEBUG undefined
// to make sure you don't break the non-debug build. This is very fragile code.
void __declspec(naked) __fastcall JIT_MonEnterStatic(AwareLock *lock)
{
    __asm {
        // We need another scratch register for what follows, so save EBX now so
        // we can use it for that purpose.
        push            ebx

        // Attempt to acquire the lock.
    Retry:
        mov             eax, [ARGUMENT_REG1]AwareLock.m_MonitorHeld
        test            eax, eax
        jne             HaveWaiters

        // Common case, lock isn't held and there are no waiters. Attempt to
        // gain ownership ourselves.
        mov             ebx, 1
        nop
        cmpxchg         [ARGUMENT_REG1]AwareLock.m_MonitorHeld, ebx
        jnz             RetryHelper

        pop             ebx

        // Success. Save the thread object in the lock and increment the use count.
        call            dword ptr [GetThread]
        mov             dword ptr [ARGUMENT_REG1]AwareLock.m_HoldingThread, eax
        inc             [ARGUMENT_REG1]AwareLock.m_Recursion
        inc             [eax]Thread.m_dwLockCount

#if defined(MON_DEBUG) && defined(TRACK_SYNC)
        push            ARGUMENT_REG1   // AwareLock
        push            [esp+4]         // return address
        call            EnterSyncHelper
#endif // MON_DEBUG && TRACK_SYNC
        ret

        // It's possible to get here with waiters but no lock held, but in this
        // case a signal is about to be fired which will wake up a waiter. So
        // for fairness sake we should wait too.
        // Check first for recursive lock attempts on the same thread.
    HaveWaiters:
        // Get thread but preserve EAX (contains cached contents of m_MonitorHeld).
        push            eax
        call            dword ptr [GetThread]
        mov             ebx, eax
        pop             eax

        // Is mutex already owned by current thread?
        cmp             [ARGUMENT_REG1]AwareLock.m_HoldingThread, ebx
        jne             PrepareToWait

        // Yes, bump our use count.
        inc             [ARGUMENT_REG1]AwareLock.m_Recursion
#if defined(MON_DEBUG) && defined(TRACK_SYNC)
        push            ARGUMENT_REG1   // AwareLock
        push            [esp+4]         // return address
        call            EnterSyncHelper
#endif // MON_DEBUG && TRACK_SYNC
        pop             ebx
        ret

        // We're going to have to wait. Increment wait count.
    PrepareToWait:
        pop             ebx
        jmp             dword ptr [utilFuncTable + JIT_UTIL_MON_CONTENTION * SIZE VMHELPDEF]VMHELPDEF.pfnHelper

    RetryHelper:
        jmp             Retry
    }
}


/*********************************************************************/
// A frameless helper for exiting a static monitor on a class.
// The methoddesc is in ARGUMENT_REG1.  This tries the normal case (no
// blocking or object allocation) in line and calls a framed helper
// for the other cases.
// Note we are changing the methoddesc parameter to a pointer to the
// AwareLock.
// ***** NOTE: if you make any changes to this routine, build with MON_DEBUG undefined
// to make sure you don't break the non-debug build. This is very fragile code.
void __declspec(naked) __fastcall JIT_MonExitStatic(AwareLock *lock)
{
    __asm {

#if defined(MON_DEBUG) && defined(TRACK_SYNC)
        push            ARGUMENT_REG1   // preserve regs

        push            ARGUMENT_REG1   // AwareLock
        push            [esp+8]         // return address
        call            LeaveSyncHelper

        pop             ARGUMENT_REG1   // restore regs
#endif // _DEBUG && TRACK_SYNC

        // Check if lock is held.
        call            dword ptr [GetThread]
        cmp             [ARGUMENT_REG1]AwareLock.m_HoldingThread, eax
        // There's a strange case where we are waiting to enter a contentious region when
        // a Thread.Interrupt occurs.  The finally protecting the leave will attempt to
        // remove us from a region we never entered.  We don't have to worry about leaving
        // the wrong entry for a recursive case, because recursive cases can never be
        // contentious, so the Thread.Interrupt will never be serviced at that spot.
        jne             JustLeave

        // Reduce our recursion count.
        dec             [ARGUMENT_REG1]AwareLock.m_Recursion
        jz              LastRecursion

        ret

        // This is the last count we held on this lock, so release the lock.
    LastRecursion:
        // eax must have the thread object
        dec             [eax]Thread.m_dwLockCount
        mov             dword ptr [ARGUMENT_REG1]AwareLock.m_HoldingThread, 0
        push            ebx

    Retry:
        mov             eax, [ARGUMENT_REG1]AwareLock.m_MonitorHeld
        lea             ebx, [eax-1]
        nop
        cmpxchg         [ARGUMENT_REG1]AwareLock.m_MonitorHeld, ebx
        jne             RetryHelper
        pop             ebx
        test            eax, 0xFFFFFFFE
        jne             MustSignal

    JustLeave:
        ret

    MustSignal:
        jmp             dword ptr [utilFuncTable + JIT_UTIL_MON_EXIT * SIZE VMHELPDEF]VMHELPDEF.pfnHelper

    RetryHelper:
        jmp             Retry
    }
}

// These functions are just here so we can link - for x86 high perf helpers are generated at startup
// so we should never get here
Object* __fastcall JIT_TrialAllocSFastSP(MethodTable *mt)   // JITinterfaceX86.cpp/JITinterfaceGen.cpp
{
    _ASSERTE(!"JIT_TrialAllocSFastSP");
    return  NULL;
}

// These functions are just here so we can link - for x86 high perf helpers are generated at startup
// so we should never get here
Object* __fastcall JIT_TrialAllocSFastMP(MethodTable *mt)   // JITinterfaceX86.cpp/JITinterfaceGen.cpp
{
    _ASSERTE(!"JIT_TrialAllocSFastMP");
    return  NULL;
}

// Note that the debugger skips this entirely when doing SetIP,
// since COMPlusCheckForAbort should always return 0.  Excep.cpp:LeaveCatch
// asserts that to be true.  If this ends up doing more work, then the
// debugger may need additional support.
// -- MiPanitz
__declspec(naked) void __stdcall JIT_EndCatch()
{
    COMPlusEndCatch( NULL,NULL);  // returns old esp value in eax
    _asm {
        mov     ecx, [esp]                              // actual return address into jitted code
        mov     edx, eax                                // old esp value
        push    eax                                     // save old esp
        push    ebp
        call    COMPlusCheckForAbort                    // returns old esp value
        pop     ecx
        // at this point, ecx   = old esp value 
        //                [esp] = return address into jitted code
        //                eax   = 0 (if no abort), address to jump to otherwise
        test    eax, eax
        jz      NormalEndCatch
        lea     esp, [esp-4]            // throw away return address into jitted code
        mov     esp, ecx
        jmp     eax

NormalEndCatch:
        pop     eax         // Move the returnAddress into ecx
        mov     esp, ecx    // Reset esp to the old value
        jmp     eax         // Resume after the "endcatch"
    }
}

HCIMPL1(int, JIT_Dbl2IntOvf, double val)
{
    __asm fnclex
    __int64 ret = JIT_Dbl2Lng(val);

    if (ret != (__int32) ret)
        goto THROW;

    return (__int32) ret;

THROW:
    FCThrow(kOverflowException);
}
HCIMPLEND


HCIMPL1(INT64, JIT_Dbl2LngOvf, double val)
{
    __asm fnclex
    __int64 ret = JIT_Dbl2Lng(val);
    __asm {
        fnstsw  ax
        and     ax,01h
        test    ax, ax
        jnz     THROW
    }
    return ret;

THROW:
    FCThrow(kOverflowException);
    return(0);
}
HCIMPLEND

__declspec(naked) VOID __cdecl InternalExceptionWorker()
{
    __asm{
        jmp             dword ptr [hlpFuncTable + CORINFO_HELP_INTERNALTHROW * SIZE VMHELPDEF]VMHELPDEF.pfnHelper
    }
}

/*********************************************************************/
// This is called by the JIT after every instruction in fully interuptable
// code to make certain our GC tracking is OK
HCIMPL0(VOID, JIT_StressGC_NOP) {}
HCIMPLEND


HCIMPL0(VOID, JIT_StressGC)
{
#ifdef _DEBUG
        HELPER_METHOD_FRAME_BEGIN_0();    // Set up a frame
        g_pGCHeap->GarbageCollect();

// @TODO: the following ifdef is in error, but if corrected the
// compiler complains about the *__ms->pRetAddr() saying machine state
// doesn't allow ->
#ifdef _X86
                // Get the machine state, (from HELPER_METHOD_FRAME_BEGIN)
                // and wack our return address to a nop function
        BYTE* retInstrs = ((BYTE*) *__ms->pRetAddr()) - 4;
        _ASSERTE(retInstrs[-1] == 0xE8);                // it is a call instruction
                // Wack it to point to the JITStressGCNop instead
        FastInterlockExchange((LONG*) retInstrs), (LONG) JIT_StressGC_NOP);
#endif // _X86
        HELPER_METHOD_FRAME_END();

#endif // _DEBUG
}
HCIMPLEND


/*********************************************************************/
// Caller has to be an EBP frame, callee-saved registers (EDI, ESI, EBX) have
// to be saved on the stack just below the stack arguments,
// enregistered arguements are in correct registers, remaining args pushed
// on stack, followed by target address and count of stack arguments.
// So the stack will look like TailCallArgs

#pragma warning(push)
#pragma warning(disable : 4200 )  // zero-sized array

struct TailCallArgs
{
    DWORD       dwRetAddr;
    DWORD       dwTargetAddr;

    int         offsetCalleeSavedRegs   : 28;
    unsigned    ebpRelCalleeSavedRegs   : 1;
    unsigned    maskCalleeSavedRegs     : 3; // EBX, ESDI, EDI

    DWORD       nNewStackArgs;
    DWORD       nOldStackArgs;
    DWORD       newStackArgs[0];
    DWORD *     GetCalleeSavedRegs(DWORD * Ebp)
    {
        if (ebpRelCalleeSavedRegs)
            return (DWORD*)&Ebp[-offsetCalleeSavedRegs];
        else
            // @TODO : Doesnt work with localloc
            return (DWORD*)&newStackArgs[nNewStackArgs + offsetCalleeSavedRegs];
    }
};
#pragma warning(pop)

#pragma warning (disable : 4731)
extern "C" void __cdecl JIT_TailCallHelper(ArgumentRegisters argRegs,
                                           MachState machState, TailCallArgs * args)
{
    Thread * pThread = GetThread();

    bool shouldTrip = pThread->CatchAtSafePoint() != 0;

#ifdef _DEBUG
    // Force a GC if the stress level is high enough. Doing it on every tailcall
    // will slow down things too much. So do only periodically
    static count = 0;
    count++;
    if ((count % 10)==0 && (g_pConfig->GetGCStressLevel() & EEConfig::GCSTRESS_TRANSITION))
        shouldTrip = true;
#endif // _DEBUG

    if (shouldTrip)
    {
        /* We will rendezvous with the EE. Set up frame to protect the arguments */

        MethodDesc * pMD = Entry2MethodDesc((BYTE *)(size_t)args->dwTargetAddr, NULL);

        // The return address is separated from the stack arguments by the
        // extra arguments passed to JIT_TailCall(). Put them together
        // while creating the helper frame. When done, we will undo this.

        DWORD oldArgs = args->nOldStackArgs;        // temp
        _ASSERTE(offsetof(TailCallArgs, nOldStackArgs) + sizeof(void*) ==
                 offsetof(TailCallArgs,newStackArgs));
        args->nOldStackArgs = args->dwRetAddr;      // move dwRetAddr near newStackArgs[]
        _ASSERTE(machState.pRetAddr() == (void**)(size_t)0xDDDDDDDD);
        machState.pRetAddr()  = (void **)&args->nOldStackArgs;

        HelperMethodFrame helperFrame(&machState, pMD, &argRegs);

#ifdef STRESS_HEAP
        if ((g_pConfig->GetGCStressLevel() & EEConfig::GCSTRESS_TRANSITION)
#ifdef _DEBUG
            && !g_pConfig->FastGCStressLevel()
#endif
            )
        {
            // GC stress
            g_pGCHeap->StressHeap();
        }
        else
#endif // STRESS_HEAP
        {
            // rendezvous with the EE
#ifdef _DEBUG
            BOOL GCOnTransition = FALSE;
            if (g_pConfig->FastGCStressLevel()) {
                GCOnTransition = GC_ON_TRANSITIONS (FALSE);
            }
#endif
            CommonTripThread();
#ifdef _DEBUG
            if (g_pConfig->FastGCStressLevel()) {
                GC_ON_TRANSITIONS (GCOnTransition);
            }
#endif
        }

        // Pop the frame

        helperFrame.Pop();

        // Undo move of dwRetAddr from close to newStackArgs[]

        args->dwRetAddr = args->nOldStackArgs;
        args->nOldStackArgs = oldArgs;
#ifdef _DEBUG
        machState.pRetAddr() = (void **)(size_t)0xDDDDDDDD;
#endif // _DEBUG

        // The thread better not still be hijacked as we will be shuffling
        // the return address around.
        _ASSERTE((pThread->m_State & Thread::TS_Hijacked) == 0);
    }

    /* Now the return-address is unhijacked. More importantly, the EE cannot
       have the address of the return-address. So we can move it around. */

    // Make a copy of the callee saved registers and return address
    // as they may get whacked during sliding of the argument.

    DWORD *  Ebp = (DWORD*)*machState.pEbp();
    DWORD * calleeSavedRegsBase = args->GetCalleeSavedRegs(Ebp);

#define GET_REG(reg, mask)                                              \
    (args->maskCalleeSavedRegs & (mask)) ? *calleeSavedRegsBase++       \
                                         : (DWORD)(size_t)(*machState.p##reg());

    DWORD calleeSavedRegs_ebx   = GET_REG(Ebx, 0x4);
    DWORD calleeSavedRegs_esi   = GET_REG(Esi, 0x2);
    DWORD calleeSavedRegs_edi   = GET_REG(Edi, 0x1);
    DWORD calleeSavedRegs_ebp   = Ebp[0];
    DWORD retAddr               = Ebp[1];

    // Slide the arguments. The old and the new location may be overlapping,
    // so use memmove() instead of memcpy().

    DWORD * argsBase = Ebp + 2 + args->nOldStackArgs - args->nNewStackArgs;
    memmove(argsBase, args->newStackArgs, args->nNewStackArgs*sizeof(void*));

    // Write the original return address just below the arguments

    argsBase[-1] = retAddr;

    // Now reload the argRegs, callee-saved regs, and jump to the target

    DWORD argRegs_ECX   = argRegs.ECX;
    DWORD argRegs_EDX   = argRegs.EDX;
    DWORD * newESP      = &argsBase[-1]; // this will be the esp when we jump to targetAddr

    // We will set esp to newESP_m1 before doing a "ret" to keep the call-ret count balanced
    DWORD * newESP_m1   = newESP - 1;
    *newESP_m1          = args->dwTargetAddr; // this value will be popped by the / "ret"

    __asm {
        mov     ecx, argRegs_ECX            // Reload argRegs
        mov     edx, argRegs_EDX

        mov     ebx, calleeSavedRegs_ebx    // Reload callee-saved registers
        mov     esi, calleeSavedRegs_esi
        mov     edi, calleeSavedRegs_edi

        mov     eax, newESP_m1              // Reload esp and ebp. Note that locals cannot ...
        mov     ebp, calleeSavedRegs_ebp    // ... be safely accessed once these are changed.
        mov     esp, eax

        // The JITed code "call"ed into JIT_TailCall. We use a "ret" here
        // instead of a "jmp" to keep the call-ret count balanced

        ret     // Will branch to targetAddr and esp will be set to "newESP"
    }

    _ASSERTE(!"Error: Cant get here in JIT_TailCallHelper");
}
#pragma warning (default : 4731)


    // emit code that adds MIN_OBJECT_SIZE to reg if reg is unaligned thus making it aligned
void JIT_TrialAlloc::EmitAlignmentRoundup(CPUSTUBLINKER *psl, X86Reg testAlignReg, X86Reg adjReg, Flags flags)
{   
    _ASSERTE((MIN_OBJECT_SIZE & 7) == 4);   // want to change alignment

    CodeLabel *AlreadyAligned = psl->NewCodeLabel();

    // test reg, 7
    psl->Emit16(0xC0F7 | (testAlignReg << 8));
    psl->Emit32(0x7);

    // jz alreadyAligned
    if (flags & ALIGN8OBJ)
    {
        psl->X86EmitCondJump(AlreadyAligned, X86CondCode::kJNZ);
    }
    else
    {
        psl->X86EmitCondJump(AlreadyAligned, X86CondCode::kJZ);
    }

    psl->X86EmitAddReg(adjReg, MIN_OBJECT_SIZE);        
    // AlreadyAligned:
    psl->EmitLabel(AlreadyAligned);
}

    // if 'reg' is unaligned, then set the dummy object at EAX and increment EAX past 
    // the dummy object
void JIT_TrialAlloc::EmitDummyObject(CPUSTUBLINKER *psl, X86Reg alignTestReg, Flags flags)
{
    CodeLabel *AlreadyAligned = psl->NewCodeLabel();

    // test reg, 7
    psl->Emit16(0xC0F7 | (alignTestReg << 8));
    psl->Emit32(0x7);

    // jz alreadyAligned
    if (flags & ALIGN8OBJ)
    {
        psl->X86EmitCondJump(AlreadyAligned, X86CondCode::kJNZ);
    }
    else
    {
        psl->X86EmitCondJump(AlreadyAligned, X86CondCode::kJZ);
    }

    // Make the fake object
    // mov EDX, [g_pObjectClass]
    psl->Emit16(0x158B);
    psl->Emit32((int)(size_t)&g_pObjectClass);

    // mov [EAX], EDX
    psl->X86EmitOffsetModRM(0x89, kEDX, kEAX, 0);

#if CHECK_APP_DOMAIN_LEAKS 
    EmitSetAppDomain(psl);
#endif

    // add EAX, MIN_OBJECT_SIZE
    psl->X86EmitAddReg(kEAX, MIN_OBJECT_SIZE);
    
    // AlreadyAligned:
    psl->EmitLabel(AlreadyAligned);
}

void JIT_TrialAlloc::EmitCore(CPUSTUBLINKER *psl, CodeLabel *noLock, CodeLabel *noAlloc, Flags flags)
{

    if (flags & MP_ALLOCATOR)
    {
        // Upon entry here, ecx contains the method we are to try allocate memory for
        // Upon exit, eax contains the allocated memory, edx is trashed, and ecx undisturbed

#ifdef MAXALLOC
        if (flags & SIZE_IN_EAX)
        {
            // save size for later
            psl->X86EmitPushReg(kEAX);
        }
        else
        {
            // load size from method table
            psl->X86EmitIndexRegLoad(kEAX, kECX, offsetof(MethodTable, m_BaseSize));
        }

        // save regs
        psl->X86EmitPushRegs((1<<kECX));

        // CheckAllocRequest(size);
        psl->X86EmitPushReg(kEAX);
        psl->X86EmitCall(psl->NewExternalCodeLabel(CheckAllocRequest), 0);

        // test eax, eax
        psl->Emit16(0xc085);

        // restore regs
        psl->X86EmitPopRegs((1<<kECX));

        CodeLabel *AllocRequestOK = psl->NewCodeLabel();

        if (flags & SIZE_IN_EAX)
            psl->X86EmitPopReg(kEAX);

        // jnz             AllocRequestOK
        psl->X86EmitCondJump(AllocRequestOK, X86CondCode::kJNZ);

        if (flags & SIZE_IN_EAX)
            psl->Emit16(0xc033);

        // ret
        psl->X86EmitReturn(0);

        // AllocRequestOK:
        psl->EmitLabel(AllocRequestOK);
#endif // MAXALLOC

        if (flags & (ALIGN8 | SIZE_IN_EAX | ALIGN8OBJ)) 
        {
            if (flags & ALIGN8OBJ)
            {
                // mov             eax, [ecx]MethodTable.m_BaseSize
                psl->X86EmitIndexRegLoad(kEAX, kECX, offsetof(MethodTable, m_BaseSize));
            }

            psl->X86EmitPushReg(kEBX);  // we need a spare register
        }
        else
        {
            // mov             eax, [ecx]MethodTable.m_BaseSize
            psl->X86EmitIndexRegLoad(kEAX, kECX, offsetof(MethodTable, m_BaseSize));
        }

        assert( ((flags & ALIGN8)==0     ||  // EAX loaded by else statement
                 (flags & SIZE_IN_EAX)   ||  // EAX already comes filled out
                 (flags & ALIGN8OBJ)     )   // EAX loaded in the if (flags & ALIGN8OBJ) statement
                 && "EAX should contain size for allocation and it doesnt!!!");

        // Fetch current thread into EDX, preserving EAX and ECX
        psl->X86EmitTLSFetch(GetThreadTLSIndex(), kEDX, (1<<kEAX)|(1<<kECX));

        // Try the allocation.


        if (flags & (ALIGN8 | SIZE_IN_EAX | ALIGN8OBJ)) 
        {
            // MOV EBX, [edx]Thread.m_alloc_context.alloc_ptr 
            psl->X86EmitOffsetModRM(0x8B, kEBX, kEDX, offsetof(Thread, m_alloc_context) + offsetof(alloc_context, alloc_ptr));
            // add EAX, EBX
            psl->Emit16(0xC303);
            if (flags & ALIGN8)
                EmitAlignmentRoundup(psl, kEBX, kEAX, flags);      // bump EAX up size by 12 if EBX unaligned (so that we are aligned)
        }
        else 
        {
            // add             eax, [edx]Thread.m_alloc_context.alloc_ptr
            psl->X86EmitOffsetModRM(0x03, kEAX, kEDX, offsetof(Thread, m_alloc_context) + offsetof(alloc_context, alloc_ptr));
        }

        // cmp             eax, [edx]Thread.m_alloc_context.alloc_limit
        psl->X86EmitOffsetModRM(0x3b, kEAX, kEDX, offsetof(Thread, m_alloc_context) + offsetof(alloc_context, alloc_limit));

        // ja              noAlloc
        psl->X86EmitCondJump(noAlloc, X86CondCode::kJA);

        // Fill in the allocation and get out.

        // mov             [edx]Thread.m_alloc_context.alloc_ptr, eax
        psl->X86EmitIndexRegStore(kEDX, offsetof(Thread, m_alloc_context) + offsetof(alloc_context, alloc_ptr), kEAX);

        if (flags & (ALIGN8 | SIZE_IN_EAX | ALIGN8OBJ)) 
        {
            // mov EAX, EBX
            psl->Emit16(0xC38B);
            // pop EBX
            psl->X86EmitPopReg(kEBX);

            if (flags & ALIGN8)
                EmitDummyObject(psl, kEAX, flags);
        }
        else
        {
            // sub             eax, [ecx]MethodTable.m_BaseSize
            psl->X86EmitOffsetModRM(0x2b, kEAX, kECX, offsetof(MethodTable, m_BaseSize));
        }

        // mov             dword ptr [eax], ecx
        psl->X86EmitIndexRegStore(kEAX, 0, kECX);
    }
    else
    {
        // Take the GC lock (there is no lock prefix required - we will use JIT_TrialAllocSFastMP on an MP System).
        // inc             dword ptr [m_GCLock]
        psl->Emit16(0x05ff);
        psl->Emit32((int)(size_t)&m_GCLock);

        // jnz             NoLock
        psl->X86EmitCondJump(noLock, X86CondCode::kJNZ);

        if (flags & SIZE_IN_EAX)
        {
            // mov edx, eax
            psl->Emit16(0xd08b);
        }
        else
        {
            // mov             edx, [ecx]MethodTable.m_BaseSize
            psl->X86EmitIndexRegLoad(kEDX, kECX, offsetof(MethodTable, m_BaseSize));
        }

#ifdef MAXALLOC
        // save regs
        psl->X86EmitPushRegs((1<<kEDX)|(1<<kECX));

        // CheckAllocRequest(size);
        psl->X86EmitPushReg(kEDX);
        psl->X86EmitCall(psl->NewExternalCodeLabel(CheckAllocRequest), 0);

        // test eax, eax
        psl->Emit16(0xc085);

        // restore regs
        psl->X86EmitPopRegs((1<<kEDX)|(1<<kECX));

        CodeLabel *AllocRequestOK = psl->NewCodeLabel();

        // jnz             AllocRequestOK
        psl->X86EmitCondJump(AllocRequestOK, X86CondCode::kJNZ);

        // ret
        psl->X86EmitReturn(0);

        // AllocRequestOK:
        psl->EmitLabel(AllocRequestOK);
#endif // MAXALLOC

        // mov             eax, dword ptr [generation_table]
        psl->Emit8(0xA1);
        psl->Emit32((int)(size_t)&generation_table);

        // Try the allocation.
        // add             edx, eax
        psl->Emit16(0xd003);

        if (flags & (ALIGN8 | ALIGN8OBJ))
            EmitAlignmentRoundup(psl, kEAX, kEDX, flags);      // bump up EDX size by 12 if EAX unaligned (so that we are aligned)

        // cmp             edx, dword ptr [generation_table+4]
        psl->Emit16(0x153b);
        psl->Emit32((int)(size_t)&generation_table + 4);

        // ja              noAlloc
        psl->X86EmitCondJump(noAlloc, X86CondCode::kJA);

        // Fill in the allocation and get out.
        // mov             dword ptr [generation_table], edx
        psl->Emit16(0x1589);
        psl->Emit32((int)(size_t)&generation_table);

        if (flags & (ALIGN8 | ALIGN8OBJ))
            EmitDummyObject(psl, kEAX, flags);

        // mov             dword ptr [eax], ecx
        psl->X86EmitIndexRegStore(kEAX, 0, kECX);

        // mov             dword ptr [m_GCLock], 0FFFFFFFFh
        psl->Emit16(0x05C7);
        psl->Emit32((int)(size_t)&m_GCLock);
        psl->Emit32(0xFFFFFFFF);
    }


#ifdef  INCREMENTAL_MEMCLR
    // We're planning to get rid of this anyhow according to Patrick
    _ASSERTE(!"NYI");
#endif // INCREMENTAL_MEMCLR
}

#if CHECK_APP_DOMAIN_LEAKS
void JIT_TrialAlloc::EmitSetAppDomain(CPUSTUBLINKER *psl)
{
    if (!g_pConfig->AppDomainLeaks())
        return;

    // At both entry & exit, eax contains the allocated object.
    // ecx is preserved, edx is not.

    //
    // Add in a call to SetAppDomain.  (Note that this
    // probably would have been easier to implement by just not using
    // the generated helpers in a checked build, but we'd lose code
    // coverage that way.)
    //

    // Save ECX over function call
    psl->X86EmitPushReg(kECX);

    // Push object as arg
    psl->X86EmitPushReg(kEAX);

    // SetObjectAppDomain pops its arg & returns object in EAX
    psl->X86EmitCall(psl->NewExternalCodeLabel(SetObjectAppDomain), 4);
    
    psl->X86EmitPopReg(kECX);
}

#endif


void JIT_TrialAlloc::EmitNoAllocCode(CPUSTUBLINKER *psl, Flags flags)
{
#ifdef MAXALLOC
    psl->X86EmitPushRegs((1<<kEAX)|(1<<kEDX)|(1<<kECX));
    // call            UndoAllocRequest
    psl->X86EmitCall(psl->NewExternalCodeLabel(UndoAllocRequest), 0);
    psl->X86EmitPopRegs((1<<kEAX)|(1<<kEDX)|(1<<kECX));
#endif // MAXALLOC
    if (flags & MP_ALLOCATOR)
    {
        if (flags & (ALIGN8|SIZE_IN_EAX))
            psl->X86EmitPopReg(kEBX);
    }
    else
    {
        // mov             dword ptr [m_GCLock], 0FFFFFFFFh
        psl->Emit16(0x05c7);
        psl->Emit32((int)(size_t)&m_GCLock);
        psl->Emit32(0xFFFFFFFF);
    }
}

void *JIT_TrialAlloc::GenAllocSFast(Flags flags)
{
    CPUSTUBLINKER sl;

    CodeLabel *noLock  = sl.NewCodeLabel();
    CodeLabel *noAlloc = sl.NewCodeLabel();

    // Emit the main body of the trial allocator, be it SP or MP
    EmitCore(&sl, noLock, noAlloc, flags);

#if CHECK_APP_DOMAIN_LEAKS
    EmitSetAppDomain(&sl);
#endif

    // Here we are at the end of the success case - just emit a ret
    sl.X86EmitReturn(0);

    // Come here in case of no space
    sl.EmitLabel(noAlloc);

    // Release the lock in the uniprocessor case
    EmitNoAllocCode(&sl, flags);

    // Come here in case of failure to get the lock
    sl.EmitLabel(noLock);

    // Jump to the framed helper
    sl.Emit16(0x25ff);
    sl.Emit32((int)(size_t)&hlpFuncTable[CORINFO_HELP_NEWFAST].pfnHelper);

    Stub *pStub = sl.Link(SystemDomain::System()->GetHighFrequencyHeap());

    return (void *)pStub->GetEntryPoint();
}


void *JIT_TrialAlloc::GenBox(Flags flags)
{
    CPUSTUBLINKER sl;

    CodeLabel *noLock  = sl.NewCodeLabel();
    CodeLabel *noAlloc = sl.NewCodeLabel();

    // Save address of value to be boxed
    sl.X86EmitPushReg(kEBX);
    sl.Emit16(0xda8b);

    // Check whether the class has not been initialized
    // test [ecx]MethodTable.m_wFlags,MethodTable::enum_flag_Unrestored
    sl.X86EmitOffsetModRM(0xf7, (X86Reg)0x0, kECX, offsetof(MethodTable, m_wFlags));
    sl.Emit32(MethodTable::enum_flag_Unrestored);

    // jne              noAlloc
    sl.X86EmitCondJump(noAlloc, X86CondCode::kJNE);

    // Emit the main body of the trial allocator
    EmitCore(&sl, noLock, noAlloc, flags);

#if CHECK_APP_DOMAIN_LEAKS
    EmitSetAppDomain(&sl);
#endif

    // Here we are at the end of the success case

    // Check whether the object contains pointers
    // test [ecx]MethodTable.m_wFlags,MethodTable::enum_flag_ContainsPointers
    sl.X86EmitOffsetModRM(0xf7, (X86Reg)0x0, kECX, offsetof(MethodTable, m_wFlags));
    sl.Emit32(MethodTable::enum_flag_ContainsPointers);

    CodeLabel *pointerLabel = sl.NewCodeLabel();

    // jne              pointerLabel
    sl.X86EmitCondJump(pointerLabel, X86CondCode::kJNE);

    // We have no pointers - emit a simple inline copy loop

    // mov             ecx, [ecx]MethodTable.m_BaseSize
    sl.X86EmitOffsetModRM(0x8b, kECX, kECX, offsetof(MethodTable, m_BaseSize));

    // sub ecx,12
    sl.X86EmitSubReg(kECX, 12);

    CodeLabel *loopLabel = sl.NewCodeLabel();

    sl.EmitLabel(loopLabel);

    // mov edx,[ebx+ecx]
    sl.X86EmitOp(0x8b, kEDX, kEBX, 0, kECX, 1);

    // mov [eax+ecx+4],edx
    sl.X86EmitOp(0x89, kEDX, kEAX, 4, kECX, 1);

    // sub ecx,4
    sl.X86EmitSubReg(kECX, 4);

    // jg loopLabel
    sl.X86EmitCondJump(loopLabel, X86CondCode::kJGE);

    sl.X86EmitPopReg(kEBX);

    sl.X86EmitReturn(0);

    // Arrive at this label if there are pointers in the object
    sl.EmitLabel(pointerLabel);

    // Do call to CopyValueClassUnchecked(object, data, pMT)

    // Pass pMT (still in ECX)
    sl.X86EmitPushReg(kECX);

    // Pass data (still in EBX)
    sl.X86EmitPushReg(kEBX);

    // Save the address of the object just allocated
    // mov ebx,eax
    sl.Emit16(0xD88B);

    // Pass address of first user byte in the newly allocated object
    sl.X86EmitAddReg(kEAX, 4);
    sl.X86EmitPushReg(kEAX);

    // call CopyValueClass
    sl.X86EmitCall(sl.NewExternalCodeLabel(CopyValueClassUnchecked), 12);

    // Restore the address of the newly allocated object and return it.
    // mov eax,ebx
    sl.Emit16(0xC38B);

    sl.X86EmitPopReg(kEBX);

    sl.X86EmitReturn(0);

    // Come here in case of no space
    sl.EmitLabel(noAlloc);

    // Release the lock in the uniprocessor case
    EmitNoAllocCode(&sl, flags);

    // Come here in case of failure to get the lock
    sl.EmitLabel(noLock);

    // Restore the address of the value to be boxed
    // mov edx,ebx
    sl.Emit16(0xD38B);

    // pop ebx
    sl.X86EmitPopReg(kEBX);

    // Jump to the slow version of JIT_Box
    sl.X86EmitNearJump(sl.NewExternalCodeLabel(hlpFuncTable[CORINFO_HELP_BOX].pfnHelper));

    Stub *pStub = sl.Link(SystemDomain::System()->GetHighFrequencyHeap());

    return (void *)pStub->GetEntryPoint();
}

Object* __fastcall UnframedAllocateObjectArray(MethodTable *ElementType, DWORD cElements)
{
    return OBJECTREFToObject( AllocateObjectArray(cElements, TypeHandle(ElementType), FALSE) );
}

Object* __fastcall UnframedAllocatePrimitiveArray(CorElementType type, DWORD cElements)
{
    return OBJECTREFToObject( AllocatePrimitiveArray(type, cElements, FALSE) );
}


void *JIT_TrialAlloc::GenAllocArray(Flags flags)
{
    CPUSTUBLINKER sl;

    CodeLabel *noLock  = sl.NewCodeLabel();
    CodeLabel *noAlloc = sl.NewCodeLabel();

    // We were passed a type descriptor in ECX, which contains the (shared)
    // array method table and the element type.

    // If this is the allocator for use from unmanaged code, ECX contains the
    // element type descriptor, or the CorElementType.

    // We need to save ECX for later

    // push ecx
    sl.X86EmitPushReg(kECX);

    // The element count is in EDX - we need to save it for later.

    // push edx
    sl.X86EmitPushReg(kEDX);

    if (flags & NO_FRAME)
    {
        if (flags & OBJ_ARRAY)
        {
            // mov ecx, [g_pPredefinedArrayTypes[ELEMENT_TYPE_OBJECT]]
            sl.Emit16(0x0d8b);
            sl.Emit32((int)(size_t)&g_pPredefinedArrayTypes[ELEMENT_TYPE_OBJECT]);
        }
        else
        {
            // mov ecx,[g_pPredefinedArrayTypes+ecx*4]
            sl.Emit8(0x8b);
            sl.Emit16(0x8d0c);
            sl.Emit32((int)(size_t)&g_pPredefinedArrayTypes);

            // test ecx,ecx
            sl.Emit16(0xc985);

            // je noLock
            sl.X86EmitCondJump(noLock, X86CondCode::kJZ);
        }

        // we need to load the true method table from the type desc
        sl.X86EmitIndexRegLoad(kECX, kECX, offsetof(ArrayTypeDesc,m_TemplateMT));
    }
    else
    {
        // we need to load the true method table from the type desc
        sl.X86EmitIndexRegLoad(kECX, kECX, offsetof(ArrayTypeDesc,m_TemplateMT)-2);
    }

    // Instead of doing elaborate overflow checks, we just limit the number of elements
    // to (LARGE_OBJECT_SIZE - 256)/LARGE_ELEMENT_SIZE or less. As the jit will not call
    // this fast helper for element sizes bigger than LARGE_ELEMENT_SIZE, this will
    // avoid avoid all overflow problems, as well as making sure big array objects are
    // correctly allocated in the big object heap.

    // cmp edx,(LARGE_OBJECT_SIZE - 256)/LARGE_ELEMENT_SIZE
    sl.Emit16(0xfa81);


		// The large object heap is 8 byte aligned, so for double arrays we 
		// want to bias toward putting things in the large object heap  
	unsigned maxElems =  (LARGE_OBJECT_SIZE - 256)/LARGE_ELEMENT_SIZE;

	if ((flags & ALIGN8) && g_pConfig->GetDoubleArrayToLargeObjectHeap() < maxElems)
		maxElems = g_pConfig->GetDoubleArrayToLargeObjectHeap();
	sl.Emit32(maxElems);


    // jae noLock - seems tempting to jump to noAlloc, but we haven't taken the lock yet
    sl.X86EmitCondJump(noLock, X86CondCode::kJAE);

    if (flags & OBJ_ARRAY)
    {
        // In this case we know the element size is sizeof(void *), or 4 for x86
        // This helps us in two ways - we can shift instead of multiplying, and
        // there's no need to align the size either

        _ASSERTE(sizeof(void *) == 4);

        // mov eax, [ecx]MethodTable.m_BaseSize
        sl.X86EmitIndexRegLoad(kEAX, kECX, offsetof(MethodTable, m_BaseSize));

        // lea eax, [eax+edx*4]
        sl.X86EmitOp(0x8d, kEAX, kEAX, 0, kEDX, 4);
    }
    else
    {
        // movzx eax, [ECX]MethodTable.m_ComponentSize
        sl.Emit8(0x0f);
        sl.X86EmitOffsetModRM(0xb7, kEAX, kECX, offsetof(MethodTable, m_ComponentSize));

        // mul eax, edx
        sl.Emit16(0xe2f7);

        // add eax, [ecx]MethodTable.m_BaseSize
        sl.X86EmitOffsetModRM(0x03, kEAX, kECX, offsetof(MethodTable, m_BaseSize));
    }

    if (flags & OBJ_ARRAY)
    {
        // No need for rounding in this case - element size is 4, and m_BaseSize is guaranteed
        // to be a multiple of 4.
    }
    else
    {
        // round the size to a multiple of 4

        // add eax, 3
        sl.X86EmitAddReg(kEAX, 3);

        // and eax, ~3
        sl.Emit16(0xe083);
        sl.Emit8(0xfc);
    }

    flags = (Flags)(flags | SIZE_IN_EAX);

    // Emit the main body of the trial allocator, be it SP or MP
    EmitCore(&sl, noLock, noAlloc, flags);

    // Here we are at the end of the success case - store element count
    // and possibly the element type descriptor and return

    // pop edx - element count
    sl.X86EmitPopReg(kEDX);

    // pop ecx - array type descriptor
    sl.X86EmitPopReg(kECX);

    // mov             dword ptr [eax]ArrayBase.m_NumComponents, edx
    sl.X86EmitIndexRegStore(kEAX, offsetof(ArrayBase,m_NumComponents), kEDX);

    if (flags & OBJ_ARRAY)
    {
        // need to store the element type descriptor

        if ((flags & NO_FRAME) == 0)
        {
            // mov ecx, [ecx]ArrayTypeDescriptor.m_Arg
            sl.X86EmitIndexRegLoad(kECX, kECX, offsetof(ArrayTypeDesc,m_Arg)-2);
        }

        // mov [eax]PtrArray.m_ElementType, ecx
        sl.X86EmitIndexRegStore(kEAX, offsetof(PtrArray,m_ElementType), kECX);
    }

#if CHECK_APP_DOMAIN_LEAKS
    EmitSetAppDomain(&sl);
#endif

    // no stack parameters
    sl.X86EmitReturn(0);

    // Come here in case of no space
    sl.EmitLabel(noAlloc);

    // Release the lock in the uniprocessor case
    EmitNoAllocCode(&sl, flags);

    // Come here in case of failure to get the lock
    sl.EmitLabel(noLock);

    // pop edx - element count
    sl.X86EmitPopReg(kEDX);

    // pop ecx - array type descriptor
    sl.X86EmitPopReg(kECX);

    if (flags & NO_FRAME)
    {
        if (flags & OBJ_ARRAY)
        {
            // Jump to the unframed helper
            sl.X86EmitNearJump(sl.NewExternalCodeLabel(UnframedAllocateObjectArray));
        }
        else
        {
            // Jump to the unframed helper
            sl.X86EmitNearJump(sl.NewExternalCodeLabel(UnframedAllocatePrimitiveArray));
        }
    }
    else
    {
        // Jump to the framed helper
        sl.Emit16(0x25ff);
        sl.Emit32((int)(size_t)&hlpFuncTable[CORINFO_HELP_NEWARR_1_DIRECT].pfnHelper);
    }

    Stub *pStub = sl.Link(SystemDomain::System()->GetHighFrequencyHeap());

    return (void *)pStub->GetEntryPoint();
}


static StringObject* __fastcall UnframedAllocateString(DWORD stringLength)
{
    STRINGREF result;
    result = SlowAllocateString(stringLength+1);
    result->SetStringLength(stringLength);
    return((StringObject*) OBJECTREFToObject(result));
}


HCIMPL1(static StringObject*, FramedAllocateString, DWORD stringLength)
    StringObject* result;
    HELPER_METHOD_FRAME_BEGIN_RET_0();    // Set up a frame
    result = UnframedAllocateString(stringLength);
    HELPER_METHOD_FRAME_END();
    return result;
HCIMPLEND


void *JIT_TrialAlloc::GenAllocString(Flags flags)
{
    CPUSTUBLINKER sl;

    CodeLabel *noLock  = sl.NewCodeLabel();
    CodeLabel *noAlloc = sl.NewCodeLabel();

    // We were passed the number of characters in ECX

    // push ecx
    sl.X86EmitPushReg(kECX);

    // mov eax, ecx
    sl.Emit16(0xc18b);

    // we need to load the method table for string from the global

    // mov ecx, [g_pStringMethodTable]
    sl.Emit16(0x0d8b);
    sl.Emit32((int)(size_t)&g_pStringClass);

    // Instead of doing elaborate overflow checks, we just limit the number of elements
    // to (LARGE_OBJECT_SIZE - 256)/sizeof(WCHAR) or less.
    // This will avoid avoid all overflow problems, as well as making sure
    // big string objects are correctly allocated in the big object heap.

    _ASSERTE(sizeof(WCHAR) == 2);

    // cmp edx,(LARGE_OBJECT_SIZE - 256)/sizeof(WCHAR)
    sl.Emit16(0xf881);
    sl.Emit32((LARGE_OBJECT_SIZE - 256)/sizeof(WCHAR));

    // jae noLock - seems tempting to jump to noAlloc, but we haven't taken the lock yet
    sl.X86EmitCondJump(noLock, X86CondCode::kJAE);

    // mov edx, [ecx]MethodTable.m_BaseSize
    sl.X86EmitIndexRegLoad(kEDX, kECX, offsetof(MethodTable,m_BaseSize));

    // Calculate the final size to allocate.
    // We need to calculate baseSize + cnt*2, then round that up by adding 3 and anding ~3.

    // lea eax, [edx+eax*2+5]
    sl.X86EmitOp(0x8d, kEAX, kEDX, 5, kEAX, 2);

    // and eax, ~3
    sl.Emit16(0xe083);
    sl.Emit8(0xfc);

    flags = (Flags)(flags | SIZE_IN_EAX);

    // Emit the main body of the trial allocator, be it SP or MP
    EmitCore(&sl, noLock, noAlloc, flags);

    // Here we are at the end of the success case - store element count
    // and possibly the element type descriptor and return

#if CHECK_APP_DOMAIN_LEAKS
    EmitSetAppDomain(&sl);
#endif

    // pop ecx - element count
    sl.X86EmitPopReg(kECX);

    // mov             dword ptr [eax]ArrayBase.m_StringLength, ecx
    sl.X86EmitIndexRegStore(kEAX, offsetof(StringObject,m_StringLength), kECX);

    // inc ecx
    sl.Emit8(0x41);

    // mov             dword ptr [eax]ArrayBase.m_ArrayLength, ecx
    sl.X86EmitIndexRegStore(kEAX, offsetof(StringObject,m_ArrayLength), kECX);

    // no stack parameters
    sl.X86EmitReturn(0);

    // Come here in case of no space
    sl.EmitLabel(noAlloc);

    // Release the lock in the uniprocessor case
    EmitNoAllocCode(&sl, flags);

    // Come here in case of failure to get the lock
    sl.EmitLabel(noLock);

    // pop ecx - element count
    sl.X86EmitPopReg(kECX);

    if (flags & NO_FRAME)
    {
        // Jump to the unframed helper
        sl.X86EmitNearJump(sl.NewExternalCodeLabel(UnframedAllocateString));
    }
    else
    {
        // Jump to the framed helper
        sl.X86EmitNearJump(sl.NewExternalCodeLabel(FramedAllocateString));
    }

    Stub *pStub = sl.Link(SystemDomain::System()->GetHighFrequencyHeap());

    return (void *)pStub->GetEntryPoint();
}


FastStringAllocatorFuncPtr fastStringAllocator;

FastObjectArrayAllocatorFuncPtr fastObjectArrayAllocator;

FastPrimitiveArrayAllocatorFuncPtr fastPrimitiveArrayAllocator;


// Note that this helper cannot be used directly since it doesn't preserve EDX

HCIMPL1(static void*, JIT_GetSharedStaticBase, DWORD dwClassDomainID)

    THROWSCOMPLUSEXCEPTION();

    DomainLocalClass *pLocalClass;

    HELPER_METHOD_FRAME_BEGIN_RET_0();    // Set up a frame

    AppDomain *pDomain = SystemDomain::GetCurrentDomain();
    DomainLocalBlock *pBlock = pDomain->GetDomainLocalBlock();
    if (dwClassDomainID >= pBlock->GetClassCount()) {
        pBlock->EnsureIndex(SharedDomain::GetDomain()->GetMaxSharedClassIndex());
        _ASSERTE (dwClassDomainID < pBlock->GetClassCount());
    }
    
    MethodTable *pMT = SharedDomain::GetDomain()->FindIndexClass(dwClassDomainID);
    _ASSERTE(pMT != NULL);

    OBJECTREF throwable = NULL;    
    GCPROTECT_BEGIN(throwable);
    if (!pMT->CheckRunClassInit(&throwable, &pLocalClass))
      COMPlusThrow(throwable);
    GCPROTECT_END();
    HELPER_METHOD_FRAME_END();

    return pLocalClass;

HCIMPLEND

// For this helper, ECX contains the class domain ID, and the 
// shared static base is returned in EAX.  EDX is preserved.

// "init" should be the address of a routine which takes an argument of
// the class domain ID, and returns the static base pointer

static void EmitFastGetSharedStaticBase(CPUSTUBLINKER *psl, CodeLabel *init)
{
    CodeLabel *DoInit = psl->NewCodeLabel();

    // mov eax GetAppDomain()
    psl->X86EmitTLSFetch(GetAppDomainTLSIndex(), kEAX, (1<<kECX)|(1<<kEDX));

    // cmp ecx [eax->m_sDomainLocalBlock.m_cSlots]
    psl->X86EmitOffsetModRM(0x3b, kECX, kEAX, AppDomain::GetOffsetOfSlotsCount());
    
    // jb init
    psl->X86EmitCondJump(DoInit, X86CondCode::kJNB);

    // mov eax [eax->m_sDomainLocalBlock.m_pSlots]
    psl->X86EmitIndexRegLoad(kEAX, kEAX, (__int32) AppDomain::GetOffsetOfSlotsPointer());

    // mov eax [eax + ecx*4]
    psl->X86EmitOp(0x8b, kEAX, kEAX, 0, kECX, 4);

    // btr eax, INTIALIZED_FLAG_BIT
    static BYTE code[] = {0x0f, 0xba, 0xf0, DomainLocalBlock::INITIALIZED_FLAG_BIT};
    psl->EmitBytes(code, sizeof(code));

    // jnc init
    psl->X86EmitCondJump(DoInit, X86CondCode::kJNC);

    // ret
    psl->X86EmitReturn(0);

    // DoInit: 
    psl->EmitLabel(DoInit);

    // push edx (must be preserved)
    psl->X86EmitPushReg(kEDX);

    // call init
    psl->X86EmitCall(init, 0);

    // pop edx  
    psl->X86EmitPopReg(kEDX);

    // ret
    psl->X86EmitReturn(0);
}

void *GenFastGetSharedStaticBase()
{
    CPUSTUBLINKER sl;

    CodeLabel *init = sl.NewExternalCodeLabel(JIT_GetSharedStaticBase);
    
    EmitFastGetSharedStaticBase(&sl, init);

    Stub *pStub = sl.Link(SystemDomain::System()->GetHighFrequencyHeap());

    return (void*) pStub->GetEntryPoint();
}

/*********************************************************************/
// Initialize the part of the JIT helpers that require very little of
// EE infrastructure to be in place.
/*********************************************************************/
BOOL InitJITHelpers1()
{
    BYTE *          pfunc;

    // Init GetThread function
    _ASSERTE(GetThread != NULL);
    hlpFuncTable[CORINFO_HELP_GET_THREAD].pfnHelper = (void *) GetThread;

    // make certain object layout in corjit.h is consistant with
    // what is in object.h
    _ASSERTE(offsetof(Object, m_pMethTab) == offsetof(CORINFO_Object, methTable));
        // TODO: do array count
    _ASSERTE(offsetof(I1Array, m_Array) == offsetof(CORINFO_Array, i1Elems));
    _ASSERTE(offsetof(PTRArray, m_Array) == offsetof(CORINFO_RefArray, refElems));

    // Handle the case that we are on an MP machine.
    if (g_SystemInfo.dwNumberOfProcessors != 1)
    {
        // If we are on a multiproc machine stomp some nop's with lock prefix's

        // Issue : currently BBT doesn't move these around.  The prevailing belief is
        // that this will not bite us.  If we crap out in BBT builds then this should
        // be a priority place to look!
        DWORD   oldProt;

        // I am using wirtual protect to cover the entire range that this code falls in.
        // we may want to do a pragma section so the BBT doesn't put this code all over the place
        // or I can virtual protect around each instruction which will be slower but potentially
        // more accurate in the BBT case.

        if (!VirtualProtect((void *) JIT_MonEnter,
                            (((DWORD)(size_t)JIT_MonExitStatic + 0x22) - (DWORD)(size_t)JIT_MonEnter),
                            PAGE_EXECUTE_READWRITE, &oldProt))
        {
            _ASSERTE(!"VirtualProtect of code page failed");
            return FALSE;
        }
        // there are 4 methods we need to stomp
#define PATCH_LOCK(_rtn, _off) \
        pfunc = (BYTE*)(_rtn) + (_off); \
        _ASSERTE(*pfunc == 0x90); \
        *pfunc = 0xF0;

// ***** NOTE: you must ensure that both the checked and free versions work if you
// make any changes here. Do this by undefining MON_DEBUG.

#ifdef MON_DEBUG
        PATCH_LOCK(JIT_MonEnter, 0x51);
        PATCH_LOCK(JIT_MonEnter, 0x8b);
        PATCH_LOCK(JIT_MonEnter, 0xe0);
        PATCH_LOCK(JIT_MonTryEnter, 0x55);
        PATCH_LOCK(JIT_MonTryEnter, 0x92);
        PATCH_LOCK(JIT_MonTryEnter, 0xc5);
#else // ! MON_DEBUG
        PATCH_LOCK(JIT_MonEnter, 0x32); 
        PATCH_LOCK(JIT_MonEnter, 0x6c); 
        PATCH_LOCK(JIT_MonEnter, 0xc1); 
        PATCH_LOCK(JIT_MonTryEnter, 0x36);
        PATCH_LOCK(JIT_MonTryEnter, 0x73);
        PATCH_LOCK(JIT_MonTryEnter, 0xa6);
#endif // MON_DEBUG
        PATCH_LOCK(JIT_MonExit, 0x31);
        PATCH_LOCK(JIT_MonExit, 0x43);
        PATCH_LOCK(JIT_MonExit, 0x8c);
        PATCH_LOCK(JIT_MonEnterStatic, 0x0c);
        PATCH_LOCK(JIT_MonExitStatic, 0x21);

        if (!VirtualProtect((void *) JIT_MonEnter,
                            (((DWORD)(size_t)JIT_MonExitStatic + 0x22) - (DWORD)(size_t)JIT_MonEnter), oldProt, &oldProt))
        {
            _ASSERTE(!"VirtualProtect of code page failed");
            return FALSE;
        }
    }

    _ASSERTE(hlpFuncTable[CORINFO_HELP_NEWSFAST].pfnHelper == (void *)JIT_TrialAllocSFastSP);
    _ASSERTE(hlpFuncTable[CORINFO_HELP_NEWSFAST_ALIGN8].pfnHelper == (void *)JIT_TrialAllocSFastSP);

    JIT_TrialAlloc::Flags flags = JIT_TrialAlloc::NORMAL;
    
    if (g_SystemInfo.dwNumberOfProcessors != 1)
        flags = JIT_TrialAlloc::MP_ALLOCATOR;

#ifdef MULTIPLE_HEAPS
        //stomp the allocator even for one processor
        flags = JIT_TrialAlloc::MP_ALLOCATOR;
#endif //MULTIPLE_HEAPS

    COMPLUS_TRY 
    {
        // Get CPU features and check for SSE2 support.
        // This code should eventually probably be moved into codeman.cpp,
        // where we set the cpu feature flags for the JIT based on CPU type and features.
        DWORD dwCPUFeatures;

        __asm
        {
            pushad
            mov eax, 1
            cpuid
            mov dwCPUFeatures, edx
            popad
        }

        //  If bit 26 (SSE2) is set, then we can use the SSE2 flavors
        //  and faster x87 implementation for the P4 of Dbl2Lng.
        if (dwCPUFeatures & (1<<26))
        {
            hlpFuncTable[CORINFO_HELP_DBL2INT].pfnHelper = JIT_Dbl2IntSSE2;
            hlpFuncTable[CORINFO_HELP_DBL2UINT].pfnHelper = JIT_Dbl2LngP4x87;   // SSE2 only for signed
            hlpFuncTable[CORINFO_HELP_DBL2LNG].pfnHelper = JIT_Dbl2LngP4x87;
        }
        
        if (!((CORProfilerTrackAllocationsEnabled()) || (LoggingOn(LF_GCALLOC, LL_INFO10))))
        {
            // Replace the slow helpers with faster version
            hlpFuncTable[CORINFO_HELP_NEWSFAST].pfnHelper = JIT_TrialAlloc::GenAllocSFast(flags);
            hlpFuncTable[CORINFO_HELP_NEWSFAST_ALIGN8].pfnHelper = JIT_TrialAlloc::GenAllocSFast((JIT_TrialAlloc::Flags)(flags|JIT_TrialAlloc::ALIGN8 | JIT_TrialAlloc::ALIGN8OBJ));       
            hlpFuncTable[CORINFO_HELP_BOX].pfnHelper = JIT_TrialAlloc::GenBox(flags);
            hlpFuncTable[CORINFO_HELP_NEWARR_1_OBJ].pfnHelper = JIT_TrialAlloc::GenAllocArray((JIT_TrialAlloc::Flags)(flags|JIT_TrialAlloc::OBJ_ARRAY));
            hlpFuncTable[CORINFO_HELP_NEWARR_1_VC].pfnHelper = JIT_TrialAlloc::GenAllocArray(flags);

            fastObjectArrayAllocator = (FastObjectArrayAllocatorFuncPtr)JIT_TrialAlloc::GenAllocArray((JIT_TrialAlloc::Flags)(flags|JIT_TrialAlloc::NO_FRAME|JIT_TrialAlloc::OBJ_ARRAY));
            fastPrimitiveArrayAllocator = (FastPrimitiveArrayAllocatorFuncPtr)JIT_TrialAlloc::GenAllocArray((JIT_TrialAlloc::Flags)(flags|JIT_TrialAlloc::NO_FRAME));

            // If allocation logging is on, then we divert calls to FastAllocateString to an Ecall method, not this
            // generated method. Find this hack in Ecall::Init() in ecall.cpp. 
            (*FCallFastAllocateStringImpl) = (FastStringAllocatorFuncPtr) JIT_TrialAlloc::GenAllocString(flags);

            // generate another allocator for use from unmanaged code (won't need a frame)
            fastStringAllocator = (FastStringAllocatorFuncPtr) JIT_TrialAlloc::GenAllocString((JIT_TrialAlloc::Flags)(flags|JIT_TrialAlloc::NO_FRAME));
                                                               //UnframedAllocateString;
            hlpFuncTable[CORINFO_HELP_GETSHAREDSTATICBASE].pfnHelper = GenFastGetSharedStaticBase();
        }
        else
        {
            // Replace the slow helpers with faster version
            hlpFuncTable[CORINFO_HELP_NEWSFAST].pfnHelper = hlpFuncTable[CORINFO_HELP_NEWFAST].pfnHelper;
            hlpFuncTable[CORINFO_HELP_NEWSFAST_ALIGN8].pfnHelper = hlpFuncTable[CORINFO_HELP_NEWFAST].pfnHelper;
            hlpFuncTable[CORINFO_HELP_NEWARR_1_OBJ].pfnHelper = hlpFuncTable[CORINFO_HELP_NEWARR_1_DIRECT].pfnHelper;
            hlpFuncTable[CORINFO_HELP_NEWARR_1_VC].pfnHelper = hlpFuncTable[CORINFO_HELP_NEWARR_1_DIRECT].pfnHelper;
            // hlpFuncTable[CORINFO_HELP_NEW_CROSSCONTEXT].pfnHelper = &JIT_NewCrossContextProfiler;

            fastObjectArrayAllocator = UnframedAllocateObjectArray;
            fastPrimitiveArrayAllocator = UnframedAllocatePrimitiveArray;

            // If allocation logging is on, then we divert calls to FastAllocateString to an Ecall method, not this
            // generated method. Find this hack in Ecall::Init() in ecall.cpp. 
            (*FCallFastAllocateStringImpl) = (FastStringAllocatorFuncPtr)FramedAllocateString;

            // This allocator is used from unmanaged code
            fastStringAllocator = UnframedAllocateString;

            hlpFuncTable[CORINFO_HELP_GETSHAREDSTATICBASE].pfnHelper = JIT_GetSharedStaticBase;
        }
    }
    COMPLUS_CATCH 
    {
        return FALSE;
    }
    COMPLUS_END_CATCH

    // Copy the write barriers to their final resting place.
    // Note: I use a pfunc temporary here to avoid a WinCE internal compiler error
    for (int reg = 0; reg < 8; reg++)
    {
        pfunc = (BYTE *) JIT_UP_WriteBarrierReg_PreGrow;
        memcpy(&JIT_UP_WriteBarrierReg_Buf[reg], pfunc, 31);

        // assert the copied code ends in a ret to make sure we got the right length
        _ASSERTE(JIT_UP_WriteBarrierReg_Buf[reg][30] == 0xC3);

        // We need to adjust registers in a couple of instructions
        // It would be nice to have the template contain all zeroes for
        // the register fields (corresponding to EAX), but that doesn't
        // work because then we get a smaller encoding for the compares 
        // that only works for EAX but not the other registers.
        // So we always have to clear the register fields before updating them.

        // First instruction to patch is a mov [edx], reg

        _ASSERTE(JIT_UP_WriteBarrierReg_Buf[reg][0] == 0x89);
        // Update the reg field (bits 3..5) of the ModR/M byte of this instruction
        JIT_UP_WriteBarrierReg_Buf[reg][1] &= 0xc7;
        JIT_UP_WriteBarrierReg_Buf[reg][1] |= reg << 3;

        // Second instruction to patch is cmp reg, imm32 (low bound)

        _ASSERTE(JIT_UP_WriteBarrierReg_Buf[reg][2] == 0x81);
        // Here the lowest three bits in ModR/M field are the register
        JIT_UP_WriteBarrierReg_Buf[reg][3] &= 0xf8;
        JIT_UP_WriteBarrierReg_Buf[reg][3] |= reg;

#ifdef WRITE_BARRIER_CHECK
        // Don't do the fancy optimization just jump to the old one
        // Use the slow one from time to time in a debug build because
        // there are some good asserts in the unoptimized one
        if (g_pConfig->GetHeapVerifyLevel() > 1 || DbgGetEXETimeStamp() % 7 == 4) {

            static void *JIT_UP_WriteBarrierTab[8] = {
                JIT_UP_WriteBarrierEAX,
                JIT_UP_WriteBarrierECX,
                0, // JIT_UP_WriteBarrierEDX,
                JIT_UP_WriteBarrierEBX,
                0, // JIT_UP_WriteBarrierESP,
                JIT_UP_WriteBarrierEBP,
                JIT_UP_WriteBarrierESI,
                JIT_UP_WriteBarrierEDI,
            };
            pfunc = &JIT_UP_WriteBarrierReg_Buf[reg][0];
            *pfunc++ = 0xE9;                // JMP JIT_UP_WriteBarrierTab[reg]
            *((DWORD*) pfunc) = (BYTE*) JIT_UP_WriteBarrierTab[reg] - (pfunc + sizeof(DWORD));
        }
#endif
    }
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\ia64\eecallconv.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==

//===================================================================
// EECALLCONV.H
//
//  This file can be included multiple times and is useful when you
//  need to write code that depends on details of the calling convention.
//
//  To learn how many registers are reserved for arguments, use the macro
//  NUM_ARGUMENT_REGISTERS
//
//  To enumerate the registers from the first (param #1 or "this") to last,
//
//      #define DEFINE_ARGUMENT_REGISTER(regname)  <expression using regname>
//      #include "eecallconv.h"
//
//  To enumerate the registers in reverse order
//
//      #define DEFINE_ARGUMENT_REGISTER_BACKWARD(regname)  <expression using regname>
//      #include "eecallconv.h"
//
//
//===================================================================


#ifndef NUM_ARGUMENT_REGISTERS
#define NUM_ARGUMENT_REGISTERS 2
#endif // !NUM_ARGUMENT_REGISTERS


//--------------------------------------------------------------------
// This defines one register guaranteed not to hold an argument.
//--------------------------------------------------------------------
#ifndef SCRATCH_REGISTER
#define SCRATCH_REGISTER EAX
#endif // !SCRATCH_REGISTER

#ifndef SCRATCH_REGISTER_X86REG
#define SCRATCH_REGISTER_X86REG kEAX
#endif // !SCRATCH_REGISTER_X86REG


#ifndef DEFINE_ARGUMENT_REGISTER
#ifndef DEFINE_ARGUMENT_REGISTER_BACKWARD
#ifndef DEFINE_ARGUMENT_REGISTER_BACKWARD_WITH_OFFSET
#ifndef DEFINE_ARGUMENT_REGISTER_NOTHING    // used to pick up NUM_ARGUMENT_REGISTERS above
#error  "You didn't pick any choices. Check your spelling."
#endif // !DEFINE_ARGUMENT_REGISTER_NOTHING
#endif // !DEFINE_ARGUMENT_REGISTER_BACKWARD_WITH_OFFSET
#endif // !DEFINE_ARGUMENT_REGISTER_BACKWARD
#endif // !DEFINE_ARGUMENT_REGISTER


//-----------------------------------------------------------------------
// Location of "this" argument.
//-----------------------------------------------------------------------
#ifndef THIS_REG
#define THIS_REG        ECX
#endif // !THIS_REG

#ifndef THIS_kREG
#define THIS_kREG       kECX
#endif // !THIS_kREG


#define ARGUMENT_REG1   ECX
#define ARGUMENT_REG2   EDX

//-----------------------------------------------------------------------
// List of registers in forward order. MUST KEEP ALL LISTS IN SYNC.
//-----------------------------------------------------------------------

#ifndef DEFINE_ARGUMENT_REGISTER
#define DEFINE_ARGUMENT_REGISTER(regname)
#endif // !DEFINE_ARGUMENT_REGISTER

DEFINE_ARGUMENT_REGISTER(  ECX  )
DEFINE_ARGUMENT_REGISTER(  EDX  )

#undef DEFINE_ARGUMENT_REGISTER



//-----------------------------------------------------------------------
// List of registers in backward order. MUST KEEP ALL LISTS IN SYNC.
//-----------------------------------------------------------------------

#ifndef DEFINE_ARGUMENT_REGISTER_BACKWARD
#define DEFINE_ARGUMENT_REGISTER_BACKWARD(regname)
#endif // !DEFINE_ARGUMENT_REGISTER_BACKWARD


DEFINE_ARGUMENT_REGISTER_BACKWARD(EDX)
DEFINE_ARGUMENT_REGISTER_BACKWARD(ECX)


#undef DEFINE_ARGUMENT_REGISTER_BACKWARD



//-----------------------------------------------------------------------
// List of registers in backward order with offsets. MUST KEEP ALL LISTS IN SYNC.
//-----------------------------------------------------------------------

#ifndef DEFINE_ARGUMENT_REGISTER_BACKWARD_WITH_OFFSET
#define DEFINE_ARGUMENT_REGISTER_BACKWARD_WITH_OFFSET(regname,ofs)
#endif // !DEFINE_ARGUMENT_REGISTER_BACKWARD_WITH_OFFSET


DEFINE_ARGUMENT_REGISTER_BACKWARD_WITH_OFFSET(EDX,0)
DEFINE_ARGUMENT_REGISTER_BACKWARD_WITH_OFFSET(ECX,4)


#undef DEFINE_ARGUMENT_REGISTER_BACKWARD_WITH_OFFSET
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\i386\makefile.inc ===
!IF "$(FREEBUILD)"!="1" 
..\excep.cpp $(O)\excep.obj :
	$(C_COMPILER) -Fo$(O)\excep.tmp ..\excep.cpp
	sxgen /in:$(O)\excep.tmp /out:$(O)\excep.obj \
	?COMPlusCooperativeTransitionHandler@@YA?AW4_EXCEPTION_DISPOSITION@@PAU_EXCEPTION_RECORD@@PAU_EXCEPTION_REGISTRATION_RECORD@@PAU_CONTEXT@@PAX@Z \
	?COMPlusNestedExceptionHandler@@YA?AW4_EXCEPTION_DISPOSITION@@PAU_EXCEPTION_RECORD@@PAU_EXCEPTION_REGISTRATION_RECORD@@PAU_CONTEXT@@PAX@Z \
	?COMPlusCannotThrowExceptionHandler@@YA?AW4_EXCEPTION_DISPOSITION@@PAU_EXCEPTION_RECORD@@PAU_EXCEPTION_REGISTRATION_RECORD@@PAU_CONTEXT@@PAX@Z \
	?COMPlusCannotThrowExceptionMarker@@YA?AW4_EXCEPTION_DISPOSITION@@PAU_EXCEPTION_RECORD@@PAU_EXCEPTION_REGISTRATION_RECORD@@PAU_CONTEXT@@PAX@Z  
	-del $(O)\excep.tmp
!ELSE
..\excep.cpp $(O)\excep.obj :
	$(C_COMPILER) -Fo$(O)\excep.tmp ..\excep.cpp
	sxgen /in:$(O)\excep.tmp /out:$(O)\excep.obj \
	?COMPlusCooperativeTransitionHandler@@YA?AW4_EXCEPTION_DISPOSITION@@PAU_EXCEPTION_RECORD@@PAU_EXCEPTION_REGISTRATION_RECORD@@PAU_CONTEXT@@PAX@Z \
	?COMPlusNestedExceptionHandler@@YA?AW4_EXCEPTION_DISPOSITION@@PAU_EXCEPTION_RECORD@@PAU_EXCEPTION_REGISTRATION_RECORD@@PAU_CONTEXT@@PAX@Z
	-del $(O)\excep.tmp
!ENDIF	

..\nexport.cpp $(O)\nexport.obj :
	$(C_COMPILER) -Fo$(O)\nexport.tmp ..\nexport.cpp
	sxgen /in:$(O)\nexport.tmp /out:$(O)\nexport.obj \
	?FastNExportExceptHandler@@YA?AW4_EXCEPTION_DISPOSITION@@PAU_EXCEPTION_RECORD@@PAU_EXCEPTION_REGISTRATION_RECORD@@PAU_CONTEXT@@PAX@Z \
	?NExportExceptHandler@@YA?AW4_EXCEPTION_DISPOSITION@@PAU_EXCEPTION_RECORD@@PAU_EXCEPTION_REGISTRATION_RECORD@@PAU_CONTEXT@@PAX@Z \
	?UMThunkPrestubHandler@@YA?AW4_EXCEPTION_DISPOSITION@@PAU_EXCEPTION_RECORD@@PAU_EXCEPTION_REGISTRATION_RECORD@@PAU_CONTEXT@@PAX@Z
	-del $(O)\nexport.tmp


..\$(TARGET_DIRECTORY)\ExcepX86.cpp $(O)\ExcepX86.obj :
	$(C_COMPILER) -Fo$(O)\ExcepX86.tmp ..\$(TARGET_DIRECTORY)\ExcepX86.cpp
	sxgen /in:$(O)\ExcepX86.tmp /out:$(O)\ExcepX86.obj \
	?CPFH_RealFirstPassHandler@@YA?AW4_EXCEPTION_DISPOSITION@@PAU_EXCEPTION_RECORD@@PAU_EXCEPTION_REGISTRATION_RECORD@@PAU_CONTEXT@@PAXH@Z \
	?CPFH_FirstPassHandler@@YA?AW4_EXCEPTION_DISPOSITION@@PAU_EXCEPTION_RECORD@@PAU_EXCEPTION_REGISTRATION_RECORD@@PAU_CONTEXT@@PAX@Z \
	?CPFH_UnwindHandler@@YA?AW4_EXCEPTION_DISPOSITION@@PAU_EXCEPTION_RECORD@@PAU_EXCEPTION_REGISTRATION_RECORD@@PAU_CONTEXT@@PAX@Z \
	?COMPlusFrameHandler@@YA?AW4_EXCEPTION_DISPOSITION@@PAU_EXCEPTION_RECORD@@PAU_EXCEPTION_REGISTRATION_RECORD@@PAU_CONTEXT@@PAX@Z \
	?ComToManagedExceptHandler@@YA?AW4_EXCEPTION_DISPOSITION@@PAU_EXCEPTION_RECORD@@PAUComToManagedExRecord@@PAU_CONTEXT@@PAX@Z \
	?ContextTransitionFrameHandler@@YA?AW4_EXCEPTION_DISPOSITION@@PAU_EXCEPTION_RECORD@@PAU_EXCEPTION_REGISTRATION_RECORD@@PAU_CONTEXT@@PAX@Z	
	-del $(O)\ExcepX86.tmp
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\i386\remotingx86.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*===========================================================================
**
** File:    remotingx86.cpp
**
** Author(s):   Gopal Kakivaya  (GopalK)
**              Tarun Anand     (TarunA)     
**              Matt Smith      (MattSmit)
**              Manish Prabhu   (MPrabhu)
**
** Purpose: Defines various remoting related functions for the x86 architecture
**
** Date:    Oct 12, 1999
**
=============================================================================*/

#include "common.h"
#include "excep.h"
#include "COMString.h"
#include "COMDelegate.h"
#include "remoting.h"
#include "reflectwrap.h"
#include "field.h"
#include "ComCallWrapper.h"
#include "siginfo.hpp"
#include "COMClass.h"
#include "StackBuilderSink.h"
#include "wsperf.h"
#include "threads.h"
#include "method.hpp"

#include "interoputil.h"
#include "comcache.h"

// External variables
extern size_t g_dwTPStubAddr;
extern size_t g_dwOOContextAddr;
extern DWORD g_dwNonVirtualThunkRemotingLabelOffset;
extern DWORD g_dwNonVirtualThunkReCheckLabelOffset;

extern DWORD g_dwOffsetOfReservedForOLEinTEB;
extern DWORD g_dwOffsetCtxInOLETLS;

//+----------------------------------------------------------------------------
//
//  Method:     CRemotingServices::CheckForContextMatch   public
//
//  Synopsis:   This code generates a check to see if the current context and
//              the context of the proxy match.
//
//  History:    26-Jun-99   TarunA      Created
//
//+----------------------------------------------------------------------------
__declspec(naked) void CRemotingServices::CheckForContextMatch()
{
    enum
    {
        POINTER_SIZE = sizeof(ULONG_PTR)
    };

    _asm
    {
        push ebx                            ; spill ebx
        mov ebx, [eax + POINTER_SIZE]       ; Get the internal context id by unboxing the stub data
        call GetThread                      ; Get the current thread, assumes that the registers are preserved
        mov eax, [eax]Thread.m_Context      ; Get the current context from the thread
        sub eax, ebx                        ; Get the pointer to the context from proxy and compare with current context
        pop ebx                             ; restore the value of ebx
        ret
    }
}


//+----------------------------------------------------------------------------
//
//  Method:     CRemotingServices::GenerateCheckForProxy   public
//
//  Synopsis:   This code generates a check to see if the "this" pointer
//              is a proxy. If so, the interface invoke is handled via
//              the CRemotingServices::DispatchInterfaceCall else we 
//              delegate to the old path
//
//  History:    26-Jun-99   TarunA      Created
//
//+----------------------------------------------------------------------------
void CRemotingServices::GenerateCheckForProxy(CPUSTUBLINKER* psl)
{
    THROWSCOMPLUSEXCEPTION();

    // Generate label where non-remoting code will start executing
    CodeLabel *pPrologStart = psl->NewCodeLabel();

    // mov eax, [ecx]
    psl->X86EmitIndexRegLoad(kEAX, kECX, 0);

    // cmp eax, CTPMethodTable::s_pThunkTable
    psl->Emit8(0x3b);
    psl->Emit8(0x05);
    psl->Emit32((DWORD)(size_t)CTPMethodTable::GetMethodTableAddr());

    // jne PrologStart
    psl->X86EmitCondJump(pPrologStart, X86CondCode::kJNE);

    // call CRemotingServices::DispatchInterfaceCall
    // NOTE: We pop 0 bytes of stack even though the size of the arguments is
    // 4 bytes because the MethodDesc argument gets pushed for "free" via the 
    // call instruction placed just before the start of the MethodDesc. 
    // See the class MethodDesc for more details.
    psl->X86EmitCall(psl->NewExternalCodeLabel(CRemotingServices::DispatchInterfaceCall), 0);

    // emit label for non remoting case
    psl->EmitLabel(pPrologStart);
}

//+----------------------------------------------------------------------------
//
//  Method:     CRemotingServices::DispatchInterfaceCall   public
//
//  Synopsis:   
//              Push that method desc on the stack and jump to the 
//              transparent proxy stub to execute the call.
//              WARNING!! This MethodDesc is not the methoddesc in the vtable
//              of the object instead it is the methoddesc in the vtable of
//              the interface class. Since we use the MethodDesc only to probe
//              the stack via the signature of the method call we are safe.
//              If we want to get any object vtable/class specific 
//              information this is not safe.
//              
//
//  History:    26-Jun-99   TarunA      Created
//
//+----------------------------------------------------------------------------
__declspec(naked) void __stdcall CRemotingServices::DispatchInterfaceCall(MethodDesc* pMD)
{
    enum
    { 
        MD_IndexOffset = MDEnums::MD_IndexOffset,
        MD_SkewOffset  = MDEnums::MD_SkewOffset,
        MD_Alignment   = MethodDesc::ALIGNMENT
    };

    _asm 
    {  
        // NOTE: At this point the stack looks like
        // 
        // esp--->  return addr of stub 
        //          saved MethodDesc of Interface method
        //          return addr of calling function
        //

        mov eax, [ecx + TP_OFFSET_STUBDATA]
        call [ecx + TP_OFFSET_STUB]
        INDEBUG(nop)                         // mark the fact that this can call managed code
        test eax, eax
        jnz CtxMismatch

		CtxMatch:
                                                         ; in current context, so resolve MethodDesc to real slot no
        push ebx                                         ; spill ebx                 
        mov eax, [esp + 8]                               ; eax <-- MethodDesc
        movsx ebx, byte ptr [eax + MD_IndexOffset]       ; get MethodTable from MethodDesc
        mov eax, [eax + ebx*MD_Alignment + MD_SkewOffset]
        mov eax, [eax]MethodTable.m_pEEClass             ; get EEClass from MethodTable

        mov ebx, [eax]EEClass.m_dwInterfaceId            ; get the interface id from the EEClass
        mov eax, [ecx + TP_OFFSET_MT]                    ; get the *real* MethodTable 
        mov eax, [eax]MethodTable.m_pInterfaceVTableMap  ; get interface map    
        mov eax, [eax + ebx* SIZE PVOID]                 ; offset map by interface id
        mov ebx, [esp + 8]                               ; get MethodDesc
        mov bx,  [ebx]MethodDesc.m_wSlotNumber
        and ebx, 0xffff    
        mov eax, [eax + ebx*SIZE PVOID]                  ; get jump addr
                
        pop ebx                                          ; restore ebx
            
        add esp, 0x8                                     ; pop off Method desc and stub's ra
        jmp eax
                        
        pop edx                                          ; restore registers
        pop ecx
        test eax, eax
		jnz CtxMatch

        CtxMismatch:                                     ; Jump to TPStub
        
        mov eax, [esp + 0x4]                             ; mov eax, MethodDesc
                                                                
        add esp, 0x8                                     ; pop ret addr of stub, saved MethodDesc so that the stack and 
                                                         ; registers are now setup exactly like they were at the callsite        

        push eax                                         ; push the MethodDesc
        
        jmp [g_dwOOContextAddr]                          ; jump to OOContext label in TPStub        
    }
} 

//+----------------------------------------------------------------------------
//
//  Method:     CRemotingServices::CallFieldGetter   private
//
//  Synopsis:   Calls the field getter function (Object::__FieldGetter) in 
//              managed code by setting up the stack and calling the target
//              
//
//  History:    26-Jun-99   TarunA      Created
//
//+----------------------------------------------------------------------------
__declspec(naked) void __stdcall CRemotingServices::CallFieldGetter(
    MethodDesc *pMD, 
    LPVOID pThis,
    LPVOID pFirst,
    LPVOID pSecond,
    LPVOID pThird)
{
    enum 
    {
        ARG_SIZE = sizeof(ULONG_PTR) + 4*sizeof(LPVOID)
    };

    _asm 
    {
        push ebp                         // set up the call frame
        mov ebp, esp

        mov ecx, pThis                  // enregister the this pointer
        mov edx, pFirst                 // enregister the first argument

        push pThird                     // push the third argument on the stack
        push pSecond                    // push the second argument on the stack        
        lea eax, retAddr                // push the return address 
        push eax

        push pMD                        // push the MethodDesc of Object::__FieldGetter
        jmp [g_dwTPStubAddr]            // jump to the TP Stub
                                        
retAddr:
        mov esp, ebp                    // tear down the call frame
        pop ebp

        ret ARG_SIZE
    }
}

//+----------------------------------------------------------------------------
//
//  Method:     CRemotingServices::CallFieldSetter   private
//
//  Synopsis:   Calls the field setter function (Object::__FieldSetter) in 
//              managed code by setting up the stack and calling the target
//              
//
//  History:    26-Jun-99   TarunA      Created
//
//+----------------------------------------------------------------------------
__declspec(naked) void __stdcall CRemotingServices::CallFieldSetter(
    MethodDesc *pMD, 
    LPVOID pThis,
    LPVOID pFirst, 
    LPVOID pSecond,
    LPVOID pThird)
{
    enum 
    {
        ARG_SIZE        =  sizeof(ULONG_PTR) + 4*sizeof(LPVOID)
    };

    _asm 
    {
        push ebp                         // set up the call frame
        mov ebp, esp
        
        mov ecx, pThis                  // enregister the this pointer
        mov edx, pFirst                 // enregister first argument 

        push pThird                     // push the object (third arg) on the stack
        push pSecond                    // push the field name (second arg) on the stack       
        lea eax, retAddr                // push the return address 
        push eax

        push pMD                        // push the MethodDesc of Object::__FieldSetter
        jmp [g_dwTPStubAddr]            // jump to the TP Stub
     
retAddr:
        mov esp, ebp                    // tear down the call frame
        pop ebp

        ret ARG_SIZE    
    }
}

//+----------------------------------------------------------------------------
//
//  Method:     CTPMethodTable::CreateThunkForVirtualMethod   private
//
//  Synopsis:   Creates the thunk that pushes the supplied slot number and jumps
//              to TP Stub
//
//  History:    17-Feb-99   Gopalk      Created
//
//+----------------------------------------------------------------------------
void CTPMethodTable::CreateThunkForVirtualMethod(DWORD dwSlot, BYTE *bCode)
{
    _ASSERTE(NULL != s_pTPStub);

    // 0000   68 67 45 23 01     PUSH dwSlot
    // 0005   E9 ?? ?? ?? ??     JMP  s_pTPStub+1
    *bCode++ = 0x68;
    *((DWORD *) bCode) = dwSlot;
    bCode += sizeof(DWORD);
    *bCode++ = 0xE9;
    // self-relative call, based on the start of the next instruction.
    *((LONG *) bCode) = (LONG)(((size_t) s_pTPStub->GetEntryPoint()) - (size_t) (bCode + sizeof(LONG)));
}




//+----------------------------------------------------------------------------
//
//  Method:     CTPMethodTable::CreateStubForNonVirtualMethod   public
//
//  Synopsis:   Create a stub for a non virtual method
//                            
//  History:    22-Mar-00   Rajak      Created
//
//+----------------------------------------------------------------------------

Stub* CTPMethodTable::CreateStubForNonVirtualMethod(MethodDesc* pMD, CPUSTUBLINKER* psl, 
                                            LPVOID pvAddrOfCode, Stub* pInnerStub)
{
    // Sanity check
    THROWSCOMPLUSEXCEPTION();

    RuntimeExceptionKind reException = kLastException;
    BOOL fThrow = FALSE;
    Stub *pStub = NULL;    

    // we need a hash table only for virtual methods
    _ASSERTE(!pMD->IsVirtual());

    if(!s_fInitializedTPTable)
    {
        if(!InitializeFields())
        {
            reException = kExecutionEngineException;
            fThrow = TRUE;
        }
    }
       
    if (!fThrow)
    {

        COMPLUS_TRY
        {           
            // The thunk has not been created yet. Go ahead and create it.    
            EEClass* pClass = pMD->GetClass();                
            // Compute the address of the slot         
            LPVOID pvSlot = (LPVOID)pClass->GetMethodSlot(pMD);
            LPVOID pvStub = (LPVOID)s_pTPStub->GetEntryPoint();

            // Generate label where a null reference exception will be thrown
            CodeLabel *pJmpAddrLabel = psl->NewCodeLabel();
            // Generate label where remoting code will execute
            CodeLabel *pRemotingLabel = psl->NewCodeLabel();
        
            // if this == NULL throw NullReferenceException
            // test ecx, ecx
            psl->X86EmitR2ROp(0x85, kECX, kECX);

            // je ExceptionLabel
            psl->X86EmitCondJump(pJmpAddrLabel, X86CondCode::kJE);


            // Emit a label here for the debugger. A breakpoint will
            // be set at the next instruction and the debugger will
            // call CNonVirtualThunkMgr::TraceManager when the
            // breakpoint is hit with the thread's context.
            CodeLabel *pRecheckLabel = psl->NewCodeLabel();
            psl->EmitLabel(pRecheckLabel);
        
            // If this.MethodTable != TPMethodTable then do RemotingCall
            // mov eax, [ecx]
            psl->X86EmitIndexRegLoad(kEAX, kECX, 0);
    
            // cmp eax, CTPMethodTable::s_pThunkTable
            psl->Emit8(0x3D);
            psl->Emit32((DWORD)(size_t)GetMethodTable());
    
            // jne pJmpAddrLabel
            // marshalbyref case
            psl->X86EmitCondJump(pJmpAddrLabel, X86CondCode::kJNE);

            // Transparent proxy case
            EmitCallToStub(psl, pRemotingLabel);

            // Exception handling and non-remoting share the 
            // same codepath
            psl->EmitLabel(pJmpAddrLabel);

            if (pInnerStub == NULL)
            {
                // pop the method desc
                psl->X86EmitPopReg(kEAX);
                // jump to the address
                psl->X86EmitNearJump(psl->NewExternalCodeLabel(pvAddrOfCode));
            }
            else
            {
                // jump to the address
                psl->X86EmitNearJump(psl->NewExternalCodeLabel(pvAddrOfCode));
            }
            
            psl->EmitLabel(pRemotingLabel);
                                        
            // the MethodDesc is already on top of the stack.  goto TPStub
            // jmp TPStub
            psl->X86EmitNearJump(psl->NewExternalCodeLabel(pvStub));

            // Link and produce the stub
            pStub = psl->LinkInterceptor(pMD->GetClass()->GetDomain()->GetStubHeap(),
                                           pInnerStub, pvAddrOfCode);        
        }
        COMPLUS_CATCH
        {
            reException = kOutOfMemoryException;
            fThrow = TRUE;
        }                       
        COMPLUS_END_CATCH
    }
    
    // Check for the need to throw exceptions
    if(fThrow)
    {
        COMPlusThrow(reException);
    }
    
    _ASSERTE(NULL != pStub);
    return pStub;
}

//+----------------------------------------------------------------------------
//
//  Synopsis:   Find an existing thunk or create a new one for the given 
//              method descriptor. NOTE: This is used for the methods that do 
//              not go through the vtable such as constructors, private and 
//              final methods.
//                            
//  History:    26-Jun-99   TarunA      Created
//
//+----------------------------------------------------------------------------
LPVOID CTPMethodTable::GetOrCreateNonVirtualThunkForVirtualMethod(MethodDesc* pMD, CPUSTUBLINKER* psl)
{       
    // Sanity check
    THROWSCOMPLUSEXCEPTION();

    RuntimeExceptionKind reException = kLastException;
    BOOL fThrow = FALSE;

    Stub *pStub = NULL;    
    LPVOID pvThunk = NULL;

    if(!s_fInitializedTPTable)
    {
        if(!InitializeFields())
        {
            reException = kExecutionEngineException;
            fThrow = TRUE;
        }
    }
             
    // Create the thunk in a thread safe manner
    LOCKCOUNTINCL("GetOrCreateNonVirtualThunk in i486/remotingx86.cpp");                        \
    EnterCriticalSection(&s_TPMethodTableCrst);

    COMPLUS_TRY
    {
        // Check to make sure that no other thread has 
        // created the thunk
        _ASSERTE(NULL != s_pThunkHashTable);
    
        s_pThunkHashTable->GetValue(pMD, (HashDatum *)&pvThunk);
    
        if((NULL == pvThunk) && !fThrow)
        {
            // The thunk has not been created yet. Go ahead and create it.    
            EEClass* pClass = pMD->GetClass();                
            // Compute the address of the slot         
            LPVOID pvSlot = (LPVOID)pClass->GetMethodSlot(pMD);
            LPVOID pvStub = (LPVOID)s_pTPStub->GetEntryPoint();
    
            // Generate label where a null reference exception will be thrown
            CodeLabel *pExceptionLabel = psl->NewCodeLabel();

            //  !!! WARNING WARNING WARNING WARNING WARNING !!!
            //
            //  DO NOT CHANGE this code without changing the thunk recognition
            //  code in CNonVirtualThunkMgr::IsThunkByASM 
            //  & CNonVirtualThunkMgr::GetMethodDescByASM
            //
            //  !!! WARNING WARNING WARNING WARNING WARNING !!!
            
            // if this == NULL throw NullReferenceException
            // test ecx, ecx
            psl->X86EmitR2ROp(0x85, kECX, kECX);
    
            // je ExceptionLabel
            psl->X86EmitCondJump(pExceptionLabel, X86CondCode::kJE);
    
            // Generate label where remoting code will execute
            CodeLabel *pRemotingLabel = psl->NewCodeLabel();
    
            // Emit a label here for the debugger. A breakpoint will
            // be set at the next instruction and the debugger will
            // call CNonVirtualThunkMgr::TraceManager when the
            // breakpoint is hit with the thread's context.
            CodeLabel *pRecheckLabel = psl->NewCodeLabel();
            psl->EmitLabel(pRecheckLabel);
            
            // If this.MethodTable == TPMethodTable then do RemotingCall
            // mov eax, [ecx]
            psl->X86EmitIndexRegLoad(kEAX, kECX, 0);
        
            // cmp eax, CTPMethodTable::s_pThunkTable
            psl->Emit8(0x3D);
            psl->Emit32((DWORD)(size_t)GetMethodTable());
        
            // je RemotingLabel
            psl->X86EmitCondJump(pRemotingLabel, X86CondCode::kJE);
    
            // Exception handling and non-remoting share the 
            // same codepath
            psl->EmitLabel(pExceptionLabel);
    
            // Non-RemotingCode
            // Jump to the vtable slot of the method
            // jmp [slot]
            psl->Emit8(0xff);
            psl->Emit8(0x25);
            psl->Emit32((DWORD)(size_t)pvSlot);            

            // Remoting code. Note: CNonVirtualThunkMgr::TraceManager
            // relies on this label being right after the jmp [slot]
            // instruction above. If you move this label, update
            // CNonVirtualThunkMgr::DoTraceStub.
            psl->EmitLabel(pRemotingLabel);
    
            // Save the MethodDesc and goto TPStub
            // push MethodDesc

            psl->X86EmitPushImm32((DWORD)(size_t)pMD);

            // jmp TPStub
            psl->X86EmitNearJump(psl->NewExternalCodeLabel(pvStub));
    
            // Link and produce the stub
            // FUTURE: Do we have to provide the loader heap ?
            pStub = psl->Link(SystemDomain::System()->GetHighFrequencyHeap());
    
            // Grab the offset of the RemotingLabel and RecheckLabel
            // for use in CNonVirtualThunkMgr::DoTraceStub and
            // TraceManager.
            g_dwNonVirtualThunkRemotingLabelOffset =
                psl->GetLabelOffset(pRemotingLabel);
            g_dwNonVirtualThunkReCheckLabelOffset =
                psl->GetLabelOffset(pRecheckLabel);
    
            // Set the generated thunk once and for all..            
            CNonVirtualThunk *pThunk = CNonVirtualThunk::SetNonVirtualThunks(pStub->GetEntryPoint());
    
            // Remember the thunk address in a hash table 
            // so that we dont generate it again
            pvThunk = (LPVOID)pThunk->GetAddrOfCode();
            s_pThunkHashTable->InsertValue(pMD, (HashDatum)pvThunk);
        }
    }
    COMPLUS_CATCH
    {
        reException = kOutOfMemoryException;
        fThrow = TRUE;
    }                       
    COMPLUS_END_CATCH

    // Leave the lock
    LeaveCriticalSection(&s_TPMethodTableCrst);    
    LOCKCOUNTDECL("GetOrCreateNonVirtualThunk in remotingx86.cpp");                     \
    
    // Check for the need to throw exceptions
    if(fThrow)
    {
        COMPlusThrow(reException);
    }
    
    _ASSERTE(NULL != pvThunk);
    return pvThunk;
}


CPUSTUBLINKER *CTPMethodTable::NewStubLinker()
{
    return new CPUSTUBLINKER();
}

//+----------------------------------------------------------------------------
//
//  Method:     CTPMethodTable::CreateTPStub   private
//
//  Synopsis:   Creates the stub that sets up a CtxCrossingFrame and forwards the
//              call to
//
//  History:    17-Feb-99   Gopalk      Created
//
//+----------------------------------------------------------------------------

Stub *CTPMethodTable::CreateTPStub()
{
    THROWSCOMPLUSEXCEPTION();

    CPUSTUBLINKER *pStubLinker = NULL;

    EE_TRY_FOR_FINALLY
    {
        // Note: We are already inside a criticalsection

        if (s_pTPStub == NULL)
        {
            pStubLinker = CTPMethodTable::NewStubLinker();
            if (!pStubLinker)
                COMPlusThrowOM();
                        
            CodeLabel *ConvMD = pStubLinker->NewCodeLabel();
            CodeLabel *UseCode = pStubLinker->NewCodeLabel();
            CodeLabel *OOContext = pStubLinker->NewCodeLabel();
            DWORD finalizeSlotNum = g_Mscorlib.GetMethod(METHOD__OBJECT__FINALIZE)->GetSlot(); 

	        if (!pStubLinker || !UseCode || !OOContext )
            {
                COMPlusThrowOM();
            }

            // before we setup a frame check if the method is being executed 
            // in the same context in which the server was created, if true,
            // we do not set up a frame and instead jump directly to the code address.            
            EmitCallToStub(pStubLinker, OOContext);

            // The contexts match. Jump to the real address and start executing...
            EmitJumpToAddressCode(pStubLinker, ConvMD, UseCode);

            // label: OOContext
            pStubLinker->EmitLabel(OOContext);
            
			// CONTEXT MISMATCH CASE, call out to the real proxy to
			// dispatch

            // Setup the frame
            EmitSetupFrameCode(pStubLinker);

            // Finally, create the stub
            s_pTPStub = pStubLinker->Link();

            // Set the address of Out Of Context case.
            // This address is used by other stubs like interface
            // invoke to jump straight to RealProxy::PrivateInvoke
            // because they have already determined that contexts 
            // don't match.
            g_dwOOContextAddr = (DWORD)(size_t)(s_pTPStub->GetEntryPoint() + 
                                        pStubLinker->GetLabelOffset(OOContext));
        }

        if(NULL != s_pTPStub)
        {
            // Initialize the stub manager which will aid the debugger in finding
            // the actual address of a call made through the vtable
            // Note: This function can throw, but we are guarded by a try..finally
            CVirtualThunkMgr::InitVirtualThunkManager((const BYTE *) s_pTPStub->GetEntryPoint());
    
        }        
    }
    EE_FINALLY
    {
        // Cleanup
        if (pStubLinker)
            delete pStubLinker;
    }EE_END_FINALLY;

        
    return(s_pTPStub);
}

//+----------------------------------------------------------------------------
//
//  Method:     CTPMethodTable::CreateDelegateStub   private
//
//  Synopsis:   Creates the stub that sets up a CtxCrossingFrame and forwards the
//              call to PreCall
//
//  History:    26-Jun-00   TarunA      Created
//
//+----------------------------------------------------------------------------
Stub *CTPMethodTable::CreateDelegateStub()
{
    THROWSCOMPLUSEXCEPTION();

    CPUSTUBLINKER *pStubLinker = NULL;

    EE_TRY_FOR_FINALLY
    {
        // Note: We are inside a critical section

        if (s_pDelegateStub == NULL)
        {
            pStubLinker = NewStubLinker();

	        if (!pStubLinker)
            {
                COMPlusThrowOM();
            }

            // Setup the frame
            EmitSetupFrameCode(pStubLinker);

            s_pDelegateStub = pStubLinker->Link();
        }
    }
    EE_FINALLY
    {
        // Cleanup
        if (pStubLinker)
            delete pStubLinker;
    }EE_END_FINALLY;

        
    return(s_pDelegateStub);
}

//+----------------------------------------------------------------------------
//
//  Method:     CTPMethodTable::EmitCallToStub   private
//
//  Synopsis:   Emits code to call a stub defined on the proxy. 
//              The result of the call dictates whether the call should be executed in the callers 
//              context or not.
//
//  History:    30-Sep-00   TarunA      Created
//
//+----------------------------------------------------------------------------
VOID CTPMethodTable::EmitCallToStub(CPUSTUBLINKER* pStubLinker, CodeLabel* pCtxMismatch)
{       

    // Move into eax the stub data and call the stub
    // mov eax, [ecx + TP_OFFSET_STUBDATA]
    pStubLinker->X86EmitIndexRegLoad(kEAX, kECX, TP_OFFSET_STUBDATA);

    //call [ecx + TP_OFFSET_STUB]
    byte callStub[] = {0xff, 0x51, (byte)TP_OFFSET_STUB};
    pStubLinker->EmitBytes(callStub, sizeof(callStub));

    // test eax,eax
    pStubLinker->Emit16(0xc085);
    // jnz CtxMismatch
    pStubLinker->X86EmitCondJump(pCtxMismatch, X86CondCode::kJNZ);
}

//+----------------------------------------------------------------------------
//
//  Method:     CTPMethodTable::GenericCheckForContextMatch private
//
//  Synopsis:   Calls the stub in the TP & returns TRUE if the contexts
//              match, FALSE otherwise.
//
//  Note:       1. Called during FieldSet/Get, used for proxy extensibility
//
//  History:    23-Jan-01   MPrabhu     Created
//
//+----------------------------------------------------------------------------
__declspec(naked) BOOL __stdcall CTPMethodTable::GenericCheckForContextMatch(OBJECTREF tp)
{
    _asm
    {
        push ebp            // Callee saved registers
        mov ebp, esp
        push ecx
        mov ecx, tp
        mov eax, [ecx + TP_OFFSET_STUBDATA]
        call [ecx + TP_OFFSET_STUB]
        INDEBUG(nop)        // mark the fact that this can call managed code
        test eax, eax       
        mov eax, 0x0
        setz al
        // NOTE: In the CheckForXXXMatch stubs (for URT ctx/ Ole32 ctx) eax is 
        // non-zero if contexts *do not* match & zero if they do.  
        pop ecx
        mov esp, ebp
        pop ebp
        ret 0x4
    }
}

//+----------------------------------------------------------------------------
//
//  Method:     CTPMethodTable::EmitJumpToAddressCode   private
//
//  Synopsis:   Emits the code to extract the address from the slot or the method 
//              descriptor and jump to it.
//
//  History:    26-Jun-00   TarunA      Created
//
//+----------------------------------------------------------------------------
VOID CTPMethodTable::EmitJumpToAddressCode(CPUSTUBLINKER* pStubLinker, CodeLabel* ConvMD, 
                                           CodeLabel* UseCode)
{
    // UseCode:
    pStubLinker->EmitLabel(UseCode);

    // mov eax, [esp]
    byte loadSlotOrMD[] = {0x8B, 0x44, 0x24, 0x00};
    pStubLinker->EmitBytes(loadSlotOrMD, sizeof(loadSlotOrMD));

    // test eax, 0xffff0000
    byte testForSlot[] = { 0xA9, 0x00, 0x00, 0xFF, 0xFF };
    pStubLinker->EmitBytes(testForSlot, sizeof(testForSlot));

    // jnz ConvMD
    pStubLinker->X86EmitCondJump(ConvMD, X86CondCode::kJNZ);
    
    // if ([esp] & 0xffff0000)
    // {
    
        // ** code addr from slot case **
    
        // mov eax, [ecx + TPMethodTable::GetOffsetOfMT()]
        pStubLinker->X86EmitIndexRegLoad(kEAX, kECX, TP_OFFSET_MT);

        // push ebx
        pStubLinker->X86EmitPushReg(kEBX);

        // mov ebx, [esp + 4]
        byte loadSlot[] = {0x8B, 0x5C, 0x24, 0x04};
        pStubLinker->EmitBytes(loadSlot, sizeof(loadSlot));

        // mov eax,[eax + ebx*4 + MethodTable::GetOffsetOfVtable()]
        byte getCodePtr[]  = {0x8B, 0x84, 0x98, 0x00, 0x00, 0x00, 0x00};
        *((DWORD *)(getCodePtr+3)) = MethodTable::GetOffsetOfVtable();
        pStubLinker->EmitBytes(getCodePtr, sizeof(getCodePtr));

        // pop ebx
        pStubLinker->X86EmitPopReg(kEBX);

        // lea esp, [esp+4]
        byte popNULL[] = { 0x8D, 0x64, 0x24, 0x04};
        pStubLinker->EmitBytes(popNULL, sizeof(popNULL));

        // jmp eax
        byte jumpToRegister[] = {0xff, 0xe0};
        pStubLinker->EmitBytes(jumpToRegister, sizeof(jumpToRegister));
    
    // }
    // else
    // {
        // ** code addr from MethodDesc case **

        pStubLinker->EmitLabel(ConvMD);                
        
        // sub eax, METHOD_CALL_PRESTUB_SIZE
        pStubLinker->X86EmitSubReg(kEAX, METHOD_CALL_PRESTUB_SIZE);
                
        // lea esp, [esp+4]
        pStubLinker->EmitBytes(popNULL, sizeof(popNULL));

        // jmp eax
        pStubLinker->EmitBytes(jumpToRegister, sizeof(jumpToRegister));

    // }
}

//+----------------------------------------------------------------------------
//
//  Method:     CTPMethodTable::EmitJumpToCode   private
//
//  Synopsis:   Emits the code jump to the address of code
//
//  History:    26-Jun-00   TarunA      Created
//
//+----------------------------------------------------------------------------
VOID CTPMethodTable::EmitJumpToCode(CPUSTUBLINKER* pStubLinker, CodeLabel* UseCode)
{
    // Use the address of code if eax != 0
    pStubLinker->X86EmitCondJump(UseCode, X86CondCode::kJNZ);
}

//+----------------------------------------------------------------------------
//
//  Method:     CTPMethodTable::EmitSetupFrameCode   private
//
//  Synopsis:   Emits the code to setup a frame and call to PreCall method
//              call to PreCall
//
//  History:    26-Jun-00   TarunA      Created
//
//+----------------------------------------------------------------------------
VOID CTPMethodTable::EmitSetupFrameCode(CPUSTUBLINKER *pStubLinker)
{
        ////////////////START SETUP FRAME//////////////////////////////
        // Setup frame (partial)
        pStubLinker->EmitMethodStubProlog(TPMethodFrame::GetMethodFrameVPtr());

        // Complete the setup of the frame by calling PreCall
        
        // push esi (push new frame as ARG)
        pStubLinker->X86EmitPushReg(kESI); 

        // pop 4 bytes or args on return from call
        pStubLinker->X86EmitCall(pStubLinker->NewExternalCodeLabel(PreCall), 4);

        ////////////////END SETUP FRAME////////////////////////////////                
        
        // Debugger patch location
        // NOTE: This MUST follow the call to emit the "PreCall" label
        // since after PreCall we know how to help the debugger in 
        // finding the actual destination address of the call.
        // @see CVirtualThunkMgr::DoTraceStub
        pStubLinker->EmitPatchLabel();

        // Call
        pStubLinker->X86EmitSubEsp(sizeof(INT64));
        pStubLinker->Emit8(0x54);          // push esp (push return value as ARG)
        pStubLinker->X86EmitPushReg(kEBX); // push ebx (push current thread as ARG)
        pStubLinker->X86EmitPushReg(kESI); // push esi (push new frame as ARG)
#ifdef _DEBUG
        // push IMM32
        pStubLinker->Emit8(0x68);
        pStubLinker->EmitPtr(OnCall);
        // in CE pop 12 bytes or args on return from call
            pStubLinker->X86EmitCall(pStubLinker->NewExternalCodeLabel(WrapCall), 12);
#else // !_DEBUG
        // in CE pop 12 bytes or args on return from call
        pStubLinker->X86EmitCall(pStubLinker->NewExternalCodeLabel(OnCall), 12);
#endif // _DEBUG

        // Tear down frame
        pStubLinker->X86EmitAddEsp(sizeof(INT64));
        pStubLinker->EmitMethodStubEpilog(-1, kNoTripStubStyle);
}

//+----------------------------------------------------------------------------
//
//  Method:     CTPMethodTable::CallTarget   private
//
//  Synopsis:   Calls the target method on the given object
//
//  History:    17-Feb-99   Gopalk      Created
//
//+----------------------------------------------------------------------------
__declspec(naked) INT64 __stdcall CTPMethodTableCallTargetHelper(const void *pTarget,
                                                             LPVOID pvFirst,
                                                             LPVOID pvSecond)
{
    __asm {
        push ebp                // Callee saved registers
        mov ebp, esp

        mov ecx, pvFirst        //  Enregister the first two arguments
        mov edx, pvSecond

        call pTarget            // Make the call
        INDEBUG(nop)            // Mark this as a special call site that can directly call managed

        mov esp, ebp            // Restore the registers
        pop ebp

        ret 0xC                 // Return
    }
}

INT64 __stdcall CTPMethodTable::CallTarget (const void *pTarget,
                                            LPVOID pvFirst,
                                            LPVOID pvSecond)
{
#ifdef _DEBUG
    Thread* curThread = GetThread();
    
    unsigned ObjRefTable[OBJREF_TABSIZE];
    if (curThread)
        memcpy(ObjRefTable, curThread->dangerousObjRefs,
               sizeof(curThread->dangerousObjRefs));
    
    if (curThread)
        curThread->SetReadyForSuspension ();

    _ASSERTE(curThread->PreemptiveGCDisabled());  // Jitted code expects to be in cooperative mode
#endif

    INT64 ret;
    INSTALL_COMPLUS_EXCEPTION_HANDLER();
    ret = CTPMethodTableCallTargetHelper (pTarget, pvFirst, pvSecond);
    UNINSTALL_COMPLUS_EXCEPTION_HANDLER();
    
#ifdef _DEBUG
    // Restore dangerousObjRefs when we return back to EE after call
    if (curThread)
        memcpy(curThread->dangerousObjRefs, ObjRefTable,
               sizeof(curThread->dangerousObjRefs));

    TRIGGERSGC ();

    ENABLESTRESSHEAP ();
#endif

    return ret;
}

//+----------------------------------------------------------------------------
//
//  Method:     CTPMethodTable::CallTarget   private
//
//  Synopsis:   Calls the target method on the given object
//
//  History:    17-Feb-99   Gopalk      Created
//
//+----------------------------------------------------------------------------
__declspec(naked) INT64 __stdcall CTPMethodTableCallTargetHelper(const void *pTarget,
                                                             LPVOID pvFirst,
                                                             LPVOID pvSecond,
                                                             LPVOID pvThird)
{
    __asm {
        push ebp                // Callee saved registers
        mov ebp, esp

        mov ecx, pvFirst        //  Enregister the first two arguments
        mov edx, pvSecond

        push pvThird            // Push the third argument

        call pTarget            // Make the call
        INDEBUG(nop)            // Mark this as a special call site that can directly call managed

        mov esp, ebp            // Restore the registers
        pop ebp

        ret 0x10                 // Return
    }
}

INT64 __stdcall CTPMethodTable::CallTarget (const void *pTarget,
                                            LPVOID pvFirst,
                                            LPVOID pvSecond,
                                            LPVOID pvThird)
{
#ifdef _DEBUG
    Thread* curThread = GetThread();
    
    unsigned ObjRefTable[OBJREF_TABSIZE];
    if (curThread)
        memcpy(ObjRefTable, curThread->dangerousObjRefs,
               sizeof(curThread->dangerousObjRefs));
    
    if (curThread)
        curThread->SetReadyForSuspension ();

    _ASSERTE(curThread->PreemptiveGCDisabled());  // Jitted code expects to be in cooperative mode
#endif

    INT64 ret;
    INSTALL_COMPLUS_EXCEPTION_HANDLER();
    ret = CTPMethodTableCallTargetHelper (pTarget, pvFirst, pvSecond, pvThird);
    UNINSTALL_COMPLUS_EXCEPTION_HANDLER();
    
#ifdef _DEBUG
    // Restore dangerousObjRefs when we return back to EE after call
    if (curThread)
        memcpy(curThread->dangerousObjRefs, ObjRefTable,
               sizeof(curThread->dangerousObjRefs));

    TRIGGERSGC ();

    ENABLESTRESSHEAP ();
#endif
    
    return ret;
}

//+----------------------------------------------------------------------------
//
//  Method:     CVirtualThunkMgr::DoTraceStub   public
//
//  Synopsis:   Traces the stub given the starting address
//
//  History:    26-Jun-99   TarunA      Created
//
//+----------------------------------------------------------------------------
BOOL CVirtualThunkMgr::DoTraceStub(const BYTE *stubStartAddress, TraceDestination *trace)
{
    BOOL bIsStub = FALSE;

    // Find a thunk whose code address matching the starting address
    LPBYTE pThunk = FindThunk(stubStartAddress);
    if(NULL != pThunk)
    {
        LPBYTE pbAddr = NULL;
        LONG destAddress = 0;
        if(stubStartAddress == pThunk)
        {

            // Extract the long which gives the self relative address
            // of the destination
            pbAddr = pThunk + ConstStubLabel + sizeof(BYTE);
            destAddress = *(LONG *)pbAddr;

            // Calculate the absolute address by adding the offset of the next 
            // instruction after the call instruction
            destAddress += (LONG)(size_t)(pbAddr + sizeof(LONG));

        }

        // We cannot tell where the stub will end up until OnCall is reached.
        // So we tell the debugger to run till OnCall is reached and then 
        // come back and ask us again for the actual destination address of 
        // the call
    
        Stub *stub = Stub::RecoverStub((BYTE *)(size_t)destAddress);
    
        trace->type = TRACE_FRAME_PUSH;
        trace->address = stub->GetEntryPoint() + stub->GetPatchOffset();
        bIsStub = TRUE;
    }

    return bIsStub;
}

//+----------------------------------------------------------------------------
//
//  Method:     CVirtualThunkMgr::IsThunkByASM  public
//
//  Synopsis:   Check assembly to see if this one of our thunks
//
//  History:    14-Sep-99 MattSmit      Created
//
//+----------------------------------------------------------------------------
BOOL CVirtualThunkMgr::IsThunkByASM(const BYTE *startaddr)
{

    // Future:: Try using the rangelist. This may be a problem if the code is not at least 6 bytes long
    const BYTE *bCode = startaddr + 6;
    return (startaddr &&
            (startaddr[0] == 0x68) &&
            (startaddr[5] == 0xe9) &&
            (*((LONG *) bCode) == (LONG)((LONG_PTR)CTPMethodTable::GetTPStub()->GetEntryPoint()) - (LONG_PTR)(bCode + sizeof(LONG))) &&
            CheckIsStub(startaddr));
}

//+----------------------------------------------------------------------------
//
//  Method:     CVirtualThunkMgr::GetMethodDescByASM   public
//
//  Synopsis:   Parses MethodDesc out of assembly code
//
//  History:    14-Sep-99 MattSmit      Creatde
//
//+----------------------------------------------------------------------------
MethodDesc *CVirtualThunkMgr::GetMethodDescByASM(const BYTE *startaddr, MethodTable *pMT)
{
    return pMT->GetClass()->GetMethodDescForSlot(*((DWORD *) (startaddr + 1)));
}


//+----------------------------------------------------------------------------
//
//  Method:     CNonVirtualThunkMgr::TraceManager   public
//
//  Synopsis:   Traces the stub given the current context
//
//  History:    26-Jun-99   TarunA      Created
//
//+----------------------------------------------------------------------------
BOOL CNonVirtualThunkMgr::TraceManager(Thread *thread,
                                       TraceDestination *trace,
                                       CONTEXT *pContext,
                                       BYTE **pRetAddr)
{
    BOOL bRet = FALSE;
    
    // Does this.MethodTable ([ecx]) == CTPMethodTable::GetMethodTableAddr()?
    DWORD pThis = pContext->Ecx;

    if ((pThis != NULL) &&
        (*(DWORD*)(size_t)pThis == (DWORD)(size_t)CTPMethodTable::GetMethodTableAddr()))
    {
        // @todo: what do we do here. We know that we've got a proxy
        // in the way. If the proxy is to a remote call, with no
        // managed code in between, then the debugger doesn't care and
        // we should just be able to return FALSE.
        //
        // -- mikemag Wed Oct 13 17:59:03 1999
        bRet = FALSE;
    }
    else
    {
        // No proxy in the way, so figure out where we're really going
        // to and let the stub manager try to pickup the trace from
        // there.
        DWORD stubStartAddress = pContext->Eip -
            g_dwNonVirtualThunkReCheckLabelOffset;
        
        // Extract the long which gives the address of the destination
        BYTE* pbAddr = (BYTE *)(size_t)(stubStartAddress +
                                g_dwNonVirtualThunkRemotingLabelOffset -
                                sizeof(DWORD));

        // Since we do an indirect jump we have to dereference it twice
        LONG destAddress = **(LONG **)pbAddr;

        // Ask the stub manager to trace the destination address
        bRet = StubManager::TraceStub((BYTE *)(size_t)destAddress, trace);
    }

    // While we may have made it this far, further tracing may reveal
    // that the debugger can't continue on. Therefore, since there is
    // no frame currently pushed, we need to tell the debugger where
    // we're returning to just in case it hits such a situtation.  We
    // know that the return address is on the top of the thread's
    // stack.
    *pRetAddr = *((BYTE**)(size_t)(pContext->Esp));
    
    return bRet;
}

//+----------------------------------------------------------------------------
//
//  Method:     CNonVirtualThunkMgr::DoTraceStub   public
//
//  Synopsis:   Traces the stub given the starting address
//
//  History:    26-Jun-99   TarunA      Created
//
//+----------------------------------------------------------------------------
BOOL CNonVirtualThunkMgr::DoTraceStub(const BYTE *stubStartAddress,
                                      TraceDestination *trace)
{    
    BOOL bRet = FALSE;

    CNonVirtualThunk* pThunk = FindThunk(stubStartAddress);
    
    if(NULL != pThunk)
    {
        // We can either jump to 
        // (1) a slot in the transparent proxy table (UNMANAGED)
        // (2) a slot in the non virtual part of the vtable
        // ... so, we need to return TRACE_MGR_PUSH with the address
        // at which we want to be called back with the thread's context
        // so we can figure out which way we're gonna go.
        if(stubStartAddress == pThunk->GetThunkCode())
        {
            trace->type = TRACE_MGR_PUSH;
            trace->stubManager = this; // Must pass this stub manager!
            trace->address = (BYTE*)(stubStartAddress +
                                     g_dwNonVirtualThunkReCheckLabelOffset);
            bRet = TRUE;
        }
    }

    return bRet;
}

//+----------------------------------------------------------------------------
//
//  Method:     CNonVirtualThunkMgr::IsThunkByASM  public
//
//  Synopsis:   Check assembly to see if this one of our thunks
//
//  History:    14-Sep-99 MattSmit      Created
//
//+----------------------------------------------------------------------------
BOOL CNonVirtualThunkMgr::IsThunkByASM(const BYTE *startaddr)
{
    // FUTURE:: Try using rangelist, this may be a problem if the code is not long enough
    return  (startaddr &&
             startaddr[0] == 0x85 && 
             startaddr[1] == 0xc9 && 
             startaddr[2] == 0x74 && 
             (*((DWORD *)(startaddr + 7)) == (DWORD)(size_t)CTPMethodTable::GetMethodTable()) && 
             CheckIsStub(startaddr) && 
             startaddr[19] == 0x68); // To distinguish thunk case from NonVirtual method stub
}

//+----------------------------------------------------------------------------
//
//  Method:     CNonVirtualThunkMgr::GetMethodDescByASM   public
//
//  Synopsis:   Parses MethodDesc out of assembly code
//
//  History:    14-Sep-99 MattSmit      Created
//
//+----------------------------------------------------------------------------
MethodDesc *CNonVirtualThunkMgr::GetMethodDescByASM(const BYTE *startaddr)
{
    return *((MethodDesc **) (startaddr + 20));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\ia64\calldescrworker.s ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
.text
.proc   CallDescrWorker#
.type   CallDescrWorker#, @function
.global CallDescrWorker#

.global GetThread
.global ?GetMethodFrameVPtr@PrestubMethodFrame@@SAPEAXXZ    // PrestubMethodFrame::GetMethodFrameVPtr()
.align 32


#define PRESTUB_SIZE_BYTES          0x20
#define OFFSET_THREAD_M_PFRAME      0x8
#define PMF_GETMETHODFRAME          ?GetMethodFrameVPtr@PrestubMethodFrame@@SAPEAXXZ
#define STACK_SIZE                  64  
#define FRAME_OFFSET                32


//INT64 __cdecl CallDescrWorker(LPVOID                   pSrcEnd,
//                              UINT32                   numStackSlots,
//                              const ArgumentRegisters *pArgumentRegisters,
//                              LPVOID                   pTarget
//                             )
CallDescrWorker:
        alloc       loc0 = ar.pfs, 4, 10, 1, 0              // in, loc, out, rotating
        mov         loc1 = rp
        mov         loc2 = gp                               // save gp
        mov         loc3 = pr                               // do we need to save this?

        add         sp = -STACK_SIZE, sp

        //
        // @TODO_IA64: deal with args here
        //

        //
        // @TODO_IA64: this assembly is intentionally un-optimized because
        //             it will need to change once we start using this to
        //             pass arguments as well as when we take parts of it
        //             out and put them in a stub
        //

        add         loc4 = @gprel(GetThread), gp
        ld8         loc5 = [loc4]                       // loc5 <- ptr to GetThread fn descriptor
        ld8         loc6 = [loc5], 8                    // loc6 <- ptr to GetThread
        ld8         gp   = [loc5]                       // get gp for GetThread
        mov         b1   = loc6                         // b1 <- GetThread
        br.call.sptk.few    rp = b1                     // call GetThread()

        cmp.eq      p2, p3 = ret0, r0
        mov         loc7 = ret0                         // loc7 <- pThread
(p2)    br.cond.spnt.few    ReturnLabel
    
        movl        loc8 = PMF_GETMETHODFRAME           // loc8 <- ptr to GetMethodFrameVPtr fn descriptor
        ld8         loc9 = [loc8], 8                    // loc9 <- ptr to GetMethodFrameVPtr
        ld8         gp   = [loc8]                       // get gp for GetMethodFrameVPtr
        mov         b2   = loc9                         // b2 <- GetMethodFrameVPtr
        br.call.sptk.few    rp = b2                     // call PrestubMethodFrame::GetMethodFrameVPtr()

        add         loc4 = FRAME_OFFSET, sp
        add         out0 = FRAME_OFFSET, sp             // out0 <- pPFrame


        add         loc5 = OFFSET_THREAD_M_PFRAME, loc7
        ld8         loc6 = [loc5]                       // loc6 <- pThread->m_pFrame
        st8         [loc5] = out0                       // pThread->m_pFrame = pPFrame

        add         loc7 = PRESTUB_SIZE_BYTES, in3      // loc7 <- m_Datum
        movl        loc8 = ReturnLabel                  // loc8 <- m_ReturnAddress

        st8         [loc4] = ret0, 8                    // vtbl ptr
        st8         [loc4] = loc6, 8                    // m_Next = pThread->m_pFrame
        st8         [loc4] = loc7, 8                    // m_Datum
        st8         [loc4] = loc8                       // m_ReturnAddress

        mov         b3  = in3
        br.cond.sptk.few    b3

ReturnLabel:
        add         sp = STACK_SIZE, sp
        mov         pr = loc3
        mov         gp = loc2
        mov         rp = loc1
        mov         ar.pfs = loc0
        br.ret.sptk.few  rp

.endp CallDescrWorker#
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\ia64\makefile.inc ===
[CODE: No readable text]
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\ia64\cgencpu.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
// CGENCPU.H -
//
// Various helper routines for generating IA64 assembly code.
//
// DO NOT INCLUDE THIS FILE DIRECTLY - ALWAYS USE CGENSYS.H INSTEAD
//


#ifndef _IA64_
#error Should only include "ia64\cgencpu.h" for IA64 builds
#endif

#ifndef __cgencpu_h__
#define __cgencpu_h__

#include "stublink.h"
#include "utilcode.h"

// FCALL is available on this platform
#define FCALLAVAILABLE 1


// preferred alignment for data
#define DATA_ALIGNMENT 4

class MethodDesc;
class FramedMethodFrame;
class Module;
struct ArrayOpScript;
struct DeclActionInfo;

// default return value type
typedef INT64 PlatformDefaultReturnType;

// CPU-dependent functions
extern "C" void __cdecl PreStubTemplate(void);
extern "C" INT64 __cdecl CallWorker_WilDefault(const BYTE  *pStubTarget, UINT32 numArgSlots, PCCOR_SIGNATURE pSig,
                                               Module *pmodule, const BYTE  *pArgsEnd, BOOL fIsStatic);
extern "C" INT64 __cdecl CallDllFunction(LPVOID pTarget, LPVOID pEndArguments, UINT32 numArgumentSlots, BOOL fThisCall);
extern "C" void __stdcall WrapCall(void *target);
extern "C" void CopyPreStubTemplate(Stub *preStub);
// Non-CPU-specific helper functions called by the CPU-dependent code
extern "C" VOID __stdcall ArgFiller_WilDefault(BOOL fIsStatic, PCCOR_SIGNATURE pSig, Module *pmodule, BYTE *psrc, BYTE *pdst);
extern "C" const BYTE * __stdcall PreStubWorker(PrestubMethodFrame *pPFrame);
extern "C" INT64 __stdcall NDirectGenericStubWorker(Thread *pThread, NDirectMethodFrame *pFrame);
extern "C" INT64 __stdcall ComPlusToComWorker(Thread *pThread, ComPlusMethodFrame* pFrame);

extern "C" DWORD __stdcall GetSpecificCpuType();

void *GetWrapCallFunctionReturn();



//**********************************************************************
// This structure captures the format of the METHOD_PREPAD area (behind
// the MethodDesc.)
//**********************************************************************
#pragma pack(push,1)

struct StubCallInstrs
{
    UINT64  m_Fill1;    // we have two instruction bundles (256 bits) here
    UINT64  m_Fill2;    // ...
    UINT64  m_Fill3;    // ...
    UINT64  m_Fill4;    // ...
};

#pragma pack(pop)


#define METHOD_PREPAD                       32  // # extra bytes to allocate in addition to sizeof(Method)
#define METHOD_CALL_PRESTUB_SIZE            32  // IA64: two full bundles
#define METHOD_ALIGN                        16  // required alignment for StubCallInstrs

#define JUMP_ALLOCATE_SIZE                  32  // # bytes to allocate for a jump instrucation
#define METHOD_DESC_CHUNK_ALIGNPAD_BYTES    12  // # bytes required to pad MethodDescChunk to correct size

//**********************************************************************
// Parameter size
//**********************************************************************

typedef INT64 StackElemType;
#define STACK_ELEM_SIZE sizeof(StackElemType)


// !! This expression assumes STACK_ELEM_SIZE is a power of 2.
#define StackElemSize(parmSize) (((parmSize) + STACK_ELEM_SIZE - 1) & ~((ULONG)(STACK_ELEM_SIZE - 1)))

// Get address of actual arg within widened arg
#define ArgTypeAddr(stack, type)      ((type *) ((BYTE*)stack + StackElemSize(sizeof(type)) - sizeof(type)))

// Get value of actual arg within widened arg
#define ExtractArg(stack, type)   (*(type *) ((BYTE*)stack + StackElemSize(sizeof(type)) - sizeof(type)))

#define CEE_PARM_SIZE(size) (max(size), sizeof(INT32))
#define CEE_SLOT_COUNT(size) ((max(size), sizeof(INT32))/INT32)

#define DECLARE_ECALL_DEFAULT_ARG(vartype, varname)   \
    vartype varname;

#define DECLARE_ECALL_OBJECTREF_ARG(vartype, varname)   \
    DECLARE_ECALL_DEFAULT_ARG(vartype, varname);

#define DECLARE_ECALL_PTR_ARG(vartype, varname)   \
    DECLARE_ECALL_DEFAULT_ARG(vartype, varname);

#define DECLARE_ECALL_I1_ARG(vartype, varname)   \
    DECLARE_ECALL_DEFAULT_ARG(vartype, varname);

#define DECLARE_ECALL_I2_ARG(vartype, varname)   \
    vartype varname;

#define DECLARE_ECALL_I4_ARG(vartype, varname)   \
    DECLARE_ECALL_DEFAULT_ARG(vartype, varname);

#define DECLARE_ECALL_R4_ARG(vartype, varname)   \
    DECLARE_ECALL_DEFAULT_ARG(vartype, varname);

#define DECLARE_ECALL_I8_ARG(vartype, varname)   \
    DECLARE_ECALL_DEFAULT_ARG(vartype, varname);

#define DECLARE_ECALL_R8_ARG(vartype, varname)   \
    DECLARE_ECALL_DEFAULT_ARG(vartype, varname);

inline BYTE *getStubCallAddr(MethodDesc *fd) 
{
    return ((BYTE*)fd) - METHOD_CALL_PRESTUB_SIZE;
}

inline BYTE *getStubCallTargetAddr(MethodDesc *fd) {
    return (BYTE*)((size_t)(*(UINT32*)((size_t)fd - 1)) + (size_t)fd);
}

inline void setStubCallTargetAddr(MethodDesc *fd, const BYTE *addr) {
    FastInterlockExchange((LONG*)fd - 1, (UINT32)((size_t)addr - (size_t)fd));
}

inline BYTE *getStubCallAddr(BYTE *pBuf) 
{
    return pBuf;   // we currently don't have any padding prior to the call
}

inline BYTE *getStubJumpAddr(BYTE *pBuf) 
{
    return pBuf;   // we currently don't have any padding prior to the jump
}

//**********************************************************************
// Frames
//**********************************************************************
//--------------------------------------------------------------------
// This represents some of the TransitionFrame fields that are
// stored at negative offsets.
//--------------------------------------------------------------------
struct CalleeSavedRegisters {
    INT32       edi;
    INT32       esi;
    INT32       ebx;
    INT32       ebp;
};

//--------------------------------------------------------------------
// This represents the arguments that are stored in volatile registers.
// This should not overlap the CalleeSavedRegisters since those are already
// saved separately and it would be wasteful to save the same register twice.
// If we do use a non-volatile register as an argument, then the ArgIterator
// will probably have to communicate this back to the PromoteCallerStack
// routine to avoid a double promotion.
//
// @todo M6: It's silly for a method that has <N arguments to save N
// registers. A good perf item would be for the frame to save only
// the registers it actually needs. This means that NegSpaceSize()
// becomes a function of the callsig.
//--------------------------------------------------------------------
struct ArgumentRegisters {

#define DEFINE_ARGUMENT_REGISTER_BACKWARD(regname)  INT32 regname;
#include "eecallconv.h"

};

// Sufficient context for Try/Catch restoration.
struct EHContext {
    INT32       Eax;
    INT32       Ebx;
    INT32       Ecx;
    INT32       Edx;
    INT32       Esi;
    INT32       Edi;
    INT32       Ebp;
    INT32       Esp;
    INT32       Eip;
};

#define ARGUMENTREGISTERS_SIZE sizeof(ArgumentRegisters)


#define PLATFORM_FRAME_ALIGN(val) (val)

#ifdef _DEBUG

//-----------------------------------------------------------------------
// Under DEBUG, stubs push 8 additional bytes of info in order to
// allow the VC debugger to stacktrace through stubs. This info
// is pushed right after the callee-saved-registers. The stubs
// also must keep ebp pointed to this structure. Note that this
// precludes the use of ebp by the stub itself.
//-----------------------------------------------------------------------
struct VC5Frame
{
    INT32      m_savedebp;
    INT32      m_returnaddress;
};
#define VC5FRAME_SIZE   sizeof(VC5Frame)
#else
#define VC5FRAME_SIZE   0
#endif




#define DECLARE_PLATFORM_FRAME_INFO \
    UINT32      m_eip;              \
    UINT32      m_esp;              \
    UINT32 *getIPSaveAddr() {       \
        return &m_eip;              \
    }                               \
    UINT32 *getSPSaveAddr() {       \
        return &m_esp;              \
    }                               \
    UINT32 getIPSaveVal() {         \
        return m_eip;               \
    }                               \
    UINT32 getSPSaveVal() {         \
        return m_esp;               \
    }

//**********************************************************************
// Exception handling
//**********************************************************************

inline LPVOID GetIP(CONTEXT *context) {
    _ASSERTE(!"@TODO IA64 - GetIP (cGenCpu.h)");
    return NULL;
}

inline void SetIP(CONTEXT *context, LPVOID eip) {
    _ASSERTE(!"@TODO IA64 - SetIP (cGenCpu.h)");
}

#define GetSP(oldSP)         \
{                            \
    _ASSERTE(!"@TODO IA64 - GetSP (cGenCpu.h)"); \
}

#define SetSP(newSP)         \
{                            \
    _ASSERTE(!"@TODO IA64 - SetSP (cGenCpu.h)"); \
}

inline void EncodeNopMovlBundle(BYTE* pBuffer, DWORD nRegDest, UINT64 imm64)
{
    //
    // predication not currently supported 
    // (qp hardcoded to 0)
    // (vc hardcoded to 0)
    //

    //
    // Encodes:
    //
    // nop.m
    // movl  nRegDest = imm64 ;;
    //

    UINT64 temp1, temp2, temp3;

    temp3 = nRegDest;

    temp2  = 0x6000000000000000;        // 4 op
    temp2 |= (imm64 >> 63)      << 59;  // 1 i
    temp2 |= (imm64 & 0xFF80)   << 43;  // 9 imm9d
    temp2 |= (imm64 & 0x1F0000) << 29;  // 5 imm5c
    temp2 |= (imm64 & 0x200000) << 23;  // 1 ic                     (vc hardcoded to 0)
    temp2 |= (imm64 & 0x7F)     << 36;  // 7 imm7b
    temp2 |= (temp3 & 0x7F)     << 29;  // 7 r1                     (qp hardcoded to 0)
    temp2 |= (imm64 <<  1)      >> 41;  // 23 high bits of imm41    (qp hardcoded to 0)
    temp1  = (imm64 >> 22)      << 46;  // 18 low bits of imm41
    temp1 |= 0x0100000005;              // nop.m 0x0

    ((UINT64*)pBuffer)[0] = temp1;
    ((UINT64*)pBuffer)[1] = temp2;
}

//
// Note: the debugger relies on the fact that the stub call is a CALL NEAR32
// with an opcode of 0xe8. See Debug\CorDB\Inprocess.cpp, function
// CorDBIsStubCall.
//
// -- mikemag Sun Jun 28 17:48:42 1998
//
inline void emitStubCall(MethodDesc *pFD, BYTE *stubAddr) {
    BYTE *target = getStubCallAddr(pFD);

    _ASSERTE((((UINT_PTR)target) & 0xF) == 0);    // must be 16-byte aligned

    // nop.m  0x0
    // movl   r8 = stubAddr
    EncodeNopMovlBundle(target, 8, (UINT64)stubAddr);

    // 11 00 00 00 01 00 10 40 04 80 03 00 18 00 80 10
    // nop.m                0x0
    // mov                  b1 = r8
    // br.call.sptk.many    rp = b1 ;;
    ((UINT64*)target)[2] = 0x4010000100000011;
    ((UINT64*)target)[3] = 0x1080001800038004;
}

inline UINT32 getStubDisp(MethodDesc *fd) {
    return *( ((UINT32*)fd)-1);
}


inline void emitCall(LPBYTE pBuffer, LPVOID target)
{
    pBuffer[0] = 0xe8; //CALLNEAR32
    *((LPVOID*)(1+pBuffer)) = (LPVOID) (((LPBYTE)target) - (pBuffer+5));
}

inline LPVOID getCallTarget(const BYTE *pCall)
{
    _ASSERTE(pCall[0] == 0xe8);
    return (LPVOID) (pCall + 5 + *((UINT32*)(1 + pCall)));
}

inline void emitJump(LPBYTE pBuffer, LPVOID target)
{
    pBuffer[0] = 0xe9; //JUMPNEAR32
    *((LPVOID*)(1+pBuffer)) = (LPVOID) (((LPBYTE)target) - (pBuffer+5));
}

inline void updateJumpTarget(LPBYTE pBuffer, LPVOID target)
{
    pBuffer[0] = 0xe9; //JUMPNEAR32
    InterlockedExchange((long*)(1+pBuffer), (DWORD) (((LPBYTE)target) - (pBuffer+5)));
}

inline LPVOID getJumpTarget(const BYTE *pJump)
{
    _ASSERTE(pJump[0] == 0xe9);
    return (LPVOID) (pJump + 5 + *((UINT32*)(1 + pJump)));
}

inline SLOT setCallAddrInterlocked(SLOT *callAddr, SLOT stubAddr, 
									 SLOT expectedStubAddr)
{
	  SLOT result = (SLOT)
	  FastInterlockCompareExchange((void **) callAddr, 
								   (void *)(stubAddr - ((SIZE_T)callAddr + sizeof(SLOT))), 
								   (void *)(expectedStubAddr - ((SIZE_T)callAddr + sizeof(SLOT)))) 
	  + (SIZE_T)callAddr + sizeof(SLOT);

	// result is the previous value of the stub - 
	// instead return the current value of the stub

	if (result == expectedStubAddr)
		return stubAddr;
	else
		return result;
}

inline Stub *setStubCallPointInterlocked(MethodDesc *pFD, Stub *pStub, 
										 Stub *pExpectedStub) {
    // The offset must be 32-bit aligned for atomicity to be guaranteed.
    _ASSERTE( 0 == (((size_t)pFD) & 3) );

	SLOT stubAddr = (SLOT)pStub->GetEntryPoint();
	SLOT expectedStubAddr = (SLOT)pExpectedStub->GetEntryPoint();

	SLOT newStubAddr = setCallAddrInterlocked((SLOT *)(((long*)pFD)-1), 
											  stubAddr, expectedStubAddr);

	if (newStubAddr == stubAddr)
		 return pStub;
	else
		 return Stub::RecoverStub((BYTE *) newStubAddr);
}

inline const BYTE *getStubAddr(MethodDesc *fd) {
    return (const BYTE *)(getStubDisp(fd) + (UINT32)fd);
}

//----------------------------------------------------------
// Marshalling Language support
//----------------------------------------------------------
typedef INT32 SignedParmSourceType;
typedef UINT32 UnsignedParmSourceType;
typedef float FloatParmSourceType;
typedef double DoubleParmSourceType;
typedef INT32 SignedI1TargetType;
typedef UINT32 UnsignedI1TargetType;
typedef INT32 SignedI2TargetType;
typedef UINT32 UnsignedI2TargetType;
typedef INT32 SignedI4TargetType;
typedef UINT32 UnsignedI4TargetType;


#define PTRDST(type)            ((type*)( ((BYTE*&)pdst) -= sizeof(LPVOID) ))

#define STDST(type,val)         (*((type*)( ((BYTE*&)pdst) -= sizeof(type) )) = (val))

#define STPTRDST(type, val)     STDST(type, val)
#define LDSTR4()                STDST(UINT32, (UINT32)LDSRC(UnsignedParmSourceType))
#define LDSTR8()                STDST(UNALIGNED UINT64, LDSRC(UNALIGNED UINT64))

	// This instruction API meaning is do whatever is needed to 
	// when you want to indicate to the CPU that your are busy waiting
	// (this is a good time for this CPU to give up any resources that other
	// processors might put to good use).   On many machines this is a nop.
inline void pause()
{
}

inline MLParmSize(int parmSize)
{
    return max(sizeof(INT32), parmSize);
}


inline void setFPReturn(int fpSize, INT64 retVal)
{
    _ASSERTE(!"@TODO IA64 - setFPReturn (cGenCpu.h)");
}

inline void getFPReturn(int fpSize, INT64 &retval)
{
    _ASSERTE(!"@TODO IA64 - getFPReturn (cGenCpu.h)");
}

inline void getFPReturnSmall(INT32 *retval)
{
    _ASSERTE(!"@TODO IA64 - getFPReturnSmall (cGenCpu.h)");
}

//----------------------------------------------------------------------
// Encodes X86 registers. The numbers are chosen to match Intel's opcode
// encoding.
//----------------------------------------------------------------------
enum X86Reg {
    kEAX = 0,
    kECX = 1,
    kEDX = 2,
    kEBX = 3,
    // kESP intentionally omitted because of its irregular treatment in MOD/RM
    kEBP = 5,
    kESI = 6,
    kEDI = 7

};


// Get X86Reg indexes of argument registers (indices start from 0).
X86Reg GetX86ArgumentRegister(unsigned int index);



//----------------------------------------------------------------------
// Encodes X86 conditional jumps. The numbers are chosen to match
// Intel's opcode encoding.
//----------------------------------------------------------------------
class X86CondCode {
    public:
        enum cc {
            kJA   = 0x7,
            kJAE  = 0x3,
            kJB   = 0x2,
            kJBE  = 0x6,
            kJC   = 0x2,
            kJE   = 0x4,
            kJZ   = 0x4,
            kJG   = 0xf,
            kJGE  = 0xd,
            kJL   = 0xc,
            kJLE  = 0xe,
            kJNA  = 0x6,
            kJNAE = 0x2,
            kJNB  = 0x3,
            kJNBE = 0x7,
            kJNC  = 0x3,
            kJNE  = 0x5,
            kJNG  = 0xe,
            kJNGE = 0xc,
            kJNL  = 0xd,
            kJNLE = 0xf,
            kJNO  = 0x1,
            kJNP  = 0xb,
            kJNS  = 0x9,
            kJNZ  = 0x5,
            kJO   = 0x0,
            kJP   = 0xa,
            kJPE  = 0xa,
            kJPO  = 0xb,
            kJS   = 0x8,
        };
};


//----------------------------------------------------------------------
// StubLinker with extensions for generating X86 code.
//----------------------------------------------------------------------
class StubLinkerCPU : public StubLinker
{
    public:
        VOID EmitAddReg(X86Reg reg, __int8 imm8);
        VOID EmitSubReg(X86Reg reg, __int8 imm8);
        VOID EmitPushReg(X86Reg reg);
        VOID EmitPopReg(X86Reg reg);
        VOID EmitPushImm32(UINT value);
        VOID EmitPushImm8(BYTE value);
        VOID EmitZeroOutReg(X86Reg reg);
        VOID EmitNearJump(CodeLabel *pTarget);
        VOID EmitCondJump(CodeLabel *pTarget, X86CondCode::cc condcode);
        VOID EmitCall(CodeLabel *target, int iArgBytes, BOOL returnLabel = FALSE);
        VOID EmitReturn(int iArgBytes);
        VOID EmitCurrentThreadFetch();
        VOID EmitSetupThread();
        VOID EmitIndexRegLoad(X86Reg dstreg, X86Reg srcreg, __int32 ofs);
        VOID EmitIndexRegStore(X86Reg dstreg, __int32 ofs, X86Reg srcreg);
        VOID EmitIndexPush(X86Reg srcreg, __int32 ofs);
        VOID EmitSPIndexPush(__int8 ofs);
        VOID EmitIndexPop(X86Reg srcreg, __int32 ofs);
        VOID EmitSubEsp(INT32 imm32);
        VOID EmitAddEsp(INT32 imm32);
        VOID EmitOffsetModRM(BYTE opcode, X86Reg altreg, X86Reg indexreg, __int32 ofs);
        VOID EmitEspOffset(BYTE opcode, X86Reg altreg, __int32 ofs);

        // These are used to emit calls to notify the profiler of transitions in and out of
        // managed code through COM->COM+ interop
        VOID EmitProfilerComCallProlog(PVOID pFrameVptr, X86Reg regFrame);
        VOID EmitProfilerComCallEpilog(PVOID pFrameVptr, X86Reg regFrame);



        // Emits the most efficient form of the operation:
        //
        //    opcode   altreg, [basereg + scaledreg*scale + ofs]
        //
        // or
        //
        //    opcode   [basereg + scaledreg*scale + ofs], altreg
        //
        // (the opcode determines which comes first.)
        //
        //
        // Limitations:
        //
        //    scale must be 0,1,2,4 or 8.
        //    if scale == 0, scaledreg is ignored.
        //    basereg and altreg may be equal to 4 (ESP) but scaledreg cannot
        //    for some opcodes, "altreg" may actually select an operation
        //      rather than a second register argument.
        //    

        VOID EmitOp(BYTE    opcode,
                    X86Reg  altreg,
                    X86Reg  basereg,
                    __int32 ofs = 0,
                    X86Reg  scaledreg = (X86Reg)0,
                    BYTE    scale = 0
                    );


        // Emits
        //
        //    opcode altreg, modrmreg
        //
        // or
        //
        //    opcode modrmreg, altreg
        //
        // (the opcode determines which one comes first)
        //
        // For single-operand opcodes, "altreg" actually selects
        // an operation rather than a register.

        VOID EmitR2ROp(BYTE opcode, X86Reg altreg, X86Reg modrmreg);



        VOID EmitEnable(CodeLabel *pForwardRef);
        VOID EmitRareEnable(CodeLabel *pRejoinPoint);

        VOID EmitDisable(CodeLabel *pForwardRef);
        VOID EmitRareDisable(CodeLabel *pRejoinPoint);

        VOID EmitSetup(CodeLabel *pForwardRef);
        VOID EmitRareSetup(CodeLabel* pRejoinPoint);

        void EmitComMethodStubProlog(LPVOID pFrameVptr, CodeLabel** rgRareLabels,
                                    CodeLabel** rgRejoinLabels, LPVOID pSEHHAndler);

        void EmitEnterManagedStubEpilog(unsigned numStackBytes,
                    CodeLabel** rgRareLabels, CodeLabel** rgRejoinLabels);

        void EmitComMethodStubEpilog(unsigned numStackBytes,
                            CodeLabel** rgRareLabels, CodeLabel** rgRejoinLabels,
                            LPVOID pSEHHAndler, BOOL bShouldProfile);

        //========================================================================
        //  void StubLinkerCPU::EmitSEHProlog(LPVOID pvFrameHandler)
        //  Prolog for setting up SEH for stubs that enter managed code from unmanaged
        //  assumptions: esi has the current frame pointer
        void StubLinkerCPU::EmitSEHProlog(LPVOID pvFrameHandler);

        //===========================================================================
        //  void StubLinkerCPU::EmitUnLinkSEH(unsigned offset)
        //  negOffset is the offset from the current frame where the next exception record
        //  pointer is stored in the stack
        //  for e.g. COM to managed frames the pointer to next SEH record is in the stack
        //          after the ComMethodFrame::NegSpaceSize() + 4 ( address of handler)
        //
        //  also assumes ESI is pointing to the current frame
        void StubLinkerCPU::EmitUnLinkSEH(unsigned offset);

        VOID EmitMethodStubProlog(LPVOID pFrameVptr);
        VOID EmitMethodStubEpilog(__int16 numArgBytes, StubStyle style,
                                  __int16 shadowStackArgBytes = 0);

        VOID EmitUnboxMethodStub(MethodDesc* pRealMD);

        //----------------------------------------------------------------
        //
        // VOID EmitSharedMethodStubEpilog(StubStyle style,
        //                                             unsigned offsetRetThunk)
        //      shared epilog, uses a return thunk within the methoddesc
        //--------------------------------------------------------------------
        VOID EmitSharedMethodStubEpilog(StubStyle style,
                                               unsigned offsetRetThunk);

        //========================================================================
        //  shared Epilog for stubs that enter managed code from COM
        //  uses a return thunk within the method desc
        void EmitSharedComMethodStubEpilog(LPVOID pFrameVptr,
                                           CodeLabel** rgRareLabels,
                                           CodeLabel** rgRejoinLabels,
                                           unsigned offsetReturnThunk,
                                           BOOL bShouldProfile);

        //===========================================================================
        // Emits code to repush the original arguments in the virtual calling
        // convention format.
        VOID EmitShadowStack(FramedMethodFrame *pFrame);

        VOID EmitSecurityWrapperStub(__int16 numArgBytes, MethodDesc* pMD, BOOL fToStub, LPVOID pRealStub, DeclActionInfo *pActions);
        VOID EmitSecurityInterceptorStub(__int16 numArgBytes, MethodDesc* pMD, BOOL fToStub, LPVOID pRealStub, DeclActionInfo *pActions);

        //===========================================================================
        // Emits code for MulticastDelegate.Invoke()
        VOID EmitMulticastInvoke(UINT32 sizeofactualfixedargstack, BOOL fSingleCast, BOOL fReturnFloat);

        //===========================================================================
        // Emits code to adjust for a static delegate target.
        VOID EmitShuffleThunk(struct ShuffleEntry *pShuffeEntryArray);

        //===========================================================================
        // Emits code to capture the lasterror code.
        VOID EmitSaveLastError();


        //===========================================================================
        // Emits code to do an array operation.
        VOID EmitArrayOpStub(const ArrayOpScript*);

        //===========================================================================
        // Emits code to throw a rank exception
        VOID EmitRankExceptionThrowStub(UINT cbFixedArgs);

        //===========================================================================
        // Emits code to touch pages
        // Inputs:
        //   eax = first byte of data
        //   edx = first byte past end of data
        //
        // Trashes eax, edx, ecx
        //
        // Pass TRUE if edx is guaranteed to be strictly greater than eax.
        VOID EmitPageTouch(BOOL fSkipNullCheck);


#ifdef _DEBUG
        VOID EmitDebugTrashReg(X86Reg reg);
#endif
    private:
        VOID EmitSubEspWorker(INT32 imm32);


};






#ifdef _DEBUG
//-------------------------------------------------------------------------
// This is a helper function that stubs in DEBUG go through to call
// outside code. This is only there to provide a code section return
// address because VC's stack tracing breaks otherwise.
//
// WARNING: Trashes ESI. This is not a C-callable function.
//-------------------------------------------------------------------------
VOID WrapCall(LPVOID pFunc);
#endif

//
// Routines used by debugger support functions such as codepatch.cpp or
// exception handling code.
//
// GetInstruction, InsertBreakpoint, and SetInstruction all operate on
// a _single_ byte of memory. This is really important. If you only
// save one byte from the instruction stream before placing a breakpoint,
// you need to make sure to only replace one byte later on.
//

inline DWORD CORDbgGetInstruction(const unsigned char* address)
{
    return *address; // retrieving only one byte is important
}

inline void CORDbgInsertBreakpoint(const unsigned char* address)
{
    *((unsigned char*)address) = 0xCC; // int 3 (single byte patch)
}

inline void CORDbgSetInstruction(const unsigned char* address,
                                 DWORD instruction)
{
    *((unsigned char*)address)
          = (unsigned char) instruction; // setting one byte is important
}

inline void CORDbgAdjustPCForBreakInstruction(CONTEXT* pContext)
{
    _ASSERTE(!"@TODO IA64 - CORDbgAdjustPCForBreakInstruction (cGenCpu.h)");
}

#define CORDbg_BREAK_INSTRUCTION_SIZE 1


// Some platform-specific stuff in support of the "Contexts" feature:
//
// When we generate thunks for CtxProxy VTables, they look like:
//
//             MOV   EAX, <slot>
//             JMP   CtxProxy::HandleCall
//
#define ThunkChunk_ThunkSize    10      // size of the above code


// Adjust the generic interlocked operations for any platform specific ones we
// might have.
void InitFastInterlockOps();



// SEH info forward declarations

typedef struct _EXCEPTION_REGISTRATION_RECORD {
    struct _EXCEPTION_REGISTRATION_RECORD *Next;
    LPVOID Handler;
} EXCEPTION_REGISTRATION_RECORD;

typedef EXCEPTION_REGISTRATION_RECORD *PEXCEPTION_REGISTRATION_RECORD;

struct ComToManagedExRecord; // defined in cgencpu.cpp
// one of the internal exception SEH handlers
EXCEPTION_DISPOSITION __cdecl  ComToManagedExceptHandler (
                                 PEXCEPTION_RECORD pExcepRecord,
                                  ComToManagedExRecord* pEstFrame,
                                  PCONTEXT pContext,
                                  LPVOID    pDispatcherContext);

// Access to the TEB (TIB) from nti386.h
#if defined(MIDL_PASS) || !defined(_M_IX86)
// _inline struct _TEB * NtCurrentTeb( void ) {};
#else
#pragma warning (disable:4035)        // disable 4035 (function must return something)
#define PcTeb 0x18
_inline struct _TEB * NtCurrentTeb( void ) {_ASSERTE(!"@TODO IA64 - NtCurrentTeb (cGenCpu.h)");}
#pragma warning (default:4035)        // reenable it
#endif // defined(MIDL_PASS) || defined(__cplusplus) || !defined(_M_IX86)


inline BOOL IsUnmanagedValueTypeReturnedByRef(UINT sizeofvaluetype) 
{
	return sizeofvaluetype > 8;
}

inline BOOL IsManagedValueTypeReturnedByRef(UINT sizeofvaluetype) 
{
	return TRUE;
}


#endif // __cgencpu_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\ia64\getgp.s ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==

.text
.proc GetGp
.type   GetGp, @function
.global GetGp
.align 32


GetGp:
    mov     ret0 = gp
    br.ret.sptk.few  rp

.endp GetGp
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\ia64\excepcpu.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*  EXCEP.CPP:
 *
 */

#include "common.h"

#include "tls.h"
#include "frames.h"
#include "threads.h"
#include "excep.h"
#include "object.h"
#include "COMString.h"
#include "field.h"
#include "DbgInterface.h"
#include "cgensys.h"
#include "gcscan.h"
#include "comutilnative.h"
#include "comsystem.h"
#include "commember.h"
#include "SigFormat.h"
#include "siginfo.hpp"
#include "gc.h"
#include "EEDbgInterfaceImpl.h" //so we can clearexception in COMPlusThrow
#include "PerfCounters.h"


LPVOID GetCurrentSEHRecord();
BOOL ComPlusStubSEH(EXCEPTION_REGISTRATION_RECORD*);


VOID PopFpuStack()
{
}


VOID ResetCurrentContext()
{
    _ASSERTE(!"Platform NYI");
}


//
// Link in a new frame
//
void FaultingExceptionFrame::InitAndLink(DWORD esp, CalleeSavedRegisters* pRegs, LPVOID eip)
{
    *GetCalleeSavedRegisters() = *pRegs;
    m_ReturnAddress = eip;
    _ASSERTE(!"NYI");
    Push();
}

void InitSavedRegs(CalleeSavedRegisters *pReg, CONTEXT *pContext)
{
    _ASSERTE(!"Platform NYI");
}


// call unwind in a function with try so that when returns, registers will be restored before
// returning back to caller. Otherwise could lose regs.
BOOL CallRtlUnwind(EXCEPTION_REGISTRATION_RECORD *pEstablisherFrame, void *callback, EXCEPTION_RECORD *pExceptionRecord, void *retVal)
{
    _ASSERTE(!"@TODO IA64 - CallRtlUnwind (Excep.cpp)");
    return FALSE;
}

UnmanagedToManagedCallFrame* GetCurrFrame(ComToManagedExRecord *);

Frame *GetCurrFrame(EXCEPTION_REGISTRATION_RECORD *pEstablisherFrame)
{
    _ASSERTE(!"NYI");
    return NULL;
}


//-------------------------------------------------------------------------
// This is called by the EE to restore the stack pointer if necessary. No other
// cleanup can be performed here becuase this could be no-oped if the stack
// does not need to be preserved.
//-------------------------------------------------------------------------

DWORD COMPlusEndCatch( Thread *pCurThread, CONTEXT *pCtx, void *pSEH)
{
    _ASSERTE(!"@TODO IA64 - COMPlusEndCatch (Excep.cpp)");
    return 0;
}


//-------------------------------------------------------------------------
// This is the filter that handles exceptions raised in the context of a
// COMPLUS_TRY. It will be called if the COMPlusFrameHandler can't find a 
// handler in the IL.
//-------------------------------------------------------------------------
LONG COMPlusFilter(const EXCEPTION_POINTERS *pExceptionPointers, DWORD fCatchFlag)
{
    _ASSERTE(!"@TODO IA64 - COMPlusFilter (Excep.cpp)");
    return EXCEPTION_EXECUTE_HANDLER;
}


// all other architectures, we don't have custom SEH yet
BOOL ComPlusStubSEH(EXCEPTION_REGISTRATION_RECORD* pEHR)
{

    return FALSE;
}


#pragma warning (disable : 4035)
LPVOID GetCurrentSEHRecord()
{
    _ASSERTE(!"@TODO IA64 - GetCurrentSEHRecord (Excep.cpp)");
    return NULL;
}
#pragma warning (default : 4035)


VOID SetCurrentSEHRecord(LPVOID pSEH)
{
    _ASSERTE(!"@TODO IA64 - SetCurrentSEHRecord (Excep.cpp)");
}


//==========================================================================
// COMPlusThrowCallback
// 
//  IsInTryCatchFinally blatantly copied a subset of COMPlusThrowCallback - 
//  please change IsInTryCatchFinally if COMPlusThrowCallback changes.
//==========================================================================

StackWalkAction COMPlusThrowCallback (CrawlFrame *pCf, ThrowCallbackType *pData)
{
    _ASSERTE(!"@TODO IA64 - COMPlusThrowCallback (ExcepCpu.cpp)");
    return SWA_CONTINUE;
}


//==========================================================================
// COMPlusUnwindCallback
//==========================================================================

StackWalkAction COMPlusUnwindCallback (CrawlFrame *pCf, ThrowCallbackType *pData)
{
    _ASSERTE(!"@TODO IA64 - COMPlusUnwindCallback (ExcepCpu.cpp)");
    return SWA_CONTINUE;
}


void CallJitEHFinally(CrawlFrame* pCf, BYTE* startPC, BYTE* resumePC, DWORD nestingLevel)
{
    _ASSERTE(!"@TODO IA64 - CallJitEHFinally (Excep.cpp)");
}



EXCEPTION_DISPOSITION __cdecl ContextTransitionFrameHandler(EXCEPTION_RECORD *pExceptionRecord, 
                         EXCEPTION_REGISTRATION_RECORD *pEstablisherFrame,
                         CONTEXT *pContext,
                         void *DispatcherContext)
{
	_ASSERTE(!"NYI");
    return ExceptionContinueSearch;
}


//-------------------------------------------------------------------------
// This is the first handler that is called iin the context of a
// COMPLUS_TRY. It is the first level of defense and tries to find a handler
// in the user code to handle the exception
//-------------------------------------------------------------------------
EXCEPTION_DISPOSITION __cdecl COMPlusFrameHandler(EXCEPTION_RECORD *pExceptionRecord, 
                         EXCEPTION_REGISTRATION_RECORD *pEstablisherFrame,
                         CONTEXT *pContext,
                         void *pDispatcherContext)
{
	_ASSERTE(!"NYI");
    return ExceptionContinueSearch;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\ia64\excepcpu.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
// EXCEPX86.H -
//
// This header file is optionally included from Excep.h if the target platform is x86
//

#ifndef __excepx86_h__
#define __excepx86_h__

#include "CorError.h"  // HResults for the COM+ Runtime

#include "..\\dlls\\mscorrc\\resource.h"

// Insert a handler that will catch any exceptions prior to the COMPLUS_TRY handler and attempt
// to find a user-level handler first. In debug build, actualRecord will skip past stack overwrite
// barrier and in retail build it will be same as exRecord.
#define InsertCOMPlusFrameHandler(exRecord)                                 \
    {                                                                   \
        /*_ASSERTE(!"@TODO_IA64 - InsertCOMPlusFrameHandler (ExcepCpu.h)");*/   \
    }

// Remove the handler from the list. 
#define RemoveCOMPlusFrameHandler(exRecord)                                     \
    {                                                                           \
        /*_ASSERTE(!"@TODO_IA64 - RemoveCOMPlusFrameHandler (ExcepCpu.h)");*/   \
    }


// stackOverwriteBarrier is used to detect overwriting of stack which will mess up handler registration
#if defined(_DEBUG) && defined(_MSC_VER)
#define COMPLUS_TRY_DECLARE_EH_RECORD() \
    FrameHandlerExRecordWithBarrier *___pExRecord = (FrameHandlerExRecordWithBarrier *)_alloca(sizeof(FrameHandlerExRecordWithBarrier)); \
                    for (int ___i =0; ___i < STACK_OVERWRITE_BARRIER_SIZE; ___i++) \
                        ___pExRecord->m_StackOverwriteBarrier[___i] = STACK_OVERWRITE_BARRIER_VALUE; \
                    ___pExRecord->m_pNext = 0; \
                    ___pExRecord->m_pvFrameHandler = COMPlusFrameHandler; \
                    ___pExRecord->m_pEntryFrame = ___pCurThread->GetFrame();

#define COMPLUS_TRY_DEBUGVARS     \
                    LPVOID ___pPreviousSEH = 0; \
                    __int32 ___iPreviousTryLevel = 0; \


#define COMPLUS_TRY_DEBUGCHECKS()

#if 0
                    ___pPreviousSEH = ___pCurThread->GetComPlusTryEntrySEHRecord();     \
                    ___pCurThread->SetComPlusTryEntrySEHRecord(GetCurrentSEHRecord());         \
                    ___iPreviousTryLevel = ___pCurThread->GetComPlusTryEntryTryLevel(); \
                    ___pCurThread->SetComPlusTryEntryTryLevel( *((__int32*) (((LPBYTE)(GetCurrentSEHRecord())) + MSC_TRYLEVEL_OFFSET) ) );
#endif

#define COMPLUS_CATCH_DEBUGCHECKS()                                                     \
                     ___pCurThread->SetComPlusTryEntrySEHRecord(___pPreviousSEH);       \
                     ___pCurThread->SetComPlusTryEntryTryLevel (___iPreviousTryLevel);       

#define MSC_TRYLEVEL_OFFSET                     12

#else
#define COMPLUS_TRY_DECLARE_EH_RECORD() \
                    FrameHandlerExRecord *___pExRecord = (FrameHandlerExRecord *)_alloca(sizeof(FrameHandlerExRecord)); \
                    ___pExRecord->m_pNext = 0; \
                    ___pExRecord->m_pvFrameHandler = COMPlusFrameHandler; \
                    ___pExRecord->m_pEntryFrame = ___pCurThread->GetFrame(); 

#define COMPLUS_TRY_DEBUGCHECKS()
#define COMPLUS_TRY_DEBUGVARS    
#define COMPLUS_CATCH_DEBUGCHECKS()
#endif

LPVOID GetCurrentSEHRecord();

// Determine the address of the instruction that made the current call. For X86, pass
// esp where it contains the return address and will adjust back 5 bytes for the call
inline
DWORD GetAdjustedCallAddress(DWORD* esp)
{
    return (*esp - 5);
}

#define INSTALL_EXCEPTION_HANDLING_FUNCTION(handler)            \
  {                                                             \
    _ASSERTE(!"NYI");                                           \

#define UNINSTALL_EXCEPTION_HANDLING_FUNCTION                   \
    _ASSERTE(!"NYI");                                           \
  }                                                             \
 
#define INSTALL_EXCEPTION_HANDLING_RECORD(record)               \
    _ASSERTE(!"NYI");                                           \

#define UNINSTALL_EXCEPTION_HANDLING_RECORD(record)             \
    _ASSERTE(!"NYI");                                           \

#define INSTALL_FRAME_HANDLING_FUNCTION(handler, frame_addr)    \
    _ASSERTE(!"NYI");                                           \

#define UNINSTALL_FRAME_HANDLING_FUNCTION                       \
    _ASSERTE(!"NYI");                                           \
 

#endif // __excepx86_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\ia64\cgencpu.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
// cGenCpu.CPP -
//
// Various helper routines for generating IA64 assembly code.
//
//

// Precompiled Header
#include "common.h"

#ifdef _IA64_
#include "stublink.h"
#include "cgensys.h"
#include "siginfo.hpp"
#include "excep.h"
#include "ecall.h"
#include "ndirect.h"
#include "compluscall.h"
#include "DbgInterface.h"
#include "COMObject.h"
#include "fcall.h"

static const int numRegArgs = 6;    // number of args passed in registers, rest on stack
static const int regSize = sizeof(INT64);


DWORD __stdcall GetSpecificCpuType()
{
    return 0;   // for now indicate this is a non-x86 cpu this could be enhanced later
}


void CopyPreStubTemplate(Stub *preStub)
{
    _ASSERTE(!"@TODO IA64 - CopyPreStubTemplate (cGenCpu.cpp)");
}

INT64 CallDescr(const BYTE *pTarget, const BYTE *pShortSig, BOOL fIsStatic, const __int64 *pArguments)
{
    _ASSERTE(!"@TODO IA64 - CallDescr (cGenCpu.cpp)");
    return 0;
}

INT64 __cdecl CallWorker_WilDefault(const BYTE  *pStubTarget, // [ecx+4]
                                UINT32       numArgSlots,     // [ecx+8]
                                PCCOR_SIGNATURE  pSig,        // [ecx+12]
                                Module      *pModule,         // [ecx+16]
                                const BYTE  *pArgsEnd,        // [ecx+20]
                                BOOL         fIsStatic)       // [ecx+24]
{
    _ASSERTE(!"@TODO IA64 - CallWorker_WilDefault (cGenCPU.cpp)");
    return 0;
}





// ************************************************************************************************************
// StubLinker code
// ************************************************************************************************************

//-----------------------------------------------------------------------
// InstructionFormat for load register with 32-bit value.
//-----------------------------------------------------------------------
class IA64LoadPV : public InstructionFormat
{
    public:
        IA64LoadPV(UINT allowedSizes) : InstructionFormat(allowedSizes)
        {}

        virtual UINT GetSizeOfInstruction(UINT refsize, UINT variationCode)
        {
            return 8;
        }

        virtual VOID EmitInstruction(UINT refsize, __int64 fixedUpReference, BYTE *pOutBuffer, UINT variationCode, BYTE *pDataBuffer)
        {
            _ASSERTE(!"@TODO IA64 - EmitInstruction");
        }


};

// @TODO handle disp <=  23 bits
static IA64LoadPV   gIA64LoadPV(InstructionFormat::k32);

//---------------------------------------------------------------
// Emits:
//    call <ofs32>
//---------------------------------------------------------------
/*
    If you make any changes to the prolog instruction sequence, be sure
    to update UpdateRegdisplay, too!!
*/

static const int regSaveSize = 6*regSize;

VOID StubLinkerCPU::EmitMethodStubProlog(LPVOID pFrameVptr)
{
    _ASSERTE(!"@TODO IA64 - StubLinkerCPU::EmitMethodStubProlog (cGenCpu.cpp)");
}

VOID StubLinkerCPU::EmitMethodStubEpilog(__int16 numArgBytes, StubStyle style,
                                           __int16 shadowStackArgBytes)
{
    _ASSERTE(!"@TODO IA64 - StubLinkerCPU::EmitMethodStubEpilog (cGenCpu.cpp)");
}

// This method unboxes the THIS pointer and then calls pRealMD
VOID StubLinkerCPU::EmitUnboxMethodStub(MethodDesc* pUnboxMD)
{
    _ASSERTE(!"@TODO IA64 - StubLinkerCPU::EmitUnboxMethodStub(cgencpu.cpp)");
}

//
// SecurityWrapper
//
// Wraps a real stub do some security work before the stub and clean up after. Before the
// real stub is called a security frame is added and declarative checks are performed. The
// Frame is added so declarative asserts and denies can be maintained for the duration of the
// real call. At the end the frame is simply removed and the wrapper cleans up the stack. The
// registers are restored.
//
VOID StubLinkerCPU::EmitSecurityWrapperStub(__int16 numArgBytes, MethodDesc* pMD, BOOL fToStub, LPVOID pRealStub, DeclActionInfo *pActions)
{
    _ASSERTE(!"@TODO IA64 - EmitSecurityWrapperStub (cGenCpu.cpp)");
}

//
// Security Filter, if no security frame is required because there are no declarative asserts or denies
// then the arguments do not have to be copied. This interceptor creates a temporary Security frame
// calls the declarative security return, cleans up the stack to the same state when the inteceptor
// was called and jumps into the real routine.
//
VOID EmitSecurityInterceptorStub(__int16 numArgBytes, MethodDesc* pMD, BOOL fToStub, LPVOID pRealStub, DeclActionInfo *pActions)
{
    _ASSERTE(!"@TODO IA64 - EmtiSecurityInterceptorStub (cGenCpu.cpp)");
}

//----------------------------------------------------------------
//
// VOID StubLinkerCPU::EmitSharedMethodStubEpilog(StubStyle style,
//                                                  unsigned offsetRetThunk)
//              shared epilog, uses a return thunk within the methoddesc
//--------------------------------------------------------------------
VOID StubLinkerCPU::EmitSharedMethodStubEpilog(StubStyle style,
                                                 unsigned offsetRetThunk)
{
    _ASSERTE(!"@TODO IA64 - StubLinkerCPU::EmitSharedMethodStubEpilog(cGenCpu.cpp)");
}


//----------------------------------------------------
//
// Interpreter Call
//
//----------------------------------------------------

/*VOID StubLinkerCPU::EmitInterpretedMethodStub(__int16 numArgBytes, StubStyle style)
{
    THROWSCOMPLUSEXCEPTION();

    EmitMethodStubProlog(InterpretedMethodFrame::GetMethodFrameVPtr());

    UINT16 negspacesize = InterpretedMethodFrame::GetNegSpaceSize() -
                          TransitionFrame::GetNegSpaceSize();

        // must be aligned to 16-byte
        _ASSERTE(! (negspacesize % 16));

    // make room for negspace fields of IFrame
    // lda sp, -negspacesize(sp)
    IA64EmitMemoryInstruction(opLDA, iSP, iSP, -negspacesize);

    // pass addr of frame in a0
    // lda a0, (s1)
    IA64EmitMemoryInstruction(opLDA, iA0, iS1, 0);

    IA64EmitLoadPV(NewExternalCodeLabel(InterpretedMethodStubWorker));
#ifdef _DEBUG
    // call WrapCall to maintain VC stack tracing
    IA64EmitMemoryInstruction(opLDA, iT11, iPV, 0);
    IA64EmitLoadPV(NewExternalCodeLabel(WrapCall));
#endif
    IA64EmitMemoryInstruction(opJSR, iRA, iPV, 0x4001); // use disp of 4001 for procedure jump
    // deallocate negspace fields of IFrame
    // lda sp, negspacesize(sp)
    IA64EmitMemoryInstruction(opLDA, iSP, iSP, negspacesize);

    EmitMethodStubEpilog(numArgBytes, style);
}*/

// This hack handles arguments as an array of __int64's
INT64 MethodDesc::CallDescr(const BYTE *pTarget, Module *pModule, PCCOR_SIGNATURE pSig, BOOL fIsStatic, const __int64 *pArguments)
{
    MetaSig sig(pSig, pModule);
    return MethodDesc::CallDescr (pTarget, pModule, &sig, fIsStatic, pArguments);
}

INT64 MethodDesc::CallDescr(const BYTE *pTarget, Module *pModule, MetaSig* pMetaSig, BOOL fIsStatic, const __int64 *pArguments)
{
    THROWSCOMPLUSEXCEPTION();
    BYTE callingconvention = pMetaSig->GetCallingConvention();
    if (!isCallConv(callingconvention, IMAGE_CEE_CS_CALLCONV_DEFAULT))
    {
        _ASSERTE(!"This calling convention is not supported.");
        COMPlusThrow(kInvalidProgramException);
    }

#ifdef DEBUGGING_SUPPORTED
    if (CORDebuggerTraceCall())
        g_pDebugInterface->TraceCall(pTarget);
#endif // DEBUGGING_SUPPORTED

    DWORD   NumArguments = pMetaSig->NumFixedArgs();
        DWORD   arg = 0;

    UINT   nActualStackBytes = pMetaSig->SizeOfActualFixedArgStack(fIsStatic);

    // Create a fake FramedMethodFrame on the stack.
    LPBYTE pAlloc = (LPBYTE)_alloca(FramedMethodFrame::GetNegSpaceSize() + sizeof(FramedMethodFrame) + nActualStackBytes);

    LPBYTE pFrameBase = pAlloc + FramedMethodFrame::GetNegSpaceSize();

    if (!fIsStatic) {
        *((void**)(pFrameBase + FramedMethodFrame::GetOffsetOfThis())) = *((void **)&pArguments[arg++]);
    }

    UINT   nVirtualStackBytes = pMetaSig->SizeOfVirtualFixedArgStack(fIsStatic);
    arg += NumArguments;

    ArgIterator argit(pFrameBase, pMetaSig, fIsStatic);
    if (pMetaSig->HasRetBuffArg()) {
                _ASSERTE(!"NYI");
    }

    BYTE   typ;
    UINT32 structSize;
    int    ofs;
    while (0 != (ofs = argit.GetNextOffsetFaster(&typ, &structSize))) {
                arg--;
        switch (StackElemSize(structSize)) {
            case 4:
                *((INT32*)(pFrameBase + ofs)) = *((INT32*)&pArguments[arg]);
                break;

            case 8:
                *((INT64*)(pFrameBase + ofs)) = pArguments[arg];
                break;

            default: {
                // Not defined how to spread a valueclass into 64-bit buckets!
                _ASSERTE(!"NYI");
            }

        }
    }
    INT64 retval;

#ifdef _DEBUG
// Save a copy of dangerousObjRefs in table.
    Thread* curThread = 0;
    unsigned ObjRefTable[OBJREF_TABSIZE];

    if (GetThread)
        curThread = GetThread();

    if (curThread)
        memcpy(ObjRefTable, curThread->dangerousObjRefs,
               sizeof(curThread->dangerousObjRefs));
#endif

    INSTALL_COMPLUS_EXCEPTION_HANDLER();
    retval = CallDescrWorker(pFrameBase + sizeof(FramedMethodFrame) + nActualStackBytes,
                             nActualStackBytes / STACK_ELEM_SIZE,
                             (ArgumentRegisters*)(pFrameBase + FramedMethodFrame::GetOffsetOfArgumentRegisters()),
                             (LPVOID)pTarget);
    UNINSTALL_COMPLUS_EXCEPTION_HANDLER();

#ifdef _DEBUG
// Restore dangerousObjRefs when we return back to EE after call
    if (curThread)
        memcpy(curThread->dangerousObjRefs, ObjRefTable,
               sizeof(curThread->dangerousObjRefs));
#endif

    getFPReturn(pMetaSig->GetFPReturnSize(), retval);
    return retval;

}


#ifdef _DEBUG
void Frame::CheckExitFrameDebuggerCalls()
{
    _ASSERTE(!"@TODO IA64 - CheckExitFrameDebuggerCalls (cGenCpu.cpp)");
}
#endif // _DEBUG


//----------------------------------------------------
//
// ECall
//
//----------------------------------------------------

//----------------------------------------------------
//
// NDirect
//
//----------------------------------------------------

UINT NDirect::GetCallDllFunctionReturnOffset()
{
    _ASSERTE(!"@TODO IA64 - GetCallDllFunctionReturnOffset (cGenCpu.cpp)");
    return 0;
}

/*static*/ void NDirect::CreateGenericNDirectStubSys(CPUSTUBLINKER *psl)
{
    _ASSERTE(!"@TODO IA64 - NDirect::CreateGenericNDirectStubSys (cGenCpu.cpp)");
}

void TransitionFrame::UpdateRegDisplay(const PREGDISPLAY pRD) {
        _ASSERTE(!"@TODO IA64 - TransitionFrame::UpdateRegDisplay (cGenCpu.cpp)");
}
void InlinedCallFrame::UpdateRegDisplay(const PREGDISPLAY pRD) {
        _ASSERTE(!"@TODO IA64 - InlinedCallFrame::UpdateRegDisplay (cGenCpu.cpp)");
}
void HelperMethodFrame::UpdateRegDisplay(const PREGDISPLAY pRD) {
        _ASSERTE(!"@TODO IA64 - HelperMethodFrame::UpdateRegDisplay (cGenCpu.cpp)");
}

//----------------------------------------------------
//
// COM Interop
//
//----------------------------------------------------

/*static*/ void ComPlusCall::CreateGenericComPlusStubSys(CPUSTUBLINKER *psl)
{
    _ASSERTE(!"@TODO IA64 - CreateGenericComPlusStubSys (cGenCpu.cpp)");
}


LPVOID* ResumableFrame::GetReturnAddressPtr() { 
    _ASSERTE(!"@TODO IA64 - ResumableFrame::GetReturnAddressPtr (cGenCpu.cpp)");
    return NULL;
    // Should return the address of the instruction pointer in the Context
    // (m_Regs).  Something like ...
    //     return (LPVOID) &m_Regs->Eip;
}

LPVOID ResumableFrame::GetReturnAddress() { 
    _ASSERTE(!"@TODO IA64 - ResumableFrame::GetReturnAddress (cGenCpu.cpp)");
    return NULL;
    // Should return the instruction pointer from the Context (m_Regs).  Something
    // like ...
    //     return (LPVOID) m_Regs->Eip; 
}

void ResumableFrame::UpdateRegDisplay(const PREGDISPLAY pRD) {
    _ASSERTE(!"@TODO IA64 - ResumableFrame::UpdateRegDisplay (cGenCpu.cpp)");

    // Should set up pRD to point to registers in m_Regs.  Something like this
    // X86 code ...
#if 0
    pRD->pContext = NULL;

    pRD->pEdi = &m_Regs->Edi;
    pRD->pEsi = &m_Regs->Esi;
    pRD->pEbx = &m_Regs->Ebx;
    pRD->pEbp = &m_Regs->Ebp;
    pRD->pPC  = &m_Regs->Eip;
    pRD->Esp  = m_Regs->Esp;

    pRD->pEax = &m_Regs->Eax;
    pRD->pEcx = &m_Regs->Ecx;
    pRD->pEdx = &m_Regs->Edx;
#endif
}

void PInvokeCalliFrame::UpdateRegDisplay(const PREGDISPLAY pRD)
{
    _ASSERTE(!"@TODO IA64 - PInvokeCalliFrame::UpdateRegDisplay (cGenCpu.cpp)");
}

//void SetupSlotToAddrMap(StackElemType *psrc, const void **pArgSlotToAddrMap, CallSig &csig)
//{
//        BYTE n;
//    UINT32 argnum = 0;
//
//        while (IMAGE_CEE_CS_END != (n = csig.NextArg()))
//        {
//                switch (n)
//                {
//                        case IMAGE_CEE_CS_STRUCT4:  //fallthru
//                        case IMAGE_CEE_CS_STRUCT32:
//                        {
//                                // shouldn't get on IA64
//                                _ASSERTE(!"32 bit Structure found in slot");
//                                break;
//                        }
//                        default:
//                                psrc--;
//                                pArgSlotToAddrMap[argnum++] = psrc;
//                                break;
//                }
//        }
//}

extern "C" {

        PIMAGE_RUNTIME_FUNCTION_ENTRY
        RtlLookupFunctionEntry(
                ULONG ControlPC
                );

        ULONG
        RtlCaptureContext(
                CONTEXT *contextRecord
                );

        typedef struct _FRAME_POINTERS {
                ULONG VirtualFramePointer;
                ULONG RealFramePointer;
        } FRAME_POINTERS, *PFRAME_POINTERS;

        ULONG
        RtlVirtualUnwind (
                ULONG ControlPc,
                PIMAGE_RUNTIME_FUNCTION_ENTRY FunctionEntry,
                PCONTEXT ContextRecord,
                PBOOLEAN InFunction,
                PFRAME_POINTERS EstablisherFrame,
                PVOID ContextPointers OPTIONAL
                );
}

// The Generic (GN) versions.  For some, Win32 has versions which we can wire
// up to directly (like ::InterlockedIncrement).  For the rest:

void __fastcall OrMaskGN(DWORD * const p, const int msk)
{
    *p |= msk;
}

void __fastcall AndMaskGN(DWORD * const p, const int msk)
{
    *p &= msk;
}

LONG __fastcall ExchangeAddGN(LONG *Target, LONG Value)
{
    return ::InterlockedExchangeAdd(Target, Value);
}

LONG __fastcall InterlockExchangeGN(LONG * Target, LONG Value)
{
        return ::InterlockedExchange(Target, Value);
}

void * __fastcall InterlockCompareExchangeGN(void **Destination,
                                          void *Exchange,
                                          void *Comparand)
{
        return (void*)InterlockedCompareExchange((long*)Destination, (long)Exchange, (long)Comparand);
}

LONG __fastcall InterlockIncrementGN(LONG *Target)
{
        return ::InterlockedIncrement(Target);
}

LONG __fastcall InterlockDecrementGN(LONG *Target)
{
        return ::InterlockedDecrement(Target);
}


// Here's the support for the interlocked operations.  The external view of them is
// declared in util.hpp.

BitFieldOps FastInterlockOr = OrMaskGN;
BitFieldOps FastInterlockAnd = AndMaskGN;

XchgOps     FastInterlockExchange = InterlockExchangeGN;
CmpXchgOps  FastInterlockCompareExchange = InterlockCompareExchangeGN;
XchngAddOps FastInterlockExchangeAdd = ExchangeAddGN;

IncDecOps   FastInterlockIncrement = InterlockIncrementGN;
IncDecOps   FastInterlockDecrement = InterlockDecrementGN;

// Adjust the generic interlocked operations for any platform specific ones we
// might have.
void InitFastInterlockOps()
{
}

//---------------------------------------------------------
// Handles system specfic portion of fully optimized NDirect stub creation
//---------------------------------------------------------
/*static*/ BOOL NDirect::CreateStandaloneNDirectStubSys(const MLHeader *pheader, CPUSTUBLINKER *psl, BOOL fDoComInterop)
{
    _ASSERTE(!"@TODO IA64 - CreateStandaloneNDirectStubSys (cGenCpu.cpp)");
    return FALSE;
}

Stub* NDirect::CreateSlimNDirectStub(StubLinker *pstublinker, NDirectMethodDesc *pMD)
{
    return NULL;
}



//////////////////////////////////////////////////////////////////////////////
//
// JITInterface
//
//////////////////////////////////////////////////////////////////////////////

/*********************************************************************/
float __stdcall JIT_FltRem(float divisor, float dividend)
{
    if (!_finite(divisor) && !_isnan(divisor))    // is infinite
        return(dividend);       // return infinite
    return((float)fmod(dividend,divisor));
}

/*********************************************************************/
double __stdcall JIT_DblRem(double divisor, double dividend)
{
    if (!_finite(divisor) && !_isnan(divisor))    // is infinite
        return(dividend);       // return infinite
    return(fmod(dividend,divisor));
}

void ResumeAtJit(PCONTEXT pContext, LPVOID oldESP)
{
    _ASSERTE(!"@TODO IA64 - ResumeAtJit (cGenCpu.cpp)");
}

void ResumeAtJitEH(CrawlFrame* pCf, BYTE* startPC, BYTE* resumePC, DWORD nestingLevel, Thread *pThread, BOOL unwindStack)
{
    _ASSERTE(!"@TODO IA64 - ResumeAtJitEH (cGenCpu.cpp)");
}

int CallJitEHFilter(CrawlFrame* pCf, BYTE* startPC, BYTE* resumePC, DWORD nestingLevel, OBJECTREF thrownObj)
{
    _ASSERTE(!"@TODO IA64 - CallJitEHFilter (cGenCpu.cpp)");
    return 0;
}

//
// Security Filter, if no security frame is required because there are no declarative asserts or denies
// then the arguments do not have to be copied. This interceptor creates a temporary Security frame
// calls the declarative security return, cleans up the stack to the same state when the inteceptor
// was called and jumps into the real routine.
//
VOID StubLinkerCPU::EmitSecurityInterceptorStub(__int16 numArgBytes, MethodDesc* pMD, BOOL fToStub, LPVOID pRealStub, DeclActionInfo *pActions)
{
    _ASSERTE(!"@TODO IA64 - EmitSecurityInterceptorStub (cGenCpu.cpp)");
}

//===========================================================================
// Emits code to adjust for a static delegate target.
VOID StubLinkerCPU::EmitShuffleThunk(ShuffleEntry *pShuffleEntryArray)
{
    _ASSERTE(!"@TODO IA64 - EmitShuffleThunk (cGenCpu.cpp)");
}

//===========================================================================
// Emits code for MulticastDelegate.Invoke()
VOID StubLinkerCPU::EmitMulticastInvoke(UINT32 sizeofactualfixedargstack, BOOL fSingleCast, BOOL fReturnFloat)
{
    _ASSERTE(!"@TODO IA64 - EmitMulticastInvoke (cGenCpu.cpp)");
}

//----------------------------------------------------
//
// ECall
//
//----------------------------------------------------

/* static */
VOID ECall::EmitECallMethodStub(StubLinker *pstublinker, ECallMethodDesc *pMD, StubStyle style, PrestubMethodFrame *pPrestubMethodFrame)
{
    _ASSERTE(!"@TODO IA64 - EmitECallMethodStub (cGenCpu.cpp)");
}

//===========================================================================
// Emits code to do an array operation.
VOID StubLinkerCPU::EmitArrayOpStub(const ArrayOpScript* pArrayOpScript)
{
    _ASSERTE(!"@TODO IA64 - StubLinkerCPU::EmitArrayOpStub (cGenCpu.cpp)");
}


size_t GetL2CacheSize()
{
    return 0;
}

// This method will return a Class object for the object
//  iff the Class object has already been created.  
//  If the Class object doesn't exist then you must call the GetClass() method.
FCIMPL1(LPVOID, ObjectNative::FastGetClass, Object* thisRef) {

    if (thisRef == NULL)
        FCThrow(kNullReferenceException);

    
    EEClass* pClass = thisRef->GetTrueMethodTable()->m_pEEClass;

    // For marshalbyref classes, let's just punt for the moment
    if (pClass->IsMarshaledByRef())
        return 0;

    OBJECTREF refClass;
    if (pClass->IsArrayClass()) {
        // This code is essentially a duplicate of the code in GetClass, done for perf reasons.
        ArrayBase* array = (ArrayBase*) OBJECTREFToObject(thisRef);
        TypeHandle arrayType;
        // Erect a GC Frame around the call to GetTypeHandle, since on the first call,
        // it can call AppDomain::RaiseTypeResolveEvent, which allocates Strings and calls
        // a user-provided managed callback.  Yes, we have to do an allocation to do a
        // lookup, since TypeHandles are used as keys.  Yes this sucks.  -- BrianGru, 9/12/2000
        HELPER_METHOD_FRAME_BEGIN_RET();
        arrayType = array->GetTypeHandle();
        refClass = COMClass::QuickLookupExistingArrayClassObj(arrayType.AsArray());
        HELPER_METHOD_FRAME_END();
    }
    else 
        refClass = pClass->GetExistingExposedClassObject();
    return OBJECTREFToObject(refClass);
}
FCIMPLEND

#endif // _IA64_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\ia64\jitinterfacecpu.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
// ===========================================================================
// File: JITinterfaceCpu.CPP
//
// ===========================================================================

// This contains JITinterface routines that are specific to the
// IA64 platform. They are modeled after the X86 specific routines
// found in JITinterfaceX86.cpp or JIThelp.asm

#include "common.h"
#include "JITInterface.h"
#include "EEConfig.h"
#include "excep.h"
#include "COMString.h"
#include "COMDelegate.h"
#include "remoting.h" // create context bound and remote class instances
#include "field.h"

extern "C"
{
    void __stdcall JIT_IsInstanceOfClassHelper();
    VMHELPDEF hlpFuncTable[];
    VMHELPDEF utilFuncTable[];
}


//------------------------------------------------------------------
// CORINFO_HELP_ARRADDR_ST helper
//------------------------------------------------------------------
BOOL _cdecl ComplexArrayStoreCheck(Object *pElement, PtrArray *pArray);
void JIT_SetObjectArrayMaker::CreateWorker(CPUSTUBLINKER *psl)
{
    THROWSCOMPLUSEXCEPTION();
    _ASSERTE(!"NYI");
}


/*********************************************************************/
//llshl - long shift left
//
//Purpose:
//   Does a Long Shift Left (signed and unsigned are identical)
//   Shifts a long left any number of bits.
//
//       NOTE:  This routine has been adapted from the Microsoft CRTs.
//
//Entry:
//   EDX:EAX - long value to be shifted
//       ECX     - number of bits to shift by
//
//Exit:
//   EDX:EAX - shifted value
//
//Uses:
//       ECX is destroyed.
//
//Exceptions:
//
// Notes:
//

extern "C" __int64 __stdcall JIT_LLsh(void)   // val = EDX:EAX  count = ECX
{
    _ASSERTE(!"Not Implemented");
    return 0;
}

/*********************************************************************/
//LRsh - long shift right
//
//Purpose:
//   Does a signed Long Shift Right
//   Shifts a long right any number of bits.
//
//       NOTE:  This routine has been adapted from the Microsoft CRTs.
//
//Entry:
//   EDX:EAX - long value to be shifted
//       ECX     - number of bits to shift by
//
//Exit:
//   EDX:EAX - shifted value
//
//Uses:
//       ECX is destroyed.
//
//Exceptions:
//
// Notes:
//
//
extern "C" __int64 __stdcall JIT_LRsh(void)   // val = EDX:EAX  count = ECX
{
    _ASSERTE(!"@TODO IA64 - JIT_LRsh (JITinterface.cpp)");
    return 0;
}

/*********************************************************************/
// LRsz:
//Purpose:
//   Does a unsigned Long Shift Right
//   Shifts a long right any number of bits.
//
//       NOTE:  This routine has been adapted from the Microsoft CRTs.
//
//Entry:
//   EDX:EAX - long value to be shifted
//       ECX     - number of bits to shift by
//
//Exit:
//   EDX:EAX - shifted value
//
//Uses:
//       ECX is destroyed.
//
//Exceptions:
//
// Notes:
//
//
extern "C" __int64 __stdcall JIT_LRsz(void)   // val = EDX:EAX  count = ECX
{
    _ASSERTE(!"@TODO IA64 - JIT_LRsz (JITinterface.cpp)");
    return 0;
}


// This is a high performance type checking routine.  It takes the instance
// to check in ARGUMENT_REG2 and the class to check for in ARGUMENT_REG1.  The
// class must be a class, not an array or interface.

extern "C" BOOL __stdcall JIT_IsInstanceOfClass()
{
    _ASSERTE(!"@TODO IA64 - JIT_IsInstanceOfClass (JITinterface.cpp)");
    return FALSE;
}


extern "C" int __stdcall JIT_ChkCastClass()
{
    _ASSERTE(!"@TODO IA64 - JIT_ChkCastClass (JITinterface.cpp)");
    return E_FAIL;
}


/*********************************************************************/
// This is the small write barrier thunk we use when we know the
// ephemeral generation is higher in memory than older generations.
// The 0x0F0F0F0F values are bashed by the two functions above.
extern "C" void JIT_UP_WriteBarrierReg_PreGrow()
{
    _ASSERTE(!"@TODO IA64 - JIT_UP_WriteBarrierReg_PreGrow (JITinterface.cpp)");
}


/*********************************************************************/
// This is the small write barrier thunk we use when we know the
// ephemeral generation not is higher in memory than older generations.
// The 0x0F0F0F0F values are bashed by the two functions above.
extern "C" void JIT_UP_WriteBarrierReg_PostGrow()
{
    _ASSERTE(!"@TODO IA64 - JIT_UP_WriteBarrierReg_PostGrow (JITinterface.cpp)");
}


extern "C" void __stdcall JIT_TailCall()
{
    _ASSERTE(!"@TODO IA64 - JIT_TailCall (JITinterface.cpp)");
}


void __stdcall JIT_EndCatch()
{
    _ASSERTE(!"@TODO IA64 - JIT_EndCatch (JITinterface.cpp)");
}


struct TailCallArgs
{
    DWORD       dwRetAddr;
    DWORD       dwTargetAddr;

    int         offsetCalleeSavedRegs   : 28;
    unsigned    ebpRelCalleeSavedRegs   : 1;
    unsigned    maskCalleeSavedRegs     : 3; // EBX, ESDI, EDI

    DWORD       nNewStackArgs;
    DWORD       nOldStackArgs;
    DWORD       newStackArgs[0];
    DWORD *     GetCalleeSavedRegs(DWORD * Ebp)
    {
        _ASSERTE(!"@TODO IA64 - GetCalleSavedRegs (JITinterfaceCpu.cpp)");
//        if (ebpRelCalleeSavedRegs)
//            return (DWORD*)&Ebp[-offsetCalleeSavedRegs];
//        else
            // @TODO : Doesnt work with localloc
//            return (DWORD*)&newStackArgs[nNewStackArgs + offsetCalleeSavedRegs];
    }
};

extern "C" void __cdecl JIT_TailCallHelper(ArgumentRegisters argRegs, 
                                           MachState machState, TailCallArgs * args)
{
    _ASSERTE(!"@TODO IA64 - JIT_TailCallHelper (JITinterface.cpp)");
}

extern "C" void JIT_UP_ByRefWriteBarrier()
{
    _ASSERTE(!"@TODO IA64 - JIT_UP_ByRefWriteBarrier (JITinterface.cpp)");
}

extern "C" void __stdcall JIT_UP_CheckedWriteBarrierEAX() // JIThelp.asm/JIThelp.s
{
    _ASSERTE(!"@TODO IA64 - JIT_UP_CheckedWriteBarrierEAX (JITinterface.cpp)");
}

extern "C" void __stdcall JIT_UP_CheckedWriteBarrierEBX() // JIThelp.asm/JIThelp.s
{
    _ASSERTE(!"@TODO IA64 - JIT_UP_CheckedWriteBarrierEBX (JITinterface.cpp)");
}

extern "C" void __stdcall JIT_UP_CheckedWriteBarrierECX() // JIThelp.asm/JIThelp.s
{
    _ASSERTE(!"@TODO IA64 - JIT_UP_CheckedWriteBarrierECX (JITinterface.cpp)");
}

extern "C" void __stdcall JIT_UP_CheckedWriteBarrierESI() // JIThelp.asm/JIThelp.s
{
    _ASSERTE(!"@TODO IA64 - JIT_UP_CheckedWriteBarrierESI (JITinterface.cpp)");
}

extern "C" void __stdcall JIT_UP_CheckedWriteBarrierEDI() // JIThelp.asm/JIThelp.s
{
    _ASSERTE(!"@TODO IA64 - JIT_UP_CheckedWriteBarrierEDI (JITinterface.cpp)");
}

extern "C" void __stdcall JIT_UP_CheckedWriteBarrierEBP() // JIThelp.asm/JIThelp.s
{
    _ASSERTE(!"@TODO IA64 - JIT_UP_CheckedWriteBarrierEBP (JITinterface.cpp)");
}

extern "C" void __stdcall JIT_UP_WriteBarrierEBX()        // JIThelp.asm/JIThelp.s
{
    _ASSERTE(!"@TODO IA64 - JIT_UP_WriteBarrierEBX (JITinterface.cpp)");
}

extern "C" void __stdcall JIT_UP_WriteBarrierECX()        // JIThelp.asm/JIThelp.s
{
    _ASSERTE(!"@TODO IA64 - JIT_UP_WriteBarrierECX (JITinterface.cpp)");
}

extern "C" void __stdcall JIT_UP_WriteBarrierESI()        // JIThelp.asm/JIThelp.s
{
    _ASSERTE(!"@TODO IA64 - JIT_UP_WriteBarrierESI (JITinterface.cpp)");
}

extern "C" void __stdcall JIT_UP_WriteBarrierEDI()        // JIThelp.asm/JIThelp.s
{
    _ASSERTE(!"@TODO IA64 - JIT_UP_WriteBarrierEDI (JITinterface.cpp)");
}

extern "C" void __stdcall JIT_UP_WriteBarrierEBP()        // JIThelp.asm/JIThelp.s
{
    _ASSERTE(!"@TODO IA64 - JIT_UP_WriteBarrierEBP (JITinterface.cpp)");
}

extern "C" int  __stdcall JIT_ChkCast()                   // JITInterfaceX86.cpp, etc.
{
    _ASSERTE(!"@TODO IA64 - JIT_ChkCast (JITinterface.cpp)");
    return 0;
}

/*__declspec(naked)*/ void __fastcall JIT_Stelem_Ref(PtrArray* array, unsigned idx, Object* val)
{
    _ASSERTE(!"@TODO IA64 - JIT_Stelem_Ref (JITinterface.cpp)");
}

void *JIT_TrialAlloc::GenAllocArray(Flags flags)
{
    _ASSERTE(!"@TODO IA64 - JIT_TrialAlloc::GenAllocArray (JITinterface.cpp)");
    return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\ia64\remotingcpu.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*===========================================================================
**
** File:    RemotingCpu.cpp
**
** Author(s):   Gopal Kakivaya  (GopalK)
**              Tarun Anand     (TarunA)     
**              Matt Smith      (MattSmit)
**              Manish Prabhu   (MPrabhu)
**
** Purpose: Defines various remoting related functions for the IA64 architecture
**
** Date:    Oct 12, 1999
**
=============================================================================*/

#include "common.h"
#include "excep.h"
#include "COMString.h"
#include "COMDelegate.h"
#include "remoting.h"
#include "reflectwrap.h"
#include "field.h"
#include "ComCallWrapper.h"
#include "siginfo.hpp"
#include "COMClass.h"
#include "StackBuilderSink.h"
#include "wsperf.h"
#include "threads.h"
#include "method.hpp"
#include "ComponentServices.h"

// External variables
extern size_t g_dwTPStubAddr;
extern DWORD g_dwNonVirtualThunkRemotingLabelOffset;
extern DWORD g_dwNonVirtualThunkReCheckLabelOffset;

//+----------------------------------------------------------------------------
//
//  Method:     CRemotingServices::CheckForContextMatch   public
//
//  Synopsis:   This code generates a check to see if the current context and
//              the context of the proxy match.
//
//  History:    26-Jun-99   TarunA      Created
//
//+----------------------------------------------------------------------------
void CRemotingServices::CheckForContextMatch()
{
    _ASSERTE(!"@TODO IA64 - CheckForContextMatch (RemotingCpu.cpp)");
}


//+----------------------------------------------------------------------------
//
//  Method:     ComponentServices::CheckForOle32Context   private
//
//  Synopsis:   Compares the current com context with the given com context (non NT5 platforms)
//              
//
//  History:    26-Jun-99   TarunA      Created
//
//+----------------------------------------------------------------------------
void ComponentServices::CheckForOle32Context()
{
    _ASSERTE(!"@TODO IA64 - CheckForOle32Context (RemotingCpu.cpp)");
}


//+----------------------------------------------------------------------------
//
//  Method:     CRemotingServices::GenerateCheckForProxy   public
//
//  Synopsis:   This code generates a check to see if the "this" pointer
//              is a proxy. If so, the interface invoke is handled via
//              the CRemotingServices::DispatchInterfaceCall else we 
//              delegate to the old path
//
//  History:    26-Jun-99   TarunA      Created
//
//+----------------------------------------------------------------------------
void CRemotingServices::GenerateCheckForProxy(CPUSTUBLINKER* psl)
{
    _ASSERTE(!"@TODO IA64 - GenerateCheckForProxy (RemotingCpu.cpp)");
}


//+----------------------------------------------------------------------------
//
//  Method:     CRemotingServices::DispatchInterfaceCall   public
//
//  Synopsis:   
//              Push that method desc on the stack and jump to the 
//              transparent proxy stub to execute the call.
//              WARNING!! This MethodDesc is not the methoddesc in the vtable
//              of the object instead it is the methoddesc in the vtable of
//              the interface class. Since we use the MethodDesc only to probe
//              the stack via the signature of the method call we are safe.
//              If we want to get any object vtable/class specific 
//              information this is not safe.
//              
//
//  History:    26-Jun-99   TarunA      Created
//
//+----------------------------------------------------------------------------
void __stdcall CRemotingServices::DispatchInterfaceCall(MethodDesc* pMD)
{
    _ASSERTE(!"@TODO IA64 - DispatchInterfaceCall (RemotingCpu.cpp)");
} 

//+----------------------------------------------------------------------------
//
//  Method:     CRemotingServices::CallFieldGetter   private
//
//  Synopsis:   Calls the field getter function (Object::__FieldGetter) in 
//              managed code by setting up the stack and calling the target
//              
//
//  History:    26-Jun-99   TarunA      Created
//
//+----------------------------------------------------------------------------
void __stdcall CRemotingServices::CallFieldGetter(	MethodDesc *pMD, 
                                                    LPVOID pThis,                                                                     
                                                    LPVOID pFirst,
                                                    LPVOID pSecond,
                                                    LPVOID pThird
                                                    )
{
    _ASSERTE(!"@TODO IA64 - CallFieldGetter (RemotingCpu.cpp)");
}

//+----------------------------------------------------------------------------
//
//  Method:     CRemotingServices::CallFieldSetter   private
//
//  Synopsis:   Calls the field setter function (Object::__FieldSetter) in 
//              managed code by setting up the stack and calling the target
//              
//
//  History:    26-Jun-99   TarunA      Created
//
//+----------------------------------------------------------------------------
void __stdcall CRemotingServices::CallFieldSetter(	MethodDesc *pMD, 
                                                    LPVOID pThis,                                                                     
                                                    LPVOID pFirst,
                                                    LPVOID pSecond,
                                                    LPVOID pThird
                                                    )
{
    _ASSERTE(!"@TODO IA64 - CallFieldSetter (RemotingCpu.cpp)");
}

//+----------------------------------------------------------------------------
//
//  Method:     CTPMethodTable::CreateThunkForVirtualMethod   private
//
//  Synopsis:   Creates the thunk that pushes the supplied slot number and jumps
//              to TP Stub
//
//  History:    17-Feb-99   Gopalk      Created
//
//+----------------------------------------------------------------------------
void CTPMethodTable::CreateThunkForVirtualMethod(DWORD dwSlot, BYTE *bCode)
{
    _ASSERTE(!"@TODO IA64 - CreateThunkForVirtualMethod (RemotingCpu.cpp)");
}

//+----------------------------------------------------------------------------
//
//  Method:     CTPMethodTable::CreateStubForNonVirtualMethod   public
//
//  Synopsis:   Create a stub for a non virtual method
//                            
//  History:    22-Mar-00   Rajak      Created
//
//+----------------------------------------------------------------------------

Stub* CTPMethodTable::CreateStubForNonVirtualMethod(MethodDesc* pMD, CPUSTUBLINKER* psl, 
                                            LPVOID pvAddrOfCode, Stub* pInnerStub)
{
    _ASSERTE(!"@TODO IA64 - CreateStubForNonVirtualMethod (RemotingCpu.cpp)");
    return NULL;
}


//+----------------------------------------------------------------------------
//
//  Synopsis:   Find an existing thunk or create a new one for the given 
//              method descriptor. NOTE: This is used for the methods that do 
//              not go through the vtable such as constructors, private and 
//              final methods.
//                            
//  History:    26-Jun-99   TarunA      Created
//
//+----------------------------------------------------------------------------
LPVOID CTPMethodTable::GetOrCreateNonVirtualThunkForVirtualMethod(MethodDesc* pMD, CPUSTUBLINKER* psl)
{       
    _ASSERTE(!"@TODO IA64 - GetOrCreateNonVirtualThunkForVirtualMethod (RemotingCpu.cpp)");
    return NULL;
}


//+----------------------------------------------------------------------------
//
//  Method:     CTPMethodTable::CreateTPStub   private
//
//  Synopsis:   Creates the stub that sets up a CtxCrossingFrame and forwards the
//              call to
//
//  History:    17-Feb-99   Gopalk      Created
//
//+----------------------------------------------------------------------------
CPUSTUBLINKER *CTPMethodTable::NewStubLinker()
{
    return new CPUSTUBLINKER();
}

//+----------------------------------------------------------------------------
//
//  Method:     ComponentServices::EmitCheckForOle32ContextNT5   private
//
//  Synopsis:   Compares the current com context with the given com context 
//              (NT5 platforms, slightly faster than non NT5 platforms)
//              
//
//  History:    26-Jun-99   TarunA      Created
//
//+----------------------------------------------------------------------------
Stub *ComponentServices::EmitCheckForOle32ContextOnNT5()
{
    return NULL;
}


Stub *CTPMethodTable::CreateTPStub()
{
    THROWSCOMPLUSEXCEPTION();

    CPUSTUBLINKER *pStubLinker = NULL;

    EE_TRY_FOR_FINALLY
    {
        // BUGBUG: Assert that the lock is held

        if (s_pTPStub == NULL)
        {
            pStubLinker = NewStubLinker();
            CodeLabel *ConvMD = pStubLinker->NewCodeLabel();
            CodeLabel *UseCode = pStubLinker->NewCodeLabel();
            CodeLabel *OOContext = pStubLinker->NewCodeLabel();

            if (! pStubLinker)
            {
                COMPlusThrowOM();
            }
            _ASSERTE(!"@TODO IA64 - CreateTPStub (RemotingCpu.cpp)");
        }

        if(NULL != s_pTPStub)
        {
            // Initialize the stub manager which will aid the debugger in finding
            // the actual address of a call made through the vtable
            // BUGBUG: This function can throw
            CVirtualThunkMgr::InitVirtualThunkManager((const BYTE *) s_pTPStub->GetEntryPoint());
    
        }        
    }
    EE_FINALLY
    {
        // Cleanup
        if (pStubLinker)
            delete pStubLinker;
    }EE_END_FINALLY;

        
    return(s_pTPStub);
}

//+----------------------------------------------------------------------------
//
//  Method:     CTPMethodTable::CreateDelegateStub   private
//
//  Synopsis:   Creates the stub that sets up a CtxCrossingFrame and forwards the
//              call to PreCall
//
//  History:    26-Jun-00   TarunA      Created
//
//+----------------------------------------------------------------------------
Stub *CTPMethodTable::CreateDelegateStub()
{
    THROWSCOMPLUSEXCEPTION();

    CPUSTUBLINKER *pStubLinker = NULL;

    EE_TRY_FOR_FINALLY
    {
        // BUGBUG: Assert that the lock is held

        if (s_pDelegateStub == NULL)
        {
            pStubLinker = NewStubLinker();

	        if (!pStubLinker)
            {
                COMPlusThrowOM();
            }

            // Setup the frame
            EmitSetupFrameCode(pStubLinker);

            s_pDelegateStub = pStubLinker->Link();
        }
    }
    EE_FINALLY
    {
        // Cleanup
        if (pStubLinker)
            delete pStubLinker;
    }EE_END_FINALLY;

        
    return(s_pDelegateStub);
}

//+----------------------------------------------------------------------------
//
//  Method:     CTPMethodTable::EmitSetupFrameCode   private
//
//  Synopsis:   Emits the code to setup a frame and call to PreCall method
//              call to PreCall
//
//  History:    26-Jun-00   TarunA      Created
//
//+----------------------------------------------------------------------------
VOID CTPMethodTable::EmitSetupFrameCode(CPUSTUBLINKER *pStubLinker)
{
    _ASSERTE(!"@TODO IA64 - EmitSetupFrameCode (RemotingCpu.cpp)");
}

//+----------------------------------------------------------------------------
//
//  Method:     CTPMethodTable::CallTarget   private
//
//  Synopsis:   Calls the target method on the given object
//
//  History:    17-Feb-99   Gopalk      Created
//
//+----------------------------------------------------------------------------
INT64 __stdcall CTPMethodTable::CallTarget(const void *pTarget,
                                           LPVOID pvFirst,
                                           LPVOID pvSecond)
{
    _ASSERTE(!"@TODO IA64 - CallTarget (RemotingCpu.cpp)");
    return 0;
}

//+----------------------------------------------------------------------------
//
//  Method:     CTPMethodTable::CallTarget   private
//
//  Synopsis:   Calls the target method on the given object
//
//  History:    17-Feb-99   Gopalk      Created
//
//+----------------------------------------------------------------------------
INT64 __stdcall CTPMethodTable::CallTarget(const void *pTarget,
                                           LPVOID pvFirst,
                                           LPVOID pvSecond,
                                           LPVOID pvThird)
{
    _ASSERTE(!"@TODO IA64 - CallTarget (RemotingCpu.cpp)");
    return 0;
}

//+----------------------------------------------------------------------------
//
//  Method:     CVirtualThunkMgr::DoTraceStub   public
//
//  Synopsis:   Traces the stub given the starting address
//
//  History:    26-Jun-99   TarunA      Created
//
//+----------------------------------------------------------------------------
BOOL CVirtualThunkMgr::DoTraceStub(const BYTE *stubStartAddress, TraceDestination *trace)
{
    BOOL bIsStub = FALSE;

    // Find a thunk whose code address matching the starting address
    LPBYTE pThunk = FindThunk(stubStartAddress);
    if(NULL != pThunk)
    {
        LPBYTE pbAddr = NULL;
        LONG destAddress = 0;
        if(stubStartAddress == pThunk)
        {

            // Extract the long which gives the self relative address
            // of the destination
            pbAddr = pThunk + ConstStubLabel + sizeof(BYTE);
            destAddress = *(LONG *)pbAddr;

            // Calculate the absolute address by adding the offset of the next 
            // instruction after the call instruction
            destAddress += (LONG)(pbAddr + sizeof(LONG));

        }

        // We cannot tell where the stub will end up until OnCall is reached.
        // So we tell the debugger to run till OnCall is reached and then 
        // come back and ask us again for the actual destination address of 
        // the call
    
        Stub *stub = Stub::RecoverStub((BYTE *)destAddress);
    
        trace->type = TRACE_FRAME_PUSH;
        trace->address = stub->GetEntryPoint() + stub->GetPatchOffset();
        bIsStub = TRUE;
    }

    return bIsStub;
}

//+----------------------------------------------------------------------------
//
//  Method:     CVirtualThunkMgr::IsThunkByASM  public
//
//  Synopsis:   Check assembly to see if this one of our thunks
//
//  History:    14-Sep-99 MattSmit      Created
//
//+----------------------------------------------------------------------------
BOOL CVirtualThunkMgr::IsThunkByASM(const BYTE *startaddr)
{

    // BUGBUG:: this may be a problem if the code is not at least 6 bytes long
    const BYTE *bCode = startaddr + 6;
    return (startaddr &&
            (startaddr[0] == 0x68) &&
            (startaddr[5] == 0xe9) &&
            (*((LONG *) bCode) == ((LONG) CTPMethodTable::GetTPStub()->GetEntryPoint()) - (LONG) (bCode + sizeof(LONG))) &&
            CheckIsStub(startaddr));
}

//+----------------------------------------------------------------------------
//
//  Method:     CVirtualThunkMgr::GetMethodDescByASM   public
//
//  Synopsis:   Parses MethodDesc out of assembly code
//
//  History:    14-Sep-99 MattSmit      Creatde
//
//+----------------------------------------------------------------------------
MethodDesc *CVirtualThunkMgr::GetMethodDescByASM(const BYTE *startaddr, MethodTable *pMT)
{
    return pMT->GetClass()->GetMethodDescForSlot(*((DWORD *) (startaddr + 1)));
}


//+----------------------------------------------------------------------------
//
//  Method:     CNonVirtualThunkMgr::TraceManager   public
//
//  Synopsis:   Traces the stub given the current context
//
//  History:    26-Jun-99   TarunA      Created
//
//+----------------------------------------------------------------------------
BOOL CNonVirtualThunkMgr::TraceManager(Thread *thread,
                                       TraceDestination *trace,
                                       CONTEXT *pContext,
                                       BYTE **pRetAddr)
{
    _ASSERTE(!"@TODO IA64 - TraceManager (RemotingCpu.cpp)");
    return FALSE;
}

//+----------------------------------------------------------------------------
//
//  Method:     CNonVirtualThunkMgr::DoTraceStub   public
//
//  Synopsis:   Traces the stub given the starting address
//
//  History:    26-Jun-99   TarunA      Created
//
//+----------------------------------------------------------------------------
BOOL CNonVirtualThunkMgr::DoTraceStub(const BYTE *stubStartAddress,
                                      TraceDestination *trace)
{    
    BOOL bRet = FALSE;

    CNonVirtualThunk* pThunk = FindThunk(stubStartAddress);
    
    if(NULL != pThunk)
    {
        // We can either jump to 
        // (1) a slot in the transparent proxy table (UNMANAGED)
        // (2) a slot in the non virtual part of the vtable
        // ... so, we need to return TRACE_MGR_PUSH with the address
        // at which we want to be called back with the thread's context
        // so we can figure out which way we're gonna go.
        if(stubStartAddress == pThunk->GetThunkCode())
        {
            trace->type = TRACE_MGR_PUSH;
            trace->stubManager = this; // Must pass this stub manager!
            trace->address = (BYTE*)(stubStartAddress +
                                     g_dwNonVirtualThunkReCheckLabelOffset);
            bRet = TRUE;
        }
    }

    return bRet;
}

//+----------------------------------------------------------------------------
//
//  Method:     CNonVirtualThunkMgr::IsThunkByASM  public
//
//  Synopsis:   Check assembly to see if this one of our thunks
//
//  History:    14-Sep-99 MattSmit      Created
//
//+----------------------------------------------------------------------------
BOOL CNonVirtualThunkMgr::IsThunkByASM(const BYTE *startaddr)
{
    // BUGBUG:: this may be a problem if the code is not at least 6 bytes long
    DWORD * pd = (DWORD *) startaddr;
    return  ((pd[0] == 0x7400f983) && 
             (*((DWORD *)(startaddr + 9)) == (DWORD) CTPMethodTable::GetMethodTableAddr()) && 
             CheckIsStub(startaddr));
}

//+----------------------------------------------------------------------------
//
//  Method:     CNonVirtualThunkMgr::GetMethodDescByASM   public
//
//  Synopsis:   Parses MethodDesc out of assembly code
//
//  History:    14-Sep-99 MattSmit      Created
//
//+----------------------------------------------------------------------------
MethodDesc *CNonVirtualThunkMgr::GetMethodDescByASM(const BYTE *startaddr)
{
    return *((MethodDesc **) (startaddr + 22));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\wks\makefile.inc ===
!IF "$(FREEBUILD)"!="1" 
STD_DEFINES = $(STD_DEFINES) -DWRITE_BARRIER_CHECK=1 $(C_DEFINES)
!ENDIF

!INCLUDE ..\$(TARGET_DIRECTORY)\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\shx\cgenshx.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
// CGENSHX.H -
//
// Various helper routines for generating SHX assembly code.
//
//

// Precompiled Header
#include "common.h"

#ifdef _SH3_
#include "stublink.h"
#include "cgenshx.h"
#include "tls.h"
#include "frames.h"
#include "excep.h"
#include "ecall.h"
#include "compluscall.h"
#include "ndirect.h"
#include "ctxvtab.h"

#ifdef DEBUG
// These aren't real prototypes
extern "C" void __stdcall WrapCall56(void *target);
extern "C" void __stdcall WrapCall60(void *target);
extern "C" void __stdcall WrapCall88(void *target);
#endif


#define ASSERT4U(x)		ASSERT((x & 0xF) == x)
#define ASSERT7U(x)		ASSERT((x & 0x3F) == x)
#define ASSERT8U(x)		ASSERT((x & 0xFF) == x)
#define ASSERT10U(x)	ASSERT((x & 0x3FF) == x)
#define	ASSERTALIGN4(x)	ASSERT((x & 0x3) == 0)
#define	ASSERTALIGN2(x)	ASSERT((x & 0x1) == 0)
#define ASSERTREG(r)	ASSERT((r & 0xF) == r)

#define ASSERT8S(x)		ASSERT( (((int)x) <= 127) && (((int)x) >= -128) )

#define MASK8(x)		(x & 0xFF)

//
// Code dealing with the Pre-Stub. The template is in stubshx.s
//
void CopyPreStubTemplate(Stub *preStub)
{
    DWORD *pcode = (DWORD*)(preStub->GetEntryPoint());
    const DWORD *psrc = (const DWORD *)&PreStubTemplate;
    UINT  numnops = 0;
    while (numnops < 3)
    {
        DWORD op = *(psrc++);
        if (op == 0x00090009) // look for 3 pairs of nops at the end
        {
            numnops++;
        }
        else
        {
            numnops = 0;
        }
        *(pcode++) = op;
    }
}





//
// Code to generate branches & calls
//

#define BRANCH_SIZES	(InstructionFormat::k13|InstructionFormat::k32)
#define BCOND_SIZES		(InstructionFormat::k9 |InstructionFormat::k13)
#define CALL_SIZES		(InstructionFormat::k13|InstructionFormat::k32)

#define SCRATCH_REG		1		// reserve R1 within the stub for use by branches

#define NODELAYSLOT			0x02
#define WANTDELAYSLOT		0
#define REST_OF_OPCODE		0x01

enum {
	opBF_DELAY		=0,
	opBT_DELAY		=1,
	opBF_NODELAY	=2,
	opBT_NODELAY	=3,
};
	
static const BYTE rgCondBranchOpcode[] = {
	0x8f, // BF/S
	0x8d, // BT/S
	0x8b, // BF
	0x89, // BT
};

enum {
	opBRA_DELAY		=0,
	opBSR_DELAY		=1,
	opBRA_NODELAY	=2,
	opBSR_NODELAY	=3,
};

static const WORD rgNearBranchOpcode[] = {
	0xA000,	// BRA
	0xB000,	// BSR
};

static const BYTE rgFarBranchOpcode[] = {
	0x23,	// BRAF
	0x03,	// BSRF
};

BOOL SHXCanReach(UINT refsize, UINT variationCode, BOOL fExternal, int offset)
{
	// 32 bits fits everything
	if(refsize==InstructionFormat::k32)
		return TRUE;

	if(!fExternal)
	{
		ASSERTALIGN2(offset);
		ASSERT(refsize==InstructionFormat::k9 || refsize==InstructionFormat::k13);
		return (offset == (offset & ((refsize==InstructionFormat::k9) ? 0x1FF : 0x1FFF)));
	}
	return FALSE;
}

//-----------------------------------------------------------------------
// InstructionFormat for conditional branches
//-----------------------------------------------------------------------
class SHXCondBranch : public InstructionFormat
{
private:

public:

	// permitted sizes defined above
	SHXCondBranch() : InstructionFormat(BCOND_SIZES) {}

	// we can do a 9bit disp in 1 instr, 13bits in 2 or 3 and 32bits in 3 or 4
	virtual UINT GetSizeOfInstruction(UINT refsize, UINT opcode) 
	{ 
		switch(refsize)
		{
		case k9:  return 2;
		case k13: return (opcode & NODELAYSLOT) ? 6 : 4;
		}
		ASSERT(FALSE);
		return 0;
	}

	// hot spot is always the start of the second instruction after the branch, 
	// so is 4 bytes from start of the branch instruction
	// Add length of otehr instruction we insert before the branch
	virtual UINT GetHotSpotOffset(UINT refsize, UINT variationCode)
    {
		switch(refsize)
		{
		case k9:  return 4;
		case k13: return 6;
		}
		ASSERT(FALSE);
		return 0;
	}

	virtual BOOL CanReach(UINT refsize, UINT variationCode, BOOL fExternal, int offset)
	{
		return SHXCanReach(refsize, variationCode, fExternal, offset);
	}

	// ref is the pointer we want to emit, relative to hot-spot
	virtual VOID EmitInstruction(UINT refsize, __int64 ref, BYTE *pBuf, UINT opcode, BYTE *pDataBuf)
    {
		switch(refsize)
		{
		case k9:
			// emit single instruction
	    	// low byte is offset scaled by 2
			pBuf[0] = (__int8)((DWORD)ref>>1);
			// high byte is opcode
			pBuf[1] = rgCondBranchOpcode[opcode];
			return;
			
		case k13:
			// emit the following sequence for BT foo
			//	BF +2
			// 	BRA foo
			//  NOP
			// emit the followinf sequence for BT/S foo
			//	BF +0
			//	BRA foo
			//
			// map opcode as follows BT or BTS==>BF, BF or BFS==>BT
			// i.e. we want to emit the reverse instruction w/o a delay slot)
			EmitInstruction(k9, (opcode & NODELAYSLOT), pBuf, 1-(opcode & REST_OF_OPCODE), NULL);
			// now emit the BRA. Low 12 bits are offset scaled by 2, high 4 bits are opcode
    		*((WORD*)(pBuf+2)) = ((WORD)0xA000 | (((WORD)ref>>1) & 0xFFF));
			// now emit NOP if reqd
			if(opcode & NODELAYSLOT)
				*((WORD*)(pBuf+4)) = 0x09; // NOP
			return;
		}
	}
};

inline BYTE ComputeOffset(LPBYTE pCodeBuf, LPBYTE pDataBuf)
{
	// compute offset to data area. The offset is relative to ((PC+4) & (~0x03))
   	ASSERTALIGN4((DWORD)pDataBuf);
	DWORD dwOffset = (DWORD)pDataBuf - (((DWORD)pCodeBuf+4) & (~0x03));
   	ASSERTALIGN4(dwOffset);
	// and offset is scaled by 4 in instruction
   	dwOffset >>= 2; // scale offset
   	ASSERT8U(dwOffset);
   	return (BYTE)dwOffset;
}

inline VOID GenerateConstantLoad(LPBYTE pCodeBuf, BYTE bOffset, int reg)
{
	// lobyte is offset
   	ASSERT8U(bOffset);
	pCodeBuf[0] = bOffset;
	// 3rd nibble is register, 4th is 0xD0
   	ASSERT4U(reg);
	pCodeBuf[1] = (0xD0 | reg);
}

//-----------------------------------------------------------------------
// InstructionFormat for unconditional branches & calls
//-----------------------------------------------------------------------
class SHXBranchCall : public InstructionFormat
{
public:

	// permitted sizes defined above
	SHXBranchCall() : InstructionFormat(BRANCH_SIZES|CALL_SIZES) {}
	
	// 32-bit offset requires 2 instructions. NODELAY adds a NOP
	virtual UINT GetSizeOfInstruction(UINT refsize, UINT opcode) 
	{ 
		return ((refsize==k32) ? 4 : 2) + (opcode & NODELAYSLOT);
	}
	
	// 32-bit offset requires 4 bytes of data, rest need 0
	virtual UINT GetSizeOfData(UINT refsize, UINT opcode)
	{ 
		return ((refsize==k32) ? 4 : 0);
	}

	// hot spot is always the start of the second instruction after the branch, 
	// so is 4 bytes from start of the branch instruction
	// Add length of other instruction we insert before the branch
	virtual UINT GetHotSpotOffset(UINT refsize, UINT variationCode)
    {
		return (refsize==k32) ? 6 : 4;
	}

	virtual BOOL CanReach(UINT refsize, UINT variationCode, BOOL fExternal, int offset)
	{
		return SHXCanReach(refsize, variationCode, fExternal, offset);
	}


	// ref is the pointer we want to emit, relative to hot-spot
	// iDataOffset is offset of data area (pointed to by pDataBuf), from hot-spot
	virtual VOID EmitInstruction(UINT refsize, __int64 ref, BYTE *pCodeBuf, UINT opcode, BYTE *pDataBuf)
    {
		switch(refsize)
		{
		case k13:
	    	// low 12 bits are offset scaled by 2, high 4 bits are opcode
    		*((WORD*)pCodeBuf) = (rgNearBranchOpcode[opcode & REST_OF_OPCODE] | (((WORD)ref>>1) & 0xFFF));
	   		pCodeBuf += 2;
    		break;

    	case k32:
    		// we want to generate the following
    		// 	mov.l @(iDataOffset+2, PC), SCRATCH_REG
    		// 	braf/bsrf @SCRATCH_REG
    		
    		// write out the actual branch/call offset to the data area
    		*((DWORD*)pDataBuf) = (__int32)ref;
    		
    		// write out the MOV.L (disp, PC), SCRATCH_REG
			GenerateConstantLoad(pCodeBuf, ComputeOffset(pCodeBuf, pDataBuf), SCRATCH_REG);
			
			// Now write out the BRAF or BSRF instruction. lobyte is opcode			
	   		pCodeBuf[2] = rgFarBranchOpcode[opcode & REST_OF_OPCODE];
    		// 3rd nibble is register, 4th is 0x00
	   		pCodeBuf[3] = SCRATCH_REG;
	   		
	   		pCodeBuf += 4;
	   		break;
		}
		
		// now emit NOP if reqd
		if(opcode & NODELAYSLOT)
			*((WORD*)pCodeBuf) = 0x09; // NOP
	}
};

//-----------------------------------------------------------------------
// InstructionFormat for PC-relative constant loads (treated as branch
// so as to share the data area building mechanism). We're abusing the system
// a bit. The absoulte value of the external reference is actually the 
// constant we want to load, and the "opcode" is the target register
//-----------------------------------------------------------------------
class SHXConstLoad : public InstructionFormat
{
public:
	// fake out the stublinker. Our instruction is always 2 bytes
	SHXConstLoad() : InstructionFormat(InstructionFormat::k32) {}
	virtual UINT GetSizeOfInstruction(UINT refsize, UINT opcode) { return 2; }
	virtual UINT GetHotSpotOffset(UINT refsize, UINT opcode) { return 0; }

	// we require 4 bytes of data
	virtual UINT GetSizeOfData(UINT refsize, UINT opcode) { return 4; }

	virtual BOOL CanReach(UINT refsize, UINT variationCode, BOOL fExternal, int offset)
	{
		return SHXCanReach(refsize, variationCode, fExternal, offset);
	}

	// pDataBuf is the data area
	virtual VOID EmitInstruction(UINT refsize, __int64 ref, BYTE *pCodeBuf, UINT opcode, BYTE *pDataBuf)
    {
		// ref is the constant we want to emit, made relative to PC
		// add the PC and hot-spot offset back to get it's absolute value
		ref += (__int64)pCodeBuf+0;
		
    	// stuff the value into the data area
    	*((DWORD*)pDataBuf) = (DWORD)ref;

   		// write out the MOV.L (disp, PC), opcode(==target register)
		GenerateConstantLoad(pCodeBuf, ComputeOffset(pCodeBuf, pDataBuf), opcode);
	}
};

static SHXBranchCall gSHXBranchCall;
static SHXCondBranch gSHXCondBranch;
static SHXConstLoad  gSHXConstLoad;

#define SHXEmitCallNoWrap(tval,delay) EmitLabelRef(NewExternalCodeLabel(tval), gSHXBranchCall, opBSR_DELAY|delay)
#define SHXEmitConstLoad(cval, reg)   EmitLabelRef(NewExternalCodeLabel(cval), gSHXConstLoad, reg)
#define SHXEmitJump(tgt, wantdelay)   EmitLabelRef(tgt, gSHXBranchCall, opBRA_DELAY|wantdelay)
#define SHXEmitCondJump(tgt,op,delay) EmitLabelRef(tgt, gSHXCondBranch, op|delay)
#define SHXEmitRegJump(reg, bDelay) \
	{ ASSERTREG(reg); Emit16((reg<<8)|0x402B); if(bDelay & NODELAYSLOT) SHXEmitNOP();}
#define SHXEmitRegCallNoWrap(reg, bDelay) \
	{ ASSERTREG(reg); Emit16((reg<<8)|0x400B); if(bDelay & NODELAYSLOT) SHXEmitNOP();}

// 
// Emitting machine code that is different in retail & debug
//

#ifdef DEBUG
#	define WRAPCALLOFFSET 4		// we actually jump into WrapCall *after* it's fake prolog
#	define SHXEmitCallWrapped(wrapsize, tgtval, wantdelay)   \
		{ EmitLabelRef(NewExternalCodeLabel(tgtval), gSHXConstLoad, 12); \
		  EmitLabelRef(NewExternalCodeLabel((LPBYTE)WrapCall##wrapsize+WRAPCALLOFFSET), \
						gSHXBranchCall, opBSR_DELAY|wantdelay); }
#	define SHXEmitRegCallWrappped(wrapsize, reg, wantdelay) \
		{ SHXEmitRR(opMOVRR, reg, 12); \
		  EmitLabelRef(NewExternalCodeLabel((LPBYTE)WrapCall##wrapsize+WRAPCALLOFFSET), gSHXConstLoad, reg); \
		  SHXEmitRegCallNoWrap(reg, wantdelay); }
#else
#	define SHXEmitCallWrapped(w, t, d)		SHXEmitCallNoWrap(t, d)
#	define SHXEmitRegCallWrappped(w, r, d) 	SHXEmitRegCallNoWrap(r, d)
#endif

#ifdef DEBUG
#	define SHXEmitDebugBreak()			{ Emit16(0xC301); }
#	define SHXEmitDebugTrashReg(reg)	SHXEmitConstLoad((LPVOID)0xCCCCCCCC, reg)
#	define SHXEmitDebugTrashTempRegs()	{ SHXEmitDebugTrashReg(1); SHXEmitDebugTrashReg(2); SHXEmitDebugTrashReg(3); }
#	define SHXEmitDebugTrashArgRegs()	{ SHXEmitDebugTrashReg(4); SHXEmitDebugTrashReg(5); SHXEmitDebugTrashReg(6); SHXEmitDebugTrashReg(7); }
#else
#	define SHXEmitDebugBreak()
#	define SHXEmitDebugTrashReg(reg)
#	define SHXEmitDebugTrashTempRegs()
#	define SHXEmitDebugTrashArgRegs()
#endif //DEBUG

// 
// Emitting machine code that doesn't require a label
//

// Special cases
#define SHXEmitNOP()		{ Emit16(0x0009); } // NOP
#define SHXEmitPushPR()		{ Emit16(0x4F22); } // STS.L PR, @-R15
#define SHXEmitPopPR() 		{ Emit16(0x4F26); } // LDS.L @R15+, PR
#define SHXEmitTSTI(imm)	{ ASSERT8U(imm); Emit16(0xC800|MASK8(imm)); } // TST #imm, R0
#define SHXEmitRTS(bDelay) 	{ Emit16(0x000B); if(bDelay & NODELAYSLOT) SHXEmitNOP(); }  // RTS

// register-to-register operations that are encoded XXXX RRRR RRRR XXXX
enum RRopcodes 
{
	opMOVRR  = 0x6003,	// mov   reg1, reg2
	opSTOB   = 0x2000,	// mov.b reg1, @reg2
	opSTOW   = 0x2001,	// mov.w reg1, @reg2
	opSTOL   = 0x2002,	// mov.l reg1, @reg2
	opLODB   = 0x6000,	// mov.b @reg1, reg2
	opLODW   = 0x6001,	// mov.w @reg1, reg2
	opLODL   = 0x6002,	// mov.l @reg1, reg2
	opPUSHB  = 0x2004,	// mov.b reg1, @-reg2
	opPUSHW  = 0x2005,	// mov.w reg1, @-reg2
	opPUSHL  = 0x2006,	// mov.l reg1, @-reg2
	opPOPB   = 0x6004,	// mov.b @reg1+, reg2
	opPOPW   = 0x6005,	// mov.w @reg1+, reg2
	opPOPL   = 0x6006,	// mov.l @reg1+, reg2
	opSWAPB  = 0x6008,	// swap.b  reg1, reg2
	opSWAPW  = 0x6009,	// swap.w  reg1, reg2
	opADD    = 0x300C,	// add     reg1, reg2
	opADDC   = 0x300E,	// addc    reg1, reg2
	opADDV   = 0x300F,	// addv    reg1, reg2
	opCMPEQ  = 0x3000,	// cmp/eq  reg1, reg2
	opCMPHS  = 0x3002,	// cmp/hs  reg1, reg2
	opCMPGE  = 0x3003,	// cmp/ge  reg1, reg2
	opCMPHI  = 0x3006,	// cmp/hi  reg1, reg2
	opCMPGT  = 0x3007,	// cmp/gt  reg1, reg2
	opCMPSTR = 0x200C,	// cmp/str reg1, reg2
	opEXTSB  = 0x600E,	// exts.b  reg1, reg2
	opEXTSW  = 0x600F,	// exts.w  reg1, reg2
	opEXTUB  = 0x600C,	// extu.b  reg1, reg2
	opEXTUW  = 0x600D,	// extu.w  reg1, reg2
	opSTOBindR0 = 0x0004,	// mov.b reg1, @(r0 + reg2)
	opSTOWindR0 = 0x0005,	// mov.w reg1, @(r0 + reg2)
	opSTOLindR0 = 0x0006,	// mov.l reg1, @(r0 + reg2)
	opLODBindR0 = 0x000C,	// mov.b @(r0 + reg1), reg2
	opLODWindR0 = 0x000D,	// mov.w @(r0 + reg1), reg2
	opLODLindR0 = 0x000E,	// mov.l @(r0 + reg2), reg2
	opXOR = 0x200a,
};

#define SHXEmitRR(op, reg1, reg2) \
	{ ASSERTREG(reg1); ASSERTREG(reg2); \
		Emit16(op|(reg1<<4)|(reg2<<8)); } 

// for convenience push defiedn in terms of above
#define SHXEmitPushReg(reg)	SHXEmitRR(opPUSHL, reg, 15)
#define SHXEmitPopReg(reg)	SHXEmitRR(opPOPL, 15, reg)

// 1-register operations with immediate or 8-bit displacement that are encoded XXXX RRRR IIIIIIII
enum RIopcodes 
{
	opMOVimm = 0xE000, 	// MOV   #imm, reg
//	opLODWpc = 0x9000,	// MOV.W @(disp, PC), reg
	opLODLpc = 0xD000,	// MOV.L @(disp, PC), reg
	opADDimm = 0x7000, 	// ADD   #imm, reg
};

// immediate is emitted as-is (no scaling)
#define SHXEmitRI(op, imm, reg)	\
	{ ASSERTREG(reg); ASSERT8S(imm); \
		Emit16(MASK8(imm)|(reg<<8)|op); }

// scale displacement by 4
#define SHXEmitRD4(op, disp, reg)	\
	{ ASSERTREG(reg); ASSERT10U(disp); ASSERTALIGN4(disp); \
		Emit16((disp>>2)|(reg<<8)|op); }

// 2-register operations with 4-bit displacement that are encoded XXXX RRRR RRRR DDDD
enum RRDopcodes 
{
	opLODLdisp = 0x5000,	// mov.l @(disp, reg1), reg2
	opSTOLdisp = 0x1000,	// mov.l reg1, @(disp, reg2)
};

// scale displacement by 4
#define SHXEmitRRD4(op, reg1, reg2, disp)	\
	{ ASSERTREG(reg1); ASSERTREG(reg2); ASSERT10U(disp); ASSERTALIGN4(disp); \
		Emit16((disp>>2)|(reg1<<4)|(reg2<<8)|op); }

// 1-register B & W operations (second reg is fixed at R0) with 4-bit displacement are encoded XXXX XXXX RRRR DDDD
enum RDopcodes 
{
	opLODBdisp = 0x8400,	// mov.b @(disp, reg), R0
	opLODWdisp = 0x8500,	// mov.w @(disp, reg), R0
	opSTOBdisp = 0x8000,	// mov.b R0, @(disp, reg)
	opSTOWdisp = 0x8100,	// mov.w R0, @(disp, reg)
};

// no displacement scaling for byte ops
#define SHXEmitRD1(op, reg, disp) { ASSERTREG(reg); ASSERT4U(disp); Emit16(disp|(reg<<4)|op); }
// scale by 2 for word ops
#define SHXEmitRD2(op, reg, disp) \
	{ ASSERTREG(reg); ASSERT5U(disp); ASSERTALIGN2(disp); \
		Emit16((disp>>1)|(reg<<4)|op); }

// 1-register operations encoded XXXX RRRR XXXX XXXX
/***enum Ropcodes 
{
	opJSR = 0x400B,	// JSR @reg
	opJMP = 0x402B,	// JMP @reg
};

// scale displacement by 4
#define SHXEmitR(op, reg) { ASSERTREG(reg); Emit16((reg<<8)|op); }
***/

/*------------------------------------------------------------------
// Emit code to get the current Thread structure and return it in R0
// We get this ptr by calling TlsGetValue
//
// NOTE1: This function trashes R4 and TlsGetValue (which it calls)
//		could trash all temporary & argument registers.
//		We assume that code generated by teh caller has saved these 
//		registers
// NOTE2: This function assumes that code generated by the caller
//	    has already made space for the callee arg-spill area
//
//
	mov.l	TLSGETVALUE, R0		; get call address
	jsr		@R0					; make call
	mov		#TLSINDEX,  R4		; (delay slot) pass ptr to index as arg
TLSGETVALUE:
	.data.l _TlsGetValue
------------------------------------------------------------------*/

VOID StubLinkerSHX::SHXEmitCurrentThreadFetch()
{
    THROWSCOMPLUSEXCEPTION();
    DWORD idx = GetThreadTLSIndex();

	// mov.l	TLSGETVALUE, R0	; get call address
	// jsr		@R0				; make call
	SHXEmitCallNoWrap(TlsGetValue, WANTDELAYSLOT);
	
	// mov		#TLSINDEX,  R4	; (delay slot) pass ptr to index as arg
	// assert that index can fit in an 8-bit *signed* immediate
	// since it must be positive, assert it fits in a 7bit unsigned
    ASSERT7U(idx);
	SHXEmitRI(opMOVimm, idx, 4); // delay slot
	
	// return value of TlsGetValue() will be in R0 -- we're done
	
	// trash R1--R7 in debug
	SHXEmitDebugTrashTempRegs();
	SHXEmitDebugTrashArgRegs();
}


/*---------------------------------------------------------------
// Emits: The prolog code of all Stubs.
//
// On Entry:
//	Stack contains only the original caller-pushed arguments
//	Argument registers contain original caller's arguments
//	Since we redirected here via a jump, PR still contains the return 
//  address back to the original caller.
//	R0 has been loaded with a pointer to the MethodDesc for this method
//
// (0) Save the incoming register args to stack
// (1) We need to push the PR, then the ptr to MethodDesc, then space for
//     ptr to previous frame, then ptr to vtable of the frame object
//     This constructs the Frame object expected by GC etc.
// (2) We push all callee-saved registers
// (3) We allocate space for callee arg-spill as reqd by SHX calling convention
// (4) We link ThisFrame (constructed in step1) into the current thread's
//     chain of Frames
//
// Here's the ASM for the code we generate
//
	mov.l	R4, @(0, R15)	; move register args so TlsGetValue call doesnt trash them
	mov.l	R5, @(4, R15)	; the spill area provided by the caller is guaranteed
	mov.l	R6, @(8, R15)	; to be at least 16 bytes on SHX in all cases (even if 0 args)
	mov.l	R7, @(12,R15)

	sts.l   PR,  @-R15			; push PR
	mov.l	R0,  @-R15			; push ptr to method desc (in R0)
	add		#-4, R15			; save space for m_pNext frame-link ptr
	mov.l	@(VTABLE, PC), R1	; at generation time we save the vtable ptr constant
								; in the stub's data table. Now load it
	mov.l	R1,  @-R15			; and push it

	; push callee-saved registers, R8-R13
	mov.l	R8,  @-R15				
	mov.l	R9,  @-R15
	mov.l	R10, @-R15
	mov.l	R11, @-R15
	mov.l	R12, @-R15
	mov.l	R13, @-R15
	mov.l	R14, @-R15		; push FP (R14)
	add		#-16, R15		; make space for arg-spill for our callees
	.prolog

	; emit code for GetThread, with Thread ptr ending up in R0
	mov		R0, R8			; save pThread in R8 for later
	
	mov.l	@(m_pFrame, R8), R9	; load previous frame ptr into R9
							; m_Next is now 16+24+4 bytes from R15
	mov.l	R9, @(44, R15)	; set m_Next ptr of current frame to prev frame
	mov		R15, R10		; start of ThisFrame is 16+24 from R15
	add		#40, R10		; pThisFrame = R10 = R15 + 40
	mov.l	R10, @(m_pFrame, R8) ; set pThread->m_pFrame = pThisFrame

//
// The generated stub trashes R0, R1. It calls TlsGetValue
// which can trash all temp & arg registers
//
// It uses R8, R9, R10 to save pThread, pPrevFrame and pThisFrame 
// across call to the target method
---------------------------------------------------------------*/

VOID StubLinkerSHX::EmitMethodStubProlog(LPVOID pFrameVptr)
{
    THROWSCOMPLUSEXCEPTION();

	// On entry R0 contains pFunctionDesc, PR is original-caller's return address
	// Stack contains just original caller's args. Register args still in registers

	//SHXEmitDebugBreak();

	SHXEmitRRD4(opSTOLdisp, 4, 15, 0); // mov.l	R4, @(0, R15) ; move register args so TlsGetValue doesnt trash them
	SHXEmitRRD4(opSTOLdisp, 5, 15, 4); // mov.l	R5, @(4, R15) ; the spill area provided by the caller is guaranteed
	SHXEmitRRD4(opSTOLdisp, 6, 15, 8); // mov.l	R6, @(8, R15) ; to be at least 16 bytes on SHX in all cases (even if 0 args)
	SHXEmitRRD4(opSTOLdisp, 7, 15,12); // mov.l	R7, @(12,R15)

	SHXEmitPushPR();			// sts.l PR,  @-R15	; push PR
	SHXEmitPushReg(0);			// mov.l R0,  @-R15	; push ptr to method desc (in R0)
	SHXEmitRI(opADDimm, -4, 15);// add	 #-4, R15	; save space for frame-link ptrs 

	// This 32-bit immediate load needs a data area so is treated like a labelref
	// so we can take advantage of it's data-area handling code.
	SHXEmitConstLoad(pFrameVptr, 1); // MOVE #pFrameVptr(32bit) --> R1
	SHXEmitPushReg(1);  // mov.l	R1,  @-R15	; vtable ptr now in R1 -- push it
	
	SHXEmitPushReg(8);	// mov.l	R8,  @-R15	; push callee-save registers
	SHXEmitPushReg(9);	// mov.l	R9,  @-R15
	SHXEmitPushReg(10);	// mov.l	R10, @-R15	
	SHXEmitPushReg(11);	// mov.l	R11, @-R15	
	SHXEmitPushReg(12);	// mov.l	R12, @-R15	
	SHXEmitPushReg(13);	// mov.l	R13, @-R15	
	SHXEmitPushReg(14);	// mov.l	R14, @-R15	
	SHXEmitRI(opADDimm, -16, 15);// add	 #-16, R15 ; save space for callee's arg-spill area

	// emit code for GetThread, with Thread ptr ending up in R8
	// Trashes *all* temp registers
	SHXEmitCurrentThreadFetch(); 
	SHXEmitRR(opMOVRR, 0, 8);		// mov R0, R8 ; save pThread in R8 for later
	
	int iDisp = Thread::GetOffsetOfCurrentFrame();

	// NOTE: The offsets 44 and 48 below are calculated based on SEVEN permanent 
	// registers being pushed & 16 bytes for callee arg-spill. If this changes
	// the offset need to change
	SHXEmitRRD4(opLODLdisp, 8, 9, iDisp); // mov.l @(m_pFrame,R8),R9 ; (R9)pPrevFrame = pThread(R8)->m_pFrame
	SHXEmitRRD4(opSTOLdisp, 9, 15, 48);   // mov.l R9,@(48,R15)	; pThisFrame->m_Next (at R15+48) = pPrevFrame(R9)
	SHXEmitRR(opMOVRR, 15, 10);			  // mov   R15, R10		; start of ThisFrame is 16+28 from R15
	SHXEmitRI(opADDimm, 44, 10);		  // add   #44, R10		; R10(pThisFrame) = R15 + 40
	SHXEmitRRD4(opSTOLdisp, 10, 8, iDisp);// mov.l R10,@(m_pFrame,R8) ; (R8)pThread->m_pFrame = (R10)pThisFrame

	// at the end of this emitted prolog 
	//		R10==pThisFrame, R9=pPrevFrame R8=pThread
	// incoming register args are on stack (only) above ThisFrame
	// permanent registers have been saved below ThisFrame
	// and below that we have 16 bytes of callee arg-spill area
}	

// This method is dependent on the StubProlog, therefore it's implementation
// is done right next to it.

#if JIT_OR_NATIVE_SUPPORTED
void __cdecl TransitionFrame::UpdateRegDisplay(const PREGDISPLAY pRD)
{
    DWORD *savedRegs = (DWORD *)((DWORD)this - (sizeof(CalleeSavedRegisters)));
    MethodDesc * pFunc = GetFunction();

    // reset pContext; it's only valid for active (top-most) frame
    pRD->pContext = NULL;
    pRD->pR14 = savedRegs++;
    pRD->pR13 = savedRegs++;
    pRD->pR12 = savedRegs++;
    pRD->pR11 = savedRegs++;
    pRD->pR10 = savedRegs++;
    pRD->pR9  = savedRegs++;
    pRD->pR8  = savedRegs++;
    pRD->pPC  = (DWORD *)((BYTE*)this + GetOffsetOfReturnAddress());
    pRD->Esp  = (DWORD)pRD->pPC + sizeof(void*);


    //@TODO: We still need to the following things:
    //          - figure out if we are in a hijacked slot
    //            (no adjustment of ESP necessary)
    //          - adjust ESP (popping the args)
    //          - figure out if the aborted flag is set
}

void ExceptionFrame::UpdateRegDisplay(const PREGDISPLAY pRD) {
	_ASSERTE(!"NYI");
}
#endif

/*------------------------------------------------------------------
// 
// Emit code for an ECall. We need to 
//
//	(1) Emit Prolog to create a Frame class on the stack etc
//	(2) Pass a single ptr to the args on stack as arg to the ECall
//	(3) Get the ECall ptr from teh MethodDesc and call it
//
------------------------------------------------------------------*/

VOID StubLinkerSHX::EmitECallMethodStub(__int16 numargbytes, StubStyle style)
{
    THROWSCOMPLUSEXCEPTION();

    EmitMethodStubProlog(ECallMethodFrame::GetMethodFrameVPtr());

	//	mov   R10, R4				; R4=pThisFrame
	//	add   #argoffset, R4		; R4=pArgs
	//	mov.l @(m_Datum, R10), R0	; R0=pMethodDesc
	//	mov.l @(m_pECall, R0), R0	; R0=pMethodDesc->m_pECallTarget
	//	jsr   @R0					; make ECall

	SHXEmitRR(opMOVRR, 10, 4);
	SHXEmitRI(opADDimm, TransitionFrame::GetOffsetOfArgs(), 4);
	SHXEmitRRD4(opLODLdisp, 10, 0, FramedMethodFrame::GetOffsetOfMethod());
	SHXEmitRRD4(opLODLdisp, 0, 0, ECallMethodDesc::GetECallTargetOffset());
	SHXEmitRegCallWrappped(56, 0, NODELAYSLOT);
	// after this the return value is in R0

    EmitMethodStubEpilog(0, style);
}

VOID ECall::EmitECallMethodStub(StubLinker *pstublinker, ECallMethodDesc *pMD, StubStyle style, PrestubMethodFrame *pPrestubMethodFrame)
{
	// BUGBUG: I think teh ECall convention has changed. This is probably not going to work. 
	(static_cast<StubLinkerSHX*>(pstublinker))->EmitECallMethodStub(pMD->CbStackPop(), style);
}


/*------------------------------------------------------------------
// 
// Emit code for an Interpreter Call. We need to 
//
//	(1) Allocate space for extra bytes used by InterpretedMethodFrame
//		(*below* the object)
//	(2) Pass a single ptr to the Frame on stack as arg to the helper
//
------------------------------------------------------------------*/

VOID StubLinkerSHX::EmitInterpretedMethodStub(__int16 numargbytes, StubStyle style)
{
    THROWSCOMPLUSEXCEPTION();
    int negspace = InterpretedMethodFrame::GetNegSpaceSize() -
                          TransitionFrame::GetNegSpaceSize();

	// PROLOG
	// add #-negspace, R15		; make space
	// call InterpretedMethodStubWorker	
	// mov   R10, R4			; (delayslot) R4=pThisFrame
	// add #negspace, R15		; remove added space
	// EPILOG

    EmitMethodStubProlog(InterpretedMethodFrame::GetMethodFrameVPtr());

	//SHXEmitDebugBreak();

    // make room for negspace fields of IFrame
	SHXEmitRI(opADDimm, -negspace, 15);	// add #-negspace, R15

	// make call -- ARULM--BUGBUG--unwrapped for now since we don't know size of negspace
    SHXEmitCallWrapped(88, InterpretedMethodStubWorker, WANTDELAYSLOT);
    
	// (delay slot) pass pThisFrame (R10) as arg to InterpretedMethodStubWorker
	SHXEmitRR(opMOVRR, 10, 4);

    // BUGBUG: is the return value of ultimate callee in R0??

	// trash R1--R7 in debug
	SHXEmitDebugTrashTempRegs();
	SHXEmitDebugTrashArgRegs();

    // deallocate negspace fields of IFrame
	SHXEmitRI(opADDimm, negspace, 15);	// add #-negspace, R15

    EmitMethodStubEpilog(0, style);
}

/*------------------------------------------------------------------
// 
// Emit code for an NDirect or ComplusToCom Call. We need to 
//
//	(1) Allocate space for cleanup field of pThisFrame if reqd
//		(this lies immediately below the saved regs)
//	(2) Pass ptrs to pThread and pThisFrame as args to the helper. One of:-
// 			NDirectGenericStubWorker(Thread *pThread, NDirectMethodFrame *pFrame)
// 			ComPlusToComWorker(Thread *pThread, ComPlusMethodFrame* pFrame)
//	(3) Clean up after
//
------------------------------------------------------------------*/

void StubLinkerSHX::CreateNDirectOrComPlusStubBody(LPVOID pfnHelper,  BOOL fRequiresCleanup)
{
    if (fRequiresCleanup)
    {
        // Allocate space for cleanup worker
        _ASSERTE(sizeof(CleanupWorkList) == 4);
		SHXEmitRI(opADDimm, -4, 15);	// add #-4, R15
	}

	SHXEmitRR(opMOVRR, 8, 4);		// mov  R8,  R4	; R4 = arg1 = (R8)pThread

	// make call
    if(fRequiresCleanup) {
    	SHXEmitCallWrapped(60, pfnHelper, WANTDELAYSLOT);
    } else {
    	SHXEmitCallWrapped(56, pfnHelper, WANTDELAYSLOT);
    }
    
	SHXEmitRR(opMOVRR, 10, 5); 		// (delay slot) mov  R10, R5	; R5 = arg2 = (R10)pThisFrame

	// trash R1--R7 in debug
	SHXEmitDebugTrashTempRegs();
	SHXEmitDebugTrashArgRegs();

    if (fRequiresCleanup)
    {
        // Pop off cleanup worker
        SHXEmitRI(opADDimm, 4, 15);	// add #4, R15
    }
}

/*static*/ void NDirect::CreateGenericNDirectStubSys(CPUSTUBLINKER *psl)
{
	(static_cast<StubLinkerSHX*>(psl))->CreateNDirectOrComPlusStubBody(NDirectGenericStubWorker, TRUE);
}

/*static*/ void ComPlusCall::CreateGenericComPlusStubSys(CPUSTUBLINKER *psl, BOOL fRequiresCleanup)
{
	(static_cast<StubLinkerSHX*>(psl))->CreateNDirectOrComPlusStubBody(ComPlusToComWorker, fRequiresCleanup);
}

/*static*/ Stub* NDirect::CreateSlimNDirectStub(StubLinker *pstublinker, NDirectMethodDesc *pMD)
{
    return NULL;
}

/*---------------------------------------------------------------
// Emits: The epilog code of all Stubs.
//
// On Entry:
//		R10==pThisFrame, R9=pPrevFrame R8=pThread
//		R0==return value of called function that should be preserved
//			(even across the call to OnStubXXXTripThread)
//
	mov   R0, R11 				; save return value in permanent reg
	mov.b @(m_state, R8), R0    ; byte-op can use only R0
	tst   #TS_CatchAtSafePoint, R0  ; TST-imm op can use only R0
	bt    NotTripped
	nop
	call  (OnStubObjectTripThread/OnStubScalarTripThread)  ; This will trash all temp regs
	nop
NotTripped:
	mov   R11, R0               ; restore return value
	mov.l R9, @(m_pFrame, R8)
	;; restore callee saved registers
	;; remove Frame from stack
	pop PR
	rts

// note numArgBytes is unused because SHX has no Pascal-like 
// callee-pop calling convention
---------------------------------------------------------------*/

VOID StubLinkerSHX::EmitMethodStubEpilog(__int16 numargbytes, StubStyle style,
                                         __int16 shadowStackArgBytes)
{
    THROWSCOMPLUSEXCEPTION();

    _ASSERTE(style == kNoTripStubStyle ||
             style == kObjectStubStyle ||
             style == kScalarStubStyle);        // the only ones this code knows about.

    // We don't support the case where numArgBytes isn't known until the call has
    // happened, because this stub gets reused for many signatures.  See cgenx86.cpp
    _ASSERTE(numArgBytes >= 0);

	// return value of ultimate callee is in R0 on entry

    if (style != kNoTripStubStyle) 
    {
	    CodeLabel *labelNotTripped = NewCodeLabel();

    	//   mov   R0, R11 ; save return value from being trashed below & in call
		//   mov.b @(m_state, R8), R0
		//   tst   #TS_CatchAtSafePoint, R0
		//   bt    NotTripped
		//   nop
		//   call  (OnStubObjectTripThread/OnStubScalarTripThread)
		//   nop
		// NotTripped:
		//   mov   R11, R0 ; restore return value
	
		SHXEmitRR(opMOVRR, 0, 11);
		SHXEmitRD1(opLODBdisp, 8, Thread::GetOffsetOfState());
		SHXEmitTSTI(Thread::TS_CatchAtSafePoint);
		SHXEmitCondJump(labelNotTripped, opBT_NODELAY, NODELAYSLOT);
		SHXEmitCallWrapped(56, (style == kObjectStubStyle
                        		  ? OnStubObjectTripThread
                                  : OnStubScalarTripThread), NODELAYSLOT);
		// trash R0--R7 in debug
		SHXEmitDebugTrashReg(0);
		SHXEmitDebugTrashTempRegs();
		SHXEmitDebugTrashArgRegs();
                                         
        EmitLabel(labelNotTripped);
		SHXEmitRR(opMOVRR, 11, 0);
	}

    // @TODO -- Arul, I'm trying to pop some extra bits of the frame at this point.
    // (We now release numargbytes + shadowStackArgBytes).  But I'm not sure how the
    // stack is actually being balanced here.
    //
    // if (shadowStackArgBytes)
    //      X86EmitAddEsp(shadowStackArgBytes);

	//	mov.l R9, @(m_pFrame, R8)
	SHXEmitRRD4(opSTOLdisp, 9, 8, Thread::GetOffsetOfCurrentFrame());

	SHXEmitRI(opADDimm, 16, 15);  // add #16, R15 ; pop off callee-arg-spill area

	// restore callee saved registers
	SHXEmitPopReg(14);	// mov.l	@R15+,  R14
	SHXEmitPopReg(13);	// mov.l	@R15+,  R13
	SHXEmitPopReg(12);	// mov.l	@R15+,  R12
	SHXEmitPopReg(11);	// mov.l	@R15+,  R11
	SHXEmitPopReg(10);	// mov.l	@R15+,  R10
	SHXEmitPopReg(9);	// mov.l	@R15+,  R9
	SHXEmitPopReg(8);	// mov.l	@R15+,  R8
	
	// remove Frame from stack
	SHXEmitRI(opADDimm, 12, 15);	// add #12, R15

	// pop return address into PR & return to caller
	// return value is already in R0
	SHXEmitPopPR();
	SHXEmitRTS(NODELAYSLOT);
}


//************************************************************************
// Signature to stack mapping
//************************************************************************



// This hack handles arguments as an array of __int64's
INT64 CallDescr(const BYTE *pTarget, const BYTE *pShortSig, BOOL fIsStatic, const __int64 *pArguments)
{

    THROWSCOMPLUSEXCEPTION();

    BYTE callingconvention = CallSig::GetCallingConvention(pShortSig);
    if (!isCallConv(callingconvention, IMAGE_CEE_CS_CALLCONV_DEFAULT))
    {
        _ASSERTE(!"This calling convention is not supported.");
        COMPlusThrow(kInvalidProgramException);
    }


    CallSig csig(pShortSig);
    UINT    nStackBytes = csig.SizeOfVirtualFixedArgStack(fIsStatic);
    DWORD   NumArguments = csig.NumFixedArgs();
    BYTE *  pDst;
    BYTE *  pNewArgs;
    BYTE *  pArgTypes;
    DWORD   arg = 0;
    DWORD   i;

    pNewArgs = (BYTE *) _alloca(nStackBytes + NumArguments);
    pArgTypes = pNewArgs + nStackBytes;
    pDst = pNewArgs;

    if (!fIsStatic)
    {
        // Copy "this" pointer
        *(OBJECTREF *) pDst = Int64ToObj(pArguments[arg]);
        arg++;
        pDst += sizeof(OBJECTREF);
    }

    // This will get all of the arg in sig order.  We need to 
    //  walk this list backwards because args are stored left to right
    for (i=0;i<NumArguments;i++) 
    {
        pArgTypes[i] = csig.NextArg();
    }

    for (i=0;i<NumArguments;i++)
    {
        switch (pArgTypes[NumArguments - i - 1])
        {
            case IMAGE_CEE_CS_OBJECT:
                *(OBJECTREF *) pDst = Int64ToObj(pArguments[arg]);
                arg++;
                pDst += sizeof(OBJECTREF);
                break;

            case IMAGE_CEE_CS_I4:
            case IMAGE_CEE_CS_R4:
            case IMAGE_CEE_CS_PTR:
                *(DWORD *) pDst = *(DWORD *) &pArguments[arg++];
                pDst += sizeof(DWORD);
                break;

            case IMAGE_CEE_CS_I8:
            case IMAGE_CEE_CS_R8:
                *(__int64 *) pDst = pArguments[arg++];
                pDst += sizeof(__int64);
                break;

            case IMAGE_CEE_CS_STRUCT4:
            case IMAGE_CEE_CS_STRUCT32:
                // @TODO
                break;

            case IMAGE_CEE_CS_VOID:    
            case IMAGE_CEE_CS_END:      
                _ASSERTE(0);
                break;

            default:
                _ASSERTE(0); 
        }
    }

    _ASSERTE(pDst == (pNewArgs + nStackBytes));
    return CallDescr(pTarget, pShortSig, fIsStatic, pNewArgs);
}

void SetupSlotToAddrMap(StackElemType *psrc, const void **pArgSlotToAddrMap, CallSig &csig)
{
	BYTE n;
    UINT32 argnum = 0;

	while (IMAGE_CEE_CS_END != (n = csig.NextArg()))
	{
		switch (n)
		{
			case IMAGE_CEE_CS_I8: //fallthru
			case IMAGE_CEE_CS_R8:
				psrc -= 2;
				pArgSlotToAddrMap[argnum++] = psrc;
				break;

			case IMAGE_CEE_CS_STRUCT4:  //fallthru
			case IMAGE_CEE_CS_STRUCT32:
			{
				UINT32 StructSize = csig.GetLastStructSize();
				_ASSERTE((StructSize & 3) == 0);

				psrc -= (StructSize >> 2); // psrc is in int32's
				pArgSlotToAddrMap[argnum++] = psrc;
				break;
			}

			case IMAGE_CEE_CS_PTR:
			{
				psrc -= (sizeof(OBJECTREF)/sizeof(*psrc));
				pArgSlotToAddrMap[argnum++] = psrc;
				break;
			}

			default:
				psrc--;
				pArgSlotToAddrMap[argnum++] = psrc;
				break;
		}
	}
}


//////////////////////////////////////////////////////////////////////////////
//
//      C O N T E X T S
//
// The next section is platform-specific stuff in support of Contexts:

// Create a thunk for a particular slot and return its address
PFVOID CtxVTable::CreateThunk(LONG slot)
{
	return NULL;
}


// The Generic (GN) versions.  For some, Win32 has versions which we can wire
// up to directly (like ::InterlockedIncrement).  For the rest:

void __fastcall OrMaskGN(DWORD * const p, const int msk)
{
    *p |= msk;
}

void __fastcall AndMaskGN(DWORD * const p, const int msk)
{
    *p &= msk;
}

LONG __fastcall InterlockExchangeGN(LONG * Target, LONG Value)
{
	return ::InterlockedExchange(Target, Value);
}

void * __fastcall InterlockCompareExchangeGN(void **Destination,
                                          void *Exchange,
                                          void *Comparand)
{
	return ::InterlockedCompareExchange(Destination, Exchange, Comparand);
}

LONG __fastcall InterlockIncrementGN(LONG *Target)
{
	return ::InterlockedIncrement(Target);
}

LONG __fastcall InterlockDecrementGN(LONG *Target)
{
	return ::InterlockedDecrement(Target);
}

// Here's the support for the interlocked operations.  The external view of them is
// declared in util.hpp.

BitFieldOps FastInterlockOr = OrMaskGN;
BitFieldOps FastInterlockAnd = AndMaskGN;

XchgOps     FastInterlockExchange = InterlockExchangeGN;
CmpXchgOps  FastInterlockCompareExchange = InterlockCompareExchangeGN;

IncDecOps   FastInterlockIncrement = InterlockIncrementGN;
IncDecOps   FastInterlockDecrement = InterlockDecrementGN;

// Adjust the generic interlocked operations for any platform specific ones we
// might have.
void InitFastInterlockOps()
{
}

//---------------------------------------------------------
// Handles system specfic portion of fully optimized NDirect stub creation
//---------------------------------------------------------
/*static*/ BOOL NDirect::CreateStandaloneNDirectStubSys(const NDirectMLStub *pheader, CPUSTUBLINKER *psl)
{
    return FALSE;
}




void LongJumpToInterpreterCallPoint(UINT32 neweip, UINT32 newesp)
{
	_ASSERTE(0);
}

//////////////////////////////////////////////////////////////////////////////
//
// JITInterface
//
//////////////////////////////////////////////////////////////////////////////

/*********************************************************************/

float __stdcall JIT_FltRem(float divisor, float dividend)
{
    if (!_finite(divisor) && !_isnan(divisor))    // is infinite
        return(dividend);       // return infinite
    return((float)fmod(dividend,divisor));
}

/*********************************************************************/
double __stdcall JIT_DblRem(double divisor, double dividend)
{
    if (!_finite(divisor) && !_isnan(divisor))    // is infinite
        return(dividend);       // return infinite
    return(fmod(dividend,divisor));
}

void ResumeAtJitEH(CrawlFrame* pCf, BYTE* resumePC, Thread *pThread) 
{
	_ASSERTE(0);
}

size_t GetL2CacheSize()
{
    return 0;
}

#endif // _SH3_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\svr\makefile.inc ===
!IF "$(FREEBUILD)"!="1" 
STD_DEFINES = $(STD_DEFINES) -DWRITE_BARRIER_CHECK=1 $(C_DEFINES)
!ENDIF

!INCLUDE ..\$(TARGET_DIRECTORY)\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\xmlparser\bufferedstream.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/////////////////////////////////////////////////////////////////////////////////
//
// fusion\xmlparser\BufferedStream.cxx
//
/////////////////////////////////////////////////////////////////////////////////

//#include "stdinc.h"
#include "core.h"
#pragma hdrstop

#include <memory.h> 
//#include <shlwapip.h>   
#include <ole2.h>
#include <xmlparser.h>

#include "bufferedstream.h"
#include "xmlstream.h"
#include "encodingstream.h"
#include "xmlhelper.h" 

const long BLOCK_SIZE = 4096;
// no point remembering a line buffer longer than this because client
// probably can't deal with that anyway.
const long MAX_LINE_BUFFER = 512;

BufferedStream::BufferedStream(XMLStream *pXMLStream)
{
    _pchBuffer = NULL;
    _lSize = 0;
    _pXMLStream = pXMLStream;
    init();
}
/////////////////////////////////////////////////////////////////////////////
void BufferedStream::init()
{
    _lCurrent = _lUsed = _lMark = 0;
    _lLine			= 1; // lines start at 1.
    _lMarkedline	= 1;
    _lLinepos		= 0;
    _lMarkedlinepos = 0;
    _chLast		= 0;
    _lStartAt		= 0;
    _fEof			= false;
    _lLockedPos	= -1;
    _lLastWhiteSpace = -1;
    _lLockCount	= 0;
    _fNotified		= false;
    _fFrozen		= false;
	_pPendingEncoding = NULL;
}
/////////////////////////////////////////////////////////////////////////////
BufferedStream::~BufferedStream()
{
    delete [] _pchBuffer;
    _pStmInput = NULL;
	delete _pPendingEncoding;
    _pPendingEncoding = NULL;


}
/////////////////////////////////////////////////////////////////////////////
HRESULT BufferedStream::Reset()
{
    init();

    delete[] _pchBuffer;
    _pchBuffer = NULL;
    _lSize = 0;
    _pStmInput = NULL;
    _lLockedPos = -1;
    _lLockCount = 0;
    _fFrozen = false;
    delete _pPendingEncoding;
    _pPendingEncoding = NULL;
    return S_OK;
}
/////////////////////////////////////////////////////////////////////////////
HRESULT  
BufferedStream::Load( 
        /* [unique][in] */ EncodingStream __RPC_FAR *pStm)
{
    if (pStm != NULL)
    {
        init();
        _pStmInput = pStm;
        return S_OK;
    }
    else
    {
        _pStmInput = NULL;
    }
    return S_OK;
}
/////////////////////////////////////////////////////////////////////////////
HRESULT 
BufferedStream::AppendData( const BYTE* in, ULONG length, BOOL lastBuffer)
{
    HRESULT hr;

    if (_fEof)
    {
        init();
    }

    if (!_pStmInput)
    {
        EncodingStream* stream = (EncodingStream*)EncodingStream::newEncodingStream(NULL); 
        if (stream == NULL)
            return E_OUTOFMEMORY;
        _pStmInput = stream;
        stream->Release(); // Smart pointer is holding a ref
    }

    checkhr2(_pStmInput->AppendData(in, length, lastBuffer));

    return S_OK;

}
/////////////////////////////////////////////////////////////////////////////
HRESULT  
BufferedStream::nextChar( 
        /* [out] */  WCHAR* ch,
        /* [out] */ bool* fEOF)
{
    HRESULT hr;

    if (_lCurrent >= _lUsed)
    {
        if (_fEof)
        {
            *fEOF = true;
            return S_OK;
        }
        if (! _fNotified && _lUsed > 0)
        {
            _fNotified = true;          // notify data available BEFORE blowing

            // NOTE: this code approximates what prepareForInput does
            // in order to accurately predict when the buffer is about to
            // be re-allocated.

            long shift = _fFrozen ? 0 : getNewStart(); // is data about to shift?
            long used = _lUsed - shift; // this is how much is really used after shift
            if (_lSize - used < BLOCK_SIZE + 1) // +1 for null termination.
            {
                // we will reallocate !!  So return a special
                // return code
                hr = E_DATA_REALLOCATE;
            }
            else
                hr = E_DATA_AVAILABLE;    // away the old data so parser can save it if need be.
            checkhr2( _pXMLStream->ErrorCallback(hr) );
        }                   

        checkhr2( fillBuffer() );
        if (_fEof)
        {
            *fEOF = true;
            return S_OK;
        }
        _fNotified = false;
    }

    WCHAR result = _pchBuffer[_lCurrent++];

    switch (result)
    {
    case 0xa:
    case 0xd:
        if (result == 0xd || _chLast != 0xd)
            _lLine++; 
        _lLinepos = _lCurrent;
        _chLast = result;
        _lLastWhiteSpace = _lCurrent;
        break;
    case 0x20:
    case 0x9:
        _lLastWhiteSpace = _lCurrent;
        break;
    case 0xfffe:
	case 0xffff:
    //case 0xfeff:

        return XML_E_BADCHARDATA;
    }

    *ch = result;
    return S_OK;
}
/////////////////////////////////////////////////////////////////////////////
HRESULT BufferedStream::scanPCData( 
    /* [out] */ WCHAR* ch,
    /* [out] */ bool* fWhitespace)
{
    WCHAR result;
    bool foundNonWhiteSpace = false;

    if (! isWhiteSpace(*ch))
        foundNonWhiteSpace = true;

    // Then skip the data until we find '<', '>' or '&'
    while (_lCurrent < _lUsed)
    {
        result = _pchBuffer[_lCurrent++];

        switch (result)
        {
        case ']':  // xiaoyu : the specified chars can be changed for our own purpose
        case '>':
        case '<':
        case '&':
        case '\'':  // so this can be used to scan attribute values also.
        case '"':   // so this can be used to scan attribute values also.
            *ch = result;
            if (foundNonWhiteSpace)
                *fWhitespace = false;
            return S_OK;
            break;

        case 0xa:
        case 0xd:
            if (result == 0xd || _chLast != 0xd)
                _lLine++; 
            _lLinepos = _lCurrent;
            _chLast = result;
            _lLastWhiteSpace = _lCurrent;
            break;
        case 0x20:
        case 0x9:
            _lLastWhiteSpace = _lCurrent;
            break;
        case 0xfffe:
        case 0xffff:

            return XML_E_BADCHARDATA;
        default:
            foundNonWhiteSpace = true;
            break;
        }
    }

    // And just return E_PENDING if we run out of buffer.
    if (foundNonWhiteSpace)
        *fWhitespace = false;
    return E_PENDING;
}
/////////////////////////////////////////////////////////////////////////////
long BufferedStream::getLine() 
{ 
    return _lMarkedline; 
}
/////////////////////////////////////////////////////////////////////////////
long BufferedStream::getLinePos() 
{
    // _lMarkedlinepos is the position of the beginning of the marked line
    // relative to the beginning of the buffer, and _lMark is the 
    // position of the marked token relative to the beginning of the
    // buffer, So the position of the marked token relative to the 
    // current line is the difference between the two.
    // We also return a 1-based position so that the start of the
    // line = column 1.  This is consistent with the line numbers
    // which are also 1-based.
    return (_lMarkedlinepos > _lMark+1) ? 0 : _lMark+1-_lMarkedlinepos; 
}
/////////////////////////////////////////////////////////////////////////////
long BufferedStream::getInputPos()
{
    return _lStartAt+_lMark;
}
/////////////////////////////////////////////////////////////////////////////
WCHAR* BufferedStream::getLineBuf(ULONG* len, ULONG* startpos)
{
    *len = 0;
    if (_pchBuffer == NULL)
        return NULL;

    WCHAR* result = &_pchBuffer[_lMarkedlinepos];

    ULONG i = 0;
    // internal _pchBuffer is guarenteed to be null terminated.
    WCHAR ch = result[i];
    while (ch != 0 && ch != L'\n' && ch != L'\r')
    {
        i++;
        ch = result[i];
    }
    *len = i;
    // also return the line position relative to start of
    // returned buffer.
    *startpos = (_lMarkedlinepos > _lMark+1) ? 0 : _lMark+1-_lMarkedlinepos; 
    return result;
}
/////////////////////////////////////////////////////////////////////////////
HRESULT BufferedStream::switchEncoding(const WCHAR * charset, ULONG len)
{
    HRESULT hr = S_OK;

    if (!_pStmInput)
    {
        hr = E_FAIL;
        goto CleanUp;
    }
    else
    {
        _pPendingEncoding = Encoding::newEncoding(charset, len);
        if (_pPendingEncoding == NULL)
        {
            hr = E_OUTOFMEMORY;
            goto CleanUp;
        }

        if (! _fFrozen)
        {
             hr = doSwitchEncoding();
        }
    }
CleanUp:
    return hr;
}
/////////////////////////////////////////////////////////////////////////////
HRESULT BufferedStream::doSwitchEncoding()
{
    Encoding* encoding = _pPendingEncoding;
    _pPendingEncoding = NULL;

    HRESULT hr = _pStmInput->switchEncodingAt(encoding, _lStartAt + _lCurrent);
    if (hr == S_FALSE)
    {
        // need to re-read to force re-decode into new encoding.
        // In other words we have to forget that we read past this
        // position already so that the next call to nextChar
        // will call FillBuffer again.
        // (+1 so that nextChar works correctly).
        _lUsed = _lStartAt + _lCurrent;
        hr = S_OK;
    }
    else if (FAILED(hr))
    {
        hr = (hr == E_INVALIDARG) ? XML_E_INVALIDENCODING : XML_E_INVALIDSWITCH;
    }
    return hr;
}
/////////////////////////////////////////////////////////////////////////////
// Returns a pointer to a contiguous block of text accumulated 
// from the last time Mark() was called up to but not including
// the last character read. (This allows a parser to have a
// lookahead character that is not included in the token).
HRESULT  
BufferedStream::getToken(const WCHAR**p, long* len)
{
    if (_pchBuffer == NULL)
        return E_FAIL;

    if (_lCurrent != _lCurrent2)
    {
        // need to fix up buffer since it is no
        // out of sync since we've been compressing
        // whitespace.

    }
    *p = &_pchBuffer[_lMark];
    *len = getTokenLength();
    return S_OK;
}
/////////////////////////////////////////////////////////////////////////////
void 
BufferedStream::Lock()
{
    // We allow nested locking - where the outer lock wins - unlock only 
    // really unlocks when the outer lock is unlocked.
    if (++_lLockCount == 1)
    {
        _lLockedPos = _lMark;
        _lLockedLine = _lMarkedline;
        _lLockedLinePos = _lMarkedlinepos;
    }
}
/////////////////////////////////////////////////////////////////////////////
void 
BufferedStream::UnLock()
{
    if (--_lLockCount == 0)
    {
        _lMark = _lLockedPos;
        _lMarkedline = _lLockedLine;
        _lMarkedlinepos = _lLockedLinePos;
        _lLockedPos = -1;
    }
}
/////////////////////////////////////////////////////////////////////////////
HRESULT 
BufferedStream::Freeze()
{
    HRESULT hr;
    if (_lCurrent > _lMidPoint)
    {
        // Since we freeze the buffer a lot now (any time we're inside
        // a tag) we need to shift the bytes down in the buffer more
        // frequently in order to guarentee we have space in the buffer
        // when we need it.  Otherwize the buffer would tend to just
        // keep growing and growing.  So we shift the buffer when we
        // go past the midpoint.
        checkhr2( prepareForInput() ); 
        
    }
    _fFrozen = true;
    return S_OK;
}
/////////////////////////////////////////////////////////////////////////////
HRESULT 
BufferedStream::UnFreeze()
{
    _fFrozen = false;
    if (_pPendingEncoding)
    {
        return doSwitchEncoding();
    }
    return S_OK;
}
/////////////////////////////////////////////////////////////////////////////
HRESULT 
BufferedStream::fillBuffer()
{
    HRESULT hr;
    
    checkhr2( prepareForInput() ); 

    if (_pStmInput)
    {
        long space = _lSize - _lUsed - 1; // reserve 1 for NULL termination

        // get more bytes.
        ULONG read = 0;
        HRESULT rc = _pStmInput->Read(&_pchBuffer[_lUsed], space*sizeof(WCHAR), &read);

        _lUsed += read/sizeof(WCHAR); // stream must return unicode characters.
        _pchBuffer[_lUsed] = 0; // NULL terminate the _pchBuffer.

        if (FAILED(rc))
            return rc;

        if (read == 0)
        {
            _fEof = true;
            // increment _lCurrent, so that getToken returns
            // last character in file.
            _lCurrent++; _lCurrent2++;
        }
    }
    else
    {
        // SetInput or AppendData hasn't been called yet.
        return E_PENDING;
    }

    return S_OK;
}
/////////////////////////////////////////////////////////////////////////////
HRESULT 
BufferedStream::prepareForInput()
{
    // move the currently used section of the _pchBuffer 
    // (buf[mark] to buf[used]) down to the beginning of
    // the _pchBuffer.

    long newstart = 0;

    // BUGBUG - if this code is changed BufferedStream::nextChar has to
    // be updated also so that they stay in sync, otherwise we might
    // re-allocated the buffer without generating an E_DATA_REALLOCATE
    // notification - which would be very bad (causes GPF's in the parser).

    if (! _fFrozen)  // can't shift bits if the buffer is frozen.
    {
        newstart = getNewStart();

        if (newstart > 0)
        {
            WCHAR* src = &_pchBuffer[newstart];
            _lUsed -= newstart;
            _lStartAt += newstart;
            ::memmove(_pchBuffer,src,_lUsed*sizeof(WCHAR));
            _lCurrent -= newstart;
            _lCurrent2 -= newstart;
            _lLastWhiteSpace -= newstart;
            _lLinepos = (_lLinepos > newstart) ? _lLinepos-newstart : 0;
            _lMarkedlinepos = (_lLinepos > newstart) ? _lMarkedlinepos-newstart : 0;
            _lMark -= newstart;
            _lLockedLinePos = (_lLockedLinePos > newstart) ? _lLockedLinePos-newstart : 0;
            _lLockedPos -= newstart;
        }
    }

    // make sure we have a reasonable amount of space
    // left in the _pchBuffer.
    long space = _lSize - _lUsed; 
    if (space > 0) space--; // reserve 1 for NULL termination
    if (_pchBuffer == NULL || space < BLOCK_SIZE)
    {
        // double the size of the buffer.
		long newsize = (_lSize == 0) ? BLOCK_SIZE : (_lSize*2);

        WCHAR* newbuf = NEW (WCHAR[newsize]);
        if (newbuf == NULL)
        {
            // try more conservative allocation.
            newsize = _lSize + BLOCK_SIZE;
            newbuf = NEW (WCHAR[newsize]);
        }
        if (newbuf == NULL && space == 0)
            return E_OUTOFMEMORY;

        if (newbuf != NULL)
        {
            if (_pchBuffer != NULL)
            {
                // copy old bytes to new _pchBuffer.
                ::memcpy(newbuf,_pchBuffer,_lUsed*sizeof(WCHAR));
                delete [] _pchBuffer;
            }
            newbuf[_lUsed] = 0; // make sure it's null terminated.
            _pchBuffer = newbuf;
            _lSize = newsize;
            _lMidPoint = newsize / 2;

        }
    }

    return S_OK;
}
/////////////////////////////////////////////////////////////////////////////
long
BufferedStream::getNewStart()
{
    long newstart = 0;

    // Unless the buffer is frozen, in which case we just reallocate and
    // do no shifting of data.
    if (_lLockedPos > 0)
    {
        // and try and preserve the beginning of the marked line if we can
        if (_lLockedLinePos < _lLockedPos && 
            _lLockedPos - _lLockedLinePos < MAX_LINE_BUFFER)
        {
            newstart = _lLockedLinePos;
        }
    }
    else if (_lMark > 0)
    {
        // and try and preserve the beginning of the marked line if we can
        newstart = _lMark;
        if (_lMarkedlinepos < _lMark && 
            _lMark - _lMarkedlinepos < MAX_LINE_BUFFER) // watch out for long lines
        {
            newstart = _lMarkedlinepos;
        }
    }
    return newstart;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\xmlparser\charencoder.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*
 * @(#)CharEncoder.cxx 1.0 6/10/97
 * 
 */

//#include "stdinc.h"
#include "core.h"
#pragma hdrstop
#include "codepage.h"
#include "charencoder.h"
#include "locale.h"

#ifdef FUSION_USE_OLD_XML_PARSER_SOURCE
	#include <shlwapip.h>   // IsCharSpace
	#ifdef UNIX
		#include <lendian.hpp>
	#endif

	#ifdef UNIX
	// Not needed under UNIX
	#else
	#ifndef _WIN64
    #include <w95wraps.h>
	#endif // _WIN64
	#endif /* UNIX */
#endif 

//
// Delegate other charsets to mlang
//
const EncodingEntry CharEncoder::charsetInfo [] = 
{
#ifdef FUSION_USE_OLD_XML_PARSER_SOURCE
    { CP_1250, _T("WINDOWS-1250"), 1, wideCharFromMultiByteWin32, wideCharToMultiByteWin32 }, 
    { CP_1251, _T("WINDOWS-1251"), 1, wideCharFromMultiByteWin32, wideCharToMultiByteWin32 }, 
    { CP_1252, _T("WINDOWS-1252"), 1, wideCharFromMultiByteWin32, wideCharToMultiByteWin32 },
    { CP_1253, _T("WINDOWS-1253"), 1, wideCharFromMultiByteWin32, wideCharToMultiByteWin32 }, 
    { CP_1254, _T("WINDOWS-1254"), 1, wideCharFromMultiByteWin32, wideCharToMultiByteWin32 },
    { CP_1257, _T("WINDOWS-1257"), 1, wideCharFromMultiByteWin32, wideCharToMultiByteWin32 },
    { CP_UCS_4, _T("UCS-4"), 4, wideCharFromUcs4Bigendian, wideCharToUcs4Bigendian },
    { CP_UCS_2, _T("ISO-10646-UCS-2"), 2, wideCharFromUcs2Bigendian, wideCharToUcs2Bigendian },
    { CP_UCS_2, _T("UNICODE-2-0-UTF-16"), 2, wideCharFromUcs2Bigendian, wideCharToUcs2Bigendian },
    { CP_UCS_2, _T("UTF-16"), 2, wideCharFromUcs2Bigendian, wideCharToUcs2Bigendian },
    { CP_UTF_8, _T("UNICODE-1-1-UTF-8"), 3, wideCharFromUtf8, wideCharToUtf8 },
    { CP_UTF_8, _T("UNICODE-2-0-UTF-8"), 3, wideCharFromUtf8, wideCharToUtf8 },
#endif	
	{ CP_UCS_2, TEXT("UCS-2"), 2, wideCharFromUcs2Bigendian
#ifdef FUSION_USE_OLD_XML_PARSER_SOURCE
	, wideCharToUcs2Bigendian 
#endif
	},

    { CP_UTF_8, TEXT("UTF-8"), 3, wideCharFromUtf8
#ifdef FUSION_USE_OLD_XML_PARSER_SOURCE
	, wideCharToUtf8 
#endif
	},
{437, L"437", 2, wideCharFromMultiByteWin32},
//{L"_autodetect", 50932},
//{L"_autodetect_all", 50001},
//{L"_autodetect_kr", 50949},
{20127, L"ANSI_X3.4-1968", 2, wideCharFromMultiByteWin32},
{20147, L"ANSI_X3.4-1986", 2, wideCharFromMultiByteWin32},
{28596, L"arabic", 2, wideCharFromMultiByteWin32},
{20127, L"ascii", 2, wideCharFromMultiByteWin32},
{708, L"ASMO-708", 2, wideCharFromMultiByteWin32},
{950, L"Big5", 2, wideCharFromMultiByteWin32},
{936, L"chinese", 2, wideCharFromMultiByteWin32},
{950, L"cn-big5", 2, wideCharFromMultiByteWin32},
{936, L"CN-GB", 2, wideCharFromMultiByteWin32},
{1026, L"CP1026", 2, wideCharFromMultiByteWin32},
{1256, L"cp1256", 2, wideCharFromMultiByteWin32},
{20127, L"cp367", 2, wideCharFromMultiByteWin32},
{437, L"cp437", 2, wideCharFromMultiByteWin32},
{775, L"CP500", 2, wideCharFromMultiByteWin32},
{28591, L"cp819", 2, wideCharFromMultiByteWin32},
{852, L"cp852", 2, wideCharFromMultiByteWin32},
{866, L"cp866", 2, wideCharFromMultiByteWin32},
{870, L"CP870", 2, wideCharFromMultiByteWin32},
{20127, L"csASCII", 2, wideCharFromMultiByteWin32},
{950, L"csbig5", 2, wideCharFromMultiByteWin32},
{51949, L"csEUCKR", 2, wideCharFromMultiByteWin32},
{51932, L"csEUCPkdFmtJapanese", 2, wideCharFromMultiByteWin32},
{936, L"csGB2312", 2, wideCharFromMultiByteWin32},
{936, L"csGB231280", 2, wideCharFromMultiByteWin32},
{50221, L"csISO2022JP", 2, wideCharFromMultiByteWin32},
{50225, L"csISO2022KR", 2, wideCharFromMultiByteWin32},
{936, L"csISO58GB231280", 2, wideCharFromMultiByteWin32},
{28591, L"csISOLatin1", 2, wideCharFromMultiByteWin32},
{28592, L"csISOLatin2", 2, wideCharFromMultiByteWin32},
{28953, L"csISOLatin3", 2, wideCharFromMultiByteWin32},
{28594, L"csISOLatin4", 2, wideCharFromMultiByteWin32},
{28599, L"csISOLatin5", 2, wideCharFromMultiByteWin32},
{28605, L"csISOLatin9", 2, wideCharFromMultiByteWin32},
{28596, L"csISOLatinArabic", 2, wideCharFromMultiByteWin32},
{28595, L"csISOLatinCyrillic", 2, wideCharFromMultiByteWin32},
{28597, L"csISOLatinGreek", 2, wideCharFromMultiByteWin32},
{28598, L"csISOLatinHebrew", 2, wideCharFromMultiByteWin32},
{20866, L"csKOI8R", 2, wideCharFromMultiByteWin32},
{949, L"csKSC56011987", 2, wideCharFromMultiByteWin32},
{437, L"csPC8CodePage437", 2, wideCharFromMultiByteWin32},
{932, L"csShiftJIS", 2, wideCharFromMultiByteWin32},
{65000, L"csUnicode11UTF7", 2, wideCharFromMultiByteWin32},
{932, L"csWindows31J", 2, wideCharFromMultiByteWin32},
{28595, L"cyrillic", 2, wideCharFromMultiByteWin32},
{20106, L"DIN_66003", 2, wideCharFromMultiByteWin32},
{720, L"DOS-720", 2, wideCharFromMultiByteWin32},
{862, L"DOS-862", 2, wideCharFromMultiByteWin32},
{874, L"DOS-874", 2, wideCharFromMultiByteWin32},
{37, L"ebcdic-cp-us", 2, wideCharFromMultiByteWin32},
{28596, L"ECMA-114", 2, wideCharFromMultiByteWin32},
{28597, L"ECMA-118", 2, wideCharFromMultiByteWin32},
{28597, L"ELOT_928", 2, wideCharFromMultiByteWin32},
{51936, L"euc-cn", 2, wideCharFromMultiByteWin32},
{51932, L"euc-jp", 2, wideCharFromMultiByteWin32},
{51949, L"euc-kr", 2, wideCharFromMultiByteWin32},
{51932, L"Extended_UNIX_Code_Packed_Format_for_Japanese", 2, wideCharFromMultiByteWin32},
{54936, L"gb18030", 2, wideCharFromMultiByteWin32},
{936, L"GB2312", 2, wideCharFromMultiByteWin32},
{936, L"GB2312-80", 2, wideCharFromMultiByteWin32},
{936, L"GB231280", 2, wideCharFromMultiByteWin32},
{936, L"GB_2312-80", 2, wideCharFromMultiByteWin32},
{936, L"GBK", 2, wideCharFromMultiByteWin32},
{20106, L"German", 2, wideCharFromMultiByteWin32},
{28597, L"greek", 2, wideCharFromMultiByteWin32},
{28597, L"greek8", 2, wideCharFromMultiByteWin32},
{28598, L"hebrew", 2, wideCharFromMultiByteWin32},
{52936, L"hz-gb-2312", 2, wideCharFromMultiByteWin32},
{20127, L"IBM367", 2, wideCharFromMultiByteWin32},
{437, L"IBM437", 2, wideCharFromMultiByteWin32},
{737, L"ibm737", 2, wideCharFromMultiByteWin32},
{775, L"ibm775", 2, wideCharFromMultiByteWin32},
{28591, L"ibm819", 2, wideCharFromMultiByteWin32},
{850, L"ibm850", 2, wideCharFromMultiByteWin32},
{852, L"ibm852", 2, wideCharFromMultiByteWin32},
{857, L"ibm857", 2, wideCharFromMultiByteWin32},
{861, L"ibm861", 2, wideCharFromMultiByteWin32},
{866, L"ibm866", 2, wideCharFromMultiByteWin32},
{869, L"ibm869", 2, wideCharFromMultiByteWin32},
{20105, L"irv", 2, wideCharFromMultiByteWin32},
{50220, L"iso-2022-jp", 2, wideCharFromMultiByteWin32},
{51932, L"iso-2022-jpeuc", 2, wideCharFromMultiByteWin32},
{50225, L"iso-2022-kr", 2, wideCharFromMultiByteWin32},
{50225, L"iso-2022-kr-7", 2, wideCharFromMultiByteWin32},
{50225, L"iso-2022-kr-7bit", 2, wideCharFromMultiByteWin32},
{51949, L"iso-2022-kr-8", 2, wideCharFromMultiByteWin32},
{51949, L"iso-2022-kr-8bit", 2, wideCharFromMultiByteWin32},
{28591, L"iso-8859-1", 2, wideCharFromMultiByteWin32},
{874, L"iso-8859-11", 2, wideCharFromMultiByteWin32},
{28605, L"iso-8859-15", 2, wideCharFromMultiByteWin32},
{28592, L"iso-8859-2", 2, wideCharFromMultiByteWin32},
{28593, L"iso-8859-3", 2, wideCharFromMultiByteWin32},
{28594, L"iso-8859-4", 2, wideCharFromMultiByteWin32},
{28595, L"iso-8859-5", 2, wideCharFromMultiByteWin32},
{28596, L"iso-8859-6", 2, wideCharFromMultiByteWin32},
{28597, L"iso-8859-7", 2, wideCharFromMultiByteWin32},
{28598, L"iso-8859-8", 2, wideCharFromMultiByteWin32},
{28598, L"ISO-8859-8 Visual", 2, wideCharFromMultiByteWin32},
{38598, L"iso-8859-8-i", 2, wideCharFromMultiByteWin32},
{28599, L"iso-8859-9", 2, wideCharFromMultiByteWin32},
{28591, L"iso-ir-100", 2, wideCharFromMultiByteWin32},
{28592, L"iso-ir-101", 2, wideCharFromMultiByteWin32},
{28593, L"iso-ir-109", 2, wideCharFromMultiByteWin32},
{28594, L"iso-ir-110", 2, wideCharFromMultiByteWin32},
{28597, L"iso-ir-126", 2, wideCharFromMultiByteWin32},
{28596, L"iso-ir-127", 2, wideCharFromMultiByteWin32},
{28598, L"iso-ir-138", 2, wideCharFromMultiByteWin32},
{28595, L"iso-ir-144", 2, wideCharFromMultiByteWin32},
{28599, L"iso-ir-148", 2, wideCharFromMultiByteWin32},
{949, L"iso-ir-149", 2, wideCharFromMultiByteWin32},
{936, L"iso-ir-58", 2, wideCharFromMultiByteWin32},
{20127, L"iso-ir-6", 2, wideCharFromMultiByteWin32},
{20127, L"ISO646-US", 2, wideCharFromMultiByteWin32},
{28591, L"iso8859-1", 2, wideCharFromMultiByteWin32},
{28592, L"iso8859-2", 2, wideCharFromMultiByteWin32},
{20127, L"ISO_646.irv:1991", 2, wideCharFromMultiByteWin32},
{28591, L"iso_8859-1", 2, wideCharFromMultiByteWin32},
{28605, L"ISO_8859-15", 2, wideCharFromMultiByteWin32},
{28591, L"iso_8859-1:1987", 2, wideCharFromMultiByteWin32},
{28592, L"iso_8859-2", 2, wideCharFromMultiByteWin32},
{28592, L"iso_8859-2:1987", 2, wideCharFromMultiByteWin32},
{28593, L"ISO_8859-3", 2, wideCharFromMultiByteWin32},
{28593, L"ISO_8859-3:1988", 2, wideCharFromMultiByteWin32},
{28594, L"ISO_8859-4", 2, wideCharFromMultiByteWin32},
{28594, L"ISO_8859-4:1988", 2, wideCharFromMultiByteWin32},
{28595, L"ISO_8859-5", 2, wideCharFromMultiByteWin32},
{28595, L"ISO_8859-5:1988", 2, wideCharFromMultiByteWin32},
{28596, L"ISO_8859-6", 2, wideCharFromMultiByteWin32},
{28596, L"ISO_8859-6:1987", 2, wideCharFromMultiByteWin32},
{28597, L"ISO_8859-7", 2, wideCharFromMultiByteWin32},
{28597, L"ISO_8859-7:1987", 2, wideCharFromMultiByteWin32},
{28598, L"ISO_8859-8", 2, wideCharFromMultiByteWin32},
{28598, L"ISO_8859-8:1988", 2, wideCharFromMultiByteWin32},
{28599, L"ISO_8859-9", 2, wideCharFromMultiByteWin32},
{28599, L"ISO_8859-9:1989", 2, wideCharFromMultiByteWin32},
{1361, L"Johab", 2, wideCharFromMultiByteWin32},
{20866, L"koi", 2, wideCharFromMultiByteWin32},
{20866, L"koi8", 2, wideCharFromMultiByteWin32},
{20866, L"koi8-r", 2, wideCharFromMultiByteWin32},
{21866, L"koi8-ru", 2, wideCharFromMultiByteWin32},
{21866, L"koi8-u", 2, wideCharFromMultiByteWin32},
{20866, L"koi8r", 2, wideCharFromMultiByteWin32},
{949, L"korean", 2, wideCharFromMultiByteWin32},
{949, L"ks-c-5601", 2, wideCharFromMultiByteWin32},
{949, L"ks-c5601", 2, wideCharFromMultiByteWin32},
{949, L"ks_c_5601", 2, wideCharFromMultiByteWin32},
{949, L"ks_c_5601-1987", 2, wideCharFromMultiByteWin32},
{949, L"ks_c_5601-1989", 2, wideCharFromMultiByteWin32},
{949, L"ks_c_5601_1987", 2, wideCharFromMultiByteWin32},
{949, L"KSC5601", 2, wideCharFromMultiByteWin32},
{949, L"KSC_5601", 2, wideCharFromMultiByteWin32},
{28591, L"l1", 2, wideCharFromMultiByteWin32},
{28592, L"l2", 2, wideCharFromMultiByteWin32},
{28593, L"l3", 2, wideCharFromMultiByteWin32},
{28594, L"l4", 2, wideCharFromMultiByteWin32},
{28599, L"l5", 2, wideCharFromMultiByteWin32},
{28605, L"l9", 2, wideCharFromMultiByteWin32},
{28591, L"latin1", 2, wideCharFromMultiByteWin32},
{28592, L"latin2", 2, wideCharFromMultiByteWin32},
{28593, L"latin3", 2, wideCharFromMultiByteWin32},
{28594, L"latin4", 2, wideCharFromMultiByteWin32},
{28599, L"latin5", 2, wideCharFromMultiByteWin32},
{28605, L"latin9", 2, wideCharFromMultiByteWin32},
{28598, L"logical", 2, wideCharFromMultiByteWin32},
{10000, L"macintosh", 2, wideCharFromMultiByteWin32},
{932, L"ms_Kanji", 2, wideCharFromMultiByteWin32},
{20108, L"Norwegian", 2, wideCharFromMultiByteWin32},
{20108, L"NS_4551-1", 2, wideCharFromMultiByteWin32},
{20107, L"SEN_850200_B", 2, wideCharFromMultiByteWin32},
{932, L"shift-jis", 2, wideCharFromMultiByteWin32},
{932, L"shift_jis", 2, wideCharFromMultiByteWin32},
{932, L"sjis", 2, wideCharFromMultiByteWin32},
{20107, L"Swedish", 2, wideCharFromMultiByteWin32},
{874, L"TIS-620", 2, wideCharFromMultiByteWin32},
{1200, L"ucs-2", 2, wideCharFromMultiByteWin32},
{1200, L"unicode", 2, wideCharFromMultiByteWin32},
{65000, L"unicode-1-1-utf-7", 2, wideCharFromMultiByteWin32},
{65001, L"unicode-1-1-utf-8", 2, wideCharFromMultiByteWin32},
{65000, L"unicode-2-0-utf-7", 2, wideCharFromMultiByteWin32},
{65001, L"unicode-2-0-utf-8", 2, wideCharFromMultiByteWin32},
{1201, L"unicodeFFFE", 2, wideCharFromMultiByteWin32},
{20127, L"us", 2, wideCharFromMultiByteWin32},
{20127, L"us-ascii", 2, wideCharFromMultiByteWin32},
{1200, L"utf-16", 3, wideCharFromMultiByteWin32},
{65000, L"utf-7", 3, wideCharFromMultiByteWin32},
{65001, L"utf-8", 3, wideCharFromMultiByteWin32},
{28598, L"visual", 2, wideCharFromMultiByteWin32},
{1250, L"windows-1250", 2, wideCharFromMultiByteWin32},
{1251, L"windows-1251", 2, wideCharFromMultiByteWin32},
{1252, L"windows-1252", 2, wideCharFromMultiByteWin32},
{1253, L"windows-1253", 2, wideCharFromMultiByteWin32},
{1254, L"Windows-1254", 2, wideCharFromMultiByteWin32},
{1255, L"windows-1255", 2, wideCharFromMultiByteWin32},
{1256, L"windows-1256", 2, wideCharFromMultiByteWin32},
{1257, L"windows-1257", 2, wideCharFromMultiByteWin32},
{1258, L"windows-1258", 2, wideCharFromMultiByteWin32},
{874, L"windows-874", 2, wideCharFromMultiByteWin32},
{1252, L"x-ansi", 2, wideCharFromMultiByteWin32},
{20000, L"x-Chinese-CNS", 2, wideCharFromMultiByteWin32},
{20002, L"x-Chinese-Eten", 2, wideCharFromMultiByteWin32},
{1250, L"x-cp1250", 2, wideCharFromMultiByteWin32},
{1251, L"x-cp1251", 2, wideCharFromMultiByteWin32},
{20420, L"X-EBCDIC-Arabic", 2, wideCharFromMultiByteWin32},
{1140, L"x-ebcdic-cp-us-euro", 2, wideCharFromMultiByteWin32},
{20880, L"X-EBCDIC-CyrillicRussian", 2, wideCharFromMultiByteWin32},
{21025, L"X-EBCDIC-CyrillicSerbianBulgarian", 2, wideCharFromMultiByteWin32},
{20277, L"X-EBCDIC-DenmarkNorway", 2, wideCharFromMultiByteWin32},
{1142, L"x-ebcdic-denmarknorway-euro", 2, wideCharFromMultiByteWin32},
{20278, L"X-EBCDIC-FinlandSweden", 2, wideCharFromMultiByteWin32},
{1143, L"x-ebcdic-finlandsweden-euro", 2, wideCharFromMultiByteWin32},
{20297, L"X-EBCDIC-France", 2, wideCharFromMultiByteWin32},
{1147, L"x-ebcdic-france-euro", 2, wideCharFromMultiByteWin32},
{20273, L"X-EBCDIC-Germany", 2, wideCharFromMultiByteWin32},
{1141, L"x-ebcdic-germany-euro", 2, wideCharFromMultiByteWin32},
{20423, L"X-EBCDIC-Greek", 2, wideCharFromMultiByteWin32},
{875, L"x-EBCDIC-GreekModern", 2, wideCharFromMultiByteWin32},
{20424, L"X-EBCDIC-Hebrew", 2, wideCharFromMultiByteWin32},
{20871, L"X-EBCDIC-Icelandic", 2, wideCharFromMultiByteWin32},
{1149, L"x-ebcdic-icelandic-euro", 2, wideCharFromMultiByteWin32},
{1148, L"x-ebcdic-international-euro", 2, wideCharFromMultiByteWin32},
{20280, L"X-EBCDIC-Italy", 2, wideCharFromMultiByteWin32},
{1144, L"x-ebcdic-italy-euro", 2, wideCharFromMultiByteWin32},
{50939, L"X-EBCDIC-JapaneseAndJapaneseLatin", 2, wideCharFromMultiByteWin32},
{50930, L"X-EBCDIC-JapaneseAndKana", 2, wideCharFromMultiByteWin32},
{50931, L"X-EBCDIC-JapaneseAndUSCanada", 2, wideCharFromMultiByteWin32},
{20290, L"X-EBCDIC-JapaneseKatakana", 2, wideCharFromMultiByteWin32},
{50933, L"X-EBCDIC-KoreanAndKoreanExtended", 2, wideCharFromMultiByteWin32},
{20833, L"X-EBCDIC-KoreanExtended", 2, wideCharFromMultiByteWin32},
{50935, L"X-EBCDIC-SimplifiedChinese", 2, wideCharFromMultiByteWin32},
{20284, L"X-EBCDIC-Spain", 2, wideCharFromMultiByteWin32},
{1145, L"x-ebcdic-spain-euro", 2, wideCharFromMultiByteWin32},
{20838, L"X-EBCDIC-Thai", 2, wideCharFromMultiByteWin32},
{50937, L"X-EBCDIC-TraditionalChinese", 2, wideCharFromMultiByteWin32},
{20905, L"X-EBCDIC-Turkish", 2, wideCharFromMultiByteWin32},
{20285, L"X-EBCDIC-UK", 2, wideCharFromMultiByteWin32},
{1146, L"x-ebcdic-uk-euro", 2, wideCharFromMultiByteWin32},
{51932, L"x-euc", 2, wideCharFromMultiByteWin32},
{51936, L"x-euc-cn", 2, wideCharFromMultiByteWin32},
{51932, L"x-euc-jp", 2, wideCharFromMultiByteWin32},
{29001, L"x-Europa", 2, wideCharFromMultiByteWin32},
{20105, L"x-IA5", 2, wideCharFromMultiByteWin32},
{20106, L"x-IA5-German", 2, wideCharFromMultiByteWin32},
{20108, L"x-IA5-Norwegian", 2, wideCharFromMultiByteWin32},
{20107, L"x-IA5-Swedish", 2, wideCharFromMultiByteWin32},
{57006, L"x-iscii-as", 2, wideCharFromMultiByteWin32},
{57003, L"x-iscii-be", 2, wideCharFromMultiByteWin32},
{57002, L"x-iscii-de", 2, wideCharFromMultiByteWin32},
{57010, L"x-iscii-gu", 2, wideCharFromMultiByteWin32},
{57008, L"x-iscii-ka", 2, wideCharFromMultiByteWin32},
{57009, L"x-iscii-ma", 2, wideCharFromMultiByteWin32},
{57007, L"x-iscii-or", 2, wideCharFromMultiByteWin32},
{57011, L"x-iscii-pa", 2, wideCharFromMultiByteWin32},
{57004, L"x-iscii-ta", 2, wideCharFromMultiByteWin32},
{57005, L"x-iscii-te", 2, wideCharFromMultiByteWin32},
{10004, L"x-mac-arabic", 2, wideCharFromMultiByteWin32},
{10029, L"x-mac-ce", 2, wideCharFromMultiByteWin32},
{10008, L"x-mac-chinesesimp", 2, wideCharFromMultiByteWin32},
{10002, L"x-mac-chinesetrad", 2, wideCharFromMultiByteWin32},
{10007, L"x-mac-cyrillic", 2, wideCharFromMultiByteWin32},
{10006, L"x-mac-greek", 2, wideCharFromMultiByteWin32},
{10005, L"x-mac-hebrew", 2, wideCharFromMultiByteWin32},
{10079, L"x-mac-icelandic", 2, wideCharFromMultiByteWin32},
{10001, L"x-mac-japanese", 2, wideCharFromMultiByteWin32},
{10003, L"x-mac-korean", 2, wideCharFromMultiByteWin32},
{10021, L"x-mac-thai", 2, wideCharFromMultiByteWin32},
{10081, L"x-mac-turkish", 2, wideCharFromMultiByteWin32},
{932, L"x-ms-cp932", 2, wideCharFromMultiByteWin32},
{932, L"x-sjis", 2, wideCharFromMultiByteWin32},
{65000, L"x-unicode-1-1-utf-7", 2, wideCharFromMultiByteWin32},
{65001, L"x-unicode-1-1-utf-8", 2, wideCharFromMultiByteWin32},
{65000, L"x-unicode-2-0-utf-7", 2, wideCharFromMultiByteWin32},
{65001, L"x-unicode-2-0-utf-8", 2, wideCharFromMultiByteWin32},
{50000, L"x-user-defined", 2, wideCharFromMultiByteWin32},
{950, L"x-x-big5", 2, wideCharFromMultiByteWin32},
{ CP_ACP, TEXT("default"), 2, wideCharFromMultiByteWin32}
};

#ifdef FUSION_USE_OLD_XML_PARSER_SOURCE
IMultiLanguage * CharEncoder::pMultiLanguage = NULL;
#endif 

Encoding * Encoding::newEncoding(const WCHAR * s, ULONG len, bool endian, bool mark)
{
    //Encoding * e = new Encoding();
	Encoding * e = NEW (Encoding());
    if (e == NULL)
        return NULL;
    e->charset = NEW (WCHAR[len + 1]);
    if (e->charset == NULL)
    {
        delete e;
        return NULL;
    }
    ::memcpy(e->charset, s, sizeof(WCHAR) * len);
    e->charset[len] = 0; // guarentee NULL termination.
    e->littleendian = endian;
    e->byteOrderMark = mark;
    return e;
}

Encoding::~Encoding()
{
    if (charset != NULL)
    {
        delete [] charset;
    }
}

int CharEncoder::getCharsetInfo(const WCHAR * charset, CODEPAGE * pcodepage, UINT * mCharSize)
{

    for (int i = 0; i < LENGTH(charsetInfo); i++)
    {
        //if (StrCmpI(charset, charsetInfo[i].charset) == 0)
        //if (::FusionpCompareStrings(charset, lstrlen(charset), charsetInfo[i].charset, lstrlen(charsetInfo[i].charset), true) == 0)
		if (_wcsnicmp(charset, charsetInfo[i].charset, wcslen(charset)) == 0)
        {             
            //
            // test whether we can handle it locally or not
            // BUGBUG(HACK) the index number may change if we change charsetInfo
            //

#ifdef FUSION_USE_OLD_XML_PARSER_SOURCE
			if (i > 5 || GetCPInfo(charsetInfo[i].codepage, &cpinfo))
#endif
            {
                *pcodepage = charsetInfo[i].codepage;
                *mCharSize = charsetInfo[i].maxCharSize;
                return i;
            }
#ifdef FUSION_USE_OLD_XML_PARSER_SOURCE
            else
            {
                break;
            }
#endif
        } // end of if
    }// end of for
// xiaoyu: It is assumed that an error would return if neither UTF-8 nor UCS-2
#ifdef FUSION_USE_OLD_XML_PARSER_SOURCE    
    //
    // delegate to MLANG then
    //
    MIMECSETINFO mimeCharsetInfo;
    HRESULT hr;

    hr = _EnsureMultiLanguage();
    if (hr == S_OK)
    {
        hr = pMultiLanguage->GetCharsetInfo((WCHAR*)charset, &mimeCharsetInfo);
        if (hr == S_OK)
        {
            *pcodepage = mimeCharsetInfo.uiInternetEncoding;
            if (GetCPInfo(*pcodepage, &cpinfo))
                *mCharSize = cpinfo.MaxCharSize;
            else // if we don't know the max size, assume a large size
                *mCharSize = 4;
            return -1;
        }
    }
#endif
    return -2;
}

#ifdef FUSION_USE_OLD_XML_PARSER_SOURCE    
extern HRESULT CreateMultiLanguage(IMultiLanguage ** ppUnk);

HRESULT CharEncoder::_EnsureMultiLanguage()
{
    return CreateMultiLanguage(&pMultiLanguage);
}
#endif

/**
 * get information about a code page identified by <code> encoding </code>
 */
HRESULT CharEncoder::getWideCharFromMultiByteInfo(Encoding * encoding, CODEPAGE * pcodepage, WideCharFromMultiByteFunc ** pfnWideCharFromMultiByte, UINT * mCharSize)
{
    HRESULT hr = S_OK;

    int i = getCharsetInfo(encoding->charset, pcodepage, mCharSize);
    if (i >= 0) // in our short list
    {
        switch (*pcodepage)
        {
        case CP_UCS_2:
            if (encoding->littleendian)
                *pfnWideCharFromMultiByte = wideCharFromUcs2Littleendian;
            else
                *pfnWideCharFromMultiByte = wideCharFromUcs2Bigendian;
            break;
#ifdef FUSION_USE_OLD_XML_PARSER_SOURCE            
        case CP_UCS_4:
            if (encoding->littleendian)
                *pfnWideCharFromMultiByte = wideCharFromUcs4Littleendian;
            else
                *pfnWideCharFromMultiByte = wideCharFromUcs4Bigendian;
            break;
#endif            
        default:
            *pfnWideCharFromMultiByte = charsetInfo[i].pfnWideCharFromMultiByte;
            break;
        }
    }
// xiaoyu : we do not deal this case
#ifdef FUSION_USE_OLD_XML_PARSER_SOURCE
    else if (i == -1) // delegate to MLANG
    {
        hr = pMultiLanguage->IsConvertible(*pcodepage, CP_UCS_2);
        if (S_OK == hr) 
            *pfnWideCharFromMultiByte = wideCharFromMultiByteMlang;
    }
#endif    
    else // invalid encoding
    {
        hr = E_FAIL;
    }
    return hr;
}

#ifdef FUSION_USE_OLD_XML_PARSER_SOURCE            
/**
 * get information about a code page identified by <code> encoding </code>
 */
HRESULT CharEncoder::getWideCharToMultiByteInfo(Encoding * encoding, CODEPAGE * pcodepage, WideCharToMultiByteFunc ** pfnWideCharToMultiByte, UINT * mCharSize)
{
    HRESULT hr = S_OK;

    int i = getCharsetInfo(encoding->charset, pcodepage, mCharSize);
    if (i >= 0) // in our short list
    {
        switch (*pcodepage)
        {
        case CP_UCS_2:
            if (encoding->littleendian)
                *pfnWideCharToMultiByte = wideCharToUcs2Littleendian;
            else
                *pfnWideCharToMultiByte = wideCharToUcs2Bigendian;
            break;
        case CP_UCS_4:
            if (encoding->littleendian)
                *pfnWideCharToMultiByte = wideCharToUcs4Littleendian;
            else
                *pfnWideCharToMultiByte = wideCharToUcs4Bigendian;
            break;
        default:
            *pfnWideCharToMultiByte = charsetInfo[i].pfnWideCharToMultiByte;
            break;
        }
    }
    else if (i == -1) // delegate to MLANG
    {
        hr = pMultiLanguage->IsConvertible(CP_UCS_2, *pcodepage);
        if (hr == S_OK)
            *pfnWideCharToMultiByte = wideCharToMultiByteMlang;
        else
            hr = E_FAIL;
    }
    else
    {
        hr = E_FAIL;
    }

    return hr;
}
#endif 

/**
 * Scans rawbuffer and translates UTF8 characters into UNICODE characters 
 */
HRESULT CharEncoder::wideCharFromUtf8(DWORD* pdwMode, CODEPAGE codepage, BYTE* bytebuffer,
                                            UINT * cb, WCHAR * buffer, UINT * cch)
{

	UNUSED(pdwMode);
	UNUSED(codepage);
#if 0
    // Just for the record - I tried this and measured it and it's twice as
    // slow as our hand-crafted code.

    // Back up if end of buffer is the second or third byte of a multi-byte 
    // encoding since MultiByteToWideChar cannot handle this case.  These second
    // and third bytes are easy to identify - they always start with the bit
    // pattern 0x10xxxxxx.

    UINT remaining = 0;
    UINT count;
    int endpos = (int)*cb;

    while (endpos > 0 && (bytebuffer[endpos-1] & 0xc0) == 0x80)
    {
        endpos--;
        remaining++;
    }
    if (endpos > 0)
    {
        count = MultiByteToWideChar(CP_UTF8, 0, bytebuffer, endpos, buffer, *cch);
        if (count == 0)
        {
            return HRESULT_FROM_WIN32(GetLastError());
        }
    }
#else
    UINT remaining = *cb;
    UINT count = 0;
    UINT max = *cch;
    ULONG ucs4;

    // UTF-8 multi-byte encoding.  See Appendix A.2 of the Unicode book for more info.
    //
    // Unicode value    1st byte    2nd byte    3rd byte    4th byte
    // 000000000xxxxxxx 0xxxxxxx
    // 00000yyyyyxxxxxx 110yyyyy    10xxxxxx
    // zzzzyyyyyyxxxxxx 1110zzzz    10yyyyyy    10xxxxxx
    // 110110wwwwzzzzyy+ 11110uuu   10uuzzzz    10yyyyyy    10xxxxxx
    // 110111yyyyxxxxxx, where uuuuu = wwww + 1
    WCHAR c;
    bool valid = true;

    while (remaining > 0 && count < max)
    {
        // This is an optimization for straight runs of 7-bit ascii 
        // inside the UTF-8 data.
        c = *bytebuffer;
        if (c & 0x80)   // check 8th-bit and get out of here
            break;      // so we can do proper UTF-8 decoding.
        *buffer++ = c;
        bytebuffer++;
        count++;
        remaining--;
    }

    while (remaining > 0 && count < max)
    {
        UINT bytes = 0;
        for (c = *bytebuffer; c & 0x80; c <<= 1)
            bytes++;

        if (bytes == 0) 
            bytes = 1;

        if (remaining < bytes)
        {
            break;
        }
         
        c = 0;
        switch ( bytes )
        {
            case 6: bytebuffer++;    // We do not handle ucs4 chars
            case 5: bytebuffer++;    // except those on plane 1
                    valid = false;
                    // fall through
            case 4: 
                    // Do we have enough buffer?
                    if (count >= max - 1)
                        goto Cleanup;

                    // surrogate pairs
                    ucs4 = ULONG(*bytebuffer++ & 0x07) << 18;
                    if ((*bytebuffer & 0xc0) != 0x80)
                        valid = false;
                    ucs4 |= ULONG(*bytebuffer++ & 0x3f) << 12;
                    if ((*bytebuffer & 0xc0) != 0x80)
                        valid = false;
                    ucs4 |= ULONG(*bytebuffer++ & 0x3f) << 6;
                    if ((*bytebuffer & 0xc0) != 0x80)
                        valid = false;                    
                    ucs4 |= ULONG(*bytebuffer++ & 0x3f);

                    // For non-BMP code values of ISO/IEC 10646, 
                    // only those in plane 1 are valid xml characters
                    if (ucs4 > 0x10ffff)
                        valid = false;

                    if (valid)
                    {
                        // first ucs2 char
                        *buffer++ = (USHORT)((ucs4 - 0x10000) / 0x400 + 0xd800);
                        count++;
                        // second ucs2 char
                        c = (USHORT)((ucs4 - 0x10000) % 0x400 + 0xdc00);
                    }
                    break;

            case 3: c  = WCHAR(*bytebuffer++ & 0x0f) << 12;    // 0x0800 - 0xffff
                    if ((*bytebuffer & 0xc0) != 0x80)
                        valid = false;
                    // fall through
            case 2: c |= WCHAR(*bytebuffer++ & 0x3f) << 6;     // 0x0080 - 0x07ff
                    if ((*bytebuffer & 0xc0) != 0x80)
                        valid = false;
                    c |= WCHAR(*bytebuffer++ & 0x3f);
                    break;
                    
            case 1:
                c = WCHAR(*bytebuffer++);                      // 0x0000 - 0x007f
                break;

            default:
                valid = false; // not a valid UTF-8 character.
                break;
        }

        // If the multibyte sequence was illegal, store a FFFF character code.
        // The Unicode spec says this value may be used as a signal like this.
        // This will be detected later by the parser and an error generated.
        // We don't throw an exception here because the parser would not yet know
        // the line and character where the error occurred and couldn't produce a
        // detailed error message.

        if (! valid)
        {
            c = 0xffff;
            valid = true;
        }

        *buffer++ = c;
        count++;
        remaining -= bytes;
    }
#endif

Cleanup:
    // tell caller that there are bytes remaining in the buffer to
    // be processed next time around when we have more data.
    *cb -= remaining;
    *cch = count;
    return S_OK;
}


/**
 * Scans bytebuffer and translates UCS2 big endian characters into UNICODE characters 
 */
HRESULT CharEncoder::wideCharFromUcs2Bigendian(DWORD* pdwMode, CODEPAGE codepage, BYTE* bytebuffer,
                                            UINT * cb, WCHAR * buffer, UINT * cch)
{
	UNUSED(codepage); 
	UNUSED(pdwMode);

    UINT num = *cb >> 1; 
    if (num > *cch)
        num = *cch;
    for (UINT i = num; i > 0; i--)
    {
        *buffer++ = ((*bytebuffer) << 8) | (*(bytebuffer + 1));
        bytebuffer += 2;
    }
    *cch = num;
    *cb = num << 1;
    return S_OK;
}


/**
 * Scans bytebuffer and translates UCS2 little endian characters into UNICODE characters 
 */
HRESULT CharEncoder::wideCharFromUcs2Littleendian(DWORD* pdwMode, CODEPAGE codepage, BYTE* bytebuffer,
                                            UINT * cb, WCHAR * buffer, UINT * cch)
{
	UNUSED(codepage); 
	UNUSED(pdwMode);

    UINT num = *cb / 2; // Ucs2 is two byte unicode.
    if (num > *cch)
        num = *cch;


#ifndef UNIX
    // Optimization for windows platform where little endian maps directly to WCHAR.
    // (This increases overall parser performance by 5% for large unicode files !!)
    ::memcpy(buffer, bytebuffer, num * sizeof(WCHAR));
#else
    for (UINT i = num; i > 0 ; i--)
    {
        // we want the letter 'a' to be 0x0000006a.
        *buffer++ = (*(bytebuffer+1)<<8) | (*bytebuffer); 
        bytebuffer += 2;
    }
#endif
    *cch = num;
    *cb = num * 2;
    return S_OK;
}

#ifdef FUSION_USE_OLD_XML_PARSER_SOURCE            
/**
 * Scans bytebuffer and translates UCS4 big endian characters into UNICODE characters 
 */
HRESULT CharEncoder::wideCharFromUcs4Bigendian(DWORD* pdwMode, CODEPAGE codepage, BYTE* bytebuffer,
                                            UINT * cb, WCHAR * buffer, UINT * cch)
{
    UINT num = *cb >> 2;
    if (num > *cch)
        num = *cch;
    for (UINT i = num; i > 0; i--)
    {
#ifndef UNIX
        if (*bytebuffer != 0 || *(bytebuffer + 1) != 0)
        {
            return XML_E_INVALID_UNICODE;
        }
        *buffer++ = (*(bytebuffer + 2) << 8) | (*(bytebuffer + 3));
#else
        *buffer++ = ((*bytebuffer)<<24) | (*(bytebuffer+1)<<16) | (*(bytebuffer+2)<<8) | (*(bytebuffer+3));
#endif
        bytebuffer += 4;
    }
    *cch = num;
    *cb = num << 2;
    return S_OK;
}
#endif


#ifdef FUSION_USE_OLD_XML_PARSER_SOURCE
/**
 * Scans bytebuffer and translates UCS4 little endian characters into UNICODE characters 
 */
HRESULT CharEncoder::wideCharFromUcs4Littleendian(DWORD* pdwMode, CODEPAGE codepage, BYTE* bytebuffer,
                                            UINT * cb, WCHAR * buffer, UINT * cch)
{
    UINT num = *cb >> 2; // Ucs4 is two byte unicode.
    if (num > *cch)
        num = *cch;
    for (UINT i = num; i > 0 ; i--)
    {
#ifndef UNIX
        *buffer++ = (*(bytebuffer+1)<<8) | (*bytebuffer);
        if (*(bytebuffer + 2) != 0 || *(bytebuffer + 3) != 0)
        {
            return XML_E_INVALID_UNICODE;
        }
#else
        *buffer++ = (*(bytebuffer+3)<<24) | (*(bytebuffer+2)<<16) | (*(bytebuffer+1)<<8) | (*bytebuffer);
#endif
        bytebuffer += 4;
    }
    *cch = num;
    *cb = num << 2;
    return S_OK;
}
#endif


/**
 * Scans bytebuffer and translates characters of charSet identified by 
 * <code> codepage </code> into UNICODE characters, 
 * using Win32 function MultiByteToWideChar() for encoding
 */
HRESULT CharEncoder::wideCharFromMultiByteWin32(DWORD* pdwMode, CODEPAGE codepage, BYTE* bytebuffer,
                                            UINT * cb, WCHAR * buffer, UINT * cch)
{   
    HRESULT hr = S_OK;

    UINT remaining = 0;
    UINT count=0;
    int endpos = (int)*cb;

    while (endpos > 0 && IsDBCSLeadByteEx(codepage, bytebuffer[endpos-1]))
    {
        endpos--;
        remaining++;
    }
    if (endpos > 0)
    {
        count = MultiByteToWideChar(codepage, MB_PRECOMPOSED,
                                    (char*)bytebuffer, endpos, 
                                    buffer, *cch);
        if (count == 0)
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
        }
    }

    *cb -= remaining;
    *cch = count;
    return hr;
}


#ifdef FUSION_USE_OLD_XML_PARSER_SOURCE
/**
 * Scans bytebuffer and translates multibyte characters into UNICODE characters,
 * using Mlang for encoding
 */
HRESULT CharEncoder::wideCharFromMultiByteMlang(DWORD* pdwMode, CODEPAGE codepage, BYTE* bytebuffer,
                                            UINT * cb, WCHAR * buffer, UINT * cch)
{
    HRESULT hr;
    checkhr2(_EnsureMultiLanguage());
    checkhr2(pMultiLanguage->ConvertStringToUnicode(pdwMode, codepage, 
                                 (char*)bytebuffer, cb, 
                                 buffer, cch ));
    return S_OK;
}
#endif


#ifdef FUSION_USE_OLD_XML_PARSER_SOURCE
/**
 * Scans buffer and translates Unicode characters into Ucs2 big endian characters 
 */
HRESULT CharEncoder::wideCharToUcs2Bigendian(DWORD* pdwMode, CODEPAGE codepage, WCHAR * buffer, 
                                           UINT *cch, BYTE* bytebuffer, UINT * cb)
{
    UINT num = (*cb) >> 1; 
    if (num > *cch)
        num = *cch;
    // BUGBUG - what do we do about Unix where WCHAR is 4 bytes ?
    // Currently we just throw away the high WORD - but I don't know how else
    // to do it, since UCS2 is 2-byte unicode by definition.
    for (UINT i = num; i > 0; i--)
    {
        *bytebuffer++ = (*buffer) >> 8;
        *bytebuffer++ = (*buffer++) & 0xFF;
    }
    *cch = num;
    *cb = num << 1;
    return S_OK;
}
#endif

#ifdef FUSION_USE_OLD_XML_PARSER_SOURCE
/**
 * Scans buffer and translates Unicode characters into Ucs2 little endian characters
 */
HRESULT CharEncoder::wideCharToUcs2Littleendian(DWORD* pdwMode, CODEPAGE codepage, WCHAR * buffer, 
                                              UINT *cch, BYTE* bytebuffer, UINT * cb)
{
    UINT num = (*cb) >> 1;
    if (num > *cch)
        num = *cch;

    // BUGBUG - what do we do about Unix where WCHAR is 4 bytes ?
    // Currently we just throw away the high WORD - but I don't know how else
    // to do it, since UCS2 is 2-byte unicode by definition.
#ifndef UNIX
    // Optimization for windows platform where little endian maps directly to WCHAR.
    // (This increases overall parser performance by 5% for large unicode files !!)
    ::memcpy(bytebuffer, buffer, num * sizeof(WCHAR));
#else
    for (UINT i = num; i > 0; i--)
    {
        *bytebuffer++ = (*buffer) & 0xFF;
        *bytebuffer++ = (*buffer++) >> 8;
    }
#endif
    *cch = num;
    *cb = num << 1;
    return S_OK;
}
#endif

#ifdef FUSION_USE_OLD_XML_PARSER_SOURCE
/**
 * Scans buffer and translates Unicode characters into Ucs4 big endian characters 
 */
HRESULT CharEncoder::wideCharToUcs4Bigendian(DWORD* pdwMode, CODEPAGE codepage, WCHAR * buffer, 
                                           UINT *cch, BYTE* bytebuffer, UINT * cb)
{
    UINT num = (*cb) >> 2; 
    if (num > *cch)
        num = *cch;

    for (UINT i = num; i > 0; i--)
    {
#ifndef UNIX
        *bytebuffer++ = 0;
        *bytebuffer++ = 0;
        *bytebuffer++ = (*buffer) >> 8;
        *bytebuffer++ = (*buffer) & 0xFF;
#else
        *bytebuffer++ = (*buffer) >> 24;
        *bytebuffer++ = ((*buffer) >> 16) & 0xFF;
        *bytebuffer++ = ((*buffer) >> 8) & 0xFF;
        *bytebuffer++ = (*buffer) & 0xFF;
#endif
        buffer++;
    }
    *cch = num;
    *cb = num << 2;
    return S_OK;
}
#endif

#ifdef FUSION_USE_OLD_XML_PARSER_SOURCE
/**
 * Scans buffer and translates Unicode characters into Ucs4 little endian characters
 */
HRESULT CharEncoder::wideCharToUcs4Littleendian(DWORD* pdwMode, CODEPAGE codepage, WCHAR * buffer, 
                                              UINT *cch, BYTE* bytebuffer, UINT * cb)
{
    UINT num = (*cb) >> 2;
    if (num > *cch)
        num = *cch;

    for (UINT i = num; i > 0; i--)
    {
#ifndef UNIX
        *bytebuffer++ = (*buffer) & 0xFF;
        *bytebuffer++ = (*buffer) >> 8;
        *bytebuffer++ = 0;
        *bytebuffer++ = 0;
#else
        *bytebuffer++ = (*buffer) & 0xFF;
        *bytebuffer++ = ((*buffer) >> 8) & 0xFF;
        *bytebuffer++ = ((*buffer) >> 16) & 0xFF;
        *bytebuffer++ = (*buffer) >> 24;
#endif
        buffer++;
    }
    *cch = num;
    *cb = num << 2;
    return S_OK;
}
#endif

#ifdef FUSION_USE_OLD_XML_PARSER_SOURCE
/**
 * Scans buffer and translates Unicode characters into UTF8 characters
 */
HRESULT CharEncoder::wideCharToUtf8(DWORD* pdwMode, CODEPAGE codepage, WCHAR * buffer, 
                                       UINT *cch, BYTE* bytebuffer, UINT * cb)
{
    UINT count = 0, num = *cch, m1 = *cb, m2 = m1 - 1, m3 = m2 - 1, m4 = m3 - 1;
    DWORD dw1;
    bool surrogate = false;

    for (UINT i = num; i > 0; i--)
    {
#ifdef UNIX
          // Solaris a WCHAR is 4 bytes (DWORD)
        DWORD dw = 0;
        DWORD dwTemp[4];
        BYTE* pByte = (BYTE*)buffer;
        dwTemp[3] = (DWORD)pByte[0];
        dwTemp[2] = (DWORD)pByte[1];
        dwTemp[1] = (DWORD)pByte[2];
        dwTemp[0] = (DWORD)pByte[3];
        dw = dwTemp[0]+(dwTemp[1]<<8)+(dwTemp[2]<<16)+(dwTemp[3]<<24);
#else
        DWORD dw = *buffer;
#endif

        if (surrogate) //  is it the second char of a surrogate pair?
        {
            if (dw >= 0xdc00 && dw <= 0xdfff)
            {
                // four bytes 0x11110xxx 0x10xxxxxx 0x10xxxxxx 0x10xxxxxx
                if (count < m4)
                    count += 4;
                else
                    break;
                ULONG ucs4 = (dw1 - 0xd800) * 0x400 + (dw - 0xdc00) + 0x10000;
                *bytebuffer++ = (byte)(( ucs4 >> 18) | 0xF0);
                *bytebuffer++ = (byte)((( ucs4 >> 12) & 0x3F) | 0x80);
                *bytebuffer++ = (byte)((( ucs4 >> 6) & 0x3F) | 0x80);
                *bytebuffer++ = (byte)(( ucs4 & 0x3F) | 0x80);
                surrogate = false;
                buffer++;
                continue;
            }
            else // Then dw1 must be a three byte character
            {
                if (count < m3)
                    count += 3;
                else
                    break;
                *bytebuffer++ = (byte)(( dw1 >> 12) | 0xE0);
                *bytebuffer++ = (byte)((( dw1 >> 6) & 0x3F) | 0x80);
                *bytebuffer++ = (byte)(( dw1 & 0x3F) | 0x80);
            }
            surrogate = false;
        }

        if (dw  < 0x80) // one byte, 0xxxxxxx
        {
            if (count < m1)
                count++;
            else
                break;
            *bytebuffer++ = (byte)dw;
        }
        else if ( dw < 0x800) // two WORDS, 110xxxxx 10xxxxxx
        {
            if (count < m2)
                count += 2;
            else
                break;
            *bytebuffer++ = (byte)((dw >> 6) | 0xC0);
            *bytebuffer++ = (byte)((dw & 0x3F) | 0x80);
        }
        else if (dw >= 0xd800 && dw <= 0xdbff) // Assume that it is the first char of surrogate pair
        {
            if (i == 1) // last wchar in buffer
                break;
            dw1 = dw;
            surrogate = true;
        }
        else // three bytes, 1110xxxx 10xxxxxx 10xxxxxx
        {
            if (count < m3)
                count += 3;
            else
                break;
            *bytebuffer++ = (byte)(( dw >> 12) | 0xE0);
            *bytebuffer++ = (byte)((( dw >> 6) & 0x3F) | 0x80);
            *bytebuffer++ = (byte)(( dw & 0x3F) | 0x80);
        }
        buffer++;
    }

    *cch = surrogate ? num - i - 1 : num - i;
    *cb = count;

    return S_OK;
}
#endif 

#ifdef FUSION_USE_OLD_XML_PARSER_SOURCE
/**
 * Scans buffer and translates Unicode characters into characters identified
 * by <code> codepage </>, using Win32 function WideCharToMultiByte for encoding 
 */
HRESULT CharEncoder::wideCharToMultiByteWin32(DWORD* pdwMode, CODEPAGE codepage, WCHAR * buffer, 
                                              UINT *cch, BYTE* bytebuffer, UINT * cb)
{
    HRESULT hr = S_OK;
    BOOL fBadChar = false;
    *cb = ::WideCharToMultiByte(codepage, NULL, buffer, *cch, (char*)bytebuffer, *cb, NULL, &fBadChar);
    if (*cb == 0)
        hr = ::GetLastError();
    else if (fBadChar)
        // BUGBUG: how do we inform the caller which character failed?
        hr = S_FALSE;
    return hr;
}
#endif

#ifdef FUSION_USE_OLD_XML_PARSER_SOURCE
/**
 * Scans buffer and translates Unicode characters into characters of charSet 
 * identified by <code> codepage </code>, using Mlang for encoding 
 */
HRESULT CharEncoder::wideCharToMultiByteMlang(DWORD* pdwMode, CODEPAGE codepage, WCHAR * buffer, 
                                              UINT *cch, BYTE* bytebuffer, UINT * cb)
{
    HRESULT hr;
    checkhr2(_EnsureMultiLanguage());
    checkhr2(pMultiLanguage->ConvertStringFromUnicode(pdwMode, codepage,
                                       buffer, cch, (char*)bytebuffer, cb ));
    return S_OK;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\xmlparser\bufferedstream.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/////////////////////////////////////////////////////////////////////////////////
//
// fusion\xmlparser\BufferedStream.hxx
//
/////////////////////////////////////////////////////////////////////////////////
#ifndef _FUSION_XMLPARSER__BUFFEREDSTREAM_H_INCLUDE_
#define _FUSION_XMLPARSER__BUFFEREDSTREAM_H_INCLUDE_
#pragma once

#include "encodingstream.h"

// Returned from nextChar when a new buffer is read.  This gives the
// caller some idea of download progress without having to count
// characters.  Just call nextChar again to continue on as normal.
#define E_DATA_AVAILABLE  0xC00CE600L
#define E_DATA_REALLOCATE 0xC00CE601L

//------------------------------------------------------------------------
// This class adds buffering and auto-growing semantics to an IStream
// so that a variable length chunk of an IStream can be collected
// in memory for processing using Mark() and getToken() methods.
// It also supports collapsing of newlines into 0x20 if you use 
// nextChar2 instead of nextChar.
// It also guarentees a line buffer so that a pointer to the 
// beginning of the line can be returned in error conditions.
// (for the degenerate case where there are no new lines, it
// returns the last 100 characters).
//
// Alternatively, buffers can be appended instead of
// using an IStream.  In this case the BufferedStream returns
// E_PENDING until the last buffer is appended.  Use AppendData instead
// of Load(IStream.  

class XMLStream;

class BufferedStream 
{   
public:
    BufferedStream(XMLStream *pXMLStream);
    ~BufferedStream();

    // Method 1: pass in an IStream.  The IStream must return unicode 
	// characters.
    HRESULT Load( 
        /* [unique][in] */ EncodingStream  *pStm);
    
    // Method 2: append raw buffers, set lastBuffer to TRUE you are ready to
    // return E_ENDOFINPUT.  Length is number of chars in buffer.  To do unicode
    // you must provide a byte order mark (0xFFFE or OxFEFF depending
    // on whether it is bigendian or little endian).
    HRESULT AppendData(const BYTE* buffer, ULONG length, BOOL lastBuffer);

    HRESULT Reset();

	// Get next char from buffer , if EOF, set fEOF to be true
    HRESULT nextChar( 
		/* [out] */ WCHAR* ch, 
		/* [out] */ bool* fEOF);

    // Marks the last character read as the start of a buffer
    // that grows until Mark is called again.  You can mark backwards
    // from last character read anywhere up to last marked position
    // by passing a non-zero delta.  For example, to mark the
    // position at the 3rd last character read, call Mark(3);

    // xiaoyu : _lCurrent always points to the char to read next
    inline void Mark(long back = 0) 
    {
        _lMark = (_lCurrent > back) ? (_lCurrent - back - 1) : 0;
        if (_lLinepos != _lCurrent)
        {
            // only move the marked line position forward, if we haven't
            // marked the actual new line characters.  This ensures we
            // return useful information from getLineBuf.
            _lMarkedline = _lLine;
            _lMarkedlinepos = _lLinepos;
        }
    }

    // Returns a pointer to a contiguous block of text accumulated 
    // from the last time Mark() was called up to but not including
    // the last character read. (This allows a parser to have a
    // lookahead character that is not included in the token).
    HRESULT getToken(const WCHAR**p, long* len);

	HRESULT switchEncoding(const WCHAR * charset, ULONG len);

    // Returns Marked position.
    long getLine();
    long getLinePos();
    WCHAR* getLineBuf(ULONG* len, ULONG* startpos);
    long getInputPos(); // absolute position.

    long getTokenLength() // convenience function.
    { 
		return (_lCurrent - 1 - _lMark);
    }

    inline bool isWhiteSpace(WCHAR ch) // no matter what value of "ch"
    {
		UNUSED(ch);
        return (_lLastWhiteSpace == _lCurrent);
    }

    inline void setWhiteSpace(bool flag = true)
    {
        _lLastWhiteSpace = flag ? _lCurrent : _lCurrent-1;
    }

    void init();

    // Lock/UnLock is another level on top of Mark/Reset that 
    // works as follows. If you Lock(), then the buffer keeps everything
    // until you UnLock at which time it resets the "Marked" position to
    // the Locked() position.  This is so that you can scan through
    // a series of tokens, but then return all of them in one chunk.
    void Lock();
    void UnLock();

    // Freezing the buffer makes the buffer always grow WITHOUT shifting
    // data around in the buffer.  This makes it valid to hold on to pointers
    // in the buffer until the buffer is unfrozen.
    HRESULT Freeze();
    HRESULT UnFreeze();
#ifdef FUSION_USE_OLD_XML_PARSER_SOURCE
	WCHAR*  getEncoding();
#endif
    // Special XML optimization.
    HRESULT scanPCData( 
        /* [out] */ WCHAR* ch,
        /* [out] */ bool* fWhitespace);

private:
    WCHAR nextChar();

    HRESULT fillBuffer();
    HRESULT prepareForInput();
	HRESULT doSwitchEncoding();
    long    getNewStart();

    REncodingStream _pStmInput; // input stream
    WCHAR*  _pchBuffer; // buffer containing chars from input stream.
    long    _lCurrent; // current read position in buffer
    long    _lCurrent2; // used when collapsing white space.
    long    _lSize; // total size of buffer.
    long    _lMark; // start of current token.
    long    _lUsed; // amount of buffer currently used.
    WCHAR   _chLast; // last character returned.
    long    _lLine; // current line number
    long    _lLinepos; // position of start of last line.
    long    _lMarkedline; // current line number of marked position.
    long    _lMarkedlinepos; 
    long    _lStartAt; // The number of unicode characters before the current buffer
    bool    _fEof;
    bool    _fNotified;
    bool    _fFrozen;
    long    _lLockCount;
    long    _lLockedPos;
    long    _lLockedLine;
    long    _lLockedLinePos;
    long    _lLastWhiteSpace;
    long    _lMidPoint; 
	Encoding* _pPendingEncoding;
    XMLStream *_pXMLStream; // regular pointer pointing back to the XMLStream object
};

#endif // _BUFFEREDSTREAM_HXX
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\xmlparser\codepage.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//+---------------------------------------------------------------------------
//
//  Microsoft Forms
//  File:       intl.hxx
//
//  Contents:   Codepage definitions
//
//----------------------------------------------------------------------------

#ifndef _CODEPAGE_H_
#define _CODEPAGE_H_
#pragma once

typedef UINT CODEPAGE;              // Codepage corresponds to Mlang ID

#define CP_UNDEFINED    CODEPAGE(-1)
#define CP_UCS_2        1200
#define CP_1250         1250
#define CP_1251         1251
#define CP_1252         1252
#define CP_1253         1253
#define CP_1254         1254
#define CP_1255         1255
#define CP_1256         1256
#define CP_1257         1257
#define CP_1258         1258

#define CP_UTF_8        65001
#define CP_UCS_4        12000

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\xmlparser\charencoder.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*
 * @(#)CharEncoder.hxx 1.0 6/10/97
 * 
 */
#ifndef _FUSION_XMLPARSER__CHARENCODER_HXX
#define _FUSION_XMLPARSER__CHARENCODER_HXX
#pragma once
//#include "codepage.h"

#ifdef FUSION_USE_OLD_XML_PARSER_SOURCE
	#include "mlang.h"
#endif


typedef HRESULT WideCharFromMultiByteFunc(DWORD* pdwMode, CODEPAGE codepage, BYTE * bytebuffer, 
                         UINT * cb, WCHAR * buffer, UINT * cch);
#ifdef FUSION_USE_OLD_XML_PARSER_SOURCE
	typedef HRESULT WideCharToMultiByteFunc(DWORD* pdwMode, CODEPAGE codepage, WCHAR * buffer, 
                         UINT *cch, BYTE * bytebuffer, UINT * cb);
#endif

struct EncodingEntry
{
    UINT codepage;
    WCHAR * charset;
    UINT  maxCharSize;
    WideCharFromMultiByteFunc * pfnWideCharFromMultiByte;
#ifdef FUSION_USE_OLD_XML_PARSER_SOURCE
    WideCharToMultiByteFunc * pfnWideCharToMultiByte;
#endif
};

class Encoding
{
protected: 
    Encoding() {};

public:

    // default encoding is UTF-8.
    static Encoding* newEncoding(const WCHAR * s = TEXT("UTF-8"), ULONG len = 5, bool endian = false, bool mark = false);
    virtual ~Encoding();
    WCHAR * charset;        // charset 
    bool    littleendian;   // endian flag for UCS-2/UTF-16 encoding, true: little endian, false: big endian
    bool    byteOrderMark;  // byte order mark (BOM) flag, BOM appears when true
};

/**
 * 
 * An Encoder specifically for dealing with different encoding formats 
 * @version 1.0, 6/10/97
 */

class CharEncoder
{
    //
    // class CharEncoder is a utility class, makes sure no instance can be defined
    //
    private: virtual charEncoder() = 0;

public:

    static HRESULT getWideCharFromMultiByteInfo(Encoding * encoding, CODEPAGE * pcodepage, WideCharFromMultiByteFunc ** pfnWideCharFromMultiByte, UINT * mCharSize);
#ifdef FUSION_USE_OLD_XML_PARSER_SOURCE
    static HRESULT getWideCharToMultiByteInfo(Encoding * encoding, CODEPAGE * pcodepage, WideCharToMultiByteFunc ** pfnWideCharToMultiByte, UINT * mCharSize);
#endif

    /**
     * Encoding functions: get Unicode from other encodings
     */
#ifdef FUSION_USE_OLD_XML_PARSER_SOURCE
    static WideCharFromMultiByteFunc wideCharFromUcs4Bigendian;
    static WideCharFromMultiByteFunc wideCharFromUcs4Littleendian;
    static WideCharFromMultiByteFunc wideCharFromUtf7;
    static WideCharFromMultiByteFunc wideCharFromAnsiLatin1;
    static WideCharFromMultiByteFunc wideCharFromMultiByteMlang;
#endif
    static WideCharFromMultiByteFunc wideCharFromMultiByteWin32;

    // actually, we only use these three functions for UCS-2 and UTF-8
	static WideCharFromMultiByteFunc wideCharFromUtf8;
    static WideCharFromMultiByteFunc wideCharFromUcs2Bigendian;
    static WideCharFromMultiByteFunc wideCharFromUcs2Littleendian;

    /**
     * Encoding functions: from Unicode to other encodings
     */
#ifdef FUSION_USE_OLD_XML_PARSER_SOURCE
    static WideCharToMultiByteFunc wideCharToUcs2Bigendian;
    static WideCharToMultiByteFunc wideCharToUcs2Littleendian;
    static WideCharToMultiByteFunc wideCharToUcs4Bigendian;
    static WideCharToMultiByteFunc wideCharToUcs4Littleendian;
    static WideCharToMultiByteFunc wideCharToUtf8;
    static WideCharToMultiByteFunc wideCharToUtf7;
    static WideCharToMultiByteFunc wideCharToAnsiLatin1;
    static WideCharToMultiByteFunc wideCharToMultiByteWin32;
    static WideCharToMultiByteFunc wideCharToMultiByteMlang;
#endif

    static int getCharsetInfo(const WCHAR * charset, CODEPAGE * pcodepage, UINT * mCharSize);

private: 
#ifdef FUSION_USE_OLD_XML_PARSER_SOURCE
    static HRESULT _EnsureMultiLanguage();
#endif
private:

#ifdef FUSION_USE_OLD_XML_PARSER_SOURCE
    static IMultiLanguage * pMultiLanguage;
#endif

    static const EncodingEntry charsetInfo [];
};

#endif _FUSION_XMLPARSER__CHARENCODER_HXX
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\xmlparser\core.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/////////////////////////////////////////////////////////////////////////////////
//
// fusion\xmlparser\xmlcore.hxx, renamed to be core.hxx on 4/09/00
//
/////////////////////////////////////////////////////////////////////////////////
#ifndef _FUSION_XMLPARSER_XMLCORE_H_INCLUDE_
#define _FUSION_XMLPARSER_XMLCORE_H_INCLUDE_
#pragma once

#pragma warning ( disable : 4201 )
#pragma warning ( disable : 4214 )
#pragma warning ( disable : 4251 )
#pragma warning ( disable : 4275 )
#define STRICT 1
//#include "fusioneventlog.h"
#ifdef _CRTIMP
#undef _CRTIMP
#endif
#define _CRTIMP
#include <windows.h>
#include "utilcode.h"
#define NOVTABLE __declspec(novtable)

#define UNUSED(x) (x)

#define CHECKTYPEID(x,y) (&typeid(x)==&typeid(y))
#define AssertPMATCH(p,c) Assert(p == null || CHECKTYPEID(*p, c))

#define LENGTH(A) (sizeof(A)/sizeof(A[0]))
#include "unknwn.h"
#include "_reference.h"
#include "_unknown.h"

//#include "fusionheap.h"
//#include "util.h"

#endif // end of #ifndef _FUSION_XMLPARSER_XMLCORE_H_INCLUDE_

#define NEW(x) new x
#define FUSION_DBG_LEVEL_ERROR 0
#define CODEPAGE UINT
#ifndef Assert
#define Assert(x)
#endif
#ifndef ASSERT 
#define ASSERT(x)
#endif
#define FN_TRACE_HR(x)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\xmlparser\encodingstream.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*
 * @(#)EncodingStream.cxx 1.0 6/10/97
 * 
 */

//#include "stdinc.h"
#include "core.h"
#include "xmlhelper.h"
#include "encodingstream.h"
#pragma hdrstop

const int EncodingStream::BUFFERSIZE = 4096*sizeof(WCHAR);
//////////////////////////////////////////////////////////////////////////////////
EncodingStream::EncodingStream(IStream * pStream): stream(pStream), encoding(NULL), buf(NULL)
{
#ifdef FUSION_USE_OLD_XML_PARSER_SOURCE

    // These objects are sometimes handed out to external clients.
    ::IncrementComponents();
#endif 

    pfnWideCharFromMultiByte = NULL;
#ifdef FUSION_USE_OLD_XML_PARSER_SOURCE
    pfnWideCharToMultiByte = NULL;
#endif
    btotal = bnext = startAt = 0;
    lastBuffer = false;
    bufsize = 0;
    _fEOF = false;
    _fReadStream = true;
    _fUTF8BOM = false;
    //_fTextXML = false;
    //_fSetCharset = false;
    _dwMode = 0;
    codepage = CP_UNDEFINED;
}
//////////////////////////////////////////////////////////////////////////////////
/**
 * Builds the EncodingStream for input.
 * Reads the first two bytes of the InputStream * in order to make a guess
 * as to the character encoding of the file.
 */
IStream * EncodingStream::newEncodingStream(IStream * pStream)
{
    EncodingStream * es = NEW (EncodingStream(pStream));
    if (es == NULL)
        return NULL;

    es->AddRef(); // xwu@@ : check this addRef()!

    es->isInput = true;
    es->buf = NULL;

    return es;
}
//////////////////////////////////////////////////////////////////////////////////
EncodingStream::~EncodingStream()
{
    if (buf)
        delete [] buf;
    if (encoding != NULL)
        delete encoding;

    stream = NULL; // smart pointer
}
//////////////////////////////////////////////////////////////////////////////////
/**
 * Reads characters from stream and encode it to Unicode
 */
HRESULT STDMETHODCALLTYPE EncodingStream::Read(void * pv, ULONG cb, ULONG * pcbRead)
{
    HRESULT hr;
    
    ULONG num = 0;

    if (pcbRead != NULL)
        *pcbRead = 0;

    if (btotal == 0 && _fEOF)          // we already hit EOF - so return right away.
        return S_OK;

    // Calculate how many UNICODE chars we are allowed to return, 
    // xiaoyu : which is the same as the number of BYTES read from the file
    cb /= sizeof(WCHAR);    
    checkhr2(prepareForInput(cb));

    if (stream && _fReadStream)
    {
        // btotal = number of bytes already in start of buffer.
        if (cb > btotal)
        {
            hr = stream->Read(buf + btotal, cb - btotal, &num);
            if (hr == E_PENDING && num > 0)
            {
                // in which case we ignore the error, and continue on !!.
                // BUGBUG - this may be a problem.since we are changing the
                // return code returned from the stream.  This may mean we
                // should not ever hand out this stream outside of MSXML.
                hr = 0;
            }
            if (FAILED(hr))
            {
                return hr;
            }
            if (btotal == 0 && num == 0)
            {
                _fEOF = true;
                return hr;
            }
        }
        else
        {
            hr = S_OK;
        }
    }
    else if (btotal == 0)
    {
    	return (lastBuffer) ? S_FALSE : E_PENDING;
    }

    btotal += num;
    UINT b = btotal, utotal = cb;

    if (b > cb)
    {
        // If we have more bytes in our buffer than the caller has
        // room for, then only return the number of bytes the caller
        // asked for -- otherwise pfnWideCharFromMultiByte will write
        // off the end of the caller's buffer.
        b = cb;
    }
    if (pfnWideCharFromMultiByte == NULL) // first read() call
    {
        checkhr2(autoDetect());
        if (pfnWideCharFromMultiByte == NULL) // failed to fully determine encoding
            return (lastBuffer) ? S_FALSE : E_PENDING;
        b -= bnext;
        startAt -= bnext;
    }
    hr = (this->pfnWideCharFromMultiByte)(&_dwMode, codepage, buf + bnext, &b, (WCHAR *)pv, &utotal);
    if (hr != S_OK)
        return hr;	
    if (b == 0 && num == 0 && (stream || lastBuffer))
    {
        // stream says we're at the end, but pfnWideCharFromMultiByte
        // disagrees !!

        return XML_E_INCOMPLETE_ENCODING;
    }
    bnext += b;
    if (pcbRead != NULL)
        *pcbRead = utotal*sizeof(WCHAR);
    return (utotal == 0) ? E_PENDING : S_OK;
} 
//////////////////////////////////////////////////////////////////////////////////
/**
 * Checks the first two/four bytes of the input Stream in order to 
 * detect UTF-16/UCS-4 or UTF-8 encoding;
 * otherwise assume it is UTF-8

 * xiaoyu : since only UCS-2 and UTF-8 are support, we do not deal with others...
 */
HRESULT EncodingStream::autoDetect()
{
    // wait until we have enough to be sure.
    if (btotal < 2)
        return S_OK;

    unsigned int guess = (((unsigned char)buf[0]) << 8) + ((unsigned char)buf[1]);
    HRESULT hr;

    if (guess == 0xFEFF || guess == 0xFFFE) // BOM found
    {
        // wait until we have enough to be sure.
        if (btotal < 4)
            return S_OK;
		
        unsigned int guess1 = (((unsigned char)buf[2]) << 8) + ((unsigned char)buf[3]);
        if (guess == guess1)
        {			
            /*
			if (!encoding)
            {
                static const WCHAR* wchUCS4 = TEXT("UCS-4");
                encoding = Encoding::newEncoding(wchUCS4, 5, (0xFFFE == guess), true);
            }
            bnext = 4;	
			*/
			// FUSION_XML_PARSER does not support UCS4
			return XML_E_INVALIDENCODING;
        }
        else
        {
            if (!encoding)
            {   
                static const WCHAR* wchUCS2 = TEXT("UCS-2");
                encoding = Encoding::newEncoding(wchUCS2, 5, (0xFFFE == guess), true);
            }
            bnext = 2;
        }

        if (NULL == encoding)
            return E_OUTOFMEMORY;       
        encoding->littleendian =  (0xFFFE == guess);
    }
    else
    {
        if (!encoding)
        {
            encoding = Encoding::newEncoding(); // default encoding : UTF-8 
            if (NULL == encoding)
                return E_OUTOFMEMORY;
        }

        // In some system, such as win2k, there is BOM 0xEF BB BF for UTF8
        if (guess == 0xEFBB)
        {
            if (btotal < 3)
                return S_OK;
			
            if (buf[2] == 0xBF)
                _fUTF8BOM = true; 
			
            bnext = 3; 
        }
        else
        {
            encoding->byteOrderMark = false;
        }
    }

    checkhr2(CharEncoder::getWideCharFromMultiByteInfo(encoding, &codepage, &pfnWideCharFromMultiByte, &maxCharSize));
    return S_OK;
}
/////////////////////////////////////////////////////////////////////////////////////////
/**
 * Switchs the character encoding of the input stream
 * Returns:
 *         S_OK: succeeded, and do not need re-read
 *         S_FALSE: succeeded, needs to re-read from <code> newPosition </code>
 *         Otherwise: error code
 * Notice: 
 *         This method only works for input stream, newPosition starts with 1
 */
HRESULT EncodingStream::switchEncodingAt(Encoding * newEncoding, int newPosition)
{
    // Ignore encoding information in the document when charset information is set from outside
	// xwu: fusion xml parsed does not use Charset
    //if (_fSetCharset)
    //    return S_OK;


    int l = newPosition - startAt;
    if (l < 0 || l > (int)bnext) 
    {
        // out of range
        delete newEncoding;
        return E_INVALIDARG;
    }

    UINT newcodepage;
    UINT newCharSize;
    //
    // get and check charset information
    //
    WideCharFromMultiByteFunc * pfn;
    HRESULT hr = CharEncoder::getWideCharFromMultiByteInfo(newEncoding, &newcodepage, &pfn, &newCharSize);
    if (hr != S_OK)
    {
        delete newEncoding;
        return E_INVALIDARG;
    }
    if (codepage == newcodepage)
    {
        delete newEncoding;
        return S_OK;
    }

    // Now if we are in UCS-2/UCS-4 we cannot switch out of UCS-2/UCS-4 and if we are
    // not in UCS-2/UCS-4 we cannot switch into UCS-2/UCS-4.
    // Also if UTF-8 BOM is presented, we cannot switch away
    if ((codepage != CP_UCS_2 && newcodepage == CP_UCS_2) ||
        (codepage == CP_UCS_2 && newcodepage != CP_UCS_2) ||
		/* xuw: fusion xml parser only support UTF-8 and UCS-2
        (codepage != CP_UCS_4 && newcodepage == CP_UCS_4) ||
        (codepage == CP_UCS_4 && newcodepage != CP_UCS_4) ||
		*/
        (codepage == CP_UTF_8 && newcodepage != CP_UTF_8 && _fUTF8BOM))
    {
        delete newEncoding;
        return E_FAIL;
    }

    // Ok, then, let's make the switch.
    delete encoding;
    encoding = newEncoding;
    maxCharSize = newCharSize;
    codepage = newcodepage;
    pfnWideCharFromMultiByte = pfn;

    // Because the XML declaration is encoded in UTF-8, 
    // Mapping input characters to wide characters is one-to-one mapping
    if ((int)bnext != l)
    {
        bnext = l;
        return S_FALSE;
    }
    return S_OK;
}

//////////////////////////////////////////////////////////////////////////////////
// minlen is the number of UNICODE, which is the same number of byte we read from the file 
HRESULT EncodingStream::prepareForInput(ULONG minlen)
{
//    Assert(btotal >= bnext);
    btotal -= bnext;

    if (bufsize < minlen)
    {
        BYTE* newbuf = NEW (BYTE[minlen]);
        if (newbuf == NULL) { 
            return E_OUTOFMEMORY;
        }

        if (buf){
            ::memcpy(newbuf, buf+bnext, btotal);
            delete[] buf;
        }

        buf = newbuf;
        bufsize = minlen;
    }
    else if (bnext > 0 && btotal > 0)
    {
        // Shift remaining bytes down to beginning of buffer.
        ::memmove(buf, buf + bnext, btotal);          
    }

    startAt += bnext;
    bnext = 0; 
    return S_OK;
}
//////////////////////////////////////////////////////////////////////////////////
// xiaoyu : here it assumes that it is a BYTE buffer, not a WCHAR byte, so it can be copied directly
HRESULT EncodingStream::AppendData( const BYTE* buffer, ULONG length, BOOL fLastBuffer)
{
    Assert(btotal >= bnext);
    lastBuffer = (fLastBuffer != FALSE);
    HRESULT hr;
    ULONG minlen = length + (btotal - bnext); // make sure we don't loose any data
    if (minlen < BUFFERSIZE)
        minlen = BUFFERSIZE;
    checkhr2( prepareForInput(minlen)); // guarantee enough space in the array
    
    if (length > 0 && buffer != NULL){
        // Copy raw data into new buffer.
        ::memcpy(buf + btotal, buffer, length);
        btotal += length;
    }
	if (pfnWideCharFromMultiByte == NULL) // first AppendData call
    {
        checkhr2(autoDetect());
    }
    

    return hr;
}
//////////////////////////////////////////////////////////////////////////////////
HRESULT EncodingStream::BufferData()
{
    HRESULT hr = S_OK;
    checkhr2(prepareForInput(0)); // 0 is used just for shift down (so bnext=0).

    if (_fEOF)          // already hit the end of the stream.
        return S_FALSE;

    const DWORD BUFSIZE = 4096;

    DWORD dwRead = 1;

    while (S_OK == hr && dwRead > 0)
    {
        // if we cannot fit another buffer full, then re-allocate.
        DWORD minsize = (btotal+BUFSIZE > bufsize) ? bufsize + BUFSIZE : bufsize;
        checkhr2( prepareForInput(minsize)); // make space available.

        dwRead = 0;
        hr = stream->Read(buf + btotal, BUFSIZE, &dwRead);
        btotal += dwRead;
    }

    if (SUCCEEDED(hr) && dwRead == 0)
    {
        _fEOF = true;
        hr = S_FALSE; // return S_FALSE when at eof.
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\xmlparser\encodingstream.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/////////////////////////////////////////////////////////////////////////////////
//
// fusion\xmlparser\EncodingStream.hxx
//
/////////////////////////////////////////////////////////////////////////////////
#ifndef _FUSION_XMLPARSER__ENCODINGSTREAM_H_INCLUDE_
#define _FUSION_XMLPARSER__ENCODINGSTREAM_H_INCLUDE_
#pragma once

#include "codepage.h"
#include "charencoder.h"
#include "core.h"				//UNUSED() is used
#include <ole2.h>
#include <xmlparser.h>
#include <objbase.h>
typedef _reference<IStream> RStream;

class EncodingStream : public _unknown<IStream, &IID_IStream>
{
protected:

    EncodingStream(IStream * stream);
    ~EncodingStream();

public:
	// create an EncodingStream for input
    static IStream * newEncodingStream(IStream * stream);
#ifdef FUSION_USE_OLD_XML_PARSER_SOURCE
	// create an EncodingStream for OUTPUT
    static IStream * EncodingStream::newEncodingStream(IStream * stream, Encoding * encoding); 
#endif

    HRESULT STDMETHODCALLTYPE Read(void * pv, ULONG cb, ULONG * pcbRead);

#ifdef FUSION_USE_OLD_XML_PARSER_SOURCE
	HRESULT STDMETHODCALLTYPE Write(void const* pv, ULONG cb, ULONG * pcbWritten);
#else
    HRESULT STDMETHODCALLTYPE Write(void const* pv, ULONG cb, ULONG * pcbWritten)
    {	
		UNUSED(pv);
		UNUSED(cb);
		UNUSED(pcbWritten);
        return E_NOTIMPL;
    }
#endif

    virtual HRESULT STDMETHODCALLTYPE Seek(LARGE_INTEGER dlibMove, DWORD dwOrigin, ULARGE_INTEGER * plibNewPosition)
    {
		UNUSED(dlibMove);
		UNUSED(dwOrigin);
		UNUSED(plibNewPosition);
        return E_NOTIMPL;
    }

    virtual HRESULT STDMETHODCALLTYPE SetSize(ULARGE_INTEGER libNewSize)
    {
		UNUSED(libNewSize);
        return E_NOTIMPL;
    }

    virtual HRESULT STDMETHODCALLTYPE CopyTo(IStream * pstm, ULARGE_INTEGER cb, ULARGE_INTEGER * pcbRead, ULARGE_INTEGER * pcbWritten)
    {
		UNUSED(pstm);
		UNUSED(cb);
		UNUSED(pcbRead);
		UNUSED(pcbWritten);

        return E_NOTIMPL;
    } 
 
    virtual HRESULT STDMETHODCALLTYPE Commit(DWORD grfCommitFlags)
    {
        return stream->Commit(grfCommitFlags);
    }
    
    virtual HRESULT STDMETHODCALLTYPE Revert(void)
    {
        return E_NOTIMPL;
    }

    virtual HRESULT STDMETHODCALLTYPE LockRegion( ULARGE_INTEGER libOffset, ULARGE_INTEGER cb, DWORD dwLockType)
    {
		UNUSED(libOffset);
		UNUSED(cb);
		UNUSED(dwLockType);

        return E_NOTIMPL;
    }

    virtual HRESULT STDMETHODCALLTYPE UnlockRegion(ULARGE_INTEGER libOffset, ULARGE_INTEGER cb, DWORD dwLockType)
    {
        UNUSED(libOffset);
		UNUSED(cb);
		UNUSED(dwLockType);

		return E_NOTIMPL;
    }

    virtual HRESULT STDMETHODCALLTYPE Stat(STATSTG * pstatstg, DWORD grfStatFlag)
    {
		UNUSED(pstatstg);
		UNUSED(grfStatFlag);
		
        return E_NOTIMPL;
    }

    virtual HRESULT STDMETHODCALLTYPE Clone(IStream ** ppstm)
    {
		UNUSED(ppstm);

        return E_NOTIMPL;
    }

    ///////////////////////////////////////////////////////////
    // public methods
    //

    /**
     * Defines the character encoding of the input stream.  
     * The new character encoding must agree with the encoding determined by the constructer.  
     * setEncoding is used to clarify between encodings that are not fully determinable 
     * through the first four bytes in a stream and not to change the encoding.
     * This method must be called within BUFFERSIZE reads() after construction.
     */
    HRESULT switchEncodingAt(Encoding * newEncoding, int newPosition);
#ifdef FUSION_USE_OLD_XML_PARSER_SOURCE
    /**
     * Gets encoding
     */
    Encoding * getEncoding();
#endif

	// For Read EncodingStreams, this method can be used to push raw data
    // which is an alternate approach to providing another IStream.
    HRESULT AppendData(const BYTE* buffer, ULONG length, BOOL lastBuffer);

    HRESULT BufferData();
  
    void setReadStream(bool flag) { _fReadStream = flag; }

#ifdef FUSION_USE_OLD_XML_PARSER_SOURCE
    void SetMimeType(const WCHAR * pwszMimeType, int length);
    void SetCharset(const WCHAR * pwszCharset, int length);
#endif
  
private:
	/**
	* Buffer Size
	*/
    static const int BUFFERSIZE;  
	
	HRESULT autoDetect();

    HRESULT prepareForInput(ULONG minlen);

    /**
     * Character encoding variables : xiaoyu: only encoding is used for reading, other three used for writeXML
     */ 
    CODEPAGE codepage;   // code page number
    Encoding * encoding; // encoding
    //bool  _fTextXML;     // MIME type, true: "text/xml", false: "application/xml"
    //bool  _fSetCharset;  // Whether the charset has been set from outside. e.g, when mime type text/xml or application/xml
                         // has charset parameter
    
    /** 
	* Multibyte buffer 
	*/
    BYTE	*buf;           // storage for multibyte bytes
    ULONG	bufsize;
    UINT	bnext;       // point to next available byte in the rawbuffer
    ULONG	btotal;     // total number of bytes in the rawbuffer
    int		startAt;        // where the buffer starts at in the input stream 
	
	/**
     * Function pointer to convert from multibyte to unicode
     */
    WideCharFromMultiByteFunc * pfnWideCharFromMultiByte;
#ifdef FUSION_USE_OLD_XML_PARSER_SOURCE
    /**
     * Function pointer to convert from unicode to multibytes
     */
    WideCharToMultiByteFunc * pfnWideCharToMultiByte;
#endif

	UINT maxCharSize;		// maximum number of bytes of a wide char
							// xiaoyu : used for writeXML, 
    RStream stream;
    bool	isInput;
    bool	lastBuffer;
    bool	_fEOF;
	bool	_fUTF8BOM;
    bool	_fReadStream;	// lets Read() method call Read() on wrapped stream object.
	

	DWORD _dwMode;			// MLANG context.

};

typedef _reference<EncodingStream> REncodingStream;

#endif _FUSION_XMLPARSER__ENCODINGSTREAM_H_INCLUDE_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\xmlparser\xmlhelper.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==

//#include "stdinc.h"
#define _CRTIMP
#include "utilcode.h"
#include <windows.h>
#include <shlwapi.h>
#include <wchar.h>
#include <string.h>
#include <stdio.h> 
#include <ole2.h>
#include <xmlparser.h>

#include "xmlhelper.h"

bool isCharAlphaW(WCHAR wChar)
{
    WORD ctype1info;

    if (!GetStringTypeW(CT_CTYPE1, &wChar, 1, &ctype1info)) {
        //
        // GetStringTypeW returned an error!  IsCharAlphaW has no
        // provision for returning an error...  The best we can do
        // is to return FALSE
        //
        //UserAssert(FALSE);
		ASSERT(FALSE);
        return FALSE;
    }
    if (ctype1info & C1_ALPHA) {
        return TRUE;
    } else {
        return FALSE;
    }
}
//////////////////////////////////////////////////////////////////////////////
bool isDigit(WCHAR ch)
{
    return (ch >= 0x30 && ch <= 0x39);
}
//////////////////////////////////////////////////////////////////////////////
bool isHexDigit(WCHAR ch)
{
    return (ch >= 0x30 && ch <= 0x39) || (ch >= 'a' && ch <= 'f') || (ch >= 'A' && ch <= 'F');
}
//////////////////////////////////////////////////////////////////////////////
bool isLetter(WCHAR ch)
{
	//return (ch >= 0X41);
    return (ch >= 0x41) && ::isCharAlphaW(ch);
        // isBaseChar(ch) || isIdeographic(ch);
}
//////////////////////////////////////////////////////////////////////////////
int isStartNameChar(WCHAR ch)
{
    return  (ch < TABLE_SIZE) ? (g_anCharType[ch] & (FLETTER | FSTARTNAME))
        : (isLetter(ch) || (ch == '_' || ch == ':'));
        
}
//////////////////////////////////////////////////////////////////////////////
bool isCombiningChar(WCHAR ch)
{
	UNUSED(ch);
    return false;
}
//////////////////////////////////////////////////////////////////////////////
bool isExtender(WCHAR ch)
{
    return (ch == 0xb7);
}
//////////////////////////////////////////////////////////////////////////////
bool isAlphaNumeric(WCHAR ch)
{
	//return (ch >= 0x30 && ch <= 0x39) ;
    return (ch >= 0x30 && ch <= 0x39) || ((ch >= 0x41) && isCharAlphaW(ch));
        // isBaseChar(ch) || isIdeographic(ch);
}
//////////////////////////////////////////////////////////////////////////////
int isNameChar(WCHAR ch)
{
    return  (ch < TABLE_SIZE ? (g_anCharType[ch] & (FLETTER | FDIGIT | FMISCNAME | FSTARTNAME)) :
              ( isAlphaNumeric(ch) || 
                ch == '-' ||  
                ch == '_' ||
                ch == '.' ||
                ch == ':' ||
                isCombiningChar(ch) ||
                isExtender(ch)));
}
//////////////////////////////////////////////////////////////////////////////
int isCharData(WCHAR ch)
{
    // it is in the valid range if it is greater than or equal to
    // 0x20, or it is white space.
    return (ch < TABLE_SIZE) ?  (g_anCharType[ch] & FCHARDATA)
        : ((ch < 0xD800 && ch >= 0x20) ||   // Section 2.2 of spec.
            (ch >= 0xE000 && ch < 0xfffe));
}
//==============================================================================
WCHAR BuiltinEntity(const WCHAR* text, ULONG len)
{
    ULONG ulength =  len * sizeof(WCHAR); // Length in chars
    switch (len)
    {
    case 4:
        if (::memcmp(L"quot", text, ulength) == 0)
        {
            return 34;
        }
        else if (::memcmp(L"apos", text, ulength) == 0)
        {
            return 39;
        }
        break;
    case 3:
        if (::memcmp(L"amp", text, ulength) == 0)
        {
            return 38;
        }
        break;
    case 2:
        if (::memcmp(L"lt", text, ulength) == 0)
        {
            return 60;
        }
        else if (::memcmp(L"gt", text, ulength) == 0)
        {
            return 62;
        }
        break;
    }
    return 0;
}
// Since we cannot use the SHLWAPI wnsprintfA function...
int DecimalToBuffer(long value, char* buffer, int j, long maxdigits)
{
    long max = 1;
    for (int k = 0; k < maxdigits; k++)
        max = max * 10;
    if (value > (max*10)-1)
        value = (max*10)-1;
    max = max/10;
    for (int i = 0; i < maxdigits; i++)
    {
        long digit = (value / max);
        value -= (digit * max);
        max /= 10;
        buffer[i+j] = char('0' + (char)digit);
    }
    buffer[i+j]=0;

    return i+j;
}
/////////////////////////////////////////////////////////////////////
int StrToBuffer(const WCHAR* str, WCHAR* buffer, int j)
{
    while (*str != NULL)
    {
        buffer[j++] = *str++;
    }
    return j;
}
//==============================================================================
const ULONG MAXWCHAR = 0xFFFF;
HRESULT DecimalToUnicode(const WCHAR* text, ULONG len, WCHAR& ch)
{
    ULONG result = 0;
    for (ULONG i = 0; i < len; i++)
    {
        ULONG digit = 0;
        if (text[i] >= L'0' && text[i] <= L'9')
        {
            digit = (text[i] - L'0');
        }
        else
            return XML_E_INVALID_DECIMAL;

        // Last unicode value (MAXWCHAR) is reserved as "invalid value"
        if (result >= (MAXWCHAR - digit) /10)       // result is about to overflow
            return XML_E_INVALID_UNICODE;          // the maximum 4 byte value.

        result = (result*10) + digit;
    }
    if (result == 0)    // zero is also invalid.
        return XML_E_INVALID_UNICODE;

    ch = (WCHAR)result;
    return S_OK;
}
//==============================================================================
HRESULT HexToUnicode(const WCHAR* text, ULONG len, WCHAR& ch)
{
    ULONG result = 0;
    for (ULONG i = 0; i < len; i++)
    {
        ULONG digit = 0;
        if (text[i] >= L'a' && text[i] <= L'f')
        {
            digit = 10 + (text[i] - L'a');
        }
        else if (text[i] >= L'A' && text[i] <= L'F')
        {
            digit = 10 + (text[i] - L'A');
        }
        else if (text[i] >= L'0' && text[i] <= L'9')
        {
            digit = (text[i] - L'0');
        }
        else
            return XML_E_INVALID_HEXIDECIMAL;

        // Last unicode value (MAXWCHAR) is reserved as "invalid value"
        if (result >= (MAXWCHAR - digit)/16)       // result is about to overflow
            return XML_E_INVALID_UNICODE;  // the maximum 4 byte value.

        result = (result*16) + digit;
    }
    if (result == 0)    // zero is also invalid.
        return XML_E_INVALID_UNICODE;
    ch = (WCHAR)result;
    return S_OK;
}

int CompareUnicodeStrings(PCWSTR string1, PCWSTR string2, int length, bool fCaseInsensitive)
{
  if (fCaseInsensitive)
    return _wcsnicmp(string1, string2, length);
  else
    return wcsncmp(string1, string2, length);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\xmlparser\xmlhelper.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/////////////////////////////////////////////////////////////////////////////////
//
// fusion\xmlparser\xmlhelper.hxx
//
/////////////////////////////////////////////////////////////////////////////////
#ifndef _FUSION_XMLPARSER__XMLHELPER_H_INCLUDE_
#define _FUSION_XMLPARSER__XMLHELPER_H_INCLUDE_
#pragma once


#include <winbase.h>
#include <stdio.h>
#include <wchar.h>
#ifdef _CRTIMP
#undef _CRTIMP
#endif
#define _CRTIMP 0
#include <string.h>
#include <windows.h>

#include "core.h"

#define checknull(a) if (!(a)) { hr = E_OUTOFMEMORY; goto error; }
#define breakhr(a) hr = (a); if (hr != S_OK) break;
#define checkhr2(a) hr = a; if (hr != S_OK) return hr;

// resolve built-in entities.
WCHAR BuiltinEntity(const WCHAR* text, ULONG len);

HRESULT HexToUnicode(const WCHAR* text, ULONG len, WCHAR& ch);
HRESULT DecimalToUnicode(const WCHAR* text, ULONG len, WCHAR& ch);

// --------------------------------------------------------------------
// A little helper class for setting a boolean flag and clearing it
// on destruction.
class BoolLock
{
    bool* _pFlag;
public:
    BoolLock(bool* pFlag)
    {
        _pFlag = pFlag;
        *pFlag = true;
    }
    ~BoolLock()
    {
        *_pFlag = false;
    }
};

//helper Functions
int DecimalToBuffer(long, char*, int, long);
int StrToBuffer(const WCHAR*, WCHAR*, int);
bool StringEquals(const WCHAR*, const WCHAR*, long, bool); 

//////////////////////////////////////////////////////////
enum
{
    FWHITESPACE    = 1,
    FDIGIT         = 2,
    FLETTER        = 4,
    FMISCNAME      = 8,
    FSTARTNAME     = 16,
    FCHARDATA      = 32
};

static const short TABLE_SIZE = 128;

static int g_anCharType[TABLE_SIZE] = { 
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0 | FWHITESPACE | FCHARDATA,
    0 | FWHITESPACE | FCHARDATA,
    0,
    0,
    0 | FWHITESPACE | FCHARDATA,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0 | FWHITESPACE | FCHARDATA,
    0 | FCHARDATA,
    0 | FCHARDATA,
    0 | FCHARDATA,
    0 | FCHARDATA,
    0 | FCHARDATA,
    0 | FCHARDATA,
    0 | FCHARDATA,
    0 | FCHARDATA,
    0 | FCHARDATA,
    0 | FCHARDATA,
    0 | FCHARDATA,
    0 | FCHARDATA,
    0 | FMISCNAME | FCHARDATA,
    0 | FMISCNAME | FCHARDATA,
    0 | FCHARDATA,
    0 | FDIGIT | FCHARDATA,
    0 | FDIGIT | FCHARDATA,
    0 | FDIGIT | FCHARDATA,
    0 | FDIGIT | FCHARDATA,
    0 | FDIGIT | FCHARDATA,
    0 | FDIGIT | FCHARDATA,
    0 | FDIGIT | FCHARDATA,
    0 | FDIGIT | FCHARDATA,
    0 | FDIGIT | FCHARDATA,
    0 | FDIGIT | FCHARDATA,
    0 | FSTARTNAME | FCHARDATA,
    0 | FCHARDATA,
    0 | FCHARDATA,
    0 | FCHARDATA,
    0 | FCHARDATA,
    0 | FCHARDATA,
    0 | FCHARDATA,
    0 | FLETTER | FCHARDATA,
    0 | FLETTER | FCHARDATA,
    0 | FLETTER | FCHARDATA,
    0 | FLETTER | FCHARDATA,
    0 | FLETTER | FCHARDATA,
    0 | FLETTER | FCHARDATA,
    0 | FLETTER | FCHARDATA,
    0 | FLETTER | FCHARDATA,
    0 | FLETTER | FCHARDATA,
    0 | FLETTER | FCHARDATA,
    0 | FLETTER | FCHARDATA,
    0 | FLETTER | FCHARDATA,
    0 | FLETTER | FCHARDATA,
    0 | FLETTER | FCHARDATA,
    0 | FLETTER | FCHARDATA,
    0 | FLETTER | FCHARDATA,
    0 | FLETTER | FCHARDATA,
    0 | FLETTER | FCHARDATA,
    0 | FLETTER | FCHARDATA,
    0 | FLETTER | FCHARDATA,
    0 | FLETTER | FCHARDATA,
    0 | FLETTER | FCHARDATA,
    0 | FLETTER | FCHARDATA,
    0 | FLETTER | FCHARDATA,
    0 | FLETTER | FCHARDATA,
    0 | FLETTER | FCHARDATA,
    0 | FCHARDATA,
    0 | FCHARDATA,
    0 | FCHARDATA,
    0 | FCHARDATA,
    0 | FMISCNAME | FSTARTNAME | FCHARDATA,
    0 | FCHARDATA,
    0 | FLETTER | FCHARDATA,
    0 | FLETTER | FCHARDATA,
    0 | FLETTER | FCHARDATA,
    0 | FLETTER | FCHARDATA,
    0 | FLETTER | FCHARDATA,
    0 | FLETTER | FCHARDATA,
    0 | FLETTER | FCHARDATA,
    0 | FLETTER | FCHARDATA,
    0 | FLETTER | FCHARDATA,
    0 | FLETTER | FCHARDATA,
    0 | FLETTER | FCHARDATA,
    0 | FLETTER | FCHARDATA,
    0 | FLETTER | FCHARDATA,
    0 | FLETTER | FCHARDATA,
    0 | FLETTER | FCHARDATA,
    0 | FLETTER | FCHARDATA,
    0 | FLETTER | FCHARDATA,
    0 | FLETTER | FCHARDATA,
    0 | FLETTER | FCHARDATA,
    0 | FLETTER | FCHARDATA,
    0 | FLETTER | FCHARDATA,
    0 | FLETTER | FCHARDATA,
    0 | FLETTER | FCHARDATA,
    0 | FLETTER | FCHARDATA,
    0 | FLETTER | FCHARDATA,
    0 | FLETTER | FCHARDATA,
    0 | FCHARDATA,
    0 | FCHARDATA,
    0 | FCHARDATA,
    0 | FCHARDATA,
    0 | FCHARDATA,
};

bool isDigit(WCHAR ch);
bool isHexDigit(WCHAR ch);
bool isLetter(WCHAR ch);
int isStartNameChar(WCHAR ch);
bool isCombiningChar(WCHAR ch);
bool isExtender(WCHAR ch);
bool isAlphaNumeric(WCHAR ch);
int isNameChar(WCHAR ch);
int isCharData(WCHAR ch);
int CompareUnicodeStrings(PCWSTR string1, PCWSTR string2, int length, bool fCaseInsensitive);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\xmlparser\xmlparser.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/////////////////////////////////////////////////////////////////////////////////
//
// fusion\xmlparser\xmlparser.cxx
// just commend "SysFreeString" and SysAllocString()
//
/////////////////////////////////////////////////////////////////////////////////

//#include "stdinc.h"
#include "core.h"
#include "xmlhelper.h"

#pragma hdrstop
#include "xmlparser.hpp"
#include "xmlstream.h"
#include <objbase.h>

#define CRITICALSECTIONLOCK CSLock lock(&_cs);
const USHORT STACK_INCREMENT=10;

#define PUSHNODEINFO(pNodeInfo)\
    if (_cNodeInfoAllocated == _cNodeInfoCurrent)\
    {\
        checkhr2(GrowNodeInfo());\
    }\
    _paNodeInfo[_cNodeInfoCurrent++] = _pCurrent;


//////////////////////////////////////////////////////////////////
class CSLock
{
public:
    CSLock(CRITICAL_SECTION * pcs); 
    ~CSLock();

private:
    CRITICAL_SECTION * _pcs;
};

CSLock::CSLock(CRITICAL_SECTION * pcs){ 
        _pcs = pcs; 
        ::EnterCriticalSection(pcs);
}
CSLock::~CSLock(){
        ::LeaveCriticalSection(_pcs);
}

/////////////////////////////////////////////////////////////////////////////
XMLParser::XMLParser()
:   _pDownloads(1), _pStack(STACK_INCREMENT)
{
    ctorInit();
}
/////////////////////////////////////////////////////////////////////////////
void
XMLParser::ctorInit()
{
    InitializeCriticalSection(&_cs);

    _pTokenizer = NULL;
    _pCurrent = NULL;
    _lCurrentElement = 0;
    _paNodeInfo = NULL;
    _cNodeInfoAllocated = _cNodeInfoCurrent = 0;
    _pdc = NULL;
    _usFlags = 0;
    _fCaseInsensitive = false;
    _bstrError = NULL;
//    _fTokenizerChanged = false;
    _fRunEntryCount = 0;
    _pszSecureBaseURL = NULL;
    _pszCurrentURL = NULL;
    _pszBaseURL = NULL;
    //_fInLoading = false;
    _fInsideRun = false;
    //_fFoundDTDAttribute = false;
    _cAttributes = 0;
    _pRoot = NULL;
    //_fAttemptedURL = NULL;
    _fLastError = S_OK;
    _fStopped = false;
    _fSuspended = false;
    _fStarted = false;
    _fWaiting = false;
    _fIgnoreEncodingAttr = false;
    _dwSafetyOptions = 0;

    // rest of initialization done in the init() method.

    //EnableTag(tagParserCallback, TRUE);
    //EnableTag(tagParserError, TRUE);
}
/////////////////////////////////////////////////////////////////////////////
XMLParser::~XMLParser()
{
    {
        CRITICALSECTIONLOCK;
        Reset();

        // Cleanup tagname buffers in context for good this time...
        for (long i = _pStack.size()-1; i>=0; i--)
        {
            MY_XML_NODE_INFO* pNodeInfo = _pStack[i];
            if (pNodeInfo->_pwcTagName != NULL)
            {
                delete [] pNodeInfo->_pwcTagName;
                pNodeInfo->_pwcTagName = NULL;
                pNodeInfo->_ulBufLen = 0;
            }
            // NULL out the node pointer in case it point's to a GC'd object :-)
            pNodeInfo->pNode = NULL;
        }
        delete _pszSecureBaseURL;
        delete _pszCurrentURL;

        delete[] _paNodeInfo;        
    }
    DeleteCriticalSection(&_cs);
}
/////////////////////////////////////////////////////////////////////////////
HRESULT STDMETHODCALLTYPE
XMLParser::QueryInterface(REFIID riid, void ** ppvObject)
{
    //STACK_ENTRY;  // xiaoyu : what it for?

    // Since this one class implements both IXMLNodeSource and
    // IXMLParser, we must override QueryInterface since the
    // IUnknown template doesn't know about the IXMLNodeSource
    // interface.

    HRESULT hr = S_OK;
    if (riid == IID_IXMLNodeSource || riid == IID_Parser)
    {
        *ppvObject = static_cast<IXMLNodeSource*>(this);        
        AddRef();
    }
    else
    {
        hr = _unknown<IXMLParser, &IID_IXMLParser>::QueryInterface(riid, ppvObject);
    }
    return hr;
}
/////////////////////////////////////////////////////////////////////////////
ULONG STDMETHODCALLTYPE
XMLParser::AddRef(void)
{
    //STACK_ENTRY;
    return _unknown<IXMLParser, &IID_IXMLParser>::AddRef();
}
/////////////////////////////////////////////////////////////////////////////
ULONG STDMETHODCALLTYPE
XMLParser::Release(void)
{
//    STACK_ENTRY;
    return _unknown<IXMLParser, &IID_IXMLParser>::Release();
}
/////////////////////////////////////////////////////////////////////////////
HRESULT STDMETHODCALLTYPE
XMLParser::SetInput(IUnknown *pStm)
{
    if (pStm == NULL)
        return E_INVALIDARG;

    //STACK_ENTRY_MODEL(_reThreadModel);
    CRITICALSECTIONLOCK;
    if (_pDownloads.used() == 0)
        init();
    HRESULT hr = S_OK;

    //checkhr2(PushTokenizer(NULL));
    checkhr2(PushTokenizer());

    // Get the url path
    // Continue even if we cannot get it
//    STATSTG stat;
    IStream * pStream = NULL;
//    memset(&stat, 0, sizeof(stat));
    hr = pStm->QueryInterface(IID_IStream, (void**)&pStream);
    if (SUCCEEDED(hr))
    {
        hr = PushStream(pStream, false);       
        pStream->Release(); 
    }
    return hr;
}
/////////////////////////////////////////////////////////////////////////////
HRESULT STDMETHODCALLTYPE
XMLParser::PushData(
            /* [in] */ const char __RPC_FAR *pData,
            /* [in] */ ULONG ulChars,
            /* [in] */ BOOL fLastBuffer)
{
    //STACK_ENTRY_MODEL(_reThreadModel);
    CRITICALSECTIONLOCK;
    HRESULT hr;

    if ((NULL == pData) && (ulChars != 0))
    {
        return E_INVALIDARG;
    }

    if (_pTokenizer == NULL)
    {
        init();
        //checkhr2(PushTokenizer(NULL));
        checkhr2(PushTokenizer());
    }
    return _pTokenizer->AppendData((const BYTE*)pData, ulChars, fLastBuffer);
}
/////////////////////////////////////////////////////////////////////////////
HRESULT STDMETHODCALLTYPE
XMLParser::SetFactory(IXMLNodeFactory __RPC_FAR *pNodeFactory)
{
    //STACK_ENTRY;

    CRITICALSECTIONLOCK;
    _pFactory = pNodeFactory;
    return S_OK;
}
/////////////////////////////////////////////////////////////////////////////
HRESULT STDMETHODCALLTYPE
XMLParser::GetFactory(IXMLNodeFactory** ppNodeFactory)
{
    if (ppNodeFactory == NULL) return E_INVALIDARG;
    if (_pFactory)
    {
        *ppNodeFactory = _pFactory;
        (*ppNodeFactory)->AddRef();
    }
    else
    {
        *ppNodeFactory = NULL;
    }
    return S_OK;
}
/////////////////////////////////////////////////////////////////////////////
HRESULT STDMETHODCALLTYPE
XMLParser::Run(long lChars)
{
    HRESULT hr = NOERROR;

    FN_TRACE_HR(hr);

    //STACK_ENTRY_MODEL(_reThreadModel);
    CRITICALSECTIONLOCK;

    XML_NODE_INFO   info;
    XML_NODE_INFO*  aNodeInfo[1];

    USHORT          numRecs;

    bool            fIsAttribute = false;
    bool            stop = false;

    if (_fSuspended)
        _fSuspended = FALSE; // caller must want to resume.

    if (_pFactory == NULL)
    {

        return E_FAIL;
    }

    if (_fStopped)
    {        

        return XML_E_STOPPED;
    }

    if (_pTokenizer == NULL) 
    {
        if (_fLastError != S_OK)
		{
            return _fLastError;
		}
        else
		{

            // must be _fStarted == false
            return XMLPARSER_IDLE;
		}
    }

    // Check for recurrsive entry and whether caller actually
    // wants anything parsed.
    if (_fInsideRun || lChars == 0)
	{

        return E_PENDING;
	}

    BoolLock flock(&_fInsideRun);

    if (_fLastError != 0)
    {
        // one more chance to cleanup the parser stack.
        hr = _fLastError;
        goto cleanup_stack;
    }

    if (! _fStarted)
    {
        _fStarted = true;
        hr = _pFactory->NotifyEvent(this, XMLNF_STARTDOCUMENT);
        if (_fStopped)      // watch for onReadyStateChange handlers 
            return S_OK;    // fussing with the parser state.
    }

    _fWaiting = false;
    if (_fPendingBeginChildren)
    {
        _fPendingBeginChildren = false;
        hr = _pFactory->BeginChildren(this, (XML_NODE_INFO*)_pCurrent);
    }
    if (_fPendingEndChildren)
    {
        _fPendingEndChildren = false;
        hr = _pFactory->EndChildren(this, TRUE, (XML_NODE_INFO*)_pCurrent);
        if (!hr)
            hr = pop(); // no match needed
    }

    info.dwSize = sizeof(XML_NODE_INFO);
    info.dwType = XMLStream::XML_PENDING;
    info.dwSubType = 0;
    info.pwcText = NULL;
    info.ulLen = 0;
    info.ulNsPrefixLen = 0;
    info.pNode = NULL;
    info.pReserved = NULL;
    aNodeInfo[0] = &info;

more:
    _fRunEntryCount++; // count of callers inside this loop...

    while (hr == 0 && ! _fSuspended)
    {
        info.dwSubType = 0;

        // The XMLStream error codes have been aligned with the
        // XMLParser error code so no mapping is necessary.
        hr = _pTokenizer->GetNextToken(&info.dwType, (const WCHAR  **)&info.pwcText, (long*)&info.ulLen, (long*)&info.ulNsPrefixLen);
        if (hr == E_PENDING)
        {
            _fWaiting = true;
            break;
        }

        if (! _fFoundNonWS &&
                info.dwType != XMLStream::XML_PENDING &&
                info.dwType != XML_WHITESPACE &&
                info.dwType != XML_XMLDECL)
        {
            _fFoundNonWS = true;
        }

        // Now the NodeType is the same as the XMLToken value.  We set
        // this up by aligning the two enums.
        switch (info.dwType)
        {
        case 0:
            if (hr == XML_E_INVALIDSWITCH  && _fIgnoreEncodingAttr)
            {
                hr = 0; // ignore it and continue on.
            }
            break;
            // --------- Container Nodes -------------------
        case XML_XMLDECL:
            //if (_fFoundNonWS && ! _fIE4Mode)  // IE4 allowed this...
            if (_fFoundNonWS)
            {
                hr = XML_E_BADXMLDECL;
                break;
            }
//            _fFoundNonWS = true;
            goto containers;

        case XML_ATTRIBUTE:
            fIsAttribute = true;
            goto containers; 

        case XML_VERSION:
            info.dwSubType = info.dwType;
            info.dwType = XML_ATTRIBUTE;
            _fGotVersion = true;
            fIsAttribute = true;
            goto containers;

        case XML_STANDALONE:
        case XML_ENCODING:
            if (! _fGotVersion && _pDownloads.used() == 1)
            {
                hr = XML_E_EXPECTING_VERSION;
                break;
            }
            if (info.dwType == XML_STANDALONE)
            {
                if (_pDownloads.used() > 1)
                {
                    hr = XML_E_UNEXPECTED_STANDALONE;
                    break;
                }
            }
            info.dwSubType = info.dwType;
            info.dwType = XML_ATTRIBUTE;
            fIsAttribute = true;
            goto containers;
            // fall through
        case XML_ELEMENT:
containers:
            if (_fRootLevel)
            {
                // Special rules apply for root level tags.
                if (info.dwType == XML_ELEMENT)
                {
                     // This is a root level element.
                     if (! _fFoundRoot)
                     {
                         _fFoundRoot = true;
                     }
                     else
                     {

                         hr = XML_E_MULTIPLEROOTS;
                         break;
                     }
                }
                else if (info.dwType != XML_PI &&
                         info.dwType != XML_XMLDECL &&
                         info.dwType != XML_DOCTYPE)
                {

                    hr = XML_E_INVALIDATROOTLEVEL;
                    break;
                }
            }

            info.fTerminal = FALSE;

            if (fIsAttribute)
            {
                breakhr( pushAttribute(info));
                fIsAttribute = false;
            }
            else
            {
                breakhr( push(info));
            }
            break;
        case XML_PCDATA:
        case XML_CDATA:
terminals:
            // Special rules apply for root level tags.
            if (_fRootLevel)
            {

                hr = XML_E_INVALIDATROOTLEVEL;
                break;
            }
            // fall through
        case XML_COMMENT:
        case XML_WHITESPACE:
tcreatenode:
            info.fTerminal = TRUE;
            if (_cAttributes != 0)
            {
                // We are inside the attribute list, so we need to push this.
                hr = pushAttributeValue(info);
                break;
            }
            hr = _pFactory->CreateNode(this, _pNode, 1, aNodeInfo);
            info.pNode = NULL;
            break;

        case XML_ENTITYREF:
            if (_fRootLevel)
            {
                hr = XML_E_INVALIDATROOTLEVEL;
                break;
            }

            // We handle builtin entities and char entities in xmlstream
            // so these must be user defined entity, so treat it like a regular terminal node.
            goto terminals;
            break;

        case XMLStream::XML_BUILTINENTITYREF:
        case XMLStream::XML_HEXENTITYREF:
        case XMLStream::XML_NUMENTITYREF:
            // pass real entityref type as subtype so we can publish these
            // subtypes eventually.
            info.dwSubType = info.dwType; // XML_ENTITYREF;
            info.dwType = XML_PCDATA;

            if (_cAttributes == 0)
            {
                goto tcreatenode;
            }

            // We are inside the attribute list, so we need to push this.
            info.fTerminal = TRUE;
            hr = pushAttributeValue(info);
            if (SUCCEEDED(hr))
            {
                hr = CopyText(_pCurrent);
            }
            break;
        
        case XMLStream::XML_TAGEND:     // ">"
            numRecs = 1+_cAttributes;
            if (_cAttributes != 0)  // this is safe because _rawstack does NOT reclaim
            {                       // the popped stack entries.
                popAttributes();
            }
            hr = _pFactory->CreateNode(this, _pNode, numRecs, (XML_NODE_INFO **)&_paNodeInfo[_lCurrentElement]);
            _pNode = _pCurrent->pNode;
            if (FAILED(hr))
            {
                _fPendingBeginChildren = true;
                break;
            }
            breakhr( _pFactory->BeginChildren(this, (XML_NODE_INFO*)_pCurrent));
            break;

			// The ENDXMLDECL is like EMPTYENDTAGs since we've been
            // buffering up their attributes, and we have still got to call CreateNode.
		case XMLStream::XML_ENDXMLDECL:
            _fGotVersion = false; // reset back to initial state.
            // fall through.
        case XMLStream::XML_EMPTYTAGEND:
            numRecs = 1+_cAttributes;
            if (_cAttributes != 0)
            {
                popAttributes();
            }
            hr = _pFactory->CreateNode(this, _pNode, numRecs, (XML_NODE_INFO **)&_paNodeInfo[_lCurrentElement]);
            if (FAILED(hr))
            {
                _fPendingEndChildren = true;
                break;
            }
            breakhr(_pFactory->EndChildren(this, TRUE, (XML_NODE_INFO*)_pCurrent));
            breakhr(pop()); // no match needed
            break;

        case XMLStream::XML_ENDTAG:     // "</"
            if (_pStack.used() == 0)
            {

                hr = XML_E_UNEXPECTEDENDTAG;
            }
            else
            {
                XML_NODE_INFO* pCurrent = (XML_NODE_INFO*)_pCurrent; // save current record
                breakhr(pop(info.pwcText, info.ulLen)); // check tag/match
                breakhr(_pFactory->EndChildren(this, FALSE, (XML_NODE_INFO*)pCurrent));
            }
            break;
        
        case XMLStream::XML_ENDPROLOG:
            // For top level document only, (not for DTD's or
            // entities), call EndProlog on the node factory.
            if (_fRootLevel && ! _pdc->_fEntity && ! _pdc->_fDTD)
                breakhr( _pFactory->NotifyEvent(this, XMLNF_ENDPROLOG));
            break;

        default:
            hr = E_FAIL;
            break; // break from switch()
        }
    }
    _fRunEntryCount--;

    stop = false;
    if (hr == XML_E_ENDOFINPUT)
    {
        hr = S_OK;
        bool inDTD = _pdc->_fDTD;
        bool inEntity = _pdc->_fEntity;
        bool inPEReference = _pdc->_fPEReference;

        if (inEntity && _pdc->_fDepth != _pStack.used())
        {

            // Entity itself was unbalanced.
            hr = ReportUnclosedTags(_pdc->_fDepth);
        }
        else if (PopDownload() == S_OK)
        {
            // then we must have just finished a DTD and we still have more to do
            // BUGBUG -- need to check that entity is well formed, i.e. no tags
            // left open.

            if (!inPEReference)
            {
                if (inEntity)
                {
                    hr = _pFactory->NotifyEvent(this, XMLNF_ENDENTITY);
                }
                else if (inDTD)
                {
                    hr = _pFactory->NotifyEvent(this, XMLNF_ENDDTD);                    
                }
            }
            if (FAILED(hr))
            {
                goto cleanup_stack;
            }

            // In a synchronous DTD download, there is another parser
            // parser Run() call on the stack above us, so let's return
            // back to that Run method so we don't complete the parsing
            // out from under it.
            if (_fRunEntryCount > 0)
                return S_OK;

            if (_fStopped)
                return S_OK;
            goto more;
        }
        else
        {
            if (_pStack.used() > 0)
            {
                hr = ReportUnclosedTags(0);
            }
            else if (! _fFoundRoot)
            {

                hr = XML_E_MISSINGROOT;
            }
            stop = true;
        }
    }

cleanup_stack:

    if (hr != S_OK && hr != E_PENDING)
    {
        stop = true;
        _fLastError = hr;

        // Pass all the XML_NODE_INFO structs to the Error function so the client
        // gets a chance to cleanup the PVOID pNode fields.
        HRESULT edr = _pFactory->Error(this, hr,
            (USHORT)(_paNodeInfo ? _lCurrentElement+1 : 0), (XML_NODE_INFO**)_paNodeInfo);
        if (edr != 0)
            _fLastError = hr;
    }

    if (stop && ! _fStopped)
    {
        //TraceTag((tagParserError, "Parser stopping with hr %x", hr));
        _fLastError = hr;
        _fStopped = true;
        _fStarted = false;
        HRESULT edr;
        edr = _pFactory->NotifyEvent(this, XMLNF_ENDDOCUMENT);
        if (edr != 0)
        {
            hr = edr; // allow factory to change error code (except to S_OK)
            if (S_OK == _fLastError)
            {
                // Make sure the node factory always finds out about errors.
                edr = _pFactory->Error(this, hr, 0, NULL);
                if (edr != 0)
                    hr = edr;
            }
            _fLastError = hr;
        }
    }
    return hr;
}
/////////////////////////////////////////////////////////////////////////////
HRESULT
XMLParser::popAttributes()
{
    // Now I pop all the attributes that were pushed for this tag.
    // I know we have at least one attribute.
    
    while (_cAttributes > 0)
    {
        popAttribute(); // no match needed
    }
    Assert(_pStack.used() == _lCurrentElement+1);

    return S_OK;
}
/////////////////////////////////////////////////////////////////////////////
HRESULT STDMETHODCALLTYPE
XMLParser::GetParserState(void)
{
    CRITICALSECTIONLOCK;

    if (_fLastError != 0)
        return XMLPARSER_ERROR;

    if (_fStopped)
        return XMLPARSER_STOPPED;

    if (_fSuspended)
        return XMLPARSER_SUSPENDED;

    if (! _fStarted)
        return XMLPARSER_IDLE;

    if (_fWaiting)
        return XMLPARSER_WAITING;

    return XMLPARSER_BUSY;
}
/////////////////////////////////////////////////////////////////////////////
HRESULT STDMETHODCALLTYPE
XMLParser::Abort(
            /* [in] */ BSTR bstrErrorInfo)
{
    //STACK_ENTRY_MODEL(_reThreadModel);

    // Have to set these before Critical Section to notify Run()
    _fStopped = true;
    _fSuspended = true; // force Run to terminate...

    CRITICALSECTIONLOCK;
    //TraceTag((tagParserError, "Parser aborted - %ls", bstrErrorInfo));

    //BUGBUG: may need to check bstrErrorInfo is NULL or not 
    //        and the returned result so that we can report 
    //        E_OUTOFMEMORY error
    //if (_bstrError) ::SysFreeString(_bstrError);
    //_bstrError = ::SysAllocString(bstrErrorInfo);

    // abort all downloads
/*    for (int i=_pDownloads.used()-1;  i>=0;  --i)
    {
        URLStream* stm = _pDownloads[i]->_pURLStream;
        if (stm)
            stm->Abort();
    }
*/
    return S_OK;
}
/////////////////////////////////////////////////////////////////////////////
HRESULT STDMETHODCALLTYPE
XMLParser::Suspend( void)
{
    _fSuspended = true; // force Run to suspend
    return S_OK;
}
/////////////////////////////////////////////////////////////////////////////
HRESULT STDMETHODCALLTYPE
XMLParser::Reset( void)
{
//  STACK_ENTRY;

    CRITICALSECTIONLOCK;

    init();

    delete _pszCurrentURL;
    _pszCurrentURL = NULL;
    delete _pszBaseURL;
    _pszBaseURL = NULL;
    _pRoot = NULL;
    _pFactory = NULL;
    _pNode = NULL;
    //if (_bstrError != NULL) ::SysFreeString(_bstrError);
    _bstrError = NULL;
    //if (_fAttemptedURL != NULL) ::SysFreeString(_fAttemptedURL);
    //_fAttemptedURL = NULL;
    return S_OK;
}
/////////////////////////////////////////////////////////////////////////////
ULONG STDMETHODCALLTYPE
XMLParser::GetLineNumber(void)
{
    CRITICALSECTIONLOCK;
    if (_pTokenizer)  return _pTokenizer->GetLine();
	else return 0;
}
/////////////////////////////////////////////////////////////////////////////
ULONG STDMETHODCALLTYPE
XMLParser::GetLinePosition( void)
{
    CRITICALSECTIONLOCK;
    if (_pTokenizer) return _pTokenizer->GetLinePosition();
    else return 0;
}
/////////////////////////////////////////////////////////////////////////////
ULONG STDMETHODCALLTYPE
XMLParser::GetAbsolutePosition( void)
{
    CRITICALSECTIONLOCK;
    if (_pTokenizer) return _pTokenizer->GetInputPosition();
    else return 0;
}
/////////////////////////////////////////////////////////////////////////////
HRESULT STDMETHODCALLTYPE
XMLParser::GetLineBuffer(
            /* [out] */ const WCHAR __RPC_FAR *__RPC_FAR *ppwcBuf,
            /* [out] */ ULONG __RPC_FAR *pulLen,
            /* [out] */ ULONG __RPC_FAR *pulStartPos)
{
    if (pulLen == NULL || pulStartPos == NULL) return E_INVALIDARG;

    //STACK_ENTRY;

    CRITICALSECTIONLOCK;
    if (_pTokenizer)
    {
        return _pTokenizer->GetLineBuffer(ppwcBuf, pulLen, pulStartPos);
    }
    *ppwcBuf = NULL;
    *pulLen = 0;
    return S_OK;
}
/////////////////////////////////////////////////////////////////////////////
HRESULT STDMETHODCALLTYPE
XMLParser::GetLastError( void)
{
    return _fLastError;
}

//------------ PRIVATE METHODS --------------------------------------------------
HRESULT
//XMLParser::PushTokenizer(
//				  URLStream* stream)
XMLParser::PushTokenizer()
{
    _pTokenizer = NEW (XMLStream(this));
    if (_pTokenizer == NULL)
        return E_OUTOFMEMORY;

    _pTokenizer->SetFlags(_usFlags);
//    _fTokenizerChanged = true;

    //HRESULT hr= PushDownload(stream, _pTokenizer);
    HRESULT hr= PushDownload(_pTokenizer);
    if (FAILED(hr))
    {
        delete _pTokenizer;
        _pTokenizer = NULL;
        return hr;
    }
    return S_OK; 
}
/////////////////////////////////////////////////////////////////////////////
HRESULT
//XMLParser::PushDownload(URLStream* stream, XMLStream* tokenizer)
XMLParser::PushDownload(XMLStream* tokenizer)
{
    // NOTE: tokenizer can be null, in the case of a parameter entity download.

    _pdc = _pDownloads.push();
    if (_pdc == NULL)
    {
        return E_OUTOFMEMORY;
    }
    if (_pDownloads.used() > 1)
        _fRootLevel = false;

    _pdc->_pTokenizer = tokenizer;
    _pdc->_fDTD = false;
    _pdc->_fEntity = false;
    _pdc->_fAsync = false;
    _pdc->_fFoundNonWS = _fFoundNonWS;
    _pdc->_fFoundRoot = _fFoundRoot;
    _pdc->_fRootLevel = _fRootLevel;
    _pdc->_fDepth = _pStack.used();

    _fFoundNonWS = false;
    _fFoundRoot = false;

    _fRootLevel = (_pStack.used() == 0 && _pDownloads.used() == 1);

    HRESULT hr = S_OK;

    return hr;
}
/////////////////////////////////////////////////////////////////////////////
HRESULT 
XMLParser::PushStream(IStream* pStm, bool fpe)
{
    EncodingStream* stream = (EncodingStream*)EncodingStream::newEncodingStream(pStm); // refcount = 1
    if (stream == NULL)
        return E_OUTOFMEMORY;
/*
    if (_usFlags & XMLFLAG_RUNBUFFERONLY)
        stream->setReadStream(false);
*/
    _pdc->_pEncodingStream = stream;
    stream->Release(); // Smart pointer is holding a ref

    HRESULT hr = _pTokenizer->PushStream(stream, fpe);
    if (hr == E_PENDING)
    {
        _fWaiting = true;
    }
    return hr;
}
/////////////////////////////////////////////////////////////////////////////
HRESULT
XMLParser::PopDownload()
{
    // NOTE: tokenizer can be null, in the case of a parameter entity download.
    HRESULT hr = S_OK;

    if (_pdc != NULL)
    {
        if (_pdc->_pTokenizer)
        {
            _pdc->_pTokenizer->Reset();
            delete _pdc->_pTokenizer;
            _pdc->_pTokenizer = NULL;
        }
        _pdc->_pEncodingStream = NULL;
/*
        if (_pdc->_pURLStream)
            _pdc->_pURLStream->Reset();

        _pdc->_pURLStream = NULL;
*/
        // restore saved value of foundnonws.
        _fFoundNonWS = _pdc->_fFoundNonWS;
        _pdc = _pDownloads.pop();
    }
    if (_pdc != NULL)
    {
        if (_pdc->_pTokenizer != NULL)
        {
            _pTokenizer = _pdc->_pTokenizer;
        }
        /*
        if (_pdc->_pURLStream != NULL)
        {
            hr = SetCurrentURL(_pdc->_pURLStream->GetURL()->getResolved());
        }
        */
    }
    else
    {
        _pTokenizer = NULL;
        hr = S_FALSE;
    }

    if (_pStack.used() == 0 && _pDownloads.used() == 1)
        _fRootLevel = true;

    return hr;
}
/////////////////////////////////////////////////////////////////////////////
HRESULT
XMLParser::GrowNodeInfo()
{
    USHORT newsize = _cNodeInfoAllocated + STACK_INCREMENT;
    MY_XML_NODE_INFO** pNewArray = NEW (PMY_XML_NODE_INFO[newsize]);
    if (pNewArray == NULL)
        return E_OUTOFMEMORY;
    // Now since STACK_INCREMENT is the same for _pStack then _pStack
    // has also re-allocated.  Therefore we need to re-initialize all
    // the pointers in this array - since they point into the _pStack's memory.
    for (int i = _pStack.used() - 1; i >= 0; i--)
    {
        pNewArray[i] = _pStack[i];
    }
    delete[] _paNodeInfo;
    _paNodeInfo = pNewArray;
    _cNodeInfoAllocated = newsize;
    return S_OK;
}
/////////////////////////////////////////////////////////////////////////////
HRESULT
XMLParser::GrowBuffer(PMY_XML_NODE_INFO pNodeInfo, long newlen)
{
    delete [] pNodeInfo->_pwcTagName;
    pNodeInfo->_pwcTagName = NULL;
    // add 50 characters to avoid too many reallocations.
    pNodeInfo->_pwcTagName = NEW (WCHAR[ newlen ]);
    if (pNodeInfo->_pwcTagName == NULL)
        return E_OUTOFMEMORY;
    pNodeInfo->_ulBufLen = newlen;
    return S_OK;
}
/////////////////////////////////////////////////////////////////////////////
HRESULT
XMLParser::push(XML_NODE_INFO& info)
{
    HRESULT hr;
    _lCurrentElement = _pStack.used();

    _pCurrent = _pStack.push();
    if (_pCurrent == NULL)
        return E_OUTOFMEMORY;

    *((XML_NODE_INFO*)_pCurrent) = info;
    PUSHNODEINFO(_pCurrent);

    _fRootLevel = false;

    // Save the tag name into the private buffer so it sticks around until the
    // close tag </foo> which could be anywhere down the road after the
    // BufferedStream been overwritten

    // THIS CODE IS OPTIMIZED FOR PERFORMANCE WHICH IS WHY IT IS NOT
    // CALLING THE CopyText METHOD.

    
	if (_pCurrent->_ulBufLen < info.ulLen+1)
    {
        checkhr2(GrowBuffer(_pCurrent, info.ulLen + 50));
    }
    Assert(info.ulLen >= 0);
    ::memcpy(_pCurrent->_pwcTagName, info.pwcText, info.ulLen*sizeof(WCHAR));
    _pCurrent->_pwcTagName[info.ulLen] = L'\0';

    // And make the XML_NODE_INFO point to private buffer.
    _pCurrent->pwcText = _pCurrent->_pwcTagName;

    return S_OK;
}
/////////////////////////////////////////////////////////////////////////////
HRESULT
XMLParser::pushAttribute(XML_NODE_INFO& info)
{
    HRESULT hr;
    if (_cAttributes != 0)
    {
        // Attributes are special in that they are supposed to be unique.
        // So here we actually check this.
        for (long i = _pStack.used()-1; i > _lCurrentElement; i--)
        {
            XML_NODE_INFO* ptr = _pStack[i];

            if (ptr->dwType != XML_ATTRIBUTE)
                continue; // ignore attribute values.

            if (ptr->ulLen != info.ulLen)
            {
                continue; // we're ok with this one
            }

            // Optimized for the normal case where there is no match
            if (::memcmp(ptr->pwcText, info.pwcText, info.ulLen*sizeof(WCHAR)) == 0)
            {
                if (! _fCaseInsensitive)
                {

                    return XML_E_DUPLICATEATTRIBUTE;
                }
                //else if (StrCmpNI(ptr->pwcText, info.pwcText, info.ulLen) == 0)
//                else if (::FusionpCompareStrings(ptr->pwcText, lstrlen(ptr->pwcText), info.pwcText, info.ulLen, true) == 0)
				  else if (_wcsnicmp(ptr->pwcText, info.pwcText, info.ulLen) == 0)
                {

                    // Duplicate attributes are allowed in IE4 mode!!
                    // But only the latest one shows up
                    // So we have to delete the previous duplication
                    return XML_E_DUPLICATEATTRIBUTE;
                }
            }
        }
    }

    _cAttributes++;

    _pCurrent = _pStack.push();
    if (_pCurrent == NULL)
        return E_OUTOFMEMORY;

    *((XML_NODE_INFO*)_pCurrent) = info;
    PUSHNODEINFO(_pCurrent);

    return S_OK;
}
/////////////////////////////////////////////////////////////////////////////
HRESULT
XMLParser::pushAttributeValue(XML_NODE_INFO& info)
{
    HRESULT hr;
    // Attributes are saved in the BufferedStream so we can point to the
    // real text in the buffered stream instead of copying it !!

    _pCurrent = _pStack.push();
    if (_pCurrent == NULL)
        return E_OUTOFMEMORY;

    // store attribute value quote character in the pReserved field.
    info.pReserved = (PVOID)_pTokenizer->getAttrValueQuoteChar();

    *((XML_NODE_INFO*)_pCurrent) = info;
    PUSHNODEINFO(_pCurrent);

    // this is really the count of nodes on the stack, not just attributes.
    _cAttributes++;
    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
HRESULT
XMLParser::pop(const WCHAR* tag, ULONG len)
{
    HRESULT hr = S_OK;

    if (_pCurrent == NULL || _pStack.used() == 0)
    {

        hr = XML_E_UNEXPECTEDENDTAG;
        goto Cleanup;
    }
    if (len != 0)
    {
        if (_pCurrent->ulLen != len)
        {

            hr = XML_E_ENDTAGMISMATCH;
        }
        // Optimized for the normal case where there is no match
        else if (::memcmp(_pCurrent->pwcText, tag, len*sizeof(WCHAR)) != 0)
        {
            if (! _fCaseInsensitive)
            {

                hr = XML_E_ENDTAGMISMATCH;
            }
            //else if ( XML_StrCmpNI(_pCurrent->pwcText, tag, len) != 0 )
            //else if (::FusionpCompareStrings(_pCurrent->pwcText, len, tag, len, true) != 0)
			else if(_wcsnicmp(_pCurrent->pwcText, tag, len) != 0)
            {
                hr = XML_E_ENDTAGMISMATCH;
            }
        }
        if (hr)
        {
            /*
            TRY
            {
                String* s = Resources::FormatMessage(hr, String::newString(_pCurrent->pwcText, 0, _pCurrent->ulLen),
                                                         String::newString(tag, 0, len), NULL);
                _bstrError = s->getBSTR();
            }
            CATCH
            {
                hr = ERESULT;
            }
            ENDTRY
            */
            goto Cleanup;
        }
    }

    // We don't delete the fTagName because we're going to reuse this field
    // later to avoid lots of memory allocations.

    _pCurrent = _pStack.pop();
    _cNodeInfoCurrent--;

    if (_pCurrent == 0)
    {
        _pNode = _pRoot;
        if (_pDownloads.used() == 1)
            _fRootLevel = true;
    }
    else
    {
        _pNode = _pCurrent->pNode;
    }

Cleanup:
    return hr;
}
/////////////////////////////////////////////////////////////////////////////
HRESULT XMLParser::pop()
{
    // We don't delete the fTagName because we're going to reuse this field
    // later to avoid lots of memory allocations.

    _pCurrent = _pStack.pop();
    _cNodeInfoCurrent--;

    if (_pCurrent == 0)
    {
        _pNode = _pRoot;
        if (_pDownloads.used() == 1)
            _fRootLevel = true;
    }
    else
    {
        _pNode = _pCurrent->pNode;
    }
    return S_OK;
}
/////////////////////////////////////////////////////////////////////////////
void XMLParser::popAttribute()
{
    Assert(_pStack.used() > 0);

    _pCurrent = _pStack.pop();
    _cNodeInfoCurrent--;

    Assert(_pCurrent != 0);

    _cAttributes--;

}
/////////////////////////////////////////////////////////////////////////////
HRESULT
XMLParser::CopyText(PMY_XML_NODE_INFO pNodeInfo)
{
    HRESULT hr = S_OK;
    if (pNodeInfo->_pwcTagName != pNodeInfo->pwcText)
    {
        ULONG len = pNodeInfo->ulLen;

        // Copy the current text into the buffer.
        if (pNodeInfo->_ulBufLen < len+1)
        {
            checkhr2(GrowBuffer(pNodeInfo, len + 50));
        }
        if (len > 0)
        {
            ::memcpy(pNodeInfo->_pwcTagName, pNodeInfo->pwcText, len*sizeof(WCHAR));
        }
        pNodeInfo->_pwcTagName[len] = L'\0';

        // And make the XML_NODE_INFO point to private buffer.
        pNodeInfo->pwcText = pNodeInfo->_pwcTagName;
    }
    return S_OK;
}
/////////////////////////////////////////////////////////////////////////////
HRESULT
XMLParser::CopyContext()
{
    // For performance reasons we try not to copy the data for attributes
    // and their values when we push them on the stack.  We can do this
    // because the tokenizer tries to freeze the internal buffers while
    // parsing attributes and thereby guarentee that the pointers stay
    // good.  But occasionally the BufferedStream has to reallocate when
    // the attributes are right at the end of the buffer.

    long last = _pStack.used();
    for (long i = _cAttributes; i > 0 ; i--)
    {
        long index = last - i;
        MY_XML_NODE_INFO* ptr = _pStack[index];
        CopyText(ptr);
    }
    return S_OK;
}
/////////////////////////////////////////////////////////////////////////////
HRESULT XMLParser::ReportUnclosedTags(int start)
{
    HRESULT hr = XML_E_UNCLOSEDTAG;
    // Build a string containing the list of unclosed tags and format an error
    // message containing this text.
    int tags = _pStack.used();

    WCHAR* buffer = NULL;
    WCHAR* msgbuf = NULL;
    unsigned long size = 0;
    unsigned long used = 0;

    for (long i = start; i < tags; i++)
    {
        XML_NODE_INFO* ptr = _pStack[i];
        if (ptr->dwType == XML_ATTRIBUTE)
            break;

        if (used + ptr->ulLen + 3 > size) // +3 for '<','>' and '\0'
        {
            long newsize = used + ptr->ulLen + 500;
            WCHAR* newbuf = NEW (WCHAR[newsize]);
            if (newbuf == NULL)
            {
                goto nomem;
            }
            if (buffer != NULL)
            {
                ::memcpy(newbuf, buffer, used);
                delete[] buffer;
            }

            size = newsize;
            buffer = newbuf;
        }
        if (i > start)
        {
            buffer[used++] = ',';
            buffer[used++] = ' ';
        }
        ::memcpy(&buffer[used], ptr->pwcText, sizeof(WCHAR) * ptr->ulLen);
        used += ptr->ulLen;
        buffer[used] = '\0';
    }
    goto cleanup; 

	//xiaoyu : SysAllocString and SysFreeString are commended off. 
//    msgbuf = ::FormatMessageInternal(g_hInstance, XML_E_UNCLOSEDTAG, buffer, NULL);
/*  
    TRY
    {
        String* s = Resources::FormatMessage(XML_E_UNCLOSEDTAG,
            String::newString(buffer), NULL);
        _bstrError = s->getBSTR();
        goto cleanup;
    }
    CATCH
    {
        hr = ERESULT;
        goto done;
    }
    ENDTRY
    
    
    if (msgbuf == NULL)
        goto nomem;

    if (_bstrError) ::SysFreeString(_bstrError);
    _bstrError = ::SysAllocString(msgbuf);
    if (_bstrError == NULL)
        goto nomem;

    goto cleanup;
*/
nomem:
    hr = E_OUTOFMEMORY;

cleanup:    

    delete [] buffer;
    delete [] msgbuf;

    return hr;
}
/////////////////////////////////////////////////////////////////////////////
HRESULT XMLParser::init()
{
    CRITICALSECTIONLOCK;

    _fLastError = 0;
    _fStopped = false;
    _fSuspended = false;
    _pNode = _pRoot;
    _fStarted = false;
    _fStopped = false;
    _fWaiting = false;
    _fFoundRoot = false;
    _fFoundNonWS = false;
    _pTokenizer = NULL;
    _fGotVersion = false;
    _fRootLevel = true;
    _cAttributes = 0;
    

    _fPendingBeginChildren = false;
    _fPendingEndChildren = false;

    while (_pCurrent != NULL)
    {
        _pCurrent = _pStack.pop();
    }

    _cNodeInfoCurrent = 0;
    _lCurrentElement = 0;

    // cleanup downloads
    while (_pdc != NULL)
    {
        PopDownload();
    }

    _pCurrent = NULL;
    return S_OK;
}
/////////////////////////////////////////////////////////////////////////////
HRESULT 
XMLParser::ErrorCallback(HRESULT hr)
{
    Assert(hr == XMLStream::XML_DATAAVAILABLE ||
           hr == XMLStream::XML_DATAREALLOCATE);

    if (hr == XMLStream::XML_DATAREALLOCATE)
    {
        // This is more serious.  We have to actually save away the
        // context because the buffers are about to be reallocated.
        checkhr2(CopyContext());
    }
    checkhr2(_pFactory->NotifyEvent(this, XMLNF_DATAAVAILABLE));
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\xmlparser\xmlstream.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*

* 

* EXEMPT: copyright change only, no build required

* 

*/

#ifndef _XMLSTREAM_HXX

#define _XMLSTREAM_HXX

#pragma once


#include "bufferedstream.h"

#include "encodingstream.h"

#include "_rawstack.h"



class XMLParser;



// the XMLStream class uses the error code and token types defined in the xmlparser

#include <ole2.h>

#include <xmlparser.h>



//==============================================================================

// This enum and StateEntry struct are used in table driven parsing for DTD

// stuff - so that the parser isn't bloated by this stuff.  This is about 15%

// slower than a hand written parser.



typedef enum {

    OP_OWS,     // optional whitespace

    OP_WS,      // required whitespace

    OP_CHAR,    // char comparison, _pch[0] is char, _sArg1 is else goto state or error code

    OP_CHAR2,   // same os OP_CHAR - except it doesn't do _pInput->Mark.

    OP_PEEK,    // same as OP_CHAR - except it doesn't advance.

    OP_NAME,    // scan name

    OP_TOKEN,   // return token, _sArg1 = token

    OP_STRING,  // scan a string

    OP_EXTID,   // scan an external id.

    OP_STRCMP,  // string comparison.

    OP_POP,     // pop state

    OP_NWS,     // not whitespace conditional

    OP_SUBSET,  // skip an internal subset

    OP_PUBIDOPTION, // conditional for _fShortPubIdOption

    OP_NMTOKEN,

    OP_TABLE,   // push a new table. (pointer in _pch field).

    OP_STABLE,   // switch to new table. (pointer in _pch field).

    OP_COMMENT,

    OP_CONDSECT,

    OP_SNCHAR,  // conditional 'is start name char'

    OP_EQUALS,  // scan ' = '

    OP_ENCODING, // switch encoding.

    OP_CHARWS,   // match char or must be white space.

    OP_ATTRVAL, //parse attribute values.(_sArg1 = return PCDATA token or not)

    OP_PETEST,

    OP_ATTEXPAND,

    OP_NMSTRING, // unqualified name within quote 

    OP_FAKESYSTEM,

} OPCODE;



typedef struct {

    OPCODE			_sOp;

    const WCHAR*	_pch;

    DWORD			_sGoto;

    DWORD			_sArg1;

    long			_lDelta; // for when we do a Mark(), or Token if OP_CHAR

} StateEntry;



//================================================================================

class XMLStream

{   

public:

    XMLStream(XMLParser * pXMLParser);

    ~XMLStream();



    //------------------------------------------------------------------------

    // These are some more tokens that the XMLStream returns.

	// xiaoyu : only few are used in fusion manifest

    typedef enum 

    {

        // ADDITIONAL TOKENS THAT THE PARSER PULLS UP

        XML_PENDING = 0,						// still parsing.

        XML_NUMENTITYREF = XML_LASTSUBNODETYPE, // &23;                 

        XML_HEXENTITYREF,						// &x0cf7;

        XML_BUILTINENTITYREF,					//&gt;

        XML_TAGEND,								// >

        XML_EMPTYTAGEND,						// /> (text = tag name)

        XML_ENDTAG,								// </ (text = tag name)

        XML_ENDPI,								// text = pi body minus '?>'

        XML_ENDXMLDECL,							// end of xml declaration

        XML_ENDDECL,							// '>'

        XML_CLOSEPAREN,

        XML_ENDCONDSECT,						// ']]>'

        XML_STARTDTDSUBSET,

        XML_ENDPROLOG,

        XML_DATAAVAILABLE,

        XML_DATAREALLOCATE,

    } XMLToken;



    HRESULT PushStream( 

        /* [in] */ EncodingStream  *pStm,

        /* [in] */ bool fExternalPE);



    HRESULT AppendData( 

        /* [in] */ const BYTE  *buffer,

        /* [in] */ long length,

        /* [in] */ BOOL lastBuffer);



    HRESULT Reset( void);



    HRESULT GetNextToken( 

        /* [out] */ DWORD  *token,

        /* [out] */ const WCHAR  **text,

        /* [out] */ long  *length,

        /* [out] */ long  *nslen);

        

    ULONG GetLine();



    ULONG GetLinePosition();

    

    ULONG GetInputPosition();



    HRESULT GetLineBuffer( 

        /* [out] */ const WCHAR  * *buf,

        /* [out] */ ULONG* len,

        /* [out] */ ULONG* startpos);



    void SetFlags( 

        /* [in] */ unsigned short usFlags);

    

    unsigned short GetFlags();



    HRESULT ErrorCallback(HRESULT hr);



    WCHAR   getAttrValueQuoteChar() { return _chTerminator; }



private:

    HRESULT init();

    void _init();



    HRESULT firstAdvance();

    HRESULT parseContent();

    HRESULT parseElement();

    HRESULT parseEndTag();

	HRESULT parsePI();

    HRESULT parseComment();

    HRESULT parseName();

    HRESULT parseAttributes();

    HRESULT parseAttrValue();

    

    HRESULT parsePCData();

	HRESULT parseEntityRef();



	HRESULT parseCondSect();

    HRESULT parseCData();



	HRESULT parseTable();

	HRESULT parseEquals();



    HRESULT skipWhiteSpace();



    inline void mark(long back = 0) { _pInput->Mark(back); }



    typedef HRESULT (XMLStream::* StateFunc)();



    // The state machine consists of functions where each

    // function can determine for itself its own substates 

    // so that when it is reactivated by a pop() it can pick 

    // up where it left off.  The current substate is set

    // to zero on a push() and at pop() time it is restored 

    // to whatever it was told to be in the push().

    HRESULT push(StateFunc f, short substate = 0);

    HRESULT pushTable(short substate = 0, const StateEntry* table = NULL, DWORD le = 0);

    HRESULT pop(bool boundary = true);

    HRESULT switchTo(StateFunc f); // pop & push

    

    // Advance and jump to state

    HRESULT AdvanceTo(short substate);



    HRESULT PopStream();



    HRESULT ScanHexDigits();

    HRESULT ScanDecimalDigits();



	bool    PreEntityText();



    // Always use this function instead of calling _pInput->getToken

    inline void getToken(const WCHAR** ppText, long* pLen) { _pInput->getToken(ppText,pLen); }



    BufferedStream* getCurrentStream();



    StateFunc   _fnState; // current function.

    short       _sSubState; // current substate.

    short       _sSavedState;



    struct StateInfo

    {

        StateFunc			_fnState;

        short				_sSubState;

        const StateEntry*	_pTable;

        //DWORD				_lEOFError;

        int					_cStreamDepth;

    };

    _rawstack<StateInfo>	_pStack;



    struct InputInfo

    {

        BufferedStream*		_pInput;

        WCHAR				_chLookahead;

        //bool				_fPE;

        //bool				_fExternalPE;

        //bool				_fInternalSubset;	// remember that we were in internal subset.

        StateFunc			_fnState;			// remember the state function when pushstream

												// it is used to check parameter entity replacement text 

												// is properly nested with markup declarations.

    };

    _rawstack<InputInfo> _pStreams;


    // Cache the current value of _pStreams.used() which is used to making sure

    // a parameter entity doesn't pop out of the scope in which it was entered.

    int         _cStreamDepth; 



    BufferedStream* _pInput;			// current input stream.



    WCHAR       _chNextLookahead;

    bool        _fWasUsingBuffer;

    long        _lParseStringLevel;

    

    DWORD       _nPreToken;

    DWORD       _nToken;

    long        _lLengthDelta;			// amount to adjust token length by

    long        _lMarkDelta;			// amount to adjust mark position by

    bool        _fDelayMark;

    bool        _fFoundFirstElement;	// special trick for EndProlog.



    WCHAR       _chLookahead;

    bool        _fWhitespace;			// found whitespace while parsing PCDATA

    WCHAR       _chTerminator;    

    WCHAR       _chEndChar;				// for parseAttributes.

    bool        _fEOF;					// reached end of file.    



    long        _lNslen; // namespace length

    long        _lNssep; // namespace separator length ':' or '::'.



	long        _lEntityPos; // for parsing entity references.

	bool        _fPCDataPending; // whether pcdata is pending during parseEntityRef.

	const WCHAR* _pchCDataState;

    int         _cAttrCount;

	int         _nEntityNSLen; // saved namespace info for entity references.



    // Switches.

    unsigned short _usFlags;

    // bool      _fFloatingAmp;		// used in ParseEntityRef()

    bool         _fShortEndTags;		// used in ParserEndTag()

    bool         _fCaseInsensitive;

    bool         _fNoNamespaces;		// used in parseName()	

    //bool       _fNoWhitespaceNodes;   // used in DTD data	

    //bool       _fIE4Quirks;			// xiaoyu : what it means?

    bool         _fNoDTDNodes;			// only used in GetDTDNextToken(). may be deleted later

    //bool       _fHandlePE;			// This flag is used to turn on and off parameter entity handling in DTD

										// xiaoyu: used in ParsePI(), ParseDTD(), parseComment(),

										// parsePEDecl(), parseIgnoSet()

							



    // for table driven parsing.

    const StateEntry* _pTable;

    //DWORD				_lEOFError;	// used in parsePEDecl(), pushTable(), parseTable(),



    // buffer used during whitespace normalization

    WCHAR*      _pchBuffer;

    long        _lBufLen;

    long        _lBufSize;

    bool        _fFoundWhitespace;

    bool        _fUsingBuffer;

    bool        _fFoundNonWhitespace;

    bool        _fCheckAttribute;	// need to check the attribute name

									// xiaoyu : used for complicate attribute type, such as "xml:lang", "xmlns"

	

    bool        _fDTD;				// xiaoyu whether xml contains DTD

    //bool      _fInternalSubset;   // xiaoyu used in ParseDTD

    //int         _cConditionalSection;

    //bool        _fFoundPEREf;

    //bool        _fWasDTD;

//    bool        _fParsingNames;



    bool        _fParsingAttDef;	// used in ParseAttrValue()

    //int       _cIgnoreSectLevel;

    //bool		_fResolved;			// used in ParseEntity();

    bool        _fReturnAttributeValue;

    //int       _cStreams;			// used to identify if PushStream was called.

									// used in parseEntity();	

    WCHAR       _wcEntityValue;	// used in parseEntityRef()

    XMLParser * _pXMLParser;		// regular pointer pointing back to the parser



    inline HRESULT PushChar(WCHAR ch) 

    { 

        if (_lBufLen < _lBufSize) 

        { 

            _pchBuffer[_lBufLen++] = ch; return S_OK; 

        }

        else return _PushChar(ch); 

    }

    HRESULT     _PushChar(WCHAR ch); // grow the buffer.

};



#endif // _XML_STREAM_HXX
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\xmlparser\xmlparser.hpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/////////////////////////////////////////////////////////////////////////////////
//
// fusion\xmlparser\XMLParser.hxx
//
/////////////////////////////////////////////////////////////////////////////////
#ifndef _FUSION_XMLPARSER__XMLPARSER_H_INCLUDE_
#define _FUSION_XMLPARSER__XMLPARSER_H_INCLUDE_
#pragma once

#include <winbase.h>
#include <ole2.h>
#include <xmlparser.h>
#include "xmlhelper.h"
class XMLStream;

typedef _reference<IXMLParser> RXMLParser;
typedef _reference<IXMLNodeFactory> RNodeFactory;
typedef _reference<IUnknown> RUnknown;
typedef _reference<IBindStatusCallback> RIBindStatusCallback;

#include "encodingstream.h"

#include "_rawstack.h"
//#define XMLFLAG_RUNBUFFERONLY   0x1000

//------------------------------------------------------------------------
// An internal Parser IID so that DTDNodeFactory can call internal methods.
const IID IID_Parser = {0xa79b04fe,0x8b3c,0x11d2,{0x9c, 0xd3,0x00,0x60,0xb0,0xec,0x3d,0x30}};

class XMLParser : public _unknown<IXMLParser, &IID_IXMLParser>
{
public:

		XMLParser();
        ~XMLParser();

		// ======= IUnknown override ============================
        virtual HRESULT STDMETHODCALLTYPE QueryInterface(REFIID riid, void ** ppvObject);

        virtual ULONG STDMETHODCALLTYPE AddRef(void);
   
        virtual ULONG STDMETHODCALLTYPE Release(void);

		// ====== IXMLNodeSource methods ========================
        virtual HRESULT STDMETHODCALLTYPE SetFactory( 
            /* [in] */ IXMLNodeFactory __RPC_FAR *pNodeFactory);
        
        virtual HRESULT STDMETHODCALLTYPE GetFactory(
            /* [out] */ IXMLNodeFactory** ppNodeFactory);

        virtual HRESULT STDMETHODCALLTYPE Abort( 
            /* [in] */ BSTR bstrErrorInfo);

        virtual ULONG STDMETHODCALLTYPE GetLineNumber(void);
        
        virtual ULONG STDMETHODCALLTYPE GetLinePosition(void);
        
        virtual ULONG STDMETHODCALLTYPE GetAbsolutePosition(void);

        virtual HRESULT STDMETHODCALLTYPE GetLineBuffer( 
            /* [out] */ const WCHAR  **ppwcBuf,
            /* [out] */ ULONG  *pulLen,
            /* [out] */ ULONG  *pulStartPos);
        
        virtual HRESULT STDMETHODCALLTYPE GetLastError(void);
        
        virtual HRESULT STDMETHODCALLTYPE GetErrorInfo(/* [out] */ BSTR  *pbstrErrorInfo)
		{
			ASSERT(FALSE);
			UNUSED(pbstrErrorInfo);
			return E_NOTIMPL;
		}

		virtual ULONG STDMETHODCALLTYPE GetFlags() { 	
			return 0; 
		}

        virtual HRESULT STDMETHODCALLTYPE GetURL( 
            /* [out] */ const WCHAR  **ppwcBuf) {
			UNUSED(ppwcBuf);
			return E_NOTIMPL; 
		}

		// ====== IXMLParser methods ==============================

        virtual HRESULT STDMETHODCALLTYPE SetURL( 
            /* [in] */ const WCHAR* pszBaseUrl,
            /* [in] */ const WCHAR* pszRelativeUrl,
            /* [in] */ BOOL async) {
			UNUSED(pszBaseUrl);
			UNUSED(pszRelativeUrl);
			UNUSED(async);
			return E_NOTIMPL;
		}

        virtual HRESULT STDMETHODCALLTYPE Load( 
            /* [in] */ BOOL fFullyAvailable,
            /* [in] */ IMoniker *pimkName,
            /* [in] */ LPBC pibc,
            /* [in] */ DWORD grfMode) {

			UNUSED(fFullyAvailable);
			UNUSED(pimkName);
			UNUSED(pibc);
			UNUSED(grfMode);
			return E_NOTIMPL;
		}

        virtual HRESULT STDMETHODCALLTYPE SetInput( 
            /* [in] */ IUnknown*pStm);
        
        virtual HRESULT STDMETHODCALLTYPE PushData( 
            /* [in] */ const char *pData,
            /* [in] */ ULONG ulChars,
            /* [in] */ BOOL bLastBuffer);
        
        virtual HRESULT STDMETHODCALLTYPE LoadEntity(
            /* [in] */ const WCHAR* pszBaseUrl,
            /* [in] */ const WCHAR* pszRelativeUrl,
            /* [in] */ BOOL fpe) { 
			UNUSED(pszBaseUrl); 
			UNUSED(pszRelativeUrl); 
			UNUSED(fpe); 
			return E_NOTIMPL;
		}

        virtual HRESULT STDMETHODCALLTYPE ParseEntity(
            /* [in] */ const WCHAR* pwcText, 
            /* [in] */ ULONG ulLen,
            /* [in] */ BOOL fpe){ 
			UNUSED(pwcText);
			UNUSED(ulLen);
			UNUSED(fpe);
			return E_NOTIMPL;
		} 

	    virtual HRESULT STDMETHODCALLTYPE ExpandEntity(
            /* [in] */ const WCHAR* pwcText, 
            /* [in] */ ULONG ulLen) { 
			UNUSED(pwcText);
			UNUSED(ulLen);
			return E_NOTIMPL;
		}

        virtual HRESULT STDMETHODCALLTYPE SetRoot( 
            /* [in] */ PVOID pRoot) { 
			UNUSED(pRoot);
			return E_NOTIMPL;
		}
        
        virtual HRESULT STDMETHODCALLTYPE GetRoot( 
            /* [in] */ PVOID __RPC_FAR *ppRoot){ 
			UNUSED(ppRoot);
			return E_NOTIMPL;
		}

        virtual HRESULT STDMETHODCALLTYPE Run( 
            /* [in] */ long lChars);
        
        virtual HRESULT STDMETHODCALLTYPE GetParserState(void) ; 
                
        virtual HRESULT STDMETHODCALLTYPE Suspend(void) ; 
        
        virtual HRESULT STDMETHODCALLTYPE Reset(void) ; 
        
        virtual HRESULT STDMETHODCALLTYPE SetFlags( 
            /* [in] */ ULONG iFlags) { 
			UNUSED(iFlags);
			return E_NOTIMPL;
		}
        
        virtual HRESULT STDMETHODCALLTYPE LoadDTD(
            /* [in] */ const WCHAR * pszBaseUrl,
            /* [in] */ const WCHAR * pszRelativeUrl){ 
			UNUSED(pszBaseUrl);
			UNUSED(pszRelativeUrl);
			return E_NOTIMPL;
		}
    
        virtual HRESULT STDMETHODCALLTYPE SetSecureBaseURL( 
            /* [in] */ const WCHAR* pszBaseUrl){ 
			UNUSED(pszBaseUrl);
			return E_NOTIMPL;
		}

        virtual HRESULT STDMETHODCALLTYPE GetSecureBaseURL( 
            /* [out] */ const WCHAR ** ppwcBuf){ 
			UNUSED(ppwcBuf);
			return E_NOTIMPL;
		}

        // ======= internal only methods for Parser 
#ifdef FUSION_USE_OLD_XML_PARSER_SOURCE
        HRESULT  SetCurrentURL( 
            /* [in] */ const WCHAR* pszCurrentUrl); // SRC attribute on <SCRIPT island>
			// used by SetInput()
		HRESULT SetBaseURL( 
            /* [in] */ const WCHAR* pszBaseUrl); // in case PushData is called.
#endif

		HRESULT ErrorCallback(HRESULT hr);

private:
        void ctorInit();
#ifdef FUSION_USE_OLD_XML_PARSER_SOURCE
        HRESULT PushURL( 
            /* [in] */ const WCHAR* pszBaseUrl,
            /* [in] */ const WCHAR* pszRelativeUrl,
            /* [in] */ bool async,
            /* [in] */ bool tokenizer,
            /* [in] */ bool dtd,
            /* [in] */ bool fentity,
            /* [in] */ bool fpe );
		// used in SetURL(). LoadDTDDate(), LoadEntity();
#endif	

#ifdef FUSION_USE_OLD_XML_PARSER_SOURCE
		HRESULT PushTokenizer(URLStream* stream);
#else
		HRESULT PushTokenizer();
#endif
	
#ifdef FUSION_USE_OLD_XML_PARSER_SOURCE
		HRESULT PushDownload(URLStream* stream, XMLStream* tokenizer);
#else
        HRESULT PushDownload(XMLStream* tokenizer);
#endif
		
        HRESULT PopDownload();

        XMLStream*  _pTokenizer;
        PVOID       _pRoot;
        HRESULT     _fLastError;
        BSTR        _bstrError;
        bool        _fWaiting;
        bool        _fSuspended;
        bool        _fStopped;
        bool        _fStarted;
        bool        _fInXmlDecl;
        bool        _fFoundEncoding;
        USHORT      _usFlags;
        bool        _fCaseInsensitive;
        //bool      _fTokenizerChanged;		// used in DTD, tokenizer may change in DTD file
        bool         _fGotVersion;			    // used in XML_VERSION
        long        _fRunEntryCount;		// used in Run(), counting how many is running the Parsing-While
        
        //bool        _fInLoading;			// used in PushURL(), Load(), HandleData(), 
        bool        _fInsideRun;			// used in Run()
        bool        _fFoundRoot;
        
        //bool        _fSeenDocType;		// used in DTD 
        bool        _fRootLevel;			// whether we are at the root level in document.
        bool        _fFoundNonWS;
        bool        _fPendingBeginChildren;
        bool        _fPendingEndChildren;
        
        //BSTR        _fAttemptedURL;		// used in PushURL(), Load(), GetErrorInfo(); 

        struct Download
        {
            XMLStream*      _pTokenizer;
            //RURLStream      _pURLStream;
            REncodingStream _pEncodingStream;
            bool            _fAsync;
            bool            _fDTD;
            bool            _fEntity;
            bool            _fPEReference;
            bool            _fFoundNonWS;
            bool            _fFoundRoot;    // saved values in case we're downloading a schema
            bool            _fSeenDocType;
            bool            _fRootLevel; // whether we are at the root level in document.
            int             _fDepth;    // current depth of stack.
        };
        _rawstack<Download> _pDownloads;
        Download*       _pdc;   // current download.


        // the Context struct contains members that map to the XML_NODE_INFO struct
        // defined in xmlparser.idl so that we can pass the contents of the Context
        // as a XML_NODE_INFO* pointer in BeginChildren, EndChildren and Error.

        typedef struct _MY_XML_NODE_INFO : public XML_NODE_INFO
        {
//            DWORD           dwSize;             // size of this struct
//            DWORD           dwType;             // node type (XML_NODE_TYPE)
//            DWORD           dwSubType;          // node sub type (XML_NODE_SUBTYPE)
//            BOOL            fTerminal;          // whether this node can have any children
//            WCHAR*          pwcText;            // element names, or text node contents.
//            ULONG           ulLen;              // length of pwcText
//            ULONG           ulNsPrefixLen;      // if element name, this is namespace prefix length.
//            PVOID           pNode;              // optionally created by & returned from node factory
//            PVOID           pReserved;          // reserved for factories to use between themselves.
            WCHAR*          _pwcTagName;        // saved tag name
            ULONG           _ulBufLen; 
        } MY_XML_NODE_INFO;
        typedef MY_XML_NODE_INFO* PMY_XML_NODE_INFO;

        _rawstack<MY_XML_NODE_INFO> _pStack;

        long            _lCurrentElement;
        PMY_XML_NODE_INFO _pCurrent; 
        USHORT          _cAttributes; // count of attributes on stack.

        // And we need a contiguous array of pointers to the XML_NODE_INFO 
        // structs for CreateNode.
        PMY_XML_NODE_INFO* _paNodeInfo;
        USHORT             _cNodeInfoAllocated;
        USHORT             _cNodeInfoCurrent;
        
        PVOID   _pNode; // current node (== pCurrent->pNode OR _pRoot).

        // Push saves this factory in the context and pop restores it
        // from the context.
        RNodeFactory _pFactory; // current factory (!= pCurrent->pParentFactory).

        HRESULT push(XML_NODE_INFO& info);
        HRESULT pushAttribute(XML_NODE_INFO& info);
        HRESULT pushAttributeValue(XML_NODE_INFO& info);
      
        HRESULT pop(const WCHAR* tag, ULONG len);
        HRESULT pop();
        HRESULT popAttributes();
        void    popAttribute();
        HRESULT popDTDAttribute() { return E_NOTIMPL; }

		HRESULT CopyContext();
		HRESULT CopyText(PMY_XML_NODE_INFO pNodeInfo);
		HRESULT ReportUnclosedTags(int index);
        HRESULT GrowBuffer(PMY_XML_NODE_INFO pNodeInfo, long newlen);
        HRESULT GrowNodeInfo();
		
        
        CRITICAL_SECTION _cs;

        HRESULT init();
        
        HRESULT PushStream(IStream* pStm, bool fpe);
        //Download* FindDownload(URLStream* pStream);
        WCHAR*   getSecureBaseURL() 
                {
                    if (_pszSecureBaseURL)
                        return _pszSecureBaseURL;
                    else if (_dwSafetyOptions)
                        return _pszBaseURL;
                    return NULL;
                 }


        WCHAR*  _pszSecureBaseURL;
        WCHAR*  _pszCurrentURL;
        WCHAR*  _pszBaseURL;
        bool    _fIgnoreEncodingAttr;
        DWORD   _dwSafetyOptions;
};


#endif // _FUSION_XMLPARSER__XMLPARSER_H_INCLUDE_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\xmlparser\xmlstream.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*
* 
* EXEMPT: copyright change only, no build required
* 
*/
//#include "stdinc.h"
#include "core.h"
#pragma hdrstop

//#include <shlwapip.h>   // IsCharSpace

#include "xmlhelper.h"
#include "xmlstream.h"
#include "bufferedstream.h"
#include "xmlparser.hpp"

const long BLOCK_SIZE = 512;
const long STACK_INCREMENT = 10;

// macros used in this file
#define INTERNALERROR       return XML_E_INTERNALERROR;
#define checkeof(a,b)       if (_fEOF) return b;
#define ADVANCE             hr = _pInput->nextChar(&_chLookahead, &_fEOF); if (hr != S_OK) return hr;
#define ADVANCETO(a)        hr = AdvanceTo(a);  if (hr != S_OK) return hr;
#define ISWHITESPACE(ch)    _pInput->isWhiteSpace(ch) 
#define STATE(state)        { _sSubState = state; return S_OK; }
#define GOTOSTART(state)    { _sSubState = state; goto Start; }
#define DELAYMARK(hr)       (hr == S_OK || (hr >= XML_E_TOKEN_ERROR && hr < XML_E_LASTERROR))
#define XML_E_FOUNDPEREF    0x8000e5ff


// The tokenizer has special handling for the following attribute types.
// These values are derived from the XML_AT_XXXX types provided in SetType
// and are also calculated during parsing of an ATTLIST for parsing of
// default values.
typedef enum 
{
    XMLTYPE_CDATA,       // the default.
    XMLTYPE_NAME,
    XMLTYPE_NAMES,
    XMLTYPE_NMTOKEN,
    XMLTYPE_NMTOKENS,
} XML_ATTRIBUTE_TYPE;

//==============================================================================
// xiaoyu : a simplified table : only deal with comments, not include DOCTYPE, NotationDecl, EntityDecl and ElementDecl.
// Parse an <!^xxxxxxxx Declaration.
const StateEntry g_DeclarationTable[] =
{
// 0    '<' ^ '!' 
    { OP_CHAR, L"!", 1, (DWORD)XML_E_INTERNALERROR,  },                    
// 1    '<!' ^ '-'
    { OP_PEEK, L"-", 2, 4, 0 },                    
// 2    '<!-'
    { OP_COMMENT,  NULL, 3,   },                 
// 3    done !!
    { OP_POP,  NULL, 0, 0 },

// 4    '<!' ^ '['
    { OP_PEEK, L"[", 5, (DWORD)XML_E_BADDECLNAME, 0 }, //xiaoyu : we do not consider others <!XXX, which is a DTD subset
// 5    '<![...'
    { OP_CONDSECT,  NULL, 3,   }
 
};

//==============================================================================
// Parse an <?xml or <?xml:namespace declaration.
const StateEntry g_XMLDeclarationTable[] =
{
// 0    must be xml declaration - and not xml namespace declaration        
    { OP_TOKEN, NULL, 1, XML_XMLDECL, 0 },
// 1    '<?xml' ^ S version="1.0" ...
    { OP_OWS, NULL, 2 },
// 2    '<?xml' S ^ version="1.0" ...
    { OP_SNCHAR, NULL, 3, (DWORD)XML_E_XMLDECLSYNTAX },	
// 3    '<?xml' S ^ version="1.0" ...
    { OP_NAME, NULL, 4, },
// 4    '<?xml' S version^="1.0" ...
    { OP_STRCMP, L"version", 5, 12, XML_VERSION },
// 5
    { OP_EQUALS, NULL, 6 },
// 6    '<?xml' S version = ^ "1.0" ...
    { OP_ATTRVAL, NULL, 32, 0},
// 7    '<?xml' S version '=' value ^ 
    { OP_TOKEN, NULL, 8, XML_PCDATA, -1 },
// 8    ^ are we done ?
    { OP_CHARWS, L"?", 28, 9 },    // must be '?' or whitespace.
// 9    ^ S? [encoding|standalone] '?>'
    { OP_OWS, NULL, 10 },
// 10
    { OP_CHAR, L"?", 28, 33 },    // may have '?' after skipping whitespace.
// 11    ^ [encoding|standalone] '?>'
    { OP_NAME, NULL, 12, },
// 12
    { OP_STRCMP, L"standalone", 23, 13, XML_STANDALONE },
// 13
    { OP_STRCMP, L"encoding", 14, (DWORD)XML_E_UNEXPECTED_ATTRIBUTE, XML_ENCODING },
// 14
    { OP_EQUALS, NULL, 15 },
// 15   
    { OP_ATTRVAL, NULL, 16, 0 },
// 16
    { OP_ENCODING, NULL, 17, 0, -1 },
// 17
    { OP_TOKEN, NULL, 18, XML_PCDATA, -1 },

// 18    ^ are we done ?
    { OP_CHARWS, L"?", 28, 19 },    // must be '?' or whitespace.
// 19    ^ S? standalone '?>'
    { OP_OWS, NULL, 20 },
// 20
    { OP_CHAR, L"?", 28, 34 },    // may have '?' after skipping whitespace.
// 21    ^ standalone '?>'
    { OP_NAME, NULL, 22, },
// 22 
    { OP_STRCMP, L"standalone", 23, (DWORD)XML_E_UNEXPECTED_ATTRIBUTE, 
XML_STANDALONE },
// 23
    { OP_EQUALS, NULL, 24 },
// 24
    { OP_ATTRVAL, NULL, 25, 0 },
// 25   
    { OP_STRCMP, L"yes", 31, 30, -1  },

// 26    <?xml ....... ^ '?>'   -- now expecting just the closing '?>' chars
    { OP_OWS, NULL, 27 },
// 27    
    { OP_CHAR, L"?", 28, (DWORD)XML_E_XMLDECLSYNTAX, 0 },
// 28   
    { OP_CHAR, L">", 29, (DWORD)XML_E_XMLDECLSYNTAX, 0 },
// 29    done !!
    { OP_POP,  NULL, 0, XMLStream::XML_ENDXMLDECL },

//----------------------- check standalone values  "yes" or "no"
// 30
    { OP_STRCMP, L"no", 31, (DWORD)XML_E_INVALID_STANDALONE, -1  },
// 31
    { OP_TOKEN, NULL, 26, XML_PCDATA, -1 },
    
//----------------------- check version = "1.0"
// 32
    { OP_STRCMP, L"1.0", 7, (DWORD)XML_E_INVALID_VERSION, -1 },
// 33 
    { OP_SNCHAR, NULL, 11, (DWORD)XML_E_XMLDECLSYNTAX },   
// 34 
    { OP_SNCHAR, NULL, 21, (DWORD)XML_E_XMLDECLSYNTAX },  
};

static const WCHAR* g_pstrCDATA = L"CDATA";
////////////////////////////////////////////////////////////////////////
XMLStream::XMLStream(XMLParser * pXMLParser)
:   _pStack(1), _pStreams(1)
{   
    // precondition: 'func' is never NULL
    _fnState = &XMLStream::init;
    _pInput = NULL;
    _pchBuffer = NULL;
    _fDTD = false;
	//_fInternalSubset = false;
    _cStreamDepth = 0;
    _pXMLParser = pXMLParser;

    _init();
    SetFlags(0);
}
////////////////////////////////////////////////////////////////////////
HRESULT 
XMLStream::init()
{
    HRESULT hr = S_OK;

    if (_pInput == NULL) 
	{
		//haven' called put-stream yet
        return XML_E_ENDOFINPUT;
	}
    
    _init();
#ifdef FUSION_USE_OLD_XML_PARSER_SOURCE
    if (_fDTD)
    {
        _fnState = &XMLStream::parseDTDContent;
    }
    else
#endif
    {
        _fnState =  &XMLStream::parseContent;
    }

    checkhr2(push(&XMLStream::firstAdvance,0));

    return hr;
}
////////////////////////////////////////////////////////////////////////
void
XMLStream::_init()
{
    _fEOF = false;
    //_fEOPE = false;
    _chLookahead	= 0;
    _nToken			= XML_PENDING;
    _chTerminator	= 0;
    _lLengthDelta	= 0;
	_lNslen = _lNssep = 0;
    _sSubState		= 0;
    _lMarkDelta		= 0;
	//_nAttrType = XMLTYPE_CDATA;
    _fUsingBuffer	= false;
    _lBufLen		= 0;
    if (_pchBuffer != 0)
	    delete[] _pchBuffer;
    _pchBuffer		= NULL;
    _lBufSize		= 0;
    _fDelayMark		= false;
    _fFoundWhitespace = false;
    _fFoundNonWhitespace = false;
	//_fFoundPEREf = false;
    _fWasUsingBuffer = false;
    _chNextLookahead = 0;
    //_lParseStringLevel = 0;
    //_cConditionalSection = 0;
    //_cIgnoreSectLevel = 0;
    //_fWasDTD = false;

	_fParsingAttDef = false;
    _fFoundFirstElement = false;
    _fReturnAttributeValue = true;
	//_fHandlePE = true;

    _pTable = NULL;
    //_lEOFError = 0;
}
////////////////////////////////////////////////////////////////////////
XMLStream::~XMLStream()
{
    delete _pInput;
    delete[] _pchBuffer;

    InputInfo* pi = _pStreams.peek();
    while (pi != NULL)
    {
        // Previous stream is finished also, so
        // pop it and continue on.
        delete pi->_pInput;
        pi = _pStreams.pop();
    }
}
////////////////////////////////////////////////////////////////////////
HRESULT  
XMLStream::AppendData( 
    /* [in] */ const BYTE  *buffer,
    /* [in] */ long  length,
    /* [in] */ BOOL  last)
{
    if (_pInput == NULL)
    {
        _pInput = NEW (BufferedStream(this));
        if (_pInput == NULL)
            return E_OUTOFMEMORY;
        init();
    }

    HRESULT hr = _pInput->AppendData(buffer, length, last);

    return hr;
}
////////////////////////////////////////////////////////////////////////
HRESULT  
XMLStream::Reset( void)
{
    init();
    delete _pInput;
    _pInput = NULL;

    return S_OK;
}
////////////////////////////////////////////////////////////////////////
HRESULT  
XMLStream::PushStream( 
        /* [unique][in] */ EncodingStream  *p,
        /* [in] */ bool fExternalPE)
{
	UNUSED(fExternalPE);

    if (_pStreams.used() == 0 && _pInput == NULL)
        init();

    _cStreamDepth++;

    if (_fDelayMark && _pInput != NULL)
    {
        mark(_lMarkDelta);
        _lMarkDelta = 0;
        _fDelayMark = false;
    }

    // Save current input stream.
    if (_pInput != NULL)
    {
        InputInfo* pi = _pStreams.push();
        if (pi == NULL)
            return E_OUTOFMEMORY;
 
        pi->_pInput = _pInput;
        pi->_chLookahead = _chLookahead;
        //pi->_fPE = true; // assume this is a parameter entity.
        //pi->_fExternalPE = fExternalPE;
        //pi->_fInternalSubset = _fInternalSubset;
        if (&XMLStream::skipWhiteSpace == _fnState  && _pStack.used() > 0) {
            StateInfo* pSI = _pStack.peek();
            pi->_fnState = pSI->_fnState;
        }
        else
            pi->_fnState = _fnState;
        

        // and prepend pe text with space as per xml spec.
        _chLookahead = L' ';
        _chNextLookahead = _chLookahead;
        _pInput = NULL;
    }

    _pInput = NEW (BufferedStream(this));
    if (_pInput == NULL)
        return E_OUTOFMEMORY;

    if (p != NULL)
        _pInput->Load(p);
    
    if (_chLookahead == L' ')
        _pInput->setWhiteSpace(); // _pInput didn't see this space char.
    
	return S_OK;
}
////////////////////////////////////////////////////////////////////////
HRESULT 
XMLStream::PopStream()
{
    // This method has to pop all streams until it finds a stream that
    // can deliver the next _chLookahead character.

    HRESULT hr = S_OK;

    InputInfo* pi = NULL;

    pi = _pStreams.peek();
    if (pi == NULL) return S_FALSE;

    _chLookahead = pi->_chLookahead;

    // Found previous stream, so we can continue.
    _fEOF = false;

    // Ok, so we actually got the next character, so
    // we can now safely throw away the previous 
    // lookahead character and return the next
    // non-whitespace character from the previous stream.
    delete _pInput;

    _pInput = pi->_pInput;
    if (_chLookahead == L' ')
        _pInput->setWhiteSpace();

    // BUGBUG: we need to clear this so that the parser does not
    // try and pop a download in the internalPE case (when handling XML_E_ENDOFINPUT in run())
    // but this means that internal PEs never get XMLNF_ENDENTITY notifications generated.
    // The DTDNodeFactory requires this behaviour currently (incorrectly)
    _pStreams.pop();

    _cStreamDepth--;

    return hr;
}
////////////////////////////////////////////////////////////////////////
HRESULT  
XMLStream::GetNextToken( 
        /* [out] */ DWORD  *t,
        /* [out] */ const WCHAR  **text,
        /* [out] */ long  *length,
        /* [out] */ long  *nslen)
{
    HRESULT hr;

    if (_fDTD)
        return E_UNEXPECTED;

    if (_fDelayMark)
    {
        mark(_lMarkDelta);
        _lMarkDelta = 0;
        _fDelayMark = false;
    }

    hr = (this->*_fnState)();
    while (hr == S_OK && _nToken == XML_PENDING)
        hr = (this->*_fnState)();
    
    if (hr == S_OK)
        *t = _nToken;
    else if (hr == E_PENDING) {
        *t = XML_PENDING;
        *length = *nslen = 0;
        *text = NULL;
        goto CleanUp;
    }
    else
        *t = XML_PENDING;
    
    // At this point hr == S_OK or it is some error.  So we
    // want to return the text of the current token, since this
    // is useful in both cases.

    if (! _fUsingBuffer)
    {
        getToken(text,length);
        if (_lLengthDelta != 0)
        { // xiaoyu : IF STOP WITHIN, HAVE A CAREFUL LOOK : in ParsingAttributeValue, we have to read ahead of one char '"'
            *length += _lLengthDelta;
            _lLengthDelta = 0;
        }
// This can only happen in the context of a DTD.
//        if (_fWasUsingBuffer)
//        {
//            _fUsingBuffer = _fWasUsingBuffer;
//            _fWasUsingBuffer = false;
//        }
    }
    else
    { // xiaoyu : IF STOP WITHIN, HAVE A CAREFUL LOOK
        *text = _pchBuffer;
        *length = _lBufLen;
        _fUsingBuffer = false;
        _fFoundWhitespace = false;
        _lBufLen = 0;
        _lLengthDelta = 0;
    }
    
    if (DELAYMARK(hr))
    {
        // Mark next time around so that error information points to the
        // beginning of this token.
        _fDelayMark = true;
    }
    else 
    {  // xiaoyu : IF STOP WITHIN, HAVE A CAREFUL LOOK
        // otherwise mark this spot right away so we point to the exact
        // source of the error.
        mark(_lMarkDelta);
        _lMarkDelta = 0;
    }
    
    _nToken = XML_PENDING;
    *nslen = _lNslen;
    _lNslen = _lNssep = 0;

CleanUp:
    return hr;
}
////////////////////////////////////////////////////////////////////////
ULONG  
XMLStream::GetLine()    
{
    BufferedStream* input = getCurrentStream();
    if (input != NULL)
        return input->getLine();
    return 0;
}
////////////////////////////////////////////////////////////////////////
ULONG  
XMLStream::GetLinePosition( )
{
    BufferedStream* input = getCurrentStream();
    if (input != NULL)
        return input->getLinePos();
    return 0;
}
////////////////////////////////////////////////////////////////////////
ULONG  
XMLStream::GetInputPosition( )
{
    BufferedStream* input = getCurrentStream();
    if (input != NULL)
        return input->getInputPos();
    return 0;
}
////////////////////////////////////////////////////////////////////////
HRESULT  
XMLStream::GetLineBuffer( 
    /* [out] */ const WCHAR  * *buf, ULONG* len, ULONG* startpos)
{
    if (buf == NULL || len == NULL)
        return E_INVALIDARG;

    *buf = NULL;
    BufferedStream* input = getCurrentStream();
    if (input)
        *buf = input->getLineBuf(len, startpos);
    return S_OK;
}
////////////////////////////////////////////////////////////////////////
BufferedStream* 
XMLStream::getCurrentStream()
{
    // Return the most recent stream that
    // actually has somthing to return.
    BufferedStream* input = _pInput;
    if (!_pInput)
    {
        return NULL;
    }
    int i = _pStreams.used()-1;    
    do 
    {
        ULONG len = 0, pos = 0;
        const WCHAR* buf = input->getLineBuf(&len, &pos);
        if (len > 0)
            return input;

        if (i >= 0)
            input = _pStreams[i--]->_pInput;
        else
            break;
    }
    while (input != NULL);
    return NULL;
}
////////////////////////////////////////////////////////////////////////
void 
XMLStream::SetFlags( unsigned short usFlags)
{
    _usFlags = usFlags;
    // And break out the flags for performance reasons.
    //_fFloatingAmp = (usFlags & XMLFLAG_FLOATINGAMP) != 0;
    _fShortEndTags = (usFlags & XMLFLAG_SHORTENDTAGS) != 0;
    _fCaseInsensitive = (usFlags & XMLFLAG_CASEINSENSITIVE) != 0;
    _fNoNamespaces = (usFlags & XMLFLAG_NONAMESPACES) != 0;
    //_fNoWhitespaceNodes = false; // this is now bogus.  (usFlags & XMLFLAG_NOWHITESPACE) != 0;
    //_fIE4Quirks = (_usFlags & XMLFLAG_IE4QUIRKS) != 0;
    //_fNoDTDNodes = (_usFlags & XMLFLAG_NODTDNODES) != 0;
}
////////////////////////////////////////////////////////////////////////
unsigned short 
XMLStream::GetFlags()
{
    return _usFlags;
}
////////////////////////////////////////////////////////////////////////


//======================================================================
// Real Implementation
HRESULT 
XMLStream::firstAdvance()
{
    HRESULT hr;

    ADVANCE;
    checkhr2(pop(false));

    return S_OK;
}
////////////////////////////////////////////////////////////////////////
HRESULT 
XMLStream::parseContent()
{
    HRESULT hr = S_OK;

    if (_fEOF)
        return XML_E_ENDOFINPUT;

    switch (_chLookahead){
    case L'<':
        ADVANCE;
        checkeof(_chLookahead, XML_E_UNCLOSEDDECL);
        switch (_chLookahead)
        {
        case L'!':
            checkhr2(_pInput->Freeze()); // stop shifting data until '>'
            return pushTable( 0, g_DeclarationTable, (DWORD)XML_E_UNCLOSEDDECL);
        case L'?':
            checkhr2(push( &XMLStream::parsePI ));
            return parsePI();
        case L'/':
            checkhr2(push(&XMLStream::parseEndTag));
            return parseEndTag();
        default:
            checkhr2(push( &XMLStream::parseElement )); // push ParseContent, and _fnState = parseElement
            if (_fFoundFirstElement)
            {
                return parseElement();
            }
            else
            {
                // Return special end prolog token and then continue with 
                // with parseElement.
                _fFoundFirstElement = true;
                _nToken = XML_ENDPROLOG;
            }
        }
        break;

    default:
        checkhr2(push(&XMLStream::parsePCData));
        return parsePCData();
        break;
    }
    return S_OK;
}
////////////////////////////////////////////////////////////////////////
HRESULT 
XMLStream::skipWhiteSpace()
{
    HRESULT hr = S_OK;

    while (ISWHITESPACE(_chLookahead) && ! _fEOF)
    {
        ADVANCE;        
    }
    checkhr2(pop(false));
    return hr;
}
////////////////////////////////////////////////////////////////////////
HRESULT 
XMLStream::parseElement()
{
    HRESULT hr = S_OK;
    switch (_sSubState)
    {
    case 0:
        checkhr2(_pInput->Freeze()); // stop shifting data until '>'
        checkhr2(push( &XMLStream::parseName, 1));
        checkhr2(parseName());
        _sSubState = 1;
        // fall through
    case 1:
        checkeof(_chLookahead, XML_E_UNCLOSEDSTARTTAG);
        _nToken = XML_ELEMENT;
        // and then try and parse the attributes, and return
        // to state 2 to finish up.  With an optimization
        // for the case where there are no attributes.
        if (_chLookahead == L'/' || _chLookahead == L'>')
        {
            _sSubState = 2;
        }
		else {
			if (!ISWHITESPACE(_chLookahead))
			{
				return XML_E_BADNAMECHAR;
			}
			
			_chEndChar = L'/'; // for empty tags. //xiaoyu : used to match ENDTAG
			checkhr2(push(&XMLStream::parseAttributes,2));
		}	
        
        return S_OK;
        break;

    case 2: // finish up with start tag.
        mark(); // only return '>' or '/>' in _nToken text
        if (_chLookahead == L'/')
        {
            // must be empty tag sequence '/>'.
            ADVANCE;
            _nToken = XML_EMPTYTAGEND;
        } 
        else if (_chLookahead == L'>')
        {
            _nToken = XML_TAGEND;
        }
        else if (ISWHITESPACE(_chLookahead))
        {
            return XML_E_UNEXPECTED_WHITESPACE;
        }
        else
            return XML_E_EXPECTINGTAGEND;

        _sSubState = 3;
        // fall through
    case 3:
        checkeof(_chLookahead, XML_E_UNCLOSEDSTARTTAG);
        if (_chLookahead != L'>')
        {
            if (ISWHITESPACE(_chLookahead))
                return XML_E_UNEXPECTED_WHITESPACE;
            else 
                return XML_E_EXPECTINGTAGEND;
        }
        ADVANCE; 
        mark();
        checkhr2(pop());// return to parseContent.

        return _pInput->UnFreeze(); 
        break;

    case 4: // swollow up bad tag
        // Allow the weird CDF madness <PRECACHE="YES"/>
        // For total compatibility we fake out the parser by returning
        // XML_EMPTYTAGEND, this way the rest of the tag becomes PCDATA.
        // YUK -- but it works.
        _nToken = XML_EMPTYTAGEND;
        mark();
        checkhr2(pop());// return to parseContent.
        return _pInput->UnFreeze(); 
        break;

    default:
        INTERNALERROR;
    }
    //return S_OK;
}
////////////////////////////////////////////////////////////////////////
HRESULT 
XMLStream::parseEndTag()
{
    HRESULT hr = S_OK;
    switch (_sSubState)
    {
    case 0:
        ADVANCE; // soak up the '/'
        mark(); 
        // SHORT END TAG SUPPORT, IE4 Compatibility Mode only.
        if (! _fShortEndTags || _chLookahead != L'>') 
        {
            checkhr2(push( &XMLStream::parseName, 1));
            checkhr2(parseName());
        }
        _sSubState = 1;
        // fall through
        
    case 1: // finish parsing end tag
        checkeof(_chLookahead, XML_E_UNCLOSEDENDTAG);
        _nToken = XML_ENDTAG;
        checkhr2(push(&XMLStream::skipWhiteSpace, 2));
        return S_OK;

    case 2:
        checkeof(_chLookahead, XML_E_UNCLOSEDENDTAG);
        if (_chLookahead != L'>')
        {
            return XML_E_BADNAMECHAR;
        }
        ADVANCE;
        mark();
        checkhr2(pop());// return to parseContent.
        break;

    default:
        INTERNALERROR;
    }
    return S_OK;
}
////////////////////////////////////////////////////////////////////////
HRESULT 
XMLStream::parsePI()
{
    HRESULT hr = S_OK;
    switch (_sSubState)
    {
    case 0:
        //_fWasDTD = _fDTD; // as far as Advance is concerned, the contents
        //_fHandlePE = false;    // of a PI are not special.
        ADVANCE;
        checkhr2(_pInput->Freeze()); // stop shifting data until '?>'
        mark(); // don't include '?' in tag name.
        if (_chLookahead == L'x' || _chLookahead == L'X')
        {
            // perhaps this is the magic <?xml version="1.0"?> declaration.
            STATE(7);  // jump to state 7.
        }
        // fall through
        _sSubState = 1;
    case 1:
        checkhr2(push( &XMLStream::parseName, 2));
        checkhr2(parseName()); 
        _sSubState = 2;
        // fall through
    case 2:
        checkeof(_chLookahead, XML_E_UNCLOSEDPI);
        if (_chLookahead != L'?' && ! ISWHITESPACE(_chLookahead))
        { 
            return XML_E_BADNAMECHAR;
        }
        _nToken = XML_PI;
        STATE(3);   // found startpi _nToken and return to _sSubState 3
        break;

    case 3: // finish with rest of PI
        if (_chLookahead == L'?')
        {
            ADVANCE;
            if (_chLookahead == L'>')
            {
                STATE(6);
            }
            else
            {
                return XML_E_EXPECTINGTAGEND;
            }
        }

        checkhr2(push(&XMLStream::skipWhiteSpace, 4));
        checkhr2( skipWhiteSpace() );
        _sSubState = 4;
        // fall through

    case 4: // support for normalized whitespace
        mark(); // strip whitespace from beginning of PI data, since this is
                // just the separator between the PI target name and the PI  data.
        _sSubState = 5;
        // fallthrough

    case 5:
        while (! _fEOF )
        {
            if (_chLookahead == L'?')
            {
                ADVANCE;
                break;
            }
            if (! isCharData(_chLookahead))
                return XML_E_PIDECLSYNTAX;
            ADVANCE;
        }
        _sSubState = 6; // go to next state
        // fall through.
    case 6:
        checkeof(_chLookahead, XML_E_UNCLOSEDPI);
        if (_chLookahead == L'>')
        {
            ADVANCE;
            _lLengthDelta = -2; // don't include '?>' in PI CDATA.
        }
        else
        {
            // Hmmm.  Must be  a lone '?' so go back to state 5.
            STATE(5);
        }
        _nToken = XML_ENDPI;
        //_fHandlePE = true;
        checkhr2(pop());
        return _pInput->UnFreeze();
        break;      

    case 7: // recognize 'm' in '<?xml' declaration
        ADVANCE;
        if (_chLookahead != L'm' && _chLookahead != L'M')
        {
            STATE(11); // not 'xml' so jump to state 11 to parse name
        }
        _sSubState = 8;
        // fall through                

    case 8: // recognize L'l' in '<?xml' declaration
        ADVANCE;
        if (_chLookahead != L'l' && _chLookahead != L'L')
        {
            STATE(11); // not 'xml' so jump to state 11 to parse name
        }
        _sSubState = 9;
        // fall through                

    case 9: // now need whitespace or ':' or '?' to terminate name.
        ADVANCE;
        if (ISWHITESPACE(_chLookahead))
        {
            if (! _fCaseInsensitive)
            {
                const WCHAR* t;
                long len;
                getToken(&t,&len);
                //if (! StringEquals(L"xml",t,3,false)) // case sensitive
                //if (::FusionpCompareStrings(L"xml", 3, t, 3, false)!=0) // not equal 
				if(wcsncmp(L"xml", t, 3) != 0)
                    return XML_E_BADXMLCASE;
            }
            return pushTable(10, g_XMLDeclarationTable, (DWORD)XML_E_UNCLOSEDPI);
        }
        if (isNameChar(_chLookahead) || _chLookahead == ':')  
        {
            STATE(11); // Hmmm.  Must be something else then so continue parsing name
        }
        else
        {
            return XML_E_XMLDECLSYNTAX;
        }
        break;

    case 10:
        //_fHandlePE = true;
        checkhr2(pop());
        return _pInput->UnFreeze();
        break;

    case 11:
        if (_chLookahead == ':')
            ADVANCE;
        _sSubState = 12;
        // fall through
    case 12:
        if (isNameChar(_chLookahead))
        {
            checkhr2(push( &XMLStream::parseName, 2));
            _sSubState = 1; // but skip IsStartNameChar test
            checkhr2(parseName());
            return S_OK;
        } 
        else
        {
            STATE(2);
        }
        break;

    default:
        INTERNALERROR;
    }

    //return S_OK;
}
////////////////////////////////////////////////////////////////////////
HRESULT 
XMLStream::parseComment()
{
    // ok, so '<!-' has been parsed so far
    HRESULT hr = S_OK;
    switch (_sSubState)
    {
    case 0:
        //_fWasDTD = _fDTD; // as far as the DTD is concerned, the contents
        //_fHandlePE = false;    // of a COMMENT are not special.
        ADVANCE; // soak up first '-'
        checkeof(_chLookahead, XML_E_UNCLOSEDCOMMENT);
        if (_chLookahead != L'-')
        {
            return XML_E_COMMENTSYNTAX;
        }
        _sSubState = 1;
        // fall through
    case 1:
        ADVANCE; // soak up second '-'
        mark(); // don't include '<!--' in comment text
        _sSubState = 2;
        // fall through;
    case 2:
        while (! _fEOF)
        {
            if (_chLookahead == L'-')
            {
                ADVANCE; // soak up first closing L'-'                
                break;
            }
            if (! isCharData(_chLookahead))
                return XML_E_BADCHARDATA;
            ADVANCE;
        }
        checkeof(_chLookahead, XML_E_UNCLOSEDCOMMENT);
        _sSubState = 3; // advance to next state        
        // fall through.
    case 3:
        if (_chLookahead != L'-')
        {
            // Hmmm, must have been a floating L'-' so go back to state 2
            STATE(2);
        }
        ADVANCE; // soak up second closing L'-'
        _sSubState = 4; 
        // fall through
    case 4:
        checkeof(_chLookahead, XML_E_UNCLOSEDCOMMENT);
        //if (_chLookahead != L'>' && ! _fIE4Quirks)
		if (_chLookahead != L'>')
        {
            // cannot have floating L'--' unless we are in compatibility mode.
            return XML_E_COMMENTSYNTAX;
        }
        ADVANCE; // soak up closing L'>'
        _lLengthDelta = -3; // don't include L'-->' in PI CDATA.
        _nToken = XML_COMMENT;
        checkhr2(pop());
        //_fHandlePE = true;
        break;

    default:
        INTERNALERROR;
    }    
    return S_OK;
}
////////////////////////////////////////////////////////////////////////
HRESULT 
XMLStream::parseName()
{
    HRESULT hr = S_OK;
    switch (_sSubState)
    {
    case 0:
        if (! isStartNameChar(_chLookahead))
        {
            if (ISWHITESPACE(_chLookahead))
                hr = XML_E_UNEXPECTED_WHITESPACE;
            else
                hr = XML_E_BADSTARTNAMECHAR;
            goto CleanUp;
        }
        mark(); 
        _sSubState = 1;
        // fall through

    case 1:
		_lNslen = _lNssep = 0;
        while (isNameChar(_chLookahead) && !_fEOF)
        {
            ADVANCE;
        }
        hr = pop(false); // return to the previous state
        break;

    default:
        INTERNALERROR;
    }

CleanUp:
    return hr;
}
////////////////////////////////////////////////////////////////////////
HRESULT 
XMLStream::parseAttributes()
{
    HRESULT hr = S_OK;
    switch (_sSubState)
    {
    case 0:
        //_nAttrType = XMLTYPE_CDATA;
        _fCheckAttribute = false;
        checkhr2(push(&XMLStream::skipWhiteSpace, 1));
        checkhr2( skipWhiteSpace() );
        _sSubState = 1;
        // fall through
    case 1:
        if (_chLookahead == _chEndChar || _chLookahead == L'>' )
        {
            checkhr2(pop()); // no attributes.
            return S_OK;
        }
        checkhr2( push( &XMLStream::parseName, 2 ) );
        checkhr2( parseName() );

        if (!ISWHITESPACE(_chLookahead) && _chLookahead != L'=')
        {
            return XML_E_BADNAMECHAR;
        }
        _sSubState = 2;
        // fall through
    case 2:
        if (ISWHITESPACE(_chLookahead))
        {
            // Eq ::= S? '=' S?
            STATE(7);
        }

        checkeof(_chLookahead, XML_E_UNCLOSEDSTARTTAG);
        _nToken = XML_ATTRIBUTE;    
        _sSubState = 3;
        return S_OK;
        break;

    case 3:
        if (ISWHITESPACE(_chLookahead))
            return XML_E_UNEXPECTED_WHITESPACE;
        _fWhitespace = false;
        _sSubState = 4;
        // fall through

    case 4:
        if (_chLookahead != L'=')
        {
            return XML_E_MISSINGEQUALS;
        }
        ADVANCE;
        if (ISWHITESPACE(_chLookahead))
        {
            // allow whitespace between '=' and attribute value.
            checkhr2(push(&XMLStream::skipWhiteSpace, 5));
            checkhr2( skipWhiteSpace() );            
        }
        _sSubState = 5;
        // fall through

    case 5:
        if (ISWHITESPACE(_chLookahead))
            return XML_E_UNEXPECTED_WHITESPACE;
        if (_chLookahead != L'"' && _chLookahead != L'\'')
        {
            return XML_E_MISSINGQUOTE;
        }
        _chTerminator = _chLookahead;
        ADVANCE;
        mark(); 
        return push(&XMLStream::parseAttrValue, 6);
        //_sSubState = 6;
    // fall through;

    case 6:
        checkeof(_chLookahead, XML_E_UNCLOSEDSTARTTAG);
        if (_chLookahead == _chEndChar || _chLookahead == L'>')
        {
            checkhr2(pop());
            return S_OK;
        }
        if (! ISWHITESPACE(_chLookahead) )
        {
            return XML_E_MISSINGWHITESPACE;
        }
        STATE(0); // go back to state 0
        break;

    case 7:
        // allow whitespace between attribute and '='
        _lLengthDelta = _pInput->getTokenLength();
        checkhr2(push(&XMLStream::skipWhiteSpace, 8));
        checkhr2( skipWhiteSpace() );       
        _sSubState = 8;
        // fall through

    case 8:
        checkeof(_chLookahead, XML_E_UNCLOSEDSTARTTAG);
        _lLengthDelta -= _pInput->getTokenLength();
        STATE(2);
        break;

    default:
        INTERNALERROR;
    }
    //return hr;
}
////////////////////////////////////////////////////////////////////////
HRESULT XMLStream::parseAttrValue()
{
    HRESULT hr = S_OK;

    switch (_sSubState)
    {
    case 0: 
        _fParsingAttDef = true;        
        // mark beginning of attribute data           
        _sSubState =  2;
        // fall through;

    case 2:
        while ( _chLookahead != _chTerminator && 
                _chLookahead != L'<' &&
                ! _fEOF  ) 
        {
            if (_chLookahead == L'&')
            {
                // then parse entity ref and then return
                // to state 2 to continue with PCDATA.
                return push(&XMLStream::parseEntityRef,2);
            }
            hr = _pInput->scanPCData(&_chLookahead, &_fWhitespace);
            if (FAILED(hr))
            {
                if (hr == E_PENDING)
                {
                    hr = S_OK;
                    ADVANCE;
                }
                return hr;
            }
        }
        _sSubState = 3;
        // fall through
    case 3:
        checkeof(_chLookahead, XML_E_UNCLOSEDSTRING);
        if (_chLookahead == _chTerminator)
        {
            ADVANCE;
            if (_fReturnAttributeValue)
            {
                // return what we have so far - if anything.
                if ((_fUsingBuffer && _lBufLen > 0) ||
                    _pInput->getTokenLength() > 1)
                {
                    _lLengthDelta = -1; // don't include string _chTerminator.
                    _nToken = XML_PCDATA;
                }
            }
            else
            {
                _fReturnAttributeValue = true; // reset to default value.
            }
            _fParsingAttDef = false;
            checkhr2(pop());
            return S_OK;
        } 
        else
        {
            return XML_E_BADCHARINSTRING;
        }        
        break;

    default:
        INTERNALERROR;
    }
    //return hr;
}
////////////////////////////////////////////////////////////////////////
HRESULT 
XMLStream::ScanHexDigits()
{
    HRESULT hr = S_OK;
    while (! _fEOF && _chLookahead != L';')
    {
        if (! isHexDigit(_chLookahead))
        {
            return ISWHITESPACE(_chLookahead) ? XML_E_UNEXPECTED_WHITESPACE : XML_E_BADCHARINENTREF;
        }
        ADVANCE;
    }
    checkeof(_chLookahead, XML_E_UNEXPECTEDEOF);
    return hr;
}
////////////////////////////////////////////////////////////////////////
HRESULT 
XMLStream::ScanDecimalDigits()
{
    HRESULT hr = S_OK;
    while (! _fEOF && _chLookahead != L';')
    {
        if (! isDigit(_chLookahead))
        {
            return ISWHITESPACE(_chLookahead) ? XML_E_UNEXPECTED_WHITESPACE : XML_E_BADCHARINENTREF;
        }
        ADVANCE;
    }
    checkeof(_chLookahead, XML_E_UNEXPECTEDEOF);
    return hr;
}
////////////////////////////////////////////////////////////////////////
HRESULT 
XMLStream::parsePCData()
{
    HRESULT hr = S_OK;

    switch (_sSubState)
    {
    case 0:
        _fWhitespace = true;
        _sSubState = 1;
        // fall through;

    case 1:
        // This state is used when we are not normalizing white space.  This
        // is a separate state for performance reasons.  
        // Normalizing whitespace is about 11% slower.
        while (_chLookahead != L'<' && ! _fEOF )
        {
             if (_chLookahead == L'&')
            {
                // then parse entity ref and then return
                // to state 1 to continue with PCDATA.
                return push(&XMLStream::parseEntityRef,1);
            }

            if (_chLookahead == L'>')
            {
                WCHAR* pText;
                long len;
                _pInput->getToken((const WCHAR**)&pText, &len);
                //if (len >= 2 && StrCmpN(L"]]", pText + len - 2, 2) == 0)
//                if ((len >= 2) && (::FusionpCompareStrings(L"]]", 2, pText + len - 2, 2, false)==0))
                  if ((len >= 2) && (wcsncmp(L"]]", pText + len - 2, 2)==0))
		             return XML_E_INVALID_CDATACLOSINGTAG;               
            }
// This slows us down too much.
//            else if (! isCharData(_chLookahead))
//            {
//                return XML_E_BADCHARDATA;
//            }

            hr = _pInput->scanPCData(&_chLookahead, &_fWhitespace);
            if (FAILED(hr))
            {
                if (hr == E_PENDING)
                {
                    hr = S_OK;
                    ADVANCE;
                }
                return hr;
            }
            checkhr2(hr);
        }
        _sSubState = 2;
        // fall through

    case 2:
        if (_pInput->getTokenLength() > 0 || _fUsingBuffer)
        {
            _nToken = _fWhitespace ? XML_WHITESPACE : XML_PCDATA;
        }
        checkhr2(pop());
        break;

    default:
        INTERNALERROR;
    }   
    return S_OK;
}
////////////////////////////////////////////////////////////////////////
HRESULT 
XMLStream::parseEntityRef()
{
    HRESULT hr = S_OK;
    long entityLen = 0, lLen = 1;
    const WCHAR* t; 
    long len;

Start:
    switch (_sSubState)
    {
    case 0: // ^ ( '&#' [0-9]+ ) | ('&#X' [0-9a-fA-F]+) | ('&' Name) ';'
        _nPreToken = XML_PENDING;
        _lEntityPos = _pInput->getTokenLength(); // record entity position.
        _fPCDataPending = (_lEntityPos > 0);

        if (PreEntityText())
        {
            // remember the pending text before parsing the entity.
            _nPreToken = _nToken;
            _nToken = XML_PENDING;
        }
        _sSubState = 1;
        // fall through
    case 1:
        ADVANCE; // soak up the '&'
        _sSubState = 2;
        // fall through
    case 2:
        checkeof(_chLookahead, XML_E_UNEXPECTEDEOF);
        if (_chLookahead == L'#')
        {
            ADVANCE;
            _sSubState = 3;
            // fall through
        }
        else
        {
            // Loose entity parsing allows "...&6..."
            if (! isStartNameChar(_chLookahead))
            {
				/*
                if (_fFloatingAmp)
                {
                    // then it isn't an entity reference, so go back to PCDATA
                    if (_fUsingBuffer)
                    {
                        // this in case we are normalizing white space.
                        PushChar(L'&');
                    }
                    _fWhitespace = false;
                    checkhr2(pop());
                    return S_OK;
                }
                else */
				if (ISWHITESPACE(_chLookahead))
                    return XML_E_UNEXPECTED_WHITESPACE;
                else
                    return XML_E_BADSTARTNAMECHAR;
            }
            checkhr2(push(&XMLStream::parseName, 6));
            _sSubState = 1; // avoid doing a mark() so we can return PCDATA if necessary.
            return parseName();
        }
        break;

        // ------------- Numeric entity references --------------------
    case 3:
        checkeof(_chLookahead, XML_E_UNEXPECTEDEOF);
        if (_chLookahead == L'x')
        {
            // hex character reference.
            ADVANCE;
            STATE(5); // go to state 5
        }
        _sSubState = 4;
        // fall through

    case 4: // '&#' ^ [0-9]+ ';'
        checkhr2(ScanDecimalDigits());
        if (_chLookahead != L';')
        {
            STATE(9);
        }

        entityLen = _pInput->getTokenLength() - _lEntityPos;
        getToken(&t, &len);
        checkhr2(DecimalToUnicode(t + _lEntityPos + 2, entityLen - 2, _wcEntityValue));
        lLen = 2;
        _nToken = XML_NUMENTITYREF;
        GOTOSTART(10); // have to use GOTOSTART() because we want to use the values of t and len
        break;

    case 5: // '&#X' ^ [0-9a-fA-F]+
        checkhr2(ScanHexDigits());
        if (_chLookahead != L';')
        {
            STATE(9);
        }

        entityLen = _pInput->getTokenLength() - _lEntityPos;
        getToken(&t, &len);
        checkhr2(HexToUnicode(t + _lEntityPos + 3, entityLen - 3, _wcEntityValue));
        lLen = 3;
        _nToken = XML_HEXENTITYREF;
        GOTOSTART(10);  // have to use GOTOSTART() because we want to use the values of t and len
        break;
        
        // ------------- Named Entity References --------------------
    case 6: // '&' Name ^ ';'
        checkeof(_chLookahead, XML_E_UNEXPECTEDEOF);
        if (_chLookahead != L';')
        {
            STATE(9);
        }

        // If parseName found a namespace then we need to calculate the
        // real nslen taking the pending PC data and '&' into account
        // and remember this in case we have to return the PCDATA.
        _nEntityNSLen = (_lNslen > 0) ? _lNslen - _lEntityPos - 1 : 0;
        _fUsingBuffer = false;

        entityLen = _pInput->getTokenLength() - _lEntityPos;
        getToken(&t, &len);

        if (0 != (_wcEntityValue = BuiltinEntity(t + _lEntityPos + 1, entityLen - 1))) //||
            //(_fIE4Quirks && 0xFFFF != (_wcEntityValue = LookupBuiltinEntity(t + _lEntityPos + 1, entityLen - 1))))
        {
            lLen = 1;
            _nToken = XML_BUILTINENTITYREF;
            GOTOSTART(10);  // have to use GOTOSTART() because we want to use the values of t and len
        }
        else //xiaoyu : Fusion XML Parser does not support external ref, 
			 // so, if it is not a builtIn ref, we would return error
			return XML_E_MISSINGSEMICOLON;
		break; 
		//xiaoyu : Fusion XML Parser does not support external ref
		/*
			if (_nPreToken != XML_PENDING)
        {
            // Return previous token (XML_PCDATA or XML_WHITESPACE)
            _lLengthDelta = -entityLen;
            _lMarkDelta = entityLen - 1; // don't include '&' in _nToken.
            _nToken = _nPreToken;
            STATE(7);
        }

        mark(entityLen-1); // don't include '&' in _nToken.
        _sSubState = 7;
        // fall through

    case 7:
        ADVANCE; // soak up the ';'
        _nToken = XML_ENTITYREF;
        _lNslen = _nEntityNSLen;
        _lLengthDelta = -1; // don't include the ';'
        STATE(8); // return token and resume in state 8.
        break;
    */
    case 8:
        mark();
        checkhr2(pop());
        return S_OK;
	/*
    case 9:
        // Soft entity handling - we just continue with PCDATA in 
        // this case.
		
        if (_fFloatingAmp)
        {
            if (_fUsingBuffer)
            {
                // this in case we are normalizing white space.  In this case
                // we have to copy what we have so far to the normalized buffer.
                long endpos = _pInput->getTokenLength();
                const WCHAR* t; long len;
                getToken(&t, &len);
                for (long i = _lEntityPos; i < endpos; i++)
                    PushChar(t[i]);
            }
            _fWhitespace = false;
            checkhr2(pop());
            return S_OK;
        }
        else
		
            return XML_E_MISSINGSEMICOLON;
        break;
	*/

    case 10:
        // Return the text before builtin or char entityref as XML_PCDATA
        if (_nPreToken)
        {
            _nPreToken = _nToken;
            _nToken = XML_PCDATA;
            _lLengthDelta = -entityLen;
            _lMarkDelta = entityLen - lLen; // don't include '&' in _nToken.
            STATE(11);  // return token and resume in state 12.
        }
        else
        {
            _nPreToken = _nToken;
            mark(entityLen - lLen);
            GOTOSTART(11);
        }
        break;

    case 11:
        // push the builtin entity
        _fUsingBuffer = true;
        PushChar(_wcEntityValue);
        _nToken = _nPreToken;
        STATE(12); // return token and resume in state 12.
        break;

    case 12:
        ADVANCE; // soak up the ';'
        STATE(8); // resume in state 8.
        break;

    default:
        INTERNALERROR;
    }   
    return S_OK;      
}
////////////////////////////////////////////////////////////////////////
HRESULT 
XMLStream::pushTable(short substate, const StateEntry* table, DWORD le)
{
    HRESULT hr = S_OK;

    checkhr2(push(&XMLStream::parseTable, substate));
	_pTable = table;
	UNUSED(le);
    //_lEOFError = le;
    return hr;
}
////////////////////////////////////////////////////////////////////////
HRESULT 
XMLStream::push(StateFunc f, short s)
{
    StateInfo* pSI = _pStack.push();
    if (pSI == NULL)
        return E_OUTOFMEMORY;

    pSI->_sSubState = s;
    pSI->_fnState = _fnState;
	pSI->_pTable = _pTable;
	pSI->_cStreamDepth = _cStreamDepth;


    _sSubState = 0;
    _fnState = f;

    return S_OK;
}
////////////////////////////////////////////////////////////////////////
HRESULT
XMLStream::pop(bool boundary)
{
    StateInfo* pSI = _pStack.peek();

    if (_fDTD && 
        ! (_fParsingAttDef) && boundary && _cStreamDepth != pSI->_cStreamDepth) // _fParsingNames || 
    {
        // If we are in a PE and we are popping out to a state that is NOT in a PE
        // and this is a pop where we need to check this condition, then return an error.
        // For example, the following is not well formed because the parameter entity
        // pops us out of the ContentModel state in which the PE was found:
        // <!DOCTYPE foo [
        //      <!ENTITY % foo "a)">
        //      <!ELEMENT bar ( %foo; >
        //  ]>...
        return XML_E_PE_NESTING;
    }

    _fnState	= pSI->_fnState;
    _sSubState	= pSI->_sSubState;
    _pTable		= pSI->_pTable;
    //_lEOFError	= pSI->_lEOFError;
    _pStack.pop();

    return S_OK;
}
////////////////////////////////////////////////////////////////////////
HRESULT 
XMLStream::switchTo(StateFunc f)
{
    HRESULT hr;

    // Make sure we keep the old stream depth.
    StateInfo* pSI = _pStack.peek();
    int currentDepth = _cStreamDepth;
    _cStreamDepth = pSI->_cStreamDepth;

    checkhr2(pop(false));
    checkhr2(push(f,_sSubState)); // keep return to _sSubState the same

    _cStreamDepth = currentDepth;

    return (this->*f)();
}
////////////////////////////////////////////////////////////////////////
HRESULT 
XMLStream::parseCondSect()
{
    HRESULT hr = S_OK;
    switch (_sSubState)
    {
    case 0:
        ADVANCE; // soak up the '[' character
        //if (_fFoundPEREf) return S_OK;
        _sSubState = 1;
        // fall through
    case 1: // now match magic '[CDATA[' sequence.     
        checkeof(_chLookahead, XML_E_UNCLOSEDMARKUPDECL);
        if (_chLookahead == L'C')
        {
            _pchCDataState = g_pstrCDATA;
            STATE(5); // goto state 5
        }
        _sSubState = 2;   // must be IGNORE, INCLUDE or %pe;
        // fall through

    case 2: // must be DTD markup declaration
        // '<![' ^ S? ('INCLUDE' | 'IGNORE' | %pe;) S? [...]]> or 
        // skip optional whitespace
        //if (_fInternalSubset)
        //    return XML_E_CONDSECTINSUBSET;
        checkeof(_chLookahead, XML_E_EXPECTINGOPENBRACKET);
        checkhr2(push(&XMLStream::skipWhiteSpace, 3));
        return skipWhiteSpace(); // must return because of %pe;

    case 3:
        checkeof(_chLookahead, XML_E_UNCLOSEDMARKUPDECL);
        checkhr2(push(&XMLStream::parseName,4));
        return parseName();

    case 4: // scanned 'INCLUDE' or 'IGNORE'
        {
            const WCHAR* t;
            long len;
            getToken(&t,&len);
            //if (StringEquals(L"IGNORE",t,len,false))
            //{
            //    return switchTo(&XMLStream::parseIgnoreSect);
            //}
            //else if (StringEquals(L"INCLUDE",t,len,false))
            //{
            //    return switchTo(&XMLStream::parseIncludeSect);
            //}
            //else
                return XML_E_BADENDCONDSECT;
        }
        break;

    case 5: // parse CDATA name
        while (*_pchCDataState != 0 && _chLookahead == *_pchCDataState && ! _fEOF)
        {
            ADVANCE;            // advance first, before incrementing _pchCDataState
            _pchCDataState++;   // so that this state is re-entrant in the E_PENDING case.
            checkeof(_chLookahead, XML_E_UNCLOSEDMARKUPDECL);
        }
        if (*_pchCDataState != 0)
        {
            // must be INCLUDE or IGNORE section so go to state 2.
            _sSubState = 2;
        } 
        else if (_chLookahead != L'[')
        {
            return XML_E_EXPECTINGOPENBRACKET;
        }
        else if (_fDTD)
            return XML_E_CDATAINVALID;
        else
            return switchTo(&XMLStream::parseCData);

        return S_OK;
        break;        

    default:
        INTERNALERROR;
    }
    return S_OK;
}

////////////////////////////////////////////////////////////////////////
HRESULT 
XMLStream::parseCData()
{
    HRESULT hr = S_OK;
    switch (_sSubState)
    {
    case 0:
        ADVANCE; // soak up the '[' character.
        mark(); // don't include 'CDATA[' in CDATA text
        _sSubState = 1;
        // fall through
    case 1:
        while (_chLookahead != L']' && ! _fEOF)
        {
            // scanPCData will stop when it sees a ']' character.
            hr = _pInput->scanPCData(&_chLookahead, &_fWhitespace);
            if (FAILED(hr))
            {
                if (hr == E_PENDING)
                {
                    hr = S_OK;
                    ADVANCE;
                }
                return hr;
            }
        }
        checkeof(_chLookahead, XML_E_UNCLOSEDCDATA);
        _sSubState = 2;
        // fall through
    case 2:
        ADVANCE; // soak up first L']' character.
        checkeof(_chLookahead, XML_E_UNCLOSEDCDATA);
        if (_chLookahead != L']')
        {
            // must have been floating ']' character, so
            // return to state 1.
            STATE(1); 
        }
        _sSubState = 3;
        // fall through
    case 3:
        ADVANCE; // soak up second ']' character.
        checkeof(_chLookahead, XML_E_UNCLOSEDCDATA);
        if (_chLookahead == L']')
        {
            // Ah, an extra ']' character, tricky !!  
            // In this case we stay in state 3 until we find a non ']' character
            // so you can terminate a CDATA section with ']]]]]]]]]]]]]]]]>'
            // and everying except the final ']]>' is treated as CDATA.
            STATE(3);
        }
        else if (_chLookahead != L'>')
        {
            // must have been floating "]]" pair, so
            // return to state 1.
            STATE(1);
        }
        _sSubState = 4;
        // fall through
    case 4:
        ADVANCE; // soak up the '>'
        _nToken = XML_CDATA;
        _lLengthDelta = -3; // don't include terminating ']]>' in text.
        checkhr2(pop()); // return to parseContent.
        return S_OK;
        break;

    default:
        INTERNALERROR;
    }
    return S_OK;
}
////////////////////////////////////////////////////////////////////////
HRESULT
XMLStream::parseEquals()
{
    HRESULT hr = S_OK;
    switch (_sSubState)
    {
    case 0: // Eq ::= S? '=' S? 
        if (ISWHITESPACE(_chLookahead))
        {
            // allow whitespace between attribute and '='
            checkhr2(push(&XMLStream::skipWhiteSpace, 1));
            checkhr2( skipWhiteSpace() );            
        }
        _sSubState = 1;
        // fall through

    case 1:
        if (_chLookahead != L'=')
        {
            return XML_E_MISSINGEQUALS;
        }
        ADVANCE;
        if (ISWHITESPACE(_chLookahead))
        {
            // allow whitespace between '=' and attribute value.
            checkhr2(push(&XMLStream::skipWhiteSpace, 2));
            checkhr2( skipWhiteSpace() );            
        }
        _sSubState = 2;
        // fall through

    case 2:
        checkhr2(pop(false));
        break;

    default:
        INTERNALERROR;

    }
    return S_OK;
}
////////////////////////////////////////////////////////////////////////
HRESULT 
XMLStream::parseTable()
{
    HRESULT hr = S_OK;

    while (hr == S_OK && _nToken == XML_PENDING)
    {
        const StateEntry* pSE = &_pTable[_sSubState];

        DWORD newState = pSE->_sGoto;

        switch (pSE->_sOp)
        {
        case OP_WS:
            //checkeof(_chLookahead, _lEOFError);
            if (! ISWHITESPACE(_chLookahead))
                return XML_E_MISSINGWHITESPACE;
            // fall through
        case OP_OWS:
            //checkeof(_chLookahead, _lEOFError);
            checkhr2(push(&XMLStream::skipWhiteSpace, (short)newState));
            checkhr2(skipWhiteSpace());
            //if (_fFoundPEREf) return XML_E_FOUNDPEREF;
            break;
        case OP_CHARWS:
            //if (_fFoundPEREf) return S_OK;
            mark();
            //checkeof(_chLookahead, _lEOFError);
            if (_chLookahead == pSE->_pch[0])
            {
                ADVANCE;
                newState = pSE->_sGoto;
                _nToken = pSE->_lDelta;
            }
            else if (! ISWHITESPACE(_chLookahead))
            {
                return XML_E_WHITESPACEORQUESTIONMARK;
            }
            else
                newState = pSE->_sArg1;
            break;
        case OP_CHAR:
            //if (_fFoundPEREf) return S_OK;
            mark();
        case OP_CHAR2:
            //if (_fFoundPEREf) return S_OK;
            //checkeof(_chLookahead, _lEOFError);
            if (_chLookahead == pSE->_pch[0])
            {
                ADVANCE;
                newState = pSE->_sGoto;
                _nToken = pSE->_lDelta;
                //if (_nToken == XML_GROUP)
                    //_nAttrType = XMLTYPE_NMTOKEN;
            }
            else
            {
                newState = pSE->_sArg1;
                if (newState >= XML_E_PARSEERRORBASE &&
                    ISWHITESPACE(_chLookahead))
                    return XML_E_UNEXPECTED_WHITESPACE;
            }
            break;
        case OP_PEEK:
            //if (_fFoundPEREf) return S_OK;
            //checkeof(_chLookahead, _lEOFError);
            if (_chLookahead == pSE->_pch[0])
            {
                newState = pSE->_sGoto;
            }
            else
                newState = pSE->_sArg1;
            break;

        case OP_NAME:
            //if (_fFoundPEREf) return S_OK;
            //checkeof(_chLookahead, _lEOFError);
            checkhr2(push(&XMLStream::parseName, (short)newState));
            checkhr2(parseName());
            break;
        case OP_TOKEN:
            _nToken = pSE->_sArg1;
            _lLengthDelta = pSE->_lDelta;  
            break;
        case OP_POP:
            _lLengthDelta = pSE->_lDelta;
            if (_lLengthDelta == 0) mark();
            // The _lDelta field contains a boolean flag to tell us whether this
            // pop needs to check for parameter entity boundary or not.
            checkhr2(pop(pSE->_lDelta == 0)); // we're done !
            _nToken = pSE->_sArg1;
            //_nAttrType = XMLTYPE_CDATA;
            return S_OK;
        case OP_STRCMP:
            {
                const WCHAR* t;
                long len;
                getToken(&t,&len);
                long delta = (pSE->_lDelta < 0) ? pSE->_lDelta : 0;
                //if (StringEquals(pSE->_pch,t,len+delta,_fCaseInsensitive))
                //if (::FusionpCompareStrings(pSE->_pch, len+delta, t, len+delta, _fCaseInsensitive)==0)
				if (CompareUnicodeStrings(pSE->_pch, t, len+delta, _fCaseInsensitive)==0)
                {
                    if (pSE->_lDelta > 0) 
                    {
                        _nToken = pSE->_lDelta;
                        _lLengthDelta = 0;
                    }

					newState = pSE->_sGoto;
                }
                else
                    newState = pSE->_sArg1;
             }
             break;

        case OP_COMMENT:
            return push(&XMLStream::parseComment, (short)newState);
            break;

        case OP_CONDSECT:
            //if (_fFoundPEREf) return S_OK;
            // parse <![CDATA[...]]> or <![IGNORE[...]]>
            return push(&XMLStream::parseCondSect, (short)newState);

        case OP_SNCHAR:
            //checkeof(_chLookahead, _lEOFError);
            if (isStartNameChar(_chLookahead))
            {
                newState = pSE->_sGoto;
            }
            else
                newState = pSE->_sArg1;
            break;
        case OP_EQUALS:
            //if (_fFoundPEREf) return S_OK;
            //checkeof(_chLookahead, _lEOFError);
            checkhr2(push(&XMLStream::parseEquals, (short)newState));
            checkhr2(parseEquals());
            break;
        case OP_ENCODING:
            {
                const WCHAR* t;
                long len;
                _pInput->getToken(&t,&len);
                hr =  _pInput->switchEncoding(t, len+pSE->_lDelta);
            }
            break;

        case OP_ATTRVAL:
            //if (_fFoundPEREf) return S_OK;
            if (_chLookahead != L'"' && _chLookahead != L'\'')
            {
                return XML_E_MISSINGQUOTE;
            }  
            _chTerminator = _chLookahead;
            ADVANCE; 
            mark();
            _fReturnAttributeValue = (pSE->_sArg1 == 1);
            //checkeof(_chLookahead, _lEOFError);
            return push(&XMLStream::parseAttrValue, (short)newState);
            break;

        } // end of switch
        if (_fnState != &XMLStream::parseTable)
            return S_OK;

        if (newState >= XML_E_PARSEERRORBASE)
            return (HRESULT)newState;
        else
            _sSubState = (short)newState;
    } // end of while

    if (_nToken == XMLStream::XML_ENDDECL)
    {
        return _pInput->UnFreeze();
    }
    return S_OK;
}
////////////////////////////////////////////////////////////////////////
HRESULT    
XMLStream::_PushChar(WCHAR ch) 
{
    // buffer needs to grow.
    long   newsize =  (_lBufSize+512)*2 ;
    WCHAR* newbuf = NEW ( WCHAR[newsize]);
    if (newbuf == NULL)
        return E_OUTOFMEMORY;

    if (_pchBuffer != NULL){
        ::memcpy(newbuf, _pchBuffer, sizeof(WCHAR)*_lBufLen);
        delete[] _pchBuffer;
    }

    _lBufSize = newsize;
    _pchBuffer = newbuf;   
    _pchBuffer[_lBufLen++] = ch;
    
	return S_OK;
}
////////////////////////////////////////////////////////////////////////
HRESULT 
XMLStream::AdvanceTo(short substate)
{
    // This method combines and advance with a state switch in one
    // atomic operation that handles the E_PENDING case properly.

    _sSubState = substate;

    //HRESULT hr = (!_fDTD) ? _pInput->nextChar(&_chLookahead, &_fEOF) : DTDAdvance(); 
	HRESULT hr = _pInput->nextChar(&_chLookahead, &_fEOF) ; 
    if (hr != S_OK && (hr == E_PENDING || hr == E_DATA_AVAILABLE || hr == E_DATA_REALLOCATE || hr == XML_E_FOUNDPEREF))
    {
        // Then we must do an advance next time around before continuing
        // with previous state.  Push will save the _sSubState and return
        // to it.
        push(&XMLStream::firstAdvance,substate);
    }    
    return hr;
}
////////////////////////////////////////////////////////////////////////
bool
XMLStream::PreEntityText()
{
    // This is a helper function that calculates whether or not to
    // return some PCDATA or WHITEPACE before an entity reference.
    if (_fPCDataPending)
    {
        // return what we have so far.
        //if (_fWhitespace && ! _fIE4Quirks) // in IE4 mode we do not have WHITESPACE nodes
                                           // and entities are always resolved, so return
                                           // the leading whitespace as PCDATA.
		if (_fWhitespace )
            _nToken = XML_WHITESPACE;                                
        else                               
            _nToken = XML_PCDATA;

        long entityLen = _pInput->getTokenLength() - _lEntityPos;
        _lLengthDelta = -entityLen;
        _lMarkDelta = entityLen;
        _fPCDataPending = false;
        _fWhitespace = true;
        return true;
    }

    return false;
}
////////////////////////////////////////////////////////////////////////
HRESULT 
XMLStream::ErrorCallback(HRESULT hr)
{
    if (hr == E_DATA_AVAILABLE)
        hr = XML_DATAAVAILABLE;
    else if (hr == E_DATA_REALLOCATE)
        hr = XML_DATAREALLOCATE;
    return _pXMLParser->ErrorCallback(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\xmlparser\_rawstack.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*
* 
* EXEMPT: copyright change only, no build required
* 
*/
#ifndef _RAWSTACK_HXX
#define _RAWSTACK_HXX
#pragma once

//===========================================================================
// This is a raw stack based on a contiguous block of memory that is divided
// up into chunks.
//
// This is a Non-GC class because it is used in the tokenizer.
//

class RawStack
{
public:
    RawStack(long entrySize, long growth);
    ~RawStack();

protected:
    inline char* _push() { if (_ncSize == _ncUsed) return __push(); return &_pStack[_lEntrySize * _ncUsed++]; }
    inline char* _pop() { if (_ncUsed > 0) _ncUsed--; return _peek(); }
    inline char* _peek() { if (_ncUsed == 0) return NULL; return &_pStack[_lEntrySize * (_ncUsed - 1)]; }
    inline char* _item(long index) { return &_pStack[_lEntrySize * index]; }

    long    _lEntrySize;    
    char*   _pStack;
    long    _ncUsed;
    long    _ncSize;
    long    _lGrowth;

private:
    char* __push();
};

//===========================================================================
// This class implements a raw stack of C primitive types (or structs).

template <class T> class _rawstack : public RawStack
{
public:        
        _rawstack<T>(long growth) : RawStack(sizeof(T),growth)
        { 
        }

        T* push()
        {
            return (T*)_push();
        }

        T* pop()
        {
            return (T*)_pop();
        }

        T* peek()
        {
            return (T*)_peek();
        }

        long size()
        {
            return _ncSize;
        }

        long used()
        {
            return _ncUsed;
        }

        T* operator[](long index)
        {
            return (T*)_item(index);
        }
};    

#endif _RAWSTACK_HXX
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\xmlparser\_reference.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*
 * @(#)_reference.cxx 1.0 6/3/97
 * 
 */
//#include "stdinc.h"
#include "core.h"
#pragma hdrstop

void _assign(IUnknown ** ppref, IUnknown * pref)
{
    IUnknown *punkRef = *ppref;

#ifdef FUSION_USE_OLD_XML_PARSER_SOURCE
	if (pref) ((Object *)pref)->AddRef();
		(*ppref) = (Object *)pref; 
#else // fusion xml parser
    if (pref) pref->AddRef();
    (*ppref) = pref; 

#endif

    if (punkRef) punkRef->Release();
}    

void _release(IUnknown ** ppref)
{
    if (*ppref) 
    {
        (*ppref)->Release();
        *ppref = NULL;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\xmlparser\_reference.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#ifndef __reference_HXX
#define __reference_HXX
#pragma once

/*
 * @(#)_reference.hxx 1.0 2/27/98
 * 
 */
    
void _assign(IUnknown ** ppref, IUnknown * pref);
void _release(IUnknown ** ppref);

template <class T> 
void assign(T ** ppref, T * pref){ _assign((IUnknown **) ppref, pref);}

//----------------------------------------------------------------------------
template <class T> class _reference
{    
private:
    T * _p;
public:
    
    _reference() : _p(NULL) {}

    _reference(T * p) : _p(p) { if (_p) _p->AddRef(); }    

    _reference(const _reference<T> & r) { _p = r._p; if (_p) _p->AddRef(); }

    ~_reference() { _release((IUnknown **)&_p); }

    operator T * () { return _p; }    

    operator T * () const { return _p; }    

    T & operator * () { return *_p; }

    T * operator -> () { return _p; }    

    T * operator -> () const { return _p; }    

    T** operator & () { return &_p; }

    _reference & operator = (T * p) { assign(&_p, p); return *this; }

    _reference & operator = (const _reference<T> & r) { return operator=(r._p); }
};

#endif __reference_HXX
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\xmlparser\_rawstack.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*
 * @(#)_rawstack.cxx 1.0 3/30/98
 * 
 */
//#include "stdinc.h"
#include "core.h"
#pragma hdrstop

#include "_rawstack.h"

//===========================================================================
RawStack::RawStack(long entrySize, long growth)
{
    _lEntrySize = entrySize;
    _pStack = NULL;
    _ncUsed = _ncSize = 0;
    _lGrowth = growth;
}
 
RawStack::~RawStack()
{
    delete _pStack;
}

char* 
RawStack::__push()
{
    // No magic object construction -- user has to do this.
#ifdef FUSION_USE_OLD_XML_PARSER_SOURCE
	char* newStack = new_ne char[_lEntrySize * ( _ncSize + _lGrowth) ];
#else
	char* newStack = NEW (char[_lEntrySize * ( _ncSize + _lGrowth) ]);
#endif
    if (newStack == NULL)
    {
        return NULL;
    }
    ::memset(newStack, 0, _lEntrySize * (_ncSize + _lGrowth));
    if (_ncUsed > 0)
    {
        ::memcpy(newStack, _pStack, _lEntrySize * _ncUsed);
    }
    _ncSize += _lGrowth;
    delete _pStack;
    _pStack = newStack;

    return &_pStack[_lEntrySize * _ncUsed++];
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\zzbbt\makefile.inc ===
!IF "$(LINKONLY)" == "1"

RunTheScript:
!if "$(TARGETCOMPLUS)" != ""
	BuildBBT.bat
!endif

!ELSE

RunTheScript:

!ENDIF
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\zzbuildpreproc\makefile.inc ===
RunTheScript:
        CleanUpForBuild.cmd
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\xmlparser\_unknown.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*
* 
* EXEMPT: copyright change only, no build required
* 
*/
#ifndef _UNKNOWN_HXX
#define _UNKNOWN_HXX
#pragma once

#include "core.h"
//===========================================================================
// This template implements the IUnknown portion of a given COM interface.

template <class I, const IID* I_IID> class _unknown : public I
{
private:    long _refcount;

public:        
        _unknown() 
        { 
            _refcount = 0;
        }

        virtual ~_unknown()
        {
        }

        virtual HRESULT STDMETHODCALLTYPE QueryInterface(REFIID riid, void ** ppvObject)
        {
            if (riid == IID_IUnknown)
            {
                *ppvObject = static_cast<IUnknown*>(this);
            }
            else if (riid == *I_IID)
            {
                *ppvObject = static_cast<I*>(this);
            }
            else
                return E_NOINTERFACE;
            
            reinterpret_cast<IUnknown*>(*ppvObject)->AddRef();
            return S_OK;
        }
    
        virtual ULONG STDMETHODCALLTYPE AddRef( void)
        {
            return InterlockedIncrement(&_refcount);
        }
    
        virtual ULONG STDMETHODCALLTYPE Release( void)
        {
            if (InterlockedDecrement(&_refcount) == 0)
            {
                delete this;
                return 0;
            }
            return _refcount;
        }
};    

#endif _UNKNOWN_HXX
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\zap\nlog.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#include <WinWrap.h>
#include <windows.h>
#include <stdlib.h>
#include <objbase.h>
#include <stddef.h>
#include <float.h>
#include <limits.h>

#include "utilcode.h"
#include "arraylist.h"

#include "nlog.h"
#include "hrex.h"

//
// To prejit everything in the log:
//
// iterate over NLogDirectory.  For each NLog:
//      Merge all NLogRecords.
//      In the merged record, for each assembly
//          Verify the assembly's identity by binding in context???
//          if the assembly is simple named, 
//              compile the zap file.
//          if the assembly is strong named, 
//              bind the assembly. 
//              Store the assembly in the strong named list.
//                  (Merge with existing matching assembly if necessary.)
// Finally, iterate over the strong named list.
//      Compile every assembly in the list.
//
// To do a subset, compute weights for every assembly described above, and
// prioritize.
//
// Think about: Construct NLogRecords from existing native images, and factor
// in with existing data.  This may make sense only for strong named images.
// Note that if we're logging existing zap files however, we will 
// automatically pick this stuff up as part of the existing logging.
//

//
// @todo ia64: examine use of DWORD for sizes throughout
//

/* ------------------------------------------------------------------------------------ *
 * NLogFile
 * ------------------------------------------------------------------------------------ */

NLogFile::NLogFile(LPCWSTR pPath)
  : MiniFile(pPath)
{
}

CorZapSharing NLogFile::ReadSharing()
{
    if (CheckEmptyTag("MultiDomain"))
        return CORZAP_SHARING_MULTIPLE;
    else
        return CORZAP_SHARING_SINGLE;
}

void NLogFile::WriteSharing(CorZapSharing sharing)
{
    switch (sharing)
    {
    case CORZAP_SHARING_MULTIPLE:
        StartNewLine();
        WriteEmptyTag("MultiDomain");
        break;
    case CORZAP_SHARING_SINGLE:
        break;
    }
}

CorZapDebugging NLogFile::ReadDebugging()
{
    if (CheckEmptyTag("Debug"))
        return CORZAP_DEBUGGING_FULL;
    else if (CheckEmptyTag("DebugOpt"))
        return CORZAP_DEBUGGING_OPTIMIZED;
    else
        return CORZAP_DEBUGGING_NONE;
}

void NLogFile::WriteDebugging(CorZapDebugging debugging)
{
    switch (debugging)
    {
    case CORZAP_DEBUGGING_FULL:
        StartNewLine();
        WriteEmptyTag("Debug");
        break;
    case CORZAP_DEBUGGING_OPTIMIZED:
        StartNewLine();
        WriteEmptyTag("DebugOpt");
        break;
    case CORZAP_DEBUGGING_NONE:
        break;
    }
}

CorZapProfiling NLogFile::ReadProfiling()
{
    if (CheckEmptyTag("ProfilerHooks"))
        return CORZAP_PROFILING_ENABLED;
    else
        return CORZAP_PROFILING_DISABLED;
}

void NLogFile::WriteProfiling(CorZapProfiling profiling)
{
    switch (profiling)
    {
    case CORZAP_PROFILING_ENABLED:
        StartNewLine();
        WriteEmptyTag("ProfilerHooks");
        break;
    case CORZAP_PROFILING_DISABLED:
        break;
    }
}

void NLogFile::ReadTimestamp(SYSTEMTIME *pTimestamp)
{
    ZeroMemory(pTimestamp, sizeof(SYSTEMTIME));

    if (CheckStartTag("Timestamp"))
    {
        pTimestamp->wYear = ReadNumber();
        MatchOne(' ');
        pTimestamp->wMonth = ReadNumber();
        MatchOne(' ');
        pTimestamp->wDay = ReadNumber();
        MatchOne(' ');
        pTimestamp->wHour = ReadNumber();
        MatchOne(' ');
        pTimestamp->wMinute = ReadNumber();
        MatchOne(' ');
        pTimestamp->wSecond = ReadNumber();

        ReadEndTag("Timestamp");
    }
}

void NLogFile::WriteTimestamp(SYSTEMTIME *pTimestamp)
{
    WriteStartTag("Timestamp");
    WriteNumber(pTimestamp->wYear);
    WriteOne(' ');
    WriteNumber(pTimestamp->wMonth);
    WriteOne(' ');
    WriteNumber(pTimestamp->wDay);
    WriteOne(' ');
    WriteNumber(pTimestamp->wHour);
    WriteOne(' ');
    WriteNumber(pTimestamp->wMinute);
    WriteOne(' ');
    WriteNumber(pTimestamp->wSecond);
    WriteEndTag("Timestamp");
}

static LPWSTR applicationContextProperties[] = 
{
    ACTAG_APP_BASE_URL,
    ACTAG_MACHINE_CONFIG,
    ACTAG_APP_PRIVATE_BINPATH,
    ACTAG_APP_SHARED_BINPATH,
    ACTAG_APP_DYNAMIC_BASE,
    ACTAG_APP_SNAPSHOT_ID,
    ACTAG_APP_ID, // @todo: include this ????
};

static LPCSTR applicationContextTags[] = 
{
    "Base",
    "ConfigFile",
    "PrivateBinPath",
    "SharedBinPath",
    "DynamicBase",
    "SnapshotID",
    "AppID",
};

IApplicationContext *NLogFile::ReadApplicationContext()
{
    IApplicationContext *pContext;

    ReadStartTag("IApplicationContext");

    IAssemblyName *pName = ReadAssemblyName();
    IfFailThrow(CreateApplicationContext(pName, &pContext));
    pName->Release();

    CQuickBytes buffer;

    for (int i=0; i<(sizeof(applicationContextProperties)
                     /sizeof(*applicationContextProperties)); i++)
    {
        LPSTR prop = CheckTag(applicationContextTags[i]);
        
        if (prop != NULL)
        {
            MAKE_WIDEPTR_FROMUTF8(wprop, prop);

            IfFailThrow(pContext->Set(applicationContextProperties[i], wprop, 
                                      (DWORD)((wcslen(wprop)+1)*2), 0));

            delete [] prop;
        }
    }
    
    ReadEndTag("IApplicationContext");

    return pContext;
}

void NLogFile::WriteApplicationContext(IApplicationContext *pContext)
{
    WriteStartTag("IApplicationContext");

    StartNewLine();

    IAssemblyName *pName;
    IfFailThrow(pContext->GetContextNameObject(&pName));
    WriteAssemblyName(pName);
    pName->Release();

    CQuickBytes buffer;

    for (int i=0; i<(sizeof(applicationContextProperties)
                     /sizeof(*applicationContextProperties)); i++)
    {
        DWORD cbSize = 0;
        if (pContext->Get(applicationContextProperties[i], NULL, &cbSize, 0)
            == HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER))
        {
            buffer.ReSize(cbSize);
            LPWSTR pwName = (LPWSTR) buffer.Ptr();
            IfFailThrow(pContext->Get(applicationContextProperties[i], pwName, &cbSize, 0));

            MAKE_UTF8PTR_FROMWIDE(pName, pwName);

            WriteTag(applicationContextTags[i], pName);
            StartNewLine();
        }
    }
        
    StartNewLine();

    WriteEndTag("IApplicationContext");

    StartNewLine();
}

static int assemblyNameProperties[] = 
{
    ASM_NAME_CODEBASE_URL,
};

static LPCSTR assemblyNameTags[] = 
{
    "CodeBase",
};

IAssemblyName *NLogFile::ReadAssemblyName()
{
    ReadStartTag("IAssemblyName");

    LPSTR pDisplayName = ReadTag("Name");

    MAKE_WIDEPTR_FROMUTF8(pwDisplayName, pDisplayName);

    IAssemblyName *pName;
    IfFailThrow(CreateAssemblyNameObject(&pName, pwDisplayName, 
                                         CANOF_PARSE_DISPLAY_NAME, NULL));

    delete [] pDisplayName;

    CQuickBytes buffer;

    for (int i=0; i<(sizeof(assemblyNameProperties)
                     /sizeof(*assemblyNameProperties)); i++)
    {
        LPSTR prop = CheckTag(assemblyNameTags[i]);
        
        if (prop != NULL)
        {
            MAKE_WIDEPTR_FROMUTF8(wprop, prop);

            IfFailThrow(pName->SetProperty(assemblyNameProperties[i], (BYTE*) wprop, 
                                           (DWORD)((wcslen(wprop)+1)*2)));

            delete [] prop;
        }
    }
    
    ReadEndTag("IAssemblyName");

    return pName;
}

void NLogFile::WriteAssemblyName(IAssemblyName *pName)
{
    WriteStartTag("IAssemblyName");

    StartNewLine();

    CQuickBytes buffer;
    DWORD cDisplayName = (DWORD)(buffer.Size()/sizeof(WCHAR));

    HRESULT hr = pName->GetDisplayName((WCHAR*)buffer.Ptr(), &cDisplayName, 0);

    if (hr == HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER))
    {
        IfFailThrow(buffer.ReSize(cDisplayName*sizeof(WCHAR)));

        IfFailThrow(pName->GetDisplayName((WCHAR*)buffer.Ptr(), &cDisplayName, 0));
    }

    MAKE_UTF8PTR_FROMWIDE(pDisplayName, (WCHAR*)buffer.Ptr());

    WriteTag("Name", pDisplayName);

    StartNewLine();

    for (int i=0; i<(sizeof(assemblyNameProperties)
                     /sizeof(*assemblyNameProperties)); i++)
    {
        DWORD cbSize = 0;
        if (pName->GetProperty(assemblyNameProperties[i], NULL, &cbSize)
            == HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER))
        {
            buffer.ReSize(cbSize);
            IfFailThrow(pName->GetProperty(assemblyNameProperties[i], buffer.Ptr(), &cbSize));

            LPWSTR pwName = (LPWSTR) buffer.Ptr();
            MAKE_UTF8PTR_FROMWIDE(pName, pwName);

            WriteTag(assemblyNameTags[i], pName);
            StartNewLine();
        }
    }

    WriteEndTag("IAssemblyName");
}

/* ------------------------------------------------------------------------------------ *
 * NLogDirectory
 * ------------------------------------------------------------------------------------ */

#define LOGSUBDIRECTORY L"nlog\\"

NLogDirectory::NLogDirectory()
{
    //
    // Put the log directory in the system directory.  We should have 
    // the installer ensure that this directory exists and is writable.
    // Note that the logs exist in a version specific area - entries
    // in the log are specific to a particular version of the runtime.
    //

    DWORD cDir = sizeof(m_wszDirPath)/sizeof(*m_wszDirPath);
    IfFailThrow(GetInternalSystemDirectory(m_wszDirPath, &cDir));

    DWORD cPath = (DWORD)(cDir + wcslen(LOGSUBDIRECTORY));
    if (cPath > sizeof(m_wszDirPath)/sizeof(*m_wszDirPath))
        ThrowHR(HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER));

    wcscpy(m_wszDirPath + cDir - 1, LOGSUBDIRECTORY);

    //
    // Read the zap set (for tests)
    //

    LPCWSTR pZapSet = REGUTIL::GetConfigString(L"ZapSet");
    if (pZapSet != NULL)
    {
        // Ignore a zap set with len > 3 (this is consistent with EE behavior)
        if (wcslen(pZapSet) <= 3)
        {
            if (cPath + wcslen(pZapSet) + 1 > sizeof(m_wszDirPath)/sizeof(*m_wszDirPath))
                ThrowHR(HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER));

            m_wszDirPath[cPath-1] = '-';
            wcscpy(m_wszDirPath + cPath, pZapSet);
            wcscat(m_wszDirPath + cPath, L"\\");
        }

        delete pZapSet;
    }

    //
    // Make sure the directory exists.  Create it if necessary.
    //

    DWORD attributes = WszGetFileAttributes(m_wszDirPath);
    if (attributes == -1)
    {
        if (!WszCreateDirectory(m_wszDirPath, NULL))
            ThrowHR(HRESULT_FROM_WIN32(GetLastError()));
    }
    else if ((attributes & FILE_ATTRIBUTE_DIRECTORY) == 0)
        ThrowHR(HRESULT_FROM_WIN32(ERROR_FILE_EXISTS));
}

NLogDirectory::Iterator NLogDirectory::IterateLogs(LPCWSTR pSimpleName)
{
    return Iterator(this, pSimpleName);
}

NLogDirectory::Iterator::Iterator(NLogDirectory *pDir, LPCWSTR pSimpleName)
{
    m_dir = pDir;

    DWORD cDir = (DWORD)wcslen(pDir->GetPath());

    m_path = new WCHAR [ cDir
                       + (pSimpleName == NULL ? 0 : wcslen(pSimpleName))
                       + 1 + 4 + 1 ];
    if (m_path == NULL)
        ThrowHR(E_OUTOFMEMORY);
    
    wcscpy(m_path, pDir->GetPath());

    m_pFile = m_path + cDir;

    if (pSimpleName != NULL)
        wcscpy(m_pFile, pSimpleName);

    wcscat(m_pFile, L"*.log");

    m_findHandle = INVALID_HANDLE_VALUE;
}

NLogDirectory::Iterator::~Iterator()
{
    if (m_findHandle != INVALID_HANDLE_VALUE)
        FindClose(m_findHandle);

    delete [] m_path;
}

BOOL NLogDirectory::Iterator::Next()
{
    if (m_findHandle == INVALID_HANDLE_VALUE)
    {
        m_findHandle = WszFindFirstFile(m_path, &m_data);

        return (m_findHandle != INVALID_HANDLE_VALUE);
    }
    else
    {
        return WszFindNextFile(m_findHandle, &m_data);
    }
}


NLog *NLogDirectory::Iterator::GetLog()
{
    _ASSERTE(m_findHandle != INVALID_HANDLE_VALUE);
    
    return new NLog(m_dir, m_data.cFileName);
}

/* ------------------------------------------------------------------------------------ *
 * NLog 
 * ------------------------------------------------------------------------------------ */

NLog::NLog(NLogDirectory *pDir, IApplicationContext *pContext)
{
    m_pContext = pContext;
    m_pContext->AddRef();
    
    //
    // Form name from app name + hash.
    //

    //
    // Get name object for first part of file name
    //

    IAssemblyName *pName;
    IfFailThrow(pContext->GetContextNameObject(&pName));

    //
    // Get size of name
    //

    DWORD cbName = 0;
    pName->GetProperty(ASM_NAME_NAME, NULL, &cbName);

    //
    // Allocate buffer for name
    //

    DWORD cPath = (DWORD)wcslen(pDir->GetPath());
    DWORD cFileName = cPath + cbName/sizeof(WCHAR) + 8 + 1 + 3;

    m_pPath = new WCHAR [cFileName];
    wcscpy(m_pPath, pDir->GetPath());

    IfFailThrow(pName->GetProperty(ASM_NAME_NAME, 
                                   m_pPath + cPath,
                                   &cbName));

    //
    // Make sure the name conforms to file system requirements.
    //

    DWORD cName = cbName/sizeof(WCHAR);
    if (cName >= _MAX_FNAME-8)
        cName = _MAX_FNAME-8;

    WCHAR *p = m_pPath + cPath;
    WCHAR *pEnd = p + cName;
    while (p < pEnd)
    {
        if (wcschr(L"<>:\"/\\|", *p) != NULL)
            *p = '_';
        p++;
    }

    //
    // Add the hash at the end
    //
  
    DWORD hash = HashApplicationContext(pContext);

    p = m_pPath + cPath + cName - 1;
    for (int i=0; i<8; i++)
    {
        BYTE b = (BYTE) (hash&0xf);

        if (b < 10)
            *p++ = b + '0';
        else
            *p++ = b - 10 + 'A';

        hash >>= 4;
    }

    wcscpy(m_pPath + cPath + cName - 1 + 8, L".log");

    //
    // The file may or may not exist at this point.  If it doesn't we need,
    // to write the header information (the app context)
    //

    m_pFile = new NLogFile(m_pPath);

    if (m_pFile->IsEOF())
        m_pFile->WriteApplicationContext(m_pContext);

    m_recordStartOffset = m_pFile->GetOffset();

    m_fDelete = FALSE;
}

NLog::NLog(NLogDirectory *pDir, LPCWSTR pFileName)
{
    DWORD cFileName = (DWORD)(wcslen(pDir->GetPath()) + wcslen(pFileName) + 1);

    m_pPath = new WCHAR [cFileName];
    wcscpy(m_pPath, pDir->GetPath());

    wcscat(m_pPath, pFileName);

    m_pFile = new NLogFile(m_pPath);

    m_pContext = m_pFile->ReadApplicationContext();

    m_recordStartOffset = m_pFile->GetOffset();

    m_fDelete = FALSE;
}


NLog::~NLog()
{
    delete m_pFile;

    if (m_fDelete)
        WszDeleteFile(m_pPath);

    m_pContext->Release();
    delete m_pPath;
}

DWORD NLog::HashAssemblyName(IAssemblyName *pName)
{
    CQuickBytes buffer;
    DWORD cDisplayName = (DWORD)(buffer.Size()/sizeof(WCHAR));

    HRESULT hr = pName->GetDisplayName((WCHAR*)buffer.Ptr(), &cDisplayName, 0);

    if (hr == HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER))
    {
        IfFailThrow(buffer.ReSize(cDisplayName*sizeof(WCHAR)));

        IfFailThrow(pName->GetDisplayName((WCHAR*)buffer.Ptr(), &cDisplayName, 0));
    }

    return HashString((WCHAR*)buffer.Ptr());
}

DWORD NLog::HashApplicationContext(IApplicationContext *pContext)
{
    DWORD result;

    IAssemblyName *pName;
    IfFailThrow(pContext->GetContextNameObject(&pName));
    result = HashAssemblyName(pName);
    pName->Release();

    CQuickBytes buffer;

    for (int i=0; i<(sizeof(applicationContextProperties)
                     /sizeof(*applicationContextProperties)); i++)
    {
        result = _rotl(result, 2);

        DWORD cbSize = 0;
        if (pContext->Get(applicationContextProperties[i], NULL, &cbSize, 0)
            == HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER))
        {
            buffer.ReSize(cbSize);
            LPWSTR pwName = (LPWSTR) buffer.Ptr();
            IfFailThrow(pContext->Get(applicationContextProperties[i], pwName, &cbSize, 0));

            result ^= HashString(pwName);
        }
    }

    return result;
}

void NLog::Delete()
{
    m_fDelete = TRUE;
}

void NLog::AppendRecord(NLogRecord *pRecord)
{
    _ASSERTE(!m_fDelete);

    m_pFile->SeekFromEnd(0);

    pRecord->Write(m_pFile);

#define MAX_LOG_SIZE 8192

    if (m_pFile->GetSize() > MAX_LOG_SIZE)
    {
        m_pFile->SeekTo(m_recordStartOffset);
        if (m_recordStartOffset == 0)
        {
            m_pFile->ReadApplicationContext()->Release();
            m_recordStartOffset = m_pFile->GetOffset();
        }

        NLogRecord *pFirstRecord = new NLogRecord(m_pFile);

        DWORD read;
        while (m_pFile->SkipToOne(&read, '<'))
        {
            NLogRecord *pNextRecord = new NLogRecord(m_pFile);
            pFirstRecord->Merge(pNextRecord);
            delete pNextRecord;
        }

        m_pFile->SeekTo(m_recordStartOffset);
        m_pFile->Truncate();
        m_pFile->StartNewLine();
        pFirstRecord->Write(m_pFile);

        delete pFirstRecord;
    } 
}

NLog::Iterator NLog::IterateRecords()
{
    m_pFile->SeekTo(m_recordStartOffset);

    return Iterator(m_pFile);
}

NLog::Iterator::Iterator(NLogFile *pFile) 
  : m_pFile(pFile),
    m_pNext(NULL)
{
}

BOOL NLog::Iterator::Next()
{
    DWORD read;
    if (!m_pFile->SkipToOne(&read, '<'))
        return FALSE;

    m_pNext = new NLogRecord(m_pFile);
    return TRUE;
}

/* ------------------------------------------------------------------------------------ *
 * NLogRecord
 * ------------------------------------------------------------------------------------ */

NLogRecord::NLogRecord() 
{
    GetSystemTime(&m_Timestamp);
    m_Weight = 1;
}

NLogRecord::NLogRecord(NLogFile *pFile)
{
    Read(pFile);
    GetSystemTime(&m_Timestamp);
}

NLogRecord::~NLogRecord()
{
    Iterator i = IterateAssemblies();
    while (i.Next())
    {
        NLogAssembly *pAssembly = i.GetAssembly();
        delete pAssembly;
    }
}

class NLogAssemblyHash : public CClosedHash<NLogAssembly *>
{
  public:
    NLogAssemblyHash(int buckets) 
      : CClosedHash<NLogAssembly*>(buckets) {}

    void Add(NLogAssembly *pAssembly)
    {
        NLogAssembly **pElement = CClosedHash<NLogAssembly*>::Add(pAssembly);
        *(SIZE_T*) pElement = ((SIZE_T)pAssembly) | USED;
    }

    NLogAssembly *Find(NLogAssembly *pAssembly)
    {
        NLogAssembly **pElement = CClosedHash<NLogAssembly*>::Find(pAssembly);

        if (pElement == NULL)
            return NULL;
        else
            return (NLogAssembly *) GetKey((BYTE*)pElement);
    }
  private:
    unsigned long Hash(const void *pData)
      { return ((NLogAssembly *)pData)->Hash(); }
    unsigned long Compare(const void *pData, BYTE *pElement)
      { return ((NLogAssembly *)pData)->Compare((NLogAssembly*) GetKey(pElement)); }
    ELEMENTSTATUS Status(BYTE *pElement)
      { return (ELEMENTSTATUS) ((*(SIZE_T*)pElement)&3); }
    void SetStatus(BYTE *pElement, ELEMENTSTATUS eStatus)
      {  *(SIZE_T*)pElement &= ~3; *(SIZE_T*)pElement |= eStatus; }  
    void *GetKey(BYTE *pElement) 
      { return (void *) ((*(SIZE_T*)pElement)&~3); }
};

BOOL NLogRecord::Merge(NLogRecord *pRecord)
{
    //
    // Merge assemblies
    //

    NLogAssemblyHash table(m_Assemblies.GetCount()*2);

    Iterator i = IterateAssemblies();
    while (i.Next())
    {
        table.Add(i.GetAssembly());
    }

    i = pRecord->IterateAssemblies();
    while (i.Next())
    {
        NLogAssembly *pAssembly = table.Find(i.GetAssembly());
        if (pAssembly == NULL)
            AppendAssembly(new NLogAssembly(i.GetAssembly()));
        else
            i.GetAssembly()->Merge(pAssembly);
    }

    //
    // Use most recent timestamp
    //

    if (pRecord->m_Timestamp.wYear > m_Timestamp.wYear
        || (pRecord->m_Timestamp.wYear == m_Timestamp.wYear
            && (pRecord->m_Timestamp.wMonth > m_Timestamp.wMonth
                || (pRecord->m_Timestamp.wMonth == m_Timestamp.wMonth
                    && (pRecord->m_Timestamp.wDay > m_Timestamp.wDay
                        || (pRecord->m_Timestamp.wDay == m_Timestamp.wDay
                            && (pRecord->m_Timestamp.wHour > m_Timestamp.wHour
                                || (pRecord->m_Timestamp.wHour == m_Timestamp.wHour
                                    && (pRecord->m_Timestamp.wMinute > m_Timestamp.wMinute
                                        || (pRecord->m_Timestamp.wMinute == m_Timestamp.wMinute
                                            && pRecord->m_Timestamp.wSecond > m_Timestamp.wSecond))))))))))
    {
        m_Timestamp = pRecord->m_Timestamp;
    }

    //
    // Merge Weights
    //

    m_Weight += pRecord->m_Weight;

    return TRUE;
}

void NLogRecord::Write(NLogFile *pFile)
{
    pFile->WriteStartTag("Record");

    pFile->StartNewLine();

    pFile->WriteTimestamp(&m_Timestamp);

    pFile->StartNewLine();

    pFile->WriteStartTag("Weight");
    pFile->WriteNumber(m_Weight);
    pFile->WriteEndTag("Weight");

    Iterator i = IterateAssemblies();
    while (i.Next())
    {
        pFile->StartNewLine();
        i.GetAssembly()->Write(pFile);
    }

    pFile->StartNewLine();
    pFile->WriteEndTag("Record");
    pFile->StartNewLine();
}

void NLogRecord::Read(NLogFile *pFile)
{
    pFile->ReadStartTag("Record");

    pFile->ReadTimestamp(&m_Timestamp);
    
    pFile->ReadStartTag("Weight");
    m_Weight = pFile->ReadNumber();
    pFile->ReadEndTag("Weight");

    _ASSERTE(m_Assemblies.GetCount() == 0);

    while (!pFile->CheckEndTag("Record"))
        AppendAssembly(new NLogAssembly(pFile));
}

/* ------------------------------------------------------------------------------------ *
 * NLogAssembly
 * ------------------------------------------------------------------------------------ */

NLogAssembly::NLogAssembly(IAssemblyName *pAssemblyName, 
                           CorZapSharing sharing, 
                           CorZapDebugging debugging,
                           CorZapProfiling profiling,
                           GUID *pMVID)
  : m_pAssemblyName(pAssemblyName),
    m_pDisplayName(NULL),
    m_sharing(sharing),
    m_debugging(debugging),
    m_profiling(profiling),
    m_cBindings(0),
    m_pBindings(NULL),
    m_mvid(*pMVID)
{
    m_pAssemblyName->AddRef();
}

NLogAssembly::NLogAssembly(NLogFile *pFile)
  : m_pAssemblyName(NULL),
    m_pDisplayName(NULL),
    m_cBindings(0),
    m_pBindings(NULL)
{
    Read(pFile);
}

NLogAssembly::NLogAssembly(NLogAssembly *pAssembly)
  : m_pAssemblyName(pAssembly->m_pAssemblyName),
    m_pDisplayName(NULL),
    m_sharing(pAssembly->m_sharing),
    m_debugging(pAssembly->m_debugging),
    m_profiling(pAssembly->m_profiling),
    m_cBindings(0),
    m_pBindings(NULL),
    m_mvid(pAssembly->m_mvid)
{
    m_pAssemblyName->AddRef();

    Iterator i = pAssembly->IterateModules();
    while (i.Next())
        AppendModule(new NLogModule(i.GetModule()));
}

NLogAssembly::~NLogAssembly()
{
    if (m_pAssemblyName != NULL)
        m_pAssemblyName->Release();

    if (m_pDisplayName != NULL)
        delete [] m_pDisplayName;

    if (m_cBindings > 0)
    {
        ICorZapBinding **p = m_pBindings;
        ICorZapBinding **pEnd = p + m_cBindings;
        while (p < pEnd)
            (*p++)->Release();

        delete [] m_pBindings;
    }

    Iterator i = IterateModules();
    while (i.Next())
    {
        NLogModule *pModule = i.GetModule();
        delete pModule;
    }
}

class ZapConfiguration : public ICorZapConfiguration
{
  private:
    LONG            m_refCount;
    CorZapSharing   m_sharing;
    CorZapDebugging m_debugging;
    CorZapProfiling m_profiling;

  public:
    ZapConfiguration(CorZapSharing sharing, 
                     CorZapDebugging debugging,
                     CorZapProfiling profiling)
      : m_refCount(1),
        m_sharing(sharing),
        m_debugging(debugging),
        m_profiling(profiling)
    {
    }
  
    ULONG STDMETHODCALLTYPE AddRef() 
    {
        return (InterlockedIncrement((long *) &m_refCount));
    }

    ULONG STDMETHODCALLTYPE Release() 
    {
        long refCount = InterlockedDecrement(&m_refCount);
        if (refCount == 0)
            delete this;

        return refCount;
    }

    HRESULT STDMETHODCALLTYPE QueryInterface(REFIID riid, void **ppInterface)
    {
        if (riid == IID_IUnknown)
            *ppInterface = (IUnknown *) this;
        else if (riid == IID_ICorZapConfiguration)
            *ppInterface = (ICorZapConfiguration *) this;
        else
            return (E_NOINTERFACE);

        this->AddRef();
        return S_OK;
    }

    HRESULT STDMETHODCALLTYPE GetSharing(CorZapSharing *pResult)
    {
        *pResult = m_sharing;
        return S_OK;
    }

    HRESULT STDMETHODCALLTYPE GetDebugging(CorZapDebugging *pResult)
    {
        *pResult = m_debugging;
        return S_OK;
    }

    HRESULT STDMETHODCALLTYPE GetProfiling(CorZapProfiling *pResult)
    {
        *pResult = m_profiling;
        return S_OK;
    }
};

ICorZapConfiguration *NLogAssembly::GetConfiguration()
{
    return new ZapConfiguration(m_sharing, m_debugging, m_profiling);
}

class NLogModuleHash : public CClosedHash<NLogModule *>
{
  public:
    NLogModuleHash(int buckets) 
      : CClosedHash<NLogModule*>(buckets) {}

    void Add(NLogModule *pModule)
    {
        NLogModule **pElement = CClosedHash<NLogModule*>::Add(pModule);
        *(SIZE_T*) pElement = ((SIZE_T)pModule) | USED;
    }

    NLogModule *Find(NLogModule *pModule)
    {
        NLogModule **pElement = CClosedHash<NLogModule*>::Find(pModule);

        if (pElement == NULL)
            return NULL;
        else
            return (NLogModule *) GetKey((BYTE *) pElement);
    }

  private:
    unsigned long Hash(const void *pData)
      { return ((NLogModule *)pData)->Hash(); }
    unsigned long Compare(const void *pData, BYTE *pElement)
      { return ((NLogModule *)pData)->Compare((NLogModule*) GetKey(pElement)); }
    ELEMENTSTATUS Status(BYTE *pElement)
      { return (ELEMENTSTATUS) ((*(SIZE_T*)pElement)&3); }
    void SetStatus(BYTE *pElement, ELEMENTSTATUS eStatus)
      {  *(SIZE_T*)pElement &= ~3; *(SIZE_T*)pElement |= eStatus; }  
    void *GetKey(BYTE *pElement) 
      { return (void *) ((*(SIZE_T*)pElement)&~3); }
};

BOOL NLogAssembly::Merge(NLogAssembly *pAssembly)
{
    // @todo: Either application context must be the same, or
    // bindings lists must be compatible.

    if (Compare(pAssembly) != 0)
        return FALSE;

    NLogModuleHash table(m_Modules.GetCount()*2);

    Iterator i = IterateModules();
    while (i.Next())
        table.Add(i.GetModule());

    i = pAssembly->IterateModules();
    while (i.Next())
    {
        NLogModule *pModule = table.Find(i.GetModule());
        if (pModule == NULL)
            AppendModule(new NLogModule(i.GetModule()));
        else
            i.GetModule()->Merge(pModule);
    }

    return TRUE;
} 

void NLogAssembly::Write(NLogFile *pFile)
{
    // There is currently no reason to record one of these puppies:
    _ASSERTE(m_cBindings == 0);

    pFile->WriteStartTag("Assembly");

    pFile->StartNewLine();

    pFile->WriteAssemblyName(m_pAssemblyName);
    pFile->StartNewLine();

    pFile->WriteSharing(m_sharing);
    pFile->WriteDebugging(m_debugging);
    pFile->WriteProfiling(m_profiling);

    LPOLESTR pwMVID;
    IfFailThrow(StringFromIID(m_mvid, &pwMVID));
    MAKE_UTF8PTR_FROMWIDE(pMVID, pwMVID);
    pFile->WriteTag("MVID", pMVID);
    CoTaskMemFree(pwMVID);

    Iterator i = IterateModules();
    while (i.Next())
    {
        pFile->StartNewLine();
        i.GetModule()->Write(pFile);
    }

    pFile->StartNewLine();
    pFile->WriteEndTag("Assembly");
}

void NLogAssembly::Read(NLogFile *pFile)
{
    pFile->ReadStartTag("Assembly");

    m_pAssemblyName = pFile->ReadAssemblyName();

    m_sharing = pFile->ReadSharing();
    m_debugging = pFile->ReadDebugging();
    m_profiling = pFile->ReadProfiling();

    LPSTR pMVID = pFile->ReadTag("MVID");
    MAKE_WIDEPTR_FROMUTF8(pwMVID, pMVID);
    IfFailThrow(IIDFromString(pwMVID, &m_mvid));
    delete [] pMVID;

    _ASSERTE(m_Modules.GetCount() == 0);
    while (!pFile->CheckEndTag("Assembly"))
        AppendModule(new NLogModule(pFile));
}

BOOL NLogAssembly::HasStrongName()
{
    DWORD cbSize = 0;

    m_pAssemblyName->GetProperty(ASM_NAME_PUBLIC_KEY_TOKEN, NULL, &cbSize);

    return cbSize > 0;
}

NLogAssembly *NLogAssembly::Bind(IApplicationContext *pContext)
{
    // !!! 

    // Bind assembly in context

    // Read manifest

    // Bind dependencies in context

    // (repeat to compute closure)

    // Bindings should be stored in some sort of hash

    return NULL;
}

unsigned long NLogAssembly::Hash()
{
    unsigned long result = HashString(GetDisplayName());

    result = _rotl(result, 1);
    result += m_sharing;

    result = _rotl(result, 2);
    result += m_debugging;

    result = _rotl(result, 1);
    result += m_profiling;

    return result;
}

unsigned long NLogAssembly::Compare(NLogAssembly *pAssembly)
{
    unsigned long  result = wcscmp(GetDisplayName(), pAssembly->GetDisplayName());
    if (result != 0)
        return result;

    result = m_sharing - pAssembly->m_sharing;
    if (result != 0)
        return result;

    result = m_debugging - pAssembly->m_debugging;
    if (result != 0)
        return result;

    result = m_profiling - pAssembly->m_profiling;
    if (result != 0)
        return result;

    return IsEqualGUID(m_mvid, pAssembly->m_mvid) == 0;
}

LPCWSTR NLogAssembly::GetDisplayName()
{
    if (m_pDisplayName == NULL)
    {
        DWORD cDisplayName = 0;
        m_pAssemblyName->GetDisplayName(NULL, &cDisplayName, 0);

        m_pDisplayName = new WCHAR [cDisplayName];
        if (m_pDisplayName == NULL)
            ThrowHR(E_OUTOFMEMORY);
        
        IfFailThrow(m_pAssemblyName->GetDisplayName(m_pDisplayName, &cDisplayName, 0));
    }
    
    return m_pDisplayName;
}

/* ------------------------------------------------------------------------------------ *
 * NLogModule
 * ------------------------------------------------------------------------------------ */

NLogModule::NLogModule(LPCSTR pModuleName)
{
    m_pName = new CHAR [strlen(pModuleName) + 1];
    strcpy(m_pName, pModuleName);
}

NLogModule::NLogModule(NLogFile *pFile)
{
    Read(pFile);
}

NLogModule::NLogModule(NLogModule *pModule)
  : m_compiledMethods(&pModule->m_compiledMethods),
    m_loadedClasses(&pModule->m_loadedClasses)
{
    m_pName = new CHAR [strlen(pModule->m_pName) + 1];
    strcpy(m_pName, pModule->m_pName);
}

NLogModule::~NLogModule()
{
    delete [] m_pName;
}

BOOL NLogModule::Merge(NLogModule *pModule)
{
    if (strcmp(pModule->m_pName, m_pName) != 0)
        return FALSE;

    m_compiledMethods.Merge(&pModule->m_compiledMethods);
    m_loadedClasses.Merge(&pModule->m_loadedClasses);

    return TRUE;
}

void NLogModule::Write(NLogFile *pFile)
{
    pFile->WriteStartTag("Module");
    pFile->StartNewLine();

    if (m_pName[0] != 0)
    {
        pFile->WriteTag("Name", m_pName);
        pFile->StartNewLine();
    }

    pFile->WriteStartTag("CompiledMethods");
    pFile->StartNewLine();
    m_compiledMethods.Write(pFile);
    pFile->StartNewLine();
    pFile->WriteEndTag("CompiledMethods");
    pFile->StartNewLine();

    pFile->WriteStartTag("LoadedClasses");
    pFile->StartNewLine();
    m_loadedClasses.Write(pFile);
    pFile->StartNewLine();
    pFile->WriteEndTag("LoadedClasses");
    pFile->StartNewLine();

    pFile->WriteEndTag("Module");
}

void NLogModule::Read(NLogFile *pFile)
{
    pFile->ReadStartTag("Module");

    m_pName = pFile->CheckTag("Name");
    if (m_pName == NULL)
    {
        m_pName = new CHAR[1];
        *m_pName = 0;
    }

    if (pFile->CheckStartTag("CompiledMethods"))
    {
        m_compiledMethods.Read(pFile);
        pFile->ReadEndTag("CompiledMethods");
    }

    if (pFile->CheckStartTag("LoadedClasses"))
    {
        m_loadedClasses.Read(pFile);
        pFile->ReadEndTag("LoadedClasses");
    }

    pFile->ReadEndTag("Module");
}

unsigned long NLogModule::Hash()
{
    return HashStringA(GetModuleName());
}

unsigned long NLogModule::Compare(NLogModule *pModule)
{
    LPCSTR pName = pModule->GetModuleName();
    return strcmp(pName, m_pName);
}

/* ------------------------------------------------------------------------------------ *
 * NLogIndexList
 * ------------------------------------------------------------------------------------ */

NLogIndexList::NLogIndexList(NLogIndexList *pIndexList) 
{
    Iterator i = pIndexList->IterateIndices();
    while (i.Next())
        m_list.Append((void*)i.GetIndex());

    m_max = pIndexList->m_max;
}

BOOL NLogIndexList::Merge(NLogIndexList *pIndexList)
{
    //
    // Keep an array of used indices
    //

    CQuickBytes buffer;
    buffer.ReSize((DWORD)(m_max+1));

    BYTE *dups = (BYTE *) buffer.Ptr();
    ZeroMemory(dups, m_max+1);

    Iterator i = IterateIndices();
    while (i.Next())
        dups[i.GetIndex()] = TRUE;

    //
    // Append indices that aren't alread in the list
    //
    // @todo: it might be a good idea to move indices
    // which are in both lists up to the front.
    //

    SIZE_T newMax = m_max;

    i = pIndexList->IterateIndices();
    while (i.Next())
    {
        SIZE_T index = i.GetIndex();
        if (index > m_max || !dups[index])
        {
            m_list.Append((void*)index);
            if (index > newMax)
                newMax = index;
        }                 
    }

    m_max = newMax;

    return TRUE;
}

void NLogIndexList::Write(NLogFile *pFile)
{
    pFile->WriteStartTag("IndexList");

    Iterator i = IterateIndices();
    while (i.Next())
    {
        pFile->WriteOne(' ');
        pFile->WriteHexNumber((DWORD)i.GetIndex());
    }

    pFile->WriteEndTag("IndexList");
}

void NLogIndexList::Read(NLogFile *pFile)
{
    _ASSERTE(m_list.GetCount() == 0);

    pFile->ReadStartTag("IndexList");

    while (pFile->MatchOne(' '))
        AppendIndex(pFile->ReadHexNumber());

    pFile->ReadEndTag("IndexList");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\zap\zapper.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#include <WinWrap.h>
#include <windows.h>
#include <stdlib.h>
#include <objbase.h>
#include <stddef.h>
#include <float.h>
#include <limits.h>

#include "utilcode.h"
#include "corjit.h"
#include "corcompile.h"
#include "iceefilegen.h"
#include "fusionbind.h"
#include "corpriv.h"

#include "zapper.h"
#include "Holder.h"
#include "StrongName.h"
#include "nlog.h"
#include "hrex.h"
#include "safegetfilesize.h"
#include "fusionsink.h"
#include "ngen.h"

/* --------------------------------------------------------------------------- *
 * Error Macros
 * --------------------------------------------------------------------------- */
#ifdef _DEBUG
#define BAD_FORMAT_ASSERT(str) { if (REGUTIL::GetConfigDWORD(L"AssertOnBadImageFormat", 1)) { _ASSERTE(str); } }
#else
#define BAD_FORMAT_ASSERT(str) 0
#endif

/* --------------------------------------------------------------------------- *
 * Destructor wrapper objects
 * --------------------------------------------------------------------------- */

template <class TYPE>
class Cleaner
{
  private:
    void (TYPE::*m_cleanup)(void);
    TYPE *m_ptr;
  public:
    Cleaner<TYPE>(void (TYPE::*cleanup)(void)) : m_ptr(NULL), m_cleanup(cleanup) {}
    Cleaner<TYPE>(TYPE *ptr, void (TYPE::*cleanup)(void)) : m_ptr(ptr), m_cleanup(cleanup) {}
    ~Cleaner<TYPE>() 
    { 
        (m_ptr->*m_cleanup)(); 
    }
};

/* --------------------------------------------------------------------------- *
 * Private fusion entry points
 * --------------------------------------------------------------------------- */

STDAPI InstallCustomAssembly(LPCOLESTR szPath, LPBYTE pbCustom, 
                                       DWORD cbCustom, IAssembly **ppAsmOut);
STDAPI InstallCustomModule(IAssemblyName *pName, LPCOLESTR szPath);

/* --------------------------------------------------------------------------- *
 * Public entry points for ngen
 * --------------------------------------------------------------------------- */

// For side by side issues, it's best to use the exported API calls to generate a
// Zapper Object instead of creating one on your own.

STDAPI NGenCreateZapper(HANDLE* hZapper, NGenOptions* opt)
{
    if (hZapper == NULL)
        return E_POINTER;


    Zapper* zap = new Zapper(opt);

    if (zap == NULL)
        return E_OUTOFMEMORY;

    *hZapper = (HANDLE)zap;
    return S_OK;
}// NGenCreateZapper

STDAPI NGenFreeZapper(HANDLE hZapper)
{
    if (hZapper == NULL || hZapper == INVALID_HANDLE_VALUE)
        return E_HANDLE;

    Zapper *zapper = (Zapper*)hZapper;
    delete zapper;
    return S_OK;
}// NGenFreeZapper

STDAPI NGenTryEnumerateFusionCache(HANDLE hZapper, LPCWSTR assemblyName, bool fPrint, bool fDelete)
{
    if (hZapper == NULL || hZapper == INVALID_HANDLE_VALUE)
        return E_HANDLE;

    Zapper *zapper = (Zapper*)hZapper;
    return zapper->TryEnumerateFusionCache(assemblyName, fPrint, fDelete);
}// NGenTryEnumerateFusionCache

STDAPI NGenCompile(HANDLE hZapper, LPCWSTR path)
{
    if (hZapper == NULL || hZapper == INVALID_HANDLE_VALUE)
        return E_HANDLE;

    Zapper *zapper = (Zapper*)hZapper;
    return zapper->Compile(path);
}// NGenCompile

/* --------------------------------------------------------------------------- *
 * Options class
 * --------------------------------------------------------------------------- */

ZapperOptions::ZapperOptions() : 
  m_preload(true),
  m_jit(true),
  m_recurse(false),
  m_update(false),
  m_shared(false),
  m_autodebug(false),
  m_restricted(false),
  m_onlyMethods(0),
  m_excludeMethods(0),
  m_verbose(false),
  m_silent(true),
  m_ignoreErrors(true),
  m_JITcode(false),
  m_assumeInit(false),
  m_stats(false),
  m_attribStats(false),
  m_compilerFlags(CORJIT_FLG_RELOC | CORJIT_FLG_PREJIT),
  m_logLevel(0)
{
    m_stats = false;

    m_set = REGUTIL::GetConfigString(L"ZapSet");
    if (m_set != NULL && wcslen(m_set) > 3)
    {
        delete m_set;
        m_set = NULL;
    }

    if (REGUTIL::GetConfigDWORD(L"LogEnable",0))
    {
        m_logLevel = REGUTIL::GetConfigDWORD(L"LogLevel", 0);
    }
}

ZapperOptions::~ZapperOptions()
{
    delete m_onlyMethods;
    delete m_excludeMethods;

    if (m_set != NULL)
        delete m_set;
}

/* --------------------------------------------------------------------------- *
 * Statistics class
 * --------------------------------------------------------------------------- */

ZapperStats::ZapperStats() 
{
    memset(this, 0, sizeof(*this));
}

void ZapperStats::PrintStats(FILE *stream) 
{
    if (m_outputFileSize > 0) {

        fprintf(stream, "-------------------------------------------------------\n");
        fprintf(stream, "Input file size:            %8d\n", m_inputFileSize);
        fprintf(stream, "Output file size:           %8d\t%8.2fx\n", m_outputFileSize,(double)m_outputFileSize/m_inputFileSize);
        fprintf(stream, "\n");
        fprintf(stream, "Metadata:                   %8d\t%8.2f%%\n", m_metadataSize, (double)m_metadataSize/m_outputFileSize*100);
        fprintf(stream, "Debugging maps:             %8d\t%8.2f%%\n", m_debuggingTableSize, (double)m_debuggingTableSize/m_outputFileSize*100);
        fprintf(stream, "Code manager:               %8d\t%8.2f%%\n", m_codeMgrSize, (double)m_codeMgrSize/m_outputFileSize*100);
        fprintf(stream, "GC info:                    %8d\t%8.2f%%\n", m_headerSectionSize, (double)m_headerSectionSize/m_outputFileSize*100);
        fprintf(stream, "Native code & r/o data:     %8d\t%8.2f%%\n", m_codeSectionSize, (double)m_codeSectionSize/m_outputFileSize*100);
        fprintf(stream, "Exception tables:           %8d\t%8.2f%%\n", m_exceptionSectionSize, (double)m_exceptionSectionSize/m_outputFileSize*100);
        fprintf(stream, "Writable user data:         %8d\t%8.2f%%\n", m_writableDataSectionSize, (double)m_writableDataSectionSize/m_outputFileSize*100);
        fprintf(stream, "Base relocs:                %8d\t%8.2f%%\n", m_relocSectionSize, (double)m_relocSectionSize/m_outputFileSize*100);

        fprintf(stream, "Preload image:              %8d\t%8.2f%%\n", m_preloadImageSize, (double)m_preloadImageSize/m_outputFileSize*100);
        fprintf(stream, "       Module:                     %8d\t%8.2f%%\n",
                m_preloadImageModuleSize, (double)m_preloadImageModuleSize/m_preloadImageSize*100);
        fprintf(stream, "       Method Tables:              %8d\t%8.2f%%\n",
                m_preloadImageMethodTableSize, (double)m_preloadImageMethodTableSize/m_preloadImageSize*100);
        fprintf(stream, "       Classes:                    %8d\t%8.2f%%\n",
                m_preloadImageClassSize, (double)m_preloadImageClassSize/m_preloadImageSize*100);
        fprintf(stream, "       Method Descs:               %8d\t%8.2f%%\n",
                m_preloadImageMethodDescSize, (double)m_preloadImageMethodDescSize/m_preloadImageSize*100);
        fprintf(stream, "       Field Descs:                %8d\t%8.2f%%\n",
                m_preloadImageFieldDescSize, (double)m_preloadImageFieldDescSize/m_preloadImageSize*100);
        fprintf(stream, "       Debugging info:             %8d\t%8.2f%%\n",
                m_preloadImageDebugSize, (double)m_preloadImageDebugSize/m_preloadImageSize*100);
        fprintf(stream, "       Fixups:                     %8d\t%8.2f%%\n",
                m_preloadImageFixupsSize, (double)m_preloadImageFixupsSize/m_preloadImageSize*100);
        fprintf(stream, "       Other:                      %8d\t%8.2f%%\n",
                m_preloadImageOtherSize, (double)m_preloadImageOtherSize/m_preloadImageSize*100);

        unsigned totalIndirections = 
          m_dynamicInfoDelayListSize +
          m_eeInfoTableSize +
          m_helperTableSize +
          m_dynamicInfoTableSize +
          m_importTableSize +
          m_importBlobsSize;

        for (int i=0; i<CORCOMPILE_TABLE_COUNT; i++)
            totalIndirections += m_dynamicInfoSize[i];
    
        fprintf(stream, "Indirections:               %8d\t%8.2f%%\n",
                totalIndirections, (double)totalIndirections/m_outputFileSize*100);

        fprintf(stream, "       Delay load lists:           %8d\t%8.2f%%\n",
                m_dynamicInfoDelayListSize, (double)m_dynamicInfoDelayListSize/totalIndirections*100);
        fprintf(stream, "       Tables:                     %8d\t%8.2f%%\n",
                m_dynamicInfoTableSize, (double)m_dynamicInfoTableSize/totalIndirections*100);
        fprintf(stream, "       EE Values:                  %8d\t%8.2f%%\n",
                m_eeInfoTableSize, (double)m_eeInfoTableSize/totalIndirections*100);
        fprintf(stream, "       Helper functions:           %8d\t%8.2f%%\n",
                m_helperTableSize, (double)m_helperTableSize/totalIndirections*100);
        fprintf(stream, "       EE Handles:                 %8d\t%8.2f%%\n",
                m_dynamicInfoSize[CORCOMPILE_HANDLE_TABLE], 
                (double)m_dynamicInfoSize[CORCOMPILE_HANDLE_TABLE]/totalIndirections*100);
        fprintf(stream, "       Varargs:                    %8d\t%8.2f%%\n",
                m_dynamicInfoSize[CORCOMPILE_VARARGS_TABLE], 
                (double)m_dynamicInfoSize[CORCOMPILE_VARARGS_TABLE]/totalIndirections*100);
        fprintf(stream, "       Entry points:               %8d\t%8.2f%%\n",
                m_dynamicInfoSize[CORCOMPILE_ENTRY_POINT_TABLE], 
                (double)m_dynamicInfoSize[CORCOMPILE_ENTRY_POINT_TABLE]/totalIndirections*100);
        fprintf(stream, "       Function pointers:          %8d\t%8.2f%%\n",
                m_dynamicInfoSize[CORCOMPILE_FUNCTION_POINTER_TABLE], 
                (double)m_dynamicInfoSize[CORCOMPILE_FUNCTION_POINTER_TABLE]/totalIndirections*100);
        fprintf(stream, "       Sync locks:                 %8d\t%8.2f%%\n",
                m_dynamicInfoSize[CORCOMPILE_SYNC_LOCK_TABLE], 
                (double)m_dynamicInfoSize[CORCOMPILE_SYNC_LOCK_TABLE]/totalIndirections*100);
        fprintf(stream, "       PInvoke targets:            %8d\t%8.2f%%\n",
                m_dynamicInfoSize[CORCOMPILE_PINVOKE_TARGET_TABLE], 
                (double)m_dynamicInfoSize[CORCOMPILE_PINVOKE_TARGET_TABLE]/totalIndirections*100);
        fprintf(stream, "       Indirect PInvoke targets:   %8d\t%8.2f%%\n",
                m_dynamicInfoSize[CORCOMPILE_INDIRECT_PINVOKE_TARGET_TABLE], 
                (double)m_dynamicInfoSize[CORCOMPILE_INDIRECT_PINVOKE_TARGET_TABLE]/totalIndirections*100);
        fprintf(stream, "       Profiling handles:          %8d\t%8.2f%%\n",
                m_dynamicInfoSize[CORCOMPILE_PROFILING_HANDLE_TABLE], 
                (double)m_dynamicInfoSize[CORCOMPILE_PROFILING_HANDLE_TABLE]/totalIndirections*100);
        fprintf(stream, "       Static field addresses:     %8d\t%8.2f%%\n",
                m_dynamicInfoSize[CORCOMPILE_STATIC_FIELD_ADDRESS_TABLE], 
                (double)m_dynamicInfoSize[CORCOMPILE_STATIC_FIELD_ADDRESS_TABLE]/totalIndirections*100);
        fprintf(stream, "       Interface table offsets:    %8d\t%8.2f%%\n",
                m_dynamicInfoSize[CORCOMPILE_INTERFACE_TABLE_OFFSET_TABLE], 
                (double)m_dynamicInfoSize[CORCOMPILE_INTERFACE_TABLE_OFFSET_TABLE]/totalIndirections*100);
        fprintf(stream, "       .cctor triggers:            %8d\t%8.2f%%\n",
                m_dynamicInfoSize[CORCOMPILE_CLASS_CONSTRUCTOR_TABLE], 
                (double)m_dynamicInfoSize[CORCOMPILE_CLASS_CONSTRUCTOR_TABLE]/totalIndirections*100);
        fprintf(stream, "       load triggers:            %8d\t%8.2f%%\n",
                m_dynamicInfoSize[CORCOMPILE_CLASS_LOAD_TABLE], 
                (double)m_dynamicInfoSize[CORCOMPILE_CLASS_LOAD_TABLE]/totalIndirections*100);
        fprintf(stream, "       Domain ID triggers:         %8d\t%8.2f%%\n",
                m_dynamicInfoSize[CORCOMPILE_CLASS_DOMAIN_ID_TABLE], 
                (double)m_dynamicInfoSize[CORCOMPILE_CLASS_DOMAIN_ID_TABLE]/totalIndirections*100);
        fprintf(stream, "       Import table:               %8d\t%8.2f%%\n",
                m_importTableSize, (double)m_importTableSize/totalIndirections*100);
        fprintf(stream, "       Import blobs:               %8d\t%8.2f%%\n",
                m_importBlobsSize, (double)m_importBlobsSize/totalIndirections*100);
    }

    fprintf(stream, "-------------------------------------------------------\n");
    fprintf(stream, "Total Methods:          %8d\n", m_methods);
    fprintf(stream, "Total IL Code:          %8d\n", m_ilCodeSize);
    fprintf(stream, "Total NativeCode:       %8d\n", m_nativeCodeSize);

    fprintf(stream, "Total Native RW Data:   %8d\n", m_nativeRWDataSize);
    fprintf(stream, "Total Native RO Data:   %8d\n", m_nativeRODataSize);
    fprintf(stream, "Total Native GC Info:   %8d\n", m_gcInfoSize);
    size_t nativeTotal = m_nativeCodeSize + m_nativeRWDataSize + m_nativeRODataSize + m_gcInfoSize;
    fprintf(stream, "Total Native Total :    %8d\n", nativeTotal);

    if (m_methods > 0) {
        fprintf(stream, "\n");
        fprintf(stream, "Average IL Code:        %8.2f\n", double(m_ilCodeSize) / m_methods);
        fprintf(stream, "Average NativeCode:         %8.2f\n", double(m_nativeCodeSize) / m_methods);
        fprintf(stream, "Average Native RW Data:     %8.2f\n", double(m_nativeRWDataSize) / m_methods);
        fprintf(stream, "Average Native RO Data:     %8.2f\n", double(m_nativeRODataSize) / m_methods);
        fprintf(stream, "Average Native GC Info:     %8.2f\n", double(m_gcInfoSize) / m_methods);
        fprintf(stream, "Average Native:             %8.2f\n", double(nativeTotal) / m_methods);   
        fprintf(stream, "\n");
        fprintf(stream, "NativeGC / Native:      %8.2f\n", double(m_gcInfoSize) / nativeTotal);
        fprintf(stream, "Native / IL:            %8.2f\n", double(nativeTotal) / m_ilCodeSize);
    }
}

/* --------------------------------------------------------------------------- *
 * Attribution Statistics class
 * --------------------------------------------------------------------------- */

ZapperAttributionStats::ZapperAttributionStats(IMetaDataImport *pImport)
  : m_image(pImport),
    m_metadata(pImport),
    m_il(pImport),
    m_native(pImport),
    m_pImport(pImport)
{
    pImport->AddRef();
}

ZapperAttributionStats::~ZapperAttributionStats()
{
    m_pImport->Release();
}

void ZapperAttributionStats::PrintStats(FILE *stream)
{
    fprintf(stream, "===============================================================================\n");
    fprintf(stream, "%-40s%8s%8s%8s%8s\n", 
            "Name", "Image ", "Metadata", "IL", "Native");
    fprintf(stream, "===============================================================================\n");

    ULONG imageTotal = 0, metadataTotal = 0, ilTotal = 0, nativeTotal = 0;

    CQuickWSTR wszName;
    wszName.Maximize();

    ULONG imageModule = 0;
    ULONG metadataModule = 0;
    ULONG ilModule = 0;
    ULONG nativeModule = 0;

    DWORD count;
    HCORENUM hTypeEnum = NULL;
    while (TRUE)
    {
        mdTypeDef   td;

        IfFailThrow(m_pImport->EnumTypeDefs(&hTypeEnum, &td, 1, &count));
        if (count == 0)
            break;

        IfFailThrow(m_pImport->GetTypeDefProps(td, wszName.Ptr(), wszName.Size(), NULL,
                                               NULL, NULL));

        ULONG imageClass = m_image.m_pTypeSizes[RidFromToken(td)];
        ULONG metadataClass = m_metadata.m_pTypeSizes[RidFromToken(td)];
        ULONG ilClass = m_il.m_pTypeSizes[RidFromToken(td)];
        ULONG nativeClass = m_native.m_pTypeSizes[RidFromToken(td)];

        fprintf(stream, "%-40S%8d%8d%8d%8d\n", wszName.Ptr(),
                imageClass, metadataClass, ilClass, nativeClass);

        HCORENUM hMethodEnum = NULL;
        while (TRUE)
        {
            mdMethodDef md;

            IfFailThrow(m_pImport->EnumMethods(&hMethodEnum, td, &md, 1, &count));
            if (count == 0)
                break;

            IfFailThrow(m_pImport->GetMethodProps(md, NULL, wszName.Ptr(), wszName.Size(), NULL, 
                                                  NULL, NULL, NULL, NULL, NULL));

            ULONG imageMethod = m_image.m_pMethodSizes[RidFromToken(md)];
            ULONG metadataMethod = m_metadata.m_pMethodSizes[RidFromToken(md)];
            ULONG ilMethod = m_il.m_pMethodSizes[RidFromToken(md)];
            ULONG nativeMethod = m_native.m_pMethodSizes[RidFromToken(md)];

            fprintf(stream, "    %-36S%8d%8d%8d%8d\n", wszName.Ptr(),
                    imageMethod, metadataMethod, ilMethod, nativeMethod);

            imageClass += imageMethod;
            metadataClass += metadataMethod;
            ilClass += ilMethod;
            nativeClass += nativeMethod;
        }
        m_pImport->CloseEnum(hMethodEnum);

        HCORENUM hFieldEnum = NULL;
        while (TRUE)
        {
            mdFieldDef fd;

            IfFailThrow(m_pImport->EnumFields(&hFieldEnum, td, &fd, 1, &count));
            if (count == 0)
                break;

            IfFailThrow(m_pImport->GetFieldProps(fd, NULL, wszName.Ptr(), wszName.Size(), NULL, 
                                                  NULL, NULL, NULL, NULL, NULL, NULL));

            ULONG imageField = m_image.m_pFieldSizes[RidFromToken(fd)];
            ULONG metadataField = m_metadata.m_pFieldSizes[RidFromToken(fd)];
            ULONG ilField = m_il.m_pFieldSizes[RidFromToken(fd)];
            ULONG nativeField = m_native.m_pFieldSizes[RidFromToken(fd)];

            fprintf(stream, "    %-36S%8d%8d%8d%8d\n", wszName.Ptr(),
                    imageField, metadataField, ilField, nativeField);

            imageClass += imageField;
            metadataClass += metadataField;
            ilClass += ilField;
            nativeClass += nativeField;

        }
        m_pImport->CloseEnum(hFieldEnum);

        IfFailThrow(m_pImport->GetTypeDefProps(td, wszName.Ptr(), wszName.Size(), NULL,
                                               NULL, NULL));

        fprintf(stream, "-------------------------------------------------------------------------------\n");
        fprintf(stream, "%-40S%8d%8d%8d%8d\n", wszName.Ptr(),
                imageClass, metadataClass, ilClass, nativeClass);
        
        fprintf(stream, "-------------------------------------------------------------------------------\n");

        imageModule += imageClass;
        metadataModule += metadataClass;
        ilModule += ilClass;
        nativeModule += nativeClass;
    }
    m_pImport->CloseEnum(hTypeEnum);

    //
    // Now report global methods.
    //

    ULONG imageClass = m_image.m_pTypeSizes[1];
    ULONG metadataClass = m_metadata.m_pTypeSizes[1];
    ULONG ilClass = m_il.m_pTypeSizes[1];
    ULONG nativeClass = m_native.m_pTypeSizes[1];

    fprintf(stream, "%-40S%8d%8d%8d%8d\n", L"<global>",
            imageClass, metadataClass, ilClass, nativeClass);

    HCORENUM hMethodEnum = NULL;
    while (TRUE)
    {
        mdMethodDef md;

        IfFailThrow(m_pImport->EnumMethods(&hMethodEnum, mdTypeDefNil, 
                                             &md, 1, &count));
        if (count == 0)
            break;

        IfFailThrow(m_pImport->GetMethodProps(md, NULL, wszName.Ptr(), wszName.Size(), NULL, 
                                              NULL, NULL, NULL, NULL, NULL));

        ULONG imageMethod = m_image.m_pMethodSizes[RidFromToken(md)];
        ULONG metadataMethod = m_metadata.m_pMethodSizes[RidFromToken(md)];
        ULONG ilMethod = m_il.m_pMethodSizes[RidFromToken(md)];
        ULONG nativeMethod = m_native.m_pMethodSizes[RidFromToken(md)];

        fprintf(stream, "    %-36S%8d%8d%8d%8d\n", wszName.Ptr(),
                imageMethod, metadataMethod, ilMethod, nativeMethod);

        imageClass += imageMethod;
        metadataClass += metadataMethod;
        ilClass += ilMethod;
        nativeClass += nativeMethod;
    }
    m_pImport->CloseEnum(hMethodEnum);
    
    HCORENUM hFieldEnum = NULL;
    while (TRUE)
    {
        mdFieldDef fd;

        IfFailThrow(m_pImport->EnumFields(&hFieldEnum, mdTypeDefNil, &fd, 1, &count));
        if (count == 0)
            break;

        IfFailThrow(m_pImport->GetFieldProps(fd, NULL, wszName.Ptr(), wszName.Size(), NULL, 
                                             NULL, NULL, NULL, NULL, NULL, NULL));

        ULONG imageField = m_image.m_pFieldSizes[RidFromToken(fd)];
        ULONG metadataField = m_metadata.m_pFieldSizes[RidFromToken(fd)];
        ULONG ilField = m_il.m_pFieldSizes[RidFromToken(fd)];
        ULONG nativeField = m_native.m_pFieldSizes[RidFromToken(fd)];

        fprintf(stream, "    %-36S%8d%8d%8d%8d\n", wszName.Ptr(),
                imageField, metadataField, ilField, nativeField);

        imageClass += imageField;
        metadataClass += metadataField;
        ilClass += ilField;
        nativeClass += nativeField;

    }
    m_pImport->CloseEnum(hFieldEnum);

    fprintf(stream, "-------------------------------------------------------------------------------\n");

    fprintf(stream, "Total %-34S%8d%8d%8d%8d\n", L"<global>",
            imageClass, metadataClass, ilClass, nativeClass);
        
    imageModule += imageClass;
    metadataModule += metadataClass;
    ilModule += ilClass;
    nativeModule += nativeClass;

    fprintf(stream, "===============================================================================\n");

    
    fprintf(stream, "%-40S%8d%8d%8d%8d\n", L"Unattributed",
            m_image.m_total - imageModule,
            m_metadata.m_total, 
            m_il.m_total, 
            m_native.m_total);
        
    fprintf(stream, "===============================================================================\n");

    fprintf(stream, "%-40S%8d%8d%8d%8d\n", L"Total",
            m_image.m_total,
            metadataModule,
            ilModule,
            nativeModule);
        
        
    fprintf(stream, "===============================================================================\n");
}

/* --------------------------------------------------------------------------- *
 * Zapper class
 * --------------------------------------------------------------------------- */

Zapper::Zapper(NGenOptions *pOptions)
{
    ZapperOptions *zo = new ZapperOptions();
    // If the memory allocation did fail, what should we do?
    if (zo != NULL)
    {
        // We can version NGenOptions by looking at the dwSize variable
        // We don't need to check it for the first version, since we're
        // guaranteed to have all these fields here

        zo->m_compilerFlags = CORJIT_FLG_RELOC | CORJIT_FLG_PREJIT;
        zo->m_autodebug = true;

        if (pOptions->fDebug)
        {
            zo->m_compilerFlags |= CORJIT_FLG_DEBUG_INFO|CORJIT_FLG_DEBUG_OPT;
            zo->m_autodebug = false;
        }
        if (pOptions->fDebugOpt)
        {
            zo->m_compilerFlags &= ~CORJIT_FLG_DEBUG_OPT;
            zo->m_compilerFlags |= CORJIT_FLG_DEBUG_INFO;
            zo->m_autodebug = false;

        }

        if (pOptions->fProf)
            zo->m_compilerFlags |= CORJIT_FLG_PROF_ENTERLEAVE;


        zo->m_silent = pOptions->fSilent;
        zo->m_preload = true;
        zo->m_jit = true;
        zo->m_recurse = false;
        zo->m_update = true;
        zo->m_shared = false;
        zo->m_verbose = false;
        zo->m_restricted = true;

    }

    m_exeName[0] = 0;

    if (pOptions->lpszExecutableFileName != NULL)
    {
        wcsncpy(m_exeName, pOptions->lpszExecutableFileName, NumItems(m_exeName));
        m_exeName[NumItems(m_exeName)-1] = 0;
    }
    Init(zo, true, false);
}

Zapper::Zapper(ZapperOptions *pOptions)
{
    Init(pOptions);
}

void Zapper::Init(ZapperOptions *pOptions, bool fFreeZapperOptions, bool fInitExeName)
{
    m_refCount = 1;
    m_pEECompileInfo = NULL;
    m_pJitCompiler = NULL;
    m_pCeeFileGen = NULL;
    m_pMetaDataDispenser = NULL;
    m_hJitLib = NULL;

    m_pOpt = pOptions;

    m_pStatus = NULL;

    m_pDomain = NULL;
    m_hAssembly = NULL;
    m_pAssemblyImport = NULL;
    m_fStrongName = FALSE;

    m_pAssemblyEmit = NULL;
    m_fFreeZapperOptions = fFreeZapperOptions;

    if (fInitExeName)
        *m_exeName = 0;

    HRESULT hr;

    //
    // Get metadata dispenser interface
    //

    IfFailThrow(MetaDataGetDispenser(CLSID_CorMetaDataDispenser, 
                                     IID_IMetaDataDispenserEx, (void **)&m_pMetaDataDispenser));

    //
    // Make sure we don't duplicate assembly refs and file refs
    //

    VARIANT opt;
    hr = m_pMetaDataDispenser->GetOption(MetaDataCheckDuplicatesFor, &opt);
    _ASSERTE(SUCCEEDED(hr));

    _ASSERTE(V_VT(&opt) == VT_UI4);
    V_UI4(&opt) |= MDDupAssemblyRef | MDDupFile;

    hr = m_pMetaDataDispenser->SetOption(MetaDataCheckDuplicatesFor, &opt);
    _ASSERTE(SUCCEEDED(hr));
}

void Zapper::InitEE()
{
    if (m_pEECompileInfo == NULL)
    {
        //
        // Initialize COM & the EE
        //

        CoInitializeEx(NULL, COINIT_MULTITHREADED);

        // 
        // Init unicode wrappers
        // 

        OnUnicodeSystem();

        //
        // Get EE compiler interface
        //

        m_pEECompileInfo = GetCompileInfo();
    
        IfFailThrow(m_pEECompileInfo->Startup());

#ifdef _DEBUG    
        if (m_pOpt->m_JITcode)
            m_pEECompileInfo->DisableSecurity();
#endif

        //
        // Get JIT interface
        // !!! This code lifted from codeman.cpp
        //

        m_hJitLib = WszLoadLibrary(L"MSCORJIT.DLL");
        if (!m_hJitLib)
            ThrowLastError();

        typedef ICorJitCompiler* (__stdcall* pGetJitFn)();

        pGetJitFn getJitFn = (pGetJitFn) GetProcAddress(m_hJitLib, "getJit");

        if (getJitFn != NULL)
            m_pJitCompiler = (*getJitFn)();

        if (m_pJitCompiler == NULL)
        {
            Error(L"Can't load jit.\n");
            ThrowLastError();
        }

        //
        // Get CeeGen file writer
        //

        IfFailThrow(CreateICeeFileGen(&m_pCeeFileGen));
    }
}

Zapper::~Zapper()
{
    CleanupAssembly();

    if (m_pMetaDataDispenser != NULL)
        m_pMetaDataDispenser->Release();

    if (m_fFreeZapperOptions)
    {
        if (m_pOpt != NULL)
            delete m_pOpt;
        m_pOpt = NULL;
    }


    if (m_pEECompileInfo != NULL)
    {
        if (m_pCeeFileGen != NULL)
            DestroyICeeFileGen(&m_pCeeFileGen);

        m_pEECompileInfo->Shutdown();

        if (m_hJitLib != NULL)
            FreeLibrary(m_hJitLib);

        CoUninitialize();
    }
}

void Zapper::CleanupAssembly()
{
    if (m_pAssemblyEmit != NULL)
    {
        m_pAssemblyEmit->Release();
        m_pAssemblyEmit = NULL;
    }

    if (m_pAssemblyImport != NULL)
    {
        m_pAssemblyImport->Release();
        m_pAssemblyImport = NULL;
    }
}

HRESULT Zapper::TryEnumerateFusionCache(LPCWSTR name, bool fPrint, bool fDelete)
{
    HRESULT hr = S_OK;

    __try
      {
          if (EnumerateFusionCache(name, fPrint, fDelete) == 0)
              hr = S_FALSE;
      }
    __except (FilterException(GetExceptionInformation()))
      {
          hr = GetExceptionHR();
      }

    return hr;
}

int Zapper::EnumerateFusionCache(LPCWSTR name, bool fPrint, bool fDelete)
{
    int count = 0;

    ComWrap<IAssemblyName> pName;

    //
    // Decide whether the name is a file or assemb