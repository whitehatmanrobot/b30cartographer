ade using the calling thread's current security context, which
        may be that of a client if impersonating, or using the caller's
        process-level security context.  A value of FALSE indicates the
        caller's current context should be used un-modified.  A value of
        TRUE indicates the request should be fulfilled using the process
        level security context.

        This parameter is necessary to allow a server process to open
        a client's token when the client specified IDENTIFICATION level
        impersonation.  In this case, the caller would not be able to
        open the client's token using the client's context (because you
        can't create executive level objects using IDENTIFICATION level
        impersonation).

    TokenHandle - Receives the handle of the newly opened token.

Return Value:

    Returns TRUE for success, FALSE for failure.  Extended error status
    is available using GetLastError.

--*/
{
    NTSTATUS Status;

    Status = NtOpenThreadToken (
        ThreadHandle,
        DesiredAccess,
        (BOOLEAN)OpenAsSelf,
        TokenHandle
        );

    if ( !NT_SUCCESS(Status) ) {
        BaseSetLastNTError(Status);
        return FALSE;
    }

    return TRUE;
}

BOOL
APIENTRY
GetTokenInformation (
    HANDLE TokenHandle,
    TOKEN_INFORMATION_CLASS TokenInformationClass,
    PVOID TokenInformation,
    DWORD TokenInformationLength,
    PDWORD ReturnLength
    )
/*++


Routine Description:

    Retrieve information about a specified token.

Arguments:

    TokenHandle - Provides a handle to the token to operate on.

    TokenInformationClass - The token information class about which
        to retrieve information.

    TokenInformation - The buffer to receive the requested class of
        information.  The buffer must be aligned on at least a
        longword boundary.  The actual structures returned are
        dependent upon the information class requested, as defined in
        the TokenInformationClass parameter description.

        TokenInformation Format By Information Class:

           TokenUser => TOKEN_USER data structure.  TOKEN_QUERY
           access is needed to retrieve this information about a
           token.

           TokenGroups => TOKEN_GROUPS data structure.  TOKEN_QUERY
           access is needed to retrieve this information about a
           token.

           TokenPrivileges => TOKEN_PRIVILEGES data structure.
           TOKEN_QUERY access is needed to retrieve this information
           about a token.

           TokenOwner => TOKEN_OWNER data structure.  TOKEN_QUERY
           access is needed to retrieve this information about a
           token.

           TokenPrimaryGroup => TOKEN_PRIMARY_GROUP data structure.
           TOKEN_QUERY access is needed to retrieve this information
           about a token.

           TokenDefaultDacl => TOKEN_DEFAULT_DACL data structure.
           TOKEN_QUERY access is needed to retrieve this information
           about a token.

           TokenSource => TOKEN_SOURCE data structure.
           TOKEN_QUERY_SOURCE access is needed to retrieve this
           information about a token.

           TokenType => TOKEN_TYPE data structure.
           TOKEN_QUERY access is needed to retrieve this information
           about a token.

           TokenStatistics => TOKEN_STATISTICS data structure.
           TOKEN_QUERY access is needed to retrieve this
           information about a token.

           TokenSessionId => ULONG.  TOKEN_QUERY access is needed to 
           query the Session ID of the token.
            
    TokenInformationLength - Indicates the length, in bytes, of the
        TokenInformation buffer.

    ReturnLength - This parameter receives the actual length of the
        requested information.  If this value is larger than that
        provided by the TokenInformationLength parameter, then the
        buffer provided to receive the requested information is not
        large enough to hold that data and no data is returned.

        If the queried class is TokenDefaultDacl and there is no
        default Dacl established for the token, then the return
        length will be returned as zero, and no data will be returned.

Return Value:

    Returns TRUE for success, FALSE for failure.  Extended error status
    is available using GetLastError.

--*/
{
    NTSTATUS Status;

    Status = NtQueryInformationToken (
        TokenHandle,
        TokenInformationClass,
        TokenInformation,
        TokenInformationLength,
        ReturnLength
        );

    if ( !NT_SUCCESS(Status) ) {
        BaseSetLastNTError(Status);
        return FALSE;
    }

    return TRUE;
}




BOOL
APIENTRY
SetTokenInformation (
    HANDLE TokenHandle,
    TOKEN_INFORMATION_CLASS TokenInformationClass,
    PVOID TokenInformation,
    DWORD TokenInformationLength
    )
/*++


Routine Description:

    Modify information in a specified token.

Arguments:

    TokenHandle - Provides a handle to the token to operate on.

    TokenInformationClass - The token information class being set.

    TokenInformation - The buffer containing the new values for the
        specified class of information.  The buffer must be aligned
        on at least a longword boundary.  The actual structures
        provided are dependent upon the information class specified,
        as defined in the TokenInformationClass parameter
        description.

        TokenInformation Format By Information Class:

           TokenUser => This value is not a valid value for this API.
           The User ID may not be replaced.

           TokenGroups => This value is not a valid value for this
           API.  The Group IDs may not be replaced.  However, groups
           may be enabled and disabled using NtAdjustGroupsToken().

           TokenPrivileges => This value is not a valid value for
           this API.  Privilege information may not be replaced.
           However, privileges may be explicitly enabled and disabled
           using the NtAdjustPrivilegesToken API.

           TokenOwner => TOKEN_OWNER data structure.
           TOKEN_ADJUST_DEFAULT access is needed to replace this
           information in a token.  The owner values that may be
           specified are restricted to the user and group IDs with an
           attribute indicating they may be assigned as the owner of
           objects.

           TokenPrimaryGroup => TOKEN_PRIMARY_GROUP data structure.
           TOKEN_ADJUST_DEFAULT access is needed to replace this
           information in a token.  The primary group values that may
           be specified are restricted to be one of the group IDs
           already in the token.

           TokenDefaultDacl => TOKEN_DEFAULT_DACL data structure.
           TOKEN_ADJUST_DEFAULT access is needed to replace this
           information in a token.  The ACL provided as a new default
           discretionary ACL is not validated for structural
           correctness or consistency.

           TokenSource => This value is not a valid value for this
           API.  The source name and context handle  may not be
           replaced.

           TokenStatistics => This value is not a valid value for this
           API.  The statistics of a token are read-only.

           TokenSessionId => ULONG to set the token session.  Must have
           TOKEN_ADJUST_SESSIONID and TCB privilege.

           TokenSessionReference => ULONG.  Must be zero.  Must have 
           TCB privilege to dereference the logon session.  This info class
           will remove a reference for the logon session, and mark the token
           as not referencing the session.
              
    TokenInformationLength - Indicates the length, in bytes, of the
        TokenInformation buffer.  This is only the length of the primary
        buffer.  All extensions of the primary buffer are self describing.

Return Value:

    Returns TRUE for success, FALSE for failure.  Extended error status
    is available using GetLastError.

--*/
{
    NTSTATUS Status;

    Status = NtSetInformationToken (
        TokenHandle,
        TokenInformationClass,
        TokenInformation,
        TokenInformationLength
        );

    if ( !NT_SUCCESS(Status) ) {
        BaseSetLastNTError(Status);
        return FALSE;
    }

    return TRUE;
}



BOOL
APIENTRY
AdjustTokenPrivileges (
    HANDLE TokenHandle,
    BOOL DisableAllPrivileges,
    PTOKEN_PRIVILEGES NewState,
    DWORD BufferLength,
    PTOKEN_PRIVILEGES PreviousState,
    PDWORD ReturnLength
    )
/*++


Routine Description:

    This routine is used to disable or enable privileges in the
    specified token.  The absence of some of the privileges listed to
    be changed won't effect the successful modification of the
    privileges that are in the token.  The previous enabled/disabled
    state of changed privileges may optionally be capture (for
    resetting later).

    TOKEN_ADJUST_PRIVILEGES access is required to enable or disable
    privileges in a token.


Arguments:

    TokenHandle - Provides a handle to the token to operate on.

    DisableAllPrivileges - This boolean parameter may be
        used to disable all privileges assigned to the token.  If
        this parameter is specified as TRUE, then the NewState parameter is
        ignored.

    NewState - This (optional) parameter points to a TOKEN_PRIVILEGES
        data structure containing the privileges whose states are to
        be adjusted (disabled or enabled).  Only the Enabled flag of
        the attributes associated with each privilege is used.  It
        provides the new value that is to be assigned to the privilege
        in the token.

    BufferLength - This optional parameter indicates the length (in
        bytes) of the PreviousState buffer.  This value must be
        provided if the PreviousState parameter is provided.

    PreviousState - This (optional) parameter points to a buffer to
        receive the state of any privileges actually changed by this
        request.  This information is formated as a TOKEN_PRIVILEGES
        data structure which may be passed as the NewState parameter
        in a subsequent call to this routine to restore the original
        state of those privilges.  TOKEN_QUERY access is needed to use
        this parameter.

        If this buffer does not contain enough space to receive the
        complete list of modified privileges, then no privilege
        states are changed and STATUS_BUFFER_TOO_SMALL is returned.
        In this case, the ReturnLength OUT parameter will
        contain the actual number of bytes needed to hold the
        information.

    ReturnLength - Indicates the actual number of bytes needed to
        contain the previous privilege state information.  This
        parameter is ignored if the PreviousState argument is not
        passed.

Return Value:

    Returns TRUE for success, FALSE for failure.  Extended error status
    is available using GetLastError.

--*/
{
    NTSTATUS Status;

    Status = NtAdjustPrivilegesToken (
        TokenHandle,
        (BOOLEAN)DisableAllPrivileges,
        NewState,
        BufferLength,
        PreviousState,
        ReturnLength
        );

    //
    // We need to set last error even for success because that
    // is the only way to tell if the api successfully assigned
    // all privileges.  That is, STATUS_NOT_ALL_ASSIGNED is a
    // Success severity level.
    //

    BaseSetLastNTError(Status);


    if ( !NT_SUCCESS(Status) ) {
        return FALSE;
    }

    return TRUE;
}




BOOL
APIENTRY
AdjustTokenGroups (
    HANDLE TokenHandle,
    BOOL ResetToDefault,
    PTOKEN_GROUPS NewState,
    DWORD BufferLength,
    PTOKEN_GROUPS PreviousState,
    PDWORD ReturnLength
    )
/*++


Routine Description:

    This routine is used to disable or enable groups in the specified
    token.  The absence of some of the groups listed to be changed
    won't effect the successful modification of the groups that are in
    the token.  The previous enabled/disabled state of changed groups
    may optionally be capture (for resetting later).

    TOKEN_ADJUST_GROUPS access is required to enable or disable groups
    in a token

    Note that mandatory groups can not be disabled.  An attempt
    disable any mandatory groups will cause the call to fail, leaving
    the state of all groups unchanged.


Arguments:

    TokenHandle - Provides a handle to the token to operate on.

    ResetToDefault - The parameter indicates whether all the groups
        in the token are to be reset to their default enabled/disabled
        state.

    NewState - This parameter points to a TOKEN_GROUPS data structure
        containing the groups whose states are to be adjusted
        (disabled or enabled).  Only the Enabled flag of the
        attributes associated with each group is used.  It provides
        the new value that is to be assigned to the group in the
        token.  If the ResetToDefault argument is specified as TRUE,
        then this argument is ignored.  Otherwise, it must be passed.

    BufferLength - This optional parameter indicates the length (in
        bytes) of the PreviousState buffer.  This value must be
        provided if the PreviousState parameter is provided.

    PreviousState - This (optional) parameter points to a buffer to
        receive the state of any groups actually changed by this
        request.  This information is formated as a TOKEN_GROUPS data
        structure which may be passed as the NewState parameter in a
        subsequent call to NtAdjustGroups to restore the original state
        of those groups.  TOKEN_QUERY access is needed to use this
        parameter.

        If this buffer does not contain enough space to receive the
        complete list of modified groups, then no group states are
        changed and STATUS_BUFFER_TOO_SMALL is returned.  In this
        case, the ReturnLength return parameter will contain the
        actual number of bytes needed to hold the information.

    ReturnLength - Indicates the actual number of bytes needed to
        contain the previous group state information.
        This parameter is ignored if the PreviousState argument is not
        passed.


Return Value:

    Returns TRUE for success, FALSE for failure.  Extended error status
    is available using GetLastError.

--*/
{
    NTSTATUS Status;

    Status = NtAdjustGroupsToken (
        TokenHandle,
        (BOOLEAN)ResetToDefault,
        NewState,
        BufferLength,
        PreviousState,
        ReturnLength
        );

    //
    // We need to set last error even for success because that
    // is the only way to tell if the api successfully assigned
    // all groups.  That is, STATUS_NOT_ALL_ASSIGNED is a
    // Success severity level.
    //

    BaseSetLastNTError(Status);


    if ( !NT_SUCCESS(Status) ) {
        return FALSE;
    }

    return TRUE;

}





BOOL
APIENTRY
PrivilegeCheck (
    HANDLE ClientToken,
    PPRIVILEGE_SET RequiredPrivileges,
    LPBOOL pfResult
    )
/*++

Routine Description:

    This routine tests the caller's client's security context to see if it
    contains the specified privileges.

Arguments:

    ClientToken - A handle to a token object representing a client
        attempting access.  This handle must be obtained from a
        communication session layer, such as from an LPC Port or Local
        Named Pipe, to prevent possible security policy violations.

    RequiredPrivileges - Points to a set of privileges.  The client's
        security context is to be checked to see which of the specified
        privileges are present.  The results will be indicated in the
        attributes associated with each privilege.  Note that
        flags in this parameter indicate whether all the privileges listed
        are needed, or any of the privileges.

    pfResult - Receives a boolean flag indicating whether the client
        has all the specified privileges or not.  A value of TRUE
        indicates the client has all the specified privileges.
        Otherwise a value of FALSE is returned.


Return Value:

    Returns TRUE for success, FALSE for failure.  Extended error status
    is available using GetLastError.

--*/
{
    NTSTATUS Status;
    BOOLEAN Result = FALSE;

    Status = NtPrivilegeCheck (
                ClientToken,
                RequiredPrivileges,
                &Result
                );

    *pfResult = Result;

    if ( !NT_SUCCESS(Status) ) {
        BaseSetLastNTError(Status);
        return FALSE;
    }

    return TRUE;
}



BOOL
APIENTRY
AccessCheckAndAuditAlarmW(
    LPCWSTR SubsystemName,
    PVOID HandleId,
    LPWSTR ObjectTypeName,
    LPWSTR ObjectName,
    PSECURITY_DESCRIPTOR SecurityDescriptor,
    DWORD DesiredAccess,
    PGENERIC_MAPPING GenericMapping,
    BOOL ObjectCreation,
    LPDWORD GrantedAccess,
    LPBOOL AccessStatus,
    LPBOOL pfGenerateOnClose
    )
/*++

Routine Description:

    This routine compares the input Security Descriptor against the
    caller's impersonation token and indicates if access is granted or
    denied.  If access is granted then the desired access mask becomes
    the granted access mask for the object.  The semantics of the
    access check routine is described in the DSA Security Architecture
    workbook.

    This routine will also generate any necessary audit messages as a
    result of the access attempt.

Arguments:

    SubsystemName - Supplies a name string identifying the subsystem
        calling the routine.

    HandleId - A unique value that will be used to represent the client's
        handle to the object.  This value is ignored (and may be re-used)
        if the access is denied.

    ObjectTypeName - Supplies the name of the type of the object being
        created or accessed.

    ObjectName - Supplies the name of the object being created or accessed.

    SecurityDescriptor - A pointer to the Security Descriptor against which
        acccess is to be checked.

    DesiredAccess - The desired acccess mask.  This mask must have been
        previously mapped to contain no generic accesses.

    GenericMapping - Supplies a pointer to the generic mapping associated
        with this object type.

    ObjectCreation - A boolean flag indicated whether the access will
        result in a new object being created if granted.  A value of TRUE
        indicates an object will be created, FALSE indicates an existing
        object will be opened.

    GrantedAccess - Receives a masking indicating which accesses have been
        granted (only valid on success).

    AccessStatus - Receives an indication of the success or failure of the
        access check.  If access is granted, STATUS_SUCCESS is returned.
        If access is denied, a value appropriate for return to the client
        is returned.  This will be STATUS_ACCESS_DENIED or, when mandatory
        access controls are implemented, STATUS_OBJECT_NOT_FOUND.

    pfGenerateOnClose - Points to a boolean that is set by the audity
        generation routine and must be passed to ObjectCloseAuditAlarm
        when the object handle is closed.


Return Value:

    Returns TRUE for success, FALSE for failure.  Extended error status
    is available using GetLastError.

--*/
{
    NTSTATUS Status;
    NTSTATUS RealAccessStatus;
    BOOLEAN GenerateOnClose = FALSE;
    UNICODE_STRING Subsystem;
    UNICODE_STRING ObjectType;
    UNICODE_STRING Object;


    RtlInitUnicodeString(
        &Subsystem,
        SubsystemName
        );

    RtlInitUnicodeString(
        &ObjectType,
        ObjectTypeName
        );

    RtlInitUnicodeString(
        &Object,
        ObjectName
        );

    Status = NtAccessCheckAndAuditAlarm (
                &Subsystem,
                HandleId,
                &ObjectType,
                &Object,
                SecurityDescriptor,
                DesiredAccess,
                GenericMapping,
                (BOOLEAN)ObjectCreation,
                GrantedAccess,
                &RealAccessStatus,
                &GenerateOnClose
                );


    *pfGenerateOnClose = (BOOL)GenerateOnClose;

    if ( !NT_SUCCESS(Status) ) {
        BaseSetLastNTError(Status);
        return FALSE;
    }

    if ( !NT_SUCCESS( RealAccessStatus )) {
        *AccessStatus = FALSE;
        BaseSetLastNTError( RealAccessStatus );
        return( TRUE );
    }

    *AccessStatus = TRUE;
    return TRUE;
}

BOOL
APIENTRY
AccessCheckByTypeAndAuditAlarmW (
    LPCWSTR SubsystemName,
    LPVOID HandleId,
    LPCWSTR ObjectTypeName,
    LPCWSTR ObjectName,
    PSECURITY_DESCRIPTOR SecurityDescriptor,
    PSID PrincipalSelfSid,
    DWORD DesiredAccess,
    AUDIT_EVENT_TYPE AuditType,
    DWORD Flags,
    POBJECT_TYPE_LIST ObjectTypeList,
    DWORD ObjectTypeListLength,
    PGENERIC_MAPPING GenericMapping,
    BOOL ObjectCreation,
    LPDWORD GrantedAccess,
    LPBOOL AccessStatus,
    LPBOOL pfGenerateOnClose
    )
/*++

Routine Description:

    This routine compares the input Security Descriptor against the
    caller's impersonation token and indicates if access is granted or
    denied.  If access is granted then the desired access mask becomes
    the granted access mask for the object.  The semantics of the
    access check routine is described in the DSA Security Architecture
    workbook.

    This routine will also generate any necessary audit messages as a
    result of the access attempt.

Arguments:

    SubsystemName - Supplies a name string identifying the subsystem
        calling the routine.

    HandleId - A unique value that will be used to represent the client's
        handle to the object.  This value is ignored (and may be re-used)
        if the access is denied.

    ObjectTypeName - Supplies the name of the type of the object being
        created or accessed.

    ObjectName - Supplies the name of the object being created or accessed.

    SecurityDescriptor - A pointer to the Security Descriptor against which
        acccess is to be checked.

    PrincipalSelfSid - If the object being access checked is an object which
        represents a principal (e.g., a user object), this parameter should
        be the SID of the object.  Any ACE containing the constant
        PRINCIPAL_SELF_SID is replaced by this SID.

        The parameter should be NULL if the object does not represent a principal.

    DesiredAccess - The desired acccess mask.  This mask must have been
        previously mapped to contain no generic accesses.

    AuditType - Specifies the type of audit to be generated.  Valid values
        are: AuditEventObjectAccess and AuditEventDirectoryServiceAccess.

    Flags - Flags modifying the execution of the API:

        AUDIT_ALLOW_NO_PRIVILEGE - If the caller does not have AuditPrivilege,
            the call will silently continue to check access and will
            generate no audit.

    ObjectTypeList - Supplies a list of GUIDs representing the object (and
        sub-objects) being accessed.  If no list is present, AccessCheckByType
        behaves identically to AccessCheck.

    ObjectTypeListLength - Specifies the number of elements in the ObjectTypeList.

    GenericMapping - Supplies a pointer to the generic mapping associated
        with this object type.

    ObjectCreation - A boolean flag indicated whether the access will
        result in a new object being created if granted.  A value of TRUE
        indicates an object will be created, FALSE indicates an existing
        object will be opened.

    GrantedAccess - Receives a masking indicating which accesses have been
        granted (only valid on success).

    AccessStatus - Receives an indication of the success or failure of the
        access check.  If access is granted, STATUS_SUCCESS is returned.
        If access is denied, a value appropriate for return to the client
        is returned.  This will be STATUS_ACCESS_DENIED or, when mandatory
        access controls are implemented, STATUS_OBJECT_NOT_FOUND.

    pfGenerateOnClose - Points to a boolean that is set by the audity
        generation routine and must be passed to ObjectCloseAuditAlarm
        when the object handle is closed.


Return Value:

    Returns TRUE for success, FALSE for failure.  Extended error status
    is available using GetLastError.

--*/
{
    NTSTATUS Status;
    NTSTATUS RealAccessStatus;
    BOOLEAN GenerateOnClose = FALSE;
    UNICODE_STRING Subsystem;
    UNICODE_STRING ObjectType;
    UNICODE_STRING Object;

    RtlInitUnicodeString(
        &Subsystem,
        SubsystemName
        );

    RtlInitUnicodeString(
        &ObjectType,
        ObjectTypeName
        );

    RtlInitUnicodeString(
        &Object,
        ObjectName
        );

    Status = NtAccessCheckByTypeAndAuditAlarm (
                &Subsystem,
                HandleId,
                &ObjectType,
                &Object,
                SecurityDescriptor,
                PrincipalSelfSid,
                DesiredAccess,
                AuditType,
                Flags,
                ObjectTypeList,
                ObjectTypeListLength,
                GenericMapping,
                (BOOLEAN)ObjectCreation,
                GrantedAccess,
                &RealAccessStatus,
                &GenerateOnClose
                );


    *pfGenerateOnClose = (BOOL)GenerateOnClose;

    if ( !NT_SUCCESS(Status) ) {
        BaseSetLastNTError(Status);
        return FALSE;
    }

    if ( !NT_SUCCESS( RealAccessStatus )) {
        *AccessStatus = FALSE;
        BaseSetLastNTError( RealAccessStatus );
        return( TRUE );
    }

    *AccessStatus = TRUE;
    return TRUE;
}


BOOL
APIENTRY
AccessCheckByTypeResultListAndAuditAlarmW (
    LPCWSTR SubsystemName,
    LPVOID HandleId,
    LPCWSTR ObjectTypeName,
    LPCWSTR ObjectName,
    PSECURITY_DESCRIPTOR SecurityDescriptor,
    PSID PrincipalSelfSid,
    DWORD DesiredAccess,
    AUDIT_EVENT_TYPE AuditType,
    DWORD Flags,
    POBJECT_TYPE_LIST ObjectTypeList,
    DWORD ObjectTypeListLength,
    PGENERIC_MAPPING GenericMapping,
    BOOL ObjectCreation,
    LPDWORD GrantedAccessList,
    LPDWORD AccessStatusList,
    LPBOOL pfGenerateOnClose
    )
/*++

Routine Description:

    This routine compares the input Security Descriptor against the
    caller's impersonation token and indicates if access is granted or
    denied.  If access is granted then the desired access mask becomes
    the granted access mask for the object.  The semantics of the
    access check routine is described in the DSA Security Architecture
    workbook.

    This routine will also generate any necessary audit messages as a
    result of the access attempt.

Arguments:

    SubsystemName - Supplies a name string identifying the subsystem
        calling the routine.

    HandleId - A unique value that will be used to represent the client's
        handle to the object.  This value is ignored (and may be re-used)
        if the access is denied.

    ObjectTypeName - Supplies the name of the type of the object being
        created or accessed.

    ObjectName - Supplies the name of the object being created or accessed.

    SecurityDescriptor - A pointer to the Security Descriptor against which
        acccess is to be checked.

    PrincipalSelfSid - If the object being access checked is an object which
        represents a principal (e.g., a user object), this parameter should
        be the SID of the object.  Any ACE containing the constant
        PRINCIPAL_SELF_SID is replaced by this SID.

        The parameter should be NULL if the object does not represent a principal.

    DesiredAccess - The desired acccess mask.  This mask must have been
        previously mapped to contain no generic accesses.

    AuditType - Specifies the type of audit to be generated.  Valid values
        are: AuditEventObjectAccess and AuditEventDirectoryServiceAccess.

    Flags - Flags modifying the execution of the API:

        AUDIT_ALLOW_NO_PRIVILEGE - If the called does not have AuditPrivilege,
            the call will silently continue to check access and will
            generate no audit.

    ObjectTypeList - Supplies a list of GUIDs representing the object (and
        sub-objects) being accessed.  If no list is present, AccessCheckByType
        behaves identically to AccessCheck.

    ObjectTypeListLength - Specifies the number of elements in the ObjectTypeList.

    GenericMapping - Supplies a pointer to the generic mapping associated
        with this object type.

    ObjectCreation - A boolean flag indicated whether the access will
        result in a new object being created if granted.  A value of TRUE
        indicates an object will be created, FALSE indicates an existing
        object will be opened.

    GrantedAccessList - Returns an access mask describing the granted access.

    AccessStatusList - Status value that may be returned indicating the
         reason why access was denied.  Routines should avoid hardcoding a
         return value of STATUS_ACCESS_DENIED so that a different value can
         be returned when mandatory access control is implemented.

    pfGenerateOnClose - Points to a boolean that is set by the audity
        generation routine and must be passed to ObjectCloseAuditAlarm
        when the object handle is closed.


Return Value:

    Returns TRUE for success, FALSE for failure.  Extended error status
    is available using GetLastError.

--*/
{
    NTSTATUS Status;
    NTSTATUS RealAccessStatus;
    BOOLEAN GenerateOnClose = FALSE;
    UNICODE_STRING Subsystem;
    UNICODE_STRING ObjectType;
    UNICODE_STRING Object;
    ULONG i;


    RtlInitUnicodeString(
        &Subsystem,
        SubsystemName
        );

    RtlInitUnicodeString(
        &ObjectType,
        ObjectTypeName
        );

    RtlInitUnicodeString(
        &Object,
        ObjectName
        );

    Status = NtAccessCheckByTypeResultListAndAuditAlarm (
                &Subsystem,
                HandleId,
                &ObjectType,
                &Object,
                SecurityDescriptor,
                PrincipalSelfSid,
                DesiredAccess,
                AuditType,
                Flags,
                ObjectTypeList,
                ObjectTypeListLength,
                GenericMapping,
                (BOOLEAN)ObjectCreation,
                GrantedAccessList,
                AccessStatusList,
                &GenerateOnClose
                );


    *pfGenerateOnClose = (BOOL)GenerateOnClose;

    if ( !NT_SUCCESS(Status) ) {
        BaseSetLastNTError(Status);
        return FALSE;
    }

    //
    // Loop converting the array of NT status codes to WIN status codes.
    //

    for ( i=0; i<ObjectTypeListLength; i++ ) {
        if ( AccessStatusList[i] == STATUS_SUCCESS ) {
            AccessStatusList[i] = NO_ERROR;
        } else {
            AccessStatusList[i] = RtlNtStatusToDosError( AccessStatusList[i] );
        }
    }

    return TRUE;
}


BOOL
APIENTRY
AccessCheckByTypeResultListAndAuditAlarmByHandleW (
    LPCWSTR SubsystemName,
    LPVOID HandleId,
    HANDLE ClientToken,
    LPCWSTR ObjectTypeName,
    LPCWSTR ObjectName,
    PSECURITY_DESCRIPTOR SecurityDescriptor,
    PSID PrincipalSelfSid,
    DWORD DesiredAccess,
    AUDIT_EVENT_TYPE AuditType,
    DWORD Flags,
    POBJECT_TYPE_LIST ObjectTypeList,
    DWORD ObjectTypeListLength,
    PGENERIC_MAPPING GenericMapping,
    BOOL ObjectCreation,
    LPDWORD GrantedAccessList,
    LPDWORD AccessStatusList,
    LPBOOL pfGenerateOnClose
    )
/*++

Routine Description:

    This routine compares the input Security Descriptor against the
    caller's impersonation token and indicates if access is granted or
    denied.  If access is granted then the desired access mask becomes
    the granted access mask for the object.  The semantics of the
    access check routine is described in the DSA Security Architecture
    workbook.

    This routine will also generate any necessary audit messages as a
    result of the access attempt.

Arguments:

    SubsystemName - Supplies a name string identifying the subsystem
        calling the routine.

    HandleId - A unique value that will be used to represent the client's
        handle to the object.  This value is ignored (and may be re-used)
        if the access is denied.

    ClientToken - A handle to a token object representing the client that
        requested the operation.  This handle must be obtained from a
        communication session layer, such as from an LPC Port or Local
        Named Pipe, to prevent possible security policy violations.

    ObjectTypeName - Supplies the name of the type of the object being
        created or accessed.

    ObjectName - Supplies the name of the object being created or accessed.

    SecurityDescriptor - A pointer to the Security Descriptor against which
        acccess is to be checked.

    PrincipalSelfSid - If the object being access checked is an object which
        represents a principal (e.g., a user object), this parameter should
        be the SID of the object.  Any ACE containing the constant
        PRINCIPAL_SELF_SID is replaced by this SID.

        The parameter should be NULL if the object does not represent a principal.

    DesiredAccess - The desired acccess mask.  This mask must have been
        previously mapped to contain no generic accesses.

    AuditType - Specifies the type of audit to be generated.  Valid values
        are: AuditEventObjectAccess and AuditEventDirectoryServiceAccess.

    Flags - Flags modifying the execution of the API:

        AUDIT_ALLOW_NO_PRIVILEGE - If the called does not have AuditPrivilege,
            the call will silently continue to check access and will
            generate no audit.

    ObjectTypeList - Supplies a list of GUIDs representing the object (and
        sub-objects) being accessed.  If no list is present, AccessCheckByType
        behaves identically to AccessCheck.

    ObjectTypeListLength - Specifies the number of elements in the ObjectTypeList.

    GenericMapping - Supplies a pointer to the generic mapping associated
        with this object type.

    ObjectCreation - A boolean flag indicated whether the access will
        result in a new object being created if granted.  A value of TRUE
        indicates an object will be created, FALSE indicates an existing
        object will be opened.

    GrantedAccessList - Returns an access mask describing the granted access.

    AccessStatusList - Status value that may be returned indicating the
         reason why access was denied.  Routines should avoid hardcoding a
         return value of STATUS_ACCESS_DENIED so that a different value can
         be returned when mandatory access control is implemented.

    pfGenerateOnClose - Points to a boolean that is set by the audity
        generation routine and must be passed to ObjectCloseAuditAlarm
        when the object handle is closed.


Return Value:

    Returns TRUE for success, FALSE for failure.  Extended error status
    is available using GetLastError.

--*/
{
    NTSTATUS Status;
    NTSTATUS RealAccessStatus;
    BOOLEAN GenerateOnClose = FALSE;
    UNICODE_STRING Subsystem;
    UNICODE_STRING ObjectType;
    UNICODE_STRING Object;
    ULONG i;


    RtlInitUnicodeString(
        &Subsystem,
        SubsystemName
        );

    RtlInitUnicodeString(
        &ObjectType,
        ObjectTypeName
        );

    RtlInitUnicodeString(
        &Object,
        ObjectName
        );

    Status = NtAccessCheckByTypeResultListAndAuditAlarmByHandle (
                &Subsystem,
                HandleId,
                ClientToken,
                &ObjectType,
                &Object,
                SecurityDescriptor,
                PrincipalSelfSid,
                DesiredAccess,
                AuditType,
                Flags,
                ObjectTypeList,
                ObjectTypeListLength,
                GenericMapping,
                (BOOLEAN)ObjectCreation,
                GrantedAccessList,
                AccessStatusList,
                &GenerateOnClose
                );


    *pfGenerateOnClose = (BOOL)GenerateOnClose;

    if ( !NT_SUCCESS(Status) ) {
        BaseSetLastNTError(Status);
        return FALSE;
    }

    //
    // Loop converting the array of NT status codes to WIN status codes.
    //

    for ( i=0; i<ObjectTypeListLength; i++ ) {
        if ( AccessStatusList[i] == STATUS_SUCCESS ) {
            AccessStatusList[i] = NO_ERROR;
        } else {
            AccessStatusList[i] = RtlNtStatusToDosError( AccessStatusList[i] );
        }
    }

    return TRUE;
}


BOOL
APIENTRY
AccessCheckAndAuditAlarmA (
    LPCSTR SubsystemName,
    PVOID HandleId,
    LPSTR ObjectTypeName,
    LPSTR ObjectName,
    PSECURITY_DESCRIPTOR SecurityDescriptor,
    DWORD DesiredAccess,
    PGENERIC_MAPPING GenericMapping,
    BOOL ObjectCreation,
    LPDWORD GrantedAccess,
    LPBOOL AccessStatus,
    LPBOOL pfGenerateOnClose
    )
/*++

Routine Description:

    ANSI Thunk to AccessCheckAndAuditAlarmW

--*/
{
    PUNICODE_STRING ObjectNameW;
    ANSI_STRING AnsiString;
    UNICODE_STRING SubsystemNameW;
    UNICODE_STRING ObjectTypeNameW;
    NTSTATUS Status;
    BOOL RVal;


    ObjectNameW = &NtCurrentTeb()->StaticUnicodeString;


    RtlInitAnsiString(&AnsiString,SubsystemName);
    Status = RtlAnsiStringToUnicodeString(&SubsystemNameW,&AnsiString,TRUE);

    if ( !NT_SUCCESS(Status) ) {

        BaseSetLastNTError(Status);
        return FALSE;
    }



    RtlInitAnsiString(&AnsiString,ObjectTypeName);
    Status = RtlAnsiStringToUnicodeString(&ObjectTypeNameW,&AnsiString,TRUE);

    if ( !NT_SUCCESS(Status) ) {

        RtlFreeUnicodeString( &SubsystemNameW );

        BaseSetLastNTError(Status);
        return FALSE;
    }


    //
    // Convert the object name string, but don't allocate memory to
    // do it, since we've got the space in the TEB available.
    //

    RtlInitAnsiString(&AnsiString,ObjectName);
    Status = RtlAnsiStringToUnicodeString(ObjectNameW,&AnsiString,FALSE);

    if ( !NT_SUCCESS(Status) ) {

        RtlFreeUnicodeString( &SubsystemNameW );
        RtlFreeUnicodeString( &ObjectTypeNameW );

        BaseSetLastNTError(Status);
        return FALSE;
    }


    RVal =  AccessCheckAndAuditAlarmW (
                (LPCWSTR)SubsystemNameW.Buffer,
                HandleId,
                ObjectTypeNameW.Buffer,
                ObjectNameW->Buffer,
                SecurityDescriptor,
                DesiredAccess,
                GenericMapping,
                ObjectCreation,
                GrantedAccess,
                AccessStatus,
                pfGenerateOnClose
                );


    RtlFreeUnicodeString( &SubsystemNameW );
    RtlFreeUnicodeString( &ObjectTypeNameW );

    return( RVal );
}

BOOL
APIENTRY
AccessCheckByTypeAndAuditAlarmA (
    LPCSTR SubsystemName,
    PVOID HandleId,
    LPCSTR ObjectTypeName,
    LPCSTR ObjectName,
    PSECURITY_DESCRIPTOR SecurityDescriptor,
    PSID PrincipalSelfSid,
    DWORD DesiredAccess,
    AUDIT_EVENT_TYPE AuditType,
    DWORD Flags,
    POBJECT_TYPE_LIST ObjectTypeList,
    DWORD ObjectTypeListLength,
    PGENERIC_MAPPING GenericMapping,
    BOOL ObjectCreation,
    LPDWORD GrantedAccess,
    LPBOOL AccessStatus,
    LPBOOL pfGenerateOnClose
    )
/*++

Routine Description:

    ANSI Thunk to AccessCheckByTypeAndAuditAlarmW

--*/
{
    PUNICODE_STRING ObjectNameW;
    ANSI_STRING AnsiString;
    UNICODE_STRING SubsystemNameW;
    UNICODE_STRING ObjectTypeNameW;
    NTSTATUS Status;

    BOOL RVal;


    ObjectNameW = &NtCurrentTeb()->StaticUnicodeString;


    RtlInitAnsiString(&AnsiString,SubsystemName);
    Status = RtlAnsiStringToUnicodeString(&SubsystemNameW,&AnsiString,TRUE);

    if ( !NT_SUCCESS(Status) ) {

        BaseSetLastNTError(Status);
        return FALSE;
    }



    RtlInitAnsiString(&AnsiString,ObjectTypeName);
    Status = RtlAnsiStringToUnicodeString(&ObjectTypeNameW,&AnsiString,TRUE);

    if ( !NT_SUCCESS(Status) ) {

        RtlFreeUnicodeString( &SubsystemNameW );

        BaseSetLastNTError(Status);
        return FALSE;
    }


    //
    // Convert the object name string, but don't allocate memory to
    // do it, since we've got the space in the TEB available.
    //

    RtlInitAnsiString(&AnsiString,ObjectName);
    Status = RtlAnsiStringToUnicodeString(ObjectNameW,&AnsiString,FALSE);

    if ( !NT_SUCCESS(Status) ) {

        RtlFreeUnicodeString( &SubsystemNameW );
        RtlFreeUnicodeString( &ObjectTypeNameW );

        BaseSetLastNTError(Status);
        return FALSE;
    }


    RVal =  AccessCheckByTypeAndAuditAlarmW (
                (LPCWSTR)SubsystemNameW.Buffer,
                HandleId,
                ObjectTypeNameW.Buffer,
                ObjectNameW->Buffer,
                SecurityDescriptor,
                PrincipalSelfSid,
                DesiredAccess,
                AuditType,
                Flags,
                ObjectTypeList,
                ObjectTypeListLength,
                GenericMapping,
                ObjectCreation,
                GrantedAccess,
                AccessStatus,
                pfGenerateOnClose
                );


    RtlFreeUnicodeString( &SubsystemNameW );
    RtlFreeUnicodeString( &ObjectTypeNameW );

    return( RVal );
}

WINADVAPI
BOOL
WINAPI
AccessCheckByTypeResultListAndAuditAlarmA (
    LPCSTR SubsystemName,
    LPVOID HandleId,
    LPCSTR ObjectTypeName,
    LPCSTR ObjectName,
    PSECURITY_DESCRIPTOR SecurityDescriptor,
    PSID PrincipalSelfSid,
    DWORD DesiredAccess,
    AUDIT_EVENT_TYPE AuditType,
    DWORD Flags,
    POBJECT_TYPE_LIST ObjectTypeList,
    DWORD ObjectTypeListLength,
    PGENERIC_MAPPING GenericMapping,
    BOOL ObjectCreation,
    LPDWORD GrantedAccess,
    LPDWORD AccessStatusList,
    LPBOOL pfGenerateOnClose
    )
/*++

Routine Description:

    ANSI Thunk to AccessCheckByTypeResultListAndAuditAlarmW

--*/
{
    PUNICODE_STRING ObjectNameW;
    ANSI_STRING AnsiString;
    UNICODE_STRING SubsystemNameW;
    UNICODE_STRING ObjectTypeNameW;
    NTSTATUS Status;

    BOOL RVal;


    ObjectNameW = &NtCurrentTeb()->StaticUnicodeString;


    RtlInitAnsiString(&AnsiString,SubsystemName);
    Status = RtlAnsiStringToUnicodeString(&SubsystemNameW,&AnsiString,TRUE);

    if ( !NT_SUCCESS(Status) ) {

        BaseSetLastNTError(Status);
        return FALSE;
    }



    RtlInitAnsiString(&AnsiString,ObjectTypeName);
    Status = RtlAnsiStringToUnicodeString(&ObjectTypeNameW,&AnsiString,TRUE);

    if ( !NT_SUCCESS(Status) ) {

        RtlFreeUnicodeString( &SubsystemNameW );

        BaseSetLastNTError(Status);
        return FALSE;
    }


    //
    // Convert the object name string, but don't allocate memory to
    // do it, since we've got the space in the TEB available.
    //

    RtlInitAnsiString(&AnsiString,ObjectName);
    Status = RtlAnsiStringToUnicodeString(ObjectNameW,&AnsiString,FALSE);

    if ( !NT_SUCCESS(Status) ) {

        RtlFreeUnicodeString( &SubsystemNameW );
        RtlFreeUnicodeString( &ObjectTypeNameW );

        BaseSetLastNTError(Status);
        return FALSE;
    }


    RVal =  AccessCheckByTypeResultListAndAuditAlarmW (
                (LPCWSTR)SubsystemNameW.Buffer,
                HandleId,
                ObjectTypeNameW.Buffer,
                ObjectNameW->Buffer,
                SecurityDescriptor,
                PrincipalSelfSid,
                DesiredAccess,
                AuditType,
                Flags,
                ObjectTypeList,
                ObjectTypeListLength,
                GenericMapping,
                ObjectCreation,
                GrantedAccess,
                AccessStatusList,
                pfGenerateOnClose
                );

    RtlFreeUnicodeString( &SubsystemNameW );
    RtlFreeUnicodeString( &ObjectTypeNameW );

    return( RVal );
}


WINADVAPI
BOOL
WINAPI
AccessCheckByTypeResultListAndAuditAlarmByHandleA (
    LPCSTR SubsystemName,
    LPVOID HandleId,
    HANDLE ClientToken,
    LPCSTR ObjectTypeName,
    LPCSTR ObjectName,
    PSECURITY_DESCRIPTOR SecurityDescriptor,
    PSID PrincipalSelfSid,
    DWORD DesiredAccess,
    AUDIT_EVENT_TYPE AuditType,
    DWORD Flags,
    POBJECT_TYPE_LIST ObjectTypeList,
    DWORD ObjectTypeListLength,
    PGENERIC_MAPPING GenericMapping,
    BOOL ObjectCreation,
    LPDWORD GrantedAccess,
    LPDWORD AccessStatusList,
    LPBOOL pfGenerateOnClose
    )
/*++

Routine Description:

    ANSI Thunk to AccessCheckByTypeResultListAndAuditAlarmW

--*/
{
    PUNICODE_STRING ObjectNameW;
    ANSI_STRING AnsiString;
    UNICODE_STRING SubsystemNameW;
    UNICODE_STRING ObjectTypeNameW;
    NTSTATUS Status;

    BOOL RVal;


    ObjectNameW = &NtCurrentTeb()->StaticUnicodeString;


    RtlInitAnsiString(&AnsiString,SubsystemName);
    Status = RtlAnsiStringToUnicodeString(&SubsystemNameW,&AnsiString,TRUE);

    if ( !NT_SUCCESS(Status) ) {

        BaseSetLastNTError(Status);
        return FALSE;
    }



    RtlInitAnsiString(&AnsiString,ObjectTypeName);
    Status = RtlAnsiStringToUnicodeString(&ObjectTypeNameW,&AnsiString,TRUE);

    if ( !NT_SUCCESS(Status) ) {

        RtlFreeUnicodeString( &SubsystemNameW );

        BaseSetLastNTError(Status);
        return FALSE;
    }


    //
    // Convert the object name string, but don't allocate memory to
    // do it, since we've got the space in the TEB available.
    //

    RtlInitAnsiString(&AnsiString,ObjectName);
    Status = RtlAnsiStringToUnicodeString(ObjectNameW,&AnsiString,FALSE);

    if ( !NT_SUCCESS(Status) ) {

        RtlFreeUnicodeString( &SubsystemNameW );
        RtlFreeUnicodeString( &ObjectTypeNameW );

        BaseSetLastNTError(Status);
        return FALSE;
    }


    RVal =  AccessCheckByTypeResultListAndAuditAlarmByHandleW (
                (LPCWSTR)SubsystemNameW.Buffer,
                HandleId,
                ClientToken,
                ObjectTypeNameW.Buffer,
                ObjectNameW->Buffer,
                SecurityDescriptor,
                PrincipalSelfSid,
                DesiredAccess,
                AuditType,
                Flags,
                ObjectTypeList,
                ObjectTypeListLength,
                GenericMapping,
                ObjectCreation,
                GrantedAccess,
                AccessStatusList,
                pfGenerateOnClose
                );

    RtlFreeUnicodeString( &SubsystemNameW );
    RtlFreeUnicodeString( &ObjectTypeNameW );

    return( RVal );
}

BOOL
APIENTRY
ObjectOpenAuditAlarmA (
    LPCSTR SubsystemName,
    PVOID HandleId,
    LPSTR ObjectTypeName,
    LPSTR ObjectName,
    PSECURITY_DESCRIPTOR pSecurityDescriptor,
    HANDLE ClientToken,
    DWORD DesiredAccess,
    DWORD GrantedAccess,
    PPRIVILEGE_SET Privileges OPTIONAL,
    BOOL ObjectCreation,
    BOOL AccessGranted,
    LPBOOL GenerateOnClose
    )
/*++

Routine Description:

    ANSI Thunk to ObjectOpenAuditAlarmW

--*/
{
    PUNICODE_STRING ObjectNameW;
    ANSI_STRING AnsiString;
    UNICODE_STRING SubsystemNameW;
    UNICODE_STRING ObjectTypeNameW;
    NTSTATUS Status;
    BOOL RVal;


    ObjectNameW = &NtCurrentTeb()->StaticUnicodeString;


    RtlInitAnsiString(&AnsiString,SubsystemName);
    Status = RtlAnsiStringToUnicodeString(&SubsystemNameW,&AnsiString,TRUE);

    if ( !NT_SUCCESS(Status) ) {

        BaseSetLastNTError(Status);
        return FALSE;
    }



    RtlInitAnsiString(&AnsiString,ObjectTypeName);
    Status = RtlAnsiStringToUnicodeString(&ObjectTypeNameW,&AnsiString,TRUE);

    if ( !NT_SUCCESS(Status) ) {

        RtlFreeUnicodeString( &SubsystemNameW );

        BaseSetLastNTError(Status);
        return FALSE;
    }


    //
    // Convert the object name string, but don't allocate memory to
    // do it, since we've got the space in the TEB available.
    //

    RtlInitAnsiString(&AnsiString,ObjectName);
    Status = RtlAnsiStringToUnicodeString(ObjectNameW,&AnsiString,FALSE);

    if ( !NT_SUCCESS(Status) ) {

        RtlFreeUnicodeString( &SubsystemNameW );
        RtlFreeUnicodeString( &ObjectTypeNameW );

        BaseSetLastNTError(Status);
        return FALSE;
    }

    RVal = ObjectOpenAuditAlarmW (
               (LPCWSTR)SubsystemNameW.Buffer,
               HandleId,
               ObjectTypeNameW.Buffer,
               ObjectNameW->Buffer,
               pSecurityDescriptor,
               ClientToken,
               DesiredAccess,
               GrantedAccess,
               Privileges,
               ObjectCreation,
               AccessGranted,
               GenerateOnClose
               );

    RtlFreeUnicodeString( &SubsystemNameW );
    RtlFreeUnicodeString( &ObjectTypeNameW );

    return( RVal );

}



BOOL
APIENTRY
ObjectOpenAuditAlarmW (
    LPCWSTR SubsystemName,
    PVOID HandleId,
    LPWSTR ObjectTypeName,
    LPWSTR ObjectName,
    PSECURITY_DESCRIPTOR pSecurityDescriptor,
    HANDLE ClientToken,
    DWORD DesiredAccess,
    DWORD GrantedAccess,
    PPRIVILEGE_SET Privileges OPTIONAL,
    BOOL ObjectCreation,
    BOOL AccessGranted,
    LPBOOL GenerateOnClose
    )
/*++

    Routine Description:

    This routine is used to generate audit and alarm messages when an
    attempt is made to access an existing protected subsystem object or
    create a new one.  This routine may result in several messages being
    generated and sent to Port objects.  This may result in a significant
    latency before returning.  Design of routines that must call this
    routine must take this potential latency into account.  This may have
    an impact on the approach taken for data structure mutex locking, for
    example.

    This routine may not be able to generate a complete audit record
    due to memory restrictions.

    This API requires the caller have SeSecurityPrivilege privilege.
    The test for this privilege is always against the primary token of
    the calling process, not the impersonation token of the thread.

Arguments:

    SubsystemName - Supplies a name string identifying the
        subsystem calling the routine.

    HandleId - A unique value representing the client's handle to the
        object.  If the access attempt was not successful (AccessGranted is
        FALSE), then this parameter is ignored.

    ObjectTypeName - Supplies the name of the type of object being
        accessed.

    ObjectName - Supplies the name of the object the client
        accessed or attempted to access.

    pSecurityDescriptor - An optional pointer to the security
        descriptor of the object being accessed.

    ClientToken - A handle to a token object representing the client that
        requested the operation.  This handle must be obtained from a
        communication session layer, such as from an LPC Port or Local
        Named Pipe, to prevent possible security policy violations.

    DesiredAccess - The desired access mask.  This mask must have been
        previously mapped to contain no generic accesses.

    GrantedAccess - The mask of accesses that were actually granted.

    Privileges - Optionally points to a set of privileges that were
        required for the access attempt.  Those privileges that were held
        by the subject are marked using the UsedForAccess flag of the
        attributes associated with each privilege.

    ObjectCreation - A boolean flag indicating whether the access will
        result in a new object being created if granted.  A value of TRUE
        indicates an object will be created, FALSE indicates an existing
        object will be opened.

    AccessGranted - Indicates whether the requested access was granted or
        not.  A value of TRUE indicates the access was granted.  A value of
        FALSE indicates the access was not granted.

    GenerateOnClose - Points to a boolean that is set by the audit
        generation routine and must be passed to NtCloseObjectAuditAlarm()
        when the object handle is closed.

Return Value:

    Returns TRUE for success, FALSE for failure.  Extended error status
    is available using GetLastError.

--*/
{
    NTSTATUS Status;
    UNICODE_STRING Subsystem;
    UNICODE_STRING ObjectType;
    UNICODE_STRING Object;


    RtlInitUnicodeString(
        &Subsystem,
        SubsystemName
        );

    RtlInitUnicodeString(
        &ObjectType,
        ObjectTypeName
        );

    RtlInitUnicodeString(
        &Object,
        ObjectName
        );

    Status = NtOpenObjectAuditAlarm (
                &Subsystem,
                &HandleId,
                &ObjectType,
                &Object,
                pSecurityDescriptor,
                ClientToken,
                DesiredAccess,
                GrantedAccess,
                Privileges,
                (BOOLEAN)ObjectCreation,
                (BOOLEAN)AccessGranted,
                (PBOOLEAN)GenerateOnClose
                );

    if ( !NT_SUCCESS(Status) ) {
        BaseSetLastNTError(Status);
        return FALSE;
    }

    return TRUE;
}



BOOL
APIENTRY
ObjectPrivilegeAuditAlarmA (
    LPCSTR SubsystemName,
    PVOID HandleId,
    HANDLE ClientToken,
    DWORD DesiredAccess,
    PPRIVILEGE_SET Privileges,
    BOOL AccessGranted
    )
/*++

Routine Description:

    ANSI Thunk to ObjectPrivilegeAuditAlarmW

--*/
{
    PUNICODE_STRING SubsystemNameW;
    ANSI_STRING AnsiString;
    NTSTATUS Status;
    BOOL RVal;

    SubsystemNameW = &NtCurrentTeb()->StaticUnicodeString;

    //
    // Convert the object name string, but don't allocate memory to
    // do it, since we've got the space in the TEB available.
    //

    RtlInitAnsiString(&AnsiString,SubsystemName);
    Status = RtlAnsiStringToUnicodeString(SubsystemNameW,&AnsiString,FALSE);

    if ( !NT_SUCCESS(Status) ) {

        BaseSetLastNTError(Status);
        return FALSE;
    }

    RVal = ObjectPrivilegeAuditAlarmW (
                (LPCWSTR)SubsystemNameW->Buffer,
                HandleId,
                ClientToken,
                DesiredAccess,
                Privileges,
                AccessGranted
                );

    return( RVal );
}




BOOL
APIENTRY
ObjectPrivilegeAuditAlarmW (
    LPCWSTR SubsystemName,
    PVOID HandleId,
    HANDLE ClientToken,
    DWORD DesiredAccess,
    PPRIVILEGE_SET Privileges,
    BOOL AccessGranted
    )
/*++

Routine Description:

    This routine is used to generate audit and alarm messages when an
    attempt is made to perform privileged operations on a protected
    subsystem object after the object is already opened.  This routine
    may result in several messages being generated and sent to Port
    objects.  This may result in a significant latency before
    returning.  Design of routines that must call this routine must
    take this potential latency into account.  This may have an impact
    on the approach taken for data structure mutex locking, for
    example.

    This API requires the caller have SeSecurityPrivilege privilege.
    The test for this privilege is always against the primary token of
    the calling process, allowing the caller to be impersonating a
    client during the call with no ill effects.

Arguments:

    SubsystemName - Supplies a name string identifying the subsystem
        calling the routine.

    HandleId - A unique value representing the client's handle to the
        object.

    ClientToken - A handle to a token object representing the client that
        requested the operation.  This handle must be obtained from a
        communication session layer, such as from an LPC Port or Local
        Named Pipe, to prevent possible security policy violations.

    DesiredAccess - The desired access mask.  This mask must have been
        previously mapped to contain no generic accesses.

    Privileges - The set of privileges required for the requested
        operation.  Those privileges that were held by the subject are
        marked using the UsedForAccess flag of the attributes
        associated with each privilege.

    AccessGranted - Indicates whether the requested access was granted or
        not.  A value of TRUE indicates the access was granted.  A value of
        FALSE indicates the access was not granted.

Return value:

    Returns TRUE for success, FALSE for failure.  Extended error status
    is available using GetLastError.

--*/
{
    NTSTATUS Status;
    UNICODE_STRING Subsystem;

    RtlInitUnicodeString(
        &Subsystem,
        SubsystemName
        );

    Status = NtPrivilegeObjectAuditAlarm (
        &Subsystem,
        HandleId,
        ClientToken,
        DesiredAccess,
        Privileges,
        (BOOLEAN)AccessGranted
        );

    if ( !NT_SUCCESS(Status) ) {
        BaseSetLastNTError(Status);
        return FALSE;
    }

    return TRUE;
}


BOOL
APIENTRY
ObjectCloseAuditAlarmA (
    LPCSTR SubsystemName,
    PVOID HandleId,
    BOOL GenerateOnClose
    )
/*++

Routine Description:

    ANSI Thunk to ObjectCloseAuditAlarmW

--*/
{
    PUNICODE_STRING SubsystemNameW;
    NTSTATUS Status;
    ANSI_STRING AnsiString;

    SubsystemNameW = &NtCurrentTeb()->StaticUnicodeString;

    //
    // Convert the object name string, but don't allocate memory to
    // do it, since we've got the space in the TEB available.
    //

    RtlInitAnsiString(&AnsiString,SubsystemName);
    Status = RtlAnsiStringToUnicodeString(SubsystemNameW,&AnsiString,FALSE);

    if ( !NT_SUCCESS(Status) ) {

        BaseSetLastNTError(Status);
        return FALSE;
    }

    return ObjectCloseAuditAlarmW (
               (LPCWSTR)SubsystemNameW->Buffer,
               HandleId,
               GenerateOnClose
               );


}

BOOL
APIENTRY
ObjectCloseAuditAlarmW (
    LPCWSTR SubsystemName,
    PVOID HandleId,
    BOOL GenerateOnClose
    )
/*++

Routine Description:

    This routine is used to generate audit and alarm messages when a handle
    to a protected subsystem object is deleted.  This routine may result in
    several messages being generated and sent to Port objects.  This may
    result in a significant latency before returning.  Design of routines
    that must call this routine must take this potential latency into
    account.  This may have an impact on the approach taken for data
    structure mutex locking, for example.

    This API requires the caller have SeSecurityPrivilege privilege.  The test
    for this privilege is always against the primary token of the calling
    process, allowing the caller to be impersonating a client during the
    call with no ill effects.

Arguments:

    SubsystemName - Supplies a name string identifying the subsystem
        calling the routine.

    HandleId - A unique value representing the client's handle to the
        object.

    GenerateOnClose - Is a boolean value returned from a corresponding
        AccessCheckAndAuditAlarm() call or ObjectOpenAuditAlarm() call
        when the object handle was created.

Return value:

    Returns TRUE for success, FALSE for failure.  Extended error status
    is available using GetLastError.


--*/
{
    NTSTATUS Status;
    UNICODE_STRING Subsystem;

    RtlInitUnicodeString( &Subsystem, SubsystemName );

    Status = NtCloseObjectAuditAlarm (
        &Subsystem,
        HandleId,
        (BOOLEAN)GenerateOnClose
        );

    if ( !NT_SUCCESS(Status) ) {
        BaseSetLastNTError(Status);
        return FALSE;
    }

    return TRUE;
}


BOOL
APIENTRY
ObjectDeleteAuditAlarmA (
    LPCSTR SubsystemName,
    PVOID HandleId,
    BOOL GenerateOnClose
    )
/*++

Routine Description:

    ANSI Thunk to ObjectDeleteAuditAlarmW

--*/
{
    PUNICODE_STRING SubsystemNameW;
    NTSTATUS Status;
    ANSI_STRING AnsiString;

    SubsystemNameW = &NtCurrentTeb()->StaticUnicodeString;

    //
    // Convert the object name string, but don't allocate memory to
    // do it, since we've got the space in the TEB available.
    //

    RtlInitAnsiString(&AnsiString,SubsystemName);
    Status = RtlAnsiStringToUnicodeString(SubsystemNameW,&AnsiString,FALSE);

    if ( !NT_SUCCESS(Status) ) {

        BaseSetLastNTError(Status);
        return FALSE;
    }

    return ObjectDeleteAuditAlarmW (
               (LPCWSTR)SubsystemNameW->Buffer,
               HandleId,
               GenerateOnClose
               );


}

BOOL
APIENTRY
ObjectDeleteAuditAlarmW (
    LPCWSTR SubsystemName,
    PVOID HandleId,
    BOOL GenerateOnClose
    )
/*++

Routine Description:

    This routine is used to generate audit and alarm messages when an object
    in a protected subsystem is deleted.  This routine may result in
    several messages being generated and sent to Port objects.  This may
    result in a significant latency before returning.  Design of routines
    that must call this routine must take this potential latency into
    account.  This may have an impact on the approach taken for data
    structure mutex locking, for example.

    This API requires the caller have SeSecurityPrivilege privilege.  The test
    for this privilege is always against the primary token of the calling
    process, allowing the caller to be impersonating a client during the
    call with no ill effects.

Arguments:

    SubsystemName - Supplies a name string identifying the subsystem
        calling the routine.

    HandleId - A unique value representing the client's handle to the
        object.

    GenerateOnClose - Is a boolean value returned from a corresponding
        AccessCheckAndAuditAlarm() call or ObjectOpenAuditAlarm() call
        when the object handle was created.

Return value:

    Returns TRUE for success, FALSE for failure.  Extended error status
    is available using GetLastError.


--*/
{
    NTSTATUS Status;
    UNICODE_STRING Subsystem;

    RtlInitUnicodeString( &Subsystem, SubsystemName );

    Status = NtDeleteObjectAuditAlarm (
        &Subsystem,
        HandleId,
        (BOOLEAN)GenerateOnClose
        );

    if ( !NT_SUCCESS(Status) ) {
        BaseSetLastNTError(Status);
        return FALSE;
    }

    return TRUE;
}



BOOL
APIENTRY
PrivilegedServiceAuditAlarmA (
    LPCSTR SubsystemName,
    LPCSTR ServiceName,
    HANDLE ClientToken,
    PPRIVILEGE_SET Privileges,
    BOOL AccessGranted
    )
/*++

Routine Description:

    ANSI Thunk to PrivilegedServiceAuditAlarmW

--*/
{
    PUNICODE_STRING ServiceNameW;
    UNICODE_STRING SubsystemNameW;
    ANSI_STRING  AnsiString;
    NTSTATUS Status;
    BOOL RVal;

    ServiceNameW = &NtCurrentTeb()->StaticUnicodeString;

    //
    // Convert the object name string, but don't allocate memory to
    // do it, since we've got the space in the TEB available.
    //

    RtlInitAnsiString(&AnsiString,ServiceName);
    Status = RtlAnsiStringToUnicodeString(ServiceNameW,&AnsiString,FALSE);

    if ( !NT_SUCCESS(Status) ) {

        BaseSetLastNTError(Status);
        return FALSE;
    }

    RtlInitAnsiString(&AnsiString,SubsystemName);
    Status = RtlAnsiStringToUnicodeString(&SubsystemNameW,&AnsiString,TRUE);

    if ( !NT_SUCCESS(Status) ) {

        BaseSetLastNTError(Status);
        return FALSE;
    }

    RVal =  PrivilegedServiceAuditAlarmW (
                (LPCWSTR)SubsystemNameW.Buffer,
                (LPCWSTR)ServiceNameW->Buffer,
                ClientToken,
                Privileges,
                AccessGranted
                );

    RtlFreeUnicodeString( &SubsystemNameW );

    return( RVal );

}

BOOL
APIENTRY
PrivilegedServiceAuditAlarmW (
    LPCWSTR SubsystemName,
    LPCWSTR ServiceName,
    HANDLE ClientToken,
    PPRIVILEGE_SET Privileges,
    BOOL AccessGranted
    )
/*++

Routine Description:

    This routine is used to generate audit and alarm messages when an
    attempt is made to perform privileged system service operations.  This
    routine may result in several messages being generated and sent to Port
    objects.  This may result in a significant latency before returning.
    Design of routines that must call this routine must take this potential
    latency into account.  This may have an impact on the approach taken
    for data structure mutex locking, for example.

    This API requires the caller have SeSecurityPrivilege privilege.  The test
    for this privilege is always against the primary token of the calling
    process, allowing the caller to be impersonating a client during the
    call with no ill effects

Arguments:

    SubsystemName - Supplies a name string identifying the subsystem
        calling the routine.

    ServiceName - Supplies a name of the privileged subsystem service.  For
        example, "RESET RUNTIME LOCAL SECURITY POLICY" might be specified
        by a Local Security Authority service used to update the local
        security policy database.

    ClientToken - A handle to a token object representing the client that
        requested the operation.  This handle must be obtained from a
        communication session layer, such as from an LPC Port or Local
        Named Pipe, to prevent possible security policy violations.

    Privileges - Points to a set of privileges required to perform the
        privileged operation.  Those privileges that were held by the
        subject are marked using the UsedForAccess flag of the
        attributes associated with each privilege.

    AccessGranted - Indicates whether the requested access was granted or
        not.  A value of TRUE indicates the access was granted.  A value of
        FALSE indicates the access was not granted.


Return value:

    Returns TRUE for success, FALSE for failure.  Extended error status
    is available using GetLastError.


--*/
{
    NTSTATUS Status;
    UNICODE_STRING Subsystem;
    UNICODE_STRING Service;

    RtlInitUnicodeString( &Subsystem, SubsystemName );

    RtlInitUnicodeString( &Service, ServiceName );

    Status = NtPrivilegedServiceAuditAlarm (
        &Subsystem,
        &Service,
        ClientToken,
        Privileges,
        (BOOLEAN)AccessGranted
        );

    if ( !NT_SUCCESS(Status) ) {
        BaseSetLastNTError(Status);
        return FALSE;
    }

    return TRUE;
}




BOOL
APIENTRY
IsValidSid (
    PSID pSid
    )
/*++

Routine Description:

    This procedure validates an SID's structure.

Arguments:

    pSid - Pointer to the SID structure to validate.

Return Value:

    BOOLEAN - TRUE if the structure of pSid is valid.

--*/
{
    if ( !RtlValidSid ( pSid ) ) {
        SetLastError(ERROR_INVALID_SID);
        return FALSE;
    }

    return TRUE;


}




BOOL
APIENTRY
EqualSid (
    PSID pSid1,
    PSID pSid2
    )
/*++

Routine Description:

    This procedure tests two SID values for equality.

Arguments:

    pSid1, pSid2 - Supply pointers to the two SID values to compare.
        The SID structures are assumed to be valid.

Return Value:

    BOOLEAN - TRUE if the value of pSid1 is equal to pSid2, and FALSE
        otherwise.

--*/
{
    SetLastError(0);
    return (BOOL) RtlEqualSid (
                    pSid1,
                    pSid2
                    );
}




BOOL
APIENTRY
EqualPrefixSid (
    PSID pSid1,
    PSID pSid2
    )
/*++

Routine Description:

    This procedure tests two SID prefix values for equality.

    An SID prefix is the entire SID except for the last sub-authority
    value.

Arguments:

    pSid1, pSid2 - Supply pointers to the two SID values to compare.
        The SID structures are assumed to be valid.

Return Value:

    BOOLEAN - TRUE if the prefix value of pSid1 is equal to pSid2, and
        FALSE otherwise.

--*/
{
    SetLastError(0);
    return (BOOL) RtlEqualPrefixSid (
                    pSid1,
                    pSid2
                    );
}




DWORD
APIENTRY
GetSidLengthRequired (
    UCHAR nSubAuthorityCount
    )
/*++

Routine Description:

    This routine returns the length, in bytes, required to store an SID
    with the specified number of Sub-Authorities.

Arguments:

    nSubAuthorityCount - The number of sub-authorities to be stored in
        the SID.

Return Value:

    DWORD - The length, in bytes, required to store the SID.

--*/
{
    return RtlLengthRequiredSid (
                nSubAuthorityCount
                );
}



BOOL
APIENTRY
InitializeSid (
    PSID Sid,
    PSID_IDENTIFIER_AUTHORITY pIdentifierAuthority,
    BYTE nSubAuthorityCount
    )

/*++

Routine Description:

    This function initializes an SID data structure.  It does not,
    however, set the sub-authority values.  This must be done
    separately.

Arguments:

    Sid - Pointer to the SID data structure to initialize.

    pIdentifierAuthority - Pointer to the Identifier Authority value
        to set in the SID.

    nSubAuthorityCount - The number of sub-authorities that will be
        placed in the SID (a separate action).

Return Value:

    None

--*/
{
    NTSTATUS Status;

    Status = RtlInitializeSid (
                Sid,
                pIdentifierAuthority,
                nSubAuthorityCount
                );

    if ( !NT_SUCCESS( Status )) {
        BaseSetLastNTError( Status );
        return( FALSE );
    }

    return( TRUE );
}



PVOID
APIENTRY
FreeSid(
    PSID pSid
    )

/*++

Routine Description:

    This function is used to free a SID previously allocated using
    AllocateAndInitializeSid().


Arguments:

    Sid - Pointer to the SID to free.

Return Value:

    None.


--*/
{
    return(RtlFreeSid( pSid ));
}



BOOL
APIENTRY
AllocateAndInitializeSid (
    PSID_IDENTIFIER_AUTHORITY pIdentifierAuthority,
    BYTE nSubAuthorityCount,
    DWORD nSubAuthority0,
    DWORD nSubAuthority1,
    DWORD nSubAuthority2,
    DWORD nSubAuthority3,
    DWORD nSubAuthority4,
    DWORD nSubAuthority5,
    DWORD nSubAuthority6,
    DWORD nSubAuthority7,
    PSID *pSid
    )

/*++

Routine Description:

    This function allocates and initializes a sid with the specified
    number of sub-authorities (up to 8).  A sid allocated with this
    routine must be freed using FreeSid().


Arguments:

    pIdentifierAuthority - Pointer to the Identifier Authority value to
        set in the SID.

    nSubAuthorityCount - The number of sub-authorities to place in the SID.
        This also identifies how many of the SubAuthorityN parameters
        have meaningful values.  This must contain a value from 0 through
        8.

    nSubAuthority0-7 - Provides the corresponding sub-authority value to
        place in the SID.  For example, a SubAuthorityCount value of 3
        indicates that SubAuthority0, SubAuthority1, and SubAuthority0
        have meaningful values and the rest are to be ignored.

    Sid - Receives a pointer to the allocated and initialized SID data
        structure.

Return Value:


    ERROR_NO_MEMORY - The attempt to allocate memory for the SID
        failed.

    ERROR_INVALID_SID - The number of sub-authorities specified did
        not fall in the valid range for this api (0 through 8).

--*/
{
    NTSTATUS Status;

    Status = RtlAllocateAndInitializeSid (
                 pIdentifierAuthority,
                 (UCHAR)nSubAuthorityCount,
                 (ULONG)nSubAuthority0,
                 (ULONG)nSubAuthority1,
                 (ULONG)nSubAuthority2,
                 (ULONG)nSubAuthority3,
                 (ULONG)nSubAuthority4,
                 (ULONG)nSubAuthority5,
                 (ULONG)nSubAuthority6,
                 (ULONG)nSubAuthority7,
                 pSid
                 );

    if ( !NT_SUCCESS( Status )) {
        BaseSetLastNTError( Status );
        return( FALSE );
    }

    return( TRUE );
}




PSID_IDENTIFIER_AUTHORITY
GetSidIdentifierAuthority (
    PSID pSid
    )
/*++

Routine Description:

    This function returns the address of an SID's IdentifierAuthority field.

Arguments:

    Sid - Pointer to the SID data structure.

Return Value:

    Address of an SID's Identifier Authority field.

--*/
{
    SetLastError(0);
    return RtlIdentifierAuthoritySid (
               pSid
               );
}




PDWORD
GetSidSubAuthority (
    PSID pSid,
    DWORD nSubAuthority
    )
/*++

Routine Description:

    This function returns the address of a sub-authority array element of
    an SID.

Arguments:

    pSid - Pointer to the SID data structure.

    nSubAuthority - An index indicating which sub-authority is being
        specified.  This value is not compared against the number of
        sub-authorities in the SID for validity.

Return Value:

    Address of a relative ID within the SID.

--*/
{
    SetLastError(0);
    return RtlSubAuthoritySid (
               pSid,
               nSubAuthority
               );
}

PUCHAR
GetSidSubAuthorityCount (
    PSID pSid
    )
/*++

Routine Description:

    This function returns the address of the sub-authority count field of
    an SID.

Arguments:

    pSid - Pointer to the SID data structure.

Return Value:

    Address of the sub-authority count field of an SID.


--*/
{
    SetLastError(0);
    return RtlSubAuthorityCountSid (
               pSid
               );
}



DWORD
APIENTRY
GetLengthSid (
    PSID pSid
    )
/*++

Routine Description:

    This routine returns the length, in bytes, of a structurally valid SID.

Arguments:

    pSid - Points to the SID whose length is to be returned.  The
        SID's structure is assumed to be valid.

Return Value:

    DWORD - The length, in bytes, of the SID.

--*/
{
    SetLastError(0);
    return RtlLengthSid (
                pSid
                );
}



BOOL
APIENTRY
CopySid (
    DWORD nDestinationSidLength,
    PSID pDestinationSid,
    PSID pSourceSid
    )
/*++

Routine Description:

    This routine copies the value of the source SID to the destination
    SID.

Arguments:

    nDestinationSidLength - Indicates the length, in bytes, of the
        destination SID buffer.

    pDestinationSid - Pointer to a buffer to receive a copy of the
        source Sid value.

    pSourceSid - Supplies the Sid value to be copied.

Return Value:

    Returns TRUE for success, FALSE for failure.  Extended error status
    is available using GetLastError.

--*/
{
    NTSTATUS Status;

    Status = RtlCopySid (
                nDestinationSidLength,
                pDestinationSid,
                pSourceSid
                );

    if ( !NT_SUCCESS(Status) ) {
        BaseSetLastNTError(Status);
        return FALSE;
    }

    return TRUE;
}




BOOL
APIENTRY
AreAllAccessesGranted (
    DWORD GrantedAccess,
    DWORD DesiredAccess
    )
/*++

Routine Description:

    This routine is used to check a desired access mask against a
    granted access mask.

Arguments:

        GrantedAccess - Specifies the granted access mask.

        DesiredAccess - Specifies the desired access mask.

Return Value:

    BOOL - TRUE if the GrantedAccess mask has all the bits set that
        the DesiredAccess mask has set.  That is, TRUE is returned if
        all of the desired accesses have been granted.

--*/
{
    return (BOOL) RtlAreAllAccessesGranted (
        GrantedAccess,
        DesiredAccess
        );
}




BOOL
APIENTRY
AreAnyAccessesGranted (
    DWORD GrantedAccess,
    DWORD DesiredAccess
    )
/*++

Routine Description:

    This routine is used to test whether any of a set of desired
    accesses are granted by a granted access mask.

Arguments:

        GrantedAccess - Specifies the granted access mask.

        DesiredAccess - Specifies the desired access mask.

Return Value:

    BOOL - TRUE if the GrantedAccess mask contains any of the bits
        specified in the DesiredAccess mask.  That is, if any of the
        desired accesses have been granted, TRUE is returned.


--*/
{
    return (BOOL) RtlAreAnyAccessesGranted (
        GrantedAccess,
        DesiredAccess
        );
}




VOID
APIENTRY
MapGenericMask (
    PDWORD AccessMask,
    PGENERIC_MAPPING GenericMapping
    )
/*++

Routine Description:

    This routine maps all generic accesses in the provided access mask
    to specific and standard accesses according to the provided
    GenericMapping.  The resulting mask will not have any of the
    generic bits set (GenericRead, GenericWrite, GenericExecute, or
    GenericAll) or any undefined bits set, but may have any other bit
    set.  If bits other than the generic bits are provided on input,
    they will not be cleared bt the mapping.

Arguments:

    AccessMask - Points to the access mask to be mapped.

    GenericMapping - The mapping of generic to specific and standard
        access types.

Return Value:

    None.

--*/
{
    RtlMapGenericMask (
        AccessMask,
        GenericMapping
        );
}



BOOL
APIENTRY
IsValidAcl (
    PACL pAcl
    )
/*++

Routine Description:

    This procedure validates an ACL.

    This involves validating the revision level of the ACL and ensuring
    that the number of ACEs specified in the AceCount fit in the space
    specified by the AclSize field of the ACL header.

Arguments:

    pAcl - Pointer to the ACL structure to validate.

Return Value:

    BOOLEAN - TRUE if the structure of Acl is valid.


--*/
{
    if ( !RtlValidAcl( pAcl ) ) {
        SetLastError(ERROR_INVALID_ACL);
        return FALSE;
    }
    return TRUE;
}




BOOL
APIENTRY
InitializeAcl (
    PACL pAcl,
    DWORD nAclLength,
    DWORD dwAclRevision
    )
/*++

Routine Description:

    InitializeAcl creates a new ACL in the caller supplied memory
    buffer.  The ACL contains zero ACEs; therefore, it is an empty ACL
    as opposed to a nonexistent ACL.  That is, if the ACL is now set
    to an object it will implicitly deny access to everyone.

Arguments:

    pAcl - Supplies the buffer containing the ACL being initialized

    nAclLength - Supplies the length of the ace buffer in bytes

    dwAclRevision - Supplies the revision for this Acl

Return Value:

    Returns TRUE for success, FALSE for failure.  Extended error status
    is available using GetLastError.

--*/
{
    NTSTATUS Status;

    Status = RtlCreateAcl (
                pAcl,
                nAclLength,
                dwAclRevision
                );

    if ( !NT_SUCCESS(Status) ) {
        BaseSetLastNTError(Status);
        return FALSE;
    }

    return TRUE;
}



BOOL
APIENTRY
GetAclInformation (
    PACL pAcl,
    PVOID pAclInformation,
    DWORD nAclInformationLength,
    ACL_INFORMATION_CLASS dwAclInformationClass
    )
/*++

Routine Description:

    This routine returns to the caller information about an ACL.  The requested
    information can be AclRevisionInformation, or AclSizeInformation.

Arguments:

    pAcl - Supplies the Acl being examined

    pAclInformation - Supplies the buffer to receive the information
        being requested

    nAclInformationLength - Supplies the length of the AclInformation
        buffer in bytes

    dwAclInformationClass - Supplies the type of information being
        requested

Return Value:

    Returns TRUE for success, FALSE for failure.  Extended error status
    is available using GetLastError.

--*/
{
    NTSTATUS Status;

    Status = RtlQueryInformationAcl (
                pAcl,
                pAclInformation,
                nAclInformationLength,
                dwAclInformationClass
                );

    if ( !NT_SUCCESS(Status) ) {
        BaseSetLastNTError(Status);
        return FALSE;
    }

    return TRUE;
}




BOOL
APIENTRY
SetAclInformation (
    PACL pAcl,
    PVOID pAclInformation,
    DWORD nAclInformationLength,
    ACL_INFORMATION_CLASS dwAclInformationClass
    )
/*++

Routine Description:

    This routine sets the state of an ACL.  For now only the revision
    level can be set and for now only a revision level of 1 is accepted
    so this procedure is rather simple

Arguments:

    pAcl - Supplies the Acl being altered

    pAclInformation - Supplies the buffer containing the information
        being set

    nAclInformationLength - Supplies the length of the Acl information
        buffer

    dwAclInformationClass - Supplies the type of information begin set

Return Value:

    Returns TRUE for success, FALSE for failure.  Extended error status
    is available using GetLastError.

--*/
{
    NTSTATUS Status;

    Status = RtlSetInformationAcl (
                pAcl,
                pAclInformation,
                nAclInformationLength,
                dwAclInformationClass
                );

    if ( !NT_SUCCESS(Status) ) {
        BaseSetLastNTError(Status);
        return FALSE;
    }

    return TRUE;
}

BOOL
APIENTRY
AddAce (
    PACL pAcl,
    DWORD dwAceRevision,
    DWORD dwStartingAceIndex,
    PVOID pAceList,
    DWORD nAceListLength
    )
/*++

Routine Description:

    This routine adds a string of ACEs to an ACL.

Arguments:

    pAcl - Supplies the Acl being modified

    dwAceRevision - Supplies the Acl/Ace revision of the ACE being
        added

    dwStartingAceIndex - Supplies the ACE index which will be the
        index of the first ace inserted in the acl.  0 for the
        beginning of the list and MAXULONG for the end of the list.

    pAceList - Supplies the list of Aces to be added to the Acl

    nAceListLength - Supplies the size, in bytes, of the AceList
        buffer

Return Value:

    Returns TRUE for success, FALSE for failure.  Extended error status
    is available using GetLastError.


--*/
{
    NTSTATUS Status;

    Status = RtlAddAce (
        pAcl,
        dwAceRevision,
        dwStartingAceIndex,
        pAceList,
        nAceListLength
        );

    if ( !NT_SUCCESS(Status) ) {
        BaseSetLastNTError(Status);
        return FALSE;
    }

    return TRUE;
}

BOOL
APIENTRY
DeleteAce (
    PACL pAcl,
    DWORD dwAceIndex
    )
/*++

Routine Description:

    This routine deletes one ACE from an ACL.

Arguments:

    pAcl - Supplies the Acl being modified

    dwAceIndex - Supplies the index of the Ace to delete.

Return Value:

    Returns TRUE for success, FALSE for failure.  Extended error status
    is available using GetLastError.

--*/
{
    NTSTATUS Status;

    Status = RtlDeleteAce (
                pAcl,
                dwAceIndex
                );

    if ( !NT_SUCCESS(Status) ) {
        BaseSetLastNTError(Status);
        return FALSE;
    }

    return TRUE;
}

BOOL
APIENTRY
GetAce (
    PACL pAcl,
    DWORD dwAceIndex,
    PVOID *pAce
    )
/*++

Routine Description:

    This routine returns a pointer to an ACE in an ACl referenced by
    ACE index

Arguments:

    pAcl - Supplies the ACL being queried

    dwAceIndex - Supplies the Ace index to locate

    pAce - Receives the address of the ACE within the ACL

Return Value:

    Returns TRUE for success, FALSE for failure.  Extended error status
    is available using GetLastError.

--*/
{
    NTSTATUS Status;

    Status = RtlGetAce (
                pAcl,
                dwAceIndex,
                pAce
                );

    if ( !NT_SUCCESS(Status) ) {
        BaseSetLastNTError(Status);
        return FALSE;
    }

    return TRUE;
}

BOOL
APIENTRY
AddAccessAllowedAce (
    PACL pAcl,
    DWORD dwAceRevision,
    DWORD AccessMask,
    PSID pSid
    )
/*++

Routine Description:

    This routine adds an ACCESS_ALLOWED ACE to an ACL.  This is
    expected to be a common form of ACL modification.

    A very bland ACE header is placed in the ACE.  It provides no
    inheritance and no ACE flags.

Arguments:

    PAcl - Supplies the Acl being modified

    dwAceRevision - Supplies the Acl/Ace revision of the ACE being added

    AccessMask - The mask of accesses to be granted to the specified SID.

    pSid - Pointer to the SID being granted access.

Return Value:

    Returns TRUE for success, FALSE for failure.  Extended error status
    is available using GetLastError.

--*/
{
    NTSTATUS Status;

    Status = RtlAddAccessAllowedAce (
                pAcl,
                dwAceRevision,
                AccessMask,
                pSid
                );

    if ( !NT_SUCCESS(Status) ) {
        BaseSetLastNTError(Status);
        return FALSE;
    }

    return TRUE;
}

BOOL
APIENTRY
AddAccessAllowedAceEx (
    PACL pAcl,
    DWORD dwAceRevision,
    DWORD AceFlags,
    DWORD AccessMask,
    PSID pSid
    )
/*++

Routine Description:

    This routine adds an ACCESS_ALLOWED ACE to an ACL.  This is
    expected to be a common form of ACL modification.

    A very bland ACE header is placed in the ACE.  The AceFlags and
    inheritance are specified by the AceFlags parameter.

Arguments:

    PAcl - Supplies the Acl being modified

    dwAceRevision - Supplies the Acl/Ace revision of the ACE being added

    AceFlags - Supplies the inherit flags for the ACE.

    AccessMask - The mask of accesses to be granted to the specified SID.

    pSid - Pointer to the SID being granted access.

Return Value:

    Returns TRUE for success, FALSE for failure.  Extended error status
    is available using GetLastError.

--*/
{
    NTSTATUS Status;

    Status = RtlAddAccessAllowedAceEx (
                pAcl,
                dwAceRevision,
                AceFlags,
                AccessMask,
                pSid
                );

    if ( !NT_SUCCESS(Status) ) {
        if ( Status == STATUS_INVALID_PARAMETER ) {
            SetLastError( ERROR_INVALID_FLAGS );
        } else {
            BaseSetLastNTError(Status);
        }
        return FALSE;
    }

    return TRUE;
}



BOOL
APIENTRY
AddAccessDeniedAce (
    PACL pAcl,
    DWORD dwAceRevision,
    DWORD AccessMask,
    PSID pSid
    )
/*++

Routine Description:

    This routine adds an ACCESS_DENIED ACE to an ACL.  This is
    expected to be a common form of ACL modification.

    A very bland ACE header is placed in the ACE.  It provides no
    inheritance and no ACE flags.


Arguments:

    pAcl - Supplies the Acl being modified

    dwAceRevision - Supplies the Acl/Ace revision of the ACE being added

    AccessMask - The mask of accesses to be denied to the specified SID.

    pSid - Pointer to the SID being denied access.


Return Value:

    Returns TRUE for success, FALSE for failure.  Extended error status
    is available using GetLastError.

--*/
{
    NTSTATUS Status;

    Status = RtlAddAccessDeniedAce (
                pAcl,
                dwAceRevision,
                AccessMask,
                pSid
                );

    if ( !NT_SUCCESS(Status) ) {
        BaseSetLastNTError(Status);
        return FALSE;
    }

    return TRUE;
}



BOOL
APIENTRY
AddAccessDeniedAceEx (
    PACL pAcl,
    DWORD dwAceRevision,
    DWORD AceFlags,
    DWORD AccessMask,
    PSID pSid
    )
/*++

Routine Description:

    This routine adds an ACCESS_DENIED ACE to an ACL.  This is
    expected to be a common form of ACL modification.

    A very bland ACE header is placed in the ACE.  The AceFlags and
    inheritance are specified by the AceFlags parameter.


Arguments:

    pAcl - Supplies the Acl being modified

    dwAceRevision - Supplies the Acl/Ace revision of the ACE being added

    AceFlags - Supplies the inherit flags for the ACE.

    AccessMask - The mask of accesses to be denied to the specified SID.

    pSid - Pointer to the SID being denied access.


Return Value:

    Returns TRUE for success, FALSE for failure.  Extended error status
    is available using GetLastError.

--*/
{
    NTSTATUS Status;

    Status = RtlAddAccessDeniedAceEx (
                pAcl,
                dwAceRevision,
                AceFlags,
                AccessMask,
                pSid
                );

    if ( !NT_SUCCESS(Status) ) {
        if ( Status == STATUS_INVALID_PARAMETER ) {
            SetLastError( ERROR_INVALID_FLAGS );
        } else {
            BaseSetLastNTError(Status);
        }
        return FALSE;
    }

    return TRUE;
}




BOOL
APIENTRY
AddAuditAccessAce(
    PACL pAcl,
    DWORD dwAceRevision,
    DWORD dwAccessMask,
    PSID pSid,
    BOOL bAuditSuccess,
    BOOL bAuditFailure
    )
/*++

Routine Description:

    This routine adds a SYSTEM_AUDIT ACE to an ACL.  This is
    expected to be a common form of ACL modification.

    A very bland ACE header is placed in the ACE.  It provides no
    inheritance.

    Parameters are used to indicate whether auditing is to be performed
    on success, failure, or both.


Arguments:

    pAcl - Supplies the Acl being modified

    dwAceRevision - Supplies the Acl/Ace revision of the ACE being added

    dwAccessMask - The mask of accesses to be denied to the specified SID.

    pSid - Pointer to the SID to be audited.

    bAuditSuccess - If TRUE, indicates successful access attempts are to be
        audited.

    bAuditFailure - If TRUE, indicated failed access attempts are to be
        audited.

Return Value:

    Returns TRUE for success, FALSE for failure.  Extended error status
    is available using GetLastError.

--*/

{
    NTSTATUS Status;

    Status =  RtlAddAuditAccessAce (
                pAcl,
                dwAceRevision,
                dwAccessMask,
                pSid,
                (BOOLEAN)bAuditSuccess,
                (BOOLEAN)bAuditFailure
                );

    if ( !NT_SUCCESS(Status) ) {
        BaseSetLastNTError(Status);
        return FALSE;
    }

    return TRUE;
}

BOOL
APIENTRY
AddAuditAccessAceEx(
    PACL pAcl,
    DWORD dwAceRevision,
    DWORD AceFlags,
    DWORD dwAccessMask,
    PSID pSid,
    BOOL bAuditSuccess,
    BOOL bAuditFailure
    )
/*++

Routine Description:

    This routine adds a SYSTEM_AUDIT ACE to an ACL.  This is
    expected to be a common form of ACL modification.

    A very bland ACE header is placed in the ACE.  The AceFlags and
    inheritance are specified by the AceFlags parameter.

    Parameters are used to indicate whether auditing is to be performed
    on success, failure, or both.


Arguments:

    pAcl - Supplies the Acl being modified

    dwAceRevision - Supplies the Acl/Ace revision of the ACE being added

    AceFlags - Supplies the inherit flags for the ACE.

    dwAccessMask - The mask of accesses to be denied to the specified SID.

    pSid - Pointer to the SID to be audited.

    bAuditSuccess - If TRUE, indicates successful access attempts are to be
        audited.

    bAuditFailure - If TRUE, indicated failed access attempts are to be
        audited.

Return Value:

    Returns TRUE for success, FALSE for failure.  Extended error status
    is available using GetLastError.

--*/

{
    NTSTATUS Status;

    Status =  RtlAddAuditAccessAceEx (
                pAcl,
                dwAceRevision,
                AceFlags,
                dwAccessMask,
                pSid,
                (BOOLEAN)bAuditSuccess,
                (BOOLEAN)bAuditFailure
                );

    if ( !NT_SUCCESS(Status) ) {
        if ( Status == STATUS_INVALID_PARAMETER ) {
            SetLastError( ERROR_INVALID_FLAGS );
        } else {
            BaseSetLastNTError(Status);
        }
        return FALSE;
    }

    return TRUE;
}


BOOL
APIENTRY
AddAccessAllowedObjectAce (
    PACL pAcl,
    DWORD dwAceRevision,
    DWORD AceFlags,
    DWORD AccessMask,
    GUID *ObjectTypeGuid,
    GUID *InheritedObjectTypeGuid,
    PSID pSid
    )
/*++

Routine Description:

    This routine adds an ACCESS_ALLOWED_OBJECT ACE to an ACL.  This is
    expected to be a common form of ACL modification.

    A very bland ACE header is placed in the ACE.

Arguments:

    PAcl - Supplies the Acl being modified

    dwAceRevision - Supplies the Acl/Ace revision of the ACE being added

    AceFlags - Supplies the inherit flags for the ACE.

    AccessMask - The mask of accesses to be granted to the specified SID.

    ObjectTypeGuid - Supplies the GUID of the object this ACE applies to.
        If NULL, no object type GUID is placed in the ACE.

    InheritedObjectTypeGuid - Supplies the GUID of the object type that will
        inherit this ACE.  If NULL, no inherited object type GUID is placed in
        the ACE.

    pSid - Pointer to the SID being granted access.

Return Value:

    Returns TRUE for success, FALSE for failure.  Extended error status
    is available using GetLastError.

--*/
{
    NTSTATUS Status;

    Status = RtlAddAccessAllowedObjectAce (
                pAcl,
                dwAceRevision,
                AceFlags,
                AccessMask,
                ObjectTypeGuid,
                InheritedObjectTypeGuid,
                pSid
                );

    if ( !NT_SUCCESS(Status) ) {
        if ( Status == STATUS_INVALID_PARAMETER ) {
            SetLastError( ERROR_INVALID_FLAGS );
        } else {
            BaseSetLastNTError(Status);
        }
        return FALSE;
    }

    return TRUE;
}

BOOL
APIENTRY
AddAccessDeniedObjectAce (
    PACL pAcl,
    DWORD dwAceRevision,
    DWORD AceFlags,
    DWORD AccessMask,
    GUID *ObjectTypeGuid,
    GUID *InheritedObjectTypeGuid,
    PSID pSid
    )
/*++

Routine Description:

    This routine adds an ACCESS_DENIED_OBJECT ACE to an ACL.  This is
    expected to be a common form of ACL modification.

    A very bland ACE header is placed in the ACE.

Arguments:

    PAcl - Supplies the Acl being modified

    dwAceRevision - Supplies the Acl/Ace revision of the ACE being added

    AceFlags - Supplies the inherit flags for the ACE.

    AccessMask - The mask of accesses to be granted to the specified SID.

    ObjectTypeGuid - Supplies the GUID of the object this ACE applies to.
        If NULL, no object type GUID is placed in the ACE.

    InheritedObjectTypeGuid - Supplies the GUID of the object type that will
        inherit this ACE.  If NULL, no inherited object type GUID is placed in
        the ACE.

    pSid - Pointer to the SID being denied access.

Return Value:

    Returns TRUE for success, FALSE for failure.  Extended error status
    is available using GetLastError.

--*/
{
    NTSTATUS Status;

    Status = RtlAddAccessDeniedObjectAce (
                pAcl,
                dwAceRevision,
                AceFlags,
                AccessMask,
                ObjectTypeGuid,
                InheritedObjectTypeGuid,
                pSid
                );

    if ( !NT_SUCCESS(Status) ) {
        if ( Status == STATUS_INVALID_PARAMETER ) {
            SetLastError( ERROR_INVALID_FLAGS );
        } else {
            BaseSetLastNTError(Status);
        }
        return FALSE;
    }

    return TRUE;
}

BOOL
APIENTRY
AddAuditAccessObjectAce(
    PACL pAcl,
    DWORD dwAceRevision,
    DWORD AceFlags,
    DWORD dwAccessMask,
    GUID *ObjectTypeGuid,
    GUID *InheritedObjectTypeGuid,
    PSID pSid,
    BOOL bAuditSuccess,
    BOOL bAuditFailure
    )
/*++

Routine Description:

    This routine adds a SYSTEM_AUDIT_OBJECT_ACE to an ACL.  This is
    expected to be a common form of ACL modification.

    A very bland ACE header is placed in the ACE.  The AceFlags and
    inheritance are specified by the AceFlags parameter.

    Parameters are used to indicate whether auditing is to be performed
    on success, failure, or both.


Arguments:

    pAcl - Supplies the Acl being modified

    dwAceRevision - Supplies the Acl/Ace revision of the ACE being added

    AceFlags - Supplies the inherit flags for the ACE.

    dwAccessMask - The mask of accesses to be denied to the specified SID.

    ObjectTypeGuid - Supplies the GUID of the object this ACE applies to.
        If NULL, no object type GUID is placed in the ACE.

    InheritedObjectTypeGuid - Supplies the GUID of the object type that will
        inherit this ACE.  If NULL, no inherited object type GUID is placed in
        the ACE.

    pSid - Pointer to the SID to be audited.

    bAuditSuccess - If TRUE, indicates successful access attempts are to be
        audited.

    bAuditFailure - If TRUE, indicated failed access attempts are to be
        audited.

Return Value:

    Returns TRUE for success, FALSE for failure.  Extended error status
    is available using GetLastError.

--*/

{
    NTSTATUS Status;

    Status =  RtlAddAuditAccessObjectAce (
                pAcl,
                dwAceRevision,
                AceFlags,
                dwAccessMask,
                ObjectTypeGuid,
                InheritedObjectTypeGuid,
                pSid,
                (BOOLEAN)bAuditSuccess,
                (BOOLEAN)bAuditFailure
                );

    if ( !NT_SUCCESS(Status) ) {
        if ( Status == STATUS_INVALID_PARAMETER ) {
            SetLastError( ERROR_INVALID_FLAGS );
        } else {
            BaseSetLastNTError(Status);
        }
        return FALSE;
    }

    return TRUE;
}




BOOL
APIENTRY
FindFirstFreeAce (
    PACL pAcl,
    PVOID *pAce
    )
/*++

Routine Description:

    This routine returns a pointer to the first free byte in an Acl
    or NULL if the acl is ill-formed.  If the Acl is full then the
    return pointer is to the byte immediately following the acl, and
    TRUE will be returned.

Arguments:

    pAcl - Supplies a pointer to the Acl to examine

    pAce - Receives a pointer to the first free position in the Acl

Return Value:

    Returns TRUE for success, FALSE for failure.  Extended error status
    is available using GetLastError.

--*/
{
    if ( !RtlFirstFreeAce( pAcl, pAce ) ) {
        SetLastError(ERROR_INVALID_ACL);
        return FALSE;
    }
    return TRUE;
}

BOOL
APIENTRY
InitializeSecurityDescriptor (
    PSECURITY_DESCRIPTOR pSecurityDescriptor,
    DWORD dwRevision
    )
/*++

Routine Description:

    This procedure initializes a new "absolute format" security descriptor.
    After the procedure call the security descriptor is initialized with no
    system ACL, no discretionary ACL, no owner, no primary group and
    all control flags set to false (null).

Arguments:


    pSecurityDescriptor - Supplies the security descriptor to
        initialize.

    dwRevision - Provides the revision level to assign to the security
        descriptor.  This should be one (1) for this release.

Return Value:

    Returns TRUE for success, FALSE for failure.  Extended error status
    is available using GetLastError.

--*/
{
    NTSTATUS Status;

    Status = RtlCreateSecurityDescriptor (
                pSecurityDescriptor,
                dwRevision
                );

    if ( !NT_SUCCESS(Status) ) {
        BaseSetLastNTError(Status);
        return FALSE;
    }

    return TRUE;
}




BOOL
APIENTRY
IsValidSecurityDescriptor (
    PSECURITY_DESCRIPTOR pSecurityDescriptor
    )
/*++

Routine Description:

    This procedure validates a SecurityDescriptor's structure.  This
    involves validating the revision levels of each component of the
    security descriptor.

Arguments:

    pSecurityDescriptor - Pointer to the SECURITY_DESCRIPTOR structure
        to validate.

Return Value:

    BOOL - TRUE if the structure of SecurityDescriptor is valid.


--*/
{
    if (!RtlValidSecurityDescriptor ( pSecurityDescriptor )) {
        BaseSetLastNTError( STATUS_INVALID_SECURITY_DESCR );
        return( FALSE );
    }

    return( TRUE );
}




DWORD
APIENTRY
GetSecurityDescriptorLength (
    PSECURITY_DESCRIPTOR pSecurityDescriptor
    )
/*++

Routine Description:

    This routine returns the length, in bytes, necessary to capture a
    structurally valid SECURITY_DESCRIPTOR.  The length includes the length
    of all associated data structures (like SIDs and ACLs).  The length also
    takes into account the alignment requirements of each component.

    The minimum length of a security descriptor (one which has no associated
    SIDs or ACLs) is SECURITY_DESCRIPTOR_MIN_LENGTH.


Arguments:

    pSecurityDescriptor - Points to the SECURITY_DESCRIPTOR whose
        length is to be returned.  The SECURITY_DESCRIPTOR's structure
        is assumed to be valid.

Return Value:

    DWORD - The length, in bytes, of the SECURITY_DESCRIPTOR.


--*/
{
    return RtlLengthSecurityDescriptor (
        pSecurityDescriptor
        );
}





BOOL
APIENTRY
GetSecurityDescriptorControl (
    PSECURITY_DESCRIPTOR pSecurityDescriptor,
    PSECURITY_DESCRIPTOR_CONTROL pControl,
    LPDWORD lpdwRevision
    )
/*++

Routine Description:

    This procedure retrieves the control information from a security descriptor.

Arguments:

    pSecurityDescriptor - Supplies the security descriptor.

    pControl - Receives the control information.

    lpdwRevision - Receives the revision of the security descriptor.
        This value will always be returned, even if an error is
        returned by this routine.

Return Value:

    Returns TRUE for success, FALSE for failure.  Extended error status
    is available using GetLastError.

--*/
{
    NTSTATUS Status;

    Status = RtlGetControlSecurityDescriptor (
                pSecurityDescriptor,
                pControl,
                lpdwRevision
                );

    if ( !NT_SUCCESS(Status) ) {
        BaseSetLastNTError(Status);
        return FALSE;
    }

    return TRUE;
}

BOOL
APIENTRY
SetSecurityDescriptorControl (
    PSECURITY_DESCRIPTOR pSecurityDescriptor,
    SECURITY_DESCRIPTOR_CONTROL ControlBitsOfInterest,
    SECURITY_DESCRIPTOR_CONTROL ControlBitsToSet
    )
/*++

Routine Description:

    This procedure sets the control information in a security descriptor.


    For instance,

        SetSecurityDescriptorControl( &SecDesc,
                                      SE_DACL_PROTECTED,
                                      SE_DACL_PROTECTED );

    marks the DACL on the security descriptor as protected. And

        SetSecurityDescriptorControl( &SecDesc,
                                      SE_DACL_PROTECTED,
                                      0 );


    marks the DACL as not protected.

Arguments:

    pSecurityDescriptor - Supplies the security descriptor.

    ControlBitsOfInterest - A mask of the control bits being changed, set,
        or reset by this call.  The mask is the logical OR of one or more of
        the following flags:

            SE_DACL_UNTRUSTED
            SE_SERVER_SECURITY
            SE_DACL_AUTO_INHERIT_REQ
            SE_SACL_AUTO_INHERIT_REQ
            SE_DACL_AUTO_INHERITED
            SE_SACL_AUTO_INHERITED
            SE_DACL_PROTECTED
            SE_SACL_PROTECTED

    ControlBitsToSet - A mask indicating what the bits specified by ControlBitsOfInterest
        should be set to.

Return Value:

    Returns TRUE for success, FALSE for failure.  Extended error status
    is available using GetLastError.

--*/
{
    NTSTATUS Status;

    Status = RtlSetControlSecurityDescriptor (
                pSecurityDescriptor,
                ControlBitsOfInterest,
                ControlBitsToSet );

    if ( !NT_SUCCESS(Status) ) {
        BaseSetLastNTError(Status);
        return FALSE;
    }

    return TRUE;
}




BOOL
APIENTRY
SetSecurityDescriptorDacl (
    PSECURITY_DESCRIPTOR pSecurityDescriptor,
    BOOL bDaclPresent,
    PACL pDacl OPTIONAL,
    BOOL bDaclDefaulted OPTIONAL
    )
/*++

Routine Description:

    This procedure sets the discretionary ACL information of an absolute
    format security descriptor.  If there is already a discretionary ACL
    present in the security descriptor, it is superseded.

Arguments:

    pSecurityDescriptor - Supplies the security descriptor to be which
        the discretionary ACL is to be added.

    bDaclPresent - If FALSE, indicates the DaclPresent flag in the
        security descriptor should be set to FALSE.  In this case, the
        remaining optional parameters are ignored.  Otherwise, the
        DaclPresent control flag in the security descriptor is set to
        TRUE and the remaining optional parameters are not ignored.

    pDacl - Supplies the discretionary ACL for the security
        descriptor.  If this optional parameter is not passed, then a
        null ACL is assigned to the security descriptor.  A null
        discretionary ACL unconditionally grants access.  The ACL is
        referenced by, not copied into, by the security descriptor.

    bDaclDefaulted - When set, indicates the discretionary ACL was
        picked up from some default mechanism (rather than explicitly
        specified by a user).  This value is set in the DaclDefaulted
        control flag in the security descriptor.  If this optional
        parameter is not passed, then the DaclDefaulted flag will be
        cleared.

Return Value:

    Returns TRUE for success, FALSE for failure.  Extended error status
    is available using GetLastError.

--*/
{
    NTSTATUS Status;

    Status = RtlSetDaclSecurityDescriptor (
        pSecurityDescriptor,
        (BOOLEAN)bDaclPresent,
        pDacl,
        (BOOLEAN)bDaclDefaulted
        );

    if ( !NT_SUCCESS(Status) ) {
        BaseSetLastNTError(Status);
        return FALSE;
    }

    return TRUE;
}



BOOL
APIENTRY
GetSecurityDescriptorDacl (
    PSECURITY_DESCRIPTOR pSecurityDescriptor,
    LPBOOL lpbDaclPresent,
    PACL *pDacl,
    LPBOOL lpbDaclDefaulted
    )
/*++

Routine Description:

    This procedure retrieves the discretionary ACL information of a
    security descriptor.

Arguments:

    pSecurityDescriptor - Supplies the security descriptor.

    lpbDaclPresent - If TRUE, indicates that the security descriptor
        does contain a discretionary ACL.  In this case, the
        remaining OUT parameters will receive valid values.
        Otherwise, the security descriptor does not contain a
        discretionary ACL and the remaining OUT parameters will not
        receive valid values.

    pDacl - This value is returned only if the value returned for the
        DaclPresent flag is TRUE.  In this case, the Dacl parameter
        receives the address of the security descriptor's
        discretionary ACL.  If this value is returned as null, then
        the security descriptor has a null discretionary ACL.

    lpbDaclDefaulted - This value is returned only if the value
        returned for the DaclPresent flag is TRUE.  In this case, the
        DaclDefaulted parameter receives the value of the security
        descriptor's DaclDefaulted control flag.

Return Value:

    Returns TRUE for success, FALSE for failure.  Extended error status
    is available using GetLastError.

--*/
{
    NTSTATUS Status;
    BOOLEAN DaclPresent, DaclDefaulted;

    Status = RtlGetDaclSecurityDescriptor (
        pSecurityDescriptor,
        &DaclPresent,
        pDacl,
        &DaclDefaulted
        );

    if ( !NT_SUCCESS(Status) ) {
        BaseSetLastNTError(Status);
        return FALSE;
    } else {
        *lpbDaclPresent = (BOOL)DaclPresent;
        *lpbDaclDefaulted = (BOOL)DaclDefaulted;
    }

    return TRUE;
}




BOOL
APIENTRY
SetSecurityDescriptorSacl (
    PSECURITY_DESCRIPTOR pSecurityDescriptor,
    BOOL bSaclPresent,
    PACL pSacl OPTIONAL,
    BOOL bSaclDefaulted
    )
/*++

Routine Description:

    This procedure sets the system ACL information of an absolute security
    descriptor.  If there is already a system ACL present in the
    security descriptor, it is superseded.

Arguments:

    pSecurityDescriptor - Supplies the security descriptor to be which
        the system ACL is to be added.

    bSaclPresent - If FALSE, indicates the SaclPresent flag in the
        security descriptor should be set to FALSE.  In this case,
        the remaining optional parameters are ignored.  Otherwise,
        the SaclPresent control flag in the security descriptor is
        set to TRUE and the remaining optional parameters are not
        ignored.

    pSacl - Supplies the system ACL for the security descriptor.  If
        this optional parameter is not passed, then a null ACL is
        assigned to the security descriptor.  The ACL is referenced
        by, not copied into, by the security descriptor.

    bSaclDefaulted - When set, indicates the system ACL was picked up
        from some default mechanism (rather than explicitly specified
        by a user).  This value is set in the SaclDefaulted control
        flag in the security descriptor.  If this optional parameter
        is not passed, then the SaclDefaulted flag will be cleared.

Return Value:

    Returns TRUE for success, FALSE for failure.  Extended error status
    is available using GetLastError.

--*/
{
    NTSTATUS Status;

    Status = RtlSetSaclSecurityDescriptor (
                pSecurityDescriptor,
                (BOOLEAN)bSaclPresent,
                pSacl,
                (BOOLEAN)bSaclDefaulted
                );

    if ( !NT_SUCCESS(Status) ) {
        BaseSetLastNTError(Status);
        return FALSE;
    }

    return TRUE;
}




BOOL
APIENTRY
GetSecurityDescriptorSacl (
    PSECURITY_DESCRIPTOR pSecurityDescriptor,
    LPBOOL lpbSaclPresent,
    PACL *pSacl,
    LPBOOL lpbSaclDefaulted
    )
/*++

Routine Description:

    This procedure retrieves the system ACL information of a security
    descriptor.

Arguments:

    pSecurityDescriptor - Supplies the security descriptor.

    lpbSaclPresent - If TRUE, indicates that the security descriptor
        does contain a system ACL.  In this case, the remaining OUT
        parameters will receive valid values.  Otherwise, the
        security descriptor does not contain a system ACL and the
        remaining OUT parameters will not receive valid values.

    pSacl - This value is returned only if the value returned for the
        SaclPresent flag is TRUE.  In this case, the Sacl parameter
        receives the address of the security descriptor's system ACL.
        If this value is returned as null, then the security
        descriptor has a null system ACL.

    lpbSaclDefaulted - This value is returned only if the value
        returned for the SaclPresent flag is TRUE.  In this case, the
        SaclDefaulted parameter receives the value of the security
        descriptor's SaclDefaulted control flag.

Return Value:

    Returns TRUE for success, FALSE for failure.  Extended error status
    is available using GetLastError.

--*/
{
    NTSTATUS Status;
    BOOLEAN SaclPresent, SaclDefaulted;

    Status = RtlGetSaclSecurityDescriptor (
        pSecurityDescriptor,
        &SaclPresent,
        pSacl,
        &SaclDefaulted
        );

    if ( !NT_SUCCESS(Status) ) {
        BaseSetLastNTError(Status);
        return FALSE;
    } else {
        *lpbSaclPresent = (BOOL)SaclPresent;
        *lpbSaclDefaulted = (BOOL)SaclDefaulted;
    }

    return TRUE;
}




BOOL
APIENTRY
SetSecurityDescriptorOwner (
    PSECURITY_DESCRIPTOR pSecurityDescriptor,
    PSID pOwner OPTIONAL,
    BOOL bOwnerDefaulted OPTIONAL
    )
/*++

Routine Description:

    This procedure sets the owner information of an absolute security
    descriptor.  If there is already an owner present in the security
    descriptor, it is superseded.

Arguments:

    pSecurityDescriptor - Supplies the security descriptor in which
        the owner is to be set.  If the security descriptor already
        includes an owner, it will be superseded by the new owner.

    pOwner - Supplies the owner SID for the security descriptor.  If
        this optional parameter is not passed, then the owner is
        cleared (indicating the security descriptor has no owner).
        The SID is referenced by, not copied into, the security
        descriptor.

    bOwnerDefaulted - When set, indicates the owner was picked up from
        some default mechanism (rather than explicitly specified by a
        user).  This value is set in the OwnerDefaulted control flag
        in the security descriptor.  If this optional parameter is
        not passed, then the SaclDefaulted flag will be cleared.

Return Value:

    Returns TRUE for success, FALSE for failure.  Extended error status
    is available using GetLastError.


--*/
{
    NTSTATUS Status;

    Status = RtlSetOwnerSecurityDescriptor (
        pSecurityDescriptor,
        pOwner,
        (BOOLEAN)bOwnerDefaulted
        );

    if ( !NT_SUCCESS(Status) ) {
        BaseSetLastNTError(Status);
        return FALSE;
    }

    return TRUE;
}

BOOL
APIENTRY
GetSecurityDescriptorOwner (
    PSECURITY_DESCRIPTOR pSecurityDescriptor,
    PSID *pOwner,
    LPBOOL lpbOwnerDefaulted
    )
/*++

Routine Description:

    This procedure retrieves the owner information of a security
    descriptor.

Arguments:

    pSecurityDescriptor - Supplies the security descriptor.

    pOwner - Receives a pointer to the owner SID.  If the security
        descriptor does not currently contain an owner, then this
        value will be returned as null.  In this case, the remaining
        OUT parameters are not given valid return values.  Otherwise,
        this parameter points to an SID and the remaining OUT
        parameters are provided valid return values.

    lpbOwnerDefaulted - This value is returned only if the value
        returned for the Owner parameter is not null.  In this case,
        the OwnerDefaulted parameter receives the value of the
        security descriptor's OwnerDefaulted control flag.

Return Value:

    Returns TRUE for success, FALSE for failure.  Extended error status
    is available using GetLastError.

--*/
{
    NTSTATUS Status;
    BOOLEAN OwnerDefaulted;

    Status = RtlGetOwnerSecurityDescriptor (
        pSecurityDescriptor,
        pOwner,
        &OwnerDefaulted
        );

    if ( !NT_SUCCESS(Status) ) {
        BaseSetLastNTError(Status);
        return FALSE;
    } else {
        *lpbOwnerDefaulted = (BOOL)OwnerDefaulted;
    }

    return TRUE;
}




BOOL
APIENTRY
SetSecurityDescriptorGroup (
    PSECURITY_DESCRIPTOR pSecurityDescriptor,
    PSID pGroup OPTIONAL,
    BOOL bGroupDefaulted OPTIONAL
    )
/*++

Routine Description:

    This procedure sets the primary group information of an absolute security
    descriptor.  If there is already an primary group present in the
    security descriptor, it is superseded.

Arguments:

    pSecurityDescriptor - Supplies the security descriptor in which
        the primary group is to be set.  If the security descriptor
        already includes a primary group, it will be superseded by
        the new group.

    pGroup - Supplies the primary group SID for the security
        descriptor.  If this optional parameter is not passed, then
        the primary group is cleared (indicating the security
        descriptor has no primary group).  The SID is referenced by,
        not copied into, the security descriptor.

    bGroupDefaulted - When set, indicates the owner was picked up from
        some default mechanism (rather than explicitly specified by a
        user).  This value is set in the OwnerDefaulted control flag
        in the security descriptor.  If this optional parameter is
        not passed, then the SaclDefaulted flag will be cleared.

Return Value:

    Returns TRUE for success, FALSE for failure.  Extended error status
    is available using GetLastError.

--*/
{
    NTSTATUS Status;

    Status = RtlSetGroupSecurityDescriptor (
        pSecurityDescriptor,
        pGroup,
        (BOOLEAN)bGroupDefaulted
        );

    if ( !NT_SUCCESS(Status) ) {
        BaseSetLastNTError(Status);
        return FALSE;
    }

    return TRUE;
}




BOOL
APIENTRY
GetSecurityDescriptorGroup (
    PSECURITY_DESCRIPTOR pSecurityDescriptor,
    PSID *pGroup,
    LPBOOL lpbGroupDefaulted
    )
/*++

Routine Description:

    This procedure retrieves the primary group information of a
    security descriptor.

Arguments:

    pSecurityDescriptor - Supplies the security descriptor.

    pGroup - Receives a pointer to the primary group SID.  If the
        security descriptor does not currently contain a primary
        group, then this value will be returned as null.  In this
        case, the remaining OUT parameters are not given valid return
        values.  Otherwise, this parameter points to an SID and the
        remaining OUT parameters are provided valid return values.

    lpbGroupDefaulted - This value is returned only if the value
        returned for the Group parameter is not null.  In this case,
        the GroupDefaulted parameter receives the value of the
        security descriptor's GroupDefaulted control flag.

Return Value:

    Returns TRUE for success, FALSE for failure.  Extended error status
    is available using GetLastError.

--*/
{
    NTSTATUS Status;
    BOOLEAN GroupDefaulted;

    Status = RtlGetGroupSecurityDescriptor (
        pSecurityDescriptor,
        pGroup,
        &GroupDefaulted
        );

    if ( !NT_SUCCESS(Status) ) {
        BaseSetLastNTError(Status);
        return FALSE;
    } else {
        *lpbGroupDefaulted = GroupDefaulted;
    }

    return TRUE;
}




BOOL
APIENTRY
CreatePrivateObjectSecurity (
    PSECURITY_DESCRIPTOR ParentDescriptor OPTIONAL,
    PSECURITY_DESCRIPTOR CreatorDescriptor OPTIONAL,
    PSECURITY_DESCRIPTOR * NewDescriptor,
    BOOL IsDirectoryObject,
    HANDLE Token,
    PGENERIC_MAPPING GenericMapping
    )
/*++

Routine Description:

    The procedure is used to allocpate and initialize a self-relative
    Security Descriptor for a new protected server's object.  It is called
    when a new protected server object is being created.  The generated
    security descriptor will be in self-relative form.

    This procedure, called only from user mode, is used to establish a
    security descriptor for a new protected server's object.  When no
    longer needed, this descriptor must be freed using
    DestroyPrivateObjectSecurity().

Arguments:

    ParentDescriptor - Supplies the Security Descriptor for the parent
        directory under which a new object is being created.  If there is
        no parent directory, then this argument is specified as NULL.

    CreatorDescriptor - (Optionally) Points to a security descriptor
        presented by the creator of the object.  If the creator of the
        object did not explicitly pass security information for the new
        object, then a null pointer should be passed.

    NewDescriptor - Points to a pointer that is to be made to point to the
        newly allocated self-relative security descriptor.

    IsDirectoryObject - Specifies if the new object is going to be a
        directory object.  A value of TRUE indicates the object is a
        container of other objects.

    Token - Supplies the token for the client on whose behalf the
        object is being created.  If it is an impersonation token,
        then it must be at SecurityIdentification level or higher.  If
        it is not an impersonation token, the operation proceeds
        normally.

        A client token is used to retrieve default security
        information for the new object, such as default owner, primary
        group, and discretionary access control.  The token must be
        open for TOKEN_QUERY access.

    GenericMapping - Supplies a pointer to a generic mapping array denoting
        the mapping between each generic right to specific rights.

Return Value:

    Returns TRUE for success, FALSE for failure.  Extended error status
    is available using GetLastError.

--*/
{
    NTSTATUS Status;

    Status = RtlNewSecurityObject (
        ParentDescriptor,
        CreatorDescriptor,
        NewDescriptor,
        (BOOLEAN)IsDirectoryObject,
        Token,
        GenericMapping
        );

    if ( !NT_SUCCESS(Status) ) {
        BaseSetLastNTError(Status);
        return FALSE;
    }

    return TRUE;
}



BOOL
APIENTRY
ConvertToAutoInheritPrivateObjectSecurity(
    PSECURITY_DESCRIPTOR ParentDescriptor OPTIONAL,
    PSECURITY_DESCRIPTOR CurrentSecurityDescriptor,
    PSECURITY_DESCRIPTOR *NewSecurityDescriptor,
    GUID *ObjectType,
    BOOLEAN IsDirectoryObject,
    PGENERIC_MAPPING GenericMapping
    )
/*++

Routine Description:

    This is a converts a security descriptor whose ACLs are not marked
    as AutoInherit to a security descriptor whose ACLs are marked as
    AutoInherit.

    The resultant security descriptor has appropriate ACEs marked as
    INHERITED_ACE if the ACE was apparently inherited from the ParentDescriptor.
    If the ACL is apparently not inherited from the ParentDescriptor, the
    ACL in the resultant security descriptor is marked as SE_xACL_PROTECTED.

    This routine takes into account the various mechanisms for creating an
    inherited ACL:

    1) It was inherited via NT 3.x or 4.x ACL inheritance when the
    object was created.

    2) The subsequent parent or child ACL was re-written by the ACL editor
    (which perversely modifies the ACL to a semantically equivalent but
    different form).

    3) It was inherited by asking the ACL editor (File Manager/Explorer) to
    "Replace permissions on existing files/directories".

    4) It was inherited via cacls.exe.

    If the ACLs in the resultant security descriptor are not marked as protected, the
    resultant ACL is composed of two sets of ACEs: the non-inherited ACEs followed by the
    inherited ACEs.  The inherited ACEs are computed by called CreatePrivateObjectSecurityEx
    using the ParentDescriptor.  The non-inherited ACEs are those ACEs (or parts of ACEs)
    from the original CurrentSecurityDescriptor that were not inherited from the parent.

    When building the resultant NewSecurityDescriptor, care is taken to not change the
    semantics of the security descriptor.  As such, allow and deny ACEs are never moved
    in relation to one another.  If such movement is needed (for instance to place all
    non-inherited ACEs at the front of an ACL), the ACL is marked as protected to prevent
    the semantic change.

    ACEs in the original CurrentSecurityDescriptor are matched with ACEs in a computed
    inherited security descriptor to determine which ACEs were inherited.  During the
    comparision there is no requirement of a one to one match.  For instance, one ACL
    might use separate ACEs to grant a user read and write access while the other ACL
    might use only one ACE to grant the same access.  Or one ACL might grant the user
    the same access twice and the other might grant the user that access only once.  Or
    one ACL might combine the container inherit and object inherit ACE into a single ACE.
    In all these case, equivalent ACE combinations are deemed equivalent.

    No security checks are made in this routine.  The resultant security descriptor
    is equivalent to the new security descriptor, so the caller needs no permission to
    update the security descriptor to the new form.

    The Owner and Group field of the CurrentSecurityDescriptor is maintained.

    This routine support revision 2 and revision 4 ACLs.  It does not support compound
    ACEs.

Arguments:

    ParentDescriptor - Supplies the Security Descriptor for the parent
        directory under which a object exists.  If there is
        no parent directory, then this argument is specified as NULL.

    CurrentSecurityDescriptor - Supplies a pointer to the objects security descriptor
        that is going to be altered by this procedure.

    NewSecurityDescriptor Points to a pointer that is to be made to point to the
        newly allocated self-relative security descriptor. When no
        longer needed, this descriptor must be freed using
        DestroyPrivateObjectSecurity().

    ObjectType - GUID of the object type being created.  If the object being
        created has no GUID associated with it, then this argument is
        specified as NULL.

    IsDirectoryObject - Specifies if the object is a
        directory object.  A value of TRUE indicates the object is a
        container of other objects.

    GenericMapping - Supplies a pointer to a generic mapping array denoting
        the mapping between each generic right to specific rights.

Return Value:

    Returns TRUE for success, FALSE for failure.  Extended error status
    is available using GetLastError.

--*/
{
    NTSTATUS Status;

    Status = RtlConvertToAutoInheritSecurityObject(
                ParentDescriptor,
                CurrentSecurityDescriptor,
                NewSecurityDescriptor,
                ObjectType,
                IsDirectoryObject,
                GenericMapping ) ;

    if ( !NT_SUCCESS(Status) ) {
        BaseSetLastNTError(Status);
        return FALSE;
    }

    return TRUE;
}




BOOL
APIENTRY
CreatePrivateObjectSecurityEx (
    PSECURITY_DESCRIPTOR ParentDescriptor,
    PSECURITY_DESCRIPTOR CreatorDescriptor,
    PSECURITY_DESCRIPTOR * NewDescriptor,
    GUID *ObjectType,
    BOOL IsContainerObject,
    ULONG AutoInheritFlags,
    HANDLE Token,
    PGENERIC_MAPPING GenericMapping
    )
/*++

Routine Description:

    The procedure is used to allocate and initialize a self-relative
    Security Descriptor for a new protected server's object.  It is called
    when a new protected server object is being created. The generated
    security descriptor will be in self-relative form.

    This procedure, called only from user mode, is used to establish a
    security descriptor for a new protected server's object.
Arguments:

    ParentDescriptor - Supplies the Security Descriptor for the parent
        directory under which a new object is being created.  If there is
        no parent directory, then this argument is specified as NULL.

    CreatorDescriptor - (Optionally) Points to a security descriptor
        presented by the creator of the object.  If the creator of the
        object did not explicitly pass security information for the new
        object, then a null pointer should be passed.

    NewDescriptor - Points to a pointer that is to be made to point to the
        newly allocated self-relative security descriptor. When no
        longer needed, this descriptor must be freed using
        DestroyPrivateObjectSecurity().

    ObjectType - GUID of the object type being created.  If the object being
        created has no GUID associated with it, then this argument is
        specified as NULL.

    IsContainerObject - Specifies if the new object is going to be a
        container object.  A value of TRUE indicates the object is a
        container of other objects.

    AutoInheritFlags - Controls automatic inheritance of ACES from the Parent
        Descriptor.  Valid values are a bits mask of the logical OR of
        one or more of the following bits:

        SEF_DACL_AUTO_INHERIT - If set, inherit ACEs from the
            DACL ParentDescriptor are inherited to NewDescriptor in addition
            to any explicit ACEs specified by the CreatorDescriptor.

        SEF_SACL_AUTO_INHERIT - If set, inherit ACEs from the
            SACL ParentDescriptor are inherited to NewDescriptor in addition
            to any explicit ACEs specified by the CreatorDescriptor.

        SEF_DEFAULT_DESCRIPTOR_FOR_OBJECT - If set, the CreatorDescriptor
            is the default descriptor for ObjectType.  As such, the
            CreatorDescriptor will be ignored if any ObjectType specific
            ACEs are inherited from the parent.  If not such ACEs are inherited,
            the CreatorDescriptor is handled as though this flag were not
            specified.

        SEF_AVOID_PRIVILEGE_CHECK - If set, no privilege checking is done by this
            routine.  This flag is useful while implementing automatic inheritance
            to avoid checking privileges on each child updated.

        SEF_AVOID_OWNER_CHECK - If set, no owner checking is done by this routine.

        SEF_DEFAULT_OWNER_FROM_PARENT - If set, the owner of NewDescriptor will
            default to the owner from ParentDescriptor.  If not set, the owner
            of NewDescriptor will default to the user specified in Token.

            In either case, the owner of NewDescriptor is set to the owner from
            the CreatorDescriptor if that field is specified.

        SEF_DEFAULT_GROUP_FROM_PARENT - If set, the group of NewDescriptor will
            default to the group from ParentDescriptor.  If not set, the group
            of NewDescriptor will default to the group specified in Token.

            In either case, the group of NewDescriptor is set to the group from
            the CreatorDescriptor if that field is specified.


    Token - Supplies the token for the client on whose behalf the
        object is being created.  If it is an impersonation token,
        then it must be at SecurityIdentification level or higher.  If
        it is not an impersonation token, the operation proceeds
        normally.

        A client token is used to retrieve default security
        information for the new object, such as default owner, primary
        group, and discretionary access control.  The token must be
        open for TOKEN_QUERY access.

    GenericMapping - Supplies a pointer to a generic mapping array denoting
        the mapping between each generic right to specific rights.

Return Value:

    Returns TRUE for success, FALSE for failure.  Extended error status
    is available using GetLastError.

--*/
{
    NTSTATUS Status;

    Status = RtlNewSecurityObjectEx (
        ParentDescriptor,
        CreatorDescriptor,
        NewDescriptor,
        ObjectType,
        (BOOLEAN)IsContainerObject,
        AutoInheritFlags,
        Token,
        GenericMapping
        );

    if ( !NT_SUCCESS(Status) ) {
        BaseSetLastNTError(Status);
        return FALSE;
    }

    return TRUE;
}



BOOL
APIENTRY
CreatePrivateObjectSecurityWithMultipleInheritance (
    PSECURITY_DESCRIPTOR ParentDescriptor,
    PSECURITY_DESCRIPTOR CreatorDescriptor,
    PSECURITY_DESCRIPTOR * NewDescriptor,
    GUID **ObjectTypes,
    ULONG GuidCount,
    BOOL IsContainerObject,
    ULONG AutoInheritFlags,
    HANDLE Token,
    PGENERIC_MAPPING GenericMapping
    )
/*++

Routine Description:

    The procedure is used to allocate and initialize a self-relative
    Security Descriptor for a new protected server's object.  It is called
    when a new protected server object is being created. The generated
    security descriptor will be in self-relative form.

    This procedure, called only from user mode, is used to establish a
    security descriptor for a new protected server's object.
Arguments:

    ParentDescriptor - Supplies the Security Descriptor for the parent
        directory under which a new object is being created.  If there is
        no parent directory, then this argument is specified as NULL.

    CreatorDescriptor - (Optionally) Points to a security descriptor
        presented by the creator of the object.  If the creator of the
        object did not explicitly pass security information for the new
        object, then a null pointer should be passed.

    NewDescriptor - Points to a pointer that is to be made to point to the
        newly allocated self-relative security descriptor. When no
        longer needed, this descriptor must be freed using
        DestroyPrivateObjectSecurity().

    ObjectTypes - List of GUIDs of the object type being created.  If the object being
        created has no GUID associated with it, then this argument is
        specified as NULL.

    GuidCount - Number of guids present in the list.

    IsContainerObject - Specifies if the new object is going to be a
        container object.  A value of TRUE indicates the object is a
        container of other objects.

    AutoInheritFlags - Controls automatic inheritance of ACES from the Parent
        Descriptor.  Valid values are a bits mask of the logical OR of
        one or more of the following bits:

        SEF_DACL_AUTO_INHERIT - If set, inherit ACEs from the
            DACL ParentDescriptor are inherited to NewDescriptor in addition
            to any explicit ACEs specified by the CreatorDescriptor.

        SEF_SACL_AUTO_INHERIT - If set, inherit ACEs from the
            SACL ParentDescriptor are inherited to NewDescriptor in addition
            to any explicit ACEs specified by the CreatorDescriptor.

        SEF_DEFAULT_DESCRIPTOR_FOR_OBJECT - If set, the CreatorDescriptor
            is the default descriptor for ObjectType.  As such, the
            CreatorDescriptor will be ignored if any ObjectType specific
            ACEs are inherited from the parent.  If not such ACEs are inherited,
            the CreatorDescriptor is handled as though this flag were not
            specified.

        SEF_AVOID_PRIVILEGE_CHECK - If set, no privilege checking is done by this
            routine.  This flag is useful while implementing automatic inheritance
            to avoid checking privileges on each child updated.

        SEF_AVOID_OWNER_CHECK - If set, no owner checking is done by this routine.

        SEF_DEFAULT_OWNER_FROM_PARENT - If set, the owner of NewDescriptor will
            default to the owner from ParentDescriptor.  If not set, the owner
            of NewDescriptor will default to the user specified in Token.

            In either case, the owner of NewDescriptor is set to the owner from
            the CreatorDescriptor if that field is specified.

        SEF_DEFAULT_GROUP_FROM_PARENT - If set, the group of NewDescriptor will
            default to the group from ParentDescriptor.  If not set, the group
            of NewDescriptor will default to the group specified in Token.

            In either case, the group of NewDescriptor is set to the group from
            the CreatorDescriptor if that field is specified.


    Token - Supplies the token for the client on whose behalf the
        object is being created.  If it is an impersonation token,
        then it must be at SecurityIdentification level or higher.  If
        it is not an impersonation token, the operation proceeds
        normally.

        A client token is used to retrieve default security
        information for the new object, such as default owner, primary
        group, and discretionary access control.  The token must be
        open for TOKEN_QUERY access.

    GenericMapping - Supplies a pointer to a generic mapping array denoting
        the mapping between each generic right to specific rights.

Return Value:

    Returns TRUE for success, FALSE for failure.  Extended error status
    is available using GetLastError.

--*/
{
    NTSTATUS Status;

    Status = RtlNewSecurityObjectWithMultipleInheritance (
        ParentDescriptor,
        CreatorDescriptor,
        NewDescriptor,
        ObjectTypes,
        GuidCount,
        (BOOLEAN)IsContainerObject,
        AutoInheritFlags,
        Token,
        GenericMapping
        );

    if ( !NT_SUCCESS(Status) ) {
        BaseSetLastNTError(Status);
        return FALSE;
    }

    return TRUE;
}




BOOL
APIENTRY
SetPrivateObjectSecurity (
    SECURITY_INFORMATION SecurityInformation,
    PSECURITY_DESCRIPTOR ModificationDescriptor,
    PSECURITY_DESCRIPTOR *ObjectsSecurityDescriptor,
    PGENERIC_MAPPING GenericMapping,
    HANDLE Token OPTIONAL
    )
/*++

Routine Description:

    Modify an object's existing self-relative form security descriptor.

    This procedure, called only from user mode, is used to update a
    security descriptor on an existing protected server's object.  It
    applies changes requested by a new security descriptor to the existing
    security descriptor.  If necessary, this routine will allocate
    additional memory to produce a larger security descriptor.  All access
    checking is expected to be done before calling this routine.  This
    includes checking for WRITE_OWNER, WRITE_DAC, and privilege to assign a
    system ACL as appropriate.

    The caller of this routine must not be impersonating a client.

Arguments:

    SecurityInformation - Indicates which security information is
        to be applied to the object.  The value(s) to be assigned are
        passed in the ModificationDescriptor parameter.

    ModificationDescriptor - Supplies the input security descriptor to be
        applied to the object.  The caller of this routine is expected
        to probe and capture the passed security descriptor before calling
        and release it after calling.

    ObjectsSecurityDescriptor - Supplies the address of a pointer to
        the objects security descriptor that is going to be altered by
        this procedure.  This security descriptor must be in self-
        relative form or an error will be returned.

    GenericMapping - This argument provides the mapping of generic to
        specific/standard access types for the object being accessed.
        This mapping structure is expected to be safe to access
        (i.e., captured if necessary) prior to be passed to this routine.

    Token - (optionally) Supplies the token for the client on whose
        behalf the security is being modified.  This parameter is only
        required to ensure that the client has provided a legitimate
        value for a new owner SID.  The token must be open for
        TOKEN_QUERY access.

Return Value:

    Returns TRUE for success, FALSE for failure.  Extended error status
    is available using GetLastError.

--*/
{
    NTSTATUS Status;

    Status = RtlSetSecurityObject (
        SecurityInformation,
        ModificationDescriptor,
        ObjectsSecurityDescriptor,
        GenericMapping,
        Token
        );

    if ( !NT_SUCCESS(Status) ) {
        BaseSetLastNTError(Status);
        return FALSE;
    }

    return TRUE;
}




BOOL
APIENTRY
SetPrivateObjectSecurityEx (
    SECURITY_INFORMATION SecurityInformation,
    PSECURITY_DESCRIPTOR ModificationDescriptor,
    PSECURITY_DESCRIPTOR *ObjectsSecurityDescriptor,
    ULONG AutoInheritFlags,
    PGENERIC_MAPPING GenericMapping,
    HANDLE Token OPTIONAL
    )
/*++

Routine Description:

    Modify an object's existing self-relative form security descriptor.

    This procedure, called only from user mode, is used to update a
    security descriptor on an existing protected server's object.  It
    applies changes requested by a new security descriptor to the existing
    security descriptor.  If necessary, this routine will allocate
    additional memory to produce a larger security descriptor.  All access
    checking is expected to be done before calling this routine.  This
    includes checking for WRITE_OWNER, WRITE_DAC, and privilege to assign a
    system ACL as appropriate.

    The caller of this routine must not be impersonating a client.

Arguments:

    SecurityInformation - Indicates which security information is
        to be applied to the object.  The value(s) to be assigned are
        passed in the ModificationDescriptor parameter.

    ModificationDescriptor - Supplies the input security descriptor to be
        applied to the object.  The caller of this routine is expected
        to probe and capture the passed security descriptor before calling
        and release it after calling.

    ObjectsSecurityDescriptor - Supplies the address of a pointer to
        the objects security descriptor that is going to be altered by
        this procedure.  This security descriptor must be in self-
        relative form or an error will be returned.

    AutoInheritFlags - Controls automatic inheritance of ACES.
        Valid values are a bits mask of the logical OR of
        one or more of the following bits:

        SEF_DACL_AUTO_INHERIT - If set, inherited ACEs from the
            DACL in the ObjectsSecurityDescriptor are preserved and inherited ACEs from
            the ModificationDescriptor are ignored. Inherited ACEs are not supposed
            to be modified; so preserving them across this call is appropriate.
            If a protected server does not itself implement auto inheritance, it should
            not set this bit.  The caller of the protected server may implement
            auto inheritance and my indeed be modifying inherited ACEs.

        SEF_SACL_AUTO_INHERIT - If set, inherited ACEs from the
            SACL in the ObjectsSecurityDescriptor are preserved and inherited ACEs from
            the ModificationDescriptor are ignored. Inherited ACEs are not supposed
            to be modified; so preserving them across this call is appropriate.
            If a protected server does not itself implement auto inheritance, it should
            not set this bit.  The caller of the protected server may implement
            auto inheritance and my indeed be modifying inherited ACEs.

    GenericMapping - This argument provides the mapping of generic to
        specific/standard access types for the object being accessed.
        This mapping structure is expected to be safe to access
        (i.e., captured if necessary) prior to be passed to this routine.

    Token - (optionally) Supplies the token for the client on whose
        behalf the security is being modified.  This parameter is only
        required to ensure that the client has provided a legitimate
        value for a new owner SID.  The token must be open for
        TOKEN_QUERY access.

Return Value:

    Returns TRUE for success, FALSE for failure.  Extended error status
    is available using GetLastError.

--*/
{
    NTSTATUS Status;

    Status = RtlSetSecurityObjectEx (
        SecurityInformation,
        ModificationDescriptor,
        ObjectsSecurityDescriptor,
        AutoInheritFlags,
        GenericMapping,
        Token
        );

    if ( !NT_SUCCESS(Status) ) {
        BaseSetLastNTError(Status);
        return FALSE;
    }

    return TRUE;
}




BOOL
APIENTRY
GetPrivateObjectSecurity (
    PSECURITY_DESCRIPTOR ObjectDescriptor,
    SECURITY_INFORMATION SecurityInformation,
    PSECURITY_DESCRIPTOR ResultantDescriptor,
    DWORD DescriptorLength,
    PDWORD ReturnLength
    )
/*++

Routine Description:

    Query information from a protected server object's existing security
    descriptor.

    This procedure, called only from user mode, is used to retrieve
    information from a security descriptor on an existing protected
    server's object.  All access checking is expected to be done before
    calling this routine.  This includes checking for READ_CONTROL, and
    privilege to read a system ACL as appropriate.

Arguments:

    ObjectDescriptor - Points to a pointer to a security descriptor to be
        queried.

    SecurityInformation - Identifies the security information being
        requested.

    ResultantDescriptor - Points to buffer to receive the resultant
        security descriptor.  The resultant security descriptor will
        contain all information requested by the SecurityInformation
        parameter.

    DescriptorLength - Is an unsigned integer which indicates the length,
        in bytes, of the buffer provided to receive the resultant
        descriptor.

    ReturnLength - Receives an unsigned integer indicating the actual
        number of bytes needed in the ResultantDescriptor to store the
        requested information.  If the value returned is greater than the
        value passed via the DescriptorLength parameter, then
        STATUS_BUFFER_TOO_SMALL is returned and no information is returned.


Return Value:

    Returns TRUE for success, FALSE for failure.  Extended error status
    is available using GetLastError.

--*/
{
    NTSTATUS Status;

    Status = RtlQuerySecurityObject (
         ObjectDescriptor,
         SecurityInformation,
         ResultantDescriptor,
         DescriptorLength,
         ReturnLength
         );

    if ( !NT_SUCCESS(Status) ) {
        BaseSetLastNTError(Status);
        return FALSE;
    }

    return TRUE;
}




BOOL
APIENTRY
DestroyPrivateObjectSecurity (
    PSECURITY_DESCRIPTOR * ObjectDescriptor
    )
/*++

Routine Description:

    Delete a protected server object's security descriptor.

    This procedure, called only from user mode, is used to delete a
    security descriptor associated with a protected server's object.  This
    routine will normally be called by a protected server during object
    deletion.  The input descriptor is expected to be one created via
    a call to CreatePrivateObjectSecurity.

Arguments:

    ObjectDescriptor - Points to a pointer to a security descriptor to be
        deleted.


Return Value:

    Returns TRUE for success, FALSE for failure.  Extended error status
    is available using GetLastError.

--*/
{
    NTSTATUS Status;

    Status = RtlDeleteSecurityObject (
        ObjectDescriptor
        );

    if ( !NT_SUCCESS(Status) ) {
        BaseSetLastNTError(Status);
        return FALSE;
    }

    return TRUE;
}




BOOL
APIENTRY
MakeSelfRelativeSD (
    PSECURITY_DESCRIPTOR pAbsoluteSecurityDescriptor,
    PSECURITY_DESCRIPTOR pSelfRelativeSecurityDescriptor,
    LPDWORD lpdwBufferLength
    )
/*++

Routine Description:

    Converts a security descriptor in absolute form to one in self-relative
    form.

Arguments:

    pAbsoluteSecurityDescriptor - Pointer to an absolute format
        security descriptor.  This descriptor will not be modified.

    pSelfRelativeSecurityDescriptor - Pointer to a buffer that will
        contain the returned self-relative security descriptor.

    lpdwBufferLength - Supplies the length of the buffer.  If the
        supplied buffer is not large enough to hold the self-relative
        security descriptor, an error will be returned, and this field
        will return the minimum size required.


Return Value:

    Returns TRUE for success, FALSE for failure.  Extended error status
    is available using GetLastError.

--*/
{
    NTSTATUS Status;

    Status = RtlAbsoluteToSelfRelativeSD (
                pAbsoluteSecurityDescriptor,
                pSelfRelativeSecurityDescriptor,
                lpdwBufferLength
                );

    if ( !NT_SUCCESS(Status) ) {
        BaseSetLastNTError(Status);
        return FALSE;
    }

    return TRUE;
}

BOOL
APIENTRY
MakeAbsoluteSD (
    PSECURITY_DESCRIPTOR pSelfRelativeSecurityDescriptor,
    PSECURITY_DESCRIPTOR pAbsoluteSecurityDescriptor,
    LPDWORD lpdwAbsoluteSecurityDescriptorSize,
    PACL pDacl,
    LPDWORD lpdwDaclSize,
    PACL pSacl,
    LPDWORD lpdwSaclSize,
    PSID pOwner,
    LPDWORD lpdwOwnerSize,
    PSID pPrimaryGroup,
    LPDWORD lpdwPrimaryGroupSize
    )
/*++

Routine Description:

    Converts a security descriptor from self-relative format to absolute
    format

Arguments:

    pSecurityDescriptor - Supplies a pointer to a security descriptor
        in Self-Relative format

    pAbsoluteSecurityDescriptor - A pointer to a buffer in which will
        be placed the main body of the Absolute format security
        descriptor.

    lpdwAbsoluteSecurityDescriptorSize - The size in bytes of the
        buffer pointed to by pAbsoluteSecurityDescriptor.

    pDacl - Supplies a pointer to a buffer that will contain the Dacl
        of the output descriptor.  This pointer will be referenced by,
        not copied into, the output descriptor.

    lpdwDaclSize - Supplies the size of the buffer pointed to by Dacl.
        In case of error, it will return the minimum size necessary to
        contain the Dacl.

    pSacl - Supplies a pointer to a buffer that will contain the Sacl
        of the output descriptor.  This pointer will be referenced by,
        not copied into, the output descriptor.

    lpdwSaclSize - Supplies the size of the buffer pointed to by Sacl.
        In case of error, it will return the minimum size necessary to
        contain the Sacl.

    pOwner - Supplies a pointer to a buffer that will contain the
        Owner of the output descriptor.  This pointer will be
        referenced by, not copied into, the output descriptor.

    lpdwOwnerSize - Supplies the size of the buffer pointed to by
        Owner.  In case of error, it will return the minimum size
        necessary to contain the Owner.

    pPrimaryGroup - Supplies a pointer to a buffer that will contain
        the PrimaryGroup of the output descriptor.  This pointer will
        be referenced by, not copied into, the output descriptor.

    lpdwPrimaryGroupSize - Supplies the size of the buffer pointed to
        by PrimaryGroup.  In case of error, it will return the minimum
        size necessary to contain the PrimaryGroup.


Return Value:

    Returns TRUE for success, FALSE for failure.  Extended error status
    is available using GetLastError.

--*/
{
    NTSTATUS Status;

    Status = RtlSelfRelativeToAbsoluteSD (
                pSelfRelativeSecurityDescriptor,
                pAbsoluteSecurityDescriptor,
                lpdwAbsoluteSecurityDescriptorSize,
                pDacl,
                lpdwDaclSize,
                pSacl,
                lpdwSaclSize,
                pOwner,
                lpdwOwnerSize,
                pPrimaryGroup,
                lpdwPrimaryGroupSize
                );

    if ( !NT_SUCCESS(Status) ) {
        BaseSetLastNTError(Status);
        return FALSE;
    }

    return TRUE;
}


VOID
SetSecurityAccessMask(
    IN SECURITY_INFORMATION SecurityInformation,
    OUT LPDWORD DesiredAccess
    )

/*++

Routine Description:

    This routine builds an access mask representing the accesses necessary
    to set the object security information specified in the SecurityInformation
    parameter.  While it is not difficult to determine this information,
    the use of a single routine to generate it will ensure minimal impact
    when the security information associated with an object is extended in
    the future (to include mandatory access control information).

Arguments:

    SecurityInformation - Identifies the object's security information to be
        modified.

    DesiredAccess - Points to an access mask to be set to represent the
        accesses necessary to modify the information specified in the
        SecurityInformation parameter.

Return Value:

    None.

--*/

{

    //
    // Figure out accesses needed to perform the indicated operation(s).
    //

    (*DesiredAccess) = 0;

    if ((SecurityInformation & OWNER_SECURITY_INFORMATION) ||
        (SecurityInformation & GROUP_SECURITY_INFORMATION)   ) {
        (*DesiredAccess) |= WRITE_OWNER;
    }

    if (SecurityInformation & DACL_SECURITY_INFORMATION) {
        (*DesiredAccess) |= WRITE_DAC;
    }

    if (SecurityInformation & SACL_SECURITY_INFORMATION) {
        (*DesiredAccess) |= ACCESS_SYSTEM_SECURITY;
    }

    return;

}


VOID
QuerySecurityAccessMask(
    IN SECURITY_INFORMATION SecurityInformation,
    OUT LPDWORD DesiredAccess
    )

/*++

Routine Description:

    This routine builds an access mask representing the accesses necessary
    to query the object security information specified in the
    SecurityInformation parameter.  While it is not difficult to determine
    this information, the use of a single routine to generate it will ensure
    minimal impact when the security information associated with an object is
    extended in the future (to include mandatory access control information).

Arguments:

    SecurityInformation - Identifies the object's security information to be
        queried.

    DesiredAccess - Points to an access mask to be set to represent the
        accesses necessary to query the information specified in the
        SecurityInformation parameter.

Return Value:

    None.

--*/

{

    //
    // Figure out accesses needed to perform the indicated operation(s).
    //

    (*DesiredAccess) = 0;

    if ((SecurityInformation & OWNER_SECURITY_INFORMATION) ||
        (SecurityInformation & GROUP_SECURITY_INFORMATION) ||
        (SecurityInformation & DACL_SECURITY_INFORMATION)) {
        (*DesiredAccess) |= READ_CONTROL;
    }

    if ((SecurityInformation & SACL_SECURITY_INFORMATION)) {
        (*DesiredAccess) |= ACCESS_SYSTEM_SECURITY;
    }

    return;

}

BOOL
APIENTRY
SetFileSecurityW(
    LPCWSTR lpFileName,
    SECURITY_INFORMATION SecurityInformation,
    PSECURITY_DESCRIPTOR pSecurityDescriptor
    )

/*++

Routine Description:

    This API can be used to set the security of a file or directory
    (process, file, event, etc.).  This call is only successful if the
    following conditions are met:

    o If the object's owner or group is to be set, the caller must
      have WRITE_OWNER permission or have SeTakeOwnershipPrivilege.

    o If the object's DACL is to be set, the caller must have
      WRITE_DAC permission or be the object's owner.

    o If the object's SACL is to be set, the caller must have
      SeSecurityPrivilege.

Arguments:

    lpFileName - Supplies the file name of the file to open.  Depending on
        the value of the FailIfExists parameter, this name may or may
        not already exist.

    SecurityInformation - A pointer to information describing the
        contents of the Security Descriptor.

    pSecurityDescriptor - A pointer to a well formed Security
        Descriptor.

Return Value:

    TRUE - The operation was successful.

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/
{
    NTSTATUS Status;
    HANDLE FileHandle;
    ACCESS_MASK DesiredAccess;

    OBJECT_ATTRIBUTES Obja;
    UNICODE_STRING FileName;
    BOOLEAN TranslationStatus;
    RTL_RELATIVE_NAME_U RelativeName;
    IO_STATUS_BLOCK IoStatusBlock;
    PVOID FreeBuffer;


    SetSecurityAccessMask(
        SecurityInformation,
        &DesiredAccess
        );

    TranslationStatus = RtlDosPathNameToRelativeNtPathName_U(
                            lpFileName,
                            &FileName,
                            NULL,
                            &RelativeName
                            );

    if ( !TranslationStatus ) {
        BaseSetLastNTError(STATUS_OBJECT_NAME_INVALID);
        return FALSE;
        }

    FreeBuffer = FileName.Buffer;

    if ( RelativeName.RelativeName.Length ) {
        FileName = RelativeName.RelativeName;
        }
    else {
        RelativeName.ContainingDirectory = NULL;
        }

    InitializeObjectAttributes(
        &Obja,
        &FileName,
        OBJ_CASE_INSENSITIVE,
        RelativeName.ContainingDirectory,
        NULL
        );

    //
    // Notice that FILE_OPEN_REPARSE_POINT inhibits the reparse behavior. Thus, the
    // security will always be set, as before, in the file denoted by the name.
    //

    Status = NtOpenFile(
                 &FileHandle,
                 DesiredAccess,
                 &Obja,
                 &IoStatusBlock,
                 FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                 FILE_OPEN_REPARSE_POINT
                 );

    //
    // Back-level file systems may not support the FILE_OPEN_REPARSE_POINT
    // flag. We treat this case explicitly.
    //

    if ( Status == STATUS_INVALID_PARAMETER ) {
        //
        // Open without inhibiting the reparse behavior.
        //

        Status = NtOpenFile(
                     &FileHandle,
                     DesiredAccess,
                     &Obja,
                     &IoStatusBlock,
                     FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                     0
                     );
        }

    RtlReleaseRelativeName(&RelativeName);
    RtlFreeHeap(RtlProcessHeap(), 0, FreeBuffer);

    if ( !NT_SUCCESS( Status ) ) {
        BaseSetLastNTError( Status );
        return FALSE;
        }

    Status = NtSetSecurityObject(
                FileHandle,
                SecurityInformation,
                pSecurityDescriptor
                );

    NtClose(FileHandle);

    if (!NT_SUCCESS(Status)) {
        BaseSetLastNTError(Status);
        return FALSE;
        }

    return TRUE;
}

BOOL
APIENTRY
SetFileSecurityA(
    LPCSTR lpFileName,
    SECURITY_INFORMATION SecurityInformation,
    PSECURITY_DESCRIPTOR pSecurityDescriptor
    )

/*++

Routine Description:

    ANSI thunk to SetFileSecurityW

--*/

{

    PUNICODE_STRING Unicode;
    ANSI_STRING AnsiString;
    NTSTATUS Status;

    Unicode = &NtCurrentTeb()->StaticUnicodeString;
    RtlInitAnsiString(&AnsiString,lpFileName);
    if (AreFileApisANSI()) {
        Status = RtlAnsiStringToUnicodeString(Unicode,&AnsiString,FALSE);
    } else {
        Status = RtlOemStringToUnicodeString(Unicode,&AnsiString,FALSE);
    }
    if ( !NT_SUCCESS(Status) ) {
        BaseSetLastNTError(Status);
        return FALSE;
        }
    return ( SetFileSecurityW( (LPCWSTR)Unicode->Buffer,
                               SecurityInformation,
                               pSecurityDescriptor
                        )
           );
}

BOOL
APIENTRY
GetFileSecurityW(
    LPCWSTR lpFileName,
    SECURITY_INFORMATION RequestedInformation,
    PSECURITY_DESCRIPTOR pSecurityDescriptor,
    DWORD nLength,
    LPDWORD lpnLengthNeeded
    )

/*++

Routine Description:

    This API returns top the caller a copy of the security descriptor
    protecting a file or directory.  Based on the caller's access
    rights and privileges, this procedure will return a security
    descriptor containing the requested security descriptor fields.
    To read the handle's security descriptor the caller must be
    granted READ_CONTROL access or be the owner of the object.  In
    addition, the caller must have SeSecurityPrivilege privilege to
    read the system ACL.

Arguments:

    lpFileName - Represents the name of the file or directory whose
        security is being retrieved.

    RequestedInformation - A pointer to the security information being
        requested.

    pSecurityDescriptor - A pointer to the buffer to receive a copy of
        the secrity descriptor protecting the object that the caller
        has the rigth to view.  The security descriptor is returned in
        self-relative format.

    nLength - The size, in bytes, of the security descriptor buffer.

    lpnLengthNeeded - A pointer to the variable to receive the number
        of bytes needed to store the complete secruity descriptor.  If
        returned number of bytes is less than or equal to nLength then
        the entire security descriptor is returned in the output
        buffer, otherwise none of the descriptor is returned.

Return Value:

    TRUE is returned for success, FALSE if access is denied or if the
        buffer is too small to hold the security descriptor.


--*/
{
    NTSTATUS Status;
    HANDLE FileHandle;
    ACCESS_MASK DesiredAccess;

    OBJECT_ATTRIBUTES Obja;
    UNICODE_STRING FileName;
    BOOLEAN TranslationStatus;
    RTL_RELATIVE_NAME_U RelativeName;
    IO_STATUS_BLOCK IoStatusBlock;
    PVOID FreeBuffer;

    QuerySecurityAccessMask(
        RequestedInformation,
        &DesiredAccess
        );

    TranslationStatus = RtlDosPathNameToRelativeNtPathName_U(
                            lpFileName,
                            &FileName,
                            NULL,
                            &RelativeName
                            );

    if ( !TranslationStatus ) {
        BaseSetLastNTError(STATUS_OBJECT_NAME_INVALID);
        return FALSE;
        }

    FreeBuffer = FileName.Buffer;

    if ( RelativeName.RelativeName.Length ) {
        FileName = RelativeName.RelativeName;
        }
    else {
        RelativeName.ContainingDirectory = NULL;
        }

    InitializeObjectAttributes(
        &Obja,
        &FileName,
        OBJ_CASE_INSENSITIVE,
        RelativeName.ContainingDirectory,
        NULL
        );

    //
    // Notice that FILE_OPEN_REPARSE_POINT inhibits the reparse behavior. Thus, the
    // security will always be set, as before, in the file denoted by the name.
    //

    Status = NtOpenFile(
                 &FileHandle,
                 DesiredAccess,
                 &Obja,
                 &IoStatusBlock,
                 FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                 FILE_OPEN_REPARSE_POINT
                 );

    //
    // Back-level file systems may not support the FILE_OPEN_REPARSE_POINT
    // flag. We treat this case explicitly.
    //

    if ( Status == STATUS_INVALID_PARAMETER ) {
        //
        // Open without inhibiting the reparse behavior.
        //

        Status = NtOpenFile(
                     &FileHandle,
                     DesiredAccess,
                     &Obja,
                     &IoStatusBlock,
                     FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                     0
                     );
        }

    RtlReleaseRelativeName(&RelativeName);
    RtlFreeHeap(RtlProcessHeap(), 0, FreeBuffer);

    if (NT_SUCCESS(Status)) {
        Status = NtQuerySecurityObject(
                     FileHandle,
                     RequestedInformation,
                     pSecurityDescriptor,
                     nLength,
                     lpnLengthNeeded
                     );
        NtClose(FileHandle);
    }


    if (!NT_SUCCESS(Status)) {
        BaseSetLastNTError(Status);
        return FALSE;
        }

    return TRUE;
}

BOOL
APIENTRY
GetFileSecurityA(
    LPCSTR lpFileName,
    SECURITY_INFORMATION RequestedInformation,
    PSECURITY_DESCRIPTOR pSecurityDescriptor,
    DWORD nLength,
    LPDWORD lpnLengthNeeded
    )

/*++

Routine Description:

    ANSI thunk to GetFileSecurityW

--*/

{

    PUNICODE_STRING Unicode;
    ANSI_STRING AnsiString;
    NTSTATUS Status;

    Unicode = &NtCurrentTeb()->StaticUnicodeString;

    RtlInitAnsiString(&AnsiString,lpFileName);
    if (AreFileApisANSI()) {
        Status = RtlAnsiStringToUnicodeString(Unicode,&AnsiString,FALSE);
    } else {
        Status = RtlOemStringToUnicodeString(Unicode,&AnsiString,FALSE);
    }
    if ( !NT_SUCCESS(Status) ) {
        BaseSetLastNTError(Status);
        return FALSE;
        }
    return ( GetFileSecurityW( (LPCWSTR)Unicode->Buffer,
                               RequestedInformation,
                               pSecurityDescriptor,
                               nLength,
                               lpnLengthNeeded
                        )
           );
}




BOOL
APIENTRY
SetKernelObjectSecurity (
    HANDLE Handle,
    SECURITY_INFORMATION SecurityInformation,
    PSECURITY_DESCRIPTOR SecurityDescriptor
    )
/*++

Routine Description:

    This API can be used to set the security of a kernel object
    (process, file, event, etc.).  This call is only successful if the
    following conditions are met:

    o If the object's owner or group is to be set, the caller must
      have WRITE_OWNER permission or have SeTakeOwnershipPrivilege.

    o If the object's DACL is to be set, the caller must have
      WRITE_DAC permission or be the object's owner.

    o If the object's SACL is to be set, the caller must have
      SeSecurityPrivilege.

Arguments:

    Handle - Represents a handle of a kernel object.

    SecurityInformation - A pointer to information describing the
        contents of the Security Descriptor.

    pSecurityDescriptor - A pointer to a well formed Security
        Descriptor.

Return Value:

    Returns TRUE for success, FALSE for failure.  Extended error status
    is available using GetLastError.

--*/

{
    NTSTATUS Status;

    Status = NtSetSecurityObject(
                 Handle,
                 SecurityInformation,
                 SecurityDescriptor
                 );

    if ( !NT_SUCCESS(Status) ) {
        BaseSetLastNTError(Status);
        return FALSE;
    }

    return TRUE;
}




BOOL
APIENTRY
GetKernelObjectSecurity (
    HANDLE Handle,
    SECURITY_INFORMATION RequestedInformation,
    PSECURITY_DESCRIPTOR pSecurityDescriptor,
    DWORD nLength,
    LPDWORD lpnLengthNeeded
    )
/*++

Routine Description:

    This API returns top the caller a copy of the security descriptor
    protecting a kernel object.  Based on the caller's access rights
    and privileges, this procedure will return a security descriptor
    containing the requested security descriptor fields.  To read the
    handle's security descriptor the caller must be granted
    READ_CONTROL access or be the owner of the object.  In addition,
    the caller must have SeSecurityPrivilege privilege to read the
    system ACL.


Arguments:

    Handle - Represents a handle of a kernel object.

    RequestedInformation - A pointer to the security information being
        requested.

    pSecurityDescriptor - A pointer to the buffer to receive a copy of
        the secrity descriptor protecting the object that the caller
        has the rigth to view.  The security descriptor is returned in
        self-relative format.

    nLength - The size, in bytes, of the security descriptor buffer.

    lpnLengthNeeded - A pointer to the variable to receive the number
        of bytes needed to store the complete secruity descriptor.  If
        returned number of bytes is less than or equal to nLength then
        the entire security descriptor is returned in the output
        buffer, otherwise none of the descriptor is returned.


Return Value:

    return-value - Description of conditions needed to return value. - or -
    None.

--*/

{
    NTSTATUS Status;

    Status = NtQuerySecurityObject(
                 Handle,
                 RequestedInformation,
                 pSecurityDescriptor,
                 nLength,
                 lpnLengthNeeded
                 );

    if ( !NT_SUCCESS(Status) ) {
        BaseSetLastNTError(Status);
        return FALSE;
    }

    return TRUE;

}


BOOL
APIENTRY
ImpersonateNamedPipeClient(
    IN HANDLE hNamedPipe
    )
/*++

Routine Description:

    Impersonate a named pipe client application.

Arguments:

    hNamedPipe - Handle to a named pipe.

Return Value:

    Returns TRUE for success, FALSE for failure.  Extended error status
    is available using GetLastError.


--*/

{
    NTSTATUS Status;
    IO_STATUS_BLOCK IoStatusBlock;

    Status =  NtFsControlFile(
                  hNamedPipe,
                  NULL,
                  NULL,
                  NULL,
                  &IoStatusBlock,
                  FSCTL_PIPE_IMPERSONATE,
                  NULL,
                  0,
                  NULL,
                  0
                 );

    if ( !NT_SUCCESS(Status) ) {
        BaseSetLastNTError(Status);
        return FALSE;
    }

    return TRUE;
}

BOOL
APIENTRY
ImpersonateSelf(
    SECURITY_IMPERSONATION_LEVEL ImpersonationLevel
    )

/*++

Routine Description:

    This routine may be used to obtain an Impersonation token representing
    your own process's context.  This may be useful for enabling a privilege
    for a single thread rather than for the entire process; or changing
    the default DACL for a single thread.

    The token is assigned to the callers thread.



Arguments:

    ImpersonationLevel - The level to make the impersonation token.



Return Value:

    Returns TRUE for success, FALSE for failure.  Extended error status
    is available using GetLastError.

--*/
{

    NTSTATUS Status;

    Status = RtlImpersonateSelf( ImpersonationLevel );

    if ( !NT_SUCCESS(Status) ) {
        BaseSetLastNTError(Status);
        return FALSE;
    }

    return TRUE;


}



BOOL
APIENTRY
RevertToSelf (
    VOID
    )
/*++

Routine Description:

    Terminate impersonation of a named pipe client application.

Arguments:

    None.

Return Value:

    Returns TRUE for success, FALSE for failure.  Extended error status
    is available using GetLastError.

--*/

{
    HANDLE NewToken;
    NTSTATUS Status;

    NewToken = NULL;
    Status = NtSetInformationThread(
                 NtCurrentThread(),
                 ThreadImpersonationToken,
                 (PVOID)&NewToken,
                 (ULONG)sizeof(HANDLE)
                 );

    if ( !NT_SUCCESS(Status) ) {
        BaseSetLastNTError(Status);
        return FALSE;
    }

    return TRUE;

}



BOOL
APIENTRY
SetThreadToken (
    PHANDLE Thread,
    HANDLE Token
    )
/*++

Routine Description:

    Assigns the specified impersonation token to the specified
    thread.

Arguments:

    Thread - Specifies the thread whose token is to be assigned.
        If NULL is specified, then the caller's thread is assumed.

    Token - The token to assign.  Must be open for TOKEN_IMPERSONATE
        access.  If null, then causes the specified thread to stop
        impersonating.

Return Value:

    Returns TRUE for success, FALSE for failure.  Extended error status
    is available using GetLastError.

--*/

{
    NTSTATUS Status;
    HANDLE TargetThread;

    if (ARGUMENT_PRESENT(Thread)) {
        TargetThread = (*Thread);
    } else {
        TargetThread = NtCurrentThread();
    }


    Status = NtSetInformationThread(
                 TargetThread,
                 ThreadImpersonationToken,
                 (PVOID)&Token,
                 (ULONG)sizeof(HANDLE)
                 );

    if ( !NT_SUCCESS(Status) ) {
        BaseSetLastNTError(Status);
        return FALSE;
    }

    return TRUE;

}

BOOL
LookupAccountNameInternal(
    LPCWSTR lpSystemName,
    LPCWSTR lpAccountName,
    PSID Sid,
    LPDWORD cbSid,
    LPWSTR ReferencedDomainName,
    LPDWORD cchReferencedDomainName,
    PSID_NAME_USE peUse,
    BOOL fUnicode
    )

/*++

Routine Description:

    Translates a passed name into an account SID.  It will also return
    the name and SID of the first domain in which this name was found.

Arguments:

    lpSystemName - Supplies the name of the system at which the lookup
        is to be performed.  If the null string is provided, the local
        system is assumed.

    lpAccountName - Supplies the account name.

    Sid - Returns the SID corresponding to the passed account name.

    cbSid - Supplies the size of the buffer passed in for Sid.  If
        the buffer size is not big enough, this parameter will
        return the size necessary to hold the output Sid.

    ReferencedDomainName - Returns the name of the domain in which the
        name was found.

    cchReferencedDomainName - Supplies the size (in Wide characters) of the
        ReferencedDomainName buffer.  If the buffer size is not large
        enough, this parameter will return the size necessary to hold
        the null-terminated output domain name.  If the buffer size is
        large enough, tis parameter will return the size (in Ansi characters,
        excluding the terminating null) of the Referenced Domain name.

    peUse - Returns an enumerated type inidicating the type of the
        account.

    fUnicode - indicates whether the caller wants a count of unicode or
        ansi characters.

Return Value:

    BOOL - TRUE is returned if successful, else FALSE.

--*/

{
    SECURITY_QUALITY_OF_SERVICE SecurityQualityOfService;
    OBJECT_ATTRIBUTES ObjectAttributes;
    LSA_HANDLE PolicyHandle;
    NTSTATUS Status;
    NTSTATUS TmpStatus;
    UNICODE_STRING Name;
    PLSA_REFERENCED_DOMAIN_LIST ReferencedDomains = NULL;
    PLSA_TRANSLATED_SID2 TranslatedSid = NULL;
    PSID ReturnedDomainSid;
    UCHAR nSubAuthorities;
    UNICODE_STRING TmpString;
    DWORD ReturnedDomainNameSize;
    DWORD SidLengthRequired;
    BOOL Rc;
    UNICODE_STRING SystemName;
    PUNICODE_STRING pSystemName = NULL;

    SecurityQualityOfService.Length = sizeof(SECURITY_QUALITY_OF_SERVICE);
    SecurityQualityOfService.ImpersonationLevel = SecurityImpersonation;
    SecurityQualityOfService.ContextTrackingMode = SECURITY_DYNAMIC_TRACKING;
    SecurityQualityOfService.EffectiveOnly = FALSE;

    //
    // Set up the object attributes prior to opening the LSA.
    //

    InitializeObjectAttributes(
        &ObjectAttributes,
        NULL,
        0L,
        NULL,
        NULL
        );

    //
    // The InitializeObjectAttributes macro presently stores NULL for
    // the SecurityQualityOfService field, so we must manually copy that
    // structure for now.
    //

    ObjectAttributes.SecurityQualityOfService = &SecurityQualityOfService;

    if ( ARGUMENT_PRESENT( lpSystemName )) {
        RtlInitUnicodeString( &SystemName, lpSystemName );
        pSystemName = &SystemName;
    }

    //
    // Open the LSA Policy Database for the target system.  This is the
    // starting point for the Name Lookup operation.
    //

    Status = LsaOpenPolicy(
                 pSystemName,
                 &ObjectAttributes,
                 POLICY_LOOKUP_NAMES,
                 &PolicyHandle
                 );

    if ( !NT_SUCCESS( Status )) {

        BaseSetLastNTError( Status );
        return( FALSE );
    }

    RtlInitUnicodeString( &Name, lpAccountName );

    //
    // Attempt to translate the Name to a Sid.
    //

    Status = LsaLookupNames2(
                 PolicyHandle,
                 0, // Flags
                 1,
                 &Name,
                 &ReferencedDomains,
                 &TranslatedSid
                 );

#if DBG
//
// This code is useful for tracking down components that call Lookup code
// before the system is initialized
//
    // ASSERT( Status != STATUS_INVALID_SERVER_STATE );
    if ( Status == STATUS_INVALID_SERVER_STATE ) {

        DbgPrint( "Process: %lu, Thread: %lu\n", GetCurrentProcessId(), GetCurrentThreadId() );
    }
#endif

    //
    // Close the Policy Handle,  which is not needed after here.
    //

    TmpStatus = LsaClose( PolicyHandle );
//    ASSERT( NT_SUCCESS( TmpStatus ));

    //
    // If an error was returned, check specifically for STATUS_NONE_MAPPED.
    // In this case, we may need to dispose of the returned Referenced Domain
    // List and Translated Sid structures.  For all other errors,
    // LsaLookupNames() frees these structures prior to exit.
    //

    if ( !NT_SUCCESS( Status )) {

        if (Status == STATUS_NONE_MAPPED) {

            if (ReferencedDomains != NULL) {

                TmpStatus = LsaFreeMemory( ReferencedDomains );
                ASSERT( NT_SUCCESS( TmpStatus ));
            }

            if (TranslatedSid != NULL) {

                TmpStatus = LsaFreeMemory( TranslatedSid );
                ASSERT( NT_SUCCESS( TmpStatus ));
            }
        }

        BaseSetLastNTError( Status );
        return( FALSE );
    }

    //
    // The Name was successfully translated.  There should be exactly
    // one Referenced Domain and its DomainIndex should be zero.
    //

    ASSERT ( TranslatedSid->DomainIndex == 0 );
    ASSERT ( ReferencedDomains != NULL);
    ASSERT ( ReferencedDomains->Domains != NULL );

    //
    // Calculate the lengths of the returned Sid and Domain Name (in Wide
    // Characters, excluding null).
    //
    if ( !fUnicode ) {
        RtlUnicodeToMultiByteSize(&ReturnedDomainNameSize,
                                  ReferencedDomains->Domains->Name.Buffer,
                                  ReferencedDomains->Domains->Name.Length);
    } else {
        ReturnedDomainNameSize = (ReferencedDomains->Domains->Name.Length / sizeof(WCHAR));
    }
    SidLengthRequired = RtlLengthSid( TranslatedSid->Sid );

    //
    // Check if buffer sizes are too small.  For the returned domain,
    // the size in Wide characters provided must allow for the null
    // terminator that will be appended to the returned name.
    //

    if ( (SidLengthRequired > *cbSid) ||
         (ReturnedDomainNameSize + 1 > *cchReferencedDomainName)
       ) {

        //
        // One or both buffers are too small.  Return sizes required for
        // both buffers.
        //

        *cbSid = SidLengthRequired;
        *cchReferencedDomainName = ReturnedDomainNameSize + 1;
        BaseSetLastNTError( STATUS_BUFFER_TOO_SMALL );
        Rc = FALSE;

    } else {

        //
        // The provided buffers are large enough. 
        //
        CopySid( *cbSid, Sid, TranslatedSid->Sid );

        //
        // Copy the Domain Name into the return buffer and NULL terminate it.
        //

        TmpString.Buffer = ReferencedDomainName;
        TmpString.Length = 0;

        //
        // Watch for overflow of 16-bit name length
        //

        if (*cchReferencedDomainName < (DWORD) MAXSHORT) {

            TmpString.MaximumLength = (USHORT)((*cchReferencedDomainName) * sizeof(WCHAR));

        } else {

            TmpString.MaximumLength = (USHORT) MAXUSHORT -1;
        }

        RtlCopyUnicodeString( &TmpString, &ReferencedDomains->Domains->Name );

        TmpString.Buffer[TmpString.Length/sizeof(WCHAR)] = (WCHAR) 0;

        //
        // Copy the Sid Use field.
        //

        *peUse = TranslatedSid->Use;

        //
        // Return the size (in Wide Characters, excluding the terminating
        // null) of the returned Referenced Domain Name.
        //

        *cchReferencedDomainName = ReturnedDomainNameSize;

        Rc = TRUE;
    }

    //
    // If necessary, free the structures returned by the LsaLookupNames()
    // function.
    //

    if (ReferencedDomains !=  NULL) {

        Status = LsaFreeMemory( ReferencedDomains );
        ASSERT( NT_SUCCESS( Status ));
    }

    if (TranslatedSid != NULL) {

        Status = LsaFreeMemory( TranslatedSid );
        ASSERT( NT_SUCCESS( Status ));
    }

    return( Rc );
}



BOOL
APIENTRY
LookupAccountNameA(
    LPCSTR lpSystemName,
    LPCSTR lpAccountName,
    PSID Sid,
    LPDWORD cbSid,
    LPSTR ReferencedDomainName,
    LPDWORD cchReferencedDomainName,
    PSID_NAME_USE peUse
    )

/*++

Routine Description:

    ANSI Thunk to LookupAccountNameW

Arguments:

    lpSystemName - Supplies the name of the system at which the lookup
        is to be performed.  If the null string is provided, the local
        system is assumed.

    lpAccountName - Supplies the account name.

    Sid - Returns the SID corresponding to the passed account name.

    cbSid - Supplies the size of the buffer passed in for Sid.  If
        the buffer size is not big enough, this parameter will
        return the size necessary to hold the output Sid.

    ReferencedDomainName - Returns the name of the domain in which the
        name was found.

    cchReferencedDomainName - Supplies the size (in Ansi characters) of the
        ReferencedDomainName buffer.  If the buffer size is not large
        enough, this parameter will return the size necessary to hold
        the null-terminated output domain name.  If the buffer size is
        large enough, tis parameter will return the size (in Ansi characters,
        excluding the terminating null) of the Referenced Domain name.

    peUse - Returns an enumerated type indicating the type of the
        account.

Return Value:

    BOOL - TRUE is returned if successful, else FALSE.

--*/

{
    UNICODE_STRING Unicode;
    UNICODE_STRING TmpUnicode;
    ANSI_STRING  AnsiString;
    PWSTR WReferencedDomainName = NULL;
    UNICODE_STRING SystemName;
    PWSTR pSystemName = NULL;
    NTSTATUS Status;
    BOOL rc = TRUE;
    DWORD cchInitReferencedDomainName;

    Unicode.Buffer = NULL;
    SystemName.Buffer = NULL;

    //
    // Save the original buffer size
    //

    cchInitReferencedDomainName = *cchReferencedDomainName;

    //
    // Convert the passed lpAccountName to a WCHAR string to be
    // passed to the ..W routine.  Note that we cannot use the
    // StaticUnicodeString in the Thread Environment Block because
    // this is used by LdrpWalkImportDescriptor, called from the
    // client RPC stub code of the LsaOpenPolicy() call in
    // LookupAccountNameW.
    //

    RtlInitAnsiString( &AnsiString, lpAccountName );
    Status = RtlAnsiStringToUnicodeString( &Unicode, &AnsiString, TRUE );

    if (!NT_SUCCESS(Status)) {

        rc = FALSE;
    }

    //
    // Allocate a temporary buffer for ReferencedDomainName that
    // is twice as large as what was passed to adjust for the
    // intermediate conversion to a WCHAR string.
    //

    if (rc) {

        WReferencedDomainName = LocalAlloc(
                                    LMEM_FIXED,
                                    sizeof(WCHAR) * (*cchReferencedDomainName)
                                    );

        if (WReferencedDomainName == NULL) {

            Status = STATUS_NO_MEMORY;
            rc = FALSE;
        }
    }

    //
    // If the target system name is non NULL, convert it to Unicode
    //

    if (rc) {

        if ( ARGUMENT_PRESENT( lpSystemName ) ) {

            RtlInitAnsiString( &AnsiString, lpSystemName );
            Status = RtlAnsiStringToUnicodeString( &SystemName, &AnsiString, TRUE );

            if (!NT_SUCCESS(Status)) {

                rc = FALSE;
            }

            pSystemName = SystemName.Buffer;
        }
    }

    //
    // Lookup the Account Sid and obtain its Unicode Account Name.
    //

    if (rc) {

        rc = LookupAccountNameInternal(
                 (LPCWSTR)pSystemName,
                 (LPCWSTR)Unicode.Buffer,
                 Sid,
                 cbSid,
                 WReferencedDomainName,
                 cchReferencedDomainName,
                 peUse,
                 FALSE          // not unicode
                 );
    }

    if ( SystemName.Buffer != NULL ) {

        RtlFreeUnicodeString( &SystemName );
    }

    //
    // Convert the returned null-terminated WCHAR string
    // back to a null-terminated CHAR string.
    //

    if (rc) {

        RtlInitUnicodeString( &TmpUnicode, WReferencedDomainName );
        AnsiString.Buffer = ReferencedDomainName;

        //
        // Watch for 16-bit overflow of MaximumLength
        //
                                                      
        if (cchInitReferencedDomainName <= (DWORD) MAXUSHORT) {

            AnsiString.MaximumLength = (USHORT) cchInitReferencedDomainName;

        } else {

            AnsiString.MaximumLength = (USHORT) MAXUSHORT;
        }

        Status = RtlUnicodeStringToAnsiString( &AnsiString, &TmpUnicode, FALSE );

        if ( NT_SUCCESS( Status )) {

            ReferencedDomainName[AnsiString.Length] = 0;

        } else {

            rc = FALSE;
        }
    }

    if ( WReferencedDomainName != NULL) {

        LocalFree( WReferencedDomainName );
    }

    if (Unicode.Buffer != NULL) {

        RtlFreeUnicodeString(&Unicode);
    }

    if (!NT_SUCCESS(Status)) {

        BaseSetLastNTError( Status );
    }

    return( rc );
}





BOOL
APIENTRY
LookupAccountNameW(
    LPCWSTR lpSystemName,
    LPCWSTR lpAccountName,
    PSID Sid,
    LPDWORD cbSid,
    LPWSTR ReferencedDomainName,
    LPDWORD cchReferencedDomainName,
    PSID_NAME_USE peUse
    )

/*++

Routine Description:

    Translates a passed name into an account SID.  It will also return
    the name and SID of the first domain in which this name was found.

Arguments:

    lpSystemName - Supplies the name of the system at which the lookup
        is to be performed.  If the null string is provided, the local
        system is assumed.

    lpAccountName - Supplies the account name.

    Sid - Returns the SID corresponding to the passed account name.

    cbSid - Supplies the size of the buffer passed in for Sid.  If
        the buffer size is not big enough, this parameter will
        return the size necessary to hold the output Sid.

    ReferencedDomainName - Returns the name of the domain in which the
        name was found.

    cchReferencedDomainName - Supplies the size (in Wide characters) of the
        ReferencedDomainName buffer.  If the buffer size is not large
        enough, this parameter will return the size necessary to hold
        the null-terminated output domain name.  If the buffer size is
        large enough, tis parameter will return the size (in Ansi characters,
        excluding the terminating null) of the Referenced Domain name.

    peUse - Returns an enumerated type inidicating the type of the
        account.

Return Value:

    BOOL - TRUE is returned if successful, else FALSE.

--*/

{
    return(LookupAccountNameInternal( lpSystemName,
                                      lpAccountName,
                                      Sid,
                                      cbSid,
                                      ReferencedDomainName,
                                      cchReferencedDomainName,
                                      peUse,
                                      TRUE              // Unicode
                                    ) );

}


BOOL
APIENTRY
LookupAccountSidInternal(
    LPCWSTR lpSystemName,
    PSID lpSid,
    LPWSTR lpName,
    LPDWORD cchName,
    LPWSTR lpReferencedDomainName,
    LPDWORD cchReferencedDomainName,
    PSID_NAME_USE peUse,
    BOOL fUnicode
    )

/*++

Routine Description:

    Translates a passed SID into an account name.  It will also return
    the name and SID of the first domain in which this SID was found.

Arguments:

    lpSystemName - Supplies the name of the system at which the lookup
        is to be performed.  If the null string is provided, the local
        system is assumed.

    lpSid - Supplies the account Sid.

    lpName - Returns the name corresponding to the passed account SID.

    cchName - Supplies the size (in Wide characters) of the buffer passed in for
        lpName.  This size must allow one character for the null terminator
        that will be appended to the returned name.  If the buffer size is not
        large enough, this parameter will return the size necessary to hold
        the null-terminated output name.  If the buffer size is large enough,
        this parameter will return the size (in Ansi characters, excluding
        the null terminator) of the name returned.

    lpReferencedDomainName - Returns the name of the domain in which the
        name was found.

    cchReferencedDomainName - Supplies the size (in Wide characters) of the
        ReferencedDomainName buffer.  This size must allow one charcter for the
        null terminator that will be appended to the returned name.  If the
        buffer size is not large enough, this parameter will return the size
        necessary to hold the output null-terminated domain name.  If the
        buffer size is large enough, the size of the returned name, excluding
        the terminating null will be returned.

    peUse - Returns an enumerated type inidicating the type of the
        account.

    fUnicode - indicates whether the caller wants a count of unicode or
        ansi characters.

Return Value:

    BOOL - TRUE if successful, else FALSE.

--*/

{

    PLSA_TRANSLATED_NAME Names;
    OBJECT_ATTRIBUTES ObjectAttributes;
    LSA_HANDLE PolicyHandle;
    PLSA_REFERENCED_DOMAIN_LIST ReferencedDomains;
    DWORD ReturnedDomainNameSize;
    DWORD ReturnedNameSize;
    SECURITY_QUALITY_OF_SERVICE SecurityQualityOfService;
    NTSTATUS Status;
    UNICODE_STRING TmpString;
    NTSTATUS TmpStatus;
    UNICODE_STRING SystemName;
    PUNICODE_STRING pSystemName = NULL;
    BOOLEAN Rc = FALSE;

    SecurityQualityOfService.Length = sizeof(SECURITY_QUALITY_OF_SERVICE);
    SecurityQualityOfService.ImpersonationLevel = SecurityImpersonation;
    SecurityQualityOfService.ContextTrackingMode = SECURITY_DYNAMIC_TRACKING;
    SecurityQualityOfService.EffectiveOnly = FALSE;

    //
    // Set up the object attributes prior to opening the LSA.
    //

    InitializeObjectAttributes(
        &ObjectAttributes,
        NULL,
        0L,
        NULL,
        NULL
        );

    //
    // The InitializeObjectAttributes macro presently stores NULL for
    // the SecurityQualityOfService field, so we must manually copy that
    // structure for now.
    //

    ObjectAttributes.SecurityQualityOfService = &SecurityQualityOfService;

    if ( ARGUMENT_PRESENT( lpSystemName )) {
        RtlInitUnicodeString( &SystemName, lpSystemName );
        pSystemName = &SystemName;
    }

    Status = LsaOpenPolicy(
                 pSystemName,
                 &ObjectAttributes,
                 POLICY_LOOKUP_NAMES,
                 &PolicyHandle
                 );

    if ( !NT_SUCCESS( Status )) {

        BaseSetLastNTError( Status );
        return( FALSE );
    }

    Status = LsaLookupSids(
                 PolicyHandle,
                 1,
                 &lpSid,
                 &ReferencedDomains,
                 &Names
                 );
#if DBG
//
// This code is useful for tracking down components that call Lookup code
// before the system is initialized
//
    // ASSERT( Status != STATUS_INVALID_SERVER_STATE );
    if ( Status == STATUS_INVALID_SERVER_STATE ) {

        DbgPrint( "Process: %lu, Thread: %lu\n", GetCurrentProcessId(), GetCurrentThreadId() );
    }
#endif

    TmpStatus = LsaClose( PolicyHandle );


    //
    // If an error was returned, check specifically for STATUS_NONE_MAPPED.
    // In this case, we may need to dispose of the returned Referenced Domain
    // List and Names structures.  For all other errors, LsaLookupSids()
    // frees these structures prior to exit.
    //
                                                           
    if ( !NT_SUCCESS( Status )) {

        if (Status == STATUS_NONE_MAPPED) {

            if (ReferencedDomains != NULL) {

                TmpStatus = LsaFreeMemory( ReferencedDomains );
                ASSERT( NT_SUCCESS( TmpStatus ));
            }

            if (Names != NULL) {

                TmpStatus = LsaFreeMemory( Names );
                ASSERT( NT_SUCCESS( TmpStatus ));
            }
        }

        BaseSetLastNTError( Status );
        return( FALSE );
    }

    //
    // The Sid was successfully translated.  There should be exactly
    // one Referenced Domain and its DomainIndex should be zero.
    //

    ASSERT(Names->DomainIndex == 0);
    ASSERT(ReferencedDomains != NULL);
    ASSERT(ReferencedDomains->Domains != NULL);

    if ( ! fUnicode ) {

        RtlUnicodeToMultiByteSize(&ReturnedNameSize,
                                  Names->Name.Buffer,
                                  Names->Name.Length);


        RtlUnicodeToMultiByteSize(&ReturnedDomainNameSize,
                                  ReferencedDomains->Domains->Name.Buffer,
                                  ReferencedDomains->Domains->Name.Length);

    } else {
        ReturnedNameSize = (Names->Name.Length / sizeof(WCHAR));
        ReturnedDomainNameSize = (ReferencedDomains->Domains->Name.Length / sizeof(WCHAR));
    }


    //
    // Check if buffer sizes  for the Name and Referenced Domain Name are too
    // small.  The sizes in Wide characters provided must allow for the null
    // terminator that will be appended to the returned names.
    //

    if ((ReturnedNameSize + 1 > *cchName) ||
        (ReturnedDomainNameSize + 1 > *cchReferencedDomainName)) {

        //
        // One or both buffers are too small.  Return sizes required for
        // both buffers, allowing one character for the null terminator.
        //

        *cchReferencedDomainName = ReturnedDomainNameSize + 1;
        *cchName = ReturnedNameSize + 1;
        BaseSetLastNTError( STATUS_BUFFER_TOO_SMALL );
        Rc = FALSE;

    } else {

        //
        // Both buffers are of sufficient size.  Copy in the Name
        // information and add NULL terminators.
        //

        TmpString.Buffer = lpName;
        TmpString.Length = 0;

        //
        // Watch for 16-bit overflow on buffer size.  Clamp size to
        // 16 bits if necessary.
        //

        if (*cchName <= MAXSHORT) {

            TmpString.MaximumLength = (USHORT)((*cchName) * sizeof(WCHAR));

        } else {

            TmpString.MaximumLength = (USHORT) MAXUSHORT -1;
        }

        if ((*cchName) > 0) {

            RtlCopyUnicodeString( &TmpString, &Names->Name );
            TmpString.Buffer[TmpString.Length/sizeof(WCHAR)] = (WCHAR) 0;
        }

        //
        // Copy in the Referenced Domain information.
        //

        TmpString.Buffer = lpReferencedDomainName;
        TmpString.Length = 0;

        //
        // Watch for 16-bit overflow on buffer size.  Clamp size to
        // 16 bits if necessary.
        //

        if (*cchReferencedDomainName <= MAXSHORT) {

            TmpString.MaximumLength = (USHORT)((*cchReferencedDomainName) * sizeof(WCHAR));

        } else {

            TmpString.MaximumLength = (USHORT) MAXUSHORT -1;
        }

        RtlCopyUnicodeString( &TmpString, &ReferencedDomains->Domains->Name );
        TmpString.Buffer[TmpString.Length/sizeof(WCHAR)] = (WCHAR) 0;

        //
        // Return the sizes (in Wide Characters, excluding the terminating
        // null) of the name and domain name.
        //

        *cchReferencedDomainName = ReturnedDomainNameSize;
        *cchName = ReturnedNameSize;

        // Copy in the Use field.
        //

        *peUse = Names->Use;
        Rc = TRUE;
    }

    //
    // If necessary, free output buffers returned by LsaLookupSids
    //

    if (Names != NULL) {

        Status = LsaFreeMemory( Names );
        ASSERT( NT_SUCCESS( Status ));
    }

    if (ReferencedDomains != NULL) {

        Status = LsaFreeMemory( ReferencedDomains );
        ASSERT( NT_SUCCESS( Status ));
    }

    return(Rc);
}



BOOL
APIENTRY
LookupAccountSidA(
    LPCSTR lpSystemName,
    PSID lpSid,
    LPSTR lpName,
    LPDWORD cchName,
    LPSTR lpReferencedDomainName,
    LPDWORD cchReferencedDomainName,
    PSID_NAME_USE peUse
    )
/*++

Routine Description:

    ANSI Thunk to LookupAccountSidW

Arguments:

    lpSystemName - Supplies the name of the system at which the lookup
        is to be performed.  If the null string is provided, the local
        system is assumed.

    lpSid - Supplies the account Sid.

    lpName - Returns the name corresponding to the passed account SID.

    cchName - Supplies the size (in Ansi characters) of the buffer passed in for
        lpName.  This size must allow one character for the null terminator
        that will be appended to the returned name.  If the buffer size is not
        large enough, this parameter will return the size necessary to hold
        the null-terminated output name.  If the buffer size is large enough,
        this parameter will return the size (in Ansi characters, excluding
        the null terminator) of the name returned.

    lpReferencedDomainName - Returns the name of the domain in which the
        name was found.

    cchReferencedDomainName - Supplies the size (in Ansi characters) of the
        ReferencedDomainName buffer.  This size must allow one charcter for the
        null terminator that will be appended to the returned name.  If the
        buffer size is not large enough, this parameter will return the size
        necessary to hold the output null-terminated domain name.  If the
        buffer size is large enough, the size of the returned name, excluding
        the terminating null will be returned.

    peUse - Returns an enumerated type indicating the type of the
        account.


Return Value:

    BOOL - TRUE if successful, else FALSE.

--*/

{
    NTSTATUS Status;
    LPWSTR WName = NULL;
    LPWSTR WReferencedDomainName = NULL;
    BOOL BoolStatus;
    ANSI_STRING AnsiString;
    UNICODE_STRING UnicodeString;
    UNICODE_STRING SystemName;
    PWSTR pSystemName = NULL;
    DWORD cchInitName, cchInitReferencedDomainName;

    //
    // Save the original buffer sizes specified for the returned account Name
    // and Referenced Domain Name.
    //

    cchInitName = *cchName;
    cchInitReferencedDomainName = *cchReferencedDomainName;

    //
    // Construct temporary buffers for the Name and Domain information
    // that are twice the size of those passed in to adjust for the
    // intermediate conversion to WCHAR strings.
    //

    if ( *cchName > 0 ) {
        WName = LocalAlloc( LMEM_FIXED, (*cchName) * sizeof(WCHAR));

        if ( !WName )
        {
            SetLastError( ERROR_OUTOFMEMORY );
            return FALSE ;
        }
    }

    if ( *cchReferencedDomainName > 0 ) {
        WReferencedDomainName =
            LocalAlloc( LMEM_FIXED, (*cchReferencedDomainName) * sizeof(WCHAR));

        if ( !WReferencedDomainName )
        {
            if ( WName )
            {
                LocalFree( WName );
            }

            SetLastError( ERROR_OUTOFMEMORY );

            return FALSE ;
        }
    }

    if ( ARGUMENT_PRESENT( lpSystemName ) ) {

        RtlInitAnsiString( &AnsiString, lpSystemName );
        RtlAnsiStringToUnicodeString( &SystemName, &AnsiString, TRUE );
        pSystemName = SystemName.Buffer;
    }

    BoolStatus = LookupAccountSidInternal(
                     (LPCWSTR)pSystemName,
                     lpSid,
                     WName,
                     cchName,
                     WReferencedDomainName,
                     cchReferencedDomainName,
                     peUse,
                     FALSE              // not unicode
                     );

    if ( ARGUMENT_PRESENT( lpSystemName ) ) {
        RtlFreeUnicodeString( &SystemName );
    }

    if ( BoolStatus ) {

        //
        // Copy the Name and DomainName information into the passed CHAR
        // buffers.
        //

        if ( ARGUMENT_PRESENT(lpName) ) {

            AnsiString.Buffer = lpName;

            //
            // Watch for 16-bit overflow on buffer size.  Clamp size to
            // 16 bits if necessary.
            //

            if (cchInitName <= (DWORD) MAXUSHORT) {

                AnsiString.MaximumLength = (USHORT) cchInitName;

            } else {

                AnsiString.MaximumLength = (USHORT) MAXUSHORT;
            }

            RtlInitUnicodeString( &UnicodeString, WName );
            Status = RtlUnicodeStringToAnsiString( &AnsiString,
                                                   &UnicodeString,
                                                   FALSE );
            ASSERT(NT_SUCCESS(Status));
            AnsiString.Buffer[AnsiString.Length] = 0;
        }

        if ( ARGUMENT_PRESENT(lpReferencedDomainName) ) {

            AnsiString.Buffer = lpReferencedDomainName;

            //
            // Watch for 16-bit overflow on buffer size.  Clamp size to
            // 16 bits if necessary.
            //

            if (cchInitReferencedDomainName <= (DWORD) MAXUSHORT) {

                AnsiString.MaximumLength = (USHORT) cchInitReferencedDomainName;

            } else {

                AnsiString.MaximumLength = (USHORT) MAXUSHORT;
            }

            RtlInitUnicodeString( &UnicodeString, WReferencedDomainName );
            Status = RtlUnicodeStringToAnsiString( &AnsiString,
                                                   &UnicodeString,
                                                   FALSE );
            ASSERT(NT_SUCCESS(Status));
            AnsiString.Buffer[AnsiString.Length] = 0;
        }

    }

    if (ARGUMENT_PRESENT(WName)) {
        LocalFree( WName );
    }
    if (ARGUMENT_PRESENT(WReferencedDomainName)) {
        LocalFree( WReferencedDomainName );
    }

    return( BoolStatus );
}




BOOL
APIENTRY
LookupAccountSidW(
    LPCWSTR lpSystemName,
    PSID lpSid,
    LPWSTR lpName,
    LPDWORD cchName,
    LPWSTR lpReferencedDomainName,
    LPDWORD cchReferencedDomainName,
    PSID_NAME_USE peUse
    )

/*++

Routine Description:

    Translates a passed SID into an account name.  It will also return
    the name and SID of the first domain in which this SID was found.

Arguments:

    lpSystemName - Supplies the name of the system at which the lookup
        is to be performed.  If the null string is provided, the local
        system is assumed.

    lpSid - Supplies the account Sid.

    lpName - Returns the name corresponding to the passed account SID.

    cchName - Supplies the size (in Wide characters) of the buffer passed in for
        lpName.  This size must allow one character for the null terminator
        that will be appended to the returned name.  If the buffer size is not
        large enough, this parameter will return the size necessary to hold
        the null-terminated output name.  If the buffer size is large enough,
        this parameter will return the size (in Ansi characters, excluding
        the null terminator) of the name returned.

    lpReferencedDomainName - Returns the name of the domain in which the
        name was found.

    cchReferencedDomainName - Supplies the size (in Wide characters) of the
        ReferencedDomainName buffer.  This size must allow one charcter for the
        null terminator that will be appended to the returned name.  If the
        buffer size is not large enough, this parameter will return the size
        necessary to hold the output null-terminated domain name.  If the
        buffer size is large enough, the size of the returned name, excluding
        the terminating null will be returned.

    peUse - Returns an enumerated type inidicating the type of the
        account.

Return Value:

    BOOL - TRUE if successful, else FALSE.

--*/

{
    return(LookupAccountSidInternal(
                lpSystemName,
                lpSid,
                lpName,
                cchName,
                lpReferencedDomainName,
                cchReferencedDomainName,
                peUse,
                TRUE                    // Unicode
                ));
}


BOOL
APIENTRY
LookupPrivilegeValueA(
    LPCSTR lpSystemName,
    LPCSTR lpName,
    PLUID lpLuid
    )
/*++

Routine Description:

    ANSI Thunk to LookupPrivilegeValueW().

Arguments:


Return Value:


--*/
{
    NTSTATUS Status;
    UNICODE_STRING USystemName, UName;
    ANSI_STRING ASystemName, AName;
    BOOL bool;

    RtlInitAnsiString( &ASystemName, lpSystemName );
    RtlInitAnsiString( &AName, lpName );

    USystemName.Buffer = NULL;
    UName.Buffer = NULL;

    Status = RtlAnsiStringToUnicodeString( &USystemName, &ASystemName, TRUE );
    if (NT_SUCCESS(Status)) {

        Status = RtlAnsiStringToUnicodeString( &UName, &AName, TRUE );
        if (NT_SUCCESS(Status)) {


            bool = LookupPrivilegeValueW( (LPCWSTR)USystemName.Buffer,
                                          (LPCWSTR)UName.Buffer,
                                          lpLuid
                                          );

            RtlFreeUnicodeString( &UName );
        }

        RtlFreeUnicodeString( &USystemName );
    }

    if (!NT_SUCCESS(Status)) {

        BaseSetLastNTError( Status );
        return( FALSE );

    }

    return(bool);


}

BOOL
APIENTRY
LookupPrivilegeValueW(
    LPCWSTR lpSystemName,
    LPCWSTR lpName,
    PLUID  lpLuid
    )

/*++

Routine Description:


    This function retrieves the value used on the target system
    to locally represent the specified privilege.  The privilege
    is specified by programmatic name.


Arguments:

    lpSystemName - Supplies the name of the system at which the lookup
        is to be performed.  If the null string is provided, the local
        system is assumed.

    lpName - provides the privilege's programmatic name.

    lpLuid - Receives the locally unique ID the privilege is known by on the
        target machine.


Return Value:



--*/
{
    NTSTATUS                    Status,
                                TmpStatus;

    LSA_HANDLE                  PolicyHandle;

    OBJECT_ATTRIBUTES           ObjectAttributes;

    SECURITY_QUALITY_OF_SERVICE SecurityQualityOfService;

    UNICODE_STRING              USystemName,
                                UName;

    PUNICODE_STRING             SystemName = NULL;


    SecurityQualityOfService.Length = sizeof(SECURITY_QUALITY_OF_SERVICE);
    SecurityQualityOfService.ImpersonationLevel = SecurityImpersonation;
    SecurityQualityOfService.ContextTrackingMode = SECURITY_DYNAMIC_TRACKING;
    SecurityQualityOfService.EffectiveOnly = FALSE;

    //
    // Set up the object attributes prior to opening the LSA.
    //

    InitializeObjectAttributes( &ObjectAttributes, NULL, 0L, NULL, NULL );
    ObjectAttributes.SecurityQualityOfService = &SecurityQualityOfService;


    if ( ARGUMENT_PRESENT( lpSystemName )) {
        RtlInitUnicodeString( &USystemName, lpSystemName );
        SystemName = &USystemName;
    }

    Status = LsaOpenPolicy(
                 SystemName,
                 &ObjectAttributes,
                 POLICY_LOOKUP_NAMES,
                 &PolicyHandle
                 );

    if ( !NT_SUCCESS( Status )) {
        BaseSetLastNTError( Status );
        return( FALSE );
    }



    RtlInitUnicodeString( &UName, lpName );
    Status = LsaLookupPrivilegeValue( PolicyHandle, &UName, lpLuid );

    TmpStatus = LsaClose( PolicyHandle );
//    ASSERT( NT_SUCCESS( TmpStatus ));


    if ( !NT_SUCCESS( Status )) {
        BaseSetLastNTError( Status );
        return( FALSE );
    }


    return(TRUE);
}



BOOL
APIENTRY
LookupPrivilegeNameA(
    LPCSTR   lpSystemName,
    PLUID   lpLuid,
    LPSTR   lpName,
    LPDWORD cchName
    )
/*++

Routine Description:

    ANSI Thunk to LookupPrivilegeValueW().

Arguments:


Return Value:


--*/
{
    NTSTATUS       Status;

    ANSI_STRING    AnsiName;
    LPWSTR         UnicodeBuffer;
    UNICODE_STRING UnicodeString;

    ANSI_STRING    AnsiSystemName;
    UNICODE_STRING UnicodeSystemName;
    DWORD          LengthRequired;

    //
    // Convert the passed SystemName to Unicode.  Let the Rtl function
    // allocate the memory we need.
    //

    RtlInitAnsiString( &AnsiSystemName, lpSystemName );
    Status = RtlAnsiStringToUnicodeString( &UnicodeSystemName, &AnsiSystemName, TRUE );

    if (!NT_SUCCESS( Status )) {

        BaseSetLastNTError( Status );
        return( FALSE );
    }

    //
    // Make sure we don't exceed the limits of a unicode string.
    //

    if (*cchName > 0xFFFC) {
        *cchName = 0xFFFC;
    }

    UnicodeBuffer = RtlAllocateHeap( RtlProcessHeap(), 0, *cchName * sizeof(WCHAR) );

    if (UnicodeBuffer == NULL) {

        RtlFreeUnicodeString( &UnicodeSystemName );
        BaseSetLastNTError( STATUS_NO_MEMORY );
        return( FALSE );
    }

    //
    // Don't pass in cchName, since it will be overwritten by LookupPrivilegeNameW,
    // and we need it later.
    //

    LengthRequired = *cchName;

    if (!LookupPrivilegeNameW( (LPCWSTR)UnicodeSystemName.Buffer,
                               lpLuid,
                               UnicodeBuffer,
                               &LengthRequired
                               )) {

        RtlFreeHeap( RtlProcessHeap(), 0, UnicodeBuffer );
        RtlFreeUnicodeString( &UnicodeSystemName );
        *cchName = LengthRequired;
        return(FALSE);
    }

    //
    // Now convert back to ANSI for the caller
    //

    RtlInitUnicodeString(&UnicodeString, UnicodeBuffer);

    AnsiName.Buffer = lpName;
    AnsiName.Length = 0;
    AnsiName.MaximumLength = (USHORT)*cchName;

    Status = RtlUnicodeStringToAnsiString(&AnsiName, &UnicodeString, FALSE);

    ASSERT( NT_SUCCESS( Status ));

    *cchName = AnsiName.Length;

    RtlFreeHeap( RtlProcessHeap(), 0, UnicodeBuffer );
    RtlFreeUnicodeString( &UnicodeSystemName );

    return(TRUE);
}



BOOL
APIENTRY
LookupPrivilegeNameW(
    LPCWSTR  lpSystemName,
    PLUID   lpLuid,
    LPWSTR  lpName,
    LPDWORD cchName
    )
/*++

Routine Description:


    This function returns the programmatic name corresponding to
    the privilege represented on the target system by the provided
    LUID.


Arguments:


    lpSystemName - Supplies the name of the system at which the lookup
        is to be performed.  If the null string is provided, the local
        system is assumed.


    lpLuid - is the locally unique ID the privilege is known by on the
        target machine.

    lpName - Receives the privilege's programmatic name.

    cchName - indicates how large the buffer is (in characters).  This
        count does not include the null-terminator that is added at the
        end of the string.



Return Value:



--*/
{
    NTSTATUS                    Status,
                                TmpStatus;
    LSA_HANDLE                  PolicyHandle;
    OBJECT_ATTRIBUTES           ObjectAttributes;
    SECURITY_QUALITY_OF_SERVICE SecurityQualityOfService;
    UNICODE_STRING              USystemName;
    PUNICODE_STRING             SystemName,
                                UName;


    SecurityQualityOfService.Length = sizeof(SECURITY_QUALITY_OF_SERVICE);
    SecurityQualityOfService.ImpersonationLevel = SecurityImpersonation;
    SecurityQualityOfService.ContextTrackingMode = SECURITY_DYNAMIC_TRACKING;
    SecurityQualityOfService.EffectiveOnly = FALSE;

    //
    // Set up the object attributes prior to opening the LSA.
    //

    InitializeObjectAttributes( &ObjectAttributes, NULL, 0L, NULL, NULL );
    ObjectAttributes.SecurityQualityOfService = &SecurityQualityOfService;


    SystemName = NULL;
    if ( ARGUMENT_PRESENT( lpSystemName )) {
        RtlInitUnicodeString( &USystemName, lpSystemName );
        SystemName = &USystemName;
    }

    Status = LsaOpenPolicy(
                 SystemName,
                 &ObjectAttributes,
                 POLICY_LOOKUP_NAMES,
                 &PolicyHandle
                 );

    if ( !NT_SUCCESS( Status )) {
        BaseSetLastNTError( Status );
        return( FALSE );
    }


    UName = NULL;
    Status = LsaLookupPrivilegeName( PolicyHandle,lpLuid, &UName );

    if (NT_SUCCESS(Status) ) {

        if ((DWORD)UName->Length + sizeof( WCHAR) > (*cchName) * sizeof( WCHAR )) {
            Status = STATUS_BUFFER_TOO_SMALL;
            (*cchName) = ( UName->Length + sizeof( WCHAR) ) / sizeof( WCHAR );

        } else {

            RtlMoveMemory( lpName, UName->Buffer, UName->Length );
            lpName[UName->Length/sizeof(WCHAR)] = 0;  // NULL terminate it
            (*cchName) = UName->Length / sizeof( WCHAR );
        }

        LsaFreeMemory( UName->Buffer );
        LsaFreeMemory( UName );
    }

    TmpStatus = LsaClose( PolicyHandle );
//    ASSERT( NT_SUCCESS( TmpStatus ));


    if ( !NT_SUCCESS( Status )) {
        BaseSetLastNTError( Status );
        return( FALSE );
    }


    return(TRUE);
}



BOOL
APIENTRY
LookupPrivilegeDisplayNameA(
    LPCSTR   lpSystemName,
    LPCSTR   lpName,
    LPSTR   lpDisplayName,
    LPDWORD cchDisplayName,
    LPDWORD lpLanguageId
    )

/*++

Routine Description:

    ANSI Thunk to LookupPrivilegeValueW().

Arguments:


Return Value:


--*/
{
    NTSTATUS                Status;

    UNICODE_STRING          UnicodeSystemName;
    UNICODE_STRING          UnicodeString;
    UNICODE_STRING          UnicodeName;

    ANSI_STRING             AnsiSystemName;
    ANSI_STRING             AnsiDisplayName;
    ANSI_STRING             AnsiName;

    LPWSTR                  UnicodeBuffer;
    DWORD                   RequiredLength;


    RtlInitAnsiString( &AnsiSystemName, lpSystemName );
    Status = RtlAnsiStringToUnicodeString( &UnicodeSystemName, &AnsiSystemName, TRUE );

    if (!NT_SUCCESS( Status )) {

        BaseSetLastNTError( Status );
        return( FALSE );
    }

    //
    // Make sure we don't exceed that limits of a unicode string.
    //

    if (*cchDisplayName > 0xFFFC) {
        *cchDisplayName = 0xFFFC;
    }

    UnicodeBuffer =  RtlAllocateHeap( RtlProcessHeap(), 0, *cchDisplayName * sizeof(WCHAR));

    if (UnicodeBuffer == NULL) {

        RtlFreeUnicodeString( &UnicodeSystemName );
        BaseSetLastNTError( STATUS_NO_MEMORY );
        return( FALSE );
    }

    RtlInitAnsiString( &AnsiName, lpName );
    Status = RtlAnsiStringToUnicodeString( &UnicodeName, &AnsiName, TRUE );

    if (!NT_SUCCESS( Status )) {

        RtlFreeUnicodeString( &UnicodeSystemName );
        RtlFreeHeap( RtlProcessHeap(), 0, UnicodeBuffer );
        BaseSetLastNTError( Status );
        return( FALSE );
    }

    RequiredLength = *cchDisplayName;

    if (! LookupPrivilegeDisplayNameW( (LPCWSTR)UnicodeSystemName.Buffer,
                                       (LPCWSTR)UnicodeName.Buffer,
                                       UnicodeBuffer,
                                       &RequiredLength,
                                       lpLanguageId
                                       )) {

        //
        // No need to set last error here, we can assume the W routine did so.
        //

        *cchDisplayName = RequiredLength;

        RtlFreeUnicodeString( &UnicodeSystemName );
        RtlFreeUnicodeString( &UnicodeName );
        RtlFreeHeap( RtlProcessHeap(), 0, UnicodeBuffer );
        return( FALSE );
    }

    //
    // Now convert back to ANSI for the caller
    //

    RtlInitUnicodeString( &UnicodeString, UnicodeBuffer );

    AnsiDisplayName.Buffer = lpDisplayName;
    AnsiDisplayName.Length = 0;
    AnsiDisplayName.MaximumLength = (USHORT)(*cchDisplayName);

    Status = RtlUnicodeStringToAnsiString( &AnsiDisplayName, &UnicodeString, FALSE );

    ASSERT( NT_SUCCESS( Status ));

    *cchDisplayName = AnsiDisplayName.Length;

    RtlFreeUnicodeString( &UnicodeSystemName );
    RtlFreeUnicodeString( &UnicodeName );
    RtlFreeHeap( RtlProcessHeap(), 0, UnicodeBuffer );

    return( TRUE );
}



BOOL
APIENTRY
LookupPrivilegeDisplayNameW(
    LPCWSTR  lpSystemName,
    LPCWSTR  lpName,
    LPWSTR  lpDisplayName,
    LPDWORD cchDisplayName,
    LPDWORD lpLanguageId
    )

/*++

Routine Description:

    This function retrieves a displayable name representing the
    specified privilege.


Arguments:

    lpSystemName - Supplies the name of the system at which the lookup
        is to be performed.  If the null string is provided, the local
        system is assumed.


    lpName - provides the privilege's programmatic name.


    lpDisplayName - Receives the privilege's displayable name.

    cchDisplayName - indicates how large the buffer is (in characters).  This
        count does not include the null-terminator that is added at the
        end of the string.

    lpLanguageId - Receives the language of the returned displayable
        name.


Return Value:


--*/

{
    NTSTATUS                    Status,
                                TmpStatus;

    LSA_HANDLE                  PolicyHandle;

    OBJECT_ATTRIBUTES           ObjectAttributes;

    SECURITY_QUALITY_OF_SERVICE SecurityQualityOfService;

    UNICODE_STRING              USystemName,
                                UName;

    PUNICODE_STRING             SystemName,
                                UDisplayName;

    SHORT                       LanguageId;


    SecurityQualityOfService.Length = sizeof(SECURITY_QUALITY_OF_SERVICE);
    SecurityQualityOfService.ImpersonationLevel = SecurityImpersonation;
    SecurityQualityOfService.ContextTrackingMode = SECURITY_DYNAMIC_TRACKING;
    SecurityQualityOfService.EffectiveOnly = FALSE;

    //
    // Set up the object attributes prior to opening the LSA.
    //

    InitializeObjectAttributes( &ObjectAttributes, NULL, 0L, NULL, NULL );
    ObjectAttributes.SecurityQualityOfService = &SecurityQualityOfService;


    SystemName = NULL;
    if ( ARGUMENT_PRESENT( lpSystemName )) {
        RtlInitUnicodeString( &USystemName, lpSystemName );
        SystemName = &USystemName;
    }

    Status = LsaOpenPolicy(
                 SystemName,
                 &ObjectAttributes,
                 POLICY_LOOKUP_NAMES,
                 &PolicyHandle
                 );

    if ( !NT_SUCCESS( Status )) {
        BaseSetLastNTError( Status );
        return( FALSE );
    }

    RtlInitUnicodeString( &UName, lpName );


    UDisplayName = NULL;
    Status = LsaLookupPrivilegeDisplayName( PolicyHandle,
                                            &UName,
                                            &UDisplayName,
                                            &LanguageId
                                            );
    (*lpLanguageId) = LanguageId;

    if (NT_SUCCESS(Status)) {

        if (UDisplayName->Length + sizeof(WCHAR) > (*cchDisplayName) * sizeof(WCHAR)) {
            Status = STATUS_BUFFER_TOO_SMALL;
            (*cchDisplayName) = (UDisplayName->Length + sizeof( WCHAR )) / sizeof( WCHAR );

        } else {

            RtlMoveMemory( lpDisplayName,
                           UDisplayName->Buffer,
                           UDisplayName->Length
                           );
            lpDisplayName[UDisplayName->Length/sizeof(WCHAR)] = 0;  // Null terminate it.
            (*cchDisplayName) = UDisplayName->Length / sizeof( WCHAR );
        }

        LsaFreeMemory( UDisplayName->Buffer );
        LsaFreeMemory( UDisplayName );

    }
    TmpStatus = LsaClose( PolicyHandle );
//    ASSERT( NT_SUCCESS( TmpStatus ));


    if ( !NT_SUCCESS( Status )) {
        BaseSetLastNTError( Status );
        return( FALSE );
    }


    return(TRUE);
}


BOOL
APIENTRY
ImpersonateAnonymousToken(
    IN HANDLE ThreadHandle
    )
/*++

Routine Description:

    Win32 wrapper for NtImpersonateAnonymousToken();

    Impersonates the system's anonymous logon token on this thread.

Arguments:

    ThreadHandle - Handle to the thread to do the impersonation.

Return Value:

    TRUE for success, FALSE for failure.

    Call GetLastError() for more information.

--*/
{
    NTSTATUS Status;

    Status = NtImpersonateAnonymousToken(
                ThreadHandle
                );

    if ( !NT_SUCCESS( Status )) {
        BaseSetLastNTError( Status );
        return( FALSE );

    } else {
        return( TRUE );
    }
}





/////////////////////////////////////////////////////////////////////////////
//                                                                         //
//               Private Routines                                          //
//                                                                         //
/////////////////////////////////////////////////////////////////////////////

VOID
SepFormatAccountSid(
    PSID Sid,
    LPWSTR OutputBuffer
    )
{
    UCHAR Buffer[128];
    UCHAR TmpBuffer[128];
    ANSI_STRING AccountName;
    UCHAR i;
    ULONG Tmp;
    UNICODE_STRING OutputString;
    PISID iSid;
    NTSTATUS Status;

    //
    // Do everything as ANSI for the time being, and then
    // convert to wide-char at the bottom.
    //
    // We need to do this until we have more complete c-runtime support
    // for w-char strings.
    //

    iSid = (PISID) Sid;

    OutputString.Buffer = OutputBuffer;
    OutputString.MaximumLength = 127;

    Buffer[0] = 0;
    TmpBuffer[0] = 0;

    AccountName.MaximumLength = 127;
    AccountName.Length = (USHORT)((GetLengthSid( Sid ) > MAXUSHORT) ? MAXUSHORT : GetLengthSid( Sid ));
    AccountName.Buffer = Buffer;

    sprintf(TmpBuffer, "S-%u-", (USHORT)iSid->Revision );
    lstrcpy(Buffer, TmpBuffer);

    if (  (iSid->IdentifierAuthority.Value[0] != 0)  ||
          (iSid->IdentifierAuthority.Value[1] != 0)     ){
        sprintf(TmpBuffer, "0x%02hx%02hx%02hx%02hx%02hx%02hx",
                    (USHORT)iSid->IdentifierAuthority.Value[0],
                    (USHORT)iSid->IdentifierAuthority.Value[1],
                    (USHORT)iSid->IdentifierAuthority.Value[2],
                    (USHORT)iSid->IdentifierAuthority.Value[3],
                    (USHORT)iSid->IdentifierAuthority.Value[4],
                    (USHORT)iSid->IdentifierAuthority.Value[5] );
        lstrcat(Buffer, TmpBuffer);
    } else {
        Tmp = (ULONG)iSid->IdentifierAuthority.Value[5]          +
              (ULONG)(iSid->IdentifierAuthority.Value[4] <<  8)  +
              (ULONG)(iSid->IdentifierAuthority.Value[3] << 16)  +
              (ULONG)(iSid->IdentifierAuthority.Value[2] << 24);
        sprintf(TmpBuffer, "%lu", Tmp);
        lstrcat(Buffer, TmpBuffer);
    }

    for (i=0;i<iSid->SubAuthorityCount ;i++ ) {
        sprintf(TmpBuffer, "-%lu", iSid->SubAuthority[i]);
        lstrcat(Buffer, TmpBuffer);
    }

    Status = RtlAnsiStringToUnicodeString( &OutputString, &AccountName, FALSE );

    ASSERT( NT_SUCCESS( Status ));

    return;
}

BOOL
APIENTRY
CreateRestrictedToken(
    IN HANDLE ExistingTokenHandle,
    IN DWORD Flags,
    IN DWORD DisableSidCount,
    IN PSID_AND_ATTRIBUTES SidsToDisable OPTIONAL,
    IN DWORD DeletePrivilegeCount,
    IN PLUID_AND_ATTRIBUTES PrivilegesToDelete OPTIONAL,
    IN DWORD RestrictedSidCount,
    IN PSID_AND_ATTRIBUTES SidsToRestrict OPTIONAL,
    OUT PHANDLE NewTokenHandle
    )
{
    NTSTATUS Status;
    PTOKEN_GROUPS DisabledSids = NULL;
    PTOKEN_PRIVILEGES DeletedPrivileges = NULL;
    PTOKEN_GROUPS RestrictedSids = NULL;

    //
    // Convert the input parameters into the native NT format
    //

    if (DisableSidCount != 0) {
        if (SidsToDisable == NULL) {
            Status = STATUS_INVALID_PARAMETER;
            goto Cleanup;
        }
        DisabledSids = (PTOKEN_GROUPS) LocalAlloc(0,sizeof(TOKEN_GROUPS) +
                                        (DisableSidCount - 1) * sizeof(SID_AND_ATTRIBUTES) );
        if (DisabledSids == NULL)
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Cleanup;
        }
        DisabledSids->GroupCount = DisableSidCount;
        RtlCopyMemory(
            DisabledSids->Groups,
            SidsToDisable,
            DisableSidCount * sizeof(SID_AND_ATTRIBUTES)
            );
    }

    if (DeletePrivilegeCount != 0) {
        if (PrivilegesToDelete == NULL) {
            Status = STATUS_INVALID_PARAMETER;
            goto Cleanup;
        }
        DeletedPrivileges = (PTOKEN_PRIVILEGES) LocalAlloc(0,sizeof(TOKEN_PRIVILEGES) +
                                        (DeletePrivilegeCount - 1) * sizeof(LUID_AND_ATTRIBUTES) );
        if (DeletedPrivileges == NULL)
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Cleanup;
        }
        DeletedPrivileges->PrivilegeCount = DeletePrivilegeCount;
        RtlCopyMemory(
            DeletedPrivileges->Privileges,
            PrivilegesToDelete,
            DeletePrivilegeCount * sizeof(LUID_AND_ATTRIBUTES)
            );
    }

    if (RestrictedSidCount != 0) {
        if (SidsToRestrict == NULL) {
            Status = STATUS_INVALID_PARAMETER;
            goto Cleanup;
        }
        RestrictedSids = (PTOKEN_GROUPS) LocalAlloc(0,sizeof(TOKEN_GROUPS) +
                                        (RestrictedSidCount - 1) * sizeof(SID_AND_ATTRIBUTES) );
        if (RestrictedSids == NULL)
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Cleanup;
        }
        RestrictedSids->GroupCount = RestrictedSidCount;
        RtlCopyMemory(
            RestrictedSids->Groups,
            SidsToRestrict,
            RestrictedSidCount * sizeof(SID_AND_ATTRIBUTES)
            );
    }

    Status = NtFilterToken(
                ExistingTokenHandle,
                Flags,
                DisabledSids,
                DeletedPrivileges,
                RestrictedSids,
                NewTokenHandle
                );

Cleanup:
    if (DisabledSids != NULL) {
        LocalFree(DisabledSids);
    }
    if (DeletedPrivileges != NULL) {
        LocalFree(DeletedPrivileges);
    }
    if (RestrictedSids != NULL) {
        LocalFree(RestrictedSids);
    }
    if (!NT_SUCCESS(Status)) {
        BaseSetLastNTError( Status );
        return(FALSE);
    }
    return(TRUE);
}

BOOL
APIENTRY
IsTokenRestricted(
    IN HANDLE TokenHandle
    )
{
    PTOKEN_GROUPS RestrictedSids = NULL;
    ULONG ReturnLength;
    NTSTATUS Status;
    BOOL Result = FALSE;


    Status = NtQueryInformationToken(
                TokenHandle,
                TokenRestrictedSids,
                NULL,
                0,
                &ReturnLength
                );
    if (Status != STATUS_BUFFER_TOO_SMALL)
    {
        BaseSetLastNTError(Status);
        return(FALSE);
    }

    RestrictedSids = (PTOKEN_GROUPS) LocalAlloc(0, ReturnLength);
    if (RestrictedSids == NULL)
    {
        SetLastError(ERROR_OUTOFMEMORY);
        return(FALSE);
    }

    Status = NtQueryInformationToken(
                TokenHandle,
                TokenRestrictedSids,
                RestrictedSids,
                ReturnLength,
                &ReturnLength
                );
    if (NT_SUCCESS(Status))
    {
        if (RestrictedSids->GroupCount != 0)
        {
            Result = TRUE;
        }
    }
    else
    {
        BaseSetLastNTError(Status);
    }
    LocalFree(RestrictedSids);
    return(Result);
}


BOOL
APIENTRY
CheckTokenMembership(
    IN HANDLE TokenHandle OPTIONAL,
    IN PSID SidToCheck,
    OUT PBOOL IsMember
    )
/*++

Routine Description:

    This function checks to see whether the specified sid is enabled in
    the specified token.

Arguments:

    TokenHandle - If present, this token is checked for the sid. If not
        present then the current effective token will be used. This must
        be an impersonation token.

    SidToCheck - The sid to check for presence in the token

    IsMember - If the sid is enabled in the token, contains TRUE otherwise
        false.

Return Value:

    TRUE - The API completed successfully. It does not indicate that the
        sid is a member of the token.

    FALSE - The API failed. A more detailed status code can be retrieved
        via GetLastError()


--*/
{
    HANDLE ProcessToken = NULL;
    HANDLE EffectiveToken = NULL;
    NTSTATUS Status = STATUS_SUCCESS;
    PISECURITY_DESCRIPTOR SecDesc = NULL;
    ULONG SecurityDescriptorSize;
    GENERIC_MAPPING GenericMapping = {
        STANDARD_RIGHTS_READ,
        STANDARD_RIGHTS_EXECUTE,
        STANDARD_RIGHTS_WRITE,
        STANDARD_RIGHTS_ALL };
    //
    // The size of the privilege set needs to contain the set itself plus
    // any privileges that may be used. The privileges that are used
    // are SeTakeOwnership and SeSecurity, plus one for good measure
    //

    BYTE PrivilegeSetBuffer[sizeof(PRIVILEGE_SET) + 3*sizeof(LUID_AND_ATTRIBUTES)];
    PPRIVILEGE_SET PrivilegeSet = (PPRIVILEGE_SET) PrivilegeSetBuffer;
    ULONG PrivilegeSetLength = sizeof(PrivilegeSetBuffer);
    ACCESS_MASK AccessGranted = 0;
    NTSTATUS AccessStatus = 0;
    PACL Dacl = NULL;

#define MEMBER_ACCESS 1

    *IsMember = FALSE;

    //
    // Get a handle to the token
    //

    if (ARGUMENT_PRESENT(TokenHandle))
    {
        EffectiveToken = TokenHandle;
    }
    else
    {
        Status = NtOpenThreadToken(
                    NtCurrentThread(),
                    TOKEN_QUERY,
                    FALSE,              // don't open as self
                    &EffectiveToken
                    );

        //
        // if there is no thread token, try the process token
        //

        if (Status == STATUS_NO_TOKEN)
        {
            Status = NtOpenProcessToken(
                        NtCurrentProcess(),
                        TOKEN_QUERY | TOKEN_DUPLICATE,
                        &ProcessToken
                        );
            //
            // If we have a process token, we need to convert it to an
            // impersonation token
            //

            if (NT_SUCCESS(Status))
            {
                BOOL Result;
                Result = DuplicateToken(
                            ProcessToken,
                            SecurityImpersonation,
                            &EffectiveToken
                            );

                CloseHandle(ProcessToken);
                if (!Result)
                {
                    return(FALSE);
                }
            }
        }

        if (!NT_SUCCESS(Status))
        {
            goto Cleanup;
        }

    }

    //
    // Construct a security descriptor to pass to access check
    //

    //
    // The size is equal to the size of an SD + twice the length of the SID
    // (for owner and group) + size of the DACL = sizeof ACL + size of the
    // ACE, which is an ACE + length of
    // ths SID.
    //

    SecurityDescriptorSize = sizeof(SECURITY_DESCRIPTOR) +
                                sizeof(ACCESS_ALLOWED_ACE) +
                                sizeof(ACL) +
                                3 * RtlLengthSid(SidToCheck);

    SecDesc = (PISECURITY_DESCRIPTOR) LocalAlloc(LMEM_ZEROINIT, SecurityDescriptorSize );
    if (SecDesc == NULL)
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }
    Dacl = (PACL) (SecDesc + 1);

    RtlCreateSecurityDescriptor(
        SecDesc,
        SECURITY_DESCRIPTOR_REVISION
        );

    //
    // Fill in fields of security descriptor
    //

    RtlSetOwnerSecurityDescriptor(
        SecDesc,
        SidToCheck,
        FALSE
        );
    RtlSetGroupSecurityDescriptor(
        SecDesc,
        SidToCheck,
        FALSE
        );

    Status = RtlCreateAcl(
                Dacl,
                SecurityDescriptorSize - sizeof(SECURITY_DESCRIPTOR),
                ACL_REVISION
                );
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }
    Status = RtlAddAccessAllowedAce(
                Dacl,
                ACL_REVISION,
                MEMBER_ACCESS,
                SidToCheck
                );

    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    //
    // Set the DACL on the security descriptor
    //

    Status = RtlSetDaclSecurityDescriptor(
                SecDesc,
                TRUE,   // DACL present
                Dacl,
                FALSE   // not defaulted
                );
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    Status = NtAccessCheck(
                SecDesc,
                EffectiveToken,
                MEMBER_ACCESS,
                &GenericMapping,
                PrivilegeSet,
                &PrivilegeSetLength,
                &AccessGranted,
                &AccessStatus
                );
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    //
    // if the access check failed, then the sid is not a member of the
    // token
    //

    if ((AccessStatus == STATUS_SUCCESS) && (AccessGranted == MEMBER_ACCESS))
    {
        *IsMember = TRUE;
    }




Cleanup:
    if (!ARGUMENT_PRESENT(TokenHandle) && (EffectiveToken != NULL))
    {
        (VOID) NtClose(EffectiveToken);
    }

    if (SecDesc != NULL)
    {
        LocalFree(SecDesc);
    }

    if (!NT_SUCCESS(Status))
    {
        BaseSetLastNTError(Status);
        return(FALSE);
    }
    else
    {
        return(TRUE);
    }
}

BOOL
APIENTRY
MakeAbsoluteSD2 (
    PSECURITY_DESCRIPTOR pSelfRelativeSecurityDescriptor,
    LPDWORD lpdwBufferSize
    )
/*++

Routine Description:

    Converts a security descriptor from self-relative format to absolute
    format

Arguments:

    pSelfRelativeSecurityDescriptor - Supplies a pointer to a security descriptor
        in Self-Relative format

    lpdwBufferSize - The size in bytes of the
        buffer pointed to by pSelfRelativeSecurityDescriptor.

Return Value:

    Returns TRUE for success, FALSE for failure.  Extended error status
    is available using GetLastError.

--*/
{
    NTSTATUS Status;

    Status = RtlSelfRelativeToAbsoluteSD2 (
                pSelfRelativeSecurityDescriptor,
                lpdwBufferSize
                );

    //
    // MakeAbsoluteSD2() has the same prototype as
    // RtlSelfRelativeToAbsoluteSD2() so the parameters check
    // returns the same parameter order if the caller passes invalid parameter.
    //

    if ( !NT_SUCCESS(Status) ) {
        BaseSetLastNTError(Status);
        return FALSE;
    }

    return TRUE;

} // MakeAbsoluteSD2()




DWORD
APIENTRY
GetSecurityDescriptorRMControl(
    IN PSECURITY_DESCRIPTOR SecurityDescriptor,
    OUT PUCHAR RMControl
    )
/*++

Routine Description:

    This procedure returns the RM Control flags from a SecurityDescriptor if
    SE_RM_CONTROL_VALID flags is present in the control field.

Arguments:

    SecurityDescriptor - Pointer to the SECURITY_DESCRIPTOR structure

    RMControl          - Returns the flags in the SecurityDescriptor if
                         SE_RM_CONTROL_VALID is set in the control bits of the
                         SecurityDescriptor.

Return Value:
    ERROR_INVALID_DATA      if the SE_RM_CONTROL_VALID flag is not present in
                            the security descriptor
    ERROR_SUCCESS           otherwise

--*/


{
    BOOLEAN Result;

    Result = RtlGetSecurityDescriptorRMControl(
                 SecurityDescriptor,
                 RMControl
                 );

    if (FALSE == Result)
    {
        return ERROR_INVALID_DATA;
    }

    return ERROR_SUCCESS;
}

DWORD
APIENTRY
SetSecurityDescriptorRMControl(
    IN OUT PSECURITY_DESCRIPTOR SecurityDescriptor,
    IN PUCHAR RMControl OPTIONAL
    )


/*++

Routine Description:

    This procedure sets the RM Control flag in the control field of
    SecurityDescriptor and sets Sbz1 to the the byte to which RMContol point
    If RMControl is NULL then the bits are cleared.


Arguments:

    SecurityDescriptor - Pointer to the SECURITY_DESCRIPTOR structure

    RMControl          - Pointer to the flags to set. If NULL then the bits
                         are cleared.


Return Value: ERROR_SUCCESS

--*/

{
    RtlSetSecurityDescriptorRMControl(
        SecurityDescriptor,
        RMControl
        );

    return ERROR_SUCCESS;
}


//
// Datatypes for identifying and constructing well known sids
//
//
// N.B When adding a new well known security principal, all that is 
// necessary is to update one of the domain tables below. For example,
// if adding a new domain group, add an entry to AccountDomainSids
// with the new RID and the new WELL_KNOWN_SID_TYPE enumeration.  If 
// the addition would create two entries with the same RID then determine
// if a new table is required to contain SIDs with a common subauthority.
//

#define NELEMENTS(x)  sizeof(x)/sizeof((x)[0])

typedef struct 
{
    ULONG               Rid;
    WELL_KNOWN_SID_TYPE Type;

} WELL_KNOWN_RID_ARRAY;

WELL_KNOWN_RID_ARRAY NullAuthoritySids[] = 
{
    {SECURITY_NULL_RID, WinNullSid}
};

WELL_KNOWN_RID_ARRAY WorldAuthoritySids[] =
{
    {SECURITY_WORLD_RID, WinWorldSid}
};

WELL_KNOWN_RID_ARRAY LocalAuthoritySids[] =
{
    {SECURITY_LOCAL_RID, WinLocalSid}
};

WELL_KNOWN_RID_ARRAY CreatorOwnerAuthoritySids[] =
{
    {SECURITY_CREATOR_OWNER_RID, WinCreatorOwnerSid},
    {SECURITY_CREATOR_GROUP_RID, WinCreatorGroupSid},
    {SECURITY_CREATOR_OWNER_SERVER_RID, WinCreatorOwnerServerSid},
    {SECURITY_CREATOR_GROUP_SERVER_RID, WinCreatorGroupServerSid}
};

WELL_KNOWN_RID_ARRAY NtAuthoritySids[] =
{
    {SECURITY_DIALUP_RID, WinDialupSid},
    {SECURITY_NETWORK_RID, WinNetworkSid},
    {SECURITY_BATCH_RID, WinBatchSid},
    {SECURITY_INTERACTIVE_RID, WinInteractiveSid},
    {SECURITY_SERVICE_RID, WinServiceSid},
    {SECURITY_ANONYMOUS_LOGON_RID, WinAnonymousSid},
    {SECURITY_PROXY_RID, WinProxySid},
    {SECURITY_ENTERPRISE_CONTROLLERS_RID, WinEnterpriseControllersSid},
    {SECURITY_PRINCIPAL_SELF_RID, WinSelfSid},
    {SECURITY_AUTHENTICATED_USER_RID, WinAuthenticatedUserSid},
    {SECURITY_RESTRICTED_CODE_RID, WinRestrictedCodeSid},
    {SECURITY_TERMINAL_SERVER_RID, WinTerminalServerSid},
    {SECURITY_REMOTE_LOGON_RID, WinRemoteLogonIdSid},
    {SECURITY_THIS_ORGANIZATION_RID, WinThisOrganizationSid},
    {SECURITY_OTHER_ORGANIZATION_RID, WinOtherOrganizationSid},
//
// N.B. The Logon IDs SID is special in that it has three subauth's.
// IsWellKnownSid() special cases this, CreateWellKnownSid doesn't accept
// WinLogonIdsSid
//
//    {SECURITY_LOGON_IDS_RID, WinLogonIdsSid},
    {SECURITY_LOCAL_SYSTEM_RID, WinLocalSystemSid},
    {SECURITY_LOCAL_SERVICE_RID, WinLocalServiceSid},
    {SECURITY_NETWORK_SERVICE_RID, WinNetworkServiceSid},
    {SECURITY_BUILTIN_DOMAIN_RID, WinBuiltinDomainSid},
};

WELL_KNOWN_RID_ARRAY BuiltinDomainSids[] =
{
    {DOMAIN_ALIAS_RID_ADMINS, WinBuiltinAdministratorsSid},
    {DOMAIN_ALIAS_RID_USERS, WinBuiltinUsersSid},
    {DOMAIN_ALIAS_RID_GUESTS, WinBuiltinGuestsSid},
    {DOMAIN_ALIAS_RID_POWER_USERS, WinBuiltinPowerUsersSid},
    {DOMAIN_ALIAS_RID_ACCOUNT_OPS, WinBuiltinAccountOperatorsSid},
    {DOMAIN_ALIAS_RID_SYSTEM_OPS, WinBuiltinSystemOperatorsSid},
    {DOMAIN_ALIAS_RID_PRINT_OPS, WinBuiltinPrintOperatorsSid},
    {DOMAIN_ALIAS_RID_BACKUP_OPS, WinBuiltinBackupOperatorsSid},
    {DOMAIN_ALIAS_RID_REPLICATOR, WinBuiltinReplicatorSid},
    {DOMAIN_ALIAS_RID_PREW2KCOMPACCESS, WinBuiltinPreWindows2000CompatibleAccessSid},
    {DOMAIN_ALIAS_RID_REMOTE_DESKTOP_USERS, WinBuiltinRemoteDesktopUsersSid},
    {DOMAIN_ALIAS_RID_NETWORK_CONFIGURATION_OPS, WinBuiltinNetworkConfigurationOperatorsSid},
    {DOMAIN_ALIAS_RID_INCOMING_FOREST_TRUST_BUILDERS, WinBuiltinIncomingForestTrustBuildersSid},
    {DOMAIN_ALIAS_RID_MONITORING_USERS, WinBuiltinPerfMonitoringUsersSid},
    {DOMAIN_ALIAS_RID_LOGGING_USERS, WinBuiltinPerfLoggingUsersSid},
    {DOMAIN_ALIAS_RID_AUTHORIZATIONACCESS, WinBuiltinAuthorizationAccessSid},
    {DOMAIN_ALIAS_RID_TS_LICENSE_SERVERS, WinBuiltinTerminalServerLicenseServersSid},
};

WELL_KNOWN_RID_ARRAY AccountDomainSids[] =
{
    {DOMAIN_USER_RID_ADMIN, WinAccountAdministratorSid},
    {DOMAIN_USER_RID_GUEST, WinAccountGuestSid},
    {DOMAIN_USER_RID_KRBTGT, WinAccountKrbtgtSid},
    {DOMAIN_GROUP_RID_ADMINS, WinAccountDomainAdminsSid},
    {DOMAIN_GROUP_RID_USERS, WinAccountDomainUsersSid},
    {DOMAIN_GROUP_RID_GUESTS, WinAccountDomainGuestsSid},
    {DOMAIN_GROUP_RID_COMPUTERS, WinAccountComputersSid},
    {DOMAIN_GROUP_RID_CONTROLLERS, WinAccountControllersSid},
    {DOMAIN_GROUP_RID_CERT_ADMINS, WinAccountCertAdminsSid},
    {DOMAIN_GROUP_RID_SCHEMA_ADMINS, WinAccountSchemaAdminsSid},
    {DOMAIN_GROUP_RID_ENTERPRISE_ADMINS, WinAccountEnterpriseAdminsSid},
    {DOMAIN_GROUP_RID_POLICY_ADMINS, WinAccountPolicyAdminsSid},
    {DOMAIN_ALIAS_RID_RAS_SERVERS, WinAccountRasAndIasServersSid},
};

WELL_KNOWN_RID_ARRAY SecurityPackageSids[] =
{  
    {SECURITY_PACKAGE_NTLM_RID, WinNTLMAuthenticationSid},
    {SECURITY_PACKAGE_DIGEST_RID, WinDigestAuthenticationSid},
    {SECURITY_PACKAGE_SCHANNEL_RID, WinSChannelAuthenticationSid},
};

typedef struct 
{
    SID_IDENTIFIER_AUTHORITY Authority;
    WELL_KNOWN_RID_ARRAY*    WellKnownRids;
    ULONG                    Count;

} WELL_KNOWN_AUTHORITIES_TYPE;

//
// WARNING!  Do not change the numbering here without changing the order
// of the KnownAuthoritiesAndDomains table.  There should never be a reason
// to change the ordering.
//

#define AUTHORITY_INDEX_START          0
#define NULL_AUTHORITY_INDEX           0
#define WORLD_AUTHORITY_INDEX          1
#define LOCAL_AUTHORITY_INDEX          2
#define CREATOR_OWNER_AUTHORITY_INDEX  3
#define NT_AUTHORITY_INDEX             4
#define AUTHORITY_INDEX_SENTINEL       5

#define BUILTIN_DOMAIN_INDEX           5
#define ACCOUNT_DOMAIN_INDEX           6
#define SECURITY_PACKAGE_INDEX         7
                                
WELL_KNOWN_AUTHORITIES_TYPE KnownAuthoritiesAndDomains[] = 
{
    {SECURITY_NULL_SID_AUTHORITY, NullAuthoritySids, NELEMENTS(NullAuthoritySids)},
    {SECURITY_WORLD_SID_AUTHORITY, WorldAuthoritySids, NELEMENTS(WorldAuthoritySids)},
    {SECURITY_LOCAL_SID_AUTHORITY, LocalAuthoritySids, NELEMENTS(LocalAuthoritySids)},
    {SECURITY_CREATOR_SID_AUTHORITY, CreatorOwnerAuthoritySids, NELEMENTS(CreatorOwnerAuthoritySids)},
    {SECURITY_NT_AUTHORITY, NtAuthoritySids, NELEMENTS(NtAuthoritySids)},
    {SECURITY_NT_AUTHORITY, BuiltinDomainSids, NELEMENTS(BuiltinDomainSids)},
    {SECURITY_NT_AUTHORITY, AccountDomainSids, NELEMENTS(AccountDomainSids)},
    {SECURITY_NT_AUTHORITY, SecurityPackageSids, NELEMENTS(SecurityPackageSids)},
};

WINADVAPI
BOOL
WINAPI
IsWellKnownSid (
    IN  PSID pSid,
    IN  WELL_KNOWN_SID_TYPE WellKnownSidType
    )
/*++

Routine Description:

    This routine determines is pSID is the well known SID specified.
    
    It is purely runtime routine (that is, it makes no network or kernel 
    calls).
    
Parameters:

    pSid -- the SID to inspect
    
    WellKnownSidType - the well known SID to check for

Return Values

    TRUE is the SID matches the well known SID, 
    FALSE otherwise
    
 --*/
{

    ULONG i;
    BOOL fFound = FALSE;
    WELL_KNOWN_SID_TYPE Type;
    SID_IDENTIFIER_AUTHORITY *pAuthority = NULL;
    WELL_KNOWN_RID_ARRAY *RidArray = NULL;
    UCHAR SubAuthCount = 0;
    ULONG RidArrayCount;

#define IS_EQUAL_AUTHORITY(x, y) \
    RtlEqualMemory((x),(y),sizeof(SID_IDENTIFIER_AUTHORITY))

    //
    // Guard against bad parameters
    //
    if (!RtlValidSid(pSid)) {
        return FALSE;
    }

    pAuthority = GetSidIdentifierAuthority(pSid);
    if (NULL == pAuthority) {
        return FALSE;
    }

    SubAuthCount = *RtlSubAuthorityCountSid(pSid);
    if (SubAuthCount == 0) {

        //
        // Only one such known sid -- the Nt Authority domain sid has no
        // sub auth's
        //
        if ( IS_EQUAL_AUTHORITY(pAuthority, 
                  &KnownAuthoritiesAndDomains[NT_AUTHORITY_INDEX].Authority) ) {
            fFound = TRUE;
            Type = WinNtAuthoritySid;
        }

    } else if (SubAuthCount == 1) {

        //
        // Try the known authorities that aren't domains
        //

        for ( i = AUTHORITY_INDEX_START; i < AUTHORITY_INDEX_SENTINEL; i++) {
            if  (IS_EQUAL_AUTHORITY(pAuthority, 
                                   &KnownAuthoritiesAndDomains[i].Authority)) {
                RidArray = KnownAuthoritiesAndDomains[i].WellKnownRids;
                RidArrayCount = KnownAuthoritiesAndDomains[i].Count;
                break;
            }
        }

    } else if (SubAuthCount > 1) {

        //
        // Try the domains (builtin and account)
        //
        if ( IS_EQUAL_AUTHORITY(pAuthority, 
                  &KnownAuthoritiesAndDomains[NT_AUTHORITY_INDEX].Authority) ) {

            ULONG FirstSubAuth = *RtlSubAuthoritySid(pSid, 0);
    
            if  ( (FirstSubAuth == SECURITY_BUILTIN_DOMAIN_RID)
             &&   (SubAuthCount == 2)  ) {

                // Builtin domain sids always have 2 sub auth's: the builtin
                // RID and the principal RID
                RidArray = BuiltinDomainSids;
                RidArrayCount = NELEMENTS(BuiltinDomainSids);

            } else if ((FirstSubAuth == SECURITY_NT_NON_UNIQUE)
                    && (SubAuthCount == SECURITY_NT_NON_UNIQUE_SUB_AUTH_COUNT+2)){

                // These account domains have 
                // 1 subauth for the SECURITY_NT_NON_UNIQUE,
                // 1 for the principal and
                // SECURITY_NT_NON_UNIQUE_SUB_AUTH_COUNT for the domain portion
                RidArray = AccountDomainSids;
                RidArrayCount = NELEMENTS(AccountDomainSids);

            } else if  ( (FirstSubAuth == SECURITY_LOGON_IDS_RID)
                    &&   (SubAuthCount == SECURITY_LOGON_IDS_RID_COUNT)) {
                //
                // This is the special LogonId sid S-1-5-5-X-Y
                //
                fFound = TRUE;
                Type = WinLogonIdsSid;
                
            } else if  ( (FirstSubAuth == SECURITY_PACKAGE_BASE_RID)
                    &&   (SubAuthCount == SECURITY_PACKAGE_RID_COUNT)) {
                //
                // This is the special security package sid S-1-5-0x40-X
                //
                RidArray = SecurityPackageSids;
                RidArrayCount = NELEMENTS(SecurityPackageSids);
            }

        }             

    }
    

    //
    // If we matched for authority or domain, try to match RID
    //
    if ( RidArray ) {

        ULONG Rid;
        ASSERT(SubAuthCount > 0);

        Rid = *RtlSubAuthoritySid(pSid, SubAuthCount - 1);
        for (i = 0; i < RidArrayCount; i++) {
            if (Rid == RidArray[i].Rid) {
                fFound = TRUE;
                Type = RidArray[i].Type;
                break;
            }
        }
    }

    if (fFound && (Type == WellKnownSidType)) {
        fFound = TRUE;
    } else {
        fFound = FALSE;
    }

    return fFound;

}


WINADVAPI
BOOL
WINAPI
CreateWellKnownSid(
    IN WELL_KNOWN_SID_TYPE WellKnownSidType,
    IN PSID pDomainSid  OPTIONAL,
    OUT PSID pSid,
    IN OUT DWORD *cbSid
    )
/*++

Routine Description:

    This routines creates the SID of a well known principal.
   
Parameters:

    WellKnownSidType - the well known account sid that the caller desires

    pDomainSid - if the WellKnownSidType is an SID from an Account domain, this
                 value can be set; if not set and the WellKnownSidType is from 
                 an Account domain, error STATUS_INVALID_PARAMETER is returned.
                 If the WellKnownSidType is not from an Account domain, this 
                 parameter is ignored.

    pSID - a client allocated buffer
    
    cbSid - the number of bytes pointed to by pSID

Return Values

    TRUE if WellKnownSidType is understood and pSID points to a buffer large 
    enough to hold the SID

    FALSE otherwise
    
 --*/
{

    BOOL  fFound = FALSE;
    ULONG Rid;
    ULONG i, j;
    ULONG SizeRequired;
    NTSTATUS Status;
    UCHAR SubAuthCount;

    if (pDomainSid && !RtlValidSid(pDomainSid)) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    if (IsBadWritePtr(cbSid, sizeof(*cbSid))) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    // special case -- can't create this one
    if (WinLogonIdsSid == WellKnownSidType) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }
    
    //
    // Find the requested type
    //
    for (i = 0; i < NELEMENTS(KnownAuthoritiesAndDomains); i++) {
        for (j = 0; j < KnownAuthoritiesAndDomains[i].Count; j++) {
            if (WellKnownSidType == KnownAuthoritiesAndDomains[i].WellKnownRids[j].Type){
                Rid = KnownAuthoritiesAndDomains[i].WellKnownRids[j].Rid;
                fFound = TRUE;
                break;
            }
        }
        if (fFound) {
            break;
        }
    }

    // special case since the NtAuthority domain doesn't have any sub auth's
    if (!fFound && (WellKnownSidType == WinNtAuthoritySid)) {
        i = NT_AUTHORITY_INDEX;
        fFound = TRUE;
    }

    if (!fFound) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    //
    // Determine how much space we need
    //
    switch (i) {
        case NULL_AUTHORITY_INDEX:
        case WORLD_AUTHORITY_INDEX:
        case LOCAL_AUTHORITY_INDEX:
        case CREATOR_OWNER_AUTHORITY_INDEX:
        case NT_AUTHORITY_INDEX:
            if (WellKnownSidType == WinNtAuthoritySid) {
                SubAuthCount = 0;
            } else {
                SubAuthCount = 1;
            }
            break;
        case SECURITY_PACKAGE_INDEX:
            SubAuthCount = SECURITY_PACKAGE_RID_COUNT;
            break;
        case BUILTIN_DOMAIN_INDEX:
            SubAuthCount = 2;
            break;
        case ACCOUNT_DOMAIN_INDEX:
            if (NULL == pDomainSid) {
                SetLastError(ERROR_INVALID_PARAMETER);
                return FALSE;
            }
            SubAuthCount = *RtlSubAuthorityCountSid(pDomainSid);
            if (SubAuthCount == SID_MAX_SUB_AUTHORITIES) {
                SetLastError(ERROR_INVALID_PARAMETER);
                return FALSE;
            }
            // Add for the RID
            SubAuthCount++;
            break;
        default:
            ASSERT(!"Invalid index");
    }

    //
    // Make sure we have enough space
    //
    SizeRequired = GetSidLengthRequired(SubAuthCount);
    if (*cbSid < SizeRequired) {
        *cbSid = SizeRequired;
        SetLastError(ERROR_INSUFFICIENT_BUFFER);
        return FALSE;
    }
    *cbSid = SizeRequired;

    if (IsBadWritePtr(pSid, SizeRequired)) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    //
    // Fill the sid in
    //
    switch (i) {
    
        case ACCOUNT_DOMAIN_INDEX:
            Status = RtlCopySid(*cbSid, pSid, pDomainSid);
            if (NT_SUCCESS(Status)) {
                (*RtlSubAuthorityCountSid(pSid))++;
            }
            break;

        case BUILTIN_DOMAIN_INDEX:
        case NULL_AUTHORITY_INDEX:
        case WORLD_AUTHORITY_INDEX:
        case LOCAL_AUTHORITY_INDEX:
        case CREATOR_OWNER_AUTHORITY_INDEX:
        case NT_AUTHORITY_INDEX:
        case SECURITY_PACKAGE_INDEX:
    
            Status = RtlInitializeSid(pSid,
                                     &KnownAuthoritiesAndDomains[i].Authority,
                                     SubAuthCount);

            if (NT_SUCCESS(Status)) {
                
                if (i == BUILTIN_DOMAIN_INDEX) {
                    ASSERT(SubAuthCount > 1);
                    *RtlSubAuthoritySid(pSid, 0) = SECURITY_BUILTIN_DOMAIN_RID;
                
                } else if (i == SECURITY_PACKAGE_INDEX) {
                    ASSERT(SubAuthCount == 2);
                    *RtlSubAuthoritySid(pSid, 0) = SECURITY_PACKAGE_BASE_RID;
                }
            }
    
            break;
        default:
        ASSERT(!"Invalid index");

    }

    if (!NT_SUCCESS(Status)) {
        BaseSetLastNTError(Status);
        return FALSE;
    }

    //
    // Append the Rid
    //
    if (SubAuthCount > 0) {
        *RtlSubAuthoritySid(pSid, SubAuthCount-1) = Rid;
    }

    return TRUE;

}

WINADVAPI
BOOL
WINAPI
GetWindowsAccountDomainSid(
    IN PSID pSid,
    IN OUT PSID pDomainSid OPTIONAL,
    OUT DWORD* cbDomainSid
    )
/*++

Routine Description:

    This routine returns the domain portion of pSid, if any if the SID is
    from an account domain.  If the SID is not from an account domain, then
    ERROR_NON_ACCOUNT_SID is returned.

Parameters:

    pSid -- the SID from which to extract the domain portion
    
    pDomainSid -- the domain portion of pSid; caller must allocate buffer
    
    cbDomainSid -- the number of bytes pointed to by pDomainSid; if 
                   insufficient, this value will be set to the number of
                   bytes required.

Return Values

    TRUE if a domain portion could be extracted and placed into pDomainSid
    
    FALSE otherwise; win32 errors are
    
        ERROR_INVALID_SID
        ERROR_INVALID_PARAMETER
        ERROR_NON_ACCOUNT_SID
        ERROR_INSUFFICIENT_BUFFER
        
 --*/
{
    NTSTATUS Status;
    ULONG SizeRequired;
    UCHAR SubAuthCount;
    UCHAR DomainSubAuthCount = 0;
    BOOL  fRecognized = FALSE;
    ULONG i;

    if (!RtlValidSid(pSid)) {
        SetLastError(ERROR_INVALID_SID);
        return FALSE;
    }

    if (cbDomainSid == NULL) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    if ( IS_EQUAL_AUTHORITY(RtlIdentifierAuthoritySid(pSid), 
              &KnownAuthoritiesAndDomains[NT_AUTHORITY_INDEX].Authority)) {

        SubAuthCount = *RtlSubAuthorityCountSid(pSid);
        if (SubAuthCount > SECURITY_NT_NON_UNIQUE_SUB_AUTH_COUNT) {
            ULONG FirstSubAuth;
            FirstSubAuth = *RtlSubAuthoritySid(pSid, 0);
            if ( (SECURITY_NT_NON_UNIQUE == FirstSubAuth) ) {
                // This is an NT Account Domain
                DomainSubAuthCount = SECURITY_NT_NON_UNIQUE_SUB_AUTH_COUNT+1;
                fRecognized = TRUE;
            }
        }
    }

    if (!fRecognized) {
        SetLastError(ERROR_NON_ACCOUNT_SID);
        return FALSE;
    }

    SizeRequired = RtlLengthRequiredSid(DomainSubAuthCount);
    if (*cbDomainSid < SizeRequired) {
        *cbDomainSid = SizeRequired;
        SetLastError(ERROR_INSUFFICIENT_BUFFER);
        return FALSE;
    }
    *cbDomainSid = SizeRequired;

    if (IsBadWritePtr(pDomainSid, SizeRequired)) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    Status = RtlInitializeSid(pDomainSid,
                              RtlIdentifierAuthoritySid(pSid),
                              DomainSubAuthCount);
    if (!NT_SUCCESS(Status)) {
        BaseSetLastNTError(Status);
        return FALSE;
    }

    for (i = 0; i < DomainSubAuthCount; i++) {
        *RtlSubAuthoritySid(pDomainSid, i) = *RtlSubAuthoritySid(pSid,i);
    }

    return TRUE;

}

WINADVAPI
BOOL
WINAPI
EqualDomainSid(
    IN PSID pSid1,
    IN PSID pSid2,
    OUT BOOL *pfEqual
    )
/*++

Routine Description:
    
    This routine determines if either 
    
    1) Both sids are the same domain SID
    
    2) One SID is from the other SID's domain
    
    The "domains" recognized are BUILTIN and NT account domains
    
Parameters:

    pSid1 -- the first SID
    
    pSid2 -- the second SID
    
    pfEqual -- on success, set to TRUE if the domain portions are equal

Return Values

    TRUE if the SID's are recognized (are either from an account domain or
    the BUILTIN domain).
    
    FALSE otherwise                           
    
    Win32 Errors:
    
    ERROR_NON_DOMAIN_SID
    ERROR_REVISION_MISMATCH
    ERROR_INVALID_PARAMETER
    ERROR_INVALID_SID
    

 --*/
{
    ULONG i;
    SID *ISid1 = pSid1;
    SID *ISid2 = pSid2;

    BYTE Buffer1[SECURITY_MAX_SID_SIZE];
    PSID BuiltinDomainSid = (PSID) Buffer1;

    BYTE Buffer2[SECURITY_MAX_SID_SIZE];
    PSID pDomainSid1 = (PSID) Buffer2;

    BYTE Buffer3[SECURITY_MAX_SID_SIZE];
    PSID pDomainSid2 = (PSID) Buffer3;

    ULONG Size;

    if ( !RtlValidSid(pSid1) || !RtlValidSid(pSid2) ) {
        SetLastError(ERROR_INVALID_SID);
        return FALSE;
    }

    if (NULL == pfEqual) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    if ( ISid1->Revision != ISid2->Revision ) {
        SetLastError(ERROR_REVISION_MISMATCH);
        return FALSE;
    }

    // Create the builtin SID
    Size = sizeof(Buffer1);
    if (!CreateWellKnownSid(WinBuiltinDomainSid, NULL, BuiltinDomainSid, &Size)) {
        // LastError is set
        return FALSE;
    }

    // Extract the first SID's domain portion if any
    Size = sizeof(Buffer2);
    if (!GetWindowsAccountDomainSid(pSid1, pDomainSid1, &Size)) {
        // The SID is not an account domain SID -- try for builtin
        pDomainSid1 = NULL;
        if ( (IS_EQUAL_AUTHORITY(RtlIdentifierAuthoritySid(pSid1), &KnownAuthoritiesAndDomains[NT_AUTHORITY_INDEX].Authority))
          && (*RtlSubAuthorityCountSid(pSid1) > 0)
          && (*RtlSubAuthoritySid(pSid1, 0) == SECURITY_BUILTIN_DOMAIN_RID)) {
                pDomainSid1 = BuiltinDomainSid;
        }
    }

    if (NULL == pDomainSid1) {
        SetLastError(ERROR_NON_DOMAIN_SID);
        return FALSE;
    }

    Size = sizeof(Buffer3);
    if (!GetWindowsAccountDomainSid(pSid2, pDomainSid2, &Size)) {
        // The SID is not an account domain SID -- try for builtin
        pDomainSid2 = NULL;
        if ( (IS_EQUAL_AUTHORITY(RtlIdentifierAuthoritySid(pSid2), &KnownAuthoritiesAndDomains[NT_AUTHORITY_INDEX].Authority))
          && (*RtlSubAuthorityCountSid(pSid2) > 0)
          && (*RtlSubAuthoritySid(pSid2, 0) == SECURITY_BUILTIN_DOMAIN_RID)) {
                pDomainSid2 = BuiltinDomainSid;
        }
    }

    if (NULL == pDomainSid2) {
        SetLastError(ERROR_NON_DOMAIN_SID);
        return FALSE;
    }

    *pfEqual = EqualSid(pDomainSid1, pDomainSid2);

    return TRUE;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\advapi32\sddl.c ===
/*++

Copyright (c) 1997-1998  Microsoft Corporation

Module Name:

    sddl.c

Abstract:

    This module implements the Security Descriptor Definition Language support functions

Author:

    Mac McLain          (MacM)       Nov 07, 1997

Environment:

    User Mode

Revision History:

    Jin Huang           (JinHuang)  3/4/98   Fix validity flags (GetAceFlagsInTable)
    Jin Huang           (JinHuang)  3/10/98  Add SD controls (GetSDControlForString)
                                             Set SidsInitialized flag
                                             Skip any possible spaces in string
    Jin Huang           (JinHuang)  5/1/98   Fix memory leek, error checking
                                             improve performance
    Alaa Abdelhalim     (Alaa)      7/20/99  Initialize sbz2 field to 0 in LocalGetAclForString
                                             function.
    Vishnu Patankar     (VishnuP)   7/5/00   Added new API ConvertStringSDToSDDomain(A/W)
    
    Shawn Wu            (ShawnWu)   4/27/02  Added encrypted ldap support.

--*/
#include "advapi.h"
#include <windef.h>
#include <stdio.h>
#include <wchar.h>
#include <sddl.h>
#include <ntseapi.h>
#include <seopaque.h>
#include <accctrl.h>
#include <rpcdce.h>
#include <ntlsa.h>
#include "sddlp.h"


//
// include and defines for ldap calls
//
#include <winldap.h>
#include <ntldap.h>

typedef PLDAP (LDAPAPI *PFN_LDAP_INIT)( PCHAR HostName, ULONG PortNumber );
typedef ULONG (LDAPAPI *PFN_LDAP_SET_OPTION) ( LDAP *, int , const void * );
typedef ULONG (LDAPAPI *PFN_LDAP_BIND)( LDAP *, PCHAR, PCHAR, ULONG);
typedef ULONG (LDAPAPI *PFN_LDAP_UNBIND)( LDAP * );
typedef ULONG (LDAPAPI *PFN_LDAP_SEARCH)(LDAP *, PCHAR, ULONG, PCHAR, PCHAR *, ULONG,PLDAPControlA *, PLDAPControlA *, struct l_timeval *, ULONG, LDAPMessage **);
typedef LDAPMessage * (LDAPAPI *PFN_LDAP_FIRST_ENTRY)( LDAP *, LDAPMessage * );
typedef PCHAR * (LDAPAPI *PFN_LDAP_GET_VALUE)(LDAP *, LDAPMessage *, PCHAR );
typedef ULONG (LDAPAPI *PFN_LDAP_MSGFREE)( LDAPMessage * );
typedef ULONG (LDAPAPI *PFN_LDAP_VALUE_FREE)( PCHAR * );
typedef ULONG (LDAPAPI *PFN_LDAP_MAP_ERROR)( ULONG );

// 64K-1
#define SDDL_MAX_ACL_SIZE      0xFFFF

#define SDDL_SID_STRING_SIZE    256


//
// To allow the defines to be used as Wide strings, redefine the TEXT macro
//
#ifdef TEXT
#undef TEXT
#endif
#define TEXT(quote) L##quote

//
// Local macros
//
#define STRING_GUID_LEN 36
#define STRING_GUID_SIZE  ( STRING_GUID_LEN * sizeof( WCHAR ) )
#define SDDL_LEN_TAG( tagdef )  ( sizeof( tagdef ) / sizeof( WCHAR ) - 1 )
#define SDDL_SIZE_TAG( tagdef )  ( wcslen( tagdef ) * sizeof( WCHAR ) )
#define SDDL_SIZE_SEP( sep ) (sizeof( WCHAR ) )

#define SDDL_VALID_DACL  0x00000001
#define SDDL_VALID_SACL  0x00000002

//
// This structure is used to do some lookups for mapping ACES
//
typedef struct _STRSD_KEY_LOOKUP {

    PWSTR Key;
    ULONG KeyLen;
    ULONG Value;
    ULONG ValidityFlags;

} STRSD_KEY_LOOKUP, *PSTRSD_KEY_LOOKUP;

typedef enum _STRSD_SID_TYPE {
    ST_DOMAIN_RELATIVE = 0,
    ST_WORLD,
    ST_LOCALSY,
    ST_LOCAL,
    ST_CREATOR,
    ST_NTAUTH,
    ST_BUILTIN,
    ST_ROOT_DOMAIN_RELATIVE
} STRSD_SID_TYPE;

//
// This structure is used to map account monikers to sids
//
typedef struct _STRSD_SID_LOOKUP {

    BOOLEAN Valid;
    WCHAR Key[SDDL_ALIAS_SIZE+2];
    ULONG KeyLen;
    PSID Sid;
    ULONG Rid;
    STRSD_SID_TYPE SidType;
    DWORD SidBuff[ sizeof( SID ) / sizeof( DWORD ) + 5];
} STRSD_SID_LOOKUP, *PSTRSD_SID_LOOKUP;

//
// Globally defined sids
//
/* JINHUANG: not used anywhere
DWORD PersonalSelfBuiltSid[sizeof(SID)/sizeof(DWORD) + 2];
DWORD AuthUserBuiltSid[sizeof(SID)/sizeof(DWORD) + 2];
DWORD CreatorOwnerBuiltSid[sizeof(SID)/sizeof(DWORD) + 2];
DWORD CreatorGroupBuiltSid[sizeof(SID)/sizeof(DWORD) + 2];
PSID  PersonalSelfSid = (PSID)PersonalSelfBuiltSid;
PSID  AuthUserSid = (PSID)AuthUserBuiltSid;
PSID  CreatorOwnerSid = (PSID)CreatorOwnerBuiltSid;
PSID  CreatorGroupSid = (PSID)CreatorGroupBuiltSid;
*/

CRITICAL_SECTION SddlSidLookupCritical;
static DWORD SidTableReinitializeInstance=0;

//    JINHUANG 3/26 BVT break for dcpromo
//
//    Some of the Valid fields were preset to TRUE with NULL Sid field. The SidLookup
//    table initialization is stopped if Status is not SUCCESS. So if error occurs,
//    for example, no domain info as in dcpromo, other SIDs will not be initialized
//    but the Valid fields are set to TRUE (with NULL SIDs).
//
//    changes: 1) preset Valid field to FALSE all all lookups and set the Valid to TRUE if
//                the SID is really initialized
//             2) do not stop the initialization process if an error occurs
//                if the Valid field is already TRUE (already initialized), skip the row
//
static STRSD_SID_LOOKUP  SidLookup[] = {
        { FALSE, SDDL_DOMAIN_ADMINISTRATORS, SDDL_LEN_TAG( SDDL_DOMAIN_ADMINISTRATORS ),
            NULL, DOMAIN_GROUP_RID_ADMINS, ST_DOMAIN_RELATIVE, 0 },
        { FALSE, SDDL_DOMAIN_GUESTS, SDDL_LEN_TAG( SDDL_DOMAIN_GUESTS ),
            NULL, DOMAIN_GROUP_RID_GUESTS, ST_DOMAIN_RELATIVE, 0 },
        { FALSE, SDDL_DOMAIN_USERS, SDDL_LEN_TAG( SDDL_DOMAIN_USERS ),
              NULL, DOMAIN_GROUP_RID_USERS, ST_DOMAIN_RELATIVE, 0 },
        { FALSE, SDDL_DOMAIN_DOMAIN_CONTROLLERS, SDDL_LEN_TAG( SDDL_DOMAIN_DOMAIN_CONTROLLERS ),
              NULL, DOMAIN_GROUP_RID_CONTROLLERS, ST_DOMAIN_RELATIVE, 0 },
        { FALSE, SDDL_DOMAIN_COMPUTERS, SDDL_LEN_TAG( SDDL_DOMAIN_COMPUTERS ),
              NULL, DOMAIN_GROUP_RID_COMPUTERS, ST_DOMAIN_RELATIVE, 0 },
        { FALSE, SDDL_SCHEMA_ADMINISTRATORS, SDDL_LEN_TAG( SDDL_SCHEMA_ADMINISTRATORS ),
              NULL, DOMAIN_GROUP_RID_SCHEMA_ADMINS, ST_ROOT_DOMAIN_RELATIVE, 0 },  // should be root domain only ST_DOMAIN_RELATIVE,
        { FALSE, SDDL_ENTERPRISE_ADMINS, SDDL_LEN_TAG( SDDL_ENTERPRISE_ADMINS ),
              NULL, DOMAIN_GROUP_RID_ENTERPRISE_ADMINS, ST_ROOT_DOMAIN_RELATIVE, 0 }, // root domain only
        { FALSE, SDDL_CERT_SERV_ADMINISTRATORS, SDDL_LEN_TAG( SDDL_CERT_SERV_ADMINISTRATORS ),
              NULL, DOMAIN_GROUP_RID_CERT_ADMINS, ST_DOMAIN_RELATIVE, 0 },
        { FALSE, SDDL_ACCOUNT_OPERATORS, SDDL_LEN_TAG( SDDL_ACCOUNT_OPERATORS ),
              NULL, DOMAIN_ALIAS_RID_ACCOUNT_OPS, ST_BUILTIN, 0 },
        { FALSE, SDDL_BACKUP_OPERATORS, SDDL_LEN_TAG( SDDL_BACKUP_OPERATORS ),
              NULL, DOMAIN_ALIAS_RID_BACKUP_OPS, ST_BUILTIN, 0 },
        { FALSE, SDDL_PRINTER_OPERATORS, SDDL_LEN_TAG( SDDL_PRINTER_OPERATORS ),
              NULL, DOMAIN_ALIAS_RID_PRINT_OPS, ST_BUILTIN, 0 },
        { FALSE, SDDL_SERVER_OPERATORS, SDDL_LEN_TAG( SDDL_SERVER_OPERATORS ),
              NULL, DOMAIN_ALIAS_RID_SYSTEM_OPS, ST_BUILTIN, 0 },
        { FALSE, SDDL_REPLICATOR, SDDL_LEN_TAG( SDDL_REPLICATOR ),
              NULL, DOMAIN_ALIAS_RID_REPLICATOR, ST_BUILTIN, 0 },
        { FALSE, SDDL_RAS_SERVERS, SDDL_LEN_TAG( SDDL_RAS_SERVERS ),
              NULL, DOMAIN_ALIAS_RID_RAS_SERVERS, ST_DOMAIN_RELATIVE, 0 },  // ST_LOCAL
        { FALSE, SDDL_AUTHENTICATED_USERS, SDDL_LEN_TAG( SDDL_AUTHENTICATED_USERS ),
              NULL, SECURITY_AUTHENTICATED_USER_RID, ST_NTAUTH, 0 },
        { FALSE, SDDL_PERSONAL_SELF, SDDL_LEN_TAG( SDDL_PERSONAL_SELF ),
              NULL, SECURITY_PRINCIPAL_SELF_RID, ST_NTAUTH, 0 },
        { FALSE, SDDL_CREATOR_OWNER, SDDL_LEN_TAG( SDDL_CREATOR_OWNER ),
              NULL, SECURITY_CREATOR_OWNER_RID, ST_CREATOR, 0 },
        { FALSE, SDDL_CREATOR_GROUP, SDDL_LEN_TAG( SDDL_CREATOR_GROUP ),
              NULL, SECURITY_CREATOR_GROUP_RID, ST_CREATOR, 0 },
        { FALSE, SDDL_LOCAL_SYSTEM, SDDL_LEN_TAG( SDDL_LOCAL_SYSTEM ),
              NULL, SECURITY_LOCAL_SYSTEM_RID, ST_NTAUTH, 0 },
        { FALSE, SDDL_INTERACTIVE, SDDL_LEN_TAG( SDDL_INTERACTIVE ),
              NULL, SECURITY_INTERACTIVE_RID, ST_NTAUTH, 0 },
        { FALSE, SDDL_NETWORK, SDDL_LEN_TAG( SDDL_NETWORK ),
              NULL, SECURITY_NETWORK_RID, ST_NTAUTH, 0 },
        { FALSE, SDDL_SERVICE, SDDL_LEN_TAG( SDDL_SERVICE ),
              NULL, SECURITY_SERVICE_RID, ST_NTAUTH, 0 },
        { FALSE, SDDL_ENTERPRISE_DOMAIN_CONTROLLERS, SDDL_LEN_TAG( SDDL_ENTERPRISE_DOMAIN_CONTROLLERS ),
              NULL, SECURITY_SERVER_LOGON_RID, ST_NTAUTH, 0 },
        { FALSE, SDDL_RESTRICTED_CODE, SDDL_LEN_TAG( SDDL_RESTRICTED_CODE ),
              NULL, SECURITY_RESTRICTED_CODE_RID, ST_NTAUTH, 0 },
        { FALSE, SDDL_ANONYMOUS, SDDL_LEN_TAG( SDDL_ANONYMOUS ),
              NULL, SECURITY_ANONYMOUS_LOGON_RID, ST_NTAUTH, 0 },
        { FALSE, SDDL_LOCAL_ADMIN, SDDL_LEN_TAG( SDDL_LOCAL_ADMIN ),
              NULL, DOMAIN_USER_RID_ADMIN, ST_LOCAL, 0 },
        { FALSE, SDDL_LOCAL_GUEST, SDDL_LEN_TAG( SDDL_LOCAL_GUEST ),
              NULL, DOMAIN_USER_RID_GUEST, ST_LOCAL, 0 },
        { FALSE, SDDL_BUILTIN_ADMINISTRATORS, SDDL_LEN_TAG( SDDL_BUILTIN_ADMINISTRATORS ),
              NULL, DOMAIN_ALIAS_RID_ADMINS, ST_BUILTIN, 0 },
        { FALSE, SDDL_BUILTIN_GUESTS, SDDL_LEN_TAG( SDDL_BUILTIN_GUESTS ),
              NULL, DOMAIN_ALIAS_RID_GUESTS, ST_BUILTIN, 0 },
        { FALSE, SDDL_BUILTIN_USERS, SDDL_LEN_TAG( SDDL_BUILTIN_USERS ),
              NULL, DOMAIN_ALIAS_RID_USERS, ST_BUILTIN, 0 },
        { FALSE, SDDL_POWER_USERS, SDDL_LEN_TAG( SDDL_POWER_USERS ),
              NULL, DOMAIN_ALIAS_RID_POWER_USERS, ST_BUILTIN, 0 },
        { FALSE, SDDL_EVERYONE, SDDL_LEN_TAG( SDDL_EVERYONE ),
              NULL, SECURITY_WORLD_RID, ST_WORLD, 0 },
        { FALSE, SDDL_GROUP_POLICY_ADMINS, SDDL_LEN_TAG( SDDL_GROUP_POLICY_ADMINS ),
              NULL, DOMAIN_GROUP_RID_POLICY_ADMINS, ST_DOMAIN_RELATIVE, 0 },
        { FALSE, SDDL_ALIAS_PREW2KCOMPACC, SDDL_LEN_TAG( SDDL_ALIAS_PREW2KCOMPACC ),
              NULL, DOMAIN_ALIAS_RID_PREW2KCOMPACCESS, ST_BUILTIN, 0 },
        { FALSE, SDDL_LOCAL_SERVICE, SDDL_LEN_TAG( SDDL_LOCAL_SERVICE ),
              NULL, SECURITY_LOCAL_SERVICE_RID, ST_NTAUTH, 0 },
        { FALSE, SDDL_NETWORK_SERVICE, SDDL_LEN_TAG( SDDL_NETWORK_SERVICE ),
              NULL, SECURITY_NETWORK_SERVICE_RID, ST_NTAUTH, 0 },
        { FALSE, SDDL_REMOTE_DESKTOP, SDDL_LEN_TAG( SDDL_REMOTE_DESKTOP ),
              NULL, DOMAIN_ALIAS_RID_REMOTE_DESKTOP_USERS, ST_BUILTIN, 0 },
        { FALSE, SDDL_NETWORK_CONFIGURATION_OPS, SDDL_LEN_TAG( SDDL_NETWORK_CONFIGURATION_OPS ),
              NULL, DOMAIN_ALIAS_RID_NETWORK_CONFIGURATION_OPS, ST_BUILTIN, 0 },                            
        { FALSE, SDDL_PERFMON_USERS, SDDL_LEN_TAG( SDDL_PERFMON_USERS ),
                    NULL, DOMAIN_ALIAS_RID_MONITORING_USERS, ST_BUILTIN, 0 },
        { FALSE, SDDL_PERFLOG_USERS, SDDL_LEN_TAG( SDDL_PERFLOG_USERS ),
              NULL, DOMAIN_ALIAS_RID_LOGGING_USERS, ST_BUILTIN, 0 }
    };



STRSD_SID_LOOKUP  SidLookupDomOrRootDomRelative[] = {
        { FALSE, SDDL_DOMAIN_ADMINISTRATORS, SDDL_LEN_TAG( SDDL_DOMAIN_ADMINISTRATORS ),
            NULL, DOMAIN_GROUP_RID_ADMINS, ST_DOMAIN_RELATIVE, 0 },
        { FALSE, SDDL_DOMAIN_GUESTS, SDDL_LEN_TAG( SDDL_DOMAIN_GUESTS ),
            NULL, DOMAIN_GROUP_RID_GUESTS, ST_DOMAIN_RELATIVE, 0 },
        { FALSE, SDDL_DOMAIN_USERS, SDDL_LEN_TAG( SDDL_DOMAIN_USERS ),
              NULL, DOMAIN_GROUP_RID_USERS, ST_DOMAIN_RELATIVE, 0 },
        { FALSE, SDDL_DOMAIN_DOMAIN_CONTROLLERS, SDDL_LEN_TAG( SDDL_DOMAIN_DOMAIN_CONTROLLERS ),
              NULL, DOMAIN_GROUP_RID_CONTROLLERS, ST_DOMAIN_RELATIVE, 0 },
        { FALSE, SDDL_DOMAIN_COMPUTERS, SDDL_LEN_TAG( SDDL_DOMAIN_COMPUTERS ),
              NULL, DOMAIN_GROUP_RID_COMPUTERS, ST_DOMAIN_RELATIVE, 0 },
        { FALSE, SDDL_CERT_SERV_ADMINISTRATORS, SDDL_LEN_TAG( SDDL_CERT_SERV_ADMINISTRATORS ),
              NULL, DOMAIN_GROUP_RID_CERT_ADMINS, ST_DOMAIN_RELATIVE, 0 },
        { FALSE, SDDL_RAS_SERVERS, SDDL_LEN_TAG( SDDL_RAS_SERVERS ),
              NULL, DOMAIN_ALIAS_RID_RAS_SERVERS, ST_DOMAIN_RELATIVE, 0 },  // ST_LOCAL
        { FALSE, SDDL_GROUP_POLICY_ADMINS, SDDL_LEN_TAG( SDDL_GROUP_POLICY_ADMINS ),
              NULL, DOMAIN_GROUP_RID_POLICY_ADMINS, ST_DOMAIN_RELATIVE, 0 },
        { FALSE, SDDL_SCHEMA_ADMINISTRATORS, SDDL_LEN_TAG( SDDL_SCHEMA_ADMINISTRATORS ),
            NULL, DOMAIN_GROUP_RID_SCHEMA_ADMINS, ST_ROOT_DOMAIN_RELATIVE, 0 },
        { FALSE, SDDL_ENTERPRISE_ADMINS, SDDL_LEN_TAG( SDDL_ENTERPRISE_ADMINS ),
            NULL, DOMAIN_GROUP_RID_ENTERPRISE_ADMINS, ST_ROOT_DOMAIN_RELATIVE, 0 }
    };




static DWORD RootDomSidBuf[sizeof(SID)/sizeof(DWORD)+5];
static BOOL RootDomInited=FALSE;

#define STRSD_REINITIALIZE_ENTER              1
#define STRSD_REINITIALIZE_LEAVE              2

BOOLEAN
InitializeSidLookupTable(
    IN BYTE InitFlag
    );

//
// Control Lookup table
//
static STRSD_KEY_LOOKUP ControlLookup[] = {
    { SDDL_PROTECTED, SDDL_LEN_TAG( SDDL_PROTECTED ), SE_DACL_PROTECTED, SDDL_VALID_DACL },
    { SDDL_AUTO_INHERIT_REQ, SDDL_LEN_TAG( SDDL_AUTO_INHERIT_REQ ), SE_DACL_AUTO_INHERIT_REQ, SDDL_VALID_DACL },
    { SDDL_AUTO_INHERITED, SDDL_LEN_TAG( SDDL_AUTO_INHERITED ), SE_DACL_AUTO_INHERITED, SDDL_VALID_DACL },
    { SDDL_PROTECTED, SDDL_LEN_TAG( SDDL_PROTECTED ), SE_SACL_PROTECTED, SDDL_VALID_SACL },
    { SDDL_AUTO_INHERIT_REQ, SDDL_LEN_TAG( SDDL_AUTO_INHERIT_REQ ), SE_SACL_AUTO_INHERIT_REQ, SDDL_VALID_SACL },
    { SDDL_AUTO_INHERITED, SDDL_LEN_TAG( SDDL_AUTO_INHERITED ), SE_SACL_AUTO_INHERITED, SDDL_VALID_SACL }
    };

//
// Local prototypes
//
BOOL
LocalConvertStringSidToSid(
    IN  PWSTR String,
    OUT PSID *SID,
    OUT PWSTR *End
    );

PSTRSD_SID_LOOKUP
LookupSidInTable(
    IN PWSTR String, OPTIONAL
    IN PSID Sid OPTIONAL,
    IN PSID RootDomainSid OPTIONAL,
    IN PSID DomainSid OPTIONAL,
    IN PSTRSD_SID_LOOKUP tSidLookupDomOrRootDomRelativeTable OPTIONAL,
    IN BOOLEAN DefaultToDomain,
    OUT PVOID *pSASid
    );

DWORD
LocalGetSidForString(
    IN  PWSTR String,
    OUT PSID *SID,
    OUT PWSTR *End,
    OUT PBOOLEAN FreeSid,
    IN  PSID RootDomainSid OPTIONAL,
    IN  PSID DomainSid OPTIONAL,
    IN  PSTRSD_SID_LOOKUP tSidLookupDomOrRootDomRelativeTable OPTIONAL,
    IN  BOOLEAN DefaultToDomain
    );

PSTRSD_KEY_LOOKUP
LookupAccessMaskInTable(
    IN PWSTR String, OPTIONAL
    IN ULONG AccessMask, OPTIONAL
    IN ULONG LookupFlags
    );


PSTRSD_KEY_LOOKUP
LookupAceTypeInTable(
    IN PWSTR String, OPTIONAL
    IN ULONG AceType, OPTIONAL
    IN ULONG LookupFlags
    );

PSTRSD_KEY_LOOKUP
LookupAceFlagsInTable(
    IN PWSTR String, OPTIONAL
    IN ULONG AceFlags OPTIONAL,
    IN ULONG LookupFlags
    );

DWORD
LocalGetStringForSid(
    IN  PSID Sid,
    OUT PWSTR *String,
    IN  PSID RootDomainSid OPTIONAL
    );

DWORD
LocalGetStringForControl(
    IN SECURITY_DESCRIPTOR_CONTROL ControlCode,
    IN ULONG LookupFlags,
    OUT PWSTR *ControlString
    );

DWORD
LocalGetSDControlForString (
    IN  PWSTR AclString,
    IN ULONG LookupFlags,
    OUT SECURITY_DESCRIPTOR_CONTROL *pControl,
    OUT PWSTR *End
    );

DWORD
LocalGetAclForString (
    IN  PWSTR AclString,
    IN  BOOLEAN ConvertAsDacl,
    OUT PACL *Acl,
    OUT PWSTR *End,
    IN  PSID RootDomainSid OPTIONAL,
    IN  PSID DomainSid OPTIONAL,
    IN  PSTRSD_SID_LOOKUP tSidLookupDomOrRootDomRelativeTable OPTIONAL,
    IN  BOOLEAN DefaultToDomain
    );

DWORD
LocalConvertAclToString(
    IN PACL Acl,
    IN BOOLEAN AclPresent,
    IN BOOLEAN ConvertAsDacl,
    OUT PWSTR *AclString,
    OUT PDWORD AclStringSize,
    IN PSID RootDomainSid OPTIONAL
    );

DWORD
LocalConvertSDToStringSD_Rev1(
    IN  PSID RootDomainSid OPTIONAL,
    IN  PSECURITY_DESCRIPTOR  SecurityDescriptor,
    IN  SECURITY_INFORMATION  SecurityInformation,
    OUT LPWSTR  *StringSecurityDescriptor,
    OUT PULONG StringSecurityDescriptorLen OPTIONAL
    );

DWORD
LocalConvertStringSDToSD_Rev1(
    IN  PSID RootDomainSid OPTIONAL,
    IN  PSID DomainSid OPTIONAL,
    IN  BOOLEAN DefaultToDomain,
    IN  LPCWSTR StringSecurityDescriptor,
    OUT PSECURITY_DESCRIPTOR  *SecurityDescriptor,
    OUT PULONG  SecurityDescriptorSize OPTIONAL
    );

BOOL
SddlpGetRootDomainSid(void);

//
// Exported functions
//

BOOL
APIENTRY
ConvertSidToStringSidA(
    IN  PSID     Sid,
    OUT LPSTR  *StringSid
    )
/*++

Routine Description:

    ANSI thunk to ConvertSidToStringSidW

--*/
{
    LPWSTR StringSidW = NULL;
    ULONG AnsiLen, WideLen;
    BOOL ReturnValue;

    if ( NULL == StringSid ) {
        //
        // invalid parameter
        //
        SetLastError( ERROR_INVALID_PARAMETER );
        return(FALSE);
    }

    ReturnValue = ConvertSidToStringSidW( Sid, &StringSidW );

    if ( ReturnValue ) {

        WideLen = wcslen( StringSidW ) + 1;

        AnsiLen = WideCharToMultiByte( CP_ACP,
                                       0,
                                       StringSidW,
                                       WideLen,
                                       *StringSid,
                                       0,
                                       NULL,
                                       NULL );

        if ( AnsiLen != 0 ) {

            *StringSid = LocalAlloc( LMEM_FIXED, AnsiLen );

            if ( *StringSid == NULL ) {

                SetLastError( ERROR_NOT_ENOUGH_MEMORY );
                ReturnValue = FALSE;

            } else {

                AnsiLen = WideCharToMultiByte( CP_ACP,
                                               0,
                                               StringSidW,
                                               WideLen,
                                               *StringSid,
                                               AnsiLen,
                                               NULL,
                                               NULL );
                ASSERT( AnsiLen != 0 );

                if ( AnsiLen == 0 ) {

                    ReturnValue = FALSE;
                    //
                    // jinhuang: failed, free the buffer
                    //
                    LocalFree(*StringSid);
                    *StringSid = NULL;
                }
            }

        } else {

            ReturnValue = FALSE;
        }

    }

    //
    // jinhuang: free the wide buffer
    //
    if ( StringSidW ) {
        LocalFree(StringSidW);
    }

    if ( ReturnValue ) {
        SetLastError(ERROR_SUCCESS);
    }

    return( ReturnValue );

}


BOOL
APIENTRY
ConvertSidToStringSidW(
    IN  PSID     Sid,
    OUT LPWSTR  *StringSid
    )
/*++

Routine Description:

    This routine converts a SID into a string representation of a SID, suitable for framing or
    display

Arguments:

    Sid - SID to be converted.

    StringSid - Where the converted SID is returned.  Allocated via LocalAlloc and needs to
        be freed via LocalFree.


Return Value:

    TRUE    -   Success
    FALSE   -   Failure

    Extended error status is available using GetLastError.

--*/
{
    NTSTATUS Status;
    UNICODE_STRING UnicodeStringSid;

    if ( NULL == Sid || NULL == StringSid ) {
        //
        // invalid parameter
        //
        SetLastError( ERROR_INVALID_PARAMETER );
        return( FALSE );
    }

    //
    // Convert using the Rtl functions
    //
    Status = RtlConvertSidToUnicodeString( &UnicodeStringSid, Sid, TRUE );

    if ( !NT_SUCCESS( Status ) ) {

        BaseSetLastNTError( Status );
        return( FALSE );
    }

    //
    // Convert it to the proper allocator
    //
    *StringSid = LocalAlloc( LMEM_FIXED | LMEM_ZEROINIT,
                             UnicodeStringSid.Length + sizeof( WCHAR ) );

    if ( *StringSid == NULL ) {

        RtlFreeUnicodeString( &UnicodeStringSid );

        SetLastError( ERROR_NOT_ENOUGH_MEMORY );
        return( FALSE );

    }

    RtlCopyMemory( *StringSid, UnicodeStringSid.Buffer, UnicodeStringSid.Length );
    RtlFreeUnicodeString( &UnicodeStringSid );

    SetLastError(ERROR_SUCCESS);
    return( TRUE );
}


BOOL
APIENTRY
ConvertStringSidToSidA(
    IN LPCSTR  StringSid,
    OUT PSID   *Sid
    )
/*++

Routine Description:

    ANSI thunk to ConvertStringSidToSidW

--*/
{
    UNICODE_STRING Unicode;
    ANSI_STRING AnsiString;
    NTSTATUS Status;
    BOOL Result;

    if ( NULL == StringSid || NULL == Sid ) {

        SetLastError( ERROR_INVALID_PARAMETER );
        return(FALSE);
    }

    RtlInitAnsiString( &AnsiString, StringSid );

    Status = SddlpAnsiStringToUnicodeString(&Unicode,
                                            &AnsiString);

    if ( !NT_SUCCESS( Status ) ) {

        BaseSetLastNTError( Status );

        return FALSE;

    }


    Result = ConvertStringSidToSidW( ( LPCWSTR )Unicode.Buffer, Sid );

    LocalFree( Unicode.Buffer );

    if ( Result ) {
        SetLastError(ERROR_SUCCESS);
    }

    return( Result );
}


BOOL
APIENTRY
ConvertStringSidToSidW(
    IN LPCWSTR  StringSid,
    OUT PSID   *Sid
    )
/*++

Routine Description:

    This routine converts a stringized SID into a valid, functional SID

Arguments:

    StringSid - SID to be converted.

    Sid - Where the converted SID is returned.  Buffer is allocated via LocalAlloc and should
        be free via LocalFree.


Return Value:

    TRUE    -   Success
    FALSE   -   Failure

    Extended error status is available using GetLastError.

        ERROR_INVALID_PARAMETER - A NULL name was given

        ERROR_INVALID_SID - The format of the given sid was incorrect

--*/
{
    PWSTR End = NULL;
    BOOL ReturnValue = FALSE;
    PSTRSD_SID_LOOKUP MatchedEntry=NULL;
    PSID pSASid=NULL;
    ULONG Len=0;
    DWORD SaveCode=0;
    DWORD Err=0;

    if ( StringSid == NULL || Sid == NULL ) {

        SetLastError( ERROR_INVALID_PARAMETER );

    } else {

        ReturnValue = LocalConvertStringSidToSid( ( PWSTR )StringSid, Sid, &End );


        if ( ReturnValue == TRUE ) {

            if ( ( ULONG )( End - StringSid ) != wcslen( StringSid ) ) {

                SetLastError( ERROR_INVALID_SID );
                LocalFree( *Sid );
                *Sid = FALSE;
                ReturnValue = FALSE;

            } else {
                SetLastError(ERROR_SUCCESS);
            }

        } else {

            SaveCode = GetLastError();

            //
            // lookup in the SidLookup table to see if it's pre-defined
            //

            MatchedEntry = LookupSidInTable( (PWSTR)StringSid,
                                             NULL,
                                             NULL,
                                             NULL,
                                             NULL,
                                             FALSE,
                                             (PVOID *)&pSASid);

            if ( MatchedEntry && MatchedEntry->Sid ) {

                //
                // find it in the table, check if the input string is valid
                //
                if ( wcslen( (PWSTR)StringSid ) != MatchedEntry->KeyLen ) {

                    //
                    // the total string length doesn't match the table define
                    //
                    SetLastError(ERROR_INVALID_SID);

                } else {

                    //
                    // matched! now copy it to the output buffer
                    //
                    Len = RtlLengthSid ( MatchedEntry->Sid );

                    *Sid = ( PSID )LocalAlloc( LMEM_FIXED | LMEM_ZEROINIT, Len );

                    if ( *Sid == NULL ) {

                        SetLastError(ERROR_NOT_ENOUGH_MEMORY);

                    } else {

                        Err = RtlNtStatusToDosError(RtlCopySid ( Len, *Sid, MatchedEntry->Sid ) );

                        if ( ERROR_SUCCESS == Err ) {

                            ReturnValue = TRUE;

                        } else {

                            LocalFree(*Sid);
                            *Sid = NULL;
                        }

                        SetLastError(Err);

                    }
                }

            } else if ( pSASid && wcslen((PWSTR)StringSid) == SDDL_LEN_TAG( SDDL_SCHEMA_ADMINISTRATORS ) ) {
                //
                // this is schema admin SID
                //
                *Sid = pSASid;
                pSASid = NULL;

                ReturnValue = TRUE;

                SetLastError(ERROR_SUCCESS);

            } else {
                //
                // reset last error
                //
                SetLastError(SaveCode);
            }
        }

        if ( pSASid ) {
            LocalFree(pSASid);
        }
    }

    return( ReturnValue );

}


BOOL
APIENTRY
ConvertStringSecurityDescriptorToSecurityDescriptorA(
    IN  LPCSTR StringSecurityDescriptor,
    IN  DWORD StringSDRevision,
    OUT PSECURITY_DESCRIPTOR  *SecurityDescriptor,
    OUT PULONG  SecurityDescriptorSize OPTIONAL
    )
/*++

Routine Description:

    ANSI thunk to ConvertStringSecurityDescriptorToSecurityDescriptorW

--*/
{
    UNICODE_STRING Unicode;
    ANSI_STRING AnsiString;
    NTSTATUS Status;
    BOOL Result;

    if ( NULL == StringSecurityDescriptor ||
         NULL == SecurityDescriptor ) {

        SetLastError(ERROR_INVALID_PARAMETER);
        return(FALSE);
    }

    RtlInitAnsiString( &AnsiString, StringSecurityDescriptor );

    Status = SddlpAnsiStringToUnicodeString(&Unicode,                                                             
                                            &AnsiString);

    if ( !NT_SUCCESS( Status ) ) {

        BaseSetLastNTError( Status );

        return FALSE;

    }

    Result = ConvertStringSecurityDescriptorToSecurityDescriptorW( ( LPCWSTR )Unicode.Buffer,
                                                                   StringSDRevision,
                                                                   SecurityDescriptor,
                                                                   SecurityDescriptorSize);

    LocalFree( Unicode.Buffer );

    if ( Result ) {
        SetLastError(ERROR_SUCCESS);
    }

    return( Result );
}



BOOL
APIENTRY
ConvertStringSecurityDescriptorToSecurityDescriptorW(
    IN  LPCWSTR StringSecurityDescriptor,
    IN  DWORD StringSDRevision,
    OUT PSECURITY_DESCRIPTOR  *SecurityDescriptor,
    OUT PULONG  SecurityDescriptorSize OPTIONAL
    )
/*++

Routine Description:

    This routine converts a stringized Security descriptor into a valid, functional security
    descriptor

    Ex:
    SD:[O:xyz][G:xyz][D: (Ace1)(Ace2)][S: (Ace3)(Ace4)]
          where some Ace is (OA;CIIO; DS_READ; OT: abc; IOT: abc; SID: xyz)

    So a possible Security descriptor may be (as all one long string):

    L"O:AOG:DAD:(A;IO;RPRWXRCWDWO;;;S-1-0-0)(OA;CI;RWX;af110080-1b13-11d0-af10-0020afd3606c;"
    L"a153d9e0-1b13-11d0-af10-0020afd3606c;AUS)(A;SAFA;0x7800003F;;;DA)(OA;FA;X;"
    L"954378e0-1b13-11d0-af10-0020afd3606c;880b12a0-1b13-11d0-af10-0020afd3606c;PO)"

    would build a security descriptor:

    Revision: 0x1
    Sbz1: 0x0
    Control: 0x8014
    Owner: S-1-5-32-548

    Group:S-1-5-32-544

    Dacl: Revision: 4
    AceCount: 2
    InUse: 84
    Free: 52
    Flags: 0
            Ace  0:
                Type: 0
                Flags: 0x1
                Size: 0x14
                Mask: 0xe00e0010
                S-1-0-0

            Ace  1:
                Type: 5
                Flags: 0x2
                Size: 0x38
                Mask: 0xe0000000
                af110080-1b13-11d0-af100020afd3606c
                a153d9e0-1b13-11d0-af100020afd3606c
                S-1-5-11


    sacl: Revision: 4
    AceCount: 2
    InUse: 92
    Free: 44
    Flags: 0
            Ace  0:
                Type: 2
                Flags: 0xc0
                Size: 0x18
                Mask: 0xe0000000
                S-1-5-32-544

            Ace  1:
                Type: 7
                Flags: 0x80
                Size: 0x3c
                Mask: 0x20000000
                954378e0-1b13-11d0-af100020afd3606c
                880b12a0-1b13-11d0-af100020afd3606c
                S-1-5-32-550
Arguments:

    StringSecurityDescriptor - Stringized security descriptor to be converted.

    StringSDRevision - String revision of the input string SD

    SecurityDescriptor - Where the converted SD is returned.  Buffer is allocated via
        LocalAlloc and should be free via LocalFree.  The returned security descriptor
        is always self relative

    SecurityDescriptorSize - OPTIONAL.  If non-NULL, the size of the converted security
        descriptor is returned here.


Return Value:

    TRUE    -   Success
    FALSE   -   Failure

    Extended error status is available using GetLastError.

        ERROR_INVALID_PARAMETER - A NULL input or output parameter was given

        ERROR_UNKNOWN_REVISION - An unsupported revision was given

--*/
{
    DWORD Err = ERROR_SUCCESS;

    //
    // Little elementary parameter checking...
    //
    if ( StringSecurityDescriptor == NULL || SecurityDescriptor == NULL ) {

        Err = ERROR_INVALID_PARAMETER;

    } else {

        switch ( StringSDRevision ) {
        case SDDL_REVISION_1:

            Err = LocalConvertStringSDToSD_Rev1( NULL,  // no root domain sid is provided
                                                 NULL,  // no domain sid is provided for this API
                                                 FALSE, //TRUE, do not default to domain for EA/SA
                                                 StringSecurityDescriptor,
                                                 SecurityDescriptor,
                                                 SecurityDescriptorSize);
            break;

        default:

            Err = ERROR_UNKNOWN_REVISION;
            break;
        }

    }

    SetLastError( Err );

    return( Err == ERROR_SUCCESS );
}


BOOL
APIENTRY
ConvertSecurityDescriptorToStringSecurityDescriptorA(
    IN  PSECURITY_DESCRIPTOR  SecurityDescriptor,
    IN  DWORD RequestedStringSDRevision,
    IN  SECURITY_INFORMATION SecurityInformation,
    OUT LPSTR  *StringSecurityDescriptor,
    OUT PULONG StringSecurityDescriptorLen OPTIONAL
    )
/*++

Routine Description:

    ANSI thunk to ConvertSecurityDescriptorToStringSecurityDescriptorW

--*/
{
    LPWSTR StringSecurityDescriptorW = NULL;
    ULONG AnsiLen, WideLen = 0;
    BOOL ReturnValue ;

    if ( StringSecurityDescriptor == NULL ) {

        SetLastError( ERROR_INVALID_PARAMETER );
        return( FALSE );
    }

    ReturnValue = ConvertSecurityDescriptorToStringSecurityDescriptorW(
                      SecurityDescriptor,
                      RequestedStringSDRevision,
                      SecurityInformation,
                      &StringSecurityDescriptorW,
                      &WideLen );

    if ( ReturnValue ) {


        //  jinhuang: WindeLen is returned from previous call
        //        WideLen = wcslen( StringSecurityDescriptorW ) + 1;


        AnsiLen = WideCharToMultiByte( CP_ACP,
                                       0,
                                       StringSecurityDescriptorW,
                                       WideLen + 1,
                                       *StringSecurityDescriptor,
                                       0,
                                       NULL,
                                       NULL );

        if ( AnsiLen != 0 ) {

            *StringSecurityDescriptor = LocalAlloc( LMEM_FIXED, AnsiLen );

            if ( *StringSecurityDescriptor == NULL ) {

                SetLastError( ERROR_NOT_ENOUGH_MEMORY );
                ReturnValue = FALSE;

            } else {

                AnsiLen = WideCharToMultiByte( CP_ACP,
                                               0,
                                               StringSecurityDescriptorW,
                                               WideLen + 1,
                                               *StringSecurityDescriptor,
                                               AnsiLen,
                                               NULL,
                                               NULL );
                ASSERT( AnsiLen != 0 );

                if ( AnsiLen == 0 ) {

                    LocalFree(*StringSecurityDescriptor);
                    *StringSecurityDescriptor = NULL;

                    ReturnValue = FALSE;
                }

                //
                // jinhuang
                // output the length (optional)
                //
                if ( StringSecurityDescriptorLen ) {
                    *StringSecurityDescriptorLen = AnsiLen;
                }

            }

        } else {

            ReturnValue = FALSE;
        }

        //
        // jinhuang
        // StringSecurityDescriptorW should be freed
        //

        LocalFree(StringSecurityDescriptorW);

    }

    if ( ReturnValue ) {
        SetLastError(ERROR_SUCCESS);
    }

    return( ReturnValue );
}


BOOL
APIENTRY
ConvertSecurityDescriptorToStringSecurityDescriptorW(
    IN  PSECURITY_DESCRIPTOR  SecurityDescriptor,
    IN  DWORD RequestedStringSDRevision,
    IN  SECURITY_INFORMATION SecurityInformation,
    OUT LPWSTR  *StringSecurityDescriptor,
    OUT PULONG StringSecurityDescriptorLen OPTIONAL
    )
/*++

Routine Description:

    This routine converts a security descriptor into a string version persuant to SDDL definition

Arguments:

    SecurityDescriptor - Security Descriptor to be converted.

    RequestedStringSDRevision - Requested revision of the output string security descriptor

    SecurityInformation - security information of which to be converted

    StringSecurityDescriptor - Where the converted SD is returned.  Buffer is allocated via
        LocalAlloc and should be free via LocalFree.

    StringSecurityDescriptorLen - the optional length of the converted SD

Return Value:

    TRUE    -   Success
    FALSE   -   Failure

    Extended error status is available using GetLastError.

        ERROR_INVALID_PARAMETER - A NULL input or output parameter was given

        ERROR_UNKNOWN_REVISION - An unsupported revision was given

--*/
{
    DWORD Err = ERROR_SUCCESS;

    //
    // A little parameter checking...
    //

    if  ( (SecurityDescriptor == NULL || SecurityInformation == 0) && 
          StringSecurityDescriptor ) {
        
        *StringSecurityDescriptor = LocalAlloc( LMEM_FIXED | LMEM_ZEROINIT, sizeof( WCHAR ) );

        if (*StringSecurityDescriptor) {
            
            (*StringSecurityDescriptor)[0] = L'\0';

            if (StringSecurityDescriptorLen) {

                *StringSecurityDescriptorLen = 0;
            
            }

        }

        else {
            
            Err = ERROR_NOT_ENOUGH_MEMORY;

        }

        SetLastError( Err );

        return( Err == ERROR_SUCCESS );

    }
    
    if ( SecurityDescriptor == NULL || StringSecurityDescriptor == NULL ||
         SecurityInformation == 0 ) {

        Err =  ERROR_INVALID_PARAMETER;

    } else {

        switch ( RequestedStringSDRevision ) {
        case SDDL_REVISION_1:

            Err = LocalConvertSDToStringSD_Rev1( NULL,  // root domain sid is not privided
                                                 SecurityDescriptor,
                                                 SecurityInformation,
                                                 StringSecurityDescriptor,
                                                 StringSecurityDescriptorLen );
            break;

        default:
            Err = ERROR_UNKNOWN_REVISION;
            break;
        }

    }

    SetLastError( Err );

    return( Err == ERROR_SUCCESS);
}



//
// Private functions
//
BOOL
LocalConvertStringSidToSid (
    IN  PWSTR       StringSid,
    OUT PSID       *Sid,
    OUT PWSTR      *End
    )
/*++

Routine Description:

    This routine will convert a string representation of a SID back into
    a sid.  The expected format of the string is:
                "S-1-5-32-549"
    If a string in a different format or an incorrect or incomplete string
    is given, the operation is failed.

    The returned sid must be free via a call to LocalFree


Arguments:

    StringSid - The string to be converted

    Sid - Where the created SID is to be returned

    End - Where in the string we stopped processing


Return Value:

    TRUE - Success.

    FALSE - Failure.  Additional information returned from GetLastError().  Errors set are:

            ERROR_SUCCESS indicates success

            ERROR_NOT_ENOUGH_MEMORY indicates a memory allocation for the ouput sid
                                    failed
            ERROR_INVALID_SID indicates that the given string did not represent a sid

--*/
{
    DWORD Err = ERROR_SUCCESS;
    UCHAR Revision, Subs;
    SID_IDENTIFIER_AUTHORITY IDAuth;
    PULONG SubAuth = NULL;
    PWSTR CurrEnd, Curr, Next;

    ULONG Index;
    INT gBase=10;
    INT lBase=10;
    ULONGLONG Auto;
    ULONG ulRev;
        
    //
    // ID authority is defined to be a 48 bit value
    //

    const ULONGLONG ullMaxIdAuthority = 0x0000FFFFFFFFFFFF;

    WCHAR wchSidString[SDDL_SID_STRING_SIZE];
    PWSTR pwszHeapSidStr = NULL;

    if ( NULL == StringSid || NULL == Sid || NULL == End ) {

        SetLastError( ERROR_INVALID_PARAMETER );
        return( FALSE );

    }

//    if ( wcslen( StringSid ) < 2 || ( *StringSid != L'S' && *( StringSid + 1 ) != L'-' ) ) {

    //
    // no need to check length because StringSid is NULL
    // and if the first char is NULL, it won't access the second char
    //
    if ( (*StringSid != L'S' && *StringSid != L's') ||
         *( StringSid + 1 ) != L'-' ) {
        //
        // string sid should always start with S-
        //
        SetLastError( ERROR_INVALID_SID );
        return( FALSE );
    }


    Curr = StringSid + 2;

    if ( (*Curr == L'0') &&
         ( *(Curr+1) == L'x' ||
           *(Curr+1) == L'X' ) ) {

        gBase = 16;
    }

    ulRev = wcstoul( Curr, &CurrEnd, gBase );

    if (ulRev > 0xFF || CurrEnd == Curr || *CurrEnd != L'-' || *(CurrEnd+1) == L'\0' ) {
        //
        // no revision is provided, or invalid delimeter
        //
        SetLastError( ERROR_INVALID_SID );
        return( FALSE );
    }

    Revision = (UCHAR)ulRev;

    Curr = CurrEnd + 1;

    //
    // Count the number of characters in the indentifer authority...
    //
    Next = wcschr( Curr, L'-' );
    if (Next == NULL || Next == Curr)
    {
        //
        // no identifier authority
        //

        SetLastError( ERROR_INVALID_SID );
        return( FALSE );
    }

/*
    Length = 6 doesn't mean each digit is a id authority value, could be 0x...

    if ( Next != NULL && (Next - Curr == 6) ) {

        for ( Index = 0; Index < 6; Index++ ) {

//            IDAuth.Value[Index] = (UCHAR)Next[Index];  what is this ???
            IDAuth.Value[Index] = (BYTE) (Curr[Index]-L'0');
        }

        Curr +=6;

    } else {
*/
        if ( (*Curr == L'0') &&
             ( *(Curr+1) == L'x' ||
               *(Curr+1) == L'X' ) ) {

            lBase = 16;
        } else {
            lBase = gBase;
        }

        Auto = _wcstoui64( Curr, &CurrEnd, lBase );

        if (Auto > ullMaxIdAuthority)
        {
            //
            // Must be overflow
            //

            SetLastError( ERROR_INVALID_SID );
            return FALSE;
        }


         if ( CurrEnd == Curr || *CurrEnd != L'-' || *(CurrEnd+1) == L'\0' ) {
             //
             // no revision is provided, or invalid delimeter
             //
             SetLastError( ERROR_INVALID_SID );
             return( FALSE );
         }

         IDAuth.Value[5] = ( UCHAR )Auto & 0xFF;
         IDAuth.Value[4] = ( UCHAR )(( Auto >> 8 ) & 0xFF );
         IDAuth.Value[3] = ( UCHAR )(( Auto >> 16 ) & 0xFF );
         IDAuth.Value[2] = ( UCHAR )(( Auto >> 24 ) & 0xFF );
         IDAuth.Value[1] = ( UCHAR )(( Auto >> 32 ) & 0xFF );
         IDAuth.Value[0] = ( UCHAR )(( Auto >> 40 ) & 0xFF );
         Curr = CurrEnd;
//    }

    //
    // Now, count the number of sub auths, at least one sub auth is required
    //
    Subs = 0;
    Next = Curr;

    //
    // We'll have to count our sub authoritys one character at a time,
    // since there are several deliminators that we can have...
    //

    while ( Next ) {

        if ( *Next == L'-' && *(Next-1) != L'-') {

            //
            // do not allow two continuous '-'s
            // We've found one!
            //
            Subs++;

            if ( (*(Next+1) == L'0') &&
                 ( *(Next+2) == L'x' ||
                   *(Next+2) == L'X' ) ) {
                //
                // this is hex indicator
                //
                Next += 2;

            }

        } else if ( *Next == SDDL_SEPERATORC || *Next  == L'\0' ||
                    *Next == SDDL_ACE_ENDC || *Next == L' ' ||
                    ( *(Next+1) == SDDL_DELIMINATORC &&
                      (*Next == L'G' || *Next == L'O' || *Next == L'S')) ) {
            //
            // space is a terminator too
            //
            if ( *( Next - 1 ) == L'-' ) {
                //
                // shouldn't allow a SID terminated with '-'
                //
                Err = ERROR_INVALID_SID;
                Next--;

            } else {
                Subs++;
            }

            *End = Next;
            break;

        } else if ( !iswxdigit( *Next ) ) {

            Err = ERROR_INVALID_SID;
            *End = Next;
//            Subs++;
            break;

        } else {

            //
            // Note: SID is also used as a owner or group
            //
            // Some of the tags (namely 'D' for Dacl) fall under the category of iswxdigit, so
            // if the current character is a character we care about and the next one is a
            // delminiator, we'll quit
            //
            if ( *Next == L'D' && *( Next + 1 ) == SDDL_DELIMINATORC ) {

                //
                // We need to make a copy this of SID string from Curr to Next
                //
                
                LPCWSTR pwszStart = Curr;
                
                //
                // For majority, the our stack variable's size is large enough.
                // This will perform much better.
                //
                
                if ( (Next - pwszStart) < SDDL_SID_STRING_SIZE )
                {
                    Curr = wchSidString;
                }
                else
                {
                    pwszHeapSidStr = (PWSTR)LocalAlloc(LPTR, ((Next - pwszStart) + 1) * sizeof(WCHAR));
                    if ( NULL == pwszHeapSidStr )
                    {
                        Err = ERROR_NOT_ENOUGH_MEMORY;
                        break;
                    }
                    else
                    {
                        Curr = pwszHeapSidStr;
                    }
                }
                
                //
                // Copy the sub-string of the sid and then NULL terminate it
                //
                
                memcpy(Curr, pwszStart, (Next - pwszStart) * sizeof(WCHAR));
                Curr[(Next - pwszStart)] = L'\0';
              
                *End = Next;
                Subs++;
                break;
            }

        }

        Next++;

    }

    if ( Err == ERROR_SUCCESS ) {

        if ( Subs != 0 ) Subs--;

        if ( Subs != 0 ) {

            Curr++;

            SubAuth = ( PULONG )LocalAlloc( LMEM_FIXED | LMEM_ZEROINIT, Subs * sizeof( ULONG ) );

            if ( SubAuth == NULL ) {

                Err = ERROR_NOT_ENOUGH_MEMORY;

            } else {

                for ( Index = 0; Index < Subs; Index++ ) {

                    if ( (*Curr == L'0') &&
                         ( *(Curr+1) == L'x' ||
                           *(Curr+1) == L'X' ) ) {

                        lBase = 16;
                    } else {
                        lBase = gBase;
                    }

                    SubAuth[Index] = wcstoul( Curr, &CurrEnd, lBase );

                    //
                    // Valid sub-authority ID must end with delimiter L'-', right parentheless, or one
                    // of the following:
                    //  D:
                    //  S:
                    //  O:
                    //  G:
                    //

                    if (CurrEnd != NULL             && 
                        *CurrEnd != L'\0'           && 
                        *CurrEnd != SDDL_ACE_ENDC   && 
                        *CurrEnd != L'-'            &&
                         ( *(CurrEnd + 1) != SDDL_DELIMINATORC ||      // because of *CurrEnd != L'\0', we are safe
                           *CurrEnd != *SDDL_OWNER  && 
                           *CurrEnd != *SDDL_GROUP  && 
                           *CurrEnd != *SDDL_DACL   && 
                           *CurrEnd != *SDDL_SACL
                         )
                        )
                    {
                        
                        Err = ERROR_INVALID_SID;
                        break;
                    }
                    else
                    {
                        Curr = CurrEnd + 1;
                    }
                }
            }

        } else {

            Err = ERROR_INVALID_SID;
        }
    }

    //
    // Now, create the SID
    //
    if ( Err == ERROR_SUCCESS ) {

        *Sid = ( PSID )LocalAlloc( LMEM_FIXED | LMEM_ZEROINIT,
                                   sizeof( SID ) + Subs * sizeof( ULONG ) );

        if ( *Sid == NULL ) {

            Err = ERROR_NOT_ENOUGH_MEMORY;

        } else {

            PISID ISid = ( PISID )*Sid;
            ISid->Revision = Revision;
            ISid->SubAuthorityCount = Subs;
            RtlCopyMemory( &( ISid->IdentifierAuthority ), &IDAuth,
                           sizeof( SID_IDENTIFIER_AUTHORITY ) );
            RtlCopyMemory( ISid->SubAuthority, SubAuth, Subs * sizeof( ULONG ) );
        }
    }

    LocalFree( SubAuth );

    if ( NULL != pwszHeapSidStr ) {

       LocalFree(pwszHeapSidStr);
    }

    SetLastError( Err );

    return( Err == ERROR_SUCCESS );
}


PSTRSD_SID_LOOKUP
LookupSidInTable(
    IN PWSTR String OPTIONAL,
    IN PSID Sid OPTIONAL,
    IN PSID RootDomainSid OPTIONAL,
    IN PSID DomainSid OPTIONAL,
    IN PSTRSD_SID_LOOKUP tSidLookupDomOrRootDomRelativeTable OPTIONAL,
    IN BOOLEAN DefaultToDomain,
    IN PVOID *pSASid
    )
/*++

Routine Description:

    This routine will determine if the given sid or string sid exists in the lookup table.

    A pointer to the matching static lookup entry is returned.


Arguments:

    String - The string to be looked up

    Sid - The sid to be looked up.

Return Value:

    Lookup table entry if found

    NULL if not found

--*/
{
    BOOLEAN LookupSid = FALSE;
    DWORD i, SidCount = sizeof( SidLookup ) / sizeof( STRSD_SID_LOOKUP );
    PSTRSD_SID_LOOKUP MatchedEntry = NULL;
    DWORD DomainAdminIndex;

    BOOL  InitRootDomain;
    ULONG Rid;
    BOOL bIsSA = FALSE;


    if ( String == NULL && Sid == NULL ) {
        //
        // JINHUANG: if both string and sid are NULL
        // just return NULL
        //
        return((PSTRSD_SID_LOOKUP)NULL);
    }

    *pSASid = NULL;

    InitRootDomain = FALSE;
    DomainAdminIndex = SidCount;

    if ( String == NULL ) {
        //
        // lookup on the Sid
        //
        LookupSid = TRUE;

        //
        // check if the RID is for Enterprise Admins
        //
        Rid = *( RtlSubAuthoritySid( Sid,
                                     *( RtlSubAuthorityCountSid(Sid) ) - 1 ) );

        if ( DOMAIN_GROUP_RID_ENTERPRISE_ADMINS == Rid ||
             DOMAIN_GROUP_RID_SCHEMA_ADMINS == Rid ) {

            InitRootDomain = TRUE;
            if ( DOMAIN_GROUP_RID_SCHEMA_ADMINS == Rid ) {
                bIsSA = TRUE;
            }
        }

    } else {

        if ( _wcsnicmp( String, SDDL_ENTERPRISE_ADMINS, SDDL_LEN_TAG( SDDL_ENTERPRISE_ADMINS ) ) == 0 ) {
            //
            // Enterprise admins string is requested
            //
            InitRootDomain = TRUE;
        } else if ( _wcsnicmp( String, SDDL_SCHEMA_ADMINISTRATORS, SDDL_LEN_TAG( SDDL_SCHEMA_ADMINISTRATORS ) ) == 0 ) {
            //
            // schema admin is requested
            //
            InitRootDomain = TRUE;
            bIsSA = TRUE;
        }
    }

    //
    // the new API is the caller iff DomainSid != NULL
    // on demand, initialize domain relative dynamic table for new API ()
    //

    if ( DomainSid ) {

        //
        // in this search, we will deal with the per thread table and not the global table
        // in actuality, this per thread table is a proper subset of the global table
        //

        for ( i = 0; i < sizeof(SidLookupDomOrRootDomRelative)/sizeof(STRSD_SID_LOOKUP); i++ ) {

            //
            // for performance, only compute SID etc. if names match.
            // in case the table is sparse, this heuristic comes in handy
            // this doesn't preclude future lookup calls from leveraging useful work done here
            //

            if ( _wcsnicmp( String,
                            tSidLookupDomOrRootDomRelativeTable[ i ].Key,
                            tSidLookupDomOrRootDomRelativeTable[ i ].KeyLen ) == 0 ) {


                if (tSidLookupDomOrRootDomRelativeTable[ i ].Valid == FALSE ||
                    tSidLookupDomOrRootDomRelativeTable[ i ].Sid == NULL) {

                    PSID RootDomainSidOrDomainSid = NULL;

                    if ( tSidLookupDomOrRootDomRelativeTable[ i ].SidType == ST_DOMAIN_RELATIVE )
                        RootDomainSidOrDomainSid = DomainSid;
                    else if ( tSidLookupDomOrRootDomRelativeTable[ i ].SidType == ST_ROOT_DOMAIN_RELATIVE &&
                              RootDomainSid )
                        RootDomainSidOrDomainSid = RootDomainSid;
                    else {
                        
                        //
                        // this will happen when the RootDomainSid is not provided when using the 
                        // new API and so ST_ROOT_DOMAIN_RELATIVE type SIDs will get resolved wrt
                        // the local m/c's root domain - so we will allow the lookup to continue
                        // in the normal way
                        //
                        
                        break;
                    }

                    //
                    // do this for legacy-code reasons
                    //

                    tSidLookupDomOrRootDomRelativeTable[ i ].Sid =
                        ( PSID )tSidLookupDomOrRootDomRelativeTable[ i ].SidBuff;


                    RtlCopyMemory( tSidLookupDomOrRootDomRelativeTable[ i ].Sid, RootDomainSidOrDomainSid,
                                   RtlLengthSid( RootDomainSidOrDomainSid ) );
                    ( ( PISID )( tSidLookupDomOrRootDomRelativeTable[ i ].Sid ) )->SubAuthorityCount++;
                    *( RtlSubAuthoritySid( tSidLookupDomOrRootDomRelativeTable[ i ].Sid,
                                           *( RtlSubAuthorityCountSid( RootDomainSidOrDomainSid ) ) ) ) =
                        tSidLookupDomOrRootDomRelativeTable[ i ].Rid;

                    tSidLookupDomOrRootDomRelativeTable[ i ].Valid = TRUE;

                }

                if (tSidLookupDomOrRootDomRelativeTable[ i ].Valid == TRUE)
                    MatchedEntry = &tSidLookupDomOrRootDomRelativeTable[ i ];

                //
                // if we get here, we have to return MatchedEntry since we know that:
                //
                //      (a) the new API is the caller (DomainSid != NULL) and
                //      (b) we are dealing with ST_DOMAIN_RELATIVE or 
                //          ST_ROOT_DOMAIN_RELATIVE type trustees (with RootDomainSid provided)
                //      (c) there is a match with the trustee name such as "DA" or "EA"
                //

                return (MatchedEntry);

            }

        }

    }

    InitializeSidLookupTable(STRSD_REINITIALIZE_ENTER);

    if ( InitRootDomain &&
         RootDomainSid == NULL &&
         DefaultToDomain == FALSE &&
         ( RootDomInited == FALSE ||
           !RtlValidSid( (PSID)RootDomSidBuf ) ) ) {

        //
        // get the root domain sid (using ldap calls)
        //

        SddlpGetRootDomainSid();

    }



    for ( i = 0; i < SidCount; i++ ) {

        //
        // if new API and domain relative trustee, skip the entry
        // since the global table won't be used in this scenario.
        // matches for such entries are taken care of, in the per-thread table above
        //
        // cannot skip if InitRootDomain == TRUE since SDDL_DOMAIN_ADMINISTRATORS in
        // SidLookup[] is potentially matched against, shortly
        //

        if ( InitRootDomain == FALSE &&
             DomainSid &&
             SidLookup[ i ].SidType == ST_DOMAIN_RELATIVE )
            continue;

        //
        // if this is an entry that has been initialized, skip it
        //

        if ( SidLookup[ i ].Valid == FALSE ||
             SidLookup[ i ].Sid == NULL ) {


            if ( SidLookup[ i ].SidType == ST_ROOT_DOMAIN_RELATIVE &&
                 InitRootDomain ) {

                if ( RootDomainSid != NULL ) {

                    EnterCriticalSection(&SddlSidLookupCritical);

                    RtlCopyMemory( SidLookup[ i ].Sid, RootDomainSid,
                                   RtlLengthSid( RootDomainSid ) );
                    ( ( PISID )( SidLookup[ i ].Sid ) )->SubAuthorityCount++;
                    *( RtlSubAuthoritySid( SidLookup[ i ].Sid,
                                           *( RtlSubAuthorityCountSid( RootDomainSid ) ) ) ) =
                                           SidLookup[ i ].Rid;
                    SidLookup[ i ].Valid = TRUE;

                    LeaveCriticalSection(&SddlSidLookupCritical);

                } else if ( DefaultToDomain ) {
                    //
                    // should default EA to DA and SA to domain relative
                    //
                } else {

                    if ( RootDomInited && RtlValidSid( (PSID)RootDomSidBuf ) &&
                         ( ( SidLookup[ i ].Valid == FALSE ) ||
                           ( SidLookup[ i ].Sid == NULL ) ) ) {

                        EnterCriticalSection(&SddlSidLookupCritical);

                        RtlCopyMemory( SidLookup[ i ].Sid, (PSID)RootDomSidBuf,
                                       RtlLengthSid( (PSID)RootDomSidBuf ) );
                        ( ( PISID )( SidLookup[ i ].Sid ) )->SubAuthorityCount++;
                        *( RtlSubAuthoritySid( SidLookup[ i ].Sid,
                                               *( RtlSubAuthorityCountSid( (PSID)RootDomSidBuf ) ) ) ) =
                                               SidLookup[ i ].Rid;
                        SidLookup[ i ].Valid = TRUE;

                        LeaveCriticalSection(&SddlSidLookupCritical);
                    }

                }

            }


            if ( SidLookup[ i ].Valid == FALSE ||
                 SidLookup[ i ].Sid == NULL ) {
                continue;
            }
        }

        if ( LookupSid ) {

            if ( RtlEqualSid( Sid, SidLookup[ i ].Sid ) ) {

                break;
            }

        } else {

            //
            // check for the current key first
            //
            if ( _wcsnicmp( String, SidLookup[i].Key, SidLookup[i].KeyLen ) == 0 ) {

                break;

            } else if ( InitRootDomain && DefaultToDomain &&
                        (RootDomainSid == NULL) ) {

                //
                // looking for EA/SA, not found them,
                // EA needs to default to DA, SA needs to default to domain relative
                //
                if ( _wcsnicmp( SDDL_DOMAIN_ADMINISTRATORS, SidLookup[i].Key, SidLookup[i].KeyLen ) == 0 ) {
                    DomainAdminIndex = i;
//                    break;
                }

            }
        }
    }


    if ( i < SidCount ) {

        MatchedEntry = &SidLookup[ i ];

    } else if ( InitRootDomain && DefaultToDomain &&
                (RootDomainSid == NULL) &&
                ( DomainAdminIndex < SidCount ) ) {

        if ( bIsSA ) {
            //
            // default to domain relative sid
            //

            if ( LookupSid ) {
                *pSASid = (PVOID)Sid;

            } else if ( SidLookup[ DomainAdminIndex ].Sid ) {
                //
                // allocate buffer for domain relative SA sid
                // which means it's only valid on the root domain
                //

                i = RtlLengthSid( SidLookup[ DomainAdminIndex ].Sid );

                *pSASid = (PVOID)LocalAlloc( LMEM_FIXED, i+1 );

                if ( *pSASid != NULL ) {

                    RtlCopyMemory( (PSID)(*pSASid), SidLookup[ DomainAdminIndex ].Sid, i );

                    // replace the DA rid with SA rid
                    *( RtlSubAuthoritySid( (PSID)(*pSASid),
                                           *( RtlSubAuthorityCountSid( SidLookup[ DomainAdminIndex ].Sid )) - 1) ) =
                                           DOMAIN_GROUP_RID_SCHEMA_ADMINS;
                }
            }

        } else {

            //
            // default to the domain admin account
            //

            MatchedEntry = &SidLookup[ DomainAdminIndex ];
        }
    }

    InitializeSidLookupTable(STRSD_REINITIALIZE_LEAVE);

    return( MatchedEntry );
}


DWORD
LocalGetSidForString(
    IN  PWSTR String,
    OUT PSID *SID,
    OUT PWSTR *End,
    OUT PBOOLEAN FreeSid,
    IN  PSID RootDomainSid OPTIONAL,
    IN  PSID DomainSid OPTIONAL,
    IN  PSTRSD_SID_LOOKUP tSidLookupDomOrRootDomRelativeTable OPTIONAL,
    IN  BOOLEAN DefaultToDomain
    )
/*++

Routine Description:

    This routine will determine which sid is an appropriate match for the
    given string, either as a sid moniker or as a string representation of a
    sid (ie: "DA or "S-1-0-0" )

    The returned sid must be free via a call to LocalFree if the *pFreeSid
    output parameter is TRUE.  If it's FALSE, no additional action needs to
    be taken


Arguments:

    String - The string to be converted

    Sid - Where the created SID is to be returned

    End - Where in the string we stopped processing

    FreeSid - Determines whether the returned SID needs to be freed via a
        call to LocalFree or not


Return Value:

    ERROR_SUCCESS - success

    ERROR_NON_MAPPED - An invalid format of the SID was given

--*/
{
    DWORD Err = ERROR_SUCCESS;
    PSTRSD_SID_LOOKUP MatchedEntry;
    PSID pSidSA=NULL;

    if ( String == NULL || SID == NULL || End == NULL || FreeSid == NULL ) {
        return(ERROR_INVALID_PARAMETER);
    }

    //
    // Assume we'll return a well known sid
    //
    *FreeSid = FALSE;

//    if ( wcslen( String ) < 2 ) {
//  no need to do wcslen (expensive) because we know that String is not NULL
//  so just check for the first and second char
    if ( *String == L'\0' || *( String +1 ) == L'\0' ) {

        return( ERROR_NONE_MAPPED );
    }

    //
    // Set our end of string pointer
    //
    *End = String + 2;

    MatchedEntry = LookupSidInTable( String,
                                     NULL,
                                     RootDomainSid,
                                     DomainSid,
                                     tSidLookupDomOrRootDomRelativeTable,
                                     DefaultToDomain,
                                     (PVOID *)&pSidSA);

    //
    // If we didn't find a match, try it as a sid string
    //
    if ( MatchedEntry == NULL ) {

        if ( pSidSA ) {
            //
            // this is schema admin lookup
            //
            *SID = pSidSA;
            *FreeSid = TRUE;

        } else {

            //
            // We assumed a known moniker, so we'll have to unset our end of string pointer.
            // Also, if it's a not a SID, the Convert routine will return the appropriate error.
            //
            *End -= 2;
            if ( LocalConvertStringSidToSid( String, SID, End) == FALSE ) {

                Err = GetLastError();
            }

            if ( Err == ERROR_SUCCESS && *SID != NULL ) {

                *FreeSid = TRUE;
            }
        }

    } else {

        //
        // If the entry that's been selected hasn't been initialized yet, do it now
        //
        *SID = MatchedEntry->Sid;
    }


    return(Err);
}


DWORD
LocalGetStringForSid(
    IN  PSID Sid,
    OUT PWSTR *String,
    IN  PSID RootDomainSid OPTIONAL
    )
/*++

Routine Description:

    This routine will determine which string represents a sid, either as a sid moniker or
    as a string representation of a sid (ie: "DA or "S-1-0-0" )

    The returned string must be free via a call to LocalFree


Arguments:

    Sid - Sid to be converted

    String - Where the mapped Sid is to be returned

Return Value:

    ERROR_SUCCESS - success

    ERROR_NON_MAPPED - An invalid format of the SID was given

    ERROR_NOT_ENOUGH_MEMORY - A memory allocation failed

--*/
{
    DWORD Err = ERROR_SUCCESS;
    PSTRSD_SID_LOOKUP MatchedEntry;
    PSID pSidSA=NULL;
    DWORD Len;

    if ( Sid == NULL || String == NULL ) {

        return(ERROR_INVALID_PARAMETER);
    }

    //
    // Try to find a match in the lookup table
    //
    MatchedEntry = LookupSidInTable( NULL,
                                     Sid,
                                     RootDomainSid,
                                     NULL,
                                     NULL,
                                     FALSE,
                                     (PVOID *)&pSidSA );

    //
    // If a match was found, return it
    //
    if ( MatchedEntry || pSidSA ) {

        if ( MatchedEntry ) {
            Len = MatchedEntry->KeyLen;
        } else {
            Len = wcslen(SDDL_SCHEMA_ADMINISTRATORS);
        }

        *String = LocalAlloc( LMEM_FIXED, ( Len * sizeof( WCHAR ) ) + sizeof( WCHAR ) );
        if ( *String == NULL ) {

            Err = ERROR_NOT_ENOUGH_MEMORY;

        } else {

            if ( MatchedEntry ) {
                wcscpy( *String, MatchedEntry->Key );
            } else {
                wcscpy( *String, SDDL_SCHEMA_ADMINISTRATORS);
            }
        }

    } else {

        if ( ConvertSidToStringSidW( Sid, String ) == FALSE ) {

            Err = GetLastError();
        }

    }

    return(Err);
}

DWORD
LocalGetStringForControl(
    IN SECURITY_DESCRIPTOR_CONTROL ControlCode,
    IN ULONG LookupFlags,
    OUT PWSTR *ControlString
    )
{
    DWORD   i, ControlCount = sizeof( ControlLookup ) / sizeof( STRSD_KEY_LOOKUP );
    WCHAR Buffer[256];
    DWORD nOffset=0;


    if ( !ControlString ) {
        return(ERROR_INVALID_PARAMETER);
    }

    *ControlString = NULL;

    for ( i = 0; i < ControlCount; i++ ) {

        //
        // If it doesn't match our lookup type, skip it.
        //
        if ( ( LookupFlags & ControlLookup[ i ].ValidityFlags ) != LookupFlags ) {

            continue;
        }

        if ( ControlCode & ControlLookup[ i ].Value ) {

            wcsncpy(Buffer+nOffset,
                    ControlLookup[ i ].Key,
                    ControlLookup[ i ].KeyLen );

            nOffset += ControlLookup[ i ].KeyLen;

        }
    }

    Buffer[nOffset] = L'\0';

    if ( nOffset ) {
        *ControlString = (PWSTR)LocalAlloc(0, (nOffset+1)*sizeof(WCHAR));

        if ( *ControlString ) {

            wcscpy(*ControlString, Buffer);

        } else {
            return(ERROR_NOT_ENOUGH_MEMORY);
        }
    }

    return( ERROR_SUCCESS );
}


PSTRSD_KEY_LOOKUP
LookupAccessMaskInTable(
    IN PWSTR String, OPTIONAL
    IN ULONG AccessMask, OPTIONAL
    IN ULONG LookupFlags
    )
/*++

Routine Description:

    This routine will determine if the given access mask or string right exists in the lookup
    table.

    A pointer to the matching static lookup entry is returned.


Arguments:

    String - The string to be looked up

    AccessMask - The accessMask to be looked up.

    LookupFlags - Flags to use for lookup (Dacl or Sacl)

Return Value:

    Lookup table entry if found

    NULL if not found

--*/
{
    //
    // This is how the access mask is looked up.  Always have the multi-char
    // rights before the single char ones
    //
    static STRSD_KEY_LOOKUP  RightsLookup[] = {
        { SDDL_READ_PROPERTY, SDDL_LEN_TAG( SDDL_READ_PROPERTY ), ACTRL_DS_READ_PROP, SDDL_VALID_DACL | SDDL_VALID_SACL },
        { SDDL_WRITE_PROPERTY, SDDL_LEN_TAG( SDDL_WRITE_PROPERTY ), ACTRL_DS_WRITE_PROP, SDDL_VALID_DACL | SDDL_VALID_SACL },
        { SDDL_CREATE_CHILD, SDDL_LEN_TAG( SDDL_CREATE_CHILD ), ACTRL_DS_CREATE_CHILD, SDDL_VALID_DACL | SDDL_VALID_SACL },
        { SDDL_DELETE_CHILD, SDDL_LEN_TAG( SDDL_DELETE_CHILD ), ACTRL_DS_DELETE_CHILD, SDDL_VALID_DACL | SDDL_VALID_SACL },
        { SDDL_LIST_CHILDREN, SDDL_LEN_TAG( SDDL_LIST_CHILDREN ), ACTRL_DS_LIST, SDDL_VALID_DACL | SDDL_VALID_SACL },
        { SDDL_SELF_WRITE, SDDL_LEN_TAG( SDDL_SELF_WRITE ), ACTRL_DS_SELF, SDDL_VALID_DACL | SDDL_VALID_SACL },
        { SDDL_LIST_OBJECT, SDDL_LEN_TAG( SDDL_LIST_OBJECT ), ACTRL_DS_LIST_OBJECT, SDDL_VALID_DACL | SDDL_VALID_SACL },
        { SDDL_DELETE_TREE, SDDL_LEN_TAG( SDDL_DELETE_TREE ), ACTRL_DS_DELETE_TREE, SDDL_VALID_DACL | SDDL_VALID_SACL },
        { SDDL_CONTROL_ACCESS, SDDL_LEN_TAG( SDDL_CONTROL_ACCESS ), ACTRL_DS_CONTROL_ACCESS, SDDL_VALID_DACL | SDDL_VALID_SACL },

        { SDDL_READ_CONTROL, SDDL_LEN_TAG( SDDL_READ_CONTROL ), READ_CONTROL, SDDL_VALID_DACL | SDDL_VALID_SACL },
        { SDDL_WRITE_DAC, SDDL_LEN_TAG( SDDL_WRITE_DAC ), WRITE_DAC, SDDL_VALID_DACL | SDDL_VALID_SACL },
        { SDDL_WRITE_OWNER, SDDL_LEN_TAG( SDDL_WRITE_OWNER ), WRITE_OWNER, SDDL_VALID_DACL | SDDL_VALID_SACL },
        { SDDL_STANDARD_DELETE, SDDL_LEN_TAG( SDDL_STANDARD_DELETE ), DELETE, SDDL_VALID_DACL | SDDL_VALID_SACL },
        { SDDL_GENERIC_ALL, SDDL_LEN_TAG( SDDL_GENERIC_ALL ), GENERIC_ALL, SDDL_VALID_DACL | SDDL_VALID_SACL },
        { SDDL_GENERIC_READ, SDDL_LEN_TAG( SDDL_GENERIC_READ ), GENERIC_READ, SDDL_VALID_DACL | SDDL_VALID_SACL },
        { SDDL_GENERIC_WRITE, SDDL_LEN_TAG( SDDL_GENERIC_WRITE ), GENERIC_WRITE, SDDL_VALID_DACL | SDDL_VALID_SACL },
        { SDDL_GENERIC_EXECUTE, SDDL_LEN_TAG( SDDL_GENERIC_EXECUTE ), GENERIC_EXECUTE, SDDL_VALID_DACL | SDDL_VALID_SACL },
        { SDDL_FILE_ALL, SDDL_LEN_TAG( SDDL_FILE_ALL ), FILE_ALL_ACCESS, SDDL_VALID_DACL | SDDL_VALID_SACL },
        { SDDL_FILE_READ, SDDL_LEN_TAG( SDDL_FILE_READ ), FILE_GENERIC_READ, SDDL_VALID_DACL | SDDL_VALID_SACL },
        { SDDL_FILE_WRITE, SDDL_LEN_TAG( SDDL_FILE_WRITE ), FILE_GENERIC_WRITE, SDDL_VALID_DACL | SDDL_VALID_SACL },
        { SDDL_FILE_EXECUTE, SDDL_LEN_TAG( SDDL_FILE_EXECUTE ), FILE_GENERIC_EXECUTE, SDDL_VALID_DACL | SDDL_VALID_SACL },
        { SDDL_KEY_ALL, SDDL_LEN_TAG( SDDL_KEY_ALL ), KEY_ALL_ACCESS, SDDL_VALID_DACL | SDDL_VALID_SACL },
        { SDDL_KEY_READ, SDDL_LEN_TAG( SDDL_KEY_READ ), KEY_READ, SDDL_VALID_DACL | SDDL_VALID_SACL },
        { SDDL_KEY_WRITE, SDDL_LEN_TAG( SDDL_KEY_WRITE ), KEY_WRITE, SDDL_VALID_DACL | SDDL_VALID_SACL },
        { SDDL_KEY_EXECUTE, SDDL_LEN_TAG( SDDL_KEY_EXECUTE ), KEY_EXECUTE, SDDL_VALID_DACL | SDDL_VALID_SACL },
        };
    DWORD   i, RightsCount = sizeof(RightsLookup) / sizeof(STRSD_KEY_LOOKUP);
    PSTRSD_KEY_LOOKUP MatchedEntry = NULL;
    BOOLEAN LookupString = FALSE;

    if ( String ) {

        LookupString = TRUE;
    }

    for ( i = 0; i < RightsCount; i++ ) {

        //
        // If it doesn't match our lookup type, skip it.
        //
        if ( ( LookupFlags & RightsLookup[ i ].ValidityFlags ) != LookupFlags ) {

            continue;
        }

        if ( LookupString ) {

            if ( _wcsnicmp( String, RightsLookup[ i ].Key, RightsLookup[ i ].KeyLen ) == 0 ) {

                break;
            }

        } else {

            if ( AccessMask == RightsLookup[ i ].Value ) {

                break;
            }

        }

    }

    //
    // If a match was found, return it
    //
    if ( i < RightsCount ) {

        MatchedEntry = &RightsLookup[ i ];
    }


    return( MatchedEntry );

}


PSTRSD_KEY_LOOKUP
LookupAceTypeInTable(
    IN PWSTR String, OPTIONAL
    IN ULONG AceType, OPTIONAL
    IN ULONG LookupFlags
    )
/*++

Routine Description:

    This routine will determine if the given ace type or string type exists in the lookup
    table.

    A pointer to the matching static lookup entry is returned.


Arguments:

    String - The string to be looked up

    AceType - The ace type to be looked up.

    LookupFlags - Flags to use for lookup (Dacl or Sacl)

Return Value:

    Lookup table entry if found

    NULL if not found

--*/
{
    //
    // Lookup table
    //
    static STRSD_KEY_LOOKUP TypeLookup[] = {
        { SDDL_ACCESS_ALLOWED, SDDL_LEN_TAG( SDDL_ACCESS_ALLOWED ), ACCESS_ALLOWED_ACE_TYPE, SDDL_VALID_DACL },
        { SDDL_ACCESS_DENIED, SDDL_LEN_TAG( SDDL_ACCESS_DENIED ), ACCESS_DENIED_ACE_TYPE, SDDL_VALID_DACL },
        { SDDL_OBJECT_ACCESS_ALLOWED, SDDL_LEN_TAG( SDDL_OBJECT_ACCESS_ALLOWED ),
                                                                ACCESS_ALLOWED_OBJECT_ACE_TYPE, SDDL_VALID_DACL },
        { SDDL_OBJECT_ACCESS_DENIED, SDDL_LEN_TAG( SDDL_OBJECT_ACCESS_DENIED ),
                                                                ACCESS_DENIED_OBJECT_ACE_TYPE, SDDL_VALID_DACL },
        { SDDL_AUDIT, SDDL_LEN_TAG( SDDL_AUDIT ), SYSTEM_AUDIT_ACE_TYPE, SDDL_VALID_SACL },
        { SDDL_ALARM, SDDL_LEN_TAG( SDDL_ALARM ), SYSTEM_ALARM_ACE_TYPE, SDDL_VALID_SACL },
        { SDDL_OBJECT_AUDIT, SDDL_LEN_TAG( SDDL_OBJECT_AUDIT ), SYSTEM_AUDIT_OBJECT_ACE_TYPE, SDDL_VALID_SACL },
        { SDDL_OBJECT_ALARM, SDDL_LEN_TAG( SDDL_OBJECT_ALARM ), SYSTEM_ALARM_OBJECT_ACE_TYPE, SDDL_VALID_SACL }
        };
    DWORD   i, TypeCount = sizeof( TypeLookup ) / sizeof( STRSD_KEY_LOOKUP );
    PSTRSD_KEY_LOOKUP MatchedEntry = NULL;
    BOOLEAN LookupString = FALSE;

    if ( String ) {

        LookupString = TRUE;
    }

    for ( i = 0; i < TypeCount; i++ ) {

        //
        // If it doesn't match our lookup type, skip it.
        //
        if ( ( LookupFlags & TypeLookup[ i ].ValidityFlags ) != LookupFlags ) {

            continue;
        }

        if ( LookupString ) {

            if ( _wcsnicmp( String, TypeLookup[ i ].Key, TypeLookup[ i ].KeyLen ) == 0 ) {

                break;
            }

        } else {

            if ( AceType == TypeLookup[ i ].Value ) {

                break;
            }

        }

    }

    //
    // If a match was found, return it
    //
    if ( i < TypeCount ) {

        MatchedEntry = &TypeLookup[ i ];
    }


    return( MatchedEntry );
}



PSTRSD_KEY_LOOKUP
LookupAceFlagsInTable(
    IN PWSTR String, OPTIONAL
    IN ULONG AceFlags, OPTIONAL
    IN ULONG LookupFlags
    )
/*++

Routine Description:

    This routine will determine if the given ace flags or string flags exists in the lookup
    table.

    A pointer to the matching static lookup entry is returned.


Arguments:

    String - The string to be looked up

    AceFlags - The ace flags to be looked up.

    LookupFlags - Flags to use for lookup (Dacl or Sacl)

Return Value:

    Lookup table entry if found

    NULL if not found

--*/
{
    //
    // Lookup tables
    //
    static STRSD_KEY_LOOKUP  FlagLookup[] = {
        { SDDL_CONTAINER_INHERIT, SDDL_LEN_TAG( SDDL_CONTAINER_INHERIT ), CONTAINER_INHERIT_ACE, SDDL_VALID_DACL | SDDL_VALID_SACL },
        { SDDL_OBJECT_INHERIT, SDDL_LEN_TAG( SDDL_OBJECT_INHERIT ), OBJECT_INHERIT_ACE, SDDL_VALID_DACL | SDDL_VALID_SACL },
        { SDDL_NO_PROPAGATE, SDDL_LEN_TAG( SDDL_NO_PROPAGATE  ), NO_PROPAGATE_INHERIT_ACE, SDDL_VALID_DACL | SDDL_VALID_SACL },
        { SDDL_INHERIT_ONLY, SDDL_LEN_TAG( SDDL_INHERIT_ONLY  ), INHERIT_ONLY_ACE, SDDL_VALID_DACL | SDDL_VALID_SACL },
        { SDDL_INHERITED, SDDL_LEN_TAG( SDDL_INHERITED  ), INHERITED_ACE, SDDL_VALID_DACL | SDDL_VALID_SACL },
        { SDDL_AUDIT_SUCCESS, SDDL_LEN_TAG( SDDL_AUDIT_SUCCESS ), SUCCESSFUL_ACCESS_ACE_FLAG, SDDL_VALID_SACL },
        { SDDL_AUDIT_FAILURE, SDDL_LEN_TAG( SDDL_AUDIT_FAILURE ), FAILED_ACCESS_ACE_FLAG, SDDL_VALID_SACL }
        };
    DWORD   i, FlagCount = sizeof( FlagLookup ) / sizeof( STRSD_KEY_LOOKUP );
    PSTRSD_KEY_LOOKUP MatchedEntry = NULL;
    BOOLEAN LookupString = FALSE;

    if ( String ) {

        LookupString = TRUE;
    }


    for ( i = 0; i < FlagCount; i++ ) {

        //
        // If it doesn't match our lookup type, skip it.
        //
        if ( ( LookupFlags & FlagLookup[ i ].ValidityFlags ) != LookupFlags ) {

            continue;
        }

        if ( LookupString ) {

            if ( _wcsnicmp( String, FlagLookup[ i ].Key, FlagLookup[ i ].KeyLen ) == 0 ) {

                break;
            }

        } else {

            if ( AceFlags == FlagLookup[ i ].Value ) {

                break;
            }

        }

    }

    //
    // If a match was found, return it
    //
    if ( i < FlagCount ) {

        MatchedEntry = &FlagLookup[ i ];
    }


    return( MatchedEntry );
}


DWORD
LocalGetSDControlForString (
    IN  PWSTR ControlString,
    IN ULONG LookupFlags,
    OUT SECURITY_DESCRIPTOR_CONTROL *pControl,
    OUT PWSTR *End
    )
{

    DWORD   i, ControlCount = sizeof( ControlLookup ) / sizeof( STRSD_KEY_LOOKUP );
    PWSTR pCursor=ControlString;
    BOOL bFound;

    if ( !ControlString || !pControl || !End ) {

        return(ERROR_INVALID_PARAMETER);
    }

    *pControl = 0;

    while ( pCursor && *pCursor == L' ' ) {
        //
        // skip any blanks
        //
        pCursor++;
    }


    do {

        bFound = FALSE;

        for ( i = 0; i < ControlCount; i++ ) {

            //
            // If it doesn't match our lookup type, skip it.
            //
            if ( ( LookupFlags & ControlLookup[ i ].ValidityFlags ) != LookupFlags ) {

                continue;
            }

            if ( _wcsnicmp( pCursor,
                            ControlLookup[ i ].Key,
                            ControlLookup[ i ].KeyLen ) == 0 ) {

                *pControl |= ControlLookup[ i ].Value;

                pCursor += ControlLookup[ i ].KeyLen;

                while ( pCursor && *pCursor == L' ' ) {
                    //
                    // skip any blanks
                    //
                    pCursor++;
                }

                bFound = TRUE;

                break;  // break the for loop
            }
        }

    } while ( bFound );


    *End = pCursor;


    return( ERROR_SUCCESS );

}

DWORD
LocalGetAclForString(
    IN  PWSTR       AclString,
    IN  BOOLEAN     ConvertAsDacl,
    OUT PACL       *Acl,
    OUT PWSTR      *End,
    IN  PSID RootDomainSid OPTIONAL,
    IN  PSID DomainSid OPTIONAL,
    IN  PSTRSD_SID_LOOKUP tSidLookupDomOrRootDomRelativeTable OPTIONAL,
    IN  BOOLEAN DefaultToDomain
    )
/*++

Routine Description:

    This routine convert a string into an ACL.  The format of the aces is:

    Ace := ( Type; Flags; Rights; ObjGuid; IObjGuid; Sid;
    Type : = A | D | OA | OD        {Access, Deny, ObjectAccess, ObjectDeny}
    Flags := Flags Flag
    Flag : = CI | IO | NP | SA | FA {Container Inherit,Inherit Only, NoProp,
                                     SuccessAudit, FailAdit }
    Rights := Rights Right
    Right := DS_READ_PROPERTY |  blah blah
    Guid := String representation of a GUID (via RPC UuidToString)
    Sid := DA | PS | AO | PO | AU | S-* (Domain Admins, PersonalSelf, Acct Ops,
                                         PrinterOps, AuthenticatedUsers, or
                                         the string representation of a sid)
    The seperator is a ';'.

    The returned ACL must be free via a call to LocalFree


Arguments:

    AclString - The string to be converted

    ConvertAsDacl - Treat the input string as a dacl string

    ppSid - Where the created SID is to be returned

    End - Where in the string we stopped processing


Return Value:

    ERROR_SUCCESS indicates success
    ERROR_NOT_ENOUGH_MEMORY indicates a memory allocation for the ouput acl
                            failed
    ERROR_INVALID_PARAMETER The string does not represent an ACL


--*/
{
    DWORD Err = ERROR_SUCCESS;
    DWORD AclSize = 0, AclUsed = 0;
    ULONG Acls = 0, i, j;
    PWSTR Curr, MaskEnd;
    WCHAR ConvertGuidString[ STRING_GUID_LEN + 1];
    BOOLEAN FreeSid = FALSE;
    BOOL OpRes;
    PSTRSD_KEY_LOOKUP MatchedEntry;
    ULONG LookupFlags;
    PSID  SidPtr = NULL;


    if ( NULL == AclString || NULL == Acl || NULL == End ) {
        return(ERROR_INVALID_PARAMETER);
    }

    if ( ConvertAsDacl ) {

        LookupFlags = SDDL_VALID_DACL;

    } else {

        LookupFlags = SDDL_VALID_SACL;
    }

    //
    // First, we'll have to go through and count the number of entries that
    // we have.  We'll do the by computing the length of this ACL (which is
    // delimited by either the end of the list or a ':' that seperates a key
    // from a value
    //
    *End = wcschr( AclString, SDDL_DELIMINATORC );

    if ( *End == AclString ) {
        return(ERROR_INVALID_PARAMETER);
    }

    if ( *End == NULL ) {

        *End = AclString + wcslen( AclString );

    } else {

        ( *End )--;
    }

    //
    // Now, do the count
    //
    Curr = AclString;

    OpRes = 0;
//    while ( Curr != *End ) {
    while ( Curr < *End ) {

        if ( *Curr == SDDL_SEPERATORC ) {

            Acls++;

        } else if ( *Curr != L' ' ) {
            OpRes = 1;
        }

        Curr++;
    }

    //
    // Now, we've counted the total number of seperators.  Make sure we
    // have the right number.  (There is 5 seperators per ace)
    //
    if ( Acls % 5 == 0 ) {

        if ( Acls == 0 && OpRes ) {
            //
            // gabbage chars in between
            //
            Err = ERROR_INVALID_PARAMETER;

        } else {
            Acls = Acls / 5;
        }

    } else {

        Err = ERROR_INVALID_PARAMETER;
    }

    if (  Err == ERROR_SUCCESS && Acls == 0 ) {

        *Acl = LocalAlloc( LMEM_FIXED, sizeof( ACL ) );

        if ( *Acl == NULL ) {

            Err = ERROR_NOT_ENOUGH_MEMORY;

        } else {

            ( *Acl )->AclRevision = ACL_REVISION;
            ( *Acl )->Sbz1 = ( BYTE )0;
            ( *Acl )->AclSize = ( USHORT )sizeof( ACL ) ;
            ( *Acl )->AceCount = 0;
            ( *Acl )->Sbz2 = ( USHORT )0;

        }

        return( Err );
    }

    //
    // Ok now do the allocation.  We'll do a sort of worst case initial
    // allocation.  This saves us from having to process everything twice
    // (once to size, once to build).  If we determine later that we have
    // an acl that is not big enough, we allocate additional space.  The only
    // time that this reallocation should happen is if the input string
    // contains a lot of explicit SIDs.  Otherwise, the chosen buffer size
    // should be pretty close to the proper size
    //
    if ( Err == ERROR_SUCCESS ) {

        AclSize = sizeof( ACL ) + ( Acls * ( sizeof( ACCESS_ALLOWED_OBJECT_ACE ) +
                                            sizeof( SID ) + ( 6 * sizeof( ULONG ) ) ) );
        if ( AclSize > SDDL_MAX_ACL_SIZE ) {
            AclSize = SDDL_MAX_ACL_SIZE;
        }

        *Acl = ( PACL )LocalAlloc( LMEM_FIXED | LMEM_ZEROINIT, AclSize );

        if ( *Acl == NULL ) {

            Err = ERROR_NOT_ENOUGH_MEMORY;

        } else {

            AclUsed = sizeof( ACL );

            //
            // We'll start initializing it...
            //
            ( *Acl )->AclRevision = ACL_REVISION;
            ( *Acl )->Sbz1        = ( BYTE )0;
            ( *Acl )->AclSize     = ( USHORT )AclSize;
            ( *Acl )->AceCount    = 0;
            ( *Acl )->Sbz2 = ( USHORT )0;

            //
            // Ok, now we'll go through and start building them all
            //
            Curr = AclString;

            for( i = 0; i < Acls; i++ ) {

                //
                // First, get the type..
                //
                UCHAR Type;
                UCHAR Flags = 0;
                USHORT Size;
                ACCESS_MASK Mask = 0;
                GUID *ObjId = NULL, ObjGuid;
                GUID *IObjId = NULL, IObjGuid;
                PWSTR  Next;
                DWORD AceSize = 0;

                //
                // skip any space before (
                //
                while(*Curr == L' ' ) {
                    Curr++;
                }
                 //
                 // Skip any parens that may exist in the ace list
                 //
                if ( *Curr == SDDL_ACE_BEGINC ) {

                    Curr++;
                }
                 //
                 // skip any space after (
                 //
                 while(*Curr == L' ' ) {
                     Curr++;
                 }

                MatchedEntry = LookupAceTypeInTable( Curr, 0, LookupFlags );

                if ( MatchedEntry ) {

                    Type = ( UCHAR )MatchedEntry->Value;
                    Curr += MatchedEntry->KeyLen + 1;

                } else {

                    //
                    // Found an invalid type
                    //
                    Err = ERROR_INVALID_DATATYPE;
                    break;
                }

                //
                // If we have any object aces, set the acl revision to REVISION_DS
                //
                if ( Type >= ACCESS_MIN_MS_OBJECT_ACE_TYPE && Type <= ACCESS_MAX_MS_OBJECT_ACE_TYPE ) {

                    ( *Acl )->AclRevision = ACL_REVISION_DS;
                }

                //
                // skip any space before ;
                //
                while(*Curr == L' ' ) {
                    Curr++;
                }

                //
                // Next, get the flags...
                //
                while ( Curr != *End ) {

                    if ( *Curr == SDDL_SEPERATORC ) {

                        Curr++;
                        break;
                    }

                    //
                    // Skip any blanks
                    //
                    while ( *Curr == L' ' ) {

                        Curr++;
                    }

                    MatchedEntry = LookupAceFlagsInTable( Curr, 0, LookupFlags );

                    if ( MatchedEntry ) {

                        Flags |= ( UCHAR )MatchedEntry->Value;
                        Curr += MatchedEntry->KeyLen;

                    } else {
                        //
                        // Found an invalid flag
                        //
                        Err = ERROR_INVALID_FLAGS;
                        break;
                    }
                }

                if ( Err != ERROR_SUCCESS ) {

                    break;
                }

                //
                // skip any space after ;
                //
                while(*Curr == L' ' ) {
                    Curr++;
                }

                //
                // Now, get the access mask
                //
                while( TRUE ) {

                    if ( *Curr == SDDL_SEPERATORC ) {

                        Curr++;
                        break;
                    }

                    //
                    // Skip any blanks
                    //
                    while ( *Curr == L' ' ) {

                        Curr++;
                    }

                    MatchedEntry = LookupAccessMaskInTable( Curr, 0, LookupFlags );

                    if ( MatchedEntry ) {

                        Mask |= MatchedEntry->Value;
                        Curr += MatchedEntry->KeyLen;

                    } else {

                        //
                        // If the rights couldn't be looked up, see if it's a converted mask
                        //

                        Mask |= wcstoul( Curr, &MaskEnd, 0 );

                        if ( MaskEnd != Curr ) {

                            Curr = MaskEnd;

                        } else {
                            //
                            // Found an invalid right
                            //
                            Err = ERROR_INVALID_ACL;
                            break;
                        }
                    }
                }

                if ( Err != ERROR_SUCCESS ) {

                    break;
                }

                //
                // If that worked, we'll get the ids
                //
                for ( j = 0; j < 2; j++ ) {

                    //
                    // skip any space before ;
                    //
                    while(*Curr == L' ' ) {
                        Curr++;
                    }

                    if ( *Curr != SDDL_SEPERATORC ) {

                        wcsncpy( ConvertGuidString, Curr, STRING_GUID_LEN );
                        ConvertGuidString[ STRING_GUID_LEN ] = UNICODE_NULL;

                        if ( j == 0 ) {


                            if ( UuidFromStringW( ConvertGuidString, &ObjGuid ) == RPC_S_OK ) {

                                ObjId = &ObjGuid;

                            } else {

                                Err = RPC_S_INVALID_STRING_UUID;
                                break;
                            }

                        } else {

                            if ( UuidFromStringW( ConvertGuidString, &IObjGuid ) == RPC_S_OK ) {

                                IObjId = &IObjGuid;

                            } else {

                                Err = RPC_S_INVALID_STRING_UUID;
                                break;
                            }
                        }

                        // success
                        Curr += STRING_GUID_LEN;
                        if ( *Curr != SDDL_SEPERATORC &&
                             *Curr != L' ' ) {

                            Err = RPC_S_INVALID_STRING_UUID;
                            break;
                        }

                    }

                    Curr++;
                }

                if ( Err != ERROR_SUCCESS ) {

                    break;
                }

                //
                // skip any space before ;
                //
                while(*Curr == L' ' ) {
                    Curr++;
                }

                //
                // Finally, the SID
                //
                if ( ERROR_SUCCESS == Err ) {

                    PWSTR   End;
                    Err = LocalGetSidForString( Curr,
                                                &SidPtr,
                                                &End,
                                                &FreeSid,
                                                RootDomainSid,
                                                DomainSid,
                                                tSidLookupDomOrRootDomRelativeTable,
                                                DefaultToDomain );

                    if ( Err == ERROR_SUCCESS ) {

                        if ( End == NULL ) {
                            Err = ERROR_INVALID_ACL;
                        } else {

                            while(*End == L' ' ) {
                                End++;
                            }
                            //
                            // a ace must be terminated by ')'
                            //
                            if ( *End != SDDL_ACE_ENDC ) {
                                Err = ERROR_INVALID_ACL;

                            } else {

                                Curr = End + 1;

                                if ( !SidPtr ) {
                                    Err = ERROR_INVALID_ACL;
                                }
                            }
                        }

                    }
                }

                //
                // Quit on an error
                //
                if ( Err != ERROR_SUCCESS ) {

                    break;
                }

                //
                // Now, we'll create the ace, and add it...
                //

                //
                // First, make sure we have the room for it
                //
                switch ( Type ) {
                case ACCESS_ALLOWED_ACE_TYPE:
                case ACCESS_DENIED_ACE_TYPE:
                case SYSTEM_AUDIT_ACE_TYPE:
                case SYSTEM_ALARM_ACE_TYPE:

                    AceSize = sizeof( ACCESS_ALLOWED_ACE );
                    break;

                case ACCESS_ALLOWED_OBJECT_ACE_TYPE:
                case ACCESS_DENIED_OBJECT_ACE_TYPE:
                case SYSTEM_AUDIT_OBJECT_ACE_TYPE:
                case SYSTEM_ALARM_OBJECT_ACE_TYPE:
                    AceSize = sizeof( KNOWN_OBJECT_ACE );

                    if ( ObjId ) {

                        AceSize += sizeof ( GUID );
                    }

                    if ( IObjId ) {

                        AceSize += sizeof ( GUID );
                    }
                    break;

                default:
                    Err = ERROR_INVALID_ACL;
                    break;

                }

                if ( Err != ERROR_SUCCESS ) {

                    break;
                }

                AceSize += RtlLengthSid( SidPtr )  - sizeof( ULONG );

                if (AceSize + AclUsed > AclSize)
                {
                    //
                    // We'll have to reallocate, since our buffer isn't
                    // big enough...
                    //
                    PACL  NewAcl;
                    DWORD NewSize = AclSize + ( ( Acls - i ) * AceSize );

                    NewAcl = ( PACL )LocalAlloc( LMEM_FIXED | LMEM_ZEROINIT,
                                                 NewSize );
                    if ( NewAcl == NULL ) {

                        LocalFree( *Acl );
                        *Acl = NULL;

                        if ( FreeSid == TRUE ) {

                            LocalFree( SidPtr );
                            SidPtr = NULL;

                            FreeSid = FALSE;
                        }

                        Err = ERROR_NOT_ENOUGH_MEMORY;
                        break;

                    } else {

                        memcpy( NewAcl, *Acl, AclSize );
                        NewAcl->AclSize = ( USHORT )NewSize;

                        LocalFree( *Acl );
                        *Acl = NewAcl;

                        AclSize = NewSize;
                    }

                }

                AclUsed += AceSize;

                SetLastError( ERROR_SUCCESS );

                switch (Type)
                {
                case SYSTEM_AUDIT_ACE_TYPE:
                    OpRes = AddAuditAccessAceEx( *Acl,
                                                 ACL_REVISION,
                                                 Flags &
                                                     ~(SUCCESSFUL_ACCESS_ACE_FLAG |
                                                       FAILED_ACCESS_ACE_FLAG),
                                                 Mask,
                                                 SidPtr,
                                                 Flags & SUCCESSFUL_ACCESS_ACE_FLAG,
                                                 Flags & FAILED_ACCESS_ACE_FLAG );
                    break;

                case ACCESS_ALLOWED_ACE_TYPE:
                    OpRes = AddAccessAllowedAceEx( *Acl,
                                                   ACL_REVISION,
                                                   Flags,
                                                   Mask,
                                                   SidPtr );

                    break;

                case ACCESS_DENIED_ACE_TYPE:
                    OpRes = AddAccessDeniedAceEx( *Acl,
                                                  ACL_REVISION,
                                                   Flags,
                                                  Mask,
                                                  SidPtr );

                    break;

                case SYSTEM_AUDIT_OBJECT_ACE_TYPE:
                    OpRes = AddAuditAccessObjectAce( *Acl,
                                                     ACL_REVISION_DS,
                                                     Flags,
                                                     Mask,
                                                     ObjId,
                                                     IObjId,
                                                     SidPtr,
                                                     Flags & SUCCESSFUL_ACCESS_ACE_FLAG,
                                                     Flags & FAILED_ACCESS_ACE_FLAG );
                    break;

                case ACCESS_ALLOWED_OBJECT_ACE_TYPE:
                    OpRes = AddAccessAllowedObjectAce( *Acl,
                                                       ACL_REVISION_DS,
                                                       Flags,
                                                       Mask,
                                                       ObjId,
                                                       IObjId,
                                                        SidPtr );
                    break;

                case ACCESS_DENIED_OBJECT_ACE_TYPE:
                    OpRes = AddAccessDeniedObjectAce( *Acl,
                                                      ACL_REVISION_DS,
                                                      Flags,
                                                      Mask,
                                                      ObjId,
                                                      IObjId,
                                                      SidPtr );

                    break;

                default:
                    SetLastError( ERROR_INVALID_DATATYPE );
                    OpRes = FALSE;
                    break;

                }

                if ( OpRes == FALSE ) {

                    Err = GetLastError();
                    break;
                }

                //
                // Clean up whatever memory we have to
                //
                if ( FreeSid == TRUE ) {

                    LocalFree( SidPtr );
                }

                SidPtr = NULL;

                if ( *Curr == SDDL_ACE_BEGINC ) {

                    Curr++;
                }

            }

            //
            // If something didn't work, clean up
            //
            if ( Err != ERROR_SUCCESS ) {

                LocalFree( *Acl );
                *Acl = NULL;

            } else {

                //
                // Set a more realistic acl size
                //
                ( *Acl )->AclSize = ( USHORT )AclUsed;
            }

            //
            // free any SIDs buffer used
            //
            if ( FreeSid && SidPtr ) {
                LocalFree(SidPtr);
                SidPtr = NULL;
            }

            FreeSid = FALSE;
        }
    }

    return(Err);
}


DWORD
LocalConvertAclToString(
    IN PACL Acl,
    IN BOOLEAN AclPresent,
    IN BOOLEAN ConvertAsDacl,
    OUT PWSTR *AclString,
    OUT PDWORD AclStringSize,
    IN PSID RootDomainSid OPTIONAL
    )
/*++

Routine Description:

    This routine convert an acl into a string.  The format of the aces is:

    Ace := ( Type; Flags; Rights; ObjGuid; IObjGuid; Sid;
    Type : = A | D | OA | OD        {Access, Deny, ObjectAccess, ObjectDeny}
    Flags := Flags Flag
    Flag : = CI | IO | NP | SA | FA {Container Inherit,Inherit Only, NoProp,
                                     SuccessAudit, FailAdit }
    Rights := Rights Right
    Right := DS_READ_PROPERTY |  blah blah
    Guid := String representation of a GUID (via RPC UuidToString)
    Sid := DA | PS | AO | PO | AU | S-* (Domain Admins, PersonalSelf, Acct Ops,
                                         PrinterOps, AuthenticatedUsers, or
                                         the string representation of a sid)
    The seperator is a ';'.

    The returned string must be free via a call to LocalFree


Arguments:

    Acl - The acl to be converted

    AclPresent - if TRUE, the acl is present, even if NULL

    AclString - Where the created acl string is to be returned

    ConvertAsDacl - Convert the given acl as the DACL, not the SACL

    AclStringLen - The size of the allocated string is returned here


Return Value:

    ERROR_SUCCESS - success

    ERROR_NOT_ENOUGH_MEMORY indicates a memory allocation for the ouput acl
                            failed

    ERROR_INVALID_PARAMETER The string does not represent an ACL

    ERROR_INVALID_ACL - An unexpected access mask was encountered or a NULL acl was encountered

--*/
{
    DWORD   Err = ERROR_SUCCESS;
    DWORD   AclSize = 0, MaskSize;
    PACE_HEADER AceHeader;
    ULONG i, j;
    PWSTR *SidStrings = NULL, Curr, Guid;
    BOOLEAN *SidFrees = NULL;
    UINT *pMaskAsString = NULL;
    PSTRSD_KEY_LOOKUP MatchedEntry;
    PSTRSD_SID_LOOKUP MatchedSidEntry;
    PKNOWN_ACE KnownAce;
    PKNOWN_OBJECT_ACE KnownObjectAce;
    ACCESS_MASK AccessMask;
    PSID Sid, pSidSA=NULL;
    GUID *Obj, *Inherit;
    ULONG LookupFlags;
    ULONG AceFlags[ ] = {
        OBJECT_INHERIT_ACE,
        CONTAINER_INHERIT_ACE,
        NO_PROPAGATE_INHERIT_ACE,
        INHERIT_ONLY_ACE,
        INHERITED_ACE,
        SUCCESSFUL_ACCESS_ACE_FLAG,
        FAILED_ACCESS_ACE_FLAG
        };


    if ( AclString == NULL || AclStringSize == NULL ) {
        return(ERROR_INVALID_PARAMETER);
    }

    //
    // treat the case when (AclPresent == TRUE and Acl == NULL) 
    // same as the case when AclPresent == FALSE. 
    // This fix is to be compatible with IsValidSecurityDescriptor() 
    // when ACL_PRESENT bit is set and Acl == NULL
    //

    if ( !AclPresent || 
         (AclPresent &&  (Acl == NULL) ) ) {

        *AclString = NULL;
        *AclStringSize = 0;
        return( ERROR_SUCCESS );

    }

    //
    // If the ace count is 0, then it's an empty acl, and we don't handle those...
    //
    if ( Acl->AceCount == 0 ) {

        *AclString = NULL;
        *AclStringSize = 0;
        return( ERROR_SUCCESS );

    }

    if ( ConvertAsDacl ) {

        LookupFlags = SDDL_VALID_DACL;

    } else {

        LookupFlags = SDDL_VALID_SACL;
    }

    //
    // Allocate buffers to hold sids that are looked up
    //
    SidStrings = LocalAlloc( LMEM_FIXED | LMEM_ZEROINIT, Acl->AceCount * sizeof( PWSTR ) );

    if ( SidStrings == NULL ) {

        return( ERROR_NOT_ENOUGH_MEMORY );
    }

    SidFrees = LocalAlloc( LMEM_FIXED | LMEM_ZEROINIT, Acl->AceCount * sizeof( BOOLEAN ) );

    if ( SidFrees == NULL ) {

        LocalFree( SidStrings );
        return( ERROR_NOT_ENOUGH_MEMORY );
    }

    pMaskAsString = LocalAlloc( LMEM_FIXED | LMEM_ZEROINIT, Acl->AceCount * sizeof( UINT ) );

    if ( pMaskAsString == NULL ) {

        LocalFree( SidStrings );
        LocalFree( SidFrees );
        return( ERROR_NOT_ENOUGH_MEMORY );
    }

    AceHeader = ( PACE_HEADER )FirstAce( Acl );

    //
    // Size the acl, so we know how big a buffer to allocate
    //
    for(i = 0; i < Acl->AceCount && Err == ERROR_SUCCESS;
        i++, AceHeader = ( PACE_HEADER )NextAce( AceHeader ) ) {

        AclSize += sizeof( WCHAR );
        //
        // First, the type
        //
        MatchedEntry = LookupAceTypeInTable( NULL, ( ULONG )AceHeader->AceType, LookupFlags );

        if ( MatchedEntry ) {

            AclSize += SDDL_SIZE_TAG( MatchedEntry->Key ) + SDDL_SIZE_SEP( SDDL_SEPERATORC );

        } else {

            //
            // Found an invalid type
            //
            Err = ERROR_INVALID_ACL;
            break;
        }

        //
        // Next, process the ace flags
        //
        for ( j = 0; j < sizeof( AceFlags ) / sizeof( ULONG ); j++ ) {

            if ( ( ULONG )AceHeader->AceFlags & ( AceFlags[ j ] ) ) {

                MatchedEntry = LookupAceFlagsInTable( 0, AceFlags[ j ], LookupFlags );
                if ( MatchedEntry ) {

                    AclSize += SDDL_SIZE_TAG( MatchedEntry->Key );
                }
            }
        }

        if ( Err != ERROR_SUCCESS ) {

            break;

        } else {

            AclSize += SDDL_SIZE_SEP( SDDL_SEPERATORC );
        }

        //
        // Next, the rights and optionally the guids.  This gets done on a per ace type basis
        //
        switch ( AceHeader->AceType ) {
        case ACCESS_ALLOWED_ACE_TYPE:
        case ACCESS_DENIED_ACE_TYPE:
        case SYSTEM_AUDIT_ACE_TYPE:
        case SYSTEM_ALARM_ACE_TYPE:
            KnownAce = ( PKNOWN_ACE )AceHeader;
            AccessMask = KnownAce->Mask;
            Sid = ( PSID )&KnownAce->SidStart;

            break;

        case ACCESS_ALLOWED_OBJECT_ACE_TYPE:
        case ACCESS_DENIED_OBJECT_ACE_TYPE:
        case SYSTEM_AUDIT_OBJECT_ACE_TYPE:
        case SYSTEM_ALARM_OBJECT_ACE_TYPE:
            KnownObjectAce = ( PKNOWN_OBJECT_ACE )AceHeader;
            AccessMask = KnownObjectAce->Mask;
            Sid = RtlObjectAceSid( AceHeader );

            //
            // Deal with potential guids
            //
            if ( RtlObjectAceObjectType( AceHeader ) ) {

                AclSize += STRING_GUID_SIZE;
            }

            if ( RtlObjectAceInheritedObjectType( AceHeader ) ) {

                AclSize += STRING_GUID_SIZE;
            }

            break;

        default:
            Err = ERROR_INVALID_ACL;
            break;

        }

        //
        // Size the rights
        //
        if ( Err == ERROR_SUCCESS ) {

            MaskSize = 0;
            pMaskAsString[i] = 0;

            //
            // lookup for the exact value first
            //
            MatchedEntry = LookupAccessMaskInTable( 0, AccessMask, LookupFlags );

            if ( MatchedEntry ) {

                pMaskAsString[i] = 1;
                MaskSize += SDDL_SIZE_TAG( MatchedEntry->Key );

            } else {
                //
                // look for each bit
                //
                for ( j = 0; j < 32; j++ ) {

                    if ( AccessMask & ( 1 << j ) ) {

                        MatchedEntry = LookupAccessMaskInTable( 0, AccessMask & ( 1 << j ), LookupFlags );

                        if ( MatchedEntry ) {

                            MaskSize += SDDL_SIZE_TAG( MatchedEntry->Key );

                        } else {

                            //
                            // Found an invalid type.  We'll convert the whole thing to a string
                            //
                            pMaskAsString[i] = 2;
                            MaskSize = 10 * sizeof( WCHAR );
                            break;
                        }
                    }
                }
            }

            if ( Err != ERROR_SUCCESS ) {

                break;

            } else {

                AclSize += MaskSize;
                AclSize += SDDL_SIZE_SEP( SDDL_SEPERATORC );
            }
        }

        if ( Err != ERROR_SUCCESS ) {

            break;
        }

        //
        // Add in space for the guid seperators
        //
        AclSize += 2 * SDDL_SIZE_SEP( SDDL_SEPERATORC );

        //
        // Finally, lookup the sids
        //
        MatchedSidEntry = LookupSidInTable( NULL,
                                            Sid,
                                            RootDomainSid,
                                            NULL,
                                            NULL,
                                            FALSE,
                                            &pSidSA );

        //
        // If we didn't find a match, try it as a sid string
        //
        if ( MatchedSidEntry == NULL ) {

            if ( pSidSA ) {
                //
                // when sid lookup finds the sid of SA, pSidSA is assigned to Sid
                // so it doesn't need to be freed.
                //

                SidStrings[ i ] = LocalAlloc( LMEM_FIXED, (wcslen(SDDL_SCHEMA_ADMINISTRATORS)+1)*sizeof(TCHAR) );

                if ( SidStrings[ i ] == NULL ) {

                    Err = ERROR_NOT_ENOUGH_MEMORY;
                    break;

                } else {
                    wcscpy( SidStrings[ i ], SDDL_SCHEMA_ADMINISTRATORS );

                    SidFrees[ i ] = TRUE;
                }

            } else {

                if ( ConvertSidToStringSidW( Sid, &SidStrings[ i ] ) == FALSE ) {

                    Err = GetLastError();
                    break;

                } else {

                    SidFrees[ i ] = TRUE;
                }
            }

        } else {

            //
            // If the entry that's been selected hasn't been initialized yet, do it now
            //
            SidStrings[ i ] = MatchedSidEntry->Key;
        }
        AclSize += SDDL_SIZE_TAG( SidStrings[ i ] );


        AclSize += sizeof( WCHAR );  // Closing paren
        AclSize += sizeof( WCHAR );  // Trailing NULL
    }

    //
    // If all of that worked, allocate the return buffer, and build the acl string
    //
    if ( AclSize == 0 ) {
        Err = ERROR_INVALID_ACL;
    }

    if ( Err == ERROR_SUCCESS ) {

        if ( AclSize % 2 != 0 ) {
            AclSize++;
        }

        *AclString = LocalAlloc( LMEM_FIXED, AclSize );

        if ( *AclString == NULL ) {

            Err = ERROR_NOT_ENOUGH_MEMORY;
        }
    }

    //
    // Build the acl
    //
    if ( Err == ERROR_SUCCESS ) {

        Curr = *AclString;

        AceHeader = ( PACE_HEADER )FirstAce( Acl );

        //
        // Size the acl, so we know how big a buffer to allocate
        //
        for(i = 0; i < Acl->AceCount && Err == ERROR_SUCCESS;
            i++, AceHeader = ( PACE_HEADER )NextAce( AceHeader ) ) {

            //
            // "("
            //
            *Curr = SDDL_ACE_BEGINC;
            Curr++;

            //
            // By the time we get down here, we've ensured that we can lookup all the values,
            // so there is no need to check for failure
            //

            //
            // First, the type, must find it
            // "T;"
            //
            MatchedEntry = LookupAceTypeInTable( NULL, ( ULONG )AceHeader->AceType, LookupFlags );
            if ( MatchedEntry ) {
                wcscpy( Curr, MatchedEntry->Key );
                Curr += MatchedEntry->KeyLen;
            }
            *Curr = SDDL_SEPERATORC;
            Curr++;

            //
            // Next, process the ace flags
            // "CIIO;"
            //
            for ( j = 0; j < sizeof( AceFlags ) / sizeof( ULONG ); j++ ) {

                if ( ( ULONG )AceHeader->AceFlags & ( AceFlags[ j ] ) ) {

                    MatchedEntry = LookupAceFlagsInTable( 0, AceFlags[ j ], LookupFlags );

                    if ( MatchedEntry ) {

                        wcscpy( Curr, MatchedEntry->Key );
                        Curr+= MatchedEntry->KeyLen;

                    }

                }
            }
            *Curr = SDDL_SEPERATORC;
            Curr++;

            //
            // Next, the rights and optionally the guids.  This gets done on a per ace type basis
            //
            Obj = NULL;
            Inherit = NULL;

            switch ( AceHeader->AceType ) {
            case ACCESS_ALLOWED_ACE_TYPE:
            case ACCESS_DENIED_ACE_TYPE:
            case SYSTEM_AUDIT_ACE_TYPE:
            case SYSTEM_ALARM_ACE_TYPE:
                KnownAce = ( PKNOWN_ACE )AceHeader;
                AccessMask = KnownAce->Mask;
                Sid = ( PSID )&KnownAce->SidStart;

                break;

            case ACCESS_ALLOWED_OBJECT_ACE_TYPE:
            case ACCESS_DENIED_OBJECT_ACE_TYPE:
            case SYSTEM_AUDIT_OBJECT_ACE_TYPE:
            case SYSTEM_ALARM_OBJECT_ACE_TYPE:
                KnownObjectAce = ( PKNOWN_OBJECT_ACE )AceHeader;
                AccessMask = KnownObjectAce->Mask;
                Sid = RtlObjectAceSid( AceHeader );

                //
                // Deal with potential guids
                //
                Inherit = RtlObjectAceInheritedObjectType( AceHeader );
                Obj = RtlObjectAceObjectType( AceHeader );
                break;
            }

            //
            // Add the rights
            //
            if ( pMaskAsString[i] == 2 ) {

                wcscpy( Curr, L"0x");
                Curr += 2;
                _ultow( AccessMask, Curr, 16 );
                Curr += wcslen( Curr );

            } else if ( pMaskAsString[i] == 1 ) {

                //
                // lookup for the entire value first
                //
                MatchedEntry = LookupAccessMaskInTable( 0, AccessMask, LookupFlags );

                if ( MatchedEntry ) {

                    wcscpy( Curr, MatchedEntry->Key );
                    Curr += MatchedEntry->KeyLen;
                }

            } else { // 0

                for ( j = 0; j < 32; j++ ) {

                    if ( AccessMask & (1 << j) ) {

                        MatchedEntry = LookupAccessMaskInTable( 0, AccessMask & ( 1 << j ), LookupFlags );

                        if ( MatchedEntry ) {

                            wcscpy( Curr, MatchedEntry->Key );
                            Curr += MatchedEntry->KeyLen;

                        } // else shouldn't happen but if it happens
                          // it is too late to convert it into 0x format
                          // because the buffer is already allocated with smaller size.

                    }
                }
            }

            *Curr = SDDL_SEPERATORC;
            Curr++;


            //
            // Optional object guid
            //
            if ( Obj ) {

                Err = UuidToStringW( Obj, &Guid );

                if ( Err != ERROR_SUCCESS ) {

                    break;
                }

                wcscpy( Curr, Guid );
                Curr += wcslen( Guid );
                RpcStringFreeW( &Guid );

            }
            *Curr = SDDL_SEPERATORC;
            Curr++;

            if ( Inherit ) {

                Err = UuidToStringW( Inherit, &Guid );

                if ( Err != ERROR_SUCCESS ) {

                    break;
                }

                wcscpy( Curr, Guid );
                Curr += wcslen( Guid );
                RpcStringFreeW( &Guid );

            }
            *Curr = SDDL_SEPERATORC;
            Curr++;

            //
            // Finally, the sids
            //
            wcscpy( Curr, SidStrings[ i ] );
            Curr += wcslen( SidStrings[ i ] );

            *Curr = SDDL_ACE_ENDC;
            Curr++;
            *Curr = UNICODE_NULL;

        }
    }

    //
    // Free any allocated memory
    // jinhuang: should always free the allocated buffer
    //

//    if ( Err != ERROR_SUCCESS && SidStrings ) {

        for ( j = 0; j < Acl->AceCount; j++ ) {

            if ( SidFrees[ j ] ) {

                LocalFree( SidStrings[ j ] );
            }
        }
//    }

    LocalFree( SidStrings );
    LocalFree( SidFrees );
    LocalFree( pMaskAsString );

    if ( Err != ERROR_SUCCESS ) {

        LocalFree(*AclString);
        *AclString = NULL;
        *AclStringSize = 0;

    } else {

        *AclStringSize = AclSize;

    }

    return( Err );
}


DWORD
LocalConvertSDToStringSD_Rev1(
    IN  PSID RootDomainSid OPTIONAL,
    IN  PSECURITY_DESCRIPTOR  SecurityDescriptor,
    IN  SECURITY_INFORMATION  SecurityInformation,
    OUT LPWSTR  *StringSecurityDescriptor,
    OUT PULONG StringSecurityDescriptorLen OPTIONAL
    )
/*++

Routine Description:

    This routine converts a security descriptor into a string version persuant to SDDL definition

Arguments:

    SecurityDescriptor - Security Descriptor to be converted.

    SecurityInformation - the security information of which component to be converted

    StringSecurityDescriptor - Where the converted SD is returned.  Buffer is allocated via
        LocalAlloc and should be free via LocalFree.

    StringSecurityDescriptorLen - optional length of the converted SD buffer.

Return Value:

    TRUE    -   Success
    FALSE   -   Failure

    Extended error status is available using GetLastError.

--*/
{
    DWORD Err = ERROR_SUCCESS;
    NTSTATUS Status=STATUS_SUCCESS;
    DWORD ReturnBufferSize = 0, AclSize;
    PSID Owner = NULL, Group = NULL;
    PACL Dacl = NULL, Sacl = NULL;
    BOOLEAN Defaulted, SaclPresent=FALSE, DaclPresent=FALSE;
    PWSTR OwnerString = NULL, GroupString = NULL, SaclString = NULL, DaclString = NULL;
    SECURITY_DESCRIPTOR_CONTROL ControlCode;
    ULONG Revision;
    PWSTR DaclControl=NULL, SaclControl=NULL;

    if ( SecurityDescriptor == NULL || StringSecurityDescriptor == NULL ) {
        return(ERROR_INVALID_PARAMETER);
    }

    //
    // Get the relevant security descriptor parts
    // based on the SecurityInforamtion input parameter
    //
    if ( SecurityInformation & OWNER_SECURITY_INFORMATION ) {

        Status = RtlGetOwnerSecurityDescriptor( SecurityDescriptor, &Owner, &Defaulted );
    }

    if ( NT_SUCCESS( Status ) &&
         SecurityInformation & GROUP_SECURITY_INFORMATION ) {

        Status = RtlGetGroupSecurityDescriptor( SecurityDescriptor, &Group, &Defaulted );

    }

    if ( NT_SUCCESS( Status ) &&
         SecurityInformation & DACL_SECURITY_INFORMATION ) {

        Status = RtlGetDaclSecurityDescriptor( SecurityDescriptor, &DaclPresent, &Dacl, &Defaulted );
    }

    if ( NT_SUCCESS( Status ) &&
         SecurityInformation & SACL_SECURITY_INFORMATION ) {

        Status = RtlGetSaclSecurityDescriptor( SecurityDescriptor, &SaclPresent, &Sacl, &Defaulted );
    }

    if ( NT_SUCCESS( Status ) ) {

        Status = RtlGetControlSecurityDescriptor ( SecurityDescriptor, &ControlCode, &Revision);
    }

    if ( !NT_SUCCESS( Status ) ) {

        Err = RtlNtStatusToDosError( Status );
        return( Err );
    }

    //
    // make sure the SidLookup table is reinitialized
    //
    InitializeSidLookupTable(STRSD_REINITIALIZE_ENTER);

    //
    // Convert the owner and group, if they exist
    //
    if ( Owner ) {

        Err = LocalGetStringForSid( Owner,
                                    &OwnerString,
                                    RootDomainSid
                                  );

    }

    if ( Err == ERROR_SUCCESS && Group ) {

        Err = LocalGetStringForSid( Group,
                                    &GroupString,
                                    RootDomainSid );
    }

    //
    // JINHUANG 3/10/98
    // get DACL control string
    //
    if ( Err == ERROR_SUCCESS && ControlCode ) {

        Err = LocalGetStringForControl(ControlCode, SDDL_VALID_DACL, &DaclControl);
    }

    //
    // get SACL control string
    //
    if ( Err == ERROR_SUCCESS && ControlCode ) {

        Err = LocalGetStringForControl(ControlCode, SDDL_VALID_SACL, &SaclControl);
    }

    //
    // SACL first because the size of DACL is needed later
    //
    if ( Err == ERROR_SUCCESS && SaclPresent ) {


        Err = LocalConvertAclToString( Sacl,
                                       SaclPresent,
                                       FALSE,
                                       &SaclString,
                                       &AclSize,
                                       RootDomainSid );
        if ( Err == ERROR_SUCCESS ) {

            ReturnBufferSize += AclSize;
        }
    }

    //
    // Then, the DACL
    //
    if ( Err == ERROR_SUCCESS && DaclPresent ) {

        Err = LocalConvertAclToString( Dacl,
                                       DaclPresent,
                                       TRUE,
                                       &DaclString,
                                       &AclSize,
                                       RootDomainSid );

        if ( Err == ERROR_SUCCESS ) {

            ReturnBufferSize += AclSize;
        }
    }

    //
    // Now, if all of that worked, allocate and build the return string
    //
    if ( Err == ERROR_SUCCESS ) {

        if ( OwnerString ) {

            ReturnBufferSize += ( wcslen( OwnerString ) * sizeof( WCHAR ) ) +
                                SDDL_SIZE_TAG( SDDL_OWNER )  +
                                SDDL_SIZE_SEP( SDDL_DELIMINATORC );
        }

        if ( GroupString ) {

            ReturnBufferSize += ( wcslen( GroupString ) * sizeof( WCHAR ) ) +
                                SDDL_SIZE_TAG( SDDL_GROUP )  +
                                SDDL_SIZE_SEP( SDDL_DELIMINATORC );
        }

        if ( DaclPresent ) {

            ReturnBufferSize += SDDL_SIZE_TAG( SDDL_DACL )  +
                                SDDL_SIZE_SEP( SDDL_DELIMINATORC );

            if ( DaclControl ) {
                ReturnBufferSize += (wcslen( DaclControl ) * sizeof(WCHAR)) ;
            }
        }

        if ( SaclPresent ) {

            ReturnBufferSize += SDDL_SIZE_TAG( SDDL_SACL )  +
                                SDDL_SIZE_SEP( SDDL_DELIMINATORC );

            if ( SaclControl ) {
                ReturnBufferSize += (wcslen( SaclControl ) * sizeof(WCHAR)) ;
            }
        }


        *StringSecurityDescriptor = LocalAlloc( LMEM_FIXED | LMEM_ZEROINIT,
                                                ReturnBufferSize + sizeof( WCHAR ) );

        if ( *StringSecurityDescriptor == NULL ) {

            Err = ERROR_NOT_ENOUGH_MEMORY;

        } else {

            //
            // Build the string from the previously determined components.  Note that
            // if a component is not present, it is skipped.
            //
            DWORD dwOffset=0;

            if ( OwnerString ) {

                swprintf( *StringSecurityDescriptor, L"%ws%wc%ws",
                          SDDL_OWNER, SDDL_DELIMINATORC, OwnerString );

                dwOffset = wcslen(*StringSecurityDescriptor);
            }

            if ( GroupString ) {

                swprintf( *StringSecurityDescriptor + dwOffset,
                          L"%ws%wc%ws", SDDL_GROUP, SDDL_DELIMINATORC, GroupString );

                Revision = wcslen( *StringSecurityDescriptor + dwOffset ); // temp use
                dwOffset += Revision;

            }

            if ( DaclPresent ) {

                if ( DaclControl ) {
                    swprintf( *StringSecurityDescriptor + dwOffset,
                          L"%ws%wc%ws", SDDL_DACL, SDDL_DELIMINATORC, DaclControl );
                } else {
                    swprintf( *StringSecurityDescriptor + dwOffset,
                          L"%ws%wc", SDDL_DACL, SDDL_DELIMINATORC );
                }

                Revision = wcslen( *StringSecurityDescriptor + dwOffset );
                dwOffset += Revision;

                if ( DaclString ) {

                    wcscpy( *StringSecurityDescriptor + dwOffset, DaclString );

                    Revision = wcslen( *StringSecurityDescriptor + dwOffset ); // temp use
                    dwOffset += Revision;  // (AclSize/sizeof(WCHAR));
                }

            }

            if ( SaclPresent ) {

                if ( SaclControl ) {

                    swprintf( *StringSecurityDescriptor + dwOffset,
                              L"%ws%wc%ws", SDDL_SACL, SDDL_DELIMINATORC, SaclControl );
                } else {
                    swprintf( *StringSecurityDescriptor + dwOffset,
                              L"%ws%wc", SDDL_SACL, SDDL_DELIMINATORC );
                }

                Revision = wcslen( *StringSecurityDescriptor + dwOffset );
                dwOffset += Revision;

                if ( SaclString ) {

                    wcscpy( *StringSecurityDescriptor + dwOffset, SaclString);
                }

            }

            //
            // jinhuang
            // output the buffer size
            //

            if ( StringSecurityDescriptorLen ) {
                *StringSecurityDescriptorLen = ReturnBufferSize/sizeof(WCHAR);
            }
        }
    }


    //
    // Free any buffers that were allocated
    //
    LocalFree( OwnerString );
    LocalFree( GroupString );
    LocalFree( SaclString );
    LocalFree( DaclString );

    //
    // JINHUANG 3/10/98
    // it's ok to free them even if they are NULL
    //
    LocalFree( SaclControl );
    LocalFree( DaclControl );

    //
    // decrement the SidLookup instance
    //
    InitializeSidLookupTable(STRSD_REINITIALIZE_LEAVE);

    return( Err );
}




DWORD
LocalConvertStringSDToSD_Rev1(
    IN  PSID RootDomainSid OPTIONAL,
    IN  PSID DomainSid OPTIONAL,
    IN  BOOLEAN DefaultToDomain,
    IN  LPCWSTR StringSecurityDescriptor,
    OUT PSECURITY_DESCRIPTOR  *SecurityDescriptor,
    OUT PULONG  SecurityDescriptorSize OPTIONAL
    )
/*++

Routine Description:

    This routine converts a revision 1 stringized Security descriptor into a valid, functional
    security descriptor

Arguments:

    StringSecurityDescriptor - Stringized security descriptor to be converted.

    SecurityDescriptor - Where the converted SD is returned.  Buffer is allocated via
        LocalAlloc and should be free via LocalFree.  The returned security descriptor
        is always self relative

    SecurityDescriptorSize - OPTIONAL.  If non-NULL, the size of the converted security
        descriptor is returned here.

    SecurityInformation - OPTIONAL. If non-NULL, the security information of the converted
        security descriptor is returned here.

Return Value:

    TRUE    -   Success
    FALSE   -   Failure

    Extended error status is available using GetLastError.

        ERROR_INVALID_PARAMETER - A NULL input or output parameter was given

        ERROR_UNKNOWN_REVISION - An unsupported revision was given

--*/
{
    DWORD Err = ERROR_SUCCESS;
    PSID Owner = NULL, Group = NULL;
    PACL Dacl  = NULL, Sacl  = NULL;
    SECURITY_INFORMATION SeInfo = 0;
    SECURITY_DESCRIPTOR SD;
    PWSTR Curr, End;
    NTSTATUS Status;
    BOOLEAN FreeOwner = FALSE, FreeGroup = FALSE;
    SID_IDENTIFIER_AUTHORITY UaspBuiltinAuthority = SECURITY_NT_AUTHORITY;
    SID_IDENTIFIER_AUTHORITY UaspCreatorAuthority = SECURITY_CREATOR_SID_AUTHORITY;
    ULONG SDSize = 0;
    BOOLEAN DaclPresent = FALSE, SaclPresent = FALSE;
    SECURITY_DESCRIPTOR_CONTROL DaclControl=0, SaclControl=0;
    PSTRSD_SID_LOOKUP    tSidLookupDomOrRootDomRelativeTable = NULL;


    if ( StringSecurityDescriptor == NULL || SecurityDescriptor == NULL ) {
        return(ERROR_INVALID_PARAMETER);
    }

    if ( SecurityDescriptorSize ) {

        *SecurityDescriptorSize = 0;
    }

    //
    // make sure the SidLookup table is reinitialized
    //
    InitializeSidLookupTable(STRSD_REINITIALIZE_ENTER);

    //
    // for the API ConvertStringSDToSDDomain, if DomainSid != NULL, we need a table on
    // the heap, for this thread to stash lookups for ST_DOMAIN_RELATIVE type trustees
    // this table will be freed when all lookups have been done for this thread
    //



    if (DomainSid) {

        tSidLookupDomOrRootDomRelativeTable =
            (PSTRSD_SID_LOOKUP) LocalAlloc(LMEM_ZEROINIT, sizeof(SidLookupDomOrRootDomRelative));

        //
        // table copy/init from the template-table
        //

        if (tSidLookupDomOrRootDomRelativeTable)

            memcpy(tSidLookupDomOrRootDomRelativeTable,
                   SidLookupDomOrRootDomRelative,
                   sizeof(SidLookupDomOrRootDomRelative));

        else

            Err = ERROR_NOT_ENOUGH_MEMORY;

    }

    //
    // Now, we'll just start parsing and building
    //
    Curr = ( PWSTR )StringSecurityDescriptor;

    while ( Err == ERROR_SUCCESS && Curr ) {

        switch( *Curr ) {

        //
        // Get the Owner sid
        //
        case L'O':

            Err = ERROR_INVALID_PARAMETER;

            if ( *(Curr+1) == SDDL_DELIMINATORC ) {

                Curr += 2;

                if ( Owner == NULL )  {

                    Err = LocalGetSidForString( Curr,
                                                &Owner,
                                                &End,
                                                &FreeOwner,
                                                RootDomainSid,
                                                DomainSid,
                                                tSidLookupDomOrRootDomRelativeTable,
                                                DefaultToDomain );

                    if ( Err == ERROR_SUCCESS ) {

                        Curr = End;
                        SeInfo |= OWNER_SECURITY_INFORMATION;
                    }
                }
            }
            break;

        //
        // Get the Group sid
        //
        case L'G':

            Err = ERROR_INVALID_PARAMETER;

            if ( *(Curr+1) == SDDL_DELIMINATORC ) {

                Curr += 2;

                if ( Group == NULL ) {

                    Err = LocalGetSidForString( Curr,
                                                &Group,
                                                &End,
                                                &FreeGroup,
                                                RootDomainSid,
                                                DomainSid,
                                                tSidLookupDomOrRootDomRelativeTable,
                                                DefaultToDomain );

                    if ( Err == ERROR_SUCCESS ) {

                        Curr = End;
                        SeInfo |= GROUP_SECURITY_INFORMATION;
                    }
                }
            }
            break;

        //
        // Next, the DAcl
        //
        case L'D':

            if ( *(Curr+1) == SDDL_DELIMINATORC ) {

                Curr += 2;

                if ( Dacl == NULL ) {

                    //
                    // JINHUANG: 3/10/98
                    // look for any security descriptor controls
                    //
                    if ( *Curr != SDDL_ACE_BEGINC ) {

                        Err = LocalGetSDControlForString( Curr,
                                                          SDDL_VALID_DACL,
                                                          &DaclControl,
                                                          &End );
                        if ( Err == ERROR_SUCCESS ) {
                            Curr = End;
                        }
                    }

                    if ( Err == ERROR_SUCCESS ) {

                        Err = LocalGetAclForString( Curr,
                                                    TRUE,
                                                    &Dacl,
                                                    &End,
                                                    RootDomainSid,
                                                    DomainSid,
                                                    tSidLookupDomOrRootDomRelativeTable,
                                                    DefaultToDomain );

                        if ( Err == ERROR_SUCCESS ) {

                            Curr = End;
                            SeInfo |= DACL_SECURITY_INFORMATION;
                            DaclPresent = TRUE;
                        }
                    }

                } else {

                    Err = ERROR_INVALID_PARAMETER;
                }

            } else {

                Err = ERROR_INVALID_PARAMETER;
            }
            break;

        //
        // Finally, the SAcl
        //
        case L'S':

            if ( *(Curr+1) == SDDL_DELIMINATORC ) {

                Curr += 2;

                if ( Sacl == NULL ) {

                    //
                    // JINHUANG: 3/10/98
                    // look for any security descriptor controls
                    //
                    if ( *Curr != SDDL_ACE_BEGINC ) {

                        Err = LocalGetSDControlForString( Curr,
                                                          SDDL_VALID_SACL,
                                                          &SaclControl,
                                                          &End );
                        if ( Err == ERROR_SUCCESS ) {
                            Curr = End;
                        }
                    }

                    if ( Err == ERROR_SUCCESS ) {

                        Err = LocalGetAclForString( Curr,
                                                    FALSE,
                                                    &Sacl,
                                                    &End,
                                                    RootDomainSid,
                                                    DomainSid,
                                                    tSidLookupDomOrRootDomRelativeTable,
                                                    DefaultToDomain );

                        if ( Err == ERROR_SUCCESS ) {

                            Curr = End;
                            SeInfo |= SACL_SECURITY_INFORMATION;
                            SaclPresent = TRUE;
                        }
                    }

                } else {

                    Err = ERROR_INVALID_PARAMETER;
                }

            } else {

                Err = ERROR_INVALID_PARAMETER;
            }
            break;

        //
        // It's a space, so ignore it
        //
        case L' ':
            Curr++;
            break;

        //
        // End of the string, so quit
        //
        case L'\0':
            Curr = NULL;
            break;

        //
        // Don't know what it is, so consider it an error
        //
        default:
            Err = ERROR_INVALID_PARAMETER;
            break;
        }
    }


    //
    // Ok, if we have the information we need, we'll create the security
    // descriptor
    //
    if ( Err == ERROR_SUCCESS ) {

        if ( InitializeSecurityDescriptor(&SD, SECURITY_DESCRIPTOR_REVISION ) == FALSE ) {

            Err = GetLastError();
        }

        //
        // JINHUANG 3/10/98
        // set the security descriptor control
        //

        SD.Control |= (DaclControl | SaclControl);

        //
        // Now, add the owner and group
        //
        if ( Err == ERROR_SUCCESS && Owner != NULL ) {

            if ( SetSecurityDescriptorOwner(&SD, Owner, FALSE ) == FALSE ) {

                Err = GetLastError();
            }
        }

        if ( Err == ERROR_SUCCESS && Group != NULL ) {

            if ( SetSecurityDescriptorGroup( &SD, Group, FALSE ) == FALSE ) {

                Err = GetLastError();
            }
        }

        //
        // Then the DACL and SACL
        //
        if ( Err == ERROR_SUCCESS && DaclPresent ) {

            if ( SetSecurityDescriptorDacl( &SD, DaclPresent, Dacl, FALSE ) == FALSE ) {

                Err = GetLastError();
            }
        }

        if ( Err == ERROR_SUCCESS && SaclPresent ) {

            if ( SetSecurityDescriptorSacl( &SD, SaclPresent, Sacl, FALSE ) == FALSE ) {

                Err = GetLastError();
            }
        }

    }

    //
    // Finally, we'll allocate our buffer and return
    //
    if ( Err == ERROR_SUCCESS ) {

        MakeSelfRelativeSD( &SD, *SecurityDescriptor, &SDSize );

        if ( GetLastError() == ERROR_INSUFFICIENT_BUFFER ) {

            *SecurityDescriptor = (PSECURITY_DESCRIPTOR) LocalAlloc( LMEM_FIXED | LMEM_ZEROINIT,
                                                                     SDSize );

            if ( *SecurityDescriptor == NULL ) {

                Err = ERROR_NOT_ENOUGH_MEMORY;

            } else {

                if ( MakeSelfRelativeSD( &SD, *SecurityDescriptor, &SDSize ) == FALSE ) {

                    Err = GetLastError();
                    LocalFree( *SecurityDescriptor );
                    *SecurityDescriptor = NULL;

                }
            }

        } else {

            //
            // This should never happen
            //
            if ( GetLastError() == ERROR_SUCCESS ) {

                Err = ERROR_INSUFFICIENT_BUFFER;
            }
        }
    }

    //
    // Return the security descriptor size, if requested
    //
    if ( Err == ERROR_SUCCESS && SecurityDescriptorSize ) {

        *SecurityDescriptorSize = SDSize;
    }

    //
    // Finally, free any memory we may have allocated...
    //
    if ( FreeOwner == TRUE ) {

        LocalFree( Owner );

    }

    if ( FreeGroup == TRUE ) {

        LocalFree( Group );

    }

    LocalFree( Dacl );
    LocalFree( Sacl );

    if (tSidLookupDomOrRootDomRelativeTable)

        LocalFree(tSidLookupDomOrRootDomRelativeTable);

    //
    // make sure the SidLookup table is reinitialized
    //
    InitializeSidLookupTable(STRSD_REINITIALIZE_LEAVE);

    return( Err );
}

STRSD_SID_LOOKUP    gDomainSidLookup;
STRSD_SID_LOOKUP    gDnsDomainSidLookup;

BOOL    gbDomainSidCached = FALSE;
BOOL    gbDnsDomainSidCached = FALSE;


BOOLEAN
CacheDomainAndDnsDomainSids(
    )
{
    OBJECT_ATTRIBUTES ObjectAttributes;
    NTSTATUS Status=STATUS_SUCCESS;
    LSA_HANDLE LsaPolicyHandle;
    PPOLICY_ACCOUNT_DOMAIN_INFO DomainInfo = NULL;
    PPOLICY_DNS_DOMAIN_INFO DnsDomainInfo = NULL;

    InitializeObjectAttributes( &ObjectAttributes, NULL, 0, NULL, NULL );

    Status = LsaOpenPolicy( NULL, &ObjectAttributes,
                            POLICY_VIEW_LOCAL_INFORMATION,
                            &LsaPolicyHandle );

    //
    // There's a high probability that both LSA queries succeed or fail together 
    //

    if ( NT_SUCCESS(Status) ) {

        Status = LsaQueryInformationPolicy( LsaPolicyHandle,
                                            PolicyDnsDomainInformation,
                                            ( PVOID * )&DnsDomainInfo );

        if ( NT_SUCCESS(Status) && DnsDomainInfo != NULL && DnsDomainInfo->Sid != NULL ) {

            RtlCopyMemory( gDnsDomainSidLookup.SidBuff, DnsDomainInfo->Sid,
                           RtlLengthSid( DnsDomainInfo->Sid ) );

            gDnsDomainSidLookup.Sid = (PSID) gDnsDomainSidLookup.SidBuff;

            gbDnsDomainSidCached = TRUE;
        }


        Status = LsaQueryInformationPolicy( LsaPolicyHandle,
                                            PolicyAccountDomainInformation,
                                            ( PVOID * )&DomainInfo );

        if ( NT_SUCCESS(Status) && DomainInfo != NULL && DomainInfo->DomainSid != NULL ) {

            RtlCopyMemory( gDomainSidLookup.SidBuff, DomainInfo->DomainSid,
                           RtlLengthSid( DomainInfo->DomainSid ) );

            gDomainSidLookup.Sid = (PSID) gDomainSidLookup.SidBuff;
            
            gbDomainSidCached = TRUE;
        }
    
        LsaClose( LsaPolicyHandle );

    }
    
    LsaFreeMemory( DomainInfo );
    LsaFreeMemory( DnsDomainInfo );
    
    return TRUE;
}

BOOL    gbLookupTableInitialized = FALSE;


BOOLEAN
InitializeSidLookupTable(
    IN BYTE InitFlag
    )
{
    SID_IDENTIFIER_AUTHORITY UaspWorldAuthority = SECURITY_WORLD_SID_AUTHORITY;
    SID_IDENTIFIER_AUTHORITY UaspLocalAuthority = SECURITY_LOCAL_SID_AUTHORITY;
    SID_IDENTIFIER_AUTHORITY UaspCreatorAuthority = SECURITY_CREATOR_SID_AUTHORITY;
    SID_IDENTIFIER_AUTHORITY UaspNtAuthority = SECURITY_NT_AUTHORITY;
    DWORD i;


    EnterCriticalSection(&SddlSidLookupCritical);

    switch ( InitFlag ) {
    case STRSD_REINITIALIZE_ENTER:

        SidTableReinitializeInstance++;

        if ( SidTableReinitializeInstance > 1 || gbLookupTableInitialized == TRUE) {
            //
            // there is another thread going, or no need to reinitialize the table again
            //
            LeaveCriticalSection(&SddlSidLookupCritical);

            return TRUE;
        }
        break;

    case STRSD_REINITIALIZE_LEAVE:

        if ( SidTableReinitializeInstance > 1 ) {
            SidTableReinitializeInstance--;
        } else {
            SidTableReinitializeInstance = 0;
        }

        LeaveCriticalSection(&SddlSidLookupCritical);

        return TRUE;
        break;
    }


    CacheDomainAndDnsDomainSids();

    //
    // If the list of sids hasn't been built, do it now
    //
    // JINHUANG 3/26 BVT break,
    // see comments above always try to initialization table
    // but skip the ones already initialized for performance
    //
    for ( i = 0;
          i < sizeof( SidLookup ) / sizeof( STRSD_SID_LOOKUP ); i++ ) {

        if ( STRSD_REINITIALIZE_ENTER == InitFlag ) {
            SidLookup[ i ].Valid = FALSE;
        }

        if ( SidLookup[ i ].Valid == TRUE &&
             SidLookup[ i ].Sid != NULL ) {
            //
            // this one is already initialized
            //
            continue;
        }

        SidLookup[ i ].Sid = ( PSID )SidLookup[ i ].SidBuff;

        switch ( SidLookup[ i ].SidType ) {
        case ST_DOMAIN_RELATIVE:

            if ( gbDnsDomainSidCached ) {

                RtlCopyMemory( SidLookup[ i ].Sid, gDnsDomainSidLookup.Sid,
                               RtlLengthSid( gDnsDomainSidLookup.Sid ) );
                ( ( PISID )( SidLookup[ i ].Sid ) )->SubAuthorityCount++;
                *( RtlSubAuthoritySid( SidLookup[ i ].Sid,
                                       *( RtlSubAuthorityCountSid( gDnsDomainSidLookup.Sid ) ) ) ) =
                                       SidLookup[ i ].Rid;
                SidLookup[ i ].Valid = TRUE;

            }

            break;

        case ST_ROOT_DOMAIN_RELATIVE:
            //
            // will be initialized on demand
            //
            break;

        case ST_WORLD:
            RtlInitializeSid( SidLookup[ i ].Sid, &UaspWorldAuthority, 1 );
            *( RtlSubAuthoritySid( SidLookup[ i ].Sid, 0 ) ) = SidLookup[ i ].Rid;
            SidLookup[ i ].Valid = TRUE;
            break;

        case ST_LOCALSY:
            RtlInitializeSid( SidLookup[ i ].Sid, &UaspLocalAuthority, 1 );
            *( RtlSubAuthoritySid( SidLookup[ i ].Sid, 0 ) ) = SidLookup[ i ].Rid;
            SidLookup[ i ].Valid = TRUE;
            break;

        case ST_LOCAL:
            if ( gbDomainSidCached ) {

                RtlCopyMemory( SidLookup[ i ].Sid, gDomainSidLookup.Sid,
                               RtlLengthSid( gDomainSidLookup.Sid ) );

                ( ( PISID )( SidLookup[ i ].Sid ) )->SubAuthorityCount++;
                *( RtlSubAuthoritySid( SidLookup[ i ].Sid,
                                       *( RtlSubAuthorityCountSid( gDomainSidLookup.Sid ) ) ) ) =
                                       SidLookup[ i ].Rid;
                SidLookup[ i ].Valid = TRUE;
            }
            break;

        case ST_CREATOR:
            RtlInitializeSid( SidLookup[ i ].Sid, &UaspCreatorAuthority, 1 );
            *( RtlSubAuthoritySid( SidLookup[ i ].Sid, 0 ) ) = SidLookup[ i ].Rid;
            SidLookup[ i ].Valid = TRUE;
            break;

        case ST_NTAUTH:
            RtlInitializeSid( SidLookup[ i ].Sid, &UaspNtAuthority, 1 );
            *( RtlSubAuthoritySid( SidLookup[ i ].Sid, 0 ) ) = SidLookup[ i ].Rid;
            SidLookup[ i ].Valid = TRUE;
            break;

        case ST_BUILTIN:
            RtlInitializeSid( SidLookup[ i ].Sid, &UaspNtAuthority, 2 );
            *( RtlSubAuthoritySid( SidLookup[ i ].Sid, 0 ) ) = SECURITY_BUILTIN_DOMAIN_RID;
            *( RtlSubAuthoritySid( SidLookup[ i ].Sid, 1 ) ) = SidLookup[ i ].Rid;
            SidLookup[ i ].Valid = TRUE;
            break;

        }
    }

    //
    // only update gbLookupTableInitialized if LSA Lookups passed
    //

    if (gbDnsDomainSidCached && gbDomainSidCached)
        gbLookupTableInitialized = TRUE;

    LeaveCriticalSection(&SddlSidLookupCritical);

    return TRUE;
}


BOOL
APIENTRY
ConvertStringSDToSDRootDomainA(
    IN  PSID RootDomainSid OPTIONAL,
    IN  LPCSTR StringSecurityDescriptor,
    IN  DWORD StringSDRevision,
    OUT PSECURITY_DESCRIPTOR  *SecurityDescriptor,
    OUT PULONG  SecurityDescriptorSize OPTIONAL
    )
{
    UNICODE_STRING Unicode;
    ANSI_STRING AnsiString;
    NTSTATUS Status;
    BOOL Result;

    if ( NULL == StringSecurityDescriptor ||
         NULL == SecurityDescriptor ) {

        SetLastError(ERROR_INVALID_PARAMETER);
        return(FALSE);
    }

    RtlInitAnsiString( &AnsiString, StringSecurityDescriptor );

    Status = SddlpAnsiStringToUnicodeString(&Unicode,                                                                                                            
                                            &AnsiString);

    if ( !NT_SUCCESS( Status ) ) {

        BaseSetLastNTError( Status );

        return FALSE;

    }

    Result = ConvertStringSDToSDRootDomainW( RootDomainSid,
                                           ( LPCWSTR )Unicode.Buffer,
                                           StringSDRevision,
                                           SecurityDescriptor,
                                           SecurityDescriptorSize);

    LocalFree( Unicode.Buffer );

    if ( Result ) {
        SetLastError(ERROR_SUCCESS);
    }

    return( Result );

}

BOOL
APIENTRY
ConvertStringSDToSDRootDomainW(
    IN  PSID RootDomainSid OPTIONAL,
    IN  LPCWSTR StringSecurityDescriptor,
    IN  DWORD StringSDRevision,
    OUT PSECURITY_DESCRIPTOR  *SecurityDescriptor,
    OUT PULONG  SecurityDescriptorSize OPTIONAL
    )
{

    DWORD Err = ERROR_SUCCESS;

    //
    // Little elementary parameter checking...
    //
    if ( StringSecurityDescriptor == NULL || SecurityDescriptor == NULL ) {

        Err = ERROR_INVALID_PARAMETER;

    } else {

        switch ( StringSDRevision ) {
        case SDDL_REVISION_1:

            Err = LocalConvertStringSDToSD_Rev1( RootDomainSid,  // root domain sid
                                                 NULL,  // no domain sid is provided for this API
                                                 TRUE, // default to domain for EA/SA if root domain sid is not provided
                                                 StringSecurityDescriptor,
                                                 SecurityDescriptor,
                                                 SecurityDescriptorSize);
            break;

        default:

            Err = ERROR_UNKNOWN_REVISION;
            break;
        }

    }

    SetLastError( Err );

    return( Err == ERROR_SUCCESS );
}

BOOL
APIENTRY
ConvertSDToStringSDRootDomainA(
    IN  PSID RootDomainSid OPTIONAL,
    IN  PSECURITY_DESCRIPTOR  SecurityDescriptor,
    IN  DWORD RequestedStringSDRevision,
    IN  SECURITY_INFORMATION SecurityInformation,
    OUT LPSTR  *StringSecurityDescriptor OPTIONAL,
    OUT PULONG StringSecurityDescriptorLen OPTIONAL
    )
{
    LPWSTR StringSecurityDescriptorW = NULL;
    ULONG AnsiLen, WideLen = 0;
    BOOL ReturnValue ;

    if ( StringSecurityDescriptor == NULL ||
         0 == SecurityInformation ) {

        SetLastError( ERROR_INVALID_PARAMETER );
        return( FALSE );
    }

    ReturnValue = ConvertSDToStringSDRootDomainW(
                      RootDomainSid,
                      SecurityDescriptor,
                      RequestedStringSDRevision,
                      SecurityInformation,
                      &StringSecurityDescriptorW,
                      &WideLen );

    if ( ReturnValue ) {


        AnsiLen = WideCharToMultiByte( CP_ACP,
                                       0,
                                       StringSecurityDescriptorW,
                                       WideLen + 1,
                                       *StringSecurityDescriptor,
                                       0,
                                       NULL,
                                       NULL );

        if ( AnsiLen != 0 ) {

            *StringSecurityDescriptor = LocalAlloc( LMEM_FIXED, AnsiLen );

            if ( *StringSecurityDescriptor == NULL ) {

                SetLastError( ERROR_NOT_ENOUGH_MEMORY );
                ReturnValue = FALSE;

            } else {

                AnsiLen = WideCharToMultiByte( CP_ACP,
                                               0,
                                               StringSecurityDescriptorW,
                                               WideLen + 1,
                                               *StringSecurityDescriptor,
                                               AnsiLen,
                                               NULL,
                                               NULL );
                ASSERT( AnsiLen != 0 );

                if ( AnsiLen == 0 ) {

                    LocalFree(*StringSecurityDescriptor);
                    *StringSecurityDescriptor = NULL;

                    ReturnValue = FALSE;
                }

                //
                // jinhuang
                // output the length (optional)
                //
                if ( StringSecurityDescriptorLen ) {
                    *StringSecurityDescriptorLen = AnsiLen;
                }

            }

        } else {

            ReturnValue = FALSE;
        }

        LocalFree(StringSecurityDescriptorW);

    }

    if ( ReturnValue ) {
        SetLastError(ERROR_SUCCESS);
    }

    return( ReturnValue );

}

BOOL
APIENTRY
ConvertSDToStringSDRootDomainW(
    IN  PSID RootDomainSid OPTIONAL,
    IN  PSECURITY_DESCRIPTOR  SecurityDescriptor,
    IN  DWORD RequestedStringSDRevision,
    IN  SECURITY_INFORMATION SecurityInformation,
    OUT LPWSTR  *StringSecurityDescriptor OPTIONAL,
    OUT PULONG StringSecurityDescriptorLen OPTIONAL
    )
{

    DWORD Err = ERROR_SUCCESS;

    //
    // A little parameter checking...
    //
    if ( SecurityDescriptor == NULL || StringSecurityDescriptor == NULL ||
         SecurityInformation == 0 ) {

        Err =  ERROR_INVALID_PARAMETER;

    } else {

        switch ( RequestedStringSDRevision ) {
        case SDDL_REVISION_1:

            Err = LocalConvertSDToStringSD_Rev1( RootDomainSid,  // root domain sid
                                                 SecurityDescriptor,
                                                 SecurityInformation,
                                                 StringSecurityDescriptor,
                                                 StringSecurityDescriptorLen );
            break;

        default:
            Err = ERROR_UNKNOWN_REVISION;
            break;
        }

    }

    SetLastError( Err );

    return( Err == ERROR_SUCCESS);

}

BOOL
SddlpGetRootDomainSid(void)
{
    //
    // get root domain sid, save it in RootDomSidBuf (global)
    // this function is called within the critical section
    //
    // 1) ldap_open to the DC of interest.
    // 2) you do not need to ldap_connect - the following step works anonymously
    // 3) read the operational attribute rootDomainNamingContext and provide the
    //    operational control LDAP_SERVER_EXTENDED_DN_OID as defined in sdk\inc\ntldap.h.


    DWORD               Win32rc=NO_ERROR;
    BOOL                bRetValue=FALSE;

    HINSTANCE                   hLdapDll=NULL;
    PFN_LDAP_INIT               pfnLdapInit=NULL;
    PFN_LDAP_SET_OPTION         pfnLdapSetOption=NULL;
    PFN_LDAP_BIND               pfnLdapBind=NULL;
    PFN_LDAP_UNBIND             pfnLdapUnbind=NULL;
    PFN_LDAP_SEARCH             pfnLdapSearch=NULL;
    PFN_LDAP_FIRST_ENTRY        pfnLdapFirstEntry=NULL;
    PFN_LDAP_GET_VALUE          pfnLdapGetValue=NULL;
    PFN_LDAP_MSGFREE            pfnLdapMsgFree=NULL;
    PFN_LDAP_VALUE_FREE         pfnLdapValueFree=NULL;
    PFN_LDAP_MAP_ERROR          pfnLdapMapError=NULL;

    PLDAP                       phLdap=NULL;

    LDAPControlA    serverControls = { LDAP_SERVER_EXTENDED_DN_OID,
                                       { 0, (PCHAR) NULL },
                                       TRUE
                                     };
    LPSTR           Attribs[] = { LDAP_OPATT_ROOT_DOMAIN_NAMING_CONTEXT, NULL };

    PLDAPControlA   rServerControls[] = { &serverControls, NULL };
    PLDAPMessage    pMessage = NULL;
    LDAPMessage     *pEntry = NULL;
    PCHAR           *ppszValues=NULL;

    LPSTR           pSidStart, pSidEnd, pParse;
    BYTE            *pDest;
    BYTE            OneByte;

    hLdapDll = LoadLibraryA("wldap32.dll");

    if ( hLdapDll) {
        pfnLdapInit = (PFN_LDAP_INIT)GetProcAddress(hLdapDll,
                                                    "ldap_initA");
        pfnLdapSetOption = (PFN_LDAP_SET_OPTION)GetProcAddress(hLdapDll,
                                                    "ldap_set_option");
        pfnLdapBind = (PFN_LDAP_BIND)GetProcAddress(hLdapDll,
                                                    "ldap_bind_sA");
        pfnLdapUnbind = (PFN_LDAP_UNBIND)GetProcAddress(hLdapDll,
                                                      "ldap_unbind");
        pfnLdapSearch = (PFN_LDAP_SEARCH)GetProcAddress(hLdapDll,
                                                    "ldap_search_ext_sA");
        pfnLdapFirstEntry = (PFN_LDAP_FIRST_ENTRY)GetProcAddress(hLdapDll,
                                                      "ldap_first_entry");
        pfnLdapGetValue = (PFN_LDAP_GET_VALUE)GetProcAddress(hLdapDll,
                                                    "ldap_get_valuesA");
        pfnLdapMsgFree = (PFN_LDAP_MSGFREE)GetProcAddress(hLdapDll,
                                                      "ldap_msgfree");
        pfnLdapValueFree = (PFN_LDAP_VALUE_FREE)GetProcAddress(hLdapDll,
                                                    "ldap_value_freeA");
        pfnLdapMapError = (PFN_LDAP_MAP_ERROR)GetProcAddress(hLdapDll,
                                                      "LdapMapErrorToWin32");
    }

    if ( pfnLdapInit == NULL ||
         pfnLdapSetOption == NULL ||
         pfnLdapBind == NULL ||
         pfnLdapUnbind == NULL ||
         pfnLdapSearch == NULL ||
         pfnLdapFirstEntry == NULL ||
         pfnLdapGetValue == NULL ||
         pfnLdapMsgFree == NULL ||
         pfnLdapValueFree == NULL ||
         pfnLdapMapError == NULL ) {

        Win32rc = ERROR_PROC_NOT_FOUND;

    } else {

        //
        // bind to ldap
        //
        
        phLdap = (*pfnLdapInit)(NULL, LDAP_PORT);

        if ( phLdap == NULL ) {
            Win32rc = ERROR_DS_UNAVAILABLE;
        }
        else
        {
            //
            // Turn on the encryption option
            //
            
            LONG LdapOption = PtrToLong( LDAP_OPT_ON );
            ULONG uLdapStatus = (*pfnLdapSetOption)( phLdap, LDAP_OPT_ENCRYPT, &LdapOption );
            Win32rc = (*pfnLdapMapError)( uLdapStatus );

            //
            // If everything goes on fine, then we can finally bind
            //
            
            if (NO_ERROR == Win32rc)
            {
                uLdapStatus = (*pfnLdapBind)(phLdap, NULL, NULL, LDAP_AUTH_NEGOTIATE);
                Win32rc = (*pfnLdapMapError)( uLdapStatus );
            }
        }
    }

    if ( NO_ERROR == Win32rc ) {
        //
        // now get the ldap handle,
        //

        Win32rc = (*pfnLdapSearch)(
                        phLdap,
                        "",
                        LDAP_SCOPE_BASE,
                        "(objectClass=*)",
                        Attribs,
                        0,
                        (PLDAPControlA *)&rServerControls,
                        NULL,
                        NULL,
                        10000,
                        &pMessage);

        if( Win32rc == NO_ERROR && pMessage ) {

            Win32rc = ERROR_SUCCESS;

            pEntry = (*pfnLdapFirstEntry)(phLdap, pMessage);

            if(pEntry == NULL) {

                Win32rc = (*pfnLdapMapError)( phLdap->ld_errno );

            } else {
                //
                // Now, we'll have to get the values
                //
                ppszValues = (*pfnLdapGetValue)(phLdap,
                                              pEntry,
                                              Attribs[0]);

                if( ppszValues == NULL) {

                    Win32rc = (*pfnLdapMapError)( phLdap->ld_errno );

                } else if ( ppszValues[0] && ppszValues[0][0] != '\0' ) {

                    //
                    // ppszValues[0] is the value to parse.
                    // The data will be returned as something like:

                    // <GUID=278676f8d753d211a61ad7e2dfa25f11>;<SID=010400000000000515000000828ba6289b0bc11e67c2ef7f>;DC=colinbrdom1,DC=nttest,DC=microsoft,DC=com

                    // Parse through this to find the <SID=xxxxxx> part.  Note that it may be missing, but the GUID= and trailer should not be.
                    // The xxxxx represents the hex nibbles of the SID.  Translate to the binary form and case to a SID.


                    pSidStart = strstr(ppszValues[0], "<SID=");

                    if ( pSidStart ) {
                        //
                        // find the end of this SID
                        //
                        pSidEnd = strchr(pSidStart, '>');

                        if ( pSidEnd ) {

                            EnterCriticalSection(&SddlSidLookupCritical);

                            pParse = pSidStart + 5;
                            pDest = (BYTE *)RootDomSidBuf;

                            while ( pParse < pSidEnd-1 ) {

                                if ( *pParse >= '0' && *pParse <= '9' ) {
                                    OneByte = (BYTE) ((*pParse - '0') * 16);
                                } else {
                                    OneByte = (BYTE) ( (tolower(*pParse) - 'a' + 10) * 16 );
                                }

                                if ( *(pParse+1) >= '0' && *(pParse+1) <= '9' ) {
                                    OneByte += (BYTE) ( *(pParse+1) - '0' ) ;
                                } else {
                                    OneByte += (BYTE) ( tolower(*(pParse+1)) - 'a' + 10 ) ;
                                }

                                *pDest = OneByte;
                                pDest++;
                                pParse += 2;
                            }

                            RootDomInited = TRUE;

                            LeaveCriticalSection(&SddlSidLookupCritical);

                            bRetValue = TRUE;

                        } else {
                            Win32rc = ERROR_OBJECT_NOT_FOUND;
                        }
                    } else {
                        Win32rc = ERROR_OBJECT_NOT_FOUND;
                    }

                    (*pfnLdapValueFree)(ppszValues);

                } else {
                    Win32rc = ERROR_OBJECT_NOT_FOUND;
                }
            }

            (*pfnLdapMsgFree)(pMessage);
        }

    }

    //
    // even though it's not binded, use unbind to close
    //
    if ( phLdap != NULL && pfnLdapUnbind )
        (*pfnLdapUnbind)(phLdap);

    if ( hLdapDll ) {
        FreeLibrary(hLdapDll);
    }

    SetLastError(Win32rc);

    return bRetValue;
}

BOOL
APIENTRY
ConvertStringSDToSDDomainA(
    IN  PSID DomainSid,
    IN  PSID RootDomainSid OPTIONAL,
    IN  LPCSTR StringSecurityDescriptor,
    IN  DWORD StringSDRevision,
    OUT PSECURITY_DESCRIPTOR  *SecurityDescriptor,
    OUT PULONG  SecurityDescriptorSize OPTIONAL
    )
/*
Routine Description:

    This API is exported from advapi32.dll.
    This is the ANSI version of ConvertStringSDToSDDomainW and it calls the latter API.
    See description for ConvertStringSDToSDDomainW.

*/
{
    UNICODE_STRING Unicode;
    ANSI_STRING AnsiString;
    NTSTATUS Status;
    BOOL Result;

    if ( NULL == StringSecurityDescriptor ||
         NULL == SecurityDescriptor ||
         NULL == DomainSid ||
         !RtlValidSid(DomainSid) || 
         (RootDomainSid && !RtlValidSid(RootDomainSid)) ) {

        SetLastError(ERROR_INVALID_PARAMETER);
        return(FALSE);
    }

    RtlInitAnsiString( &AnsiString, StringSecurityDescriptor );

    Status = SddlpAnsiStringToUnicodeString(&Unicode,                                                                                                        
                                            &AnsiString);

    if ( !NT_SUCCESS( Status ) ) {

        BaseSetLastNTError( Status );

        return FALSE;

    }

    Result = ConvertStringSDToSDDomainW( DomainSid,
                                         RootDomainSid,                                           
                                         ( LPCWSTR )Unicode.Buffer,                                           
                                         StringSDRevision,                                           
                                         SecurityDescriptor,                                           
                                         SecurityDescriptorSize);

    LocalFree( Unicode.Buffer );

    if ( Result ) {
        SetLastError(ERROR_SUCCESS);
    }

    return( Result );

}

BOOL
APIENTRY
ConvertStringSDToSDDomainW(
    IN  PSID DomainSid,
    IN  PSID RootDomainSid OPTIONAL,
    IN  LPCWSTR StringSecurityDescriptor,
    IN  DWORD StringSDRevision,
    OUT PSECURITY_DESCRIPTOR  *SecurityDescriptor,
    OUT PULONG  SecurityDescriptorSize OPTIONAL
    )
/*
Routine Description:

    This API is exported from advapi32.dll. It is similar to ConvertSDToStringSDRootDomainW
    except that it takes in a required DomainSid parameter. Domain relative trustees will be
    resolved w.r.t. DomainSid.


Arguments:

    IN      PSID DomainSid                            - pointer to the domain sid w.r.t. which
                                                        ST_DOMAIN_RELATIVE type trustees are resolved against
    IN      PSID RootDomainSid OPTIONAL               - pointer to root domain sid w.r.t. which  
                                                        ST_ROOT_DOMAIN_RELATIVE type trustees are resolved against
                                                        if this is NULL, the local m/c's root domain is used
    IN      LPCWSTR StringSecurityDescriptor          - the input SDDL string
    IN      DWORD StringSDRevision                    - SDDL revision, only SDDL_REVISION_1 is supported
    OUT     PSECURITY_DESCRIPTOR  *SecurityDescriptor - pointer to the constructed security descriptor
    OUT     PULONG  SecurityDescriptorSize OPTIONAL   - size of the constructed security descriptor


Return Value:

    TRUE if succeeded else FALSE. Caller can use GetLastError() to retrieve the error code.
*/
{

    DWORD Err = ERROR_SUCCESS;

    //
    // Little elementary parameter checking...
    //
    if ( StringSecurityDescriptor == NULL ||
         SecurityDescriptor == NULL ||
         DomainSid == NULL ||
         !RtlValidSid(DomainSid) ||
        (RootDomainSid && !RtlValidSid(RootDomainSid)) ) {

        Err = ERROR_INVALID_PARAMETER;

    } else {

        switch ( StringSDRevision ) {
        case SDDL_REVISION_1:

            Err = LocalConvertStringSDToSD_Rev1( RootDomainSid, // no root domain sid maybe provided for this API
                                                 DomainSid, // domain sid
                                                 FALSE,     // domain sid is required
                                                 StringSecurityDescriptor,
                                                 SecurityDescriptor,
                                                 SecurityDescriptorSize);
            break;

        default:

            Err = ERROR_UNKNOWN_REVISION;
            break;
        }

    }

    SetLastError( Err );

    return( Err == ERROR_SUCCESS );
}


NTSTATUS
SddlpAnsiStringToUnicodeString(
    OUT PUNICODE_STRING DestinationString,
    IN PANSI_STRING SourceString
    )

/*++

Routine Description:

    See RtlAnsiStringToUnicodeString - only difference is that Unicode Length
    is immaterial here. When using this API, never depend on a well formed 
    UNICODE_STRING - only rely on the Buffer field.
    
    This functions converts the specified ansi source string into a
    Unicode string. The translation is done with respect to the
    current system locale information.

Arguments:

    DestinationString - Returns a unicode string that is equivalent to
        the ansi source string. Should be freed outside using LocalFree()

    SourceString - Supplies the ansi source string that is to be
        converted to unicode.

Return Value:

    SUCCESS - The conversion was successful

    !SUCCESS - The operation failed.  No storage was allocated and no
        conversion was done.  None.

--*/

{
    ULONG UnicodeLength;
    ULONG Index;
    NTSTATUS st;

    UnicodeLength = RtlAnsiStringToUnicodeSize(SourceString);

    DestinationString->Buffer = (PWSTR) LocalAlloc(LMEM_ZEROINIT, UnicodeLength);
        
    if ( !DestinationString->Buffer ) {
        return STATUS_NO_MEMORY;
    }

    st = RtlMultiByteToUnicodeN(
             DestinationString->Buffer,
             UnicodeLength - sizeof(UNICODE_NULL),
             &Index,
             SourceString->Buffer,
             SourceString->Length
             );

    if (!NT_SUCCESS(st)) {
            
        LocalFree(DestinationString->Buffer);

        DestinationString->Buffer = NULL;
        
        return st;
    }

    DestinationString->Buffer[Index / sizeof(WCHAR)] = UNICODE_NULL;

    return STATUS_SUCCESS;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\ddk\legacy_files\drivinit.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992-1999.
//
//  File:       drivinit.h
//
//----------------------------------------------------------------------------

// All items moved to wingdi.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\ddk\makefile.inc ===
DDK_TOOL_PATH=\sdktools\ddk\generate
PROJECT_ROOT=$(BASEDIR)
ddk:
!IFNDEF PASS0ONLY
ddk:
#
# Process only on the second pass
#
# NOTE: DDKBUILD.CMD will exit w/o building a DDK on AXP64 and Alpha.
#        This is by design.
	call $(RAZZLETOOLPATH)\copyddkfiles.cmd  ddk_public.ini  ddk $(PROJECT_ROOT)
	call $(RAZZLETOOLPATH)\copyddkfiles.cmd  hal_public.ini  hal $(PROJECT_ROOT)
	call $(RAZZLETOOLPATH)\copyddkfiles.cmd  ifs_public.ini  ifs $(PROJECT_ROOT)
	call $(RAZZLETOOLPATH)\copyddkfiles.cmd  processor_public.ini  processor $(PROJECT_ROOT)

!ENDIF
#
# Remove generated files
#
clean:
	@if EXIST .\obj          rd  /s/q .\obj
	@if EXIST .\objchk       rd  /s/q .\objchk
	@if EXIST .\objfre       rd  /s/q .\objfre
	@if EXIST .\build.log    del /f/q .\build.log
	@if EXIST .\build.wrn    del /f/q .\build.wrn
	@if EXIST .\build.err    del /f/q .\build.err
	@if EXIST .\buildfre.log del /f/q .\buildfre.log
	@if EXIST .\buildfre.wrn del /f/q .\buildfre.wrn
	@if EXIST .\buildfre.err del /f/q .\buildfre.err
	@if EXIST .\buildchk.log del /f/q .\buildchk.log
	@if EXIST .\buildchk.wrn del /f/q .\buildchk.wrn
	@if EXIST .\buildchk.err del /f/q .\buildchk.err
	@echo Clean
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\dload\advapi.c ===
//
// Copyright (c) Microsoft Corporation
//
#include "pch.h"
#include "dloadexcept.h"
#pragma hdrstop

#include "winreg.h"
#include "ntelfapi.h"
#include <wincrypt.h>
#include <winsafer.h>
#include <Aclapi.h>

/*
Elf == Event Log
a notable difference between Elf and the Win32 API is Elf accepts non nul terminated UNICODE_STRINGs.
*/

static
NTSTATUS
NTAPI
ElfReportEventW(
    IN     HANDLE      LogHandle,
    IN     USHORT      EventType,
    IN     USHORT      EventCategory   OPTIONAL,
    IN     ULONG       EventID,
    IN     PSID        UserSid         OPTIONAL,
    IN     USHORT      NumStrings,
    IN     ULONG       DataSize,
    IN     PUNICODE_STRING* Strings    OPTIONAL,
    IN     PVOID       Data            OPTIONAL,
    IN     USHORT      Flags,
    IN OUT PULONG      RecordNumber    OPTIONAL,
    IN OUT PULONG      TimeWritten     OPTIONAL
    )
{
    if (ARGUMENT_PRESENT(RecordNumber))
    {
        *RecordNumber = 0;
    }
    if (ARGUMENT_PRESENT(TimeWritten))
    {
        *TimeWritten = 0;
    }
    return DelayLoad_GetNtStatus();
}

static
NTSTATUS
NTAPI
ElfRegisterEventSourceW(
    IN  PUNICODE_STRING UNCServerName,
    IN  PUNICODE_STRING SourceName,
    OUT PHANDLE         LogHandle
    )
{
    if (ARGUMENT_PRESENT(LogHandle))
    {
        *LogHandle = NULL;
    }
    return DelayLoad_GetNtStatus();
}

static
NTSTATUS
NTAPI
ElfDeregisterEventSource(
    IN  HANDLE LogHandle
    )
{
    return DelayLoad_GetNtStatus();
}

static
LONG
APIENTRY
RegCreateKeyW (
    IN HKEY hKey,
    IN LPCWSTR lpSubKey,
    OUT PHKEY phkResult
    )
{
    return DelayLoad_GetWin32Error();
}

static
LONG
APIENTRY
RegCreateKeyExW(
    IN HKEY hKey,
    IN PCWSTR lpSubKey,
    IN DWORD Reserved,
    IN PWSTR lpClass,
    IN DWORD dwOptions,
    IN REGSAM samDesired,
    IN PSECURITY_ATTRIBUTES lpSecurityAttributes,
    OUT PHKEY phkResult,
    OUT LPDWORD lpdwDisposition
    )
{
    if (ARGUMENT_PRESENT(phkResult))
    {
        *phkResult = INVALID_HANDLE_VALUE;
    }
    if (ARGUMENT_PRESENT(lpdwDisposition))
    {
        *lpdwDisposition = 0;
    }
    return DelayLoad_GetWin32Error();
}

static
LONG
APIENTRY
RegOpenKeyExA (
    IN HKEY hKey,
    IN LPCSTR lpSubKey,
    IN DWORD ulOptions,
    IN REGSAM samDesired,
    OUT PHKEY phkResult
    )
{
    return DelayLoad_GetWin32Error();
}

static
LONG
APIENTRY
RegOpenKeyExW(
    IN HKEY hKey,
    IN PCWSTR lpSubKey,
    IN DWORD ulOptions,
    IN REGSAM samDesired,
    OUT PHKEY phkResult
    )
{
    if (ARGUMENT_PRESENT(phkResult))
    {
        *phkResult = INVALID_HANDLE_VALUE;
    }
    return DelayLoad_GetWin32Error();
}

static
LONG
APIENTRY
RegSetValueExA (
    IN HKEY hKey,
    IN LPCSTR lpValueName,
    IN DWORD Reserved,
    IN DWORD dwType,
    IN CONST BYTE* lpData,
    IN DWORD cbData
    )
{
    return DelayLoad_GetWin32Error();
}

static
LONG
APIENTRY
RegSetValueExW (
    IN HKEY hKey,
    IN LPCWSTR lpValueName,
    IN DWORD Reserved,
    IN DWORD dwType,
    IN CONST BYTE* lpData,
    IN DWORD cbData
    )
{
    return DelayLoad_GetWin32Error();
}

static
LONG
APIENTRY
RegQueryValueExA (
    IN HKEY hKey,
    IN LPCSTR lpValueName,
    IN LPDWORD lpReserved,
    OUT LPDWORD lpType,
    IN OUT LPBYTE lpData,
    IN OUT LPDWORD lpcbData
    )
{
    return DelayLoad_GetWin32Error();
}

static
LONG
APIENTRY
RegQueryValueExW(
    IN HKEY hKey,
    IN PCWSTR lpValueName,
    IN LPDWORD lpReserved,
    OUT LPDWORD lpType,
    IN OUT LPBYTE lpData,
    IN OUT LPDWORD lpcbData
    )
{
    if (ARGUMENT_PRESENT(lpType))
    {
        *lpType = 0;
    }
    if (ARGUMENT_PRESENT(lpcbData))
    {
        *lpcbData = 0;
    }
    return DelayLoad_GetWin32Error();
}

static
BOOL
WINAPI
GetUserNameW (
    OUT LPWSTR lpBuffer,
    IN OUT LPDWORD nSize
    )
{
    DelayLoad_SetLastNtStatusAndWin32Error();
    return FALSE;
}

static
LONG
APIENTRY
RegCloseKey(
    IN HKEY hKey
    )
{
    return DelayLoad_GetWin32Error();
}

static
LONG
APIENTRY
RegDeleteKeyW(
    IN HKEY hKey,
    IN PCWSTR lpSubKey
    )
{
    return DelayLoad_GetWin32Error();
}

static
BOOL
WINAPI
QueryServiceStatus(
    SC_HANDLE           hService,
    LPSERVICE_STATUS    lpServiceStatus
    )
{
    DelayLoad_SetLastNtStatusAndWin32Error();
    return FALSE;
}

static
LONG
APIENTRY
RegSaveKeyA(
    IN HKEY hKey,
    IN PCSTR lpFile,
    IN LPSECURITY_ATTRIBUTES lpSecurity
    )
{
    return DelayLoad_GetWin32Error();
}

static
LONG
APIENTRY
RegSaveKeyExW(
    IN HKEY hKey,
    IN PCWSTR lpFile,
    IN LPSECURITY_ATTRIBUTES lpSecurity,
    DWORD Flags
    )
{
    return DelayLoad_GetWin32Error();
}

static
LONG
APIENTRY
RegSaveKeyW(
    IN HKEY hKey,
    IN PCWSTR lpFile,
    IN LPSECURITY_ATTRIBUTES lpSecurity
    )
{
    return DelayLoad_GetWin32Error();
}

static
LONG
APIENTRY
RegDeleteValueW(
    IN HKEY hKey,
    IN PCWSTR lpValueName
    )
{
    return DelayLoad_GetWin32Error();
}

static
LONG
APIENTRY
RegNotifyChangeKeyValue(
    IN HKEY hKey,
    IN BOOL bWatchSubtree,
    IN DWORD dwNotifyFilter,
    IN HANDLE hEvent,
    IN BOOL fAsynchronus
    )
{
    return DelayLoad_GetWin32Error();
}

static
LONG
APIENTRY
RegOpenKeyA (
    IN HKEY hKey,
    IN LPCSTR lpSubKey,
    OUT PHKEY phkResult
    )
{
    return DelayLoad_GetWin32Error();
}

static
LONG
APIENTRY
RegOpenKeyW (
    IN HKEY hKey,
    IN LPCWSTR lpSubKey,
    OUT PHKEY phkResult
    )
{
    return DelayLoad_GetWin32Error();
}

static
LONG
APIENTRY
RegEnumKeyExW(
    IN HKEY hKey,
    IN DWORD dwIndex,
    OUT LPWSTR lpName,
    IN OUT LPDWORD lpcbName,
    IN LPDWORD lpReserved,
    IN OUT LPWSTR lpClass,
    IN OUT LPDWORD lpcbClass,
    OUT PFILETIME lpftLastWriteTime
    )
{
    if (ARGUMENT_PRESENT(lpcbName))
    {
        *lpcbName = 0;
    }
    return DelayLoad_GetWin32Error();
}

static
WINADVAPI
LONG
APIENTRY
RegQueryInfoKeyW(
    IN HKEY hKey,
    OUT LPWSTR lpClass,
    IN OUT LPDWORD lpcbClass,
    IN LPDWORD lpReserved,
    OUT LPDWORD lpcSubKeys,
    OUT LPDWORD lpcbMaxSubKeyLen,
    OUT LPDWORD lpcbMaxClassLen,
    OUT LPDWORD lpcValues,
    OUT LPDWORD lpcbMaxValueNameLen,
    OUT LPDWORD lpcbMaxValueLen,
    OUT LPDWORD lpcbSecurityDescriptor,
    OUT PFILETIME lpftLastWriteTime
    )
{
    return DelayLoad_GetWin32Error();
}

static
LONG
APIENTRY
RegRestoreKeyW(
    HKEY hkey,
    LPCWSTR lpFile,
    DWORD dwFlags
    )
{
    return DelayLoad_GetWin32Error();
}

static
WINADVAPI
BOOL
WINAPI
DeregisterEventSource(
    IN OUT HANDLE hEventLog
    )
{
    DelayLoad_SetLastNtStatusAndWin32Error();
    return FALSE;
}

static
WINADVAPI
HANDLE
WINAPI
RegisterEventSourceW(
    IN LPCWSTR lpUNCServerName,
    IN LPCWSTR lpSourceName
    )
{
    DelayLoad_SetLastNtStatusAndWin32Error();
    return NULL;
}

static
WINADVAPI
BOOL
WINAPI
ReportEventW(
    IN HANDLE     hEventLog,
    IN WORD       wType,
    IN WORD       wCategory,
    IN DWORD      dwEventID,
    IN PSID       lpUserSid,
    IN WORD       wNumStrings,
    IN DWORD      dwDataSize,
    IN LPCWSTR   *lpStrings,
    IN LPVOID     lpRawData
    )
{
    DelayLoad_SetLastNtStatusAndWin32Error();
    return FALSE;
}

static
BOOL
WINAPI
AdjustTokenPrivileges(
    IN HANDLE TokenHandle,
    IN BOOL DisableAllPrivileges,
    IN PTOKEN_PRIVILEGES NewState,
    IN DWORD BufferLength,
    OUT PTOKEN_PRIVILEGES PreviousState,
    OUT PDWORD ReturnLength
    )
{
    DelayLoad_SetLastNtStatusAndWin32Error();
    return FALSE;
}

static
BOOL
WINAPI
LookupAccountSidW(
    IN		LPCWSTR lpSystemName,
	IN		PSID lpSid,
	OUT		LPWSTR lpName,
	IN OUT	LPDWORD cbName,
	OUT		LPWSTR lpReferencedDomainName,
	IN OUT	LPDWORD cbReferencedDomainName,
	OUT		PSID_NAME_USE peUse
    )
{
	if (ARGUMENT_PRESENT(lpName))
    {
        *lpName = 0;
    }
	if (ARGUMENT_PRESENT(lpReferencedDomainName))
    {
        *lpReferencedDomainName = 0;
    }
    SetLastError(ERROR_PROC_NOT_FOUND);
    return FALSE;
}

static
BOOL
WINAPI
LookupPrivilegeValueA(
    IN LPCSTR lpSystemName,
    IN LPCSTR lpName,
    OUT PLUID   lpLuid
    )
{
    DelayLoad_SetLastNtStatusAndWin32Error();
    return FALSE;
}

static
BOOL
WINAPI
LookupPrivilegeValueW(
    IN LPCWSTR lpSystemName,
    IN LPCWSTR lpName,
    OUT PLUID   lpLuid
    )
{
    DelayLoad_SetLastNtStatusAndWin32Error();
    return FALSE;
}

static
PVOID
WINAPI
FreeSid(
    IN PSID pSid
    )
{
    DelayLoad_SetLastNtStatusAndWin32Error();
    return NULL;
}

static
DWORD
WINAPI
GetLengthSid (
    PSID pSid
    )
{
    DelayLoad_SetLastNtStatusAndWin32Error();
    return 0;
}

static
BOOL
WINAPI
IsValidSid (
    PSID pSid
    )
{
    DelayLoad_SetLastNtStatusAndWin32Error();
    return FALSE;
}

static
BOOL
APIENTRY
CheckTokenMembership(
    IN HANDLE TokenHandle OPTIONAL,
    IN PSID SidToCheck,
    OUT PBOOL IsMember
    )
{
    DelayLoad_SetLastNtStatusAndWin32Error();
    return FALSE;
}

static
BOOL
WINAPI
AllocateAndInitializeSid (
    IN PSID_IDENTIFIER_AUTHORITY pIdentifierAuthority,
    IN BYTE nSubAuthorityCount,
    IN DWORD nSubAuthority0,
    IN DWORD nSubAuthority1,
    IN DWORD nSubAuthority2,
    IN DWORD nSubAuthority3,
    IN DWORD nSubAuthority4,
    IN DWORD nSubAuthority5,
    IN DWORD nSubAuthority6,
    IN DWORD nSubAuthority7,
    OUT PSID *pSid
    )
{
    DelayLoad_SetLastNtStatusAndWin32Error();
    return FALSE;
}

static
WINADVAPI
BOOL
WINAPI
OpenProcessToken(
    IN HANDLE ProcessHandle,
    IN DWORD DesiredAccess,
    OUT PHANDLE TokenHandle
    )
{
    DelayLoad_SetLastNtStatusAndWin32Error();
    return FALSE;
}

static
WINADVAPI
BOOL
WINAPI
OpenThreadToken(
    IN HANDLE ThreadHandle,
    IN DWORD DesiredAccess,
    IN BOOL OpenAsSelf,
    OUT PHANDLE TokenHandle
    )
{
    DelayLoad_SetLastNtStatusAndWin32Error();
    return FALSE;
}

static
WINADVAPI
BOOL
WINAPI
GetTokenInformation(
    IN HANDLE TokenHandle,
    IN TOKEN_INFORMATION_CLASS TokenInformationClass,
    OUT LPVOID TokenInformation,
    IN DWORD TokenInformationLength,
    OUT PDWORD ReturnLength
    )
{
    DelayLoad_SetLastNtStatusAndWin32Error();
    return FALSE;
}

static
LONG
APIENTRY
RegEnumKeyW (
    IN HKEY hKey,
    IN DWORD dwIndex,
    OUT LPWSTR lpName,
    IN DWORD cbName
    )
{
    return DelayLoad_GetWin32Error();
}

static
WINADVAPI
LONG
APIENTRY
RegEnumValueW (
    IN HKEY hKey,
    IN DWORD dwIndex,
    OUT LPWSTR lpValueName,
    IN OUT LPDWORD lpcbValueName,
    IN LPDWORD lpReserved,
    OUT LPDWORD lpType,
    OUT LPBYTE lpData,
    IN OUT LPDWORD lpcbData
    )
{
    return DelayLoad_GetWin32Error();
}

static
WINADVAPI
BOOL
WINAPI
CryptHashData(
    HCRYPTHASH hHash,
    CONST BYTE *pbData,
    DWORD dwDataLen,
    DWORD dwFlags
    )
{
    DelayLoad_SetLastNtStatusAndWin32Error();
    return FALSE;
}

static
WINADVAPI
BOOL
WINAPI
CryptReleaseContext(
    HCRYPTPROV hProv,
    DWORD dwFlags
    )
{
    DelayLoad_SetLastNtStatusAndWin32Error();
    return FALSE;
}

static
WINADVAPI
BOOL
WINAPI
CryptAcquireContextW(
    HCRYPTPROV *phProv,
    LPCWSTR szContainer,
    LPCWSTR szProvider,
    DWORD dwProvType,
    DWORD dwFlags
    )
{
    DelayLoad_SetLastNtStatusAndWin32Error();
    return FALSE;
}

static
WINADVAPI
BOOL
WINAPI
CryptDestroyHash(
    HCRYPTHASH hHash
    )
{
    DelayLoad_SetLastNtStatusAndWin32Error();
    return FALSE;
}

static
WINADVAPI
BOOL
WINAPI
CryptDestroyKey(
    HCRYPTKEY hKey
    )
{
    DelayLoad_SetLastNtStatusAndWin32Error();
    return FALSE;
}

static
WINADVAPI
BOOL
WINAPI
CryptExportKey(
    HCRYPTKEY hKey,
    HCRYPTKEY hExpKey,
    DWORD dwBlobType,
    DWORD dwFlags,
    BYTE *pbData,
    DWORD *pdwDataLen
    )
{
    DelayLoad_SetLastNtStatusAndWin32Error();
    return FALSE;
}
    

static
WINADVAPI
BOOL
WINAPI
CryptGetHashParam(
    HCRYPTHASH hHash,
    DWORD dwParam,
    BYTE *pbData,
    DWORD *pdwDataLen,
    DWORD dwFlags
    )
{
    if (ARGUMENT_PRESENT(pdwDataLen))
    {
        *pdwDataLen = 0;
    }
    DelayLoad_SetLastNtStatusAndWin32Error();
    return FALSE;
}

static
WINADVAPI
BOOL
WINAPI
CryptCreateHash(
    HCRYPTPROV hProv,
    ALG_ID Algid,
    HCRYPTKEY hKey,
    DWORD dwFlags,
    HCRYPTHASH *phHash
    )
{
    DelayLoad_SetLastNtStatusAndWin32Error();
    return FALSE;
}



static
WINADVAPI
BOOL WINAPI
SaferGetPolicyInformation (
        IN DWORD                            dwScopeId,
        IN SAFER_POLICY_INFO_CLASS          CodeAuthzPolicyInfoClass,
        IN DWORD                            InfoBufferSize,
        IN OUT PVOID                        InfoBuffer,
        IN OUT PDWORD                       InfoBufferRetSize,
        IN LPVOID                           lpReserved
        )
{
    DelayLoad_SetLastNtStatusAndWin32Error();
    return FALSE;
}


static
WINADVAPI
BOOL WINAPI
SaferSetPolicyInformation (
        IN DWORD                            dwScopeId,
        IN SAFER_POLICY_INFO_CLASS          CodeAuthzPolicyInfoClass,
        IN DWORD                            InfoBufferSize,
        IN PVOID                            InfoBuffer,
        IN LPVOID                           lpReserved
        )
{
    DelayLoad_SetLastNtStatusAndWin32Error();
    return FALSE;
}


static
WINADVAPI
BOOL WINAPI
SaferCreateLevel(
        IN DWORD            dwScopeId,
        IN DWORD            dwLevelId,
        IN DWORD            OpenFlags,
        OUT SAFER_LEVEL_HANDLE    *pLevelHandle,
        IN LPVOID           lpReserved)
{
    DelayLoad_SetLastNtStatusAndWin32Error();
    return FALSE;
}


static
WINADVAPI
BOOL WINAPI
SaferCloseLevel(
        IN SAFER_LEVEL_HANDLE      hLevelHandle)
{
    DelayLoad_SetLastNtStatusAndWin32Error();
    return FALSE;
}


static
WINADVAPI
BOOL WINAPI
SaferIdentifyLevel (
        IN DWORD                       dwNumProperties,
        IN PSAFER_CODE_PROPERTIES      pCodeProperties,
        OUT SAFER_LEVEL_HANDLE        *pLevelHandle,
        IN LPVOID                      lpReserved
        )
{
    DelayLoad_SetLastNtStatusAndWin32Error();
    return FALSE;
}


static
WINADVAPI
BOOL WINAPI
SaferComputeTokenFromLevel (
        IN SAFER_LEVEL_HANDLE      LevelHandle,
        IN HANDLE                  InAccessToken         OPTIONAL,
        OUT PHANDLE                OutAccessToken,
        IN DWORD                   dwFlags,
        IN LPVOID                  lpReserved
        )
{
    DelayLoad_SetLastNtStatusAndWin32Error();
    return FALSE;
}

static
WINADVAPI
BOOL WINAPI
SaferGetLevelInformation (
        IN SAFER_LEVEL_HANDLE              LevelHandle,
        IN SAFER_OBJECT_INFO_CLASS         dwInfoType,
        OUT LPVOID                         lpQueryBuffer   OPTIONAL,
        IN DWORD                           dwInBufferSize,
        OUT LPDWORD                        lpdwOutBufferSize
        )
{
    DelayLoad_SetLastNtStatusAndWin32Error();
    return FALSE;
}


static
WINADVAPI
BOOL WINAPI
SaferSetLevelInformation (
    IN SAFER_LEVEL_HANDLE          LevelHandle,
    IN SAFER_OBJECT_INFO_CLASS     dwInfoType,
    IN LPVOID                      pQueryBuffer,
    IN DWORD                       dwInBufferSize
    )
{
    DelayLoad_SetLastNtStatusAndWin32Error();
    return FALSE;
}

static
WINADVAPI
BOOL WINAPI
SetSecurityDescriptorDacl (
    IN OUT PSECURITY_DESCRIPTOR pSecurityDescriptor,
    IN BOOL bDaclPresent,
    IN PACL pDacl,
    IN BOOL bDaclDefaulted
    )
{
    DelayLoad_SetLastNtStatusAndWin32Error();
    return FALSE;
}

static
WINADVAPI
BOOL WINAPI
InitializeSecurityDescriptor (
    OUT PSECURITY_DESCRIPTOR pSecurityDescriptor,
    IN DWORD dwRevision
    )
{
    DelayLoad_SetLastNtStatusAndWin32Error();
    return FALSE;
}

static
WINADVAPI
DWORD WINAPI
SetEntriesInAclW(
    IN  ULONG               cCountOfExplicitEntries,
    IN  PEXPLICIT_ACCESS_W  pListOfExplicitEntries,
    IN  PACL                OldAcl,
    OUT PACL              * NewAcl
    )
{
    DelayLoad_SetLastNtStatusAndWin32Error();
    return ERROR_DELAY_LOAD_FAILED;
}


//
// !! WARNING !! The entries below must be in alphabetical order, and are CASE SENSITIVE (eg lower case comes last!)
//
DEFINE_PROCNAME_ENTRIES(advapi32)
{
    DLPENTRY(AdjustTokenPrivileges)
    DLPENTRY(AllocateAndInitializeSid)
    DLPENTRY(CheckTokenMembership)
    DLPENTRY(CryptAcquireContextW)
    DLPENTRY(CryptCreateHash)
    DLPENTRY(CryptDestroyHash)
    DLPENTRY(CryptDestroyKey)
    DLPENTRY(CryptExportKey)
    DLPENTRY(CryptGetHashParam)
    DLPENTRY(CryptHashData)
    DLPENTRY(CryptReleaseContext)
    DLPENTRY(DeregisterEventSource)
    DLPENTRY(ElfDeregisterEventSource)
    DLPENTRY(ElfRegisterEventSourceW)
    DLPENTRY(ElfReportEventW)
    DLPENTRY(FreeSid)
    DLPENTRY(GetLengthSid)
    DLPENTRY(GetTokenInformation)
    DLPENTRY(GetUserNameW)
    DLPENTRY(InitializeSecurityDescriptor)
    DLPENTRY(IsValidSid)
	DLPENTRY(LookupAccountSidW)
    DLPENTRY(LookupPrivilegeValueA)
    DLPENTRY(LookupPrivilegeValueW)
    DLPENTRY(OpenProcessToken)
    DLPENTRY(OpenThreadToken)
    DLPENTRY(QueryServiceStatus)
    DLPENTRY(RegCloseKey)
    DLPENTRY(RegCreateKeyExW)
    DLPENTRY(RegCreateKeyW)
    DLPENTRY(RegDeleteKeyW)
    DLPENTRY(RegDeleteValueW)
    DLPENTRY(RegEnumKeyExW)
    DLPENTRY(RegEnumKeyW)
    DLPENTRY(RegEnumValueW)
    DLPENTRY(RegNotifyChangeKeyValue)
    DLPENTRY(RegOpenKeyA)
    DLPENTRY(RegOpenKeyExA)
    DLPENTRY(RegOpenKeyExW)
    DLPENTRY(RegOpenKeyW)
    DLPENTRY(RegQueryInfoKeyW)
    DLPENTRY(RegQueryValueExA)
    DLPENTRY(RegQueryValueExW)
    DLPENTRY(RegRestoreKeyW)
    DLPENTRY(RegSaveKeyA)
    DLPENTRY(RegSaveKeyExW)
    DLPENTRY(RegSaveKeyW)
    DLPENTRY(RegSetValueExA)
    DLPENTRY(RegSetValueExW)
    DLPENTRY(RegisterEventSourceW)
    DLPENTRY(ReportEventW)
    DLPENTRY(SaferCloseLevel)
    DLPENTRY(SaferComputeTokenFromLevel)
    DLPENTRY(SaferCreateLevel)
    DLPENTRY(SaferGetLevelInformation)
    DLPENTRY(SaferGetPolicyInformation)
    DLPENTRY(SaferIdentifyLevel)
    DLPENTRY(SaferSetLevelInformation)
    DLPENTRY(SaferSetPolicyInformation)
    DLPENTRY(SetEntriesInAclW)
    DLPENTRY(SetSecurityDescriptorDacl)
};


DEFINE_PROCNAME_MAP(advapi32)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\dlcheck\dlcheck.c ===
/* dlcheck - verify that a DLL using delay-load calls APIs that have
 *           stubs in kernel32.dll (aka dload.lib)
 *
 * HISTORY:
 * 25-Nov-98    barrybo Wrote it.
 */

#include <stdio.h>
#include <stdlib.h>
#include <windows.h>
#include <imagehlp.h>
#include <delayimp.h>
#include <dloaddef.h>
#include <shlwapi.h>
#include <strsafe.h>

#define ARRAYSIZE(x)  (sizeof(x) / sizeof(x[0]))

// Function Forward Parameters...
void Usage( void );
int __cdecl main( int, char ** );

int DloadBreakOnFail = FALSE;
extern int DloadDbgPrint = FALSE;

// implemented in kernel32p.lib
FARPROC
WINAPI
DelayLoadFailureHook (
    LPCSTR pszDllName,
    LPCSTR pszProcName
    );


typedef FARPROC (WINAPI *PfnKernel32HookProc)(
    LPCSTR pszDllName,
    LPCSTR pszProcName
    );

PfnKernel32HookProc __pfnFailureProc = DelayLoadFailureHook;

const char rgstrUsage[] = {
    "Verify that delayloaded imports all have failure handlers in kernel32.\n"
    "usage: dlcheck [switches] image-name\n"
    "where: [-?] display this message\n"
    "       [-l] use the live version of kernel32.dll on the machine\n"
    "       [-s] use the static dload.lib linked into dlcheck\n"
    "       [-t] test the static dload.lib linked into dlcheck and exit\n"
    "       [-i <inifile>] use the information in inifile to check a binary\n"
    "       [-f] force check the binary (assumes -s)\n"
    "\n"
    };

HANDLE BaseDllHandle;
PLOADED_IMAGE g_pli;
PIMAGE_SECTION_HEADER g_DelaySection;

//
// Convert an absolute pointer that points into the image if the image
// was loaded as a DLL at its preferred base, into a pointer into the
// DLL as it was mapped by imagehlp.
//
void *
ConvertImagePointer(void * p)
{
    if (!p) {
        return NULL;
    } else {
        return (void *)((ULONG_PTR)(p) -
                  (ULONG_PTR)g_pli->FileHeader->OptionalHeader.ImageBase +
                  (ULONG_PTR)g_pli->MappedAddress -
                  (ULONG_PTR)g_DelaySection->VirtualAddress +
                  (ULONG_PTR)g_DelaySection->PointerToRawData);
    }
}

void *
RvaToPtr(DWORD_PTR rva)
{
    DWORD i;
    PIMAGE_SECTION_HEADER pSect;
    if (!rva)
        return NULL;

    for (i = 0; i < g_pli->NumberOfSections; i++) {
        pSect = g_pli->Sections+i;
        if (rva >= g_pli->Sections[i].VirtualAddress &&
            rva <= (g_pli->Sections[i].VirtualAddress + g_pli->Sections[i].Misc.VirtualSize))
        {
            return (PVOID)
                   (g_pli->MappedAddress +
                    g_pli->Sections[i].PointerToRawData +
                   (rva - g_pli->Sections[i].VirtualAddress));
        }
    }
    return NULL;
}

void Usage( void )
{
    puts(rgstrUsage);

    exit (1);
}

BOOLEAN ImageLinksToKernel32Handler( void )
{
    PIMAGE_IMPORT_DESCRIPTOR Imports;
    ULONG ImportSize;
    PULONG_PTR pIAT;
    PIMAGE_IMPORT_BY_NAME pImport;

    Imports = (PIMAGE_IMPORT_DESCRIPTOR)
                  ImageDirectoryEntryToData(g_pli->MappedAddress,
                                            FALSE,
                                            IMAGE_DIRECTORY_ENTRY_IMPORT,
                                            &ImportSize
                                            );
    if (!Imports) {
        // Image has delayload imports, but no true imports.
        return FALSE;
    }

    while (Imports->Name) {
        char *szName;

        szName = ImageRvaToVa(g_pli->FileHeader, (PVOID)g_pli->MappedAddress, Imports->Name, NULL);

        if (szName && _stricmp(szName, "KERNEL32.DLL") == 0) {
            pIAT = ImageRvaToVa(g_pli->FileHeader,
                                 (PVOID)g_pli->MappedAddress,
                                 Imports->OriginalFirstThunk,
                                 NULL);

            while (pIAT && *pIAT) {
                pImport = ImageRvaToVa(g_pli->FileHeader,
                                       (PVOID)g_pli->MappedAddress,
                                       (ULONG) *pIAT,
                                       NULL);

                if (pImport && _stricmp(pImport->Name, "DelayLoadFailureHook") == 0) {
                    return TRUE;
                }
                pIAT++;
            }
        }
        Imports++;
    }

    return FALSE;
}

//
//  Validate that the statically-linked delayload stub table is not
//  blatantly broken.  The most common error is not listing the functions
//  in the correct order so the binary search fails.
//
int ValidateStaticDelayloadStubs()
{
    extern const DLOAD_DLL_MAP g_DllMap;
    UINT i, j;
    int Errors = 0;

    //
    //  Ensure that the DLL map is in alphabetical order.
    //
    for (i = 1; i < g_DllMap.NumberOfEntries; i++)
    {
        if (strcmp(g_DllMap.pDllEntry[i-1].pszDll,
                   g_DllMap.pDllEntry[i].pszDll) >= 0)
        {
            fprintf(stderr, "DLCHECK : error DL000001 : Static delayload table is corrupted\n"
                            "          %s and %s not in alphabetical order\n",
                            g_DllMap.pDllEntry[i-1].pszDll,
                            g_DllMap.pDllEntry[i].pszDll);
            Errors = 1;
        }
    }

    //  For each DLL...
    for (i = 0; i < g_DllMap.NumberOfEntries; i++)
    {
        const DLOAD_DLL_ENTRY *pEntry = &g_DllMap.pDllEntry[i];

        //
        //  Name must be lowercase.
        //
        char szLower[MAX_PATH];

        StringCchCopy(szLower, ARRAYSIZE(szLower), pEntry->pszDll);
        _strlwr(szLower);
        if (strcmp(szLower, pEntry->pszDll) != 0)
        {
            fprintf(stderr, "DLCHECK : error DL000002 : Static delayload table is corrupted\n"
                            "          %s must be all-lowercase\n",
                            pEntry->pszDll);
            Errors = 1;
        }

        //
        // Ensure that the exports are in alphabetical order
        //
        {
            const DLOAD_PROCNAME_MAP *pProcNameMap = pEntry->pProcNameMap;

            if (pProcNameMap)
            {
                const DLOAD_PROCNAME_ENTRY *pProcNameEntry = pProcNameMap->pProcNameEntry;
                for (j = 1; j < pProcNameMap->NumberOfEntries; j++)
                {
                    if (strcmp(pProcNameEntry[j-1].pszProcName,
                               pProcNameEntry[j].pszProcName) >= 0)
                    {
                        fprintf(stderr, "DLCHECK : error DL000003 : Static delayload table is corrupted\n"
                                        "          %s.%s and %s.%s not in alphabetical order\n",
                                        g_DllMap.pDllEntry[i].pszDll,
                                        pProcNameEntry[j-1].pszProcName,
                                        g_DllMap.pDllEntry[i].pszDll,
                                        pProcNameEntry[j].pszProcName);

                        Errors = 1;
                    }
                }
            }
        }

        //
        // Ensure that the ordinals are in alphabetical order
        //
        {
            const DLOAD_ORDINAL_MAP *pOrdinalMap = pEntry->pOrdinalMap;

            if (pOrdinalMap)
            {
                const DLOAD_ORDINAL_ENTRY *pOrdinalEntry = pOrdinalMap->pOrdinalEntry;
                for (j = 1; j < pOrdinalMap->NumberOfEntries; j++)
                {
                    if (pOrdinalEntry[j-1].dwOrdinal >= pOrdinalEntry[j].dwOrdinal)
                    {
                        fprintf(stderr, "DLCHECK : error DL000001 : Static delayload table is corrupted\n"
                                        "          %s.%d and %s.%d not in numeric order\n",
                                        g_DllMap.pDllEntry[i].pszDll,
                                        pOrdinalEntry[j-1].dwOrdinal,
                                        g_DllMap.pDllEntry[i].pszDll,
                                        pOrdinalEntry[j-1].dwOrdinal);
                        Errors = 1;
                    }
                }
            }
        }

    }

    return Errors;
}

int CheckImage(char *szImageName, BOOL fForceCheckImage)
{
    PImgDelayDescr Imports;
    ULONG ImportSize;
    char *szName;
    PIMAGE_THUNK_DATA pINT;
    DelayLoadInfo dlinfo;
    FARPROC fp;
    int ReturnValue;
    BOOL fCallHandler;
    BOOL fPE32;

    g_pli = ImageLoad(szImageName, NULL);
    if (!g_pli) {
        fprintf(stderr, "DLCHECK : fatal error %d: loading '%s'\n", GetLastError(), szImageName);
        return 1;
    }
    Imports = (PImgDelayDescr)
                  ImageDirectoryEntryToDataEx(g_pli->MappedAddress,
                                            FALSE,
                                            IMAGE_DIRECTORY_ENTRY_DELAY_IMPORT,
                                            &ImportSize,
                                            &g_DelaySection
                                            );
    if (!Imports) {
        fprintf(stdout, "DLCHECK : warning DL000000: image '%s' has no delayload imports\n", szImageName);
        return 0;
    }

    fPE32 = g_pli->FileHeader->OptionalHeader.Magic == IMAGE_NT_OPTIONAL_HDR32_MAGIC ? TRUE : FALSE;

    if (fForceCheckImage)
    {
        fCallHandler = TRUE;
    }
    else
    {
        fCallHandler = ImageLinksToKernel32Handler();
    }

    if (!fCallHandler) {
        fprintf(stderr, "DLCHECK : fatal errror : image '%s' doesn't import kernel32!DelayLoadFailureHook.\n"
                        "(use -f option to override)\n"
                        "\n", szImageName);
        return 1;
    }

    //
    // Walk each delayloaded DLL
    //
    ReturnValue = 0;    // assume success

    if (Imports->grAttrs & dlattrRva) {
        PImgDelayDescrV2 pImportsV2 = (PImgDelayDescrV2)Imports;
        szName = (char *)RvaToPtr(pImportsV2->rvaDLLName);
        pINT = (PIMAGE_THUNK_DATA)RvaToPtr(pImportsV2->rvaINT);
    } else {
        PImgDelayDescrV1 pImportsV1 = (PImgDelayDescrV1)Imports;
        szName = (char *)ConvertImagePointer((void *)pImportsV1->szName);
        pINT = (PIMAGE_THUNK_DATA)ConvertImagePointer((void *)pImportsV1->pINT);
    }

    while (szName) {
        // printf("DelayLoad DLL %s\n", szName);
        char szModuleName[MAX_PATH];
        char szImportName[MAX_PATH];
        
        {
            char* p;
            // change "module.dll" to just "module"
            StringCchCopy(szModuleName, ARRAYSIZE(szModuleName), szName);
            p = szModuleName;
            while (*p != '\0')
            {
                if (*p == '.')
                {
                    *p = '\0';
                    break;
                }
                p++;
            }
        }

        //
        // Walk each function called from the delayloaded DLL
        //

        while (pINT->u1.AddressOfData) {
            dlinfo.cb = sizeof(dlinfo);
            dlinfo.pidd = NULL;
            dlinfo.ppfn = NULL;
            dlinfo.szDll = szName;
            dlinfo.pfnCur = NULL;
            dlinfo.dwLastError = ERROR_NOT_ENOUGH_MEMORY;
            dlinfo.dlp.szProcName = NULL;   // Make sure the upper 32 bits are zeroed out on win64.

            if (
                ( fPE32 && IMAGE_SNAP_BY_ORDINAL32(((PIMAGE_THUNK_DATA32)pINT)->u1.AddressOfData)) ||
                (!fPE32 && IMAGE_SNAP_BY_ORDINAL64(((PIMAGE_THUNK_DATA64)pINT)->u1.AddressOfData))
               )
            {
                StringCchPrintf(szImportName, ARRAYSIZE(szImportName), TEXT("Ordinal%d"), IMAGE_ORDINAL(pINT->u1.AddressOfData));
                dlinfo.dlp.fImportByName = FALSE;
                dlinfo.dlp.dwOrdinal = IMAGE_ORDINAL((ULONG)pINT->u1.AddressOfData);
            } else {
                PIMAGE_IMPORT_BY_NAME pImport;
                if (Imports->grAttrs & dlattrRva) {
                    pImport = (PIMAGE_IMPORT_BY_NAME)RvaToPtr(pINT->u1.AddressOfData);
                } else {
                    pImport = (PIMAGE_IMPORT_BY_NAME)ConvertImagePointer((void *)pINT->u1.AddressOfData);
                }
                StringCchCopy(szImportName, ARRAYSIZE(szImportName), pImport->Name);
                dlinfo.dlp.fImportByName = TRUE;
                dlinfo.dlp.szProcName = pImport->Name;
            }

            if (fCallHandler) {
                //
                // Call the delayload handler and see what it does.
                //
                try {
                    fp = (*__pfnFailureProc)(dlinfo.szDll, dlinfo.dlp.szProcName);
                    if (!fp) {
                        fprintf(stderr, "DLCHECK : error DL000000: %s imports %s!%s which is not handled.\n", szImageName, szModuleName, szImportName);
                        ReturnValue = 1;
                    } else {
                        // printing success takes too much time
                        // printf("DLCHECK : %s imports %s!%s - OK.\n", szImageName, szModuleName, szImportName);
                    }
                } except (EXCEPTION_EXECUTE_HANDLER) {
                    fprintf(stderr, "DLCHECK : error %x: %s imports %s!%s - handler threw an exception.\n", GetExceptionCode(), szImageName, szModuleName, szImportName);
                    ReturnValue = 1;
                }
            }
            else
            {
                printf("DLCHECK : %s imports %s!%s - not checked.\n", szImageName, szModuleName, szImportName);
            }

            if (fPE32) {
                pINT = (PIMAGE_THUNK_DATA)(((PIMAGE_THUNK_DATA32)pINT)++);
            } else {
                pINT = (PIMAGE_THUNK_DATA)(((PIMAGE_THUNK_DATA64)pINT)++);
            }
        }
        if (Imports->grAttrs & dlattrRva) {
            PImgDelayDescrV2 pImportsV2 = (PImgDelayDescrV2)Imports;
            pImportsV2++;
            Imports = (PImgDelayDescr)pImportsV2;
            szName = (char *)RvaToPtr(pImportsV2->rvaDLLName);
            pINT = (PIMAGE_THUNK_DATA)RvaToPtr(pImportsV2->rvaINT);
        } else {
            PImgDelayDescrV1 pImportsV1 = (PImgDelayDescrV1)Imports;
            pImportsV1++;
            Imports = (PImgDelayDescr)pImportsV1;
            szName = (char *)ConvertImagePointer((void *)pImportsV1->szName);
            pINT = (PIMAGE_THUNK_DATA)ConvertImagePointer((void *)pImportsV1->pINT);
        }
    }

    if (ReturnValue == 0)
    {
        printf("DLCHECK : succeeded on %s\n", szImageName);
    }
    else
    {
        fprintf(stderr, "DLCHECK : failed on %s\n", szImageName);
    }

    return ReturnValue;
}

int CheckIniFile(char *pszFile, BOOL fForceCheckImage)
{
    char szIniFile[MAX_PATH];
    char szTemp[MAX_PATH];
    char szTemp2[MAX_PATH];
    char szImageName[MAX_PATH];
    char szDelayLoadHandler[MAX_PATH];
    int ReturnValue;
    LPTSTR psz;

    if ((GetFullPathName(pszFile, ARRAYSIZE(szIniFile), szIniFile, &psz) == 0) ||
        (GetPrivateProfileString("Default",
                                 "DelayLoadHandler",
                                 "",
                                 szDelayLoadHandler,
                                 ARRAYSIZE(szDelayLoadHandler),
                                 szIniFile) == 0))
    {
        fprintf(stderr, "DLCHECK : fatal error : failed to load %s\n", szIniFile);
        return 1;
    }

    // foomodule.dll.ini -> foomodule.dll
    StringCchCopy(szImageName, ARRAYSIZE(szImageName), psz);
    _strlwr(szImageName);
    psz = strstr(szImageName, ".ini");
    if (psz)
    {
        *psz = '\0';
    }

    if (_stricmp(szDelayLoadHandler, "FORCE") == 0)
    {
        // if the delayload handler is set to FORCE, we check the binary as if it were
        // using kernel32
        fForceCheckImage = TRUE;
    }

    if ((_stricmp(szDelayLoadHandler, "kernel32") != 0) &&
        (_stricmp(szDelayLoadHandler, "FORCE") != 0))
    {
        // currently only able to check dll's who use kernel32.dll for their delayload handler
        fprintf(stdout, "DLCHECK : warning DL000000 : Unable to check delayload failure behavior\n"
                        "          %s uses %s as a handler, not kernel32\n", szImageName, szDelayLoadHandler);
        return 0;
    }

    // foomodule.dll -> d:\binaries.x86chk\foomodule.dll
    if (ExpandEnvironmentStrings("%_NTPostBld%", szTemp, ARRAYSIZE(szTemp)) == 0)
    {
        fprintf(stderr, "DLCHECK : fatal error : _NTPostBld environment variable not set\n");
        return 1;
    }
    if (GetPrivateProfileString("Default",
                                "DestinationDir",
                                "",
                                szTemp2,
                                ARRAYSIZE(szTemp2),
                                szIniFile) == 0)
    {
        fprintf(stderr, "DLCHECK : fatal error : failed to read 'DestinationDir' from %s\n", szIniFile);
        return 1;
    }

    StringCchCat(szTemp, ARRAYSIZE(szTemp), TEXT("\\"));
    StringCchCat(szTemp, ARRAYSIZE(szTemp), szTemp2);
    StringCchCat(szTemp, ARRAYSIZE(szTemp), szImageName);

    GetFullPathName(szTemp, ARRAYSIZE(szImageName), szImageName, NULL);

    // Heck, lets always validate the static delay load stubs, its fast
    ReturnValue = ValidateStaticDelayloadStubs();

    if (szImageName[0] != '\0')
    {
        ReturnValue += CheckImage(szImageName, fForceCheckImage);
    }

    return ReturnValue;
}

BOOL PathIsDotOrDotDot(LPCSTR pszPath)
{
    return ((pszPath[0] == '.') && 
            ((pszPath[1] == '\0') || ((pszPath[1] == '.') && (pszPath[2] == '\0'))));
}

BOOL PathIsWild(LPCSTR pszPath)
{
    while (*pszPath) 
    {
        if (*pszPath == TEXT('?') || *pszPath == TEXT('*'))
            return TRUE;
        pszPath = CharNext(pszPath);
    }
    return FALSE;
}

int CheckImageOrIniFileRecursive(char *szName, BOOL fForceCheckImage, BOOL fIniFile, int *piFiles)
{
    HANDLE  hfind;
    WIN32_FIND_DATA fd;
    char szPathName[MAX_PATH];
    char *pszFileSpec;
    int ReturnValue = 0;

    pszFileSpec = PathFindFileName(szName);

    // First find all files that match the file spec, ignoring directories
    hfind = FindFirstFile(szName, &fd);

    if (hfind != INVALID_HANDLE_VALUE)
    {
        do {
            if (!PathIsDotOrDotDot(fd.cFileName))
            {
                StrCpyN(szPathName, szName, sizeof(szPathName));
                PathRemoveFileSpec(szPathName);
                PathAppend(szPathName, fd.cFileName);

                if (fd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
                {
                    // Ignore directories
                }
                else
                {
                    (*piFiles)++;

                    if (fIniFile)
                    {
                        ReturnValue += CheckIniFile(szPathName, fForceCheckImage);
                    }
                    else
                    {
                        ReturnValue += CheckImage(szPathName, fForceCheckImage);
                    }
                }
            }
        } while (FindNextFile(hfind, &fd));

        FindClose(hfind);
    }

    if (PathIsWild(szName))
    {
        char szPathSearch[MAX_PATH];
        // Now do all directories
        StrCpyN(szPathSearch,szName,sizeof(szPathSearch));
        PathRemoveFileSpec(szPathSearch);
        PathAppend(szPathSearch,"*.*");
        hfind = FindFirstFile(szPathSearch, &fd);

        if (hfind != INVALID_HANDLE_VALUE)
        {
            do {
                if (!PathIsDotOrDotDot(fd.cFileName))
                {
                    StrCpyN(szPathName, szPathSearch, sizeof(szPathName));
                    PathRemoveFileSpec(szPathName);
                    PathAppend(szPathName, fd.cFileName);

                    if (fd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
                    {
                        PathAppend(szPathName,pszFileSpec);
                        ReturnValue += CheckImageOrIniFileRecursive(szPathName, fForceCheckImage, fIniFile, piFiles);
                    }
                    else
                    {
                        // Only process directories
                    }
                }
            } while (FindNextFile(hfind, &fd));

            FindClose(hfind);
        }
    }
    return ReturnValue;
}


int
__cdecl
main (
    int c,
    char *v[]
    )
{
    int ReturnValue;
    BOOL fIniFile = FALSE;
    char szImageName[MAX_PATH];
    BOOL fForceCheckImage = FALSE;

    if (c < 2) {
        Usage();
    }

    if (*v[1] == '-' || *v[1] == '/') {
        switch ( *(v[1]+1) ) {
        case 's':
        case 'S':
            if (c != 3) {
                Usage();
            }
            StringCchCopy(szImageName, ARRAYSIZE(szImageName), v[2]);
            break;  // nothing needs to be done.

        case 'l':
        case 'L':
            __pfnFailureProc = (PfnKernel32HookProc)GetProcAddress(GetModuleHandleA("kernel32.dll"), "DelayLoadFailureHook");
            if (!__pfnFailureProc) {
                fprintf(stderr, "DLCHECK : fatal error %d: looking up kernel32 delayload hook\n", GetLastError());
                return 1;
            }   
            if (c != 3) {
                Usage();
            }
            StringCchCopy(szImageName, ARRAYSIZE(szImageName), v[2]);
            break;

        case 'i':
        case 'I':
            if (c != 3) {
                Usage();
            }
            fIniFile = TRUE;
            StringCchCopy(szImageName, ARRAYSIZE(szImageName), v[2]);
            break;

        case 't':
        case 'T':
            if (c != 2) {
                Usage();
            }
            StringCchCopy(szImageName, ARRAYSIZE(szImageName), "");
            break;

        case 'f':
        case 'F':
            if (c != 3)
            {
                Usage();
            }
            fForceCheckImage = TRUE;
            StringCchCopy(szImageName, ARRAYSIZE(szImageName), v[2]);
            break;  // nothing needs to be done.

        default:
            Usage();
        }
    } else {
        Usage();
    }

    // Heck, lets always validate the static delay load stubs, its fast
    ReturnValue = ValidateStaticDelayloadStubs();

    if (szImageName[0] != '\0')
    {
        int iFiles = 0;

        ReturnValue += CheckImageOrIniFileRecursive(szImageName, fForceCheckImage, fIniFile, &iFiles);

        if (iFiles == 0)
        {
            fprintf(stderr, "DLCHECK : fatal error : no files found to process\n");
        }
    }

    return ReturnValue;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\dload\dload.h ===
#pragma once

// Get the public delay load stub definitions.
//
#include <dloaddef.h>

// 'B' for both
// 'P' for procname only
// 'O' for ordinal only
//
#define DLDENTRYB(_dllbasename) \
    { #_dllbasename".dll", \
      &c_Pmap_##_dllbasename, \
      &c_Omap_##_dllbasename },

#define DLDENTRYB_DRV(_dllbasename) \
    { #_dllbasename".drv", \
      &c_Pmap_##_dllbasename, \
      &c_Omap_##_dllbasename },

#define DLDENTRYP(_dllbasename) \
    { #_dllbasename".dll", \
      &c_Pmap_##_dllbasename, \
      NULL },

#define DLDENTRYP_DRV(_dllbasename) \
    { #_dllbasename".drv", \
      &c_Pmap_##_dllbasename, \
      NULL },

#define DLDENTRYO(_dllbasename) \
    { #_dllbasename".dll", \
      NULL, \
      &c_Omap_##_dllbasename },


extern const DLOAD_DLL_MAP g_DllMap;

FARPROC
LookupHandler (
    LPCSTR pszDllName,
    LPCSTR pszProcName
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\dload\dloaddefaultbreak.c ===
#include "pch.h"
int DloadBreakOnFail = TRUE;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\dload\dloaddefaulttrace.c ===
#include "pch.h"
int DloadDbgPrint = TRUE;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\dload\dllmap.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       P R O C M A P . C
//
//  Contents:   Procedure maps for dload.c
//
//  Notes:
//
//  Author:     shaunco   19 May 1998
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop

//
// All of the DLLs that kernel32.dll supports delay-load failure handlers for
// (both by procedure and by ordinal) need both a DECLARE_XXXXXX_MAP below and
// a DLDENTRYX entry in the g_DllEntries list.
//

// alphabetical order (hint hint)
DECLARE_ORDINAL_MAP(aclui)
DECLARE_ORDINAL_MAP(activeds)
DECLARE_PROCNAME_MAP(advapi32)
DECLARE_PROCNAME_MAP(advpack)
DECLARE_PROCNAME_MAP(apphelp)
DECLARE_PROCNAME_MAP(authz)
DECLARE_ORDINAL_MAP(browseui)
DECLARE_ORDINAL_MAP(cabinet)
DECLARE_PROCNAME_MAP(catsrv)
DECLARE_PROCNAME_MAP(catsrvut)
DECLARE_PROCNAME_MAP(cdfview)
DECLARE_ORDINAL_MAP(certcli)
DECLARE_PROCNAME_MAP(certcli)
DECLARE_PROCNAME_MAP(clbcatq)
DECLARE_PROCNAME_MAP(colbact)
DECLARE_ORDINAL_MAP(comctl32)
DECLARE_PROCNAME_MAP(comctl32)
DECLARE_PROCNAME_MAP(comdlg32)
DECLARE_PROCNAME_MAP(comres)
DECLARE_PROCNAME_MAP(comsvcs)
DECLARE_PROCNAME_MAP(credui)
DECLARE_PROCNAME_MAP(crypt32)
DECLARE_PROCNAME_MAP(cryptui)
DECLARE_ORDINAL_MAP(cscdll)
DECLARE_PROCNAME_MAP(dbghelp)
DECLARE_PROCNAME_MAP(ddraw)
DECLARE_ORDINAL_MAP(devmgr)
DECLARE_PROCNAME_MAP(dhcpcsvc)
DECLARE_PROCNAME_MAP(dnsapi)
DECLARE_ORDINAL_MAP(dsound)
DECLARE_PROCNAME_MAP(duser)
DECLARE_PROCNAME_MAP(efsadu)
DECLARE_PROCNAME_MAP(esent)
DECLARE_PROCNAME_MAP(fxsapi)
DECLARE_PROCNAME_MAP(gdi32)
DECLARE_PROCNAME_MAP(gdiplus)
DECLARE_ORDINAL_MAP(hlink)
DECLARE_PROCNAME_MAP(iashlpr)
DECLARE_PROCNAME_MAP(imagehlp)
DECLARE_PROCNAME_MAP(imgutil)
DECLARE_PROCNAME_MAP(imm32)
DECLARE_PROCNAME_MAP(inetcomm)
DECLARE_PROCNAME_MAP(iphlpapi)
DECLARE_PROCNAME_MAP(kdcsvc)
DECLARE_PROCNAME_MAP(keymgr)
DECLARE_PROCNAME_MAP(linkinfo)
DECLARE_PROCNAME_MAP(loadperf)
DECLARE_PROCNAME_MAP(lsasrv)
DECLARE_PROCNAME_MAP(lz32)
DECLARE_ORDINAL_MAP(mlang)
DECLARE_PROCNAME_MAP(mobsync)
DECLARE_PROCNAME_MAP(mpr)
DECLARE_PROCNAME_MAP(mprapi)
DECLARE_PROCNAME_MAP(mprui)
DECLARE_PROCNAME_MAP(mqrt)
DECLARE_PROCNAME_MAP(msacm32)
DECLARE_PROCNAME_MAP(mscat32)
DECLARE_ORDINAL_MAP(msgina)
DECLARE_PROCNAME_MAP(mshtml)
DECLARE_ORDINAL_MAP(msi)
DECLARE_PROCNAME_MAP(msimg32)
DECLARE_PROCNAME_MAP(msjava)
DECLARE_PROCNAME_MAP(msrating)
DECLARE_PROCNAME_MAP(mssign32)
DECLARE_PROCNAME_MAP(mswsock)
DECLARE_PROCNAME_MAP(mtxclu)
DECLARE_PROCNAME_MAP(netapi32)
DECLARE_PROCNAME_MAP(netcfgx)
DECLARE_PROCNAME_MAP(netman)
DECLARE_PROCNAME_MAP(netplwiz)
DECLARE_PROCNAME_MAP(netrap)
DECLARE_PROCNAME_MAP(netshell)
DECLARE_PROCNAME_MAP(ntdsa)
DECLARE_PROCNAME_MAP(ntdsapi)
DECLARE_PROCNAME_MAP(ntdsbsrv)
DECLARE_PROCNAME_MAP(ntdsetup)
DECLARE_PROCNAME_MAP(ntdskcc)
DECLARE_PROCNAME_MAP(ntlanman)
DECLARE_PROCNAME_MAP(ntlsapi)
DECLARE_PROCNAME_MAP(ntmarta)
DECLARE_PROCNAME_MAP(ntshrui)
DECLARE_PROCNAME_MAP(ocmanage)
DECLARE_ORDINAL_MAP(odbc32)
DECLARE_PROCNAME_MAP(ole32)
DECLARE_PROCNAME_MAP(oleacc)
DECLARE_ORDINAL_MAP(oleaut32)
DECLARE_PROCNAME_MAP(pautoenr)
DECLARE_ORDINAL_MAP(pidgen)
DECLARE_PROCNAME_MAP(powrprof)
DECLARE_PROCNAME_MAP(printui)
DECLARE_PROCNAME_MAP(pstorec)
DECLARE_PROCNAME_MAP(query)
DECLARE_PROCNAME_MAP(rasapi32)
DECLARE_PROCNAME_MAP(rasdlg)
DECLARE_PROCNAME_MAP(rasman)
DECLARE_PROCNAME_MAP(regapi)
DECLARE_PROCNAME_MAP(rpcrt4)
DECLARE_PROCNAME_MAP(rtutils)
DECLARE_PROCNAME_MAP(samlib)
DECLARE_PROCNAME_MAP(samsrv)
DECLARE_PROCNAME_MAP(scecli)
DECLARE_PROCNAME_MAP(secur32)
DECLARE_PROCNAME_MAP(setupapi)
DECLARE_ORDINAL_MAP(sfc)
DECLARE_PROCNAME_MAP(sfc)
DECLARE_PROCNAME_MAP(sfmapi)
DECLARE_ORDINAL_MAP(shdocvw)
DECLARE_PROCNAME_MAP(shdocvw)
DECLARE_ORDINAL_MAP(shell32)
DECLARE_PROCNAME_MAP(shell32)
DECLARE_ORDINAL_MAP(shlwapi)
DECLARE_PROCNAME_MAP(shlwapi)
DECLARE_ORDINAL_MAP(shsvcs)
DECLARE_PROCNAME_MAP(sti)
DECLARE_PROCNAME_MAP(syssetup)
DECLARE_PROCNAME_MAP(tapi32)
DECLARE_PROCNAME_MAP(urlmon)
DECLARE_PROCNAME_MAP(user32)
DECLARE_ORDINAL_MAP(userenv)
DECLARE_PROCNAME_MAP(userenv)
DECLARE_PROCNAME_MAP(usp10)
DECLARE_PROCNAME_MAP(utildll)
DECLARE_ORDINAL_MAP(uxtheme)
DECLARE_PROCNAME_MAP(uxtheme)
DECLARE_PROCNAME_MAP(version)
DECLARE_PROCNAME_MAP(w32topl)
DECLARE_PROCNAME_MAP(winhttp)
DECLARE_ORDINAL_MAP(wininet)
DECLARE_PROCNAME_MAP(wininet)
DECLARE_PROCNAME_MAP(winmm)
DECLARE_PROCNAME_MAP(winscard)
DECLARE_ORDINAL_MAP(winspool)
DECLARE_PROCNAME_MAP(winspool)
DECLARE_PROCNAME_MAP(winsta)
DECLARE_PROCNAME_MAP(wintrust)
DECLARE_ORDINAL_MAP(wldap32)
DECLARE_PROCNAME_MAP(wmi)
DECLARE_PROCNAME_MAP(wmvcore)
DECLARE_ORDINAL_MAP(ws2_32)
DECLARE_PROCNAME_MAP(ws2_32)
DECLARE_PROCNAME_MAP(wtsapi32)
DECLARE_PROCNAME_MAP(wzcdlg)
DECLARE_ORDINAL_MAP(wzcsapi)
DECLARE_PROCNAME_MAP(wzcsapi)
DECLARE_PROCNAME_MAP(xolehlp)

const DLOAD_DLL_ENTRY g_DllEntries [] =
{
    // alphabetical order (hint hint)
    DLDENTRYO(aclui)
    DLDENTRYO(activeds)
    DLDENTRYP(advapi32)
    DLDENTRYP(advpack)
    DLDENTRYP(apphelp)
    DLDENTRYP(authz)
    DLDENTRYO(browseui)
    DLDENTRYO(cabinet)
    DLDENTRYP(catsrv)
    DLDENTRYP(catsrvut)
    DLDENTRYP(cdfview)
    DLDENTRYB(certcli)
    DLDENTRYP(clbcatq)
    DLDENTRYP(colbact)
    DLDENTRYB(comctl32)
    DLDENTRYP(comdlg32)
    DLDENTRYP(comres)
    DLDENTRYP(comsvcs)
    DLDENTRYP(credui)
    DLDENTRYP(crypt32)
    DLDENTRYP(cryptui)
    DLDENTRYO(cscdll)
    DLDENTRYP(dbghelp)
    DLDENTRYP(ddraw)
    DLDENTRYO(devmgr)
    DLDENTRYP(dhcpcsvc)
    DLDENTRYP(dnsapi)
    DLDENTRYO(dsound)
    DLDENTRYP(duser)
    DLDENTRYP(efsadu)
    DLDENTRYP(esent)
    DLDENTRYP(fxsapi)
    DLDENTRYP(gdi32)
    DLDENTRYP(gdiplus)
    DLDENTRYO(hlink)
    DLDENTRYP(iashlpr)
    DLDENTRYP(imagehlp)
    DLDENTRYP(imgutil)
    DLDENTRYP(imm32)
    DLDENTRYP(inetcomm)
    DLDENTRYP(iphlpapi)
    DLDENTRYP(kdcsvc)
    DLDENTRYP(keymgr)
    DLDENTRYP(linkinfo)
    DLDENTRYP(loadperf)
    DLDENTRYP(lsasrv)
    DLDENTRYP(lz32)
    DLDENTRYO(mlang)
    DLDENTRYP(mobsync)
    DLDENTRYP(mpr)
    DLDENTRYP(mprapi)
    DLDENTRYP(mprui)
    DLDENTRYP(mqrt)
    DLDENTRYP(msacm32)
    DLDENTRYP(mscat32)
    DLDENTRYO(msgina)
    DLDENTRYP(mshtml)
    DLDENTRYO(msi)
    DLDENTRYP(msimg32)
    DLDENTRYP(msjava)
    DLDENTRYP(msrating)
    DLDENTRYP(mssign32)
    DLDENTRYP(mswsock)
    DLDENTRYP(mtxclu)
    DLDENTRYP(netapi32)
    DLDENTRYP(netcfgx)
    DLDENTRYP(netman)
    DLDENTRYP(netplwiz)
    DLDENTRYP(netrap)
    DLDENTRYP(netshell)
    DLDENTRYP(ntdsa)
    DLDENTRYP(ntdsapi)
    DLDENTRYP(ntdsbsrv)
    DLDENTRYP(ntdsetup)
    DLDENTRYP(ntdskcc)
    DLDENTRYP(ntlanman)
    DLDENTRYP(ntlsapi)
    DLDENTRYP(ntmarta)
    DLDENTRYP(ntshrui)
    DLDENTRYP(ocmanage)
    DLDENTRYO(odbc32)
    DLDENTRYP(ole32)
    DLDENTRYP(oleacc)
    DLDENTRYO(oleaut32)
    DLDENTRYP(pautoenr)
    DLDENTRYO(pidgen)
    DLDENTRYP(powrprof)
    DLDENTRYP(printui)
    DLDENTRYP(pstorec)
    DLDENTRYP(query)
    DLDENTRYP(rasapi32)
    DLDENTRYP(rasdlg)
    DLDENTRYP(rasman)
    DLDENTRYP(regapi)
    DLDENTRYP(rpcrt4)
    DLDENTRYP(rtutils)
    DLDENTRYP(samlib)
    DLDENTRYP(samsrv)
    DLDENTRYP(scecli)
    DLDENTRYP(secur32)
    DLDENTRYP(setupapi)
    DLDENTRYB(sfc)
    DLDENTRYP(sfmapi)
    DLDENTRYB(shdocvw)
    DLDENTRYB(shell32)
    DLDENTRYB(shlwapi)
    DLDENTRYO(shsvcs)
    DLDENTRYP(sti)
    DLDENTRYP(syssetup)
    DLDENTRYP(tapi32)
    DLDENTRYP(urlmon)
    DLDENTRYP(user32)
    DLDENTRYB(userenv)
    DLDENTRYP(usp10)
    DLDENTRYP(utildll)
    DLDENTRYB(uxtheme)
    DLDENTRYP(version)
    DLDENTRYP(w32topl)
    DLDENTRYP(winhttp)
    DLDENTRYB(wininet)
    DLDENTRYP(winmm)
    DLDENTRYP(winscard)
    DLDENTRYB_DRV(winspool)
    DLDENTRYP(winsta)
    DLDENTRYP(wintrust)
    DLDENTRYO(wldap32)
    DLDENTRYP(wmi)
    DLDENTRYP(wmvcore)
    DLDENTRYB(ws2_32)
    DLDENTRYP(wtsapi32)
    DLDENTRYP(wzcdlg)
    DLDENTRYB(wzcsapi)
    DLDENTRYP(xolehlp)
};

const DLOAD_DLL_MAP g_DllMap =
{
    celems(g_DllEntries),
    g_DllEntries
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\dload\dload.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation.
//
//  File:       D L O A D . C
//
//  Contents:   Delay Load Failure Hook
//
//  Notes:      This lib implements all of the stub functions for modules
//              that are delayloaded by the OS. It merges together all of the
//              dloadXXX.lib files from each depot.
//
//  To Use:     In your sources file, right after you specify the modules you
//              are delayloading do:
//
//                  DLOAD_ERROR_HANDLER=kernel32
//
//              If you want to use kernel32 as your dload error handler. If you
//              do this, your dll will be checked that everything it delayloads
//              has a proper error handler function by the delayload.cmd postbuild
//              script.
//
//              To check that all functions you delayload have error handlers you
//              can do the following:
//
//                  1. do a "link -dump -imports foo.dll", and find all functions 
//                     that you delay-import.
//
//                  2. do a "link -dump -symbols \nt\public\internal\base\lib\*\dload.lib"
//                     and make sure every function that shows up as delayloaded in step #1
//                     has a error handler fn. in dload.lib.
//
//                  3. if a function is missing in step #2 (dlcheck will also fails as 
//                     part of postbuild), you need to add an error handler. Go to the depot
//                     where that dll is build, and go to the dload subdir (usually under
//                     the root or under the published\dload subdir) and add an error handler.
//
//
//  Author:     shaunco   19 May 1998
//  Modified:   reinerf   12 Jan 2001   Changed above comment
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop


// External global variables
//
extern HANDLE   BaseDllHandle;

#if DBG
extern int DloadBreakOnFail;
extern int DloadDbgPrint;
#endif

#if DBG

#define DBG_ERROR   0
#define DBG_INFO    1

//+---------------------------------------------------------------------------
// Trace a message to the debug console.  Prefix with who we are so
// people know who to contact.
//
INT
__cdecl
DbgTrace (
    INT     nLevel,
    PCSTR   Format,
    ...
    )
{
    INT cch = 0;
    if (DloadDbgPrint) {
    
        if (nLevel <= DBG_INFO)
        {
            CHAR    szBuf [1024];
            va_list argptr;
    
            va_start (argptr, Format);
            cch = vsprintf (szBuf, Format, argptr);
            va_end (argptr);
    
            OutputDebugStringA ("dload: ");
            OutputDebugStringA (szBuf);
        }
    }

    return cch;
}

//+---------------------------------------------------------------------------
// Cannot use RtlAssert since doing so will cause setupapi.dll to fail
// for upgrade over win95(gold)
//
VOID
WINAPI
DelayLoadAssertFailed(
    IN PCSTR FailedAssertion,
    IN PVOID FileName,
    IN ULONG LineNumber,
    IN PCSTR Message OPTIONAL
    )
{
    DbgTrace (
        DBG_ERROR,
        "Assertion failure at line %u in file %s: %s%s%s\r\n",
        LineNumber,
        FileName,
        FailedAssertion,
        (Message && Message[0] && FailedAssertion[0]) ? " " : "",
        Message ? Message : ""
        );

    if (DloadBreakOnFail) {
        DebugBreak();
    }
}

#endif // DBG


//+---------------------------------------------------------------------------
//
//
FARPROC
WINAPI
DelayLoadFailureHook (
    LPCSTR pszDllName,
    LPCSTR pszProcName
    )
{
    FARPROC ReturnValue = NULL;

    MYASSERT (pszDllName);
    MYASSERT (pszProcName);  

    // Trace some potentially useful information about why we were called.
    //
#if DBG
    if (!IS_INTRESOURCE(pszProcName))
    {
        DbgTrace (DBG_INFO,
            "DelayloadFailureHook: Dll=%s, ProcName=%s\n",
            pszDllName,
            pszProcName);
    }
    else
    {
        DbgTrace (DBG_INFO,
            "DelayloadFailureHook: Dll=%s, Ordinal=%u\n",
            pszDllName,
            (DWORD)((DWORD_PTR)pszProcName));
    }
#endif

    ReturnValue = LookupHandler(pszDllName, pszProcName);

    if (ReturnValue)
    {
#if DBG
        DbgTrace (DBG_INFO,
            "Returning handler function at address 0x%08x\n",
            (LONG_PTR)ReturnValue);
#endif
    }
#if DBG
    else
    {
        CHAR pszMsg [MAX_PATH];

        if (!IS_INTRESOURCE(pszProcName))
        {
            sprintf (pszMsg,
                "No delayload handler found for Dll=%s, ProcName=%s\n"
                "Please add one in private\\dload.",
                pszDllName,
                pszProcName);
        }
        else
        {
            sprintf (pszMsg,
                "No delayload handler found for Dll=%s, Ordinal=%u\n"
                "Please add one in private\\dload.",
                pszDllName,
                (DWORD)((DWORD_PTR)pszProcName));
        }

        DelayLoadAssertFailed ( "" , __FILE__, __LINE__, pszMsg);
    }
#endif

    return ReturnValue;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\dload\dloadexcept.h ===
#pragma once

// Our primary client is kernel32.dll.  Because we use APIs exported
// by kernel32.dll, we need to build this static library as if we
// are kernel32.dll.  If we don't we get link warnings like:
// warning LNK4049: locally defined symbol "_OutputDebugStringA@4" imported
// warning LNK4049: locally defined symbol "_SetLastError@4" imported
//
// Other clients of this library will just go through the import thunk
// instead of doing a call indirect for these APIs.
//
#define _KERNEL32_

// "Build as if we are advapi32.dll. If we don't we get" compiler errors like:
// advapi.c : error C2491: 'RegCreateKeyExW' : definition of dllimport function not allowed
#define _ADVAPI32_
// same problem..
#define _RPCRT4_
#define _USER32_

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <delayimp.h>
#include <stdio.h>
#include <wtypes.h>

#include <dloaddef.h>

#if DBG

//
// DelayLoadAssertFailed/MYASSERT used instead of RtlAssert/ASSERT
// as dload is also compiled to run on Win95
//

VOID
WINAPI
DelayLoadAssertFailed(
    IN PCSTR FailedAssertion,
    IN PVOID FileName,
    IN ULONG LineNumber,
    IN PCSTR Message OPTIONAL
    );

VOID
WINAPI
AssertDelayLoadFailureMapsAreSorted(
    VOID
    );

#define MYASSERT(x)     if(!(x)) { DelayLoadAssertFailed(#x,__FILE__,__LINE__,NULL); }

#else

#define MYASSERT(x)

#endif


extern const LONG  g_lDelayLoad_NtStatus;
extern const ULONG g_ulDelayLoad_Win32Error;

#define DelayLoad_GetNtStatus()   (g_lDelayLoad_NtStatus)
#define DelayLoad_GetWin32Error() (g_ulDelayLoad_Win32Error)

VOID
WINAPI
DelayLoad_SetLastNtStatusAndWin32Error(
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\dload\lookup.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       L O O K U P . C
//
//  Contents:   Routines to find a handler for a DLL procedure.
//
//  Notes:
//
//  Author:     shaunco   21 May 1998
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop


VOID
WINAPI
AssertDelayLoadFailureMapsAreSorted (
    VOID
    )
{
#if DBG // Leave the function existing in free builds for binary compat on mixed checked/free,
        // since the checked in .lib is only free.
    UINT iDll, iProcName, iOrdinal;
    INT  nRet;
    CHAR pszMsg [1024];

    const DLOAD_DLL_ENTRY*      pDll;
    const DLOAD_PROCNAME_MAP*   pProcNameMap;
    const DLOAD_ORDINAL_MAP*    pOrdinalMap;

    for (iDll = 0;
         iDll < g_DllMap.NumberOfEntries;
         iDll++)
    {
        if (iDll >= 1)
        {
            nRet = strcmp (
                        g_DllMap.pDllEntry[iDll].pszDll,
                        g_DllMap.pDllEntry[iDll-1].pszDll);

            if (nRet <= 0)
            {
                sprintf (pszMsg,
                    "dload: rows %u and %u are out of order in dload!g_DllMap",
                    iDll-1, iDll);

                DelayLoadAssertFailed ( "" , __FILE__, __LINE__, pszMsg);
            }
        }

        pDll = g_DllMap.pDllEntry + iDll;
        pProcNameMap = pDll->pProcNameMap;
        pOrdinalMap  = pDll->pOrdinalMap;

        if (pProcNameMap)
        {
            MYASSERT (pProcNameMap->NumberOfEntries);

            for (iProcName = 0;
                 iProcName < pProcNameMap->NumberOfEntries;
                 iProcName++)
            {
                if (iProcName >= 1)
                {
                    nRet = strcmp (
                                pProcNameMap->pProcNameEntry[iProcName].pszProcName,
                                pProcNameMap->pProcNameEntry[iProcName-1].pszProcName);

                    if (nRet <= 0)
                    {
                        sprintf (pszMsg,
                            "dload: rows %u and %u of pProcNameMap are out "
                            "of order in dload!g_DllMap for pszDll=%s",
                            iProcName-1, iProcName, pDll->pszDll);

                        DelayLoadAssertFailed ( "" , __FILE__, __LINE__, pszMsg);
                    }
                }
            }
        }

        if (pOrdinalMap)
        {
            MYASSERT (pOrdinalMap->NumberOfEntries);

            for (iOrdinal = 0;
                 iOrdinal < pOrdinalMap->NumberOfEntries;
                 iOrdinal++)
            {
                if (iOrdinal >= 1)
                {
                    if (pOrdinalMap->pOrdinalEntry[iOrdinal].dwOrdinal <=
                        pOrdinalMap->pOrdinalEntry[iOrdinal-1].dwOrdinal)
                    {
                        sprintf (pszMsg,
                            "dload: rows %u and %u of pOrdinalMap are out "
                            "of order in dload!g_DllMap for pszDll=%s",
                            iOrdinal-1, iOrdinal, pDll->pszDll);

                        DelayLoadAssertFailed ( "" , __FILE__, __LINE__, pszMsg);
                    }
                }
            }
        }
    }
#endif
}


const DLOAD_DLL_ENTRY*
FindDll (
    LPCSTR pszDll
    )
{
    const DLOAD_DLL_ENTRY* pDll = NULL;

    CHAR pszDllLowerCased [MAX_PATH + 1] = {0};
    INT nResult;

    // These must be signed integers for the following binary search
    // to work correctly when iMiddle == 0 and nResult < 0.
    //
    INT iLow;
    INT iMiddle;
    INT iHigh;

    MYASSERT (pszDll);
    MYASSERT (strlen (pszDll) <= MAX_PATH);

    strncat (pszDllLowerCased, pszDll, sizeof(pszDllLowerCased)-1);
    _strlwr (pszDllLowerCased);

    iLow = 0;
    iHigh = g_DllMap.NumberOfEntries - 1;
    while (iHigh >= iLow)
    {
        iMiddle = (iLow + iHigh) / 2;
        nResult = strcmp (pszDllLowerCased, g_DllMap.pDllEntry[iMiddle].pszDll);

        if (nResult < 0)
        {
            iHigh = iMiddle - 1;
        }
        else if (nResult > 0)
        {
            iLow = iMiddle + 1;
        }
        else
        {
            MYASSERT (0 == nResult);
            pDll = &g_DllMap.pDllEntry[iMiddle];
            break;
        }
    }

    return pDll;
}

FARPROC
LookupHandlerByName (
    LPCSTR                      pszProcName,
    const DLOAD_PROCNAME_MAP*   pMap
    )
{
    FARPROC pfnHandler = NULL;

    INT nResult;

    // These must be signed integers for the following binary search
    // to work correctly when iMiddle == 0 and nResult < 0.
    //
    INT iLow;
    INT iMiddle;
    INT iHigh;

    MYASSERT (pszProcName);

    iLow = 0;
    iHigh = pMap->NumberOfEntries - 1;
    while (iHigh >= iLow)
    {
        iMiddle = (iLow + iHigh) / 2;
        nResult = strcmp (
                    pszProcName,
                    pMap->pProcNameEntry[iMiddle].pszProcName);

        if (nResult < 0)
        {
            iHigh = iMiddle - 1;
        }
        else if (nResult > 0)
        {
            iLow = iMiddle + 1;
        }
        else
        {
            MYASSERT (0 == nResult);
            pfnHandler = pMap->pProcNameEntry[iMiddle].pfnProc;
            break;
        }
    }

    return pfnHandler;
}

FARPROC
LookupHandlerByOrdinal (
    DWORD                       dwOrdinal,
    const DLOAD_ORDINAL_MAP*    pMap
    )
{
    FARPROC pfnHandler = NULL;

    DWORD dwOrdinalProbe;

    // These must be signed integers for the following binary search
    // to work correctly when iMiddle == 0 and dwOrdinal < dwOrdinalProbe.
    //
    INT iLow;
    INT iMiddle;
    INT iHigh;

    iLow = 0;
    iHigh = pMap->NumberOfEntries - 1;
    while (iHigh >= iLow)
    {
        iMiddle = (iLow + iHigh) / 2;
        dwOrdinalProbe = pMap->pOrdinalEntry[iMiddle].dwOrdinal;

        if (dwOrdinal < dwOrdinalProbe)
        {
            iHigh = iMiddle - 1;
        }
        else if (dwOrdinal > dwOrdinalProbe)
        {
            iLow = iMiddle + 1;
        }
        else
        {
            MYASSERT (dwOrdinal == dwOrdinalProbe);
            pfnHandler = pMap->pOrdinalEntry[iMiddle].pfnProc;
            break;
        }
    }

    return pfnHandler;
}

FARPROC
LookupHandler (
    LPCSTR pszDllName,
    LPCSTR pszProcName
    )
{
    FARPROC                 pfnHandler = NULL;
    const DLOAD_DLL_ENTRY*  pDll;

    MYASSERT (pszDllName);
    MYASSERT (pszProcName);

    // Find the DLL record if we have one.
    //
    pDll = FindDll (pszDllName);
    if (pDll)
    {
        // Now find the handler whether it be by name or ordinal.
        //
        if (!IS_INTRESOURCE(pszProcName) &&
            pDll->pProcNameMap)
        {
            pfnHandler = LookupHandlerByName (
                            pszProcName,
                            pDll->pProcNameMap);
        }
        else if (pDll->pOrdinalMap)
        {
            pfnHandler = LookupHandlerByOrdinal (
                            PtrToUlong(pszProcName),
                            pDll->pOrdinalMap);
        }
    }

    return pfnHandler;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\dload\downlevel_dload.c ===
#include "pch.h"
#pragma hdrstop

// External function prototypes
FARPROC
WINAPI
DelayLoadFailureHook (
    LPCSTR pszDllName,
    LPCSTR pszProcName
    );


//
// This function is for people who statically link to dload.lib so that
// the can get all of kernel32's dload error stubs on any os <= Whistler.
//

// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
//
// NOTE: You should ONLY use this if you have a binary that must run on NT4, win2k, win9x, etc.
//       If your binary is whistler or greater, use DLOAD_ERROR_HANDLER=kernel32 in your
//       sources file instead.
//
// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

FARPROC
WINAPI
Downlevel_DelayLoadFailureHook(
    UINT unReason,
    PDelayLoadInfo pDelayInfo
    )
{
    FARPROC ReturnValue = NULL;

    // For a failed LoadLibrary, we will return the HINSTANCE of this DLL.
    // This will cause the loader to try a GetProcAddress on our DLL for the
    // function.  This will subsequently fail and then we will be called
    // for dliFailGetProc below.
    if (dliFailLoadLib == unReason)
    {
        // HACKHACK (reinerf)
        //
        // For ORDINAL delayload failures we cannot just return our base addr and be done with everything. The problem 
        // is that the linker stub code will turn around and call GetProcAddress() some random ordinal which probably 
        // exists and is definately NOT the correct function.
        //
        // So to get around this problem we return -1 for a the hModule, which should cause GetProcAddress(-1, ...) to
        // always fail. This is good, because the linker code will call us back for the GetProcAddress failure and we
        // can then return the stub error handler proc.
        ReturnValue = (FARPROC)-1;
    }
    else if (dliFailGetProc == unReason)
    {
        // The loader is asking us to return a pointer to a procedure.
        // Lookup the handler for this DLL/procedure and, if found, return it.
        ReturnValue = DelayLoadFailureHook(pDelayInfo->szDll, pDelayInfo->dlp.szProcName);

        if (ReturnValue)
        {
            // Do this on behalf of the handler now that it is about to
            // be called.
            SetLastError(ERROR_MOD_NOT_FOUND);
        }
    }

    return ReturnValue;
}

extern const ULONG g_ulDelayLoad_Win32Error = ERROR_PROC_NOT_FOUND;
extern const LONG  g_lDelayLoad_NtStatus = STATUS_ENTRYPOINT_NOT_FOUND;

VOID
WINAPI
DelayLoad_SetLastNtStatusAndWin32Error(
    )
{
    SetLastError(g_ulDelayLoad_Win32Error);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\dload\pch.h ===
#pragma once

#pragma warning(disable:4201) /* nonstandard extension: nameless struct/union */
#pragma warning(disable:4100) /* unused parameter */
#pragma warning(disable:4211) /* nonstandard extension: redefined extern to static */
#include <dloadexcept.h>
#include "dload.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\dload\wmi.c ===
//
// Copyright (c) Microsoft Corporation
//
#include "pch.h"
#include "dloadexcept.h"
#pragma hdrstop

#define _WMI_SOURCE_
#include <wmium.h>

static
ULONG
WMIAPI
WmiNotificationRegistrationA(
    IN LPGUID Guid,
    IN BOOLEAN Enable,
    IN PVOID DeliveryInfo,
    IN ULONG_PTR DeliveryContext,
    IN ULONG Flags
    )
{
    return DelayLoad_GetWin32Error();
}

static
ULONG
WMIAPI
WmiNotificationRegistrationW(
    IN LPGUID Guid,
    IN BOOLEAN Enable,
    IN PVOID DeliveryInfo,
    IN ULONG_PTR DeliveryContext,
    IN ULONG Flags
    )
{
    return DelayLoad_GetWin32Error();
}


//
// !! WARNING !! The entries below must be in alphabetical order, and are CASE SENSITIVE (eg lower case comes last!)
//
DEFINE_PROCNAME_ENTRIES(wmi)
{
    DLPENTRY(WmiNotificationRegistrationA)
    DLPENTRY(WmiNotificationRegistrationW)
};

DEFINE_PROCNAME_MAP(wmi)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\prerelease.inc ===
#
# This file is used to control build options that should only appear in
# internal releases, and NOT the beta or RTM releases.  This controls
# features such as the GUI mode command prompt and the Win9x upgrade
# autostress option.
#
# To change, simply set PRERELEASE to 1 for private builds, or 0 for beta
# or RTM builds.
#
# **CHANGES HERE WILL REQUIRE A CLEAN BUILD OF THE SetupInfs and sub-components **
#

!ifndef PRERELEASE
PRERELEASE=0
!endif

!if $(PRERELEASE)
C_DEFINES=$(C_DEFINES) -DPRERELEASE
!endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\sources.inc ===
#
# This file is designed to be included from 2 levels below
# (ie, daytona\srv, daytona\wks, cairo\srv, or cairo\wks).
#

#
# include definition of PRERELEASE
#
!include prerelease.inc

TARGETNAME=inf
TARGETPATH=obj
TARGETTYPE=LIBRARY

#
# No explicit sources because build doesn't understand .inf files.
#
SOURCES=

#
# Use NTTARGETFILE0 macros to cause the infs to get built during
# the compile phase. We do this so that we can disable MP build for
# this directory, using BLOCK and DRAIN.
#
NTTARGETFILE0=make_infs
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\makefile.inc ===
#
# For daytona, this file is designed to be included from 3 levels below
# ie, dayona\$(LANGUAGE)inf\srv, or daytona\$(LANGUAGE)inf\wks
#
# Note: NEC98 builds go through this file twice, the second time
# with "ALT_PROJECT"=="NEC_98".  These latter produce a subset
# of binaries which are only used on NEC98 machines.
#


!IFNDEF LANGUAGE
LANGUAGE=usa
!ENDIF

#
# ANSI_CODEPAGE:  ANSI codepage for a given language.
#
# LANGUAGE_DRVCAB:  Offset to the language-specific list of files
#   contained in driver.cab:
#      setup\inf\win4\inf\lib\<language_drvcab>\<arch>\sorted.lst
#   European languages having a very similar set of files as US may
#   be able to leverage the US sorted.lst.  Far East languages have
#   extra files and their own language-specific list.
#
# LCID:  Locale ID in hex.
#
# UNITEXT_OPT:  Unitext.exe command line options to specify the ANSI codepage
#   for a given language.  Used for Multibuyte -> Unicode conversion.
#

# Defaults
ANSI_CODEPAGE=1252
LCID=409
LANGUAGE_DRVCAB=$(LANGUAGE)

!if "$(LANGUAGE)"=="ARA" || "$(LANGUAGE)"=="ara"
# Arabic
ANSI_CODEPAGE=1256
LCID=401

!elseif "$(LANGUAGE)"=="BR" || "$(LANGUAGE)"=="br"
# Portuguese, Brazilian
ANSI_CODEPAGE=1252
LCID=416

!elseif "$(LANGUAGE)"=="CHH" || "$(LANGUAGE)"=="chh"
# Chinese, Traditional (Hong Kong)
ANSI_CODEPAGE=950
LCID=C04

!elseif "$(LANGUAGE)"=="CHS" || "$(LANGUAGE)"=="chs"
# Chinese, Simplified
ANSI_CODEPAGE=936
LCID=804

!elseif "$(LANGUAGE)"=="CHT" || "$(LANGUAGE)"=="cht"
# Chinese, Traditional (Taiwan)
ANSI_CODEPAGE=950
LCID=404

!elseif "$(LANGUAGE)"=="CS" || "$(LANGUAGE)"=="cs"
# Czech
ANSI_CODEPAGE=1250
LCID=405

!elseif "$(LANGUAGE)"=="DA" || "$(LANGUAGE)"=="da"
# Danish
ANSI_CODEPAGE=1252
LCID=406

!elseif "$(LANGUAGE)"=="EL" || "$(LANGUAGE)"=="el"
# Greek
ANSI_CODEPAGE=1253
LCID=408

!elseif "$(LANGUAGE)"=="ES" || "$(LANGUAGE)"=="es"
# Spanish
ANSI_CODEPAGE=1252
LCID=C0A

!elseif "$(LANGUAGE)"=="FI" || "$(LANGUAGE)"=="fi"
# Finish
ANSI_CODEPAGE=1252
LCID=40b

!elseif "$(LANGUAGE)"=="FR" || "$(LANGUAGE)"=="fr"
# French
ANSI_CODEPAGE=1252
LCID=40C

!elseif "$(LANGUAGE)"=="GER" || "$(LANGUAGE)"=="ger"
# German
ANSI_CODEPAGE=1252
LCID=407

!elseif "$(LANGUAGE)"=="HEB" || "$(LANGUAGE)"=="heb"
# Hebrew
ANSI_CODEPAGE=1255
LCID=40D

!elseif "$(LANGUAGE)"=="HU" || "$(LANGUAGE)"=="hu"
# Hungarian
ANSI_CODEPAGE=1250
LCID=40e

!elseif "$(LANGUAGE)"=="IT" || "$(LANGUAGE)"=="it"
# Italian
ANSI_CODEPAGE=1252
LCID=410

!elseif "$(LANGUAGE)"=="JPN" || "$(LANGUAGE)"=="jpn"
# Japanese
ANSI_CODEPAGE=932
LCID=411

!elseif "$(LANGUAGE)"=="KOR" || "$(LANGUAGE)"=="kor"
# Korean
ANSI_CODEPAGE=949
LCID=412

!elseif "$(LANGUAGE)"=="NL" || "$(LANGUAGE)"=="nl"
# Dutch
ANSI_CODEPAGE=1252
LCID=413

!elseif "$(LANGUAGE)"=="NO" || "$(LANGUAGE)"=="no"
# Norwegian
ANSI_CODEPAGE=1252
LCID=414

!elseif "$(LANGUAGE)"=="PL" || "$(LANGUAGE)"=="pl"
# Polish
ANSI_CODEPAGE=1250
LCID=415

!elseif "$(LANGUAGE)"=="PSU" || "$(LANGUAGE)"=="psu"
# Pseudo-loc
ANSI_CODEPAGE=1252
LCID=409

!elseif "$(LANGUAGE)"=="PT" || "$(LANGUAGE)"=="pt"
# Portuguese
ANSI_CODEPAGE=1252
LCID=816

!elseif "$(LANGUAGE)"=="RU" || "$(LANGUAGE)"=="ru"
# Russian
ANSI_CODEPAGE=1251
LCID=419

!elseif "$(LANGUAGE)"=="SV" || "$(LANGUAGE)"=="sv"
# Swedish
ANSI_CODEPAGE=1252
LCID=41D

!elseif "$(LANGUAGE)"=="TR" || "$(LANGUAGE)"=="tr"
# Turkish
ANSI_CODEPAGE=1254
LCID=41F

!endif

UNITEXT_OPT=-m -$(ANSI_CODEPAGE)

!IF "$(TARGET_DIRECTORY)"=="i386"  || "$(TARGET_DIRECTORY)"=="I386"
PLATFORM_SWITCH=i
!ELSEIF "$(TARGET_DIRECTORY)"=="ia64"  || "$(TARGET_DIRECTORY)"=="IA64"
PLATFORM_SWITCH=m
!ELSEIF "$(TARGET_DIRECTORY)"=="amd64"  || "$(TARGET_DIRECTORY)"=="AMD64"
PLATFORM_SWITCH=a
!ELSE
! ERROR Invalid Platform Switch for infs
!ENDIF


STAMP=stampinf -f $@
PREFLAGS=/DLANGUAGE_ID=0x0$(LCID) -nologo /EP
!if $(PRERELEASE)
PREFLAGS=/DPRERELEASE $(PREFLAGS)
!endif
PREFILTFLAGS=/EP -DPLATFORM_SWITCH='$(PLATFORM_SWITCH)' -DPRODSWITCH='$(PRODSWITCH)'

!IFDEF _ALT_LANG_SRC
_LNG = $(_ALT_LANG_SRC)
!ELSE
_LNG=..\..\..\$(LANGUAGE)
!ENDIF
_LIBLNG=..\..\..\lib\$(LANGUAGE)
_INX=..\..\..
_INF=$(O)
_RSINF=$(O)\realsign

BUILD_COVINF=0
!if "$(LANGUAGE)"=="usa" || "$(LANGUAGE)"=="USA"
!if !$(WIN64)
_COVINF=$(O)\covinf
_RSCOVINF=$(O)\covinf\realsign
BUILD_COVINF=1
!endif
!endif

STRIPCHAR=call $(_INX)\stripchar.cmd

!ifndef BUILD_SPECIFIC_INFS

!IF "$(ALT_PROJECT_TARGET)" == "CHH"
make_infs:$(O)\hivesft.inf
!ELSE
make_infs:$(O)\layout.inf    \
          $(_RSINF)\layout.inf  \
!IF $(BUILD_COVINF)
          $(_COVINF)\layout.inx  \
          $(_COVINF)\layout.inf  \
          $(_RSCOVINF)\layout.inf  \
!endif
          $(O)\testroot.cer  \
!IF $(BUILD_COVINF)
          $(_COVINF)\testroot.cer  \
!endif
          $(O)\layout.inx    \
          $(O)\layout.txt    \
          $(O)\1394.inf      \
          $(O)\61883.inf     \
          $(O)\accessor.inf  \
!if $(WIN64)
          $(O)\accessor.wow  \
!endif
!IF !$(WIN64)
          $(O)\acerscan.inf  \
!endif
          $(O)\acpi.inf      \
          $(O)\apps.inf      \
          $(O)\apcompat.inf  \
!if $(WIN64)
          $(O)\apcompat.wow  \
!endif
!if "$(PRODSWITCH)" == "w"
          $(O)\apphlpui.inf  \
!endif
          $(O)\asroc.inf     \
          $(O)\avc.inf       \
          $(O)\battery.inf   \
          $(O)\bda.inf       \
!if $(386)
          $(O)\bfcab.inf     \
          $(O)\bfax.inf      \
!endif
          $(O)\biomtric.inf \
          $(O)\biosinfo.inf  \
!if $(386)
          $(O)\brmfcmdm.inf  \
          $(O)\brmfcmf.inf   \
          $(O)\brmfcsto.inf  \
          $(O)\brmfcumd.inf  \
          $(O)\brmfcwia.inf  \
          $(O)\brmfport.inf  \
!endif
          $(O)\camdsh20.inf  \
          $(O)\camvid20.inf  \
          $(O)\camvid30.inf  \
          $(O)\ccdecode.inf   \
          $(O)\cdrom.inf     \
          $(O)\certclas.inf  \
          $(O)\communic.inf  \
!if $(WIN64)
          $(O)\communic.wow  \
!endif
          $(O)\compatws.inf  \
          $(O)\cpu.inf       \
          $(O)\cyclad-z.inf  \
          $(O)\cyclom-y.inf  \
          $(O)\cyyport.inf   \
          $(O)\cyzport.inf   \
          $(O)\dcfirst.inf   \
          $(O)\dcup.inf      \
          $(O)\dcup5.inf     \
          $(O)\defdcgpo.inf  \
          $(O)\defltdc.inf   \
          $(O)\defltsv.inf   \
          $(O)\defltwk.inf   \
          $(O)\defltp.inf    \
!IF $(BUILD_COVINF)
          $(_COVINF)\defltsv.inf \
          $(_COVINF)\defltwk.inf \
!endif
          $(O)\devxprop.inf  \
          $(O)\dfrg.inf      \
          $(O)\disk.inf      \
!IF !$(WIN64)
          $(O)\dimaps.inf    \
!endif
          $(O)\dispdet.inf   \
          $(O)\display.inf   \
          $(O)\dmreg.inf     \
          $(O)\dosnet.inf    \
          $(_RSINF)\dosnet.inf  \
!IF $(BUILD_COVINF)
          $(_COVINF)\dosnet.inf    \
          $(_RSCOVINF)\dosnet.inf \
!endif
          $(O)\dot4.inf      \
          $(O)\dot4prt.inf   \
          $(O)\dpup.inf      \
          $(O)\drivercab.inf \
          $(O)\dshowext.inf  \
          $(O)\dsup.inf      \
          $(O)\dsupt.inf     \
          $(O)\dvd.inf       \
          $(O)\dwup.inf      \
!IF !$(WIN64)
          $(O)\epcfw2k.inf   \
          $(O)\epstw2k.inf   \
          $(O)\epsnscan.inf  \
!endif
          $(O)\epsnmfp.inf   \
          $(O)\epstw2k.inf   \
!if "$(PRODSWITCH)" == "w"
          $(O)\ermui.inf     \
!endif
!IF $(BUILD_COVINF)
          $(_COVINF)\dsup.inf \
          $(_COVINF)\dsupt.inf \
          $(_COVINF)\dwup.inf \
!endif
          $(O)\exclude.inf   \
          $(O)\fdc.inf       \
          $(O)\filegen.inf   \
          $(O)\fjtscan.inf   \
          $(O)\flash.inf     \
          $(O)\flpydisk.inf  \
          $(O)\font.inf      \
!if !$(WIN64)
          $(O)\gameport.inf  \
!endif
          $(O)\games.inf     \
!if $(WIN64)
          $(O)\games.wow     \
!endif
          $(O)\genprint.inf  \
!if "$(PRODSWITCH)" == "w"
          $(O)\guidrvs.inf   \
!endif
          $(O)\hal.inf       \
          $(O)\hidserv.inf   \
          $(O)\hisecws.inf   \
          $(O)\hisecdc.inf   \
          $(O)\hivecls.inf   \
          $(O)\hivedef.inf   \
          $(O)\hivesft.inf   \
          $(O)\hivesys.inf   \
!if $(WIN64)
          $(O)\hivcls32.inf  \
          $(O)\hivsft32.inf  \
!endif
!IF $(BUILD_COVINF)
          $(_COVINF)\hivesys.inf   \
!endif
          $(O)\hiveusd.inf   \
	  $(O)\homepage.inf  \
          $(O)\hotfix.inf    \
!IF !$(WIN64)
          $(O)\hpdigwia.inf  \
!endif
          $(O)\hpojscan.inf  \
          $(O)\hpscan.inf    \
          $(O)\ibmvcap.inf   \
!if $(IA64)
          $(O)\IA32Exec.inf  \
!endif
          $(O)\icwnt5.inf    \
!if $(WIN64)
          $(O)\icwnt5.wow    \
!endif
          $(O)\ie.inf        \
          $(O)\ieaccess.inf  \
!if "$(PRODSWITCH)" == "s"
          $(O)\ieharden.inf  \
          $(O)\iesacls.inf  \
!endif
!if $(WIN64)
          $(O)\ie.wow        \
!endif
!if "$(PRODSWITCH)" == "w"
          $(O)\ie5ui.inf     \
!endif
          $(O)\icam3.inf     \
          $(O)\icam4usb.inf  \
          $(O)\icam5usb.inf  \
          $(O)\image.inf     \
          $(O)\input.inf     \
          $(O)\install.ins   \
          $(O)\intl.inf      \
!if $(WIN64)
          $(O)\intl.wow      \
          $(O)\intlinfa.wow  \
!endif
          $(O)\ippocm.inf    \
          $(O)\irbus.inf     \
!if $(WIN64)
          $(O)\is_wow64.inf  \
!endif
          $(O)\keyboard.inf  \
          $(O)\kdk2x0.inf    \
          $(O)\kdkscan.inf   \
          $(O)\ks.inf        \
          $(O)\kscaptur.inf  \
          $(O)\ksfilter.inf  \
!if "$(PRODSWITCH)" == "w"
          $(O)\langinst.inf  \
!endif
         $(O)\legcydrv.inf  \
!if $(386)
          $(O)\lwusbhid.inf  \
          $(O)\lwngmadi.inf  \
!endif
          $(O)\machine.inf   \
          $(O)\mchgr.inf     \
          $(O)\mdac.inf      \
!if $(WIN64)
          $(O)\mdac.wow      \
!endif
          $(O)\mdacwx86.inf  \
          $(O)\memcard.inf   \
          $(O)\mednames.txt  \
          $(O)\memory.inf    \
          $(O)\memstpci.inf  \
          $(O)\mf.inf        \
          $(O)\mfsocket.inf  \
!if $(386)
          $(O)\migdb.inf     \
!endif
          $(O)\minioc.inf    \
          $(O)\mmdriver.inf  \
          $(O)\mmopt.inf     \
!if $(WIN64)
          $(O)\mmopt.wow     \
!endif
!if !$(WIN64)
!if "$(PRODSWITCH)" == "w"
          $(O)\moviemui.inf  \
!endif
!endif
          $(O)\mpe.inf       \
          $(O)\mscpqpa1.inf   \
          $(O)\msdv.inf      \
          $(O)\mshdc.inf     \
          $(O)\msinfo32.inf  \
!if $(WIN64)
          $(O)\msinfo32.wow  \
!endif
          $(O)\msmail.inf    \
          $(O)\msmouse.inf   \
!IF !$(WIN64)
          $(O)\msmscsi.inf   \
          $(O)\msmusb.inf    \
!endif
          $(O)\msnike.inf   \
          $(O)\msoe50.inf    \
!if $(WIN64)
          $(O)\msoe50.wow    \
!endif
          $(O)\msports.inf   \
          $(O)\msrio8.inf   \
          $(O)\msrio.inf    \
          $(O)\mstape.inf    \
          $(O)\mstask.inf    \
!if $(WIN64)
          $(O)\mstask.wow    \
!endif
!if "$(PRODSWITCH)" == "w"
          $(O)\mui.inf       \
!endif
!if $(WIN64)
!if "$(PRODSWITCH)" == "w"
          $(O)\muiwow64.inf     \
!endif
!endif
          $(O)\multimed.inf  \
!if $(WIN64)
          $(O)\multimed.wow  \
!endif
          $(O)\multiprt.inf  \
          $(O)\mxboard.inf   \
          $(O)\mxport.inf    \
          $(O)\nabtsfec.inf  \
          $(O)\ndisip.inf    \
          $(O)\netaarps.inf  \
!IF "$(PRODSWITCH)" == "s"
          $(O)\netatlk.inf   \
!ENDIF
          $(O)\netauni.inf   \
!if "$(PRODSWITCH)" == "w"
          $(O)\netbeac.inf  \
!endif
          $(O)\netcis.inf    \
          $(O)\netcmak.inf     \
          $(O)\netcps.inf     \
          $(O)\netdav.inf    \
          $(O)\netdhoc.inf   \
          $(O)\netdhcps.inf  \
          $(O)\netdns.inf    \
          $(O)\netgpc.inf    \
          $(O)\netias.inf    \
          $(O)\netip6.inf    \
          $(O)\netiprip.inf  \
          $(O)\netirda.inf   \
          $(O)\netlanem.inf  \
          $(O)\netlanep.inf  \
          $(O)\netlpd.inf    \
!IF $(386)
          $(O)\netmacpr.inf  \
!ENDIF
          $(O)\netmacsv.inf  \
          $(O)\netmscli.inf  \
          $(O)\netnb.inf     \
          $(O)\netnbf.inf    \
!IF "$(PLATFORM_SWITCH)" == "i"
          $(O)\netnwcli.inf  \
          $(O)\netnwlnk.inf  \
!ENDIF
          $(O)\netoc.inf     \
          $(O)\netpgm.inf    \
          $(O)\netpsa.inf    \
          $(O)\netpschd.inf  \
          $(O)\netrasa.inf   \
          $(O)\netrass.inf   \
          $(O)\netrast.inf   \
          $(O)\netrwan.inf   \
!IF "$(PLATFORM_SWITCH)" == "i"
          $(O)\netsap.inf    \
!ENDIF
          $(O)\netserv.inf   \
          $(O)\netsfn.inf    \
          $(O)\netsfnt.inf   \
          $(O)\netsnmp.inf   \
          $(O)\nettcpip.inf  \
          $(O)\nettpsmp.inf  \
          $(O)\nettun.inf    \
          $(O)\netupg.inf    \
          $(O)\netupnp.inf   \
          $(O)\netupnph.inf  \
          $(O)\netwins.inf   \
          $(O)\netwlbs.inf   \
          $(O)\netwlbsm.inf  \
          $(O)\netwzc.inf    \
          $(O)\ntapm.inf     \
          $(O)\ntautorun.inf \
!IF !$(WIN64)
          $(O)\ntgrip.inf  \
!endif
          $(O)\ntprint.inf   \
          $(O)\ocmri.inf     \
          $(O)\oeaccess.inf  \
          $(O)\oemmui.inf    \
          $(O)\oobe.inf      \
!if "$(PRODSWITCH)" == "w"
          $(O)\oobemui.inf   \
!endif
          $(O)\optional.inf  \
!if $(WIN64)
          $(O)\optional.wow  \
!endif
          $(O)\ovcam.inf     \
          $(O)\ovcomp.inf    \
          $(O)\ovsound.inf   \
          $(O)\pcmcia.inf    \
!if "$(PRODSWITCH)" == "w"
          $(O)\perfmui.inf     \
!endif
          $(O)\perms.inf     \
          $(O)\phdsext.inf   \
          $(O)\phil1vid.inf  \
          $(O)\phil2vid.inf  \
          $(O)\phildec.inf   \
          $(O)\pinball.inf   \
!if $(WIN64)
          $(O)\pinball.wow   \
!endif
          $(O)\pchmui.inf    \
          $(O)\pchealth.inf  \
!IF !$(WIN64)
          $(O)\pmxmcro.inf   \
!endif
          $(O)\pnpscsi.inf   \
          $(O)\pop3oc.inf    \
          $(O)\ppa.inf       \
          $(O)\ppa3.inf      \
          $(O)\printupg.inf  \
          $(O)\prod128.ini   \
          $(O)\prodspec.ini  \
          $(O)\profsec.inf   \
          $(O)\prtupg9x.inf  \
          $(O)\ptpusb.inf  \
          $(O)\ramdisk.inf   \
          $(O)\reminst.inf   \
          $(O)\ricoh.inf  \
          $(O)\rinorprt.sif  \
          $(O)\riprep.inf    \
          $(O)\ristndrd.sif  \
          $(O)\rootsec.inf   \
          $(O)\rsoptcom.inf  \
          $(O)\rsoptwks.inf  \
!IF !$(WIN64)
          $(O)\sakit.inf     \
          $(O)\sakitmui.inf     \
          $(O)\AuthMan.inf   \
!endif
          $(O)\sa.inf        \
          $(O)\wd.inf        \
          $(O)\sbp2.inf      \
          $(O)\sceregvl.inf  \
!if !$(WIN64)
          $(O)\scsi.inf      \
!endif
          $(O)\scsidev.inf   \
          $(O)\sdwndr2k.inf  \
          $(O)\securedc.inf  \
          $(O)\securews.inf  \
          $(O)\secrecs.inf   \
          $(O)\sfcgen.inf    \
          $(O)\shell.inf     \
          $(O)\shl_img.inf   \
!if "$(PRODSWITCH)" == "w"
          $(O)\shellmui.inf  \
!endif
!if "$(PRODSWITCH)" == "w"
          $(O)\skinsmui.inf  \
          $(O)\wmtrmui.inf  \
!endif
          $(O)\slip.inf      \
          $(O)\smartcrd.inf  \
          $(O)\sonypvu1.inf  \
!if !$(WIN64)
          $(O)\sr.inf        \
!endif
          $(O)\srchasst.inf  \
!if "$(PRODSWITCH)" == "w"
          $(O)\srchmui.inf     \
!endif
!IF !$(WIN64)
#          $(O)\srusbusd.inf  \
!endif
          $(O)\sslaccel.inf  \
          $(O)\sti.inf       \
          $(O)\streamip.inf  \
          $(O)\swflash.inf   \
          $(O)\swnt.inf      \
          $(O)\sysoc.inf     \
          $(O)\syscomp.inf   \
          $(O)\syssetup.inf  \
          $(O)\syssetup.inx  \
!if $(WIN64)
          $(O)\syssetup.wow  \
!endif
!IF $(BUILD_COVINF)
          $(_COVINF)\syssetup.inf  \
!endif
!if $(386)
!if "$(PRODSWITCH)" == "w"
          $(O)\tablet.inf   \
!endif
!endif
          $(O)\tape.inf      \
!if $(386)
!if "$(PRODSWITCH)" == "w"
          $(O)\tourmui.inf   \
!endif
!endif
          $(O)\tsbvcap.inf   \
          $(O)\txtsetup.sif  \
          $(O)\txtsetup.inx  \
          $(_RSINF)\txtsetup.sif \
!IF $(BUILD_COVINF)
          $(_COVINF)\txtsetup.sif  \
          $(_RSCOVINF)\txtsetup.sif \
!endif
!if !$(WIN64)
          $(O)\umax.inf      \
          $(O)\umaxpp.inf    \
!endif
          $(O)\uddi.inf      \
!if "$(PRODSWITCH)" == "w"
          $(O)\uddimui.inf   \
!endif
          $(O)\unattend.txt  \
          $(O)\unknown.inf   \
          $(O)\update.inf    \
          $(O)\usb.inf       \
          $(O)\usbport.inf   \
          $(O)\usbstor.inf   \
          $(O)\usbprint.inf  \
!if $(386)
          $(O)\usermig.inf   \
!endif
          $(O)\vgx.inf    \
!if $(WIN64)
          $(O)\vgx.wow  \
!endif
          $(O)\volume.inf    \
          $(O)\volsnap.inf   \
!if $(386)
          $(O)\vscandb.inf   \
!endif
          $(O)\wdmjoy.inf    \
!if $(WIN64)
!if "$(PRODSWITCH)" == "w"
          $(O)\wie5ui.inf     \
!endif
!endif
!if $(WIN64)
!if "$(PRODSWITCH)" == "w"
          $(O)\wermui.inf     \
!endif
!endif
!if $(386)
          $(O)\win95upg.inf  \
          $(O)\wkstamig.inf  \
!endif
          $(O)\au.inf \
          $(O)\wab50.inf     \
!if $(WIN64)
          $(O)\wab50.wow     \
!endif
          $(O)\wbemcrrl.inf  \
          $(O)\wbemfwrd.inf  \
          $(O)\wbemmsi.inf   \
          $(O)\wbemoc.inf    \
!if $(WIN64)
          $(O)\wbemoc.wow    \
!endif
          $(O)\wbemsnmp.inf  \
          $(O)\wceusbsh.inf \
!if "$(PRODSWITCH)" == "w"
          $(O)\wmprfmui.inf  \
!endif
          $(O)\sapi5.inf     \
          $(O)\wordpad.inf   \
!if $(WIN64)
          $(O)\wordpad.wow   \
          $(O)\wowexcp.txt   \
          $(O)\wowfile.cmn    \
          $(O)\wowfile.inf   \
          $(O)\wowfiled.inf  \
          $(O)\wowlist.inf   \
          $(O)\wowfrege.inf  \
          $(O)\wowfregc.inf  \
          $(O)\wowfrego.inf  \
!endif
          $(O)\wsh.inf       \
!if $(WIN64)
          $(O)\wsh.wow  \
!endif
          $(O)\wstcodec.inf  \
          $(O)\xscan_xp.inf
!ENDIF

!else           # ifdef BUILD_SPECIFIC_INFS

#
# Dev time saver -- build only the $(O) targets specified by
# BUILD_SPECIFIC_INFS. This variable is a space-separated list such as
#
# set BUILD_SPECIFIC_INFS=layout.inf syssetup.inf
#
# Does not support targets other than those in obj\i386, obj\amd64, or obj\ia64.
#
# NOTE: NMAKE does not support variable replacement strings in macro
# search/replace. So define inference rules for known $(O) combinations
#

! if "$(O)" == "obj\i386"

make_infs:$(O)\$(BUILD_SPECIFIC_INFS: = obj\i386\)

! else if "$(O)" == "obj\amd64"

make_infs:$(O)\$(BUILD_SPECIFIC_INFS: = obj\amd64\)

! else if "$(O)" == "obj\ia64"

make_infs:$(O)\$(BUILD_SPECIFIC_INFS: = obj\ia64\)

! endif

!endif          # else BUILD_SPECIFIC_INFS


# NOTE: Set NWSBINPLACE_CMD as empty in ent flavor to avoid binplace conflict
# when building Srv and Ent simultaneously on mulitple processor build machines
#

!IFDEF BINPLACE_CMD
TSBINPLACE_CMD=$(BINPLACE_CMD)
RSBINPLACE_CMD=$(BINPLACE_CMD:binplace=binplace -b realsign)
COVER_TSBINPLACE_CMD=$(BINPLACE_CMD:binplace=binplace -b covinf)
COVER_RSBINPLACE_CMD=$(BINPLACE_CMD:binplace=binplace -b covinf\realsign)
WIN9XUPGBINPLACE_CMD=$(BINPLACE_CMD)
NWSBINPLACE_CMD=$(TSBINPLACE_CMD)
!ENDIF

!IFDEF PERSONALINF
!IFDEF BINPLACE_CMD
TSBINPLACE_CMD=$(BINPLACE_CMD:binplace=binplace -b perinf)
RSBINPLACE_CMD=$(BINPLACE_CMD:binplace=binplace -b perinf\realsign)
COVER_TSBINPLACE_CMD=$(BINPLACE_CMD:binplace=binplace -b covinf\perinf)
COVER_RSBINPLACE_CMD=$(BINPLACE_CMD:binplace=binplace -b covinf\perinf\realsign)
WIN9XUPGBINPLACE_CMD=$(BINPLACE_CMD:binplace=binplace -b ..\..\perinf\winnt32\win9xupg)
NWSBINPLACE_CMD=
!ENDIF
!ENDIF

!IFDEF SBSINF
!IFDEF BINPLACE_CMD
TSBINPLACE_CMD=$(BINPLACE_CMD:binplace=binplace -b sbsinf)
RSBINPLACE_CMD=$(BINPLACE_CMD:binplace=binplace -b sbsinf\realsign)
COVER_TSBINPLACE_CMD=$(BINPLACE_CMD:binplace=binplace -b covinf\sbsinf)
COVER_RSBINPLACE_CMD=$(BINPLACE_CMD:binplace=binplace -b covinf\sbsinf\realsign)
WIN9XUPGBINPLACE_CMD=$(BINPLACE_CMD:binplace=binplace -b ..\..\sbsinf\winnt32\win9xupg)
NWSBINPLACE_CMD=
!ENDIF
!ENDIF

!IFDEF BLAINF
!IFDEF BINPLACE_CMD
TSBINPLACE_CMD=$(BINPLACE_CMD:binplace=binplace -b blainf)
RSBINPLACE_CMD=$(BINPLACE_CMD:binplace=binplace -b blainf\realsign)
COVER_TSBINPLACE_CMD=$(BINPLACE_CMD:binplace=binplace -b covinf\blainf)
COVER_RSBINPLACE_CMD=$(BINPLACE_CMD:binplace=binplace -b covinf\blainf\realsign)
WIN9XUPGBINPLACE_CMD=$(BINPLACE_CMD:binplace=binplace -b ..\..\blainf\winnt32\win9xupg)
NWSBINPLACE_CMD=
!ENDIF
!ENDIF

!IFDEF SERVERINF
!IFDEF BINPLACE_CMD
TSBINPLACE_CMD=$(BINPLACE_CMD:binplace=binplace -b srvinf)
RSBINPLACE_CMD=$(BINPLACE_CMD:binplace=binplace -b srvinf\realsign)
COVER_TSBINPLACE_CMD=$(BINPLACE_CMD:binplace=binplace -b covinf\srvinf)
COVER_RSBINPLACE_CMD=$(BINPLACE_CMD:binplace=binplace -b covinf\srvinf\realsign)
WIN9XUPGBINPLACE_CMD=$(BINPLACE_CMD:binplace=binplace -b ..\..\srvinf\winnt32\win9xupg)
NWSBINPLACE_CMD=$(TSBINPLACE_CMD:binplace -b srvinf=binplace -b nws)
!ENDIF
!ENDIF

!IFDEF ENTERPRISEINF
!IFDEF BINPLACE_CMD
TSBINPLACE_CMD=$(BINPLACE_CMD:binplace=binplace -b entinf)
RSBINPLACE_CMD=$(BINPLACE_CMD:binplace=binplace -b entinf\realsign)
COVER_TSBINPLACE_CMD=$(BINPLACE_CMD:binplace=binplace -b covinf\entinf)
COVER_RSBINPLACE_CMD=$(BINPLACE_CMD:binplace=binplace -b covinf\entinf\realsign)
WIN9XUPGBINPLACE_CMD=$(BINPLACE_CMD:binplace=binplace -b ..\..\entinf\winnt32\win9xupg)
NWSBINPLACE_CMD=
!ENDIF
!ENDIF

!IFDEF DATACENTERINF
!IFDEF BINPLACE_CMD
TSBINPLACE_CMD=$(BINPLACE_CMD:binplace=binplace -b dtcinf)
RSBINPLACE_CMD=$(BINPLACE_CMD:binplace=binplace -b dtcinf\realsign)
COVER_TSBINPLACE_CMD=$(BINPLACE_CMD:binplace=binplace -b covinf\dtcinf)
COVER_RSBINPLACE_CMD=$(BINPLACE_CMD:binplace=binplace -b covinf\dtcinf\realsign)
WIN9XUPGBINPLACE_CMD=$(BINPLACE_CMD:binplace=binplace -b ..\..\dtcinf\winnt32\win9xupg)
!ENDIF
!ENDIF

$(O)\layout.inx : $(_INX)\layout.inx
    $(CC) $(PREFLAGS) $** > $@
!if "$(PRODSWITCH)" == "w"
    $(TSBINPLACE_CMD)
!endif

$(_COVINF)\layout.inx : $(_INX)\layout.inx $(_INX)\$(@B).mcv
    call MergeFiles.cmd $(_INX)\layout.inx $(_INX)\$(@B).mcv $(_COVINF)\layout.tmp
    $(CC) $(PREFLAGS) $(_COVINF)\layout.tmp > $@
    del $(_COVINF)\layout.tmp
!if "$(PRODSWITCH)" == "w"
    $(COVER_TSBINPLACE_CMD)
!endif

$(O)\layout.txt : $(_LNG)\layout.txt \
                  $(_LNG)\mednames.txt
    $(CC) $(PREFLAGS) $** > $@
    copy $(O)\$(@B).tmp1 + $(_LNG)\mednames.txt $@
!if "$(PRODSWITCH)" == "w"
    $(TSBINPLACE_CMD)
!endif
    del $(O)\$(@B).tmp1

$(O)\syssetup.inx : $(_INX)\syssetup.inx
    $(CC) $(PREFLAGS) $** > $@


$(O)\txtsetup.inx : $(_INX)\txtsetup.inx
    $(CC) $(PREFLAGS) $** > $@

$(O)\dosnet.inx : $(_INX)\dosnet.inx
    $(CC) $(PREFLAGS) $** > $@

$(_COVINF)\dosnet.inx : $(_INX)\dosnet.inx
    $(CC) $(PREFLAGS) $** > $@

$(_RSCOVINF)\dosnet.inx : $(_INX)\dosnet.inx
    md $(_RSCOVINF)
    $(CC) $(PREFLAGS) $** > $@

$(O)\mednames.txt : $(_LNG)\mednames.txt
    $(CC) $(PREFLAGS) $** > $@
!if "$(PRODSWITCH)" == "w"
    $(TSBINPLACE_CMD)
!endif

#
# Explicit dependencies. We do it this way instead of trying to use rules
# because !#@&^$#% nmake doesn't allow multiple 'source' extensions
# when defining a rule, and we need to express a dependency between
# .txt OR .inx to the final .inf.
#

#
# 'Standard' (win95-style) infs. The rules are all the same.
#
# Real-signed layout.inf
#
$(_RSINF)\layout.inf: $(O)\layout.inx \
!IF $(WIN64)
                      $(O)\wowlist.inf $(O)\wowfile.inf \
!endif
                      $(O)\layout.txt
    copy $(O)\$(@B).inx+$(O)\$(@B).txt $(O)\$(@B).tmp1
    prodfilt -s $(O)\$(@B).tmp1 $(O)\$(@B).tmp2 +$(PRODSWITCH)
    prodfilt -s $(O)\$(@B).tmp2 $@ +$(PLATFORM_SWITCH)
!IF $(WIN64)
    copy $(@) $(O)\$(@B).tmp3
    copy $(O)\$(@B).inx+$(O)\$(@B).txt $(O)\$(@B).tmp1
    prodfilt -s $(O)\$(@B).tmp1 $(O)\$(@B).tmp2 +$(PRODSWITCH)
    prodfilt -s $(O)\$(@B).tmp2 $(O)\$(@B).tmp1 +i
    wowlist -i $(O)\$(@B).tmp1 -c $(O)\wowlist.inf -o $(O)\$(@B).tmp2 -ac -h $(O)\wowfile.inf -f w 2>NUL
    copy $(O)\$(@B).tmp3+$(O)\$(@B).tmp2 $(@)
    @del $(O)\$(@B).tmp3
!ENDIF
    @del $(O)\$(@B).tmp1
    @del $(O)\$(@B).tmp2
    perl $(_INX)\reorder_layout.pl $@ $(_INX)\layout.ord
    @del $@
    move $@.new $@
!IF $(WIN64) && ("$(LANGUAGE)" == "JPN"  || "$(LANGUAGE)" == "jpn")
    perl $(_INX)\inftest.pl $@ /B /$(PLATFORM_SWITCH)
!ELSE
    inftest $@ /B /$(PLATFORM_SWITCH)
!ENDIF
    $(RSBINPLACE_CMD)

#
# Coverage Real-signed layout.inf
#
$(_RSCOVINF)\layout.inf: $(O)\layout.inx $(_INX)\$(@B).mcv $(_RSCOVINF)\dosnet.inx \
!IF $(WIN64)
                      $(O)\wowlist.inf $(O)\wowfile.inf \
!endif
                      $(O)\layout.txt
    copy $(O)\$(@B).inx+$(O)\$(@B).txt $(O)\$(@B).tmp1
    call MergeFiles.cmd $(O)\$(@B).tmp1 $(_INX)\$(@B).mcv $(O)\$(@B).tmp2
    prodfilt -s $(O)\$(@B).tmp2 $(O)\$(@B).tmp1 +$(PRODSWITCH)
    prodfilt -s $(O)\$(@B).tmp1 $(O)\$(@B).tmp2 +$(PLATFORM_SWITCH)
    copy $(O)\$(@B).tmp2 $@
    @del $(O)\$(@B).tmp1
    @del $(O)\$(@B).tmp2
    perl $(_INX)\reorder_layout.pl $@ $(_INX)\layout.ord
    @del $@
    move $@.new $@
    $(COVER_RSBINPLACE_CMD)

#
# Test-signed layout.inf
#
$(O)\layout.inf: $(O)\layout.inx $(_INX)\layout.tst \
!IF $(WIN64)
                      $(O)\wowlist.inf $(O)\wowfile.inf \
!endif
                      $(O)\layout.txt
    copy $(O)\$(@B).inx+$(_INX)\$(@B).tst+$(O)\$(@B).txt $(O)\$(@B).tmp1
    prodfilt -s $(O)\$(@B).tmp1 $(O)\$(@B).tmp2 +$(PRODSWITCH)
    prodfilt -s $(O)\$(@B).tmp2 $@ +$(PLATFORM_SWITCH)
!IF $(WIN64)
    copy $(@) $(O)\$(@B).tmp3
    copy $(O)\$(@B).inx+$(O)\$(@B).txt $(O)\$(@B).tmp1
    prodfilt -s $(O)\$(@B).tmp1 $(O)\$(@B).tmp2 +$(PRODSWITCH)
    prodfilt -s $(O)\$(@B).tmp2 $(O)\$(@B).tmp1 +i
    wowlist -i $(O)\$(@B).tmp1 -c $(O)\wowlist.inf -o $(O)\$(@B).tmp2 -ac -h $(O)\wowfile.inf -f w 2>NUL
    copy $(O)\$(@B).tmp3+$(O)\$(@B).tmp2 $(@)
    @del $(O)\$(@B).tmp3
!ENDIF
    @del $(O)\$(@B).tmp1
    @del $(O)\$(@B).tmp2
    perl $(_INX)\reorder_layout.pl $@ $(_INX)\layout.ord
    @del $@
    move $@.new $@
!IF $(WIN64) && ("$(LANGUAGE)" == "JPN"  || "$(LANGUAGE)" == "jpn")
    perl $(_INX)\inftest.pl $@ /B /$(PLATFORM_SWITCH)
!ELSE
    inftest $@ /B /$(PLATFORM_SWITCH)
!ENDIF
    $(TSBINPLACE_CMD)

#
# Coverage Test-signed layout.inf
#
$(_COVINF)\layout.inf: $(_COVINF)\layout.inx \
!IF $(WIN64)
                      $(O)\wowlist.inf $(O)\wowfile.inf \
!endif
                      $(_INX)\layout.tst
    copy $(_COVINF)\layout.inx+$(_INX)\$(@B).tst+$(O)\$(@B).txt $(O)\$(@B).tmp1
    prodfilt -s $(O)\$(@B).tmp1 $(O)\$(@B).tmp2 +$(PRODSWITCH)
    prodfilt -s $(O)\$(@B).tmp2 $(O)\$(@B).tmp1 +$(PLATFORM_SWITCH)
    copy $(O)\$(@B).tmp1 $@
    @del $(O)\$(@B).tmp1
    @del $(O)\$(@B).tmp2
    perl $(_INX)\reorder_layout.pl $@ $(_INX)\layout.ord
    @del $@
    move $@.new $@
    $(COVER_TSBINPLACE_CMD)


# we process syssetup.inf twice for win64.  we process one time to get the
# "olecontroldlls" data, then one more time to get the copyfiles entries, etc.
#
$(O)\syssetup.inf: $(O)\syssetup.inx \
!IF $(WIN64)
                   $(O)\wowlist.inf $(O)\wowfrege.inf    \
                   $(O)\wowfregc.inf $(O)\wowfrego.inf   \
                   $(O)\layout.inx $(O)\layout.txt    \
!ENDIF
                   $(_LNG)\syssetup.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy /b $(O)\$(@B).inx+$(O)\$(@B).txt1 $(O)\$(@B).tmp1
    prodfilt -s $(O)\$(@B).tmp1 $(O)\$(@B).tmp2 +$(PRODSWITCH)
    prodfilt -s $(O)\$(@B).tmp2 $@ +$(PLATFORM_SWITCH)
!IF $(WIN64)
    copy $(@) $(O)\$(@B).tmp3
    copy $(O)\$(@B).inx+$(O)\$(@B).txt1 $(O)\$(@B).tmp1
    prodfilt -s $(O)\$(@B).tmp1 $(O)\$(@B).tmp2 +$(PRODSWITCH)
    prodfilt -s $(O)\$(@B).tmp2 $(O)\$(@B).tmp1 +i
    copy /b $(O)\layout.inx+$(O)\layout.txt $(O)\$(@B).tmp4
    prodfilt -s $(O)\$(@B).tmp4 $(O)\$(@B).tmp2 +@
    prodfilt -s $(O)\$(@B).tmp2 $(O)\$(@B).tmp4 +i
    wowlist -i $(O)\$(@B).tmp4 -c $(O)\wowlist.inf -l $(O)\$(@B).tmp1 -s OleControlDlls -o $(O)\$(@B).tmp5 -ao -h $(O)\wowfrego.inf -f w
    wowlist -i $(O)\$(@B).tmp4 -c $(O)\wowlist.inf -l $(O)\$(@B).tmp1 -s EarlyOleControlDlls -o $(O)\$(@B).tmp6 -ao -h $(O)\wowfrege.inf -f w 2>NUL
    wowlist -i $(O)\$(@B).tmp4 -c $(O)\wowlist.inf -l $(O)\$(@B).tmp1 -s CryptoDlls -o $(O)\$(@B).tmp7 -ao -h $(O)\wowfregc.inf -f w 2>NUL
    wowlist -i $(O)\$(@B).tmp1 -c $(O)\wowlist.inf -as -f w -d $(O)\syssetup.wow -o $(O)\$(@B).tmp8 -g Syssetup
    copy /b $(O)\$(@B).tmp3+$(O)\$(@B).tmp5+$(O)\$(@B).tmp6+$(O)\$(@B).tmp7+$(O)\$(@B).tmp8 $(@)
    @del $(O)\$(@B).tmp3 $(O)\$(@B).tmp4 $(O)\$(@B).tmp5 $(O)\$(@B).tmp6 $(O)\$(@B).tmp7 $(O)\$(@B).tmp8
!ENDIF
    @del $(O)\$(@B).tmp1
    @del $(O)\$(@B).tmp2
    @del $(O)\$(@B).txt1
    $(TSBINPLACE_CMD)

!IF !$(WIN64)
$(_COVINF)\syssetup.inf: $(O)\syssetup.inx $(_INX)\$(@B).mcv \
                   $(_LNG)\syssetup.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy /b $(O)\$(@B).inx+$(O)\$(@B).txt1 $(O)\$(@B).tmp1
    prodfilt -s $(O)\$(@B).tmp1 $(O)\$(@B).tmp2 +$(PRODSWITCH)
    prodfilt -s $(O)\$(@B).tmp2 $(O)\$(@B).tmp1 +$(PLATFORM_SWITCH)
    call MergeFiles.cmd $(O)\$(@B).tmp1 $(_INX)\$(@B).mcv $@
    @del $(O)\$(@B).tmp1
    @del $(O)\$(@B).tmp2
    @del $(O)\$(@B).txt1
    $(COVER_TSBINPLACE_CMD)
!ENDIF

!IF $(WIN64)
$(O)\syssetup.wow: $(O)\syssetup.inf
!ENDIF

$(O)\intl.inf: $(_INX)\intl.inx \
!if $(WIN64)
               $(O)\wowlist.inf \
!endif
               $(_LNG)\intl.txt
!if "$(LANGUAGE)"=="CHS" || "$(LANGUAGE)"=="chs" || \
    "$(LANGUAGE)"=="CHT" || "$(LANGUAGE)"=="cht" || \
    "$(LANGUAGE)"=="CHH" || "$(LANGUAGE)"=="chh" || \
    "$(LANGUAGE)"=="JPN" || "$(LANGUAGE)"=="jpn" || \
    "$(LANGUAGE)"=="KOR" || "$(LANGUAGE)"=="kor" || \
    "$(LANGUAGE)"=="ARA" || "$(LANGUAGE)"=="ara" || \
    "$(LANGUAGE)"=="HEB" || "$(LANGUAGE)"=="heb" || \
    "$(LANGUAGE)"=="PSU" || "$(LANGUAGE)"=="psu" || \
    "$(LANGUAGE)"=="RU"  || "$(LANGUAGE)"=="ru"  || \
    "$(LANGUAGE)"=="EL"  || "$(LANGUAGE)"=="el"  || \
    "$(LANGUAGE)"=="PL"  || "$(LANGUAGE)"=="pl"  || \
    "$(LANGUAGE)"=="CS"  || "$(LANGUAGE)"=="cs"  || \
    "$(LANGUAGE)"=="HU"  || "$(LANGUAGE)"=="hu"  || \
    "$(LANGUAGE)"=="TR"  || "$(LANGUAGE)"=="tr"
    infcat -t$(O)\$(@B).tmp -s$(_LNG)\$(@B).txt,0$(LCID) -a$(_INX)\usa\$(@B).txt
    copy $(_INX)\$(@B).inx+$(O)\$(@B).tmp $(O)\$(@B).tmp1
    del $(O)\$(@B).tmp
!else
    copy $(_INX)\$(@B).inx+$(_LNG)\$(@B).txt $(O)\$(@B).tmp1
!endif
    prodfilt -u $(O)\$(@B).tmp1 $(O)\$(@B).tmp2 +$(PRODSWITCH)
    prodfilt -u $(O)\$(@B).tmp2 $@ +$(PLATFORM_SWITCH)
!if $(WIN64)
    copy $@ $(O)\$(@B).tmp3
    copy $(_INX)\$(@B).inx+$(_LNG)\$(@B).txt $(O)\$(@B).tmp1
    prodfilt -u $(O)\$(@B).tmp1 $(O)\$(@B).tmp2 +i
    prodfilt -u $(O)\$(@B).tmp2 $(O)\$(@B).tmp1 +@
    wowlist -i $(O)\$(@B).tmp1 -c $(O)\wowlist.inf -as -f w -u -d $(O)\intl.wow -o $(O)\$(@B).tmp4 -n $(O)\intlinf.tmp -g Intl
    unitext -u -$(ANSI_CODEPAGE) $(O)\intlinf.tmp $(O)\intlinfa.wow
    del $(O)\intlinf.tmp
    $(STRIPCHAR) $(O)\intlinfa.wow $(O)\intlinf.tmp
    unitext -m -$(ANSI_CODEPAGE) $(O)\intlinf.tmp $(O)\intlinf.wow
    perl << $(O)\$(@B).tmp4 >$(O)\$(@B).tmp5
# perl script to convert "=10,IME" to "=10,IME (x86)" because it's too late to fix setup.
# This script would be a lot nicer except that intl.inf is UNICODE
undef $$/;
binmode(STDIN);
binmode(STDOUT);
$$_ = <>;
s/=\0\x31\0\x30\0,\0I\0M\0E\0\\\0([^\n\r]*)/=\0\x31\0\x30\0,\0"\0I\0M\0E\0 \0\(\0x\0\x38\0\x36\0\)\0\\\0\1"\0/g;
print;
<<NOKEEP
!if $(IA64)
    echo [SourceDisksFiles.ia64] >$(O)\intl.hdr1
!else
    echo [SourceDisksFiles.amd64] >$(O)\intl.hdr1
!endif
    unitext $(UNITEXT_OPT) $(O)\intl.hdr1 $(O)\intl.hdr
    copy $(O)\$(@B).tmp3+$(O)\$(@B).tmp5+$(O)\intl.hdr+$(O)\intlinf.wow $(O)\$(@B).tmp2
# This is a temporary fix as cmd.exe on beta2 2462 introduces a ^Z char at the end of the file
# when using copy /a. Running a dummy prodfilt on this fixes the issue for now. Should be removed
# once the main build lab upgrades the build running on their machines
    prodfilt -u $(O)\$(@B).tmp2 $@ +@
    @del $(O)\$(@B).tmp3 $(O)\$(@B).tmp4 $(O)\$(@B).tmp5 $(O)\intl.hdr1 $(O)\intl.hdr
!endif
    @del $(O)\$(@B).tmp1
    @del $(O)\$(@B).tmp2
    $(TSBINPLACE_CMD)

!if $(WIN64)
$(O)\intl.wow: $(O)\intl.inf

$(O)\intlinfa.wow: $(O)\intl.inf
!endif



$(O)\font.inf: $(_INX)\font.inx $(_LNG)\font.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $(O)\$(@B).tmp1
    prodfilt $(O)\$(@B).tmp1 $(O)\$(@B).tmp2 +$(PRODSWITCH)
    prodfilt $(O)\$(@B).tmp2 $@ +$(PLATFORM_SWITCH)
    @del $(O)\$(@B).tmp1
    @del $(O)\$(@B).tmp2
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\netdav.inf: $(_INX)\netdav.inx $(_LNG)\netdav.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $(O)\$(@B).tmp1
    prodfilt $(O)\$(@B).tmp1 $(O)\$(@B).tmp2 +$(PRODSWITCH)
    prodfilt $(O)\$(@B).tmp2 $@ +$(PLATFORM_SWITCH)
    @del $(O)\$(@B).tmp1
    @del $(O)\$(@B).tmp2
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\display.inf: $(_INX)\display.inx $(_LNG)\display.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $(O)\$(@B).tmp1
    prodfilt $(O)\$(@B).tmp1 $(O)\$(@B).tmp2 +$(PRODSWITCH)
    prodfilt $(O)\$(@B).tmp2 $@ +$(PLATFORM_SWITCH)
    @del $(O)\$(@B).tmp1
    @del $(O)\$(@B).tmp2
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\dispdet.inf: $(_INX)\dispdet.inx $(_LNG)\display.txt
    $(CC) $(PREFLAGS) $(_LNG)\display.txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+display.txt1 $(O)\$(@B).tmp
    prodfilt $(O)\$(@B).tmp $@ +$(PLATFORM_SWITCH)
    @del $(O)\$(@B).tmp
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\optional.inf: $(_INX)\optional.inx \
!if $(WIN64)
                   $(O)\wowlist.inf \
!endif
                   $(_LNG)\optional.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $(O)\$(@B).tmp1
    prodfilt $(O)\$(@B).tmp1 $(O)\$(@B).tmp2 +$(PLATFORM_SWITCH)
    prodfilt $(O)\$(@B).tmp2 $@ +$(PRODSWITCH)
!if $(WIN64)
    copy $@ $(O)\$(@B).tmp3
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $(O)\$(@B).tmp1
    prodfilt $(O)\$(@B).tmp1 $(O)\$(@B).tmp2 +i
    prodfilt $(O)\$(@B).tmp2 $(O)\$(@B).tmp1 +@
    wowlist -i $(O)\$(@B).tmp1 -c $(O)\wowlist.inf -as -f w -d $(O)\optional.wow -o $(O)\$(@B).tmp4
    copy $(O)\$(@B).tmp3+$(O)\$(@B).tmp4 $@
    @del $(O)\$(@B).tmp3 $(O)\$(@B).tmp4
!endif
    @del $(O)\$(@B).tmp1
    @del $(O)\$(@B).tmp2
    @del $(O)\$(@B).txt1
    $(TSBINPLACE_CMD)

!if $(WIN64)
$(O)\optional.wow: $(O)\optional.inf
!endif

$(O)\accessor.inf: $(_INX)\accessor.inx  \
!if $(WIN64)
                   $(O)\wowlist.inf \
!endif
                   $(_LNG)\accessor.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $(O)\$(@B).tmp1
    prodfilt $(O)\$(@B).tmp1 $(O)\$(@B).tmp2 +$(PLATFORM_SWITCH)
    prodfilt $(O)\$(@B).tmp2 $@ +$(PRODSWITCH)
!if $(WIN64)
    copy $@ $(O)\$(@B).tmp3
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $(O)\$(@B).tmp1
    prodfilt $(O)\$(@B).tmp1 $(O)\$(@B).tmp2 +i
    prodfilt $(O)\$(@B).tmp2 $(O)\$(@B).tmp1 +@
    wowlist -i $(O)\$(@B).tmp1 -c $(O)\wowlist.inf -as -f w -d $(O)\accessor.wow -o $(O)\$(@B).tmp4
    copy $(O)\$(@B).tmp3+$(O)\$(@B).tmp4 $@
    @del $(O)\$(@B).tmp3 $(O)\$(@B).tmp4
!endif
    @del $(O)\$(@B).tmp1
    @del $(O)\$(@B).tmp2
    @del $(O)\$(@B).txt1
    $(TSBINPLACE_CMD)

!if $(WIN64)
$(O)\accessor.wow: $(O)\accessor.inf
!endif

$(O)\communic.inf: $(_INX)\communic.inx \
!if $(WIN64)
                   $(O)\wowlist.inf \
!endif
                   $(_LNG)\communic.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $(O)\$(@B).tmp1
    prodfilt $(O)\$(@B).tmp1 $(O)\$(@B).tmp2 +$(PLATFORM_SWITCH)
    prodfilt $(O)\$(@B).tmp2 $@ +$(PRODSWITCH)
!if $(WIN64)
    copy $@ $(O)\$(@B).tmp3
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $(O)\$(@B).tmp1
    prodfilt $(O)\$(@B).tmp1 $(O)\$(@B).tmp2 +i
    prodfilt $(O)\$(@B).tmp2 $(O)\$(@B).tmp1 +@
    wowlist -i $(O)\$(@B).tmp1 -c $(O)\wowlist.inf -as -f w -d $(O)\communic.wow -o $(O)\$(@B).tmp4 -g communic
    copy $(O)\$(@B).tmp3+$(O)\$(@B).tmp4 $@
    @del $(O)\$(@B).tmp3 $(O)\$(@B).tmp4
!endif
    @del $(O)\$(@B).tmp1
    @del $(O)\$(@B).tmp2
    @del $(O)\$(@B).txt1
    $(TSBINPLACE_CMD)

!if $(WIN64)
$(O)\communic.wow: $(O)\communic.inf
!endif


$(O)\games.inf: $(_INX)\games.inx \
!if $(WIN64)
                $(O)\wowlist.inf \
!endif
                $(_LNG)\games.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $(O)\$(@B).tmp1
    prodfilt $(O)\$(@B).tmp1 $(O)\$(@B).tmp2 +$(PLATFORM_SWITCH)
    prodfilt $(O)\$(@B).tmp2 $@ +$(PRODSWITCH)
!if $(WIN64)
    copy $@ $(O)\$(@B).tmp3
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $(O)\$(@B).tmp1
    prodfilt $(O)\$(@B).tmp1 $(O)\$(@B).tmp2 +i
    prodfilt $(O)\$(@B).tmp2 $(O)\$(@B).tmp1 +@
    wowlist -i $(O)\$(@B).tmp1 -c $(O)\wowlist.inf -as -f w -d $(O)\games.wow -o $(O)\$(@B).tmp4
    copy $(O)\$(@B).tmp3+$(O)\$(@B).tmp4 $@
    @del $(O)\$(@B).tmp3 $(O)\$(@B).tmp4
!endif
    @del $(O)\$(@B).tmp1
    @del $(O)\$(@B).tmp2
    @del $(O)\$(@B).txt1
    $(TSBINPLACE_CMD)

!if $(WIN64)
$(O)\games.wow: $(O)\games.inf
!endif

$(O)\au.inf: $(_INX)\au.inx $(_LNG)\au.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $(O)\$(@B).tmp
    prodfilt $(O)\$(@B).tmp $@ +$(PLATFORM_SWITCH)
    @del $(O)\$(@B).tmp
    @del $(O)\$(@B).txt1
    $(TSBINPLACE_CMD)

$(O)\wbemcrrl.inf: $(_INX)\wbemcrrl.inx $(_LNG)\wbemcrrl.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $(O)\$(@B).tmp1
    prodfilt $(O)\$(@B).tmp1 $(O)\$(@B).tmp2 +$(PRODSWITCH)
    prodfilt $(O)\$(@B).tmp2 $@ +$(PLATFORM_SWITCH)
    @del $(O)\$(@B).tmp1
    @del $(O)\$(@B).tmp2
    @del $(O)\$(@B).txt1
    $(TSBINPLACE_CMD)

$(O)\wbemfwrd.inf: $(_INX)\wbemfwrd.inx $(_LNG)\wbemfwrd.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $(O)\$(@B).tmp1
    prodfilt $(O)\$(@B).tmp1 $(O)\$(@B).tmp2 +$(PRODSWITCH)
    prodfilt $(O)\$(@B).tmp2 $@ +$(PLATFORM_SWITCH)
    @del $(O)\$(@B).tmp1
    @del $(O)\$(@B).tmp2
    @del $(O)\$(@B).txt1
    $(TSBINPLACE_CMD)

$(O)\wbemmsi.inf: $(_INX)\wbemmsi.inx $(_LNG)\wbemmsi.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $(O)\$(@B).tmp1
    prodfilt $(O)\$(@B).tmp1 $(O)\$(@B).tmp2 +$(PRODSWITCH)
    prodfilt $(O)\$(@B).tmp2 $@ +$(PLATFORM_SWITCH)
    @del $(O)\$(@B).tmp1
    @del $(O)\$(@B).tmp2
    @del $(O)\$(@B).txt1
    $(TSBINPLACE_CMD)

$(O)\wbemoc.inf: $(_INX)\wbemoc.inx \
!if $(WIN64)
                  $(O)\wowlist.inf   \
!endif
                  $(_LNG)\wbemoc.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $(O)\$(@B).tmp1
    prodfilt $(O)\$(@B).tmp1 $(O)\$(@B).tmp2 +$(PLATFORM_SWITCH)
    prodfilt $(O)\$(@B).tmp2 $@ +$(PRODSWITCH)
!if $(WIN64)
    copy $@ $(O)\$(@B).tmp3
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $(O)\$(@B).tmp1
    prodfilt $(O)\$(@B).tmp1 $(O)\$(@B).tmp2 +i
    prodfilt $(O)\$(@B).tmp2 $(O)\$(@B).tmp1 +@
    wowlist -i $(O)\$(@B).tmp1 -c $(O)\wowlist.inf -g WbemOC -as -f w -d $(O)\wbemoc.wow -o $(O)\$(@B).tmp4
    copy $(O)\$(@B).tmp3+$(O)\$(@B).tmp4 $@
    @del $(O)\$(@B).tmp3 $(O)\$(@B).tmp4
!endif
    @del $(O)\$(@B).tmp1
    @del $(O)\$(@B).tmp2
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

!if $(WIN64)
$(O)\wbemoc.wow: $(O)\wbemoc.inf
!endif

$(O)\wbemsnmp.inf: $(_INX)\wbemsnmp.inx $(_LNG)\wbemsnmp.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $(O)\$(@B).tmp1
    prodfilt $(O)\$(@B).tmp1 $(O)\$(@B).tmp2 +$(PRODSWITCH)
    prodfilt $(O)\$(@B).tmp2 $@ +$(PLATFORM_SWITCH)
    @del $(O)\$(@B).tmp1
    @del $(O)\$(@B).tmp2
    @del $(O)\$(@B).txt1
    $(TSBINPLACE_CMD)

#
# IE.INF/INSTALL.INS notes:
# For ie.inf and install.ins, we have to replace all the
# TOK_xxx keys in the file with the appropriate entries from ieverp.h.
# To do this, we first build a makefile that will preprocess
# the file and extract the interesting entries...
#

$(O)\ietoken.mak : $(_INX)\makefile.inc $(SDK_INC_PATH)\ntverp.h
    echo !include $(NTMAKEENV)\makefile.plt > $@
    @$(TARGET_CPP) -nologo -I$(SDK_INC_PATH) -DNASHVILLE /EP /Tc << | qgrep TOK_ >> $@
#include "$(SDK_INC_PATH)\ntverp.h"

TOK_BUILDNUM = VER_PRODUCTBUILD
TOK_QFE = VER_PRODUCTBUILD_QFE
TOK_MAJOR_NUM = VER_MAJOR_PRODUCTVER
TOK_MINOR_NUM = VER_MINOR_PRODUCTVER
#if (VER_PRODUCTBUILD_QFE > 0)
TOK_FULLQFE = .VER_PRODUCTBUILD_QFE
#else
TOK_FULLQFE =
#endif
<<NOKEEP
    type << >> $@
PERL_SWITCHES = \
    $(_INX)\token.per \
    -tTOK_BUILDNUM=$$(TOK_BUILDNUM) \
    -tTOK_QFE=$$(TOK_QFE) \
    -tTOK_MAJOR_NUM=$$(TOK_MAJOR_NUM) \
    -tTOK_MINOR_NUM=$$(TOK_MINOR_NUM) \
    -tTOK_FULLQFE=$$(TOK_FULLQFE)

STD_DEP = \
    $(SDK_INC_PATH)\ntverp.h \
    $@

$(O)\ie.inf : $(O)\ie.inftok \
!if $(WIN64)
              $(O)\ie.inftok_6432 \
!endif
              $$(STD_DEP)
     perl $$(PERL_SWITCHES) $(O)\ie.inftok > $(O)\ie.inf
!if $(WIN64)
     perl $$(PERL_SWITCHES) $(O)\ie.inftok_6432 > $(O)\ie.tmp1
     wowlist -i $(O)\ie.tmp1 -c $(O)\wowlist.inf -as -f w -d $(O)\ie.wow -o $(O)\ie.tmp2
     copy $(O)\ie.inf $(O)\ie.tmp1
     copy $(O)\ie.tmp1+$(O)\ie.tmp2 $(O)\ie.inf
     @del $(O)\ie.tmp1 $(O)\ie.tmp2
!endif

$(O)\install.ins : $(O)\install.instok $(STD_DEP)
     perl $$(PERL_SWITCHES) $(O)\install.instok > $(O)\install.ins

$(O)\msoe50.inf : $(O)\msoe50.inftok \
!if $(WIN64)
                  $(O)\msoe50.inftok_6432 \
!endif
                  $(STD_DEP)
     perl $$(PERL_SWITCHES) $(O)\msoe50.inftok > $(O)\msoe50.inf
!if $(WIN64)
     perl $$(PERL_SWITCHES) $(O)\msoe50.inftok_6432 > $(O)\msoe50.tmp1
     wowlist -i $(O)\msoe50.tmp1 -c $(O)\wowlist.inf -as -f w -d $(O)\msoe50.wow -o $(O)\msoe50.tmp2
     copy $(O)\msoe50.inf $(O)\msoe50.tmp1
     copy $(O)\msoe50.tmp1+$(O)\msoe50.tmp2 $(O)\msoe50.inf
     @del $(O)\msoe50.tmp1 $(O)\msoe50.tmp2
!endif

$(O)\wab50.inf : $(O)\wab50.inftok $(STD_DEP)
     perl $$(PERL_SWITCHES) $(O)\wab50.inftok > $(O)\wab50.inf
!if $(WIN64)
     wowlist -i $(O)\wab50.inf -c $(O)\wowlist.inf -as -f w -d $(O)\wab50.wow -o $(O)\wab50.tmp2
     copy $(O)\wab50.inf $(O)\wab50.tmp1
     copy $(O)\wab50.tmp1+$(O)\wab50.tmp2 $(O)\wab50.inf
     @del $(O)\wab50.tmp1 $(O)\wab50.tmp2
!endif
<<NOKEEP

#
# IE/INSTALL notes.  Then we build a pretokenized file
# (tok added to the filename).
#

$(O)\ie.inftok: $(_INX)\ie.inx $(_LNG)\ie.txt
    @type <<$(ECHO_RSP)
$(ECHO_MSG_P)
<<NOKEEP
    @$(C_PREPROCESSOR_NAME) @<<$(CL_RSP) /Tc$(_INX)\$(@B).inx > $(O)\$(@B).tmp
$(CPPXX: =
)
/DNT5
<<NOKEEP
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(O)\$(@B).tmp+$(O)\$(@B).txt1 $(O)\$(@B).tmp1
    prodfilt $(O)\$(@B).tmp1 $(O)\$(@B).tmp2 +$(PRODSWITCH)
    prodfilt $(O)\$(@B).tmp2 $@ +$(PLATFORM_SWITCH)
    @del $(O)\$(@B).tmp $(O)\$(@B).txt1 $(O)\$(@B).tmp1 $(O)\$(@B).tmp2

$(O)\ie.inftok_6432: $(_INX)\ie.inx $(_LNG)\ie.txt
    @type <<$(ECHO_RSP)
$(C_COMPILER_NAME) -D_X86_=1 -Di386=1 $(_INX)\ie.inx
<<NOKEEP
    @$(C_PREPROCESSOR_NAME) @<<$(CL_RSP) -D_X86_=1 -Di386=1 /Tc$(_INX)\$(@B).inx > $(O)\$(@B).tmp
$(CPPXX: =
)
/DNT5
<<NOKEEP
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(O)\$(@B).tmp+$(O)\$(@B).txt1 $(O)\$(@B).tmp1
    prodfilt $(O)\$(@B).tmp1 $(O)\$(@B).tmp2 +$(PRODSWITCH)
    prodfilt $(O)\$(@B).tmp2 $@ +i
    @del $(O)\$(@B).tmp $(O)\$(@B).tmp1 $(O)\$(@B).tmp2

$(O)\install.instok: $(_INX)\install.inx $(_LNG)\install.txt $(O)\ietoken.mak
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\install.inx+$(O)\$(@B).txt1 $@
    @del $(O)\$(@B).txt1

$(O)\msoe50.inftok: $(_INX)\msoe50.inx $(_LNG)\msoe50.txt
    @type <<$(ECHO_RSP)
$(ECHO_MSG_P)
<<NOKEEP
    @$(C_PREPROCESSOR_NAME) @<<$(CL_RSP) /Tc$(_INX)\$(@B).inx > $(O)\$(@B).tmp
$(CPPXX: =
)
/DNT5
<<NOKEEP
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(O)\$(@B).tmp+$(O)\$(@B).txt1 $(O)\$(@B).tmp1
    prodfilt $(O)\$(@B).tmp1 $(O)\$(@B).tmp2 +$(PRODSWITCH)
    prodfilt $(O)\$(@B).tmp2 $@ +$(PLATFORM_SWITCH)
    @del $(O)\$(@B).tmp $(O)\$(@B).tmp1 $(O)\$(@B).tmp2 $(O)\$(@B).txt1

$(O)\msoe50.inftok_6432: $(_INX)\msoe50.inx $(_LNG)\msoe50.txt
    @type <<$(ECHO_RSP)
$(C_COMPILER_NAME) -D_X86_=1 -Di386=1 $(_INX)\msoe50.inx
<<NOKEEP
    @$(C_PREPROCESSOR_NAME) @<<$(CL_RSP) -D_X86_=1 -Di386=1 /Tc$(_INX)\$(@B).inx > $(O)\$(@B).tmp
$(CPPXX: =
)
/DNT5
<<NOKEEP
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(O)\$(@B).tmp+$(O)\$(@B).txt1 $(O)\$(@B).tmp1
    prodfilt $(O)\$(@B).tmp1 $(O)\$(@B).tmp2 +$(PRODSWITCH)
    prodfilt $(O)\$(@B).tmp2 $@ +i
    @del $(O)\$(@B).tmp $(O)\$(@B).tmp1 $(O)\$(@B).tmp2

$(O)\wab50.inftok: $(_INX)\wab50.inx $(_LNG)\wab50.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $(O)\$(@B).tmp1
    prodfilt $(O)\$(@B).tmp1 $(O)\$(@B).tmp2 +$(PLATFORM_SWITCH)
    prodfilt $(O)\$(@B).tmp2 $@ +$(PRODSWITCH)
    @del $(O)\$(@B).tmp1 $(O)\$(@B).tmp2 $(O)\$(@B).txt1
#
# IE/INSTALL notes: And finally, we run them through the
# makefile we created above, stamp, and binplace.
#

$(O)\ie.inf : $(O)\ietoken.mak \
!if $(WIN64)
              $(O)\wowlist.inf \
              $(O)\ie.inftok_6432 \
!endif
              $(O)\ie.inftok
    nmake -f $(O)\ietoken.mak $@
    $(STAMP)
    $(TSBINPLACE_CMD)

!if $(WIN64)
$(O)\ie.wow: $(O)\ie.inf
!endif

$(O)\msoe50.inf : $(O)\ietoken.mak \
!if $(WIN64)
                  $(O)\wowlist.inf \
                  $(O)\msoe50.inftok_6432 \
!endif
                  $(O)\msoe50.inftok
    nmake -f $(O)\ietoken.mak $@
    $(STAMP)
    $(TSBINPLACE_CMD)

!if $(WIN64)
$(O)\msoe50.wow: $(O)\msoe50.inf
!endif

$(O)\mstask.inf : $(_INX)\mstask.inx \
!if $(WIN64)
                  $(O)\wowlist.inf   \
!endif
                  $(_LNG)\mstask.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $(O)\$(@B).tmp1
    prodfilt $(O)\$(@B).tmp1 $(O)\$(@B).tmp2 +$(PLATFORM_SWITCH)
    prodfilt $(O)\$(@B).tmp2 $@ +$(PRODSWITCH)
!if $(WIN64)
    copy $@ $(O)\$(@B).tmp3
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $(O)\$(@B).tmp1
    prodfilt $(O)\$(@B).tmp1 $(O)\$(@B).tmp2 +i
    prodfilt $(O)\$(@B).tmp2 $(O)\$(@B).tmp1 +@
    wowlist -i $(O)\$(@B).tmp1 -c $(O)\wowlist.inf -as -f w -d $(O)\mstask.wow -o $(O)\$(@B).tmp4
    copy $(O)\$(@B).tmp3+$(O)\$(@B).tmp4 $@
    @del $(O)\$(@B).tmp3 $(O)\$(@B).tmp4
!endif
    @del $(O)\$(@B).tmp1
    @del $(O)\$(@B).tmp2
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

!if $(WIN64)
$(O)\mstask.wow: $(O)\mstask.inf
!endif

$(O)\wab50.inf :  $(O)\ietoken.mak \
!if $(WIN64)
                  $(O)\wowlist.inf \
                  $(O)\msoe50.inftok_6432 \
!endif
                  $(O)\wab50.inftok
    nmake -f $(O)\ietoken.mak $@
    $(STAMP)
    $(TSBINPLACE_CMD)

!if $(WIN64)
$(O)\wab50.wow: $(O)\wab50.inf
!endif

$(O)\install.ins: $(O)\ietoken.mak $(O)\install.instok
    nmake -f $(O)\ietoken.mak $@
    $(TSBINPLACE_CMD)

$(O)\mmopt.inf: $(_INX)\mmopt.inx \
!if $(WIN64)
                $(O)\wowlist.inf \
!endif
                $(_LNG)\mmopt.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $(O)\$(@B).tmp
    prodfilt $(O)\$(@B).tmp $@ +$(PLATFORM_SWITCH)
!if $(WIN64)
    copy $@ $(O)\$(@B).tmp3
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $(O)\$(@B).tmp1
    prodfilt $(O)\$(@B).tmp1 $(O)\$(@B).tmp2 +i
    wowlist -i $(O)\$(@B).tmp2 -c $(O)\wowlist.inf -as -f w -d $(O)\mmopt.wow -o $(O)\$(@B).tmp4
    copy $(O)\$(@B).tmp3+$(O)\$(@B).tmp4 $@
    @del $(O)\$(@B).tmp1 $(O)\$(@B).tmp2 $(O)\$(@B).tmp3 $(O)\$(@B).tmp4
!endif
    @del $(O)\$(@B).tmp
    @del $(O)\$(@B).txt1
    $(TSBINPLACE_CMD)


!if $(WIN64)
$(O)\mmopt.wow: $(O)\mmopt.inf
!endif


$(O)\msmail.inf: $(_INX)\msmail.inx $(_LNG)\msmail.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $@
    @del $(O)\$(@B).txt1
    $(TSBINPLACE_CMD)

$(O)\perms.inf: $(_INX)\perms.inx $(_LNG)\perms.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $(O)\$(@B).tmp1
    prodfilt $(O)\$(@B).tmp1 $(O)\$(@B).tmp2 +$(PRODSWITCH)
    prodfilt $(O)\$(@B).tmp2 $@ +$(PLATFORM_SWITCH)
    @del $(O)\$(@B).tmp1
    @del $(O)\$(@B).tmp2
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\hivesys.inf: $(_INX)\hivesys.inx $(_LNG)\hivesys.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $(O)\$(@B).tmp1
    $(C_COMPILER_NAME) -EP $(CDEFINES) $(O)\$(@B).tmp1 >$(O)\$(@B).tmp2
    prodfilt $(O)\$(@B).tmp2 $(O)\$(@B).tmp3 +$(PRODSWITCH)
    prodfilt $(O)\$(@B).tmp3 $@ +$(PLATFORM_SWITCH)
    @del $(O)\$(@B).tmp1
    @del $(O)\$(@B).tmp2
    @del $(O)\$(@B).tmp3
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(_COVINF)\hivesys.inf: $(_INX)\hivesys.inx $(_LNG)\hivesys.txt $(_INX)\$(@B).mcv
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $(O)\$(@B).tmp1
    $(C_COMPILER_NAME) -EP $(CDEFINES) $(O)\$(@B).tmp1 >$(O)\$(@B).tmp2
    prodfilt $(O)\$(@B).tmp2 $(O)\$(@B).tmp3 +$(PRODSWITCH)
    prodfilt $(O)\$(@B).tmp3 $(O)\$(@B).tmp2 +$(PLATFORM_SWITCH)
    call MergeFiles.cmd $(O)\$(@B).tmp2 $(_INX)\$(@B).mcv $(@)
    @del $(O)\$(@B).tmp1
    @del $(O)\$(@B).tmp2
    @del $(O)\$(@B).tmp3
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(COVER_TSBINPLACE_CMD)

$(O)\hivesft.inf: $(_INX)\hivesft.inx $(_LNG)\hivesft.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $(O)\$(@B).tmp1
    $(C_COMPILER_NAME) -EP $(CDEFINES) $(O)\$(@B).tmp1 >$(O)\$(@B).tmp2
    prodfilt $(O)\$(@B).tmp2 $(O)\$(@B).tmp3 +$(PRODSWITCH)
    prodfilt $(O)\$(@B).tmp3 $@ +$(PLATFORM_SWITCH)
    @del $(O)\$(@B).tmp1
    @del $(O)\$(@B).tmp2
    @del $(O)\$(@B).tmp3
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\hivedef.inf: $(_INX)\hivedef.inx $(_LNG)\hivedef.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $(O)\$(@B).tmp1
    prodfilt $(O)\$(@B).tmp1 $(O)\$(@B).tmp2 +$(PRODSWITCH)
    prodfilt $(O)\$(@B).tmp2 $@ +$(PLATFORM_SWITCH)
    @del $(O)\$(@B).tmp1
    @del $(O)\$(@B).tmp2
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\hivecls.inf: $(_INX)\hivecls.inx $(_LNG)\hivecls.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $(O)\$(@B).tmp1
    $(C_COMPILER_NAME) -EP $(CDEFINES) $(O)\$(@B).tmp1 >$(O)\$(@B).tmp2
    prodfilt $(O)\$(@B).tmp2 $(O)\$(@B).tmp3 +$(PRODSWITCH)
    prodfilt $(O)\$(@B).tmp3 $@ +$(PLATFORM_SWITCH)
    @del $(O)\$(@B).tmp1
    @del $(O)\$(@B).tmp2
    @del $(O)\$(@B).tmp3
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\hiveusd.inf: $(_INX)\hiveusd.inx $(_LNG)\hiveusd.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $(O)\$(@B).tmp1
    prodfilt $(O)\$(@B).tmp1 $(O)\$(@B).tmp2 +$(PRODSWITCH)
    prodfilt $(O)\$(@B).tmp2 $@ +$(PLATFORM_SWITCH)
    @del $(O)\$(@B).tmp1
    @del $(O)\$(@B).tmp2
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

!if $(WIN64)
$(O)\hivcls32.inf: $(_INX)\hivecls.inx $(_LNG)\hivecls.txt $(_INX)\hive32.pl
    $(CC) $(PREFLAGS) $(_LNG)\hivecls.txt > hivecls.txt1
    copy $(_INX)\hivecls.inx+hivecls.txt1 $(O)\$(@B).tmp1
    $(C_COMPILER_NAME) -EP $(CDEFINES) $(O)\$(@B).tmp1 >$(O)\$(@B).tmp2
    prodfilt $(O)\$(@B).tmp2 $(O)\$(@B).tmp3 +$(PRODSWITCH)
    prodfilt $(O)\$(@B).tmp3 $(O)\$(@B).tmp1 +i
    perl $(_INX)\hive32.pl -input=$(O)\$(@B).tmp1 -output=$@
    @del $(O)\$(@B).tmp1 $(O)\$(@B).tmp2 $(O)\$(@B).tmp3 hivecls.txt1
    $(TSBINPLACE_CMD)

$(O)\hivsft32.inf: $(_INX)\hivesft.inx $(_LNG)\hivesft.txt $(_INX)\hive32.pl
    $(CC) $(PREFLAGS) $(_LNG)\hivesft.txt > $(O)\hivesft.txt1
    copy $(_INX)\hivesft.inx+$(O)\hivesft.txt1 $(O)\$(@B).tmp1
    $(C_COMPILER_NAME) -EP $(CDEFINES) $(O)\$(@B).tmp1 >$(O)\$(@B).tmp2
    prodfilt $(O)\$(@B).tmp2 $(O)\$(@B).tmp3 +$(PRODSWITCH)
    prodfilt $(O)\$(@B).tmp3 $(O)\$(@B).tmp1 +i
    perl $(_INX)\hive32.pl -input=$(O)\$(@B).tmp1 -output=$@
    @del $(O)\$(@B).tmp1 $(O)\$(@B).tmp2 $(O)\$(@B).tmp3
    $(TSBINPLACE_CMD)
!endif

$(O)\mdac.inf: $(_INX)\mdac.inx \
!if $(WIN64)
               $(O)\wowlist.inf \
!endif
               $(_LNG)\mdac.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $(O)\$(@B).tmp1
    prodfilt $(O)\$(@B).tmp1 $(O)\$(@B).tmp2 +$(PRODSWITCH)
    prodfilt $(O)\$(@B).tmp2 $@ +$(PLATFORM_SWITCH)
!if $(WIN64)
    copy $@ $(O)\$(@B).tmp3
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $(O)\$(@B).tmp1
    prodfilt $(O)\$(@B).tmp1 $(O)\$(@B).tmp2 +@
    prodfilt $(O)\$(@B).tmp2 $(O)\$(@B).tmp1 +i
    wowlist -i $(O)\$(@B).tmp1 -c $(O)\wowlist.inf -as -f w -d $(O)\mdac.wow -o $(O)\$(@B).tmp4
    copy $(O)\$(@B).tmp3+$(O)\$(@B).tmp4 $@
    @del $(O)\$(@B).tmp3 $(O)\$(@B).tmp4
!endif
    @del $(O)\$(@B).tmp1
    @del $(O)\$(@B).tmp2
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

!if $(WIN64)
$(O)\mdac.wow: $(O)\mdac.inf
!endif

$(O)\mdacwx86.inf: $(_INX)\mdacwx86.inx $(_LNG)\mdac.txt
    $(CC) $(PREFLAGS) $(_LNG)\mdac.txt > mdac.txt1
    copy $(_INX)\$(@B).inx+mdac.txt1 $(O)\$(@B).tmp1
    prodfilt $(O)\$(@B).tmp1 $(O)\$(@B).tmp2 +$(PRODSWITCH)
    prodfilt $(O)\$(@B).tmp2 $@ +$(PLATFORM_SWITCH)
    @del $(O)\$(@B).tmp1
    @del $(O)\$(@B).tmp2
    @del mdac.txt1
    $(TSBINPLACE_CMD)

$(O)\multimed.inf: $(_INX)\multimed.inx \
!if $(WIN64)
                   $(O)\wowlist.inf \
!endif
                   $(_LNG)\multimed.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $(O)\$(@B).tmp1
    prodfilt $(O)\$(@B).tmp1 $(O)\$(@B).tmp2 +$(PLATFORM_SWITCH)
    prodfilt $(O)\$(@B).tmp2 $@ +$(PRODSWITCH)
!if $(WIN64)
    copy $@ $(O)\$(@B).tmp3
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $(O)\$(@B).tmp1
    prodfilt $(O)\$(@B).tmp1 $(O)\$(@B).tmp2 +i
    prodfilt $(O)\$(@B).tmp2 $(O)\$(@B).tmp1 +@
    wowlist -i $(O)\$(@B).tmp1 -c $(O)\wowlist.inf -as -f w -d $(O)\multimed.wow -o $(O)\$(@B).tmp4
    copy $(O)\$(@B).tmp3+$(O)\$(@B).tmp4 $@
    @del $(O)\$(@B).tmp3 $(O)\$(@B).tmp4
!endif
    @del $(O)\$(@B).tmp1
    @del $(O)\$(@B).tmp2
    @del $(O)\$(@B).txt1
    $(TSBINPLACE_CMD)

!if $(WIN64)
$(O)\multimed.wow: $(O)\multimed.inf
!endif


$(O)\pinball.inf: $(_INX)\pinball.inx \
!if $(WIN64)
                  $(O)\wowlist.inf \
!endif
                  $(_LNG)\pinball.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $(O)\$(@B).tmp1
    prodfilt $(O)\$(@B).tmp1 $(O)\$(@B).tmp2 +$(PLATFORM_SWITCH)
    prodfilt $(O)\$(@B).tmp2 $@ +$(PRODSWITCH)
!if $(WIN64)
    copy $@ $(O)\$(@B).tmp3
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $(O)\$(@B).tmp1
    prodfilt $(O)\$(@B).tmp1 $(O)\$(@B).tmp2 +i
    prodfilt $(O)\$(@B).tmp2 $(O)\$(@B).tmp1 +@
    wowlist -i $(O)\$(@B).tmp1 -c $(O)\wowlist.inf -as -f w -d $(O)\pinball.wow -o $(O)\$(@B).tmp4
    copy $(O)\$(@B).tmp3+$(O)\$(@B).tmp4 $@
    @del $(O)\$(@B).tmp3 $(O)\$(@B).tmp4
!endif
    @del $(O)\$(@B).tmp1
    @del $(O)\$(@B).tmp2
    @del $(O)\$(@B).txt1
    $(TSBINPLACE_CMD)

!if $(WIN64)
$(O)\pinball.wow: $(O)\pinball.inf
!endif


$(O)\sapi5.inf: $(_INX)\sapi5.inx \
                $(_LNG)\sapi5.txt
    $(CC) $(PREFLAGS) /nologo /c /EP $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    unitext -m -o $(O)\$(@B).txt1 $(O)\$(@B).txt2
    copy /b $(_INX)\$(@B).inx+$(O)\$(@B).txt2 $(O)\$(@B).tmp1
    prodfilt -u $(O)\$(@B).tmp1 $(O)\$(@B).tmp2 +$(PRODSWITCH)
    prodfilt -u $(O)\$(@B).tmp2 $@ +$(PLATFORM_SWITCH)
    @del $(O)\$(@B).tmp1
    @del $(O)\$(@B).tmp2
    @del $(O)\$(@B).txt1
    @del $(O)\$(@B).txt2
    $(STAMP)
    $(TSBINPLACE_CMD)


$(O)\wordpad.inf: $(_INX)\wordpad.inx \
!if $(WIN64)
                  $(O)\wowlist.inf \
!endif
                  $(_LNG)\wordpad.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $(O)\$(@B).tmp1
    prodfilt $(O)\$(@B).tmp1 $(O)\$(@B).tmp2 +$(PLATFORM_SWITCH)
    prodfilt $(O)\$(@B).tmp2 $@ +$(PRODSWITCH)
!if $(WIN64)
    copy $@ $(O)\$(@B).tmp3
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $(O)\$(@B).tmp1
    prodfilt $(O)\$(@B).tmp1 $(O)\$(@B).tmp2 +i
    prodfilt $(O)\$(@B).tmp2 $(O)\$(@B).tmp1 +@
    wowlist -i $(O)\$(@B).tmp1 -c $(O)\wowlist.inf -as -f w -d $(O)\wordpad.wow -o $(O)\$(@B).tmp4
    copy $(O)\$(@B).tmp3+$(O)\$(@B).tmp4 $@
    @del $(O)\$(@B).tmp3 $(O)\$(@B).tmp4
!endif
    @del $(O)\$(@B).tmp1
    @del $(O)\$(@B).tmp2
    @del $(O)\$(@B).txt1
    $(TSBINPLACE_CMD)

!if $(WIN64)
$(O)\wordpad.wow: $(O)\wordpad.inf
!endif

$(O)\devxprop.inf: $(_INX)\devxprop.inx $(_LNG)\devxprop.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $(O)\$(@B).tmp1
    prodfilt $(O)\$(@B).tmp1 $@ +$(PRODSWITCH)
    @del $(O)\$(@B).tmp1
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\devxprop.inf: $(_INX)\devxprop.inx $(_LNG)\devxprop.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $(O)\$(@B).tmp1
    prodfilt $(O)\$(@B).tmp1 $@ +$(PRODSWITCH)
    @del $(O)\$(@B).tmp1
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\shell.inf: $(_INX)\shell.inx $(_LNG)\shell.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $(O)\$(@B).tmp1
    prodfilt $(O)\$(@B).tmp1 $@ +$(PRODSWITCH)
    @del $(O)\$(@B).tmp1
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\shl_img.inf: $(_INX)\shl_img.inx $(_LNG)\shl_img.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $(O)\$(@B).tmp1
    prodfilt -s $(O)\$(@B).tmp1 $(O)\$(@B).tmp2 +$(PRODSWITCH)
    prodfilt -s $(O)\$(@B).tmp2 $@ +$(PLATFORM_SWITCH)
    @del $(O)\$(@B).tmp1
    @del $(O)\$(@B).tmp2
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\shellmui.inf: $(_INX)\shellmui.inx $(_LNG)\shellmui.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $(O)\$(@B).tmp1
    prodfilt $(O)\$(@B).tmp1 $@ +$(PRODSWITCH)
    @del $(O)\$(@B).tmp1
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\skinsmui.inf: $(_INX)\skinsmui.inx $(_LNG)\skinsmui.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(@B).txt1
    copy $(_INX)\$(@B).inx+$(@B).txt1 $(@B).tmp1
    prodfilt $(@B).tmp1 $(@B).tmp2 +$(PLATFORM_SWITCH)
    prodfilt $(@B).tmp2 $@ +$(PRODSWITCH)
    @del $(@B).tmp1
    @del $(@B).tmp2
    @del $(@B).txt1
    $(TSBINPLACE_CMD)

$(O)\wmprfmui.inf: $(_INX)\wmprfmui.inx $(_LNG)\wmprfmui.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(@B).txt1
    $(CC) $(PREFLAGS) $(_INX)\$(@B).inx > $(O)\$(@B).inx1
    copy $(O)\$(@B).inx1+$(@B).txt1 $(@B).tmp1
    prodfilt $(@B).tmp1 $(@B).tmp2 +$(PLATFORM_SWITCH)
    prodfilt $(@B).tmp2 $@ +$(PRODSWITCH)
    @del $(@B).tmp1
    @del $(@B).tmp2
    @del $(@B).txt1
    @del $(O)\$(@B).inx1
    $(TSBINPLACE_CMD)

$(O)\wmtrmui.inf: $(_INX)\wmtrmui.inx $(_LNG)\wmtrmui.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(@B).txt1
    copy $(_INX)\$(@B).inx+$(@B).txt1 $(@B).tmp1
    prodfilt $(@B).tmp1 $(@B).tmp2 +$(PLATFORM_SWITCH)
    prodfilt $(@B).tmp2 $@ +$(PRODSWITCH)
    @del $(@B).tmp1
    @del $(@B).tmp2
    @del $(@B).txt1
    $(TSBINPLACE_CMD)

$(O)\srchasst.inf: $(_INX)\srchasst.inx $(_LNG)\srchasst.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(@B).txt1
    copy $(_INX)\$(@B).inx+$(@B).txt1 $(@B).tmp1
    prodfilt $(@B).tmp1 $(@B).tmp2 +$(PLATFORM_SWITCH)
    prodfilt $(@B).tmp2 $@ +$(PRODSWITCH)
    @del $(@B).tmp1
    @del $(@B).tmp2
    @del $(@B).txt1
    $(TSBINPLACE_CMD)

$(O)\srchmui.inf: $(_INX)\srchmui.inx $(_LNG)\srchmui.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $(O)\$(@B).tmp1
    prodfilt $(O)\$(@B).tmp1 $(O)\$(@B).tmp2 +$(PRODSWITCH)
    prodfilt $(O)\$(@B).tmp2 $@ +$(PLATFORM_SWITCH)
    @del $(O)\$(@B).tmp1
    @del $(O)\$(@B).tmp2
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\sysoc.inf: $(_INX)\sysoc.inx $(_LNG)\sysoc.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $(O)\$(@B).tmp1
    prodfilt -s $(O)\$(@B).tmp1 $(O)\$(@B).tmp2 +$(PRODSWITCH)
    prodfilt -s $(O)\$(@B).tmp2 $@ +$(PLATFORM_SWITCH)
    @del $(O)\$(@B).tmp1
    @del $(O)\$(@B).tmp2
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)



# using the sysoc.txt file for strings.
$(O)\asroc.inf: $(_INX)\asroc.inx $(_LNG)\sysoc.txt
    $(CC) $(PREFLAGS) $(_LNG)\sysoc.txt > sysoc.txt1
    copy $(_INX)\$(@B).inx+sysoc.txt1 $(O)\$(@B).tmp1
    prodfilt $(O)\$(@B).tmp1 $(O)\$(@B).tmp2 +$(PRODSWITCH)
    prodfilt $(O)\$(@B).tmp2 $@ +$(PLATFORM_SWITCH)
    @del $(O)\$(@B).tmp1
    @del $(O)\$(@B).tmp2
    @del sysoc.txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\ntprint.inf: $(_INX)\ntprint.inx $(_INX)\feprint.inx \
                     $(_LNG)\ntprint.txt
    $(CC) $(PREFLAGS) -I$(_INX) $(_INX)\ntprint.inx > $(O)\$(@B).txt1
    prodfilt $(O)\$(@B).txt1  $(O)\$(@B).tmp1 +$(PLATFORM_SWITCH)
    $(CC) $(PREFLAGS) -I$(_INX) $(_LNG)\ntprint.txt > $(O)\$(@B).txt2
    prodfilt $(O)\$(@B).txt2  $(O)\$(@B).tmp2 +$(PLATFORM_SWITCH)
    unitext $(UNITEXT_OPT) $(O)\$(@B).tmp1 $(O)\$(@B).tmp11
    unitext $(UNITEXT_OPT) $(O)\$(@B).tmp2 $(O)\$(@B).tmp22
    copy $(O)\$(@B).tmp11+$(O)\$(@B).tmp22 $@
    @del $(O)\$(@B).tmp1 $(O)\$(@B).tmp2
    @del $(O)\$(@B).tmp11 $(O)\$(@B).tmp22
    @del $(O)\$(@B).txt1 $(O)\$(@B).txt2
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\prtupg9x.inf: $(_INX)\prtupg9x.inx $(_LNG)\prtupg9x.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $@
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\printupg.inf: $(_INX)\printupg.inx $(_LNG)\printupg.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $@
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\bfax.inf: $(_INX)\bfax.inx $(_LNG)\bfax.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $@
    @del $(O)\$(@B).txt1
    $(TSBINPLACE_CMD)

$(O)\bfcab.inf: $(_INX)\bfcab.inx $(_LNG)\bfcab.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $(O)\$(@B).tmp1
    prodfilt $(O)\$(@B).tmp1 $(O)\$(@B).tmp2 +$(PRODSWITCH)
    prodfilt $(O)\$(@B).tmp2 $@ +$(PLATFORM_SWITCH)
    @del $(O)\$(@B).tmp1
    @del $(O)\$(@B).tmp2
    @del $(O)\$(@B).txt1
    $(TSBINPLACE_CMD)

$(O)\brmfcmdm.inf: $(_INX)\brmfcmdm.inx $(_LNG)\brmfcmdm.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $@
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\brmfcmf.inf: $(_INX)\brmfcmf.inx $(_LNG)\brmfcmf.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $@
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\brmfcsto.inf: $(_INX)\brmfcsto.inx $(_LNG)\brmfcsto.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $@
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\brmfcumd.inf: $(_INX)\brmfcumd.inx $(_LNG)\brmfcumd.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $@
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\brmfcwia.inf: $(_INX)\brmfcwia.inx $(_LNG)\brmfcwia.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $@
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\brmfport.inf: $(_INX)\brmfport.inx $(_LNG)\brmfport.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $@
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\apps.inf: $(_INX)\apps.inx $(_LNG)\apps.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $@
    @del $(O)\$(@B).txt1
    $(TSBINPLACE_CMD)

$(O)\apcompat.inf: $(_INX)\apcompat.inx \
!if $(WIN64)
                   $(O)\wowlist.inf \
!endif
                   $(_LNG)\apcompat.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $@
!if $(WIN64)
    copy $@ $(O)\$(@B).tmp3
    wowlist -i $@ -c $(O)\wowlist.inf -as -f w -d $(O)\apcompat.wow -o $(O)\$(@B).tmp4
    copy $(O)\$(@B).tmp3+$(O)\$(@B).tmp4 $@
    @del $(O)\$(@B).tmp3 $(O)\$(@B).tmp4
!endif
    @del $(O)\$(@B).txt1
    $(TSBINPLACE_CMD)

!if $(WIN64)
$(O)\apcompat.wow: $(O)\apcompat.inf
!endif

$(O)\keyboard.inf: $(_INX)\keyboard.inx $(_LNG)\keyboard.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $(O)\$(@B).tmp1
    prodfilt $(O)\$(@B).tmp1 $@ +$(PLATFORM_SWITCH)
    @del $(O)\$(@B).tmp1
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\langinst.inf: $(_INX)\langinst.inx $(_LNG)\langinst.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $@
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\legcydrv.inf: $(_INX)\legcydrv.inx $(_LNG)\legcydrv.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $@
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\lwusbhid.inf: $(_INX)\lwusbhid.inx $(_LNG)\lwusbhid.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $@
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\lwngmadi.inf: $(_INX)\lwngmadi.inx $(_LNG)\lwngmadi.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $@
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)


$(O)\machine.inf: $(_INX)\machine.inx $(_LNG)\machine.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $(O)\$(@B).tmp1
    prodfilt $(O)\$(@B).tmp1 $(O)\$(@B).tmp2 +$(PRODSWITCH)
    prodfilt $(O)\$(@B).tmp2 $@ +$(PLATFORM_SWITCH)
    @del $(O)\$(@B).tmp1
    @del $(O)\$(@B).tmp2
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

!if $(IA64)
$(O)\IA32Exec.inf: $(_INX)\IA32Exec.inx $(_LNG)\IA32Exec.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $(O)\$(@B).tmp1
    prodfilt $(O)\$(@B).tmp1 $(O)\$(@B).tmp2 +$(PRODSWITCH)
    prodfilt $(O)\$(@B).tmp2 $@ +$(PLATFORM_SWITCH)
    @del $(O)\$(@B).tmp1
    @del $(O)\$(@B).tmp2
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)
!endif

$(O)\sa.inf: $(_INX)\sa.inx $(_LNG)\sa.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $(O)\$(@B).tmp1
    prodfilt $(O)\$(@B).tmp1 $(O)\$(@B).tmp2 +$(PRODSWITCH)
    prodfilt $(O)\$(@B).tmp2 $@ +$(PLATFORM_SWITCH)
    @del $(O)\$(@B).tmp1
    @del $(O)\$(@B).tmp2
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\wd.inf: $(_INX)\wd.inx $(_LNG)\wd.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $(O)\$(@B).tmp1
    prodfilt $(O)\$(@B).tmp1 $(O)\$(@B).tmp2 +$(PRODSWITCH)
    prodfilt $(O)\$(@B).tmp2 $@ +$(PLATFORM_SWITCH)
    @del $(O)\$(@B).tmp1
    @del $(O)\$(@B).tmp2
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\mchgr.inf: $(_INX)\mchgr.inx $(_LNG)\mchgr.txt
    $(CC) $(PREFLAGS) $(PREFILTFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    $(CC) $(PREFILTFLAGS) $(_INX)\$(@B).inx > $(O)\$(@B).inx1
    copy $(O)\$(@B).inx1+$(O)\$(@B).txt1 $@
    @del $(O)\$(@B).txt1
    @del $(O)\$(@B).inx1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\mshdc.inf: $(_INX)\mshdc.inx $(_LNG)\mshdc.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $(O)\$(@B).tmp1
    prodfilt $(O)\$(@B).tmp1 $@ +$(PLATFORM_SWITCH)
    @del $(O)\$(@B).tmp1
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\flash.inf: $(_INX)\flash.inx $(_LNG)\flash.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $@
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\msmouse.inf: $(_INX)\msmouse.inx $(_LNG)\msmouse.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $(O)\$(@B).tmp1
    prodfilt $(O)\$(@B).tmp1 $@ +$(PLATFORM_SWITCH)
    @del $(O)\$(@B).tmp1
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\msports.inf: $(_INX)\msports.inx $(_LNG)\msports.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $(O)\$(@B).tmp1
    prodfilt $(O)\$(@B).tmp1 $@ +$(PLATFORM_SWITCH)
    @del $(O)\$(@B).tmp1
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\cyclad-z.inf: $(_INX)\cyclad-z.inx $(_LNG)\cyclad-z.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $(O)\$(@B).tmp1
    prodfilt $(O)\$(@B).tmp1 $@ +$(PLATFORM_SWITCH)
    @del $(O)\$(@B).tmp1
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\cyclom-y.inf: $(_INX)\cyclom-y.inx $(_LNG)\cyclom-y.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $(O)\$(@B).tmp1
    prodfilt $(O)\$(@B).tmp1 $@ +$(PLATFORM_SWITCH)
    @del $(O)\$(@B).tmp1
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\cyyport.inf: $(_INX)\cyyport.inx $(_LNG)\cyyport.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $(O)\$(@B).tmp1
    prodfilt $(O)\$(@B).tmp1 $@ +$(PLATFORM_SWITCH)
    @del $(O)\$(@B).tmp1
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\cyzport.inf: $(_INX)\cyzport.inx $(_LNG)\cyzport.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $(O)\$(@B).tmp1
    prodfilt $(O)\$(@B).tmp1 $@ +$(PLATFORM_SWITCH)
    @del $(O)\$(@B).tmp1
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\mxboard.inf: $(_INX)\mxboard.inx $(_LNG)\mxboard.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $@
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\mxport.inf: $(_INX)\mxport.inx $(_LNG)\mxport.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $@
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\wceusbsh.inf: $(_INX)\wceusbsh.inx $(_LNG)\wceusbsh.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $@
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\multiprt.inf: $(_INX)\multiprt.inx $(_LNG)\multiprt.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $@
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\ntapm.inf: $(_INX)\ntapm.inx $(_LNG)\ntapm.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $(O)\$(@B).tmp1
    prodfilt $(O)\$(@B).tmp1 $@ +$(PLATFORM_SWITCH)
    @del $(O)\$(@B).tmp1
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\pnpscsi.inf: $(_INX)\pnpscsi.inx $(_LNG)\pnpscsi.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    $(CC) $(PREFILTFLAGS) $(_INX)\$(@B).inx > $(O)\$(@B).inx1
    copy $(O)\$(@B).inx1+$(O)\$(@B).txt1 $@
    @del $(O)\$(@B).tmp1
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\ramdisk.inf: $(_INX)\ramdisk.inx $(_LNG)\ramdisk.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $@
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)


!if !$(WIN64)
$(O)\scsi.inf: $(_INX)\scsi.inx $(_LNG)\scsi.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    $(CC) $(PREFILTFLAGS) $(_INX)\$(@B).inx > $(O)\$(@B).inx1
    copy $(O)\$(@B).inx1+$(O)\$(@B).txt1 $@
    @del $(O)\$(@B).tmp1
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)
!endif

$(O)\scsidev.inf: $(_INX)\scsidev.inx $(_LNG)\scsidev.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $(O)\$(@B).tmp1
    prodfilt $(O)\$(@B).tmp1 $@ +$(PLATFORM_SWITCH)
    @del $(O)\$(@B).tmp1
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\sdwndr2k.inf: $(_INX)\sdwndr2k.inx $(_LNG)\sdwndr2k.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $(O)\$(@B).tmp1
    prodfilt -s $(O)\$(@B).tmp1 $@ +@
    @del $(O)\$(@B).tmp1
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\smartcrd.inf: $(_INX)\smartcrd.inx $(_LNG)\smartcrd.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $@
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\swflash.inf: $(_INX)\swflash.inx $(_LNG)\swflash.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $@
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\swnt.inf: $(_INX)\swnt.inx $(_LNG)\swnt.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $(O)\$(@B).tmp1
    prodfilt $(O)\$(@B).tmp1 $@ +$(PRODSWITCH)
    @del $(O)\$(@B).tmp1
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\tape.inf: $(_INX)\tape.inx $(_LNG)\tape.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $@
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\uddi.inf: $(_INX)\uddi.inx $(_LNG)\uddi.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $(O)\$(@B).tmp1
    prodfilt $(O)\$(@B).tmp1 $@ +$(PRODSWITCH)
    @del $(O)\$(@B).tmp1
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)


$(O)\vgx.inf: $(_INX)\vgx.inx \
!if $(WIN64)
              $(O)\wowlist.inf \
!endif
              $(_LNG)\vgx.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $@
!if $(WIN64)
    copy $@ $(O)\$(@B).tmp3
    wowlist -i $@ -c $(O)\wowlist.inf -as -f w -d $(O)\vgx.wow -o $(O)\$(@B).tmp4
    copy $(O)\$(@B).tmp3+$(O)\$(@B).tmp4 $@
    @del $(O)\$(@B).tmp3 $(O)\$(@B).tmp4
!endif
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

!if $(WIN64)
$(O)\vgx.wow: $(O)\vgx.inf
!endif

$(O)\volume.inf: $(_INX)\volume.inx $(_LNG)\volume.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $@
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\volsnap.inf: $(_INX)\volsnap.inx $(_LNG)\volsnap.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $@
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\prodspec.ini: $(_INX)\prodspec.inx $(_LNG)\prodspec.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $(O)\$(@B).tmp1
    prodfilt $(O)\$(@B).tmp1 $(O)\$(@B).tmp2 +$(PRODSWITCH)
    prodfilt $(O)\$(@B).tmp2 $@ +$(PLATFORM_SWITCH)
    @del $(O)\$(@B).tmp1
    @del $(O)\$(@B).tmp2
    @del $(O)\$(@B).txt1
    echo BitVersion=40 >> $@
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\prod128.ini: $(_INX)\prodspec.inx $(_LNG)\prodspec.txt
    $(CC) $(PREFLAGS) $(_LNG)\prodspec.txt > prodspec.txt1
    copy $(_INX)\prodspec.inx+prodspec.txt1 $(O)\$(@B).tmp1
    prodfilt $(O)\$(@B).tmp1 $(O)\$(@B).tmp2 +$(PRODSWITCH)
    prodfilt $(O)\$(@B).tmp2 $@ +$(PLATFORM_SWITCH)
    @del $(O)\$(@B).tmp1
    @del $(O)\$(@B).tmp2
    @del prodspec.txt1
    echo BitVersion=128 >> $@
    $(STAMP)
    $(TSBINPLACE_CMD)

!if $(386)

$(O)\win95upg.inf: $(_INX)\win95upg.inx $(_LNG)\win95upg.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $(O)\$(@B).tmp1
    prodfilt $(O)\$(@B).tmp1 $(O)\$(@B).tmp2 +$(PLATFORM_SWITCH)
    prodfilt $(O)\$(@B).tmp2 $@ +$(PRODSWITCH)
    @del $(O)\$(@B).tmp1
    @del $(O)\$(@B).tmp2
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(WIN9XUPGBINPLACE_CMD)

$(O)\migdb.inf: $(_INX)\migdb.inx $(_LNG)\migdb.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $(O)\$(@B).tmp1
    prodfilt $(O)\$(@B).tmp1 $(O)\$(@B).tmp2 +$(PLATFORM_SWITCH)
    prodfilt $(O)\$(@B).tmp2 $@ +$(PRODSWITCH)
    @del $(O)\$(@B).tmp1
    @del $(O)\$(@B).tmp2
    @del $(O)\$(@B).txt1
    @del $(O)\$(@B).tmpInx
    $(STAMP)
    $(WIN9XUPGBINPLACE_CMD)

$(O)\vscandb.inf: $(_INX)\vscandb.inx $(_LNG)\vscandb.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $(O)\$(@B).tmp1
    prodfilt $(O)\$(@B).tmp1 $(O)\$(@B).tmp2 +$(PLATFORM_SWITCH)
    prodfilt $(O)\$(@B).tmp2 $@ +$(PRODSWITCH)
    @del $(O)\$(@B).tmp1
    @del $(O)\$(@B).tmp2
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(WIN9XUPGBINPLACE_CMD)

$(O)\wkstamig.inf: $(_INX)\wkstamig.inx $(_LNG)\wkstamig.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $(O)\$(@B).tmp1
    prodfilt $(O)\$(@B).tmp1 $(O)\$(@B).tmp2 +$(PLATFORM_SWITCH)
    prodfilt $(O)\$(@B).tmp2 $@ +$(PRODSWITCH)
    @del $(O)\$(@B).tmp1
    @del $(O)\$(@B).tmp2
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\usermig.inf: $(_INX)\usermig.inx $(_LNG)\usermig.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $(O)\$(@B).tmp1
    prodfilt $(O)\$(@B).tmp1 $(O)\$(@B).tmp2 +$(PLATFORM_SWITCH)
    prodfilt $(O)\$(@B).tmp2 $@ +$(PRODSWITCH)
    @del $(O)\$(@B).tmp1
    @del $(O)\$(@B).tmp2
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

!endif

$(O)\filegen.inf: $(_INX)\filegen.inx $(_LNG)\filegen.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $(O)\$(@B).tmp1
    prodfilt $(O)\$(@B).tmp1 $(O)\$(@B).tmp2 +$(PRODSWITCH)
    prodfilt $(O)\$(@B).tmp2 $@ +$(PLATFORM_SWITCH)
    @del $(O)\$(@B).tmp1
    @del $(O)\$(@B).tmp2
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\ntautorun.inf: $(_INX)\ntautorun.inx $(_LNG)\ntautorun.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy /A $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $@
    @del $(O)\$(@B).txt1
    $(TSBINPLACE_CMD)

$(O)\acpi.inf: $(_INX)\acpi.inx $(_LNG)\acpi.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $(O)\$(@B).tmp1
    prodfilt $(O)\$(@B).tmp1 $(O)\$(@B).tmp2 +$(PRODSWITCH)
    prodfilt $(O)\$(@B).tmp2 $@ +$(PLATFORM_SWITCH)
    @del $(O)\$(@B).tmp1
    @del $(O)\$(@B).tmp2
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\hidserv.inf: $(_INX)\hidserv.inx $(_LNG)\hidserv.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $@
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\irbus.inf: $(_INX)\irbus.inx $(_LNG)\irbus.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $@
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\input.inf: $(_INX)\input.inx $(_LNG)\input.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $(O)\$(@B).tmp1
    prodfilt $(O)\$(@B).tmp1 $(O)\$(@B).tmp2 +$(PRODSWITCH)
    prodfilt $(O)\$(@B).tmp2 $@ +$(PLATFORM_SWITCH)
    @del $(O)\$(@B).tmp1
    @del $(O)\$(@B).tmp2
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\ippocm.inf: $(_INX)\ippocm.inx $(_LNG)\ippocm.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $@
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\usbprint.inf: $(_INX)\usbprint.inx $(_LNG)\usbprint.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $@
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\usb.inf: $(_INX)\usb.inx $(_LNG)\usb.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $(O)\$(@B).tmp1
    prodfilt $(O)\$(@B).tmp1 $@ +$(PLATFORM_SWITCH)
    @del $(O)\$(@B).tmp1
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\usbstor.inf: $(_INX)\usbstor.inx $(_LNG)\usbstor.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $@
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\usbport.inf: $(_INX)\usbport.inx $(_LNG)\usbport.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $@
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\ccdecode.inf: $(_INX)\ccdecode.inx $(_LNG)\ccdecode.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $@
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\nabtsfec.inf: $(_INX)\nabtsfec.inx $(_LNG)\nabtsfec.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $@
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\wstcodec.inf: $(_INX)\wstcodec.inx $(_LNG)\wstcodec.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $@
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\cdrom.inf: $(_INX)\cdrom.inx $(_LNG)\cdrom.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $@
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\cpu.inf: $(_INX)\cpu.inx $(_LNG)\cpu.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(@B).txt1
    copy $(_INX)\$(@B).inx+$(@B).txt1 $@
    @del $(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\disk.inf: $(_INX)\disk.inx $(_LNG)\disk.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $@
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\gameport.inf: $(_INX)\gameport.inx $(_LNG)\gameport.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $(O)\$(@B).tmp1
    prodfilt $(O)\$(@B).tmp1 $(O)\$(@B).tmp2 +$(PRODSWITCH)
    prodfilt $(O)\$(@B).tmp2 $@ +$(PLATFORM_SWITCH)
    @del $(O)\$(@B).tmp1
    @del $(O)\$(@B).tmp2
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\wdmjoy.inf: $(_INX)\wdmjoy.inx $(_LNG)\wdmjoy.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $(O)\$(@B).tmp1
    prodfilt $(O)\$(@B).tmp1 $@ +$(PLATFORM_SWITCH)
    @del $(O)\$(@B).tmp1
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\ntgrip.inf: $(_INX)\ntgrip.inx $(_LNG)\ntgrip.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $@
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

# Alway filter for server product, other products used for other builds
$(O)\dimaps.inf: $(_INX)\dimaps.inx $(_LNG)\dimaps.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $(O)\$(@B).tmp1
    prodfilt $(O)\$(@B).tmp1 $(O)\$(@B).tmp2 +s
    prodfilt $(O)\$(@B).tmp2 $@ +$(PLATFORM_SWITCH)
    @del $(O)\$(@B).tmp1
    @del $(O)\$(@B).tmp2
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\battery.inf: $(_INX)\battery.inx $(_LNG)\battery.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $(O)\$(@B).tmp1
    prodfilt $(O)\$(@B).tmp1 $(O)\$(@B).tmp2 +$(PRODSWITCH)
    prodfilt $(O)\$(@B).tmp2 $@ +$(PLATFORM_SWITCH)
    @del $(O)\$(@B).tmp1
    @del $(O)\$(@B).tmp2
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\pcmcia.inf: $(_INX)\pcmcia.inx $(_LNG)\pcmcia.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $(O)\$(@B).tmp1
    prodfilt $(O)\$(@B).tmp1 $@ +$(PLATFORM_SWITCH)
    @del $(O)\$(@B).tmp1
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\memcard.inf: $(_INX)\memcard.inx $(_LNG)\memcard.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $@
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\memory.inf: $(_INX)\memory.inx $(_LNG)\memory.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(@B).txt1
    copy $(_INX)\$(@B).inx+$(@B).txt1 $@
    @del $(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\memstpci.inf: $(_INX)\memstpci.inx $(_LNG)\memstpci.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $@
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\sonypvu1.inf: $(_INX)\sonypvu1.inx $(_LNG)\sonypvu1.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $@
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\mf.inf: $(_INX)\mf.inx $(_LNG)\mf.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $@
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\mfsocket.inf: $(_INX)\mfsocket.inx $(_LNG)\mfsocket.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $@
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\1394.inf: $(_INX)\1394.inx $(_LNG)\1394.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $(O)\$(@B).tmp1
    prodfilt $(O)\$(@B).tmp1 $@ +$(PLATFORM_SWITCH)
    @del $(O)\$(@B).tmp1
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\sbp2.inf: $(_INX)\sbp2.inx $(_LNG)\sbp2.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $@
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\61883.inf: $(_INX)\61883.inx $(_LNG)\61883.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $@
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\avc.inf: $(_INX)\avc.inx $(_LNG)\avc.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $@
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\oobe.inf: $(_INX)\oobe.inx $(_LNG)\oobe.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $(O)\$(@B).tmp1
    prodfilt $(O)\$(@B).tmp1 $(O)\$(@B).tmp2 +$(PRODSWITCH)
    prodfilt $(O)\$(@B).tmp2 $@ +$(PLATFORM_SWITCH)
    @del $(O)\$(@B).tmp1
    @del $(O)\$(@B).tmp2
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\oobemui.inf: $(_INX)\oobemui.inx $(_LNG)\oobemui.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $(O)\$(@B).tmp1
    prodfilt $(O)\$(@B).tmp1 $(O)\$(@B).tmp2 +$(PRODSWITCH)
    prodfilt $(O)\$(@B).tmp2 $@ +$(PLATFORM_SWITCH)
    @del $(O)\$(@B).tmp1
    @del $(O)\$(@B).tmp2
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\genprint.inf: $(_INX)\genprint.inx $(_LNG)\genprint.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $@
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\guidrvs.inf: $(_INX)\guidrvs.inx
    prodfilt $(_INX)\guidrvs.inx $(O)\$(@B).tmp +$(PRODSWITCH)
    prodfilt $(O)\$(@B).tmp $@ +$(PLATFORM_SWITCH)
    @del $(O)\$(@B).tmp
    $(TSBINPLACE_CMD)

$(O)\icam3.inf: $(_INX)\icam3.inx $(_LNG)\icam3.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $@
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\icam4usb.inf: $(_INX)\icam4usb.inx $(_LNG)\icam4usb.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $@
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\icam5usb.inf: $(_INX)\icam5usb.inx $(_LNG)\icam5usb.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $@
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\image.inf: $(_INX)\image.inx $(_LNG)\image.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $(O)\$(@B).tmp
    prodfilt $(O)\$(@B).tmp $@ +$(PLATFORM_SWITCH)
    @del $(O)\$(@B).tmp
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\ovcam.inf: $(_INX)\ovcam.inx $(_LNG)\ovcam.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $@
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\ovcomp.inf: $(_INX)\ovcomp.inx $(_LNG)\ovcomp.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $@
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\ovsound.inf: $(_INX)\ovsound.inx $(_LNG)\ovsound.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $@
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\msdv.inf: $(_INX)\msdv.inx $(_LNG)\msdv.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $@
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\mstape.inf: $(_INX)\mstape.inx $(_LNG)\mstape.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $@
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\tsbvcap.inf: $(_INX)\tsbvcap.inx $(_LNG)\tsbvcap.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $@
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\ibmvcap.inf: $(_INX)\ibmvcap.inx $(_LNG)\ibmvcap.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $@
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\sslaccel.inf: $(_INX)\sslaccel.inx $(_LNG)\sslaccel.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    $(CC) $(PREFILTFLAGS) $(_INX)\$(@B).inx > $(O)\$(@B).inx1
    copy $(O)\$(@B).inx1+$(O)\$(@B).txt1 $@
    @del $(O)\$(@B).tmp1
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\sti.inf: $(_INX)\sti.inx $(_LNG)\sti.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $(O)\$(@B).tmp1
    prodfilt $(O)\$(@B).tmp1 $(O)\$(@B).tmp2 +$(PRODSWITCH)
    prodfilt $(O)\$(@B).tmp2 $@ +$(PLATFORM_SWITCH)
    @del $(O)\$(@B).tmp1
    @del $(O)\$(@B).tmp2
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\ricoh.inf: $(_INX)\ricoh.inx $(_LNG)\ricoh.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $@
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\kdkscan.inf: $(_INX)\kdkscan.inx $(_LNG)\kdkscan.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $@
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\srusbusd.inf: $(_INX)\srusbusd.inx $(_LNG)\srusbusd.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $@
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\hpdigwia.inf: $(_INX)\hpdigwia.inx $(_LNG)\hpdigwia.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $@
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\dot4.inf: $(_INX)\dot4.inx $(_LNG)\dot4.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $@
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\dot4prt.inf: $(_INX)\dot4prt.inx $(_LNG)\dot4prt.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $@
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\hpojscan.inf: $(_INX)\hpojscan.inx $(_LNG)\hpojscan.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $@
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\hpscan.inf: $(_INX)\hpscan.inx $(_LNG)\hpscan.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $(O)\$(@B).tmp1
    prodfilt $(O)\$(@B).tmp1 $(O)\$(@B).tmp2 +$(PRODSWITCH)
    prodfilt $(O)\$(@B).tmp2 $@ +$(PLATFORM_SWITCH)
    @del $(O)\$(@B).tmp1
    @del $(O)\$(@B).tmp2
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\xscan_xp.inf: $(_INX)\xscan_xp.inx $(_LNG)\xscan_xp.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $@
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\pmxmcro.inf: $(_INX)\pmxmcro.inx $(_LNG)\pmxmcro.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $@
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)


$(O)\epcfw2k.inf: $(_INX)\epcfw2k.inx $(_LNG)\epcfw2k.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $@
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\epsnscan.inf: $(_INX)\epsnscan.inx $(_LNG)\epsnscan.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $@
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\epsnmfp.inf: $(_INX)\epsnmfp.inx $(_LNG)\epsnmfp.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $@
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\epstw2k.inf: $(_INX)\epstw2k.inx $(_LNG)\epstw2k.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $@
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\fjtscan.inf: $(_INX)\fjtscan.inx $(_LNG)\fjtscan.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $@
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\acerscan.inf: $(_INX)\acerscan.inx $(_LNG)\acerscan.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $@
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)


$(O)\kdk2x0.inf: $(_INX)\kdk2x0.inx $(_LNG)\kdk2x0.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $@
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\ptpusb.inf: $(_INX)\ptpusb.inx $(_LNG)\ptpusb.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $@
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\bda.inf: $(_INX)\bda.inx $(_LNG)\bda.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $@
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\mscpqpa1.inf: $(_INX)\mscpqpa1.inx $(_LNG)\mscpqpa1.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $@
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\msnike.inf: $(_INX)\msnike.inx $(_LNG)\msnike.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $@
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\msrio.inf: $(_INX)\msrio.inx $(_LNG)\msrio.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $@
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\msrio8.inf: $(_INX)\msrio8.inx $(_LNG)\msrio8.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $@
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\mpe.inf: $(_INX)\mpe.inx $(_LNG)\mpe.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $@
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\ndisip.inf: $(_INX)\ndisip.inx $(_LNG)\ndisip.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $@
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\netaarps.inf: $(_INX)\netaarps.inx $(_LNG)\netaarps.txt
    copy $(_INX)\$(@B).inx+$(_LNG)\$(@B).txt $@
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\netatlk.inf: $(_INX)\netatlk.inx $(_LNG)\netatlk.txt
    copy $(_INX)\$(@B).inx+$(_LNG)\$(@B).txt $(@B).tmp1
    prodfilt $(@B).tmp1 $(@B).tmp2 +$(PRODSWITCH)
    prodfilt $(@B).tmp2 $@ +$(PLATFORM_SWITCH)
    @del $(@B).tmp1
    @del $(@B).tmp2
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\netauni.inf: $(_INX)\netauni.inx $(_LNG)\netauni.txt
    copy $(_INX)\$(@B).inx+$(_LNG)\$(@B).txt $@
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\netbeac.inf: $(_INX)\netbeac.inx $(_LNG)\netbeac.txt
    copy $(_INX)\$(@B).inx+$(_LNG)\$(@B).txt $@
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\netcis.inf: $(_INX)\netcis.inx $(_LNG)\netcis.txt
    copy $(_INX)\$(@B).inx+$(_LNG)\$(@B).txt $(@B).tmp1
    prodfilt $(@B).tmp1 $(@B).tmp2 +$(PRODSWITCH)
    prodfilt $(@B).tmp2 $@ +$(PLATFORM_SWITCH)
    @del $(@B).tmp1
    @del $(@B).tmp2
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\netcmak.inf: $(_INX)\netcmak.inx $(_LNG)\netcmak.txt
     copy $(_INX)\netcmak.inx+$(_LNG)\$(@B).txt $(@B).tmp1
     prodfilt $(@B).tmp1 $(@B).tmp2 +$(PRODSWITCH)
     prodfilt $(@B).tmp2 $@ +$(PLATFORM_SWITCH)
     @del $(@B).tmp1
     @del $(@B).tmp2
     $(STAMP)
     $(TSBINPLACE_CMD)

$(O)\netcps.inf: $(_INX)\netcps.inx $(_LNG)\netcps.txt
     copy $(_INX)\netcps.inx+$(_LNG)\$(@B).txt $(@B).tmp1
     prodfilt $(@B).tmp1 $(@B).tmp2 +$(PRODSWITCH)
     prodfilt $(@B).tmp2 $@ +$(PLATFORM_SWITCH)
     @del $(@B).tmp1
     @del $(@B).tmp2
     $(STAMP)
     $(TSBINPLACE_CMD)

$(O)\netdhoc.inf: $(_INX)\netdhoc.inx $(_LNG)\netdhoc.txt
    copy $(_INX)\$(@B).inx+$(_LNG)\$(@B).txt $@
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\netdhcps.inf: $(_INX)\netdhcps.inx $(_LNG)\netdhcps.txt
    copy $(_INX)\$(@B).inx+$(_LNG)\$(@B).txt $@
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\netdns.inf: $(_INX)\netdns.inx $(_LNG)\netdns.txt
    copy $(_INX)\$(@B).inx+$(_LNG)\$(@B).txt $@
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\netgpc.inf: $(_INX)\netgpc.inx $(_LNG)\netgpc.txt
    copy $(_INX)\$(@B).inx+$(_LNG)\$(@B).txt $@
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\netias.inf: $(_INX)\netias.inx $(_LNG)\netias.txt
    copy $(_INX)\$(@B).inx+$(_LNG)\$(@B).txt $(@B).tmp1
    prodfilt $(@B).tmp1 $@ +$(PLATFORM_SWITCH)
    @del $(@B).tmp1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\netip6.inf: $(_INX)\netip6.inx $(_LNG)\netip6.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $(O)\$(@B).tmp1
    prodfilt $(O)\$(@B).tmp1 $@ +$(PRODSWITCH)
    @del $(O)\$(@B).tmp1
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\netiprip.inf: $(_INX)\netiprip.inx $(_LNG)\netiprip.txt
    copy $(_INX)\$(@B).inx+$(_LNG)\$(@B).txt $@
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\netirda.inf: $(_INX)\netirda.inx $(_LNG)\netirda.txt
    copy $(_INX)\$(@B).inx+$(_LNG)\$(@B).txt $@
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\netlanem.inf: $(_INX)\netlanem.inx $(_LNG)\netlanem.txt
    copy $(_INX)\$(@B).inx+$(_LNG)\$(@B).txt $@
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\netlanep.inf: $(_INX)\netlanep.inx $(_LNG)\netlanep.txt
    copy $(_INX)\$(@B).inx+$(_LNG)\$(@B).txt $@
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\netlpd.inf: $(_INX)\netlpd.inx $(_LNG)\netlpd.txt
    copy $(_INX)\$(@B).inx+$(_LNG)\$(@B).txt $(@B).tmp1
    prodfilt $(@B).tmp1 $(@B).tmp2 +$(PRODSWITCH)
    prodfilt $(@B).tmp2 $@ +$(PLATFORM_SWITCH)
    @del $(@B).tmp1
    @del $(@B).tmp2
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\netmacpr.inf: $(_INX)\netmacpr.inx $(_LNG)\netmacpr.txt
    copy $(_INX)\$(@B).inx+$(_LNG)\$(@B).txt $(@B).tmp1
    prodfilt $(@B).tmp1 $(@B).tmp2 +$(PRODSWITCH)
    prodfilt $(@B).tmp2 $@ +$(PLATFORM_SWITCH)
    @del $(@B).tmp1
    @del $(@B).tmp2
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\netmacsv.inf: $(_INX)\netmacsv.inx $(_LNG)\netmacsv.txt
    copy $(_INX)\$(@B).inx+$(_LNG)\$(@B).txt $(@B).tmp1
    prodfilt $(@B).tmp1 $(@B).tmp2 +$(PRODSWITCH)
    prodfilt $(@B).tmp2 $@ +$(PLATFORM_SWITCH)
    @del $(@B).tmp1
    @del $(@B).tmp2
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\netmscli.inf: $(_INX)\netmscli.inx $(_LNG)\netmscli.txt
    copy $(_INX)\$(@B).inx+$(_LNG)\$(@B).txt $(@B).tmp1
    prodfilt $(@B).tmp1 $(@B).tmp2 +$(PRODSWITCH)
    prodfilt $(@B).tmp2 $@ +$(PLATFORM_SWITCH)
    @del $(@B).tmp1
    @del $(@B).tmp2
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\netnb.inf: $(_INX)\netnb.inx $(_LNG)\netnb.txt
    copy $(_INX)\$(@B).inx+$(_LNG)\$(@B).txt $@
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\netnbf.inf: $(_INX)\netnbf.inx $(_LNG)\netnbf.txt
    copy $(_INX)\$(@B).inx+$(_LNG)\$(@B).txt $@
    $(STAMP)
    $(TSBINPLACE_CMD)

!IF "$(PLATFORM_SWITCH)" == "i"

$(O)\netnwcli.inf: $(_INX)\netnwcli.inx $(_LNG)\netnwcli.txt
    copy $(_INX)\$(@B).inx+$(_LNG)\$(@B).txt $(@B).tmp1
    prodfilt $(@B).tmp1 $(@B).tmp2 +$(PRODSWITCH)
    prodfilt $(@B).tmp2 $@ +$(PLATFORM_SWITCH)
    @del $(@B).tmp1
    @del $(@B).tmp2
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\netnwlnk.inf: $(_INX)\netnwlnk.inx $(_LNG)\netnwlnk.txt
    copy $(_INX)\$(@B).inx+$(_LNG)\$(@B).txt $(@B).tmp1
    prodfilt $(@B).tmp1 $(@B).tmp2 +$(PRODSWITCH)
    prodfilt $(@B).tmp2 $@ +$(PLATFORM_SWITCH)
    @del $(@B).tmp1
    @del $(@B).tmp2
    $(STAMP)
    $(TSBINPLACE_CMD)

!ENDIF

$(O)\netoc.inf: $(_INX)\netoc.inx $(_LNG)\netoc.txt
    copy $(_INX)\$(@B).inx+$(_LNG)\$(@B).txt $(@B).tmp1
    prodfilt $(@B).tmp1 $(@B).tmp2 +$(PRODSWITCH)
    prodfilt $(@B).tmp2 $@ +$(PLATFORM_SWITCH)
    @del $(@B).tmp1
    @del $(@B).tmp2
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\netpgm.inf: $(_INX)\netpgm.inx $(_LNG)\netpgm.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $(O)\$(@B).tmp1
    prodfilt $(O)\$(@B).tmp1 $@ +$(PRODSWITCH)
    @del $(O)\$(@B).tmp1
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\netpsa.inf: $(_INX)\netpsa.inx $(_LNG)\netpsa.txt
    copy $(_INX)\$(@B).inx+$(_LNG)\$(@B).txt $@
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\netpschd.inf: $(_INX)\netpschd.inx $(_LNG)\netpschd.txt
    copy $(_INX)\$(@B).inx+$(_LNG)\$(@B).txt $@
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\netrwan.inf: $(_INX)\netrwan.inx $(_LNG)\netrwan.txt
    copy $(_INX)\$(@B).inx+$(_LNG)\$(@B).txt $@
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\netrasa.inf: $(_INX)\netrasa.inx $(_LNG)\netrasa.txt
    copy $(_INX)\$(@B).inx+$(_LNG)\$(@B).txt $(@B).tmp1
    prodfilt $(@B).tmp1 $(@B).tmp2 +$(PRODSWITCH)
    prodfilt $(@B).tmp2 $@ +$(PLATFORM_SWITCH)
    @del $(@B).tmp1
    @del $(@B).tmp2
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\netrass.inf: $(_INX)\netrass.inx $(_LNG)\netrass.txt
    copy $(_INX)\$(@B).inx+$(_LNG)\$(@B).txt $(@B).tmp1
    prodfilt $(@B).tmp1 $(@B).tmp2 +$(PRODSWITCH)
    prodfilt $(@B).tmp2 $@ +$(PLATFORM_SWITCH)
    @del $(@B).tmp1
    @del $(@B).tmp2
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\netrast.inf: $(_INX)\netrast.inx $(_LNG)\netrast.txt
    copy $(_INX)\$(@B).inx+$(_LNG)\$(@B).txt $(@B).tmp1
    prodfilt $(@B).tmp1 $(@B).tmp2 +$(PRODSWITCH)
    prodfilt $(@B).tmp2 $@ +$(PLATFORM_SWITCH)
    @del $(@B).tmp1
    @del $(@B).tmp2
    $(STAMP)
    $(TSBINPLACE_CMD)

!IF "$(PLATFORM_SWITCH)" == "i"

$(O)\netsap.inf: $(_INX)\netsap.inx $(_LNG)\netsap.txt
    copy $(_INX)\$(@B).inx+$(_LNG)\$(@B).txt $(@B).tmp1
    prodfilt $(@B).tmp1 $(@B).tmp2 +$(PRODSWITCH)
    prodfilt $(@B).tmp2 $@ +$(PLATFORM_SWITCH)
    @del $(@B).tmp1
    @del $(@B).tmp2
    $(STAMP)
    $(TSBINPLACE_CMD)

!ENDIF

$(O)\netserv.inf: $(_INX)\netserv.inx $(_LNG)\netserv.txt
    copy $(_INX)\$(@B).inx+$(_LNG)\$(@B).txt $(@B).tmp1
    prodfilt $(@B).tmp1 $(@B).tmp2 +$(PRODSWITCH)
    prodfilt $(@B).tmp2 $@ +$(PLATFORM_SWITCH)
    @del $(@B).tmp1
    @del $(@B).tmp2
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\netsfn.inf: $(_INX)\netsfn.inx $(_LNG)\netsfn.txt
    copy $(_INX)\$(@B).inx+$(_LNG)\$(@B).txt $@
    $(NWSBINPLACE_CMD)

$(O)\netsfnt.inf: $(_INX)\netsfnt.inx $(_LNG)\netsfnt.txt
    copy $(_INX)\$(@B).inx+$(_LNG)\$(@B).txt $(@B).tmp1
    prodfilt $(@B).tmp1 $(@B).tmp2 +$(PRODSWITCH)
    prodfilt $(@B).tmp2 $@ +$(PLATFORM_SWITCH)
    @del $(@B).tmp1
    @del $(@B).tmp2
    $(NWSBINPLACE_CMD)

$(O)\netsnmp.inf: $(_INX)\netsnmp.inx $(_LNG)\netsnmp.txt
    copy $(_INX)\$(@B).inx+$(_LNG)\$(@B).txt $(@B).tmp1
    prodfilt $(@B).tmp1 $(@B).tmp2 +$(PRODSWITCH)
    prodfilt $(@B).tmp2 $@ +$(PLATFORM_SWITCH)
    @del $(@B).tmp1
    @del $(@B).tmp2
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\nettcpip.inf: $(_INX)\nettcpip.inx $(_LNG)\nettcpip.txt
    copy $(_INX)\$(@B).inx+$(_LNG)\$(@B).txt $(@B).tmp1
    prodfilt $(@B).tmp1 $(@B).tmp2 +$(PRODSWITCH)
    prodfilt $(@B).tmp2 $@ +$(PLATFORM_SWITCH)
    @del $(@B).tmp1
    @del $(@B).tmp2
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\nettpsmp.inf: $(_INX)\nettpsmp.inx $(_LNG)\nettpsmp.txt
    copy $(_INX)\$(@B).inx+$(_LNG)\$(@B).txt $@
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\nettun.inf: $(_INX)\nettun.inx $(_LNG)\nettun.txt
    copy $(_INX)\$(@B).inx+$(_LNG)\$(@B).txt $(@B).tmp1
    prodfilt $(@B).tmp1 $(@B).tmp2 +$(PRODSWITCH)
    prodfilt $(@B).tmp2 $@ +$(PLATFORM_SWITCH)
    @del $(@B).tmp1
    @del $(@B).tmp2
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\netupg.inf: $(_INX)\netupg.inx $(_LNG)\netupg.txt
     copy $(_INX)\$(@B).inx+$(_LNG)\$(@B).txt $(@B).tmp1
     prodfilt $(@B).tmp1 $@ +$(PLATFORM_SWITCH)
     @del $(@B).tmp1
     $(STAMP)
     $(TSBINPLACE_CMD)

$(O)\netupnp.inf: $(_INX)\netupnp.inx $(_LNG)\netupnp.txt
    copy $(_INX)\$(@B).inx+$(_LNG)\$(@B).txt $@
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\netupnph.inf: $(_INX)\netupnph.inx $(_LNG)\netupnph.txt
    copy $(_INX)\$(@B).inx+$(_LNG)\$(@B).txt $@
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\netwins.inf: $(_INX)\netwins.inx $(_LNG)\netwins.txt
    copy $(_INX)\$(@B).inx+$(_LNG)\$(@B).txt $@
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\netwlbs.inf: $(_INX)\netwlbs.inx $(_LNG)\netwlbs.txt
     copy $(_INX)\$(@B).inx+$(_LNG)\$(@B).txt $(@B).tmp1
     prodfilt $(@B).tmp1 $@ +$(PLATFORM_SWITCH)
     @del $(@B).tmp1
     $(STAMP)
     $(TSBINPLACE_CMD)

$(O)\netwlbsm.inf: $(_INX)\netwlbsm.inx $(_LNG)\netwlbsm.txt
     copy $(_INX)\$(@B).inx+$(_LNG)\$(@B).txt $(@B).tmp1
     prodfilt $(@B).tmp1 $@ +$(PLATFORM_SWITCH)
     @del $(@B).tmp1
     $(STAMP)
     $(TSBINPLACE_CMD)


$(O)\netwzc.inf: $(_INX)\netwzc.inx $(_LNG)\netwzc.txt
     copy $(_INX)\$(@B).inx+$(_LNG)\$(@B).txt $(@B).tmp1
     prodfilt $(@B).tmp1 $(@B).tmp2 +$(PRODSWITCH)
     prodfilt $(@B).tmp2 $@ +$(PLATFORM_SWITCH)
     @del $(@B).tmp1
     @del $(@B).tmp2
     $(STAMP)
     $(TSBINPLACE_CMD)

$(O)\phildec.inf: $(_INX)\phildec.inx $(_LNG)\phildec.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $@
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)


$(O)\slip.inf: $(_INX)\slip.inx $(_LNG)\slip.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $@
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\streamip.inf: $(_INX)\streamip.inx $(_LNG)\streamip.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $@
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\ks.inf: $(_INX)\ks.inx $(_LNG)\ks.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $@
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\kscaptur.inf: $(_INX)\kscaptur.inx $(_LNG)\kscaptur.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $@
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\ksfilter.inf: $(_INX)\ksfilter.inx $(_LNG)\ksfilter.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $@
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\flpydisk.inf: $(_INX)\flpydisk.inx $(_LNG)\flpydisk.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $@
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\fdc.inf: $(_INX)\fdc.inx $(_LNG)\fdc.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $@
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\dvd.inf: $(_INX)\dvd.inx $(_LNG)\dvd.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $(O)\$(@B).tmp
    prodfilt $(O)\$(@B).tmp $@ +$(PLATFORM_SWITCH)
    @del $(O)\$(@B).tmp
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\dshowext.inf: $(_INX)\dshowext.inx $(_LNG)\dshowext.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $@
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\phil1vid.inf: $(_INX)\phil1vid.inx $(_LNG)\phil1vid.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $@
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\phdsext.inf: $(_INX)\phdsext.inx $(_LNG)\phdsext.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $@
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\phil2vid.inf: $(_INX)\phil2vid.inx $(_LNG)\phil2vid.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $@
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\camdsh20.inf: $(_INX)\camdsh20.inx $(_LNG)\camdsh20.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $@
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\camvid20.inf: $(_INX)\camvid20.inx $(_LNG)\camvid20.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $@
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\camvid30.inf: $(_INX)\camvid30.inx $(_LNG)\camvid30.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $@
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\mui.inf: $(_INX)\mui.inx $(_LNG)\mui.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $(O)\$(@B).tmp1
    prodfilt $(O)\$(@B).tmp1 $(O)\$(@B).tmp2 +$(PRODSWITCH)
    prodfilt $(O)\$(@B).tmp2 $@ +$(PLATFORM_SWITCH)
    @del $(O)\$(@B).tmp1
    @del $(O)\$(@B).tmp2
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\wsh.inf: $(_INX)\wsh.inx \
!if $(WIN64)
              $(O)\wowlist.inf \
!endif
              $(_LNG)\wsh.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $@
!if $(WIN64)
    copy $@ $(O)\$(@B).tmp3
    wowlist -i $@ -c $(O)\wowlist.inf -as -f w -d $(O)\wsh.wow -o $(O)\$(@B).tmp4
    copy $(O)\$(@B).tmp3+$(O)\$(@B).tmp4 $@
    @del $(O)\$(@B).tmp3 $(O)\$(@B).tmp4
!endif
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

!if $(WIN64)
$(O)\wsh.wow: $(O)\wsh.inf
!endif

!if $(WIN64)
$(O)\is_wow64.inf: $(_INX)\is_wow64.inx
    copy $(_INX)\$(@B).inx $(O)\$(@B).tmp1
    $(CC) $(PREFLAGS) $(O)\$(@B).tmp1 > $@
    del $(O)\$(@B).tmp1
    $(STAMP)
    $(TSBINPLACE_CMD)
!endif

$(O)\pop3oc.inf: $(_INX)\pop3oc.inx $(_LNG)\pop3oc.txt
    copy $(_INX)\$(@B).inx+$(_LNG)\$(@B).txt $(@B).tmp1
    prodfilt $(@B).tmp1 $(@B).tmp2 +$(PRODSWITCH)
    prodfilt $(@B).tmp2 $@ +$(PLATFORM_SWITCH)
    @del $(@B).tmp1
    @del $(@B).tmp2
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\ppa.inf: $(_INX)\ppa.inx $(_LNG)\ppa.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $@
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\ppa3.inf: $(_INX)\ppa3.inx $(_LNG)\ppa3.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $@
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\dmreg.inf: $(_INX)\dmreg.inx $(_LNG)\dmreg.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $@
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\dfrg.inf: $(_INX)\dfrg.inx $(_LNG)\dfrg.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $@
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\rsoptcom.inf: $(_INX)\rsoptcom.inx $(_LNG)\rsoptcom.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $(O)\$(@B).tmp
    prodfilt $(O)\$(@B).tmp $@ +$(PLATFORM_SWITCH)
    @del $(O)\$(@B).tmp
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\umax.inf: $(_INX)\umax.inx $(_LNG)\umax.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $@
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\umaxpp.inf: $(_INX)\umaxpp.inx $(_LNG)\umaxpp.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $@
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\rsoptwks.inf: $(_INX)\rsoptwks.inx $(_LNG)\rsoptwks.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $@
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\msinfo32.inf: $(_INX)\msinfo32.inx \
!if $(WIN64)
                   $(O)\wowlist.inf \
!endif
                   $(_LNG)\msinfo32.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $@
!if $(WIN64)
    copy $@ $(O)\$(@B).tmp1
    wowlist -i $(O)\$(@B).tmp1 -c $(O)\wowlist.inf -as -f w -d $(O)\msinfo32.wow -o $(O)\$(@B).tmp2 -g NOREGSVR
    copy $(O)\$(@B).tmp1+$(O)\$(@B).tmp2 $@
    @del $(O)\$(@B).tmp2 $(O)\$(@B).tmp1
!endif
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

!if $(WIN64)
$(O)\msinfo32.wow: $(O)\msinfo32.inf
!endif

$(O)\defltp.inf: $(_INX)\defltp.inx $(_LNG)\defltp.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $(O)\$(@B).tmp1
    prodfilt $(O)\$(@B).tmp1 $(O)\$(@B).tmp2 +$(PRODSWITCH)
    prodfilt $(O)\$(@B).tmp2 $@ +$(PLATFORM_SWITCH)
    @del $(O)\$(@B).tmp1
    @del $(O)\$(@B).tmp2
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\dpup.inf: $(_INX)\dpup.inx $(_LNG)\dpup.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $(O)\$(@B).tmp1
    prodfilt $(O)\$(@B).tmp1 $(O)\$(@B).tmp2 +$(PRODSWITCH)
    prodfilt $(O)\$(@B).tmp2 $@ +$(PLATFORM_SWITCH)
    @del $(O)\$(@B).tmp1
    @del $(O)\$(@B).tmp2
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\defltwk.inf: $(_INX)\defltwk.inx $(_LNG)\defltwk.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $(O)\$(@B).tmp1
    prodfilt $(O)\$(@B).tmp1 $(O)\$(@B).tmp2 +$(PRODSWITCH)
    prodfilt $(O)\$(@B).tmp2 $(O)\$(@B).tmp3 +$(PLATFORM_SWITCH)
    unitext $(UNITEXT_OPT) $(O)\layout.inf $(O)\layout.u.inf
    escpeinf C $(ANSI_CODEPAGE) $(O)\$(@B).tmp3 $@ $(O)\layout.u.inf
    @del $(O)\layout.u.inf
    @del $(O)\$(@B).tmp1
    @del $(O)\$(@B).tmp2
    @del $(O)\$(@B).tmp3
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(_COVINF)\defltwk.inf: $(_INX)\defltwk.inx $(_LNG)\defltwk.txt $(_COVINF)\layout.inf
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $(O)\$(@B).tmp1
    prodfilt $(O)\$(@B).tmp1 $(O)\$(@B).tmp2 +$(PRODSWITCH)
    prodfilt $(O)\$(@B).tmp2 $(O)\$(@B).tmp3 +$(PLATFORM_SWITCH)
    unitext $(UNITEXT_OPT) $(_COVINF)\layout.inf $(O)\layout.u.inf
    escpeinf C $(ANSI_CODEPAGE) $(O)\$(@B).tmp3 $@ $(O)\layout.u.inf
    @del $(O)\layout.u.inf
    @del $(O)\$(@B).tmp1
    @del $(O)\$(@B).tmp2
    @del $(O)\$(@B).tmp3
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(COVER_TSBINPLACE_CMD)

$(O)\defltsv.inf: $(_INX)\defltsv.inx $(_LNG)\defltsv.txt $(O)\layout.inf
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $(O)\$(@B).tmp1
    prodfilt $(O)\$(@B).tmp1 $(O)\$(@B).tmp2 +$(PRODSWITCH)
    prodfilt $(O)\$(@B).tmp2 $(O)\$(@B).tmp3 +$(PLATFORM_SWITCH)
    unitext $(UNITEXT_OPT) $(O)\layout.inf $(O)\layout.u.inf
    escpeinf C $(ANSI_CODEPAGE) $(O)\$(@B).tmp3 $@ $(O)\layout.u.inf
    @del $(O)\layout.u.inf
    @del $(O)\$(@B).tmp1
    @del $(O)\$(@B).tmp2
    @del $(O)\$(@B).tmp3
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(_COVINF)\defltsv.inf: $(_INX)\defltsv.inx $(_LNG)\defltsv.txt $(_COVINF)\layout.inf
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $(O)\$(@B).tmp1
    prodfilt $(O)\$(@B).tmp1 $(O)\$(@B).tmp2 +$(PRODSWITCH)
    prodfilt $(O)\$(@B).tmp2 $(O)\$(@B).tmp3 +$(PLATFORM_SWITCH)
    unitext $(UNITEXT_OPT) $(_COVINF)\layout.inf $(O)\layout.u.inf
    escpeinf C $(ANSI_CODEPAGE) $(O)\$(@B).tmp3 $@ $(O)\layout.u.inf
    @del $(O)\layout.u.inf
    @del $(O)\$(@B).tmp1
    @del $(O)\$(@B).tmp2
    @del $(O)\$(@B).tmp3
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(COVER_TSBINPLACE_CMD)

$(O)\defdcgpo.inf: $(_INX)\defdcgpo.inx $(_LNG)\defdcgpo.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $(O)\$(@B).tmp1
    prodfilt $(O)\$(@B).tmp1 $(O)\$(@B).tmp2 +$(PRODSWITCH)
    prodfilt $(O)\$(@B).tmp2 $@ +$(PLATFORM_SWITCH)
    @del $(O)\$(@B).tmp1
    @del $(O)\$(@B).tmp2
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\defltdc.inf: $(_INX)\defltdc.inx $(_LNG)\defltdc.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $(O)\$(@B).tmp1
    prodfilt $(O)\$(@B).tmp1 $(O)\$(@B).tmp2 +$(PRODSWITCH)
    prodfilt $(O)\$(@B).tmp2 $@ +$(PLATFORM_SWITCH)
    @del $(O)\$(@B).tmp1
    @del $(O)\$(@B).tmp2
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\compatws.inf: $(_INX)\compatws.inx $(_LNG)\compatws.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $(O)\$(@B).tmp1
    prodfilt $(O)\$(@B).tmp1 $(O)\$(@B).tmp2 +$(PRODSWITCH)
    prodfilt $(O)\$(@B).tmp2 $@ +$(PLATFORM_SWITCH)
    @del $(O)\$(@B).tmp1
    @del $(O)\$(@B).tmp2
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\dcup.inf: $(_INX)\dcup.inx $(_LNG)\dcup.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $(O)\$(@B).tmp1
    prodfilt $(O)\$(@B).tmp1 $(O)\$(@B).tmp2 +$(PRODSWITCH)
    prodfilt $(O)\$(@B).tmp2 $@ +$(PLATFORM_SWITCH)
    @del $(O)\$(@B).tmp1
    @del $(O)\$(@B).tmp2
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\dcfirst.inf: $(_INX)\dcfirst.inx $(_LNG)\dcfirst.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $(O)\$(@B).tmp1
    prodfilt $(O)\$(@B).tmp1 $(O)\$(@B).tmp2 +$(PRODSWITCH)
    prodfilt $(O)\$(@B).tmp2 $@ +$(PLATFORM_SWITCH)
    @del $(O)\$(@B).tmp1
    @del $(O)\$(@B).tmp2
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\rootsec.inf: $(_INX)\rootsec.inx $(_LNG)\rootsec.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $(O)\$(@B).tmp1
    prodfilt $(O)\$(@B).tmp1 $(O)\$(@B).tmp2 +$(PRODSWITCH)
    prodfilt $(O)\$(@B).tmp2 $@ +$(PLATFORM_SWITCH)
    @del $(O)\$(@B).tmp1
    @del $(O)\$(@B).tmp2
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\securews.inf: $(_INX)\securews.inx $(_LNG)\securews.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $(O)\$(@B).tmp1
    prodfilt $(O)\$(@B).tmp1 $(O)\$(@B).tmp2 +$(PRODSWITCH)
    prodfilt $(O)\$(@B).tmp2 $@ +$(PLATFORM_SWITCH)
    @del $(O)\$(@B).tmp1
    @del $(O)\$(@B).tmp2
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\securedc.inf: $(_INX)\securedc.inx $(_LNG)\securedc.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $(O)\$(@B).tmp1
    prodfilt $(O)\$(@B).tmp1 $(O)\$(@B).tmp2 +$(PRODSWITCH)
    prodfilt $(O)\$(@B).tmp2 $@ +$(PLATFORM_SWITCH)
    @del $(O)\$(@B).tmp1
    @del $(O)\$(@B).tmp2
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\hisecws.inf: $(_INX)\hisecws.inx $(_LNG)\hisecws.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $(O)\$(@B).tmp1
    prodfilt $(O)\$(@B).tmp1 $(O)\$(@B).tmp2 +$(PRODSWITCH)
    prodfilt $(O)\$(@B).tmp2 $@ +$(PLATFORM_SWITCH)
    @del $(O)\$(@B).tmp1
    @del $(O)\$(@B).tmp2
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\hisecdc.inf: $(_INX)\hisecdc.inx $(_LNG)\hisecdc.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $(O)\$(@B).tmp1
    prodfilt $(O)\$(@B).tmp1 $(O)\$(@B).tmp2 +$(PRODSWITCH)
    prodfilt $(O)\$(@B).tmp2 $@ +$(PLATFORM_SWITCH)
    @del $(O)\$(@B).tmp1
    @del $(O)\$(@B).tmp2
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\secrecs.inf: $(_INX)\secrecs.inx $(_LNG)\secrecs.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $(O)\$(@B).tmp1
    prodfilt $(O)\$(@B).tmp1 $(O)\$(@B).tmp2 +$(PRODSWITCH)
    prodfilt $(O)\$(@B).tmp2 $@ +$(PLATFORM_SWITCH)
    @del $(O)\$(@B).tmp1
    @del $(O)\$(@B).tmp2
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\sceregvl.inf: $(_INX)\sceregvl.inx $(_LNG)\sceregvl.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $(O)\$(@B).tmp1
    prodfilt $(O)\$(@B).tmp1 $(O)\$(@B).tmp2 +$(PRODSWITCH)
    prodfilt $(O)\$(@B).tmp2 $@ +$(PLATFORM_SWITCH)
    @del $(O)\$(@B).tmp1
    @del $(O)\$(@B).tmp2
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\dcup5.inf: $(_INX)\dcup5.inx $(_LNG)\dcup5.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $(O)\$(@B).tmp1
    prodfilt $(O)\$(@B).tmp1 $(O)\$(@B).tmp2 +$(PRODSWITCH)
    prodfilt $(O)\$(@B).tmp2 $@ +$(PLATFORM_SWITCH)
    @del $(O)\$(@B).tmp1
    @del $(O)\$(@B).tmp2
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\dwup.inf: $(_INX)\dwup.inx $(_LNG)\dwup.txt $(O)\layout.inf
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $(O)\$(@B).tmp1
    prodfilt $(O)\$(@B).tmp1 $(O)\$(@B).tmp2 +$(PRODSWITCH)
    prodfilt $(O)\$(@B).tmp2 $(O)\$(@B).tmp3 +$(PLATFORM_SWITCH)
    unitext $(UNITEXT_OPT) $(O)\layout.inf $(O)\layout.u.inf
    escpeinf U $(ANSI_CODEPAGE) $(O)\$(@B).tmp3 $@ $(O)\layout.u.inf
    @del $(O)\layout.u.inf
    @del $(O)\$(@B).tmp1
    @del $(O)\$(@B).tmp2
    @del $(O)\$(@B).tmp3
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(_COVINF)\dwup.inf: $(_INX)\dwup.inx $(_LNG)\dwup.txt $(_COVINF)\layout.inf
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $(O)\$(@B).tmp1
    prodfilt $(O)\$(@B).tmp1 $(O)\$(@B).tmp2 +$(PRODSWITCH)
    prodfilt $(O)\$(@B).tmp2 $(O)\$(@B).tmp3 +$(PLATFORM_SWITCH)
    unitext $(UNITEXT_OPT) $(_COVINF)\layout.inf $(O)\layout.u.inf
    escpeinf U $(ANSI_CODEPAGE) $(O)\$(@B).tmp3 $@ $(O)\layout.u.inf
    @del $(O)\layout.u.inf
    @del $(O)\$(@B).tmp1
    @del $(O)\$(@B).tmp2
    @del $(O)\$(@B).tmp3
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(COVER_TSBINPLACE_CMD)

$(O)\dsup.inf: $(_INX)\dsup.inx $(_LNG)\dsup.txt $(O)\layout.inf
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $(O)\$(@B).tmp1
    prodfilt $(O)\$(@B).tmp1 $(O)\$(@B).tmp2 +$(PRODSWITCH)
    prodfilt $(O)\$(@B).tmp2 $(O)\$(@B).tmp3 +$(PLATFORM_SWITCH)
    unitext $(UNITEXT_OPT) $(O)\layout.inf $(O)\layout.u.inf
    escpeinf U $(ANSI_CODEPAGE) $(O)\$(@B).tmp3 $@ $(O)\layout.u.inf
    @del $(O)\layout.u.inf
    @del $(O)\$(@B).tmp1
    @del $(O)\$(@B).tmp2
    @del $(O)\$(@B).tmp3
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(_COVINF)\dsup.inf: $(_INX)\dsup.inx $(_LNG)\dsup.txt $(_COVINF)\layout.inf
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $(O)\$(@B).tmp1
    prodfilt $(O)\$(@B).tmp1 $(O)\$(@B).tmp2 +$(PRODSWITCH)
    prodfilt $(O)\$(@B).tmp2 $(O)\$(@B).tmp3 +$(PLATFORM_SWITCH)
    unitext $(UNITEXT_OPT) $(_COVINF)\layout.inf $(O)\layout.u.inf
    escpeinf U $(ANSI_CODEPAGE) $(O)\$(@B).tmp3 $@ $(O)\layout.u.inf
    @del $(O)\layout.u.inf
    @del $(O)\$(@B).tmp1
    @del $(O)\$(@B).tmp2
    @del $(O)\$(@B).tmp3
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(COVER_TSBINPLACE_CMD)

$(O)\dsupt.inf: $(_INX)\dsupt.inx $(_LNG)\dsupt.txt $(O)\layout.inf
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $(O)\$(@B).tmp1
    prodfilt $(O)\$(@B).tmp1 $(O)\$(@B).tmp2 +$(PRODSWITCH)
    prodfilt $(O)\$(@B).tmp2 $(O)\$(@B).tmp3 +$(PLATFORM_SWITCH)
    unitext $(UNITEXT_OPT) $(O)\layout.inf $(O)\layout.u.inf
    escpeinf U $(ANSI_CODEPAGE) $(O)\$(@B).tmp3 $@ $(O)\layout.u.inf
    @del $(O)\layout.u.inf
    @del $(O)\$(@B).tmp1
    @del $(O)\$(@B).tmp2
    @del $(O)\$(@B).tmp3
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(_COVINF)\dsupt.inf: $(_INX)\dsupt.inx $(_LNG)\dsupt.txt $(_COVINF)\layout.inf
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $(O)\$(@B).tmp1
    prodfilt $(O)\$(@B).tmp1 $(O)\$(@B).tmp2 +$(PRODSWITCH)
    prodfilt $(O)\$(@B).tmp2 $(O)\$(@B).tmp3 +$(PLATFORM_SWITCH)
    unitext $(UNITEXT_OPT) $(_COVINF)\layout.inf $(O)\layout.u.inf
    escpeinf U $(ANSI_CODEPAGE) $(O)\$(@B).tmp3 $@ $(O)\layout.u.inf
    @del $(O)\layout.u.inf
    @del $(O)\$(@B).tmp1
    @del $(O)\$(@B).tmp2
    @del $(O)\$(@B).tmp3
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(COVER_TSBINPLACE_CMD)

$(O)\syscomp.inf: $(_INX)\syscomp.inx $(_LNG)\syscomp.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $(O)\$(@B).tmp1
    prodfilt $(O)\$(@B).tmp1 $(O)\$(@B).tmp2 +$(PRODSWITCH)
    prodfilt $(O)\$(@B).tmp2 $@ +$(PLATFORM_SWITCH)
    @del $(O)\$(@B).tmp1
    @del $(O)\$(@B).tmp2
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\ocmri.inf: $(_INX)\ocmri.inx $(_LNG)\reminst.txt
    $(CC) $(PREFLAGS) $(_LNG)\reminst.txt > reminst.txt1
    copy $(_INX)\$(@B).inx+reminst.txt1 $(O)\$(@B).tmp1
    prodfilt $(O)\$(@B).tmp1 $(O)\$(@B).tmp2 +$(PRODSWITCH)
    prodfilt $(O)\$(@B).tmp2 $@ +$(PLATFORM_SWITCH)
    @del $(O)\$(@B).tmp1
    @del $(O)\$(@B).tmp2
    @del reminst.txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\reminst.inf: $(_INX)\reminst.inx $(_LNG)\reminst.txt $(_INX)\ocmri.inx
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\ocmri.inx+$(_INX)\$(@B).inx+$(O)\$(@B).txt1 $(O)\$(@B).tmp1
    prodfilt $(O)\$(@B).tmp1 $(O)\$(@B).tmp2 +$(PRODSWITCH)
    prodfilt $(O)\$(@B).tmp2 $@ +$(PLATFORM_SWITCH)
    @del $(O)\$(@B).tmp1
    @del $(O)\$(@B).tmp2
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\ristndrd.sif: $(_INX)\ristndrd.inx $(_LNG)\ristndrd.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $(O)\$(@B).tmp1
    prodfilt $(O)\$(@B).tmp1 $(O)\$(@B).tmp2 +$(PRODSWITCH)
    prodfilt $(O)\$(@B).tmp2 $(O)\$(@B).tmp3 +R
    prodfilt $(O)\$(@B).tmp3 $@ +$(PLATFORM_SWITCH)
    @del $(O)\$(@B).tmp1
    @del $(O)\$(@B).tmp2
    @del $(O)\$(@B).tmp3
    @del $(O)\$(@B).txt1
    $(TSBINPLACE_CMD)

$(O)\rinorprt.sif: $(_INX)\ristndrd.inx $(_LNG)\ristndrd.txt
    $(CC) $(PREFLAGS) $(_LNG)\ristndrd.txt > $(O)\$(@B).txt1
    copy $(_INX)\ristndrd.inx+$(O)\$(@B).txt1 $(O)\$(@B).tmp1
    prodfilt $(O)\$(@B).tmp1 $(O)\$(@B).tmp2 +$(PRODSWITCH)
    prodfilt $(O)\$(@B).tmp2 $(O)\$(@B).tmp3 +N
    prodfilt $(O)\$(@B).tmp3 $@ +$(PLATFORM_SWITCH)
    @del $(O)\$(@B).tmp1
    @del $(O)\$(@B).tmp2
    @del $(O)\$(@B).tmp3
    @del $(O)\$(@B).txt1
    $(TSBINPLACE_CMD)

$(O)\riprep.inf: $(_INX)\riprep.inx $(_LNG)\riprep.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(@B).txt1
    copy $(_INX)\$(@B).inx+$(@B).txt1 $(@B).tmp1
    prodfilt $(@B).tmp1 $(@B).tmp2 +$(PRODSWITCH)
    prodfilt $(@B).tmp2 $@ +$(PLATFORM_SWITCH)
    @del $(@B).tmp1
    @del $(@B).tmp2
    @del $(@B).txt1
    $(TSBINPLACE_CMD)


$(O)\minioc.inf: $(_INX)\minioc.inx $(_LNG)\minioc.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $(O)\$(@B).tmp1
    prodfilt $(O)\$(@B).tmp1 $(O)\$(@B).tmp2 +$(PRODSWITCH)
    prodfilt $(O)\$(@B).tmp2 $@ +$(PLATFORM_SWITCH)
    @del $(O)\$(@B).tmp1
    @del $(O)\$(@B).tmp2
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\msmscsi.inf: $(_INX)\msmscsi.inx $(_LNG)\msmscsi.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $@
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\msmusb.inf: $(_INX)\msmusb.inx $(_LNG)\msmusb.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $@
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\biomtric.inf: $(_INX)\biomtric.inx $(_LNG)\biomtric.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $(O)\$(@B).tmp1
    prodfilt $(O)\$(@B).tmp1 $@ +$(PLATFORM_SWITCH)
    @del $(O)\$(@B).txt1 $(O)\$(@B).tmp1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\biosinfo.inf: $(_INX)\biosinfo.inx $(_LNG)\biosinfo.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $(O)\$(@B).tmp1
    prodfilt $(O)\$(@B).tmp1 $@ +$(PLATFORM_SWITCH)
    @del $(O)\$(@B).txt1 $(O)\$(@B).tmp1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\unknown.inf: $(_INX)\unknown.inx $(_LNG)\unknown.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $@
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\tablet.inf: $(_INX)\tablet.inx $(_LNG)\tablet.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(@B).txt1
    $(CC) $(PREFLAGS) $(_INX)\$(@B).inx > $(O)\$(@B).inx1
    copy $(O)\$(@B).inx1+$(@B).txt1 $(@B).tmp1
    prodfilt $(@B).tmp1 $(@B).tmp2 +$(PLATFORM_SWITCH)
    prodfilt $(@B).tmp2 $@ +$(PRODSWITCH)
    @del $(@B).tmp1
    @del $(@B).tmp2
    @del $(@B).txt1
    @del $(O)\$(@B).inx1
    $(TSBINPLACE_CMD)



$(O)\hal.inf: $(_INX)\hal.inx $(_LNG)\hal.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $(O)\$(@B).tmp
    prodfilt $(O)\$(@B).tmp $(O)\$(@B).tmp1 +$(PLATFORM_SWITCH)
    prodfilt $(O)\$(@B).tmp1 $@ +$(PRODSWITCH)
    @del $(O)\$(@B).tmp
    @del $(O)\$(@B).tmp1
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\exclude.inf: $(_INX)\exclude.inx $(_LNG)\exclude.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $@
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\wowlist.inf: $(_INX)\wowlist.inx $(_LNG)\wowlist.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $(@)
    @del $(O)\$(@B).txt1
!IF "$(PRODSWITCH)"=="w" || "$(PRODSWITCH)"=="W"
        $(TSBINPLACE_CMD)
!ENDIF

$(O)\wowfrege.inf: $(_INX)\wowfrege.inx $(_LNG)\wowfrege.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    echo [EarlyOleControlDlls] >$(O)\wowfrege.tmp1
    copy $(O)\wowfrege.tmp1+$(_INX)\$(@B).inx+$(O)\$(@B).txt1 $(@)
    @del $(O)\$(@B).txt1
#    $(TSBINPLACE_CMD)

$(O)\wowfrego.inf: $(_INX)\wowfrego.inx $(_LNG)\wowfrego.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    echo [OleControlDlls] >$(O)\wowfrego.tmp1
    copy $(O)\wowfrego.tmp1+$(_INX)\$(@B).inx+$(O)\$(@B).txt1 $(@)
    @del $(O)\$(@B).txt1
#    $(TSBINPLACE_CMD)

$(O)\wowfregc.inf: $(_INX)\wowfregc.inx $(_LNG)\wowfregc.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    echo [CryptoDlls] >$(O)\wowfregc.tmp1
    copy $(O)\wowfregc.tmp1+$(_INX)\$(@B).inx+$(O)\$(@B).txt1 $(@)
    @del $(O)\$(@B).txt1
#    $(TSBINPLACE_CMD)

$(O)\wowfile.cmn: $(_INX)\wowfile.inx $(_LNG)\wowfile.txt \
                  $(O)\accessor.wow $(O)\communic.wow $(O)\games.wow \
                  $(O)\mmopt.wow $(O)\multimed.wow $(O)\optional.wow \
                  $(O)\pinball.wow $(O)\wordpad.wow $(O)\mdac.wow    \
                  $(O)\msinfo32.wow $(O)\ie.wow $(O)\msoe50.wow      \
                  $(O)\mstask.wow $(O)\wab50.wow $(O)\syssetup.wow $(O)\wsh.wow      \
                  $(O)\apcompat.wow $(O)\intl.wow $(O)\wbemoc.wow \
                  $(O)\vgx.wow $(O)\icwnt5.wow
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    $(CC) $(PREFLAGS) $(_INX)\wowfile.inx > $(O)\wowfile.tmp1
    prodfilt -s $(O)\wowfile.tmp1 $(O)\wowfile.tmp2 +$(PRODSWITCH)
    prodfilt -s $(O)\wowfile.tmp2 $(O)\wowfile.tmp +$(PLATFORM_SWITCH)
    del $(O)\wowfile.tmp2
    del $(O)\wowfile.tmp1
    copy /b $(O)\wowfile.tmp+$(O)\$(@B).txt1 $(O)\$(@B).tmp
    prodfilt $(O)\$(@B).tmp $(O)\$(@B).tmp1 +$(PLATFORM_SWITCH)
    del $(O)\$(@B).tmp
    del $(O)\wowfile.tmp
    for %%i in ($(O)\$(@B).tmp1 $(O)\accessor.wow $(O)\communic.wow $(O)\games.wow \
                $(O)\mmopt.wow $(O)\multimed.wow $(O)\optional.wow \
                $(O)\pinball.wow $(O)\wordpad.wow $(O)\mdac.wow    \
                $(O)\msinfo32.wow $(O)\ie.wow $(O)\msoe50.wow      \
                $(O)\mstask.wow $(O)\wab50.wow $(O)\syssetup.wow $(O)\wsh.wow      \
                $(O)\apcompat.wow $(O)\intl.wow $(O)\wbemoc.wow $(O)\vgx.wow $(O)\icwnt5.wow)   \
        do $(STRIPCHAR) %%i $(O)\$(@B).tmp
    perl $(_INX)\wowfltr.pl /file=$(O)\$(@B).tmp > $@
    @del $(O)\$(@B).tmp $(O)\wowfile.tmp1 $(O)\$(@B).tmp1 $(O)\$(@B).txt1
#    $(TSBINPLACE_CMD)

!if $(AMD64)
$(O)\wowfile.inf: $(O)\wowfile.cmn $(_INX)\header1_amd64
     copy /b $(_INX)\header1_amd64+$(O)\wowfile.cmn $@
!else
$(O)\wowfile.inf: $(O)\wowfile.cmn $(_INX)\header1
     copy /b $(_INX)\header1+$(O)\wowfile.cmn $@
!endif

$(O)\wowfiled.inf: $(O)\wowfile.cmn $(_INX)\header2
     copy /b $(_INX)\header2+$(O)\wowfile.cmn $@




$(O)\wowexcp.txt: $(_INX)\wowfile.inx $(_LNG)\wowfile.txt $(O)\accessor.wow $(O)\communic.wow     \
                  $(O)\games.wow $(O)\mmopt.wow $(O)\multimed.wow              \
                  $(O)\optional.wow $(O)\pinball.wow $(O)\wordpad.wow          \
                  $(O)\mdac.wow $(O)\msinfo32.wow $(O)\ie.wow $(O)\msoe50.wow  \
                  $(O)\mstask.wow $(O)\wab50.wow $(O)\syssetup.wow $(O)\wsh.wow                \
                  $(O)\apcompat.wow $(O)\intl.wow $(O)\intlinfa.wow $(O)\wbemoc.wow $(O)\vgx.wow \
                  $(O)\icwnt5.wow
    if exist $(O)\$(@B).tmp del $(O)\$(@B).tmp
    for %%i in ($(O)\accessor.wow $(O)\communic.wow $(O)\games.wow \
                $(O)\mmopt.wow $(O)\multimed.wow $(O)\optional.wow \
                $(O)\pinball.wow $(O)\wordpad.wow $(O)\mdac.wow    \
                $(O)\msinfo32.wow $(O)\ie.wow $(O)\msoe50.wow      \
                $(O)\mstask.wow $(O)\wab50.wow $(O)\syssetup.wow $(O)\wsh.wow      \
                $(O)\apcompat.wow $(O)\intl.wow $(O)\intlinfa.wow $(O)\wbemoc.wow $(O)\vgx.wow \
                $(O)\icwnt5.wow)        \
         do type %%i >>$(O)\$(@B).tmp
    $(CC) $(PREFLAGS) $(_LNG)\wowfile.txt > $(O)\wowfile.txt1
    $(CC) $(PREFLAGS) $(_INX)\wowfile.inx > $(O)\wowfile.tmp
    prodfilt -s $(O)\wowfile.tmp $(O)\wowfile.tmp1 +$(PRODSWITCH)
    prodfilt -s $(O)\wowfile.tmp1 $(O)\wowfile.txt2 +$(PLATFORM_SWITCH)
    @del $(O)\wowfile.tmp1
    @del $(O)\wowfile.tmp
    copy /b $(O)\wowfile.txt2+$(O)\wowfile.txt1+$(O)\$(@B).tmp $(O)\$(@B).tmp2
    perl $(_INX)\wowfltr.pl /file=$(O)\$(@B).tmp2 > $@
    @del $(O)\$(@B).tmp $(O)\wowfile.txt1 $(O)\$(@B).tmp2 $(O)\wowfile.txt2
    $(TSBINPLACE_CMD)

#
#  Make a dskspace.txt for coverage builds which has bigger values than the original
#
$(_COVINF)\dskspace.txt : $(_LNG)\dskspace.txt
        cscript $(_INX)\ManDskSpc.vbs $(_LNG)\dskspace.txt $(_COVINF)\dskspace.txt 1.5

#
# Special infs (and the test certificate, which we deal with along with INFs in
# order to keep all the special magic we do for internal test builds in one
# place)...
#
# Real-signed txtsetup.sif
#

$(_RSINF)\txtsetup.sif: $(O)\txtsetup.inx $(_LNG)\txtsetup.txt $(_LNG)\dskspace.txt $(_RSINF)\layout.inf
    $(CC) $(PREFLAGS) $(_LNG)\txtsetup.txt > $(O)\txtsetup.txt1
    $(CC) $(PREFLAGS) $(_LNG)\dskspace.txt > $(O)\dskspace.txt1
    copy $(O)\$(@B).inx+$(O)\txtsetup.txt1+$(O)\dskspace.txt1 $(O)\txtsetup.tmp1
    prodfilt -s $(O)\txtsetup.tmp1 $(O)\txtsetup.tmp2 +$(PLATFORM_SWITCH)
    prodfilt -s $(O)\txtsetup.tmp2 $(O)\txtsetup.tmp1 +$(PRODSWITCH)
    copy $(_RSINF)\layout.inf+$(O)\txtsetup.tmp1 $(_RSINF)\txtsetup.sif
    inftest $(_RSINF)\txtsetup.sif /B /$(PLATFORM_SWITCH)
    @del $(O)\txtsetup.tmp1 $(O)\txtsetup.tmp2 $(O)\txtsetup.txt1 $(O)\dskspace.txt1
    $(RSBINPLACE_CMD)

#
# Coverage Real-signed txtsetup.sif
#

$(_RSCOVINF)\txtsetup.sif: $(O)\txtsetup.inx $(_LNG)\txtsetup.txt $(_COVINF)\dskspace.txt $(_RSCOVINF)\layout.inf $(_INX)\$(@B).mcv
    $(CC) $(PREFLAGS) $(_LNG)\txtsetup.txt > $(O)\txtsetup.txt1
    $(CC) $(PREFLAGS) $(_COVINF)\dskspace.txt > $(O)\dskspace.txt1
    copy $(O)\$(@B).inx+$(O)\txtsetup.txt1+$(O)\dskspace.txt1 $(O)\txtsetup.tmp1
    prodfilt -s $(O)\txtsetup.tmp1 $(O)\txtsetup.tmp2 +$(PLATFORM_SWITCH)
    prodfilt -s $(O)\txtsetup.tmp2 $(O)\txtsetup.tmp1 +$(PRODSWITCH)
    call MergeFiles.cmd $(O)\txtsetup.tmp1 $(_INX)\$(@B).mcv $(O)\txtsetup.tmp2
    copy $(_RSCOVINF)\layout.inf+$(O)\txtsetup.tmp2 $(_RSCOVINF)\txtsetup.sif
    @del $(O)\txtsetup.tmp1 $(O)\txtsetup.tmp2 $(O)\txtsetup.txt1 $(O)\dskspace.txt1
    $(COVER_RSBINPLACE_CMD)

#
# Test-signed txtsetup.sif
#

$(O)\txtsetup.sif: $(O)\txtsetup.inx $(_LNG)\txtsetup.txt $(_LNG)\dskspace.txt $(O)\layout.inf
    $(CC) $(PREFLAGS) $(_LNG)\txtsetup.txt > $(O)\txtsetup.txt1
    $(CC) $(PREFLAGS) $(_LNG)\dskspace.txt > $(O)\dskspace.txt1
    copy $(O)\$(@B).inx+$(O)\txtsetup.txt1+$(O)\dskspace.txt1 $(O)\txtsetup.tmp1
    prodfilt -s $(O)\txtsetup.tmp1 $(O)\txtsetup.tmp2 +$(PLATFORM_SWITCH)
    prodfilt -s $(O)\txtsetup.tmp2 $(O)\txtsetup.tmp1 +$(PRODSWITCH)
    copy $(O)\layout.inf+$(O)\txtsetup.tmp1 $(O)\txtsetup.sif
    inftest $(O)\txtsetup.sif /B /$(PLATFORM_SWITCH)
    @del $(O)\txtsetup.tmp1 $(O)\txtsetup.tmp2 $(O)\txtsetup.txt1 $(O)\dskspace.txt1
    $(TSBINPLACE_CMD)

#
# Coverage Test-signed txtsetup.sif
#

$(_COVINF)\txtsetup.sif: $(O)\txtsetup.inx $(_LNG)\txtsetup.txt $(_COVINF)\dskspace.txt $(_COVINF)\layout.inf $(_INX)\$(@B).mcv
    $(CC) $(PREFLAGS) $(_LNG)\txtsetup.txt > $(O)\txtsetup.txt1
    $(CC) $(PREFLAGS) $(_COVINF)\dskspace.txt > $(O)\dskspace.txt1
    copy $(O)\$(@B).inx+$(O)\txtsetup.txt1+$(O)\dskspace.txt1 $(O)\txtsetup.tmp1
    prodfilt -s $(O)\txtsetup.tmp1 $(O)\txtsetup.tmp2 +$(PLATFORM_SWITCH)
    prodfilt -s $(O)\txtsetup.tmp2 $(O)\txtsetup.tmp1 +$(PRODSWITCH)
    call MergeFiles.cmd $(O)\txtsetup.tmp1 $(_INX)\$(@B).mcv $(O)\txtsetup.tmp2
    copy $(_COVINF)\layout.inf+$(O)\txtsetup.tmp2 $(_COVINF)\txtsetup.sif
    @del $(O)\txtsetup.tmp1 $(O)\txtsetup.tmp2 $(O)\txtsetup.txt1 $(O)\dskspace.txt1
    $(COVER_TSBINPLACE_CMD)

#
# Real-signed dosnet.inf
#

$(_RSINF)\dosnet.inf: $(O)\dosnet.inx $(_LNG)\dosnet.txt \
                      $(_LNG)\dskspace.txt $(_RSINF)\layout.inf \
!IF $(WIN64)
                      $(O)\wowlist.inf $(O)\wowfiled.inf \
!endif
                       $(O)\layout.inx $(O)\layout.txt $(O)\exclude.inf
    $(CC) $(PREFLAGS) $(_LNG)\dosnet.txt > $(O)\dosnet.txt1
    $(CC) $(PREFLAGS) $(_LNG)\dskspace.txt > $(O)\dskspace.txt1
    copy $(O)\dosnet.inx+$(O)\dosnet.txt1+$(O)\dskspace.txt1 $(O)\dosnet.tmp1
    prodfilt -s $(O)\dosnet.tmp1 $(O)\dosnet.tmp2 +$(PLATFORM_SWITCH)
    prodfilt -s $(O)\dosnet.tmp2 $(O)\dosnet.tmp1 +$(PRODSWITCH)
    copy $(O)\layout.inx+$(O)\layout.txt $(O)\lydosnet.tmp1
    prodfilt -s $(O)\lydosnet.tmp1 $(O)\lydosnet.tmp2 +$(PRODSWITCH)
    prodfilt -s $(O)\lydosnet.tmp2 $(O)\lydosnet.tmp1 +$(PLATFORM_SWITCH)
!IF $(WIN64)
    xdosnet $(O)\lydosnet.tmp1 $(O)\dummy 1 $(O)\lydosnet.tmp2 $(TARGET_DIRECTORY:i386=x86) $(O)\foo $(O)\exclude.inf $(O)\bootlist.tmp
    copy $(O)\lydosnet.tmp2+$(O)\bootlist.tmp $(O)\lydosnet.tmp3
!else
    xdosnet $(O)\lydosnet.tmp1 $(O)\dummy * $(O)\lydosnet.tmp3 $(TARGET_DIRECTORY:i386=x86) $(O)\foo $(O)\exclude.inf
!endif
    copy $(O)\dosnet.tmp1+$(O)\lydosnet.tmp3 $(_RSINF)\dosnet.inf
!IF $(WIN64)
    copy $(_RSINF)\dosnet.inf $(O)\dosnet.tmp3
    copy $(O)\layout.inx+$(O)\layout.txt $(O)\dosnet.tmp1
    prodfilt -s $(O)\dosnet.tmp1 $(O)\dosnet.tmp2 +$(PRODSWITCH)
    prodfilt -s $(O)\dosnet.tmp2 $(O)\dosnet.tmp1 +i
    wowlist -i $(O)\dosnet.tmp1 -c $(O)\wowlist.inf -o $(O)\dosnet.tmp2 -ac -h $(O)\wowfiled.inf -f w 2>NUL
    xdosnet $(O)\dosnet.tmp2 $(O)\dummy 2 $(O)\dosnet.tmp1 $(TARGET_DIRECTORY:i386=x86)
    copy $(O)\dosnet.tmp3+$(O)\dosnet.tmp1 $(_RSINF)\dosnet.inf
    @del $(O)\dosnet.tmp3 $(_INF)\dosnet.tmp2
!ENDIF
    @del $(O)\dosnet.tmp1 $(O)\dosnet.tmp2 $(O)\lydosnet.tmp1 $(O)\lydosnet.tmp2 $(O)\dosnet.txt1 $(O)\dskspace.txt1 $(O)\lydosnet.tmp3 $(O)\bootlist.tmp
    set STAMPINF_VERSION=
    $(STAMP)
    $(RSBINPLACE_CMD)

#
# Coverage Real-signed dosnet.inf
#

$(_RSCOVINF)\dosnet.inf: $(_RSCOVINF)\dosnet.inx $(_LNG)\dosnet.txt $(_INX)\dosnet.mcv \
                      $(_COVINF)\dskspace.txt $(_RSCOVINF)\layout.inf $(_INX)\layout.mcv \
!IF $(WIN64)
                      $(O)\wowlist.inf $(O)\wowfiled.inf \
!endif
                       $(O)\layout.inx $(O)\layout.txt $(O)\exclude.inf
    $(CC) $(PREFLAGS) $(_LNG)\dosnet.txt > $(_RSCOVINF)\dosnet.txt1
    $(CC) $(PREFLAGS) $(_COVINF)\dskspace.txt > $(_RSCOVINF)\dskspace.txt1
    copy $(_RSCOVINF)\dosnet.inx+$(_RSCOVINF)\dosnet.txt1+$(_RSCOVINF)\dskspace.txt1 $(_RSCOVINF)\dosnet.tmp1
    call MergeFiles.cmd $(_RSCOVINF)\dosnet.tmp1 $(_INX)\dosnet.mcv $(_RSCOVINF)\dosnet.tmp2
    prodfilt -s $(_RSCOVINF)\dosnet.tmp2 $(_RSCOVINF)\dosnet.tmp1 +$(PLATFORM_SWITCH)
    prodfilt -s $(_RSCOVINF)\dosnet.tmp1 $(_RSCOVINF)\dosnet.tmp2 +$(PRODSWITCH)
    copy $(O)\layout.inx+$(O)\layout.txt $(_RSCOVINF)\lydosnet.tmp1
    call MergeFiles.cmd $(_RSCOVINF)\lydosnet.tmp1 $(_INX)\layout.mcv $(_RSCOVINF)\lydosnet.tmp2
    prodfilt -s $(_RSCOVINF)\lydosnet.tmp2 $(_RSCOVINF)\lydosnet.tmp1 +$(PRODSWITCH)
    prodfilt -s $(_RSCOVINF)\lydosnet.tmp1 $(_RSCOVINF)\lydosnet.tmp2 +$(PLATFORM_SWITCH)
!IF $(WIN64)
    xdosnet $(_RSCOVINF)\lydosnet.tmp2 $(_RSCOVINF)\dummy 1 $(_RSCOVINF)\lydosnet.tmp1 $(TARGET_DIRECTORY:i386=x86) $(O)\foo $(O)\exclude.inf $(_RSCOVINF)\bootlist.tmp
    copy $(_RSCOVINF)\lydosnet.tmp1+$(O)\bootlist.tmp $(_RSCOVINF)\lydosnet.tmp3
!else
    xdosnet $(_RSCOVINF)\lydosnet.tmp2 $(_RSCOVINF)\dummy * $(_RSCOVINF)\lydosnet.tmp3 $(TARGET_DIRECTORY:i386=x86) $(O)\foo $(O)\exclude.inf
!endif
    copy $(_RSCOVINF)\dosnet.tmp2+$(_RSCOVINF)\lydosnet.tmp3 $(_RSCOVINF)\dosnet.inf
    @del $(_RSCOVINF)\dosnet.tmp1 $(_RSCOVINF)\dosnet.tmp2 $(_RSCOVINF)\lydosnet.tmp1 $(_RSCOVINF)\lydosnet.tmp2 $(_RSCOVINF)\dosnet.txt1 $(_RSCOVINF)\dskspace.txt1 $(_RSCOVINF)\lydosnet.tmp3 $(O)\bootlist.tmp
    set STAMPINF_VERSION=
    $(STAMP)
    $(COVER_RSBINPLACE_CMD)

#
# Test-signed dosnet.inf
# Note we need to create a native layout.inf for xdosnet.exe with no wow files
# present
#

$(O)\dosnet.inf: $(O)\dosnet.inx $(_LNG)\dosnet.txt \
                    $(_LNG)\dskspace.txt $(O)\layout.inf \
!IF $(WIN64)
                      $(O)\wowlist.inf $(O)\wowfiled.inf \
!endif
                    $(O)\layout.inx $(O)\layout.txt $(O)\exclude.inf
    $(CC) $(PREFLAGS) $(_LNG)\dosnet.txt > $(O)\dosnet.txt1
    $(CC) $(PREFLAGS) $(_LNG)\dskspace.txt > $(O)\dskspace.txt1
    copy $(O)\dosnet.inx+$(O)\dosnet.txt1+$(O)\dskspace.txt1 $(O)\dosnet.tmp1
    prodfilt -s $(O)\dosnet.tmp1 $(O)\dosnet.tmp2 +$(PLATFORM_SWITCH)
    prodfilt -s $(O)\dosnet.tmp2 $(O)\dosnet.tmp1 +$(PRODSWITCH)
    copy $(O)\layout.inx+$(_INX)\layout.tst+$(O)\layout.txt $(O)\lydosnet.tmp1
    prodfilt -s $(O)\lydosnet.tmp1 $(O)\lydosnet.tmp2 +$(PRODSWITCH)
    prodfilt -s $(O)\lydosnet.tmp2 $(O)\lydosnet.tmp1 +$(PLATFORM_SWITCH)
!IF $(WIN64)
    xdosnet $(O)\lydosnet.tmp1 $(O)\dummy 1 $(O)\lydosnet.tmp2 $(TARGET_DIRECTORY:i386=x86) $(O)\foo $(O)\exclude.inf $(O)\bootlist.tmp
    copy $(O)\lydosnet.tmp2+$(O)\bootlist.tmp $(O)\lydosnet.tmp3
!else
    xdosnet $(O)\lydosnet.tmp1 $(O)\dummy * $(O)\lydosnet.tmp3 $(TARGET_DIRECTORY:i386=x86) $(O)\foo $(O)\exclude.inf
!endif
    copy $(O)\dosnet.tmp1+$(O)\lydosnet.tmp3 $(O)\dosnet.inf
!IF $(WIN64)
    copy $(_INF)\dosnet.inf $(O)\dosnet.tmp3
    copy $(O)\layout.inx+$(O)\layout.txt $(O)\dosnet.tmp1
    prodfilt -s $(O)\dosnet.tmp1 $(O)\dosnet.tmp2 +$(PRODSWITCH)
    prodfilt -s $(O)\dosnet.tmp2 $(O)\dosnet.tmp1 +i
    wowlist -i $(O)\dosnet.tmp1 -c $(O)\wowlist.inf -o $(O)\dosnet.tmp2 -ac -h $(O)\wowfiled.inf -f w 2>NUL
    xdosnet $(O)\dosnet.tmp2 $(O)\dummy 2 $(O)\dosnet.tmp1 $(TARGET_DIRECTORY:i386=x86)
    copy $(O)\dosnet.tmp3+$(O)\dosnet.tmp1 $(_INF)\dosnet.inf
    @del $(O)\dosnet.tmp3 $(_INF)\dosnet.tmp2
!ENDIF
    @del $(O)\dosnet.tmp1 $(O)\dosnet.tmp2 $(O)\lydosnet.tmp1 $(O)\lydosnet.tmp2 $(O)\dosnet.txt1 $(O)\dskspace.txt1 $(O)\lydosnet.tmp3 $(O)\bootlist.tmp
    set STAMPINF_VERSION=
    $(STAMP)
    $(TSBINPLACE_CMD)

#
# Coverage Test-signed dosnet.inf
# Note we need to create a native layout.inf for xdosnet.exe with no wow files
# present
#

$(_COVINF)\dosnet.inf: $(_COVINF)\dosnet.inx $(_LNG)\dosnet.txt $(_INX)\dosnet.mcv \
                    $(_COVINF)\dskspace.txt $(_COVINF)\layout.inf $(_INX)\layout.mcv \
!IF $(WIN64)
                      $(O)\wowlist.inf $(O)\wowfiled.inf \
!endif
                    $(O)\layout.inx $(O)\layout.txt $(O)\exclude.inf
    $(CC) $(PREFLAGS) $(_LNG)\dosnet.txt > $(_COVINF)\dosnet.txt1
    $(CC) $(PREFLAGS) $(_COVINF)\dskspace.txt > $(_COVINF)\dskspace.txt1
    copy $(_COVINF)\dosnet.inx+$(_COVINF)\dosnet.txt1+$(_COVINF)\dskspace.txt1 $(_COVINF)\dosnet.tmp1
    call MergeFiles.cmd $(_COVINF)\dosnet.tmp1 $(_INX)\dosnet.mcv $(_COVINF)\dosnet.tmp2
    prodfilt -s $(_COVINF)\dosnet.tmp2 $(_COVINF)\dosnet.tmp1 +$(PLATFORM_SWITCH)
    prodfilt -s $(_COVINF)\dosnet.tmp1 $(_COVINF)\dosnet.tmp2 +$(PRODSWITCH)
    copy $(O)\layout.inx+$(_INX)\layout.tst+$(O)\layout.txt $(_COVINF)\lydosnet.tmp1
    call MergeFiles.cmd $(_COVINF)\lydosnet.tmp1 $(_INX)\layout.mcv $(_COVINF)\lydosnet.tmp2
    prodfilt -s $(_COVINF)\lydosnet.tmp2 $(_COVINF)\lydosnet.tmp1 +$(PRODSWITCH)
    prodfilt -s $(_COVINF)\lydosnet.tmp1 $(_COVINF)\lydosnet.tmp2 +$(PLATFORM_SWITCH)
!IF $(WIN64)
    xdosnet $(_COVINF)\lydosnet.tmp2 $(_COVINF)\dummy 1 $(_COVINF)\lydosnet.tmp1 $(TARGET_DIRECTORY:i386=x86) $(O)\foo $(O)\exclude.inf $(O)\bootlist.tmp
    copy $(_COVINF)\lydosnet.tmp1+$(O)\bootlist.tmp $(_COVINF)\lydosnet.tmp3
!else
    xdosnet $(_COVINF)\lydosnet.tmp2 $(_COVINF)\dummy * $(_COVINF)\lydosnet.tmp3 $(TARGET_DIRECTORY:i386=x86) $(O)\foo $(O)\exclude.inf
!endif
    copy $(_COVINF)\dosnet.tmp2+$(_COVINF)\lydosnet.tmp3 $(_COVINF)\dosnet.inf
    @del $(_COVINF)\dosnet.tmp1 $(_COVINF)\dosnet.tmp2 $(_COVINF)\lydosnet.tmp1 $(_COVINF)\lydosnet.tmp2 $(_COVINF)\dosnet.txt1 $(_COVINF)\dskspace.txt1 $(_COVINF)\lydosnet.tmp3 $(O)\bootlist.tmp
    set STAMPINF_VERSION=
    $(STAMP)
    $(COVER_TSBINPLACE_CMD)


$(O)\sfcgen.inf: $(_INX)\sfcgen.inx $(_LNG)\sfcgen.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $(O)\$(@B).tmp1
    prodfilt -s $(O)\$(@B).tmp1 $(O)\$(@B).tmp2 +$(PRODSWITCH)
    prodfilt -s $(O)\$(@B).tmp2 $@ +$(PLATFORM_SWITCH)
    @del $(O)\$(@B).tmp1
    @del $(O)\$(@B).tmp2
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\certclas.inf: $(_INX)\certclas.inf
    prodfilt $(_INX)\certclas.inf $@ +$(PLATFORM_SWITCH)
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\testroot.cer: $(_INX)\testroot.cer
    copy $(_INX)\testroot.cer $(O)\.
    $(TSBINPLACE_CMD)

$(_COVINF)\testroot.cer: $(_INX)\testroot.cer
    copy $(_INX)\testroot.cer $(_COVINF)\.
    $(COVER_TSBINPLACE_CMD)

#
# BEGIN PCHealth preprocessing.
#
$(O)\pchmui.inf: $(_INX)\pchmui.inx $(_LNG)\pchmui.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $(O)\$(@B).tmp1
    prodfilt -s $(O)\$(@B).tmp1 $(O)\$(@B).tmp2 +$(PRODSWITCH)
    prodfilt -s $(O)\$(@B).tmp2 $@ +$(PLATFORM_SWITCH)
    @del $(O)\$(@B).tmp1
    @del $(O)\$(@B).tmp2
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\pchealth.inf: $(_INX)\pchealth.inx $(_LNG)\pchealth.txt
    copy $(_INX)\$(@B).inx+$(_LNG)\$(@B).txt $(O)\$(@B).tmp1
    prodfilt -s $(O)\$(@B).tmp1 $(O)\$(@B).tmp2 +$(PRODSWITCH)
    prodfilt -s $(O)\$(@B).tmp2 $@ +$(PLATFORM_SWITCH)
    @del $(O)\$(@B).tmp1
    @del $(O)\$(@B).tmp2
    $(TSBINPLACE_CMD)
#
# END PCHealth preprocessing.
#

$(O)\apphlpui.inf: $(_INX)\apphlpui.inx $(_LNG)\apphlpui.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $(O)\$(@B).tmp1
    prodfilt $(O)\$(@B).tmp1 $(O)\$(@B).tmp2 +$(PRODSWITCH)
    prodfilt $(O)\$(@B).tmp2 $@ +$(PLATFORM_SWITCH)
    @del $(O)\$(@B).tmp1
    @del $(O)\$(@B).tmp2
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\sr.inf: $(_INX)\sr.inx $(_LNG)\sr.txt
    copy $(_INX)\$(@B).inx+$(_LNG)\$(@B).txt $(O)\$(@B).tmp1
    prodfilt -s $(O)\$(@B).tmp1 $(O)\$(@B).tmp2 +$(PRODSWITCH)
    prodfilt -s $(O)\$(@B).tmp2 $@ +$(PLATFORM_SWITCH)
    @del $(O)\$(@B).tmp1
    @del $(O)\$(@B).tmp2
    $(TSBINPLACE_CMD)

$(O)\mmdriver.inf: $(_INX)\mmdriver.inx
    prodfilt -s $(_INX)\$(@B).inx $@ +$(PRODSWITCH)
    $(TSBINPLACE_CMD)

$(O)\ie5ui.inf: $(_INX)\ie5ui.inx $(_LNG)\ie5ui.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $(O)\$(@B).tmp1
    prodfilt $(O)\$(@B).tmp1 $(O)\$(@B).tmp2 +$(PRODSWITCH)
    prodfilt $(O)\$(@B).tmp2 $@ +$(PLATFORM_SWITCH)
    @del $(O)\$(@B).tmp1
    @del $(O)\$(@B).tmp2
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\perfmui.inf: $(_INX)\perfmui.inx $(_LNG)\perfmui.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $(O)\$(@B).tmp1
    prodfilt $(O)\$(@B).tmp1 $(O)\$(@B).tmp2 +$(PRODSWITCH)
    prodfilt $(O)\$(@B).tmp2 $@ +$(PLATFORM_SWITCH)
    @del $(O)\$(@B).tmp1
    @del $(O)\$(@B).tmp2
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\oemmui.inf: $(_INX)\oemmui.inx $(_LNG)\oemmui.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $(O)\$(@B).tmp1
    prodfilt $(O)\$(@B).tmp1 $(O)\$(@B).tmp2 +$(PRODSWITCH)
    prodfilt $(O)\$(@B).tmp2 $@ +$(PLATFORM_SWITCH)
    @del $(O)\$(@B).tmp1
    @del $(O)\$(@B).tmp2
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\wie5ui.inf: $(_INX)\wie5ui.inx $(_LNG)\wie5ui.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $(O)\$(@B).tmp1
    prodfilt $(O)\$(@B).tmp1 $(O)\$(@B).tmp2 +$(PRODSWITCH)
    prodfilt $(O)\$(@B).tmp2 $@ +$(PLATFORM_SWITCH)
    @del $(O)\$(@B).tmp1
    @del $(O)\$(@B).tmp2
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\moviemui.inf: $(_INX)\moviemui.inx $(_LNG)\moviemui.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $(O)\$(@B).tmp1
    prodfilt $(O)\$(@B).tmp1 $(O)\$(@B).tmp2 +$(PRODSWITCH)
    prodfilt $(O)\$(@B).tmp2 $@ +$(PLATFORM_SWITCH)
    @del $(O)\$(@B).tmp1
    @del $(O)\$(@B).tmp2
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\muiwow64.inf: $(_INX)\muiwow64.inx $(_LNG)\muiwow64.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $(O)\$(@B).tmp1
    prodfilt $(O)\$(@B).tmp1 $(O)\$(@B).tmp2 +$(PRODSWITCH)
    prodfilt $(O)\$(@B).tmp2 $@ +$(PLATFORM_SWITCH)
    @del $(O)\$(@B).tmp1
    @del $(O)\$(@B).tmp2
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\ermui.inf: $(_INX)\ermui.inx $(_LNG)\ermui.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $(O)\$(@B).tmp1
    prodfilt $(O)\$(@B).tmp1 $(O)\$(@B).tmp2 +$(PRODSWITCH)
    prodfilt $(O)\$(@B).tmp2 $@ +$(PLATFORM_SWITCH)
    @del $(O)\$(@B).tmp1
    @del $(O)\$(@B).tmp2
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\wermui.inf: $(_INX)\wermui.inx $(_LNG)\wermui.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $(O)\$(@B).tmp1
    prodfilt $(O)\$(@B).tmp1 $(O)\$(@B).tmp2 +$(PRODSWITCH)
    prodfilt $(O)\$(@B).tmp2 $@ +$(PLATFORM_SWITCH)
    @del $(O)\$(@B).tmp1
    @del $(O)\$(@B).tmp2
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\tourmui.inf: $(_INX)\tourmui.inx $(_LNG)\tourmui.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $(O)\$(@B).tmp1
    prodfilt $(O)\$(@B).tmp1 $(O)\$(@B).tmp2 +$(PRODSWITCH)
    prodfilt $(O)\$(@B).tmp2 $@ +$(PLATFORM_SWITCH)
    @del $(O)\$(@B).tmp1
    @del $(O)\$(@B).tmp2
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\drivercab.inf: $(_INX)\drivercab.inx $(_LNG)\drivercab.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $(O)\$(@B).tmp1
    prodfilt -s $(O)\$(@B).tmp1 $(O)\$(@B).tmp2 +$(PRODSWITCH)
    prodfilt -s $(O)\$(@B).tmp2 $@ +$(PLATFORM_SWITCH)
    @del $(O)\$(@B).tmp1
    @del $(O)\$(@B).tmp2
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

#
# icwnt5.inf
# Note: THis is currently not run through prodfilt. You will need to do that if you make any platform specific or
# product specific changes to the inx/txt file in the future.
#


$(O)\icwnt5.inf: $(_INX)\icwnt5.inx \
!if $(WIN64)
                   $(O)\wowlist.inf \
!endif
                 $(_LNG)\icwnt5.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $(O)\$(@B).tmp1
    $(C_COMPILER_NAME) -EP $(CDEFINES) $(O)\$(@B).tmp1 >$@
!if $(WIN64)
    copy $@ $(O)\$(@B).tmp2
    wowlist -i $@ -c $(O)\wowlist.inf -as -f w -d $(O)\icwnt5.wow -o $(O)\$(@B).tmp3
    copy $(O)\$(@B).tmp2+$(O)\$(@B).tmp3 $@
    @del $(O)\$(@B).tmp2 $(O)\$(@B).tmp3
!endif
    @del $(O)\$(@B).tmp1
    @del $(O)\$(@B).txt1
    $(TSBINPLACE_CMD)

!if $(WIN64)
$(O)\icwnt5.wow: $(O)\icwnt5.inf
!endif

$(O)\ieaccess.inf: $(_INX)\ieaccess.inx $(_LNG)\ieaccess.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $(O)\$(@B).tmp1
    prodfilt $(O)\$(@B).tmp1 $(O)\$(@B).tmp2 +$(PRODSWITCH)
    prodfilt $(O)\$(@B).tmp2 $@ +$(PLATFORM_SWITCH)
    @del $(O)\$(@B).tmp1
    @del $(O)\$(@B).tmp2
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\oeaccess.inf: $(_INX)\oeaccess.inx $(_LNG)\oeaccess.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $(O)\$(@B).tmp1
    prodfilt $(O)\$(@B).tmp1 $(O)\$(@B).tmp2 +$(PRODSWITCH)
    prodfilt $(O)\$(@B).tmp2 $@ +$(PLATFORM_SWITCH)
    @del $(O)\$(@B).tmp1
    @del $(O)\$(@B).tmp2
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\ieharden.inf: $(_INX)\ieharden.inx $(_LNG)\ieharden.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $(O)\$(@B).tmp1
    prodfilt $(O)\$(@B).tmp1 $(O)\$(@B).tmp2 +$(PRODSWITCH)
    prodfilt $(O)\$(@B).tmp2 $@ +$(PLATFORM_SWITCH)
    @del $(O)\$(@B).tmp1
    @del $(O)\$(@B).tmp2
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\iesacls.inf: $(_INX)\iesacls.inx
    copy $(_INX)\$(@B).inx $@
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\homepage.inf: $(_INX)\homepage.inx
    copy $(_INX)\$(@B).inx $(O)\$(@B).tmp1
    prodfilt $(O)\$(@B).tmp1 $(O)\$(@B).tmp2 +$(PRODSWITCH)
    prodfilt $(O)\$(@B).tmp2 $@ +$(PLATFORM_SWITCH)
    @del $(O)\$(@B).tmp1
    @del $(O)\$(@B).tmp2
    $(STAMP)
    $(TSBINPLACE_CMD)
    
$(O)\sakit.inf: $(_INX)\sakit.inx $(_LNG)\sakit.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $(O)\$(@B).tmp1
    prodfilt $(O)\$(@B).tmp1 $(O)\$(@B).tmp2 +$(PRODSWITCH)
    prodfilt $(O)\$(@B).tmp2 $@ +$(PLATFORM_SWITCH)
    @del $(O)\$(@B).tmp1
    @del $(O)\$(@B).tmp2
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\sakitmui.inf: $(_INX)\sakitmui.inx $(_LNG)\sakitmui.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $(O)\$(@B).tmp1
    prodfilt $(O)\$(@B).tmp1 $(O)\$(@B).tmp2 +$(PRODSWITCH)
    prodfilt $(O)\$(@B).tmp2 $@ +$(PLATFORM_SWITCH)
    @del $(O)\$(@B).tmp1
    @del $(O)\$(@B).tmp2
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\AuthMan.inf: $(_INX)\AuthMan.inx $(_LNG)\AuthMan.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $(O)\$(@B).tmp1
    prodfilt $(O)\$(@B).tmp1 $(O)\$(@B).tmp2 +$(PRODSWITCH)
    prodfilt $(O)\$(@B).tmp2 $@ +$(PLATFORM_SWITCH)
    @del $(O)\$(@B).tmp1
    @del $(O)\$(@B).tmp2
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\uddimui.inf: $(_INX)\uddimui.inx $(_LNG)\uddimui.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
    copy $(_INX)\$(@B).inx+$(O)\$(@B).txt1 $(O)\$(@B).tmp1
    prodfilt $(O)\$(@B).tmp1 $(O)\$(@B).tmp2 +$(PRODSWITCH)
    prodfilt $(O)\$(@B).tmp2 $@ +$(PLATFORM_SWITCH)
    @del $(O)\$(@B).tmp1
    @del $(O)\$(@B).tmp2
    @del $(O)\$(@B).txt1
    $(STAMP)
    $(TSBINPLACE_CMD)

$(O)\unattend.txt: $(_INX)\unattend.txt $(_LNG)\unattend.txt
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt $(_INX)\$(@B).txt > $(O)\$(@B).tmp1
    prodfilt $(O)\$(@B).tmp1 $(O)\$(@B).tmp2 +$(PRODSWITCH)
    prodfilt $(O)\$(@B).tmp2 $@ +$(PLATFORM_SWITCH)
    @del $(O)\$(@B).tmp1
    @del $(O)\$(@B).tmp2
    $(TSBINPLACE_CMD)

$(O)\profsec.inf: $(_INX)\profsec.inf
    prodfilt $(_INX)\profsec.inf $(O)\$(@B).tmp +$(PRODSWITCH)
    prodfilt $(O)\$(@B).tmp $@ +$(PLATFORM_SWITCH)
    @del $(O)\$(@B).tmp
    $(STAMP)
    $(TSBINPLACE_CMD)

#
# Update.inf's for both Hotfixes and Service Pack are
# both built using update.inx and update.txt
#
# Update.inf
#
$(O)\update.inf: $(_INX)\update.inx $(_LNG)\update.txt
    $(CC) $(PREFLAGS) $(_INX)\update.inx > $(O)\$(@B).inx1
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt  > $(O)\$(@B).txt1
    infmerge.exe $(O)\$(@B).inx1 $(O)\$(@B).txt1 $(O)\$(@B).tmp1
    prodfilt $(O)\$(@B).tmp1 $(O)\$(@B).tmp2 +$(PLATFORM_SWITCH)
    prodfilt $(O)\$(@B).tmp2 $@ +u
    @del $(O)\$(@B).tmp1
    @del $(O)\$(@B).tmp2
    @del $(O)\$(@B).inx1
    @del $(O)\$(@B).txt1
!if "$(PRODSWITCH)"=="w" || "$(PRODSWITCH)"=="W"
    $(TSBINPLACE_CMD)
!endif

#
# Hotfix.inf using update.inx
#
$(O)\hotfix.inf: $(_INX)\update.inx $(_LNG)\update.txt
    $(CC) $(PREFLAGS) $(_INX)\update.inx > $(O)\$(@B).inx1
    $(CC) $(PREFLAGS) $(_LNG)\update.txt  > $(O)\$(@B).txt1
    infmerge.exe $(O)\$(@B).inx1 $(O)\$(@B).txt1 $(O)\$(@B).tmp1
    prodfilt $(O)\$(@B).tmp1 $(O)\$(@B).tmp2 +$(PLATFORM_SWITCH)
    prodfilt $(O)\$(@B).tmp2 $@ +h
    @del $(O)\$(@B).tmp1
    @del $(O)\$(@B).tmp2
    @del $(O)\$(@B).inx1
    @del $(O)\$(@B).txt1
!if "$(PRODSWITCH)"=="w" || "$(PRODSWITCH)"=="W"
    $(TSBINPLACE_CMD)
!endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\compdata\makefile.inc ===
#################################################
# HOW TO UPDATE THIS FILE:
#
# 1. If you're adding a file that's the same in all sku's, skip down
#    to the BINPLACE_ONLY_FILES section and add your filename there
#
# 2. If you're adding a file that's different for one or more sku,
#    add it to the PREPROCESSED_HTMS macro.
#
# 3. There's no need to add it to both.
#

!ifndef BUILD_SPECIFIC_INFS

LCID=409
!IFNDEF LANGUAGE
LANGUAGE=usa
!ENDIF

!if "$(LANGUAGE)"=="CHS" || "$(LANGUAGE)"=="chs"
# Chinese, Simplified
LCID=804

!elseif "$(LANGUAGE)"=="CHT" || "$(LANGUAGE)"=="cht"
# Chinese, Traditional
LCID=404

!elseif "$(LANGUAGE)"=="CHH" || "$(LANGUAGE)"=="chh"
# Chinese, Traditional
LCID=C04

!elseif "$(LANGUAGE)"=="JPN" || "$(LANGUAGE)"=="jpn"
# Japanese
LCID=411

!elseif "$(LANGUAGE)"=="KOR" || "$(LANGUAGE)"=="kor"
# Korean
LCID=412

!elseif "$(LANGUAGE)"=="ARA" || "$(LANGUAGE)"=="ara"
# Arabic
LCID=401

!elseif "$(LANGUAGE)"=="HEB" || "$(LANGUAGE)"=="heb"
# Hebrew
LCID=40D

!elseif "$(LANGUAGE)"=="CS" || "$(LANGUAGE)"=="cs"
# Czech
LCID=405

!elseif "$(LANGUAGE)"=="HU" || "$(LANGUAGE)"=="hu"
# Hungarian
LCID=40E

!elseif "$(LANGUAGE)"=="PL" || "$(LANGUAGE)"=="pl"
# Polish
LCID=415

!elseif "$(LANGUAGE)"=="RU" || "$(LANGUAGE)"=="ru"
# Russian
LCID=419

!elseif "$(LANGUAGE)"=="EL" || "$(LANGUAGE)"=="el"
# Greek
LCID=408

!elseif "$(LANGUAGE)"=="TR" || "$(LANGUAGE)"=="tr"
# Turkish
LCID=41F

!elseif "$(LANGUAGE)"=="PSU" || "$(LANGUAGE)"=="psu"
LCID=408
!endif


!IF "$(TARGET_DIRECTORY)"=="i386"  || "$(TARGET_DIRECTORY)"=="I386"
PLATFORM_SWITCH=i
!ELSEIF "$(TARGET_DIRECTORY)"=="ia64"  || "$(TARGET_DIRECTORY)"=="IA64"
PLATFORM_SWITCH=m
!ELSEIF "$(TARGET_DIRECTORY)"=="amd64"  || "$(TARGET_DIRECTORY)"=="AMD64"
PLATFORM_SWITCH=a
!ELSE
! ERROR Invalid Platform Switch for infs
!ENDIF

PREFLAGS=/DLANGUAGE_ID=0x0$(LCID) -nologo /EP


_SRC=..\..
_LNG=$(_SRC)\$(LANGUAGE)

.SUFFIXES: .htm .txt

PREPROCESSED_HTMS= \
          $(O)\artcas6e.htm  \
          $(O)\artcas6e.txt  \
          $(O)\cano620p.htm \
          $(O)\cano620p.txt \
          $(O)\canos100.htm \
          $(O)\canos100.txt \
          $(O)\gsnw.htm     \
          $(O)\hp3300C.htm  \
          $(O)\hp3300C.txt  \
          $(O)\hp4300C.htm  \
          $(O)\hp4300C.txt  \
          $(O)\hp5300C.htm  \
          $(O)\hp5300C.txt  \
          $(O)\kodk4800.htm   \
          $(O)\kodk4800.txt   \
          $(O)\lqdaudio.htm \
          $(O)\mcrotk60.htm   \
          $(O)\mcrotk60.txt   \
          $(O)\mcrotkc3.htm \
          $(O)\mcrotkc3.txt \
          $(O)\mcrotks.htm  \
          $(O)\mcrotks.txt  \
          $(O)\minpw20.htm  \
          $(O)\minpw20.txt  \
          $(O)\ntcompat.inf \
          $(O)\plust120.htm   \
          $(O)\plust120.txt   \
          $(O)\sacompat.htm \
          $(O)\sacompat.txt \
          $(O)\sfunfscg.htm   \
          $(O)\sfunfscg.txt   \
          $(O)\tmaster.htm \
          $(O)\tmaster.txt \
          $(O)\tmdualag.htm \
          $(O)\tmdualag.txt \
          $(O)\upgbnn.htm \
          $(O)\upgbnn.txt \
          $(O)\upgbny.htm \
          $(O)\upgbny.txt \
          $(O)\upgbyn.htm \
          $(O)\upgbyn.txt \
          $(O)\upgbyy.htm \
          $(O)\upgbyy.txt \
          $(O)\upgwn.htm \
          $(O)\upgwn.txt \
          $(O)\upgwy.htm \
          $(O)\upgwy.txt \
          $(O)\visn5300.htm \
          $(O)\visn5300.txt \
          $(O)\visn6100.htm \
          $(O)\visn6100.txt \
          $(O)\winachsf.htm \
          $(O)\xeroxwct.htm \
          $(O)\xeroxwct.txt \
!if "$(PRODSWITCH)" == "s"
          $(_SRC)\wms.htm      \
          $(_SRC)\wms.txt      \
	  $(_SRC)\winsip.htm   \
          $(_SRC)\winsip.txt   \
!endif

BINPLACE_ONLY_FILES = \
!if "$(PRODSWITCH)" == "s"
          $(_SRC)\ClusComp.htm \
          $(_SRC)\ClusComp.txt \
          $(_SRC)\ClusTCB.htm \
          $(_SRC)\ClusTCB.txt \
          $(_SRC)\ClusTCBF.htm \
          $(_SRC)\ClusTCBF.txt \
          $(_SRC)\dmusic.htm   \
          $(_SRC)\dmusic.txt   \
!elseif "$(PRODSWITCH)" == "w"
          $(_SRC)\3com.htm     \
          $(_SRC)\3com.txt     \
          $(_SRC)\3com1.htm    \
          $(_SRC)\3com1.txt    \
          $(_SRC)\aacraid.htm  \
          $(_SRC)\aacraid.txt  \
          $(_SRC)\acer640p.htm \
          $(_SRC)\acer640p.txt \
          $(_SRC)\aclient.htm  \
          $(_SRC)\aclient.txt  \
          $(_SRC)\acs.htm      \
          $(_SRC)\acs.txt      \
          $(_SRC)\adaptec.htm  \
          $(_SRC)\adaptec.txt  \
          $(_SRC)\admpkw2k.htm \
          $(_SRC)\admpkw2k.txt \
          $(_SRC)\admpkxp.htm \
          $(_SRC)\admpkxp.txt \
          $(_SRC)\adperr.htm  \
          $(_SRC)\adperr.txt  \
          $(_SRC)\aha8940.htm  \
          $(_SRC)\aha8940.txt  \
          $(_SRC)\aicdrv.htm   \
          $(_SRC)\aicdrv.txt   \
          $(_SRC)\alkb2k.htm   \
          $(_SRC)\alkb2k.txt   \
          $(_SRC)\apmerror.htm \
          $(_SRC)\apmerror.txt \
          $(_SRC)\apfiltr.htm  \
          $(_SRC)\apfiltr.txt  \
          $(_SRC)\assetci.htm  \
          $(_SRC)\assetci.txt  \
          $(_SRC)\atguard.htm  \
          $(_SRC)\atguard.txt  \
          $(_SRC)\atkproto.htm \
          $(_SRC)\atkproto.txt \
          $(_SRC)\avpgatek.htm \
          $(_SRC)\avpgatek.txt \
          $(_SRC)\award.htm    \
          $(_SRC)\award.txt    \
          $(_SRC)\bayman.htm    \
          $(_SRC)\bayman.txt    \
          $(_SRC)\blackice.htm \
          $(_SRC)\blackice.txt \
          $(_SRC)\boserror.htm \
          $(_SRC)\boserror.txt \
          $(_SRC)\calcomp.htm  \
          $(_SRC)\calcomp.txt  \
          $(_SRC)\cardexec.htm \
          $(_SRC)\cardexec.txt \
          $(_SRC)\cdr4vsd.htm  \
          $(_SRC)\cdr4vsd.txt  \
          $(_SRC)\certsrv.htm  \
          $(_SRC)\certsrv.txt  \
          $(_SRC)\cic.htm      \
          $(_SRC)\cic.txt      \
          $(_SRC)\CiMgr.htm \
          $(_SRC)\CiMgr.txt \
          $(_SRC)\ciscoacu.htm \
          $(_SRC)\ciscoacu.txt \
          $(_SRC)\cldvd.htm    \
          $(_SRC)\cldvd.txt    \
          $(_SRC)\cltmgr.htm   \
          $(_SRC)\cltmgr.txt   \
          $(_SRC)\cpqcisse.htm \
          $(_SRC)\cpqcisse.txt \
	  $(_SRC)\cpqdaen.htm  \
	  $(_SRC)\cpqdaen.txt  \
          $(_SRC)\cpqdiagc.htm \
          $(_SRC)\cpqdiagc.txt \
          $(_SRC)\cpqfcac.htm  \
	  $(_SRC)\cpqfcac.txt  \
          $(_SRC)\cpqkbd.htm   \
          $(_SRC)\cpqkbd.txt   \
          $(_SRC)\cpqmulti.htm \
          $(_SRC)\cpqmulti.txt \
          $(_SRC)\cpqpnpmg.htm \
          $(_SRC)\cpqpnpmg.txt \
          $(_SRC)\cpqpwrex.htm \
          $(_SRC)\cpqpwrex.txt \
          $(_SRC)\cpufeat.htm  \
          $(_SRC)\cpufeat.txt  \
          $(_SRC)\crashmon.htm \
          $(_SRC)\crashmon.txt \
          $(_SRC)\cruise.htm   \
          $(_SRC)\cruise.txt   \
          $(_SRC)\crystal.htm  \
          $(_SRC)\crystal.txt  \
          $(_SRC)\cs4281.htm   \
          $(_SRC)\cs4281.txt   \
          $(_SRC)\csa64xx.htm  \
          $(_SRC)\csa64xx.txt  \
          $(_SRC)\csmigrat.htm \
          $(_SRC)\csmigrat.txt \
          $(_SRC)\csrem32.htm  \
          $(_SRC)\csrem32.txt  \
          $(_SRC)\ctz_crdl.htm \
          $(_SRC)\ctz_crdl.txt \
          $(_SRC)\custhal.htm  \
          $(_SRC)\custhal.txt  \
          $(_SRC)\dayt.htm \
          $(_SRC)\dayt.txt \
          $(_SRC)\decatapi.htm \
          $(_SRC)\decatapi.txt \
          $(_SRC)\decml.htm    \
          $(_SRC)\decml.txt    \
          $(_SRC)\dellps.htm   \
          $(_SRC)\dellps.txt   \
          $(_SRC)\dellth.htm   \
          $(_SRC)\dellth.txt   \
	  $(_SRC)\dfsComp.htm \
          $(_SRC)\dfsComp.txt   \
          $(_SRC)\directcd.htm \
          $(_SRC)\directcd.txt \
          $(_SRC)\dlcproto.htm    \
          $(_SRC)\dlcproto.txt    \
          $(_SRC)\dmibios.htm  \
          $(_SRC)\dmibios.txt  \
          $(_SRC)\dock.htm     \
          $(_SRC)\dock.txt     \
          $(_SRC)\docksvc.htm  \
          $(_SRC)\docksvc.txt  \
          $(_SRC)\domain2a.htm  \
          $(_SRC)\domain2a.txt  \
          $(_SRC)\domain2b.htm  \
          $(_SRC)\domain2b.txt  \
          $(_SRC)\drvncdb.htm  \
          $(_SRC)\drvncdb.txt  \
          $(_SRC)\dsmu.htm     \
          $(_SRC)\dsmu.txt     \
          $(_SRC)\dv_comp.htm  \
          $(_SRC)\dv_comp.txt  \
          $(_SRC)\dv_gen.htm   \
          $(_SRC)\dv_gen.txt   \
          $(_SRC)\dwrite.htm   \
          $(_SRC)\dwrite.txt   \
          $(_SRC)\eiconta.htm  \
          $(_SRC)\eiconta.txt  \
          $(_SRC)\elsamx.htm \
          $(_SRC)\elsamx.txt \
          $(_SRC)\ensoniqv.htm \
          $(_SRC)\ensoniqv.txt \
          $(_SRC)\ensqaudm.htm \
          $(_SRC)\ensqaudm.txt \
          $(_SRC)\exchange.htm \
          $(_SRC)\exchange.txt \
          $(_SRC)\fazam.htm    \
          $(_SRC)\fazam.txt    \
          $(_SRC)\fidmou.htm   \
          $(_SRC)\fidmou.txt   \
          $(_SRC)\fjhwmn.htm   \
          $(_SRC)\fjhwmn.txt   \
          $(_SRC)\fjpman.htm   \
          $(_SRC)\fjpman.txt   \
          $(_SRC)\flowch7.htm  \
          $(_SRC)\flowch7.txt  \
          $(_SRC)\forest1a.htm  \
          $(_SRC)\forest1a.txt  \
          $(_SRC)\forest1b.htm  \
          $(_SRC)\forest1b.txt  \
          $(_SRC)\ftcomp1.htm   \
          $(_SRC)\ftcomp1.txt   \
          $(_SRC)\ftcomp2.htm   \
          $(_SRC)\ftcomp2.txt   \
          $(_SRC)\ftcomp3.htm   \
          $(_SRC)\ftcomp3.txt   \
          $(_SRC)\generic.htm  \
          $(_SRC)\generic.txt  \
          $(_SRC)\genius.htm   \
          $(_SRC)\genius.txt   \
          $(_SRC)\glint.htm    \
          $(_SRC)\glint.txt    \
          $(_SRC)\groveler.htm \
          $(_SRC)\groveler.txt \
          $(_SRC)\gsnw.txt     \
          $(_SRC)\halhook.htm  \
          $(_SRC)\halhook.txt  \
          $(_SRC)\hdmib.htm    \
          $(_SRC)\hdmib.txt    \
          $(_SRC)\hdmon.htm    \
          $(_SRC)\hdmon.txt    \
          $(_SRC)\hercules.htm  \
          $(_SRC)\hercules.txt  \
          $(_SRC)\hpcompat.htm \
          $(_SRC)\hpcompat.txt \
          $(_SRC)\hpdmi.htm    \
          $(_SRC)\hpdmi.txt    \
          $(_SRC)\hpi_usb.htm  \
          $(_SRC)\hpi_usb.txt  \
          $(_SRC)\hpjetmon.htm \
          $(_SRC)\hpjetmon.txt \
          $(_SRC)\hplock.htm   \
          $(_SRC)\hplock.txt   \
          $(_SRC)\hpmmkb.htm   \
          $(_SRC)\hpmmkb.txt   \
          $(_SRC)\hpmon.htm    \
          $(_SRC)\hpmon.txt    \
          $(_SRC)\hpsmart.htm  \
          $(_SRC)\hpsmart.txt  \
          $(_SRC)\hpsparnt.htm \
          $(_SRC)\hpsparnt.txt \
          $(_SRC)\hpttidm.htm  \
          $(_SRC)\hpttidm.txt  \
          $(_SRC)\iavboot4.htm \
          $(_SRC)\iavboot4.txt \
          $(_SRC)\i2cnt.htm    \
          $(_SRC)\i2cnt.txt    \
          $(_SRC)\iascomp.htm  \
          $(_SRC)\iascomp.txt  \
          $(_SRC)\ibmir.htm    \
          $(_SRC)\ibmir.txt    \
          $(_SRC)\ibmmpg.htm   \
          $(_SRC)\ibmmpg.txt   \
          $(_SRC)\ibmsva.htm   \
          $(_SRC)\ibmsva.txt   \
          $(_SRC)\ibmtp4.htm   \
          $(_SRC)\ibmtp4.txt   \
          $(_SRC)\ibm_ums.htm  \
          $(_SRC)\ibm_ums.txt  \
          $(_SRC)\ibmvc.htm    \
          $(_SRC)\ibmvc.txt    \
          $(_SRC)\icpv.htm     \
          $(_SRC)\icpv.txt     \
          $(_SRC)\icsupgrd.htm \
          $(_SRC)\icsupgrd.txt \
          $(_SRC)\ils.htm \
          $(_SRC)\ils.txt \
          $(_SRC)\imation.htm  \
          $(_SRC)\imation.txt  \
          $(_SRC)\incompat.htm \
          $(_SRC)\incompat.txt \
          $(_SRC)\initio.htm   \
          $(_SRC)\initio.txt   \
          $(_SRC)\intelapp.htm \
          $(_SRC)\intelapp.txt \
          $(_SRC)\intelata.htm \
          $(_SRC)\intelata.txt \
          $(_SRC)\intellip.htm \
          $(_SRC)\intellip.txt \
          $(_SRC)\intelup.htm  \
          $(_SRC)\intelup.txt  \
          $(_SRC)\intlsisl.htm \
          $(_SRC)\intlsisl.txt \
          $(_SRC)\ioclick.htm  \
          $(_SRC)\ioclick.txt  \
          $(_SRC)\iomega.htm   \
          $(_SRC)\iomega.txt   \
          $(_SRC)\ipxrras.htm  \
          $(_SRC)\ipxrras.txt  \
          $(_SRC)\ishrnt.htm   \
          $(_SRC)\ishrnt.txt   \
          $(_SRC)\isotp4.htm   \
          $(_SRC)\isotp4.txt   \
          $(_SRC)\isvgina.htm  \
          $(_SRC)\isvgina.txt  \
          $(_SRC)\ix526fc.htm  \
          $(_SRC)\ix526fc.txt  \
          $(_SRC)\kmw.htm      \
          $(_SRC)\kmw.txt      \
          $(_SRC)\krnlchk.htm      \
          $(_SRC)\krnlchk.txt      \
          $(_SRC)\laplink.htm  \
          $(_SRC)\laplink.txt  \
          $(_SRC)\laplnk2k.htm \
          $(_SRC)\laplnk2k.txt \
          $(_SRC)\ldcm.htm     \
          $(_SRC)\ldcm.txt     \
          $(_SRC)\lexdlc.htm   \
          $(_SRC)\lexdlc.txt   \
          $(_SRC)\lextcp.htm   \
          $(_SRC)\lextcp.txt   \
          $(_SRC)\lm75.htm     \
          $(_SRC)\lm75.txt     \
          $(_SRC)\lm78.htm     \
          $(_SRC)\lm78.txt     \
          $(_SRC)\lmrepl.htm   \
          $(_SRC)\lmrepl.txt   \
          $(_SRC)\logitech.htm \
          $(_SRC)\logitech.txt \
          $(_SRC)\logkcmd.htm  \
          $(_SRC)\logkcmd.txt  \
          $(_SRC)\lqdaudio.txt \
          $(_SRC)\ltmodem.htm  \
          $(_SRC)\ltmodem.txt  \
          $(_SRC)\macdrive.htm \
          $(_SRC)\macdrive.txt \
          $(_SRC)\maestro0.htm \
          $(_SRC)\maestro0.txt \
          $(_SRC)\maxell.htm   \
          $(_SRC)\maxell.txt   \
          $(_SRC)\mca.htm      \
          $(_SRC)\mca.txt      \
          $(_SRC)\mcfilter.htm \
          $(_SRC)\mcfilter.txt \
          $(_SRC)\melco.htm    \
          $(_SRC)\melco.txt    \
          $(_SRC)\mgactrl.htm  \
          $(_SRC)\mgactrl.txt  \
          $(_SRC)\mpath.htm    \
          $(_SRC)\mpath.txt    \
          $(_SRC)\msmqcomp.htm \
          $(_SRC)\msmqcomp.txt \
          $(_SRC)\msp1.htm     \
          $(_SRC)\msp1.txt     \
          $(_SRC)\msp2.htm     \
          $(_SRC)\msp2.txt     \
          $(_SRC)\msss3.htm     \
          $(_SRC)\msss3.txt     \
          $(_SRC)\mstock.htm   \
          $(_SRC)\mstock.txt   \
          $(_SRC)\nav5.htm    \
          $(_SRC)\nav5.txt    \
          $(_SRC)\nbfproto.htm    \
          $(_SRC)\nbfproto.txt    \
          $(_SRC)\NdcPrtNS.htm \
          $(_SRC)\NdcPrtNS.txt \
          $(_SRC)\netfmigt.htm \
          $(_SRC)\netfmigt.txt \
          $(_SRC)\nmsms.htm   \
          $(_SRC)\nmsms.txt   \
          $(_SRC)\ntdsupg.htm  \
          $(_SRC)\ntdsupg.txt  \
          $(_SRC)\ntdsupgd.htm \
          $(_SRC)\ntdsupgd.txt \
          $(_SRC)\nwcli32.htm \
          $(_SRC)\nwcli32.txt \
          $(_SRC)\ocablock.htm \
          $(_SRC)\ocablock.txt \
          $(_SRC)\oilchg25.htm \
          $(_SRC)\oilchg25.txt \
          $(_SRC)\omc.htm      \
          $(_SRC)\omc.txt      \
          $(_SRC)\Omnipg10.htm \
          $(_SRC)\Omnipg10.txt \
          $(_SRC)\onstream.htm \
          $(_SRC)\onstream.txt \
          $(_SRC)\orb.htm      \
          $(_SRC)\orb.txt      \
          $(_SRC)\palm.htm     \
          $(_SRC)\palm.txt     \
          $(_SRC)\panadvd.htm  \
          $(_SRC)\panadvd.txt  \
          $(_SRC)\panda.htm    \
          $(_SRC)\panda.txt    \
          $(_SRC)\pcany.htm    \
          $(_SRC)\pcany.txt    \
          $(_SRC)\pccillin.htm \
          $(_SRC)\pccillin.txt \
          $(_SRC)\pciinfo.htm  \
          $(_SRC)\pciinfo.txt  \
          $(_SRC)\pcpnp.htm    \
          $(_SRC)\pcpnp.txt    \
          $(_SRC)\pelmouse.htm \
          $(_SRC)\pelmouse.txt \
          $(_SRC)\pfs.htm      \
          $(_SRC)\pfs.txt      \
          $(_SRC)\phnixad.htm  \
          $(_SRC)\phnixad.txt  \
          $(_SRC)\phpipe.htm   \
          $(_SRC)\phpipe.txt   \
          $(_SRC)\poolext.htm  \
          $(_SRC)\poolext.txt  \
          $(_SRC)\power.htm    \
          $(_SRC)\power.txt    \
          $(_SRC)\powpath.htm  \
          $(_SRC)\powpath.txt  \
	  $(_SRC)\prlntss.htm  \
	  $(_SRC)\prlntss.txt  \
          $(_SRC)\probepro.htm \
          $(_SRC)\probepro.txt \
          $(_SRC)\prolight.htm \
          $(_SRC)\prolight.txt \
          $(_SRC)\ps2cont.htm  \
          $(_SRC)\ps2cont.txt  \
          $(_SRC)\pstrip.htm   \
          $(_SRC)\pstrip.txt   \
          $(_SRC)\pumacsm.htm  \
          $(_SRC)\pumacsm.txt  \
          $(_SRC)\pwricon.htm  \
          $(_SRC)\pwricon.txt  \
          $(_SRC)\qdomains.htm \
          $(_SRC)\qdomains.txt \
          $(_SRC)\qfelist.htm  \
          $(_SRC)\qic117.htm   \
          $(_SRC)\qic117.txt   \
          $(_SRC)\quick3.htm   \
          $(_SRC)\quick3.txt   \
          $(_SRC)\rcentrl.htm  \
          $(_SRC)\rcentrl.txt  \
          $(_SRC)\reachout.htm \
          $(_SRC)\reachout.txt \
          $(_SRC)\riptide.htm  \
          $(_SRC)\riptide.txt  \
          $(_SRC)\rssblock.htm \
          $(_SRC)\rssblock.txt \
          $(_SRC)\runonce.htm  \
          $(_SRC)\runonce.txt  \
          $(_SRC)\sbs45fxc.htm  \
          $(_SRC)\sbs45fxc.txt  \
          $(_SRC)\sbs50fxc.htm  \
          $(_SRC)\sbs50fxc.txt  \
          $(_SRC)\sbs50fxs.htm  \
          $(_SRC)\sbs50fxs.txt  \
          $(_SRC)\w2kfax.htm    \
          $(_SRC)\w2kfax.txt    \
          $(_SRC)\scandrv.htm  \
          $(_SRC)\scandrv.txt  \
          $(_SRC)\SecInterop.htm  \
          $(_SRC)\SecInterop.txt  \
          $(_SRC)\sdselect.htm  \
          $(_SRC)\sdselect.txt  \
          $(_SRC)\sharshtl.htm \
          $(_SRC)\sharshtl.txt \
          $(_SRC)\sigma.htm    \
          $(_SRC)\sigma.txt    \
          $(_SRC)\siig.htm     \
          $(_SRC)\siig.txt     \
          $(_SRC)\siigc.htm    \
          $(_SRC)\siigc.txt    \
          $(_SRC)\sisv.htm     \
          $(_SRC)\sisv.txt     \
          $(_SRC)\siwvid.htm   \
          $(_SRC)\siwvid.txt   \
          $(_SRC)\skusbkbf.htm \
          $(_SRC)\skusbkbf.txt \
          $(_SRC)\sms.htm      \
          $(_SRC)\sms.txt      \
          $(_SRC)\sms2sp3.htm  \
          $(_SRC)\sms2sp3.txt  \
          $(_SRC)\sna.htm      \
          $(_SRC)\sna.txt      \
          $(_SRC)\snidmi.htm   \
          $(_SRC)\snidmi.txt   \
          $(_SRC)\snidpms.htm  \
          $(_SRC)\snidpms.txt  \
          $(_SRC)\snipci.htm   \
          $(_SRC)\snipci.txt   \
          $(_SRC)\softoff.htm  \
          $(_SRC)\softoff.txt  \
          $(_SRC)\sonic.htm    \
          $(_SRC)\sonic.txt    \
          $(_SRC)\sonyjdu.htm  \
          $(_SRC)\sonyjdu.txt  \
          $(_SRC)\spxblock.htm \
          $(_SRC)\spxblock.txt \
          $(_SRC)\sql.htm      \
          $(_SRC)\sql.txt      \
          $(_SRC)\sscntrl.htm  \
          $(_SRC)\sscntrl.txt  \
          $(_SRC)\ssi365.htm   \
          $(_SRC)\ssi365.txt   \
          $(_SRC)\sspower.htm  \
          $(_SRC)\sspower.txt  \
          $(_SRC)\stb.htm      \
          $(_SRC)\stb.txt      \
          $(_SRC)\svcpack.htm  \
          $(_SRC)\svcpack.txt  \
          $(_SRC)\swoff.htm    \
          $(_SRC)\swoff.txt    \
          $(_SRC)\syshwcfg.htm \
          $(_SRC)\syshwcfg.txt \
          $(_SRC)\sysmgmt.htm  \
          $(_SRC)\sysmgmt.txt  \
          $(_SRC)\sysmon.htm   \
          $(_SRC)\sysmon.txt   \
          $(_SRC)\tcbenab.htm   \
          $(_SRC)\tcbenab.txt   \
          $(_SRC)\titsb.htm    \
          $(_SRC)\titsb.txt    \
          $(_SRC)\tivoli.htm   \
          $(_SRC)\tivoli.txt   \
          $(_SRC)\tmdigpro.htm \
          $(_SRC)\tmdigpro.txt \
          $(_SRC)\toptools.htm \
          $(_SRC)\toptools.txt \
          $(_SRC)\tosdvd.htm   \
          $(_SRC)\tosdvd.txt   \
          $(_SRC)\tpchrsrv.htm \
          $(_SRC)\tpchrsrv.txt \
          $(_SRC)\tpconfig.htm \
          $(_SRC)\tpconfig.txt \
          $(_SRC)\tpfuel.htm   \
          $(_SRC)\tpfuel.txt   \
          $(_SRC)\tppmport.htm \
          $(_SRC)\tppmport.txt \
          $(_SRC)\tridwnw.htm  \
          $(_SRC)\tridwnw.txt  \
          $(_SRC)\tsb24cdj.htm \
          $(_SRC)\tsb24cdj.txt \
          $(_SRC)\tsbams.htm   \
          $(_SRC)\tsbams.txt   \
          $(_SRC)\tsbapm.htm   \
          $(_SRC)\tsbapm.txt   \
          $(_SRC)\tsbapmdt.htm \
          $(_SRC)\tsbapmdt.txt \
          $(_SRC)\tsbasd.htm   \
          $(_SRC)\tsbasd.txt   \
          $(_SRC)\tsbhddpw.htm \
          $(_SRC)\tsbhddpw.txt \
          $(_SRC)\tsbmc.htm    \
          $(_SRC)\tsbmc.txt    \
          $(_SRC)\tsbselba.txt \
          $(_SRC)\tsbselba.htm \
          $(_SRC)\tsbspoff.htm \
          $(_SRC)\tsbspoff.txt \
          $(_SRC)\tsbds.txt   \
          $(_SRC)\tsbds.htm   \
          $(_SRC)\tsbvcap.htm  \
          $(_SRC)\tsbvcap.txt  \
          $(_SRC)\tsscidrv.htm \
          $(_SRC)\tsscidrv.txt \
          $(_SRC)\tt128.htm    \
          $(_SRC)\tt128.txt    \
          $(_SRC)\umax.htm     \
          $(_SRC)\umax.txt     \
          $(_SRC)\utupgr05.htm \
          $(_SRC)\utupgr05.txt \
          $(_SRC)\utupgr06.htm \
          $(_SRC)\utupgr06.txt \
          $(_SRC)\vidapplt.htm \
          $(_SRC)\vidapplt.txt \
          $(_SRC)\vgamode.htm  \
          $(_SRC)\vgamode.txt  \
          $(_SRC)\vpnports.htm  \
          $(_SRC)\vpnports.txt  \
          $(_SRC)\wacomdrv.htm \
          $(_SRC)\wacomdrv.txt \
          $(_SRC)\wce21.htm    \
          $(_SRC)\wce21.txt    \
          $(_SRC)\wcgodrv.htm  \
          $(_SRC)\wcgodrv.txt  \
          $(_SRC)\wcmigrat.htm \
          $(_SRC)\wcmigrat.txt \
          $(_SRC)\webscanx.htm \
          $(_SRC)\webscanx.txt \
          $(_SRC)\winachsf.txt \
          $(_SRC)\winsql.htm   \
          $(_SRC)\winsql.txt   \
          $(_SRC)\wtcls2k.htm  \
          $(_SRC)\wtcls2k.txt  \
          $(_SRC)\xlink.htm    \
          $(_SRC)\xlink.txt    \
          $(_SRC)\yacxg.htm    \
          $(_SRC)\yacxg.txt    \
          $(_SRC)\ymhsynth.htm \
          $(_SRC)\ymhsynth.txt \
          $(_SRC)\zipmagic.htm \
          $(_SRC)\zipmagic.txt \
          $(_SRC)\necdmi.htm \
          $(_SRC)\necdmi.txt \
          $(_SRC)\necldcm1.htm \
          $(_SRC)\necldcm1.txt \
          $(_SRC)\necldcm2.htm \
          $(_SRC)\necldcm2.txt \
          $(_SRC)\necupkit.htm \
          $(_SRC)\necupkit.txt \
          $(_SRC)\nxpad.htm \
          $(_SRC)\nxpad.txt \
          $(_SRC)\PCANY921.HTM \
          $(_SRC)\PCANY921.TXT \
          $(_SRC)\Pcanyex1.htm \
          $(_SRC)\Pcanyex1.txt \
          $(_SRC)\PCANYEX2.HTM \
          $(_SRC)\PCANYEX2.TXT

!endif

!IFDEF PERSONALFILES
BINPLACE_FLAGS=$(BINPLACE_FLAGS) -b ..\..\perinf\winnt32\compdata
!ENDIF

!IFDEF BLADEFILES
BINPLACE_FLAGS=$(BINPLACE_FLAGS) -b ..\..\blainf\winnt32\compdata
!ENDIF

!IFDEF SMALLBUSINESSSERVERFILES
BINPLACE_FLAGS=$(BINPLACE_FLAGS) -b ..\..\sbsinf\winnt32\compdata
!ENDIF

!IFDEF SERVERFILES
BINPLACE_FLAGS=$(BINPLACE_FLAGS) -b ..\..\srvinf\winnt32\compdata
!ENDIF

!IFDEF ENTERPRISEFILES
BINPLACE_FLAGS=$(BINPLACE_FLAGS) -b ..\..\entinf\winnt32\compdata
!ENDIF

!IFDEF DATACENTERFILES
BINPLACE_FLAGS=$(BINPLACE_FLAGS) -b ..\..\dtcinf\winnt32\compdata
!ENDIF

all:    \
!if "$(LANGUAGE)"=="usa" || "$(LANGUAGE)"=="USA"
    make_htms binplace_htms 
!else
    binplace_ntcompat 
!ENDIF

make_htms: $(PREPROCESSED_HTMS)

binplace_htms: $(BINPLACE_ONLY_FILES) $(PREPROCESSED_HTMS)
!ifndef NO_BINPLACE
    !binplace -R $(_NTTREE) $(BINPLACE_DBGFLAGS_NT) $(BINPLACE_FLAGS) $(BINPLACE_LC_MISCFLAGS) $**
!endif

binplace_ntcompat: $(O)\ntcompat.inf 
!ifndef NO_BINPLACE
    !binplace -R $(_NTTREE) $(BINPLACE_DBGFLAGS_NT) $(BINPLACE_FLAGS) $(BINPLACE_LC_MISCFLAGS) $**
!endif

{$(_SRC)}.htm{$(O)}.htm:
    prodfilt $< $@ +$(PRODSWITCH)

{$(_SRC)}.txt{$(O)}.txt:
    prodfilt $< $@ +$(PRODSWITCH)

$(O)\ntcompat.inf: $(_SRC)\ntcompat.inx $(_LNG)\ntcompat.txt
        $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt1
        copy /b $(_SRC)\$(@B).inx+$(O)\$(@B).txt1 $(O)\$(@B).tmp1
        prodfilt -s $(O)\$(@B).tmp1 $(O)\$(@B).tmp2 +$(PLATFORM_SWITCH)
        prodfilt -s $(O)\$(@B).tmp2 $@ +$(PRODSWITCH)
        @del $(O)\$(@B).tmp1
        @del $(O)\$(@B).tmp2
        @del $(O)\$(@B).txt1

!else

make_htms:
!endif      # BUILD_SPECIFIC_INFS
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\compdata\sources.inc ===
TARGETNAME=htm
TARGETTYPE=NOTARGET
TARGETPATH=obj
SOURCES=
BINPLACE_PLACEFILE=..\..\placefil.txt
NTTARGETFILE0=make_htms
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\compdata\arainf\per\makefile.inc ===
PRODSWITCH=p
PERSONALFILES=1
LANGUAGE=ARA
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\compdata\arainf\wks\makefile.inc ===
PRODSWITCH=w
LANGUAGE=ARA
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\compdata\brinf\bla\makefile.inc ===
PRODSWITCH=b
BLADEFILES =1
LANGUAGE=BR
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\compdata\brinf\dat\makefile.inc ===
PRODSWITCH=d
DATACENTERFILES=1
LANGUAGE=BR
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\compdata\brinf\ent\makefile.inc ===
PRODSWITCH=e
ENTERPRISEFILES=1
LANGUAGE=BR
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\compdata\brinf\wks\makefile.inc ===
PRODSWITCH=w
LANGUAGE=BR
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\compdata\brinf\per\makefile.inc ===
PRODSWITCH=p
PERSONALFILES=1
LANGUAGE=BR
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\compdata\brinf\srv\makefile.inc ===
PRODSWITCH=s
SERVERFILES=1
LANGUAGE=BR
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\compdata\chsinf\bla\makefile.inc ===
PRODSWITCH=b
BLADEFILES=1
LANGUAGE=CHS
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\compdata\chsinf\dat\makefile.inc ===
PRODSWITCH=d
DATACENTERFILES=1
LANGUAGE=CHS
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\compdata\chsinf\ent\makefile.inc ===
PRODSWITCH=e
ENTERPRISEFILES=1
LANGUAGE=CHS
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\compdata\chsinf\per\makefile.inc ===
PRODSWITCH=p
PERSONALFILES=1
LANGUAGE=CHS
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\compdata\chsinf\srv\makefile.inc ===
PRODSWITCH=s
SERVERFILES=1
LANGUAGE=CHS
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\compdata\chtinf\bla\makefile.inc ===
PRODSWITCH=b
BLADEFILES=1
LANGUAGE=CHT
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\compdata\chtinf\dat\makefile.inc ===
PRODSWITCH=d
DATACENTERFILES=1
LANGUAGE=CHT
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\compdata\chtinf\ent\makefile.inc ===
PRODSWITCH=e
ENTERPRISEFILES=1
LANGUAGE=CHT
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\compdata\chsinf\wks\makefile.inc ===
PRODSWITCH=w
LANGUAGE=CHS
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\compdata\chtinf\per\makefile.inc ===
PRODSWITCH=p
PERSONALFILES=1
LANGUAGE=CHT
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\compdata\chtinf\srv\makefile.inc ===
PRODSWITCH=s
SERVERFILES=1
LANGUAGE=CHT
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\compdata\chtinf\wks\makefile.inc ===
PRODSWITCH=w
LANGUAGE=CHT
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\compdata\csinf\dat\makefile.inc ===
PRODSWITCH=d
DATACENTERFILES=1
LANGUAGE=CS
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\compdata\csinf\ent\makefile.inc ===
PRODSWITCH=e
ENTERPRISEFILES=1
LANGUAGE=CS
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\compdata\csinf\bla\makefile.inc ===
PRODSWITCH=b
BLADEFILES =1
LANGUAGE=CS
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\compdata\csinf\per\makefile.inc ===
PRODSWITCH=p
PERSONALFILES=1
LANGUAGE=CS
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\compdata\csinf\srv\makefile.inc ===
PRODSWITCH=s
SERVERFILES=1
LANGUAGE=CS
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\compdata\csinf\wks\makefile.inc ===
PRODSWITCH=w
LANGUAGE=CS
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\compdata\dainf\bla\makefile.inc ===
PRODSWITCH=b
BLADEFILES =1
LANGUAGE=DA
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\compdata\dainf\per\makefile.inc ===
PRODSWITCH=p
PERSONALFILES=1 
LANGUAGE=DA
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\compdata\dainf\ent\makefile.inc ===
PRODSWITCH=e
ENTERPRISEFILES=1
LANGUAGE=DA
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\compdata\dainf\dat\makefile.inc ===
PRODSWITCH=d
DATACENTERFILES=1
LANGUAGE=DA
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\compdata\dainf\srv\makefile.inc ===
PRODSWITCH=s
SERVERFILES=1
LANGUAGE=DA
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\compdata\elinf\per\makefile.inc ===
PRODSWITCH=p
PERSONALFILES=1
LANGUAGE=EL
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\compdata\elinf\bla\makefile.inc ===
PRODSWITCH=b
BLADEFILES =1
LANGUAGE=EL
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\compdata\elinf\dat\makefile.inc ===
PRODSWITCH=d
DATACENTERFILES=1
LANGUAGE=EL
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\compdata\elinf\ent\makefile.inc ===
PRODSWITCH=e
ENTERPRISEFILES=1
LANGUAGE=EL
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\compdata\dainf\wks\makefile.inc ===
PRODSWITCH=w
LANGUAGE=DA
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\compdata\elinf\srv\makefile.inc ===
PRODSWITCH=s
SERVERFILES=1
LANGUAGE=EL
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\compdata\esinf\bla\makefile.inc ===
PRODSWITCH=b
BLADEFILES =1
LANGUAGE=ES
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\compdata\esinf\per\makefile.inc ===
PRODSWITCH=p
PERSONALFILES=1
LANGUAGE=ES
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\compdata\esinf\dat\makefile.inc ===
PRODSWITCH=d
DATACENTERFILES=1
LANGUAGE=ES
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\compdata\elinf\wks\makefile.inc ===
PRODSWITCH=w
LANGUAGE=EL
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\compdata\esinf\ent\makefile.inc ===
PRODSWITCH=e
ENTERPRISEFILES=1
LANGUAGE=ES
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\compdata\fiinf\dat\makefile.inc ===
PRODSWITCH=d
DATACENTERFILES=1
LANGUAGE=FI
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\compdata\fiinf\ent\makefile.inc ===
PRODSWITCH=e
ENTERPRISEFILES=1
LANGUAGE=FI
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\compdata\fiinf\bla\makefile.inc ===
PRODSWITCH=b
BLADEFILES =1
LANGUAGE=FI
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\compdata\esinf\srv\makefile.inc ===
PRODSWITCH=s
SERVERFILES=1
LANGUAGE=ES
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\compdata\esinf\wks\makefile.inc ===
PRODSWITCH=w
LANGUAGE=ES
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\compdata\fiinf\per\makefile.inc ===
PRODSWITCH=p
PERSONALFILES=1
LANGUAGE=FI
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\compdata\fiinf\srv\makefile.inc ===
PRODSWITCH=s
SERVERFILES=1
LANGUAGE=FI
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\compdata\fiinf\wks\makefile.inc ===
PRODSWITCH=w
LANGUAGE=FI
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\compdata\frinf\ent\makefile.inc ===
PRODSWITCH=e
ENTERPRISEFILES=1
LANGUAGE=FR
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\compdata\frinf\bla\makefile.inc ===
PRODSWITCH=b
BLADEFILES=1
LANGUAGE=FR
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\compdata\frinf\dat\makefile.inc ===
PRODSWITCH=d
DATACENTERFILES=1 
LANGUAGE=FR
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\compdata\frinf\per\makefile.inc ===
PRODSWITCH=p
PERSONALFILES=1
LANGUAGE=FR
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\compdata\frinf\wks\makefile.inc ===
PRODSWITCH=w
LANGUAGE=FR
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\compdata\frinf\srv\makefile.inc ===
PRODSWITCH=s
SERVERFILES=1
LANGUAGE=FR
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\compdata\gerinf\bla\makefile.inc ===
PRODSWITCH=b
BLADEFILES=1
LANGUAGE=GER
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\compdata\gerinf\dat\makefile.inc ===
PRODSWITCH=d
DATACENTERFILES=1
LANGUAGE=GER
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\compdata\gerinf\srv\makefile.inc ===
PRODSWITCH=s
SERVERFILES=1
LANGUAGE=GER
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\compdata\gerinf\per\makefile.inc ===
PRODSWITCH=p
PERSONALFILES=1
LANGUAGE=GER
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\compdata\gerinf\ent\makefile.inc ===
PRODSWITCH=e
ENTERPRISEFILES=1
LANGUAGE=GER
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\compdata\gerinf\wks\makefile.inc ===
PRODSWITCH=w
LANGUAGE=GER
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\compdata\hebinf\wks\makefile.inc ===
PRODSWITCH=w
LANGUAGE=HEB
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\compdata\hebinf\per\makefile.inc ===
PRODSWITCH=p
PERSONALFILES=1
LANGUAGE=HEB
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\compdata\huinf\bla\makefile.inc ===
PRODSWITCH=b
BLADEFILES =1
LANGUAGE=HU
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\compdata\huinf\dat\makefile.inc ===
PRODSWITCH=d
DATACENTERFILES=1
LANGUAGE=HU
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\compdata\huinf\ent\makefile.inc ===
PRODSWITCH=e
ENTERPRISEFILES=1
LANGUAGE=HU
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\compdata\huinf\per\makefile.inc ===
PRODSWITCH=p
PERSONALFILES=1
LANGUAGE=HU
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\compdata\huinf\wks\makefile.inc ===
PRODSWITCH=w
LANGUAGE=HU
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\compdata\itinf\bla\makefile.inc ===
PRODSWITCH=b
BLADEFILES =1
LANGUAGE=IT
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\compdata\itinf\dat\makefile.inc ===
PRODSWITCH=d
DATACENTERFILES=1
LANGUAGE=IT
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\compdata\huinf\srv\makefile.inc ===
PRODSWITCH=s
SERVERFILES=1
LANGUAGE=HU
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\compdata\itinf\ent\makefile.inc ===
PRODSWITCH=e
ENTERPRISEFILES=1
LANGUAGE=IT
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\compdata\itinf\per\makefile.inc ===
PRODSWITCH=p
PERSONALFILES=1
LANGUAGE=IT
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\compdata\itinf\wks\makefile.inc ===
PRODSWITCH=w
LANGUAGE=IT
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\compdata\itinf\srv\makefile.inc ===
PRODSWITCH=s
SERVERFILES=1
LANGUAGE=IT
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\compdata\jpninf\ent\makefile.inc ===
PRODSWITCH=e
ENTERPRISEFILES=1
LANGUAGE=JPN
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\compdata\jpninf\bla\makefile.inc ===
PRODSWITCH=b
BLADEFILES=1
LANGUAGE=JPN
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\compdata\jpninf\per\makefile.inc ===
PRODSWITCH=p
PERSONALFILES=1
LANGUAGE=JPN
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\compdata\jpninf\dat\makefile.inc ===
PRODSWITCH=d
DATACENTERFILES=1
LANGUAGE=JPN
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\compdata\korinf\srv\makefile.inc ===
PRODSWITCH=s
SERVERFILES=1
LANGUAGE=KOR
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\compdata\korinf\ent\makefile.inc ===
PRODSWITCH=e
ENTERPRISEFILES=1
LANGUAGE=KOR
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\compdata\jpninf\wks\makefile.inc ===
PRODSWITCH=w
LANGUAGE=JPN
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\compdata\jpninf\srv\makefile.inc ===
PRODSWITCH=s
SERVERFILES=1
LANGUAGE=JPN
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\compdata\korinf\per\makefile.inc ===
PRODSWITCH=p
PERSONALFILES=1
LANGUAGE=KOR
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\compdata\korinf\bla\makefile.inc ===
PRODSWITCH=b
BLADEFILES=1
LANGUAGE=KOR
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\compdata\korinf\dat\makefile.inc ===
PRODSWITCH=d
DATACENTERFILES=1
LANGUAGE=KOR
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\compdata\nlinf\ent\makefile.inc ===
PRODSWITCH=e
ENTERPRISEFILES=1
LANGUAGE=NL
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\compdata\nlinf\bla\makefile.inc ===
PRODSWITCH=b
BLADEFILES =1
LANGUAGE=NL
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\compdata\nlinf\dat\makefile.inc ===
PRODSWITCH=d
DATACENTERFILES=1
LANGUAGE=NL
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\compdata\korinf\wks\makefile.inc ===
PRODSWITCH=w
LANGUAGE=KOR
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\compdata\nlinf\per\makefile.inc ===
PRODSWITCH=p
PERSONALFILES=1
LANGUAGE=NL
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\compdata\nlinf\srv\makefile.inc ===
PRODSWITCH=s
SERVERFILES=1
LANGUAGE=NL
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\compdata\noinf\bla\makefile.inc ===
PRODSWITCH=b
BLADEFILES =1 
LANGUAGE=NO
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\compdata\noinf\dat\makefile.inc ===
PRODSWITCH=d
DATACENTERFILES=1
LANGUAGE=NO
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\compdata\noinf\per\makefile.inc ===
PRODSWITCH=p
PERSONALFILES=1
LANGUAGE=NO
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\compdata\noinf\ent\makefile.inc ===
PRODSWITCH=e
ENTERPRISEFILES=1
LANGUAGE=NO
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\compdata\noinf\wks\makefile.inc ===
PRODSWITCH=w
LANGUAGE=NO
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\compdata\nlinf\wks\makefile.inc ===
PRODSWITCH=w
LANGUAGE=NL
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\compdata\noinf\srv\makefile.inc ===
PRODSWITCH=s
SERVERFILES=1
LANGUAGE=NO
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\compdata\plinf\dat\makefile.inc ===
PRODSWITCH=d
DATACENTERFILES=1
LANGUAGE=PL
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\compdata\plinf\bla\makefile.inc ===
PRODSWITCH=b
BLADEFILES =1
LANGUAGE=PL
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\compdata\plinf\ent\makefile.inc ===
PRODSWITCH=e
ENTERPRISEFILES=1
LANGUAGE=PL
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\compdata\plinf\per\makefile.inc ===
PRODSWITCH=p
PERSONALFILES=1
LANGUAGE=PL
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\compdata\plinf\srv\makefile.inc ===
PRODSWITCH=s
SERVERFILES=1
LANGUAGE=PL
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\compdata\plinf\wks\makefile.inc ===
PRODSWITCH=w
LANGUAGE=PL
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\compdata\ptinf\bla\makefile.inc ===
PRODSWITCH=b
BLADEFILES =1
LANGUAGE=PT
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\compdata\ptinf\ent\makefile.inc ===
PRODSWITCH=e
ENTERPRISEFILES=1
LANGUAGE=PT
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\compdata\ptinf\per\makefile.inc ===
PRODSWITCH=p
PERSONALFILES=1
LANGUAGE=PT
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\compdata\ptinf\srv\makefile.inc ===
PRODSWITCH=s
SERVERFILES=1
LANGUAGE=PT
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\compdata\ptinf\dat\makefile.inc ===
PRODSWITCH=d
DATACENTERFILES=1
LANGUAGE=PT
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\compdata\ptinf\wks\makefile.inc ===
PRODSWITCH=w
LANGUAGE=PT
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\compdata\ruinf\per\makefile.inc ===
PRODSWITCH=p
PERSONALFILES=1
LANGUAGE=RU
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\compdata\ruinf\ent\makefile.inc ===
PRODSWITCH=e
ENTERPRISEFILES=1
LANGUAGE=RU
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\compdata\ruinf\dat\makefile.inc ===
PRODSWITCH=d
DATACENTERFILES=1
LANGUAGE=RU
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\compdata\ruinf\srv\makefile.inc ===
PRODSWITCH=s
SERVERFILES=1 
LANGUAGE=RU
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\compdata\ruinf\wks\makefile.inc ===
PRODSWITCH=w
LANGUAGE=RU
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\compdata\ruinf\bla\makefile.inc ===
PRODSWITCH=b
BLADEFILES =1
LANGUAGE=RU
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\compdata\svinf\bla\makefile.inc ===
PRODSWITCH=b
BLADEFILES =1
LANGUAGE=SV
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\compdata\svinf\ent\makefile.inc ===
PRODSWITCH=e
ENTERPRISEFILES=1
LANGUAGE=SV
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\compdata\svinf\srv\makefile.inc ===
PRODSWITCH=s
SERVERFILES=1
LANGUAGE=SV
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\compdata\svinf\per\makefile.inc ===
PRODSWITCH=p
PERSONALFILES=1
LANGUAGE=SV
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\compdata\svinf\dat\makefile.inc ===
PRODSWITCH=d
DATACENTERFILES=1
LANGUAGE=SV
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\compdata\svinf\wks\makefile.inc ===
PRODSWITCH=w
LANGUAGE=SV
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\compdata\trinf\per\makefile.inc ===
PRODSWITCH=p
PERSONALFILES=1
LANGUAGE=TR
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\compdata\trinf\dat\makefile.inc ===
PRODSWITCH=d
DATACENTERFILES=1
LANGUAGE=TR
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\compdata\trinf\srv\makefile.inc ===
PRODSWITCH=s
SERVERFILES=1
LANGUAGE=TR
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\compdata\trinf\ent\makefile.inc ===
PRODSWITCH=e
ENTERPRISEFILES=1
LANGUAGE=TR
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\compdata\trinf\wks\makefile.inc ===
PRODSWITCH=w
LANGUAGE=TR
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\compdata\trinf\bla\makefile.inc ===
PRODSWITCH=b
BLADEFILES =1
LANGUAGE=TR
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\compdata\usainf\bla\makefile.inc ===
PRODSWITCH=b
BLADEFILES=1
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\compdata\usainf\wks\makefile.inc ===
PRODSWITCH=w
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\compdata\usainf\ent\makefile.inc ===
PRODSWITCH=e
ENTERPRISEFILES=1
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\compdata\usainf\per\makefile.inc ===
PRODSWITCH=p
PERSONALFILES=1
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\compdata\usainf\sbs\makefile.inc ===
PRODSWITCH=l
SMALLBUSINESSSERVERFILES=1
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\compdata\usainf\dat\makefile.inc ===
PRODSWITCH=d
DATACENTERFILES=1
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\compdata\usainf\srv\makefile.inc ===
PRODSWITCH=s
SERVERFILES=1
!include ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\daytona\arainf\per\makefile.inc ===
PRODSWITCH=p
PERSONALINF=1
LANGUAGE=ARA
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\daytona\aratest\blade\makefile.inc ===
PRODSWITCH=b
LANGUAGE=ARA
!include ..\..\..\langtest.mak
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\daytona\arainf\wks\makefile.inc ===
PRODSWITCH=w
LANGUAGE=ARA
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\daytona\aratest\dat\makefile.inc ===
PRODSWITCH=d
LANGUAGE=ARA
!include ..\..\..\langtest.mak
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\daytona\aratest\per\makefile.inc ===
PRODSWITCH=p
LANGUAGE=ARA
!include ..\..\..\langtest.mak
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\daytona\aratest\ent\makefile.inc ===
PRODSWITCH=e
LANGUAGE=ARA
!include ..\..\..\langtest.mak
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\daytona\aratest\sbs\makefile.inc ===
PRODSWITCH=l
LANGUAGE=ARA
!include ..\..\..\langtest.mak
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\daytona\aratest\srv\makefile.inc ===
PRODSWITCH=s
LANGUAGE=ARA
!include ..\..\..\langtest.mak
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\daytona\aratest\wks\makefile.inc ===
PRODSWITCH=w
LANGUAGE=ARA
!include ..\..\..\langtest.mak
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\daytona\brinf\dat\makefile.inc ===
PRODSWITCH=d
DATACENTERINF=1
LANGUAGE=br
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\daytona\brinf\blade\makefile.inc ===
PRODSWITCH=b
BLAINF=1
LANGUAGE=BR
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\daytona\brinf\per\makefile.inc ===
PRODSWITCH=p
PERSONALINF=1
LANGUAGE=br
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\daytona\brinf\ent\makefile.inc ===
PRODSWITCH=e
ENTERPRISEINF=1
LANGUAGE=br
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\daytona\brinf\srv\makefile.inc ===
PRODSWITCH=s
SERVERINF=1
LANGUAGE=br
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\daytona\chhinf\dat\makefile.inc ===
PRODSWITCH=d
DATACENTERINF=1
LANGUAGE=CHH
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\daytona\chhinf\ent\makefile.inc ===
PRODSWITCH=e
ENTERPRISEINF=1
LANGUAGE=CHH
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\daytona\brinf\wks\makefile.inc ===
PRODSWITCH=w
LANGUAGE=br
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\daytona\chhinf\sbs\makefile.inc ===
PRODSWITCH=l
SBSINF=1
LANGUAGE=CHH
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\daytona\chhinf\per\makefile.inc ===
PRODSWITCH=p
PERSONALINF=1
LANGUAGE=CHH
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\daytona\chhinf\srv\makefile.inc ===
PRODSWITCH=s
SERVERINF=1
LANGUAGE=CHH
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\daytona\chhinf\wks\makefile.inc ===
PRODSWITCH=w
LANGUAGE=CHH
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\daytona\chhtest\blade\makefile.inc ===
PRODSWITCH=b
LANGUAGE=CHH
!include ..\..\..\langtest.mak
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\daytona\chhtest\dat\makefile.inc ===
PRODSWITCH=d
LANGUAGE=CHH
!include ..\..\..\langtest.mak
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\daytona\chhtest\ent\makefile.inc ===
PRODSWITCH=e
LANGUAGE=CHH
!include ..\..\..\langtest.mak
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\daytona\chhtest\per\makefile.inc ===
PRODSWITCH=p
LANGUAGE=CHH
!include ..\..\..\langtest.mak
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\daytona\chhtest\sbs\makefile.inc ===
PRODSWITCH=l
LANGUAGE=CHH
!include ..\..\..\langtest.mak
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\daytona\chhtest\wks\makefile.inc ===
PRODSWITCH=w
LANGUAGE=CHH
!include ..\..\..\langtest.mak
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\daytona\chsinf\dat\makefile.inc ===
PRODSWITCH=d
DATACENTERINF=1
LANGUAGE=CHS
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\daytona\chsinf\per\makefile.inc ===
PRODSWITCH=p
PERSONALINF=1
LANGUAGE=CHS
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\daytona\chhtest\srv\makefile.inc ===
PRODSWITCH=s
LANGUAGE=CHH
!include ..\..\..\langtest.mak
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\daytona\chsinf\sbs\makefile.inc ===
PRODSWITCH=l
SBSINF=1
LANGUAGE=CHS
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\daytona\chsinf\blade\makefile.inc ===
PRODSWITCH=b
BLAINF=1
LANGUAGE=CHS
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\daytona\chsinf\ent\makefile.inc ===
PRODSWITCH=e
ENTERPRISEINF=1
LANGUAGE=CHS
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\daytona\chsinf\srv\makefile.inc ===
PRODSWITCH=s
SERVERINF=1
LANGUAGE=CHS
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\daytona\chstest\dat\makefile.inc ===
PRODSWITCH=d
LANGUAGE=CHS
!include ..\..\..\langtest.mak
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\daytona\chstest\blade\makefile.inc ===
PRODSWITCH=b
LANGUAGE=CHS
!include ..\..\..\langtest.mak
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\daytona\chstest\per\makefile.inc ===
PRODSWITCH=p
LANGUAGE=CHS
!include ..\..\..\langtest.mak
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\daytona\chsinf\wks\makefile.inc ===
PRODSWITCH=w
LANGUAGE=CHS
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\daytona\chstest\sbs\makefile.inc ===
PRODSWITCH=l
LANGUAGE=CHS
!include ..\..\..\langtest.mak
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\daytona\chstest\srv\makefile.inc ===
PRODSWITCH=s
LANGUAGE=CHS
!include ..\..\..\langtest.mak
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\daytona\chstest\ent\makefile.inc ===
PRODSWITCH=e
LANGUAGE=CHS
!include ..\..\..\langtest.mak
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\daytona\chstest\wks\makefile.inc ===
PRODSWITCH=w
LANGUAGE=CHS
!include ..\..\..\langtest.mak
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\daytona\chtinf\ent\makefile.inc ===
PRODSWITCH=e
ENTERPRISEINF=1
LANGUAGE=CHT
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\daytona\chtinf\blade\makefile.inc ===
PRODSWITCH=b
BLAINF=1
LANGUAGE=CHT
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\daytona\chtinf\per\makefile.inc ===
PRODSWITCH=p
PERSONALINF=1
LANGUAGE=CHT
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\daytona\chtinf\sbs\makefile.inc ===
PRODSWITCH=l
SBSINF=1
LANGUAGE=CHT
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\daytona\chtinf\srv\makefile.inc ===
PRODSWITCH=s
SERVERINF=1
LANGUAGE=CHT
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\daytona\chtinf\dat\makefile.inc ===
PRODSWITCH=d
DATACENTERINF=1
LANGUAGE=CHT
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\daytona\chtinf\wks\makefile.inc ===
PRODSWITCH=w
LANGUAGE=CHT
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\daytona\chttest\blade\makefile.inc ===
PRODSWITCH=b
LANGUAGE=CHT
!include ..\..\..\langtest.mak
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\daytona\chttest\ent\makefile.inc ===
PRODSWITCH=e
LANGUAGE=CHT
!include ..\..\..\langtest.mak
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\daytona\chttest\sbs\makefile.inc ===
PRODSWITCH=l
LANGUAGE=CHT
!include ..\..\..\langtest.mak
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\daytona\chttest\wks\makefile.inc ===
PRODSWITCH=w
LANGUAGE=CHT
!include ..\..\..\langtest.mak
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\daytona\chttest\per\makefile.inc ===
PRODSWITCH=p
LANGUAGE=CHT
!include ..\..\..\langtest.mak
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\daytona\csinf\blade\makefile.inc ===
PRODSWITCH=b
BLAINF=1
LANGUAGE=CS
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\daytona\chttest\srv\makefile.inc ===
PRODSWITCH=s
LANGUAGE=CHT
!include ..\..\..\langtest.mak
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\daytona\chttest\dat\makefile.inc ===
PRODSWITCH=d
LANGUAGE=CHT
!include ..\..\..\langtest.mak
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\daytona\csinf\dat\makefile.inc ===
PRODSWITCH=d
DATACENTERINF=1
LANGUAGE=cs
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\daytona\csinf\per\makefile.inc ===
PRODSWITCH=p
PERSONALINF=1
LANGUAGE=cs
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\daytona\csinf\wks\makefile.inc ===
PRODSWITCH=w
LANGUAGE=cs
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\daytona\dainf\dat\makefile.inc ===
PRODSWITCH=d
DATACENTERINF=1
LANGUAGE=da
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\daytona\csinf\srv\makefile.inc ===
PRODSWITCH=s
SERVERINF=1
LANGUAGE=cs
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\daytona\dainf\per\makefile.inc ===
PRODSWITCH=p
PERSONALINF=1
LANGUAGE=da
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\daytona\csinf\ent\makefile.inc ===
PRODSWITCH=e
ENTERPRISEINF=1
LANGUAGE=cs
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\daytona\dainf\ent\makefile.inc ===
PRODSWITCH=e
ENTERPRISEINF=1
LANGUAGE=da
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\daytona\dainf\srv\makefile.inc ===
PRODSWITCH=s
SERVERINF=1
LANGUAGE=da
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\daytona\dainf\wks\makefile.inc ===
PRODSWITCH=w
LANGUAGE=da
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\daytona\elinf\per\makefile.inc ===
PRODSWITCH=p
PERSONALINF=1
LANGUAGE=el
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\daytona\elinf\dat\makefile.inc ===
PRODSWITCH=d
DATACENTERINF=1
LANGUAGE=el
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\daytona\elinf\ent\makefile.inc ===
PRODSWITCH=e
ENTERPRISEINF=1
LANGUAGE=el
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\daytona\elinf\srv\makefile.inc ===
PRODSWITCH=s
SERVERINF=1
LANGUAGE=el
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\daytona\elinf\wks\makefile.inc ===
PRODSWITCH=w
LANGUAGE=el
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\daytona\esinf\blade\makefile.inc ===
PRODSWITCH=b
BLAINF=1
LANGUAGE=ES
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\daytona\esinf\dat\makefile.inc ===
PRODSWITCH=d
DATACENTERINF=1
LANGUAGE=es
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\daytona\esinf\per\makefile.inc ===
PRODSWITCH=p
PERSONALINF=1
LANGUAGE=es
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\daytona\fiinf\dat\makefile.inc ===
PRODSWITCH=d
DATACENTERINF=1
LANGUAGE=fi
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\daytona\fiinf\ent\makefile.inc ===
PRODSWITCH=e
ENTERPRISEINF=1
LANGUAGE=fi
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\daytona\esinf\wks\makefile.inc ===
PRODSWITCH=w
LANGUAGE=es
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\daytona\fiinf\per\makefile.inc ===
PRODSWITCH=p
PERSONALINF=1
LANGUAGE=fi
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\daytona\esinf\srv\makefile.inc ===
PRODSWITCH=s
SERVERINF=1
LANGUAGE=es
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\daytona\esinf\ent\makefile.inc ===
PRODSWITCH=e
ENTERPRISEINF=1
LANGUAGE=es
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\daytona\fiinf\srv\makefile.inc ===
PRODSWITCH=s
SERVERINF=1
LANGUAGE=fi
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\daytona\fiinf\wks\makefile.inc ===
PRODSWITCH=w
LANGUAGE=fi
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\daytona\frinf\dat\makefile.inc ===
PRODSWITCH=d
DATACENTERINF=1
LANGUAGE=fr
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\daytona\frinf\per\makefile.inc ===
PRODSWITCH=p
PERSONALINF=1
LANGUAGE=fr
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\daytona\frinf\srv\makefile.inc ===
PRODSWITCH=s
SERVERINF=1
LANGUAGE=fr
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\daytona\frinf\wks\makefile.inc ===
PRODSWITCH=w
LANGUAGE=fr
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\daytona\frinf\blade\makefile.inc ===
PRODSWITCH=b
BLAINF=1
LANGUAGE=FR
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\daytona\frinf\ent\makefile.inc ===
PRODSWITCH=e
ENTERPRISEINF=1
LANGUAGE=fr
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\daytona\gerinf\blade\makefile.inc ===
PRODSWITCH=b
BLAINF=1
LANGUAGE=GER
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\daytona\gerinf\dat\makefile.inc ===
PRODSWITCH=d
DATACENTERINF=1
LANGUAGE=GER
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\daytona\gerinf\sbs\makefile.inc ===
PRODSWITCH=l
SBSINF=1
LANGUAGE=GER
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\daytona\gerinf\srv\makefile.inc ===
PRODSWITCH=s
SERVERINF=1
LANGUAGE=GER
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\daytona\gerinf\ent\makefile.inc ===
PRODSWITCH=e
ENTERPRISEINF=1
LANGUAGE=GER
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\daytona\gerinf\per\makefile.inc ===
PRODSWITCH=p
PERSONALINF=1
LANGUAGE=GER
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\daytona\gerinf\wks\makefile.inc ===
PRODSWITCH=w
LANGUAGE=GER
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\daytona\gertest\blade\makefile.inc ===
PRODSWITCH=b
BLAINF=1
LANGUAGE=GER
!include ..\..\..\langtest.mak
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\daytona\gertest\ent\makefile.inc ===
PRODSWITCH=e
ENTERPRISEINF=1
LANGUAGE=GER
!include ..\..\..\langtest.mak
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\daytona\gertest\dat\makefile.inc ===
PRODSWITCH=d
DATACENTERINF=1
LANGUAGE=GER
!include ..\..\..\langtest.mak
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\daytona\gertest\srv\makefile.inc ===
PRODSWITCH=s
SERVERINF=1
LANGUAGE=GER
!include ..\..\..\langtest.mak
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\daytona\gertest\sbs\makefile.inc ===
PRODSWITCH=l
SBSINF=1
LANGUAGE=GER
!include ..\..\..\langtest.mak
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\daytona\gertest\per\makefile.inc ===
PRODSWITCH=p
PERSONALINF=1
LANGUAGE=GER
!include ..\..\..\langtest.mak
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\daytona\hebinf\per\makefile.inc ===
PRODSWITCH=p
PERSONALINF=1
LANGUAGE=HEB
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\daytona\hebinf\wks\makefile.inc ===
PRODSWITCH=w
LANGUAGE=HEB
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\daytona\hebtest\blade\makefile.inc ===
PRODSWITCH=b
LANGUAGE=HEB
!include ..\..\..\langtest.mak
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\daytona\gertest\wks\makefile.inc ===
PRODSWITCH=w
LANGUAGE=GER
!include ..\..\..\langtest.mak
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\daytona\hebtest\ent\makefile.inc ===
PRODSWITCH=e
LANGUAGE=HEB
!include ..\..\..\langtest.mak
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\daytona\hebtest\per\makefile.inc ===
PRODSWITCH=p
LANGUAGE=HEB
!include ..\..\..\langtest.mak
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\daytona\hebtest\dat\makefile.inc ===
PRODSWITCH=d
LANGUAGE=HEB
!include ..\..\..\langtest.mak
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\daytona\hebtest\sbs\makefile.inc ===
PRODSWITCH=l
LANGUAGE=HEB
!include ..\..\..\langtest.mak
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\daytona\hebtest\srv\makefile.inc ===
PRODSWITCH=s
LANGUAGE=HEB
!include ..\..\..\langtest.mak
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\daytona\huinf\blade\makefile.inc ===
PRODSWITCH=b
BLAINF=1
LANGUAGE=HU
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\daytona\hebtest\wks\makefile.inc ===
PRODSWITCH=w
LANGUAGE=HEB
!include ..\..\..\langtest.mak
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\daytona\huinf\per\makefile.inc ===
PRODSWITCH=p
PERSONALINF=1
LANGUAGE=hu
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\daytona\huinf\srv\makefile.inc ===
PRODSWITCH=s
SERVERINF=1
LANGUAGE=hu
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\daytona\huinf\ent\makefile.inc ===
PRODSWITCH=e
ENTERPRISEINF=1
LANGUAGE=hu
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\daytona\huinf\dat\makefile.inc ===
PRODSWITCH=d
DATACENTERINF=1
LANGUAGE=hu
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\daytona\huinf\wks\makefile.inc ===
PRODSWITCH=w
LANGUAGE=hu
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\daytona\itinf\blade\makefile.inc ===
PRODSWITCH=b
BLAINF=1
LANGUAGE=IT
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\daytona\itinf\dat\makefile.inc ===
PRODSWITCH=d
DATACENTERINF=1
LANGUAGE=it
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\daytona\itinf\ent\makefile.inc ===
PRODSWITCH=e
ENTERPRISEINF=1
LANGUAGE=it
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\daytona\itinf\srv\makefile.inc ===
PRODSWITCH=s
SERVERINF=1
LANGUAGE=it
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\daytona\itinf\wks\makefile.inc ===
PRODSWITCH=w
LANGUAGE=it
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\daytona\jpninf\blade\makefile.inc ===
PRODSWITCH=b
BLAINF=1
LANGUAGE=JPN
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\daytona\jpninf\dat\makefile.inc ===
PRODSWITCH=d
DATACENTERINF=1
LANGUAGE=JPN
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\daytona\itinf\per\makefile.inc ===
PRODSWITCH=p
PERSONALINF=1
LANGUAGE=it
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\daytona\jpninf\ent\makefile.inc ===
PRODSWITCH=e
ENTERPRISEINF=1
LANGUAGE=JPN
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\daytona\jpninf\per\makefile.inc ===
PRODSWITCH=p
PERSONALINF=1
LANGUAGE=JPN
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\daytona\jpninf\srv\makefile.inc ===
PRODSWITCH=s
SERVERINF=1
LANGUAGE=JPN
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\daytona\jpninf\sbs\makefile.inc ===
PRODSWITCH=l
SBSINF=1
LANGUAGE=JPN
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\daytona\jpntest\ent\makefile.inc ===
PRODSWITCH=e
ENTERPRISEINF=1
LANGUAGE=JPN
!include ..\..\..\langtest.mak
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\daytona\jpntest\per\makefile.inc ===
PRODSWITCH=p
PERSONALINF=1
LANGUAGE=JPN
!include ..\..\..\langtest.mak
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\daytona\jpntest\sbs\makefile.inc ===
PRODSWITCH=l
SBSINF=1
LANGUAGE=JPN
!include ..\..\..\langtest.mak
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\daytona\jpninf\wks\makefile.inc ===
PRODSWITCH=w
LANGUAGE=JPN
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\daytona\jpntest\blade\makefile.inc ===
PRODSWITCH=b
BLAINF=1
LANGUAGE=JPN
!include ..\..\..\langtest.mak
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\daytona\jpntest\dat\makefile.inc ===
PRODSWITCH=d
DATACENTERINF=1
LANGUAGE=JPN
!include ..\..\..\langtest.mak
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\daytona\jpntest\srv\makefile.inc ===
PRODSWITCH=s
SERVERINF=1
LANGUAGE=JPN
!include ..\..\..\langtest.mak
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\daytona\jpntest\wks\makefile.inc ===
PRODSWITCH=w
LANGUAGE=JPN
!include ..\..\..\langtest.mak
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\daytona\korinf\dat\makefile.inc ===
PRODSWITCH=d
DATACENTERINF=1
LANGUAGE=KOR
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\daytona\korinf\blade\makefile.inc ===
PRODSWITCH=b
BLAINF=1
LANGUAGE=KOR
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\daytona\korinf\ent\makefile.inc ===
PRODSWITCH=e
ENTERPRISEINF=1
LANGUAGE=KOR
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\daytona\korinf\sbs\makefile.inc ===
PRODSWITCH=l
SBSINF=1
LANGUAGE=KOR
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\daytona\korinf\srv\makefile.inc ===
PRODSWITCH=s
SERVERINF=1
LANGUAGE=KOR
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\daytona\korinf\per\makefile.inc ===
PRODSWITCH=p
PERSONALINF=1
LANGUAGE=KOR
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\daytona\kortest\per\makefile.inc ===
PRODSWITCH=p
PERSONALINF=1
LANGUAGE=KOR
!include ..\..\..\langtest.mak
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\daytona\kortest\dat\makefile.inc ===
PRODSWITCH=d
DATACENTERINF=1
LANGUAGE=KOR
!include ..\..\..\langtest.mak
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\daytona\kortest\ent\makefile.inc ===
PRODSWITCH=e
ENTERPRISEINF=1
LANGUAGE=KOR
!include ..\..\..\langtest.mak
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\daytona\korinf\wks\makefile.inc ===
PRODSWITCH=w
LANGUAGE=KOR
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\daytona\kortest\sbs\makefile.inc ===
PRODSWITCH=l
SBSINF=1
LANGUAGE=KOR
!include ..\..\..\langtest.mak
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\daytona\kortest\srv\makefile.inc ===
PRODSWITCH=s
SERVERINF=1
LANGUAGE=KOR
!include ..\..\..\langtest.mak
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\daytona\kortest\blade\makefile.inc ===
PRODSWITCH=b
BLAINF=1
LANGUAGE=KOR
!include ..\..\..\langtest.mak
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\daytona\kortest\wks\makefile.inc ===
PRODSWITCH=w
LANGUAGE=KOR
!include ..\..\..\langtest.mak
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\daytona\necinf\per\makefile.inc ===
PRODSWITCH=p
PERSONALINF=1
LANGUAGE=JPN
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\daytona\necinf\srv\makefile.inc ===
PRODSWITCH=s
SERVERINF=1
LANGUAGE=JPN
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\daytona\necinf\wks\makefile.inc ===
PRODSWITCH=w
LANGUAGE=JPN
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\daytona\nlinf\ent\makefile.inc ===
PRODSWITCH=e
ENTERPRISEINF=1
LANGUAGE=nl
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\daytona\nlinf\dat\makefile.inc ===
PRODSWITCH=d
DATACENTERINF=1
LANGUAGE=nl
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\daytona\nlinf\per\makefile.inc ===
PRODSWITCH=p
PERSONALINF=1
LANGUAGE=nl
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\daytona\nlinf\blade\makefile.inc ===
PRODSWITCH=b
BLAINF=1
LANGUAGE=NL
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\daytona\nlinf\srv\makefile.inc ===
PRODSWITCH=s
SERVERINF=1
LANGUAGE=nl
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\daytona\noinf\dat\makefile.inc ===
PRODSWITCH=d
DATACENTERINF=1
LANGUAGE=no
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\daytona\noinf\srv\makefile.inc ===
PRODSWITCH=s
SERVERINF=1
LANGUAGE=no
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\daytona\nlinf\wks\makefile.inc ===
PRODSWITCH=w
LANGUAGE=nl
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\daytona\noinf\per\makefile.inc ===
PRODSWITCH=p
PERSONALINF=1
LANGUAGE=no
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\daytona\plinf\dat\makefile.inc ===
PRODSWITCH=d
DATACENTERINF=1
LANGUAGE=pl
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\daytona\noinf\ent\makefile.inc ===
PRODSWITCH=e
ENTERPRISEINF=1
LANGUAGE=no
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\daytona\noinf\wks\makefile.inc ===
PRODSWITCH=w
LANGUAGE=no
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\daytona\plinf\blade\makefile.inc ===
PRODSWITCH=b
BLAINF=1
LANGUAGE=PL
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\daytona\plinf\ent\makefile.inc ===
PRODSWITCH=e
ENTERPRISEINF=1
LANGUAGE=pl
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\daytona\plinf\per\makefile.inc ===
PRODSWITCH=p
PERSONALINF=1
LANGUAGE=pl
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\daytona\plinf\srv\makefile.inc ===
PRODSWITCH=s
SERVERINF=1
LANGUAGE=pl
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\daytona\plinf\wks\makefile.inc ===
PRODSWITCH=w
LANGUAGE=pl
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\daytona\psuinf\per\makefile.inc ===
PRODSWITCH=p
PERSONALINF=1
LANGUAGE=psu
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\daytona\psuinf\blade\makefile.inc ===
PRODSWITCH=b
BLAINF=1
LANGUAGE=psu
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\daytona\psuinf\ent\makefile.inc ===
PRODSWITCH=e
ENTERPRISEINF=1
LANGUAGE=psu
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\daytona\psuinf\sbs\makefile.inc ===
PRODSWITCH=l
SBSINF=1
LANGUAGE=psu
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\daytona\psuinf\dat\makefile.inc ===
PRODSWITCH=d
DATACENTERINF=1
LANGUAGE=psu
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\daytona\psuinf\wks\makefile.inc ===
PRODSWITCH=w
LANGUAGE=psu
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\daytona\psuinf\srv\makefile.inc ===
PRODSWITCH=s
SERVERINF=1
LANGUAGE=psu
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\daytona\ptinf\blade\makefile.inc ===
PRODSWITCH=b
BLAINF=1
LANGUAGE=PT
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\daytona\ptinf\dat\makefile.inc ===
PRODSWITCH=d
DATACENTERINF=1
LANGUAGE=pt
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\daytona\ptinf\ent\makefile.inc ===
PRODSWITCH=e
ENTERPRISEINF=1
LANGUAGE=pt
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\daytona\ptinf\per\makefile.inc ===
PRODSWITCH=p
PERSONALINF=1
LANGUAGE=pt
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\daytona\ruinf\blade\makefile.inc ===
PRODSWITCH=b
BLAINF=1
LANGUAGE=RU
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\daytona\ptinf\srv\makefile.inc ===
PRODSWITCH=s
SERVERINF=1
LANGUAGE=pt
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\daytona\ruinf\dat\makefile.inc ===
PRODSWITCH=d
DATACENTERINF=1
LANGUAGE=ru
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\daytona\ptinf\wks\makefile.inc ===
PRODSWITCH=w
LANGUAGE=pt
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\daytona\ruinf\ent\makefile.inc ===
PRODSWITCH=e
ENTERPRISEINF=1
LANGUAGE=ru
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\daytona\ruinf\per\makefile.inc ===
PRODSWITCH=p
PERSONALINF=1
LANGUAGE=ru
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\daytona\ruinf\srv\makefile.inc ===
PRODSWITCH=s
SERVERINF=1
LANGUAGE=ru
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\daytona\ruinf\wks\makefile.inc ===
PRODSWITCH=w
LANGUAGE=ru
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\daytona\skinf\wks\makefile.inc ===
PRODSWITCH=w
LANGUAGE=sk
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\daytona\svinf\blade\makefile.inc ===
PRODSWITCH=b
BLAINF=1
LANGUAGE=SV
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\daytona\slinf\wks\makefile.inc ===
PRODSWITCH=w
LANGUAGE=sl
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\daytona\svinf\ent\makefile.inc ===
PRODSWITCH=e
ENTERPRISEINF=1
LANGUAGE=sv
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\daytona\svinf\per\makefile.inc ===
PRODSWITCH=p
PERSONALINF=1
LANGUAGE=sv
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\daytona\svinf\dat\makefile.inc ===
PRODSWITCH=d
DATACENTERINF=1
LANGUAGE=sv
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\daytona\svinf\wks\makefile.inc ===
PRODSWITCH=w
LANGUAGE=sv
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\daytona\svinf\srv\makefile.inc ===
PRODSWITCH=s
SERVERINF=1
LANGUAGE=sv
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\daytona\trinf\dat\makefile.inc ===
PRODSWITCH=d
DATACENTERINF=1
LANGUAGE=tr
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\daytona\trinf\ent\makefile.inc ===
PRODSWITCH=e
ENTERPRISEINF=1
LANGUAGE=tr
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\daytona\trinf\per\makefile.inc ===
PRODSWITCH=p
PERSONALINF=1
LANGUAGE=tr
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\daytona\trinf\blade\makefile.inc ===
PRODSWITCH=b
BLAINF=1
LANGUAGE=TR
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\daytona\trinf\srv\makefile.inc ===
PRODSWITCH=s
SERVERINF=1
LANGUAGE=tr
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\daytona\trinf\wks\makefile.inc ===
PRODSWITCH=w
LANGUAGE=tr
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\daytona\tstinf\dat\makefile.inc ===
PRODSWITCH=d
DATACENTERINF=1
LANGUAGE=TST
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\daytona\tstinf\ent\makefile.inc ===
PRODSWITCH=e
ENTERPRISEINF=1
LANGUAGE=TST
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\daytona\tstinf\per\makefile.inc ===
PRODSWITCH=p
PERSONALINF=1
LANGUAGE=TST
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\daytona\usainf\blade\makefile.inc ===
PRODSWITCH=b
BLAINF=1
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\daytona\usainf\per\makefile.inc ===
PRODSWITCH=p
PERSONALINF=1
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\daytona\tstinf\wks\makefile.inc ===
PRODSWITCH=w
LANGUAGE=TST
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\daytona\usainf\sbs\makefile.inc ===
PRODSWITCH=l
SBSINF=1
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\daytona\tstinf\srv\makefile.inc ===
PRODSWITCH=s
SERVERINF=1
LANGUAGE=TST
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\daytona\usainf\dat\makefile.inc ===
PRODSWITCH=d
DATACENTERINF=1
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\daytona\usainf\ent\makefile.inc ===
PRODSWITCH=e
ENTERPRISEINF=1
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\daytona\usainf\srv\makefile.inc ===
PRODSWITCH=s
SERVERINF=1
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\daytona\usainf\wks\makefile.inc ===
PRODSWITCH=w
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\winpe\makefile.inc ===
#
#
# Description:
#
#   Builds WinPE infs
#
# Author:
#
#   Vijay Jayaseelan (vijayj@microsoft.com) 20 May 2001
#
# Revision:
#
#

!IFNDEF LANGUAGE
LANGUAGE=usa
!ENDIF

#
# ANSI_CODEPAGE:  ANSI codepage for a given language.
#
# LCID:  Locale ID in hex.
#
# UNITEXT_OPT:  Unitext.exe command line options to specify the ANSI codepage
#   for a given language.  Used for Multibuyte -> Unicode conversion.
#

# Defaults
ANSI_CODEPAGE=1252
LCID=409

!if "$(LANGUAGE)"=="ARA" || "$(LANGUAGE)"=="ara"
# Arabic
ANSI_CODEPAGE=1256
LCID=401

!elseif "$(LANGUAGE)"=="BR" || "$(LANGUAGE)"=="br"
# Portuguese, Brazilian
ANSI_CODEPAGE=1252
LCID=416

!elseif "$(LANGUAGE)"=="CHH" || "$(LANGUAGE)"=="chh"
# Chinese, Traditional (Hong Kong)
ANSI_CODEPAGE=950
LCID=C04

!elseif "$(LANGUAGE)"=="CHS" || "$(LANGUAGE)"=="chs"
# Chinese, Simplified
ANSI_CODEPAGE=936
LCID=804

!elseif "$(LANGUAGE)"=="CHT" || "$(LANGUAGE)"=="cht"
# Chinese, Traditional (Taiwan)
ANSI_CODEPAGE=950
LCID=404

!elseif "$(LANGUAGE)"=="CS" || "$(LANGUAGE)"=="cs"
# Czech
ANSI_CODEPAGE=1250
LCID=405

!elseif "$(LANGUAGE)"=="DA" || "$(LANGUAGE)"=="da"
# Danish
ANSI_CODEPAGE=1252
LCID=406

!elseif "$(LANGUAGE)"=="EL" || "$(LANGUAGE)"=="el"
# Greek
ANSI_CODEPAGE=1253
LCID=408

!elseif "$(LANGUAGE)"=="ES" || "$(LANGUAGE)"=="es"
# Spanish
ANSI_CODEPAGE=1252
LCID=C0A

!elseif "$(LANGUAGE)"=="FI" || "$(LANGUAGE)"=="fi"
# Finish
ANSI_CODEPAGE=1252
LCID=40b

!elseif "$(LANGUAGE)"=="FR" || "$(LANGUAGE)"=="fr"
# French
ANSI_CODEPAGE=1252
LCID=40C

!elseif "$(LANGUAGE)"=="GER" || "$(LANGUAGE)"=="ger"
# German
ANSI_CODEPAGE=1252
LCID=407

!elseif "$(LANGUAGE)"=="HEB" || "$(LANGUAGE)"=="heb"
# Hebrew
ANSI_CODEPAGE=1255
LCID=40D

!elseif "$(LANGUAGE)"=="HU" || "$(LANGUAGE)"=="hu"
# Hungarian
ANSI_CODEPAGE=1250
LCID=40e

!elseif "$(LANGUAGE)"=="IT" || "$(LANGUAGE)"=="it"
# Italian
ANSI_CODEPAGE=1252
LCID=410

!elseif "$(LANGUAGE)"=="JPN" || "$(LANGUAGE)"=="jpn"
# Japanese
ANSI_CODEPAGE=932
LCID=411

!elseif "$(LANGUAGE)"=="KOR" || "$(LANGUAGE)"=="kor"
# Korean
ANSI_CODEPAGE=949
LCID=412

!elseif "$(LANGUAGE)"=="NL" || "$(LANGUAGE)"=="nl"
# Dutch
ANSI_CODEPAGE=1252
LCID=413

!elseif "$(LANGUAGE)"=="NO" || "$(LANGUAGE)"=="no"
# Norwegian
ANSI_CODEPAGE=1252
LCID=414

!elseif "$(LANGUAGE)"=="PL" || "$(LANGUAGE)"=="pl"
# Polish
ANSI_CODEPAGE=1250
LCID=415

!elseif "$(LANGUAGE)"=="PSU" || "$(LANGUAGE)"=="psu"
# Pseudo-loc
ANSI_CODEPAGE=1253
LCID=408

!elseif "$(LANGUAGE)"=="PT" || "$(LANGUAGE)"=="pt"
# Portuguese
ANSI_CODEPAGE=1252
LCID=816

!elseif "$(LANGUAGE)"=="RU" || "$(LANGUAGE)"=="ru"
# Russian
ANSI_CODEPAGE=1251
LCID=419

!elseif "$(LANGUAGE)"=="SV" || "$(LANGUAGE)"=="sv"
# Swedish
ANSI_CODEPAGE=1252
LCID=41D

!elseif "$(LANGUAGE)"=="TR" || "$(LANGUAGE)"=="tr"
# Turkish
ANSI_CODEPAGE=1254
LCID=41F

!endif


#
# unicode conversion options
#

UNITEXT_OPT=-m -$(ANSI_CODEPAGE)

#
# Precompile flags
#
PREFLAGS=/DLANGUAGE_ID=0x0$(LCID) -nologo /EP

!if $(PRERELEASE)
PREFLAGS=/DPRERELEASE $(PREFLAGS)
!endif

_SRC=..
_LNG=$(_SRC)\usa
_INF=$(O)

#
# targets to build
#
make_infs:  \
    $(O)\config.inf         \
    $(O)\extra.inf          \
    $(O)\winpesys.inf       \
    $(O)\winpesft.inf       \
    $(O)\winpedef.inf

  
#
# Can the below be optimized using rules ?
#

$(O)\config.inf: 
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt
    $(CC) $(PREFLAGS) $(_SRC)\$(@B).inx > $(O)\$(@B).inx
    copy $(O)\$(@B).inx+$(O)\$(@B).txt $(O)\$(@B).tmp
    unitext $(UNITEXT_OPT) $(O)\$(@B).tmp $(O)\$(@B).inf

$(O)\extra.inf: 
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt
    $(CC) $(PREFLAGS) $(_SRC)\$(@B).inx > $(O)\$(@B).inx
    copy $(O)\$(@B).inx+$(O)\$(@B).txt $(O)\$(@B).tmp
    unitext $(UNITEXT_OPT) $(O)\$(@B).tmp $(O)\$(@B).inf

$(O)\winpesys.inf: 
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt
    $(CC) $(PREFLAGS) $(_SRC)\$(@B).inx > $(O)\$(@B).inx
    copy $(O)\$(@B).inx+$(O)\$(@B).txt $(O)\$(@B).tmp
    unitext $(UNITEXT_OPT) $(O)\$(@B).tmp $(O)\$(@B).inf

$(O)\winpesft.inf: 
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt
    $(CC) $(PREFLAGS) $(_SRC)\$(@B).inx > $(O)\$(@B).inx
    copy $(O)\$(@B).inx+$(O)\$(@B).txt $(O)\$(@B).tmp
    unitext $(UNITEXT_OPT) $(O)\$(@B).tmp $(O)\$(@B).inf

$(O)\winpedef.inf: 
    $(CC) $(PREFLAGS) $(_LNG)\$(@B).txt > $(O)\$(@B).txt
    $(CC) $(PREFLAGS) $(_SRC)\$(@B).inx > $(O)\$(@B).inx
    copy $(O)\$(@B).inx+$(O)\$(@B).txt $(O)\$(@B).tmp
    unitext $(UNITEXT_OPT) $(O)\$(@B).tmp $(O)\$(@B).inf
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\winpe\sources.inc ===
!IF 0

Copyright (c) 1989  Microsoft Corporation

Module Name:

    sources

Abstract:

    Builds WinPE inf files

Author:

    Vijay Jayaseelan (vijayj@microsoft.com)

!ENDIF

#
# include PRERELEASE define
#
!include ..\..\prerelease.inc

TARGETNAME=inf
TARGETTYPE=NOTARGET
TARGETPATH=obj

#
# No explicit sources because build doesn't understand .inf files.
#
SOURCES=

BINPLACE_PLACEFILE=..\placefil.txt

#
# makefile.def will binplace any file listed in the MISCFILES macro.
#


#
# different files
#
MISCFILES = $(MISCFILES)    \
    $(O)\config.inf         \
    $(O)\extra.inf          \
    $(O)\winpesys.inf       \
    $(O)\winpesft.inf       \
    $(O)\winpedef.inf
    
#
# Use NTTARGETFILE0 macros to cause the infs to get built during
# the compile phase. We do this so that we can disable MP build for
# this directory, using BLOCK and DRAIN.
#
NTTARGETFILE0=make_infs
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\winpe\arainf\makefile.inc ===
LANGUAGE=ARA
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\winpe\brinf\makefile.inc ===
LANGUAGE=BR
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\winpe\chhinf\makefile.inc ===
LANGUAGE=CHH
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\winpe\chsinf\makefile.inc ===
LANGUAGE=CHS
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\winpe\chtinf\makefile.inc ===
LANGUAGE=CHT
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\winpe\csinf\makefile.inc ===
LANGUAGE=CS
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\winpe\elinf\makefile.inc ===
LANGUAGE=EL
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\winpe\fiinf\makefile.inc ===
LANGUAGE=FI
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\winpe\esinf\makefile.inc ===
LANGUAGE=ES
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\winpe\dainf\makefile.inc ===
LANGUAGE=DA
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\winpe\frinf\makefile.inc ===
LANGUAGE=FR
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\winpe\gerinf\makefile.inc ===
LANGUAGE=GER
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\winpe\huinf\makefile.inc ===
LANGUAGE=HU
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\winpe\itinf\makefile.inc ===
LANGUAGE=IT
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\winpe\jpninf\makefile.inc ===
LANGUAGE=JPN
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\winpe\hebinf\makefile.inc ===
LANGUAGE=HEB
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\winpe\korinf\makefile.inc ===
LANGUAGE=KOR
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\winpe\nlinf\makefile.inc ===
LANGUAGE=NL
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\winpe\ptinf\makefile.inc ===
LANGUAGE=PT
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\winpe\plinf\makefile.inc ===
LANGUAGE=PL
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\winpe\noinf\makefile.inc ===
LANGUAGE=NO
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\winpe\ruinf\makefile.inc ===
LANGUAGE=RU
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\winpe\svinf\makefile.inc ===
LANGUAGE=SV
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\winpe\trinf\makefile.inc ===
LANGUAGE=TR
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\setupinfs\winpe\usainf\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\uuid\bthguid.c ===
#include <windows.h>

//
// Instantiate public Bluetooth GUIDS
//
#include <initguid.h>
#include "bthdef.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\wlnotify\makefile.inc ===
!if exist($(TARGET_DIRECTORY).inc)
!include $(TARGET_DIRECTORY).inc
!endif

wlnotify.rc: $(O)\notifyev.rc

$(O)\notifyev.rc: $(O)\notifyev.h $(O)\msg00001.bin

$(O)\notifyev.h $(O)\msg00001.bin: notifyev.mc
    mc -v notifyev.mc -h .\$(O) -r .\$(O)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\wlnotify\wlnotify.h ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name :
	
    wlnotify.h

Abstract:

    Shared wlnotify header.

Revision History:
--*/

#ifndef _WLNOTIFY_
#define _WLNOTIFY_

//
//	Resource string IDs
//
//
#define IDS_TSSESSION_STRING           2001
#define IDS_TSERRORDIALOG_STRING       2002
#define IDS_TSPTEMPLATE_FROM           2003
#define IDS_TSPTEMPLATE_FROM_IN        2004
#define IDS_TSPTEMPLATE_ON_FROM        2005
#define IDS_TSPTEMPLATE_ON_FROM_IN     2006
#define IDS_ON                         2007
#define IDS_DRIVE_INFO_TIP             2008

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\wmistub\makefile.inc ===
PRIVLIB= $(TARGETPATH)\$(TARGET_DIRECTORY)\wmip.lib
$(TARGETPATH)\$(TARGET_DIRECTORY)\wmi.lib : $(PRIVLIB)

$(PRIVLIB) $(PRIVLIB:.lib=.exp): $(O)\wmip.def $(LIBRARY_OBJS)
   -$(LIB_NAME) -out:$(PRIVLIB) @<<
$(LIBRARIAN_FLAGS)
-def:$(O)\wmip.def
$(LIBRARY_OBJS)
<<NOKEEP

$(O)\wmip.def: wmi.def
    $(C_PREPROCESSOR) $** -DPRIVATE= -DWMIDEF > $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\wlnotify\memory.cxx ===
/*++

Copyright (c) 1997-1999 Microsoft Corporation

Module Name:

    memory.cxx

Abstract:

    Common memory utility routines.

Author:

    Gopal Parupudi    <GopalP>

[Notes:]

    optional-notes

Revision History:

    GopalP          1/15/1999         Start.

--*/



#include <rpc.h>


//
// Externs
//

extern HANDLE ghNotifyHeap;



//
// Common allocator.
//

void * __cdecl
operator new(
    IN size_t size
    )
{
    return (HeapAlloc(ghNotifyHeap, 0, size));
}

void __cdecl
operator delete(
    IN void * lpvObj
    )
/*++

Notes:

    a. We depend on the fact that HeapFree() does the right
       thing when lpvObj is NULL.

--*/
{
    HeapFree(ghNotifyHeap, 0, lpvObj);
}



//
// Allocator for MIDL stubs
//

extern "C" void __RPC_FAR * __RPC_API
MIDL_user_allocate(
    IN size_t len
    )
{
    return (new char[len]);
}

extern "C" void __RPC_API
MIDL_user_free(
    IN void __RPC_FAR * ptr
    )
{
    delete ptr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\wlnotify\schedlog.cxx ===
//+----------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       schedlog.c
//
//  Contents:   Task Scheduler StartShell notification
//
//  Classes:    None.
//
//  Functions:
//  			SchedStartShell - queue the work to the WinLogon thread pool.
//  			DoSchedStartShell - notify Sched service that a user logged on.
//
//  History:    07-Mar-01  JBenton   Created
//
//-----------------------------------------------------------------------------
//
//  Note: We don't build/publish a lib here as suggested in wlnotify.cxx.
//  Rather we include the source file here because there is only a single
//  simple function.
//
//  Note: We are using the StartShell event because the Scheduler service
//  expects the user's explorer session to be running.
//

#include <windows.h>
#include <winwlx.h>

#define SCHED_SERVICE_NAME          TEXT("Schedule")

//
// The following LOGON and LOGOFF defines must be kept in sync with
// the definition in %sdxroot%\admin\services\sched\inc\common.hxx
// 
#define SERVICE_CONTROL_USER_LOGON              128
#define SERVICE_CONTROL_USER_LOGOFF             133

DWORD WINAPI SchedStartShell(LPVOID lpvParam);
DWORD WINAPI DoSchedStartShell(LPVOID lpvParam);

DWORD WINAPI
SchedEventLogOff(LPVOID lpvParam)
//
//
// Routine Description:
//
//     Send a logoff notification to the Task Scheduler service
//     via a user defined Service Control.
//
//     Arguments:
//
//        lpvParam - Winlogon notification info (unused as of yet)
//
//     Return Value:
//
//        Extended error status from Service control functions.
//
{
   DWORD                  status     = ERROR_SUCCESS;
   SC_HANDLE              hSC        = NULL;
   SC_HANDLE              hSvc       = NULL;
   BOOL                   bSucceeded = FALSE;
   SERVICE_STATUS         ServiceStatus;

   hSC = OpenSCManager(NULL, NULL, SC_MANAGER_CONNECT);
   if (hSC == NULL)
   {
       return GetLastError();
   }

   hSvc = OpenService(hSC, SCHED_SERVICE_NAME,
                                SERVICE_USER_DEFINED_CONTROL);
   if (hSvc == NULL)
   {
       CloseServiceHandle(hSC);
       return GetLastError();
   }

   bSucceeded = ControlService(hSvc,
                             SERVICE_CONTROL_USER_LOGOFF,
                             &ServiceStatus);
   if( !bSucceeded )
   {
      status = GetLastError();
   }

   CloseServiceHandle(hSvc);
   CloseServiceHandle(hSC);

   return status;
}

DWORD WINAPI
SchedStartShell(LPVOID lpvParam)

{
    DWORD dwSessionId = 0;
    
    //
    // Don't send logon notification to Terminal Server sessions.
    //
    if (ProcessIdToSessionId(GetCurrentProcessId(), &dwSessionId))
    {
        if (dwSessionId == 0)
        {
            // 
            // Queue the work to the thread pool since we may
            // be looping on the notification.
            // 
            if (QueueUserWorkItem(DoSchedStartShell, lpvParam, WT_EXECUTELONGFUNCTION))
                return ERROR_SUCCESS;
        }
        else
            return ERROR_SUCCESS;
    }
    
    return GetLastError();
}

DWORD WINAPI
DoSchedStartShell(LPVOID lpvParam)
//
//
// Routine Description:
//
//     Send a logon notification to the Task Scheduler service
//     via a user defined Service Control.
//
//     Arguments:
//
//        lpvParam - Winlogon notification info (unused as of yet)
//
//     Return Value:
//
//        Extended error status from Service control functions.
//
{
    DWORD status = ERROR_SUCCESS;
    PWLX_NOTIFICATION_INFO pTempInfo = (PWLX_NOTIFICATION_INFO) lpvParam;

    SC_HANDLE hSC = OpenSCManager(NULL, NULL, SC_MANAGER_CONNECT);
    if (hSC == NULL)
    {
        return GetLastError();
    }

    SC_HANDLE hSvc = OpenService(hSC, SCHED_SERVICE_NAME,
                                 SERVICE_USER_DEFINED_CONTROL);
    if (hSvc == NULL)
    {
        CloseServiceHandle(hSC);
        return GetLastError();
    }

    BOOL fSucceeded;
    const int NOTIFY_RETRIES = 20;
    const DWORD NOTIFY_SLEEP = 4000;

    //
    // Use a retry loop to notify the service. This is done
    // because, if the user logs in quickly, the service may not
    // be started when the shell runs this instance.
    //
    for (int i = 1; ; i++)
    {
        SERVICE_STATUS Status;
        fSucceeded = ControlService(hSvc,
                                    SERVICE_CONTROL_USER_LOGON,
                                    &Status);
        if (fSucceeded)
        {
            break;
        }

        if (i >= NOTIFY_RETRIES)
        {
		    status = GetLastError();
            break;
        }

        Sleep(NOTIFY_SLEEP);
    }

    CloseServiceHandle(hSvc);
    CloseServiceHandle(hSC);

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\extinc\dxtdbg.h ===
/*******************************************************************************
* DXTDbg.h *
*----------*
*   Description:
*       This header file contains the custom error codes specific to DX Transforms
*-------------------------------------------------------------------------------
*  Created By: EDC                                      Date: 03/31/98
*  Copyright (C) 1998 Microsoft Corporation
*  All Rights Reserved
*
*-------------------------------------------------------------------------------
*  Revisions:
*
*******************************************************************************/
#ifndef DXTDbg_h
#define DXTDbg_h

#ifndef _INC_CRTDBG
#include <crtdbg.h>
#endif

#define DXTDBG_FUNC_TRACE   1
#define DXTDBG_INFO         2

class CDXTDbgFlags
{
  public:
    DWORD m_F;
    CDXTDbgFlags()
    {
        m_F = 0;
        HKEY hkResult;
        DWORD dwDisposition;
        if( RegCreateKeyEx( HKEY_CLASSES_ROOT, _T("DXTDbgFlags"), 0, NULL, 0,
                            KEY_ALL_ACCESS, NULL, &hkResult, &dwDisposition )
                            == ERROR_SUCCESS )
        {
            if( dwDisposition == REG_CREATED_NEW_KEY )
            {
                RegSetValueEx( hkResult, _T("Flags"), NULL, REG_DWORD, (PBYTE)&m_F, sizeof( m_F ) );
            }
            else
            {
                DWORD BuffSize = sizeof( m_F );
                RegQueryValueEx( hkResult, _T("Flags"), NULL, NULL, (PBYTE)&m_F, &BuffSize );
            }
            RegCloseKey( hkResult );
        }
    }
};

class CDXTDbgScope
{
  public:
    static CDXTDbgFlags m_DebugFlags; 
    PCHAR  m_pFuncName;
    CDXTDbgScope( PCHAR pFuncName )
    {
        m_pFuncName = pFuncName;
        if( m_DebugFlags.m_F & DXTDBG_FUNC_TRACE )
        {
            _RPT1( _CRT_WARN, "\nEntering Function: %s\n", m_pFuncName );
        }
    }
    ~CDXTDbgScope()
    {
        if( m_DebugFlags.m_F & DXTDBG_FUNC_TRACE )
        {
            _RPT1( _CRT_WARN, "Leaving Function: %s\n", m_pFuncName );
        }
    }
};

//=== User macros ==============================================================
#ifdef _DEBUG
#define DXTDBG_FUNC( name ) CDXTDbgScope DXTDbgScope( name ); 
#define DXTDBG_MSG0( reportType, format ) \
    if( DXTDbgScope.m_DebugFlags.m_F & DXTDBG_INFO ) _RPTF0( reportType, format );
#define DXTDBG_MSG1( reportType, format, arg1 ) \
    if( DXTDbgScope.m_DebugFlags.m_F & DXTDBG_INFO ) _RPTF1( reportType, format, arg1 )
#define DXTDBG_MSG2( reportType, format, arg1, arg2 ) \
    if( DXTDbgScope.m_DebugFlags.m_F & DXTDBG_INFO ) _RPTF2( reportType, format, arg1, arg2 )
#define DXTDBG_MSG3( reportType, format, arg1, arg2, arg3 ) \
    if( DXTDbgScope.m_DebugFlags.m_F & DXTDBG_INFO ) _RPTF3( reportType, format, arg1, arg2, arg3 )
#define DXTDBG_MSG4( reportType, format, arg1, arg2, arg3, arg4 ) \
    if( DXTDbgScope.m_DebugFlags.m_F & DXTDBG_INFO ) _RPTF4( reportType, format, arg1, arg2, arg3, arg4 )
#else
#define DXTDBG_FUNC( name )
#define DXTDBG_MSG0( reportType, format )
#define DXTDBG_MSG1( reportType, format, arg1 )
#define DXTDBG_MSG2( reportType, format, arg1, arg2 )
#define DXTDBG_MSG3( reportType, format, arg1, arg2, arg3 )
#define DXTDBG_MSG4( reportType, format, arg1, arg2, arg3, arg4 )
#endif

#endif  //--- This must be the last line in the file
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\mergedcomponents\wlnotify\wlnotify.cxx ===
/*++

Copyright (c) 1997-1999 Microsoft Corporation

Module Name:

    wlnotify.cxx

Abstract:

    Main source file for the common DLL that receives Winlogon
    notifications.

Author:

    Gopal Parupudi    <GopalP>

Notes:

    A. BACKGROUND:

    In Windows 2000, Winlogon allows components to hook into various events
    like Logon, Logoff, Lock, Unlock etc via the new Winlogon notifications.
    Components are required to write a DLL with exports (that process these
    notifications) and add them to the registry under HKLM\Software\Microsoft
    \Windows NT\CurrentVersion\Winlogon\Notify Key.



    B. PERFORMANCE ISSUE:

    As more and more components started hooking into these notifications, the
    number of DLLs that were being loaded increased. These notification DLLs
    also brought in other DLLs that they were implicitly linked to them and
    that were not related to processing of these notifications. This common
    DLL is a way to cut down on the number of DLLs that are loaded into the
    Winlogon process.



    C. HOW TO MERGE YOUR DLL INTO THIS DLL:

    In order to merge your DLL into this common notifcation DLL, you need to
    take the following steps:

        1. Compile and link your notification processing code into a library
           that is propagated to $(BASEDIR)\public\sdk\lib directory. Please
           ensure that there is no excess baggage in this library.

        2. Enlist in \nt\private\dllmerge\wlnotify directory.

        3. Modify the sources file to link your library into the DLL.

        4. Add your exports to the .def file for this common DLL. Please
           ensure that the names of exports reflect the component that is
           processing the notification.

        5. Add your exports to the Winlogon notification registry key, if
           you haven't done so already. Modify the DLL name in this registry
           key to point to the common DLL.

        6. Remove your standalone notification DLL from the system.

        7. Make sure you boot test your changes before checking them in.



Revision History:

    GopalP          1/15/1999         Start.

--*/


//
// Includes
//

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>


//
// Globals
//
HANDLE      ghNotifyHeap;

#ifdef __cplusplus
extern "C" {
#endif
BOOL TSDLLInit(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved);
#ifdef __cplusplus
}
#endif
#define IsTerminalServer() (BOOLEAN)(USER_SHARED_DATA->SuiteMask & (1 << TerminalServer))


//
// Functions
//


extern "C" int APIENTRY
DllMain(
    IN HINSTANCE hInstance,
    IN DWORD dwReason,
    IN LPVOID lpvReserved
    )
/*++

Routine Description:

    This routine will get called either when a process attaches to this dll
    or when a process detaches from this dll.

Arguments:

    Standard DllMain signature.

Return Value:

    TRUE - Initialization successfully occurred.

    FALSE - Insufficient memory is available for the process to attach to
        this dll.

--*/
{
    BOOL bSuccess;

    switch (dwReason)
        {
        case DLL_PROCESS_ATTACH:
            //
            // Disable Thread attach/detach calls
            //
            bSuccess = DisableThreadLibraryCalls(hInstance);
            ASSERT(bSuccess == TRUE);

            // Use Default Process heap
            ghNotifyHeap = GetProcessHeap();
            ASSERT(ghNotifyHeap != NULL);
            break;

        case DLL_PROCESS_DETACH:
            break;

        }

    if (IsTerminalServer()) {
        TSDLLInit(hInstance, dwReason, lpvReserved);
    }

    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\extinc\dxterror.h ===
/*******************************************************************************
* DXTError.h *
*------------*
*   Description:
*       This header file contains the custom error codes specific to DX Transforms
*-------------------------------------------------------------------------------
*  Created By: EDC                                      Date: 03/31/98
*  Copyright (C) 1998 Microsoft Corporation
*  All Rights Reserved
*
*-------------------------------------------------------------------------------
*  Revisions:
*
*******************************************************************************/
#ifndef DXTError_h
#define DXTError_h

#ifndef _WINERROR_
#include <winerror.h>
#endif

//=== New codes ===============================================================
#define FACILITY_DXTRANS    0x87A

/*** DXTERR_UNINITIALIZED
*   The object (transform, surface, etc.) has not been properly initialized
*/
#define DXTERR_UNINITIALIZED        MAKE_HRESULT(SEVERITY_ERROR, FACILITY_DXTRANS, 1)

/*** DXTERR_ALREADY_INITIALIZED
*   The object (surface) has already been properly initialized
*/
#define DXTERR_ALREADY_INITIALIZED  MAKE_HRESULT(SEVERITY_ERROR, FACILITY_DXTRANS, 2)

/*** DXTERR_UNSUPPORTED_FORMAT
*   The caller has specified an unsupported format
*/
#define DXTERR_UNSUPPORTED_FORMAT   MAKE_HRESULT(SEVERITY_ERROR, FACILITY_DXTRANS, 3)

/*** DXTERR_COPYRIGHT_IS_INVALID
*   The caller has specified an unsupported format
*/
#define DXTERR_COPYRIGHT_IS_INVALID   MAKE_HRESULT(SEVERITY_ERROR, FACILITY_DXTRANS, 4)

/*** DXTERR_INVALID_BOUNDS
*   The caller has specified invalid bounds for this operation
*/
#define DXTERR_INVALID_BOUNDS   MAKE_HRESULT(SEVERITY_ERROR, FACILITY_DXTRANS, 5)

/*** DXTERR_INVALID_FLAGS
*   The caller has specified invalid flags for this operation
*/
#define DXTERR_INVALID_FLAGS   MAKE_HRESULT(SEVERITY_ERROR, FACILITY_DXTRANS, 6)

/*** DXTERR_OUTOFSTACK
*   There was not enough available stack space to complete the operation 
*/
#define DXTERR_OUTOFSTACK   MAKE_HRESULT(SEVERITY_ERROR, FACILITY_DXTRANS, 7)

/*** DXTERR_REQ_IE_DLLNOTFOUND
*   Unable to load a required Internet Explorer DLL  
*/
#define DXTERR_REQ_IE_DLLNOTFOUND   MAKE_HRESULT(SEVERITY_ERROR, FACILITY_DXTRANS, 8)

/*** DXT_S_HITOUTPUT
*   The specified point intersects the generated output
*/
#define DXT_S_HITOUTPUT   MAKE_HRESULT(SEVERITY_SUCCESS, FACILITY_DXTRANS, 1)

#endif  //--- This must be the last line in the file
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\common.inc ===
!ifndef ROOT
!error ROOT must be defined in makefile
!endif

# -------------------------------------------------------------
# MISC DEFAULTS
# -------------------------------------------------------------

#this enables build.exe to default BUILD_ALT_DIR
CHECKED_ALT_DIR=1

#TODO: examine define of USE_PRINT
C_DEFINES=$(C_DEFINES) /DNT_BUILD

# If we're building retail for NT, use MSVCRT runtime.  Else, use LIBCMT. Also, turn on
# incremental linking if we're not building for NT and in debug more, specify the
# debug CRT's.
!if ("$(BUILD_PRODUCT)" == "NT") && $(FREEBUILD)
USE_MSVCRT=1
!else
NO_NTDLL=1
USE_LIBCMT=1
!endif

!if !$(FREEBUILD)
DEBUG_CRTS=1
!if ("$(BUILD_PRODUCT)" != "NT")
USE_INCREMENTAL_LINKING=1
!endif
!endif

# this dissables optimization on Alpha
ALPHA_OPTIMIZATION=-Od

# due to dsound bug, only define on non NT5 (BUILD_PRODUCT==NT only set on nt5!)
!if "$(BUILD_PRODUCT)" == "NT"
DIRECTSOUND_VERSION=0x0700
!else
DIRECTSOUND_VERSION=0x0300
!endif

WIN32_WINNT_VERSION=0x0400
WIN32_WIN95_VERSION=0x0400
WIN32_IE_VERSION=0x0400
UMTYPE=windows
NOT_LEAN_AND_MEAN=1
SUBSYSTEM_VERSION=4.00
MSC_WARNING_LEVEL=/W3 /WX

# this will set up /Gr /Gx flag unless we've explicitly disabled it.
!if "$(DO_NOT_USE_EH)" != "1"
USE_NATIVE_EH=1
!endif

# MACHINE SPECIFIC MACROS

!if $(386)
_MACHINE=x86
EAT_ERRORS=2>nul:
EAT_OUTPUT=1>nul:
!elseif $(ALPHA)
_MACHINE=alpha
EAT_ERRORS=
EAT_OUTPUT=
!elseif $(AXP64)
_MACHINE=axp64
EAT_ERRORS=
EAT_OUTPUT=
!elseif $(IA64)
_MACHINE=ia64
EAT_ERRORS=
EAT_OUTPUT=
!endif

MKDIR = MKDIR $(EAT_ERRORS)

# -------------------------------------------------------------
# DIRECTORIES
# -------------------------------------------------------------

!if $(FREEBUILD)
_BLDROOT=$(ROOT)\build\ship
!else
_BLDROOT=$(ROOT)\build\debug
!endif

BLDROOT=$(_BLDROOT)
TOOLSROOT=$(ROOT)\tools
ELEVATEDIR=$(ROOT)\build\elevated
SRCROOT=$(ROOT)\src
TOOLSDIR=$(TOOLSROOT)\$(_MACHINE)
VCDIR=$(TOOLSDIR)\msvc50\vc
ATLDIR=$(SDK_INC_PATH)\atl21
AMOVIEDIR=$(SDK_PATH)\amovie\inc
ATLINCLUDE=$(ATLDIR)
SDKDIR=$(ROOT)\lib\$(O)
SDKDIR_DEST=$(ROOT)\lib\$(_OBJ_DIR)
#QUARTZDIR=$(TOOLSDIR)\quartz
SWEEPERDIR=$(VCDIR)
TOOLSLIBMSVC=$(VCDIR)\lib
TOOLSLIBWIN32=$(TOOLSLIBMSVC)
#TOOLSLIBQUARTZ=$(QUARTZDIR)\lib
TOOLSLIBSWEEPER=$(SWEEPERDIR)\lib
!if $(FREEBUILD)
TOOLSLIBQV=$(TOOLSDIR)\QVLib\lib\WinRel
!else
TOOLSLIBQV=$(TOOLSDIR)\QVLib\lib\WinDebug
!endif
TOOLSLIBMISC=$(TOOLSDIR)\misc\lib
TOOLSLIBTRIDENT=$(TOOLSDIR)\trident\lib

PARSER=$(ROOT)\src\prims\parse.pl
CPRIMS=$(SDKDIR)\cprims.h

# -------------------------------------------------------------
# INCLUDE PATH
# -------------------------------------------------------------

TOOLSUTILS=$(TOOLSDIR)\utils
TOOLSINCLUDE=

#    $(TOOLSDIR)\directx\inc;\
#    $(VCDIR)\include;\
#    $(TOOLSDIR)\aactive\inc;\
#    $(TOOLSDIR)\masm\include;\
#    $(TOOLSDIR)\qvlib\include;\
#    $(TOOLSDIR)\RL\inc;\
#    $(TOOLSDIR)\misc\include;\
#    $(TOOLSDIR)\quartz\include;\
#    $(TOOLSDIR)\trident\include

# -------------------------------------------------------------
# TOOL
# -------------------------------------------------------------
SED = sed
PERL= perl

# -------------------------------------------------------------
# GLOBAL INCLUDES
# -------------------------------------------------------------

APPEL_INC_DIRS= \
    $(ROOT)\extinc; \
    $(SRCROOT)\appel\include; \
    $(ATLINCLUDE); \
    $(SRCROOT)\appel; \
    $(SRCROOT)\include; \
    $(SDKDIR); \
    $(SRCROOT)\apeldbg; \
    $(AMOVIEDIR)

LM_INC_DIRS= \
    $(SRCROOT)\lm\include; \
    $(ATLINCLUDE); \
    $(SRCROOT)\lm; \
    $(SRCROOT)\include; \
    $(SRCROOT)\filters\lmrtrend; \
    $(SDKDIR); \
    $(AMOVIEDIR)

FILTER_INC_DIRS= \
    $(ATLINCLUDE); \
    $(SRCROOT)\include; \
    $(SRCROOT)\apeldbg; \
    $(SDKDIR); \

DALITE_INC_DIRS= \
    $(SRCROOT); \
    $(SRCROOT)\dalite\include; \
    $(ATLINCLUDE); \
    $(SRCROOT)\dalite; \
    $(SRCROOT)\include; \
    $(SDKDIR); \

DATIME_INC_DIRS= \
    $(SRCROOT); \
    $(SRCROOT)\time\include; \
    $(ATLINCLUDE); \
    $(SRCROOT)\time; \
    $(SRCROOT)\include; \
    $(SRCROOT)\time\idl\obj$(BUILD_ALT_DIR)\$(TARGET_DIRECTORY); \
    $(SDKDIR); \

!ifdef PROJNAME
PROJROOT=$(SRCROOT)\$(PROJNAME)
INCLUDES= \
    $(SRCROOT); \
    $(PROJROOT)\include; \
    $(ATLINCLUDE); \
    $(PROJROOT); \
    $(SRCROOT)\include; \
    $(SDKDIR); \
!endif

# -------------------------------------------------------------
# MACHINE SPECIFIC
# -------------------------------------------------------------

386_STDCALL=0   #default to cdecl calling convention

# -------------------------------------------------------------
# COMPILER FLAGS
# -------------------------------------------------------------

# This turns on ieee compatible floating point for Alpha only
!if "$(PROCESSOR_ARCHITECTURE)" == "ALPHA"
USER_C_FLAGS=$(USER_C_FLAGS) /QAieee1
!endif

# for cod files....

!if "$(COD)" == "1"
USER_C_FLAGS=$(USER_C_FLAGS) /FAcs /Fa$(O)\$(@B).cod
!endif

# -------------------------------------------------------------
# DEFINES
# -------------------------------------------------------------

C_DEFINES = $(C_DEFINES) /DDA_MAJOR_VERSION=1 /DDA_MINOR_VERSION=0
C_DEFINES = $(C_DEFINES) /DDIRECTSOUND_VERSION=$(DIRECTSOUND_VERSION)

!if !$(FREEBUILD)
C_DEFINES= /D_DEBUG /DDEBUG /D_DEBUGMEM=1 /D_USE_PRINT=1 $(C_DEFINES)
DEVELOPER_BUILD=1
!else
C_DEFINES = $(C_DEFINES) /D_NO_CRT=1
!endif

!if "$(DEVELOPER_BUILD)" == "1"
C_DEFINES = $(C_DEFINES) /D_MEMORY_TRACKING=1 /DDEVELOPER_DEBUG=1
PERF_BUILD=1
# Turn on RTTI (/GR)  for everything but retail builds
USE_RTTI=1
!endif

!if "$(PERF_BUILD)" == "1"
C_DEFINES = $(C_DEFINES) /DPERFORMANCE_REPORTING
!endif

C_DEFINES=$(C_DEFINES) /DNOMINMAX /DSTRICT /DDIRECTDRAW_VERSION=0x0300

!if "$(_PROFILE)" == "1"
C_DEFINES=$(C_DEFINES) /DPRODUCT_PROF
ICECAPLIB=$(TOOLSLIBICAP)\icap.lib
!endif

!if "$(_TIMING)" == "1"
C_DEFINES =$(C_DEFINES) /DTIMING
!endif

C_DEFINES =$(C_DEFINES) /D_ATL_STATIC_REGISTRY

# -------------------------------------------------------------
# OTHER
# -------------------------------------------------------------

CONDITIONAL_INCLUDES= \
    algorithm \
        deque \
        functional \
        iterator \
        list \
        map \
        numeric \
        queue \
        set \
        stack \
        utility \
        vector \
        winwlm.h \
        macwin32.h \
        macocidl.h \
        subwtype.h \
        d3dvec.inl \
        d3dcom.h \
        strings.h \
        iostream \
        libc.h \
        rpcerr.h \
        rpcmac.h \
        macname1.h \
        macpube.h \
        macapi.h \
        macname2.h \
        streams.h \
        xstddef \
        string \
        stdafx.h \
        stdole32.tlb
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\extinc\dxtguid.c ===
//
//  This .CPP file should be included once in your project.  It defines all GUIDs
//  used by DXTransforms as well as the Pixel formats for DX Surfaces
//

#define DX_DECLARE_GUID(name, l, w1, w2, b1, b2, b3, b4, b5, b6, b7, b8) \
        EXTERN_C const GUID name \
                = { l, w1, w2, { b1, b2,  b3,  b4,  b5,  b6,  b7,  b8 } }
//
//  Pixel format definitions
//
// {e436eb78-524f-11ce-9f53-0020af0ba770}
DX_DECLARE_GUID(DDPF_RGB1, 
0xe436eb78, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70);
// {BBF7D3F3-143F-11d1-B50A-0000F8756A10}
DX_DECLARE_GUID(DDPF_RGB2, 
0xbbf7d3f3, 0x143f, 0x11d1, 0xb5, 0xa, 0x0, 0x0, 0xf8, 0x75, 0x6a, 0x10);
// {e436eb79-524f-11ce-9f53-0020af0ba770}
DX_DECLARE_GUID(DDPF_RGB4, 
0xe436eb79, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70);
// {e436eb7a-524f-11ce-9f53-0020af0ba770}
DX_DECLARE_GUID(DDPF_RGB8, 
0xe436eb7a, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70);
// {BBF7D3F6-143F-11d1-B50A-0000F8756A10}
DX_DECLARE_GUID(DDPF_RGB332, 
0xbbf7d3f6, 0x143f, 0x11d1, 0xb5, 0xa, 0x0, 0x0, 0xf8, 0x75, 0x6a, 0x10);
// {BBF7D3F7-143F-11d1-B50A-0000F8756A10}
DX_DECLARE_GUID(DDPF_ARGB4444, 
0xbbf7d3f7, 0x143f, 0x11d1, 0xb5, 0xa, 0x0, 0x0, 0xf8, 0x75, 0x6a, 0x10);
// {e436eb7b-524f-11ce-9f53-0020af0ba770}
DX_DECLARE_GUID(DDPF_RGB565, 
0xe436eb7b, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70);
// {BBF7D3F9-143F-11d1-B50A-0000F8756A10}
DX_DECLARE_GUID(DDPF_BGR565, 
0xbbf7d3f9, 0x143f, 0x11d1, 0xb5, 0xa, 0x0, 0x0, 0xf8, 0x75, 0x6a, 0x10);
// {e436eb7c-524f-11ce-9f53-0020af0ba770}
DX_DECLARE_GUID(DDPF_RGB555, 
0xe436eb7c, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70);
// {BBF7D3FB-143F-11d1-B50A-0000F8756A10}
DX_DECLARE_GUID(DDPF_ARGB1555, 
0xbbf7d3fb, 0x143f, 0x11d1, 0xb5, 0xa, 0x0, 0x0, 0xf8, 0x75, 0x6a, 0x10);
// {e436eb7d-524f-11ce-9f53-0020af0ba770}
DX_DECLARE_GUID(DDPF_RGB24, 
0xe436eb7d, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70);
// {BBF7D3FD-143F-11d1-B50A-0000F8756A10}
DX_DECLARE_GUID(DDPF_BGR24, 
0xbbf7d3fd, 0x143f, 0x11d1, 0xb5, 0xa, 0x0, 0x0, 0xf8, 0x75, 0x6a, 0x10);
// {e436eb7e-524f-11ce-9f53-0020af0ba770}
DX_DECLARE_GUID(DDPF_RGB32, 
0xe436eb7e, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70);
// {BBF7D3FF-143F-11d1-B50A-0000F8756A10}
DX_DECLARE_GUID(DDPF_BGR32, 
0xbbf7d3ff, 0x143f, 0x11d1, 0xb5, 0xa, 0x0, 0x0, 0xf8, 0x75, 0x6a, 0x10);
// {BBF7D401-143F-11d1-B50A-0000F8756A10}
DX_DECLARE_GUID(DDPF_ABGR32, 
0xbbf7d401, 0x143f, 0x11d1, 0xb5, 0xa, 0x0, 0x0, 0xf8, 0x75, 0x6a, 0x10);
// Note: this GUID is used/shared in uuids.h's MEDIASUBTYPE_ARGB32
// {773c9ac0-3274-11d0-B724-00aa006c1A01}
DX_DECLARE_GUID(DDPF_ARGB32, 
0x773c9ac0, 0x3274, 0x11d0, 0xb7, 0x24, 0x0, 0xaa, 0x0, 0x6c, 0x1a, 0x1 );
// {BBF7D403-143F-11d1-B50A-0000F8756A10}
DX_DECLARE_GUID(DDPF_PMARGB32, 
0xbbf7d403, 0x143f, 0x11d1, 0xb5, 0xa, 0x0, 0x0, 0xf8, 0x75, 0x6a, 0x10);
// {7846F94E-3915-11d1-99AA-0000F8756A10}
DX_DECLARE_GUID(DDPF_A1, 
0x7846f94e, 0x3915, 0x11d1, 0x99, 0xaa, 0x0, 0x0, 0xf8, 0x75, 0x6a, 0x10);
// {7846F94F-3915-11d1-99AA-0000F8756A10}
DX_DECLARE_GUID(DDPF_A2, 
0x7846f94f, 0x3915, 0x11d1, 0x99, 0xaa, 0x0, 0x0, 0xf8, 0x75, 0x6a, 0x10);
// {7846F950-3915-11d1-99AA-0000F8756A10}
DX_DECLARE_GUID(DDPF_A4, 
0x7846f950, 0x3915, 0x11d1, 0x99, 0xaa, 0x0, 0x0, 0xf8, 0x75, 0x6a, 0x10);
// {7846F951-3915-11d1-99AA-0000F8756A10}
DX_DECLARE_GUID(DDPF_A8, 
0x7846f951, 0x3915, 0x11d1, 0x99, 0xaa, 0x0, 0x0, 0xf8, 0x75, 0x6a, 0x10);
// {7846F952-3915-11d1-99AA-0000F8756A10}
DX_DECLARE_GUID(DDPF_Z8, 
0x7846f952, 0x3915, 0x11d1, 0x99, 0xaa, 0x0, 0x0, 0xf8, 0x75, 0x6a, 0x10);
// {7846F953-3915-11d1-99AA-0000F8756A10}
DX_DECLARE_GUID(DDPF_Z16, 
0x7846f953, 0x3915, 0x11d1, 0x99, 0xaa, 0x0, 0x0, 0xf8, 0x75, 0x6a, 0x10);
// {7846F954-3915-11d1-99AA-0000F8756A10}
DX_DECLARE_GUID(DDPF_Z24, 
0x7846f954, 0x3915, 0x11d1, 0x99, 0xaa, 0x0, 0x0, 0xf8, 0x75, 0x6a, 0x10);
// {7846F955-3915-11d1-99AA-0000F8756A10}
DX_DECLARE_GUID(DDPF_Z32, 
0x7846f955, 0x3915, 0x11d1, 0x99, 0xaa, 0x0, 0x0, 0xf8, 0x75, 0x6a, 0x10);
//
//  Component categories
//
// {C501EDBE-9E70-11d1-9053-00C04FD9189D}
DX_DECLARE_GUID(CATID_DXImageTransform, 
0xc501edbe, 0x9e70, 0x11d1, 0x90, 0x53, 0x0, 0xc0, 0x4f, 0xd9, 0x18, 0x9d);

// {C501EDBF-9E70-11d1-9053-00C04FD9189D}
DX_DECLARE_GUID(CATID_DX3DTransform, 
0xc501edbf, 0x9e70, 0x11d1, 0x90, 0x53, 0x0, 0xc0, 0x4f, 0xd9, 0x18, 0x9d);

// {ACAC94FC-E5CF-11d1-9066-00C04FD9189D}
DX_DECLARE_GUID(CATID_DXAuthoringTransform,
0xacac94fc, 0xe5cf, 0x11d1, 0x90, 0x66, 0x0, 0xc0, 0x4f, 0xd9, 0x18, 0x9d);

// {52BA7097-B52C-11d1-81CB-0000F87557DB}
DX_DECLARE_GUID(CATID_DXSurface, 
0x52ba7097, 0xb52c, 0x11d1, 0x81, 0xcb, 0x0, 0x0, 0xf8, 0x75, 0x57, 0xdb);

//
//  Service IDs.  
//
//  NOTE:  The service ID for direct draw is == IID_IDirectDraw3 for compatibility
//         with trident service ID's.  This should be the service ID for DirectDraw
//         no matter what version.
//
//  BUGBUG -- Should we use this service provider ID for direct draw?
//
DX_DECLARE_GUID(SID_SDirectDraw,
0x618f8ad4, 0x8b7a, 0x11d0, 0x8f, 0xcc, 0x0, 0xc0, 0x4f, 0xd9, 0x18, 0x9d);
//
//  The service ID for Direct 3D Retain Mode is the same as IID_IDirect3DRM
//  
DX_DECLARE_GUID(SID_SDirect3DRM,
0x2bc49361, 0x8327, 0x11cf, 0xac, 0x4a, 0x0, 0x0, 0xc0, 0x38, 0x25, 0xa1);

//
//  The service ID for DirectDraw3 is the same as IID_IDirectDraw3
//  
DX_DECLARE_GUID(SID_SDirectDraw3,
0x618f8ad4, 0x8b7a, 0x11d0, 0x8f, 0xcc, 0x0, 0xc0, 0x4f, 0xd9, 0x18, 0x9d);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\extinc\dxtmpl.h ===
/*****************************************************************************
* DXTmpl.h *
*-----------*
*       This is the header file contains the DX collection class templates. It
*   has been derived from the MFC collection templates for compatibility.
*-----------------------------------------------------------------------------
*   Created by: Ed Connell                     Date: 05/17/95
*
*****************************************************************************/
#ifndef DXTmpl_h
#define DXTmpl_h

#ifndef _INC_LIMITS
#include <limits.h>
#endif

#ifndef _INC_STRING
#include <string.h>
#endif

#ifndef _INC_STDLIB
#include <stdlib.h>
#endif

#ifndef _INC_SEARCH
#include <search.h>
#endif

#define DXASSERT_VALID( pObj )

/////////////////////////////////////////////////////////////////////////////
typedef void* DXLISTPOS;
typedef DWORD DXLISTHANDLE;

#define DX_BEFORE_START_POSITION ((void*)-1L)

inline BOOL DXIsValidAddress(const void* lp, UINT nBytes, BOOL bReadWrite)
{
    // simple version using Win-32 APIs for pointer validation.
    return (lp != NULL && !IsBadReadPtr(lp, nBytes) &&
        (!bReadWrite || !IsBadWritePtr((LPVOID)lp, nBytes)));
}

/////////////////////////////////////////////////////////////////////////////
// global helpers (can be overridden)
template<class TYPE>
inline void DXConstructElements(TYPE* pElements, int nCount)
{
    _ASSERT( nCount == 0 ||
             DXIsValidAddress( pElements, nCount * sizeof(TYPE), TRUE ) );

    // default is bit-wise zero initialization
    memset((void*)pElements, 0, nCount * sizeof(TYPE));
}

template<class TYPE>
inline void DXDestructElements(TYPE* pElements, int nCount)
{
    _ASSERT( ( nCount == 0 ||
               DXIsValidAddress( pElements, nCount * sizeof(TYPE), TRUE  ) ) );
    pElements;  // not used
    nCount; // not used

    // default does nothing
}

template<class TYPE>
inline void DXCopyElements(TYPE* pDest, const TYPE* pSrc, int nCount)
{
    _ASSERT( ( nCount == 0 ||
               DXIsValidAddress( pDest, nCount * sizeof(TYPE), TRUE  )) );
    _ASSERT( ( nCount == 0 ||
               DXIsValidAddress( pSrc, nCount * sizeof(TYPE), FALSE  )) );

    // default is bit-wise copy
    memcpy(pDest, pSrc, nCount * sizeof(TYPE));
}

template<class TYPE, class ARG_TYPE>
BOOL DXCompareElements(const TYPE* pElement1, const ARG_TYPE* pElement2)
{
    _ASSERT( DXIsValidAddress( pElement1, sizeof(TYPE), FALSE ) );
    _ASSERT( DXIsValidAddress( pElement2, sizeof(ARG_TYPE), FALSE ) );
    return *pElement1 == *pElement2;
}

template<class ARG_KEY>
inline UINT DXHashKey(ARG_KEY key)
{
    // default identity hash - works for most primitive values
    return ((UINT)(void*)(DWORD)key) >> 4;
}

/////////////////////////////////////////////////////////////////////////////
// CDXPlex

struct CDXPlex    // warning variable length structure
{
    CDXPlex* pNext;
    UINT nMax;
    UINT nCur;
    /* BYTE data[maxNum*elementSize]; */
    void* data() { return this+1; }

    static CDXPlex* PASCAL Create( CDXPlex*& pHead, UINT nMax, UINT cbElement )
    {
        CDXPlex* p = (CDXPlex*) new BYTE[sizeof(CDXPlex) + nMax * cbElement];
        p->nMax = nMax;
        p->nCur = 0;
        p->pNext = pHead;
        pHead = p;  // change head (adds in reverse order for simplicity)
        return p;
    }

    void FreeDataChain()
    {
        CDXPlex* p = this;
        while (p != NULL)
        {
            BYTE* bytes = (BYTE*) p;
            CDXPlex* pNext = p->pNext;
            delete bytes;
            p = pNext;
        }
    }
};


/////////////////////////////////////////////////////////////////////////////
// CDXArray<TYPE, ARG_TYPE>

template<class TYPE, class ARG_TYPE>
class CDXArray
{
public:
// Construction
    CDXArray();

// Attributes
    int GetSize() const;
    int GetUpperBound() const;
    void SetSize(int nNewSize, int nGrowBy = -1);

// Operations
    // Clean up
    void FreeExtra();
    void RemoveAll();

    // Accessing elements
    TYPE GetAt(int nIndex) const;
    void SetAt(int nIndex, ARG_TYPE newElement);
    TYPE& ElementAt(int nIndex);

    // Direct Access to the element data (may return NULL)
    const TYPE* GetData() const;
    TYPE* GetData();

    // Potentially growing the array
    void SetAtGrow(int nIndex, ARG_TYPE newElement);
    int Add(ARG_TYPE newElement);
    int Append(const CDXArray& src);
    void Copy(const CDXArray& src);

    // overloaded operator helpers
    TYPE operator[](int nIndex) const;
    TYPE& operator[](int nIndex);

    // Operations that move elements around
    void InsertAt(int nIndex, ARG_TYPE newElement, int nCount = 1);
    void RemoveAt(int nIndex, int nCount = 1);
    void InsertAt(int nStartIndex, CDXArray* pNewArray);
    void Sort(int (__cdecl *compare )(const void *elem1, const void *elem2 ));

// Implementation
protected:
    TYPE* m_pData;   // the actual array of data
    int m_nSize;     // # of elements (upperBound - 1)
    int m_nMaxSize;  // max allocated
    int m_nGrowBy;   // grow amount

public:
    ~CDXArray();
#ifdef _DEBUG
//  void Dump(CDumpContext&) const;
    void AssertValid() const;
#endif
};

/////////////////////////////////////////////////////////////////////////////
// CDXArray<TYPE, ARG_TYPE> inline functions

template<class TYPE, class ARG_TYPE>
inline int CDXArray<TYPE, ARG_TYPE>::GetSize() const
    { return m_nSize; }
template<class TYPE, class ARG_TYPE>
inline int CDXArray<TYPE, ARG_TYPE>::GetUpperBound() const
    { return m_nSize-1; }
template<class TYPE, class ARG_TYPE>
inline void CDXArray<TYPE, ARG_TYPE>::RemoveAll()
    { SetSize(0, -1); }
template<class TYPE, class ARG_TYPE>
inline TYPE CDXArray<TYPE, ARG_TYPE>::GetAt(int nIndex) const
    { _ASSERT( (nIndex >= 0 && nIndex < m_nSize) );
        return m_pData[nIndex]; }
template<class TYPE, class ARG_TYPE>
inline void CDXArray<TYPE, ARG_TYPE>::SetAt(int nIndex, ARG_TYPE newElement)
    { _ASSERT( (nIndex >= 0 && nIndex < m_nSize) );
        m_pData[nIndex] = newElement; }
template<class TYPE, class ARG_TYPE>
inline TYPE& CDXArray<TYPE, ARG_TYPE>::ElementAt(int nIndex)
    { _ASSERT( (nIndex >= 0 && nIndex < m_nSize) );
        return m_pData[nIndex]; }
template<class TYPE, class ARG_TYPE>
inline const TYPE* CDXArray<TYPE, ARG_TYPE>::GetData() const
    { return (const TYPE*)m_pData; }
template<class TYPE, class ARG_TYPE>
inline TYPE* CDXArray<TYPE, ARG_TYPE>::GetData()
    { return (TYPE*)m_pData; }
template<class TYPE, class ARG_TYPE>
inline int CDXArray<TYPE, ARG_TYPE>::Add(ARG_TYPE newElement)
    { int nIndex = m_nSize;
        SetAtGrow(nIndex, newElement);
        return nIndex; }
template<class TYPE, class ARG_TYPE>
inline TYPE CDXArray<TYPE, ARG_TYPE>::operator[](int nIndex) const
    { return GetAt(nIndex); }
template<class TYPE, class ARG_TYPE>
inline TYPE& CDXArray<TYPE, ARG_TYPE>::operator[](int nIndex)
    { return ElementAt(nIndex); }

/////////////////////////////////////////////////////////////////////////////
// CDXArray<TYPE, ARG_TYPE> out-of-line functions

template<class TYPE, class ARG_TYPE>
CDXArray<TYPE, ARG_TYPE>::CDXArray()
{
    m_pData = NULL;
    m_nSize = m_nMaxSize = m_nGrowBy = 0;
}

template<class TYPE, class ARG_TYPE>
CDXArray<TYPE, ARG_TYPE>::~CDXArray()
{
    DXASSERT_VALID( this );

    if (m_pData != NULL)
    {
        DXDestructElements(m_pData, m_nSize);
        delete[] (BYTE*)m_pData;
    }
}

template<class TYPE, class ARG_TYPE>
void CDXArray<TYPE, ARG_TYPE>::SetSize(int nNewSize, int nGrowBy)
{
    DXASSERT_VALID( this );
    _ASSERT( nNewSize >= 0 );

    if (nGrowBy != -1)
        m_nGrowBy = nGrowBy;  // set new size

    if (nNewSize == 0)
    {
        // shrink to nothing
        if (m_pData != NULL)
        {
            DXDestructElements(m_pData, m_nSize);
            delete[] (BYTE*)m_pData;
            m_pData = NULL;
        }
        m_nSize = m_nMaxSize = 0;
    }
    else if (m_pData == NULL)
    {
        // create one with exact size
#ifdef SIZE_T_MAX
        _ASSERT( nNewSize <= SIZE_T_MAX/sizeof(TYPE) );    // no overflow
#endif
        m_pData = (TYPE*) new BYTE[nNewSize * sizeof(TYPE)];
        DXConstructElements(m_pData, nNewSize);
        m_nSize = m_nMaxSize = nNewSize;
    }
    else if (nNewSize <= m_nMaxSize)
    {
        // it fits
        if (nNewSize > m_nSize)
        {
            // initialize the new elements
            DXConstructElements(&m_pData[m_nSize], nNewSize-m_nSize);
        }
        else if (m_nSize > nNewSize)
        {
            // destroy the old elements
            DXDestructElements(&m_pData[nNewSize], m_nSize-nNewSize);
        }
        m_nSize = nNewSize;
    }
    else
    {
        // otherwise, grow array
        int nGrowBy = m_nGrowBy;
        if (nGrowBy == 0)
        {
            // heuristically determe growth when nGrowBy == 0
            //  (this avoids heap fragmentation in many situations)
            nGrowBy = min(1024, max(4, m_nSize / 8));
        }
        int nNewMax;
        if (nNewSize < m_nMaxSize + nGrowBy)
            nNewMax = m_nMaxSize + nGrowBy;  // granularity
        else
            nNewMax = nNewSize;  // no slush

        _ASSERT( nNewMax >= m_nMaxSize );  // no wrap around
#ifdef SIZE_T_MAX
        _ASSERT( nNewMax <= SIZE_T_MAX/sizeof(TYPE) ); // no overflow
#endif
        TYPE* pNewData = (TYPE*) new BYTE[nNewMax * sizeof(TYPE)];

        // copy new data from old
        memcpy(pNewData, m_pData, m_nSize * sizeof(TYPE));

        // construct remaining elements
        _ASSERT( nNewSize > m_nSize );
        DXConstructElements(&pNewData[m_nSize], nNewSize-m_nSize);

        // get rid of old stuff (note: no destructors called)
        delete[] (BYTE*)m_pData;
        m_pData = pNewData;
        m_nSize = nNewSize;
        m_nMaxSize = nNewMax;
    }
}

template<class TYPE, class ARG_TYPE>
int CDXArray<TYPE, ARG_TYPE>::Append(const CDXArray& src)
{
    DXASSERT_VALID( this );
    _ASSERT( this != &src );   // cannot append to itself

    int nOldSize = m_nSize;
    SetSize(m_nSize + src.m_nSize);
    DXCopyElements(m_pData + nOldSize, src.m_pData, src.m_nSize);
    return nOldSize;
}

template<class TYPE, class ARG_TYPE>
void CDXArray<TYPE, ARG_TYPE>::Copy(const CDXArray& src)
{
    DXASSERT_VALID( this );
    _ASSERT( this != &src );   // cannot copy to itself

    SetSize(src.m_nSize);
    DXCopyElements(m_pData, src.m_pData, src.m_nSize);
}

template<class TYPE, class ARG_TYPE>
void CDXArray<TYPE, ARG_TYPE>::FreeExtra()
{
    DXASSERT_VALID( this );

    if (m_nSize != m_nMaxSize)
    {
        // shrink to desired size
#ifdef SIZE_T_MAX
        _ASSERT( m_nSize <= SIZE_T_MAX/sizeof(TYPE)); // no overflow
#endif
        TYPE* pNewData = NULL;
        if (m_nSize != 0)
        {
            pNewData = (TYPE*) new BYTE[m_nSize * sizeof(TYPE)];
            // copy new data from old
            memcpy(pNewData, m_pData, m_nSize * sizeof(TYPE));
        }

        // get rid of old stuff (note: no destructors called)
        delete[] (BYTE*)m_pData;
        m_pData = pNewData;
        m_nMaxSize = m_nSize;
    }
}

template<class TYPE, class ARG_TYPE>
void CDXArray<TYPE, ARG_TYPE>::SetAtGrow(int nIndex, ARG_TYPE newElement)
{
    DXASSERT_VALID( this );
    _ASSERT( nIndex >= 0 );

    if (nIndex >= m_nSize)
        SetSize(nIndex+1, -1);
    m_pData[nIndex] = newElement;
}

template<class TYPE, class ARG_TYPE>
void CDXArray<TYPE, ARG_TYPE>::InsertAt(int nIndex, ARG_TYPE newElement, int nCount /*=1*/)
{
    DXASSERT_VALID( this );
    _ASSERT( nIndex >= 0 );    // will expand to meet need
    _ASSERT( nCount > 0 );     // zero or negative size not allowed

    if (nIndex >= m_nSize)
    {
        // adding after the end of the array
        SetSize(nIndex + nCount, -1);   // grow so nIndex is valid
    }
    else
    {
        // inserting in the middle of the array
        int nOldSize = m_nSize;
        SetSize(m_nSize + nCount, -1);  // grow it to new size
        // shift old data up to fill gap
        memmove(&m_pData[nIndex+nCount], &m_pData[nIndex],
            (nOldSize-nIndex) * sizeof(TYPE));

        // re-init slots we copied from
        DXConstructElements(&m_pData[nIndex], nCount);
    }

    // insert new value in the gap
    _ASSERT( nIndex + nCount <= m_nSize );
    while (nCount--)
        m_pData[nIndex++] = newElement;
}

template<class TYPE, class ARG_TYPE>
void CDXArray<TYPE, ARG_TYPE>::RemoveAt(int nIndex, int nCount)
{
    DXASSERT_VALID( this );
    _ASSERT( nIndex >= 0 );
    _ASSERT( nCount >= 0 );
    _ASSERT( nIndex + nCount <= m_nSize );

    // just remove a range
    int nMoveCount = m_nSize - (nIndex + nCount);
    DXDestructElements(&m_pData[nIndex], nCount);
    if (nMoveCount)
        memcpy(&m_pData[nIndex], &m_pData[nIndex + nCount],
            nMoveCount * sizeof(TYPE));
    m_nSize -= nCount;
}

template<class TYPE, class ARG_TYPE>
void CDXArray<TYPE, ARG_TYPE>::InsertAt(int nStartIndex, CDXArray* pNewArray)
{
    DXASSERT_VALID( this );
    DXASSERT_VALID( pNewArray );
    _ASSERT( nStartIndex >= 0 );

    if (pNewArray->GetSize() > 0)
    {
        InsertAt(nStartIndex, pNewArray->GetAt(0), pNewArray->GetSize());
        for (int i = 0; i < pNewArray->GetSize(); i++)
            SetAt(nStartIndex + i, pNewArray->GetAt(i));
    }
}

template<class TYPE, class ARG_TYPE>
void CDXArray<TYPE, ARG_TYPE>::Sort(int (__cdecl *compare )(const void *elem1, const void *elem2 ))
{
    DXASSERT_VALID( this );
    _ASSERT( m_pData != NULL );

    qsort( m_pData, m_nSize, sizeof(TYPE), compare );
}

#ifdef _DEBUG
template<class TYPE, class ARG_TYPE>
void CDXArray<TYPE, ARG_TYPE>::AssertValid() const
{
    if (m_pData == NULL)
    {
        _ASSERT( m_nSize == 0 );
        _ASSERT( m_nMaxSize == 0 );
    }
    else
    {
        _ASSERT( m_nSize >= 0 );
        _ASSERT( m_nMaxSize >= 0 );
        _ASSERT( m_nSize <= m_nMaxSize );
        _ASSERT( DXIsValidAddress(m_pData, m_nMaxSize * sizeof(TYPE), TRUE ) );
    }
}
#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CDXList<TYPE, ARG_TYPE>

template<class TYPE, class ARG_TYPE>
class CDXList
{
protected:
    struct CNode
    {
        CNode* pNext;
        CNode* pPrev;
        TYPE data;
    };
public:

// Construction
    CDXList(int nBlockSize = 10);

// Attributes (head and tail)
    // count of elements
    int GetCount() const;
    BOOL IsEmpty() const;

    // peek at head or tail
    TYPE& GetHead();
    TYPE GetHead() const;
    TYPE& GetTail();
    TYPE GetTail() const;

// Operations
    // get head or tail (and remove it) - don't call on empty list !
    TYPE RemoveHead();
    TYPE RemoveTail();

    // add before head or after tail
    DXLISTPOS AddHead(ARG_TYPE newElement);
    DXLISTPOS AddTail(ARG_TYPE newElement);

    // add another list of elements before head or after tail
    void AddHead(CDXList* pNewList);
    void AddTail(CDXList* pNewList);

    // remove all elements
    void RemoveAll();

    // iteration
    DXLISTPOS GetHeadPosition() const;
    DXLISTPOS GetTailPosition() const;
    TYPE& GetNext(DXLISTPOS& rPosition); // return *Position++
    TYPE GetNext(DXLISTPOS& rPosition) const; // return *Position++
    TYPE& GetPrev(DXLISTPOS& rPosition); // return *Position--
    TYPE GetPrev(DXLISTPOS& rPosition) const; // return *Position--

    // getting/modifying an element at a given position
    TYPE& GetAt(DXLISTPOS position);
    TYPE GetAt(DXLISTPOS position) const;
    void SetAt(DXLISTPOS pos, ARG_TYPE newElement);
    void RemoveAt(DXLISTPOS position);

    // inserting before or after a given position
    DXLISTPOS InsertBefore(DXLISTPOS position, ARG_TYPE newElement);
    DXLISTPOS InsertAfter(DXLISTPOS position, ARG_TYPE newElement);

    // helper functions (note: O(n) speed)
    DXLISTPOS Find(ARG_TYPE searchValue, DXLISTPOS startAfter = NULL) const;
        // defaults to starting at the HEAD, return NULL if not found
    DXLISTPOS FindIndex(int nIndex) const;
        // get the 'nIndex'th element (may return NULL)

// Implementation
protected:
    CNode* m_pNodeHead;
    CNode* m_pNodeTail;
    int m_nCount;
    CNode* m_pNodeFree;
    struct CDXPlex* m_pBlocks;
    int m_nBlockSize;

    CNode* NewNode(CNode*, CNode*);
    void FreeNode(CNode*);

public:
    ~CDXList();
#ifdef _DEBUG
    void AssertValid() const;
#endif
};

/////////////////////////////////////////////////////////////////////////////
// CDXList<TYPE, ARG_TYPE> inline functions

template<class TYPE, class ARG_TYPE>
inline int CDXList<TYPE, ARG_TYPE>::GetCount() const
    { return m_nCount; }
template<class TYPE, class ARG_TYPE>
inline BOOL CDXList<TYPE, ARG_TYPE>::IsEmpty() const
    { return m_nCount == 0; }
template<class TYPE, class ARG_TYPE>
inline TYPE& CDXList<TYPE, ARG_TYPE>::GetHead()
    {   _ASSERT( m_pNodeHead != NULL );
        return m_pNodeHead->data; }
template<class TYPE, class ARG_TYPE>
inline TYPE CDXList<TYPE, ARG_TYPE>::GetHead() const
    {   _ASSERT( m_pNodeHead != NULL );
        return m_pNodeHead->data; }
template<class TYPE, class ARG_TYPE>
inline TYPE& CDXList<TYPE, ARG_TYPE>::GetTail()
    {   _ASSERT( m_pNodeTail != NULL );
        return m_pNodeTail->data; }
template<class TYPE, class ARG_TYPE>
inline TYPE CDXList<TYPE, ARG_TYPE>::GetTail() const
    {   _ASSERT( m_pNodeTail != NULL );
        return m_pNodeTail->data; }
template<class TYPE, class ARG_TYPE>
inline DXLISTPOS CDXList<TYPE, ARG_TYPE>::GetHeadPosition() const
    { return (DXLISTPOS) m_pNodeHead; }
template<class TYPE, class ARG_TYPE>
inline DXLISTPOS CDXList<TYPE, ARG_TYPE>::GetTailPosition() const
    { return (DXLISTPOS) m_pNodeTail; }
template<class TYPE, class ARG_TYPE>
inline TYPE& CDXList<TYPE, ARG_TYPE>::GetNext(DXLISTPOS& rPosition) // return *Position++
    {   CNode* pNode = (CNode*) rPosition;
        _ASSERT( DXIsValidAddress(pNode, sizeof(CNode), TRUE ) );
        rPosition = (DXLISTPOS) pNode->pNext;
        return pNode->data; }
template<class TYPE, class ARG_TYPE>
inline TYPE CDXList<TYPE, ARG_TYPE>::GetNext(DXLISTPOS& rPosition) const // return *Position++
    {   CNode* pNode = (CNode*) rPosition;
        _ASSERT( DXIsValidAddress(pNode, sizeof(CNode), TRUE ) );
        rPosition = (DXLISTPOS) pNode->pNext;
        return pNode->data; }
template<class TYPE, class ARG_TYPE>
inline TYPE& CDXList<TYPE, ARG_TYPE>::GetPrev(DXLISTPOS& rPosition) // return *Position--
    {   CNode* pNode = (CNode*) rPosition;
        _ASSERT( DXIsValidAddress(pNode, sizeof(CNode), TRUE ) );
        rPosition = (DXLISTPOS) pNode->pPrev;
        return pNode->data; }
template<class TYPE, class ARG_TYPE>
inline TYPE CDXList<TYPE, ARG_TYPE>::GetPrev(DXLISTPOS& rPosition) const // return *Position--
    {   CNode* pNode = (CNode*) rPosition;
        _ASSERT( DXIsValidAddress(pNode, sizeof(CNode), TRUE ) );
        rPosition = (DXLISTPOS) pNode->pPrev;
        return pNode->data; }
template<class TYPE, class ARG_TYPE>
inline TYPE& CDXList<TYPE, ARG_TYPE>::GetAt(DXLISTPOS position)
    {   CNode* pNode = (CNode*) position;
        _ASSERT( DXIsValidAddress(pNode, sizeof(CNode), TRUE ) );
        return pNode->data; }
template<class TYPE, class ARG_TYPE>
inline TYPE CDXList<TYPE, ARG_TYPE>::GetAt(DXLISTPOS position) const
    {   CNode* pNode = (CNode*) position;
        _ASSERT( DXIsValidAddress(pNode, sizeof(CNode), TRUE ) );
        return pNode->data; }
template<class TYPE, class ARG_TYPE>
inline void CDXList<TYPE, ARG_TYPE>::SetAt(DXLISTPOS pos, ARG_TYPE newElement)
    {   CNode* pNode = (CNode*) pos;
        _ASSERT( DXIsValidAddress(pNode, sizeof(CNode), TRUE ) );
        pNode->data = newElement; }

/////////////////////////////////////////////////////////////////////////////
// CDXList<TYPE, ARG_TYPE> out-of-line functions

template<class TYPE, class ARG_TYPE>
CDXList<TYPE, ARG_TYPE>::CDXList( int nBlockSize )
{
    _ASSERT( nBlockSize > 0 );

    m_nCount = 0;
    m_pNodeHead = m_pNodeTail = m_pNodeFree = NULL;
    m_pBlocks = NULL;
    m_nBlockSize = nBlockSize;
}

template<class TYPE, class ARG_TYPE>
void CDXList<TYPE, ARG_TYPE>::RemoveAll()
{
    DXASSERT_VALID( this );

    // destroy elements
    CNode* pNode;
    for (pNode = m_pNodeHead; pNode != NULL; pNode = pNode->pNext)
        DXDestructElements(&pNode->data, 1);

    m_nCount = 0;
    m_pNodeHead = m_pNodeTail = m_pNodeFree = NULL;
    m_pBlocks->FreeDataChain();
    m_pBlocks = NULL;
}

template<class TYPE, class ARG_TYPE>
CDXList<TYPE, ARG_TYPE>::~CDXList()
{
    RemoveAll();
    _ASSERT( m_nCount == 0 );
}

/////////////////////////////////////////////////////////////////////////////
// Node helpers
//
// Implementation note: CNode's are stored in CDXPlex blocks and
//  chained together. Free blocks are maintained in a singly linked list
//  using the 'pNext' member of CNode with 'm_pNodeFree' as the head.
//  Used blocks are maintained in a doubly linked list using both 'pNext'
//  and 'pPrev' as links and 'm_pNodeHead' and 'm_pNodeTail'
//   as the head/tail.
//
// We never free a CDXPlex block unless the List is destroyed or RemoveAll()
//  is used - so the total number of CDXPlex blocks may grow large depending
//  on the maximum past size of the list.
//

template<class TYPE, class ARG_TYPE>
typename CDXList<TYPE, ARG_TYPE>::CNode*
CDXList<TYPE, ARG_TYPE>::NewNode(CNode* pPrev, CNode* pNext)
{
    if (m_pNodeFree == NULL)
    {
        // add another block
        CDXPlex* pNewBlock = CDXPlex::Create(m_pBlocks, m_nBlockSize,
                 sizeof(CNode));

        // chain them into free list
        CNode* pNode = (CNode*) pNewBlock->data();
        // free in reverse order to make it easier to debug
        pNode += m_nBlockSize - 1;
        for (int i = m_nBlockSize-1; i >= 0; i--, pNode--)
        {
            pNode->pNext = m_pNodeFree;
            m_pNodeFree = pNode;
        }
    }
    _ASSERT( m_pNodeFree != NULL );  // we must have something

    CDXList::CNode* pNode = m_pNodeFree;
    m_pNodeFree = m_pNodeFree->pNext;
    pNode->pPrev = pPrev;
    pNode->pNext = pNext;
    m_nCount++;
    _ASSERT( m_nCount > 0 );  // make sure we don't overflow

    DXConstructElements(&pNode->data, 1);
    return pNode;
}

template<class TYPE, class ARG_TYPE>
void CDXList<TYPE, ARG_TYPE>::FreeNode(CNode* pNode)
{
    DXDestructElements(&pNode->data, 1);
    pNode->pNext = m_pNodeFree;
    m_pNodeFree = pNode;
    m_nCount--;
    _ASSERT( m_nCount >= 0 );  // make sure we don't underflow
}

template<class TYPE, class ARG_TYPE>
DXLISTPOS CDXList<TYPE, ARG_TYPE>::AddHead(ARG_TYPE newElement)
{
    DXASSERT_VALID( this );

    CNode* pNewNode = NewNode(NULL, m_pNodeHead);
    pNewNode->data = newElement;
    if (m_pNodeHead != NULL)
        m_pNodeHead->pPrev = pNewNode;
    else
        m_pNodeTail = pNewNode;
    m_pNodeHead = pNewNode;
    return (DXLISTPOS) pNewNode;
}

template<class TYPE, class ARG_TYPE>
DXLISTPOS CDXList<TYPE, ARG_TYPE>::AddTail(ARG_TYPE newElement)
{
    DXASSERT_VALID( this );

    CNode* pNewNode = NewNode(m_pNodeTail, NULL);
    pNewNode->data = newElement;
    if (m_pNodeTail != NULL)
        m_pNodeTail->pNext = pNewNode;
    else
        m_pNodeHead = pNewNode;
    m_pNodeTail = pNewNode;
    return (DXLISTPOS) pNewNode;
}

template<class TYPE, class ARG_TYPE>
void CDXList<TYPE, ARG_TYPE>::AddHead(CDXList* pNewList)
{
    DXASSERT_VALID( this );
    DXASSERT_VALID( pNewList );

    // add a list of same elements to head (maintain order)
    DXLISTPOS pos = pNewList->GetTailPosition();
    while (pos != NULL)
        AddHead(pNewList->GetPrev(pos));
}

template<class TYPE, class ARG_TYPE>
void CDXList<TYPE, ARG_TYPE>::AddTail(CDXList* pNewList)
{
    DXASSERT_VALID( this );
    DXASSERT_VALID( pNewList );

    // add a list of same elements
    DXLISTPOS pos = pNewList->GetHeadPosition();
    while (pos != NULL)
        AddTail(pNewList->GetNext(pos));
}

template<class TYPE, class ARG_TYPE>
TYPE CDXList<TYPE, ARG_TYPE>::RemoveHead()
{
    DXASSERT_VALID( this );
    _ASSERT( m_pNodeHead != NULL );  // don't call on empty list !!!
    _ASSERT( DXIsValidAddress(m_pNodeHead, sizeof(CNode), TRUE ) );

    CNode* pOldNode = m_pNodeHead;
    TYPE returnValue = pOldNode->data;

    m_pNodeHead = pOldNode->pNext;
    if (m_pNodeHead != NULL)
        m_pNodeHead->pPrev = NULL;
    else
        m_pNodeTail = NULL;
    FreeNode(pOldNode);
    return returnValue;
}

template<class TYPE, class ARG_TYPE>
TYPE CDXList<TYPE, ARG_TYPE>::RemoveTail()
{
    DXASSERT_VALID( this );
    _ASSERT( m_pNodeTail != NULL );  // don't call on empty list !!!
    _ASSERT( DXIsValidAddress(m_pNodeTail, sizeof(CNode), TRUE ) );

    CNode* pOldNode = m_pNodeTail;
    TYPE returnValue = pOldNode->data;

    m_pNodeTail = pOldNode->pPrev;
    if (m_pNodeTail != NULL)
        m_pNodeTail->pNext = NULL;
    else
        m_pNodeHead = NULL;
    FreeNode(pOldNode);
    return returnValue;
}

template<class TYPE, class ARG_TYPE>
DXLISTPOS CDXList<TYPE, ARG_TYPE>::InsertBefore(DXLISTPOS position, ARG_TYPE newElement)
{
    DXASSERT_VALID( this );

    if (position == NULL)
        return AddHead(newElement); // insert before nothing -> head of the list

    // Insert it before position
    CNode* pOldNode = (CNode*) position;
    CNode* pNewNode = NewNode(pOldNode->pPrev, pOldNode);
    pNewNode->data = newElement;

    if (pOldNode->pPrev != NULL)
    {
        _ASSERT( DXIsValidAddress(pOldNode->pPrev, sizeof(CNode), TRUE ) );
        pOldNode->pPrev->pNext = pNewNode;
    }
    else
    {
        _ASSERT( pOldNode == m_pNodeHead );
        m_pNodeHead = pNewNode;
    }
    pOldNode->pPrev = pNewNode;
    return (DXLISTPOS) pNewNode;
}

template<class TYPE, class ARG_TYPE>
DXLISTPOS CDXList<TYPE, ARG_TYPE>::InsertAfter(DXLISTPOS position, ARG_TYPE newElement)
{
    DXASSERT_VALID( this );

    if (position == NULL)
        return AddTail(newElement); // insert after nothing -> tail of the list

    // Insert it before position
    CNode* pOldNode = (CNode*) position;
    _ASSERT( DXIsValidAddress(pOldNode, sizeof(CNode), TRUE ));
    CNode* pNewNode = NewNode(pOldNode, pOldNode->pNext);
    pNewNode->data = newElement;

    if (pOldNode->pNext != NULL)
    {
        _ASSERT( DXIsValidAddress(pOldNode->pNext, sizeof(CNode), TRUE ));
        pOldNode->pNext->pPrev = pNewNode;
    }
    else
    {
        _ASSERT( pOldNode == m_pNodeTail );
        m_pNodeTail = pNewNode;
    }
    pOldNode->pNext = pNewNode;
    return (DXLISTPOS) pNewNode;
}

template<class TYPE, class ARG_TYPE>
void CDXList<TYPE, ARG_TYPE>::RemoveAt(DXLISTPOS position)
{
    DXASSERT_VALID( this );

    CNode* pOldNode = (CNode*) position;
    _ASSERT( DXIsValidAddress(pOldNode, sizeof(CNode), TRUE ) );

    // remove pOldNode from list
    if (pOldNode == m_pNodeHead)
    {
        m_pNodeHead = pOldNode->pNext;
    }
    else
    {
        _ASSERT( DXIsValidAddress(pOldNode->pPrev, sizeof(CNode), TRUE ) );
        pOldNode->pPrev->pNext = pOldNode->pNext;
    }
    if (pOldNode == m_pNodeTail)
    {
        m_pNodeTail = pOldNode->pPrev;
    }
    else
    {
        _ASSERT( DXIsValidAddress(pOldNode->pNext, sizeof(CNode), TRUE ) );
        pOldNode->pNext->pPrev = pOldNode->pPrev;
    }
    FreeNode(pOldNode);
}

template<class TYPE, class ARG_TYPE>
DXLISTPOS CDXList<TYPE, ARG_TYPE>::FindIndex(int nIndex) const
{
    DXASSERT_VALID( this );
    _ASSERT( nIndex >= 0 );

    if (nIndex >= m_nCount)
        return NULL;  // went too far

    CNode* pNode = m_pNodeHead;
    while (nIndex--)
    {
        _ASSERT( DXIsValidAddress(pNode, sizeof(CNode), TRUE ));
        pNode = pNode->pNext;
    }
    return (DXLISTPOS) pNode;
}

template<class TYPE, class ARG_TYPE>
DXLISTPOS CDXList<TYPE, ARG_TYPE>::Find(ARG_TYPE searchValue, DXLISTPOS startAfter) const
{
    DXASSERT_VALID( this );

    CNode* pNode = (CNode*) startAfter;
    if (pNode == NULL)
    {
        pNode = m_pNodeHead;  // start at head
    }
    else
    {
        _ASSERT( DXIsValidAddress(pNode, sizeof(CNode), TRUE ) );
        pNode = pNode->pNext;  // start after the one specified
    }

    for (; pNode != NULL; pNode = pNode->pNext)
        if (DXCompareElements(&pNode->data, &searchValue))
            return (DXLISTPOS)pNode;
    return NULL;
}

#ifdef _DEBUG
template<class TYPE, class ARG_TYPE>
void CDXList<TYPE, ARG_TYPE>::AssertValid() const
{
    if (m_nCount == 0)
    {
        // empty list
        _ASSERT( m_pNodeHead == NULL );
        _ASSERT( m_pNodeTail == NULL );
    }
    else
    {
        // non-empty list
        _ASSERT( DXIsValidAddress(m_pNodeHead, sizeof(CNode), TRUE ));
        _ASSERT( DXIsValidAddress(m_pNodeTail, sizeof(CNode), TRUE ));
    }
}
#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CDXMap<KEY, ARG_KEY, VALUE, ARG_VALUE>

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
class CDXMap
{
protected:
    // Association
    struct CAssoc
    {
        CAssoc* pNext;
        UINT nHashValue;  // needed for efficient iteration
        KEY key;
        VALUE value;
    };
public:
// Construction
    CDXMap( int nBlockSize = 10 );

// Attributes
    // number of elements
    int GetCount() const;
    BOOL IsEmpty() const;

    // Lookup
    BOOL Lookup(ARG_KEY key, VALUE& rValue) const;

// Operations
    // Lookup and add if not there
    VALUE& operator[](ARG_KEY key);

    // add a new (key, value) pair
    void SetAt(ARG_KEY key, ARG_VALUE newValue);

    // removing existing (key, ?) pair
    BOOL RemoveKey(ARG_KEY key);
    void RemoveAll();

    // iterating all (key, value) pairs
    DXLISTPOS GetStartPosition() const;
    void GetNextAssoc(DXLISTPOS& rNextPosition, KEY& rKey, VALUE& rValue) const;

    // advanced features for derived classes
    UINT GetHashTableSize() const;
    void InitHashTable(UINT hashSize, BOOL bAllocNow = TRUE);

// Implementation
protected:
    CAssoc** m_pHashTable;
    UINT m_nHashTableSize;
    int m_nCount;
    CAssoc* m_pFreeList;
    struct CDXPlex* m_pBlocks;
    int m_nBlockSize;

    CAssoc* NewAssoc();
    void FreeAssoc(CAssoc*);
    CAssoc* GetAssocAt(ARG_KEY, UINT&) const;

public:
    ~CDXMap();
#ifdef _DEBUG
//  void Dump(CDumpContext&) const;
    void AssertValid() const;
#endif
};

/////////////////////////////////////////////////////////////////////////////
// CDXMap<KEY, ARG_KEY, VALUE, ARG_VALUE> inline functions

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
inline int CDXMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::GetCount() const
    { return m_nCount; }
template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
inline BOOL CDXMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::IsEmpty() const
    { return m_nCount == 0; }
template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
inline void CDXMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::SetAt(ARG_KEY key, ARG_VALUE newValue)
    { (*this)[key] = newValue; }
template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
inline DXLISTPOS CDXMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::GetStartPosition() const
    { return (m_nCount == 0) ? NULL : DX_BEFORE_START_POSITION; }
template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
inline UINT CDXMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::GetHashTableSize() const
    { return m_nHashTableSize; }

/////////////////////////////////////////////////////////////////////////////
// CDXMap<KEY, ARG_KEY, VALUE, ARG_VALUE> out-of-line functions

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
CDXMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::CDXMap( int nBlockSize )
{
    _ASSERT( nBlockSize > 0 );

    m_pHashTable = NULL;
    m_nHashTableSize = 17;  // default size
    m_nCount = 0;
    m_pFreeList = NULL;
    m_pBlocks = NULL;
    m_nBlockSize = nBlockSize;
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
void CDXMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::InitHashTable(
    UINT nHashSize, BOOL bAllocNow)
//
// Used to force allocation of a hash table or to override the default
//   hash table size of (which is fairly small)
{
    DXASSERT_VALID( this );
    _ASSERT( m_nCount == 0 );
    _ASSERT( nHashSize > 0 );

    if (m_pHashTable != NULL)
    {
        // free hash table
        delete[] m_pHashTable;
        m_pHashTable = NULL;
    }

    if (bAllocNow)
    {
        m_pHashTable = new CAssoc* [nHashSize];
        memset(m_pHashTable, 0, sizeof(CAssoc*) * nHashSize);
    }
    m_nHashTableSize = nHashSize;
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
void CDXMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::RemoveAll()
{
    DXASSERT_VALID( this );

    if (m_pHashTable != NULL)
    {
        // destroy elements (values and keys)
        for (UINT nHash = 0; nHash < m_nHashTableSize; nHash++)
        {
            CAssoc* pAssoc;
            for (pAssoc = m_pHashTable[nHash]; pAssoc != NULL;
              pAssoc = pAssoc->pNext)
            {
                DXDestructElements(&pAssoc->value, 1);
                DXDestructElements(&pAssoc->key, 1);
            }
        }
    }

    // free hash table
    delete[] m_pHashTable;
    m_pHashTable = NULL;

    m_nCount = 0;
    m_pFreeList = NULL;
    m_pBlocks->FreeDataChain();
    m_pBlocks = NULL;
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
CDXMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::~CDXMap()
{
    RemoveAll();
    _ASSERT( m_nCount == 0 );
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
typename CDXMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::CAssoc*
CDXMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::NewAssoc()
{
    if (m_pFreeList == NULL)
    {
        // add another block
        CDXPlex* newBlock = CDXPlex::Create(m_pBlocks, m_nBlockSize, sizeof(CDXMap::CAssoc));
        // chain them into free list
        CDXMap::CAssoc* pAssoc = (CDXMap::CAssoc*) newBlock->data();
        // free in reverse order to make it easier to debug
        pAssoc += m_nBlockSize - 1;
        for (int i = m_nBlockSize-1; i >= 0; i--, pAssoc--)
        {
            pAssoc->pNext = m_pFreeList;
            m_pFreeList = pAssoc;
        }
    }
    _ASSERT( m_pFreeList != NULL );  // we must have something

    CDXMap::CAssoc* pAssoc = m_pFreeList;
    m_pFreeList = m_pFreeList->pNext;
    m_nCount++;
    _ASSERT( m_nCount > 0 );  // make sure we don't overflow
    DXConstructElements(&pAssoc->key, 1);
    DXConstructElements(&pAssoc->value, 1);   // special construct values
    return pAssoc;
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
void CDXMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::FreeAssoc(CAssoc* pAssoc)
{
    DXDestructElements(&pAssoc->value, 1);
    DXDestructElements(&pAssoc->key, 1);
    pAssoc->pNext = m_pFreeList;
    m_pFreeList = pAssoc;
    m_nCount--;
    _ASSERT( m_nCount >= 0 );  // make sure we don't underflow
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
typename CDXMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::CAssoc*
CDXMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::GetAssocAt(ARG_KEY key, UINT& nHash) const
// find association (or return NULL)
{
    nHash = DXHashKey(key) % m_nHashTableSize;

    if (m_pHashTable == NULL)
        return NULL;

    // see if it exists
    CAssoc* pAssoc;
    for (pAssoc = m_pHashTable[nHash]; pAssoc != NULL; pAssoc = pAssoc->pNext)
    {
        if (DXCompareElements(&pAssoc->key, &key))
            return pAssoc;
    }
    return NULL;
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
BOOL CDXMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::Lookup(ARG_KEY key, VALUE& rValue) const
{
    DXASSERT_VALID( this );

    UINT nHash;
    CAssoc* pAssoc = GetAssocAt(key, nHash);
    if (pAssoc == NULL)
        return FALSE;  // not in map

    rValue = pAssoc->value;
    return TRUE;
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
VALUE& CDXMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::operator[](ARG_KEY key)
{
    DXASSERT_VALID( this );

    UINT nHash;
    CAssoc* pAssoc;
    if ((pAssoc = GetAssocAt(key, nHash)) == NULL)
    {
        if (m_pHashTable == NULL)
            InitHashTable(m_nHashTableSize);

        // it doesn't exist, add a new Association
        pAssoc = NewAssoc();
        pAssoc->nHashValue = nHash;
        pAssoc->key = key;
        // 'pAssoc->value' is a constructed object, nothing more

        // put into hash table
        pAssoc->pNext = m_pHashTable[nHash];
        m_pHashTable[nHash] = pAssoc;
    }
    return pAssoc->value;  // return new reference
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
BOOL CDXMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::RemoveKey(ARG_KEY key)
// remove key - return TRUE if removed
{
    DXASSERT_VALID( this );

    if (m_pHashTable == NULL)
        return FALSE;  // nothing in the table

    CAssoc** ppAssocPrev;
    ppAssocPrev = &m_pHashTable[DXHashKey(key) % m_nHashTableSize];

    CAssoc* pAssoc;
    for (pAssoc = *ppAssocPrev; pAssoc != NULL; pAssoc = pAssoc->pNext)
    {
        if (DXCompareElements(&pAssoc->key, &key))
        {
            // remove it
            *ppAssocPrev = pAssoc->pNext;  // remove from list
            FreeAssoc(pAssoc);
            return TRUE;
        }
        ppAssocPrev = &pAssoc->pNext;
    }
    return FALSE;  // not found
}

template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
void CDXMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::GetNextAssoc(DXLISTPOS& rNextPosition,
    KEY& rKey, VALUE& rValue) const
{
    DXASSERT_VALID( this );
    _ASSERT( m_pHashTable != NULL );  // never call on empty map

    CAssoc* pAssocRet = (CAssoc*)rNextPosition;
    _ASSERT( pAssocRet != NULL );

    if (pAssocRet == (CAssoc*) DX_BEFORE_START_POSITION)
    {
        // find the first association
        for (UINT nBucket = 0; nBucket < m_nHashTableSize; nBucket++)
            if ((pAssocRet = m_pHashTable[nBucket]) != NULL)
                break;
        _ASSERT( pAssocRet != NULL );  // must find something
    }

    // find next association
    _ASSERT( DXIsValidAddress(pAssocRet, sizeof(CAssoc), TRUE ));
    CAssoc* pAssocNext;
    if ((pAssocNext = pAssocRet->pNext) == NULL)
    {
        // go to next bucket
        for (UINT nBucket = pAssocRet->nHashValue + 1;
          nBucket < m_nHashTableSize; nBucket++)
            if ((pAssocNext = m_pHashTable[nBucket]) != NULL)
                break;
    }

    rNextPosition = (DXLISTPOS) pAssocNext;

    // fill in return data
    rKey = pAssocRet->key;
    rValue = pAssocRet->value;
}

#ifdef _DEBUG
template<class KEY, class ARG_KEY, class VALUE, class ARG_VALUE>
void CDXMap<KEY, ARG_KEY, VALUE, ARG_VALUE>::AssertValid() const
{
    _ASSERT( m_nHashTableSize > 0 );
    _ASSERT( (m_nCount == 0 || m_pHashTable != NULL) );
        // non-empty map should have hash table
}
#endif //_DEBUG

#endif //--- This must be the last line in the file
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\extinc\dxtmsft3guid.h ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */

/* link this file in with the server and any clients */


 /* File created by MIDL compiler version 5.03.0285 */
/* Compiler settings for dxtmsft3.idl:
    Oicf (OptLev=i2), W0, Zp8, env=Win32 (32b run), ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if !defined(_M_IA64) && !defined(_M_AXP64)

#ifdef __cplusplus
extern "C"{
#endif 


#include <rpc.h>
#include <rpcndr.h>

#ifdef _MIDL_USE_GUIDDEF_

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)

#else // !_MIDL_USE_GUIDDEF_

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}

#endif !_MIDL_USE_GUIDDEF_

MIDL_DEFINE_GUID(IID, IID_IExplode,0x141DBAF0,0x55FB,0x11D1,0xB8,0x3E,0x00,0xA0,0xC9,0x33,0xBE,0x86);


MIDL_DEFINE_GUID(IID, IID_ICrShatter,0x63500AE1,0x0858,0x11D2,0x8C,0xE4,0x00,0xC0,0x4F,0x8E,0xCB,0x10);


MIDL_DEFINE_GUID(IID, IID_IDXTBlackHole,0xC3853C21,0x3F2E,0x11D2,0x99,0x00,0x00,0x00,0xF8,0x03,0xFF,0x7A);


MIDL_DEFINE_GUID(IID, IID_IDXTRoll,0x78F30B81,0x48AA,0x11D2,0x99,0x00,0x00,0x00,0xF8,0x03,0xFF,0x7A);


MIDL_DEFINE_GUID(IID, IID_IDXTSpin,0x3D2807C1,0x43DE,0x11D2,0x99,0x00,0x00,0x00,0xF8,0x03,0xFF,0x7A);


MIDL_DEFINE_GUID(IID, IID_IRipple,0x6DA4A05E,0x8E9E,0x11D1,0x90,0x4E,0x00,0xC0,0x4F,0xD9,0x18,0x9D);


MIDL_DEFINE_GUID(IID, IID_IHeightField,0x0492170A,0xB159,0x11d1,0x92,0x07,0x00,0x00,0xF8,0x75,0x8E,0x66);


MIDL_DEFINE_GUID(IID, IID_IDXTMetaStream,0x48654BC0,0xE51F,0x11D1,0xAA,0x1C,0x00,0x60,0x08,0x95,0xFB,0x99);


MIDL_DEFINE_GUID(IID, IID_IDXTText3D,0x50C4B592,0x7E8D,0x11d2,0x9B,0x4E,0x00,0xA0,0xC9,0x69,0x7C,0xD0);


MIDL_DEFINE_GUID(IID, IID_IDXTShapes,0x8241F013,0x84D3,0x11d2,0x97,0xE6,0x00,0x00,0xF8,0x03,0xFF,0x7A);


MIDL_DEFINE_GUID(IID, LIBID_DXTMSFT3Lib,0xE4BBA4C0,0x69B7,0x11d2,0x83,0x2D,0x00,0x00,0xF8,0x1F,0x59,0x95);


MIDL_DEFINE_GUID(CLSID, CLSID_Explode,0x141DBAF1,0x55FB,0x11D1,0xB8,0x3E,0x00,0xA0,0xC9,0x33,0xBE,0x86);


MIDL_DEFINE_GUID(CLSID, CLSID_ExplodeProp,0xC53059E1,0xE6E3,0x11d1,0xBA,0x12,0x00,0xC0,0x4F,0xB6,0xBD,0x36);


MIDL_DEFINE_GUID(CLSID, CLSID_Ripple,0x945F5842,0x3A8D,0x11D1,0x90,0x37,0x00,0xC0,0x4F,0xD9,0x18,0x9D);


MIDL_DEFINE_GUID(CLSID, CLSID_RipProp,0x945F5843,0x3A8D,0x11D1,0x90,0x37,0x00,0xC0,0x4F,0xD9,0x18,0x9D);


MIDL_DEFINE_GUID(CLSID, CLSID_HeightField,0x04921709,0xB159,0x11d1,0x92,0x07,0x00,0x00,0xF8,0x75,0x8E,0x66);


MIDL_DEFINE_GUID(CLSID, CLSID_HtFieldProp,0x7A8402E3,0xFBD6,0x11D1,0xB5,0xE0,0x00,0xAA,0x00,0x3B,0x60,0x61);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTMetaStream,0x60A0C080,0xE505,0x11D1,0xAA,0x1C,0x00,0x60,0x08,0x95,0xFB,0x99);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTMetaStreamProp,0xE3D77340,0xE505,0x11D1,0xAA,0x1C,0x00,0x60,0x08,0x95,0xFB,0x99);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTText3D,0xD56F34F2,0x7E89,0x11d2,0x9B,0x4E,0x00,0xA0,0xC9,0x69,0x7C,0xD0);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTText3DPP,0x50C4B593,0x7E8D,0x11d2,0x9B,0x4E,0x00,0xA0,0xC9,0x69,0x7C,0xD0);


MIDL_DEFINE_GUID(CLSID, CLSID_CrShatter,0x63500AE2,0x0858,0x11D2,0x8C,0xE4,0x00,0xC0,0x4F,0x8E,0xCB,0x10);


MIDL_DEFINE_GUID(CLSID, CLSID_CrShatterPP,0x99275F01,0x102E,0x11d2,0x8B,0x82,0x00,0xA0,0xC9,0x3C,0x09,0xB2);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTBlackHole,0xC3853C22,0x3F2E,0x11D2,0x99,0x00,0x00,0x00,0xF8,0x03,0xFF,0x7A);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTBlackHolePP,0xC3853C23,0x3F2E,0x11D2,0x99,0x00,0x00,0x00,0xF8,0x03,0xFF,0x7A);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTRoll,0x78F30B82,0x48AA,0x11D2,0x99,0x00,0x00,0x00,0xF8,0x03,0xFF,0x7A);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTRollPP,0x78F30B83,0x48AA,0x11D2,0x99,0x00,0x00,0x00,0xF8,0x03,0xFF,0x7A);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTSpin,0x3D2807C2,0x43DE,0x11D2,0x99,0x00,0x00,0x00,0xF8,0x03,0xFF,0x7A);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTSpinPP,0x3D2807C3,0x43DE,0x11D2,0x99,0x00,0x00,0x00,0xF8,0x03,0xFF,0x7A);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTShapes,0x8241F015,0x84D3,0x11d2,0x97,0xE6,0x00,0x00,0xF8,0x03,0xFF,0x7A);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTShapesPP,0x8241F016,0x84D3,0x11d2,0x97,0xE6,0x00,0x00,0xF8,0x03,0xFF,0x7A);

#undef MIDL_DEFINE_GUID

#ifdef __cplusplus
}
#endif



#endif /* !defined(_M_IA64) && !defined(_M_AXP64)*/


#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */

/* link this file in with the server and any clients */


 /* File created by MIDL compiler version 5.03.0285 */
/* Compiler settings for dxtmsft3.idl:
    Oicf (OptLev=i2), W0, Zp8, env=Win64 (32b run,appending), ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if defined(_M_IA64) || defined(_M_AXP64)

#ifdef __cplusplus
extern "C"{
#endif 


#include <rpc.h>
#include <rpcndr.h>

#ifdef _MIDL_USE_GUIDDEF_

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)

#else // !_MIDL_USE_GUIDDEF_

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}

#endif !_MIDL_USE_GUIDDEF_

MIDL_DEFINE_GUID(IID, IID_IExplode,0x141DBAF0,0x55FB,0x11D1,0xB8,0x3E,0x00,0xA0,0xC9,0x33,0xBE,0x86);


MIDL_DEFINE_GUID(IID, IID_ICrShatter,0x63500AE1,0x0858,0x11D2,0x8C,0xE4,0x00,0xC0,0x4F,0x8E,0xCB,0x10);


MIDL_DEFINE_GUID(IID, IID_IDXTBlackHole,0xC3853C21,0x3F2E,0x11D2,0x99,0x00,0x00,0x00,0xF8,0x03,0xFF,0x7A);


MIDL_DEFINE_GUID(IID, IID_IDXTRoll,0x78F30B81,0x48AA,0x11D2,0x99,0x00,0x00,0x00,0xF8,0x03,0xFF,0x7A);


MIDL_DEFINE_GUID(IID, IID_IDXTSpin,0x3D2807C1,0x43DE,0x11D2,0x99,0x00,0x00,0x00,0xF8,0x03,0xFF,0x7A);


MIDL_DEFINE_GUID(IID, IID_IRipple,0x6DA4A05E,0x8E9E,0x11D1,0x90,0x4E,0x00,0xC0,0x4F,0xD9,0x18,0x9D);


MIDL_DEFINE_GUID(IID, IID_IHeightField,0x0492170A,0xB159,0x11d1,0x92,0x07,0x00,0x00,0xF8,0x75,0x8E,0x66);


MIDL_DEFINE_GUID(IID, IID_IDXTMetaStream,0x48654BC0,0xE51F,0x11D1,0xAA,0x1C,0x00,0x60,0x08,0x95,0xFB,0x99);


MIDL_DEFINE_GUID(IID, IID_IDXTText3D,0x50C4B592,0x7E8D,0x11d2,0x9B,0x4E,0x00,0xA0,0xC9,0x69,0x7C,0xD0);


MIDL_DEFINE_GUID(IID, IID_IDXTShapes,0x8241F013,0x84D3,0x11d2,0x97,0xE6,0x00,0x00,0xF8,0x03,0xFF,0x7A);


MIDL_DEFINE_GUID(IID, LIBID_DXTMSFT3Lib,0xE4BBA4C0,0x69B7,0x11d2,0x83,0x2D,0x00,0x00,0xF8,0x1F,0x59,0x95);


MIDL_DEFINE_GUID(CLSID, CLSID_Explode,0x141DBAF1,0x55FB,0x11D1,0xB8,0x3E,0x00,0xA0,0xC9,0x33,0xBE,0x86);


MIDL_DEFINE_GUID(CLSID, CLSID_ExplodeProp,0xC53059E1,0xE6E3,0x11d1,0xBA,0x12,0x00,0xC0,0x4F,0xB6,0xBD,0x36);


MIDL_DEFINE_GUID(CLSID, CLSID_Ripple,0x945F5842,0x3A8D,0x11D1,0x90,0x37,0x00,0xC0,0x4F,0xD9,0x18,0x9D);


MIDL_DEFINE_GUID(CLSID, CLSID_RipProp,0x945F5843,0x3A8D,0x11D1,0x90,0x37,0x00,0xC0,0x4F,0xD9,0x18,0x9D);


MIDL_DEFINE_GUID(CLSID, CLSID_HeightField,0x04921709,0xB159,0x11d1,0x92,0x07,0x00,0x00,0xF8,0x75,0x8E,0x66);


MIDL_DEFINE_GUID(CLSID, CLSID_HtFieldProp,0x7A8402E3,0xFBD6,0x11D1,0xB5,0xE0,0x00,0xAA,0x00,0x3B,0x60,0x61);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTMetaStream,0x60A0C080,0xE505,0x11D1,0xAA,0x1C,0x00,0x60,0x08,0x95,0xFB,0x99);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTMetaStreamProp,0xE3D77340,0xE505,0x11D1,0xAA,0x1C,0x00,0x60,0x08,0x95,0xFB,0x99);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTText3D,0xD56F34F2,0x7E89,0x11d2,0x9B,0x4E,0x00,0xA0,0xC9,0x69,0x7C,0xD0);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTText3DPP,0x50C4B593,0x7E8D,0x11d2,0x9B,0x4E,0x00,0xA0,0xC9,0x69,0x7C,0xD0);


MIDL_DEFINE_GUID(CLSID, CLSID_CrShatter,0x63500AE2,0x0858,0x11D2,0x8C,0xE4,0x00,0xC0,0x4F,0x8E,0xCB,0x10);


MIDL_DEFINE_GUID(CLSID, CLSID_CrShatterPP,0x99275F01,0x102E,0x11d2,0x8B,0x82,0x00,0xA0,0xC9,0x3C,0x09,0xB2);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTBlackHole,0xC3853C22,0x3F2E,0x11D2,0x99,0x00,0x00,0x00,0xF8,0x03,0xFF,0x7A);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTBlackHolePP,0xC3853C23,0x3F2E,0x11D2,0x99,0x00,0x00,0x00,0xF8,0x03,0xFF,0x7A);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTRoll,0x78F30B82,0x48AA,0x11D2,0x99,0x00,0x00,0x00,0xF8,0x03,0xFF,0x7A);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTRollPP,0x78F30B83,0x48AA,0x11D2,0x99,0x00,0x00,0x00,0xF8,0x03,0xFF,0x7A);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTSpin,0x3D2807C2,0x43DE,0x11D2,0x99,0x00,0x00,0x00,0xF8,0x03,0xFF,0x7A);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTSpinPP,0x3D2807C3,0x43DE,0x11D2,0x99,0x00,0x00,0x00,0xF8,0x03,0xFF,0x7A);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTShapes,0x8241F015,0x84D3,0x11d2,0x97,0xE6,0x00,0x00,0xF8,0x03,0xFF,0x7A);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTShapesPP,0x8241F016,0x84D3,0x11d2,0x97,0xE6,0x00,0x00,0xF8,0x03,0xFF,0x7A);

#undef MIDL_DEFINE_GUID

#ifdef __cplusplus
}
#endif



#endif /* defined(_M_IA64) || defined(_M_AXP64)*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\extinc\dxtmsft3.h ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 5.03.0285 */
/* Compiler settings for dxtmsft3.idl:
    Oicf (OptLev=i2), W0, Zp8, env=Win32 (32b run), ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __dxtmsft3_h__
#define __dxtmsft3_h__

/* Forward Declarations */ 

#ifndef __IExplode_FWD_DEFINED__
#define __IExplode_FWD_DEFINED__
typedef interface IExplode IExplode;
#endif 	/* __IExplode_FWD_DEFINED__ */


#ifndef __ICrShatter_FWD_DEFINED__
#define __ICrShatter_FWD_DEFINED__
typedef interface ICrShatter ICrShatter;
#endif 	/* __ICrShatter_FWD_DEFINED__ */


#ifndef __IDXTBlackHole_FWD_DEFINED__
#define __IDXTBlackHole_FWD_DEFINED__
typedef interface IDXTBlackHole IDXTBlackHole;
#endif 	/* __IDXTBlackHole_FWD_DEFINED__ */


#ifndef __IDXTRoll_FWD_DEFINED__
#define __IDXTRoll_FWD_DEFINED__
typedef interface IDXTRoll IDXTRoll;
#endif 	/* __IDXTRoll_FWD_DEFINED__ */


#ifndef __IDXTSpin_FWD_DEFINED__
#define __IDXTSpin_FWD_DEFINED__
typedef interface IDXTSpin IDXTSpin;
#endif 	/* __IDXTSpin_FWD_DEFINED__ */


#ifndef __IRipple_FWD_DEFINED__
#define __IRipple_FWD_DEFINED__
typedef interface IRipple IRipple;
#endif 	/* __IRipple_FWD_DEFINED__ */


#ifndef __IHeightField_FWD_DEFINED__
#define __IHeightField_FWD_DEFINED__
typedef interface IHeightField IHeightField;
#endif 	/* __IHeightField_FWD_DEFINED__ */


#ifndef __IDXTMetaStream_FWD_DEFINED__
#define __IDXTMetaStream_FWD_DEFINED__
typedef interface IDXTMetaStream IDXTMetaStream;
#endif 	/* __IDXTMetaStream_FWD_DEFINED__ */


#ifndef __IDXTText3D_FWD_DEFINED__
#define __IDXTText3D_FWD_DEFINED__
typedef interface IDXTText3D IDXTText3D;
#endif 	/* __IDXTText3D_FWD_DEFINED__ */


#ifndef __IDXTShapes_FWD_DEFINED__
#define __IDXTShapes_FWD_DEFINED__
typedef interface IDXTShapes IDXTShapes;
#endif 	/* __IDXTShapes_FWD_DEFINED__ */


#ifndef __Explode_FWD_DEFINED__
#define __Explode_FWD_DEFINED__

#ifdef __cplusplus
typedef class Explode Explode;
#else
typedef struct Explode Explode;
#endif /* __cplusplus */

#endif 	/* __Explode_FWD_DEFINED__ */


#ifndef __ExplodeProp_FWD_DEFINED__
#define __ExplodeProp_FWD_DEFINED__

#ifdef __cplusplus
typedef class ExplodeProp ExplodeProp;
#else
typedef struct ExplodeProp ExplodeProp;
#endif /* __cplusplus */

#endif 	/* __ExplodeProp_FWD_DEFINED__ */


#ifndef __Ripple_FWD_DEFINED__
#define __Ripple_FWD_DEFINED__

#ifdef __cplusplus
typedef class Ripple Ripple;
#else
typedef struct Ripple Ripple;
#endif /* __cplusplus */

#endif 	/* __Ripple_FWD_DEFINED__ */


#ifndef __RipProp_FWD_DEFINED__
#define __RipProp_FWD_DEFINED__

#ifdef __cplusplus
typedef class RipProp RipProp;
#else
typedef struct RipProp RipProp;
#endif /* __cplusplus */

#endif 	/* __RipProp_FWD_DEFINED__ */


#ifndef __HeightField_FWD_DEFINED__
#define __HeightField_FWD_DEFINED__

#ifdef __cplusplus
typedef class HeightField HeightField;
#else
typedef struct HeightField HeightField;
#endif /* __cplusplus */

#endif 	/* __HeightField_FWD_DEFINED__ */


#ifndef __HtFieldProp_FWD_DEFINED__
#define __HtFieldProp_FWD_DEFINED__

#ifdef __cplusplus
typedef class HtFieldProp HtFieldProp;
#else
typedef struct HtFieldProp HtFieldProp;
#endif /* __cplusplus */

#endif 	/* __HtFieldProp_FWD_DEFINED__ */


#ifndef __DXTMetaStream_FWD_DEFINED__
#define __DXTMetaStream_FWD_DEFINED__

#ifdef __cplusplus
typedef class DXTMetaStream DXTMetaStream;
#else
typedef struct DXTMetaStream DXTMetaStream;
#endif /* __cplusplus */

#endif 	/* __DXTMetaStream_FWD_DEFINED__ */


#ifndef __DXTMetaStreamProp_FWD_DEFINED__
#define __DXTMetaStreamProp_FWD_DEFINED__

#ifdef __cplusplus
typedef class DXTMetaStreamProp DXTMetaStreamProp;
#else
typedef struct DXTMetaStreamProp DXTMetaStreamProp;
#endif /* __cplusplus */

#endif 	/* __DXTMetaStreamProp_FWD_DEFINED__ */


#ifndef __DXTText3D_FWD_DEFINED__
#define __DXTText3D_FWD_DEFINED__

#ifdef __cplusplus
typedef class DXTText3D DXTText3D;
#else
typedef struct DXTText3D DXTText3D;
#endif /* __cplusplus */

#endif 	/* __DXTText3D_FWD_DEFINED__ */


#ifndef __DXTText3DPP_FWD_DEFINED__
#define __DXTText3DPP_FWD_DEFINED__

#ifdef __cplusplus
typedef class DXTText3DPP DXTText3DPP;
#else
typedef struct DXTText3DPP DXTText3DPP;
#endif /* __cplusplus */

#endif 	/* __DXTText3DPP_FWD_DEFINED__ */


#ifndef __CrShatter_FWD_DEFINED__
#define __CrShatter_FWD_DEFINED__

#ifdef __cplusplus
typedef class CrShatter CrShatter;
#else
typedef struct CrShatter CrShatter;
#endif /* __cplusplus */

#endif 	/* __CrShatter_FWD_DEFINED__ */


#ifndef __CrShatterPP_FWD_DEFINED__
#define __CrShatterPP_FWD_DEFINED__

#ifdef __cplusplus
typedef class CrShatterPP CrShatterPP;
#else
typedef struct CrShatterPP CrShatterPP;
#endif /* __cplusplus */

#endif 	/* __CrShatterPP_FWD_DEFINED__ */


#ifndef __DXTBlackHole_FWD_DEFINED__
#define __DXTBlackHole_FWD_DEFINED__

#ifdef __cplusplus
typedef class DXTBlackHole DXTBlackHole;
#else
typedef struct DXTBlackHole DXTBlackHole;
#endif /* __cplusplus */

#endif 	/* __DXTBlackHole_FWD_DEFINED__ */


#ifndef __DXTBlackHolePP_FWD_DEFINED__
#define __DXTBlackHolePP_FWD_DEFINED__

#ifdef __cplusplus
typedef class DXTBlackHolePP DXTBlackHolePP;
#else
typedef struct DXTBlackHolePP DXTBlackHolePP;
#endif /* __cplusplus */

#endif 	/* __DXTBlackHolePP_FWD_DEFINED__ */


#ifndef __DXTRoll_FWD_DEFINED__
#define __DXTRoll_FWD_DEFINED__

#ifdef __cplusplus
typedef class DXTRoll DXTRoll;
#else
typedef struct DXTRoll DXTRoll;
#endif /* __cplusplus */

#endif 	/* __DXTRoll_FWD_DEFINED__ */


#ifndef __DXTRollPP_FWD_DEFINED__
#define __DXTRollPP_FWD_DEFINED__

#ifdef __cplusplus
typedef class DXTRollPP DXTRollPP;
#else
typedef struct DXTRollPP DXTRollPP;
#endif /* __cplusplus */

#endif 	/* __DXTRollPP_FWD_DEFINED__ */


#ifndef __DXTSpin_FWD_DEFINED__
#define __DXTSpin_FWD_DEFINED__

#ifdef __cplusplus
typedef class DXTSpin DXTSpin;
#else
typedef struct DXTSpin DXTSpin;
#endif /* __cplusplus */

#endif 	/* __DXTSpin_FWD_DEFINED__ */


#ifndef __DXTSpinPP_FWD_DEFINED__
#define __DXTSpinPP_FWD_DEFINED__

#ifdef __cplusplus
typedef class DXTSpinPP DXTSpinPP;
#else
typedef struct DXTSpinPP DXTSpinPP;
#endif /* __cplusplus */

#endif 	/* __DXTSpinPP_FWD_DEFINED__ */


#ifndef __DXTShapes_FWD_DEFINED__
#define __DXTShapes_FWD_DEFINED__

#ifdef __cplusplus
typedef class DXTShapes DXTShapes;
#else
typedef struct DXTShapes DXTShapes;
#endif /* __cplusplus */

#endif 	/* __DXTShapes_FWD_DEFINED__ */


#ifndef __DXTShapesPP_FWD_DEFINED__
#define __DXTShapesPP_FWD_DEFINED__

#ifdef __cplusplus
typedef class DXTShapesPP DXTShapesPP;
#else
typedef struct DXTShapesPP DXTShapesPP;
#endif /* __cplusplus */

#endif 	/* __DXTShapesPP_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"
#include "dxtrans.h"

#ifdef __cplusplus
extern "C"{
#endif 

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

/* interface __MIDL_itf_dxtmsft3_0000 */
/* [local] */ 

typedef 
enum EXPLODEDISPID
    {	DISPID_Explode_Tumble	= DISPID_DXE_NEXT_ID,
	DISPID_Explode_MaxRotations	= DISPID_Explode_Tumble + 1,
	DISPID_Explode_FinalVelocity	= DISPID_Explode_MaxRotations + 1,
	DISPID_Explode_PositionJump	= DISPID_Explode_FinalVelocity + 1,
	DISPID_Explode_DecayTime	= DISPID_Explode_PositionJump + 1
    }	EXPLODEDISPID;



extern RPC_IF_HANDLE __MIDL_itf_dxtmsft3_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_dxtmsft3_0000_v0_0_s_ifspec;

#ifndef __IExplode_INTERFACE_DEFINED__
#define __IExplode_INTERFACE_DEFINED__

/* interface IExplode */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IExplode;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("141DBAF0-55FB-11D1-B83E-00A0C933BE86")
    IExplode : public IDXEffect
    {
    public:
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Tumble( 
            /* [in] */ BOOL newVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Tumble( 
            /* [retval][out] */ BOOL __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_MaxRotations( 
            /* [in] */ LONG newVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_MaxRotations( 
            /* [retval][out] */ LONG __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_FinalVelocity( 
            /* [in] */ float newVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_FinalVelocity( 
            /* [retval][out] */ float __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_PositionJump( 
            /* [in] */ float newVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_PositionJump( 
            /* [retval][out] */ float __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_DecayTime( 
            /* [in] */ float newVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_DecayTime( 
            /* [retval][out] */ float __RPC_FAR *pVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IExplodeVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IExplode __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IExplode __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IExplode __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IExplode __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IExplode __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IExplode __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IExplode __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Capabilities )( 
            IExplode __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Progress )( 
            IExplode __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Progress )( 
            IExplode __RPC_FAR * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_StepResolution )( 
            IExplode __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Duration )( 
            IExplode __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Duration )( 
            IExplode __RPC_FAR * This,
            /* [in] */ float newVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Tumble )( 
            IExplode __RPC_FAR * This,
            /* [in] */ BOOL newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Tumble )( 
            IExplode __RPC_FAR * This,
            /* [retval][out] */ BOOL __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_MaxRotations )( 
            IExplode __RPC_FAR * This,
            /* [in] */ LONG newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_MaxRotations )( 
            IExplode __RPC_FAR * This,
            /* [retval][out] */ LONG __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_FinalVelocity )( 
            IExplode __RPC_FAR * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_FinalVelocity )( 
            IExplode __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_PositionJump )( 
            IExplode __RPC_FAR * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_PositionJump )( 
            IExplode __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_DecayTime )( 
            IExplode __RPC_FAR * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_DecayTime )( 
            IExplode __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        END_INTERFACE
    } IExplodeVtbl;

    interface IExplode
    {
        CONST_VTBL struct IExplodeVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IExplode_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IExplode_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IExplode_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IExplode_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IExplode_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IExplode_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IExplode_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IExplode_get_Capabilities(This,pVal)	\
    (This)->lpVtbl -> get_Capabilities(This,pVal)

#define IExplode_get_Progress(This,pVal)	\
    (This)->lpVtbl -> get_Progress(This,pVal)

#define IExplode_put_Progress(This,newVal)	\
    (This)->lpVtbl -> put_Progress(This,newVal)

#define IExplode_get_StepResolution(This,pVal)	\
    (This)->lpVtbl -> get_StepResolution(This,pVal)

#define IExplode_get_Duration(This,pVal)	\
    (This)->lpVtbl -> get_Duration(This,pVal)

#define IExplode_put_Duration(This,newVal)	\
    (This)->lpVtbl -> put_Duration(This,newVal)


#define IExplode_put_Tumble(This,newVal)	\
    (This)->lpVtbl -> put_Tumble(This,newVal)

#define IExplode_get_Tumble(This,pVal)	\
    (This)->lpVtbl -> get_Tumble(This,pVal)

#define IExplode_put_MaxRotations(This,newVal)	\
    (This)->lpVtbl -> put_MaxRotations(This,newVal)

#define IExplode_get_MaxRotations(This,pVal)	\
    (This)->lpVtbl -> get_MaxRotations(This,pVal)

#define IExplode_put_FinalVelocity(This,newVal)	\
    (This)->lpVtbl -> put_FinalVelocity(This,newVal)

#define IExplode_get_FinalVelocity(This,pVal)	\
    (This)->lpVtbl -> get_FinalVelocity(This,pVal)

#define IExplode_put_PositionJump(This,newVal)	\
    (This)->lpVtbl -> put_PositionJump(This,newVal)

#define IExplode_get_PositionJump(This,pVal)	\
    (This)->lpVtbl -> get_PositionJump(This,pVal)

#define IExplode_put_DecayTime(This,newVal)	\
    (This)->lpVtbl -> put_DecayTime(This,newVal)

#define IExplode_get_DecayTime(This,pVal)	\
    (This)->lpVtbl -> get_DecayTime(This,pVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propput] */ HRESULT STDMETHODCALLTYPE IExplode_put_Tumble_Proxy( 
    IExplode __RPC_FAR * This,
    /* [in] */ BOOL newVal);


void __RPC_STUB IExplode_put_Tumble_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IExplode_get_Tumble_Proxy( 
    IExplode __RPC_FAR * This,
    /* [retval][out] */ BOOL __RPC_FAR *pVal);


void __RPC_STUB IExplode_get_Tumble_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IExplode_put_MaxRotations_Proxy( 
    IExplode __RPC_FAR * This,
    /* [in] */ LONG newVal);


void __RPC_STUB IExplode_put_MaxRotations_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IExplode_get_MaxRotations_Proxy( 
    IExplode __RPC_FAR * This,
    /* [retval][out] */ LONG __RPC_FAR *pVal);


void __RPC_STUB IExplode_get_MaxRotations_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IExplode_put_FinalVelocity_Proxy( 
    IExplode __RPC_FAR * This,
    /* [in] */ float newVal);


void __RPC_STUB IExplode_put_FinalVelocity_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IExplode_get_FinalVelocity_Proxy( 
    IExplode __RPC_FAR * This,
    /* [retval][out] */ float __RPC_FAR *pVal);


void __RPC_STUB IExplode_get_FinalVelocity_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IExplode_put_PositionJump_Proxy( 
    IExplode __RPC_FAR * This,
    /* [in] */ float newVal);


void __RPC_STUB IExplode_put_PositionJump_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IExplode_get_PositionJump_Proxy( 
    IExplode __RPC_FAR * This,
    /* [retval][out] */ float __RPC_FAR *pVal);


void __RPC_STUB IExplode_get_PositionJump_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IExplode_put_DecayTime_Proxy( 
    IExplode __RPC_FAR * This,
    /* [in] */ float newVal);


void __RPC_STUB IExplode_put_DecayTime_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IExplode_get_DecayTime_Proxy( 
    IExplode __RPC_FAR * This,
    /* [retval][out] */ float __RPC_FAR *pVal);


void __RPC_STUB IExplode_get_DecayTime_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IExplode_INTERFACE_DEFINED__ */


#ifndef __ICrShatter_INTERFACE_DEFINED__
#define __ICrShatter_INTERFACE_DEFINED__

/* interface ICrShatter */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_ICrShatter;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("63500AE1-0858-11D2-8CE4-00C04F8ECB10")
    ICrShatter : public IDXEffect
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_seed( 
            /* [retval][out] */ long __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_seed( 
            /* [in] */ long newVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_maxShards( 
            /* [retval][out] */ long __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_maxShards( 
            /* [in] */ long newVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_depth( 
            /* [retval][out] */ float __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_depth( 
            /* [in] */ float newVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_backColor( 
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_backColor( 
            /* [in] */ BSTR newVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_evacuateX( 
            /* [retval][out] */ short __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_evacuateX( 
            /* [in] */ short newVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_evacuateY( 
            /* [retval][out] */ short __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_evacuateY( 
            /* [in] */ short newVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_evacuateZ( 
            /* [retval][out] */ short __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_evacuateZ( 
            /* [in] */ short newVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_evacuateDeltaX( 
            /* [retval][out] */ short __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_evacuateDeltaX( 
            /* [in] */ short newVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_evacuateDeltaY( 
            /* [retval][out] */ short __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_evacuateDeltaY( 
            /* [in] */ short newVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_evacuateDeltaZ( 
            /* [retval][out] */ short __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_evacuateDeltaZ( 
            /* [in] */ short newVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICrShatterVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ICrShatter __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ICrShatter __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ICrShatter __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            ICrShatter __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            ICrShatter __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            ICrShatter __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            ICrShatter __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Capabilities )( 
            ICrShatter __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Progress )( 
            ICrShatter __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Progress )( 
            ICrShatter __RPC_FAR * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_StepResolution )( 
            ICrShatter __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Duration )( 
            ICrShatter __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Duration )( 
            ICrShatter __RPC_FAR * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_seed )( 
            ICrShatter __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_seed )( 
            ICrShatter __RPC_FAR * This,
            /* [in] */ long newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_maxShards )( 
            ICrShatter __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_maxShards )( 
            ICrShatter __RPC_FAR * This,
            /* [in] */ long newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_depth )( 
            ICrShatter __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_depth )( 
            ICrShatter __RPC_FAR * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_backColor )( 
            ICrShatter __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_backColor )( 
            ICrShatter __RPC_FAR * This,
            /* [in] */ BSTR newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_evacuateX )( 
            ICrShatter __RPC_FAR * This,
            /* [retval][out] */ short __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_evacuateX )( 
            ICrShatter __RPC_FAR * This,
            /* [in] */ short newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_evacuateY )( 
            ICrShatter __RPC_FAR * This,
            /* [retval][out] */ short __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_evacuateY )( 
            ICrShatter __RPC_FAR * This,
            /* [in] */ short newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_evacuateZ )( 
            ICrShatter __RPC_FAR * This,
            /* [retval][out] */ short __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_evacuateZ )( 
            ICrShatter __RPC_FAR * This,
            /* [in] */ short newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_evacuateDeltaX )( 
            ICrShatter __RPC_FAR * This,
            /* [retval][out] */ short __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_evacuateDeltaX )( 
            ICrShatter __RPC_FAR * This,
            /* [in] */ short newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_evacuateDeltaY )( 
            ICrShatter __RPC_FAR * This,
            /* [retval][out] */ short __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_evacuateDeltaY )( 
            ICrShatter __RPC_FAR * This,
            /* [in] */ short newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_evacuateDeltaZ )( 
            ICrShatter __RPC_FAR * This,
            /* [retval][out] */ short __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_evacuateDeltaZ )( 
            ICrShatter __RPC_FAR * This,
            /* [in] */ short newVal);
        
        END_INTERFACE
    } ICrShatterVtbl;

    interface ICrShatter
    {
        CONST_VTBL struct ICrShatterVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICrShatter_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICrShatter_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICrShatter_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICrShatter_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ICrShatter_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ICrShatter_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ICrShatter_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ICrShatter_get_Capabilities(This,pVal)	\
    (This)->lpVtbl -> get_Capabilities(This,pVal)

#define ICrShatter_get_Progress(This,pVal)	\
    (This)->lpVtbl -> get_Progress(This,pVal)

#define ICrShatter_put_Progress(This,newVal)	\
    (This)->lpVtbl -> put_Progress(This,newVal)

#define ICrShatter_get_StepResolution(This,pVal)	\
    (This)->lpVtbl -> get_StepResolution(This,pVal)

#define ICrShatter_get_Duration(This,pVal)	\
    (This)->lpVtbl -> get_Duration(This,pVal)

#define ICrShatter_put_Duration(This,newVal)	\
    (This)->lpVtbl -> put_Duration(This,newVal)


#define ICrShatter_get_seed(This,pVal)	\
    (This)->lpVtbl -> get_seed(This,pVal)

#define ICrShatter_put_seed(This,newVal)	\
    (This)->lpVtbl -> put_seed(This,newVal)

#define ICrShatter_get_maxShards(This,pVal)	\
    (This)->lpVtbl -> get_maxShards(This,pVal)

#define ICrShatter_put_maxShards(This,newVal)	\
    (This)->lpVtbl -> put_maxShards(This,newVal)

#define ICrShatter_get_depth(This,pVal)	\
    (This)->lpVtbl -> get_depth(This,pVal)

#define ICrShatter_put_depth(This,newVal)	\
    (This)->lpVtbl -> put_depth(This,newVal)

#define ICrShatter_get_backColor(This,pVal)	\
    (This)->lpVtbl -> get_backColor(This,pVal)

#define ICrShatter_put_backColor(This,newVal)	\
    (This)->lpVtbl -> put_backColor(This,newVal)

#define ICrShatter_get_evacuateX(This,pVal)	\
    (This)->lpVtbl -> get_evacuateX(This,pVal)

#define ICrShatter_put_evacuateX(This,newVal)	\
    (This)->lpVtbl -> put_evacuateX(This,newVal)

#define ICrShatter_get_evacuateY(This,pVal)	\
    (This)->lpVtbl -> get_evacuateY(This,pVal)

#define ICrShatter_put_evacuateY(This,newVal)	\
    (This)->lpVtbl -> put_evacuateY(This,newVal)

#define ICrShatter_get_evacuateZ(This,pVal)	\
    (This)->lpVtbl -> get_evacuateZ(This,pVal)

#define ICrShatter_put_evacuateZ(This,newVal)	\
    (This)->lpVtbl -> put_evacuateZ(This,newVal)

#define ICrShatter_get_evacuateDeltaX(This,pVal)	\
    (This)->lpVtbl -> get_evacuateDeltaX(This,pVal)

#define ICrShatter_put_evacuateDeltaX(This,newVal)	\
    (This)->lpVtbl -> put_evacuateDeltaX(This,newVal)

#define ICrShatter_get_evacuateDeltaY(This,pVal)	\
    (This)->lpVtbl -> get_evacuateDeltaY(This,pVal)

#define ICrShatter_put_evacuateDeltaY(This,newVal)	\
    (This)->lpVtbl -> put_evacuateDeltaY(This,newVal)

#define ICrShatter_get_evacuateDeltaZ(This,pVal)	\
    (This)->lpVtbl -> get_evacuateDeltaZ(This,pVal)

#define ICrShatter_put_evacuateDeltaZ(This,newVal)	\
    (This)->lpVtbl -> put_evacuateDeltaZ(This,newVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE ICrShatter_get_seed_Proxy( 
    ICrShatter __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pVal);


void __RPC_STUB ICrShatter_get_seed_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE ICrShatter_put_seed_Proxy( 
    ICrShatter __RPC_FAR * This,
    /* [in] */ long newVal);


void __RPC_STUB ICrShatter_put_seed_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE ICrShatter_get_maxShards_Proxy( 
    ICrShatter __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pVal);


void __RPC_STUB ICrShatter_get_maxShards_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE ICrShatter_put_maxShards_Proxy( 
    ICrShatter __RPC_FAR * This,
    /* [in] */ long newVal);


void __RPC_STUB ICrShatter_put_maxShards_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE ICrShatter_get_depth_Proxy( 
    ICrShatter __RPC_FAR * This,
    /* [retval][out] */ float __RPC_FAR *pVal);


void __RPC_STUB ICrShatter_get_depth_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE ICrShatter_put_depth_Proxy( 
    ICrShatter __RPC_FAR * This,
    /* [in] */ float newVal);


void __RPC_STUB ICrShatter_put_depth_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE ICrShatter_get_backColor_Proxy( 
    ICrShatter __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB ICrShatter_get_backColor_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE ICrShatter_put_backColor_Proxy( 
    ICrShatter __RPC_FAR * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB ICrShatter_put_backColor_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE ICrShatter_get_evacuateX_Proxy( 
    ICrShatter __RPC_FAR * This,
    /* [retval][out] */ short __RPC_FAR *pVal);


void __RPC_STUB ICrShatter_get_evacuateX_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE ICrShatter_put_evacuateX_Proxy( 
    ICrShatter __RPC_FAR * This,
    /* [in] */ short newVal);


void __RPC_STUB ICrShatter_put_evacuateX_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE ICrShatter_get_evacuateY_Proxy( 
    ICrShatter __RPC_FAR * This,
    /* [retval][out] */ short __RPC_FAR *pVal);


void __RPC_STUB ICrShatter_get_evacuateY_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE ICrShatter_put_evacuateY_Proxy( 
    ICrShatter __RPC_FAR * This,
    /* [in] */ short newVal);


void __RPC_STUB ICrShatter_put_evacuateY_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE ICrShatter_get_evacuateZ_Proxy( 
    ICrShatter __RPC_FAR * This,
    /* [retval][out] */ short __RPC_FAR *pVal);


void __RPC_STUB ICrShatter_get_evacuateZ_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE ICrShatter_put_evacuateZ_Proxy( 
    ICrShatter __RPC_FAR * This,
    /* [in] */ short newVal);


void __RPC_STUB ICrShatter_put_evacuateZ_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE ICrShatter_get_evacuateDeltaX_Proxy( 
    ICrShatter __RPC_FAR * This,
    /* [retval][out] */ short __RPC_FAR *pVal);


void __RPC_STUB ICrShatter_get_evacuateDeltaX_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE ICrShatter_put_evacuateDeltaX_Proxy( 
    ICrShatter __RPC_FAR * This,
    /* [in] */ short newVal);


void __RPC_STUB ICrShatter_put_evacuateDeltaX_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE ICrShatter_get_evacuateDeltaY_Proxy( 
    ICrShatter __RPC_FAR * This,
    /* [retval][out] */ short __RPC_FAR *pVal);


void __RPC_STUB ICrShatter_get_evacuateDeltaY_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE ICrShatter_put_evacuateDeltaY_Proxy( 
    ICrShatter __RPC_FAR * This,
    /* [in] */ short newVal);


void __RPC_STUB ICrShatter_put_evacuateDeltaY_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE ICrShatter_get_evacuateDeltaZ_Proxy( 
    ICrShatter __RPC_FAR * This,
    /* [retval][out] */ short __RPC_FAR *pVal);


void __RPC_STUB ICrShatter_get_evacuateDeltaZ_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE ICrShatter_put_evacuateDeltaZ_Proxy( 
    ICrShatter __RPC_FAR * This,
    /* [in] */ short newVal);


void __RPC_STUB ICrShatter_put_evacuateDeltaZ_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICrShatter_INTERFACE_DEFINED__ */


#ifndef __IDXTBlackHole_INTERFACE_DEFINED__
#define __IDXTBlackHole_INTERFACE_DEFINED__

/* interface IDXTBlackHole */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IDXTBlackHole;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("C3853C21-3F2E-11D2-9900-0000F803FF7A")
    IDXTBlackHole : public IDXEffect
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_HoleX( 
            /* [retval][out] */ float __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_HoleX( 
            /* [in] */ float newVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_HoleY( 
            /* [retval][out] */ float __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_HoleY( 
            /* [in] */ float newVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_HoleZ( 
            /* [retval][out] */ float __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_HoleZ( 
            /* [in] */ float newVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_StretchPercent( 
            /* [retval][out] */ float __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_StretchPercent( 
            /* [in] */ float newVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_FallX( 
            /* [retval][out] */ float __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_FallX( 
            /* [in] */ float newVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_FallY( 
            /* [retval][out] */ float __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_FallY( 
            /* [in] */ float newVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_FallZ( 
            /* [retval][out] */ float __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_FallZ( 
            /* [in] */ float newVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_SpiralX( 
            /* [retval][out] */ float __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_SpiralX( 
            /* [in] */ float newVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_SpiralY( 
            /* [retval][out] */ float __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_SpiralY( 
            /* [in] */ float newVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_SpiralZ( 
            /* [retval][out] */ float __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_SpiralZ( 
            /* [in] */ float newVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Rotations( 
            /* [retval][out] */ float __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Rotations( 
            /* [in] */ float newVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Movement( 
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Movement( 
            /* [in] */ BSTR newVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDXTBlackHoleVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDXTBlackHole __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDXTBlackHole __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDXTBlackHole __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IDXTBlackHole __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IDXTBlackHole __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IDXTBlackHole __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IDXTBlackHole __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Capabilities )( 
            IDXTBlackHole __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Progress )( 
            IDXTBlackHole __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Progress )( 
            IDXTBlackHole __RPC_FAR * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_StepResolution )( 
            IDXTBlackHole __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Duration )( 
            IDXTBlackHole __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Duration )( 
            IDXTBlackHole __RPC_FAR * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_HoleX )( 
            IDXTBlackHole __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_HoleX )( 
            IDXTBlackHole __RPC_FAR * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_HoleY )( 
            IDXTBlackHole __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_HoleY )( 
            IDXTBlackHole __RPC_FAR * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_HoleZ )( 
            IDXTBlackHole __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_HoleZ )( 
            IDXTBlackHole __RPC_FAR * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_StretchPercent )( 
            IDXTBlackHole __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_StretchPercent )( 
            IDXTBlackHole __RPC_FAR * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_FallX )( 
            IDXTBlackHole __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_FallX )( 
            IDXTBlackHole __RPC_FAR * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_FallY )( 
            IDXTBlackHole __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_FallY )( 
            IDXTBlackHole __RPC_FAR * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_FallZ )( 
            IDXTBlackHole __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_FallZ )( 
            IDXTBlackHole __RPC_FAR * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_SpiralX )( 
            IDXTBlackHole __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_SpiralX )( 
            IDXTBlackHole __RPC_FAR * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_SpiralY )( 
            IDXTBlackHole __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_SpiralY )( 
            IDXTBlackHole __RPC_FAR * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_SpiralZ )( 
            IDXTBlackHole __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_SpiralZ )( 
            IDXTBlackHole __RPC_FAR * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Rotations )( 
            IDXTBlackHole __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Rotations )( 
            IDXTBlackHole __RPC_FAR * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Movement )( 
            IDXTBlackHole __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Movement )( 
            IDXTBlackHole __RPC_FAR * This,
            /* [in] */ BSTR newVal);
        
        END_INTERFACE
    } IDXTBlackHoleVtbl;

    interface IDXTBlackHole
    {
        CONST_VTBL struct IDXTBlackHoleVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDXTBlackHole_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDXTBlackHole_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDXTBlackHole_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDXTBlackHole_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IDXTBlackHole_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IDXTBlackHole_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IDXTBlackHole_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IDXTBlackHole_get_Capabilities(This,pVal)	\
    (This)->lpVtbl -> get_Capabilities(This,pVal)

#define IDXTBlackHole_get_Progress(This,pVal)	\
    (This)->lpVtbl -> get_Progress(This,pVal)

#define IDXTBlackHole_put_Progress(This,newVal)	\
    (This)->lpVtbl -> put_Progress(This,newVal)

#define IDXTBlackHole_get_StepResolution(This,pVal)	\
    (This)->lpVtbl -> get_StepResolution(This,pVal)

#define IDXTBlackHole_get_Duration(This,pVal)	\
    (This)->lpVtbl -> get_Duration(This,pVal)

#define IDXTBlackHole_put_Duration(This,newVal)	\
    (This)->lpVtbl -> put_Duration(This,newVal)


#define IDXTBlackHole_get_HoleX(This,pVal)	\
    (This)->lpVtbl -> get_HoleX(This,pVal)

#define IDXTBlackHole_put_HoleX(This,newVal)	\
    (This)->lpVtbl -> put_HoleX(This,newVal)

#define IDXTBlackHole_get_HoleY(This,pVal)	\
    (This)->lpVtbl -> get_HoleY(This,pVal)

#define IDXTBlackHole_put_HoleY(This,newVal)	\
    (This)->lpVtbl -> put_HoleY(This,newVal)

#define IDXTBlackHole_get_HoleZ(This,pVal)	\
    (This)->lpVtbl -> get_HoleZ(This,pVal)

#define IDXTBlackHole_put_HoleZ(This,newVal)	\
    (This)->lpVtbl -> put_HoleZ(This,newVal)

#define IDXTBlackHole_get_StretchPercent(This,pVal)	\
    (This)->lpVtbl -> get_StretchPercent(This,pVal)

#define IDXTBlackHole_put_StretchPercent(This,newVal)	\
    (This)->lpVtbl -> put_StretchPercent(This,newVal)

#define IDXTBlackHole_get_FallX(This,pVal)	\
    (This)->lpVtbl -> get_FallX(This,pVal)

#define IDXTBlackHole_put_FallX(This,newVal)	\
    (This)->lpVtbl -> put_FallX(This,newVal)

#define IDXTBlackHole_get_FallY(This,pVal)	\
    (This)->lpVtbl -> get_FallY(This,pVal)

#define IDXTBlackHole_put_FallY(This,newVal)	\
    (This)->lpVtbl -> put_FallY(This,newVal)

#define IDXTBlackHole_get_FallZ(This,pVal)	\
    (This)->lpVtbl -> get_FallZ(This,pVal)

#define IDXTBlackHole_put_FallZ(This,newVal)	\
    (This)->lpVtbl -> put_FallZ(This,newVal)

#define IDXTBlackHole_get_SpiralX(This,pVal)	\
    (This)->lpVtbl -> get_SpiralX(This,pVal)

#define IDXTBlackHole_put_SpiralX(This,newVal)	\
    (This)->lpVtbl -> put_SpiralX(This,newVal)

#define IDXTBlackHole_get_SpiralY(This,pVal)	\
    (This)->lpVtbl -> get_SpiralY(This,pVal)

#define IDXTBlackHole_put_SpiralY(This,newVal)	\
    (This)->lpVtbl -> put_SpiralY(This,newVal)

#define IDXTBlackHole_get_SpiralZ(This,pVal)	\
    (This)->lpVtbl -> get_SpiralZ(This,pVal)

#define IDXTBlackHole_put_SpiralZ(This,newVal)	\
    (This)->lpVtbl -> put_SpiralZ(This,newVal)

#define IDXTBlackHole_get_Rotations(This,pVal)	\
    (This)->lpVtbl -> get_Rotations(This,pVal)

#define IDXTBlackHole_put_Rotations(This,newVal)	\
    (This)->lpVtbl -> put_Rotations(This,newVal)

#define IDXTBlackHole_get_Movement(This,pVal)	\
    (This)->lpVtbl -> get_Movement(This,pVal)

#define IDXTBlackHole_put_Movement(This,newVal)	\
    (This)->lpVtbl -> put_Movement(This,newVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTBlackHole_get_HoleX_Proxy( 
    IDXTBlackHole __RPC_FAR * This,
    /* [retval][out] */ float __RPC_FAR *pVal);


void __RPC_STUB IDXTBlackHole_get_HoleX_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTBlackHole_put_HoleX_Proxy( 
    IDXTBlackHole __RPC_FAR * This,
    /* [in] */ float newVal);


void __RPC_STUB IDXTBlackHole_put_HoleX_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTBlackHole_get_HoleY_Proxy( 
    IDXTBlackHole __RPC_FAR * This,
    /* [retval][out] */ float __RPC_FAR *pVal);


void __RPC_STUB IDXTBlackHole_get_HoleY_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTBlackHole_put_HoleY_Proxy( 
    IDXTBlackHole __RPC_FAR * This,
    /* [in] */ float newVal);


void __RPC_STUB IDXTBlackHole_put_HoleY_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTBlackHole_get_HoleZ_Proxy( 
    IDXTBlackHole __RPC_FAR * This,
    /* [retval][out] */ float __RPC_FAR *pVal);


void __RPC_STUB IDXTBlackHole_get_HoleZ_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTBlackHole_put_HoleZ_Proxy( 
    IDXTBlackHole __RPC_FAR * This,
    /* [in] */ float newVal);


void __RPC_STUB IDXTBlackHole_put_HoleZ_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTBlackHole_get_StretchPercent_Proxy( 
    IDXTBlackHole __RPC_FAR * This,
    /* [retval][out] */ float __RPC_FAR *pVal);


void __RPC_STUB IDXTBlackHole_get_StretchPercent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTBlackHole_put_StretchPercent_Proxy( 
    IDXTBlackHole __RPC_FAR * This,
    /* [in] */ float newVal);


void __RPC_STUB IDXTBlackHole_put_StretchPercent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTBlackHole_get_FallX_Proxy( 
    IDXTBlackHole __RPC_FAR * This,
    /* [retval][out] */ float __RPC_FAR *pVal);


void __RPC_STUB IDXTBlackHole_get_FallX_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTBlackHole_put_FallX_Proxy( 
    IDXTBlackHole __RPC_FAR * This,
    /* [in] */ float newVal);


void __RPC_STUB IDXTBlackHole_put_FallX_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTBlackHole_get_FallY_Proxy( 
    IDXTBlackHole __RPC_FAR * This,
    /* [retval][out] */ float __RPC_FAR *pVal);


void __RPC_STUB IDXTBlackHole_get_FallY_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTBlackHole_put_FallY_Proxy( 
    IDXTBlackHole __RPC_FAR * This,
    /* [in] */ float newVal);


void __RPC_STUB IDXTBlackHole_put_FallY_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTBlackHole_get_FallZ_Proxy( 
    IDXTBlackHole __RPC_FAR * This,
    /* [retval][out] */ float __RPC_FAR *pVal);


void __RPC_STUB IDXTBlackHole_get_FallZ_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTBlackHole_put_FallZ_Proxy( 
    IDXTBlackHole __RPC_FAR * This,
    /* [in] */ float newVal);


void __RPC_STUB IDXTBlackHole_put_FallZ_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTBlackHole_get_SpiralX_Proxy( 
    IDXTBlackHole __RPC_FAR * This,
    /* [retval][out] */ float __RPC_FAR *pVal);


void __RPC_STUB IDXTBlackHole_get_SpiralX_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTBlackHole_put_SpiralX_Proxy( 
    IDXTBlackHole __RPC_FAR * This,
    /* [in] */ float newVal);


void __RPC_STUB IDXTBlackHole_put_SpiralX_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTBlackHole_get_SpiralY_Proxy( 
    IDXTBlackHole __RPC_FAR * This,
    /* [retval][out] */ float __RPC_FAR *pVal);


void __RPC_STUB IDXTBlackHole_get_SpiralY_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTBlackHole_put_SpiralY_Proxy( 
    IDXTBlackHole __RPC_FAR * This,
    /* [in] */ float newVal);


void __RPC_STUB IDXTBlackHole_put_SpiralY_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTBlackHole_get_SpiralZ_Proxy( 
    IDXTBlackHole __RPC_FAR * This,
    /* [retval][out] */ float __RPC_FAR *pVal);


void __RPC_STUB IDXTBlackHole_get_SpiralZ_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTBlackHole_put_SpiralZ_Proxy( 
    IDXTBlackHole __RPC_FAR * This,
    /* [in] */ float newVal);


void __RPC_STUB IDXTBlackHole_put_SpiralZ_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTBlackHole_get_Rotations_Proxy( 
    IDXTBlackHole __RPC_FAR * This,
    /* [retval][out] */ float __RPC_FAR *pVal);


void __RPC_STUB IDXTBlackHole_get_Rotations_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTBlackHole_put_Rotations_Proxy( 
    IDXTBlackHole __RPC_FAR * This,
    /* [in] */ float newVal);


void __RPC_STUB IDXTBlackHole_put_Rotations_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTBlackHole_get_Movement_Proxy( 
    IDXTBlackHole __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB IDXTBlackHole_get_Movement_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTBlackHole_put_Movement_Proxy( 
    IDXTBlackHole __RPC_FAR * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IDXTBlackHole_put_Movement_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDXTBlackHole_INTERFACE_DEFINED__ */


#ifndef __IDXTRoll_INTERFACE_DEFINED__
#define __IDXTRoll_INTERFACE_DEFINED__

/* interface IDXTRoll */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IDXTRoll;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("78F30B81-48AA-11D2-9900-0000F803FF7A")
    IDXTRoll : public IDXEffect
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_DirectionX( 
            /* [retval][out] */ float __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_DirectionX( 
            /* [in] */ float newVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_DirectionY( 
            /* [retval][out] */ float __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_DirectionY( 
            /* [in] */ float newVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Radius( 
            /* [retval][out] */ float __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Radius( 
            /* [in] */ float newVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDXTRollVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDXTRoll __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDXTRoll __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDXTRoll __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IDXTRoll __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IDXTRoll __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IDXTRoll __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IDXTRoll __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Capabilities )( 
            IDXTRoll __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Progress )( 
            IDXTRoll __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Progress )( 
            IDXTRoll __RPC_FAR * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_StepResolution )( 
            IDXTRoll __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Duration )( 
            IDXTRoll __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Duration )( 
            IDXTRoll __RPC_FAR * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_DirectionX )( 
            IDXTRoll __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_DirectionX )( 
            IDXTRoll __RPC_FAR * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_DirectionY )( 
            IDXTRoll __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_DirectionY )( 
            IDXTRoll __RPC_FAR * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Radius )( 
            IDXTRoll __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Radius )( 
            IDXTRoll __RPC_FAR * This,
            /* [in] */ float newVal);
        
        END_INTERFACE
    } IDXTRollVtbl;

    interface IDXTRoll
    {
        CONST_VTBL struct IDXTRollVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDXTRoll_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDXTRoll_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDXTRoll_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDXTRoll_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IDXTRoll_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IDXTRoll_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IDXTRoll_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IDXTRoll_get_Capabilities(This,pVal)	\
    (This)->lpVtbl -> get_Capabilities(This,pVal)

#define IDXTRoll_get_Progress(This,pVal)	\
    (This)->lpVtbl -> get_Progress(This,pVal)

#define IDXTRoll_put_Progress(This,newVal)	\
    (This)->lpVtbl -> put_Progress(This,newVal)

#define IDXTRoll_get_StepResolution(This,pVal)	\
    (This)->lpVtbl -> get_StepResolution(This,pVal)

#define IDXTRoll_get_Duration(This,pVal)	\
    (This)->lpVtbl -> get_Duration(This,pVal)

#define IDXTRoll_put_Duration(This,newVal)	\
    (This)->lpVtbl -> put_Duration(This,newVal)


#define IDXTRoll_get_DirectionX(This,pVal)	\
    (This)->lpVtbl -> get_DirectionX(This,pVal)

#define IDXTRoll_put_DirectionX(This,newVal)	\
    (This)->lpVtbl -> put_DirectionX(This,newVal)

#define IDXTRoll_get_DirectionY(This,pVal)	\
    (This)->lpVtbl -> get_DirectionY(This,pVal)

#define IDXTRoll_put_DirectionY(This,newVal)	\
    (This)->lpVtbl -> put_DirectionY(This,newVal)

#define IDXTRoll_get_Radius(This,pVal)	\
    (This)->lpVtbl -> get_Radius(This,pVal)

#define IDXTRoll_put_Radius(This,newVal)	\
    (This)->lpVtbl -> put_Radius(This,newVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTRoll_get_DirectionX_Proxy( 
    IDXTRoll __RPC_FAR * This,
    /* [retval][out] */ float __RPC_FAR *pVal);


void __RPC_STUB IDXTRoll_get_DirectionX_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTRoll_put_DirectionX_Proxy( 
    IDXTRoll __RPC_FAR * This,
    /* [in] */ float newVal);


void __RPC_STUB IDXTRoll_put_DirectionX_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTRoll_get_DirectionY_Proxy( 
    IDXTRoll __RPC_FAR * This,
    /* [retval][out] */ float __RPC_FAR *pVal);


void __RPC_STUB IDXTRoll_get_DirectionY_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTRoll_put_DirectionY_Proxy( 
    IDXTRoll __RPC_FAR * This,
    /* [in] */ float newVal);


void __RPC_STUB IDXTRoll_put_DirectionY_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTRoll_get_Radius_Proxy( 
    IDXTRoll __RPC_FAR * This,
    /* [retval][out] */ float __RPC_FAR *pVal);


void __RPC_STUB IDXTRoll_get_Radius_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTRoll_put_Radius_Proxy( 
    IDXTRoll __RPC_FAR * This,
    /* [in] */ float newVal);


void __RPC_STUB IDXTRoll_put_Radius_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDXTRoll_INTERFACE_DEFINED__ */


#ifndef __IDXTSpin_INTERFACE_DEFINED__
#define __IDXTSpin_INTERFACE_DEFINED__

/* interface IDXTSpin */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IDXTSpin;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3D2807C1-43DE-11D2-9900-0000F803FF7A")
    IDXTSpin : public IDXEffect
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_SpinX( 
            /* [retval][out] */ float __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_SpinX( 
            /* [in] */ float newVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_SpinY( 
            /* [retval][out] */ float __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_SpinY( 
            /* [in] */ float newVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_SpinZ( 
            /* [retval][out] */ float __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_SpinZ( 
            /* [in] */ float newVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Flips( 
            /* [retval][out] */ long __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Flips( 
            /* [in] */ long newVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDXTSpinVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDXTSpin __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDXTSpin __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDXTSpin __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IDXTSpin __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IDXTSpin __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IDXTSpin __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IDXTSpin __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Capabilities )( 
            IDXTSpin __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Progress )( 
            IDXTSpin __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Progress )( 
            IDXTSpin __RPC_FAR * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_StepResolution )( 
            IDXTSpin __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Duration )( 
            IDXTSpin __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Duration )( 
            IDXTSpin __RPC_FAR * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_SpinX )( 
            IDXTSpin __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_SpinX )( 
            IDXTSpin __RPC_FAR * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_SpinY )( 
            IDXTSpin __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_SpinY )( 
            IDXTSpin __RPC_FAR * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_SpinZ )( 
            IDXTSpin __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_SpinZ )( 
            IDXTSpin __RPC_FAR * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Flips )( 
            IDXTSpin __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Flips )( 
            IDXTSpin __RPC_FAR * This,
            /* [in] */ long newVal);
        
        END_INTERFACE
    } IDXTSpinVtbl;

    interface IDXTSpin
    {
        CONST_VTBL struct IDXTSpinVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDXTSpin_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDXTSpin_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDXTSpin_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDXTSpin_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IDXTSpin_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IDXTSpin_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IDXTSpin_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IDXTSpin_get_Capabilities(This,pVal)	\
    (This)->lpVtbl -> get_Capabilities(This,pVal)

#define IDXTSpin_get_Progress(This,pVal)	\
    (This)->lpVtbl -> get_Progress(This,pVal)

#define IDXTSpin_put_Progress(This,newVal)	\
    (This)->lpVtbl -> put_Progress(This,newVal)

#define IDXTSpin_get_StepResolution(This,pVal)	\
    (This)->lpVtbl -> get_StepResolution(This,pVal)

#define IDXTSpin_get_Duration(This,pVal)	\
    (This)->lpVtbl -> get_Duration(This,pVal)

#define IDXTSpin_put_Duration(This,newVal)	\
    (This)->lpVtbl -> put_Duration(This,newVal)


#define IDXTSpin_get_SpinX(This,pVal)	\
    (This)->lpVtbl -> get_SpinX(This,pVal)

#define IDXTSpin_put_SpinX(This,newVal)	\
    (This)->lpVtbl -> put_SpinX(This,newVal)

#define IDXTSpin_get_SpinY(This,pVal)	\
    (This)->lpVtbl -> get_SpinY(This,pVal)

#define IDXTSpin_put_SpinY(This,newVal)	\
    (This)->lpVtbl -> put_SpinY(This,newVal)

#define IDXTSpin_get_SpinZ(This,pVal)	\
    (This)->lpVtbl -> get_SpinZ(This,pVal)

#define IDXTSpin_put_SpinZ(This,newVal)	\
    (This)->lpVtbl -> put_SpinZ(This,newVal)

#define IDXTSpin_get_Flips(This,pVal)	\
    (This)->lpVtbl -> get_Flips(This,pVal)

#define IDXTSpin_put_Flips(This,newVal)	\
    (This)->lpVtbl -> put_Flips(This,newVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTSpin_get_SpinX_Proxy( 
    IDXTSpin __RPC_FAR * This,
    /* [retval][out] */ float __RPC_FAR *pVal);


void __RPC_STUB IDXTSpin_get_SpinX_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTSpin_put_SpinX_Proxy( 
    IDXTSpin __RPC_FAR * This,
    /* [in] */ float newVal);


void __RPC_STUB IDXTSpin_put_SpinX_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTSpin_get_SpinY_Proxy( 
    IDXTSpin __RPC_FAR * This,
    /* [retval][out] */ float __RPC_FAR *pVal);


void __RPC_STUB IDXTSpin_get_SpinY_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTSpin_put_SpinY_Proxy( 
    IDXTSpin __RPC_FAR * This,
    /* [in] */ float newVal);


void __RPC_STUB IDXTSpin_put_SpinY_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTSpin_get_SpinZ_Proxy( 
    IDXTSpin __RPC_FAR * This,
    /* [retval][out] */ float __RPC_FAR *pVal);


void __RPC_STUB IDXTSpin_get_SpinZ_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTSpin_put_SpinZ_Proxy( 
    IDXTSpin __RPC_FAR * This,
    /* [in] */ float newVal);


void __RPC_STUB IDXTSpin_put_SpinZ_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTSpin_get_Flips_Proxy( 
    IDXTSpin __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pVal);


void __RPC_STUB IDXTSpin_get_Flips_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTSpin_put_Flips_Proxy( 
    IDXTSpin __RPC_FAR * This,
    /* [in] */ long newVal);


void __RPC_STUB IDXTSpin_put_Flips_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDXTSpin_INTERFACE_DEFINED__ */


#ifndef __IRipple_INTERFACE_DEFINED__
#define __IRipple_INTERFACE_DEFINED__

/* interface IRipple */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IRipple;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("6DA4A05E-8E9E-11D1-904E-00C04FD9189D")
    IRipple : public IDXEffect
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_XOrigin( 
            /* [retval][out] */ float __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_XOrigin( 
            /* [in] */ float newVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_YOrigin( 
            /* [retval][out] */ float __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_YOrigin( 
            /* [in] */ float newVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Wavelength( 
            /* [retval][out] */ float __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Wavelength( 
            /* [in] */ float newVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Amplitude( 
            /* [retval][out] */ float __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Amplitude( 
            /* [in] */ float newVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_NumberOfWaves( 
            /* [retval][out] */ long __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_NumberOfWaves( 
            /* [in] */ long newVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_MinSteps( 
            /* [retval][out] */ long __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_MinSteps( 
            /* [in] */ long newVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_MaxSteps( 
            /* [retval][out] */ long __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_MaxSteps( 
            /* [in] */ long newVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRippleVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IRipple __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IRipple __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IRipple __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IRipple __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IRipple __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IRipple __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IRipple __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Capabilities )( 
            IRipple __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Progress )( 
            IRipple __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Progress )( 
            IRipple __RPC_FAR * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_StepResolution )( 
            IRipple __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Duration )( 
            IRipple __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Duration )( 
            IRipple __RPC_FAR * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_XOrigin )( 
            IRipple __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_XOrigin )( 
            IRipple __RPC_FAR * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_YOrigin )( 
            IRipple __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_YOrigin )( 
            IRipple __RPC_FAR * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Wavelength )( 
            IRipple __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Wavelength )( 
            IRipple __RPC_FAR * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Amplitude )( 
            IRipple __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Amplitude )( 
            IRipple __RPC_FAR * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_NumberOfWaves )( 
            IRipple __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_NumberOfWaves )( 
            IRipple __RPC_FAR * This,
            /* [in] */ long newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_MinSteps )( 
            IRipple __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_MinSteps )( 
            IRipple __RPC_FAR * This,
            /* [in] */ long newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_MaxSteps )( 
            IRipple __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_MaxSteps )( 
            IRipple __RPC_FAR * This,
            /* [in] */ long newVal);
        
        END_INTERFACE
    } IRippleVtbl;

    interface IRipple
    {
        CONST_VTBL struct IRippleVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRipple_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IRipple_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IRipple_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IRipple_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IRipple_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IRipple_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IRipple_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IRipple_get_Capabilities(This,pVal)	\
    (This)->lpVtbl -> get_Capabilities(This,pVal)

#define IRipple_get_Progress(This,pVal)	\
    (This)->lpVtbl -> get_Progress(This,pVal)

#define IRipple_put_Progress(This,newVal)	\
    (This)->lpVtbl -> put_Progress(This,newVal)

#define IRipple_get_StepResolution(This,pVal)	\
    (This)->lpVtbl -> get_StepResolution(This,pVal)

#define IRipple_get_Duration(This,pVal)	\
    (This)->lpVtbl -> get_Duration(This,pVal)

#define IRipple_put_Duration(This,newVal)	\
    (This)->lpVtbl -> put_Duration(This,newVal)


#define IRipple_get_XOrigin(This,pVal)	\
    (This)->lpVtbl -> get_XOrigin(This,pVal)

#define IRipple_put_XOrigin(This,newVal)	\
    (This)->lpVtbl -> put_XOrigin(This,newVal)

#define IRipple_get_YOrigin(This,pVal)	\
    (This)->lpVtbl -> get_YOrigin(This,pVal)

#define IRipple_put_YOrigin(This,newVal)	\
    (This)->lpVtbl -> put_YOrigin(This,newVal)

#define IRipple_get_Wavelength(This,pVal)	\
    (This)->lpVtbl -> get_Wavelength(This,pVal)

#define IRipple_put_Wavelength(This,newVal)	\
    (This)->lpVtbl -> put_Wavelength(This,newVal)

#define IRipple_get_Amplitude(This,pVal)	\
    (This)->lpVtbl -> get_Amplitude(This,pVal)

#define IRipple_put_Amplitude(This,newVal)	\
    (This)->lpVtbl -> put_Amplitude(This,newVal)

#define IRipple_get_NumberOfWaves(This,pVal)	\
    (This)->lpVtbl -> get_NumberOfWaves(This,pVal)

#define IRipple_put_NumberOfWaves(This,newVal)	\
    (This)->lpVtbl -> put_NumberOfWaves(This,newVal)

#define IRipple_get_MinSteps(This,pVal)	\
    (This)->lpVtbl -> get_MinSteps(This,pVal)

#define IRipple_put_MinSteps(This,newVal)	\
    (This)->lpVtbl -> put_MinSteps(This,newVal)

#define IRipple_get_MaxSteps(This,pVal)	\
    (This)->lpVtbl -> get_MaxSteps(This,pVal)

#define IRipple_put_MaxSteps(This,newVal)	\
    (This)->lpVtbl -> put_MaxSteps(This,newVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE IRipple_get_XOrigin_Proxy( 
    IRipple __RPC_FAR * This,
    /* [retval][out] */ float __RPC_FAR *pVal);


void __RPC_STUB IRipple_get_XOrigin_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IRipple_put_XOrigin_Proxy( 
    IRipple __RPC_FAR * This,
    /* [in] */ float newVal);


void __RPC_STUB IRipple_put_XOrigin_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IRipple_get_YOrigin_Proxy( 
    IRipple __RPC_FAR * This,
    /* [retval][out] */ float __RPC_FAR *pVal);


void __RPC_STUB IRipple_get_YOrigin_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IRipple_put_YOrigin_Proxy( 
    IRipple __RPC_FAR * This,
    /* [in] */ float newVal);


void __RPC_STUB IRipple_put_YOrigin_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IRipple_get_Wavelength_Proxy( 
    IRipple __RPC_FAR * This,
    /* [retval][out] */ float __RPC_FAR *pVal);


void __RPC_STUB IRipple_get_Wavelength_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IRipple_put_Wavelength_Proxy( 
    IRipple __RPC_FAR * This,
    /* [in] */ float newVal);


void __RPC_STUB IRipple_put_Wavelength_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IRipple_get_Amplitude_Proxy( 
    IRipple __RPC_FAR * This,
    /* [retval][out] */ float __RPC_FAR *pVal);


void __RPC_STUB IRipple_get_Amplitude_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IRipple_put_Amplitude_Proxy( 
    IRipple __RPC_FAR * This,
    /* [in] */ float newVal);


void __RPC_STUB IRipple_put_Amplitude_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IRipple_get_NumberOfWaves_Proxy( 
    IRipple __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pVal);


void __RPC_STUB IRipple_get_NumberOfWaves_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IRipple_put_NumberOfWaves_Proxy( 
    IRipple __RPC_FAR * This,
    /* [in] */ long newVal);


void __RPC_STUB IRipple_put_NumberOfWaves_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IRipple_get_MinSteps_Proxy( 
    IRipple __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pVal);


void __RPC_STUB IRipple_get_MinSteps_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IRipple_put_MinSteps_Proxy( 
    IRipple __RPC_FAR * This,
    /* [in] */ long newVal);


void __RPC_STUB IRipple_put_MinSteps_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IRipple_get_MaxSteps_Proxy( 
    IRipple __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pVal);


void __RPC_STUB IRipple_get_MaxSteps_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IRipple_put_MaxSteps_Proxy( 
    IRipple __RPC_FAR * This,
    /* [in] */ long newVal);


void __RPC_STUB IRipple_put_MaxSteps_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IRipple_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_dxtmsft3_0285 */
/* [local] */ 

typedef 
enum HeightFieldDISPID
    {	DISPID_HeightField_Width	= DISPID_DXE_NEXT_ID,
	DISPID_HeightField_Height	= DISPID_HeightField_Width + 1,
	DISPID_HeightField_Depth	= DISPID_HeightField_Height + 1,
	DISPID_HeightField_Samples	= DISPID_HeightField_Depth + 1
    }	HeightFieldDISPID;



extern RPC_IF_HANDLE __MIDL_itf_dxtmsft3_0285_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_dxtmsft3_0285_v0_0_s_ifspec;

#ifndef __IHeightField_INTERFACE_DEFINED__
#define __IHeightField_INTERFACE_DEFINED__

/* interface IHeightField */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IHeightField;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("0492170A-B159-11d1-9207-0000F8758E66")
    IHeightField : public IDXEffect
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Width( 
            /* [retval][out] */ float __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Width( 
            /* [in] */ float newVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Height( 
            /* [retval][out] */ float __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Height( 
            /* [in] */ float newVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Depth( 
            /* [retval][out] */ float __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Depth( 
            /* [in] */ float newVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Samples( 
            /* [retval][out] */ long __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Samples( 
            /* [in] */ long newVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IHeightFieldVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IHeightField __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IHeightField __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IHeightField __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IHeightField __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IHeightField __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IHeightField __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IHeightField __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Capabilities )( 
            IHeightField __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Progress )( 
            IHeightField __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Progress )( 
            IHeightField __RPC_FAR * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_StepResolution )( 
            IHeightField __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Duration )( 
            IHeightField __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Duration )( 
            IHeightField __RPC_FAR * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Width )( 
            IHeightField __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Width )( 
            IHeightField __RPC_FAR * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Height )( 
            IHeightField __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Height )( 
            IHeightField __RPC_FAR * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Depth )( 
            IHeightField __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Depth )( 
            IHeightField __RPC_FAR * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Samples )( 
            IHeightField __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Samples )( 
            IHeightField __RPC_FAR * This,
            /* [in] */ long newVal);
        
        END_INTERFACE
    } IHeightFieldVtbl;

    interface IHeightField
    {
        CONST_VTBL struct IHeightFieldVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IHeightField_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IHeightField_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IHeightField_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IHeightField_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IHeightField_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IHeightField_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IHeightField_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IHeightField_get_Capabilities(This,pVal)	\
    (This)->lpVtbl -> get_Capabilities(This,pVal)

#define IHeightField_get_Progress(This,pVal)	\
    (This)->lpVtbl -> get_Progress(This,pVal)

#define IHeightField_put_Progress(This,newVal)	\
    (This)->lpVtbl -> put_Progress(This,newVal)

#define IHeightField_get_StepResolution(This,pVal)	\
    (This)->lpVtbl -> get_StepResolution(This,pVal)

#define IHeightField_get_Duration(This,pVal)	\
    (This)->lpVtbl -> get_Duration(This,pVal)

#define IHeightField_put_Duration(This,newVal)	\
    (This)->lpVtbl -> put_Duration(This,newVal)


#define IHeightField_get_Width(This,pVal)	\
    (This)->lpVtbl -> get_Width(This,pVal)

#define IHeightField_put_Width(This,newVal)	\
    (This)->lpVtbl -> put_Width(This,newVal)

#define IHeightField_get_Height(This,pVal)	\
    (This)->lpVtbl -> get_Height(This,pVal)

#define IHeightField_put_Height(This,newVal)	\
    (This)->lpVtbl -> put_Height(This,newVal)

#define IHeightField_get_Depth(This,pVal)	\
    (This)->lpVtbl -> get_Depth(This,pVal)

#define IHeightField_put_Depth(This,newVal)	\
    (This)->lpVtbl -> put_Depth(This,newVal)

#define IHeightField_get_Samples(This,pVal)	\
    (This)->lpVtbl -> get_Samples(This,pVal)

#define IHeightField_put_Samples(This,newVal)	\
    (This)->lpVtbl -> put_Samples(This,newVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE IHeightField_get_Width_Proxy( 
    IHeightField __RPC_FAR * This,
    /* [retval][out] */ float __RPC_FAR *pVal);


void __RPC_STUB IHeightField_get_Width_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IHeightField_put_Width_Proxy( 
    IHeightField __RPC_FAR * This,
    /* [in] */ float newVal);


void __RPC_STUB IHeightField_put_Width_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IHeightField_get_Height_Proxy( 
    IHeightField __RPC_FAR * This,
    /* [retval][out] */ float __RPC_FAR *pVal);


void __RPC_STUB IHeightField_get_Height_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IHeightField_put_Height_Proxy( 
    IHeightField __RPC_FAR * This,
    /* [in] */ float newVal);


void __RPC_STUB IHeightField_put_Height_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IHeightField_get_Depth_Proxy( 
    IHeightField __RPC_FAR * This,
    /* [retval][out] */ float __RPC_FAR *pVal);


void __RPC_STUB IHeightField_get_Depth_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IHeightField_put_Depth_Proxy( 
    IHeightField __RPC_FAR * This,
    /* [in] */ float newVal);


void __RPC_STUB IHeightField_put_Depth_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IHeightField_get_Samples_Proxy( 
    IHeightField __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pVal);


void __RPC_STUB IHeightField_get_Samples_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IHeightField_put_Samples_Proxy( 
    IHeightField __RPC_FAR * This,
    /* [in] */ long newVal);


void __RPC_STUB IHeightField_put_Samples_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IHeightField_INTERFACE_DEFINED__ */


#ifndef __IDXTMetaStream_INTERFACE_DEFINED__
#define __IDXTMetaStream_INTERFACE_DEFINED__

/* interface IDXTMetaStream */
/* [unique][helpstring][local][dual][uuid][object] */ 


EXTERN_C const IID IID_IDXTMetaStream;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("48654BC0-E51F-11D1-AA1C-00600895FB99")
    IDXTMetaStream : public IDispatch
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_DXTurl( 
            /* [retval][out] */ BSTR __RPC_FAR *pURL) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_DXTurl( 
            /* [in] */ BSTR newURL) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_DXTAutoScale( 
            /* [in] */ VARIANT_BOOL flag) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_DXTAutoScale( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *flag) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_DXTquality( 
            /* [in] */ float flag) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_DXTquality( 
            /* [retval][out] */ float __RPC_FAR *flag) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDXTMetaStreamVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDXTMetaStream __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDXTMetaStream __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDXTMetaStream __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IDXTMetaStream __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IDXTMetaStream __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IDXTMetaStream __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IDXTMetaStream __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_DXTurl )( 
            IDXTMetaStream __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pURL);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_DXTurl )( 
            IDXTMetaStream __RPC_FAR * This,
            /* [in] */ BSTR newURL);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_DXTAutoScale )( 
            IDXTMetaStream __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL flag);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_DXTAutoScale )( 
            IDXTMetaStream __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *flag);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_DXTquality )( 
            IDXTMetaStream __RPC_FAR * This,
            /* [in] */ float flag);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_DXTquality )( 
            IDXTMetaStream __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *flag);
        
        END_INTERFACE
    } IDXTMetaStreamVtbl;

    interface IDXTMetaStream
    {
        CONST_VTBL struct IDXTMetaStreamVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDXTMetaStream_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDXTMetaStream_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDXTMetaStream_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDXTMetaStream_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IDXTMetaStream_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IDXTMetaStream_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IDXTMetaStream_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IDXTMetaStream_get_DXTurl(This,pURL)	\
    (This)->lpVtbl -> get_DXTurl(This,pURL)

#define IDXTMetaStream_put_DXTurl(This,newURL)	\
    (This)->lpVtbl -> put_DXTurl(This,newURL)

#define IDXTMetaStream_put_DXTAutoScale(This,flag)	\
    (This)->lpVtbl -> put_DXTAutoScale(This,flag)

#define IDXTMetaStream_get_DXTAutoScale(This,flag)	\
    (This)->lpVtbl -> get_DXTAutoScale(This,flag)

#define IDXTMetaStream_put_DXTquality(This,flag)	\
    (This)->lpVtbl -> put_DXTquality(This,flag)

#define IDXTMetaStream_get_DXTquality(This,flag)	\
    (This)->lpVtbl -> get_DXTquality(This,flag)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTMetaStream_get_DXTurl_Proxy( 
    IDXTMetaStream __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pURL);


void __RPC_STUB IDXTMetaStream_get_DXTurl_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTMetaStream_put_DXTurl_Proxy( 
    IDXTMetaStream __RPC_FAR * This,
    /* [in] */ BSTR newURL);


void __RPC_STUB IDXTMetaStream_put_DXTurl_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTMetaStream_put_DXTAutoScale_Proxy( 
    IDXTMetaStream __RPC_FAR * This,
    /* [in] */ VARIANT_BOOL flag);


void __RPC_STUB IDXTMetaStream_put_DXTAutoScale_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTMetaStream_get_DXTAutoScale_Proxy( 
    IDXTMetaStream __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *flag);


void __RPC_STUB IDXTMetaStream_get_DXTAutoScale_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTMetaStream_put_DXTquality_Proxy( 
    IDXTMetaStream __RPC_FAR * This,
    /* [in] */ float flag);


void __RPC_STUB IDXTMetaStream_put_DXTquality_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTMetaStream_get_DXTquality_Proxy( 
    IDXTMetaStream __RPC_FAR * This,
    /* [retval][out] */ float __RPC_FAR *flag);


void __RPC_STUB IDXTMetaStream_get_DXTquality_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDXTMetaStream_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_dxtmsft3_0287 */
/* [local] */ 

typedef 
enum DXTText3DDISPID
    {	DISPID_DXTText3D_String	= DISPID_DXE_NEXT_ID,
	DISPID_DXTText3D_FontFace	= DISPID_DXTText3D_String + 1,
	DISPID_DXTText3D_FontWeight	= DISPID_DXTText3D_FontFace + 1,
	DISPID_DXTText3D_FontStyle	= DISPID_DXTText3D_FontWeight + 1,
	DISPID_DXTText3D_Vertical	= DISPID_DXTText3D_FontStyle + 1,
	DISPID_DXTText3D_ExtrusionType	= DISPID_DXTText3D_Vertical + 1,
	DISPID_DXTText3D_XAlign	= DISPID_DXTText3D_ExtrusionType + 1,
	DISPID_DXTText3D_YAlign	= DISPID_DXTText3D_XAlign + 1,
	DISPID_DXTText3D_ZAlign	= DISPID_DXTText3D_YAlign + 1,
	DISPID_DXTText3D_LetterSpacing	= DISPID_DXTText3D_ZAlign + 1,
	DISPID_DXTText3D_Quality	= DISPID_DXTText3D_LetterSpacing + 1
    }	DXTText3DDISPID;



extern RPC_IF_HANDLE __MIDL_itf_dxtmsft3_0287_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_dxtmsft3_0287_v0_0_s_ifspec;

#ifndef __IDXTText3D_INTERFACE_DEFINED__
#define __IDXTText3D_INTERFACE_DEFINED__

/* interface IDXTText3D */
/* [unique][helpstring][local][dual][uuid][object] */ 


EXTERN_C const IID IID_IDXTText3D;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("50C4B592-7E8D-11d2-9B4E-00A0C9697CD0")
    IDXTText3D : public IDispatch
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_String( 
            /* [retval][out] */ BSTR __RPC_FAR *pbstr) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_String( 
            /* [in] */ BSTR pbstr) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_FontFace( 
            /* [retval][out] */ BSTR __RPC_FAR *pbstr) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_FontFace( 
            /* [in] */ BSTR pbstr) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_FontWeight( 
            /* [retval][out] */ BSTR __RPC_FAR *pbstr) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_FontWeight( 
            /* [in] */ BSTR pbstr) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_FontStyle( 
            /* [retval][out] */ BSTR __RPC_FAR *pbstr) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_FontStyle( 
            /* [in] */ BSTR pbstr) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Vertical( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *fVertical) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Vertical( 
            /* [in] */ VARIANT_BOOL fVertical) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_ExtrusionType( 
            /* [retval][out] */ BSTR __RPC_FAR *pbstr) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_ExtrusionType( 
            /* [in] */ BSTR pbstr) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_XAlign( 
            /* [retval][out] */ BSTR __RPC_FAR *pbstr) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_XAlign( 
            /* [in] */ BSTR pbstr) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_YAlign( 
            /* [retval][out] */ BSTR __RPC_FAR *pbstr) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_YAlign( 
            /* [in] */ BSTR pbstr) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_ZAlign( 
            /* [retval][out] */ BSTR __RPC_FAR *pbstr) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_ZAlign( 
            /* [in] */ BSTR pbstr) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_LetterSpacing( 
            /* [retval][out] */ VARIANT __RPC_FAR *pvarLetterSpacing) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_LetterSpacing( 
            /* [in] */ VARIANT varLetterSpacing) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Quality( 
            /* [retval][out] */ float __RPC_FAR *pflQuality) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Quality( 
            /* [in] */ float flQuality) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDXTText3DVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDXTText3D __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDXTText3D __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDXTText3D __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IDXTText3D __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IDXTText3D __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IDXTText3D __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IDXTText3D __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_String )( 
            IDXTText3D __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstr);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_String )( 
            IDXTText3D __RPC_FAR * This,
            /* [in] */ BSTR pbstr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_FontFace )( 
            IDXTText3D __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstr);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_FontFace )( 
            IDXTText3D __RPC_FAR * This,
            /* [in] */ BSTR pbstr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_FontWeight )( 
            IDXTText3D __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstr);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_FontWeight )( 
            IDXTText3D __RPC_FAR * This,
            /* [in] */ BSTR pbstr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_FontStyle )( 
            IDXTText3D __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstr);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_FontStyle )( 
            IDXTText3D __RPC_FAR * This,
            /* [in] */ BSTR pbstr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Vertical )( 
            IDXTText3D __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *fVertical);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Vertical )( 
            IDXTText3D __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL fVertical);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ExtrusionType )( 
            IDXTText3D __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstr);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_ExtrusionType )( 
            IDXTText3D __RPC_FAR * This,
            /* [in] */ BSTR pbstr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_XAlign )( 
            IDXTText3D __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstr);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_XAlign )( 
            IDXTText3D __RPC_FAR * This,
            /* [in] */ BSTR pbstr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_YAlign )( 
            IDXTText3D __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstr);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_YAlign )( 
            IDXTText3D __RPC_FAR * This,
            /* [in] */ BSTR pbstr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ZAlign )( 
            IDXTText3D __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstr);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_ZAlign )( 
            IDXTText3D __RPC_FAR * This,
            /* [in] */ BSTR pbstr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_LetterSpacing )( 
            IDXTText3D __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *pvarLetterSpacing);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_LetterSpacing )( 
            IDXTText3D __RPC_FAR * This,
            /* [in] */ VARIANT varLetterSpacing);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Quality )( 
            IDXTText3D __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pflQuality);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Quality )( 
            IDXTText3D __RPC_FAR * This,
            /* [in] */ float flQuality);
        
        END_INTERFACE
    } IDXTText3DVtbl;

    interface IDXTText3D
    {
        CONST_VTBL struct IDXTText3DVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDXTText3D_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDXTText3D_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDXTText3D_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDXTText3D_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IDXTText3D_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IDXTText3D_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IDXTText3D_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IDXTText3D_get_String(This,pbstr)	\
    (This)->lpVtbl -> get_String(This,pbstr)

#define IDXTText3D_put_String(This,pbstr)	\
    (This)->lpVtbl -> put_String(This,pbstr)

#define IDXTText3D_get_FontFace(This,pbstr)	\
    (This)->lpVtbl -> get_FontFace(This,pbstr)

#define IDXTText3D_put_FontFace(This,pbstr)	\
    (This)->lpVtbl -> put_FontFace(This,pbstr)

#define IDXTText3D_get_FontWeight(This,pbstr)	\
    (This)->lpVtbl -> get_FontWeight(This,pbstr)

#define IDXTText3D_put_FontWeight(This,pbstr)	\
    (This)->lpVtbl -> put_FontWeight(This,pbstr)

#define IDXTText3D_get_FontStyle(This,pbstr)	\
    (This)->lpVtbl -> get_FontStyle(This,pbstr)

#define IDXTText3D_put_FontStyle(This,pbstr)	\
    (This)->lpVtbl -> put_FontStyle(This,pbstr)

#define IDXTText3D_get_Vertical(This,fVertical)	\
    (This)->lpVtbl -> get_Vertical(This,fVertical)

#define IDXTText3D_put_Vertical(This,fVertical)	\
    (This)->lpVtbl -> put_Vertical(This,fVertical)

#define IDXTText3D_get_ExtrusionType(This,pbstr)	\
    (This)->lpVtbl -> get_ExtrusionType(This,pbstr)

#define IDXTText3D_put_ExtrusionType(This,pbstr)	\
    (This)->lpVtbl -> put_ExtrusionType(This,pbstr)

#define IDXTText3D_get_XAlign(This,pbstr)	\
    (This)->lpVtbl -> get_XAlign(This,pbstr)

#define IDXTText3D_put_XAlign(This,pbstr)	\
    (This)->lpVtbl -> put_XAlign(This,pbstr)

#define IDXTText3D_get_YAlign(This,pbstr)	\
    (This)->lpVtbl -> get_YAlign(This,pbstr)

#define IDXTText3D_put_YAlign(This,pbstr)	\
    (This)->lpVtbl -> put_YAlign(This,pbstr)

#define IDXTText3D_get_ZAlign(This,pbstr)	\
    (This)->lpVtbl -> get_ZAlign(This,pbstr)

#define IDXTText3D_put_ZAlign(This,pbstr)	\
    (This)->lpVtbl -> put_ZAlign(This,pbstr)

#define IDXTText3D_get_LetterSpacing(This,pvarLetterSpacing)	\
    (This)->lpVtbl -> get_LetterSpacing(This,pvarLetterSpacing)

#define IDXTText3D_put_LetterSpacing(This,varLetterSpacing)	\
    (This)->lpVtbl -> put_LetterSpacing(This,varLetterSpacing)

#define IDXTText3D_get_Quality(This,pflQuality)	\
    (This)->lpVtbl -> get_Quality(This,pflQuality)

#define IDXTText3D_put_Quality(This,flQuality)	\
    (This)->lpVtbl -> put_Quality(This,flQuality)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTText3D_get_String_Proxy( 
    IDXTText3D __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pbstr);


void __RPC_STUB IDXTText3D_get_String_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTText3D_put_String_Proxy( 
    IDXTText3D __RPC_FAR * This,
    /* [in] */ BSTR pbstr);


void __RPC_STUB IDXTText3D_put_String_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTText3D_get_FontFace_Proxy( 
    IDXTText3D __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pbstr);


void __RPC_STUB IDXTText3D_get_FontFace_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTText3D_put_FontFace_Proxy( 
    IDXTText3D __RPC_FAR * This,
    /* [in] */ BSTR pbstr);


void __RPC_STUB IDXTText3D_put_FontFace_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTText3D_get_FontWeight_Proxy( 
    IDXTText3D __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pbstr);


void __RPC_STUB IDXTText3D_get_FontWeight_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTText3D_put_FontWeight_Proxy( 
    IDXTText3D __RPC_FAR * This,
    /* [in] */ BSTR pbstr);


void __RPC_STUB IDXTText3D_put_FontWeight_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTText3D_get_FontStyle_Proxy( 
    IDXTText3D __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pbstr);


void __RPC_STUB IDXTText3D_get_FontStyle_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTText3D_put_FontStyle_Proxy( 
    IDXTText3D __RPC_FAR * This,
    /* [in] */ BSTR pbstr);


void __RPC_STUB IDXTText3D_put_FontStyle_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTText3D_get_Vertical_Proxy( 
    IDXTText3D __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *fVertical);


void __RPC_STUB IDXTText3D_get_Vertical_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTText3D_put_Vertical_Proxy( 
    IDXTText3D __RPC_FAR * This,
    /* [in] */ VARIANT_BOOL fVertical);


void __RPC_STUB IDXTText3D_put_Vertical_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTText3D_get_ExtrusionType_Proxy( 
    IDXTText3D __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pbstr);


void __RPC_STUB IDXTText3D_get_ExtrusionType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTText3D_put_ExtrusionType_Proxy( 
    IDXTText3D __RPC_FAR * This,
    /* [in] */ BSTR pbstr);


void __RPC_STUB IDXTText3D_put_ExtrusionType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTText3D_get_XAlign_Proxy( 
    IDXTText3D __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pbstr);


void __RPC_STUB IDXTText3D_get_XAlign_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTText3D_put_XAlign_Proxy( 
    IDXTText3D __RPC_FAR * This,
    /* [in] */ BSTR pbstr);


void __RPC_STUB IDXTText3D_put_XAlign_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTText3D_get_YAlign_Proxy( 
    IDXTText3D __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pbstr);


void __RPC_STUB IDXTText3D_get_YAlign_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTText3D_put_YAlign_Proxy( 
    IDXTText3D __RPC_FAR * This,
    /* [in] */ BSTR pbstr);


void __RPC_STUB IDXTText3D_put_YAlign_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTText3D_get_ZAlign_Proxy( 
    IDXTText3D __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pbstr);


void __RPC_STUB IDXTText3D_get_ZAlign_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTText3D_put_ZAlign_Proxy( 
    IDXTText3D __RPC_FAR * This,
    /* [in] */ BSTR pbstr);


void __RPC_STUB IDXTText3D_put_ZAlign_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTText3D_get_LetterSpacing_Proxy( 
    IDXTText3D __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *pvarLetterSpacing);


void __RPC_STUB IDXTText3D_get_LetterSpacing_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTText3D_put_LetterSpacing_Proxy( 
    IDXTText3D __RPC_FAR * This,
    /* [in] */ VARIANT varLetterSpacing);


void __RPC_STUB IDXTText3D_put_LetterSpacing_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTText3D_get_Quality_Proxy( 
    IDXTText3D __RPC_FAR * This,
    /* [retval][out] */ float __RPC_FAR *pflQuality);


void __RPC_STUB IDXTText3D_get_Quality_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTText3D_put_Quality_Proxy( 
    IDXTText3D __RPC_FAR * This,
    /* [in] */ float flQuality);


void __RPC_STUB IDXTText3D_put_Quality_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDXTText3D_INTERFACE_DEFINED__ */


#ifndef __IDXTShapes_INTERFACE_DEFINED__
#define __IDXTShapes_INTERFACE_DEFINED__

/* interface IDXTShapes */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IDXTShapes;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("8241F013-84D3-11d2-97E6-0000F803FF7A")
    IDXTShapes : public IDispatch
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Shape( 
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Shape( 
            /* [in] */ BSTR newVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_XMinRes( 
            /* [retval][out] */ long __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_XMinRes( 
            /* [in] */ long newVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_XMaxRes( 
            /* [retval][out] */ long __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_XMaxRes( 
            /* [in] */ long newVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_YMinRes( 
            /* [retval][out] */ long __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_YMinRes( 
            /* [in] */ long newVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_YMaxRes( 
            /* [retval][out] */ long __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_YMaxRes( 
            /* [in] */ long newVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Color( 
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Color( 
            /* [in] */ BSTR newVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_DoubleSided( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_DoubleSided( 
            /* [in] */ VARIANT_BOOL newVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_KeepAspectRatio( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_KeepAspectRatio( 
            /* [in] */ VARIANT_BOOL newVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDXTShapesVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDXTShapes __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDXTShapes __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDXTShapes __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IDXTShapes __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IDXTShapes __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IDXTShapes __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IDXTShapes __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Shape )( 
            IDXTShapes __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Shape )( 
            IDXTShapes __RPC_FAR * This,
            /* [in] */ BSTR newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_XMinRes )( 
            IDXTShapes __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_XMinRes )( 
            IDXTShapes __RPC_FAR * This,
            /* [in] */ long newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_XMaxRes )( 
            IDXTShapes __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_XMaxRes )( 
            IDXTShapes __RPC_FAR * This,
            /* [in] */ long newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_YMinRes )( 
            IDXTShapes __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_YMinRes )( 
            IDXTShapes __RPC_FAR * This,
            /* [in] */ long newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_YMaxRes )( 
            IDXTShapes __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_YMaxRes )( 
            IDXTShapes __RPC_FAR * This,
            /* [in] */ long newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Color )( 
            IDXTShapes __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Color )( 
            IDXTShapes __RPC_FAR * This,
            /* [in] */ BSTR newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_DoubleSided )( 
            IDXTShapes __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_DoubleSided )( 
            IDXTShapes __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_KeepAspectRatio )( 
            IDXTShapes __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_KeepAspectRatio )( 
            IDXTShapes __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL newVal);
        
        END_INTERFACE
    } IDXTShapesVtbl;

    interface IDXTShapes
    {
        CONST_VTBL struct IDXTShapesVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDXTShapes_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDXTShapes_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDXTShapes_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDXTShapes_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IDXTShapes_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IDXTShapes_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IDXTShapes_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IDXTShapes_get_Shape(This,pVal)	\
    (This)->lpVtbl -> get_Shape(This,pVal)

#define IDXTShapes_put_Shape(This,newVal)	\
    (This)->lpVtbl -> put_Shape(This,newVal)

#define IDXTShapes_get_XMinRes(This,pVal)	\
    (This)->lpVtbl -> get_XMinRes(This,pVal)

#define IDXTShapes_put_XMinRes(This,newVal)	\
    (This)->lpVtbl -> put_XMinRes(This,newVal)

#define IDXTShapes_get_XMaxRes(This,pVal)	\
    (This)->lpVtbl -> get_XMaxRes(This,pVal)

#define IDXTShapes_put_XMaxRes(This,newVal)	\
    (This)->lpVtbl -> put_XMaxRes(This,newVal)

#define IDXTShapes_get_YMinRes(This,pVal)	\
    (This)->lpVtbl -> get_YMinRes(This,pVal)

#define IDXTShapes_put_YMinRes(This,newVal)	\
    (This)->lpVtbl -> put_YMinRes(This,newVal)

#define IDXTShapes_get_YMaxRes(This,pVal)	\
    (This)->lpVtbl -> get_YMaxRes(This,pVal)

#define IDXTShapes_put_YMaxRes(This,newVal)	\
    (This)->lpVtbl -> put_YMaxRes(This,newVal)

#define IDXTShapes_get_Color(This,pVal)	\
    (This)->lpVtbl -> get_Color(This,pVal)

#define IDXTShapes_put_Color(This,newVal)	\
    (This)->lpVtbl -> put_Color(This,newVal)

#define IDXTShapes_get_DoubleSided(This,pVal)	\
    (This)->lpVtbl -> get_DoubleSided(This,pVal)

#define IDXTShapes_put_DoubleSided(This,newVal)	\
    (This)->lpVtbl -> put_DoubleSided(This,newVal)

#define IDXTShapes_get_KeepAspectRatio(This,pVal)	\
    (This)->lpVtbl -> get_KeepAspectRatio(This,pVal)

#define IDXTShapes_put_KeepAspectRatio(This,newVal)	\
    (This)->lpVtbl -> put_KeepAspectRatio(This,newVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTShapes_get_Shape_Proxy( 
    IDXTShapes __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB IDXTShapes_get_Shape_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTShapes_put_Shape_Proxy( 
    IDXTShapes __RPC_FAR * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IDXTShapes_put_Shape_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTShapes_get_XMinRes_Proxy( 
    IDXTShapes __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pVal);


void __RPC_STUB IDXTShapes_get_XMinRes_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTShapes_put_XMinRes_Proxy( 
    IDXTShapes __RPC_FAR * This,
    /* [in] */ long newVal);


void __RPC_STUB IDXTShapes_put_XMinRes_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTShapes_get_XMaxRes_Proxy( 
    IDXTShapes __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pVal);


void __RPC_STUB IDXTShapes_get_XMaxRes_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTShapes_put_XMaxRes_Proxy( 
    IDXTShapes __RPC_FAR * This,
    /* [in] */ long newVal);


void __RPC_STUB IDXTShapes_put_XMaxRes_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTShapes_get_YMinRes_Proxy( 
    IDXTShapes __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pVal);


void __RPC_STUB IDXTShapes_get_YMinRes_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTShapes_put_YMinRes_Proxy( 
    IDXTShapes __RPC_FAR * This,
    /* [in] */ long newVal);


void __RPC_STUB IDXTShapes_put_YMinRes_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTShapes_get_YMaxRes_Proxy( 
    IDXTShapes __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pVal);


void __RPC_STUB IDXTShapes_get_YMaxRes_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTShapes_put_YMaxRes_Proxy( 
    IDXTShapes __RPC_FAR * This,
    /* [in] */ long newVal);


void __RPC_STUB IDXTShapes_put_YMaxRes_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTShapes_get_Color_Proxy( 
    IDXTShapes __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB IDXTShapes_get_Color_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTShapes_put_Color_Proxy( 
    IDXTShapes __RPC_FAR * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IDXTShapes_put_Color_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTShapes_get_DoubleSided_Proxy( 
    IDXTShapes __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pVal);


void __RPC_STUB IDXTShapes_get_DoubleSided_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTShapes_put_DoubleSided_Proxy( 
    IDXTShapes __RPC_FAR * This,
    /* [in] */ VARIANT_BOOL newVal);


void __RPC_STUB IDXTShapes_put_DoubleSided_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTShapes_get_KeepAspectRatio_Proxy( 
    IDXTShapes __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pVal);


void __RPC_STUB IDXTShapes_get_KeepAspectRatio_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTShapes_put_KeepAspectRatio_Proxy( 
    IDXTShapes __RPC_FAR * This,
    /* [in] */ VARIANT_BOOL newVal);


void __RPC_STUB IDXTShapes_put_KeepAspectRatio_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDXTShapes_INTERFACE_DEFINED__ */



#ifndef __DXTMSFT3Lib_LIBRARY_DEFINED__
#define __DXTMSFT3Lib_LIBRARY_DEFINED__

/* library DXTMSFT3Lib */
/* [helpstring][version][uuid] */ 


EXTERN_C const IID LIBID_DXTMSFT3Lib;

EXTERN_C const CLSID CLSID_Explode;

#ifdef __cplusplus

class DECLSPEC_UUID("141DBAF1-55FB-11D1-B83E-00A0C933BE86")
Explode;
#endif

EXTERN_C const CLSID CLSID_ExplodeProp;

#ifdef __cplusplus

class DECLSPEC_UUID("C53059E1-E6E3-11d1-BA12-00C04FB6BD36")
ExplodeProp;
#endif

EXTERN_C const CLSID CLSID_Ripple;

#ifdef __cplusplus

class DECLSPEC_UUID("945F5842-3A8D-11D1-9037-00C04FD9189D")
Ripple;
#endif

EXTERN_C const CLSID CLSID_RipProp;

#ifdef __cplusplus

class DECLSPEC_UUID("945F5843-3A8D-11D1-9037-00C04FD9189D")
RipProp;
#endif

EXTERN_C const CLSID CLSID_HeightField;

#ifdef __cplusplus

class DECLSPEC_UUID("04921709-B159-11d1-9207-0000F8758E66")
HeightField;
#endif

EXTERN_C const CLSID CLSID_HtFieldProp;

#ifdef __cplusplus

class DECLSPEC_UUID("7A8402E3-FBD6-11D1-B5E0-00AA003B6061")
HtFieldProp;
#endif

EXTERN_C const CLSID CLSID_DXTMetaStream;

#ifdef __cplusplus

class DECLSPEC_UUID("60A0C080-E505-11D1-AA1C-00600895FB99")
DXTMetaStream;
#endif

EXTERN_C const CLSID CLSID_DXTMetaStreamProp;

#ifdef __cplusplus

class DECLSPEC_UUID("E3D77340-E505-11D1-AA1C-00600895FB99")
DXTMetaStreamProp;
#endif

EXTERN_C const CLSID CLSID_DXTText3D;

#ifdef __cplusplus

class DECLSPEC_UUID("D56F34F2-7E89-11d2-9B4E-00A0C9697CD0")
DXTText3D;
#endif

EXTERN_C const CLSID CLSID_DXTText3DPP;

#ifdef __cplusplus

class DECLSPEC_UUID("50C4B593-7E8D-11d2-9B4E-00A0C9697CD0")
DXTText3DPP;
#endif

EXTERN_C const CLSID CLSID_CrShatter;

#ifdef __cplusplus

class DECLSPEC_UUID("63500AE2-0858-11D2-8CE4-00C04F8ECB10")
CrShatter;
#endif

EXTERN_C const CLSID CLSID_CrShatterPP;

#ifdef __cplusplus

class DECLSPEC_UUID("99275F01-102E-11d2-8B82-00A0C93C09B2")
CrShatterPP;
#endif

EXTERN_C const CLSID CLSID_DXTBlackHole;

#ifdef __cplusplus

class DECLSPEC_UUID("C3853C22-3F2E-11D2-9900-0000F803FF7A")
DXTBlackHole;
#endif

EXTERN_C const CLSID CLSID_DXTBlackHolePP;

#ifdef __cplusplus

class DECLSPEC_UUID("C3853C23-3F2E-11D2-9900-0000F803FF7A")
DXTBlackHolePP;
#endif

EXTERN_C const CLSID CLSID_DXTRoll;

#ifdef __cplusplus

class DECLSPEC_UUID("78F30B82-48AA-11D2-9900-0000F803FF7A")
DXTRoll;
#endif

EXTERN_C const CLSID CLSID_DXTRollPP;

#ifdef __cplusplus

class DECLSPEC_UUID("78F30B83-48AA-11D2-9900-0000F803FF7A")
DXTRollPP;
#endif

EXTERN_C const CLSID CLSID_DXTSpin;

#ifdef __cplusplus

class DECLSPEC_UUID("3D2807C2-43DE-11D2-9900-0000F803FF7A")
DXTSpin;
#endif

EXTERN_C const CLSID CLSID_DXTSpinPP;

#ifdef __cplusplus

class DECLSPEC_UUID("3D2807C3-43DE-11D2-9900-0000F803FF7A")
DXTSpinPP;
#endif

EXTERN_C const CLSID CLSID_DXTShapes;

#ifdef __cplusplus

class DECLSPEC_UUID("8241F015-84D3-11d2-97E6-0000F803FF7A")
DXTShapes;
#endif

EXTERN_C const CLSID CLSID_DXTShapesPP;

#ifdef __cplusplus

class DECLSPEC_UUID("8241F016-84D3-11d2-97E6-0000F803FF7A")
DXTShapesPP;
#endif
#endif /* __DXTMSFT3Lib_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     unsigned long __RPC_FAR *, unsigned long            , BSTR __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  BSTR_UserMarshal(  unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, BSTR __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  BSTR_UserUnmarshal(unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, BSTR __RPC_FAR * ); 
void                      __RPC_USER  BSTR_UserFree(     unsigned long __RPC_FAR *, BSTR __RPC_FAR * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\extinc\dxtrans.h ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 5.03.0285 */
/* Compiler settings for dxtrans.idl:
    Oicf (OptLev=i2), W0, Zp8, env=Win32 (32b run), ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __dxtrans_h__
#define __dxtrans_h__

/* Forward Declarations */ 

#ifndef __IDXBaseObject_FWD_DEFINED__
#define __IDXBaseObject_FWD_DEFINED__
typedef interface IDXBaseObject IDXBaseObject;
#endif 	/* __IDXBaseObject_FWD_DEFINED__ */


#ifndef __IDXTransformFactory_FWD_DEFINED__
#define __IDXTransformFactory_FWD_DEFINED__
typedef interface IDXTransformFactory IDXTransformFactory;
#endif 	/* __IDXTransformFactory_FWD_DEFINED__ */


#ifndef __IDXTransform_FWD_DEFINED__
#define __IDXTransform_FWD_DEFINED__
typedef interface IDXTransform IDXTransform;
#endif 	/* __IDXTransform_FWD_DEFINED__ */


#ifndef __IDXSurfacePick_FWD_DEFINED__
#define __IDXSurfacePick_FWD_DEFINED__
typedef interface IDXSurfacePick IDXSurfacePick;
#endif 	/* __IDXSurfacePick_FWD_DEFINED__ */


#ifndef __IDXTBindHost_FWD_DEFINED__
#define __IDXTBindHost_FWD_DEFINED__
typedef interface IDXTBindHost IDXTBindHost;
#endif 	/* __IDXTBindHost_FWD_DEFINED__ */


#ifndef __IDXTaskManager_FWD_DEFINED__
#define __IDXTaskManager_FWD_DEFINED__
typedef interface IDXTaskManager IDXTaskManager;
#endif 	/* __IDXTaskManager_FWD_DEFINED__ */


#ifndef __IDXSurfaceFactory_FWD_DEFINED__
#define __IDXSurfaceFactory_FWD_DEFINED__
typedef interface IDXSurfaceFactory IDXSurfaceFactory;
#endif 	/* __IDXSurfaceFactory_FWD_DEFINED__ */


#ifndef __IDXSurfaceModifier_FWD_DEFINED__
#define __IDXSurfaceModifier_FWD_DEFINED__
typedef interface IDXSurfaceModifier IDXSurfaceModifier;
#endif 	/* __IDXSurfaceModifier_FWD_DEFINED__ */


#ifndef __IDXSurface_FWD_DEFINED__
#define __IDXSurface_FWD_DEFINED__
typedef interface IDXSurface IDXSurface;
#endif 	/* __IDXSurface_FWD_DEFINED__ */


#ifndef __IDXSurfaceInit_FWD_DEFINED__
#define __IDXSurfaceInit_FWD_DEFINED__
typedef interface IDXSurfaceInit IDXSurfaceInit;
#endif 	/* __IDXSurfaceInit_FWD_DEFINED__ */


#ifndef __IDXARGBSurfaceInit_FWD_DEFINED__
#define __IDXARGBSurfaceInit_FWD_DEFINED__
typedef interface IDXARGBSurfaceInit IDXARGBSurfaceInit;
#endif 	/* __IDXARGBSurfaceInit_FWD_DEFINED__ */


#ifndef __IDXARGBReadPtr_FWD_DEFINED__
#define __IDXARGBReadPtr_FWD_DEFINED__
typedef interface IDXARGBReadPtr IDXARGBReadPtr;
#endif 	/* __IDXARGBReadPtr_FWD_DEFINED__ */


#ifndef __IDXARGBReadWritePtr_FWD_DEFINED__
#define __IDXARGBReadWritePtr_FWD_DEFINED__
typedef interface IDXARGBReadWritePtr IDXARGBReadWritePtr;
#endif 	/* __IDXARGBReadWritePtr_FWD_DEFINED__ */


#ifndef __IDXDCLock_FWD_DEFINED__
#define __IDXDCLock_FWD_DEFINED__
typedef interface IDXDCLock IDXDCLock;
#endif 	/* __IDXDCLock_FWD_DEFINED__ */


#ifndef __IDXTScaleOutput_FWD_DEFINED__
#define __IDXTScaleOutput_FWD_DEFINED__
typedef interface IDXTScaleOutput IDXTScaleOutput;
#endif 	/* __IDXTScaleOutput_FWD_DEFINED__ */


#ifndef __IDXGradient_FWD_DEFINED__
#define __IDXGradient_FWD_DEFINED__
typedef interface IDXGradient IDXGradient;
#endif 	/* __IDXGradient_FWD_DEFINED__ */


#ifndef __IDXGradient2_FWD_DEFINED__
#define __IDXGradient2_FWD_DEFINED__
typedef interface IDXGradient2 IDXGradient2;
#endif 	/* __IDXGradient2_FWD_DEFINED__ */


#ifndef __IDXTScale_FWD_DEFINED__
#define __IDXTScale_FWD_DEFINED__
typedef interface IDXTScale IDXTScale;
#endif 	/* __IDXTScale_FWD_DEFINED__ */


#ifndef __IDXTLabel_FWD_DEFINED__
#define __IDXTLabel_FWD_DEFINED__
typedef interface IDXTLabel IDXTLabel;
#endif 	/* __IDXTLabel_FWD_DEFINED__ */


#ifndef __IDXRasterizer_FWD_DEFINED__
#define __IDXRasterizer_FWD_DEFINED__
typedef interface IDXRasterizer IDXRasterizer;
#endif 	/* __IDXRasterizer_FWD_DEFINED__ */


#ifndef __IDXEffect_FWD_DEFINED__
#define __IDXEffect_FWD_DEFINED__
typedef interface IDXEffect IDXEffect;
#endif 	/* __IDXEffect_FWD_DEFINED__ */


#ifndef __IDXLookupTable_FWD_DEFINED__
#define __IDXLookupTable_FWD_DEFINED__
typedef interface IDXLookupTable IDXLookupTable;
#endif 	/* __IDXLookupTable_FWD_DEFINED__ */


#ifndef __IDX2DDebug_FWD_DEFINED__
#define __IDX2DDebug_FWD_DEFINED__
typedef interface IDX2DDebug IDX2DDebug;
#endif 	/* __IDX2DDebug_FWD_DEFINED__ */


#ifndef __IDX2D_FWD_DEFINED__
#define __IDX2D_FWD_DEFINED__
typedef interface IDX2D IDX2D;
#endif 	/* __IDX2D_FWD_DEFINED__ */


#ifndef __IDXRawSurface_FWD_DEFINED__
#define __IDXRawSurface_FWD_DEFINED__
typedef interface IDXRawSurface IDXRawSurface;
#endif 	/* __IDXRawSurface_FWD_DEFINED__ */


#ifndef __DXTransformFactory_FWD_DEFINED__
#define __DXTransformFactory_FWD_DEFINED__

#ifdef __cplusplus
typedef class DXTransformFactory DXTransformFactory;
#else
typedef struct DXTransformFactory DXTransformFactory;
#endif /* __cplusplus */

#endif 	/* __DXTransformFactory_FWD_DEFINED__ */


#ifndef __DXTaskManager_FWD_DEFINED__
#define __DXTaskManager_FWD_DEFINED__

#ifdef __cplusplus
typedef class DXTaskManager DXTaskManager;
#else
typedef struct DXTaskManager DXTaskManager;
#endif /* __cplusplus */

#endif 	/* __DXTaskManager_FWD_DEFINED__ */


#ifndef __DXTScale_FWD_DEFINED__
#define __DXTScale_FWD_DEFINED__

#ifdef __cplusplus
typedef class DXTScale DXTScale;
#else
typedef struct DXTScale DXTScale;
#endif /* __cplusplus */

#endif 	/* __DXTScale_FWD_DEFINED__ */


#ifndef __DXTLabel_FWD_DEFINED__
#define __DXTLabel_FWD_DEFINED__

#ifdef __cplusplus
typedef class DXTLabel DXTLabel;
#else
typedef struct DXTLabel DXTLabel;
#endif /* __cplusplus */

#endif 	/* __DXTLabel_FWD_DEFINED__ */


#ifndef __DX2D_FWD_DEFINED__
#define __DX2D_FWD_DEFINED__

#ifdef __cplusplus
typedef class DX2D DX2D;
#else
typedef struct DX2D DX2D;
#endif /* __cplusplus */

#endif 	/* __DX2D_FWD_DEFINED__ */


#ifndef __DXSurface_FWD_DEFINED__
#define __DXSurface_FWD_DEFINED__

#ifdef __cplusplus
typedef class DXSurface DXSurface;
#else
typedef struct DXSurface DXSurface;
#endif /* __cplusplus */

#endif 	/* __DXSurface_FWD_DEFINED__ */


#ifndef __DXSurfaceModifier_FWD_DEFINED__
#define __DXSurfaceModifier_FWD_DEFINED__

#ifdef __cplusplus
typedef class DXSurfaceModifier DXSurfaceModifier;
#else
typedef struct DXSurfaceModifier DXSurfaceModifier;
#endif /* __cplusplus */

#endif 	/* __DXSurfaceModifier_FWD_DEFINED__ */


#ifndef __DXRasterizer_FWD_DEFINED__
#define __DXRasterizer_FWD_DEFINED__

#ifdef __cplusplus
typedef class DXRasterizer DXRasterizer;
#else
typedef struct DXRasterizer DXRasterizer;
#endif /* __cplusplus */

#endif 	/* __DXRasterizer_FWD_DEFINED__ */


#ifndef __DXGradient_FWD_DEFINED__
#define __DXGradient_FWD_DEFINED__

#ifdef __cplusplus
typedef class DXGradient DXGradient;
#else
typedef struct DXGradient DXGradient;
#endif /* __cplusplus */

#endif 	/* __DXGradient_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"
#include "comcat.h"

#ifdef __cplusplus
extern "C"{
#endif 

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

/* interface __MIDL_itf_dxtrans_0000 */
/* [local] */ 

#include <servprov.h>
#include <ddraw.h>
#include <d3d.h>
#include <d3drm.h>
#include <urlmon.h>
#if 0
// Bogus definition used to make MIDL compiler happy
typedef void DDSURFACEDESC;

typedef void D3DRMBOX;

typedef void D3DVECTOR;

typedef void D3DRMMATRIX4D;

typedef void __RPC_FAR *LPSECURITY_ATTRIBUTES;

#endif
#ifdef _DXTRANSIMPL
    #define _DXTRANS_IMPL_EXT _declspec(dllexport)
#else
    #define _DXTRANS_IMPL_EXT _declspec(dllimport)
#endif


















//
//   All GUIDs for DXTransforms are declared in DXTGUID.CPP in the SDK include directory
//
EXTERN_C const GUID DDPF_RGB1;
EXTERN_C const GUID DDPF_RGB2;
EXTERN_C const GUID DDPF_RGB4;
EXTERN_C const GUID DDPF_RGB8;
EXTERN_C const GUID DDPF_RGB332;
EXTERN_C const GUID DDPF_ARGB4444;
EXTERN_C const GUID DDPF_RGB565;
EXTERN_C const GUID DDPF_BGR565;
EXTERN_C const GUID DDPF_RGB555;
EXTERN_C const GUID DDPF_ARGB1555;
EXTERN_C const GUID DDPF_RGB24;
EXTERN_C const GUID DDPF_BGR24;
EXTERN_C const GUID DDPF_RGB32;
EXTERN_C const GUID DDPF_BGR32;
EXTERN_C const GUID DDPF_ABGR32;
EXTERN_C const GUID DDPF_ARGB32;
EXTERN_C const GUID DDPF_PMARGB32;
EXTERN_C const GUID DDPF_A1;
EXTERN_C const GUID DDPF_A2;
EXTERN_C const GUID DDPF_A4;
EXTERN_C const GUID DDPF_A8;
EXTERN_C const GUID DDPF_Z8;
EXTERN_C const GUID DDPF_Z16;
EXTERN_C const GUID DDPF_Z24;
EXTERN_C const GUID DDPF_Z32;
//
//   Component categories
//
EXTERN_C const GUID CATID_DXImageTransform;
EXTERN_C const GUID CATID_DX3DTransform;
EXTERN_C const GUID CATID_DXAuthoringTransform;
EXTERN_C const GUID CATID_DXSurface;
//
//   Service IDs
//
EXTERN_C const GUID SID_SDirectDraw;
EXTERN_C const GUID SID_SDirect3DRM;
#define SID_SDXTaskManager CLSID_DXTaskManager
#define SID_SDXSurfaceFactory IID_IDXSurfaceFactory


extern RPC_IF_HANDLE __MIDL_itf_dxtrans_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_dxtrans_0000_v0_0_s_ifspec;

#ifndef __IDXBaseObject_INTERFACE_DEFINED__
#define __IDXBaseObject_INTERFACE_DEFINED__

/* interface IDXBaseObject */
/* [object][unique][helpstring][uuid] */ 


EXTERN_C const IID IID_IDXBaseObject;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("17B59B2B-9CC8-11d1-9053-00C04FD9189D")
    IDXBaseObject : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetGenerationId( 
            /* [out] */ ULONG __RPC_FAR *pID) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IncrementGenerationId( 
            /* [in] */ BOOL bRefresh) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetObjectSize( 
            /* [out] */ ULONG __RPC_FAR *pcbSize) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDXBaseObjectVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDXBaseObject __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDXBaseObject __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDXBaseObject __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetGenerationId )( 
            IDXBaseObject __RPC_FAR * This,
            /* [out] */ ULONG __RPC_FAR *pID);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *IncrementGenerationId )( 
            IDXBaseObject __RPC_FAR * This,
            /* [in] */ BOOL bRefresh);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetObjectSize )( 
            IDXBaseObject __RPC_FAR * This,
            /* [out] */ ULONG __RPC_FAR *pcbSize);
        
        END_INTERFACE
    } IDXBaseObjectVtbl;

    interface IDXBaseObject
    {
        CONST_VTBL struct IDXBaseObjectVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDXBaseObject_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDXBaseObject_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDXBaseObject_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDXBaseObject_GetGenerationId(This,pID)	\
    (This)->lpVtbl -> GetGenerationId(This,pID)

#define IDXBaseObject_IncrementGenerationId(This,bRefresh)	\
    (This)->lpVtbl -> IncrementGenerationId(This,bRefresh)

#define IDXBaseObject_GetObjectSize(This,pcbSize)	\
    (This)->lpVtbl -> GetObjectSize(This,pcbSize)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDXBaseObject_GetGenerationId_Proxy( 
    IDXBaseObject __RPC_FAR * This,
    /* [out] */ ULONG __RPC_FAR *pID);


void __RPC_STUB IDXBaseObject_GetGenerationId_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXBaseObject_IncrementGenerationId_Proxy( 
    IDXBaseObject __RPC_FAR * This,
    /* [in] */ BOOL bRefresh);


void __RPC_STUB IDXBaseObject_IncrementGenerationId_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXBaseObject_GetObjectSize_Proxy( 
    IDXBaseObject __RPC_FAR * This,
    /* [out] */ ULONG __RPC_FAR *pcbSize);


void __RPC_STUB IDXBaseObject_GetObjectSize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDXBaseObject_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_dxtrans_0252 */
/* [local] */ 

typedef 
enum DXFILTERTYPE
    {	DXFILTER_NEAREST	= 0,
	DXFILTER_BILINEAR	= DXFILTER_NEAREST + 1,
	DXFILTER_CUBIC	= DXFILTER_BILINEAR + 1,
	DXFILTER_BSPLINE	= DXFILTER_CUBIC + 1,
	DXFILTER_NUM_FILTERS	= DXFILTER_BSPLINE + 1
    }	DXFILTERTYPE;

typedef 
enum DX2DXFORMOPS
    {	DX2DXO_IDENTITY	= 0,
	DX2DXO_TRANSLATE	= DX2DXO_IDENTITY + 1,
	DX2DXO_SCALE	= DX2DXO_TRANSLATE + 1,
	DX2DXO_SCALE_AND_TRANS	= DX2DXO_SCALE + 1,
	DX2DXO_GENERAL	= DX2DXO_SCALE_AND_TRANS + 1,
	DX2DXO_GENERAL_AND_TRANS	= DX2DXO_GENERAL + 1
    }	DX2DXFORMOPS;

typedef struct DX2DXFORM
    {
    FLOAT eM11;
    FLOAT eM12;
    FLOAT eM21;
    FLOAT eM22;
    FLOAT eDx;
    FLOAT eDy;
    DX2DXFORMOPS eOp;
    }	DX2DXFORM;

typedef struct DX2DXFORM __RPC_FAR *PDX2DXFORM;

typedef 
enum DXBNDID
    {	DXB_X	= 0,
	DXB_Y	= 1,
	DXB_Z	= 2,
	DXB_T	= 3
    }	DXBNDID;

typedef 
enum DXBNDTYPE
    {	DXBT_DISCRETE	= 0,
	DXBT_DISCRETE64	= DXBT_DISCRETE + 1,
	DXBT_CONTINUOUS	= DXBT_DISCRETE64 + 1,
	DXBT_CONTINUOUS64	= DXBT_CONTINUOUS + 1
    }	DXBNDTYPE;

typedef struct DXDBND
    {
    long Min;
    long Max;
    }	DXDBND;

typedef DXDBND __RPC_FAR DXDBNDS[ 4 ];

typedef struct DXDBND64
    {
    LONGLONG Min;
    LONGLONG Max;
    }	DXDBND64;

typedef DXDBND64 __RPC_FAR DXDBNDS64[ 4 ];

typedef struct DXCBND
    {
    float Min;
    float Max;
    }	DXCBND;

typedef DXCBND __RPC_FAR DXCBNDS[ 4 ];

typedef struct DXCBND64
    {
    double Min;
    double Max;
    }	DXCBND64;

typedef DXCBND64 __RPC_FAR DXCBNDS64[ 4 ];

typedef struct DXBNDS
    {
    DXBNDTYPE eType;
    /* [switch_is] */ /* [switch_type] */ union __MIDL___MIDL_itf_dxtrans_0252_0001
        {
        /* [case()] */ DXDBND D[ 4 ];
        /* [case()] */ DXDBND64 LD[ 4 ];
        /* [case()] */ DXCBND C[ 4 ];
        /* [case()] */ DXCBND64 LC[ 4 ];
        }	u;
    }	DXBNDS;

typedef long __RPC_FAR DXDVEC[ 4 ];

typedef LONGLONG __RPC_FAR DXDVEC64[ 4 ];

typedef float __RPC_FAR DXCVEC[ 4 ];

typedef double __RPC_FAR DXCVEC64[ 4 ];

typedef struct DXVEC
    {
    DXBNDTYPE eType;
    /* [switch_is] */ /* [switch_type] */ union __MIDL___MIDL_itf_dxtrans_0252_0002
        {
        /* [case()] */ long D[ 4 ];
        /* [case()] */ LONGLONG LD[ 4 ];
        /* [case()] */ float C[ 4 ];
        /* [case()] */ double LC[ 4 ];
        }	u;
    }	DXVEC;



extern RPC_IF_HANDLE __MIDL_itf_dxtrans_0252_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_dxtrans_0252_v0_0_s_ifspec;

#ifndef __IDXTransformFactory_INTERFACE_DEFINED__
#define __IDXTransformFactory_INTERFACE_DEFINED__

/* interface IDXTransformFactory */
/* [object][unique][helpstring][uuid] */ 


EXTERN_C const IID IID_IDXTransformFactory;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("6A950B2B-A971-11d1-81C8-0000F87557DB")
    IDXTransformFactory : public IServiceProvider
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetService( 
            /* [in] */ REFGUID guidService,
            /* [in] */ IUnknown __RPC_FAR *pUnkService,
            /* [in] */ BOOL bWeakReference) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateTransform( 
            /* [size_is][in] */ IUnknown __RPC_FAR *__RPC_FAR *punkInputs,
            /* [in] */ ULONG ulNumInputs,
            /* [size_is][in] */ IUnknown __RPC_FAR *__RPC_FAR *punkOutputs,
            /* [in] */ ULONG ulNumOutputs,
            /* [in] */ IPropertyBag __RPC_FAR *pInitProps,
            /* [in] */ IErrorLog __RPC_FAR *pErrLog,
            /* [in] */ REFCLSID TransCLSID,
            /* [in] */ REFIID TransIID,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppTransform) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE InitializeTransform( 
            /* [in] */ IDXTransform __RPC_FAR *pTransform,
            /* [size_is][in] */ IUnknown __RPC_FAR *__RPC_FAR *punkInputs,
            /* [in] */ ULONG ulNumInputs,
            /* [size_is][in] */ IUnknown __RPC_FAR *__RPC_FAR *punkOutputs,
            /* [in] */ ULONG ulNumOutputs,
            /* [in] */ IPropertyBag __RPC_FAR *pInitProps,
            /* [in] */ IErrorLog __RPC_FAR *pErrLog) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDXTransformFactoryVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDXTransformFactory __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDXTransformFactory __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDXTransformFactory __RPC_FAR * This);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryService )( 
            IDXTransformFactory __RPC_FAR * This,
            /* [in] */ REFGUID guidService,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetService )( 
            IDXTransformFactory __RPC_FAR * This,
            /* [in] */ REFGUID guidService,
            /* [in] */ IUnknown __RPC_FAR *pUnkService,
            /* [in] */ BOOL bWeakReference);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreateTransform )( 
            IDXTransformFactory __RPC_FAR * This,
            /* [size_is][in] */ IUnknown __RPC_FAR *__RPC_FAR *punkInputs,
            /* [in] */ ULONG ulNumInputs,
            /* [size_is][in] */ IUnknown __RPC_FAR *__RPC_FAR *punkOutputs,
            /* [in] */ ULONG ulNumOutputs,
            /* [in] */ IPropertyBag __RPC_FAR *pInitProps,
            /* [in] */ IErrorLog __RPC_FAR *pErrLog,
            /* [in] */ REFCLSID TransCLSID,
            /* [in] */ REFIID TransIID,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppTransform);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *InitializeTransform )( 
            IDXTransformFactory __RPC_FAR * This,
            /* [in] */ IDXTransform __RPC_FAR *pTransform,
            /* [size_is][in] */ IUnknown __RPC_FAR *__RPC_FAR *punkInputs,
            /* [in] */ ULONG ulNumInputs,
            /* [size_is][in] */ IUnknown __RPC_FAR *__RPC_FAR *punkOutputs,
            /* [in] */ ULONG ulNumOutputs,
            /* [in] */ IPropertyBag __RPC_FAR *pInitProps,
            /* [in] */ IErrorLog __RPC_FAR *pErrLog);
        
        END_INTERFACE
    } IDXTransformFactoryVtbl;

    interface IDXTransformFactory
    {
        CONST_VTBL struct IDXTransformFactoryVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDXTransformFactory_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDXTransformFactory_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDXTransformFactory_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDXTransformFactory_QueryService(This,guidService,riid,ppvObject)	\
    (This)->lpVtbl -> QueryService(This,guidService,riid,ppvObject)


#define IDXTransformFactory_SetService(This,guidService,pUnkService,bWeakReference)	\
    (This)->lpVtbl -> SetService(This,guidService,pUnkService,bWeakReference)

#define IDXTransformFactory_CreateTransform(This,punkInputs,ulNumInputs,punkOutputs,ulNumOutputs,pInitProps,pErrLog,TransCLSID,TransIID,ppTransform)	\
    (This)->lpVtbl -> CreateTransform(This,punkInputs,ulNumInputs,punkOutputs,ulNumOutputs,pInitProps,pErrLog,TransCLSID,TransIID,ppTransform)

#define IDXTransformFactory_InitializeTransform(This,pTransform,punkInputs,ulNumInputs,punkOutputs,ulNumOutputs,pInitProps,pErrLog)	\
    (This)->lpVtbl -> InitializeTransform(This,pTransform,punkInputs,ulNumInputs,punkOutputs,ulNumOutputs,pInitProps,pErrLog)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDXTransformFactory_SetService_Proxy( 
    IDXTransformFactory __RPC_FAR * This,
    /* [in] */ REFGUID guidService,
    /* [in] */ IUnknown __RPC_FAR *pUnkService,
    /* [in] */ BOOL bWeakReference);


void __RPC_STUB IDXTransformFactory_SetService_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXTransformFactory_CreateTransform_Proxy( 
    IDXTransformFactory __RPC_FAR * This,
    /* [size_is][in] */ IUnknown __RPC_FAR *__RPC_FAR *punkInputs,
    /* [in] */ ULONG ulNumInputs,
    /* [size_is][in] */ IUnknown __RPC_FAR *__RPC_FAR *punkOutputs,
    /* [in] */ ULONG ulNumOutputs,
    /* [in] */ IPropertyBag __RPC_FAR *pInitProps,
    /* [in] */ IErrorLog __RPC_FAR *pErrLog,
    /* [in] */ REFCLSID TransCLSID,
    /* [in] */ REFIID TransIID,
    /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppTransform);


void __RPC_STUB IDXTransformFactory_CreateTransform_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXTransformFactory_InitializeTransform_Proxy( 
    IDXTransformFactory __RPC_FAR * This,
    /* [in] */ IDXTransform __RPC_FAR *pTransform,
    /* [size_is][in] */ IUnknown __RPC_FAR *__RPC_FAR *punkInputs,
    /* [in] */ ULONG ulNumInputs,
    /* [size_is][in] */ IUnknown __RPC_FAR *__RPC_FAR *punkOutputs,
    /* [in] */ ULONG ulNumOutputs,
    /* [in] */ IPropertyBag __RPC_FAR *pInitProps,
    /* [in] */ IErrorLog __RPC_FAR *pErrLog);


void __RPC_STUB IDXTransformFactory_InitializeTransform_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDXTransformFactory_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_dxtrans_0253 */
/* [local] */ 

typedef 
enum DXTMISCFLAGS
    {	DXTMF_BLEND_WITH_OUTPUT	= 1L << 0,
	DXTMF_DITHER_OUTPUT	= 1L << 1,
	DXTMF_OPTION_MASK	= 0xffff,
	DXTMF_VALID_OPTIONS	= DXTMF_BLEND_WITH_OUTPUT | DXTMF_DITHER_OUTPUT,
	DXTMF_BLEND_SUPPORTED	= 1L << 16,
	DXTMF_DITHER_SUPPORTED	= 1L << 17,
	DXTMF_INPLACE_OPERATION	= 1L << 24,
	DXTMF_BOUNDS_SUPPORTED	= 1L << 25,
	DXTMF_PLACEMENT_SUPPORTED	= 1L << 26,
	DXTMF_QUALITY_SUPPORTED	= 1L << 27,
	DXTMF_OPAQUE_RESULT	= 1L << 28
    }	DXTMISCFLAGS;

typedef 
enum DXINOUTINFOFLAGS
    {	DXINOUTF_OPTIONAL	= 1L << 0
    }	DXINOUTINFOFLAGS;



extern RPC_IF_HANDLE __MIDL_itf_dxtrans_0253_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_dxtrans_0253_v0_0_s_ifspec;

#ifndef __IDXTransform_INTERFACE_DEFINED__
#define __IDXTransform_INTERFACE_DEFINED__

/* interface IDXTransform */
/* [object][unique][helpstring][uuid] */ 


EXTERN_C const IID IID_IDXTransform;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("30A5FB78-E11F-11d1-9064-00C04FD9189D")
    IDXTransform : public IDXBaseObject
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Setup( 
            /* [size_is][in] */ IUnknown __RPC_FAR *const __RPC_FAR *punkInputs,
            /* [in] */ ULONG ulNumInputs,
            /* [size_is][in] */ IUnknown __RPC_FAR *const __RPC_FAR *punkOutputs,
            /* [in] */ ULONG ulNumOutputs,
            /* [in] */ DWORD dwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Execute( 
            /* [in] */ const GUID __RPC_FAR *pRequestID,
            /* [in] */ const DXBNDS __RPC_FAR *pClipBnds,
            /* [in] */ const DXVEC __RPC_FAR *pPlacement) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE MapBoundsIn2Out( 
            /* [in] */ const DXBNDS __RPC_FAR *pInBounds,
            /* [in] */ ULONG ulNumInBnds,
            /* [in] */ ULONG ulOutIndex,
            /* [out] */ DXBNDS __RPC_FAR *pOutBounds) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE MapBoundsOut2In( 
            /* [in] */ ULONG ulOutIndex,
            /* [in] */ const DXBNDS __RPC_FAR *pOutBounds,
            /* [in] */ ULONG ulInIndex,
            /* [out] */ DXBNDS __RPC_FAR *pInBounds) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetMiscFlags( 
            /* [in] */ DWORD dwMiscFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetMiscFlags( 
            /* [out] */ DWORD __RPC_FAR *pdwMiscFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetInOutInfo( 
            /* [in] */ BOOL bIsOutput,
            /* [in] */ ULONG ulIndex,
            /* [out] */ DWORD __RPC_FAR *pdwFlags,
            /* [size_is][out] */ GUID __RPC_FAR *pIDs,
            /* [out][in] */ ULONG __RPC_FAR *pcIDs,
            /* [out] */ IUnknown __RPC_FAR *__RPC_FAR *ppUnkCurrentObject) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetQuality( 
            /* [in] */ float fQuality) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetQuality( 
            /* [out] */ float __RPC_FAR *fQuality) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDXTransformVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDXTransform __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDXTransform __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDXTransform __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetGenerationId )( 
            IDXTransform __RPC_FAR * This,
            /* [out] */ ULONG __RPC_FAR *pID);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *IncrementGenerationId )( 
            IDXTransform __RPC_FAR * This,
            /* [in] */ BOOL bRefresh);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetObjectSize )( 
            IDXTransform __RPC_FAR * This,
            /* [out] */ ULONG __RPC_FAR *pcbSize);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Setup )( 
            IDXTransform __RPC_FAR * This,
            /* [size_is][in] */ IUnknown __RPC_FAR *const __RPC_FAR *punkInputs,
            /* [in] */ ULONG ulNumInputs,
            /* [size_is][in] */ IUnknown __RPC_FAR *const __RPC_FAR *punkOutputs,
            /* [in] */ ULONG ulNumOutputs,
            /* [in] */ DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Execute )( 
            IDXTransform __RPC_FAR * This,
            /* [in] */ const GUID __RPC_FAR *pRequestID,
            /* [in] */ const DXBNDS __RPC_FAR *pClipBnds,
            /* [in] */ const DXVEC __RPC_FAR *pPlacement);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *MapBoundsIn2Out )( 
            IDXTransform __RPC_FAR * This,
            /* [in] */ const DXBNDS __RPC_FAR *pInBounds,
            /* [in] */ ULONG ulNumInBnds,
            /* [in] */ ULONG ulOutIndex,
            /* [out] */ DXBNDS __RPC_FAR *pOutBounds);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *MapBoundsOut2In )( 
            IDXTransform __RPC_FAR * This,
            /* [in] */ ULONG ulOutIndex,
            /* [in] */ const DXBNDS __RPC_FAR *pOutBounds,
            /* [in] */ ULONG ulInIndex,
            /* [out] */ DXBNDS __RPC_FAR *pInBounds);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetMiscFlags )( 
            IDXTransform __RPC_FAR * This,
            /* [in] */ DWORD dwMiscFlags);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetMiscFlags )( 
            IDXTransform __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pdwMiscFlags);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetInOutInfo )( 
            IDXTransform __RPC_FAR * This,
            /* [in] */ BOOL bIsOutput,
            /* [in] */ ULONG ulIndex,
            /* [out] */ DWORD __RPC_FAR *pdwFlags,
            /* [size_is][out] */ GUID __RPC_FAR *pIDs,
            /* [out][in] */ ULONG __RPC_FAR *pcIDs,
            /* [out] */ IUnknown __RPC_FAR *__RPC_FAR *ppUnkCurrentObject);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetQuality )( 
            IDXTransform __RPC_FAR * This,
            /* [in] */ float fQuality);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetQuality )( 
            IDXTransform __RPC_FAR * This,
            /* [out] */ float __RPC_FAR *fQuality);
        
        END_INTERFACE
    } IDXTransformVtbl;

    interface IDXTransform
    {
        CONST_VTBL struct IDXTransformVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDXTransform_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDXTransform_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDXTransform_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDXTransform_GetGenerationId(This,pID)	\
    (This)->lpVtbl -> GetGenerationId(This,pID)

#define IDXTransform_IncrementGenerationId(This,bRefresh)	\
    (This)->lpVtbl -> IncrementGenerationId(This,bRefresh)

#define IDXTransform_GetObjectSize(This,pcbSize)	\
    (This)->lpVtbl -> GetObjectSize(This,pcbSize)


#define IDXTransform_Setup(This,punkInputs,ulNumInputs,punkOutputs,ulNumOutputs,dwFlags)	\
    (This)->lpVtbl -> Setup(This,punkInputs,ulNumInputs,punkOutputs,ulNumOutputs,dwFlags)

#define IDXTransform_Execute(This,pRequestID,pClipBnds,pPlacement)	\
    (This)->lpVtbl -> Execute(This,pRequestID,pClipBnds,pPlacement)

#define IDXTransform_MapBoundsIn2Out(This,pInBounds,ulNumInBnds,ulOutIndex,pOutBounds)	\
    (This)->lpVtbl -> MapBoundsIn2Out(This,pInBounds,ulNumInBnds,ulOutIndex,pOutBounds)

#define IDXTransform_MapBoundsOut2In(This,ulOutIndex,pOutBounds,ulInIndex,pInBounds)	\
    (This)->lpVtbl -> MapBoundsOut2In(This,ulOutIndex,pOutBounds,ulInIndex,pInBounds)

#define IDXTransform_SetMiscFlags(This,dwMiscFlags)	\
    (This)->lpVtbl -> SetMiscFlags(This,dwMiscFlags)

#define IDXTransform_GetMiscFlags(This,pdwMiscFlags)	\
    (This)->lpVtbl -> GetMiscFlags(This,pdwMiscFlags)

#define IDXTransform_GetInOutInfo(This,bIsOutput,ulIndex,pdwFlags,pIDs,pcIDs,ppUnkCurrentObject)	\
    (This)->lpVtbl -> GetInOutInfo(This,bIsOutput,ulIndex,pdwFlags,pIDs,pcIDs,ppUnkCurrentObject)

#define IDXTransform_SetQuality(This,fQuality)	\
    (This)->lpVtbl -> SetQuality(This,fQuality)

#define IDXTransform_GetQuality(This,fQuality)	\
    (This)->lpVtbl -> GetQuality(This,fQuality)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDXTransform_Setup_Proxy( 
    IDXTransform __RPC_FAR * This,
    /* [size_is][in] */ IUnknown __RPC_FAR *const __RPC_FAR *punkInputs,
    /* [in] */ ULONG ulNumInputs,
    /* [size_is][in] */ IUnknown __RPC_FAR *const __RPC_FAR *punkOutputs,
    /* [in] */ ULONG ulNumOutputs,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB IDXTransform_Setup_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXTransform_Execute_Proxy( 
    IDXTransform __RPC_FAR * This,
    /* [in] */ const GUID __RPC_FAR *pRequestID,
    /* [in] */ const DXBNDS __RPC_FAR *pClipBnds,
    /* [in] */ const DXVEC __RPC_FAR *pPlacement);


void __RPC_STUB IDXTransform_Execute_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXTransform_MapBoundsIn2Out_Proxy( 
    IDXTransform __RPC_FAR * This,
    /* [in] */ const DXBNDS __RPC_FAR *pInBounds,
    /* [in] */ ULONG ulNumInBnds,
    /* [in] */ ULONG ulOutIndex,
    /* [out] */ DXBNDS __RPC_FAR *pOutBounds);


void __RPC_STUB IDXTransform_MapBoundsIn2Out_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXTransform_MapBoundsOut2In_Proxy( 
    IDXTransform __RPC_FAR * This,
    /* [in] */ ULONG ulOutIndex,
    /* [in] */ const DXBNDS __RPC_FAR *pOutBounds,
    /* [in] */ ULONG ulInIndex,
    /* [out] */ DXBNDS __RPC_FAR *pInBounds);


void __RPC_STUB IDXTransform_MapBoundsOut2In_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXTransform_SetMiscFlags_Proxy( 
    IDXTransform __RPC_FAR * This,
    /* [in] */ DWORD dwMiscFlags);


void __RPC_STUB IDXTransform_SetMiscFlags_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXTransform_GetMiscFlags_Proxy( 
    IDXTransform __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *pdwMiscFlags);


void __RPC_STUB IDXTransform_GetMiscFlags_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXTransform_GetInOutInfo_Proxy( 
    IDXTransform __RPC_FAR * This,
    /* [in] */ BOOL bIsOutput,
    /* [in] */ ULONG ulIndex,
    /* [out] */ DWORD __RPC_FAR *pdwFlags,
    /* [size_is][out] */ GUID __RPC_FAR *pIDs,
    /* [out][in] */ ULONG __RPC_FAR *pcIDs,
    /* [out] */ IUnknown __RPC_FAR *__RPC_FAR *ppUnkCurrentObject);


void __RPC_STUB IDXTransform_GetInOutInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXTransform_SetQuality_Proxy( 
    IDXTransform __RPC_FAR * This,
    /* [in] */ float fQuality);


void __RPC_STUB IDXTransform_SetQuality_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXTransform_GetQuality_Proxy( 
    IDXTransform __RPC_FAR * This,
    /* [out] */ float __RPC_FAR *fQuality);


void __RPC_STUB IDXTransform_GetQuality_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDXTransform_INTERFACE_DEFINED__ */


#ifndef __IDXSurfacePick_INTERFACE_DEFINED__
#define __IDXSurfacePick_INTERFACE_DEFINED__

/* interface IDXSurfacePick */
/* [object][unique][helpstring][uuid] */ 


EXTERN_C const IID IID_IDXSurfacePick;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("30A5FB79-E11F-11d1-9064-00C04FD9189D")
    IDXSurfacePick : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE PointPick( 
            /* [in] */ const DXVEC __RPC_FAR *pPoint,
            /* [out] */ ULONG __RPC_FAR *pulInputSurfaceIndex,
            /* [out] */ DXVEC __RPC_FAR *pInputPoint) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDXSurfacePickVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDXSurfacePick __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDXSurfacePick __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDXSurfacePick __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *PointPick )( 
            IDXSurfacePick __RPC_FAR * This,
            /* [in] */ const DXVEC __RPC_FAR *pPoint,
            /* [out] */ ULONG __RPC_FAR *pulInputSurfaceIndex,
            /* [out] */ DXVEC __RPC_FAR *pInputPoint);
        
        END_INTERFACE
    } IDXSurfacePickVtbl;

    interface IDXSurfacePick
    {
        CONST_VTBL struct IDXSurfacePickVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDXSurfacePick_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDXSurfacePick_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDXSurfacePick_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDXSurfacePick_PointPick(This,pPoint,pulInputSurfaceIndex,pInputPoint)	\
    (This)->lpVtbl -> PointPick(This,pPoint,pulInputSurfaceIndex,pInputPoint)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDXSurfacePick_PointPick_Proxy( 
    IDXSurfacePick __RPC_FAR * This,
    /* [in] */ const DXVEC __RPC_FAR *pPoint,
    /* [out] */ ULONG __RPC_FAR *pulInputSurfaceIndex,
    /* [out] */ DXVEC __RPC_FAR *pInputPoint);


void __RPC_STUB IDXSurfacePick_PointPick_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDXSurfacePick_INTERFACE_DEFINED__ */


#ifndef __IDXTBindHost_INTERFACE_DEFINED__
#define __IDXTBindHost_INTERFACE_DEFINED__

/* interface IDXTBindHost */
/* [object][local][unique][helpstring][uuid] */ 


EXTERN_C const IID IID_IDXTBindHost;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("D26BCE55-E9DC-11d1-9066-00C04FD9189D")
    IDXTBindHost : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetBindHost( 
            /* [in] */ IBindHost __RPC_FAR *pBindHost) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDXTBindHostVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDXTBindHost __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDXTBindHost __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDXTBindHost __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetBindHost )( 
            IDXTBindHost __RPC_FAR * This,
            /* [in] */ IBindHost __RPC_FAR *pBindHost);
        
        END_INTERFACE
    } IDXTBindHostVtbl;

    interface IDXTBindHost
    {
        CONST_VTBL struct IDXTBindHostVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDXTBindHost_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDXTBindHost_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDXTBindHost_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDXTBindHost_SetBindHost(This,pBindHost)	\
    (This)->lpVtbl -> SetBindHost(This,pBindHost)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDXTBindHost_SetBindHost_Proxy( 
    IDXTBindHost __RPC_FAR * This,
    /* [in] */ IBindHost __RPC_FAR *pBindHost);


void __RPC_STUB IDXTBindHost_SetBindHost_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDXTBindHost_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_dxtrans_0256 */
/* [local] */ 

typedef void __stdcall __stdcall DXTASKPROC( 
    void __RPC_FAR *pTaskData,
    BOOL __RPC_FAR *pbContinueProcessing);

typedef DXTASKPROC __RPC_FAR *PFNDXTASKPROC;

typedef void __stdcall __stdcall DXAPCPROC( 
    DWORD dwData);

typedef DXAPCPROC __RPC_FAR *PFNDXAPCPROC;

#ifdef __cplusplus
typedef struct DXTMTASKINFO
{
    PFNDXTASKPROC pfnTaskProc;       // Pointer to function to execute
    PVOID         pTaskData;         // Pointer to argument data
    PFNDXAPCPROC  pfnCompletionAPC;  // Pointer to completion APC proc
    DWORD         dwCompletionData;  // Pointer to APC proc data
    const GUID*   pRequestID;        // Used to identify groups of tasks
} DXTMTASKINFO;
#else
typedef struct DXTMTASKINFO
    {
    PVOID pfnTaskProc;
    PVOID pTaskData;
    PVOID pfnCompletionAPC;
    DWORD dwCompletionData;
    const GUID __RPC_FAR *pRequestID;
    }	DXTMTASKINFO;

#endif


extern RPC_IF_HANDLE __MIDL_itf_dxtrans_0256_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_dxtrans_0256_v0_0_s_ifspec;

#ifndef __IDXTaskManager_INTERFACE_DEFINED__
#define __IDXTaskManager_INTERFACE_DEFINED__

/* interface IDXTaskManager */
/* [object][unique][helpstring][uuid][local] */ 


EXTERN_C const IID IID_IDXTaskManager;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("254DBBC1-F922-11d0-883A-3C8B00C10000")
    IDXTaskManager : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE QueryNumProcessors( 
            /* [out] */ ULONG __RPC_FAR *pulNumProc) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetThreadPoolSize( 
            /* [in] */ ULONG ulNumThreads) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetThreadPoolSize( 
            /* [out] */ ULONG __RPC_FAR *pulNumThreads) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetConcurrencyLimit( 
            /* [in] */ ULONG ulNumThreads) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetConcurrencyLimit( 
            /* [out] */ ULONG __RPC_FAR *pulNumThreads) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ScheduleTasks( 
            /* [in] */ DXTMTASKINFO __RPC_FAR TaskInfo[  ],
            /* [in] */ HANDLE __RPC_FAR Events[  ],
            /* [out] */ DWORD __RPC_FAR TaskIDs[  ],
            /* [in] */ ULONG ulNumTasks,
            /* [in] */ ULONG ulWaitPeriod) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE TerminateTasks( 
            /* [in] */ DWORD __RPC_FAR TaskIDs[  ],
            /* [in] */ ULONG ulCount,
            /* [in] */ ULONG ulTimeOut) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE TerminateRequest( 
            /* [in] */ REFIID RequestID,
            /* [in] */ ULONG ulTimeOut) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDXTaskManagerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDXTaskManager __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDXTaskManager __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDXTaskManager __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryNumProcessors )( 
            IDXTaskManager __RPC_FAR * This,
            /* [out] */ ULONG __RPC_FAR *pulNumProc);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetThreadPoolSize )( 
            IDXTaskManager __RPC_FAR * This,
            /* [in] */ ULONG ulNumThreads);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetThreadPoolSize )( 
            IDXTaskManager __RPC_FAR * This,
            /* [out] */ ULONG __RPC_FAR *pulNumThreads);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetConcurrencyLimit )( 
            IDXTaskManager __RPC_FAR * This,
            /* [in] */ ULONG ulNumThreads);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetConcurrencyLimit )( 
            IDXTaskManager __RPC_FAR * This,
            /* [out] */ ULONG __RPC_FAR *pulNumThreads);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ScheduleTasks )( 
            IDXTaskManager __RPC_FAR * This,
            /* [in] */ DXTMTASKINFO __RPC_FAR TaskInfo[  ],
            /* [in] */ HANDLE __RPC_FAR Events[  ],
            /* [out] */ DWORD __RPC_FAR TaskIDs[  ],
            /* [in] */ ULONG ulNumTasks,
            /* [in] */ ULONG ulWaitPeriod);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *TerminateTasks )( 
            IDXTaskManager __RPC_FAR * This,
            /* [in] */ DWORD __RPC_FAR TaskIDs[  ],
            /* [in] */ ULONG ulCount,
            /* [in] */ ULONG ulTimeOut);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *TerminateRequest )( 
            IDXTaskManager __RPC_FAR * This,
            /* [in] */ REFIID RequestID,
            /* [in] */ ULONG ulTimeOut);
        
        END_INTERFACE
    } IDXTaskManagerVtbl;

    interface IDXTaskManager
    {
        CONST_VTBL struct IDXTaskManagerVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDXTaskManager_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDXTaskManager_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDXTaskManager_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDXTaskManager_QueryNumProcessors(This,pulNumProc)	\
    (This)->lpVtbl -> QueryNumProcessors(This,pulNumProc)

#define IDXTaskManager_SetThreadPoolSize(This,ulNumThreads)	\
    (This)->lpVtbl -> SetThreadPoolSize(This,ulNumThreads)

#define IDXTaskManager_GetThreadPoolSize(This,pulNumThreads)	\
    (This)->lpVtbl -> GetThreadPoolSize(This,pulNumThreads)

#define IDXTaskManager_SetConcurrencyLimit(This,ulNumThreads)	\
    (This)->lpVtbl -> SetConcurrencyLimit(This,ulNumThreads)

#define IDXTaskManager_GetConcurrencyLimit(This,pulNumThreads)	\
    (This)->lpVtbl -> GetConcurrencyLimit(This,pulNumThreads)

#define IDXTaskManager_ScheduleTasks(This,TaskInfo,Events,TaskIDs,ulNumTasks,ulWaitPeriod)	\
    (This)->lpVtbl -> ScheduleTasks(This,TaskInfo,Events,TaskIDs,ulNumTasks,ulWaitPeriod)

#define IDXTaskManager_TerminateTasks(This,TaskIDs,ulCount,ulTimeOut)	\
    (This)->lpVtbl -> TerminateTasks(This,TaskIDs,ulCount,ulTimeOut)

#define IDXTaskManager_TerminateRequest(This,RequestID,ulTimeOut)	\
    (This)->lpVtbl -> TerminateRequest(This,RequestID,ulTimeOut)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDXTaskManager_QueryNumProcessors_Proxy( 
    IDXTaskManager __RPC_FAR * This,
    /* [out] */ ULONG __RPC_FAR *pulNumProc);


void __RPC_STUB IDXTaskManager_QueryNumProcessors_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXTaskManager_SetThreadPoolSize_Proxy( 
    IDXTaskManager __RPC_FAR * This,
    /* [in] */ ULONG ulNumThreads);


void __RPC_STUB IDXTaskManager_SetThreadPoolSize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXTaskManager_GetThreadPoolSize_Proxy( 
    IDXTaskManager __RPC_FAR * This,
    /* [out] */ ULONG __RPC_FAR *pulNumThreads);


void __RPC_STUB IDXTaskManager_GetThreadPoolSize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXTaskManager_SetConcurrencyLimit_Proxy( 
    IDXTaskManager __RPC_FAR * This,
    /* [in] */ ULONG ulNumThreads);


void __RPC_STUB IDXTaskManager_SetConcurrencyLimit_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXTaskManager_GetConcurrencyLimit_Proxy( 
    IDXTaskManager __RPC_FAR * This,
    /* [out] */ ULONG __RPC_FAR *pulNumThreads);


void __RPC_STUB IDXTaskManager_GetConcurrencyLimit_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXTaskManager_ScheduleTasks_Proxy( 
    IDXTaskManager __RPC_FAR * This,
    /* [in] */ DXTMTASKINFO __RPC_FAR TaskInfo[  ],
    /* [in] */ HANDLE __RPC_FAR Events[  ],
    /* [out] */ DWORD __RPC_FAR TaskIDs[  ],
    /* [in] */ ULONG ulNumTasks,
    /* [in] */ ULONG ulWaitPeriod);


void __RPC_STUB IDXTaskManager_ScheduleTasks_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXTaskManager_TerminateTasks_Proxy( 
    IDXTaskManager __RPC_FAR * This,
    /* [in] */ DWORD __RPC_FAR TaskIDs[  ],
    /* [in] */ ULONG ulCount,
    /* [in] */ ULONG ulTimeOut);


void __RPC_STUB IDXTaskManager_TerminateTasks_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXTaskManager_TerminateRequest_Proxy( 
    IDXTaskManager __RPC_FAR * This,
    /* [in] */ REFIID RequestID,
    /* [in] */ ULONG ulTimeOut);


void __RPC_STUB IDXTaskManager_TerminateRequest_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDXTaskManager_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_dxtrans_0257 */
/* [local] */ 

#ifdef __cplusplus
/////////////////////////////////////////////////////

class DXBASESAMPLE;
class DXSAMPLE;
class DXPMSAMPLE;

/////////////////////////////////////////////////////

class DXBASESAMPLE
{
public:
    BYTE Blue;
    BYTE Green;
    BYTE Red;
    BYTE Alpha;
    DXBASESAMPLE() {}
    DXBASESAMPLE(const BYTE alpha, const BYTE red, const BYTE green, const BYTE blue) :
        Alpha(alpha),
        Red(red),
        Green(green),
        Blue(blue) {}
    DXBASESAMPLE(const DWORD val) { *this = (*(DXBASESAMPLE *)&val); }
    operator DWORD () const {return *((DWORD *)this); }
    DWORD operator=(const DWORD val) { return *this = *((DXBASESAMPLE *)&val); }
}; // DXBASESAMPLE

/////////////////////////////////////////////////////

class DXSAMPLE : public DXBASESAMPLE
{
public:
    DXSAMPLE() {}
    DXSAMPLE(const BYTE alpha, const BYTE red, const BYTE green, const BYTE blue) :
         DXBASESAMPLE(alpha, red, green, blue) {}
    DXSAMPLE(const DWORD val) { *this = (*(DXSAMPLE *)&val); }
    operator DWORD () const {return *((DWORD *)this); }
    DWORD operator=(const DWORD val) { return *this = *((DXSAMPLE *)&val); }
    operator DXPMSAMPLE() const;
}; // DXSAMPLE

/////////////////////////////////////////////////////

class DXPMSAMPLE : public DXBASESAMPLE
{
public:
    DXPMSAMPLE() {}
    DXPMSAMPLE(const BYTE alpha, const BYTE red, const BYTE green, const BYTE blue) :
         DXBASESAMPLE(alpha, red, green, blue) {}
    DXPMSAMPLE(const DWORD val) { *this = (*(DXPMSAMPLE *)&val); }
    operator DWORD () const {return *((DWORD *)this); }
    DWORD operator=(const DWORD val) { return *this = *((DXPMSAMPLE *)&val); }
    operator DXSAMPLE() const;
}; // DXPMSAMPLE

//
// The following cast operators are to prevent a direct assignment of a DXSAMPLE to a DXPMSAMPLE
//
inline DXSAMPLE::operator DXPMSAMPLE() const { return *((DXPMSAMPLE *)this); }
inline DXPMSAMPLE::operator DXSAMPLE() const { return *((DXSAMPLE *)this); }
#else // !__cplusplus
typedef struct DXBASESAMPLE
    {
    BYTE Blue;
    BYTE Green;
    BYTE Red;
    BYTE Alpha;
    }	DXBASESAMPLE;

typedef struct DXSAMPLE
    {
    BYTE Blue;
    BYTE Green;
    BYTE Red;
    BYTE Alpha;
    }	DXSAMPLE;

typedef struct DXPMSAMPLE
    {
    BYTE Blue;
    BYTE Green;
    BYTE Red;
    BYTE Alpha;
    }	DXPMSAMPLE;

#endif // !__cplusplus
typedef 
enum DXRUNTYPE
    {	DXRUNTYPE_CLEAR	= 0,
	DXRUNTYPE_OPAQUE	= 1,
	DXRUNTYPE_TRANS	= 2,
	DXRUNTYPE_UNKNOWN	= 3
    }	DXRUNTYPE;

#define	DX_MAX_RUN_INFO_COUNT	( 128 )

// Ignore the definition used by MIDL for TLB generation
#if 0
typedef struct DXRUNINFO
    {
    ULONG Bitfields;
    }	DXRUNINFO;

#endif // 0
typedef struct DXRUNINFO
{
    ULONG   Type  : 2;   // Type
    ULONG   Count : 30;  // Number of samples in run
} DXRUNINFO;
typedef 
enum DXSFCREATE
    {	DXSF_FORMAT_IS_CLSID	= 1L << 0,
	DXSF_NO_LAZY_DDRAW_LOCK	= 1L << 1
    }	DXSFCREATE;

typedef 
enum DXBLTOPTIONS
    {	DXBOF_DO_OVER	= 1L << 0,
	DXBOF_DITHER	= 1L << 1
    }	DXBLTOPTIONS;



extern RPC_IF_HANDLE __MIDL_itf_dxtrans_0257_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_dxtrans_0257_v0_0_s_ifspec;

#ifndef __IDXSurfaceFactory_INTERFACE_DEFINED__
#define __IDXSurfaceFactory_INTERFACE_DEFINED__

/* interface IDXSurfaceFactory */
/* [object][unique][helpstring][uuid] */ 


EXTERN_C const IID IID_IDXSurfaceFactory;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("144946F5-C4D4-11d1-81D1-0000F87557DB")
    IDXSurfaceFactory : public IUnknown
    {
    public:
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE CreateSurface( 
            /* [in] */ IUnknown __RPC_FAR *pDirectDraw,
            /* [in] */ const DDSURFACEDESC __RPC_FAR *pDDSurfaceDesc,
            /* [in] */ const GUID __RPC_FAR *pFormatID,
            /* [in] */ const DXBNDS __RPC_FAR *pBounds,
            /* [in] */ DWORD dwFlags,
            /* [in] */ IUnknown __RPC_FAR *punkOuter,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppDXSurface) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateFromDDSurface( 
            /* [in] */ IUnknown __RPC_FAR *pDDrawSurface,
            /* [in] */ const GUID __RPC_FAR *pFormatID,
            /* [in] */ DWORD dwFlags,
            /* [in] */ IUnknown __RPC_FAR *punkOuter,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppDXSurface) = 0;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE LoadImage( 
            /* [in] */ const LPWSTR pszFileName,
            /* [in] */ IUnknown __RPC_FAR *pDirectDraw,
            /* [in] */ const DDSURFACEDESC __RPC_FAR *pDDSurfaceDesc,
            /* [in] */ const GUID __RPC_FAR *pFormatID,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppDXSurface) = 0;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE LoadImageFromStream( 
            /* [in] */ IStream __RPC_FAR *pStream,
            /* [in] */ IUnknown __RPC_FAR *pDirectDraw,
            /* [in] */ const DDSURFACEDESC __RPC_FAR *pDDSurfaceDesc,
            /* [in] */ const GUID __RPC_FAR *pFormatID,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppDXSurface) = 0;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE CopySurfaceToNewFormat( 
            /* [in] */ IDXSurface __RPC_FAR *pSrc,
            /* [in] */ IUnknown __RPC_FAR *pDirectDraw,
            /* [in] */ const DDSURFACEDESC __RPC_FAR *pDDSurfaceDesc,
            /* [in] */ const GUID __RPC_FAR *pDestFormatID,
            /* [out] */ IDXSurface __RPC_FAR *__RPC_FAR *ppNewSurface) = 0;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE CreateD3DRMTexture( 
            /* [in] */ IDXSurface __RPC_FAR *pSrc,
            /* [in] */ IUnknown __RPC_FAR *pDirectDraw,
            /* [in] */ IUnknown __RPC_FAR *pD3DRM3,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppTexture3) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE BitBlt( 
            /* [in] */ IDXSurface __RPC_FAR *pDest,
            /* [in] */ const DXVEC __RPC_FAR *pPlacement,
            /* [in] */ IDXSurface __RPC_FAR *pSrc,
            /* [in] */ const DXBNDS __RPC_FAR *pClipBounds,
            /* [in] */ DWORD dwFlags) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDXSurfaceFactoryVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDXSurfaceFactory __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDXSurfaceFactory __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDXSurfaceFactory __RPC_FAR * This);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreateSurface )( 
            IDXSurfaceFactory __RPC_FAR * This,
            /* [in] */ IUnknown __RPC_FAR *pDirectDraw,
            /* [in] */ const DDSURFACEDESC __RPC_FAR *pDDSurfaceDesc,
            /* [in] */ const GUID __RPC_FAR *pFormatID,
            /* [in] */ const DXBNDS __RPC_FAR *pBounds,
            /* [in] */ DWORD dwFlags,
            /* [in] */ IUnknown __RPC_FAR *punkOuter,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppDXSurface);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreateFromDDSurface )( 
            IDXSurfaceFactory __RPC_FAR * This,
            /* [in] */ IUnknown __RPC_FAR *pDDrawSurface,
            /* [in] */ const GUID __RPC_FAR *pFormatID,
            /* [in] */ DWORD dwFlags,
            /* [in] */ IUnknown __RPC_FAR *punkOuter,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppDXSurface);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *LoadImage )( 
            IDXSurfaceFactory __RPC_FAR * This,
            /* [in] */ const LPWSTR pszFileName,
            /* [in] */ IUnknown __RPC_FAR *pDirectDraw,
            /* [in] */ const DDSURFACEDESC __RPC_FAR *pDDSurfaceDesc,
            /* [in] */ const GUID __RPC_FAR *pFormatID,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppDXSurface);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *LoadImageFromStream )( 
            IDXSurfaceFactory __RPC_FAR * This,
            /* [in] */ IStream __RPC_FAR *pStream,
            /* [in] */ IUnknown __RPC_FAR *pDirectDraw,
            /* [in] */ const DDSURFACEDESC __RPC_FAR *pDDSurfaceDesc,
            /* [in] */ const GUID __RPC_FAR *pFormatID,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppDXSurface);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CopySurfaceToNewFormat )( 
            IDXSurfaceFactory __RPC_FAR * This,
            /* [in] */ IDXSurface __RPC_FAR *pSrc,
            /* [in] */ IUnknown __RPC_FAR *pDirectDraw,
            /* [in] */ const DDSURFACEDESC __RPC_FAR *pDDSurfaceDesc,
            /* [in] */ const GUID __RPC_FAR *pDestFormatID,
            /* [out] */ IDXSurface __RPC_FAR *__RPC_FAR *ppNewSurface);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreateD3DRMTexture )( 
            IDXSurfaceFactory __RPC_FAR * This,
            /* [in] */ IDXSurface __RPC_FAR *pSrc,
            /* [in] */ IUnknown __RPC_FAR *pDirectDraw,
            /* [in] */ IUnknown __RPC_FAR *pD3DRM3,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppTexture3);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *BitBlt )( 
            IDXSurfaceFactory __RPC_FAR * This,
            /* [in] */ IDXSurface __RPC_FAR *pDest,
            /* [in] */ const DXVEC __RPC_FAR *pPlacement,
            /* [in] */ IDXSurface __RPC_FAR *pSrc,
            /* [in] */ const DXBNDS __RPC_FAR *pClipBounds,
            /* [in] */ DWORD dwFlags);
        
        END_INTERFACE
    } IDXSurfaceFactoryVtbl;

    interface IDXSurfaceFactory
    {
        CONST_VTBL struct IDXSurfaceFactoryVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDXSurfaceFactory_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDXSurfaceFactory_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDXSurfaceFactory_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDXSurfaceFactory_CreateSurface(This,pDirectDraw,pDDSurfaceDesc,pFormatID,pBounds,dwFlags,punkOuter,riid,ppDXSurface)	\
    (This)->lpVtbl -> CreateSurface(This,pDirectDraw,pDDSurfaceDesc,pFormatID,pBounds,dwFlags,punkOuter,riid,ppDXSurface)

#define IDXSurfaceFactory_CreateFromDDSurface(This,pDDrawSurface,pFormatID,dwFlags,punkOuter,riid,ppDXSurface)	\
    (This)->lpVtbl -> CreateFromDDSurface(This,pDDrawSurface,pFormatID,dwFlags,punkOuter,riid,ppDXSurface)

#define IDXSurfaceFactory_LoadImage(This,pszFileName,pDirectDraw,pDDSurfaceDesc,pFormatID,riid,ppDXSurface)	\
    (This)->lpVtbl -> LoadImage(This,pszFileName,pDirectDraw,pDDSurfaceDesc,pFormatID,riid,ppDXSurface)

#define IDXSurfaceFactory_LoadImageFromStream(This,pStream,pDirectDraw,pDDSurfaceDesc,pFormatID,riid,ppDXSurface)	\
    (This)->lpVtbl -> LoadImageFromStream(This,pStream,pDirectDraw,pDDSurfaceDesc,pFormatID,riid,ppDXSurface)

#define IDXSurfaceFactory_CopySurfaceToNewFormat(This,pSrc,pDirectDraw,pDDSurfaceDesc,pDestFormatID,ppNewSurface)	\
    (This)->lpVtbl -> CopySurfaceToNewFormat(This,pSrc,pDirectDraw,pDDSurfaceDesc,pDestFormatID,ppNewSurface)

#define IDXSurfaceFactory_CreateD3DRMTexture(This,pSrc,pDirectDraw,pD3DRM3,riid,ppTexture3)	\
    (This)->lpVtbl -> CreateD3DRMTexture(This,pSrc,pDirectDraw,pD3DRM3,riid,ppTexture3)

#define IDXSurfaceFactory_BitBlt(This,pDest,pPlacement,pSrc,pClipBounds,dwFlags)	\
    (This)->lpVtbl -> BitBlt(This,pDest,pPlacement,pSrc,pClipBounds,dwFlags)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [local] */ HRESULT STDMETHODCALLTYPE IDXSurfaceFactory_CreateSurface_Proxy( 
    IDXSurfaceFactory __RPC_FAR * This,
    /* [in] */ IUnknown __RPC_FAR *pDirectDraw,
    /* [in] */ const DDSURFACEDESC __RPC_FAR *pDDSurfaceDesc,
    /* [in] */ const GUID __RPC_FAR *pFormatID,
    /* [in] */ const DXBNDS __RPC_FAR *pBounds,
    /* [in] */ DWORD dwFlags,
    /* [in] */ IUnknown __RPC_FAR *punkOuter,
    /* [in] */ REFIID riid,
    /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppDXSurface);


void __RPC_STUB IDXSurfaceFactory_CreateSurface_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXSurfaceFactory_CreateFromDDSurface_Proxy( 
    IDXSurfaceFactory __RPC_FAR * This,
    /* [in] */ IUnknown __RPC_FAR *pDDrawSurface,
    /* [in] */ const GUID __RPC_FAR *pFormatID,
    /* [in] */ DWORD dwFlags,
    /* [in] */ IUnknown __RPC_FAR *punkOuter,
    /* [in] */ REFIID riid,
    /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppDXSurface);


void __RPC_STUB IDXSurfaceFactory_CreateFromDDSurface_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [local] */ HRESULT STDMETHODCALLTYPE IDXSurfaceFactory_LoadImage_Proxy( 
    IDXSurfaceFactory __RPC_FAR * This,
    /* [in] */ const LPWSTR pszFileName,
    /* [in] */ IUnknown __RPC_FAR *pDirectDraw,
    /* [in] */ const DDSURFACEDESC __RPC_FAR *pDDSurfaceDesc,
    /* [in] */ const GUID __RPC_FAR *pFormatID,
    /* [in] */ REFIID riid,
    /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppDXSurface);


void __RPC_STUB IDXSurfaceFactory_LoadImage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [local] */ HRESULT STDMETHODCALLTYPE IDXSurfaceFactory_LoadImageFromStream_Proxy( 
    IDXSurfaceFactory __RPC_FAR * This,
    /* [in] */ IStream __RPC_FAR *pStream,
    /* [in] */ IUnknown __RPC_FAR *pDirectDraw,
    /* [in] */ const DDSURFACEDESC __RPC_FAR *pDDSurfaceDesc,
    /* [in] */ const GUID __RPC_FAR *pFormatID,
    /* [in] */ REFIID riid,
    /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppDXSurface);


void __RPC_STUB IDXSurfaceFactory_LoadImageFromStream_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [local] */ HRESULT STDMETHODCALLTYPE IDXSurfaceFactory_CopySurfaceToNewFormat_Proxy( 
    IDXSurfaceFactory __RPC_FAR * This,
    /* [in] */ IDXSurface __RPC_FAR *pSrc,
    /* [in] */ IUnknown __RPC_FAR *pDirectDraw,
    /* [in] */ const DDSURFACEDESC __RPC_FAR *pDDSurfaceDesc,
    /* [in] */ const GUID __RPC_FAR *pDestFormatID,
    /* [out] */ IDXSurface __RPC_FAR *__RPC_FAR *ppNewSurface);


void __RPC_STUB IDXSurfaceFactory_CopySurfaceToNewFormat_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [local] */ HRESULT STDMETHODCALLTYPE IDXSurfaceFactory_CreateD3DRMTexture_Proxy( 
    IDXSurfaceFactory __RPC_FAR * This,
    /* [in] */ IDXSurface __RPC_FAR *pSrc,
    /* [in] */ IUnknown __RPC_FAR *pDirectDraw,
    /* [in] */ IUnknown __RPC_FAR *pD3DRM3,
    /* [in] */ REFIID riid,
    /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppTexture3);


void __RPC_STUB IDXSurfaceFactory_CreateD3DRMTexture_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXSurfaceFactory_BitBlt_Proxy( 
    IDXSurfaceFactory __RPC_FAR * This,
    /* [in] */ IDXSurface __RPC_FAR *pDest,
    /* [in] */ const DXVEC __RPC_FAR *pPlacement,
    /* [in] */ IDXSurface __RPC_FAR *pSrc,
    /* [in] */ const DXBNDS __RPC_FAR *pClipBounds,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB IDXSurfaceFactory_BitBlt_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDXSurfaceFactory_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_dxtrans_0258 */
/* [local] */ 

typedef 
enum DXSURFMODCOMPOP
    {	DXSURFMOD_COMP_OVER	= 0,
	DXSURFMOD_COMP_ALPHA_MASK	= 1,
	DXSURFMOD_COMP_MAX_VALID	= 1
    }	DXSURFMODCOMPOP;



extern RPC_IF_HANDLE __MIDL_itf_dxtrans_0258_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_dxtrans_0258_v0_0_s_ifspec;

#ifndef __IDXSurfaceModifier_INTERFACE_DEFINED__
#define __IDXSurfaceModifier_INTERFACE_DEFINED__

/* interface IDXSurfaceModifier */
/* [object][unique][helpstring][uuid] */ 


EXTERN_C const IID IID_IDXSurfaceModifier;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("9EA3B637-C37D-11d1-905E-00C04FD9189D")
    IDXSurfaceModifier : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetFillColor( 
            /* [in] */ DXSAMPLE Color) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFillColor( 
            /* [out] */ DXSAMPLE __RPC_FAR *pColor) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetBounds( 
            /* [in] */ const DXBNDS __RPC_FAR *pBounds) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetBackground( 
            /* [in] */ IDXSurface __RPC_FAR *pSurface) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetBackground( 
            /* [out] */ IDXSurface __RPC_FAR *__RPC_FAR *ppSurface) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetCompositeOperation( 
            /* [in] */ DXSURFMODCOMPOP CompOp) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCompositeOperation( 
            /* [out] */ DXSURFMODCOMPOP __RPC_FAR *pCompOp) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetForeground( 
            /* [in] */ IDXSurface __RPC_FAR *pSurface,
            /* [in] */ BOOL bTile,
            /* [in] */ const POINT __RPC_FAR *pOrigin) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetForeground( 
            /* [out] */ IDXSurface __RPC_FAR *__RPC_FAR *ppSurface,
            /* [out] */ BOOL __RPC_FAR *pbTile,
            /* [out] */ POINT __RPC_FAR *pOrigin) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetOpacity( 
            /* [in] */ float Opacity) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetOpacity( 
            /* [out] */ float __RPC_FAR *pOpacity) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetLookup( 
            /* [in] */ IDXLookupTable __RPC_FAR *pLookupTable) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetLookup( 
            /* [out] */ IDXLookupTable __RPC_FAR *__RPC_FAR *ppLookupTable) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDXSurfaceModifierVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDXSurfaceModifier __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDXSurfaceModifier __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDXSurfaceModifier __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetFillColor )( 
            IDXSurfaceModifier __RPC_FAR * This,
            /* [in] */ DXSAMPLE Color);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetFillColor )( 
            IDXSurfaceModifier __RPC_FAR * This,
            /* [out] */ DXSAMPLE __RPC_FAR *pColor);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetBounds )( 
            IDXSurfaceModifier __RPC_FAR * This,
            /* [in] */ const DXBNDS __RPC_FAR *pBounds);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetBackground )( 
            IDXSurfaceModifier __RPC_FAR * This,
            /* [in] */ IDXSurface __RPC_FAR *pSurface);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetBackground )( 
            IDXSurfaceModifier __RPC_FAR * This,
            /* [out] */ IDXSurface __RPC_FAR *__RPC_FAR *ppSurface);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetCompositeOperation )( 
            IDXSurfaceModifier __RPC_FAR * This,
            /* [in] */ DXSURFMODCOMPOP CompOp);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCompositeOperation )( 
            IDXSurfaceModifier __RPC_FAR * This,
            /* [out] */ DXSURFMODCOMPOP __RPC_FAR *pCompOp);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetForeground )( 
            IDXSurfaceModifier __RPC_FAR * This,
            /* [in] */ IDXSurface __RPC_FAR *pSurface,
            /* [in] */ BOOL bTile,
            /* [in] */ const POINT __RPC_FAR *pOrigin);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetForeground )( 
            IDXSurfaceModifier __RPC_FAR * This,
            /* [out] */ IDXSurface __RPC_FAR *__RPC_FAR *ppSurface,
            /* [out] */ BOOL __RPC_FAR *pbTile,
            /* [out] */ POINT __RPC_FAR *pOrigin);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetOpacity )( 
            IDXSurfaceModifier __RPC_FAR * This,
            /* [in] */ float Opacity);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetOpacity )( 
            IDXSurfaceModifier __RPC_FAR * This,
            /* [out] */ float __RPC_FAR *pOpacity);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetLookup )( 
            IDXSurfaceModifier __RPC_FAR * This,
            /* [in] */ IDXLookupTable __RPC_FAR *pLookupTable);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetLookup )( 
            IDXSurfaceModifier __RPC_FAR * This,
            /* [out] */ IDXLookupTable __RPC_FAR *__RPC_FAR *ppLookupTable);
        
        END_INTERFACE
    } IDXSurfaceModifierVtbl;

    interface IDXSurfaceModifier
    {
        CONST_VTBL struct IDXSurfaceModifierVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDXSurfaceModifier_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDXSurfaceModifier_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDXSurfaceModifier_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDXSurfaceModifier_SetFillColor(This,Color)	\
    (This)->lpVtbl -> SetFillColor(This,Color)

#define IDXSurfaceModifier_GetFillColor(This,pColor)	\
    (This)->lpVtbl -> GetFillColor(This,pColor)

#define IDXSurfaceModifier_SetBounds(This,pBounds)	\
    (This)->lpVtbl -> SetBounds(This,pBounds)

#define IDXSurfaceModifier_SetBackground(This,pSurface)	\
    (This)->lpVtbl -> SetBackground(This,pSurface)

#define IDXSurfaceModifier_GetBackground(This,ppSurface)	\
    (This)->lpVtbl -> GetBackground(This,ppSurface)

#define IDXSurfaceModifier_SetCompositeOperation(This,CompOp)	\
    (This)->lpVtbl -> SetCompositeOperation(This,CompOp)

#define IDXSurfaceModifier_GetCompositeOperation(This,pCompOp)	\
    (This)->lpVtbl -> GetCompositeOperation(This,pCompOp)

#define IDXSurfaceModifier_SetForeground(This,pSurface,bTile,pOrigin)	\
    (This)->lpVtbl -> SetForeground(This,pSurface,bTile,pOrigin)

#define IDXSurfaceModifier_GetForeground(This,ppSurface,pbTile,pOrigin)	\
    (This)->lpVtbl -> GetForeground(This,ppSurface,pbTile,pOrigin)

#define IDXSurfaceModifier_SetOpacity(This,Opacity)	\
    (This)->lpVtbl -> SetOpacity(This,Opacity)

#define IDXSurfaceModifier_GetOpacity(This,pOpacity)	\
    (This)->lpVtbl -> GetOpacity(This,pOpacity)

#define IDXSurfaceModifier_SetLookup(This,pLookupTable)	\
    (This)->lpVtbl -> SetLookup(This,pLookupTable)

#define IDXSurfaceModifier_GetLookup(This,ppLookupTable)	\
    (This)->lpVtbl -> GetLookup(This,ppLookupTable)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDXSurfaceModifier_SetFillColor_Proxy( 
    IDXSurfaceModifier __RPC_FAR * This,
    /* [in] */ DXSAMPLE Color);


void __RPC_STUB IDXSurfaceModifier_SetFillColor_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXSurfaceModifier_GetFillColor_Proxy( 
    IDXSurfaceModifier __RPC_FAR * This,
    /* [out] */ DXSAMPLE __RPC_FAR *pColor);


void __RPC_STUB IDXSurfaceModifier_GetFillColor_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXSurfaceModifier_SetBounds_Proxy( 
    IDXSurfaceModifier __RPC_FAR * This,
    /* [in] */ const DXBNDS __RPC_FAR *pBounds);


void __RPC_STUB IDXSurfaceModifier_SetBounds_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXSurfaceModifier_SetBackground_Proxy( 
    IDXSurfaceModifier __RPC_FAR * This,
    /* [in] */ IDXSurface __RPC_FAR *pSurface);


void __RPC_STUB IDXSurfaceModifier_SetBackground_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXSurfaceModifier_GetBackground_Proxy( 
    IDXSurfaceModifier __RPC_FAR * This,
    /* [out] */ IDXSurface __RPC_FAR *__RPC_FAR *ppSurface);


void __RPC_STUB IDXSurfaceModifier_GetBackground_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXSurfaceModifier_SetCompositeOperation_Proxy( 
    IDXSurfaceModifier __RPC_FAR * This,
    /* [in] */ DXSURFMODCOMPOP CompOp);


void __RPC_STUB IDXSurfaceModifier_SetCompositeOperation_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXSurfaceModifier_GetCompositeOperation_Proxy( 
    IDXSurfaceModifier __RPC_FAR * This,
    /* [out] */ DXSURFMODCOMPOP __RPC_FAR *pCompOp);


void __RPC_STUB IDXSurfaceModifier_GetCompositeOperation_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXSurfaceModifier_SetForeground_Proxy( 
    IDXSurfaceModifier __RPC_FAR * This,
    /* [in] */ IDXSurface __RPC_FAR *pSurface,
    /* [in] */ BOOL bTile,
    /* [in] */ const POINT __RPC_FAR *pOrigin);


void __RPC_STUB IDXSurfaceModifier_SetForeground_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXSurfaceModifier_GetForeground_Proxy( 
    IDXSurfaceModifier __RPC_FAR * This,
    /* [out] */ IDXSurface __RPC_FAR *__RPC_FAR *ppSurface,
    /* [out] */ BOOL __RPC_FAR *pbTile,
    /* [out] */ POINT __RPC_FAR *pOrigin);


void __RPC_STUB IDXSurfaceModifier_GetForeground_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXSurfaceModifier_SetOpacity_Proxy( 
    IDXSurfaceModifier __RPC_FAR * This,
    /* [in] */ float Opacity);


void __RPC_STUB IDXSurfaceModifier_SetOpacity_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXSurfaceModifier_GetOpacity_Proxy( 
    IDXSurfaceModifier __RPC_FAR * This,
    /* [out] */ float __RPC_FAR *pOpacity);


void __RPC_STUB IDXSurfaceModifier_GetOpacity_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXSurfaceModifier_SetLookup_Proxy( 
    IDXSurfaceModifier __RPC_FAR * This,
    /* [in] */ IDXLookupTable __RPC_FAR *pLookupTable);


void __RPC_STUB IDXSurfaceModifier_SetLookup_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXSurfaceModifier_GetLookup_Proxy( 
    IDXSurfaceModifier __RPC_FAR * This,
    /* [out] */ IDXLookupTable __RPC_FAR *__RPC_FAR *ppLookupTable);


void __RPC_STUB IDXSurfaceModifier_GetLookup_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDXSurfaceModifier_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_dxtrans_0259 */
/* [local] */ 

typedef 
enum DXSAMPLEFORMATENUM
    {	DXPF_FLAGSMASK	= 0xffff0000,
	DXPF_NONPREMULT	= 0x10000,
	DXPF_TRANSPARENCY	= 0x20000,
	DXPF_TRANSLUCENCY	= 0x40000,
	DXPF_2BITERROR	= 0x200000,
	DXPF_3BITERROR	= 0x300000,
	DXPF_4BITERROR	= 0x400000,
	DXPF_5BITERROR	= 0x500000,
	DXPF_ERRORMASK	= 0x700000,
	DXPF_NONSTANDARD	= 0,
	DXPF_PMARGB32	= 1 | DXPF_TRANSPARENCY | DXPF_TRANSLUCENCY,
	DXPF_ARGB32	= 2 | DXPF_NONPREMULT | DXPF_TRANSPARENCY | DXPF_TRANSLUCENCY,
	DXPF_ARGB4444	= 3 | DXPF_NONPREMULT | DXPF_TRANSPARENCY | DXPF_TRANSLUCENCY | DXPF_4BITERROR,
	DXPF_A8	= 4 | DXPF_TRANSPARENCY | DXPF_TRANSLUCENCY,
	DXPF_RGB32	= 5,
	DXPF_RGB24	= 6,
	DXPF_RGB565	= 7 | DXPF_3BITERROR,
	DXPF_RGB555	= 8 | DXPF_3BITERROR,
	DXPF_RGB8	= 9 | DXPF_5BITERROR,
	DXPF_ARGB1555	= 10 | DXPF_TRANSPARENCY | DXPF_3BITERROR,
	DXPF_RGB32_CK	= DXPF_RGB32 | DXPF_TRANSPARENCY,
	DXPF_RGB24_CK	= DXPF_RGB24 | DXPF_TRANSPARENCY,
	DXPF_RGB555_CK	= DXPF_RGB555 | DXPF_TRANSPARENCY,
	DXPF_RGB565_CK	= DXPF_RGB565 | DXPF_TRANSPARENCY,
	DXPF_RGB8_CK	= DXPF_RGB8 | DXPF_TRANSPARENCY
    }	DXSAMPLEFORMATENUM;

typedef 
enum DXLOCKSURF
    {	DXLOCKF_READ	= 0,
	DXLOCKF_READWRITE	= 1 << 0,
	DXLOCKF_EXISTINGINFOONLY	= 1 << 1,
	DXLOCKF_WANTRUNINFO	= 1 << 2,
	DXLOCKF_NONPREMULT	= 1 << 16,
	DXLOCKF_VALIDFLAGS	= DXLOCKF_READWRITE | DXLOCKF_EXISTINGINFOONLY | DXLOCKF_WANTRUNINFO | DXLOCKF_NONPREMULT
    }	DXLOCKSURF;

typedef 
enum DXSURFSTATUS
    {	DXSURF_TRANSIENT	= 1 << 0,
	DXSURF_READONLY	= 1 << 1,
	DXSURF_VALIDFLAGS	= DXSURF_TRANSIENT | DXSURF_READONLY
    }	DXSURFSTATUS;



extern RPC_IF_HANDLE __MIDL_itf_dxtrans_0259_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_dxtrans_0259_v0_0_s_ifspec;

#ifndef __IDXSurface_INTERFACE_DEFINED__
#define __IDXSurface_INTERFACE_DEFINED__

/* interface IDXSurface */
/* [object][unique][helpstring][uuid] */ 


EXTERN_C const IID IID_IDXSurface;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("B39FD73F-E139-11d1-9065-00C04FD9189D")
    IDXSurface : public IDXBaseObject
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetPixelFormat( 
            /* [out] */ GUID __RPC_FAR *pFormatID,
            /* [out] */ DXSAMPLEFORMATENUM __RPC_FAR *pSampleFormatEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetBounds( 
            /* [out] */ DXBNDS __RPC_FAR *pBounds) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetStatusFlags( 
            /* [out] */ DWORD __RPC_FAR *pdwStatusFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetStatusFlags( 
            /* [in] */ DWORD dwStatusFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE LockSurface( 
            /* [in] */ const DXBNDS __RPC_FAR *pBounds,
            /* [in] */ ULONG ulTimeOut,
            /* [in] */ DWORD dwFlags,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppPointer,
            /* [out] */ ULONG __RPC_FAR *pulGenerationId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDirectDrawSurface( 
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppSurface) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetColorKey( 
            DXSAMPLE __RPC_FAR *pColorKey) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetColorKey( 
            DXSAMPLE ColorKey) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE LockSurfaceDC( 
            /* [in] */ const DXBNDS __RPC_FAR *pBounds,
            /* [in] */ ULONG ulTimeOut,
            /* [in] */ DWORD dwFlags,
            /* [out] */ IDXDCLock __RPC_FAR *__RPC_FAR *ppDCLock) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetAppData( 
            DWORD dwAppData) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAppData( 
            DWORD __RPC_FAR *pdwAppData) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDXSurfaceVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDXSurface __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDXSurface __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDXSurface __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetGenerationId )( 
            IDXSurface __RPC_FAR * This,
            /* [out] */ ULONG __RPC_FAR *pID);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *IncrementGenerationId )( 
            IDXSurface __RPC_FAR * This,
            /* [in] */ BOOL bRefresh);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetObjectSize )( 
            IDXSurface __RPC_FAR * This,
            /* [out] */ ULONG __RPC_FAR *pcbSize);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetPixelFormat )( 
            IDXSurface __RPC_FAR * This,
            /* [out] */ GUID __RPC_FAR *pFormatID,
            /* [out] */ DXSAMPLEFORMATENUM __RPC_FAR *pSampleFormatEnum);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetBounds )( 
            IDXSurface __RPC_FAR * This,
            /* [out] */ DXBNDS __RPC_FAR *pBounds);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetStatusFlags )( 
            IDXSurface __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pdwStatusFlags);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetStatusFlags )( 
            IDXSurface __RPC_FAR * This,
            /* [in] */ DWORD dwStatusFlags);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *LockSurface )( 
            IDXSurface __RPC_FAR * This,
            /* [in] */ const DXBNDS __RPC_FAR *pBounds,
            /* [in] */ ULONG ulTimeOut,
            /* [in] */ DWORD dwFlags,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppPointer,
            /* [out] */ ULONG __RPC_FAR *pulGenerationId);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetDirectDrawSurface )( 
            IDXSurface __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppSurface);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetColorKey )( 
            IDXSurface __RPC_FAR * This,
            DXSAMPLE __RPC_FAR *pColorKey);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetColorKey )( 
            IDXSurface __RPC_FAR * This,
            DXSAMPLE ColorKey);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *LockSurfaceDC )( 
            IDXSurface __RPC_FAR * This,
            /* [in] */ const DXBNDS __RPC_FAR *pBounds,
            /* [in] */ ULONG ulTimeOut,
            /* [in] */ DWORD dwFlags,
            /* [out] */ IDXDCLock __RPC_FAR *__RPC_FAR *ppDCLock);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetAppData )( 
            IDXSurface __RPC_FAR * This,
            DWORD dwAppData);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetAppData )( 
            IDXSurface __RPC_FAR * This,
            DWORD __RPC_FAR *pdwAppData);
        
        END_INTERFACE
    } IDXSurfaceVtbl;

    interface IDXSurface
    {
        CONST_VTBL struct IDXSurfaceVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDXSurface_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDXSurface_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDXSurface_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDXSurface_GetGenerationId(This,pID)	\
    (This)->lpVtbl -> GetGenerationId(This,pID)

#define IDXSurface_IncrementGenerationId(This,bRefresh)	\
    (This)->lpVtbl -> IncrementGenerationId(This,bRefresh)

#define IDXSurface_GetObjectSize(This,pcbSize)	\
    (This)->lpVtbl -> GetObjectSize(This,pcbSize)


#define IDXSurface_GetPixelFormat(This,pFormatID,pSampleFormatEnum)	\
    (This)->lpVtbl -> GetPixelFormat(This,pFormatID,pSampleFormatEnum)

#define IDXSurface_GetBounds(This,pBounds)	\
    (This)->lpVtbl -> GetBounds(This,pBounds)

#define IDXSurface_GetStatusFlags(This,pdwStatusFlags)	\
    (This)->lpVtbl -> GetStatusFlags(This,pdwStatusFlags)

#define IDXSurface_SetStatusFlags(This,dwStatusFlags)	\
    (This)->lpVtbl -> SetStatusFlags(This,dwStatusFlags)

#define IDXSurface_LockSurface(This,pBounds,ulTimeOut,dwFlags,riid,ppPointer,pulGenerationId)	\
    (This)->lpVtbl -> LockSurface(This,pBounds,ulTimeOut,dwFlags,riid,ppPointer,pulGenerationId)

#define IDXSurface_GetDirectDrawSurface(This,riid,ppSurface)	\
    (This)->lpVtbl -> GetDirectDrawSurface(This,riid,ppSurface)

#define IDXSurface_GetColorKey(This,pColorKey)	\
    (This)->lpVtbl -> GetColorKey(This,pColorKey)

#define IDXSurface_SetColorKey(This,ColorKey)	\
    (This)->lpVtbl -> SetColorKey(This,ColorKey)

#define IDXSurface_LockSurfaceDC(This,pBounds,ulTimeOut,dwFlags,ppDCLock)	\
    (This)->lpVtbl -> LockSurfaceDC(This,pBounds,ulTimeOut,dwFlags,ppDCLock)

#define IDXSurface_SetAppData(This,dwAppData)	\
    (This)->lpVtbl -> SetAppData(This,dwAppData)

#define IDXSurface_GetAppData(This,pdwAppData)	\
    (This)->lpVtbl -> GetAppData(This,pdwAppData)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDXSurface_GetPixelFormat_Proxy( 
    IDXSurface __RPC_FAR * This,
    /* [out] */ GUID __RPC_FAR *pFormatID,
    /* [out] */ DXSAMPLEFORMATENUM __RPC_FAR *pSampleFormatEnum);


void __RPC_STUB IDXSurface_GetPixelFormat_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXSurface_GetBounds_Proxy( 
    IDXSurface __RPC_FAR * This,
    /* [out] */ DXBNDS __RPC_FAR *pBounds);


void __RPC_STUB IDXSurface_GetBounds_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXSurface_GetStatusFlags_Proxy( 
    IDXSurface __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *pdwStatusFlags);


void __RPC_STUB IDXSurface_GetStatusFlags_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXSurface_SetStatusFlags_Proxy( 
    IDXSurface __RPC_FAR * This,
    /* [in] */ DWORD dwStatusFlags);


void __RPC_STUB IDXSurface_SetStatusFlags_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXSurface_LockSurface_Proxy( 
    IDXSurface __RPC_FAR * This,
    /* [in] */ const DXBNDS __RPC_FAR *pBounds,
    /* [in] */ ULONG ulTimeOut,
    /* [in] */ DWORD dwFlags,
    /* [in] */ REFIID riid,
    /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppPointer,
    /* [out] */ ULONG __RPC_FAR *pulGenerationId);


void __RPC_STUB IDXSurface_LockSurface_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXSurface_GetDirectDrawSurface_Proxy( 
    IDXSurface __RPC_FAR * This,
    /* [in] */ REFIID riid,
    /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppSurface);


void __RPC_STUB IDXSurface_GetDirectDrawSurface_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXSurface_GetColorKey_Proxy( 
    IDXSurface __RPC_FAR * This,
    DXSAMPLE __RPC_FAR *pColorKey);


void __RPC_STUB IDXSurface_GetColorKey_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXSurface_SetColorKey_Proxy( 
    IDXSurface __RPC_FAR * This,
    DXSAMPLE ColorKey);


void __RPC_STUB IDXSurface_SetColorKey_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXSurface_LockSurfaceDC_Proxy( 
    IDXSurface __RPC_FAR * This,
    /* [in] */ const DXBNDS __RPC_FAR *pBounds,
    /* [in] */ ULONG ulTimeOut,
    /* [in] */ DWORD dwFlags,
    /* [out] */ IDXDCLock __RPC_FAR *__RPC_FAR *ppDCLock);


void __RPC_STUB IDXSurface_LockSurfaceDC_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXSurface_SetAppData_Proxy( 
    IDXSurface __RPC_FAR * This,
    DWORD dwAppData);


void __RPC_STUB IDXSurface_SetAppData_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXSurface_GetAppData_Proxy( 
    IDXSurface __RPC_FAR * This,
    DWORD __RPC_FAR *pdwAppData);


void __RPC_STUB IDXSurface_GetAppData_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDXSurface_INTERFACE_DEFINED__ */


#ifndef __IDXSurfaceInit_INTERFACE_DEFINED__
#define __IDXSurfaceInit_INTERFACE_DEFINED__

/* interface IDXSurfaceInit */
/* [object][local][unique][helpstring][uuid] */ 


EXTERN_C const IID IID_IDXSurfaceInit;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("9EA3B639-C37D-11d1-905E-00C04FD9189D")
    IDXSurfaceInit : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE InitSurface( 
            /* [in] */ IUnknown __RPC_FAR *pDirectDraw,
            /* [in] */ const DDSURFACEDESC __RPC_FAR *pDDSurfaceDesc,
            /* [in] */ const GUID __RPC_FAR *pFormatID,
            /* [in] */ const DXBNDS __RPC_FAR *pBounds,
            /* [in] */ DWORD dwFlags) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDXSurfaceInitVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDXSurfaceInit __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDXSurfaceInit __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDXSurfaceInit __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *InitSurface )( 
            IDXSurfaceInit __RPC_FAR * This,
            /* [in] */ IUnknown __RPC_FAR *pDirectDraw,
            /* [in] */ const DDSURFACEDESC __RPC_FAR *pDDSurfaceDesc,
            /* [in] */ const GUID __RPC_FAR *pFormatID,
            /* [in] */ const DXBNDS __RPC_FAR *pBounds,
            /* [in] */ DWORD dwFlags);
        
        END_INTERFACE
    } IDXSurfaceInitVtbl;

    interface IDXSurfaceInit
    {
        CONST_VTBL struct IDXSurfaceInitVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDXSurfaceInit_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDXSurfaceInit_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDXSurfaceInit_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDXSurfaceInit_InitSurface(This,pDirectDraw,pDDSurfaceDesc,pFormatID,pBounds,dwFlags)	\
    (This)->lpVtbl -> InitSurface(This,pDirectDraw,pDDSurfaceDesc,pFormatID,pBounds,dwFlags)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDXSurfaceInit_InitSurface_Proxy( 
    IDXSurfaceInit __RPC_FAR * This,
    /* [in] */ IUnknown __RPC_FAR *pDirectDraw,
    /* [in] */ const DDSURFACEDESC __RPC_FAR *pDDSurfaceDesc,
    /* [in] */ const GUID __RPC_FAR *pFormatID,
    /* [in] */ const DXBNDS __RPC_FAR *pBounds,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB IDXSurfaceInit_InitSurface_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDXSurfaceInit_INTERFACE_DEFINED__ */


#ifndef __IDXARGBSurfaceInit_INTERFACE_DEFINED__
#define __IDXARGBSurfaceInit_INTERFACE_DEFINED__

/* interface IDXARGBSurfaceInit */
/* [object][local][unique][helpstring][uuid] */ 


EXTERN_C const IID IID_IDXARGBSurfaceInit;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("9EA3B63A-C37D-11d1-905E-00C04FD9189D")
    IDXARGBSurfaceInit : public IDXSurfaceInit
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE InitFromDDSurface( 
            /* [in] */ IUnknown __RPC_FAR *pDDrawSurface,
            /* [in] */ const GUID __RPC_FAR *pFormatID,
            /* [in] */ DWORD dwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE InitFromRawSurface( 
            /* [in] */ IDXRawSurface __RPC_FAR *pRawSurface) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDXARGBSurfaceInitVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDXARGBSurfaceInit __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDXARGBSurfaceInit __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDXARGBSurfaceInit __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *InitSurface )( 
            IDXARGBSurfaceInit __RPC_FAR * This,
            /* [in] */ IUnknown __RPC_FAR *pDirectDraw,
            /* [in] */ const DDSURFACEDESC __RPC_FAR *pDDSurfaceDesc,
            /* [in] */ const GUID __RPC_FAR *pFormatID,
            /* [in] */ const DXBNDS __RPC_FAR *pBounds,
            /* [in] */ DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *InitFromDDSurface )( 
            IDXARGBSurfaceInit __RPC_FAR * This,
            /* [in] */ IUnknown __RPC_FAR *pDDrawSurface,
            /* [in] */ const GUID __RPC_FAR *pFormatID,
            /* [in] */ DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *InitFromRawSurface )( 
            IDXARGBSurfaceInit __RPC_FAR * This,
            /* [in] */ IDXRawSurface __RPC_FAR *pRawSurface);
        
        END_INTERFACE
    } IDXARGBSurfaceInitVtbl;

    interface IDXARGBSurfaceInit
    {
        CONST_VTBL struct IDXARGBSurfaceInitVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDXARGBSurfaceInit_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDXARGBSurfaceInit_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDXARGBSurfaceInit_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDXARGBSurfaceInit_InitSurface(This,pDirectDraw,pDDSurfaceDesc,pFormatID,pBounds,dwFlags)	\
    (This)->lpVtbl -> InitSurface(This,pDirectDraw,pDDSurfaceDesc,pFormatID,pBounds,dwFlags)


#define IDXARGBSurfaceInit_InitFromDDSurface(This,pDDrawSurface,pFormatID,dwFlags)	\
    (This)->lpVtbl -> InitFromDDSurface(This,pDDrawSurface,pFormatID,dwFlags)

#define IDXARGBSurfaceInit_InitFromRawSurface(This,pRawSurface)	\
    (This)->lpVtbl -> InitFromRawSurface(This,pRawSurface)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDXARGBSurfaceInit_InitFromDDSurface_Proxy( 
    IDXARGBSurfaceInit __RPC_FAR * This,
    /* [in] */ IUnknown __RPC_FAR *pDDrawSurface,
    /* [in] */ const GUID __RPC_FAR *pFormatID,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB IDXARGBSurfaceInit_InitFromDDSurface_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXARGBSurfaceInit_InitFromRawSurface_Proxy( 
    IDXARGBSurfaceInit __RPC_FAR * This,
    /* [in] */ IDXRawSurface __RPC_FAR *pRawSurface);


void __RPC_STUB IDXARGBSurfaceInit_InitFromRawSurface_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDXARGBSurfaceInit_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_dxtrans_0262 */
/* [local] */ 

typedef struct tagDXNATIVETYPEINFO
    {
    BYTE __RPC_FAR *pCurrentData;
    BYTE __RPC_FAR *pFirstByte;
    long lPitch;
    DWORD dwColorKey;
    }	DXNATIVETYPEINFO;

typedef struct tagDXPACKEDRECTDESC
    {
    DXBASESAMPLE __RPC_FAR *pSamples;
    BOOL bPremult;
    RECT rect;
    long lRowPadding;
    }	DXPACKEDRECTDESC;

typedef struct tagDXOVERSAMPLEDESC
    {
    POINT p;
    DXPMSAMPLE Color;
    }	DXOVERSAMPLEDESC;



extern RPC_IF_HANDLE __MIDL_itf_dxtrans_0262_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_dxtrans_0262_v0_0_s_ifspec;

#ifndef __IDXARGBReadPtr_INTERFACE_DEFINED__
#define __IDXARGBReadPtr_INTERFACE_DEFINED__

/* interface IDXARGBReadPtr */
/* [object][local][unique][helpstring][uuid] */ 


EXTERN_C const IID IID_IDXARGBReadPtr;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("EAAAC2D6-C290-11d1-905D-00C04FD9189D")
    IDXARGBReadPtr : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetSurface( 
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppSurface) = 0;
        
        virtual DXSAMPLEFORMATENUM STDMETHODCALLTYPE GetNativeType( 
            /* [out] */ DXNATIVETYPEINFO __RPC_FAR *pInfo) = 0;
        
        virtual void STDMETHODCALLTYPE Move( 
            /* [in] */ long cSamples) = 0;
        
        virtual void STDMETHODCALLTYPE MoveToRow( 
            /* [in] */ ULONG y) = 0;
        
        virtual void STDMETHODCALLTYPE MoveToXY( 
            /* [in] */ ULONG x,
            /* [in] */ ULONG y) = 0;
        
        virtual ULONG STDMETHODCALLTYPE MoveAndGetRunInfo( 
            /* [in] */ ULONG Row,
            /* [out] */ const DXRUNINFO __RPC_FAR *__RPC_FAR *ppInfo) = 0;
        
        virtual DXSAMPLE __RPC_FAR *STDMETHODCALLTYPE Unpack( 
            /* [in] */ DXSAMPLE __RPC_FAR *pSamples,
            /* [in] */ ULONG cSamples,
            /* [in] */ BOOL bMove) = 0;
        
        virtual DXPMSAMPLE __RPC_FAR *STDMETHODCALLTYPE UnpackPremult( 
            /* [in] */ DXPMSAMPLE __RPC_FAR *pSamples,
            /* [in] */ ULONG cSamples,
            /* [in] */ BOOL bMove) = 0;
        
        virtual void STDMETHODCALLTYPE UnpackRect( 
            /* [in] */ const DXPACKEDRECTDESC __RPC_FAR *pRectDesc) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDXARGBReadPtrVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDXARGBReadPtr __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDXARGBReadPtr __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDXARGBReadPtr __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetSurface )( 
            IDXARGBReadPtr __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppSurface);
        
        DXSAMPLEFORMATENUM ( STDMETHODCALLTYPE __RPC_FAR *GetNativeType )( 
            IDXARGBReadPtr __RPC_FAR * This,
            /* [out] */ DXNATIVETYPEINFO __RPC_FAR *pInfo);
        
        void ( STDMETHODCALLTYPE __RPC_FAR *Move )( 
            IDXARGBReadPtr __RPC_FAR * This,
            /* [in] */ long cSamples);
        
        void ( STDMETHODCALLTYPE __RPC_FAR *MoveToRow )( 
            IDXARGBReadPtr __RPC_FAR * This,
            /* [in] */ ULONG y);
        
        void ( STDMETHODCALLTYPE __RPC_FAR *MoveToXY )( 
            IDXARGBReadPtr __RPC_FAR * This,
            /* [in] */ ULONG x,
            /* [in] */ ULONG y);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *MoveAndGetRunInfo )( 
            IDXARGBReadPtr __RPC_FAR * This,
            /* [in] */ ULONG Row,
            /* [out] */ const DXRUNINFO __RPC_FAR *__RPC_FAR *ppInfo);
        
        DXSAMPLE __RPC_FAR *( STDMETHODCALLTYPE __RPC_FAR *Unpack )( 
            IDXARGBReadPtr __RPC_FAR * This,
            /* [in] */ DXSAMPLE __RPC_FAR *pSamples,
            /* [in] */ ULONG cSamples,
            /* [in] */ BOOL bMove);
        
        DXPMSAMPLE __RPC_FAR *( STDMETHODCALLTYPE __RPC_FAR *UnpackPremult )( 
            IDXARGBReadPtr __RPC_FAR * This,
            /* [in] */ DXPMSAMPLE __RPC_FAR *pSamples,
            /* [in] */ ULONG cSamples,
            /* [in] */ BOOL bMove);
        
        void ( STDMETHODCALLTYPE __RPC_FAR *UnpackRect )( 
            IDXARGBReadPtr __RPC_FAR * This,
            /* [in] */ const DXPACKEDRECTDESC __RPC_FAR *pRectDesc);
        
        END_INTERFACE
    } IDXARGBReadPtrVtbl;

    interface IDXARGBReadPtr
    {
        CONST_VTBL struct IDXARGBReadPtrVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDXARGBReadPtr_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDXARGBReadPtr_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDXARGBReadPtr_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDXARGBReadPtr_GetSurface(This,riid,ppSurface)	\
    (This)->lpVtbl -> GetSurface(This,riid,ppSurface)

#define IDXARGBReadPtr_GetNativeType(This,pInfo)	\
    (This)->lpVtbl -> GetNativeType(This,pInfo)

#define IDXARGBReadPtr_Move(This,cSamples)	\
    (This)->lpVtbl -> Move(This,cSamples)

#define IDXARGBReadPtr_MoveToRow(This,y)	\
    (This)->lpVtbl -> MoveToRow(This,y)

#define IDXARGBReadPtr_MoveToXY(This,x,y)	\
    (This)->lpVtbl -> MoveToXY(This,x,y)

#define IDXARGBReadPtr_MoveAndGetRunInfo(This,Row,ppInfo)	\
    (This)->lpVtbl -> MoveAndGetRunInfo(This,Row,ppInfo)

#define IDXARGBReadPtr_Unpack(This,pSamples,cSamples,bMove)	\
    (This)->lpVtbl -> Unpack(This,pSamples,cSamples,bMove)

#define IDXARGBReadPtr_UnpackPremult(This,pSamples,cSamples,bMove)	\
    (This)->lpVtbl -> UnpackPremult(This,pSamples,cSamples,bMove)

#define IDXARGBReadPtr_UnpackRect(This,pRectDesc)	\
    (This)->lpVtbl -> UnpackRect(This,pRectDesc)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDXARGBReadPtr_GetSurface_Proxy( 
    IDXARGBReadPtr __RPC_FAR * This,
    /* [in] */ REFIID riid,
    /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppSurface);


void __RPC_STUB IDXARGBReadPtr_GetSurface_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


DXSAMPLEFORMATENUM STDMETHODCALLTYPE IDXARGBReadPtr_GetNativeType_Proxy( 
    IDXARGBReadPtr __RPC_FAR * This,
    /* [out] */ DXNATIVETYPEINFO __RPC_FAR *pInfo);


void __RPC_STUB IDXARGBReadPtr_GetNativeType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


void STDMETHODCALLTYPE IDXARGBReadPtr_Move_Proxy( 
    IDXARGBReadPtr __RPC_FAR * This,
    /* [in] */ long cSamples);


void __RPC_STUB IDXARGBReadPtr_Move_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


void STDMETHODCALLTYPE IDXARGBReadPtr_MoveToRow_Proxy( 
    IDXARGBReadPtr __RPC_FAR * This,
    /* [in] */ ULONG y);


void __RPC_STUB IDXARGBReadPtr_MoveToRow_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


void STDMETHODCALLTYPE IDXARGBReadPtr_MoveToXY_Proxy( 
    IDXARGBReadPtr __RPC_FAR * This,
    /* [in] */ ULONG x,
    /* [in] */ ULONG y);


void __RPC_STUB IDXARGBReadPtr_MoveToXY_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


ULONG STDMETHODCALLTYPE IDXARGBReadPtr_MoveAndGetRunInfo_Proxy( 
    IDXARGBReadPtr __RPC_FAR * This,
    /* [in] */ ULONG Row,
    /* [out] */ const DXRUNINFO __RPC_FAR *__RPC_FAR *ppInfo);


void __RPC_STUB IDXARGBReadPtr_MoveAndGetRunInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


DXSAMPLE __RPC_FAR *STDMETHODCALLTYPE IDXARGBReadPtr_Unpack_Proxy( 
    IDXARGBReadPtr __RPC_FAR * This,
    /* [in] */ DXSAMPLE __RPC_FAR *pSamples,
    /* [in] */ ULONG cSamples,
    /* [in] */ BOOL bMove);


void __RPC_STUB IDXARGBReadPtr_Unpack_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


DXPMSAMPLE __RPC_FAR *STDMETHODCALLTYPE IDXARGBReadPtr_UnpackPremult_Proxy( 
    IDXARGBReadPtr __RPC_FAR * This,
    /* [in] */ DXPMSAMPLE __RPC_FAR *pSamples,
    /* [in] */ ULONG cSamples,
    /* [in] */ BOOL bMove);


void __RPC_STUB IDXARGBReadPtr_UnpackPremult_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


void STDMETHODCALLTYPE IDXARGBReadPtr_UnpackRect_Proxy( 
    IDXARGBReadPtr __RPC_FAR * This,
    /* [in] */ const DXPACKEDRECTDESC __RPC_FAR *pRectDesc);


void __RPC_STUB IDXARGBReadPtr_UnpackRect_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDXARGBReadPtr_INTERFACE_DEFINED__ */


#ifndef __IDXARGBReadWritePtr_INTERFACE_DEFINED__
#define __IDXARGBReadWritePtr_INTERFACE_DEFINED__

/* interface IDXARGBReadWritePtr */
/* [object][local][unique][helpstring][uuid] */ 


EXTERN_C const IID IID_IDXARGBReadWritePtr;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("EAAAC2D7-C290-11d1-905D-00C04FD9189D")
    IDXARGBReadWritePtr : public IDXARGBReadPtr
    {
    public:
        virtual void STDMETHODCALLTYPE PackAndMove( 
            /* [in] */ const DXSAMPLE __RPC_FAR *pSamples,
            /* [in] */ ULONG cSamples) = 0;
        
        virtual void STDMETHODCALLTYPE PackPremultAndMove( 
            /* [in] */ const DXPMSAMPLE __RPC_FAR *pSamples,
            /* [in] */ ULONG cSamples) = 0;
        
        virtual void STDMETHODCALLTYPE PackRect( 
            /* [in] */ const DXPACKEDRECTDESC __RPC_FAR *pRectDesc) = 0;
        
        virtual void STDMETHODCALLTYPE CopyAndMoveBoth( 
            /* [in] */ DXBASESAMPLE __RPC_FAR *pScratchBuffer,
            /* [in] */ IDXARGBReadPtr __RPC_FAR *pSrc,
            /* [in] */ ULONG cSamples,
            /* [in] */ BOOL bIsOpaque) = 0;
        
        virtual void STDMETHODCALLTYPE CopyRect( 
            /* [in] */ DXBASESAMPLE __RPC_FAR *pScratchBuffer,
            /* [in] */ const RECT __RPC_FAR *pDestRect,
            /* [in] */ IDXARGBReadPtr __RPC_FAR *pSrc,
            /* [in] */ const POINT __RPC_FAR *pSrcOrigin,
            /* [in] */ BOOL bIsOpaque) = 0;
        
        virtual void STDMETHODCALLTYPE FillAndMove( 
            /* [in] */ DXBASESAMPLE __RPC_FAR *pScratchBuffer,
            /* [in] */ DXPMSAMPLE SampVal,
            /* [in] */ ULONG cSamples,
            /* [in] */ BOOL bDoOver) = 0;
        
        virtual void STDMETHODCALLTYPE FillRect( 
            /* [in] */ const RECT __RPC_FAR *pRect,
            /* [in] */ DXPMSAMPLE SampVal,
            /* [in] */ BOOL bDoOver) = 0;
        
        virtual void STDMETHODCALLTYPE OverSample( 
            /* [in] */ const DXOVERSAMPLEDESC __RPC_FAR *pOverDesc) = 0;
        
        virtual void STDMETHODCALLTYPE OverArrayAndMove( 
            /* [in] */ DXBASESAMPLE __RPC_FAR *pScratchBuffer,
            /* [in] */ const DXPMSAMPLE __RPC_FAR *pSrc,
            /* [in] */ ULONG cSamples) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDXARGBReadWritePtrVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDXARGBReadWritePtr __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDXARGBReadWritePtr __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDXARGBReadWritePtr __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetSurface )( 
            IDXARGBReadWritePtr __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppSurface);
        
        DXSAMPLEFORMATENUM ( STDMETHODCALLTYPE __RPC_FAR *GetNativeType )( 
            IDXARGBReadWritePtr __RPC_FAR * This,
            /* [out] */ DXNATIVETYPEINFO __RPC_FAR *pInfo);
        
        void ( STDMETHODCALLTYPE __RPC_FAR *Move )( 
            IDXARGBReadWritePtr __RPC_FAR * This,
            /* [in] */ long cSamples);
        
        void ( STDMETHODCALLTYPE __RPC_FAR *MoveToRow )( 
            IDXARGBReadWritePtr __RPC_FAR * This,
            /* [in] */ ULONG y);
        
        void ( STDMETHODCALLTYPE __RPC_FAR *MoveToXY )( 
            IDXARGBReadWritePtr __RPC_FAR * This,
            /* [in] */ ULONG x,
            /* [in] */ ULONG y);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *MoveAndGetRunInfo )( 
            IDXARGBReadWritePtr __RPC_FAR * This,
            /* [in] */ ULONG Row,
            /* [out] */ const DXRUNINFO __RPC_FAR *__RPC_FAR *ppInfo);
        
        DXSAMPLE __RPC_FAR *( STDMETHODCALLTYPE __RPC_FAR *Unpack )( 
            IDXARGBReadWritePtr __RPC_FAR * This,
            /* [in] */ DXSAMPLE __RPC_FAR *pSamples,
            /* [in] */ ULONG cSamples,
            /* [in] */ BOOL bMove);
        
        DXPMSAMPLE __RPC_FAR *( STDMETHODCALLTYPE __RPC_FAR *UnpackPremult )( 
            IDXARGBReadWritePtr __RPC_FAR * This,
            /* [in] */ DXPMSAMPLE __RPC_FAR *pSamples,
            /* [in] */ ULONG cSamples,
            /* [in] */ BOOL bMove);
        
        void ( STDMETHODCALLTYPE __RPC_FAR *UnpackRect )( 
            IDXARGBReadWritePtr __RPC_FAR * This,
            /* [in] */ const DXPACKEDRECTDESC __RPC_FAR *pRectDesc);
        
        void ( STDMETHODCALLTYPE __RPC_FAR *PackAndMove )( 
            IDXARGBReadWritePtr __RPC_FAR * This,
            /* [in] */ const DXSAMPLE __RPC_FAR *pSamples,
            /* [in] */ ULONG cSamples);
        
        void ( STDMETHODCALLTYPE __RPC_FAR *PackPremultAndMove )( 
            IDXARGBReadWritePtr __RPC_FAR * This,
            /* [in] */ const DXPMSAMPLE __RPC_FAR *pSamples,
            /* [in] */ ULONG cSamples);
        
        void ( STDMETHODCALLTYPE __RPC_FAR *PackRect )( 
            IDXARGBReadWritePtr __RPC_FAR * This,
            /* [in] */ const DXPACKEDRECTDESC __RPC_FAR *pRectDesc);
        
        void ( STDMETHODCALLTYPE __RPC_FAR *CopyAndMoveBoth )( 
            IDXARGBReadWritePtr __RPC_FAR * This,
            /* [in] */ DXBASESAMPLE __RPC_FAR *pScratchBuffer,
            /* [in] */ IDXARGBReadPtr __RPC_FAR *pSrc,
            /* [in] */ ULONG cSamples,
            /* [in] */ BOOL bIsOpaque);
        
        void ( STDMETHODCALLTYPE __RPC_FAR *CopyRect )( 
            IDXARGBReadWritePtr __RPC_FAR * This,
            /* [in] */ DXBASESAMPLE __RPC_FAR *pScratchBuffer,
            /* [in] */ const RECT __RPC_FAR *pDestRect,
            /* [in] */ IDXARGBReadPtr __RPC_FAR *pSrc,
            /* [in] */ const POINT __RPC_FAR *pSrcOrigin,
            /* [in] */ BOOL bIsOpaque);
        
        void ( STDMETHODCALLTYPE __RPC_FAR *FillAndMove )( 
            IDXARGBReadWritePtr __RPC_FAR * This,
            /* [in] */ DXBASESAMPLE __RPC_FAR *pScratchBuffer,
            /* [in] */ DXPMSAMPLE SampVal,
            /* [in] */ ULONG cSamples,
            /* [in] */ BOOL bDoOver);
        
        void ( STDMETHODCALLTYPE __RPC_FAR *FillRect )( 
            IDXARGBReadWritePtr __RPC_FAR * This,
            /* [in] */ const RECT __RPC_FAR *pRect,
            /* [in] */ DXPMSAMPLE SampVal,
            /* [in] */ BOOL bDoOver);
        
        void ( STDMETHODCALLTYPE __RPC_FAR *OverSample )( 
            IDXARGBReadWritePtr __RPC_FAR * This,
            /* [in] */ const DXOVERSAMPLEDESC __RPC_FAR *pOverDesc);
        
        void ( STDMETHODCALLTYPE __RPC_FAR *OverArrayAndMove )( 
            IDXARGBReadWritePtr __RPC_FAR * This,
            /* [in] */ DXBASESAMPLE __RPC_FAR *pScratchBuffer,
            /* [in] */ const DXPMSAMPLE __RPC_FAR *pSrc,
            /* [in] */ ULONG cSamples);
        
        END_INTERFACE
    } IDXARGBReadWritePtrVtbl;

    interface IDXARGBReadWritePtr
    {
        CONST_VTBL struct IDXARGBReadWritePtrVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDXARGBReadWritePtr_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDXARGBReadWritePtr_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDXARGBReadWritePtr_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDXARGBReadWritePtr_GetSurface(This,riid,ppSurface)	\
    (This)->lpVtbl -> GetSurface(This,riid,ppSurface)

#define IDXARGBReadWritePtr_GetNativeType(This,pInfo)	\
    (This)->lpVtbl -> GetNativeType(This,pInfo)

#define IDXARGBReadWritePtr_Move(This,cSamples)	\
    (This)->lpVtbl -> Move(This,cSamples)

#define IDXARGBReadWritePtr_MoveToRow(This,y)	\
    (This)->lpVtbl -> MoveToRow(This,y)

#define IDXARGBReadWritePtr_MoveToXY(This,x,y)	\
    (This)->lpVtbl -> MoveToXY(This,x,y)

#define IDXARGBReadWritePtr_MoveAndGetRunInfo(This,Row,ppInfo)	\
    (This)->lpVtbl -> MoveAndGetRunInfo(This,Row,ppInfo)

#define IDXARGBReadWritePtr_Unpack(This,pSamples,cSamples,bMove)	\
    (This)->lpVtbl -> Unpack(This,pSamples,cSamples,bMove)

#define IDXARGBReadWritePtr_UnpackPremult(This,pSamples,cSamples,bMove)	\
    (This)->lpVtbl -> UnpackPremult(This,pSamples,cSamples,bMove)

#define IDXARGBReadWritePtr_UnpackRect(This,pRectDesc)	\
    (This)->lpVtbl -> UnpackRect(This,pRectDesc)


#define IDXARGBReadWritePtr_PackAndMove(This,pSamples,cSamples)	\
    (This)->lpVtbl -> PackAndMove(This,pSamples,cSamples)

#define IDXARGBReadWritePtr_PackPremultAndMove(This,pSamples,cSamples)	\
    (This)->lpVtbl -> PackPremultAndMove(This,pSamples,cSamples)

#define IDXARGBReadWritePtr_PackRect(This,pRectDesc)	\
    (This)->lpVtbl -> PackRect(This,pRectDesc)

#define IDXARGBReadWritePtr_CopyAndMoveBoth(This,pScratchBuffer,pSrc,cSamples,bIsOpaque)	\
    (This)->lpVtbl -> CopyAndMoveBoth(This,pScratchBuffer,pSrc,cSamples,bIsOpaque)

#define IDXARGBReadWritePtr_CopyRect(This,pScratchBuffer,pDestRect,pSrc,pSrcOrigin,bIsOpaque)	\
    (This)->lpVtbl -> CopyRect(This,pScratchBuffer,pDestRect,pSrc,pSrcOrigin,bIsOpaque)

#define IDXARGBReadWritePtr_FillAndMove(This,pScratchBuffer,SampVal,cSamples,bDoOver)	\
    (This)->lpVtbl -> FillAndMove(This,pScratchBuffer,SampVal,cSamples,bDoOver)

#define IDXARGBReadWritePtr_FillRect(This,pRect,SampVal,bDoOver)	\
    (This)->lpVtbl -> FillRect(This,pRect,SampVal,bDoOver)

#define IDXARGBReadWritePtr_OverSample(This,pOverDesc)	\
    (This)->lpVtbl -> OverSample(This,pOverDesc)

#define IDXARGBReadWritePtr_OverArrayAndMove(This,pScratchBuffer,pSrc,cSamples)	\
    (This)->lpVtbl -> OverArrayAndMove(This,pScratchBuffer,pSrc,cSamples)

#endif /* COBJMACROS */


#endif 	/* C style interface */



void STDMETHODCALLTYPE IDXARGBReadWritePtr_PackAndMove_Proxy( 
    IDXARGBReadWritePtr __RPC_FAR * This,
    /* [in] */ const DXSAMPLE __RPC_FAR *pSamples,
    /* [in] */ ULONG cSamples);


void __RPC_STUB IDXARGBReadWritePtr_PackAndMove_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


void STDMETHODCALLTYPE IDXARGBReadWritePtr_PackPremultAndMove_Proxy( 
    IDXARGBReadWritePtr __RPC_FAR * This,
    /* [in] */ const DXPMSAMPLE __RPC_FAR *pSamples,
    /* [in] */ ULONG cSamples);


void __RPC_STUB IDXARGBReadWritePtr_PackPremultAndMove_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


void STDMETHODCALLTYPE IDXARGBReadWritePtr_PackRect_Proxy( 
    IDXARGBReadWritePtr __RPC_FAR * This,
    /* [in] */ const DXPACKEDRECTDESC __RPC_FAR *pRectDesc);


void __RPC_STUB IDXARGBReadWritePtr_PackRect_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


void STDMETHODCALLTYPE IDXARGBReadWritePtr_CopyAndMoveBoth_Proxy( 
    IDXARGBReadWritePtr __RPC_FAR * This,
    /* [in] */ DXBASESAMPLE __RPC_FAR *pScratchBuffer,
    /* [in] */ IDXARGBReadPtr __RPC_FAR *pSrc,
    /* [in] */ ULONG cSamples,
    /* [in] */ BOOL bIsOpaque);


void __RPC_STUB IDXARGBReadWritePtr_CopyAndMoveBoth_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


void STDMETHODCALLTYPE IDXARGBReadWritePtr_CopyRect_Proxy( 
    IDXARGBReadWritePtr __RPC_FAR * This,
    /* [in] */ DXBASESAMPLE __RPC_FAR *pScratchBuffer,
    /* [in] */ const RECT __RPC_FAR *pDestRect,
    /* [in] */ IDXARGBReadPtr __RPC_FAR *pSrc,
    /* [in] */ const POINT __RPC_FAR *pSrcOrigin,
    /* [in] */ BOOL bIsOpaque);


void __RPC_STUB IDXARGBReadWritePtr_CopyRect_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


void STDMETHODCALLTYPE IDXARGBReadWritePtr_FillAndMove_Proxy( 
    IDXARGBReadWritePtr __RPC_FAR * This,
    /* [in] */ DXBASESAMPLE __RPC_FAR *pScratchBuffer,
    /* [in] */ DXPMSAMPLE SampVal,
    /* [in] */ ULONG cSamples,
    /* [in] */ BOOL bDoOver);


void __RPC_STUB IDXARGBReadWritePtr_FillAndMove_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


void STDMETHODCALLTYPE IDXARGBReadWritePtr_FillRect_Proxy( 
    IDXARGBReadWritePtr __RPC_FAR * This,
    /* [in] */ const RECT __RPC_FAR *pRect,
    /* [in] */ DXPMSAMPLE SampVal,
    /* [in] */ BOOL bDoOver);


void __RPC_STUB IDXARGBReadWritePtr_FillRect_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


void STDMETHODCALLTYPE IDXARGBReadWritePtr_OverSample_Proxy( 
    IDXARGBReadWritePtr __RPC_FAR * This,
    /* [in] */ const DXOVERSAMPLEDESC __RPC_FAR *pOverDesc);


void __RPC_STUB IDXARGBReadWritePtr_OverSample_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


void STDMETHODCALLTYPE IDXARGBReadWritePtr_OverArrayAndMove_Proxy( 
    IDXARGBReadWritePtr __RPC_FAR * This,
    /* [in] */ DXBASESAMPLE __RPC_FAR *pScratchBuffer,
    /* [in] */ const DXPMSAMPLE __RPC_FAR *pSrc,
    /* [in] */ ULONG cSamples);


void __RPC_STUB IDXARGBReadWritePtr_OverArrayAndMove_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDXARGBReadWritePtr_INTERFACE_DEFINED__ */


#ifndef __IDXDCLock_INTERFACE_DEFINED__
#define __IDXDCLock_INTERFACE_DEFINED__

/* interface IDXDCLock */
/* [object][local][unique][helpstring][uuid] */ 


EXTERN_C const IID IID_IDXDCLock;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("0F619456-CF39-11d1-905E-00C04FD9189D")
    IDXDCLock : public IUnknown
    {
    public:
        virtual HDC STDMETHODCALLTYPE GetDC( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDXDCLockVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDXDCLock __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDXDCLock __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDXDCLock __RPC_FAR * This);
        
        HDC ( STDMETHODCALLTYPE __RPC_FAR *GetDC )( 
            IDXDCLock __RPC_FAR * This);
        
        END_INTERFACE
    } IDXDCLockVtbl;

    interface IDXDCLock
    {
        CONST_VTBL struct IDXDCLockVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDXDCLock_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDXDCLock_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDXDCLock_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDXDCLock_GetDC(This)	\
    (This)->lpVtbl -> GetDC(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HDC STDMETHODCALLTYPE IDXDCLock_GetDC_Proxy( 
    IDXDCLock __RPC_FAR * This);


void __RPC_STUB IDXDCLock_GetDC_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDXDCLock_INTERFACE_DEFINED__ */


#ifndef __IDXTScaleOutput_INTERFACE_DEFINED__
#define __IDXTScaleOutput_INTERFACE_DEFINED__

/* interface IDXTScaleOutput */
/* [object][unique][helpstring][uuid] */ 


EXTERN_C const IID IID_IDXTScaleOutput;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("B2024B50-EE77-11d1-9066-00C04FD9189D")
    IDXTScaleOutput : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetOutputSize( 
            /* [in] */ const SIZE OutSize,
            /* [in] */ BOOL bMaintainAspect) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDXTScaleOutputVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDXTScaleOutput __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDXTScaleOutput __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDXTScaleOutput __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetOutputSize )( 
            IDXTScaleOutput __RPC_FAR * This,
            /* [in] */ const SIZE OutSize,
            /* [in] */ BOOL bMaintainAspect);
        
        END_INTERFACE
    } IDXTScaleOutputVtbl;

    interface IDXTScaleOutput
    {
        CONST_VTBL struct IDXTScaleOutputVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDXTScaleOutput_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDXTScaleOutput_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDXTScaleOutput_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDXTScaleOutput_SetOutputSize(This,OutSize,bMaintainAspect)	\
    (This)->lpVtbl -> SetOutputSize(This,OutSize,bMaintainAspect)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDXTScaleOutput_SetOutputSize_Proxy( 
    IDXTScaleOutput __RPC_FAR * This,
    /* [in] */ const SIZE OutSize,
    /* [in] */ BOOL bMaintainAspect);


void __RPC_STUB IDXTScaleOutput_SetOutputSize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDXTScaleOutput_INTERFACE_DEFINED__ */


#ifndef __IDXGradient_INTERFACE_DEFINED__
#define __IDXGradient_INTERFACE_DEFINED__

/* interface IDXGradient */
/* [object][unique][helpstring][uuid] */ 


EXTERN_C const IID IID_IDXGradient;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("B2024B51-EE77-11d1-9066-00C04FD9189D")
    IDXGradient : public IDXTScaleOutput
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetGradient( 
            DXSAMPLE StartColor,
            DXSAMPLE EndColor,
            BOOL bHorizontal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetOutputSize( 
            /* [out] */ SIZE __RPC_FAR *pOutSize) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDXGradientVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDXGradient __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDXGradient __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDXGradient __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetOutputSize )( 
            IDXGradient __RPC_FAR * This,
            /* [in] */ const SIZE OutSize,
            /* [in] */ BOOL bMaintainAspect);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetGradient )( 
            IDXGradient __RPC_FAR * This,
            DXSAMPLE StartColor,
            DXSAMPLE EndColor,
            BOOL bHorizontal);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetOutputSize )( 
            IDXGradient __RPC_FAR * This,
            /* [out] */ SIZE __RPC_FAR *pOutSize);
        
        END_INTERFACE
    } IDXGradientVtbl;

    interface IDXGradient
    {
        CONST_VTBL struct IDXGradientVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDXGradient_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDXGradient_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDXGradient_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDXGradient_SetOutputSize(This,OutSize,bMaintainAspect)	\
    (This)->lpVtbl -> SetOutputSize(This,OutSize,bMaintainAspect)


#define IDXGradient_SetGradient(This,StartColor,EndColor,bHorizontal)	\
    (This)->lpVtbl -> SetGradient(This,StartColor,EndColor,bHorizontal)

#define IDXGradient_GetOutputSize(This,pOutSize)	\
    (This)->lpVtbl -> GetOutputSize(This,pOutSize)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDXGradient_SetGradient_Proxy( 
    IDXGradient __RPC_FAR * This,
    DXSAMPLE StartColor,
    DXSAMPLE EndColor,
    BOOL bHorizontal);


void __RPC_STUB IDXGradient_SetGradient_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXGradient_GetOutputSize_Proxy( 
    IDXGradient __RPC_FAR * This,
    /* [out] */ SIZE __RPC_FAR *pOutSize);


void __RPC_STUB IDXGradient_GetOutputSize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDXGradient_INTERFACE_DEFINED__ */


#ifndef __IDXGradient2_INTERFACE_DEFINED__
#define __IDXGradient2_INTERFACE_DEFINED__

/* interface IDXGradient2 */
/* [object][unique][helpstring][uuid] */ 


EXTERN_C const IID IID_IDXGradient2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("d0ef2a80-61dc-11d2-b2eb-00a0c936b212")
    IDXGradient2 : public IDXGradient
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetRadialGradient( 
            /* [size_is][in] */ double __RPC_FAR *rgdblOffsets,
            /* [size_is][in] */ double __RPC_FAR *rgdblColors,
            /* [in] */ ULONG ulCount,
            /* [in] */ double dblOpacity,
            /* [in] */ DX2DXFORM __RPC_FAR *pXform,
            /* [in] */ DWORD dwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetLinearGradient( 
            /* [size_is][in] */ double __RPC_FAR *rgdblOffsets,
            /* [size_is][in] */ double __RPC_FAR *rgdblColors,
            /* [in] */ ULONG ulCount,
            /* [in] */ double dblOpacity,
            /* [in] */ DX2DXFORM __RPC_FAR *pXform,
            /* [in] */ DWORD dwFlags) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDXGradient2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDXGradient2 __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDXGradient2 __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDXGradient2 __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetOutputSize )( 
            IDXGradient2 __RPC_FAR * This,
            /* [in] */ const SIZE OutSize,
            /* [in] */ BOOL bMaintainAspect);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetGradient )( 
            IDXGradient2 __RPC_FAR * This,
            DXSAMPLE StartColor,
            DXSAMPLE EndColor,
            BOOL bHorizontal);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetOutputSize )( 
            IDXGradient2 __RPC_FAR * This,
            /* [out] */ SIZE __RPC_FAR *pOutSize);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetRadialGradient )( 
            IDXGradient2 __RPC_FAR * This,
            /* [size_is][in] */ double __RPC_FAR *rgdblOffsets,
            /* [size_is][in] */ double __RPC_FAR *rgdblColors,
            /* [in] */ ULONG ulCount,
            /* [in] */ double dblOpacity,
            /* [in] */ DX2DXFORM __RPC_FAR *pXform,
            /* [in] */ DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetLinearGradient )( 
            IDXGradient2 __RPC_FAR * This,
            /* [size_is][in] */ double __RPC_FAR *rgdblOffsets,
            /* [size_is][in] */ double __RPC_FAR *rgdblColors,
            /* [in] */ ULONG ulCount,
            /* [in] */ double dblOpacity,
            /* [in] */ DX2DXFORM __RPC_FAR *pXform,
            /* [in] */ DWORD dwFlags);
        
        END_INTERFACE
    } IDXGradient2Vtbl;

    interface IDXGradient2
    {
        CONST_VTBL struct IDXGradient2Vtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDXGradient2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDXGradient2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDXGradient2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDXGradient2_SetOutputSize(This,OutSize,bMaintainAspect)	\
    (This)->lpVtbl -> SetOutputSize(This,OutSize,bMaintainAspect)


#define IDXGradient2_SetGradient(This,StartColor,EndColor,bHorizontal)	\
    (This)->lpVtbl -> SetGradient(This,StartColor,EndColor,bHorizontal)

#define IDXGradient2_GetOutputSize(This,pOutSize)	\
    (This)->lpVtbl -> GetOutputSize(This,pOutSize)


#define IDXGradient2_SetRadialGradient(This,rgdblOffsets,rgdblColors,ulCount,dblOpacity,pXform,dwFlags)	\
    (This)->lpVtbl -> SetRadialGradient(This,rgdblOffsets,rgdblColors,ulCount,dblOpacity,pXform,dwFlags)

#define IDXGradient2_SetLinearGradient(This,rgdblOffsets,rgdblColors,ulCount,dblOpacity,pXform,dwFlags)	\
    (This)->lpVtbl -> SetLinearGradient(This,rgdblOffsets,rgdblColors,ulCount,dblOpacity,pXform,dwFlags)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDXGradient2_SetRadialGradient_Proxy( 
    IDXGradient2 __RPC_FAR * This,
    /* [size_is][in] */ double __RPC_FAR *rgdblOffsets,
    /* [size_is][in] */ double __RPC_FAR *rgdblColors,
    /* [in] */ ULONG ulCount,
    /* [in] */ double dblOpacity,
    /* [in] */ DX2DXFORM __RPC_FAR *pXform,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB IDXGradient2_SetRadialGradient_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXGradient2_SetLinearGradient_Proxy( 
    IDXGradient2 __RPC_FAR * This,
    /* [size_is][in] */ double __RPC_FAR *rgdblOffsets,
    /* [size_is][in] */ double __RPC_FAR *rgdblColors,
    /* [in] */ ULONG ulCount,
    /* [in] */ double dblOpacity,
    /* [in] */ DX2DXFORM __RPC_FAR *pXform,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB IDXGradient2_SetLinearGradient_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDXGradient2_INTERFACE_DEFINED__ */


#ifndef __IDXTScale_INTERFACE_DEFINED__
#define __IDXTScale_INTERFACE_DEFINED__

/* interface IDXTScale */
/* [object][unique][helpstring][uuid] */ 


EXTERN_C const IID IID_IDXTScale;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("B39FD742-E139-11d1-9065-00C04FD9189D")
    IDXTScale : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetScales( 
            /* [in] */ float __RPC_FAR Scales[ 2 ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetScales( 
            /* [out] */ float __RPC_FAR Scales[ 2 ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ScaleFitToSize( 
            /* [out][in] */ DXBNDS __RPC_FAR *pClipBounds,
            /* [in] */ SIZE FitToSize,
            /* [in] */ BOOL bMaintainAspect) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDXTScaleVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDXTScale __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDXTScale __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDXTScale __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetScales )( 
            IDXTScale __RPC_FAR * This,
            /* [in] */ float __RPC_FAR Scales[ 2 ]);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetScales )( 
            IDXTScale __RPC_FAR * This,
            /* [out] */ float __RPC_FAR Scales[ 2 ]);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ScaleFitToSize )( 
            IDXTScale __RPC_FAR * This,
            /* [out][in] */ DXBNDS __RPC_FAR *pClipBounds,
            /* [in] */ SIZE FitToSize,
            /* [in] */ BOOL bMaintainAspect);
        
        END_INTERFACE
    } IDXTScaleVtbl;

    interface IDXTScale
    {
        CONST_VTBL struct IDXTScaleVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDXTScale_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDXTScale_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDXTScale_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDXTScale_SetScales(This,Scales)	\
    (This)->lpVtbl -> SetScales(This,Scales)

#define IDXTScale_GetScales(This,Scales)	\
    (This)->lpVtbl -> GetScales(This,Scales)

#define IDXTScale_ScaleFitToSize(This,pClipBounds,FitToSize,bMaintainAspect)	\
    (This)->lpVtbl -> ScaleFitToSize(This,pClipBounds,FitToSize,bMaintainAspect)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDXTScale_SetScales_Proxy( 
    IDXTScale __RPC_FAR * This,
    /* [in] */ float __RPC_FAR Scales[ 2 ]);


void __RPC_STUB IDXTScale_SetScales_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXTScale_GetScales_Proxy( 
    IDXTScale __RPC_FAR * This,
    /* [out] */ float __RPC_FAR Scales[ 2 ]);


void __RPC_STUB IDXTScale_GetScales_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXTScale_ScaleFitToSize_Proxy( 
    IDXTScale __RPC_FAR * This,
    /* [out][in] */ DXBNDS __RPC_FAR *pClipBounds,
    /* [in] */ SIZE FitToSize,
    /* [in] */ BOOL bMaintainAspect);


void __RPC_STUB IDXTScale_ScaleFitToSize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDXTScale_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_dxtrans_0269 */
/* [local] */ 

typedef 
enum DXLOGFONTENUM
    {	DXLF_HEIGHT	= 1,
	DXLF_WIDTH	= 2,
	DXLF_ESC	= 4,
	DXLF_ORIENTATION	= 8,
	DXLF_WEIGHT	= 16,
	DXLF_ITALIC	= 32,
	DXLF_UNDERLINE	= 64,
	DXLF_STRIKEOUT	= 128,
	DXLF_CHARSET	= 256,
	DXLF_OUTPREC	= 512,
	DXLF_CLIPPREC	= 1024,
	DXLF_QUALITY	= 2048,
	DXLF_PITCHANDFAM	= 4096,
	DXLF_FACENAME	= 8192,
	DXLF_ALL	= 0x3fff
    }	DXLOGFONTENUM;

#ifndef _WINGDI_
typedef struct tagLOGFONTA
    {
    LONG lfHeight;
    LONG lfWidth;
    LONG lfEscapement;
    LONG lfOrientation;
    LONG lfWeight;
    BYTE lfItalic;
    BYTE lfUnderline;
    BYTE lfStrikeOut;
    BYTE lfCharSet;
    BYTE lfOutPrecision;
    BYTE lfClipPrecision;
    BYTE lfQuality;
    BYTE lfPitchAndFamily;
    CHAR lfFaceName[ 32 ];
    }	LOGFONTA;

typedef struct tagLOGFONTW
    {
    LONG lfHeight;
    LONG lfWidth;
    LONG lfEscapement;
    LONG lfOrientation;
    LONG lfWeight;
    BYTE lfItalic;
    BYTE lfUnderline;
    BYTE lfStrikeOut;
    BYTE lfCharSet;
    BYTE lfOutPrecision;
    BYTE lfClipPrecision;
    BYTE lfQuality;
    BYTE lfPitchAndFamily;
    WCHAR lfFaceName[ 32 ];
    }	LOGFONTW;

typedef LOGFONTA LOGFONT;

#endif


extern RPC_IF_HANDLE __MIDL_itf_dxtrans_0269_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_dxtrans_0269_v0_0_s_ifspec;

#ifndef __IDXTLabel_INTERFACE_DEFINED__
#define __IDXTLabel_INTERFACE_DEFINED__

/* interface IDXTLabel */
/* [object][unique][helpstring][uuid] */ 


EXTERN_C const IID IID_IDXTLabel;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("C0C17F0E-AE41-11d1-9A3B-0000F8756A10")
    IDXTLabel : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetFontHandle( 
            /* [in] */ HFONT hFont) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFontHandle( 
            /* [out] */ HFONT __RPC_FAR *phFont) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetTextString( 
            /* [in] */ LPCWSTR pString) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetTextString( 
            /* [out] */ LPWSTR __RPC_FAR *ppString) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFillColor( 
            /* [out] */ DXSAMPLE __RPC_FAR *pVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetFillColor( 
            /* [in] */ DXSAMPLE newVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetBackgroundColor( 
            /* [out] */ DXSAMPLE __RPC_FAR *pVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetBackgroundColor( 
            /* [in] */ DXSAMPLE newVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetTexturePosition( 
            /* [out] */ long __RPC_FAR *px,
            /* [out] */ long __RPC_FAR *py) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetTexturePosition( 
            /* [in] */ long x,
            /* [in] */ long y) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetMatrix( 
            /* [out] */ PDX2DXFORM pXform) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetMatrix( 
            /* [in] */ const PDX2DXFORM pXform) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetLogfont( 
            /* [in] */ const LOGFONT __RPC_FAR *plf,
            /* [in] */ DWORD dwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetLogfont( 
            /* [out] */ LOGFONT __RPC_FAR *plf,
            /* [in] */ DWORD dwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ExecuteWithRasterizer( 
            /* [in] */ IDXRasterizer __RPC_FAR *pRasterizer,
            /* [in] */ const DXBNDS __RPC_FAR *pClipBnds,
            /* [in] */ const DXVEC __RPC_FAR *pPlacement) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetBaselineOffset( 
            /* [out] */ long __RPC_FAR *px,
            /* [out] */ long __RPC_FAR *py,
            /* [out] */ long __RPC_FAR *pdx,
            /* [out] */ long __RPC_FAR *pdy) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDXTLabelVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDXTLabel __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDXTLabel __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDXTLabel __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetFontHandle )( 
            IDXTLabel __RPC_FAR * This,
            /* [in] */ HFONT hFont);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetFontHandle )( 
            IDXTLabel __RPC_FAR * This,
            /* [out] */ HFONT __RPC_FAR *phFont);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetTextString )( 
            IDXTLabel __RPC_FAR * This,
            /* [in] */ LPCWSTR pString);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTextString )( 
            IDXTLabel __RPC_FAR * This,
            /* [out] */ LPWSTR __RPC_FAR *ppString);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetFillColor )( 
            IDXTLabel __RPC_FAR * This,
            /* [out] */ DXSAMPLE __RPC_FAR *pVal);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetFillColor )( 
            IDXTLabel __RPC_FAR * This,
            /* [in] */ DXSAMPLE newVal);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetBackgroundColor )( 
            IDXTLabel __RPC_FAR * This,
            /* [out] */ DXSAMPLE __RPC_FAR *pVal);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetBackgroundColor )( 
            IDXTLabel __RPC_FAR * This,
            /* [in] */ DXSAMPLE newVal);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTexturePosition )( 
            IDXTLabel __RPC_FAR * This,
            /* [out] */ long __RPC_FAR *px,
            /* [out] */ long __RPC_FAR *py);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetTexturePosition )( 
            IDXTLabel __RPC_FAR * This,
            /* [in] */ long x,
            /* [in] */ long y);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetMatrix )( 
            IDXTLabel __RPC_FAR * This,
            /* [out] */ PDX2DXFORM pXform);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetMatrix )( 
            IDXTLabel __RPC_FAR * This,
            /* [in] */ const PDX2DXFORM pXform);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetLogfont )( 
            IDXTLabel __RPC_FAR * This,
            /* [in] */ const LOGFONT __RPC_FAR *plf,
            /* [in] */ DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetLogfont )( 
            IDXTLabel __RPC_FAR * This,
            /* [out] */ LOGFONT __RPC_FAR *plf,
            /* [in] */ DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ExecuteWithRasterizer )( 
            IDXTLabel __RPC_FAR * This,
            /* [in] */ IDXRasterizer __RPC_FAR *pRasterizer,
            /* [in] */ const DXBNDS __RPC_FAR *pClipBnds,
            /* [in] */ const DXVEC __RPC_FAR *pPlacement);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetBaselineOffset )( 
            IDXTLabel __RPC_FAR * This,
            /* [out] */ long __RPC_FAR *px,
            /* [out] */ long __RPC_FAR *py,
            /* [out] */ long __RPC_FAR *pdx,
            /* [out] */ long __RPC_FAR *pdy);
        
        END_INTERFACE
    } IDXTLabelVtbl;

    interface IDXTLabel
    {
        CONST_VTBL struct IDXTLabelVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDXTLabel_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDXTLabel_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDXTLabel_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDXTLabel_SetFontHandle(This,hFont)	\
    (This)->lpVtbl -> SetFontHandle(This,hFont)

#define IDXTLabel_GetFontHandle(This,phFont)	\
    (This)->lpVtbl -> GetFontHandle(This,phFont)

#define IDXTLabel_SetTextString(This,pString)	\
    (This)->lpVtbl -> SetTextString(This,pString)

#define IDXTLabel_GetTextString(This,ppString)	\
    (This)->lpVtbl -> GetTextString(This,ppString)

#define IDXTLabel_GetFillColor(This,pVal)	\
    (This)->lpVtbl -> GetFillColor(This,pVal)

#define IDXTLabel_SetFillColor(This,newVal)	\
    (This)->lpVtbl -> SetFillColor(This,newVal)

#define IDXTLabel_GetBackgroundColor(This,pVal)	\
    (This)->lpVtbl -> GetBackgroundColor(This,pVal)

#define IDXTLabel_SetBackgroundColor(This,newVal)	\
    (This)->lpVtbl -> SetBackgroundColor(This,newVal)

#define IDXTLabel_GetTexturePosition(This,px,py)	\
    (This)->lpVtbl -> GetTexturePosition(This,px,py)

#define IDXTLabel_SetTexturePosition(This,x,y)	\
    (This)->lpVtbl -> SetTexturePosition(This,x,y)

#define IDXTLabel_GetMatrix(This,pXform)	\
    (This)->lpVtbl -> GetMatrix(This,pXform)

#define IDXTLabel_SetMatrix(This,pXform)	\
    (This)->lpVtbl -> SetMatrix(This,pXform)

#define IDXTLabel_SetLogfont(This,plf,dwFlags)	\
    (This)->lpVtbl -> SetLogfont(This,plf,dwFlags)

#define IDXTLabel_GetLogfont(This,plf,dwFlags)	\
    (This)->lpVtbl -> GetLogfont(This,plf,dwFlags)

#define IDXTLabel_ExecuteWithRasterizer(This,pRasterizer,pClipBnds,pPlacement)	\
    (This)->lpVtbl -> ExecuteWithRasterizer(This,pRasterizer,pClipBnds,pPlacement)

#define IDXTLabel_GetBaselineOffset(This,px,py,pdx,pdy)	\
    (This)->lpVtbl -> GetBaselineOffset(This,px,py,pdx,pdy)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDXTLabel_SetFontHandle_Proxy( 
    IDXTLabel __RPC_FAR * This,
    /* [in] */ HFONT hFont);


void __RPC_STUB IDXTLabel_SetFontHandle_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXTLabel_GetFontHandle_Proxy( 
    IDXTLabel __RPC_FAR * This,
    /* [out] */ HFONT __RPC_FAR *phFont);


void __RPC_STUB IDXTLabel_GetFontHandle_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXTLabel_SetTextString_Proxy( 
    IDXTLabel __RPC_FAR * This,
    /* [in] */ LPCWSTR pString);


void __RPC_STUB IDXTLabel_SetTextString_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXTLabel_GetTextString_Proxy( 
    IDXTLabel __RPC_FAR * This,
    /* [out] */ LPWSTR __RPC_FAR *ppString);


void __RPC_STUB IDXTLabel_GetTextString_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXTLabel_GetFillColor_Proxy( 
    IDXTLabel __RPC_FAR * This,
    /* [out] */ DXSAMPLE __RPC_FAR *pVal);


void __RPC_STUB IDXTLabel_GetFillColor_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXTLabel_SetFillColor_Proxy( 
    IDXTLabel __RPC_FAR * This,
    /* [in] */ DXSAMPLE newVal);


void __RPC_STUB IDXTLabel_SetFillColor_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXTLabel_GetBackgroundColor_Proxy( 
    IDXTLabel __RPC_FAR * This,
    /* [out] */ DXSAMPLE __RPC_FAR *pVal);


void __RPC_STUB IDXTLabel_GetBackgroundColor_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXTLabel_SetBackgroundColor_Proxy( 
    IDXTLabel __RPC_FAR * This,
    /* [in] */ DXSAMPLE newVal);


void __RPC_STUB IDXTLabel_SetBackgroundColor_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXTLabel_GetTexturePosition_Proxy( 
    IDXTLabel __RPC_FAR * This,
    /* [out] */ long __RPC_FAR *px,
    /* [out] */ long __RPC_FAR *py);


void __RPC_STUB IDXTLabel_GetTexturePosition_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXTLabel_SetTexturePosition_Proxy( 
    IDXTLabel __RPC_FAR * This,
    /* [in] */ long x,
    /* [in] */ long y);


void __RPC_STUB IDXTLabel_SetTexturePosition_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXTLabel_GetMatrix_Proxy( 
    IDXTLabel __RPC_FAR * This,
    /* [out] */ PDX2DXFORM pXform);


void __RPC_STUB IDXTLabel_GetMatrix_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXTLabel_SetMatrix_Proxy( 
    IDXTLabel __RPC_FAR * This,
    /* [in] */ const PDX2DXFORM pXform);


void __RPC_STUB IDXTLabel_SetMatrix_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXTLabel_SetLogfont_Proxy( 
    IDXTLabel __RPC_FAR * This,
    /* [in] */ const LOGFONT __RPC_FAR *plf,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB IDXTLabel_SetLogfont_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXTLabel_GetLogfont_Proxy( 
    IDXTLabel __RPC_FAR * This,
    /* [out] */ LOGFONT __RPC_FAR *plf,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB IDXTLabel_GetLogfont_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXTLabel_ExecuteWithRasterizer_Proxy( 
    IDXTLabel __RPC_FAR * This,
    /* [in] */ IDXRasterizer __RPC_FAR *pRasterizer,
    /* [in] */ const DXBNDS __RPC_FAR *pClipBnds,
    /* [in] */ const DXVEC __RPC_FAR *pPlacement);


void __RPC_STUB IDXTLabel_ExecuteWithRasterizer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXTLabel_GetBaselineOffset_Proxy( 
    IDXTLabel __RPC_FAR * This,
    /* [out] */ long __RPC_FAR *px,
    /* [out] */ long __RPC_FAR *py,
    /* [out] */ long __RPC_FAR *pdx,
    /* [out] */ long __RPC_FAR *pdy);


void __RPC_STUB IDXTLabel_GetBaselineOffset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDXTLabel_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_dxtrans_0270 */
/* [local] */ 

typedef 
enum DXRASTERFILL
    {	DXRASTER_PEN	= 0,
	DXRASTER_BRUSH	= 1,
	DXRASTER_BACKGROUND	= 2
    }	DXRASTERFILL;

typedef struct DXRASTERSCANINFO
    {
    ULONG ulIndex;
    ULONG Row;
    const BYTE __RPC_FAR *pWeights;
    const DXRUNINFO __RPC_FAR *pRunInfo;
    ULONG cRunInfo;
    }	DXRASTERSCANINFO;

typedef struct DXRASTERPOINTINFO
    {
    DXOVERSAMPLEDESC Pixel;
    ULONG ulIndex;
    BYTE Weight;
    }	DXRASTERPOINTINFO;

typedef struct DXRASTERRECTINFO
    {
    ULONG ulIndex;
    RECT Rect;
    BYTE Weight;
    }	DXRASTERRECTINFO;



extern RPC_IF_HANDLE __MIDL_itf_dxtrans_0270_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_dxtrans_0270_v0_0_s_ifspec;

#ifndef __IDXRasterizer_INTERFACE_DEFINED__
#define __IDXRasterizer_INTERFACE_DEFINED__

/* interface IDXRasterizer */
/* [object][local][unique][helpstring][uuid] */ 


EXTERN_C const IID IID_IDXRasterizer;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("9EA3B635-C37D-11d1-905E-00C04FD9189D")
    IDXRasterizer : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetSurface( 
            /* [in] */ IDXSurface __RPC_FAR *pDXSurface) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSurface( 
            /* [out] */ IDXSurface __RPC_FAR *__RPC_FAR *ppDXSurface) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetFill( 
            /* [in] */ ULONG ulIndex,
            /* [in] */ IDXSurface __RPC_FAR *pSurface,
            /* [in] */ const POINT __RPC_FAR *ppt,
            /* [in] */ DXSAMPLE FillColor) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFill( 
            /* [in] */ ULONG ulIndex,
            /* [out] */ IDXSurface __RPC_FAR *__RPC_FAR *ppSurface,
            /* [out] */ POINT __RPC_FAR *ppt,
            /* [out] */ DXSAMPLE __RPC_FAR *pFillColor) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE BeginRendering( 
            /* [in] */ ULONG ulTimeOut) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EndRendering( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RenderScan( 
            /* [in] */ const DXRASTERSCANINFO __RPC_FAR *pScanInfo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetPixel( 
            /* [in] */ DXRASTERPOINTINFO __RPC_FAR *pPointInfo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FillRect( 
            /* [in] */ const DXRASTERRECTINFO __RPC_FAR *pRectInfo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetBounds( 
            /* [out] */ DXBNDS __RPC_FAR *pBounds) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDXRasterizerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDXRasterizer __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDXRasterizer __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDXRasterizer __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetSurface )( 
            IDXRasterizer __RPC_FAR * This,
            /* [in] */ IDXSurface __RPC_FAR *pDXSurface);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetSurface )( 
            IDXRasterizer __RPC_FAR * This,
            /* [out] */ IDXSurface __RPC_FAR *__RPC_FAR *ppDXSurface);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetFill )( 
            IDXRasterizer __RPC_FAR * This,
            /* [in] */ ULONG ulIndex,
            /* [in] */ IDXSurface __RPC_FAR *pSurface,
            /* [in] */ const POINT __RPC_FAR *ppt,
            /* [in] */ DXSAMPLE FillColor);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetFill )( 
            IDXRasterizer __RPC_FAR * This,
            /* [in] */ ULONG ulIndex,
            /* [out] */ IDXSurface __RPC_FAR *__RPC_FAR *ppSurface,
            /* [out] */ POINT __RPC_FAR *ppt,
            /* [out] */ DXSAMPLE __RPC_FAR *pFillColor);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *BeginRendering )( 
            IDXRasterizer __RPC_FAR * This,
            /* [in] */ ULONG ulTimeOut);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EndRendering )( 
            IDXRasterizer __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RenderScan )( 
            IDXRasterizer __RPC_FAR * This,
            /* [in] */ const DXRASTERSCANINFO __RPC_FAR *pScanInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetPixel )( 
            IDXRasterizer __RPC_FAR * This,
            /* [in] */ DXRASTERPOINTINFO __RPC_FAR *pPointInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *FillRect )( 
            IDXRasterizer __RPC_FAR * This,
            /* [in] */ const DXRASTERRECTINFO __RPC_FAR *pRectInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetBounds )( 
            IDXRasterizer __RPC_FAR * This,
            /* [out] */ DXBNDS __RPC_FAR *pBounds);
        
        END_INTERFACE
    } IDXRasterizerVtbl;

    interface IDXRasterizer
    {
        CONST_VTBL struct IDXRasterizerVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDXRasterizer_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDXRasterizer_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDXRasterizer_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDXRasterizer_SetSurface(This,pDXSurface)	\
    (This)->lpVtbl -> SetSurface(This,pDXSurface)

#define IDXRasterizer_GetSurface(This,ppDXSurface)	\
    (This)->lpVtbl -> GetSurface(This,ppDXSurface)

#define IDXRasterizer_SetFill(This,ulIndex,pSurface,ppt,FillColor)	\
    (This)->lpVtbl -> SetFill(This,ulIndex,pSurface,ppt,FillColor)

#define IDXRasterizer_GetFill(This,ulIndex,ppSurface,ppt,pFillColor)	\
    (This)->lpVtbl -> GetFill(This,ulIndex,ppSurface,ppt,pFillColor)

#define IDXRasterizer_BeginRendering(This,ulTimeOut)	\
    (This)->lpVtbl -> BeginRendering(This,ulTimeOut)

#define IDXRasterizer_EndRendering(This)	\
    (This)->lpVtbl -> EndRendering(This)

#define IDXRasterizer_RenderScan(This,pScanInfo)	\
    (This)->lpVtbl -> RenderScan(This,pScanInfo)

#define IDXRasterizer_SetPixel(This,pPointInfo)	\
    (This)->lpVtbl -> SetPixel(This,pPointInfo)

#define IDXRasterizer_FillRect(This,pRectInfo)	\
    (This)->lpVtbl -> FillRect(This,pRectInfo)

#define IDXRasterizer_GetBounds(This,pBounds)	\
    (This)->lpVtbl -> GetBounds(This,pBounds)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDXRasterizer_SetSurface_Proxy( 
    IDXRasterizer __RPC_FAR * This,
    /* [in] */ IDXSurface __RPC_FAR *pDXSurface);


void __RPC_STUB IDXRasterizer_SetSurface_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXRasterizer_GetSurface_Proxy( 
    IDXRasterizer __RPC_FAR * This,
    /* [out] */ IDXSurface __RPC_FAR *__RPC_FAR *ppDXSurface);


void __RPC_STUB IDXRasterizer_GetSurface_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXRasterizer_SetFill_Proxy( 
    IDXRasterizer __RPC_FAR * This,
    /* [in] */ ULONG ulIndex,
    /* [in] */ IDXSurface __RPC_FAR *pSurface,
    /* [in] */ const POINT __RPC_FAR *ppt,
    /* [in] */ DXSAMPLE FillColor);


void __RPC_STUB IDXRasterizer_SetFill_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXRasterizer_GetFill_Proxy( 
    IDXRasterizer __RPC_FAR * This,
    /* [in] */ ULONG ulIndex,
    /* [out] */ IDXSurface __RPC_FAR *__RPC_FAR *ppSurface,
    /* [out] */ POINT __RPC_FAR *ppt,
    /* [out] */ DXSAMPLE __RPC_FAR *pFillColor);


void __RPC_STUB IDXRasterizer_GetFill_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXRasterizer_BeginRendering_Proxy( 
    IDXRasterizer __RPC_FAR * This,
    /* [in] */ ULONG ulTimeOut);


void __RPC_STUB IDXRasterizer_BeginRendering_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXRasterizer_EndRendering_Proxy( 
    IDXRasterizer __RPC_FAR * This);


void __RPC_STUB IDXRasterizer_EndRendering_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXRasterizer_RenderScan_Proxy( 
    IDXRasterizer __RPC_FAR * This,
    /* [in] */ const DXRASTERSCANINFO __RPC_FAR *pScanInfo);


void __RPC_STUB IDXRasterizer_RenderScan_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXRasterizer_SetPixel_Proxy( 
    IDXRasterizer __RPC_FAR * This,
    /* [in] */ DXRASTERPOINTINFO __RPC_FAR *pPointInfo);


void __RPC_STUB IDXRasterizer_SetPixel_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXRasterizer_FillRect_Proxy( 
    IDXRasterizer __RPC_FAR * This,
    /* [in] */ const DXRASTERRECTINFO __RPC_FAR *pRectInfo);


void __RPC_STUB IDXRasterizer_FillRect_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXRasterizer_GetBounds_Proxy( 
    IDXRasterizer __RPC_FAR * This,
    /* [out] */ DXBNDS __RPC_FAR *pBounds);


void __RPC_STUB IDXRasterizer_GetBounds_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDXRasterizer_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_dxtrans_0271 */
/* [local] */ 

typedef 
enum DISPIDDXEFFECT
    {	DISPID_DXECAPABILITIES	= 10000,
	DISPID_DXEPROGRESS	= DISPID_DXECAPABILITIES + 1,
	DISPID_DXESTEP	= DISPID_DXEPROGRESS + 1,
	DISPID_DXEDURATION	= DISPID_DXESTEP + 1,
	DISPID_DXE_NEXT_ID	= DISPID_DXEDURATION + 1
    }	DISPIDDXBOUNDEDEFFECT;

typedef 
enum DXEFFECTTYPE
    {	DXTET_PERIODIC	= 1 << 0,
	DXTET_MORPH	= 1 << 1
    }	DXEFFECTTYPE;



extern RPC_IF_HANDLE __MIDL_itf_dxtrans_0271_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_dxtrans_0271_v0_0_s_ifspec;

#ifndef __IDXEffect_INTERFACE_DEFINED__
#define __IDXEffect_INTERFACE_DEFINED__

/* interface IDXEffect */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IDXEffect;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("E31FB81B-1335-11d1-8189-0000F87557DB")
    IDXEffect : public IDispatch
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Capabilities( 
            /* [retval][out] */ long __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Progress( 
            /* [retval][out] */ float __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Progress( 
            /* [in] */ float newVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_StepResolution( 
            /* [retval][out] */ float __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Duration( 
            /* [retval][out] */ float __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Duration( 
            /* [in] */ float newVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDXEffectVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDXEffect __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDXEffect __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDXEffect __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IDXEffect __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IDXEffect __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IDXEffect __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IDXEffect __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Capabilities )( 
            IDXEffect __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Progress )( 
            IDXEffect __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Progress )( 
            IDXEffect __RPC_FAR * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_StepResolution )( 
            IDXEffect __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Duration )( 
            IDXEffect __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Duration )( 
            IDXEffect __RPC_FAR * This,
            /* [in] */ float newVal);
        
        END_INTERFACE
    } IDXEffectVtbl;

    interface IDXEffect
    {
        CONST_VTBL struct IDXEffectVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDXEffect_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDXEffect_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDXEffect_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDXEffect_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IDXEffect_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IDXEffect_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IDXEffect_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IDXEffect_get_Capabilities(This,pVal)	\
    (This)->lpVtbl -> get_Capabilities(This,pVal)

#define IDXEffect_get_Progress(This,pVal)	\
    (This)->lpVtbl -> get_Progress(This,pVal)

#define IDXEffect_put_Progress(This,newVal)	\
    (This)->lpVtbl -> put_Progress(This,newVal)

#define IDXEffect_get_StepResolution(This,pVal)	\
    (This)->lpVtbl -> get_StepResolution(This,pVal)

#define IDXEffect_get_Duration(This,pVal)	\
    (This)->lpVtbl -> get_Duration(This,pVal)

#define IDXEffect_put_Duration(This,newVal)	\
    (This)->lpVtbl -> put_Duration(This,newVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXEffect_get_Capabilities_Proxy( 
    IDXEffect __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pVal);


void __RPC_STUB IDXEffect_get_Capabilities_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXEffect_get_Progress_Proxy( 
    IDXEffect __RPC_FAR * This,
    /* [retval][out] */ float __RPC_FAR *pVal);


void __RPC_STUB IDXEffect_get_Progress_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXEffect_put_Progress_Proxy( 
    IDXEffect __RPC_FAR * This,
    /* [in] */ float newVal);


void __RPC_STUB IDXEffect_put_Progress_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXEffect_get_StepResolution_Proxy( 
    IDXEffect __RPC_FAR * This,
    /* [retval][out] */ float __RPC_FAR *pVal);


void __RPC_STUB IDXEffect_get_StepResolution_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXEffect_get_Duration_Proxy( 
    IDXEffect __RPC_FAR * This,
    /* [retval][out] */ float __RPC_FAR *pVal);


void __RPC_STUB IDXEffect_get_Duration_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXEffect_put_Duration_Proxy( 
    IDXEffect __RPC_FAR * This,
    /* [in] */ float newVal);


void __RPC_STUB IDXEffect_put_Duration_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDXEffect_INTERFACE_DEFINED__ */


#ifndef __IDXLookupTable_INTERFACE_DEFINED__
#define __IDXLookupTable_INTERFACE_DEFINED__

/* interface IDXLookupTable */
/* [object][unique][helpstring][uuid] */ 


EXTERN_C const IID IID_IDXLookupTable;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("01BAFC7F-9E63-11d1-9053-00C04FD9189D")
    IDXLookupTable : public IDXBaseObject
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetTables( 
            /* [out] */ BYTE __RPC_FAR RedLUT[ 256 ],
            /* [out] */ BYTE __RPC_FAR GreenLUT[ 256 ],
            /* [out] */ BYTE __RPC_FAR BlueLUT[ 256 ],
            /* [out] */ BYTE __RPC_FAR AlphaLUT[ 256 ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsChannelIdentity( 
            /* [out] */ DXBASESAMPLE __RPC_FAR *pSampleBools) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetIndexValues( 
            /* [in] */ ULONG Index,
            /* [out] */ DXBASESAMPLE __RPC_FAR *pSample) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ApplyTables( 
            /* [out][in] */ DXSAMPLE __RPC_FAR *pSamples,
            /* [in] */ ULONG cSamples) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDXLookupTableVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDXLookupTable __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDXLookupTable __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDXLookupTable __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetGenerationId )( 
            IDXLookupTable __RPC_FAR * This,
            /* [out] */ ULONG __RPC_FAR *pID);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *IncrementGenerationId )( 
            IDXLookupTable __RPC_FAR * This,
            /* [in] */ BOOL bRefresh);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetObjectSize )( 
            IDXLookupTable __RPC_FAR * This,
            /* [out] */ ULONG __RPC_FAR *pcbSize);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTables )( 
            IDXLookupTable __RPC_FAR * This,
            /* [out] */ BYTE __RPC_FAR RedLUT[ 256 ],
            /* [out] */ BYTE __RPC_FAR GreenLUT[ 256 ],
            /* [out] */ BYTE __RPC_FAR BlueLUT[ 256 ],
            /* [out] */ BYTE __RPC_FAR AlphaLUT[ 256 ]);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *IsChannelIdentity )( 
            IDXLookupTable __RPC_FAR * This,
            /* [out] */ DXBASESAMPLE __RPC_FAR *pSampleBools);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIndexValues )( 
            IDXLookupTable __RPC_FAR * This,
            /* [in] */ ULONG Index,
            /* [out] */ DXBASESAMPLE __RPC_FAR *pSample);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ApplyTables )( 
            IDXLookupTable __RPC_FAR * This,
            /* [out][in] */ DXSAMPLE __RPC_FAR *pSamples,
            /* [in] */ ULONG cSamples);
        
        END_INTERFACE
    } IDXLookupTableVtbl;

    interface IDXLookupTable
    {
        CONST_VTBL struct IDXLookupTableVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDXLookupTable_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDXLookupTable_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDXLookupTable_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDXLookupTable_GetGenerationId(This,pID)	\
    (This)->lpVtbl -> GetGenerationId(This,pID)

#define IDXLookupTable_IncrementGenerationId(This,bRefresh)	\
    (This)->lpVtbl -> IncrementGenerationId(This,bRefresh)

#define IDXLookupTable_GetObjectSize(This,pcbSize)	\
    (This)->lpVtbl -> GetObjectSize(This,pcbSize)


#define IDXLookupTable_GetTables(This,RedLUT,GreenLUT,BlueLUT,AlphaLUT)	\
    (This)->lpVtbl -> GetTables(This,RedLUT,GreenLUT,BlueLUT,AlphaLUT)

#define IDXLookupTable_IsChannelIdentity(This,pSampleBools)	\
    (This)->lpVtbl -> IsChannelIdentity(This,pSampleBools)

#define IDXLookupTable_GetIndexValues(This,Index,pSample)	\
    (This)->lpVtbl -> GetIndexValues(This,Index,pSample)

#define IDXLookupTable_ApplyTables(This,pSamples,cSamples)	\
    (This)->lpVtbl -> ApplyTables(This,pSamples,cSamples)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDXLookupTable_GetTables_Proxy( 
    IDXLookupTable __RPC_FAR * This,
    /* [out] */ BYTE __RPC_FAR RedLUT[ 256 ],
    /* [out] */ BYTE __RPC_FAR GreenLUT[ 256 ],
    /* [out] */ BYTE __RPC_FAR BlueLUT[ 256 ],
    /* [out] */ BYTE __RPC_FAR AlphaLUT[ 256 ]);


void __RPC_STUB IDXLookupTable_GetTables_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXLookupTable_IsChannelIdentity_Proxy( 
    IDXLookupTable __RPC_FAR * This,
    /* [out] */ DXBASESAMPLE __RPC_FAR *pSampleBools);


void __RPC_STUB IDXLookupTable_IsChannelIdentity_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXLookupTable_GetIndexValues_Proxy( 
    IDXLookupTable __RPC_FAR * This,
    /* [in] */ ULONG Index,
    /* [out] */ DXBASESAMPLE __RPC_FAR *pSample);


void __RPC_STUB IDXLookupTable_GetIndexValues_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXLookupTable_ApplyTables_Proxy( 
    IDXLookupTable __RPC_FAR * This,
    /* [out][in] */ DXSAMPLE __RPC_FAR *pSamples,
    /* [in] */ ULONG cSamples);


void __RPC_STUB IDXLookupTable_ApplyTables_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDXLookupTable_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_dxtrans_0273 */
/* [local] */ 

typedef 
enum DX2DPOLYDRAW
    {	DX2D_WINDING_FILL	= 1L << 0,
	DX2D_NO_FLATTEN	= 1L << 1,
	DX2D_DO_GRID_FIT	= 1L << 2,
	DX2D_IS_RECT	= 1L << 3,
	DX2D_STROKE	= 1L << 4,
	DX2D_FILL	= 1L << 5,
	DX2D_UNUSED	= 0xffffffc0
    }	DX2DPOLYDRAW;

typedef struct DXFPOINT
    {
    FLOAT x;
    FLOAT y;
    }	DXFPOINT;

typedef 
enum DX2DPEN
    {	DX2D_PEN_DEFAULT	= 0,
	DX2D_PEN_WIDTH_IN_DISPLAY_COORDS	= 1L << 0,
	DX2D_PEN_UNUSED	= 0xfffffffe
    }	DX2DPEN;

typedef struct DXPEN
    {
    DXSAMPLE Color;
    float Width;
    DWORD Style;
    IDXSurface __RPC_FAR *pTexture;
    DXFPOINT TexturePos;
    DWORD dwFlags;
    }	DXPEN;

typedef struct DXBRUSH
    {
    DXSAMPLE Color;
    IDXSurface __RPC_FAR *pTexture;
    DXFPOINT TexturePos;
    }	DXBRUSH;

typedef 
enum DX2DGRADIENT
    {	DX2DGRAD_DEFAULT	= 0,
	DX2DGRAD_CLIPGRADIENT	= 1,
	DX2DGRAD_UNUSED	= 0xfffffffe
    }	DX2DGRADIENT;



extern RPC_IF_HANDLE __MIDL_itf_dxtrans_0273_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_dxtrans_0273_v0_0_s_ifspec;

#ifndef __IDX2DDebug_INTERFACE_DEFINED__
#define __IDX2DDebug_INTERFACE_DEFINED__

/* interface IDX2DDebug */
/* [object][unique][helpstring][uuid][local] */ 


EXTERN_C const IID IID_IDX2DDebug;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("03BB2457-A279-11d1-81C6-0000F87557DB")
    IDX2DDebug : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetDC( 
            HDC hDC) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDC( 
            HDC __RPC_FAR *phDC) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDX2DDebugVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDX2DDebug __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDX2DDebug __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDX2DDebug __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetDC )( 
            IDX2DDebug __RPC_FAR * This,
            HDC hDC);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetDC )( 
            IDX2DDebug __RPC_FAR * This,
            HDC __RPC_FAR *phDC);
        
        END_INTERFACE
    } IDX2DDebugVtbl;

    interface IDX2DDebug
    {
        CONST_VTBL struct IDX2DDebugVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDX2DDebug_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDX2DDebug_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDX2DDebug_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDX2DDebug_SetDC(This,hDC)	\
    (This)->lpVtbl -> SetDC(This,hDC)

#define IDX2DDebug_GetDC(This,phDC)	\
    (This)->lpVtbl -> GetDC(This,phDC)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDX2DDebug_SetDC_Proxy( 
    IDX2DDebug __RPC_FAR * This,
    HDC hDC);


void __RPC_STUB IDX2DDebug_SetDC_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDX2DDebug_GetDC_Proxy( 
    IDX2DDebug __RPC_FAR * This,
    HDC __RPC_FAR *phDC);


void __RPC_STUB IDX2DDebug_GetDC_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDX2DDebug_INTERFACE_DEFINED__ */


#ifndef __IDX2D_INTERFACE_DEFINED__
#define __IDX2D_INTERFACE_DEFINED__

/* interface IDX2D */
/* [object][unique][helpstring][uuid][local] */ 


EXTERN_C const IID IID_IDX2D;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("9EFD02A9-A996-11d1-81C9-0000F87557DB")
    IDX2D : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetTransformFactory( 
            IDXTransformFactory __RPC_FAR *pTransFact) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetTransformFactory( 
            IDXTransformFactory __RPC_FAR *__RPC_FAR *ppTransFact) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetSurface( 
            IUnknown __RPC_FAR *pSurface) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSurface( 
            REFIID riid,
            void __RPC_FAR *__RPC_FAR *ppSurface) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetClipRect( 
            RECT __RPC_FAR *pClipRect) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetClipRect( 
            RECT __RPC_FAR *pClipRect) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetWorldTransform( 
            const DX2DXFORM __RPC_FAR *pXform) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetWorldTransform( 
            DX2DXFORM __RPC_FAR *pXform) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetPen( 
            const DXPEN __RPC_FAR *pPen) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPen( 
            DXPEN __RPC_FAR *pPen) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetBrush( 
            const DXBRUSH __RPC_FAR *pBrush) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetBrush( 
            DXBRUSH __RPC_FAR *pBrush) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetBackgroundBrush( 
            const DXBRUSH __RPC_FAR *pBrush) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetBackgroundBrush( 
            DXBRUSH __RPC_FAR *pBrush) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetFont( 
            HFONT hFont) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFont( 
            HFONT __RPC_FAR *phFont) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Blt( 
            IUnknown __RPC_FAR *punkSrc,
            const RECT __RPC_FAR *pSrcRect,
            const POINT __RPC_FAR *pDest) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AAPolyDraw( 
            const DXFPOINT __RPC_FAR *pPos,
            const BYTE __RPC_FAR *pTypes,
            ULONG ulCount,
            ULONG SubSampRes,
            DWORD dwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AAText( 
            DXFPOINT Pos,
            LPWSTR pString,
            ULONG ulCount,
            DWORD dwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetRadialGradientBrush( 
            /* [size_is][in] */ double __RPC_FAR *rgdblOffsets,
            /* [size_is][in] */ double __RPC_FAR *rgdblColors,
            /* [in] */ ULONG ulCount,
            /* [in] */ double dblOpacity,
            /* [in] */ DX2DXFORM __RPC_FAR *pXform,
            /* [in] */ DWORD dwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetLinearGradientBrush( 
            /* [size_is][in] */ double __RPC_FAR *rgdblOffsets,
            /* [size_is][in] */ double __RPC_FAR *rgdblColors,
            /* [in] */ ULONG ulCount,
            /* [in] */ double dblOpacity,
            /* [in] */ DX2DXFORM __RPC_FAR *pXform,
            /* [in] */ DWORD dwFlags) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDX2DVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDX2D __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDX2D __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDX2D __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetTransformFactory )( 
            IDX2D __RPC_FAR * This,
            IDXTransformFactory __RPC_FAR *pTransFact);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTransformFactory )( 
            IDX2D __RPC_FAR * This,
            IDXTransformFactory __RPC_FAR *__RPC_FAR *ppTransFact);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetSurface )( 
            IDX2D __RPC_FAR * This,
            IUnknown __RPC_FAR *pSurface);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetSurface )( 
            IDX2D __RPC_FAR * This,
            REFIID riid,
            void __RPC_FAR *__RPC_FAR *ppSurface);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetClipRect )( 
            IDX2D __RPC_FAR * This,
            RECT __RPC_FAR *pClipRect);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetClipRect )( 
            IDX2D __RPC_FAR * This,
            RECT __RPC_FAR *pClipRect);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetWorldTransform )( 
            IDX2D __RPC_FAR * This,
            const DX2DXFORM __RPC_FAR *pXform);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetWorldTransform )( 
            IDX2D __RPC_FAR * This,
            DX2DXFORM __RPC_FAR *pXform);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetPen )( 
            IDX2D __RPC_FAR * This,
            const DXPEN __RPC_FAR *pPen);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetPen )( 
            IDX2D __RPC_FAR * This,
            DXPEN __RPC_FAR *pPen);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetBrush )( 
            IDX2D __RPC_FAR * This,
            const DXBRUSH __RPC_FAR *pBrush);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetBrush )( 
            IDX2D __RPC_FAR * This,
            DXBRUSH __RPC_FAR *pBrush);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetBackgroundBrush )( 
            IDX2D __RPC_FAR * This,
            const DXBRUSH __RPC_FAR *pBrush);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetBackgroundBrush )( 
            IDX2D __RPC_FAR * This,
            DXBRUSH __RPC_FAR *pBrush);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetFont )( 
            IDX2D __RPC_FAR * This,
            HFONT hFont);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetFont )( 
            IDX2D __RPC_FAR * This,
            HFONT __RPC_FAR *phFont);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Blt )( 
            IDX2D __RPC_FAR * This,
            IUnknown __RPC_FAR *punkSrc,
            const RECT __RPC_FAR *pSrcRect,
            const POINT __RPC_FAR *pDest);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AAPolyDraw )( 
            IDX2D __RPC_FAR * This,
            const DXFPOINT __RPC_FAR *pPos,
            const BYTE __RPC_FAR *pTypes,
            ULONG ulCount,
            ULONG SubSampRes,
            DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AAText )( 
            IDX2D __RPC_FAR * This,
            DXFPOINT Pos,
            LPWSTR pString,
            ULONG ulCount,
            DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetRadialGradientBrush )( 
            IDX2D __RPC_FAR * This,
            /* [size_is][in] */ double __RPC_FAR *rgdblOffsets,
            /* [size_is][in] */ double __RPC_FAR *rgdblColors,
            /* [in] */ ULONG ulCount,
            /* [in] */ double dblOpacity,
            /* [in] */ DX2DXFORM __RPC_FAR *pXform,
            /* [in] */ DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetLinearGradientBrush )( 
            IDX2D __RPC_FAR * This,
            /* [size_is][in] */ double __RPC_FAR *rgdblOffsets,
            /* [size_is][in] */ double __RPC_FAR *rgdblColors,
            /* [in] */ ULONG ulCount,
            /* [in] */ double dblOpacity,
            /* [in] */ DX2DXFORM __RPC_FAR *pXform,
            /* [in] */ DWORD dwFlags);
        
        END_INTERFACE
    } IDX2DVtbl;

    interface IDX2D
    {
        CONST_VTBL struct IDX2DVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDX2D_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDX2D_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDX2D_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDX2D_SetTransformFactory(This,pTransFact)	\
    (This)->lpVtbl -> SetTransformFactory(This,pTransFact)

#define IDX2D_GetTransformFactory(This,ppTransFact)	\
    (This)->lpVtbl -> GetTransformFactory(This,ppTransFact)

#define IDX2D_SetSurface(This,pSurface)	\
    (This)->lpVtbl -> SetSurface(This,pSurface)

#define IDX2D_GetSurface(This,riid,ppSurface)	\
    (This)->lpVtbl -> GetSurface(This,riid,ppSurface)

#define IDX2D_SetClipRect(This,pClipRect)	\
    (This)->lpVtbl -> SetClipRect(This,pClipRect)

#define IDX2D_GetClipRect(This,pClipRect)	\
    (This)->lpVtbl -> GetClipRect(This,pClipRect)

#define IDX2D_SetWorldTransform(This,pXform)	\
    (This)->lpVtbl -> SetWorldTransform(This,pXform)

#define IDX2D_GetWorldTransform(This,pXform)	\
    (This)->lpVtbl -> GetWorldTransform(This,pXform)

#define IDX2D_SetPen(This,pPen)	\
    (This)->lpVtbl -> SetPen(This,pPen)

#define IDX2D_GetPen(This,pPen)	\
    (This)->lpVtbl -> GetPen(This,pPen)

#define IDX2D_SetBrush(This,pBrush)	\
    (This)->lpVtbl -> SetBrush(This,pBrush)

#define IDX2D_GetBrush(This,pBrush)	\
    (This)->lpVtbl -> GetBrush(This,pBrush)

#define IDX2D_SetBackgroundBrush(This,pBrush)	\
    (This)->lpVtbl -> SetBackgroundBrush(This,pBrush)

#define IDX2D_GetBackgroundBrush(This,pBrush)	\
    (This)->lpVtbl -> GetBackgroundBrush(This,pBrush)

#define IDX2D_SetFont(This,hFont)	\
    (This)->lpVtbl -> SetFont(This,hFont)

#define IDX2D_GetFont(This,phFont)	\
    (This)->lpVtbl -> GetFont(This,phFont)

#define IDX2D_Blt(This,punkSrc,pSrcRect,pDest)	\
    (This)->lpVtbl -> Blt(This,punkSrc,pSrcRect,pDest)

#define IDX2D_AAPolyDraw(This,pPos,pTypes,ulCount,SubSampRes,dwFlags)	\
    (This)->lpVtbl -> AAPolyDraw(This,pPos,pTypes,ulCount,SubSampRes,dwFlags)

#define IDX2D_AAText(This,Pos,pString,ulCount,dwFlags)	\
    (This)->lpVtbl -> AAText(This,Pos,pString,ulCount,dwFlags)

#define IDX2D_SetRadialGradientBrush(This,rgdblOffsets,rgdblColors,ulCount,dblOpacity,pXform,dwFlags)	\
    (This)->lpVtbl -> SetRadialGradientBrush(This,rgdblOffsets,rgdblColors,ulCount,dblOpacity,pXform,dwFlags)

#define IDX2D_SetLinearGradientBrush(This,rgdblOffsets,rgdblColors,ulCount,dblOpacity,pXform,dwFlags)	\
    (This)->lpVtbl -> SetLinearGradientBrush(This,rgdblOffsets,rgdblColors,ulCount,dblOpacity,pXform,dwFlags)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDX2D_SetTransformFactory_Proxy( 
    IDX2D __RPC_FAR * This,
    IDXTransformFactory __RPC_FAR *pTransFact);


void __RPC_STUB IDX2D_SetTransformFactory_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDX2D_GetTransformFactory_Proxy( 
    IDX2D __RPC_FAR * This,
    IDXTransformFactory __RPC_FAR *__RPC_FAR *ppTransFact);


void __RPC_STUB IDX2D_GetTransformFactory_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDX2D_SetSurface_Proxy( 
    IDX2D __RPC_FAR * This,
    IUnknown __RPC_FAR *pSurface);


void __RPC_STUB IDX2D_SetSurface_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDX2D_GetSurface_Proxy( 
    IDX2D __RPC_FAR * This,
    REFIID riid,
    void __RPC_FAR *__RPC_FAR *ppSurface);


void __RPC_STUB IDX2D_GetSurface_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDX2D_SetClipRect_Proxy( 
    IDX2D __RPC_FAR * This,
    RECT __RPC_FAR *pClipRect);


void __RPC_STUB IDX2D_SetClipRect_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDX2D_GetClipRect_Proxy( 
    IDX2D __RPC_FAR * This,
    RECT __RPC_FAR *pClipRect);


void __RPC_STUB IDX2D_GetClipRect_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDX2D_SetWorldTransform_Proxy( 
    IDX2D __RPC_FAR * This,
    const DX2DXFORM __RPC_FAR *pXform);


void __RPC_STUB IDX2D_SetWorldTransform_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDX2D_GetWorldTransform_Proxy( 
    IDX2D __RPC_FAR * This,
    DX2DXFORM __RPC_FAR *pXform);


void __RPC_STUB IDX2D_GetWorldTransform_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDX2D_SetPen_Proxy( 
    IDX2D __RPC_FAR * This,
    const DXPEN __RPC_FAR *pPen);


void __RPC_STUB IDX2D_SetPen_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDX2D_GetPen_Proxy( 
    IDX2D __RPC_FAR * This,
    DXPEN __RPC_FAR *pPen);


void __RPC_STUB IDX2D_GetPen_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDX2D_SetBrush_Proxy( 
    IDX2D __RPC_FAR * This,
    const DXBRUSH __RPC_FAR *pBrush);


void __RPC_STUB IDX2D_SetBrush_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDX2D_GetBrush_Proxy( 
    IDX2D __RPC_FAR * This,
    DXBRUSH __RPC_FAR *pBrush);


void __RPC_STUB IDX2D_GetBrush_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDX2D_SetBackgroundBrush_Proxy( 
    IDX2D __RPC_FAR * This,
    const DXBRUSH __RPC_FAR *pBrush);


void __RPC_STUB IDX2D_SetBackgroundBrush_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDX2D_GetBackgroundBrush_Proxy( 
    IDX2D __RPC_FAR * This,
    DXBRUSH __RPC_FAR *pBrush);


void __RPC_STUB IDX2D_GetBackgroundBrush_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDX2D_SetFont_Proxy( 
    IDX2D __RPC_FAR * This,
    HFONT hFont);


void __RPC_STUB IDX2D_SetFont_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDX2D_GetFont_Proxy( 
    IDX2D __RPC_FAR * This,
    HFONT __RPC_FAR *phFont);


void __RPC_STUB IDX2D_GetFont_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDX2D_Blt_Proxy( 
    IDX2D __RPC_FAR * This,
    IUnknown __RPC_FAR *punkSrc,
    const RECT __RPC_FAR *pSrcRect,
    const POINT __RPC_FAR *pDest);


void __RPC_STUB IDX2D_Blt_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDX2D_AAPolyDraw_Proxy( 
    IDX2D __RPC_FAR * This,
    const DXFPOINT __RPC_FAR *pPos,
    const BYTE __RPC_FAR *pTypes,
    ULONG ulCount,
    ULONG SubSampRes,
    DWORD dwFlags);


void __RPC_STUB IDX2D_AAPolyDraw_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDX2D_AAText_Proxy( 
    IDX2D __RPC_FAR * This,
    DXFPOINT Pos,
    LPWSTR pString,
    ULONG ulCount,
    DWORD dwFlags);


void __RPC_STUB IDX2D_AAText_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDX2D_SetRadialGradientBrush_Proxy( 
    IDX2D __RPC_FAR * This,
    /* [size_is][in] */ double __RPC_FAR *rgdblOffsets,
    /* [size_is][in] */ double __RPC_FAR *rgdblColors,
    /* [in] */ ULONG ulCount,
    /* [in] */ double dblOpacity,
    /* [in] */ DX2DXFORM __RPC_FAR *pXform,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB IDX2D_SetRadialGradientBrush_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDX2D_SetLinearGradientBrush_Proxy( 
    IDX2D __RPC_FAR * This,
    /* [size_is][in] */ double __RPC_FAR *rgdblOffsets,
    /* [size_is][in] */ double __RPC_FAR *rgdblColors,
    /* [in] */ ULONG ulCount,
    /* [in] */ double dblOpacity,
    /* [in] */ DX2DXFORM __RPC_FAR *pXform,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB IDX2D_SetLinearGradientBrush_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDX2D_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_dxtrans_0275 */
/* [local] */ 

typedef struct DXRAWSURFACEINFO
    {
    BYTE __RPC_FAR *pFirstByte;
    long lPitch;
    ULONG Width;
    ULONG Height;
    const GUID __RPC_FAR *pPixelFormat;
    HDC hdc;
    DWORD dwColorKey;
    DXBASESAMPLE __RPC_FAR *pPalette;
    }	DXRAWSURFACEINFO;



extern RPC_IF_HANDLE __MIDL_itf_dxtrans_0275_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_dxtrans_0275_v0_0_s_ifspec;

#ifndef __IDXRawSurface_INTERFACE_DEFINED__
#define __IDXRawSurface_INTERFACE_DEFINED__

/* interface IDXRawSurface */
/* [object][local][unique][helpstring][uuid] */ 


EXTERN_C const IID IID_IDXRawSurface;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("09756C8A-D96A-11d1-9062-00C04FD9189D")
    IDXRawSurface : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetSurfaceInfo( 
            DXRAWSURFACEINFO __RPC_FAR *pSurfaceInfo) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDXRawSurfaceVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDXRawSurface __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDXRawSurface __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDXRawSurface __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetSurfaceInfo )( 
            IDXRawSurface __RPC_FAR * This,
            DXRAWSURFACEINFO __RPC_FAR *pSurfaceInfo);
        
        END_INTERFACE
    } IDXRawSurfaceVtbl;

    interface IDXRawSurface
    {
        CONST_VTBL struct IDXRawSurfaceVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDXRawSurface_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDXRawSurface_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDXRawSurface_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDXRawSurface_GetSurfaceInfo(This,pSurfaceInfo)	\
    (This)->lpVtbl -> GetSurfaceInfo(This,pSurfaceInfo)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDXRawSurface_GetSurfaceInfo_Proxy( 
    IDXRawSurface __RPC_FAR * This,
    DXRAWSURFACEINFO __RPC_FAR *pSurfaceInfo);


void __RPC_STUB IDXRawSurface_GetSurfaceInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDXRawSurface_INTERFACE_DEFINED__ */



#ifndef __DXTRANSLib_LIBRARY_DEFINED__
#define __DXTRANSLib_LIBRARY_DEFINED__

/* library DXTRANSLib */
/* [helpstring][version][uuid] */ 


EXTERN_C const IID LIBID_DXTRANSLib;

EXTERN_C const CLSID CLSID_DXTransformFactory;

#ifdef __cplusplus

class DECLSPEC_UUID("D1FE6762-FC48-11D0-883A-3C8B00C10000")
DXTransformFactory;
#endif

EXTERN_C const CLSID CLSID_DXTaskManager;

#ifdef __cplusplus

class DECLSPEC_UUID("4CB26C03-FF93-11d0-817E-0000F87557DB")
DXTaskManager;
#endif

EXTERN_C const CLSID CLSID_DXTScale;

#ifdef __cplusplus

class DECLSPEC_UUID("555278E2-05DB-11D1-883A-3C8B00C10000")
DXTScale;
#endif

EXTERN_C const CLSID CLSID_DXTLabel;

#ifdef __cplusplus

class DECLSPEC_UUID("54702535-2606-11D1-999C-0000F8756A10")
DXTLabel;
#endif

EXTERN_C const CLSID CLSID_DX2D;

#ifdef __cplusplus

class DECLSPEC_UUID("473AA80B-4577-11D1-81A8-0000F87557DB")
DX2D;
#endif

EXTERN_C const CLSID CLSID_DXSurface;

#ifdef __cplusplus

class DECLSPEC_UUID("0E890F83-5F79-11D1-9043-00C04FD9189D")
DXSurface;
#endif

EXTERN_C const CLSID CLSID_DXSurfaceModifier;

#ifdef __cplusplus

class DECLSPEC_UUID("3E669F1D-9C23-11d1-9053-00C04FD9189D")
DXSurfaceModifier;
#endif

EXTERN_C const CLSID CLSID_DXRasterizer;

#ifdef __cplusplus

class DECLSPEC_UUID("8652CE55-9E80-11D1-9053-00C04FD9189D")
DXRasterizer;
#endif

EXTERN_C const CLSID CLSID_DXGradient;

#ifdef __cplusplus

class DECLSPEC_UUID("C6365470-F667-11d1-9067-00C04FD9189D")
DXGradient;
#endif
#endif /* __DXTRANSLib_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  HFONT_UserSize(     unsigned long __RPC_FAR *, unsigned long            , HFONT __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  HFONT_UserMarshal(  unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, HFONT __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  HFONT_UserUnmarshal(unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, HFONT __RPC_FAR * ); 
void                      __RPC_USER  HFONT_UserFree(     unsigned long __RPC_FAR *, HFONT __RPC_FAR * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\extinc\dxtransguid.h ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */

/* link this file in with the server and any clients */


 /* File created by MIDL compiler version 5.03.0285 */
/* Compiler settings for dxtrans.idl:
    Oicf (OptLev=i2), W0, Zp8, env=Win32 (32b run), ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if !defined(_M_IA64) && !defined(_M_AXP64)

#ifdef __cplusplus
extern "C"{
#endif 


#include <rpc.h>
#include <rpcndr.h>

#ifdef _MIDL_USE_GUIDDEF_

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)

#else // !_MIDL_USE_GUIDDEF_

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}

#endif !_MIDL_USE_GUIDDEF_

MIDL_DEFINE_GUID(IID, IID_IDXBaseObject,0x17B59B2B,0x9CC8,0x11d1,0x90,0x53,0x00,0xC0,0x4F,0xD9,0x18,0x9D);


MIDL_DEFINE_GUID(IID, IID_IDXTransformFactory,0x6A950B2B,0xA971,0x11d1,0x81,0xC8,0x00,0x00,0xF8,0x75,0x57,0xDB);


MIDL_DEFINE_GUID(IID, IID_IDXTransform,0x30A5FB78,0xE11F,0x11d1,0x90,0x64,0x00,0xC0,0x4F,0xD9,0x18,0x9D);


MIDL_DEFINE_GUID(IID, IID_IDXSurfacePick,0x30A5FB79,0xE11F,0x11d1,0x90,0x64,0x00,0xC0,0x4F,0xD9,0x18,0x9D);


MIDL_DEFINE_GUID(IID, IID_IDXTBindHost,0xD26BCE55,0xE9DC,0x11d1,0x90,0x66,0x00,0xC0,0x4F,0xD9,0x18,0x9D);


MIDL_DEFINE_GUID(IID, IID_IDXTaskManager,0x254DBBC1,0xF922,0x11d0,0x88,0x3A,0x3C,0x8B,0x00,0xC1,0x00,0x00);


MIDL_DEFINE_GUID(IID, IID_IDXSurfaceFactory,0x144946F5,0xC4D4,0x11d1,0x81,0xD1,0x00,0x00,0xF8,0x75,0x57,0xDB);


MIDL_DEFINE_GUID(IID, IID_IDXSurfaceModifier,0x9EA3B637,0xC37D,0x11d1,0x90,0x5E,0x00,0xC0,0x4F,0xD9,0x18,0x9D);


MIDL_DEFINE_GUID(IID, IID_IDXSurface,0xB39FD73F,0xE139,0x11d1,0x90,0x65,0x00,0xC0,0x4F,0xD9,0x18,0x9D);


MIDL_DEFINE_GUID(IID, IID_IDXSurfaceInit,0x9EA3B639,0xC37D,0x11d1,0x90,0x5E,0x00,0xC0,0x4F,0xD9,0x18,0x9D);


MIDL_DEFINE_GUID(IID, IID_IDXARGBSurfaceInit,0x9EA3B63A,0xC37D,0x11d1,0x90,0x5E,0x00,0xC0,0x4F,0xD9,0x18,0x9D);


MIDL_DEFINE_GUID(IID, IID_IDXARGBReadPtr,0xEAAAC2D6,0xC290,0x11d1,0x90,0x5D,0x00,0xC0,0x4F,0xD9,0x18,0x9D);


MIDL_DEFINE_GUID(IID, IID_IDXARGBReadWritePtr,0xEAAAC2D7,0xC290,0x11d1,0x90,0x5D,0x00,0xC0,0x4F,0xD9,0x18,0x9D);


MIDL_DEFINE_GUID(IID, IID_IDXDCLock,0x0F619456,0xCF39,0x11d1,0x90,0x5E,0x00,0xC0,0x4F,0xD9,0x18,0x9D);


MIDL_DEFINE_GUID(IID, IID_IDXTScaleOutput,0xB2024B50,0xEE77,0x11d1,0x90,0x66,0x00,0xC0,0x4F,0xD9,0x18,0x9D);


MIDL_DEFINE_GUID(IID, IID_IDXGradient,0xB2024B51,0xEE77,0x11d1,0x90,0x66,0x00,0xC0,0x4F,0xD9,0x18,0x9D);


MIDL_DEFINE_GUID(IID, IID_IDXGradient2,0xd0ef2a80,0x61dc,0x11d2,0xb2,0xeb,0x00,0xa0,0xc9,0x36,0xb2,0x12);


MIDL_DEFINE_GUID(IID, IID_IDXTScale,0xB39FD742,0xE139,0x11d1,0x90,0x65,0x00,0xC0,0x4F,0xD9,0x18,0x9D);


MIDL_DEFINE_GUID(IID, IID_IDXTLabel,0xC0C17F0E,0xAE41,0x11d1,0x9A,0x3B,0x00,0x00,0xF8,0x75,0x6A,0x10);


MIDL_DEFINE_GUID(IID, IID_IDXRasterizer,0x9EA3B635,0xC37D,0x11d1,0x90,0x5E,0x00,0xC0,0x4F,0xD9,0x18,0x9D);


MIDL_DEFINE_GUID(IID, IID_IDXEffect,0xE31FB81B,0x1335,0x11d1,0x81,0x89,0x00,0x00,0xF8,0x75,0x57,0xDB);


MIDL_DEFINE_GUID(IID, IID_IDXLookupTable,0x01BAFC7F,0x9E63,0x11d1,0x90,0x53,0x00,0xC0,0x4F,0xD9,0x18,0x9D);


MIDL_DEFINE_GUID(IID, IID_IDX2DDebug,0x03BB2457,0xA279,0x11d1,0x81,0xC6,0x00,0x00,0xF8,0x75,0x57,0xDB);


MIDL_DEFINE_GUID(IID, IID_IDX2D,0x9EFD02A9,0xA996,0x11d1,0x81,0xC9,0x00,0x00,0xF8,0x75,0x57,0xDB);


MIDL_DEFINE_GUID(IID, IID_IDXRawSurface,0x09756C8A,0xD96A,0x11d1,0x90,0x62,0x00,0xC0,0x4F,0xD9,0x18,0x9D);


MIDL_DEFINE_GUID(IID, LIBID_DXTRANSLib,0x54314D1D,0x35FE,0x11d1,0x81,0xA1,0x00,0x00,0xF8,0x75,0x57,0xDB);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTransformFactory,0xD1FE6762,0xFC48,0x11D0,0x88,0x3A,0x3C,0x8B,0x00,0xC1,0x00,0x00);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTaskManager,0x4CB26C03,0xFF93,0x11d0,0x81,0x7E,0x00,0x00,0xF8,0x75,0x57,0xDB);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTScale,0x555278E2,0x05DB,0x11D1,0x88,0x3A,0x3C,0x8B,0x00,0xC1,0x00,0x00);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTLabel,0x54702535,0x2606,0x11D1,0x99,0x9C,0x00,0x00,0xF8,0x75,0x6A,0x10);


MIDL_DEFINE_GUID(CLSID, CLSID_DX2D,0x473AA80B,0x4577,0x11D1,0x81,0xA8,0x00,0x00,0xF8,0x75,0x57,0xDB);


MIDL_DEFINE_GUID(CLSID, CLSID_DXSurface,0x0E890F83,0x5F79,0x11D1,0x90,0x43,0x00,0xC0,0x4F,0xD9,0x18,0x9D);


MIDL_DEFINE_GUID(CLSID, CLSID_DXSurfaceModifier,0x3E669F1D,0x9C23,0x11d1,0x90,0x53,0x00,0xC0,0x4F,0xD9,0x18,0x9D);


MIDL_DEFINE_GUID(CLSID, CLSID_DXRasterizer,0x8652CE55,0x9E80,0x11D1,0x90,0x53,0x00,0xC0,0x4F,0xD9,0x18,0x9D);


MIDL_DEFINE_GUID(CLSID, CLSID_DXGradient,0xC6365470,0xF667,0x11d1,0x90,0x67,0x00,0xC0,0x4F,0xD9,0x18,0x9D);

#undef MIDL_DEFINE_GUID

#ifdef __cplusplus
}
#endif



#endif /* !defined(_M_IA64) && !defined(_M_AXP64)*/


#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */

/* link this file in with the server and any clients */


 /* File created by MIDL compiler version 5.03.0285 */
/* Compiler settings for dxtrans.idl:
    Oicf (OptLev=i2), W0, Zp8, env=Win64 (32b run,appending), ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if defined(_M_IA64) || defined(_M_AXP64)

#ifdef __cplusplus
extern "C"{
#endif 


#include <rpc.h>
#include <rpcndr.h>

#ifdef _MIDL_USE_GUIDDEF_

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)

#else // !_MIDL_USE_GUIDDEF_

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}

#endif !_MIDL_USE_GUIDDEF_

MIDL_DEFINE_GUID(IID, IID_IDXBaseObject,0x17B59B2B,0x9CC8,0x11d1,0x90,0x53,0x00,0xC0,0x4F,0xD9,0x18,0x9D);


MIDL_DEFINE_GUID(IID, IID_IDXTransformFactory,0x6A950B2B,0xA971,0x11d1,0x81,0xC8,0x00,0x00,0xF8,0x75,0x57,0xDB);


MIDL_DEFINE_GUID(IID, IID_IDXTransform,0x30A5FB78,0xE11F,0x11d1,0x90,0x64,0x00,0xC0,0x4F,0xD9,0x18,0x9D);


MIDL_DEFINE_GUID(IID, IID_IDXSurfacePick,0x30A5FB79,0xE11F,0x11d1,0x90,0x64,0x00,0xC0,0x4F,0xD9,0x18,0x9D);


MIDL_DEFINE_GUID(IID, IID_IDXTBindHost,0xD26BCE55,0xE9DC,0x11d1,0x90,0x66,0x00,0xC0,0x4F,0xD9,0x18,0x9D);


MIDL_DEFINE_GUID(IID, IID_IDXTaskManager,0x254DBBC1,0xF922,0x11d0,0x88,0x3A,0x3C,0x8B,0x00,0xC1,0x00,0x00);


MIDL_DEFINE_GUID(IID, IID_IDXSurfaceFactory,0x144946F5,0xC4D4,0x11d1,0x81,0xD1,0x00,0x00,0xF8,0x75,0x57,0xDB);


MIDL_DEFINE_GUID(IID, IID_IDXSurfaceModifier,0x9EA3B637,0xC37D,0x11d1,0x90,0x5E,0x00,0xC0,0x4F,0xD9,0x18,0x9D);


MIDL_DEFINE_GUID(IID, IID_IDXSurface,0xB39FD73F,0xE139,0x11d1,0x90,0x65,0x00,0xC0,0x4F,0xD9,0x18,0x9D);


MIDL_DEFINE_GUID(IID, IID_IDXSurfaceInit,0x9EA3B639,0xC37D,0x11d1,0x90,0x5E,0x00,0xC0,0x4F,0xD9,0x18,0x9D);


MIDL_DEFINE_GUID(IID, IID_IDXARGBSurfaceInit,0x9EA3B63A,0xC37D,0x11d1,0x90,0x5E,0x00,0xC0,0x4F,0xD9,0x18,0x9D);


MIDL_DEFINE_GUID(IID, IID_IDXARGBReadPtr,0xEAAAC2D6,0xC290,0x11d1,0x90,0x5D,0x00,0xC0,0x4F,0xD9,0x18,0x9D);


MIDL_DEFINE_GUID(IID, IID_IDXARGBReadWritePtr,0xEAAAC2D7,0xC290,0x11d1,0x90,0x5D,0x00,0xC0,0x4F,0xD9,0x18,0x9D);


MIDL_DEFINE_GUID(IID, IID_IDXDCLock,0x0F619456,0xCF39,0x11d1,0x90,0x5E,0x00,0xC0,0x4F,0xD9,0x18,0x9D);


MIDL_DEFINE_GUID(IID, IID_IDXTScaleOutput,0xB2024B50,0xEE77,0x11d1,0x90,0x66,0x00,0xC0,0x4F,0xD9,0x18,0x9D);


MIDL_DEFINE_GUID(IID, IID_IDXGradient,0xB2024B51,0xEE77,0x11d1,0x90,0x66,0x00,0xC0,0x4F,0xD9,0x18,0x9D);


MIDL_DEFINE_GUID(IID, IID_IDXGradient2,0xd0ef2a80,0x61dc,0x11d2,0xb2,0xeb,0x00,0xa0,0xc9,0x36,0xb2,0x12);


MIDL_DEFINE_GUID(IID, IID_IDXTScale,0xB39FD742,0xE139,0x11d1,0x90,0x65,0x00,0xC0,0x4F,0xD9,0x18,0x9D);


MIDL_DEFINE_GUID(IID, IID_IDXTLabel,0xC0C17F0E,0xAE41,0x11d1,0x9A,0x3B,0x00,0x00,0xF8,0x75,0x6A,0x10);


MIDL_DEFINE_GUID(IID, IID_IDXRasterizer,0x9EA3B635,0xC37D,0x11d1,0x90,0x5E,0x00,0xC0,0x4F,0xD9,0x18,0x9D);


MIDL_DEFINE_GUID(IID, IID_IDXEffect,0xE31FB81B,0x1335,0x11d1,0x81,0x89,0x00,0x00,0xF8,0x75,0x57,0xDB);


MIDL_DEFINE_GUID(IID, IID_IDXLookupTable,0x01BAFC7F,0x9E63,0x11d1,0x90,0x53,0x00,0xC0,0x4F,0xD9,0x18,0x9D);


MIDL_DEFINE_GUID(IID, IID_IDX2DDebug,0x03BB2457,0xA279,0x11d1,0x81,0xC6,0x00,0x00,0xF8,0x75,0x57,0xDB);


MIDL_DEFINE_GUID(IID, IID_IDX2D,0x9EFD02A9,0xA996,0x11d1,0x81,0xC9,0x00,0x00,0xF8,0x75,0x57,0xDB);


MIDL_DEFINE_GUID(IID, IID_IDXRawSurface,0x09756C8A,0xD96A,0x11d1,0x90,0x62,0x00,0xC0,0x4F,0xD9,0x18,0x9D);


MIDL_DEFINE_GUID(IID, LIBID_DXTRANSLib,0x54314D1D,0x35FE,0x11d1,0x81,0xA1,0x00,0x00,0xF8,0x75,0x57,0xDB);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTransformFactory,0xD1FE6762,0xFC48,0x11D0,0x88,0x3A,0x3C,0x8B,0x00,0xC1,0x00,0x00);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTaskManager,0x4CB26C03,0xFF93,0x11d0,0x81,0x7E,0x00,0x00,0xF8,0x75,0x57,0xDB);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTScale,0x555278E2,0x05DB,0x11D1,0x88,0x3A,0x3C,0x8B,0x00,0xC1,0x00,0x00);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTLabel,0x54702535,0x2606,0x11D1,0x99,0x9C,0x00,0x00,0xF8,0x75,0x6A,0x10);


MIDL_DEFINE_GUID(CLSID, CLSID_DX2D,0x473AA80B,0x4577,0x11D1,0x81,0xA8,0x00,0x00,0xF8,0x75,0x57,0xDB);


MIDL_DEFINE_GUID(CLSID, CLSID_DXSurface,0x0E890F83,0x5F79,0x11D1,0x90,0x43,0x00,0xC0,0x4F,0xD9,0x18,0x9D);


MIDL_DEFINE_GUID(CLSID, CLSID_DXSurfaceModifier,0x3E669F1D,0x9C23,0x11d1,0x90,0x53,0x00,0xC0,0x4F,0xD9,0x18,0x9D);


MIDL_DEFINE_GUID(CLSID, CLSID_DXRasterizer,0x8652CE55,0x9E80,0x11D1,0x90,0x53,0x00,0xC0,0x4F,0xD9,0x18,0x9D);


MIDL_DEFINE_GUID(CLSID, CLSID_DXGradient,0xC6365470,0xF667,0x11d1,0x90,0x67,0x00,0xC0,0x4F,0xD9,0x18,0x9D);

#undef MIDL_DEFINE_GUID

#ifdef __cplusplus
}
#endif



#endif /* defined(_M_IA64) || defined(_M_AXP64)*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\extinc\dxtmsftguid.h ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */

/* link this file in with the server and any clients */


 /* File created by MIDL compiler version 5.03.0285 */
/* Compiler settings for dxtmsft.idl:
    Oicf (OptLev=i2), W0, Zp8, env=Win32 (32b run), ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if !defined(_M_IA64) && !defined(_M_AXP64)

#ifdef __cplusplus
extern "C"{
#endif 


#include <rpc.h>
#include <rpcndr.h>

#ifdef _MIDL_USE_GUIDDEF_

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)

#else // !_MIDL_USE_GUIDDEF_

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}

#endif !_MIDL_USE_GUIDDEF_

MIDL_DEFINE_GUID(IID, IID_IDXLUTBuilder,0xF4370FC1,0xCADB,0x11D0,0xB5,0x2C,0x00,0xA0,0xC9,0x05,0x43,0x73);


MIDL_DEFINE_GUID(IID, IID_IDXDLUTBuilder,0x73068231,0x35EE,0x11d1,0x81,0xA1,0x00,0x00,0xF8,0x75,0x57,0xDB);


MIDL_DEFINE_GUID(IID, IID_IDXTGradientD,0x623E2881,0xFC0E,0x11d1,0x9A,0x77,0x00,0x00,0xF8,0x75,0x6A,0x10);


MIDL_DEFINE_GUID(IID, IID_IDXTConvolution,0x7BA7F8AF,0xE5EA,0x11d1,0x81,0xDD,0x00,0x00,0xF8,0x75,0x57,0xDB);


MIDL_DEFINE_GUID(IID, IID_IDXMapper,0x555278E5,0x05DB,0x11D1,0x88,0x3A,0x3C,0x8B,0x00,0xC1,0x00,0x00);


MIDL_DEFINE_GUID(IID, IID_IDXDMapper,0x7FD9088B,0x35ED,0x11d1,0x81,0xA1,0x00,0x00,0xF8,0x75,0x57,0xDB);


MIDL_DEFINE_GUID(IID, IID_IDXTComposite,0x9A43A843,0x0831,0x11D1,0x81,0x7F,0x00,0x00,0xF8,0x75,0x57,0xDB);


MIDL_DEFINE_GUID(IID, IID_IDXTWipe,0xAF279B2F,0x86EB,0x11D1,0x81,0xBF,0x00,0x00,0xF8,0x75,0x57,0xDB);


MIDL_DEFINE_GUID(IID, IID_ICrBlur,0x9F7C7827,0xE87A,0x11d1,0x81,0xE0,0x00,0x00,0xF8,0x75,0x57,0xDB);


MIDL_DEFINE_GUID(IID, IID_ICrEngrave,0xE4ACFB7F,0x053E,0x11d2,0x81,0xEA,0x00,0x00,0xF8,0x75,0x57,0xDB);


MIDL_DEFINE_GUID(IID, IID_ICrEmboss,0xE4ACFB80,0x053E,0x11d2,0x81,0xEA,0x00,0x00,0xF8,0x75,0x57,0xDB);


MIDL_DEFINE_GUID(IID, IID_IDXTFade,0x16B280C4,0xEE70,0x11D1,0x90,0x66,0x00,0xC0,0x4F,0xD9,0x18,0x9D);


MIDL_DEFINE_GUID(IID, IID_IDXBasicImage,0x16B280C7,0xEE70,0x11D1,0x90,0x66,0x00,0xC0,0x4F,0xD9,0x18,0x9D);


MIDL_DEFINE_GUID(IID, IID_IDXPixelate,0xD33E180F,0xFBE9,0x11d1,0x90,0x6A,0x00,0xC0,0x4F,0xD9,0x18,0x9D);


MIDL_DEFINE_GUID(IID, IID_ICrIris,0x3F69F350,0x0379,0x11D2,0xA4,0x84,0x00,0xC0,0x4F,0x8E,0xFB,0x69);


MIDL_DEFINE_GUID(IID, IID_ICrSlide,0x810E402E,0x056B,0x11D2,0xA4,0x84,0x00,0xC0,0x4F,0x8E,0xFB,0x69);


MIDL_DEFINE_GUID(IID, IID_ICrRadialWipe,0x424B71AE,0x0695,0x11D2,0xA4,0x84,0x00,0xC0,0x4F,0x8E,0xFB,0x69);


MIDL_DEFINE_GUID(IID, IID_ICrBarn,0x276A2EE0,0x0B5D,0x11d2,0xA4,0x84,0x00,0xC0,0x4F,0x8E,0xFB,0x69);


MIDL_DEFINE_GUID(IID, IID_ICrBlinds,0x5AF5C340,0x0BA9,0x11d2,0xA4,0x84,0x00,0xC0,0x4F,0x8E,0xFB,0x69);


MIDL_DEFINE_GUID(IID, IID_ICrInset,0x05C5EE20,0x0BA6,0x11d2,0xA4,0x84,0x00,0xC0,0x4F,0x8E,0xFB,0x69);


MIDL_DEFINE_GUID(IID, IID_ICrStretch,0x6684AF00,0x0A87,0x11d2,0xA4,0x84,0x00,0xC0,0x4F,0x8E,0xFB,0x69);


MIDL_DEFINE_GUID(IID, IID_ICrSpiral,0x0DE527A0,0x0C7E,0x11d2,0xA4,0x84,0x00,0xC0,0x4F,0x8E,0xFB,0x69);


MIDL_DEFINE_GUID(IID, IID_ICrZigzag,0x4E5A64A0,0x0C8B,0x11d2,0xA4,0x84,0x00,0xC0,0x4F,0x8E,0xFB,0x69);


MIDL_DEFINE_GUID(IID, IID_ICrWheel,0x3943DE80,0x1464,0x11d2,0xA4,0x84,0x00,0xC0,0x4F,0x8E,0xFB,0x69);


MIDL_DEFINE_GUID(IID, IID_IDXTChroma,0x1D4637E2,0x383C,0x11d2,0x95,0x2A,0x00,0xC0,0x4F,0xA3,0x4F,0x05);


MIDL_DEFINE_GUID(IID, IID_IDXTDropShadow,0x1D4637E3,0x383C,0x11d2,0x95,0x2A,0x00,0xC0,0x4F,0xA3,0x4F,0x05);


MIDL_DEFINE_GUID(IID, IID_IDXTMetaRoll,0x9C61F46D,0x0530,0x11D2,0x8F,0x98,0x00,0xC0,0x4F,0xB9,0x2E,0xB7);


MIDL_DEFINE_GUID(IID, IID_IDXTMetaRipple,0xAA0D4D02,0x06A3,0x11D2,0x8F,0x98,0x00,0xC0,0x4F,0xB9,0x2E,0xB7);


MIDL_DEFINE_GUID(IID, IID_IDXTMetaPageTurn,0xAA0D4D07,0x06A3,0x11D2,0x8F,0x98,0x00,0xC0,0x4F,0xB9,0x2E,0xB7);


MIDL_DEFINE_GUID(IID, IID_IDXTMetaLiquid,0xAA0D4D09,0x06A3,0x11D2,0x8F,0x98,0x00,0xC0,0x4F,0xB9,0x2E,0xB7);


MIDL_DEFINE_GUID(IID, IID_IDXTMetaCenterPeel,0xAA0D4D0B,0x06A3,0x11D2,0x8F,0x98,0x00,0xC0,0x4F,0xB9,0x2E,0xB7);


MIDL_DEFINE_GUID(IID, IID_IDXTMetaPeelSmall,0xAA0D4D0D,0x06A3,0x11D2,0x8F,0x98,0x00,0xC0,0x4F,0xB9,0x2E,0xB7);


MIDL_DEFINE_GUID(IID, IID_IDXTMetaPeelPiece,0xAA0D4D0F,0x06A3,0x11D2,0x8F,0x98,0x00,0xC0,0x4F,0xB9,0x2E,0xB7);


MIDL_DEFINE_GUID(IID, IID_IDXTMetaPeelSplit,0xAA0D4D11,0x06A3,0x11D2,0x8F,0x98,0x00,0xC0,0x4F,0xB9,0x2E,0xB7);


MIDL_DEFINE_GUID(IID, IID_IDXTMetaWater,0x107045C4,0x06E0,0x11D2,0x8D,0x6D,0x00,0xC0,0x4F,0x8E,0xF8,0xE0);


MIDL_DEFINE_GUID(IID, IID_IDXTMetaLightWipe,0x107045C7,0x06E0,0x11D2,0x8D,0x6D,0x00,0xC0,0x4F,0x8E,0xF8,0xE0);


MIDL_DEFINE_GUID(IID, IID_IDXTMetaRadialScaleWipe,0x107045C9,0x06E0,0x11D2,0x8D,0x6D,0x00,0xC0,0x4F,0x8E,0xF8,0xE0);


MIDL_DEFINE_GUID(IID, IID_IDXTMetaWhiteOut,0x107045CB,0x06E0,0x11D2,0x8D,0x6D,0x00,0xC0,0x4F,0x8E,0xF8,0xE0);


MIDL_DEFINE_GUID(IID, IID_IDXTMetaTwister,0x107045CE,0x06E0,0x11D2,0x8D,0x6D,0x00,0xC0,0x4F,0x8E,0xF8,0xE0);


MIDL_DEFINE_GUID(IID, IID_IDXTMetaBurnFilm,0x107045D0,0x06E0,0x11D2,0x8D,0x6D,0x00,0xC0,0x4F,0x8E,0xF8,0xE0);


MIDL_DEFINE_GUID(IID, IID_IDXTMetaJaws,0x2A54C903,0x07AA,0x11D2,0x8D,0x6D,0x00,0xC0,0x4F,0x8E,0xF8,0xE0);


MIDL_DEFINE_GUID(IID, IID_IDXTMetaColorFade,0x2A54C907,0x07AA,0x11D2,0x8D,0x6D,0x00,0xC0,0x4F,0x8E,0xF8,0xE0);


MIDL_DEFINE_GUID(IID, IID_IDXTMetaFlowMotion,0x2A54C90A,0x07AA,0x11D2,0x8D,0x6D,0x00,0xC0,0x4F,0x8E,0xF8,0xE0);


MIDL_DEFINE_GUID(IID, IID_IDXTMetaVacuum,0x2A54C90C,0x07AA,0x11D2,0x8D,0x6D,0x00,0xC0,0x4F,0x8E,0xF8,0xE0);


MIDL_DEFINE_GUID(IID, IID_IDXTMetaGriddler,0x2A54C910,0x07AA,0x11D2,0x8D,0x6D,0x00,0xC0,0x4F,0x8E,0xF8,0xE0);


MIDL_DEFINE_GUID(IID, IID_IDXTMetaGriddler2,0x2A54C912,0x07AA,0x11D2,0x8D,0x6D,0x00,0xC0,0x4F,0x8E,0xF8,0xE0);


MIDL_DEFINE_GUID(IID, IID_IDXTMetaThreshold,0x2A54C914,0x07AA,0x11D2,0x8D,0x6D,0x00,0xC0,0x4F,0x8E,0xF8,0xE0);


MIDL_DEFINE_GUID(IID, IID_IDXTMetaWormHole,0x0E6AE021,0x0C83,0x11D2,0x8C,0xD4,0x00,0x10,0x4B,0xC7,0x5D,0x9A);


MIDL_DEFINE_GUID(IID, LIBID_DXTMSFTLib,0x5E77EB03,0x937C,0x11D1,0xB0,0x47,0x00,0xAA,0x00,0x3B,0x60,0x61);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTComposite,0x9A43A844,0x0831,0x11D1,0x81,0x7F,0x00,0x00,0xF8,0x75,0x57,0xDB);


MIDL_DEFINE_GUID(CLSID, CLSID_DXLUTBuilder,0x1E54333B,0x2A00,0x11d1,0x81,0x98,0x00,0x00,0xF8,0x75,0x57,0xDB);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTGradientD,0x623E2882,0xFC0E,0x11d1,0x9A,0x77,0x00,0x00,0xF8,0x75,0x6A,0x10);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTWipe,0xAF279B30,0x86EB,0x11D1,0x81,0xBF,0x00,0x00,0xF8,0x75,0x57,0xDB);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTConvolution,0x2BC0EF29,0xE6BA,0x11d1,0x81,0xDD,0x00,0x00,0xF8,0x75,0x57,0xDB);


MIDL_DEFINE_GUID(CLSID, CLSID_CrBlur,0x7312498D,0xE87A,0x11d1,0x81,0xE0,0x00,0x00,0xF8,0x75,0x57,0xDB);


MIDL_DEFINE_GUID(CLSID, CLSID_CrEmboss,0xF515306D,0x0156,0x11d2,0x81,0xEA,0x00,0x00,0xF8,0x75,0x57,0xDB);


MIDL_DEFINE_GUID(CLSID, CLSID_CrEngrave,0xF515306E,0x0156,0x11d2,0x81,0xEA,0x00,0x00,0xF8,0x75,0x57,0xDB);


MIDL_DEFINE_GUID(CLSID, CLSID_DXFade,0x16B280C5,0xEE70,0x11D1,0x90,0x66,0x00,0xC0,0x4F,0xD9,0x18,0x9D);


MIDL_DEFINE_GUID(CLSID, CLSID_FadePP,0x16B280C6,0xEE70,0x11D1,0x90,0x66,0x00,0xC0,0x4F,0xD9,0x18,0x9D);


MIDL_DEFINE_GUID(CLSID, CLSID_BasicImageEffects,0x16B280C8,0xEE70,0x11D1,0x90,0x66,0x00,0xC0,0x4F,0xD9,0x18,0x9D);


MIDL_DEFINE_GUID(CLSID, CLSID_BasicImageEffectsPP,0x16B280C9,0xEE70,0x11D1,0x90,0x66,0x00,0xC0,0x4F,0xD9,0x18,0x9D);


MIDL_DEFINE_GUID(CLSID, CLSID_Pixelate,0x4CCEA634,0xFBE0,0x11d1,0x90,0x6A,0x00,0xC0,0x4F,0xD9,0x18,0x9D);


MIDL_DEFINE_GUID(CLSID, CLSID_PixelatePP,0x4CCEA635,0xFBE0,0x11d1,0x90,0x6A,0x00,0xC0,0x4F,0xD9,0x18,0x9D);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTWipePP,0x7FFE4D08,0xFBFD,0x11d1,0x9A,0x77,0x00,0x00,0xF8,0x75,0x6A,0x10);


MIDL_DEFINE_GUID(CLSID, CLSID_CrBlurPP,0x623E287E,0xFC0E,0x11d1,0x9A,0x77,0x00,0x00,0xF8,0x75,0x6A,0x10);


MIDL_DEFINE_GUID(CLSID, CLSID_GradientPP,0x623E2880,0xFC0E,0x11d1,0x9A,0x77,0x00,0x00,0xF8,0x75,0x6A,0x10);


MIDL_DEFINE_GUID(CLSID, CLSID_CompositePP,0x25B33660,0xFD83,0x11d1,0x8A,0xDE,0x44,0x45,0x53,0x54,0x00,0x01);


MIDL_DEFINE_GUID(CLSID, CLSID_ConvolvePP,0x25B33661,0xFD83,0x11d1,0x8A,0xDE,0x44,0x45,0x53,0x54,0x00,0x01);


MIDL_DEFINE_GUID(CLSID, CLSID_LUTBuilderPP,0x25B33662,0xFD83,0x11d1,0x8A,0xDE,0x44,0x45,0x53,0x54,0x00,0x01);


MIDL_DEFINE_GUID(CLSID, CLSID_CrIris,0x3F69F351,0x0379,0x11D2,0xA4,0x84,0x00,0xC0,0x4F,0x8E,0xFB,0x69);


MIDL_DEFINE_GUID(CLSID, CLSID_CrIrisPP,0x80DE22C4,0x0F44,0x11d2,0x8B,0x82,0x00,0xA0,0xC9,0x3C,0x09,0xB2);


MIDL_DEFINE_GUID(CLSID, CLSID_CrSlide,0x810E402F,0x056B,0x11D2,0xA4,0x84,0x00,0xC0,0x4F,0x8E,0xFB,0x69);


MIDL_DEFINE_GUID(CLSID, CLSID_CrSlidePP,0xCC8CEDE1,0x1003,0x11d2,0x8B,0x82,0x00,0xA0,0xC9,0x3C,0x09,0xB2);


MIDL_DEFINE_GUID(CLSID, CLSID_CrRadialWipe,0x424B71AF,0x0695,0x11D2,0xA4,0x84,0x00,0xC0,0x4F,0x8E,0xFB,0x69);


MIDL_DEFINE_GUID(CLSID, CLSID_CrRadialWipePP,0x33D932E0,0x0F48,0x11d2,0x8B,0x82,0x00,0xA0,0xC9,0x3C,0x09,0xB2);


MIDL_DEFINE_GUID(CLSID, CLSID_CrBarn,0xC3BDF740,0x0B58,0x11d2,0xA4,0x84,0x00,0xC0,0x4F,0x8E,0xFB,0x69);


MIDL_DEFINE_GUID(CLSID, CLSID_CrBlinds,0x00C429C0,0x0BA9,0x11d2,0xA4,0x84,0x00,0xC0,0x4F,0x8E,0xFB,0x69);


MIDL_DEFINE_GUID(CLSID, CLSID_CrBlindPP,0x213052C1,0x100D,0x11d2,0x8B,0x82,0x00,0xA0,0xC9,0x3C,0x09,0xB2);


MIDL_DEFINE_GUID(CLSID, CLSID_CrStretch,0x7658F2A2,0x0A83,0x11d2,0xA4,0x84,0x00,0xC0,0x4F,0x8E,0xFB,0x69);


MIDL_DEFINE_GUID(CLSID, CLSID_CrStretchPP,0x15FB95E0,0x0F77,0x11d2,0x8B,0x82,0x00,0xA0,0xC9,0x3C,0x09,0xB2);


MIDL_DEFINE_GUID(CLSID, CLSID_CrInset,0x93073C40,0x0BA5,0x11d2,0xA4,0x84,0x00,0xC0,0x4F,0x8E,0xFB,0x69);


MIDL_DEFINE_GUID(CLSID, CLSID_CrSpiral,0xACA97E00,0x0C7D,0x11d2,0xA4,0x84,0x00,0xC0,0x4F,0x8E,0xFB,0x69);


MIDL_DEFINE_GUID(CLSID, CLSID_CrSpiralPP,0xC6A4FE81,0x1022,0x11d2,0x8B,0x82,0x00,0xA0,0xC9,0x3C,0x09,0xB2);


MIDL_DEFINE_GUID(CLSID, CLSID_CrZigzag,0xE6E73D20,0x0C8A,0x11d2,0xA4,0x84,0x00,0xC0,0x4F,0x8E,0xFB,0x69);


MIDL_DEFINE_GUID(CLSID, CLSID_CrZigzagPP,0x1559A3C1,0x102B,0x11d2,0x8B,0x82,0x00,0xA0,0xC9,0x3C,0x09,0xB2);


MIDL_DEFINE_GUID(CLSID, CLSID_CrWheel,0x5AE1DAE0,0x1461,0x11d2,0xA4,0x84,0x00,0xC0,0x4F,0x8E,0xFB,0x69);


MIDL_DEFINE_GUID(CLSID, CLSID_CrWheelPP,0xFA9F6180,0x1464,0x11d2,0xA4,0x84,0x00,0xC0,0x4F,0x8E,0xFB,0x69);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTChroma,0x421516C1,0x3CF8,0x11D2,0x95,0x2A,0x00,0xC0,0x4F,0xA3,0x4F,0x05);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTChromaPP,0xEC7E0760,0x4C76,0x11D2,0x8A,0xDE,0x00,0xA0,0xC9,0x8E,0x65,0x27);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTDropShadow,0xADC6CB86,0x424C,0x11D2,0x95,0x2A,0x00,0xC0,0x4F,0xA3,0x4F,0x05);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTDropShadowPP,0xEC7E0761,0x4C76,0x11D2,0x8A,0xDE,0x00,0xA0,0xC9,0x8E,0x65,0x27);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTMetaRoll,0x9C61F46E,0x0530,0x11D2,0x8F,0x98,0x00,0xC0,0x4F,0xB9,0x2E,0xB7);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTMetaRipple,0xAA0D4D03,0x06A3,0x11D2,0x8F,0x98,0x00,0xC0,0x4F,0xB9,0x2E,0xB7);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTMetaPageTurn,0xAA0D4D08,0x06A3,0x11D2,0x8F,0x98,0x00,0xC0,0x4F,0xB9,0x2E,0xB7);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTMetaLiquid,0xAA0D4D0A,0x06A3,0x11D2,0x8F,0x98,0x00,0xC0,0x4F,0xB9,0x2E,0xB7);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTMetaCenterPeel,0xAA0D4D0C,0x06A3,0x11D2,0x8F,0x98,0x00,0xC0,0x4F,0xB9,0x2E,0xB7);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTMetaPeelSmall,0xAA0D4D0E,0x06A3,0x11D2,0x8F,0x98,0x00,0xC0,0x4F,0xB9,0x2E,0xB7);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTMetaPeelPiece,0xAA0D4D10,0x06A3,0x11D2,0x8F,0x98,0x00,0xC0,0x4F,0xB9,0x2E,0xB7);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTMetaPeelSplit,0xAA0D4D12,0x06A3,0x11D2,0x8F,0x98,0x00,0xC0,0x4F,0xB9,0x2E,0xB7);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTMetaWater,0x107045C5,0x06E0,0x11D2,0x8D,0x6D,0x00,0xC0,0x4F,0x8E,0xF8,0xE0);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTMetaLightWipe,0x107045C8,0x06E0,0x11D2,0x8D,0x6D,0x00,0xC0,0x4F,0x8E,0xF8,0xE0);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTMetaRadialScaleWipe,0x107045CA,0x06E0,0x11D2,0x8D,0x6D,0x00,0xC0,0x4F,0x8E,0xF8,0xE0);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTMetaWhiteOut,0x107045CC,0x06E0,0x11D2,0x8D,0x6D,0x00,0xC0,0x4F,0x8E,0xF8,0xE0);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTMetaTwister,0x107045CF,0x06E0,0x11D2,0x8D,0x6D,0x00,0xC0,0x4F,0x8E,0xF8,0xE0);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTMetaBurnFilm,0x107045D1,0x06E0,0x11D2,0x8D,0x6D,0x00,0xC0,0x4F,0x8E,0xF8,0xE0);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTMetaJaws,0x2A54C904,0x07AA,0x11D2,0x8D,0x6D,0x00,0xC0,0x4F,0x8E,0xF8,0xE0);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTMetaColorFade,0x2A54C908,0x07AA,0x11D2,0x8D,0x6D,0x00,0xC0,0x4F,0x8E,0xF8,0xE0);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTMetaFlowMotion,0x2A54C90B,0x07AA,0x11D2,0x8D,0x6D,0x00,0xC0,0x4F,0x8E,0xF8,0xE0);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTMetaVacuum,0x2A54C90D,0x07AA,0x11D2,0x8D,0x6D,0x00,0xC0,0x4F,0x8E,0xF8,0xE0);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTMetaGriddler,0x2A54C911,0x07AA,0x11D2,0x8D,0x6D,0x00,0xC0,0x4F,0x8E,0xF8,0xE0);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTMetaGriddler2,0x2A54C913,0x07AA,0x11D2,0x8D,0x6D,0x00,0xC0,0x4F,0x8E,0xF8,0xE0);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTMetaThreshold,0x2A54C915,0x07AA,0x11D2,0x8D,0x6D,0x00,0xC0,0x4F,0x8E,0xF8,0xE0);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTMetaWormHole,0x0E6AE022,0x0C83,0x11D2,0x8C,0xD4,0x00,0x10,0x4B,0xC7,0x5D,0x9A);

#undef MIDL_DEFINE_GUID

#ifdef __cplusplus
}
#endif



#endif /* !defined(_M_IA64) && !defined(_M_AXP64)*/


#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */

/* link this file in with the server and any clients */


 /* File created by MIDL compiler version 5.03.0285 */
/* Compiler settings for dxtmsft.idl:
    Oicf (OptLev=i2), W0, Zp8, env=Win64 (32b run,appending), ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if defined(_M_IA64) || defined(_M_AXP64)

#ifdef __cplusplus
extern "C"{
#endif 


#include <rpc.h>
#include <rpcndr.h>

#ifdef _MIDL_USE_GUIDDEF_

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)

#else // !_MIDL_USE_GUIDDEF_

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}

#endif !_MIDL_USE_GUIDDEF_

MIDL_DEFINE_GUID(IID, IID_IDXLUTBuilder,0xF4370FC1,0xCADB,0x11D0,0xB5,0x2C,0x00,0xA0,0xC9,0x05,0x43,0x73);


MIDL_DEFINE_GUID(IID, IID_IDXDLUTBuilder,0x73068231,0x35EE,0x11d1,0x81,0xA1,0x00,0x00,0xF8,0x75,0x57,0xDB);


MIDL_DEFINE_GUID(IID, IID_IDXTGradientD,0x623E2881,0xFC0E,0x11d1,0x9A,0x77,0x00,0x00,0xF8,0x75,0x6A,0x10);


MIDL_DEFINE_GUID(IID, IID_IDXTConvolution,0x7BA7F8AF,0xE5EA,0x11d1,0x81,0xDD,0x00,0x00,0xF8,0x75,0x57,0xDB);


MIDL_DEFINE_GUID(IID, IID_IDXMapper,0x555278E5,0x05DB,0x11D1,0x88,0x3A,0x3C,0x8B,0x00,0xC1,0x00,0x00);


MIDL_DEFINE_GUID(IID, IID_IDXDMapper,0x7FD9088B,0x35ED,0x11d1,0x81,0xA1,0x00,0x00,0xF8,0x75,0x57,0xDB);


MIDL_DEFINE_GUID(IID, IID_IDXTComposite,0x9A43A843,0x0831,0x11D1,0x81,0x7F,0x00,0x00,0xF8,0x75,0x57,0xDB);


MIDL_DEFINE_GUID(IID, IID_IDXTWipe,0xAF279B2F,0x86EB,0x11D1,0x81,0xBF,0x00,0x00,0xF8,0x75,0x57,0xDB);


MIDL_DEFINE_GUID(IID, IID_ICrBlur,0x9F7C7827,0xE87A,0x11d1,0x81,0xE0,0x00,0x00,0xF8,0x75,0x57,0xDB);


MIDL_DEFINE_GUID(IID, IID_ICrEngrave,0xE4ACFB7F,0x053E,0x11d2,0x81,0xEA,0x00,0x00,0xF8,0x75,0x57,0xDB);


MIDL_DEFINE_GUID(IID, IID_ICrEmboss,0xE4ACFB80,0x053E,0x11d2,0x81,0xEA,0x00,0x00,0xF8,0x75,0x57,0xDB);


MIDL_DEFINE_GUID(IID, IID_IDXTFade,0x16B280C4,0xEE70,0x11D1,0x90,0x66,0x00,0xC0,0x4F,0xD9,0x18,0x9D);


MIDL_DEFINE_GUID(IID, IID_IDXBasicImage,0x16B280C7,0xEE70,0x11D1,0x90,0x66,0x00,0xC0,0x4F,0xD9,0x18,0x9D);


MIDL_DEFINE_GUID(IID, IID_IDXPixelate,0xD33E180F,0xFBE9,0x11d1,0x90,0x6A,0x00,0xC0,0x4F,0xD9,0x18,0x9D);


MIDL_DEFINE_GUID(IID, IID_ICrIris,0x3F69F350,0x0379,0x11D2,0xA4,0x84,0x00,0xC0,0x4F,0x8E,0xFB,0x69);


MIDL_DEFINE_GUID(IID, IID_ICrSlide,0x810E402E,0x056B,0x11D2,0xA4,0x84,0x00,0xC0,0x4F,0x8E,0xFB,0x69);


MIDL_DEFINE_GUID(IID, IID_ICrRadialWipe,0x424B71AE,0x0695,0x11D2,0xA4,0x84,0x00,0xC0,0x4F,0x8E,0xFB,0x69);


MIDL_DEFINE_GUID(IID, IID_ICrBarn,0x276A2EE0,0x0B5D,0x11d2,0xA4,0x84,0x00,0xC0,0x4F,0x8E,0xFB,0x69);


MIDL_DEFINE_GUID(IID, IID_ICrBlinds,0x5AF5C340,0x0BA9,0x11d2,0xA4,0x84,0x00,0xC0,0x4F,0x8E,0xFB,0x69);


MIDL_DEFINE_GUID(IID, IID_ICrInset,0x05C5EE20,0x0BA6,0x11d2,0xA4,0x84,0x00,0xC0,0x4F,0x8E,0xFB,0x69);


MIDL_DEFINE_GUID(IID, IID_ICrStretch,0x6684AF00,0x0A87,0x11d2,0xA4,0x84,0x00,0xC0,0x4F,0x8E,0xFB,0x69);


MIDL_DEFINE_GUID(IID, IID_ICrSpiral,0x0DE527A0,0x0C7E,0x11d2,0xA4,0x84,0x00,0xC0,0x4F,0x8E,0xFB,0x69);


MIDL_DEFINE_GUID(IID, IID_ICrZigzag,0x4E5A64A0,0x0C8B,0x11d2,0xA4,0x84,0x00,0xC0,0x4F,0x8E,0xFB,0x69);


MIDL_DEFINE_GUID(IID, IID_ICrWheel,0x3943DE80,0x1464,0x11d2,0xA4,0x84,0x00,0xC0,0x4F,0x8E,0xFB,0x69);


MIDL_DEFINE_GUID(IID, IID_IDXTChroma,0x1D4637E2,0x383C,0x11d2,0x95,0x2A,0x00,0xC0,0x4F,0xA3,0x4F,0x05);


MIDL_DEFINE_GUID(IID, IID_IDXTDropShadow,0x1D4637E3,0x383C,0x11d2,0x95,0x2A,0x00,0xC0,0x4F,0xA3,0x4F,0x05);


MIDL_DEFINE_GUID(IID, IID_IDXTMetaRoll,0x9C61F46D,0x0530,0x11D2,0x8F,0x98,0x00,0xC0,0x4F,0xB9,0x2E,0xB7);


MIDL_DEFINE_GUID(IID, IID_IDXTMetaRipple,0xAA0D4D02,0x06A3,0x11D2,0x8F,0x98,0x00,0xC0,0x4F,0xB9,0x2E,0xB7);


MIDL_DEFINE_GUID(IID, IID_IDXTMetaPageTurn,0xAA0D4D07,0x06A3,0x11D2,0x8F,0x98,0x00,0xC0,0x4F,0xB9,0x2E,0xB7);


MIDL_DEFINE_GUID(IID, IID_IDXTMetaLiquid,0xAA0D4D09,0x06A3,0x11D2,0x8F,0x98,0x00,0xC0,0x4F,0xB9,0x2E,0xB7);


MIDL_DEFINE_GUID(IID, IID_IDXTMetaCenterPeel,0xAA0D4D0B,0x06A3,0x11D2,0x8F,0x98,0x00,0xC0,0x4F,0xB9,0x2E,0xB7);


MIDL_DEFINE_GUID(IID, IID_IDXTMetaPeelSmall,0xAA0D4D0D,0x06A3,0x11D2,0x8F,0x98,0x00,0xC0,0x4F,0xB9,0x2E,0xB7);


MIDL_DEFINE_GUID(IID, IID_IDXTMetaPeelPiece,0xAA0D4D0F,0x06A3,0x11D2,0x8F,0x98,0x00,0xC0,0x4F,0xB9,0x2E,0xB7);


MIDL_DEFINE_GUID(IID, IID_IDXTMetaPeelSplit,0xAA0D4D11,0x06A3,0x11D2,0x8F,0x98,0x00,0xC0,0x4F,0xB9,0x2E,0xB7);


MIDL_DEFINE_GUID(IID, IID_IDXTMetaWater,0x107045C4,0x06E0,0x11D2,0x8D,0x6D,0x00,0xC0,0x4F,0x8E,0xF8,0xE0);


MIDL_DEFINE_GUID(IID, IID_IDXTMetaLightWipe,0x107045C7,0x06E0,0x11D2,0x8D,0x6D,0x00,0xC0,0x4F,0x8E,0xF8,0xE0);


MIDL_DEFINE_GUID(IID, IID_IDXTMetaRadialScaleWipe,0x107045C9,0x06E0,0x11D2,0x8D,0x6D,0x00,0xC0,0x4F,0x8E,0xF8,0xE0);


MIDL_DEFINE_GUID(IID, IID_IDXTMetaWhiteOut,0x107045CB,0x06E0,0x11D2,0x8D,0x6D,0x00,0xC0,0x4F,0x8E,0xF8,0xE0);


MIDL_DEFINE_GUID(IID, IID_IDXTMetaTwister,0x107045CE,0x06E0,0x11D2,0x8D,0x6D,0x00,0xC0,0x4F,0x8E,0xF8,0xE0);


MIDL_DEFINE_GUID(IID, IID_IDXTMetaBurnFilm,0x107045D0,0x06E0,0x11D2,0x8D,0x6D,0x00,0xC0,0x4F,0x8E,0xF8,0xE0);


MIDL_DEFINE_GUID(IID, IID_IDXTMetaJaws,0x2A54C903,0x07AA,0x11D2,0x8D,0x6D,0x00,0xC0,0x4F,0x8E,0xF8,0xE0);


MIDL_DEFINE_GUID(IID, IID_IDXTMetaColorFade,0x2A54C907,0x07AA,0x11D2,0x8D,0x6D,0x00,0xC0,0x4F,0x8E,0xF8,0xE0);


MIDL_DEFINE_GUID(IID, IID_IDXTMetaFlowMotion,0x2A54C90A,0x07AA,0x11D2,0x8D,0x6D,0x00,0xC0,0x4F,0x8E,0xF8,0xE0);


MIDL_DEFINE_GUID(IID, IID_IDXTMetaVacuum,0x2A54C90C,0x07AA,0x11D2,0x8D,0x6D,0x00,0xC0,0x4F,0x8E,0xF8,0xE0);


MIDL_DEFINE_GUID(IID, IID_IDXTMetaGriddler,0x2A54C910,0x07AA,0x11D2,0x8D,0x6D,0x00,0xC0,0x4F,0x8E,0xF8,0xE0);


MIDL_DEFINE_GUID(IID, IID_IDXTMetaGriddler2,0x2A54C912,0x07AA,0x11D2,0x8D,0x6D,0x00,0xC0,0x4F,0x8E,0xF8,0xE0);


MIDL_DEFINE_GUID(IID, IID_IDXTMetaThreshold,0x2A54C914,0x07AA,0x11D2,0x8D,0x6D,0x00,0xC0,0x4F,0x8E,0xF8,0xE0);


MIDL_DEFINE_GUID(IID, IID_IDXTMetaWormHole,0x0E6AE021,0x0C83,0x11D2,0x8C,0xD4,0x00,0x10,0x4B,0xC7,0x5D,0x9A);


MIDL_DEFINE_GUID(IID, LIBID_DXTMSFTLib,0x5E77EB03,0x937C,0x11D1,0xB0,0x47,0x00,0xAA,0x00,0x3B,0x60,0x61);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTComposite,0x9A43A844,0x0831,0x11D1,0x81,0x7F,0x00,0x00,0xF8,0x75,0x57,0xDB);


MIDL_DEFINE_GUID(CLSID, CLSID_DXLUTBuilder,0x1E54333B,0x2A00,0x11d1,0x81,0x98,0x00,0x00,0xF8,0x75,0x57,0xDB);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTGradientD,0x623E2882,0xFC0E,0x11d1,0x9A,0x77,0x00,0x00,0xF8,0x75,0x6A,0x10);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTWipe,0xAF279B30,0x86EB,0x11D1,0x81,0xBF,0x00,0x00,0xF8,0x75,0x57,0xDB);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTConvolution,0x2BC0EF29,0xE6BA,0x11d1,0x81,0xDD,0x00,0x00,0xF8,0x75,0x57,0xDB);


MIDL_DEFINE_GUID(CLSID, CLSID_CrBlur,0x7312498D,0xE87A,0x11d1,0x81,0xE0,0x00,0x00,0xF8,0x75,0x57,0xDB);


MIDL_DEFINE_GUID(CLSID, CLSID_CrEmboss,0xF515306D,0x0156,0x11d2,0x81,0xEA,0x00,0x00,0xF8,0x75,0x57,0xDB);


MIDL_DEFINE_GUID(CLSID, CLSID_CrEngrave,0xF515306E,0x0156,0x11d2,0x81,0xEA,0x00,0x00,0xF8,0x75,0x57,0xDB);


MIDL_DEFINE_GUID(CLSID, CLSID_DXFade,0x16B280C5,0xEE70,0x11D1,0x90,0x66,0x00,0xC0,0x4F,0xD9,0x18,0x9D);


MIDL_DEFINE_GUID(CLSID, CLSID_FadePP,0x16B280C6,0xEE70,0x11D1,0x90,0x66,0x00,0xC0,0x4F,0xD9,0x18,0x9D);


MIDL_DEFINE_GUID(CLSID, CLSID_BasicImageEffects,0x16B280C8,0xEE70,0x11D1,0x90,0x66,0x00,0xC0,0x4F,0xD9,0x18,0x9D);


MIDL_DEFINE_GUID(CLSID, CLSID_BasicImageEffectsPP,0x16B280C9,0xEE70,0x11D1,0x90,0x66,0x00,0xC0,0x4F,0xD9,0x18,0x9D);


MIDL_DEFINE_GUID(CLSID, CLSID_Pixelate,0x4CCEA634,0xFBE0,0x11d1,0x90,0x6A,0x00,0xC0,0x4F,0xD9,0x18,0x9D);


MIDL_DEFINE_GUID(CLSID, CLSID_PixelatePP,0x4CCEA635,0xFBE0,0x11d1,0x90,0x6A,0x00,0xC0,0x4F,0xD9,0x18,0x9D);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTWipePP,0x7FFE4D08,0xFBFD,0x11d1,0x9A,0x77,0x00,0x00,0xF8,0x75,0x6A,0x10);


MIDL_DEFINE_GUID(CLSID, CLSID_CrBlurPP,0x623E287E,0xFC0E,0x11d1,0x9A,0x77,0x00,0x00,0xF8,0x75,0x6A,0x10);


MIDL_DEFINE_GUID(CLSID, CLSID_GradientPP,0x623E2880,0xFC0E,0x11d1,0x9A,0x77,0x00,0x00,0xF8,0x75,0x6A,0x10);


MIDL_DEFINE_GUID(CLSID, CLSID_CompositePP,0x25B33660,0xFD83,0x11d1,0x8A,0xDE,0x44,0x45,0x53,0x54,0x00,0x01);


MIDL_DEFINE_GUID(CLSID, CLSID_ConvolvePP,0x25B33661,0xFD83,0x11d1,0x8A,0xDE,0x44,0x45,0x53,0x54,0x00,0x01);


MIDL_DEFINE_GUID(CLSID, CLSID_LUTBuilderPP,0x25B33662,0xFD83,0x11d1,0x8A,0xDE,0x44,0x45,0x53,0x54,0x00,0x01);


MIDL_DEFINE_GUID(CLSID, CLSID_CrIris,0x3F69F351,0x0379,0x11D2,0xA4,0x84,0x00,0xC0,0x4F,0x8E,0xFB,0x69);


MIDL_DEFINE_GUID(CLSID, CLSID_CrIrisPP,0x80DE22C4,0x0F44,0x11d2,0x8B,0x82,0x00,0xA0,0xC9,0x3C,0x09,0xB2);


MIDL_DEFINE_GUID(CLSID, CLSID_CrSlide,0x810E402F,0x056B,0x11D2,0xA4,0x84,0x00,0xC0,0x4F,0x8E,0xFB,0x69);


MIDL_DEFINE_GUID(CLSID, CLSID_CrSlidePP,0xCC8CEDE1,0x1003,0x11d2,0x8B,0x82,0x00,0xA0,0xC9,0x3C,0x09,0xB2);


MIDL_DEFINE_GUID(CLSID, CLSID_CrRadialWipe,0x424B71AF,0x0695,0x11D2,0xA4,0x84,0x00,0xC0,0x4F,0x8E,0xFB,0x69);


MIDL_DEFINE_GUID(CLSID, CLSID_CrRadialWipePP,0x33D932E0,0x0F48,0x11d2,0x8B,0x82,0x00,0xA0,0xC9,0x3C,0x09,0xB2);


MIDL_DEFINE_GUID(CLSID, CLSID_CrBarn,0xC3BDF740,0x0B58,0x11d2,0xA4,0x84,0x00,0xC0,0x4F,0x8E,0xFB,0x69);


MIDL_DEFINE_GUID(CLSID, CLSID_CrBlinds,0x00C429C0,0x0BA9,0x11d2,0xA4,0x84,0x00,0xC0,0x4F,0x8E,0xFB,0x69);


MIDL_DEFINE_GUID(CLSID, CLSID_CrBlindPP,0x213052C1,0x100D,0x11d2,0x8B,0x82,0x00,0xA0,0xC9,0x3C,0x09,0xB2);


MIDL_DEFINE_GUID(CLSID, CLSID_CrStretch,0x7658F2A2,0x0A83,0x11d2,0xA4,0x84,0x00,0xC0,0x4F,0x8E,0xFB,0x69);


MIDL_DEFINE_GUID(CLSID, CLSID_CrStretchPP,0x15FB95E0,0x0F77,0x11d2,0x8B,0x82,0x00,0xA0,0xC9,0x3C,0x09,0xB2);


MIDL_DEFINE_GUID(CLSID, CLSID_CrInset,0x93073C40,0x0BA5,0x11d2,0xA4,0x84,0x00,0xC0,0x4F,0x8E,0xFB,0x69);


MIDL_DEFINE_GUID(CLSID, CLSID_CrSpiral,0xACA97E00,0x0C7D,0x11d2,0xA4,0x84,0x00,0xC0,0x4F,0x8E,0xFB,0x69);


MIDL_DEFINE_GUID(CLSID, CLSID_CrSpiralPP,0xC6A4FE81,0x1022,0x11d2,0x8B,0x82,0x00,0xA0,0xC9,0x3C,0x09,0xB2);


MIDL_DEFINE_GUID(CLSID, CLSID_CrZigzag,0xE6E73D20,0x0C8A,0x11d2,0xA4,0x84,0x00,0xC0,0x4F,0x8E,0xFB,0x69);


MIDL_DEFINE_GUID(CLSID, CLSID_CrZigzagPP,0x1559A3C1,0x102B,0x11d2,0x8B,0x82,0x00,0xA0,0xC9,0x3C,0x09,0xB2);


MIDL_DEFINE_GUID(CLSID, CLSID_CrWheel,0x5AE1DAE0,0x1461,0x11d2,0xA4,0x84,0x00,0xC0,0x4F,0x8E,0xFB,0x69);


MIDL_DEFINE_GUID(CLSID, CLSID_CrWheelPP,0xFA9F6180,0x1464,0x11d2,0xA4,0x84,0x00,0xC0,0x4F,0x8E,0xFB,0x69);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTChroma,0x421516C1,0x3CF8,0x11D2,0x95,0x2A,0x00,0xC0,0x4F,0xA3,0x4F,0x05);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTChromaPP,0xEC7E0760,0x4C76,0x11D2,0x8A,0xDE,0x00,0xA0,0xC9,0x8E,0x65,0x27);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTDropShadow,0xADC6CB86,0x424C,0x11D2,0x95,0x2A,0x00,0xC0,0x4F,0xA3,0x4F,0x05);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTDropShadowPP,0xEC7E0761,0x4C76,0x11D2,0x8A,0xDE,0x00,0xA0,0xC9,0x8E,0x65,0x27);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTMetaRoll,0x9C61F46E,0x0530,0x11D2,0x8F,0x98,0x00,0xC0,0x4F,0xB9,0x2E,0xB7);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTMetaRipple,0xAA0D4D03,0x06A3,0x11D2,0x8F,0x98,0x00,0xC0,0x4F,0xB9,0x2E,0xB7);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTMetaPageTurn,0xAA0D4D08,0x06A3,0x11D2,0x8F,0x98,0x00,0xC0,0x4F,0xB9,0x2E,0xB7);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTMetaLiquid,0xAA0D4D0A,0x06A3,0x11D2,0x8F,0x98,0x00,0xC0,0x4F,0xB9,0x2E,0xB7);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTMetaCenterPeel,0xAA0D4D0C,0x06A3,0x11D2,0x8F,0x98,0x00,0xC0,0x4F,0xB9,0x2E,0xB7);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTMetaPeelSmall,0xAA0D4D0E,0x06A3,0x11D2,0x8F,0x98,0x00,0xC0,0x4F,0xB9,0x2E,0xB7);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTMetaPeelPiece,0xAA0D4D10,0x06A3,0x11D2,0x8F,0x98,0x00,0xC0,0x4F,0xB9,0x2E,0xB7);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTMetaPeelSplit,0xAA0D4D12,0x06A3,0x11D2,0x8F,0x98,0x00,0xC0,0x4F,0xB9,0x2E,0xB7);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTMetaWater,0x107045C5,0x06E0,0x11D2,0x8D,0x6D,0x00,0xC0,0x4F,0x8E,0xF8,0xE0);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTMetaLightWipe,0x107045C8,0x06E0,0x11D2,0x8D,0x6D,0x00,0xC0,0x4F,0x8E,0xF8,0xE0);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTMetaRadialScaleWipe,0x107045CA,0x06E0,0x11D2,0x8D,0x6D,0x00,0xC0,0x4F,0x8E,0xF8,0xE0);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTMetaWhiteOut,0x107045CC,0x06E0,0x11D2,0x8D,0x6D,0x00,0xC0,0x4F,0x8E,0xF8,0xE0);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTMetaTwister,0x107045CF,0x06E0,0x11D2,0x8D,0x6D,0x00,0xC0,0x4F,0x8E,0xF8,0xE0);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTMetaBurnFilm,0x107045D1,0x06E0,0x11D2,0x8D,0x6D,0x00,0xC0,0x4F,0x8E,0xF8,0xE0);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTMetaJaws,0x2A54C904,0x07AA,0x11D2,0x8D,0x6D,0x00,0xC0,0x4F,0x8E,0xF8,0xE0);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTMetaColorFade,0x2A54C908,0x07AA,0x11D2,0x8D,0x6D,0x00,0xC0,0x4F,0x8E,0xF8,0xE0);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTMetaFlowMotion,0x2A54C90B,0x07AA,0x11D2,0x8D,0x6D,0x00,0xC0,0x4F,0x8E,0xF8,0xE0);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTMetaVacuum,0x2A54C90D,0x07AA,0x11D2,0x8D,0x6D,0x00,0xC0,0x4F,0x8E,0xF8,0xE0);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTMetaGriddler,0x2A54C911,0x07AA,0x11D2,0x8D,0x6D,0x00,0xC0,0x4F,0x8E,0xF8,0xE0);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTMetaGriddler2,0x2A54C913,0x07AA,0x11D2,0x8D,0x6D,0x00,0xC0,0x4F,0x8E,0xF8,0xE0);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTMetaThreshold,0x2A54C915,0x07AA,0x11D2,0x8D,0x6D,0x00,0xC0,0x4F,0x8E,0xF8,0xE0);


MIDL_DEFINE_GUID(CLSID, CLSID_DXTMetaWormHole,0x0E6AE022,0x0C83,0x11D2,0x8C,0xD4,0x00,0x10,0x4B,0xC7,0x5D,0x9A);

#undef MIDL_DEFINE_GUID

#ifdef __cplusplus
}
#endif



#endif /* defined(_M_IA64) || defined(_M_AXP64)*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\extinc\dxtmsft.h ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 5.03.0285 */
/* Compiler settings for dxtmsft.idl:
    Oicf (OptLev=i2), W0, Zp8, env=Win32 (32b run), ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __dxtmsft_h__
#define __dxtmsft_h__

/* Forward Declarations */ 

#ifndef __IDXLUTBuilder_FWD_DEFINED__
#define __IDXLUTBuilder_FWD_DEFINED__
typedef interface IDXLUTBuilder IDXLUTBuilder;
#endif 	/* __IDXLUTBuilder_FWD_DEFINED__ */


#ifndef __IDXDLUTBuilder_FWD_DEFINED__
#define __IDXDLUTBuilder_FWD_DEFINED__
typedef interface IDXDLUTBuilder IDXDLUTBuilder;
#endif 	/* __IDXDLUTBuilder_FWD_DEFINED__ */


#ifndef __IDXTGradientD_FWD_DEFINED__
#define __IDXTGradientD_FWD_DEFINED__
typedef interface IDXTGradientD IDXTGradientD;
#endif 	/* __IDXTGradientD_FWD_DEFINED__ */


#ifndef __IDXTConvolution_FWD_DEFINED__
#define __IDXTConvolution_FWD_DEFINED__
typedef interface IDXTConvolution IDXTConvolution;
#endif 	/* __IDXTConvolution_FWD_DEFINED__ */


#ifndef __IDXMapper_FWD_DEFINED__
#define __IDXMapper_FWD_DEFINED__
typedef interface IDXMapper IDXMapper;
#endif 	/* __IDXMapper_FWD_DEFINED__ */


#ifndef __IDXDMapper_FWD_DEFINED__
#define __IDXDMapper_FWD_DEFINED__
typedef interface IDXDMapper IDXDMapper;
#endif 	/* __IDXDMapper_FWD_DEFINED__ */


#ifndef __IDXTComposite_FWD_DEFINED__
#define __IDXTComposite_FWD_DEFINED__
typedef interface IDXTComposite IDXTComposite;
#endif 	/* __IDXTComposite_FWD_DEFINED__ */


#ifndef __IDXTWipe_FWD_DEFINED__
#define __IDXTWipe_FWD_DEFINED__
typedef interface IDXTWipe IDXTWipe;
#endif 	/* __IDXTWipe_FWD_DEFINED__ */


#ifndef __ICrBlur_FWD_DEFINED__
#define __ICrBlur_FWD_DEFINED__
typedef interface ICrBlur ICrBlur;
#endif 	/* __ICrBlur_FWD_DEFINED__ */


#ifndef __ICrEngrave_FWD_DEFINED__
#define __ICrEngrave_FWD_DEFINED__
typedef interface ICrEngrave ICrEngrave;
#endif 	/* __ICrEngrave_FWD_DEFINED__ */


#ifndef __ICrEmboss_FWD_DEFINED__
#define __ICrEmboss_FWD_DEFINED__
typedef interface ICrEmboss ICrEmboss;
#endif 	/* __ICrEmboss_FWD_DEFINED__ */


#ifndef __IDXTFade_FWD_DEFINED__
#define __IDXTFade_FWD_DEFINED__
typedef interface IDXTFade IDXTFade;
#endif 	/* __IDXTFade_FWD_DEFINED__ */


#ifndef __IDXBasicImage_FWD_DEFINED__
#define __IDXBasicImage_FWD_DEFINED__
typedef interface IDXBasicImage IDXBasicImage;
#endif 	/* __IDXBasicImage_FWD_DEFINED__ */


#ifndef __IDXPixelate_FWD_DEFINED__
#define __IDXPixelate_FWD_DEFINED__
typedef interface IDXPixelate IDXPixelate;
#endif 	/* __IDXPixelate_FWD_DEFINED__ */


#ifndef __ICrIris_FWD_DEFINED__
#define __ICrIris_FWD_DEFINED__
typedef interface ICrIris ICrIris;
#endif 	/* __ICrIris_FWD_DEFINED__ */


#ifndef __ICrSlide_FWD_DEFINED__
#define __ICrSlide_FWD_DEFINED__
typedef interface ICrSlide ICrSlide;
#endif 	/* __ICrSlide_FWD_DEFINED__ */


#ifndef __ICrRadialWipe_FWD_DEFINED__
#define __ICrRadialWipe_FWD_DEFINED__
typedef interface ICrRadialWipe ICrRadialWipe;
#endif 	/* __ICrRadialWipe_FWD_DEFINED__ */


#ifndef __ICrBarn_FWD_DEFINED__
#define __ICrBarn_FWD_DEFINED__
typedef interface ICrBarn ICrBarn;
#endif 	/* __ICrBarn_FWD_DEFINED__ */


#ifndef __ICrBlinds_FWD_DEFINED__
#define __ICrBlinds_FWD_DEFINED__
typedef interface ICrBlinds ICrBlinds;
#endif 	/* __ICrBlinds_FWD_DEFINED__ */


#ifndef __ICrInset_FWD_DEFINED__
#define __ICrInset_FWD_DEFINED__
typedef interface ICrInset ICrInset;
#endif 	/* __ICrInset_FWD_DEFINED__ */


#ifndef __ICrStretch_FWD_DEFINED__
#define __ICrStretch_FWD_DEFINED__
typedef interface ICrStretch ICrStretch;
#endif 	/* __ICrStretch_FWD_DEFINED__ */


#ifndef __ICrSpiral_FWD_DEFINED__
#define __ICrSpiral_FWD_DEFINED__
typedef interface ICrSpiral ICrSpiral;
#endif 	/* __ICrSpiral_FWD_DEFINED__ */


#ifndef __ICrZigzag_FWD_DEFINED__
#define __ICrZigzag_FWD_DEFINED__
typedef interface ICrZigzag ICrZigzag;
#endif 	/* __ICrZigzag_FWD_DEFINED__ */


#ifndef __ICrWheel_FWD_DEFINED__
#define __ICrWheel_FWD_DEFINED__
typedef interface ICrWheel ICrWheel;
#endif 	/* __ICrWheel_FWD_DEFINED__ */


#ifndef __IDXTChroma_FWD_DEFINED__
#define __IDXTChroma_FWD_DEFINED__
typedef interface IDXTChroma IDXTChroma;
#endif 	/* __IDXTChroma_FWD_DEFINED__ */


#ifndef __IDXTDropShadow_FWD_DEFINED__
#define __IDXTDropShadow_FWD_DEFINED__
typedef interface IDXTDropShadow IDXTDropShadow;
#endif 	/* __IDXTDropShadow_FWD_DEFINED__ */


#ifndef __IDXTMetaRoll_FWD_DEFINED__
#define __IDXTMetaRoll_FWD_DEFINED__
typedef interface IDXTMetaRoll IDXTMetaRoll;
#endif 	/* __IDXTMetaRoll_FWD_DEFINED__ */


#ifndef __IDXTMetaRipple_FWD_DEFINED__
#define __IDXTMetaRipple_FWD_DEFINED__
typedef interface IDXTMetaRipple IDXTMetaRipple;
#endif 	/* __IDXTMetaRipple_FWD_DEFINED__ */


#ifndef __IDXTMetaPageTurn_FWD_DEFINED__
#define __IDXTMetaPageTurn_FWD_DEFINED__
typedef interface IDXTMetaPageTurn IDXTMetaPageTurn;
#endif 	/* __IDXTMetaPageTurn_FWD_DEFINED__ */


#ifndef __IDXTMetaLiquid_FWD_DEFINED__
#define __IDXTMetaLiquid_FWD_DEFINED__
typedef interface IDXTMetaLiquid IDXTMetaLiquid;
#endif 	/* __IDXTMetaLiquid_FWD_DEFINED__ */


#ifndef __IDXTMetaCenterPeel_FWD_DEFINED__
#define __IDXTMetaCenterPeel_FWD_DEFINED__
typedef interface IDXTMetaCenterPeel IDXTMetaCenterPeel;
#endif 	/* __IDXTMetaCenterPeel_FWD_DEFINED__ */


#ifndef __IDXTMetaPeelSmall_FWD_DEFINED__
#define __IDXTMetaPeelSmall_FWD_DEFINED__
typedef interface IDXTMetaPeelSmall IDXTMetaPeelSmall;
#endif 	/* __IDXTMetaPeelSmall_FWD_DEFINED__ */


#ifndef __IDXTMetaPeelPiece_FWD_DEFINED__
#define __IDXTMetaPeelPiece_FWD_DEFINED__
typedef interface IDXTMetaPeelPiece IDXTMetaPeelPiece;
#endif 	/* __IDXTMetaPeelPiece_FWD_DEFINED__ */


#ifndef __IDXTMetaPeelSplit_FWD_DEFINED__
#define __IDXTMetaPeelSplit_FWD_DEFINED__
typedef interface IDXTMetaPeelSplit IDXTMetaPeelSplit;
#endif 	/* __IDXTMetaPeelSplit_FWD_DEFINED__ */


#ifndef __IDXTMetaWater_FWD_DEFINED__
#define __IDXTMetaWater_FWD_DEFINED__
typedef interface IDXTMetaWater IDXTMetaWater;
#endif 	/* __IDXTMetaWater_FWD_DEFINED__ */


#ifndef __IDXTMetaLightWipe_FWD_DEFINED__
#define __IDXTMetaLightWipe_FWD_DEFINED__
typedef interface IDXTMetaLightWipe IDXTMetaLightWipe;
#endif 	/* __IDXTMetaLightWipe_FWD_DEFINED__ */


#ifndef __IDXTMetaRadialScaleWipe_FWD_DEFINED__
#define __IDXTMetaRadialScaleWipe_FWD_DEFINED__
typedef interface IDXTMetaRadialScaleWipe IDXTMetaRadialScaleWipe;
#endif 	/* __IDXTMetaRadialScaleWipe_FWD_DEFINED__ */


#ifndef __IDXTMetaWhiteOut_FWD_DEFINED__
#define __IDXTMetaWhiteOut_FWD_DEFINED__
typedef interface IDXTMetaWhiteOut IDXTMetaWhiteOut;
#endif 	/* __IDXTMetaWhiteOut_FWD_DEFINED__ */


#ifndef __IDXTMetaTwister_FWD_DEFINED__
#define __IDXTMetaTwister_FWD_DEFINED__
typedef interface IDXTMetaTwister IDXTMetaTwister;
#endif 	/* __IDXTMetaTwister_FWD_DEFINED__ */


#ifndef __IDXTMetaBurnFilm_FWD_DEFINED__
#define __IDXTMetaBurnFilm_FWD_DEFINED__
typedef interface IDXTMetaBurnFilm IDXTMetaBurnFilm;
#endif 	/* __IDXTMetaBurnFilm_FWD_DEFINED__ */


#ifndef __IDXTMetaJaws_FWD_DEFINED__
#define __IDXTMetaJaws_FWD_DEFINED__
typedef interface IDXTMetaJaws IDXTMetaJaws;
#endif 	/* __IDXTMetaJaws_FWD_DEFINED__ */


#ifndef __IDXTMetaColorFade_FWD_DEFINED__
#define __IDXTMetaColorFade_FWD_DEFINED__
typedef interface IDXTMetaColorFade IDXTMetaColorFade;
#endif 	/* __IDXTMetaColorFade_FWD_DEFINED__ */


#ifndef __IDXTMetaFlowMotion_FWD_DEFINED__
#define __IDXTMetaFlowMotion_FWD_DEFINED__
typedef interface IDXTMetaFlowMotion IDXTMetaFlowMotion;
#endif 	/* __IDXTMetaFlowMotion_FWD_DEFINED__ */


#ifndef __IDXTMetaVacuum_FWD_DEFINED__
#define __IDXTMetaVacuum_FWD_DEFINED__
typedef interface IDXTMetaVacuum IDXTMetaVacuum;
#endif 	/* __IDXTMetaVacuum_FWD_DEFINED__ */


#ifndef __IDXTMetaGriddler_FWD_DEFINED__
#define __IDXTMetaGriddler_FWD_DEFINED__
typedef interface IDXTMetaGriddler IDXTMetaGriddler;
#endif 	/* __IDXTMetaGriddler_FWD_DEFINED__ */


#ifndef __IDXTMetaGriddler2_FWD_DEFINED__
#define __IDXTMetaGriddler2_FWD_DEFINED__
typedef interface IDXTMetaGriddler2 IDXTMetaGriddler2;
#endif 	/* __IDXTMetaGriddler2_FWD_DEFINED__ */


#ifndef __IDXTMetaThreshold_FWD_DEFINED__
#define __IDXTMetaThreshold_FWD_DEFINED__
typedef interface IDXTMetaThreshold IDXTMetaThreshold;
#endif 	/* __IDXTMetaThreshold_FWD_DEFINED__ */


#ifndef __IDXTMetaWormHole_FWD_DEFINED__
#define __IDXTMetaWormHole_FWD_DEFINED__
typedef interface IDXTMetaWormHole IDXTMetaWormHole;
#endif 	/* __IDXTMetaWormHole_FWD_DEFINED__ */


#ifndef __DXTComposite_FWD_DEFINED__
#define __DXTComposite_FWD_DEFINED__

#ifdef __cplusplus
typedef class DXTComposite DXTComposite;
#else
typedef struct DXTComposite DXTComposite;
#endif /* __cplusplus */

#endif 	/* __DXTComposite_FWD_DEFINED__ */


#ifndef __DXLUTBuilder_FWD_DEFINED__
#define __DXLUTBuilder_FWD_DEFINED__

#ifdef __cplusplus
typedef class DXLUTBuilder DXLUTBuilder;
#else
typedef struct DXLUTBuilder DXLUTBuilder;
#endif /* __cplusplus */

#endif 	/* __DXLUTBuilder_FWD_DEFINED__ */


#ifndef __DXTGradientD_FWD_DEFINED__
#define __DXTGradientD_FWD_DEFINED__

#ifdef __cplusplus
typedef class DXTGradientD DXTGradientD;
#else
typedef struct DXTGradientD DXTGradientD;
#endif /* __cplusplus */

#endif 	/* __DXTGradientD_FWD_DEFINED__ */


#ifndef __DXTWipe_FWD_DEFINED__
#define __DXTWipe_FWD_DEFINED__

#ifdef __cplusplus
typedef class DXTWipe DXTWipe;
#else
typedef struct DXTWipe DXTWipe;
#endif /* __cplusplus */

#endif 	/* __DXTWipe_FWD_DEFINED__ */


#ifndef __DXTConvolution_FWD_DEFINED__
#define __DXTConvolution_FWD_DEFINED__

#ifdef __cplusplus
typedef class DXTConvolution DXTConvolution;
#else
typedef struct DXTConvolution DXTConvolution;
#endif /* __cplusplus */

#endif 	/* __DXTConvolution_FWD_DEFINED__ */


#ifndef __CrBlur_FWD_DEFINED__
#define __CrBlur_FWD_DEFINED__

#ifdef __cplusplus
typedef class CrBlur CrBlur;
#else
typedef struct CrBlur CrBlur;
#endif /* __cplusplus */

#endif 	/* __CrBlur_FWD_DEFINED__ */


#ifndef __CrEmboss_FWD_DEFINED__
#define __CrEmboss_FWD_DEFINED__

#ifdef __cplusplus
typedef class CrEmboss CrEmboss;
#else
typedef struct CrEmboss CrEmboss;
#endif /* __cplusplus */

#endif 	/* __CrEmboss_FWD_DEFINED__ */


#ifndef __CrEngrave_FWD_DEFINED__
#define __CrEngrave_FWD_DEFINED__

#ifdef __cplusplus
typedef class CrEngrave CrEngrave;
#else
typedef struct CrEngrave CrEngrave;
#endif /* __cplusplus */

#endif 	/* __CrEngrave_FWD_DEFINED__ */


#ifndef __DXFade_FWD_DEFINED__
#define __DXFade_FWD_DEFINED__

#ifdef __cplusplus
typedef class DXFade DXFade;
#else
typedef struct DXFade DXFade;
#endif /* __cplusplus */

#endif 	/* __DXFade_FWD_DEFINED__ */


#ifndef __FadePP_FWD_DEFINED__
#define __FadePP_FWD_DEFINED__

#ifdef __cplusplus
typedef class FadePP FadePP;
#else
typedef struct FadePP FadePP;
#endif /* __cplusplus */

#endif 	/* __FadePP_FWD_DEFINED__ */


#ifndef __BasicImageEffects_FWD_DEFINED__
#define __BasicImageEffects_FWD_DEFINED__

#ifdef __cplusplus
typedef class BasicImageEffects BasicImageEffects;
#else
typedef struct BasicImageEffects BasicImageEffects;
#endif /* __cplusplus */

#endif 	/* __BasicImageEffects_FWD_DEFINED__ */


#ifndef __BasicImageEffectsPP_FWD_DEFINED__
#define __BasicImageEffectsPP_FWD_DEFINED__

#ifdef __cplusplus
typedef class BasicImageEffectsPP BasicImageEffectsPP;
#else
typedef struct BasicImageEffectsPP BasicImageEffectsPP;
#endif /* __cplusplus */

#endif 	/* __BasicImageEffectsPP_FWD_DEFINED__ */


#ifndef __Pixelate_FWD_DEFINED__
#define __Pixelate_FWD_DEFINED__

#ifdef __cplusplus
typedef class Pixelate Pixelate;
#else
typedef struct Pixelate Pixelate;
#endif /* __cplusplus */

#endif 	/* __Pixelate_FWD_DEFINED__ */


#ifndef __PixelatePP_FWD_DEFINED__
#define __PixelatePP_FWD_DEFINED__

#ifdef __cplusplus
typedef class PixelatePP PixelatePP;
#else
typedef struct PixelatePP PixelatePP;
#endif /* __cplusplus */

#endif 	/* __PixelatePP_FWD_DEFINED__ */


#ifndef __DXTWipePP_FWD_DEFINED__
#define __DXTWipePP_FWD_DEFINED__

#ifdef __cplusplus
typedef class DXTWipePP DXTWipePP;
#else
typedef struct DXTWipePP DXTWipePP;
#endif /* __cplusplus */

#endif 	/* __DXTWipePP_FWD_DEFINED__ */


#ifndef __CrBlurPP_FWD_DEFINED__
#define __CrBlurPP_FWD_DEFINED__

#ifdef __cplusplus
typedef class CrBlurPP CrBlurPP;
#else
typedef struct CrBlurPP CrBlurPP;
#endif /* __cplusplus */

#endif 	/* __CrBlurPP_FWD_DEFINED__ */


#ifndef __GradientPP_FWD_DEFINED__
#define __GradientPP_FWD_DEFINED__

#ifdef __cplusplus
typedef class GradientPP GradientPP;
#else
typedef struct GradientPP GradientPP;
#endif /* __cplusplus */

#endif 	/* __GradientPP_FWD_DEFINED__ */


#ifndef __CompositePP_FWD_DEFINED__
#define __CompositePP_FWD_DEFINED__

#ifdef __cplusplus
typedef class CompositePP CompositePP;
#else
typedef struct CompositePP CompositePP;
#endif /* __cplusplus */

#endif 	/* __CompositePP_FWD_DEFINED__ */


#ifndef __ConvolvePP_FWD_DEFINED__
#define __ConvolvePP_FWD_DEFINED__

#ifdef __cplusplus
typedef class ConvolvePP ConvolvePP;
#else
typedef struct ConvolvePP ConvolvePP;
#endif /* __cplusplus */

#endif 	/* __ConvolvePP_FWD_DEFINED__ */


#ifndef __LUTBuilderPP_FWD_DEFINED__
#define __LUTBuilderPP_FWD_DEFINED__

#ifdef __cplusplus
typedef class LUTBuilderPP LUTBuilderPP;
#else
typedef struct LUTBuilderPP LUTBuilderPP;
#endif /* __cplusplus */

#endif 	/* __LUTBuilderPP_FWD_DEFINED__ */


#ifndef __CrIris_FWD_DEFINED__
#define __CrIris_FWD_DEFINED__

#ifdef __cplusplus
typedef class CrIris CrIris;
#else
typedef struct CrIris CrIris;
#endif /* __cplusplus */

#endif 	/* __CrIris_FWD_DEFINED__ */


#ifndef __CrIrisPP_FWD_DEFINED__
#define __CrIrisPP_FWD_DEFINED__

#ifdef __cplusplus
typedef class CrIrisPP CrIrisPP;
#else
typedef struct CrIrisPP CrIrisPP;
#endif /* __cplusplus */

#endif 	/* __CrIrisPP_FWD_DEFINED__ */


#ifndef __CrSlide_FWD_DEFINED__
#define __CrSlide_FWD_DEFINED__

#ifdef __cplusplus
typedef class CrSlide CrSlide;
#else
typedef struct CrSlide CrSlide;
#endif /* __cplusplus */

#endif 	/* __CrSlide_FWD_DEFINED__ */


#ifndef __CrSlidePP_FWD_DEFINED__
#define __CrSlidePP_FWD_DEFINED__

#ifdef __cplusplus
typedef class CrSlidePP CrSlidePP;
#else
typedef struct CrSlidePP CrSlidePP;
#endif /* __cplusplus */

#endif 	/* __CrSlidePP_FWD_DEFINED__ */


#ifndef __CrRadialWipe_FWD_DEFINED__
#define __CrRadialWipe_FWD_DEFINED__

#ifdef __cplusplus
typedef class CrRadialWipe CrRadialWipe;
#else
typedef struct CrRadialWipe CrRadialWipe;
#endif /* __cplusplus */

#endif 	/* __CrRadialWipe_FWD_DEFINED__ */


#ifndef __CrRadialWipePP_FWD_DEFINED__
#define __CrRadialWipePP_FWD_DEFINED__

#ifdef __cplusplus
typedef class CrRadialWipePP CrRadialWipePP;
#else
typedef struct CrRadialWipePP CrRadialWipePP;
#endif /* __cplusplus */

#endif 	/* __CrRadialWipePP_FWD_DEFINED__ */


#ifndef __CrBarn_FWD_DEFINED__
#define __CrBarn_FWD_DEFINED__

#ifdef __cplusplus
typedef class CrBarn CrBarn;
#else
typedef struct CrBarn CrBarn;
#endif /* __cplusplus */

#endif 	/* __CrBarn_FWD_DEFINED__ */


#ifndef __CrBlinds_FWD_DEFINED__
#define __CrBlinds_FWD_DEFINED__

#ifdef __cplusplus
typedef class CrBlinds CrBlinds;
#else
typedef struct CrBlinds CrBlinds;
#endif /* __cplusplus */

#endif 	/* __CrBlinds_FWD_DEFINED__ */


#ifndef __CrBlindPP_FWD_DEFINED__
#define __CrBlindPP_FWD_DEFINED__

#ifdef __cplusplus
typedef class CrBlindPP CrBlindPP;
#else
typedef struct CrBlindPP CrBlindPP;
#endif /* __cplusplus */

#endif 	/* __CrBlindPP_FWD_DEFINED__ */


#ifndef __CrStretch_FWD_DEFINED__
#define __CrStretch_FWD_DEFINED__

#ifdef __cplusplus
typedef class CrStretch CrStretch;
#else
typedef struct CrStretch CrStretch;
#endif /* __cplusplus */

#endif 	/* __CrStretch_FWD_DEFINED__ */


#ifndef __CrStretchPP_FWD_DEFINED__
#define __CrStretchPP_FWD_DEFINED__

#ifdef __cplusplus
typedef class CrStretchPP CrStretchPP;
#else
typedef struct CrStretchPP CrStretchPP;
#endif /* __cplusplus */

#endif 	/* __CrStretchPP_FWD_DEFINED__ */


#ifndef __CrInset_FWD_DEFINED__
#define __CrInset_FWD_DEFINED__

#ifdef __cplusplus
typedef class CrInset CrInset;
#else
typedef struct CrInset CrInset;
#endif /* __cplusplus */

#endif 	/* __CrInset_FWD_DEFINED__ */


#ifndef __CrSpiral_FWD_DEFINED__
#define __CrSpiral_FWD_DEFINED__

#ifdef __cplusplus
typedef class CrSpiral CrSpiral;
#else
typedef struct CrSpiral CrSpiral;
#endif /* __cplusplus */

#endif 	/* __CrSpiral_FWD_DEFINED__ */


#ifndef __CrSpiralPP_FWD_DEFINED__
#define __CrSpiralPP_FWD_DEFINED__

#ifdef __cplusplus
typedef class CrSpiralPP CrSpiralPP;
#else
typedef struct CrSpiralPP CrSpiralPP;
#endif /* __cplusplus */

#endif 	/* __CrSpiralPP_FWD_DEFINED__ */


#ifndef __CrZigzag_FWD_DEFINED__
#define __CrZigzag_FWD_DEFINED__

#ifdef __cplusplus
typedef class CrZigzag CrZigzag;
#else
typedef struct CrZigzag CrZigzag;
#endif /* __cplusplus */

#endif 	/* __CrZigzag_FWD_DEFINED__ */


#ifndef __CrZigzagPP_FWD_DEFINED__
#define __CrZigzagPP_FWD_DEFINED__

#ifdef __cplusplus
typedef class CrZigzagPP CrZigzagPP;
#else
typedef struct CrZigzagPP CrZigzagPP;
#endif /* __cplusplus */

#endif 	/* __CrZigzagPP_FWD_DEFINED__ */


#ifndef __CrWheel_FWD_DEFINED__
#define __CrWheel_FWD_DEFINED__

#ifdef __cplusplus
typedef class CrWheel CrWheel;
#else
typedef struct CrWheel CrWheel;
#endif /* __cplusplus */

#endif 	/* __CrWheel_FWD_DEFINED__ */


#ifndef __CrWheelPP_FWD_DEFINED__
#define __CrWheelPP_FWD_DEFINED__

#ifdef __cplusplus
typedef class CrWheelPP CrWheelPP;
#else
typedef struct CrWheelPP CrWheelPP;
#endif /* __cplusplus */

#endif 	/* __CrWheelPP_FWD_DEFINED__ */


#ifndef __DXTChroma_FWD_DEFINED__
#define __DXTChroma_FWD_DEFINED__

#ifdef __cplusplus
typedef class DXTChroma DXTChroma;
#else
typedef struct DXTChroma DXTChroma;
#endif /* __cplusplus */

#endif 	/* __DXTChroma_FWD_DEFINED__ */


#ifndef __DXTChromaPP_FWD_DEFINED__
#define __DXTChromaPP_FWD_DEFINED__

#ifdef __cplusplus
typedef class DXTChromaPP DXTChromaPP;
#else
typedef struct DXTChromaPP DXTChromaPP;
#endif /* __cplusplus */

#endif 	/* __DXTChromaPP_FWD_DEFINED__ */


#ifndef __DXTDropShadow_FWD_DEFINED__
#define __DXTDropShadow_FWD_DEFINED__

#ifdef __cplusplus
typedef class DXTDropShadow DXTDropShadow;
#else
typedef struct DXTDropShadow DXTDropShadow;
#endif /* __cplusplus */

#endif 	/* __DXTDropShadow_FWD_DEFINED__ */


#ifndef __DXTDropShadowPP_FWD_DEFINED__
#define __DXTDropShadowPP_FWD_DEFINED__

#ifdef __cplusplus
typedef class DXTDropShadowPP DXTDropShadowPP;
#else
typedef struct DXTDropShadowPP DXTDropShadowPP;
#endif /* __cplusplus */

#endif 	/* __DXTDropShadowPP_FWD_DEFINED__ */


#ifndef __DXTMetaRoll_FWD_DEFINED__
#define __DXTMetaRoll_FWD_DEFINED__

#ifdef __cplusplus
typedef class DXTMetaRoll DXTMetaRoll;
#else
typedef struct DXTMetaRoll DXTMetaRoll;
#endif /* __cplusplus */

#endif 	/* __DXTMetaRoll_FWD_DEFINED__ */


#ifndef __DXTMetaRipple_FWD_DEFINED__
#define __DXTMetaRipple_FWD_DEFINED__

#ifdef __cplusplus
typedef class DXTMetaRipple DXTMetaRipple;
#else
typedef struct DXTMetaRipple DXTMetaRipple;
#endif /* __cplusplus */

#endif 	/* __DXTMetaRipple_FWD_DEFINED__ */


#ifndef __DXTMetaPageTurn_FWD_DEFINED__
#define __DXTMetaPageTurn_FWD_DEFINED__

#ifdef __cplusplus
typedef class DXTMetaPageTurn DXTMetaPageTurn;
#else
typedef struct DXTMetaPageTurn DXTMetaPageTurn;
#endif /* __cplusplus */

#endif 	/* __DXTMetaPageTurn_FWD_DEFINED__ */


#ifndef __DXTMetaLiquid_FWD_DEFINED__
#define __DXTMetaLiquid_FWD_DEFINED__

#ifdef __cplusplus
typedef class DXTMetaLiquid DXTMetaLiquid;
#else
typedef struct DXTMetaLiquid DXTMetaLiquid;
#endif /* __cplusplus */

#endif 	/* __DXTMetaLiquid_FWD_DEFINED__ */


#ifndef __DXTMetaCenterPeel_FWD_DEFINED__
#define __DXTMetaCenterPeel_FWD_DEFINED__

#ifdef __cplusplus
typedef class DXTMetaCenterPeel DXTMetaCenterPeel;
#else
typedef struct DXTMetaCenterPeel DXTMetaCenterPeel;
#endif /* __cplusplus */

#endif 	/* __DXTMetaCenterPeel_FWD_DEFINED__ */


#ifndef __DXTMetaPeelSmall_FWD_DEFINED__
#define __DXTMetaPeelSmall_FWD_DEFINED__

#ifdef __cplusplus
typedef class DXTMetaPeelSmall DXTMetaPeelSmall;
#else
typedef struct DXTMetaPeelSmall DXTMetaPeelSmall;
#endif /* __cplusplus */

#endif 	/* __DXTMetaPeelSmall_FWD_DEFINED__ */


#ifndef __DXTMetaPeelPiece_FWD_DEFINED__
#define __DXTMetaPeelPiece_FWD_DEFINED__

#ifdef __cplusplus
typedef class DXTMetaPeelPiece DXTMetaPeelPiece;
#else
typedef struct DXTMetaPeelPiece DXTMetaPeelPiece;
#endif /* __cplusplus */

#endif 	/* __DXTMetaPeelPiece_FWD_DEFINED__ */


#ifndef __DXTMetaPeelSplit_FWD_DEFINED__
#define __DXTMetaPeelSplit_FWD_DEFINED__

#ifdef __cplusplus
typedef class DXTMetaPeelSplit DXTMetaPeelSplit;
#else
typedef struct DXTMetaPeelSplit DXTMetaPeelSplit;
#endif /* __cplusplus */

#endif 	/* __DXTMetaPeelSplit_FWD_DEFINED__ */


#ifndef __DXTMetaWater_FWD_DEFINED__
#define __DXTMetaWater_FWD_DEFINED__

#ifdef __cplusplus
typedef class DXTMetaWater DXTMetaWater;
#else
typedef struct DXTMetaWater DXTMetaWater;
#endif /* __cplusplus */

#endif 	/* __DXTMetaWater_FWD_DEFINED__ */


#ifndef __DXTMetaLightWipe_FWD_DEFINED__
#define __DXTMetaLightWipe_FWD_DEFINED__

#ifdef __cplusplus
typedef class DXTMetaLightWipe DXTMetaLightWipe;
#else
typedef struct DXTMetaLightWipe DXTMetaLightWipe;
#endif /* __cplusplus */

#endif 	/* __DXTMetaLightWipe_FWD_DEFINED__ */


#ifndef __DXTMetaRadialScaleWipe_FWD_DEFINED__
#define __DXTMetaRadialScaleWipe_FWD_DEFINED__

#ifdef __cplusplus
typedef class DXTMetaRadialScaleWipe DXTMetaRadialScaleWipe;
#else
typedef struct DXTMetaRadialScaleWipe DXTMetaRadialScaleWipe;
#endif /* __cplusplus */

#endif 	/* __DXTMetaRadialScaleWipe_FWD_DEFINED__ */


#ifndef __DXTMetaWhiteOut_FWD_DEFINED__
#define __DXTMetaWhiteOut_FWD_DEFINED__

#ifdef __cplusplus
typedef class DXTMetaWhiteOut DXTMetaWhiteOut;
#else
typedef struct DXTMetaWhiteOut DXTMetaWhiteOut;
#endif /* __cplusplus */

#endif 	/* __DXTMetaWhiteOut_FWD_DEFINED__ */


#ifndef __DXTMetaTwister_FWD_DEFINED__
#define __DXTMetaTwister_FWD_DEFINED__

#ifdef __cplusplus
typedef class DXTMetaTwister DXTMetaTwister;
#else
typedef struct DXTMetaTwister DXTMetaTwister;
#endif /* __cplusplus */

#endif 	/* __DXTMetaTwister_FWD_DEFINED__ */


#ifndef __DXTMetaBurnFilm_FWD_DEFINED__
#define __DXTMetaBurnFilm_FWD_DEFINED__

#ifdef __cplusplus
typedef class DXTMetaBurnFilm DXTMetaBurnFilm;
#else
typedef struct DXTMetaBurnFilm DXTMetaBurnFilm;
#endif /* __cplusplus */

#endif 	/* __DXTMetaBurnFilm_FWD_DEFINED__ */


#ifndef __DXTMetaJaws_FWD_DEFINED__
#define __DXTMetaJaws_FWD_DEFINED__

#ifdef __cplusplus
typedef class DXTMetaJaws DXTMetaJaws;
#else
typedef struct DXTMetaJaws DXTMetaJaws;
#endif /* __cplusplus */

#endif 	/* __DXTMetaJaws_FWD_DEFINED__ */


#ifndef __DXTMetaColorFade_FWD_DEFINED__
#define __DXTMetaColorFade_FWD_DEFINED__

#ifdef __cplusplus
typedef class DXTMetaColorFade DXTMetaColorFade;
#else
typedef struct DXTMetaColorFade DXTMetaColorFade;
#endif /* __cplusplus */

#endif 	/* __DXTMetaColorFade_FWD_DEFINED__ */


#ifndef __DXTMetaFlowMotion_FWD_DEFINED__
#define __DXTMetaFlowMotion_FWD_DEFINED__

#ifdef __cplusplus
typedef class DXTMetaFlowMotion DXTMetaFlowMotion;
#else
typedef struct DXTMetaFlowMotion DXTMetaFlowMotion;
#endif /* __cplusplus */

#endif 	/* __DXTMetaFlowMotion_FWD_DEFINED__ */


#ifndef __DXTMetaVacuum_FWD_DEFINED__
#define __DXTMetaVacuum_FWD_DEFINED__

#ifdef __cplusplus
typedef class DXTMetaVacuum DXTMetaVacuum;
#else
typedef struct DXTMetaVacuum DXTMetaVacuum;
#endif /* __cplusplus */

#endif 	/* __DXTMetaVacuum_FWD_DEFINED__ */


#ifndef __DXTMetaGriddler_FWD_DEFINED__
#define __DXTMetaGriddler_FWD_DEFINED__

#ifdef __cplusplus
typedef class DXTMetaGriddler DXTMetaGriddler;
#else
typedef struct DXTMetaGriddler DXTMetaGriddler;
#endif /* __cplusplus */

#endif 	/* __DXTMetaGriddler_FWD_DEFINED__ */


#ifndef __DXTMetaGriddler2_FWD_DEFINED__
#define __DXTMetaGriddler2_FWD_DEFINED__

#ifdef __cplusplus
typedef class DXTMetaGriddler2 DXTMetaGriddler2;
#else
typedef struct DXTMetaGriddler2 DXTMetaGriddler2;
#endif /* __cplusplus */

#endif 	/* __DXTMetaGriddler2_FWD_DEFINED__ */


#ifndef __DXTMetaThreshold_FWD_DEFINED__
#define __DXTMetaThreshold_FWD_DEFINED__

#ifdef __cplusplus
typedef class DXTMetaThreshold DXTMetaThreshold;
#else
typedef struct DXTMetaThreshold DXTMetaThreshold;
#endif /* __cplusplus */

#endif 	/* __DXTMetaThreshold_FWD_DEFINED__ */


#ifndef __DXTMetaWormHole_FWD_DEFINED__
#define __DXTMetaWormHole_FWD_DEFINED__

#ifdef __cplusplus
typedef class DXTMetaWormHole DXTMetaWormHole;
#else
typedef struct DXTMetaWormHole DXTMetaWormHole;
#endif /* __cplusplus */

#endif 	/* __DXTMetaWormHole_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"
#include "dxtrans.h"

#ifdef __cplusplus
extern "C"{
#endif 

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

/* interface __MIDL_itf_dxtmsft_0000 */
/* [local] */ 

#include <dxtmsft3.h>






typedef 
enum OPIDDXLUTBUILDER
    {	OPID_DXLUTBUILDER_Gamma	= 0,
	OPID_DXLUTBUILDER_Opacity	= OPID_DXLUTBUILDER_Gamma + 1,
	OPID_DXLUTBUILDER_Brightness	= OPID_DXLUTBUILDER_Opacity + 1,
	OPID_DXLUTBUILDER_Contrast	= OPID_DXLUTBUILDER_Brightness + 1,
	OPID_DXLUTBUILDER_ColorBalance	= OPID_DXLUTBUILDER_Contrast + 1,
	OPID_DXLUTBUILDER_Posterize	= OPID_DXLUTBUILDER_ColorBalance + 1,
	OPID_DXLUTBUILDER_Invert	= OPID_DXLUTBUILDER_Posterize + 1,
	OPID_DXLUTBUILDER_Threshold	= OPID_DXLUTBUILDER_Invert + 1,
	OPID_DXLUTBUILDER_NUM_OPS	= OPID_DXLUTBUILDER_Threshold + 1
    }	OPIDDXLUTBUILDER;

typedef 
enum DXLUTCOLOR
    {	DXLUTCOLOR_RED	= 0,
	DXLUTCOLOR_GREEN	= DXLUTCOLOR_RED + 1,
	DXLUTCOLOR_BLUE	= DXLUTCOLOR_GREEN + 1
    }	DXLUTCOLOR;



extern RPC_IF_HANDLE __MIDL_itf_dxtmsft_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_dxtmsft_0000_v0_0_s_ifspec;

#ifndef __IDXLUTBuilder_INTERFACE_DEFINED__
#define __IDXLUTBuilder_INTERFACE_DEFINED__

/* interface IDXLUTBuilder */
/* [object][unique][helpstring][uuid] */ 


EXTERN_C const IID IID_IDXLUTBuilder;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("F4370FC1-CADB-11D0-B52C-00A0C9054373")
    IDXLUTBuilder : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetNumBuildSteps( 
            /* [out] */ ULONG __RPC_FAR *pulNumSteps) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetBuildOrder( 
            /* [size_is][out] */ OPIDDXLUTBUILDER __RPC_FAR OpOrder[  ],
            /* [in] */ ULONG ulSize) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetBuildOrder( 
            /* [size_is][in] */ const OPIDDXLUTBUILDER __RPC_FAR OpOrder[  ],
            /* [in] */ ULONG ulNumSteps) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetGamma( 
            /* [in] */ float newVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetGamma( 
            /* [out] */ float __RPC_FAR *pVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetOpacity( 
            /* [out] */ float __RPC_FAR *pVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetOpacity( 
            /* [in] */ float newVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetBrightness( 
            /* [out][in] */ ULONG __RPC_FAR *pulCount,
            /* [size_is][out] */ float __RPC_FAR Weights[  ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetBrightness( 
            /* [in] */ ULONG ulCount,
            /* [size_is][in] */ const float __RPC_FAR Weights[  ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetContrast( 
            /* [out][in] */ ULONG __RPC_FAR *pulCount,
            /* [size_is][out] */ float __RPC_FAR Weights[  ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetContrast( 
            /* [in] */ ULONG ulCount,
            /* [size_is][in] */ const float __RPC_FAR Weights[  ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetColorBalance( 
            /* [in] */ DXLUTCOLOR Color,
            /* [out][in] */ ULONG __RPC_FAR *pulCount,
            /* [size_is][out] */ float __RPC_FAR Weights[  ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetColorBalance( 
            /* [in] */ DXLUTCOLOR Color,
            /* [in] */ ULONG ulCount,
            /* [size_is][in] */ const float __RPC_FAR Weights[  ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetLevelsPerChannel( 
            /* [out] */ ULONG __RPC_FAR *pVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetLevelsPerChannel( 
            /* [in] */ ULONG newVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetInvert( 
            /* [out] */ float __RPC_FAR *pThreshold) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetInvert( 
            /* [in] */ float Threshold) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetThreshold( 
            /* [out] */ float __RPC_FAR *pVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetThreshold( 
            /* [in] */ float newVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDXLUTBuilderVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDXLUTBuilder __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDXLUTBuilder __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDXLUTBuilder __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetNumBuildSteps )( 
            IDXLUTBuilder __RPC_FAR * This,
            /* [out] */ ULONG __RPC_FAR *pulNumSteps);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetBuildOrder )( 
            IDXLUTBuilder __RPC_FAR * This,
            /* [size_is][out] */ OPIDDXLUTBUILDER __RPC_FAR OpOrder[  ],
            /* [in] */ ULONG ulSize);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetBuildOrder )( 
            IDXLUTBuilder __RPC_FAR * This,
            /* [size_is][in] */ const OPIDDXLUTBUILDER __RPC_FAR OpOrder[  ],
            /* [in] */ ULONG ulNumSteps);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetGamma )( 
            IDXLUTBuilder __RPC_FAR * This,
            /* [in] */ float newVal);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetGamma )( 
            IDXLUTBuilder __RPC_FAR * This,
            /* [out] */ float __RPC_FAR *pVal);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetOpacity )( 
            IDXLUTBuilder __RPC_FAR * This,
            /* [out] */ float __RPC_FAR *pVal);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetOpacity )( 
            IDXLUTBuilder __RPC_FAR * This,
            /* [in] */ float newVal);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetBrightness )( 
            IDXLUTBuilder __RPC_FAR * This,
            /* [out][in] */ ULONG __RPC_FAR *pulCount,
            /* [size_is][out] */ float __RPC_FAR Weights[  ]);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetBrightness )( 
            IDXLUTBuilder __RPC_FAR * This,
            /* [in] */ ULONG ulCount,
            /* [size_is][in] */ const float __RPC_FAR Weights[  ]);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetContrast )( 
            IDXLUTBuilder __RPC_FAR * This,
            /* [out][in] */ ULONG __RPC_FAR *pulCount,
            /* [size_is][out] */ float __RPC_FAR Weights[  ]);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetContrast )( 
            IDXLUTBuilder __RPC_FAR * This,
            /* [in] */ ULONG ulCount,
            /* [size_is][in] */ const float __RPC_FAR Weights[  ]);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetColorBalance )( 
            IDXLUTBuilder __RPC_FAR * This,
            /* [in] */ DXLUTCOLOR Color,
            /* [out][in] */ ULONG __RPC_FAR *pulCount,
            /* [size_is][out] */ float __RPC_FAR Weights[  ]);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetColorBalance )( 
            IDXLUTBuilder __RPC_FAR * This,
            /* [in] */ DXLUTCOLOR Color,
            /* [in] */ ULONG ulCount,
            /* [size_is][in] */ const float __RPC_FAR Weights[  ]);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetLevelsPerChannel )( 
            IDXLUTBuilder __RPC_FAR * This,
            /* [out] */ ULONG __RPC_FAR *pVal);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetLevelsPerChannel )( 
            IDXLUTBuilder __RPC_FAR * This,
            /* [in] */ ULONG newVal);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetInvert )( 
            IDXLUTBuilder __RPC_FAR * This,
            /* [out] */ float __RPC_FAR *pThreshold);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetInvert )( 
            IDXLUTBuilder __RPC_FAR * This,
            /* [in] */ float Threshold);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetThreshold )( 
            IDXLUTBuilder __RPC_FAR * This,
            /* [out] */ float __RPC_FAR *pVal);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetThreshold )( 
            IDXLUTBuilder __RPC_FAR * This,
            /* [in] */ float newVal);
        
        END_INTERFACE
    } IDXLUTBuilderVtbl;

    interface IDXLUTBuilder
    {
        CONST_VTBL struct IDXLUTBuilderVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDXLUTBuilder_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDXLUTBuilder_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDXLUTBuilder_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDXLUTBuilder_GetNumBuildSteps(This,pulNumSteps)	\
    (This)->lpVtbl -> GetNumBuildSteps(This,pulNumSteps)

#define IDXLUTBuilder_GetBuildOrder(This,OpOrder,ulSize)	\
    (This)->lpVtbl -> GetBuildOrder(This,OpOrder,ulSize)

#define IDXLUTBuilder_SetBuildOrder(This,OpOrder,ulNumSteps)	\
    (This)->lpVtbl -> SetBuildOrder(This,OpOrder,ulNumSteps)

#define IDXLUTBuilder_SetGamma(This,newVal)	\
    (This)->lpVtbl -> SetGamma(This,newVal)

#define IDXLUTBuilder_GetGamma(This,pVal)	\
    (This)->lpVtbl -> GetGamma(This,pVal)

#define IDXLUTBuilder_GetOpacity(This,pVal)	\
    (This)->lpVtbl -> GetOpacity(This,pVal)

#define IDXLUTBuilder_SetOpacity(This,newVal)	\
    (This)->lpVtbl -> SetOpacity(This,newVal)

#define IDXLUTBuilder_GetBrightness(This,pulCount,Weights)	\
    (This)->lpVtbl -> GetBrightness(This,pulCount,Weights)

#define IDXLUTBuilder_SetBrightness(This,ulCount,Weights)	\
    (This)->lpVtbl -> SetBrightness(This,ulCount,Weights)

#define IDXLUTBuilder_GetContrast(This,pulCount,Weights)	\
    (This)->lpVtbl -> GetContrast(This,pulCount,Weights)

#define IDXLUTBuilder_SetContrast(This,ulCount,Weights)	\
    (This)->lpVtbl -> SetContrast(This,ulCount,Weights)

#define IDXLUTBuilder_GetColorBalance(This,Color,pulCount,Weights)	\
    (This)->lpVtbl -> GetColorBalance(This,Color,pulCount,Weights)

#define IDXLUTBuilder_SetColorBalance(This,Color,ulCount,Weights)	\
    (This)->lpVtbl -> SetColorBalance(This,Color,ulCount,Weights)

#define IDXLUTBuilder_GetLevelsPerChannel(This,pVal)	\
    (This)->lpVtbl -> GetLevelsPerChannel(This,pVal)

#define IDXLUTBuilder_SetLevelsPerChannel(This,newVal)	\
    (This)->lpVtbl -> SetLevelsPerChannel(This,newVal)

#define IDXLUTBuilder_GetInvert(This,pThreshold)	\
    (This)->lpVtbl -> GetInvert(This,pThreshold)

#define IDXLUTBuilder_SetInvert(This,Threshold)	\
    (This)->lpVtbl -> SetInvert(This,Threshold)

#define IDXLUTBuilder_GetThreshold(This,pVal)	\
    (This)->lpVtbl -> GetThreshold(This,pVal)

#define IDXLUTBuilder_SetThreshold(This,newVal)	\
    (This)->lpVtbl -> SetThreshold(This,newVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDXLUTBuilder_GetNumBuildSteps_Proxy( 
    IDXLUTBuilder __RPC_FAR * This,
    /* [out] */ ULONG __RPC_FAR *pulNumSteps);


void __RPC_STUB IDXLUTBuilder_GetNumBuildSteps_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXLUTBuilder_GetBuildOrder_Proxy( 
    IDXLUTBuilder __RPC_FAR * This,
    /* [size_is][out] */ OPIDDXLUTBUILDER __RPC_FAR OpOrder[  ],
    /* [in] */ ULONG ulSize);


void __RPC_STUB IDXLUTBuilder_GetBuildOrder_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXLUTBuilder_SetBuildOrder_Proxy( 
    IDXLUTBuilder __RPC_FAR * This,
    /* [size_is][in] */ const OPIDDXLUTBUILDER __RPC_FAR OpOrder[  ],
    /* [in] */ ULONG ulNumSteps);


void __RPC_STUB IDXLUTBuilder_SetBuildOrder_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXLUTBuilder_SetGamma_Proxy( 
    IDXLUTBuilder __RPC_FAR * This,
    /* [in] */ float newVal);


void __RPC_STUB IDXLUTBuilder_SetGamma_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXLUTBuilder_GetGamma_Proxy( 
    IDXLUTBuilder __RPC_FAR * This,
    /* [out] */ float __RPC_FAR *pVal);


void __RPC_STUB IDXLUTBuilder_GetGamma_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXLUTBuilder_GetOpacity_Proxy( 
    IDXLUTBuilder __RPC_FAR * This,
    /* [out] */ float __RPC_FAR *pVal);


void __RPC_STUB IDXLUTBuilder_GetOpacity_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXLUTBuilder_SetOpacity_Proxy( 
    IDXLUTBuilder __RPC_FAR * This,
    /* [in] */ float newVal);


void __RPC_STUB IDXLUTBuilder_SetOpacity_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXLUTBuilder_GetBrightness_Proxy( 
    IDXLUTBuilder __RPC_FAR * This,
    /* [out][in] */ ULONG __RPC_FAR *pulCount,
    /* [size_is][out] */ float __RPC_FAR Weights[  ]);


void __RPC_STUB IDXLUTBuilder_GetBrightness_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXLUTBuilder_SetBrightness_Proxy( 
    IDXLUTBuilder __RPC_FAR * This,
    /* [in] */ ULONG ulCount,
    /* [size_is][in] */ const float __RPC_FAR Weights[  ]);


void __RPC_STUB IDXLUTBuilder_SetBrightness_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXLUTBuilder_GetContrast_Proxy( 
    IDXLUTBuilder __RPC_FAR * This,
    /* [out][in] */ ULONG __RPC_FAR *pulCount,
    /* [size_is][out] */ float __RPC_FAR Weights[  ]);


void __RPC_STUB IDXLUTBuilder_GetContrast_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXLUTBuilder_SetContrast_Proxy( 
    IDXLUTBuilder __RPC_FAR * This,
    /* [in] */ ULONG ulCount,
    /* [size_is][in] */ const float __RPC_FAR Weights[  ]);


void __RPC_STUB IDXLUTBuilder_SetContrast_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXLUTBuilder_GetColorBalance_Proxy( 
    IDXLUTBuilder __RPC_FAR * This,
    /* [in] */ DXLUTCOLOR Color,
    /* [out][in] */ ULONG __RPC_FAR *pulCount,
    /* [size_is][out] */ float __RPC_FAR Weights[  ]);


void __RPC_STUB IDXLUTBuilder_GetColorBalance_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXLUTBuilder_SetColorBalance_Proxy( 
    IDXLUTBuilder __RPC_FAR * This,
    /* [in] */ DXLUTCOLOR Color,
    /* [in] */ ULONG ulCount,
    /* [size_is][in] */ const float __RPC_FAR Weights[  ]);


void __RPC_STUB IDXLUTBuilder_SetColorBalance_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXLUTBuilder_GetLevelsPerChannel_Proxy( 
    IDXLUTBuilder __RPC_FAR * This,
    /* [out] */ ULONG __RPC_FAR *pVal);


void __RPC_STUB IDXLUTBuilder_GetLevelsPerChannel_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXLUTBuilder_SetLevelsPerChannel_Proxy( 
    IDXLUTBuilder __RPC_FAR * This,
    /* [in] */ ULONG newVal);


void __RPC_STUB IDXLUTBuilder_SetLevelsPerChannel_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXLUTBuilder_GetInvert_Proxy( 
    IDXLUTBuilder __RPC_FAR * This,
    /* [out] */ float __RPC_FAR *pThreshold);


void __RPC_STUB IDXLUTBuilder_GetInvert_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXLUTBuilder_SetInvert_Proxy( 
    IDXLUTBuilder __RPC_FAR * This,
    /* [in] */ float Threshold);


void __RPC_STUB IDXLUTBuilder_SetInvert_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXLUTBuilder_GetThreshold_Proxy( 
    IDXLUTBuilder __RPC_FAR * This,
    /* [out] */ float __RPC_FAR *pVal);


void __RPC_STUB IDXLUTBuilder_GetThreshold_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXLUTBuilder_SetThreshold_Proxy( 
    IDXLUTBuilder __RPC_FAR * This,
    /* [in] */ float newVal);


void __RPC_STUB IDXLUTBuilder_SetThreshold_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDXLUTBuilder_INTERFACE_DEFINED__ */


#ifndef __IDXDLUTBuilder_INTERFACE_DEFINED__
#define __IDXDLUTBuilder_INTERFACE_DEFINED__

/* interface IDXDLUTBuilder */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IDXDLUTBuilder;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("73068231-35EE-11d1-81A1-0000F87557DB")
    IDXDLUTBuilder : public IDispatch
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_NumBuildSteps( 
            /* [retval][out] */ long __RPC_FAR *pNumSteps) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_BuildOrder( 
            /* [retval][out] */ VARIANT __RPC_FAR *pOpOrder) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_BuildOrder( 
            /* [in] */ VARIANT __RPC_FAR *pOpOrder) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Gamma( 
            /* [retval][out] */ float __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Gamma( 
            /* [in] */ float newVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Opacity( 
            /* [retval][out] */ float __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Opacity( 
            /* [in] */ float newVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Brightness( 
            /* [retval][out] */ VARIANT __RPC_FAR *pWeights) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Brightness( 
            /* [in] */ VARIANT __RPC_FAR *pWeights) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Contrast( 
            /* [retval][out] */ VARIANT __RPC_FAR *pWeights) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Contrast( 
            /* [in] */ VARIANT __RPC_FAR *pWeights) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_ColorBalance( 
            /* [in] */ DXLUTCOLOR Color,
            /* [retval][out] */ VARIANT __RPC_FAR *pWeights) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_ColorBalance( 
            /* [in] */ DXLUTCOLOR Color,
            /* [in] */ VARIANT __RPC_FAR *pWeights) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_LevelsPerChannel( 
            /* [retval][out] */ long __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_LevelsPerChannel( 
            /* [in] */ long newVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Invert( 
            /* [retval][out] */ float __RPC_FAR *pThreshold) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Invert( 
            /* [in] */ float Threshold) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Threshold( 
            /* [retval][out] */ float __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Threshold( 
            /* [in] */ float newVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDXDLUTBuilderVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDXDLUTBuilder __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDXDLUTBuilder __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDXDLUTBuilder __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IDXDLUTBuilder __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IDXDLUTBuilder __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IDXDLUTBuilder __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IDXDLUTBuilder __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_NumBuildSteps )( 
            IDXDLUTBuilder __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pNumSteps);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_BuildOrder )( 
            IDXDLUTBuilder __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *pOpOrder);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_BuildOrder )( 
            IDXDLUTBuilder __RPC_FAR * This,
            /* [in] */ VARIANT __RPC_FAR *pOpOrder);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Gamma )( 
            IDXDLUTBuilder __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Gamma )( 
            IDXDLUTBuilder __RPC_FAR * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Opacity )( 
            IDXDLUTBuilder __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Opacity )( 
            IDXDLUTBuilder __RPC_FAR * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Brightness )( 
            IDXDLUTBuilder __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *pWeights);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Brightness )( 
            IDXDLUTBuilder __RPC_FAR * This,
            /* [in] */ VARIANT __RPC_FAR *pWeights);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Contrast )( 
            IDXDLUTBuilder __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *pWeights);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Contrast )( 
            IDXDLUTBuilder __RPC_FAR * This,
            /* [in] */ VARIANT __RPC_FAR *pWeights);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ColorBalance )( 
            IDXDLUTBuilder __RPC_FAR * This,
            /* [in] */ DXLUTCOLOR Color,
            /* [retval][out] */ VARIANT __RPC_FAR *pWeights);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_ColorBalance )( 
            IDXDLUTBuilder __RPC_FAR * This,
            /* [in] */ DXLUTCOLOR Color,
            /* [in] */ VARIANT __RPC_FAR *pWeights);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_LevelsPerChannel )( 
            IDXDLUTBuilder __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_LevelsPerChannel )( 
            IDXDLUTBuilder __RPC_FAR * This,
            /* [in] */ long newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Invert )( 
            IDXDLUTBuilder __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pThreshold);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Invert )( 
            IDXDLUTBuilder __RPC_FAR * This,
            /* [in] */ float Threshold);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Threshold )( 
            IDXDLUTBuilder __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Threshold )( 
            IDXDLUTBuilder __RPC_FAR * This,
            /* [in] */ float newVal);
        
        END_INTERFACE
    } IDXDLUTBuilderVtbl;

    interface IDXDLUTBuilder
    {
        CONST_VTBL struct IDXDLUTBuilderVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDXDLUTBuilder_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDXDLUTBuilder_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDXDLUTBuilder_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDXDLUTBuilder_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IDXDLUTBuilder_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IDXDLUTBuilder_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IDXDLUTBuilder_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IDXDLUTBuilder_get_NumBuildSteps(This,pNumSteps)	\
    (This)->lpVtbl -> get_NumBuildSteps(This,pNumSteps)

#define IDXDLUTBuilder_get_BuildOrder(This,pOpOrder)	\
    (This)->lpVtbl -> get_BuildOrder(This,pOpOrder)

#define IDXDLUTBuilder_put_BuildOrder(This,pOpOrder)	\
    (This)->lpVtbl -> put_BuildOrder(This,pOpOrder)

#define IDXDLUTBuilder_get_Gamma(This,pVal)	\
    (This)->lpVtbl -> get_Gamma(This,pVal)

#define IDXDLUTBuilder_put_Gamma(This,newVal)	\
    (This)->lpVtbl -> put_Gamma(This,newVal)

#define IDXDLUTBuilder_get_Opacity(This,pVal)	\
    (This)->lpVtbl -> get_Opacity(This,pVal)

#define IDXDLUTBuilder_put_Opacity(This,newVal)	\
    (This)->lpVtbl -> put_Opacity(This,newVal)

#define IDXDLUTBuilder_get_Brightness(This,pWeights)	\
    (This)->lpVtbl -> get_Brightness(This,pWeights)

#define IDXDLUTBuilder_put_Brightness(This,pWeights)	\
    (This)->lpVtbl -> put_Brightness(This,pWeights)

#define IDXDLUTBuilder_get_Contrast(This,pWeights)	\
    (This)->lpVtbl -> get_Contrast(This,pWeights)

#define IDXDLUTBuilder_put_Contrast(This,pWeights)	\
    (This)->lpVtbl -> put_Contrast(This,pWeights)

#define IDXDLUTBuilder_get_ColorBalance(This,Color,pWeights)	\
    (This)->lpVtbl -> get_ColorBalance(This,Color,pWeights)

#define IDXDLUTBuilder_put_ColorBalance(This,Color,pWeights)	\
    (This)->lpVtbl -> put_ColorBalance(This,Color,pWeights)

#define IDXDLUTBuilder_get_LevelsPerChannel(This,pVal)	\
    (This)->lpVtbl -> get_LevelsPerChannel(This,pVal)

#define IDXDLUTBuilder_put_LevelsPerChannel(This,newVal)	\
    (This)->lpVtbl -> put_LevelsPerChannel(This,newVal)

#define IDXDLUTBuilder_get_Invert(This,pThreshold)	\
    (This)->lpVtbl -> get_Invert(This,pThreshold)

#define IDXDLUTBuilder_put_Invert(This,Threshold)	\
    (This)->lpVtbl -> put_Invert(This,Threshold)

#define IDXDLUTBuilder_get_Threshold(This,pVal)	\
    (This)->lpVtbl -> get_Threshold(This,pVal)

#define IDXDLUTBuilder_put_Threshold(This,newVal)	\
    (This)->lpVtbl -> put_Threshold(This,newVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXDLUTBuilder_get_NumBuildSteps_Proxy( 
    IDXDLUTBuilder __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pNumSteps);


void __RPC_STUB IDXDLUTBuilder_get_NumBuildSteps_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXDLUTBuilder_get_BuildOrder_Proxy( 
    IDXDLUTBuilder __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *pOpOrder);


void __RPC_STUB IDXDLUTBuilder_get_BuildOrder_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXDLUTBuilder_put_BuildOrder_Proxy( 
    IDXDLUTBuilder __RPC_FAR * This,
    /* [in] */ VARIANT __RPC_FAR *pOpOrder);


void __RPC_STUB IDXDLUTBuilder_put_BuildOrder_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXDLUTBuilder_get_Gamma_Proxy( 
    IDXDLUTBuilder __RPC_FAR * This,
    /* [retval][out] */ float __RPC_FAR *pVal);


void __RPC_STUB IDXDLUTBuilder_get_Gamma_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXDLUTBuilder_put_Gamma_Proxy( 
    IDXDLUTBuilder __RPC_FAR * This,
    /* [in] */ float newVal);


void __RPC_STUB IDXDLUTBuilder_put_Gamma_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXDLUTBuilder_get_Opacity_Proxy( 
    IDXDLUTBuilder __RPC_FAR * This,
    /* [retval][out] */ float __RPC_FAR *pVal);


void __RPC_STUB IDXDLUTBuilder_get_Opacity_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXDLUTBuilder_put_Opacity_Proxy( 
    IDXDLUTBuilder __RPC_FAR * This,
    /* [in] */ float newVal);


void __RPC_STUB IDXDLUTBuilder_put_Opacity_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXDLUTBuilder_get_Brightness_Proxy( 
    IDXDLUTBuilder __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *pWeights);


void __RPC_STUB IDXDLUTBuilder_get_Brightness_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXDLUTBuilder_put_Brightness_Proxy( 
    IDXDLUTBuilder __RPC_FAR * This,
    /* [in] */ VARIANT __RPC_FAR *pWeights);


void __RPC_STUB IDXDLUTBuilder_put_Brightness_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXDLUTBuilder_get_Contrast_Proxy( 
    IDXDLUTBuilder __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *pWeights);


void __RPC_STUB IDXDLUTBuilder_get_Contrast_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXDLUTBuilder_put_Contrast_Proxy( 
    IDXDLUTBuilder __RPC_FAR * This,
    /* [in] */ VARIANT __RPC_FAR *pWeights);


void __RPC_STUB IDXDLUTBuilder_put_Contrast_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXDLUTBuilder_get_ColorBalance_Proxy( 
    IDXDLUTBuilder __RPC_FAR * This,
    /* [in] */ DXLUTCOLOR Color,
    /* [retval][out] */ VARIANT __RPC_FAR *pWeights);


void __RPC_STUB IDXDLUTBuilder_get_ColorBalance_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXDLUTBuilder_put_ColorBalance_Proxy( 
    IDXDLUTBuilder __RPC_FAR * This,
    /* [in] */ DXLUTCOLOR Color,
    /* [in] */ VARIANT __RPC_FAR *pWeights);


void __RPC_STUB IDXDLUTBuilder_put_ColorBalance_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXDLUTBuilder_get_LevelsPerChannel_Proxy( 
    IDXDLUTBuilder __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pVal);


void __RPC_STUB IDXDLUTBuilder_get_LevelsPerChannel_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXDLUTBuilder_put_LevelsPerChannel_Proxy( 
    IDXDLUTBuilder __RPC_FAR * This,
    /* [in] */ long newVal);


void __RPC_STUB IDXDLUTBuilder_put_LevelsPerChannel_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXDLUTBuilder_get_Invert_Proxy( 
    IDXDLUTBuilder __RPC_FAR * This,
    /* [retval][out] */ float __RPC_FAR *pThreshold);


void __RPC_STUB IDXDLUTBuilder_get_Invert_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXDLUTBuilder_put_Invert_Proxy( 
    IDXDLUTBuilder __RPC_FAR * This,
    /* [in] */ float Threshold);


void __RPC_STUB IDXDLUTBuilder_put_Invert_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXDLUTBuilder_get_Threshold_Proxy( 
    IDXDLUTBuilder __RPC_FAR * This,
    /* [retval][out] */ float __RPC_FAR *pVal);


void __RPC_STUB IDXDLUTBuilder_get_Threshold_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXDLUTBuilder_put_Threshold_Proxy( 
    IDXDLUTBuilder __RPC_FAR * This,
    /* [in] */ float newVal);


void __RPC_STUB IDXDLUTBuilder_put_Threshold_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDXDLUTBuilder_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_dxtmsft_0281 */
/* [local] */ 

typedef 
enum DXGRADIENTTYPE
    {	DXGRADIENT_VERTICAL	= 0,
	DXGRADIENT_HORIZONTAL	= DXGRADIENT_VERTICAL + 1,
	DXGRADIENT_NUM_GRADIENTS	= DXGRADIENT_HORIZONTAL + 1
    }	DXGRADIENTTYPE;

typedef 
enum DXGRADDISPID
    {	DISPID_GradientType	= 1,
	DISPID_StartColor	= DISPID_GradientType + 1,
	DISPID_EndColor	= DISPID_StartColor + 1,
	DISPID_GradientWidth	= DISPID_EndColor + 1,
	DISPID_GradientHeight	= DISPID_GradientWidth + 1,
	DISPID_GradientAspect	= DISPID_GradientHeight + 1,
	DISPID_StartColorStr	= DISPID_GradientAspect + 1,
	DISPID_EndColorStr	= DISPID_StartColorStr + 1
    }	DXGRADDISPID;



extern RPC_IF_HANDLE __MIDL_itf_dxtmsft_0281_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_dxtmsft_0281_v0_0_s_ifspec;

#ifndef __IDXTGradientD_INTERFACE_DEFINED__
#define __IDXTGradientD_INTERFACE_DEFINED__

/* interface IDXTGradientD */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IDXTGradientD;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("623E2881-FC0E-11d1-9A77-0000F8756A10")
    IDXTGradientD : public IDispatch
    {
    public:
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_GradientType( 
            /* [in] */ DXGRADIENTTYPE eType) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_GradientType( 
            /* [retval][out] */ DXGRADIENTTYPE __RPC_FAR *peType) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_StartColor( 
            /* [in] */ OLE_COLOR newVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_StartColor( 
            /* [retval][out] */ OLE_COLOR __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_EndColor( 
            /* [in] */ OLE_COLOR newVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_EndColor( 
            /* [retval][out] */ OLE_COLOR __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_GradientWidth( 
            /* [in] */ long newVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_GradientWidth( 
            /* [retval][out] */ long __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_GradientHeight( 
            /* [in] */ long newVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_GradientHeight( 
            /* [retval][out] */ long __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_KeepAspectRatio( 
            /* [in] */ VARIANT_BOOL newVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_KeepAspectRatio( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_StartColorStr( 
            /* [in] */ BSTR newVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_EndColorStr( 
            /* [in] */ BSTR newVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDXTGradientDVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDXTGradientD __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDXTGradientD __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDXTGradientD __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IDXTGradientD __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IDXTGradientD __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IDXTGradientD __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IDXTGradientD __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_GradientType )( 
            IDXTGradientD __RPC_FAR * This,
            /* [in] */ DXGRADIENTTYPE eType);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_GradientType )( 
            IDXTGradientD __RPC_FAR * This,
            /* [retval][out] */ DXGRADIENTTYPE __RPC_FAR *peType);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_StartColor )( 
            IDXTGradientD __RPC_FAR * This,
            /* [in] */ OLE_COLOR newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_StartColor )( 
            IDXTGradientD __RPC_FAR * This,
            /* [retval][out] */ OLE_COLOR __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_EndColor )( 
            IDXTGradientD __RPC_FAR * This,
            /* [in] */ OLE_COLOR newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_EndColor )( 
            IDXTGradientD __RPC_FAR * This,
            /* [retval][out] */ OLE_COLOR __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_GradientWidth )( 
            IDXTGradientD __RPC_FAR * This,
            /* [in] */ long newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_GradientWidth )( 
            IDXTGradientD __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_GradientHeight )( 
            IDXTGradientD __RPC_FAR * This,
            /* [in] */ long newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_GradientHeight )( 
            IDXTGradientD __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_KeepAspectRatio )( 
            IDXTGradientD __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_KeepAspectRatio )( 
            IDXTGradientD __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_StartColorStr )( 
            IDXTGradientD __RPC_FAR * This,
            /* [in] */ BSTR newVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_EndColorStr )( 
            IDXTGradientD __RPC_FAR * This,
            /* [in] */ BSTR newVal);
        
        END_INTERFACE
    } IDXTGradientDVtbl;

    interface IDXTGradientD
    {
        CONST_VTBL struct IDXTGradientDVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDXTGradientD_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDXTGradientD_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDXTGradientD_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDXTGradientD_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IDXTGradientD_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IDXTGradientD_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IDXTGradientD_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IDXTGradientD_put_GradientType(This,eType)	\
    (This)->lpVtbl -> put_GradientType(This,eType)

#define IDXTGradientD_get_GradientType(This,peType)	\
    (This)->lpVtbl -> get_GradientType(This,peType)

#define IDXTGradientD_put_StartColor(This,newVal)	\
    (This)->lpVtbl -> put_StartColor(This,newVal)

#define IDXTGradientD_get_StartColor(This,pVal)	\
    (This)->lpVtbl -> get_StartColor(This,pVal)

#define IDXTGradientD_put_EndColor(This,newVal)	\
    (This)->lpVtbl -> put_EndColor(This,newVal)

#define IDXTGradientD_get_EndColor(This,pVal)	\
    (This)->lpVtbl -> get_EndColor(This,pVal)

#define IDXTGradientD_put_GradientWidth(This,newVal)	\
    (This)->lpVtbl -> put_GradientWidth(This,newVal)

#define IDXTGradientD_get_GradientWidth(This,pVal)	\
    (This)->lpVtbl -> get_GradientWidth(This,pVal)

#define IDXTGradientD_put_GradientHeight(This,newVal)	\
    (This)->lpVtbl -> put_GradientHeight(This,newVal)

#define IDXTGradientD_get_GradientHeight(This,pVal)	\
    (This)->lpVtbl -> get_GradientHeight(This,pVal)

#define IDXTGradientD_put_KeepAspectRatio(This,newVal)	\
    (This)->lpVtbl -> put_KeepAspectRatio(This,newVal)

#define IDXTGradientD_get_KeepAspectRatio(This,pVal)	\
    (This)->lpVtbl -> get_KeepAspectRatio(This,pVal)

#define IDXTGradientD_put_StartColorStr(This,newVal)	\
    (This)->lpVtbl -> put_StartColorStr(This,newVal)

#define IDXTGradientD_put_EndColorStr(This,newVal)	\
    (This)->lpVtbl -> put_EndColorStr(This,newVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTGradientD_put_GradientType_Proxy( 
    IDXTGradientD __RPC_FAR * This,
    /* [in] */ DXGRADIENTTYPE eType);


void __RPC_STUB IDXTGradientD_put_GradientType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTGradientD_get_GradientType_Proxy( 
    IDXTGradientD __RPC_FAR * This,
    /* [retval][out] */ DXGRADIENTTYPE __RPC_FAR *peType);


void __RPC_STUB IDXTGradientD_get_GradientType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTGradientD_put_StartColor_Proxy( 
    IDXTGradientD __RPC_FAR * This,
    /* [in] */ OLE_COLOR newVal);


void __RPC_STUB IDXTGradientD_put_StartColor_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTGradientD_get_StartColor_Proxy( 
    IDXTGradientD __RPC_FAR * This,
    /* [retval][out] */ OLE_COLOR __RPC_FAR *pVal);


void __RPC_STUB IDXTGradientD_get_StartColor_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTGradientD_put_EndColor_Proxy( 
    IDXTGradientD __RPC_FAR * This,
    /* [in] */ OLE_COLOR newVal);


void __RPC_STUB IDXTGradientD_put_EndColor_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTGradientD_get_EndColor_Proxy( 
    IDXTGradientD __RPC_FAR * This,
    /* [retval][out] */ OLE_COLOR __RPC_FAR *pVal);


void __RPC_STUB IDXTGradientD_get_EndColor_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTGradientD_put_GradientWidth_Proxy( 
    IDXTGradientD __RPC_FAR * This,
    /* [in] */ long newVal);


void __RPC_STUB IDXTGradientD_put_GradientWidth_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTGradientD_get_GradientWidth_Proxy( 
    IDXTGradientD __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pVal);


void __RPC_STUB IDXTGradientD_get_GradientWidth_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTGradientD_put_GradientHeight_Proxy( 
    IDXTGradientD __RPC_FAR * This,
    /* [in] */ long newVal);


void __RPC_STUB IDXTGradientD_put_GradientHeight_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTGradientD_get_GradientHeight_Proxy( 
    IDXTGradientD __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pVal);


void __RPC_STUB IDXTGradientD_get_GradientHeight_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTGradientD_put_KeepAspectRatio_Proxy( 
    IDXTGradientD __RPC_FAR * This,
    /* [in] */ VARIANT_BOOL newVal);


void __RPC_STUB IDXTGradientD_put_KeepAspectRatio_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTGradientD_get_KeepAspectRatio_Proxy( 
    IDXTGradientD __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pVal);


void __RPC_STUB IDXTGradientD_get_KeepAspectRatio_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTGradientD_put_StartColorStr_Proxy( 
    IDXTGradientD __RPC_FAR * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IDXTGradientD_put_StartColorStr_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTGradientD_put_EndColorStr_Proxy( 
    IDXTGradientD __RPC_FAR * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IDXTGradientD_put_EndColorStr_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDXTGradientD_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_dxtmsft_0282 */
/* [local] */ 

typedef 
enum DXCONVFILTERTYPE
    {	DXCFILTER_SRCCOPY	= 0,
	DXCFILTER_BOX7X7	= DXCFILTER_SRCCOPY + 1,
	DXCFILTER_BLUR3X3	= DXCFILTER_BOX7X7 + 1,
	DXCFILTER_SHARPEN	= DXCFILTER_BLUR3X3 + 1,
	DXCFILTER_EMBOSS	= DXCFILTER_SHARPEN + 1,
	DXCFILTER_ENGRAVE	= DXCFILTER_EMBOSS + 1,
	DXCFILTER_NUM_FILTERS	= DXCFILTER_ENGRAVE + 1,
	DXCFILTER_CUSTOM	= DXCFILTER_NUM_FILTERS + 1
    }	DXCONVFILTERTYPE;



extern RPC_IF_HANDLE __MIDL_itf_dxtmsft_0282_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_dxtmsft_0282_v0_0_s_ifspec;

#ifndef __IDXTConvolution_INTERFACE_DEFINED__
#define __IDXTConvolution_INTERFACE_DEFINED__

/* interface IDXTConvolution */
/* [object][unique][helpstring][uuid] */ 


EXTERN_C const IID IID_IDXTConvolution;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("7BA7F8AF-E5EA-11d1-81DD-0000F87557DB")
    IDXTConvolution : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetFilterType( 
            /* [in] */ DXCONVFILTERTYPE eType) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFilterType( 
            /* [out] */ DXCONVFILTERTYPE __RPC_FAR *peType) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetCustomFilter( 
            /* [in] */ float __RPC_FAR *pFilter,
            /* [in] */ SIZE Size) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetConvertToGray( 
            /* [in] */ BOOL bConvertToGray) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetConvertToGray( 
            /* [out] */ BOOL __RPC_FAR *pbConvertToGray) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetBias( 
            /* [in] */ float Bias) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetBias( 
            /* [out] */ float __RPC_FAR *pBias) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetExcludeAlpha( 
            /* [in] */ BOOL bExcludeAlpha) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetExcludeAlpha( 
            /* [out] */ BOOL __RPC_FAR *pbExcludeAlpha) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDXTConvolutionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDXTConvolution __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDXTConvolution __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDXTConvolution __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetFilterType )( 
            IDXTConvolution __RPC_FAR * This,
            /* [in] */ DXCONVFILTERTYPE eType);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetFilterType )( 
            IDXTConvolution __RPC_FAR * This,
            /* [out] */ DXCONVFILTERTYPE __RPC_FAR *peType);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetCustomFilter )( 
            IDXTConvolution __RPC_FAR * This,
            /* [in] */ float __RPC_FAR *pFilter,
            /* [in] */ SIZE Size);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetConvertToGray )( 
            IDXTConvolution __RPC_FAR * This,
            /* [in] */ BOOL bConvertToGray);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetConvertToGray )( 
            IDXTConvolution __RPC_FAR * This,
            /* [out] */ BOOL __RPC_FAR *pbConvertToGray);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetBias )( 
            IDXTConvolution __RPC_FAR * This,
            /* [in] */ float Bias);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetBias )( 
            IDXTConvolution __RPC_FAR * This,
            /* [out] */ float __RPC_FAR *pBias);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetExcludeAlpha )( 
            IDXTConvolution __RPC_FAR * This,
            /* [in] */ BOOL bExcludeAlpha);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetExcludeAlpha )( 
            IDXTConvolution __RPC_FAR * This,
            /* [out] */ BOOL __RPC_FAR *pbExcludeAlpha);
        
        END_INTERFACE
    } IDXTConvolutionVtbl;

    interface IDXTConvolution
    {
        CONST_VTBL struct IDXTConvolutionVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDXTConvolution_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDXTConvolution_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDXTConvolution_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDXTConvolution_SetFilterType(This,eType)	\
    (This)->lpVtbl -> SetFilterType(This,eType)

#define IDXTConvolution_GetFilterType(This,peType)	\
    (This)->lpVtbl -> GetFilterType(This,peType)

#define IDXTConvolution_SetCustomFilter(This,pFilter,Size)	\
    (This)->lpVtbl -> SetCustomFilter(This,pFilter,Size)

#define IDXTConvolution_SetConvertToGray(This,bConvertToGray)	\
    (This)->lpVtbl -> SetConvertToGray(This,bConvertToGray)

#define IDXTConvolution_GetConvertToGray(This,pbConvertToGray)	\
    (This)->lpVtbl -> GetConvertToGray(This,pbConvertToGray)

#define IDXTConvolution_SetBias(This,Bias)	\
    (This)->lpVtbl -> SetBias(This,Bias)

#define IDXTConvolution_GetBias(This,pBias)	\
    (This)->lpVtbl -> GetBias(This,pBias)

#define IDXTConvolution_SetExcludeAlpha(This,bExcludeAlpha)	\
    (This)->lpVtbl -> SetExcludeAlpha(This,bExcludeAlpha)

#define IDXTConvolution_GetExcludeAlpha(This,pbExcludeAlpha)	\
    (This)->lpVtbl -> GetExcludeAlpha(This,pbExcludeAlpha)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDXTConvolution_SetFilterType_Proxy( 
    IDXTConvolution __RPC_FAR * This,
    /* [in] */ DXCONVFILTERTYPE eType);


void __RPC_STUB IDXTConvolution_SetFilterType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXTConvolution_GetFilterType_Proxy( 
    IDXTConvolution __RPC_FAR * This,
    /* [out] */ DXCONVFILTERTYPE __RPC_FAR *peType);


void __RPC_STUB IDXTConvolution_GetFilterType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXTConvolution_SetCustomFilter_Proxy( 
    IDXTConvolution __RPC_FAR * This,
    /* [in] */ float __RPC_FAR *pFilter,
    /* [in] */ SIZE Size);


void __RPC_STUB IDXTConvolution_SetCustomFilter_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXTConvolution_SetConvertToGray_Proxy( 
    IDXTConvolution __RPC_FAR * This,
    /* [in] */ BOOL bConvertToGray);


void __RPC_STUB IDXTConvolution_SetConvertToGray_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXTConvolution_GetConvertToGray_Proxy( 
    IDXTConvolution __RPC_FAR * This,
    /* [out] */ BOOL __RPC_FAR *pbConvertToGray);


void __RPC_STUB IDXTConvolution_GetConvertToGray_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXTConvolution_SetBias_Proxy( 
    IDXTConvolution __RPC_FAR * This,
    /* [in] */ float Bias);


void __RPC_STUB IDXTConvolution_SetBias_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXTConvolution_GetBias_Proxy( 
    IDXTConvolution __RPC_FAR * This,
    /* [out] */ float __RPC_FAR *pBias);


void __RPC_STUB IDXTConvolution_GetBias_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXTConvolution_SetExcludeAlpha_Proxy( 
    IDXTConvolution __RPC_FAR * This,
    /* [in] */ BOOL bExcludeAlpha);


void __RPC_STUB IDXTConvolution_SetExcludeAlpha_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXTConvolution_GetExcludeAlpha_Proxy( 
    IDXTConvolution __RPC_FAR * This,
    /* [out] */ BOOL __RPC_FAR *pbExcludeAlpha);


void __RPC_STUB IDXTConvolution_GetExcludeAlpha_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDXTConvolution_INTERFACE_DEFINED__ */


#ifndef __IDXMapper_INTERFACE_DEFINED__
#define __IDXMapper_INTERFACE_DEFINED__

/* interface IDXMapper */
/* [object][unique][helpstring][uuid] */ 


EXTERN_C const IID IID_IDXMapper;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("555278E5-05DB-11D1-883A-3C8B00C10000")
    IDXMapper : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE MapIn2Out( 
            /* [in] */ DXVEC __RPC_FAR *pInPt,
            /* [out] */ DXVEC __RPC_FAR *pOutPt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE MapOut2In( 
            /* [in] */ DXVEC __RPC_FAR *pOutPt,
            /* [out] */ DXVEC __RPC_FAR *pInPt) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDXMapperVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDXMapper __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDXMapper __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDXMapper __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *MapIn2Out )( 
            IDXMapper __RPC_FAR * This,
            /* [in] */ DXVEC __RPC_FAR *pInPt,
            /* [out] */ DXVEC __RPC_FAR *pOutPt);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *MapOut2In )( 
            IDXMapper __RPC_FAR * This,
            /* [in] */ DXVEC __RPC_FAR *pOutPt,
            /* [out] */ DXVEC __RPC_FAR *pInPt);
        
        END_INTERFACE
    } IDXMapperVtbl;

    interface IDXMapper
    {
        CONST_VTBL struct IDXMapperVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDXMapper_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDXMapper_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDXMapper_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDXMapper_MapIn2Out(This,pInPt,pOutPt)	\
    (This)->lpVtbl -> MapIn2Out(This,pInPt,pOutPt)

#define IDXMapper_MapOut2In(This,pOutPt,pInPt)	\
    (This)->lpVtbl -> MapOut2In(This,pOutPt,pInPt)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDXMapper_MapIn2Out_Proxy( 
    IDXMapper __RPC_FAR * This,
    /* [in] */ DXVEC __RPC_FAR *pInPt,
    /* [out] */ DXVEC __RPC_FAR *pOutPt);


void __RPC_STUB IDXMapper_MapIn2Out_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXMapper_MapOut2In_Proxy( 
    IDXMapper __RPC_FAR * This,
    /* [in] */ DXVEC __RPC_FAR *pOutPt,
    /* [out] */ DXVEC __RPC_FAR *pInPt);


void __RPC_STUB IDXMapper_MapOut2In_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDXMapper_INTERFACE_DEFINED__ */


#ifndef __IDXDMapper_INTERFACE_DEFINED__
#define __IDXDMapper_INTERFACE_DEFINED__

/* interface IDXDMapper */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IDXDMapper;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("7FD9088B-35ED-11d1-81A1-0000F87557DB")
    IDXDMapper : public IDispatch
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE MapIn2Out( 
            /* [in] */ SAFEARRAY __RPC_FAR * __RPC_FAR *pInPt,
            /* [out] */ SAFEARRAY __RPC_FAR * __RPC_FAR *pOutPt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE MapOut2In( 
            /* [in] */ SAFEARRAY __RPC_FAR * __RPC_FAR *pOutPt,
            /* [out] */ SAFEARRAY __RPC_FAR * __RPC_FAR *pInPt) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDXDMapperVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDXDMapper __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDXDMapper __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDXDMapper __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IDXDMapper __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IDXDMapper __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IDXDMapper __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IDXDMapper __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *MapIn2Out )( 
            IDXDMapper __RPC_FAR * This,
            /* [in] */ SAFEARRAY __RPC_FAR * __RPC_FAR *pInPt,
            /* [out] */ SAFEARRAY __RPC_FAR * __RPC_FAR *pOutPt);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *MapOut2In )( 
            IDXDMapper __RPC_FAR * This,
            /* [in] */ SAFEARRAY __RPC_FAR * __RPC_FAR *pOutPt,
            /* [out] */ SAFEARRAY __RPC_FAR * __RPC_FAR *pInPt);
        
        END_INTERFACE
    } IDXDMapperVtbl;

    interface IDXDMapper
    {
        CONST_VTBL struct IDXDMapperVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDXDMapper_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDXDMapper_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDXDMapper_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDXDMapper_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IDXDMapper_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IDXDMapper_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IDXDMapper_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IDXDMapper_MapIn2Out(This,pInPt,pOutPt)	\
    (This)->lpVtbl -> MapIn2Out(This,pInPt,pOutPt)

#define IDXDMapper_MapOut2In(This,pOutPt,pInPt)	\
    (This)->lpVtbl -> MapOut2In(This,pOutPt,pInPt)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDXDMapper_MapIn2Out_Proxy( 
    IDXDMapper __RPC_FAR * This,
    /* [in] */ SAFEARRAY __RPC_FAR * __RPC_FAR *pInPt,
    /* [out] */ SAFEARRAY __RPC_FAR * __RPC_FAR *pOutPt);


void __RPC_STUB IDXDMapper_MapIn2Out_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDXDMapper_MapOut2In_Proxy( 
    IDXDMapper __RPC_FAR * This,
    /* [in] */ SAFEARRAY __RPC_FAR * __RPC_FAR *pOutPt,
    /* [out] */ SAFEARRAY __RPC_FAR * __RPC_FAR *pInPt);


void __RPC_STUB IDXDMapper_MapOut2In_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDXDMapper_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_dxtmsft_0285 */
/* [local] */ 

typedef 
enum DXCOMPFUNC
    {	DXCOMPFUNC_SWAP_AB	= 0x10,
	DXCOMPFUNC_FUNCMASK	= 0xf,
	DXCOMPFUNC_CLEAR	= 0,
	DXCOMPFUNC_MIN	= DXCOMPFUNC_CLEAR + 1,
	DXCOMPFUNC_MAX	= DXCOMPFUNC_MIN + 1,
	DXCOMPFUNC_A	= DXCOMPFUNC_MAX + 1,
	DXCOMPFUNC_A_OVER_B	= DXCOMPFUNC_A + 1,
	DXCOMPFUNC_A_IN_B	= DXCOMPFUNC_A_OVER_B + 1,
	DXCOMPFUNC_A_OUT_B	= DXCOMPFUNC_A_IN_B + 1,
	DXCOMPFUNC_A_ATOP_B	= DXCOMPFUNC_A_OUT_B + 1,
	DXCOMPFUNC_A_SUBTRACT_B	= DXCOMPFUNC_A_ATOP_B + 1,
	DXCOMPFUNC_A_ADD_B	= DXCOMPFUNC_A_SUBTRACT_B + 1,
	DXCOMPFUNC_A_XOR_B	= DXCOMPFUNC_A_ADD_B + 1,
	DXCOMPFUNC_B	= DXCOMPFUNC_A | DXCOMPFUNC_SWAP_AB,
	DXCOMPFUNC_B_OVER_A	= DXCOMPFUNC_A_OVER_B | DXCOMPFUNC_SWAP_AB,
	DXCOMPFUNC_B_IN_A	= DXCOMPFUNC_A_IN_B | DXCOMPFUNC_SWAP_AB,
	DXCOMPFUNC_B_OUT_A	= DXCOMPFUNC_A_OUT_B | DXCOMPFUNC_SWAP_AB,
	DXCOMPFUNC_B_ATOP_A	= DXCOMPFUNC_A_ATOP_B | DXCOMPFUNC_SWAP_AB,
	DXCOMPFUNC_B_SUBTRACT_A	= DXCOMPFUNC_A_SUBTRACT_B | DXCOMPFUNC_SWAP_AB,
	DXCOMPFUNC_B_ADD_A	= DXCOMPFUNC_A_ADD_B | DXCOMPFUNC_SWAP_AB,
	DXCOMPFUNC_NUMFUNCS	= DXCOMPFUNC_B_ADD_A + 1
    }	DXCOMPFUNC;

typedef 
enum DXCOMPOSITEDISPID
    {	DISPID_DXCOMPOSITE_Function	= 1
    }	DXCOMPOSITEDISPID;



extern RPC_IF_HANDLE __MIDL_itf_dxtmsft_0285_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_dxtmsft_0285_v0_0_s_ifspec;

#ifndef __IDXTComposite_INTERFACE_DEFINED__
#define __IDXTComposite_INTERFACE_DEFINED__

/* interface IDXTComposite */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IDXTComposite;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("9A43A843-0831-11D1-817F-0000F87557DB")
    IDXTComposite : public IDispatch
    {
    public:
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Function( 
            /* [in] */ DXCOMPFUNC eFunc) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Function( 
            /* [retval][out] */ DXCOMPFUNC __RPC_FAR *peFunc) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDXTCompositeVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDXTComposite __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDXTComposite __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDXTComposite __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IDXTComposite __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IDXTComposite __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IDXTComposite __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IDXTComposite __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Function )( 
            IDXTComposite __RPC_FAR * This,
            /* [in] */ DXCOMPFUNC eFunc);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Function )( 
            IDXTComposite __RPC_FAR * This,
            /* [retval][out] */ DXCOMPFUNC __RPC_FAR *peFunc);
        
        END_INTERFACE
    } IDXTCompositeVtbl;

    interface IDXTComposite
    {
        CONST_VTBL struct IDXTCompositeVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDXTComposite_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDXTComposite_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDXTComposite_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDXTComposite_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IDXTComposite_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IDXTComposite_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IDXTComposite_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IDXTComposite_put_Function(This,eFunc)	\
    (This)->lpVtbl -> put_Function(This,eFunc)

#define IDXTComposite_get_Function(This,peFunc)	\
    (This)->lpVtbl -> get_Function(This,peFunc)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTComposite_put_Function_Proxy( 
    IDXTComposite __RPC_FAR * This,
    /* [in] */ DXCOMPFUNC eFunc);


void __RPC_STUB IDXTComposite_put_Function_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTComposite_get_Function_Proxy( 
    IDXTComposite __RPC_FAR * This,
    /* [retval][out] */ DXCOMPFUNC __RPC_FAR *peFunc);


void __RPC_STUB IDXTComposite_get_Function_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDXTComposite_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_dxtmsft_0286 */
/* [local] */ 

typedef 
enum DXWIPEDIRECTION
    {	DXWD_HORIZONTAL	= 0,
	DXWD_VERTICAL	= DXWD_HORIZONTAL + 1
    }	DXWIPEDIRECTION;

typedef 
enum DXWIPEDISPID
    {	DISPID_DXW_GradientSize	= DISPID_DXE_NEXT_ID,
	DISPID_DXW_WipeStyle	= DISPID_DXW_GradientSize + 1
    }	DXWIPEDISPID;



extern RPC_IF_HANDLE __MIDL_itf_dxtmsft_0286_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_dxtmsft_0286_v0_0_s_ifspec;

#ifndef __IDXTWipe_INTERFACE_DEFINED__
#define __IDXTWipe_INTERFACE_DEFINED__

/* interface IDXTWipe */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IDXTWipe;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("AF279B2F-86EB-11D1-81BF-0000F87557DB")
    IDXTWipe : public IDXEffect
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_GradientSize( 
            /* [retval][out] */ float __RPC_FAR *pPercentSize) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_GradientSize( 
            /* [in] */ float PercentSize) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_WipeStyle( 
            /* [retval][out] */ DXWIPEDIRECTION __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_WipeStyle( 
            /* [in] */ DXWIPEDIRECTION newVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDXTWipeVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDXTWipe __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDXTWipe __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDXTWipe __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IDXTWipe __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IDXTWipe __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IDXTWipe __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IDXTWipe __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Capabilities )( 
            IDXTWipe __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Progress )( 
            IDXTWipe __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Progress )( 
            IDXTWipe __RPC_FAR * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_StepResolution )( 
            IDXTWipe __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Duration )( 
            IDXTWipe __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Duration )( 
            IDXTWipe __RPC_FAR * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_GradientSize )( 
            IDXTWipe __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pPercentSize);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_GradientSize )( 
            IDXTWipe __RPC_FAR * This,
            /* [in] */ float PercentSize);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_WipeStyle )( 
            IDXTWipe __RPC_FAR * This,
            /* [retval][out] */ DXWIPEDIRECTION __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_WipeStyle )( 
            IDXTWipe __RPC_FAR * This,
            /* [in] */ DXWIPEDIRECTION newVal);
        
        END_INTERFACE
    } IDXTWipeVtbl;

    interface IDXTWipe
    {
        CONST_VTBL struct IDXTWipeVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDXTWipe_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDXTWipe_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDXTWipe_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDXTWipe_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IDXTWipe_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IDXTWipe_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IDXTWipe_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IDXTWipe_get_Capabilities(This,pVal)	\
    (This)->lpVtbl -> get_Capabilities(This,pVal)

#define IDXTWipe_get_Progress(This,pVal)	\
    (This)->lpVtbl -> get_Progress(This,pVal)

#define IDXTWipe_put_Progress(This,newVal)	\
    (This)->lpVtbl -> put_Progress(This,newVal)

#define IDXTWipe_get_StepResolution(This,pVal)	\
    (This)->lpVtbl -> get_StepResolution(This,pVal)

#define IDXTWipe_get_Duration(This,pVal)	\
    (This)->lpVtbl -> get_Duration(This,pVal)

#define IDXTWipe_put_Duration(This,newVal)	\
    (This)->lpVtbl -> put_Duration(This,newVal)


#define IDXTWipe_get_GradientSize(This,pPercentSize)	\
    (This)->lpVtbl -> get_GradientSize(This,pPercentSize)

#define IDXTWipe_put_GradientSize(This,PercentSize)	\
    (This)->lpVtbl -> put_GradientSize(This,PercentSize)

#define IDXTWipe_get_WipeStyle(This,pVal)	\
    (This)->lpVtbl -> get_WipeStyle(This,pVal)

#define IDXTWipe_put_WipeStyle(This,newVal)	\
    (This)->lpVtbl -> put_WipeStyle(This,newVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTWipe_get_GradientSize_Proxy( 
    IDXTWipe __RPC_FAR * This,
    /* [retval][out] */ float __RPC_FAR *pPercentSize);


void __RPC_STUB IDXTWipe_get_GradientSize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTWipe_put_GradientSize_Proxy( 
    IDXTWipe __RPC_FAR * This,
    /* [in] */ float PercentSize);


void __RPC_STUB IDXTWipe_put_GradientSize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTWipe_get_WipeStyle_Proxy( 
    IDXTWipe __RPC_FAR * This,
    /* [retval][out] */ DXWIPEDIRECTION __RPC_FAR *pVal);


void __RPC_STUB IDXTWipe_get_WipeStyle_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTWipe_put_WipeStyle_Proxy( 
    IDXTWipe __RPC_FAR * This,
    /* [in] */ DXWIPEDIRECTION newVal);


void __RPC_STUB IDXTWipe_put_WipeStyle_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDXTWipe_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_dxtmsft_0287 */
/* [local] */ 

typedef 
enum CRBLURDISPID
    {	DISPID_CRB_MakeShadow	= 1,
	DISPID_CRB_ShadowOpacity	= DISPID_CRB_MakeShadow + 1,
	DISPID_CRB_PixelRadius	= DISPID_CRB_ShadowOpacity + 1
    }	CRBLURDISPID;



extern RPC_IF_HANDLE __MIDL_itf_dxtmsft_0287_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_dxtmsft_0287_v0_0_s_ifspec;

#ifndef __ICrBlur_INTERFACE_DEFINED__
#define __ICrBlur_INTERFACE_DEFINED__

/* interface ICrBlur */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_ICrBlur;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("9F7C7827-E87A-11d1-81E0-0000F87557DB")
    ICrBlur : public IDispatch
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_MakeShadow( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_MakeShadow( 
            /* [in] */ VARIANT_BOOL newVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_ShadowOpacity( 
            /* [retval][out] */ float __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_ShadowOpacity( 
            /* [in] */ float newVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_PixelRadius( 
            /* [retval][out] */ float __RPC_FAR *pPixelRadius) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_PixelRadius( 
            /* [in] */ float PixelRadius) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICrBlurVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ICrBlur __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ICrBlur __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ICrBlur __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            ICrBlur __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            ICrBlur __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            ICrBlur __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            ICrBlur __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_MakeShadow )( 
            ICrBlur __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_MakeShadow )( 
            ICrBlur __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ShadowOpacity )( 
            ICrBlur __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_ShadowOpacity )( 
            ICrBlur __RPC_FAR * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_PixelRadius )( 
            ICrBlur __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pPixelRadius);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_PixelRadius )( 
            ICrBlur __RPC_FAR * This,
            /* [in] */ float PixelRadius);
        
        END_INTERFACE
    } ICrBlurVtbl;

    interface ICrBlur
    {
        CONST_VTBL struct ICrBlurVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICrBlur_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICrBlur_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICrBlur_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICrBlur_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ICrBlur_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ICrBlur_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ICrBlur_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ICrBlur_get_MakeShadow(This,pVal)	\
    (This)->lpVtbl -> get_MakeShadow(This,pVal)

#define ICrBlur_put_MakeShadow(This,newVal)	\
    (This)->lpVtbl -> put_MakeShadow(This,newVal)

#define ICrBlur_get_ShadowOpacity(This,pVal)	\
    (This)->lpVtbl -> get_ShadowOpacity(This,pVal)

#define ICrBlur_put_ShadowOpacity(This,newVal)	\
    (This)->lpVtbl -> put_ShadowOpacity(This,newVal)

#define ICrBlur_get_PixelRadius(This,pPixelRadius)	\
    (This)->lpVtbl -> get_PixelRadius(This,pPixelRadius)

#define ICrBlur_put_PixelRadius(This,PixelRadius)	\
    (This)->lpVtbl -> put_PixelRadius(This,PixelRadius)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE ICrBlur_get_MakeShadow_Proxy( 
    ICrBlur __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pVal);


void __RPC_STUB ICrBlur_get_MakeShadow_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE ICrBlur_put_MakeShadow_Proxy( 
    ICrBlur __RPC_FAR * This,
    /* [in] */ VARIANT_BOOL newVal);


void __RPC_STUB ICrBlur_put_MakeShadow_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE ICrBlur_get_ShadowOpacity_Proxy( 
    ICrBlur __RPC_FAR * This,
    /* [retval][out] */ float __RPC_FAR *pVal);


void __RPC_STUB ICrBlur_get_ShadowOpacity_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE ICrBlur_put_ShadowOpacity_Proxy( 
    ICrBlur __RPC_FAR * This,
    /* [in] */ float newVal);


void __RPC_STUB ICrBlur_put_ShadowOpacity_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE ICrBlur_get_PixelRadius_Proxy( 
    ICrBlur __RPC_FAR * This,
    /* [retval][out] */ float __RPC_FAR *pPixelRadius);


void __RPC_STUB ICrBlur_get_PixelRadius_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE ICrBlur_put_PixelRadius_Proxy( 
    ICrBlur __RPC_FAR * This,
    /* [in] */ float PixelRadius);


void __RPC_STUB ICrBlur_put_PixelRadius_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICrBlur_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_dxtmsft_0288 */
/* [local] */ 

typedef 
enum CRENGRAVEDISPID
    {	DISPID_CREN_Bias	= 1
    }	CRENGRAVEDISPID;



extern RPC_IF_HANDLE __MIDL_itf_dxtmsft_0288_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_dxtmsft_0288_v0_0_s_ifspec;

#ifndef __ICrEngrave_INTERFACE_DEFINED__
#define __ICrEngrave_INTERFACE_DEFINED__

/* interface ICrEngrave */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_ICrEngrave;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("E4ACFB7F-053E-11d2-81EA-0000F87557DB")
    ICrEngrave : public IDispatch
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Bias( 
            /* [retval][out] */ float __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Bias( 
            /* [in] */ float newVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICrEngraveVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ICrEngrave __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ICrEngrave __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ICrEngrave __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            ICrEngrave __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            ICrEngrave __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            ICrEngrave __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            ICrEngrave __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Bias )( 
            ICrEngrave __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Bias )( 
            ICrEngrave __RPC_FAR * This,
            /* [in] */ float newVal);
        
        END_INTERFACE
    } ICrEngraveVtbl;

    interface ICrEngrave
    {
        CONST_VTBL struct ICrEngraveVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICrEngrave_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICrEngrave_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICrEngrave_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICrEngrave_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ICrEngrave_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ICrEngrave_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ICrEngrave_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ICrEngrave_get_Bias(This,pVal)	\
    (This)->lpVtbl -> get_Bias(This,pVal)

#define ICrEngrave_put_Bias(This,newVal)	\
    (This)->lpVtbl -> put_Bias(This,newVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE ICrEngrave_get_Bias_Proxy( 
    ICrEngrave __RPC_FAR * This,
    /* [retval][out] */ float __RPC_FAR *pVal);


void __RPC_STUB ICrEngrave_get_Bias_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE ICrEngrave_put_Bias_Proxy( 
    ICrEngrave __RPC_FAR * This,
    /* [in] */ float newVal);


void __RPC_STUB ICrEngrave_put_Bias_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICrEngrave_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_dxtmsft_0289 */
/* [local] */ 

typedef 
enum CREMBOSSDISPID
    {	DISPID_CREM_Bias	= 1
    }	CREMBOSSDISPID;



extern RPC_IF_HANDLE __MIDL_itf_dxtmsft_0289_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_dxtmsft_0289_v0_0_s_ifspec;

#ifndef __ICrEmboss_INTERFACE_DEFINED__
#define __ICrEmboss_INTERFACE_DEFINED__

/* interface ICrEmboss */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_ICrEmboss;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("E4ACFB80-053E-11d2-81EA-0000F87557DB")
    ICrEmboss : public IDispatch
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Bias( 
            /* [retval][out] */ float __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Bias( 
            /* [in] */ float newVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICrEmbossVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ICrEmboss __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ICrEmboss __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ICrEmboss __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            ICrEmboss __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            ICrEmboss __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            ICrEmboss __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            ICrEmboss __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Bias )( 
            ICrEmboss __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Bias )( 
            ICrEmboss __RPC_FAR * This,
            /* [in] */ float newVal);
        
        END_INTERFACE
    } ICrEmbossVtbl;

    interface ICrEmboss
    {
        CONST_VTBL struct ICrEmbossVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICrEmboss_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICrEmboss_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICrEmboss_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICrEmboss_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ICrEmboss_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ICrEmboss_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ICrEmboss_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ICrEmboss_get_Bias(This,pVal)	\
    (This)->lpVtbl -> get_Bias(This,pVal)

#define ICrEmboss_put_Bias(This,newVal)	\
    (This)->lpVtbl -> put_Bias(This,newVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE ICrEmboss_get_Bias_Proxy( 
    ICrEmboss __RPC_FAR * This,
    /* [retval][out] */ float __RPC_FAR *pVal);


void __RPC_STUB ICrEmboss_get_Bias_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE ICrEmboss_put_Bias_Proxy( 
    ICrEmboss __RPC_FAR * This,
    /* [in] */ float newVal);


void __RPC_STUB ICrEmboss_put_Bias_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICrEmboss_INTERFACE_DEFINED__ */


#ifndef __IDXTFade_INTERFACE_DEFINED__
#define __IDXTFade_INTERFACE_DEFINED__

/* interface IDXTFade */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IDXTFade;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("16B280C4-EE70-11D1-9066-00C04FD9189D")
    IDXTFade : public IDXEffect
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Overlap( 
            /* [retval][out] */ float __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Overlap( 
            /* [in] */ float newVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Center( 
            /* [retval][out] */ BOOL __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Center( 
            /* [in] */ BOOL newVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDXTFadeVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDXTFade __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDXTFade __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDXTFade __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IDXTFade __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IDXTFade __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IDXTFade __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IDXTFade __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Capabilities )( 
            IDXTFade __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Progress )( 
            IDXTFade __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Progress )( 
            IDXTFade __RPC_FAR * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_StepResolution )( 
            IDXTFade __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Duration )( 
            IDXTFade __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Duration )( 
            IDXTFade __RPC_FAR * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Overlap )( 
            IDXTFade __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Overlap )( 
            IDXTFade __RPC_FAR * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Center )( 
            IDXTFade __RPC_FAR * This,
            /* [retval][out] */ BOOL __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Center )( 
            IDXTFade __RPC_FAR * This,
            /* [in] */ BOOL newVal);
        
        END_INTERFACE
    } IDXTFadeVtbl;

    interface IDXTFade
    {
        CONST_VTBL struct IDXTFadeVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDXTFade_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDXTFade_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDXTFade_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDXTFade_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IDXTFade_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IDXTFade_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IDXTFade_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IDXTFade_get_Capabilities(This,pVal)	\
    (This)->lpVtbl -> get_Capabilities(This,pVal)

#define IDXTFade_get_Progress(This,pVal)	\
    (This)->lpVtbl -> get_Progress(This,pVal)

#define IDXTFade_put_Progress(This,newVal)	\
    (This)->lpVtbl -> put_Progress(This,newVal)

#define IDXTFade_get_StepResolution(This,pVal)	\
    (This)->lpVtbl -> get_StepResolution(This,pVal)

#define IDXTFade_get_Duration(This,pVal)	\
    (This)->lpVtbl -> get_Duration(This,pVal)

#define IDXTFade_put_Duration(This,newVal)	\
    (This)->lpVtbl -> put_Duration(This,newVal)


#define IDXTFade_get_Overlap(This,pVal)	\
    (This)->lpVtbl -> get_Overlap(This,pVal)

#define IDXTFade_put_Overlap(This,newVal)	\
    (This)->lpVtbl -> put_Overlap(This,newVal)

#define IDXTFade_get_Center(This,pVal)	\
    (This)->lpVtbl -> get_Center(This,pVal)

#define IDXTFade_put_Center(This,newVal)	\
    (This)->lpVtbl -> put_Center(This,newVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTFade_get_Overlap_Proxy( 
    IDXTFade __RPC_FAR * This,
    /* [retval][out] */ float __RPC_FAR *pVal);


void __RPC_STUB IDXTFade_get_Overlap_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTFade_put_Overlap_Proxy( 
    IDXTFade __RPC_FAR * This,
    /* [in] */ float newVal);


void __RPC_STUB IDXTFade_put_Overlap_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTFade_get_Center_Proxy( 
    IDXTFade __RPC_FAR * This,
    /* [retval][out] */ BOOL __RPC_FAR *pVal);


void __RPC_STUB IDXTFade_get_Center_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTFade_put_Center_Proxy( 
    IDXTFade __RPC_FAR * This,
    /* [in] */ BOOL newVal);


void __RPC_STUB IDXTFade_put_Center_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDXTFade_INTERFACE_DEFINED__ */


#ifndef __IDXBasicImage_INTERFACE_DEFINED__
#define __IDXBasicImage_INTERFACE_DEFINED__

/* interface IDXBasicImage */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IDXBasicImage;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("16B280C7-EE70-11D1-9066-00C04FD9189D")
    IDXBasicImage : public IDispatch
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Rotation( 
            /* [retval][out] */ int __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Rotation( 
            /* [in] */ int newVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Mirror( 
            /* [retval][out] */ BOOL __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Mirror( 
            /* [in] */ BOOL newVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_GrayScale( 
            /* [retval][out] */ BOOL __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_GrayScale( 
            /* [in] */ BOOL newVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Opacity( 
            /* [retval][out] */ float __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Opacity( 
            /* [in] */ float newVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Invert( 
            /* [retval][out] */ BOOL __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Invert( 
            /* [in] */ BOOL newVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_XRay( 
            /* [retval][out] */ BOOL __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_XRay( 
            /* [in] */ BOOL newVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Mask( 
            /* [retval][out] */ BOOL __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Mask( 
            /* [in] */ BOOL newVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_MaskColor( 
            /* [retval][out] */ int __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_MaskColor( 
            /* [in] */ int newVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDXBasicImageVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDXBasicImage __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDXBasicImage __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDXBasicImage __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IDXBasicImage __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IDXBasicImage __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IDXBasicImage __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IDXBasicImage __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Rotation )( 
            IDXBasicImage __RPC_FAR * This,
            /* [retval][out] */ int __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Rotation )( 
            IDXBasicImage __RPC_FAR * This,
            /* [in] */ int newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Mirror )( 
            IDXBasicImage __RPC_FAR * This,
            /* [retval][out] */ BOOL __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Mirror )( 
            IDXBasicImage __RPC_FAR * This,
            /* [in] */ BOOL newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_GrayScale )( 
            IDXBasicImage __RPC_FAR * This,
            /* [retval][out] */ BOOL __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_GrayScale )( 
            IDXBasicImage __RPC_FAR * This,
            /* [in] */ BOOL newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Opacity )( 
            IDXBasicImage __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Opacity )( 
            IDXBasicImage __RPC_FAR * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Invert )( 
            IDXBasicImage __RPC_FAR * This,
            /* [retval][out] */ BOOL __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Invert )( 
            IDXBasicImage __RPC_FAR * This,
            /* [in] */ BOOL newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_XRay )( 
            IDXBasicImage __RPC_FAR * This,
            /* [retval][out] */ BOOL __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_XRay )( 
            IDXBasicImage __RPC_FAR * This,
            /* [in] */ BOOL newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Mask )( 
            IDXBasicImage __RPC_FAR * This,
            /* [retval][out] */ BOOL __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Mask )( 
            IDXBasicImage __RPC_FAR * This,
            /* [in] */ BOOL newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_MaskColor )( 
            IDXBasicImage __RPC_FAR * This,
            /* [retval][out] */ int __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_MaskColor )( 
            IDXBasicImage __RPC_FAR * This,
            /* [in] */ int newVal);
        
        END_INTERFACE
    } IDXBasicImageVtbl;

    interface IDXBasicImage
    {
        CONST_VTBL struct IDXBasicImageVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDXBasicImage_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDXBasicImage_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDXBasicImage_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDXBasicImage_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IDXBasicImage_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IDXBasicImage_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IDXBasicImage_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IDXBasicImage_get_Rotation(This,pVal)	\
    (This)->lpVtbl -> get_Rotation(This,pVal)

#define IDXBasicImage_put_Rotation(This,newVal)	\
    (This)->lpVtbl -> put_Rotation(This,newVal)

#define IDXBasicImage_get_Mirror(This,pVal)	\
    (This)->lpVtbl -> get_Mirror(This,pVal)

#define IDXBasicImage_put_Mirror(This,newVal)	\
    (This)->lpVtbl -> put_Mirror(This,newVal)

#define IDXBasicImage_get_GrayScale(This,pVal)	\
    (This)->lpVtbl -> get_GrayScale(This,pVal)

#define IDXBasicImage_put_GrayScale(This,newVal)	\
    (This)->lpVtbl -> put_GrayScale(This,newVal)

#define IDXBasicImage_get_Opacity(This,pVal)	\
    (This)->lpVtbl -> get_Opacity(This,pVal)

#define IDXBasicImage_put_Opacity(This,newVal)	\
    (This)->lpVtbl -> put_Opacity(This,newVal)

#define IDXBasicImage_get_Invert(This,pVal)	\
    (This)->lpVtbl -> get_Invert(This,pVal)

#define IDXBasicImage_put_Invert(This,newVal)	\
    (This)->lpVtbl -> put_Invert(This,newVal)

#define IDXBasicImage_get_XRay(This,pVal)	\
    (This)->lpVtbl -> get_XRay(This,pVal)

#define IDXBasicImage_put_XRay(This,newVal)	\
    (This)->lpVtbl -> put_XRay(This,newVal)

#define IDXBasicImage_get_Mask(This,pVal)	\
    (This)->lpVtbl -> get_Mask(This,pVal)

#define IDXBasicImage_put_Mask(This,newVal)	\
    (This)->lpVtbl -> put_Mask(This,newVal)

#define IDXBasicImage_get_MaskColor(This,pVal)	\
    (This)->lpVtbl -> get_MaskColor(This,pVal)

#define IDXBasicImage_put_MaskColor(This,newVal)	\
    (This)->lpVtbl -> put_MaskColor(This,newVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXBasicImage_get_Rotation_Proxy( 
    IDXBasicImage __RPC_FAR * This,
    /* [retval][out] */ int __RPC_FAR *pVal);


void __RPC_STUB IDXBasicImage_get_Rotation_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXBasicImage_put_Rotation_Proxy( 
    IDXBasicImage __RPC_FAR * This,
    /* [in] */ int newVal);


void __RPC_STUB IDXBasicImage_put_Rotation_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXBasicImage_get_Mirror_Proxy( 
    IDXBasicImage __RPC_FAR * This,
    /* [retval][out] */ BOOL __RPC_FAR *pVal);


void __RPC_STUB IDXBasicImage_get_Mirror_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXBasicImage_put_Mirror_Proxy( 
    IDXBasicImage __RPC_FAR * This,
    /* [in] */ BOOL newVal);


void __RPC_STUB IDXBasicImage_put_Mirror_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXBasicImage_get_GrayScale_Proxy( 
    IDXBasicImage __RPC_FAR * This,
    /* [retval][out] */ BOOL __RPC_FAR *pVal);


void __RPC_STUB IDXBasicImage_get_GrayScale_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXBasicImage_put_GrayScale_Proxy( 
    IDXBasicImage __RPC_FAR * This,
    /* [in] */ BOOL newVal);


void __RPC_STUB IDXBasicImage_put_GrayScale_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXBasicImage_get_Opacity_Proxy( 
    IDXBasicImage __RPC_FAR * This,
    /* [retval][out] */ float __RPC_FAR *pVal);


void __RPC_STUB IDXBasicImage_get_Opacity_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXBasicImage_put_Opacity_Proxy( 
    IDXBasicImage __RPC_FAR * This,
    /* [in] */ float newVal);


void __RPC_STUB IDXBasicImage_put_Opacity_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXBasicImage_get_Invert_Proxy( 
    IDXBasicImage __RPC_FAR * This,
    /* [retval][out] */ BOOL __RPC_FAR *pVal);


void __RPC_STUB IDXBasicImage_get_Invert_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXBasicImage_put_Invert_Proxy( 
    IDXBasicImage __RPC_FAR * This,
    /* [in] */ BOOL newVal);


void __RPC_STUB IDXBasicImage_put_Invert_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXBasicImage_get_XRay_Proxy( 
    IDXBasicImage __RPC_FAR * This,
    /* [retval][out] */ BOOL __RPC_FAR *pVal);


void __RPC_STUB IDXBasicImage_get_XRay_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXBasicImage_put_XRay_Proxy( 
    IDXBasicImage __RPC_FAR * This,
    /* [in] */ BOOL newVal);


void __RPC_STUB IDXBasicImage_put_XRay_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXBasicImage_get_Mask_Proxy( 
    IDXBasicImage __RPC_FAR * This,
    /* [retval][out] */ BOOL __RPC_FAR *pVal);


void __RPC_STUB IDXBasicImage_get_Mask_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXBasicImage_put_Mask_Proxy( 
    IDXBasicImage __RPC_FAR * This,
    /* [in] */ BOOL newVal);


void __RPC_STUB IDXBasicImage_put_Mask_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXBasicImage_get_MaskColor_Proxy( 
    IDXBasicImage __RPC_FAR * This,
    /* [retval][out] */ int __RPC_FAR *pVal);


void __RPC_STUB IDXBasicImage_get_MaskColor_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXBasicImage_put_MaskColor_Proxy( 
    IDXBasicImage __RPC_FAR * This,
    /* [in] */ int newVal);


void __RPC_STUB IDXBasicImage_put_MaskColor_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDXBasicImage_INTERFACE_DEFINED__ */


#ifndef __IDXPixelate_INTERFACE_DEFINED__
#define __IDXPixelate_INTERFACE_DEFINED__

/* interface IDXPixelate */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IDXPixelate;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("D33E180F-FBE9-11d1-906A-00C04FD9189D")
    IDXPixelate : public IDXEffect
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_MaxSquare( 
            /* [retval][out] */ int __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_MaxSquare( 
            /* [in] */ int newVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDXPixelateVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDXPixelate __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDXPixelate __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDXPixelate __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IDXPixelate __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IDXPixelate __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IDXPixelate __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IDXPixelate __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Capabilities )( 
            IDXPixelate __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Progress )( 
            IDXPixelate __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Progress )( 
            IDXPixelate __RPC_FAR * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_StepResolution )( 
            IDXPixelate __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Duration )( 
            IDXPixelate __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Duration )( 
            IDXPixelate __RPC_FAR * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_MaxSquare )( 
            IDXPixelate __RPC_FAR * This,
            /* [retval][out] */ int __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_MaxSquare )( 
            IDXPixelate __RPC_FAR * This,
            /* [in] */ int newVal);
        
        END_INTERFACE
    } IDXPixelateVtbl;

    interface IDXPixelate
    {
        CONST_VTBL struct IDXPixelateVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDXPixelate_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDXPixelate_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDXPixelate_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDXPixelate_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IDXPixelate_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IDXPixelate_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IDXPixelate_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IDXPixelate_get_Capabilities(This,pVal)	\
    (This)->lpVtbl -> get_Capabilities(This,pVal)

#define IDXPixelate_get_Progress(This,pVal)	\
    (This)->lpVtbl -> get_Progress(This,pVal)

#define IDXPixelate_put_Progress(This,newVal)	\
    (This)->lpVtbl -> put_Progress(This,newVal)

#define IDXPixelate_get_StepResolution(This,pVal)	\
    (This)->lpVtbl -> get_StepResolution(This,pVal)

#define IDXPixelate_get_Duration(This,pVal)	\
    (This)->lpVtbl -> get_Duration(This,pVal)

#define IDXPixelate_put_Duration(This,newVal)	\
    (This)->lpVtbl -> put_Duration(This,newVal)


#define IDXPixelate_get_MaxSquare(This,pVal)	\
    (This)->lpVtbl -> get_MaxSquare(This,pVal)

#define IDXPixelate_put_MaxSquare(This,newVal)	\
    (This)->lpVtbl -> put_MaxSquare(This,newVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXPixelate_get_MaxSquare_Proxy( 
    IDXPixelate __RPC_FAR * This,
    /* [retval][out] */ int __RPC_FAR *pVal);


void __RPC_STUB IDXPixelate_get_MaxSquare_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXPixelate_put_MaxSquare_Proxy( 
    IDXPixelate __RPC_FAR * This,
    /* [in] */ int newVal);


void __RPC_STUB IDXPixelate_put_MaxSquare_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDXPixelate_INTERFACE_DEFINED__ */


#ifndef __ICrIris_INTERFACE_DEFINED__
#define __ICrIris_INTERFACE_DEFINED__

/* interface ICrIris */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_ICrIris;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3F69F350-0379-11D2-A484-00C04F8EFB69")
    ICrIris : public IDXEffect
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_irisStyle( 
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_irisStyle( 
            /* [in] */ BSTR newVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICrIrisVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ICrIris __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ICrIris __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ICrIris __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            ICrIris __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            ICrIris __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            ICrIris __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            ICrIris __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Capabilities )( 
            ICrIris __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Progress )( 
            ICrIris __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Progress )( 
            ICrIris __RPC_FAR * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_StepResolution )( 
            ICrIris __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Duration )( 
            ICrIris __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Duration )( 
            ICrIris __RPC_FAR * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_irisStyle )( 
            ICrIris __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_irisStyle )( 
            ICrIris __RPC_FAR * This,
            /* [in] */ BSTR newVal);
        
        END_INTERFACE
    } ICrIrisVtbl;

    interface ICrIris
    {
        CONST_VTBL struct ICrIrisVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICrIris_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICrIris_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICrIris_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICrIris_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ICrIris_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ICrIris_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ICrIris_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ICrIris_get_Capabilities(This,pVal)	\
    (This)->lpVtbl -> get_Capabilities(This,pVal)

#define ICrIris_get_Progress(This,pVal)	\
    (This)->lpVtbl -> get_Progress(This,pVal)

#define ICrIris_put_Progress(This,newVal)	\
    (This)->lpVtbl -> put_Progress(This,newVal)

#define ICrIris_get_StepResolution(This,pVal)	\
    (This)->lpVtbl -> get_StepResolution(This,pVal)

#define ICrIris_get_Duration(This,pVal)	\
    (This)->lpVtbl -> get_Duration(This,pVal)

#define ICrIris_put_Duration(This,newVal)	\
    (This)->lpVtbl -> put_Duration(This,newVal)


#define ICrIris_get_irisStyle(This,pVal)	\
    (This)->lpVtbl -> get_irisStyle(This,pVal)

#define ICrIris_put_irisStyle(This,newVal)	\
    (This)->lpVtbl -> put_irisStyle(This,newVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE ICrIris_get_irisStyle_Proxy( 
    ICrIris __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB ICrIris_get_irisStyle_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE ICrIris_put_irisStyle_Proxy( 
    ICrIris __RPC_FAR * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB ICrIris_put_irisStyle_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICrIris_INTERFACE_DEFINED__ */


#ifndef __ICrSlide_INTERFACE_DEFINED__
#define __ICrSlide_INTERFACE_DEFINED__

/* interface ICrSlide */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_ICrSlide;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("810E402E-056B-11D2-A484-00C04F8EFB69")
    ICrSlide : public IDXEffect
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_bands( 
            /* [retval][out] */ short __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_bands( 
            /* [in] */ short newVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_slideStyle( 
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_slideStyle( 
            /* [in] */ BSTR newVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICrSlideVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ICrSlide __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ICrSlide __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ICrSlide __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            ICrSlide __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            ICrSlide __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            ICrSlide __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            ICrSlide __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Capabilities )( 
            ICrSlide __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Progress )( 
            ICrSlide __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Progress )( 
            ICrSlide __RPC_FAR * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_StepResolution )( 
            ICrSlide __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Duration )( 
            ICrSlide __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Duration )( 
            ICrSlide __RPC_FAR * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_bands )( 
            ICrSlide __RPC_FAR * This,
            /* [retval][out] */ short __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_bands )( 
            ICrSlide __RPC_FAR * This,
            /* [in] */ short newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_slideStyle )( 
            ICrSlide __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_slideStyle )( 
            ICrSlide __RPC_FAR * This,
            /* [in] */ BSTR newVal);
        
        END_INTERFACE
    } ICrSlideVtbl;

    interface ICrSlide
    {
        CONST_VTBL struct ICrSlideVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICrSlide_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICrSlide_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICrSlide_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICrSlide_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ICrSlide_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ICrSlide_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ICrSlide_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ICrSlide_get_Capabilities(This,pVal)	\
    (This)->lpVtbl -> get_Capabilities(This,pVal)

#define ICrSlide_get_Progress(This,pVal)	\
    (This)->lpVtbl -> get_Progress(This,pVal)

#define ICrSlide_put_Progress(This,newVal)	\
    (This)->lpVtbl -> put_Progress(This,newVal)

#define ICrSlide_get_StepResolution(This,pVal)	\
    (This)->lpVtbl -> get_StepResolution(This,pVal)

#define ICrSlide_get_Duration(This,pVal)	\
    (This)->lpVtbl -> get_Duration(This,pVal)

#define ICrSlide_put_Duration(This,newVal)	\
    (This)->lpVtbl -> put_Duration(This,newVal)


#define ICrSlide_get_bands(This,pVal)	\
    (This)->lpVtbl -> get_bands(This,pVal)

#define ICrSlide_put_bands(This,newVal)	\
    (This)->lpVtbl -> put_bands(This,newVal)

#define ICrSlide_get_slideStyle(This,pVal)	\
    (This)->lpVtbl -> get_slideStyle(This,pVal)

#define ICrSlide_put_slideStyle(This,newVal)	\
    (This)->lpVtbl -> put_slideStyle(This,newVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE ICrSlide_get_bands_Proxy( 
    ICrSlide __RPC_FAR * This,
    /* [retval][out] */ short __RPC_FAR *pVal);


void __RPC_STUB ICrSlide_get_bands_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE ICrSlide_put_bands_Proxy( 
    ICrSlide __RPC_FAR * This,
    /* [in] */ short newVal);


void __RPC_STUB ICrSlide_put_bands_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE ICrSlide_get_slideStyle_Proxy( 
    ICrSlide __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB ICrSlide_get_slideStyle_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE ICrSlide_put_slideStyle_Proxy( 
    ICrSlide __RPC_FAR * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB ICrSlide_put_slideStyle_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICrSlide_INTERFACE_DEFINED__ */


#ifndef __ICrRadialWipe_INTERFACE_DEFINED__
#define __ICrRadialWipe_INTERFACE_DEFINED__

/* interface ICrRadialWipe */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_ICrRadialWipe;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("424B71AE-0695-11D2-A484-00C04F8EFB69")
    ICrRadialWipe : public IDXEffect
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_wipeStyle( 
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_wipeStyle( 
            /* [in] */ BSTR newVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICrRadialWipeVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ICrRadialWipe __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ICrRadialWipe __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ICrRadialWipe __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            ICrRadialWipe __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            ICrRadialWipe __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            ICrRadialWipe __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            ICrRadialWipe __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Capabilities )( 
            ICrRadialWipe __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Progress )( 
            ICrRadialWipe __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Progress )( 
            ICrRadialWipe __RPC_FAR * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_StepResolution )( 
            ICrRadialWipe __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Duration )( 
            ICrRadialWipe __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Duration )( 
            ICrRadialWipe __RPC_FAR * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_wipeStyle )( 
            ICrRadialWipe __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_wipeStyle )( 
            ICrRadialWipe __RPC_FAR * This,
            /* [in] */ BSTR newVal);
        
        END_INTERFACE
    } ICrRadialWipeVtbl;

    interface ICrRadialWipe
    {
        CONST_VTBL struct ICrRadialWipeVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICrRadialWipe_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICrRadialWipe_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICrRadialWipe_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICrRadialWipe_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ICrRadialWipe_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ICrRadialWipe_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ICrRadialWipe_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ICrRadialWipe_get_Capabilities(This,pVal)	\
    (This)->lpVtbl -> get_Capabilities(This,pVal)

#define ICrRadialWipe_get_Progress(This,pVal)	\
    (This)->lpVtbl -> get_Progress(This,pVal)

#define ICrRadialWipe_put_Progress(This,newVal)	\
    (This)->lpVtbl -> put_Progress(This,newVal)

#define ICrRadialWipe_get_StepResolution(This,pVal)	\
    (This)->lpVtbl -> get_StepResolution(This,pVal)

#define ICrRadialWipe_get_Duration(This,pVal)	\
    (This)->lpVtbl -> get_Duration(This,pVal)

#define ICrRadialWipe_put_Duration(This,newVal)	\
    (This)->lpVtbl -> put_Duration(This,newVal)


#define ICrRadialWipe_get_wipeStyle(This,pVal)	\
    (This)->lpVtbl -> get_wipeStyle(This,pVal)

#define ICrRadialWipe_put_wipeStyle(This,newVal)	\
    (This)->lpVtbl -> put_wipeStyle(This,newVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE ICrRadialWipe_get_wipeStyle_Proxy( 
    ICrRadialWipe __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB ICrRadialWipe_get_wipeStyle_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE ICrRadialWipe_put_wipeStyle_Proxy( 
    ICrRadialWipe __RPC_FAR * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB ICrRadialWipe_put_wipeStyle_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICrRadialWipe_INTERFACE_DEFINED__ */


#ifndef __ICrBarn_INTERFACE_DEFINED__
#define __ICrBarn_INTERFACE_DEFINED__

/* interface ICrBarn */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_ICrBarn;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("276A2EE0-0B5D-11d2-A484-00C04F8EFB69")
    ICrBarn : public IDXEffect
    {
    public:
    };
    
#else 	/* C style interface */

    typedef struct ICrBarnVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ICrBarn __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ICrBarn __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ICrBarn __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            ICrBarn __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            ICrBarn __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            ICrBarn __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            ICrBarn __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Capabilities )( 
            ICrBarn __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Progress )( 
            ICrBarn __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Progress )( 
            ICrBarn __RPC_FAR * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_StepResolution )( 
            ICrBarn __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Duration )( 
            ICrBarn __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Duration )( 
            ICrBarn __RPC_FAR * This,
            /* [in] */ float newVal);
        
        END_INTERFACE
    } ICrBarnVtbl;

    interface ICrBarn
    {
        CONST_VTBL struct ICrBarnVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICrBarn_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICrBarn_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICrBarn_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICrBarn_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ICrBarn_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ICrBarn_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ICrBarn_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ICrBarn_get_Capabilities(This,pVal)	\
    (This)->lpVtbl -> get_Capabilities(This,pVal)

#define ICrBarn_get_Progress(This,pVal)	\
    (This)->lpVtbl -> get_Progress(This,pVal)

#define ICrBarn_put_Progress(This,newVal)	\
    (This)->lpVtbl -> put_Progress(This,newVal)

#define ICrBarn_get_StepResolution(This,pVal)	\
    (This)->lpVtbl -> get_StepResolution(This,pVal)

#define ICrBarn_get_Duration(This,pVal)	\
    (This)->lpVtbl -> get_Duration(This,pVal)

#define ICrBarn_put_Duration(This,newVal)	\
    (This)->lpVtbl -> put_Duration(This,newVal)


#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ICrBarn_INTERFACE_DEFINED__ */


#ifndef __ICrBlinds_INTERFACE_DEFINED__
#define __ICrBlinds_INTERFACE_DEFINED__

/* interface ICrBlinds */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_ICrBlinds;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("5AF5C340-0BA9-11d2-A484-00C04F8EFB69")
    ICrBlinds : public IDXEffect
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_bands( 
            /* [retval][out] */ short __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_bands( 
            /* [in] */ short newVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICrBlindsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ICrBlinds __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ICrBlinds __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ICrBlinds __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            ICrBlinds __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            ICrBlinds __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            ICrBlinds __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            ICrBlinds __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Capabilities )( 
            ICrBlinds __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Progress )( 
            ICrBlinds __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Progress )( 
            ICrBlinds __RPC_FAR * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_StepResolution )( 
            ICrBlinds __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Duration )( 
            ICrBlinds __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Duration )( 
            ICrBlinds __RPC_FAR * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_bands )( 
            ICrBlinds __RPC_FAR * This,
            /* [retval][out] */ short __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_bands )( 
            ICrBlinds __RPC_FAR * This,
            /* [in] */ short newVal);
        
        END_INTERFACE
    } ICrBlindsVtbl;

    interface ICrBlinds
    {
        CONST_VTBL struct ICrBlindsVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICrBlinds_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICrBlinds_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICrBlinds_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICrBlinds_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ICrBlinds_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ICrBlinds_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ICrBlinds_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ICrBlinds_get_Capabilities(This,pVal)	\
    (This)->lpVtbl -> get_Capabilities(This,pVal)

#define ICrBlinds_get_Progress(This,pVal)	\
    (This)->lpVtbl -> get_Progress(This,pVal)

#define ICrBlinds_put_Progress(This,newVal)	\
    (This)->lpVtbl -> put_Progress(This,newVal)

#define ICrBlinds_get_StepResolution(This,pVal)	\
    (This)->lpVtbl -> get_StepResolution(This,pVal)

#define ICrBlinds_get_Duration(This,pVal)	\
    (This)->lpVtbl -> get_Duration(This,pVal)

#define ICrBlinds_put_Duration(This,newVal)	\
    (This)->lpVtbl -> put_Duration(This,newVal)


#define ICrBlinds_get_bands(This,pVal)	\
    (This)->lpVtbl -> get_bands(This,pVal)

#define ICrBlinds_put_bands(This,newVal)	\
    (This)->lpVtbl -> put_bands(This,newVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE ICrBlinds_get_bands_Proxy( 
    ICrBlinds __RPC_FAR * This,
    /* [retval][out] */ short __RPC_FAR *pVal);


void __RPC_STUB ICrBlinds_get_bands_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE ICrBlinds_put_bands_Proxy( 
    ICrBlinds __RPC_FAR * This,
    /* [in] */ short newVal);


void __RPC_STUB ICrBlinds_put_bands_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICrBlinds_INTERFACE_DEFINED__ */


#ifndef __ICrInset_INTERFACE_DEFINED__
#define __ICrInset_INTERFACE_DEFINED__

/* interface ICrInset */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_ICrInset;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("05C5EE20-0BA6-11d2-A484-00C04F8EFB69")
    ICrInset : public IDXEffect
    {
    public:
    };
    
#else 	/* C style interface */

    typedef struct ICrInsetVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ICrInset __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ICrInset __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ICrInset __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            ICrInset __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            ICrInset __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            ICrInset __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            ICrInset __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Capabilities )( 
            ICrInset __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Progress )( 
            ICrInset __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Progress )( 
            ICrInset __RPC_FAR * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_StepResolution )( 
            ICrInset __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Duration )( 
            ICrInset __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Duration )( 
            ICrInset __RPC_FAR * This,
            /* [in] */ float newVal);
        
        END_INTERFACE
    } ICrInsetVtbl;

    interface ICrInset
    {
        CONST_VTBL struct ICrInsetVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICrInset_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICrInset_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICrInset_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICrInset_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ICrInset_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ICrInset_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ICrInset_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ICrInset_get_Capabilities(This,pVal)	\
    (This)->lpVtbl -> get_Capabilities(This,pVal)

#define ICrInset_get_Progress(This,pVal)	\
    (This)->lpVtbl -> get_Progress(This,pVal)

#define ICrInset_put_Progress(This,newVal)	\
    (This)->lpVtbl -> put_Progress(This,newVal)

#define ICrInset_get_StepResolution(This,pVal)	\
    (This)->lpVtbl -> get_StepResolution(This,pVal)

#define ICrInset_get_Duration(This,pVal)	\
    (This)->lpVtbl -> get_Duration(This,pVal)

#define ICrInset_put_Duration(This,newVal)	\
    (This)->lpVtbl -> put_Duration(This,newVal)


#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ICrInset_INTERFACE_DEFINED__ */


#ifndef __ICrStretch_INTERFACE_DEFINED__
#define __ICrStretch_INTERFACE_DEFINED__

/* interface ICrStretch */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_ICrStretch;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("6684AF00-0A87-11d2-A484-00C04F8EFB69")
    ICrStretch : public IDXEffect
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_stretchStyle( 
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_stretchStyle( 
            /* [in] */ BSTR newVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICrStretchVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ICrStretch __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ICrStretch __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ICrStretch __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            ICrStretch __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            ICrStretch __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            ICrStretch __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            ICrStretch __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Capabilities )( 
            ICrStretch __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Progress )( 
            ICrStretch __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Progress )( 
            ICrStretch __RPC_FAR * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_StepResolution )( 
            ICrStretch __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Duration )( 
            ICrStretch __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Duration )( 
            ICrStretch __RPC_FAR * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_stretchStyle )( 
            ICrStretch __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_stretchStyle )( 
            ICrStretch __RPC_FAR * This,
            /* [in] */ BSTR newVal);
        
        END_INTERFACE
    } ICrStretchVtbl;

    interface ICrStretch
    {
        CONST_VTBL struct ICrStretchVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICrStretch_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICrStretch_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICrStretch_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICrStretch_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ICrStretch_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ICrStretch_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ICrStretch_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ICrStretch_get_Capabilities(This,pVal)	\
    (This)->lpVtbl -> get_Capabilities(This,pVal)

#define ICrStretch_get_Progress(This,pVal)	\
    (This)->lpVtbl -> get_Progress(This,pVal)

#define ICrStretch_put_Progress(This,newVal)	\
    (This)->lpVtbl -> put_Progress(This,newVal)

#define ICrStretch_get_StepResolution(This,pVal)	\
    (This)->lpVtbl -> get_StepResolution(This,pVal)

#define ICrStretch_get_Duration(This,pVal)	\
    (This)->lpVtbl -> get_Duration(This,pVal)

#define ICrStretch_put_Duration(This,newVal)	\
    (This)->lpVtbl -> put_Duration(This,newVal)


#define ICrStretch_get_stretchStyle(This,pVal)	\
    (This)->lpVtbl -> get_stretchStyle(This,pVal)

#define ICrStretch_put_stretchStyle(This,newVal)	\
    (This)->lpVtbl -> put_stretchStyle(This,newVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE ICrStretch_get_stretchStyle_Proxy( 
    ICrStretch __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB ICrStretch_get_stretchStyle_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE ICrStretch_put_stretchStyle_Proxy( 
    ICrStretch __RPC_FAR * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB ICrStretch_put_stretchStyle_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICrStretch_INTERFACE_DEFINED__ */


#ifndef __ICrSpiral_INTERFACE_DEFINED__
#define __ICrSpiral_INTERFACE_DEFINED__

/* interface ICrSpiral */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_ICrSpiral;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("0DE527A0-0C7E-11d2-A484-00C04F8EFB69")
    ICrSpiral : public IDXEffect
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_gridSizeX( 
            /* [retval][out] */ short __RPC_FAR *pX) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_gridSizeX( 
            /* [in] */ short newX) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_gridSizeY( 
            /* [retval][out] */ short __RPC_FAR *pY) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_gridSizeY( 
            /* [in] */ short newY) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICrSpiralVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ICrSpiral __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ICrSpiral __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ICrSpiral __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            ICrSpiral __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            ICrSpiral __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            ICrSpiral __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            ICrSpiral __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Capabilities )( 
            ICrSpiral __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Progress )( 
            ICrSpiral __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Progress )( 
            ICrSpiral __RPC_FAR * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_StepResolution )( 
            ICrSpiral __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Duration )( 
            ICrSpiral __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Duration )( 
            ICrSpiral __RPC_FAR * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_gridSizeX )( 
            ICrSpiral __RPC_FAR * This,
            /* [retval][out] */ short __RPC_FAR *pX);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_gridSizeX )( 
            ICrSpiral __RPC_FAR * This,
            /* [in] */ short newX);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_gridSizeY )( 
            ICrSpiral __RPC_FAR * This,
            /* [retval][out] */ short __RPC_FAR *pY);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_gridSizeY )( 
            ICrSpiral __RPC_FAR * This,
            /* [in] */ short newY);
        
        END_INTERFACE
    } ICrSpiralVtbl;

    interface ICrSpiral
    {
        CONST_VTBL struct ICrSpiralVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICrSpiral_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICrSpiral_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICrSpiral_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICrSpiral_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ICrSpiral_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ICrSpiral_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ICrSpiral_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ICrSpiral_get_Capabilities(This,pVal)	\
    (This)->lpVtbl -> get_Capabilities(This,pVal)

#define ICrSpiral_get_Progress(This,pVal)	\
    (This)->lpVtbl -> get_Progress(This,pVal)

#define ICrSpiral_put_Progress(This,newVal)	\
    (This)->lpVtbl -> put_Progress(This,newVal)

#define ICrSpiral_get_StepResolution(This,pVal)	\
    (This)->lpVtbl -> get_StepResolution(This,pVal)

#define ICrSpiral_get_Duration(This,pVal)	\
    (This)->lpVtbl -> get_Duration(This,pVal)

#define ICrSpiral_put_Duration(This,newVal)	\
    (This)->lpVtbl -> put_Duration(This,newVal)


#define ICrSpiral_get_gridSizeX(This,pX)	\
    (This)->lpVtbl -> get_gridSizeX(This,pX)

#define ICrSpiral_put_gridSizeX(This,newX)	\
    (This)->lpVtbl -> put_gridSizeX(This,newX)

#define ICrSpiral_get_gridSizeY(This,pY)	\
    (This)->lpVtbl -> get_gridSizeY(This,pY)

#define ICrSpiral_put_gridSizeY(This,newY)	\
    (This)->lpVtbl -> put_gridSizeY(This,newY)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE ICrSpiral_get_gridSizeX_Proxy( 
    ICrSpiral __RPC_FAR * This,
    /* [retval][out] */ short __RPC_FAR *pX);


void __RPC_STUB ICrSpiral_get_gridSizeX_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE ICrSpiral_put_gridSizeX_Proxy( 
    ICrSpiral __RPC_FAR * This,
    /* [in] */ short newX);


void __RPC_STUB ICrSpiral_put_gridSizeX_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE ICrSpiral_get_gridSizeY_Proxy( 
    ICrSpiral __RPC_FAR * This,
    /* [retval][out] */ short __RPC_FAR *pY);


void __RPC_STUB ICrSpiral_get_gridSizeY_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE ICrSpiral_put_gridSizeY_Proxy( 
    ICrSpiral __RPC_FAR * This,
    /* [in] */ short newY);


void __RPC_STUB ICrSpiral_put_gridSizeY_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICrSpiral_INTERFACE_DEFINED__ */


#ifndef __ICrZigzag_INTERFACE_DEFINED__
#define __ICrZigzag_INTERFACE_DEFINED__

/* interface ICrZigzag */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_ICrZigzag;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("4E5A64A0-0C8B-11d2-A484-00C04F8EFB69")
    ICrZigzag : public IDXEffect
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_gridSizeX( 
            /* [retval][out] */ short __RPC_FAR *pX) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_gridSizeX( 
            /* [in] */ short newX) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_gridSizeY( 
            /* [retval][out] */ short __RPC_FAR *pY) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_gridSizeY( 
            /* [in] */ short newY) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICrZigzagVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ICrZigzag __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ICrZigzag __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ICrZigzag __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            ICrZigzag __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            ICrZigzag __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            ICrZigzag __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            ICrZigzag __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Capabilities )( 
            ICrZigzag __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Progress )( 
            ICrZigzag __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Progress )( 
            ICrZigzag __RPC_FAR * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_StepResolution )( 
            ICrZigzag __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Duration )( 
            ICrZigzag __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Duration )( 
            ICrZigzag __RPC_FAR * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_gridSizeX )( 
            ICrZigzag __RPC_FAR * This,
            /* [retval][out] */ short __RPC_FAR *pX);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_gridSizeX )( 
            ICrZigzag __RPC_FAR * This,
            /* [in] */ short newX);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_gridSizeY )( 
            ICrZigzag __RPC_FAR * This,
            /* [retval][out] */ short __RPC_FAR *pY);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_gridSizeY )( 
            ICrZigzag __RPC_FAR * This,
            /* [in] */ short newY);
        
        END_INTERFACE
    } ICrZigzagVtbl;

    interface ICrZigzag
    {
        CONST_VTBL struct ICrZigzagVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICrZigzag_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICrZigzag_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICrZigzag_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICrZigzag_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ICrZigzag_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ICrZigzag_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ICrZigzag_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ICrZigzag_get_Capabilities(This,pVal)	\
    (This)->lpVtbl -> get_Capabilities(This,pVal)

#define ICrZigzag_get_Progress(This,pVal)	\
    (This)->lpVtbl -> get_Progress(This,pVal)

#define ICrZigzag_put_Progress(This,newVal)	\
    (This)->lpVtbl -> put_Progress(This,newVal)

#define ICrZigzag_get_StepResolution(This,pVal)	\
    (This)->lpVtbl -> get_StepResolution(This,pVal)

#define ICrZigzag_get_Duration(This,pVal)	\
    (This)->lpVtbl -> get_Duration(This,pVal)

#define ICrZigzag_put_Duration(This,newVal)	\
    (This)->lpVtbl -> put_Duration(This,newVal)


#define ICrZigzag_get_gridSizeX(This,pX)	\
    (This)->lpVtbl -> get_gridSizeX(This,pX)

#define ICrZigzag_put_gridSizeX(This,newX)	\
    (This)->lpVtbl -> put_gridSizeX(This,newX)

#define ICrZigzag_get_gridSizeY(This,pY)	\
    (This)->lpVtbl -> get_gridSizeY(This,pY)

#define ICrZigzag_put_gridSizeY(This,newY)	\
    (This)->lpVtbl -> put_gridSizeY(This,newY)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE ICrZigzag_get_gridSizeX_Proxy( 
    ICrZigzag __RPC_FAR * This,
    /* [retval][out] */ short __RPC_FAR *pX);


void __RPC_STUB ICrZigzag_get_gridSizeX_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE ICrZigzag_put_gridSizeX_Proxy( 
    ICrZigzag __RPC_FAR * This,
    /* [in] */ short newX);


void __RPC_STUB ICrZigzag_put_gridSizeX_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE ICrZigzag_get_gridSizeY_Proxy( 
    ICrZigzag __RPC_FAR * This,
    /* [retval][out] */ short __RPC_FAR *pY);


void __RPC_STUB ICrZigzag_get_gridSizeY_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE ICrZigzag_put_gridSizeY_Proxy( 
    ICrZigzag __RPC_FAR * This,
    /* [in] */ short newY);


void __RPC_STUB ICrZigzag_put_gridSizeY_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICrZigzag_INTERFACE_DEFINED__ */


#ifndef __ICrWheel_INTERFACE_DEFINED__
#define __ICrWheel_INTERFACE_DEFINED__

/* interface ICrWheel */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_ICrWheel;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3943DE80-1464-11d2-A484-00C04F8EFB69")
    ICrWheel : public IDXEffect
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_spokes( 
            /* [retval][out] */ short __RPC_FAR *pX) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_spokes( 
            /* [in] */ short newX) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICrWheelVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ICrWheel __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ICrWheel __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ICrWheel __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            ICrWheel __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            ICrWheel __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            ICrWheel __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            ICrWheel __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Capabilities )( 
            ICrWheel __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Progress )( 
            ICrWheel __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Progress )( 
            ICrWheel __RPC_FAR * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_StepResolution )( 
            ICrWheel __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Duration )( 
            ICrWheel __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Duration )( 
            ICrWheel __RPC_FAR * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_spokes )( 
            ICrWheel __RPC_FAR * This,
            /* [retval][out] */ short __RPC_FAR *pX);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_spokes )( 
            ICrWheel __RPC_FAR * This,
            /* [in] */ short newX);
        
        END_INTERFACE
    } ICrWheelVtbl;

    interface ICrWheel
    {
        CONST_VTBL struct ICrWheelVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICrWheel_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICrWheel_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICrWheel_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICrWheel_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ICrWheel_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ICrWheel_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ICrWheel_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ICrWheel_get_Capabilities(This,pVal)	\
    (This)->lpVtbl -> get_Capabilities(This,pVal)

#define ICrWheel_get_Progress(This,pVal)	\
    (This)->lpVtbl -> get_Progress(This,pVal)

#define ICrWheel_put_Progress(This,newVal)	\
    (This)->lpVtbl -> put_Progress(This,newVal)

#define ICrWheel_get_StepResolution(This,pVal)	\
    (This)->lpVtbl -> get_StepResolution(This,pVal)

#define ICrWheel_get_Duration(This,pVal)	\
    (This)->lpVtbl -> get_Duration(This,pVal)

#define ICrWheel_put_Duration(This,newVal)	\
    (This)->lpVtbl -> put_Duration(This,newVal)


#define ICrWheel_get_spokes(This,pX)	\
    (This)->lpVtbl -> get_spokes(This,pX)

#define ICrWheel_put_spokes(This,newX)	\
    (This)->lpVtbl -> put_spokes(This,newX)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE ICrWheel_get_spokes_Proxy( 
    ICrWheel __RPC_FAR * This,
    /* [retval][out] */ short __RPC_FAR *pX);


void __RPC_STUB ICrWheel_get_spokes_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE ICrWheel_put_spokes_Proxy( 
    ICrWheel __RPC_FAR * This,
    /* [in] */ short newX);


void __RPC_STUB ICrWheel_put_spokes_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICrWheel_INTERFACE_DEFINED__ */


#ifndef __IDXTChroma_INTERFACE_DEFINED__
#define __IDXTChroma_INTERFACE_DEFINED__

/* interface IDXTChroma */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IDXTChroma;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("1D4637E2-383C-11d2-952A-00C04FA34F05")
    IDXTChroma : public IDispatch
    {
    public:
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Color( 
            /* [in] */ VARIANT newVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Color( 
            /* [retval][out] */ VARIANT __RPC_FAR *pVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDXTChromaVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDXTChroma __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDXTChroma __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDXTChroma __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IDXTChroma __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IDXTChroma __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IDXTChroma __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IDXTChroma __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Color )( 
            IDXTChroma __RPC_FAR * This,
            /* [in] */ VARIANT newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Color )( 
            IDXTChroma __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *pVal);
        
        END_INTERFACE
    } IDXTChromaVtbl;

    interface IDXTChroma
    {
        CONST_VTBL struct IDXTChromaVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDXTChroma_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDXTChroma_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDXTChroma_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDXTChroma_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IDXTChroma_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IDXTChroma_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IDXTChroma_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IDXTChroma_put_Color(This,newVal)	\
    (This)->lpVtbl -> put_Color(This,newVal)

#define IDXTChroma_get_Color(This,pVal)	\
    (This)->lpVtbl -> get_Color(This,pVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTChroma_put_Color_Proxy( 
    IDXTChroma __RPC_FAR * This,
    /* [in] */ VARIANT newVal);


void __RPC_STUB IDXTChroma_put_Color_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTChroma_get_Color_Proxy( 
    IDXTChroma __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *pVal);


void __RPC_STUB IDXTChroma_get_Color_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDXTChroma_INTERFACE_DEFINED__ */


#ifndef __IDXTDropShadow_INTERFACE_DEFINED__
#define __IDXTDropShadow_INTERFACE_DEFINED__

/* interface IDXTDropShadow */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IDXTDropShadow;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("1D4637E3-383C-11d2-952A-00C04FA34F05")
    IDXTDropShadow : public IDispatch
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Color( 
            /* [retval][out] */ VARIANT __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Color( 
            /* [in] */ VARIANT newVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_OffX( 
            /* [retval][out] */ int __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_OffX( 
            /* [in] */ int newVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_OffY( 
            /* [retval][out] */ int __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_OffY( 
            /* [in] */ int newVal) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Positive( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Positive( 
            /* [in] */ VARIANT_BOOL newVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDXTDropShadowVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDXTDropShadow __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDXTDropShadow __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDXTDropShadow __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IDXTDropShadow __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IDXTDropShadow __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IDXTDropShadow __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IDXTDropShadow __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Color )( 
            IDXTDropShadow __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Color )( 
            IDXTDropShadow __RPC_FAR * This,
            /* [in] */ VARIANT newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_OffX )( 
            IDXTDropShadow __RPC_FAR * This,
            /* [retval][out] */ int __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_OffX )( 
            IDXTDropShadow __RPC_FAR * This,
            /* [in] */ int newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_OffY )( 
            IDXTDropShadow __RPC_FAR * This,
            /* [retval][out] */ int __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_OffY )( 
            IDXTDropShadow __RPC_FAR * This,
            /* [in] */ int newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Positive )( 
            IDXTDropShadow __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Positive )( 
            IDXTDropShadow __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL newVal);
        
        END_INTERFACE
    } IDXTDropShadowVtbl;

    interface IDXTDropShadow
    {
        CONST_VTBL struct IDXTDropShadowVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDXTDropShadow_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDXTDropShadow_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDXTDropShadow_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDXTDropShadow_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IDXTDropShadow_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IDXTDropShadow_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IDXTDropShadow_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IDXTDropShadow_get_Color(This,pVal)	\
    (This)->lpVtbl -> get_Color(This,pVal)

#define IDXTDropShadow_put_Color(This,newVal)	\
    (This)->lpVtbl -> put_Color(This,newVal)

#define IDXTDropShadow_get_OffX(This,pVal)	\
    (This)->lpVtbl -> get_OffX(This,pVal)

#define IDXTDropShadow_put_OffX(This,newVal)	\
    (This)->lpVtbl -> put_OffX(This,newVal)

#define IDXTDropShadow_get_OffY(This,pVal)	\
    (This)->lpVtbl -> get_OffY(This,pVal)

#define IDXTDropShadow_put_OffY(This,newVal)	\
    (This)->lpVtbl -> put_OffY(This,newVal)

#define IDXTDropShadow_get_Positive(This,pVal)	\
    (This)->lpVtbl -> get_Positive(This,pVal)

#define IDXTDropShadow_put_Positive(This,newVal)	\
    (This)->lpVtbl -> put_Positive(This,newVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTDropShadow_get_Color_Proxy( 
    IDXTDropShadow __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *pVal);


void __RPC_STUB IDXTDropShadow_get_Color_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTDropShadow_put_Color_Proxy( 
    IDXTDropShadow __RPC_FAR * This,
    /* [in] */ VARIANT newVal);


void __RPC_STUB IDXTDropShadow_put_Color_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTDropShadow_get_OffX_Proxy( 
    IDXTDropShadow __RPC_FAR * This,
    /* [retval][out] */ int __RPC_FAR *pVal);


void __RPC_STUB IDXTDropShadow_get_OffX_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTDropShadow_put_OffX_Proxy( 
    IDXTDropShadow __RPC_FAR * This,
    /* [in] */ int newVal);


void __RPC_STUB IDXTDropShadow_put_OffX_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTDropShadow_get_OffY_Proxy( 
    IDXTDropShadow __RPC_FAR * This,
    /* [retval][out] */ int __RPC_FAR *pVal);


void __RPC_STUB IDXTDropShadow_get_OffY_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTDropShadow_put_OffY_Proxy( 
    IDXTDropShadow __RPC_FAR * This,
    /* [in] */ int newVal);


void __RPC_STUB IDXTDropShadow_put_OffY_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTDropShadow_get_Positive_Proxy( 
    IDXTDropShadow __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pVal);


void __RPC_STUB IDXTDropShadow_get_Positive_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTDropShadow_put_Positive_Proxy( 
    IDXTDropShadow __RPC_FAR * This,
    /* [in] */ VARIANT_BOOL newVal);


void __RPC_STUB IDXTDropShadow_put_Positive_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDXTDropShadow_INTERFACE_DEFINED__ */


#ifndef __IDXTMetaRoll_INTERFACE_DEFINED__
#define __IDXTMetaRoll_INTERFACE_DEFINED__

/* interface IDXTMetaRoll */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IDXTMetaRoll;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("9C61F46D-0530-11D2-8F98-00C04FB92EB7")
    IDXTMetaRoll : public IDXEffect
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Copyright( 
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Copyright( 
            /* [in] */ BSTR newVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDXTMetaRollVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDXTMetaRoll __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDXTMetaRoll __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDXTMetaRoll __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IDXTMetaRoll __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IDXTMetaRoll __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IDXTMetaRoll __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IDXTMetaRoll __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Capabilities )( 
            IDXTMetaRoll __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Progress )( 
            IDXTMetaRoll __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Progress )( 
            IDXTMetaRoll __RPC_FAR * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_StepResolution )( 
            IDXTMetaRoll __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Duration )( 
            IDXTMetaRoll __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Duration )( 
            IDXTMetaRoll __RPC_FAR * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Copyright )( 
            IDXTMetaRoll __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Copyright )( 
            IDXTMetaRoll __RPC_FAR * This,
            /* [in] */ BSTR newVal);
        
        END_INTERFACE
    } IDXTMetaRollVtbl;

    interface IDXTMetaRoll
    {
        CONST_VTBL struct IDXTMetaRollVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDXTMetaRoll_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDXTMetaRoll_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDXTMetaRoll_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDXTMetaRoll_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IDXTMetaRoll_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IDXTMetaRoll_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IDXTMetaRoll_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IDXTMetaRoll_get_Capabilities(This,pVal)	\
    (This)->lpVtbl -> get_Capabilities(This,pVal)

#define IDXTMetaRoll_get_Progress(This,pVal)	\
    (This)->lpVtbl -> get_Progress(This,pVal)

#define IDXTMetaRoll_put_Progress(This,newVal)	\
    (This)->lpVtbl -> put_Progress(This,newVal)

#define IDXTMetaRoll_get_StepResolution(This,pVal)	\
    (This)->lpVtbl -> get_StepResolution(This,pVal)

#define IDXTMetaRoll_get_Duration(This,pVal)	\
    (This)->lpVtbl -> get_Duration(This,pVal)

#define IDXTMetaRoll_put_Duration(This,newVal)	\
    (This)->lpVtbl -> put_Duration(This,newVal)


#define IDXTMetaRoll_get_Copyright(This,pVal)	\
    (This)->lpVtbl -> get_Copyright(This,pVal)

#define IDXTMetaRoll_put_Copyright(This,newVal)	\
    (This)->lpVtbl -> put_Copyright(This,newVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTMetaRoll_get_Copyright_Proxy( 
    IDXTMetaRoll __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB IDXTMetaRoll_get_Copyright_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTMetaRoll_put_Copyright_Proxy( 
    IDXTMetaRoll __RPC_FAR * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IDXTMetaRoll_put_Copyright_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDXTMetaRoll_INTERFACE_DEFINED__ */


#ifndef __IDXTMetaRipple_INTERFACE_DEFINED__
#define __IDXTMetaRipple_INTERFACE_DEFINED__

/* interface IDXTMetaRipple */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IDXTMetaRipple;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("AA0D4D02-06A3-11D2-8F98-00C04FB92EB7")
    IDXTMetaRipple : public IDXEffect
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Copyright( 
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Copyright( 
            /* [in] */ BSTR newVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDXTMetaRippleVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDXTMetaRipple __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDXTMetaRipple __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDXTMetaRipple __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IDXTMetaRipple __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IDXTMetaRipple __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IDXTMetaRipple __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IDXTMetaRipple __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Capabilities )( 
            IDXTMetaRipple __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Progress )( 
            IDXTMetaRipple __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Progress )( 
            IDXTMetaRipple __RPC_FAR * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_StepResolution )( 
            IDXTMetaRipple __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Duration )( 
            IDXTMetaRipple __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Duration )( 
            IDXTMetaRipple __RPC_FAR * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Copyright )( 
            IDXTMetaRipple __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Copyright )( 
            IDXTMetaRipple __RPC_FAR * This,
            /* [in] */ BSTR newVal);
        
        END_INTERFACE
    } IDXTMetaRippleVtbl;

    interface IDXTMetaRipple
    {
        CONST_VTBL struct IDXTMetaRippleVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDXTMetaRipple_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDXTMetaRipple_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDXTMetaRipple_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDXTMetaRipple_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IDXTMetaRipple_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IDXTMetaRipple_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IDXTMetaRipple_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IDXTMetaRipple_get_Capabilities(This,pVal)	\
    (This)->lpVtbl -> get_Capabilities(This,pVal)

#define IDXTMetaRipple_get_Progress(This,pVal)	\
    (This)->lpVtbl -> get_Progress(This,pVal)

#define IDXTMetaRipple_put_Progress(This,newVal)	\
    (This)->lpVtbl -> put_Progress(This,newVal)

#define IDXTMetaRipple_get_StepResolution(This,pVal)	\
    (This)->lpVtbl -> get_StepResolution(This,pVal)

#define IDXTMetaRipple_get_Duration(This,pVal)	\
    (This)->lpVtbl -> get_Duration(This,pVal)

#define IDXTMetaRipple_put_Duration(This,newVal)	\
    (This)->lpVtbl -> put_Duration(This,newVal)


#define IDXTMetaRipple_get_Copyright(This,pVal)	\
    (This)->lpVtbl -> get_Copyright(This,pVal)

#define IDXTMetaRipple_put_Copyright(This,newVal)	\
    (This)->lpVtbl -> put_Copyright(This,newVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTMetaRipple_get_Copyright_Proxy( 
    IDXTMetaRipple __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB IDXTMetaRipple_get_Copyright_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTMetaRipple_put_Copyright_Proxy( 
    IDXTMetaRipple __RPC_FAR * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IDXTMetaRipple_put_Copyright_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDXTMetaRipple_INTERFACE_DEFINED__ */


#ifndef __IDXTMetaPageTurn_INTERFACE_DEFINED__
#define __IDXTMetaPageTurn_INTERFACE_DEFINED__

/* interface IDXTMetaPageTurn */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IDXTMetaPageTurn;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("AA0D4D07-06A3-11D2-8F98-00C04FB92EB7")
    IDXTMetaPageTurn : public IDXEffect
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Copyright( 
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Copyright( 
            /* [in] */ BSTR newVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDXTMetaPageTurnVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDXTMetaPageTurn __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDXTMetaPageTurn __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDXTMetaPageTurn __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IDXTMetaPageTurn __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IDXTMetaPageTurn __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IDXTMetaPageTurn __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IDXTMetaPageTurn __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Capabilities )( 
            IDXTMetaPageTurn __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Progress )( 
            IDXTMetaPageTurn __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Progress )( 
            IDXTMetaPageTurn __RPC_FAR * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_StepResolution )( 
            IDXTMetaPageTurn __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Duration )( 
            IDXTMetaPageTurn __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Duration )( 
            IDXTMetaPageTurn __RPC_FAR * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Copyright )( 
            IDXTMetaPageTurn __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Copyright )( 
            IDXTMetaPageTurn __RPC_FAR * This,
            /* [in] */ BSTR newVal);
        
        END_INTERFACE
    } IDXTMetaPageTurnVtbl;

    interface IDXTMetaPageTurn
    {
        CONST_VTBL struct IDXTMetaPageTurnVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDXTMetaPageTurn_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDXTMetaPageTurn_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDXTMetaPageTurn_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDXTMetaPageTurn_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IDXTMetaPageTurn_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IDXTMetaPageTurn_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IDXTMetaPageTurn_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IDXTMetaPageTurn_get_Capabilities(This,pVal)	\
    (This)->lpVtbl -> get_Capabilities(This,pVal)

#define IDXTMetaPageTurn_get_Progress(This,pVal)	\
    (This)->lpVtbl -> get_Progress(This,pVal)

#define IDXTMetaPageTurn_put_Progress(This,newVal)	\
    (This)->lpVtbl -> put_Progress(This,newVal)

#define IDXTMetaPageTurn_get_StepResolution(This,pVal)	\
    (This)->lpVtbl -> get_StepResolution(This,pVal)

#define IDXTMetaPageTurn_get_Duration(This,pVal)	\
    (This)->lpVtbl -> get_Duration(This,pVal)

#define IDXTMetaPageTurn_put_Duration(This,newVal)	\
    (This)->lpVtbl -> put_Duration(This,newVal)


#define IDXTMetaPageTurn_get_Copyright(This,pVal)	\
    (This)->lpVtbl -> get_Copyright(This,pVal)

#define IDXTMetaPageTurn_put_Copyright(This,newVal)	\
    (This)->lpVtbl -> put_Copyright(This,newVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTMetaPageTurn_get_Copyright_Proxy( 
    IDXTMetaPageTurn __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB IDXTMetaPageTurn_get_Copyright_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTMetaPageTurn_put_Copyright_Proxy( 
    IDXTMetaPageTurn __RPC_FAR * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IDXTMetaPageTurn_put_Copyright_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDXTMetaPageTurn_INTERFACE_DEFINED__ */


#ifndef __IDXTMetaLiquid_INTERFACE_DEFINED__
#define __IDXTMetaLiquid_INTERFACE_DEFINED__

/* interface IDXTMetaLiquid */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IDXTMetaLiquid;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("AA0D4D09-06A3-11D2-8F98-00C04FB92EB7")
    IDXTMetaLiquid : public IDXEffect
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Copyright( 
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Copyright( 
            /* [in] */ BSTR newVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDXTMetaLiquidVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDXTMetaLiquid __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDXTMetaLiquid __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDXTMetaLiquid __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IDXTMetaLiquid __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IDXTMetaLiquid __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IDXTMetaLiquid __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IDXTMetaLiquid __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Capabilities )( 
            IDXTMetaLiquid __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Progress )( 
            IDXTMetaLiquid __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Progress )( 
            IDXTMetaLiquid __RPC_FAR * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_StepResolution )( 
            IDXTMetaLiquid __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Duration )( 
            IDXTMetaLiquid __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Duration )( 
            IDXTMetaLiquid __RPC_FAR * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Copyright )( 
            IDXTMetaLiquid __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Copyright )( 
            IDXTMetaLiquid __RPC_FAR * This,
            /* [in] */ BSTR newVal);
        
        END_INTERFACE
    } IDXTMetaLiquidVtbl;

    interface IDXTMetaLiquid
    {
        CONST_VTBL struct IDXTMetaLiquidVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDXTMetaLiquid_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDXTMetaLiquid_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDXTMetaLiquid_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDXTMetaLiquid_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IDXTMetaLiquid_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IDXTMetaLiquid_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IDXTMetaLiquid_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IDXTMetaLiquid_get_Capabilities(This,pVal)	\
    (This)->lpVtbl -> get_Capabilities(This,pVal)

#define IDXTMetaLiquid_get_Progress(This,pVal)	\
    (This)->lpVtbl -> get_Progress(This,pVal)

#define IDXTMetaLiquid_put_Progress(This,newVal)	\
    (This)->lpVtbl -> put_Progress(This,newVal)

#define IDXTMetaLiquid_get_StepResolution(This,pVal)	\
    (This)->lpVtbl -> get_StepResolution(This,pVal)

#define IDXTMetaLiquid_get_Duration(This,pVal)	\
    (This)->lpVtbl -> get_Duration(This,pVal)

#define IDXTMetaLiquid_put_Duration(This,newVal)	\
    (This)->lpVtbl -> put_Duration(This,newVal)


#define IDXTMetaLiquid_get_Copyright(This,pVal)	\
    (This)->lpVtbl -> get_Copyright(This,pVal)

#define IDXTMetaLiquid_put_Copyright(This,newVal)	\
    (This)->lpVtbl -> put_Copyright(This,newVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTMetaLiquid_get_Copyright_Proxy( 
    IDXTMetaLiquid __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB IDXTMetaLiquid_get_Copyright_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTMetaLiquid_put_Copyright_Proxy( 
    IDXTMetaLiquid __RPC_FAR * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IDXTMetaLiquid_put_Copyright_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDXTMetaLiquid_INTERFACE_DEFINED__ */


#ifndef __IDXTMetaCenterPeel_INTERFACE_DEFINED__
#define __IDXTMetaCenterPeel_INTERFACE_DEFINED__

/* interface IDXTMetaCenterPeel */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IDXTMetaCenterPeel;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("AA0D4D0B-06A3-11D2-8F98-00C04FB92EB7")
    IDXTMetaCenterPeel : public IDXEffect
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Copyright( 
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Copyright( 
            /* [in] */ BSTR newVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDXTMetaCenterPeelVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDXTMetaCenterPeel __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDXTMetaCenterPeel __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDXTMetaCenterPeel __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IDXTMetaCenterPeel __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IDXTMetaCenterPeel __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IDXTMetaCenterPeel __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IDXTMetaCenterPeel __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Capabilities )( 
            IDXTMetaCenterPeel __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Progress )( 
            IDXTMetaCenterPeel __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Progress )( 
            IDXTMetaCenterPeel __RPC_FAR * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_StepResolution )( 
            IDXTMetaCenterPeel __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Duration )( 
            IDXTMetaCenterPeel __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Duration )( 
            IDXTMetaCenterPeel __RPC_FAR * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Copyright )( 
            IDXTMetaCenterPeel __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Copyright )( 
            IDXTMetaCenterPeel __RPC_FAR * This,
            /* [in] */ BSTR newVal);
        
        END_INTERFACE
    } IDXTMetaCenterPeelVtbl;

    interface IDXTMetaCenterPeel
    {
        CONST_VTBL struct IDXTMetaCenterPeelVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDXTMetaCenterPeel_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDXTMetaCenterPeel_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDXTMetaCenterPeel_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDXTMetaCenterPeel_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IDXTMetaCenterPeel_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IDXTMetaCenterPeel_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IDXTMetaCenterPeel_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IDXTMetaCenterPeel_get_Capabilities(This,pVal)	\
    (This)->lpVtbl -> get_Capabilities(This,pVal)

#define IDXTMetaCenterPeel_get_Progress(This,pVal)	\
    (This)->lpVtbl -> get_Progress(This,pVal)

#define IDXTMetaCenterPeel_put_Progress(This,newVal)	\
    (This)->lpVtbl -> put_Progress(This,newVal)

#define IDXTMetaCenterPeel_get_StepResolution(This,pVal)	\
    (This)->lpVtbl -> get_StepResolution(This,pVal)

#define IDXTMetaCenterPeel_get_Duration(This,pVal)	\
    (This)->lpVtbl -> get_Duration(This,pVal)

#define IDXTMetaCenterPeel_put_Duration(This,newVal)	\
    (This)->lpVtbl -> put_Duration(This,newVal)


#define IDXTMetaCenterPeel_get_Copyright(This,pVal)	\
    (This)->lpVtbl -> get_Copyright(This,pVal)

#define IDXTMetaCenterPeel_put_Copyright(This,newVal)	\
    (This)->lpVtbl -> put_Copyright(This,newVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTMetaCenterPeel_get_Copyright_Proxy( 
    IDXTMetaCenterPeel __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB IDXTMetaCenterPeel_get_Copyright_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTMetaCenterPeel_put_Copyright_Proxy( 
    IDXTMetaCenterPeel __RPC_FAR * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IDXTMetaCenterPeel_put_Copyright_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDXTMetaCenterPeel_INTERFACE_DEFINED__ */


#ifndef __IDXTMetaPeelSmall_INTERFACE_DEFINED__
#define __IDXTMetaPeelSmall_INTERFACE_DEFINED__

/* interface IDXTMetaPeelSmall */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IDXTMetaPeelSmall;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("AA0D4D0D-06A3-11D2-8F98-00C04FB92EB7")
    IDXTMetaPeelSmall : public IDXEffect
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Copyright( 
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Copyright( 
            /* [in] */ BSTR newVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDXTMetaPeelSmallVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDXTMetaPeelSmall __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDXTMetaPeelSmall __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDXTMetaPeelSmall __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IDXTMetaPeelSmall __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IDXTMetaPeelSmall __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IDXTMetaPeelSmall __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IDXTMetaPeelSmall __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Capabilities )( 
            IDXTMetaPeelSmall __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Progress )( 
            IDXTMetaPeelSmall __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Progress )( 
            IDXTMetaPeelSmall __RPC_FAR * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_StepResolution )( 
            IDXTMetaPeelSmall __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Duration )( 
            IDXTMetaPeelSmall __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Duration )( 
            IDXTMetaPeelSmall __RPC_FAR * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Copyright )( 
            IDXTMetaPeelSmall __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Copyright )( 
            IDXTMetaPeelSmall __RPC_FAR * This,
            /* [in] */ BSTR newVal);
        
        END_INTERFACE
    } IDXTMetaPeelSmallVtbl;

    interface IDXTMetaPeelSmall
    {
        CONST_VTBL struct IDXTMetaPeelSmallVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDXTMetaPeelSmall_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDXTMetaPeelSmall_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDXTMetaPeelSmall_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDXTMetaPeelSmall_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IDXTMetaPeelSmall_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IDXTMetaPeelSmall_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IDXTMetaPeelSmall_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IDXTMetaPeelSmall_get_Capabilities(This,pVal)	\
    (This)->lpVtbl -> get_Capabilities(This,pVal)

#define IDXTMetaPeelSmall_get_Progress(This,pVal)	\
    (This)->lpVtbl -> get_Progress(This,pVal)

#define IDXTMetaPeelSmall_put_Progress(This,newVal)	\
    (This)->lpVtbl -> put_Progress(This,newVal)

#define IDXTMetaPeelSmall_get_StepResolution(This,pVal)	\
    (This)->lpVtbl -> get_StepResolution(This,pVal)

#define IDXTMetaPeelSmall_get_Duration(This,pVal)	\
    (This)->lpVtbl -> get_Duration(This,pVal)

#define IDXTMetaPeelSmall_put_Duration(This,newVal)	\
    (This)->lpVtbl -> put_Duration(This,newVal)


#define IDXTMetaPeelSmall_get_Copyright(This,pVal)	\
    (This)->lpVtbl -> get_Copyright(This,pVal)

#define IDXTMetaPeelSmall_put_Copyright(This,newVal)	\
    (This)->lpVtbl -> put_Copyright(This,newVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTMetaPeelSmall_get_Copyright_Proxy( 
    IDXTMetaPeelSmall __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB IDXTMetaPeelSmall_get_Copyright_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTMetaPeelSmall_put_Copyright_Proxy( 
    IDXTMetaPeelSmall __RPC_FAR * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IDXTMetaPeelSmall_put_Copyright_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDXTMetaPeelSmall_INTERFACE_DEFINED__ */


#ifndef __IDXTMetaPeelPiece_INTERFACE_DEFINED__
#define __IDXTMetaPeelPiece_INTERFACE_DEFINED__

/* interface IDXTMetaPeelPiece */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IDXTMetaPeelPiece;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("AA0D4D0F-06A3-11D2-8F98-00C04FB92EB7")
    IDXTMetaPeelPiece : public IDXEffect
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Copyright( 
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Copyright( 
            /* [in] */ BSTR newVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDXTMetaPeelPieceVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDXTMetaPeelPiece __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDXTMetaPeelPiece __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDXTMetaPeelPiece __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IDXTMetaPeelPiece __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IDXTMetaPeelPiece __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IDXTMetaPeelPiece __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IDXTMetaPeelPiece __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Capabilities )( 
            IDXTMetaPeelPiece __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Progress )( 
            IDXTMetaPeelPiece __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Progress )( 
            IDXTMetaPeelPiece __RPC_FAR * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_StepResolution )( 
            IDXTMetaPeelPiece __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Duration )( 
            IDXTMetaPeelPiece __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Duration )( 
            IDXTMetaPeelPiece __RPC_FAR * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Copyright )( 
            IDXTMetaPeelPiece __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Copyright )( 
            IDXTMetaPeelPiece __RPC_FAR * This,
            /* [in] */ BSTR newVal);
        
        END_INTERFACE
    } IDXTMetaPeelPieceVtbl;

    interface IDXTMetaPeelPiece
    {
        CONST_VTBL struct IDXTMetaPeelPieceVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDXTMetaPeelPiece_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDXTMetaPeelPiece_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDXTMetaPeelPiece_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDXTMetaPeelPiece_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IDXTMetaPeelPiece_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IDXTMetaPeelPiece_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IDXTMetaPeelPiece_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IDXTMetaPeelPiece_get_Capabilities(This,pVal)	\
    (This)->lpVtbl -> get_Capabilities(This,pVal)

#define IDXTMetaPeelPiece_get_Progress(This,pVal)	\
    (This)->lpVtbl -> get_Progress(This,pVal)

#define IDXTMetaPeelPiece_put_Progress(This,newVal)	\
    (This)->lpVtbl -> put_Progress(This,newVal)

#define IDXTMetaPeelPiece_get_StepResolution(This,pVal)	\
    (This)->lpVtbl -> get_StepResolution(This,pVal)

#define IDXTMetaPeelPiece_get_Duration(This,pVal)	\
    (This)->lpVtbl -> get_Duration(This,pVal)

#define IDXTMetaPeelPiece_put_Duration(This,newVal)	\
    (This)->lpVtbl -> put_Duration(This,newVal)


#define IDXTMetaPeelPiece_get_Copyright(This,pVal)	\
    (This)->lpVtbl -> get_Copyright(This,pVal)

#define IDXTMetaPeelPiece_put_Copyright(This,newVal)	\
    (This)->lpVtbl -> put_Copyright(This,newVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTMetaPeelPiece_get_Copyright_Proxy( 
    IDXTMetaPeelPiece __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB IDXTMetaPeelPiece_get_Copyright_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTMetaPeelPiece_put_Copyright_Proxy( 
    IDXTMetaPeelPiece __RPC_FAR * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IDXTMetaPeelPiece_put_Copyright_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDXTMetaPeelPiece_INTERFACE_DEFINED__ */


#ifndef __IDXTMetaPeelSplit_INTERFACE_DEFINED__
#define __IDXTMetaPeelSplit_INTERFACE_DEFINED__

/* interface IDXTMetaPeelSplit */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IDXTMetaPeelSplit;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("AA0D4D11-06A3-11D2-8F98-00C04FB92EB7")
    IDXTMetaPeelSplit : public IDXEffect
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Copyright( 
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Copyright( 
            /* [in] */ BSTR newVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDXTMetaPeelSplitVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDXTMetaPeelSplit __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDXTMetaPeelSplit __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDXTMetaPeelSplit __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IDXTMetaPeelSplit __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IDXTMetaPeelSplit __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IDXTMetaPeelSplit __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IDXTMetaPeelSplit __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Capabilities )( 
            IDXTMetaPeelSplit __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Progress )( 
            IDXTMetaPeelSplit __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Progress )( 
            IDXTMetaPeelSplit __RPC_FAR * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_StepResolution )( 
            IDXTMetaPeelSplit __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Duration )( 
            IDXTMetaPeelSplit __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Duration )( 
            IDXTMetaPeelSplit __RPC_FAR * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Copyright )( 
            IDXTMetaPeelSplit __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Copyright )( 
            IDXTMetaPeelSplit __RPC_FAR * This,
            /* [in] */ BSTR newVal);
        
        END_INTERFACE
    } IDXTMetaPeelSplitVtbl;

    interface IDXTMetaPeelSplit
    {
        CONST_VTBL struct IDXTMetaPeelSplitVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDXTMetaPeelSplit_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDXTMetaPeelSplit_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDXTMetaPeelSplit_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDXTMetaPeelSplit_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IDXTMetaPeelSplit_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IDXTMetaPeelSplit_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IDXTMetaPeelSplit_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IDXTMetaPeelSplit_get_Capabilities(This,pVal)	\
    (This)->lpVtbl -> get_Capabilities(This,pVal)

#define IDXTMetaPeelSplit_get_Progress(This,pVal)	\
    (This)->lpVtbl -> get_Progress(This,pVal)

#define IDXTMetaPeelSplit_put_Progress(This,newVal)	\
    (This)->lpVtbl -> put_Progress(This,newVal)

#define IDXTMetaPeelSplit_get_StepResolution(This,pVal)	\
    (This)->lpVtbl -> get_StepResolution(This,pVal)

#define IDXTMetaPeelSplit_get_Duration(This,pVal)	\
    (This)->lpVtbl -> get_Duration(This,pVal)

#define IDXTMetaPeelSplit_put_Duration(This,newVal)	\
    (This)->lpVtbl -> put_Duration(This,newVal)


#define IDXTMetaPeelSplit_get_Copyright(This,pVal)	\
    (This)->lpVtbl -> get_Copyright(This,pVal)

#define IDXTMetaPeelSplit_put_Copyright(This,newVal)	\
    (This)->lpVtbl -> put_Copyright(This,newVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTMetaPeelSplit_get_Copyright_Proxy( 
    IDXTMetaPeelSplit __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB IDXTMetaPeelSplit_get_Copyright_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTMetaPeelSplit_put_Copyright_Proxy( 
    IDXTMetaPeelSplit __RPC_FAR * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IDXTMetaPeelSplit_put_Copyright_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDXTMetaPeelSplit_INTERFACE_DEFINED__ */


#ifndef __IDXTMetaWater_INTERFACE_DEFINED__
#define __IDXTMetaWater_INTERFACE_DEFINED__

/* interface IDXTMetaWater */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IDXTMetaWater;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("107045C4-06E0-11D2-8D6D-00C04F8EF8E0")
    IDXTMetaWater : public IDXEffect
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Copyright( 
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Copyright( 
            /* [in] */ BSTR newVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDXTMetaWaterVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDXTMetaWater __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDXTMetaWater __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDXTMetaWater __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IDXTMetaWater __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IDXTMetaWater __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IDXTMetaWater __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IDXTMetaWater __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Capabilities )( 
            IDXTMetaWater __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Progress )( 
            IDXTMetaWater __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Progress )( 
            IDXTMetaWater __RPC_FAR * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_StepResolution )( 
            IDXTMetaWater __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Duration )( 
            IDXTMetaWater __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Duration )( 
            IDXTMetaWater __RPC_FAR * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Copyright )( 
            IDXTMetaWater __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Copyright )( 
            IDXTMetaWater __RPC_FAR * This,
            /* [in] */ BSTR newVal);
        
        END_INTERFACE
    } IDXTMetaWaterVtbl;

    interface IDXTMetaWater
    {
        CONST_VTBL struct IDXTMetaWaterVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDXTMetaWater_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDXTMetaWater_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDXTMetaWater_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDXTMetaWater_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IDXTMetaWater_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IDXTMetaWater_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IDXTMetaWater_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IDXTMetaWater_get_Capabilities(This,pVal)	\
    (This)->lpVtbl -> get_Capabilities(This,pVal)

#define IDXTMetaWater_get_Progress(This,pVal)	\
    (This)->lpVtbl -> get_Progress(This,pVal)

#define IDXTMetaWater_put_Progress(This,newVal)	\
    (This)->lpVtbl -> put_Progress(This,newVal)

#define IDXTMetaWater_get_StepResolution(This,pVal)	\
    (This)->lpVtbl -> get_StepResolution(This,pVal)

#define IDXTMetaWater_get_Duration(This,pVal)	\
    (This)->lpVtbl -> get_Duration(This,pVal)

#define IDXTMetaWater_put_Duration(This,newVal)	\
    (This)->lpVtbl -> put_Duration(This,newVal)


#define IDXTMetaWater_get_Copyright(This,pVal)	\
    (This)->lpVtbl -> get_Copyright(This,pVal)

#define IDXTMetaWater_put_Copyright(This,newVal)	\
    (This)->lpVtbl -> put_Copyright(This,newVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTMetaWater_get_Copyright_Proxy( 
    IDXTMetaWater __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB IDXTMetaWater_get_Copyright_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTMetaWater_put_Copyright_Proxy( 
    IDXTMetaWater __RPC_FAR * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IDXTMetaWater_put_Copyright_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDXTMetaWater_INTERFACE_DEFINED__ */


#ifndef __IDXTMetaLightWipe_INTERFACE_DEFINED__
#define __IDXTMetaLightWipe_INTERFACE_DEFINED__

/* interface IDXTMetaLightWipe */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IDXTMetaLightWipe;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("107045C7-06E0-11D2-8D6D-00C04F8EF8E0")
    IDXTMetaLightWipe : public IDXEffect
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Copyright( 
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Copyright( 
            /* [in] */ BSTR newVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDXTMetaLightWipeVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDXTMetaLightWipe __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDXTMetaLightWipe __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDXTMetaLightWipe __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IDXTMetaLightWipe __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IDXTMetaLightWipe __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IDXTMetaLightWipe __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IDXTMetaLightWipe __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Capabilities )( 
            IDXTMetaLightWipe __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Progress )( 
            IDXTMetaLightWipe __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Progress )( 
            IDXTMetaLightWipe __RPC_FAR * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_StepResolution )( 
            IDXTMetaLightWipe __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Duration )( 
            IDXTMetaLightWipe __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Duration )( 
            IDXTMetaLightWipe __RPC_FAR * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Copyright )( 
            IDXTMetaLightWipe __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Copyright )( 
            IDXTMetaLightWipe __RPC_FAR * This,
            /* [in] */ BSTR newVal);
        
        END_INTERFACE
    } IDXTMetaLightWipeVtbl;

    interface IDXTMetaLightWipe
    {
        CONST_VTBL struct IDXTMetaLightWipeVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDXTMetaLightWipe_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDXTMetaLightWipe_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDXTMetaLightWipe_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDXTMetaLightWipe_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IDXTMetaLightWipe_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IDXTMetaLightWipe_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IDXTMetaLightWipe_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IDXTMetaLightWipe_get_Capabilities(This,pVal)	\
    (This)->lpVtbl -> get_Capabilities(This,pVal)

#define IDXTMetaLightWipe_get_Progress(This,pVal)	\
    (This)->lpVtbl -> get_Progress(This,pVal)

#define IDXTMetaLightWipe_put_Progress(This,newVal)	\
    (This)->lpVtbl -> put_Progress(This,newVal)

#define IDXTMetaLightWipe_get_StepResolution(This,pVal)	\
    (This)->lpVtbl -> get_StepResolution(This,pVal)

#define IDXTMetaLightWipe_get_Duration(This,pVal)	\
    (This)->lpVtbl -> get_Duration(This,pVal)

#define IDXTMetaLightWipe_put_Duration(This,newVal)	\
    (This)->lpVtbl -> put_Duration(This,newVal)


#define IDXTMetaLightWipe_get_Copyright(This,pVal)	\
    (This)->lpVtbl -> get_Copyright(This,pVal)

#define IDXTMetaLightWipe_put_Copyright(This,newVal)	\
    (This)->lpVtbl -> put_Copyright(This,newVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTMetaLightWipe_get_Copyright_Proxy( 
    IDXTMetaLightWipe __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB IDXTMetaLightWipe_get_Copyright_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTMetaLightWipe_put_Copyright_Proxy( 
    IDXTMetaLightWipe __RPC_FAR * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IDXTMetaLightWipe_put_Copyright_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDXTMetaLightWipe_INTERFACE_DEFINED__ */


#ifndef __IDXTMetaRadialScaleWipe_INTERFACE_DEFINED__
#define __IDXTMetaRadialScaleWipe_INTERFACE_DEFINED__

/* interface IDXTMetaRadialScaleWipe */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IDXTMetaRadialScaleWipe;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("107045C9-06E0-11D2-8D6D-00C04F8EF8E0")
    IDXTMetaRadialScaleWipe : public IDXEffect
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Copyright( 
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Copyright( 
            /* [in] */ BSTR newVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDXTMetaRadialScaleWipeVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDXTMetaRadialScaleWipe __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDXTMetaRadialScaleWipe __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDXTMetaRadialScaleWipe __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IDXTMetaRadialScaleWipe __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IDXTMetaRadialScaleWipe __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IDXTMetaRadialScaleWipe __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IDXTMetaRadialScaleWipe __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Capabilities )( 
            IDXTMetaRadialScaleWipe __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Progress )( 
            IDXTMetaRadialScaleWipe __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Progress )( 
            IDXTMetaRadialScaleWipe __RPC_FAR * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_StepResolution )( 
            IDXTMetaRadialScaleWipe __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Duration )( 
            IDXTMetaRadialScaleWipe __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Duration )( 
            IDXTMetaRadialScaleWipe __RPC_FAR * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Copyright )( 
            IDXTMetaRadialScaleWipe __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Copyright )( 
            IDXTMetaRadialScaleWipe __RPC_FAR * This,
            /* [in] */ BSTR newVal);
        
        END_INTERFACE
    } IDXTMetaRadialScaleWipeVtbl;

    interface IDXTMetaRadialScaleWipe
    {
        CONST_VTBL struct IDXTMetaRadialScaleWipeVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDXTMetaRadialScaleWipe_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDXTMetaRadialScaleWipe_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDXTMetaRadialScaleWipe_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDXTMetaRadialScaleWipe_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IDXTMetaRadialScaleWipe_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IDXTMetaRadialScaleWipe_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IDXTMetaRadialScaleWipe_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IDXTMetaRadialScaleWipe_get_Capabilities(This,pVal)	\
    (This)->lpVtbl -> get_Capabilities(This,pVal)

#define IDXTMetaRadialScaleWipe_get_Progress(This,pVal)	\
    (This)->lpVtbl -> get_Progress(This,pVal)

#define IDXTMetaRadialScaleWipe_put_Progress(This,newVal)	\
    (This)->lpVtbl -> put_Progress(This,newVal)

#define IDXTMetaRadialScaleWipe_get_StepResolution(This,pVal)	\
    (This)->lpVtbl -> get_StepResolution(This,pVal)

#define IDXTMetaRadialScaleWipe_get_Duration(This,pVal)	\
    (This)->lpVtbl -> get_Duration(This,pVal)

#define IDXTMetaRadialScaleWipe_put_Duration(This,newVal)	\
    (This)->lpVtbl -> put_Duration(This,newVal)


#define IDXTMetaRadialScaleWipe_get_Copyright(This,pVal)	\
    (This)->lpVtbl -> get_Copyright(This,pVal)

#define IDXTMetaRadialScaleWipe_put_Copyright(This,newVal)	\
    (This)->lpVtbl -> put_Copyright(This,newVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTMetaRadialScaleWipe_get_Copyright_Proxy( 
    IDXTMetaRadialScaleWipe __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB IDXTMetaRadialScaleWipe_get_Copyright_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTMetaRadialScaleWipe_put_Copyright_Proxy( 
    IDXTMetaRadialScaleWipe __RPC_FAR * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IDXTMetaRadialScaleWipe_put_Copyright_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDXTMetaRadialScaleWipe_INTERFACE_DEFINED__ */


#ifndef __IDXTMetaWhiteOut_INTERFACE_DEFINED__
#define __IDXTMetaWhiteOut_INTERFACE_DEFINED__

/* interface IDXTMetaWhiteOut */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IDXTMetaWhiteOut;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("107045CB-06E0-11D2-8D6D-00C04F8EF8E0")
    IDXTMetaWhiteOut : public IDXEffect
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Copyright( 
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Copyright( 
            /* [in] */ BSTR newVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDXTMetaWhiteOutVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDXTMetaWhiteOut __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDXTMetaWhiteOut __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDXTMetaWhiteOut __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IDXTMetaWhiteOut __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IDXTMetaWhiteOut __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IDXTMetaWhiteOut __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IDXTMetaWhiteOut __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Capabilities )( 
            IDXTMetaWhiteOut __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Progress )( 
            IDXTMetaWhiteOut __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Progress )( 
            IDXTMetaWhiteOut __RPC_FAR * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_StepResolution )( 
            IDXTMetaWhiteOut __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Duration )( 
            IDXTMetaWhiteOut __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Duration )( 
            IDXTMetaWhiteOut __RPC_FAR * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Copyright )( 
            IDXTMetaWhiteOut __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Copyright )( 
            IDXTMetaWhiteOut __RPC_FAR * This,
            /* [in] */ BSTR newVal);
        
        END_INTERFACE
    } IDXTMetaWhiteOutVtbl;

    interface IDXTMetaWhiteOut
    {
        CONST_VTBL struct IDXTMetaWhiteOutVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDXTMetaWhiteOut_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDXTMetaWhiteOut_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDXTMetaWhiteOut_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDXTMetaWhiteOut_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IDXTMetaWhiteOut_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IDXTMetaWhiteOut_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IDXTMetaWhiteOut_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IDXTMetaWhiteOut_get_Capabilities(This,pVal)	\
    (This)->lpVtbl -> get_Capabilities(This,pVal)

#define IDXTMetaWhiteOut_get_Progress(This,pVal)	\
    (This)->lpVtbl -> get_Progress(This,pVal)

#define IDXTMetaWhiteOut_put_Progress(This,newVal)	\
    (This)->lpVtbl -> put_Progress(This,newVal)

#define IDXTMetaWhiteOut_get_StepResolution(This,pVal)	\
    (This)->lpVtbl -> get_StepResolution(This,pVal)

#define IDXTMetaWhiteOut_get_Duration(This,pVal)	\
    (This)->lpVtbl -> get_Duration(This,pVal)

#define IDXTMetaWhiteOut_put_Duration(This,newVal)	\
    (This)->lpVtbl -> put_Duration(This,newVal)


#define IDXTMetaWhiteOut_get_Copyright(This,pVal)	\
    (This)->lpVtbl -> get_Copyright(This,pVal)

#define IDXTMetaWhiteOut_put_Copyright(This,newVal)	\
    (This)->lpVtbl -> put_Copyright(This,newVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTMetaWhiteOut_get_Copyright_Proxy( 
    IDXTMetaWhiteOut __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB IDXTMetaWhiteOut_get_Copyright_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTMetaWhiteOut_put_Copyright_Proxy( 
    IDXTMetaWhiteOut __RPC_FAR * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IDXTMetaWhiteOut_put_Copyright_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDXTMetaWhiteOut_INTERFACE_DEFINED__ */


#ifndef __IDXTMetaTwister_INTERFACE_DEFINED__
#define __IDXTMetaTwister_INTERFACE_DEFINED__

/* interface IDXTMetaTwister */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IDXTMetaTwister;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("107045CE-06E0-11D2-8D6D-00C04F8EF8E0")
    IDXTMetaTwister : public IDXEffect
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Copyright( 
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Copyright( 
            /* [in] */ BSTR newVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDXTMetaTwisterVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDXTMetaTwister __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDXTMetaTwister __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDXTMetaTwister __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IDXTMetaTwister __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IDXTMetaTwister __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IDXTMetaTwister __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IDXTMetaTwister __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Capabilities )( 
            IDXTMetaTwister __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Progress )( 
            IDXTMetaTwister __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Progress )( 
            IDXTMetaTwister __RPC_FAR * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_StepResolution )( 
            IDXTMetaTwister __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Duration )( 
            IDXTMetaTwister __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Duration )( 
            IDXTMetaTwister __RPC_FAR * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Copyright )( 
            IDXTMetaTwister __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Copyright )( 
            IDXTMetaTwister __RPC_FAR * This,
            /* [in] */ BSTR newVal);
        
        END_INTERFACE
    } IDXTMetaTwisterVtbl;

    interface IDXTMetaTwister
    {
        CONST_VTBL struct IDXTMetaTwisterVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDXTMetaTwister_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDXTMetaTwister_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDXTMetaTwister_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDXTMetaTwister_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IDXTMetaTwister_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IDXTMetaTwister_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IDXTMetaTwister_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IDXTMetaTwister_get_Capabilities(This,pVal)	\
    (This)->lpVtbl -> get_Capabilities(This,pVal)

#define IDXTMetaTwister_get_Progress(This,pVal)	\
    (This)->lpVtbl -> get_Progress(This,pVal)

#define IDXTMetaTwister_put_Progress(This,newVal)	\
    (This)->lpVtbl -> put_Progress(This,newVal)

#define IDXTMetaTwister_get_StepResolution(This,pVal)	\
    (This)->lpVtbl -> get_StepResolution(This,pVal)

#define IDXTMetaTwister_get_Duration(This,pVal)	\
    (This)->lpVtbl -> get_Duration(This,pVal)

#define IDXTMetaTwister_put_Duration(This,newVal)	\
    (This)->lpVtbl -> put_Duration(This,newVal)


#define IDXTMetaTwister_get_Copyright(This,pVal)	\
    (This)->lpVtbl -> get_Copyright(This,pVal)

#define IDXTMetaTwister_put_Copyright(This,newVal)	\
    (This)->lpVtbl -> put_Copyright(This,newVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTMetaTwister_get_Copyright_Proxy( 
    IDXTMetaTwister __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB IDXTMetaTwister_get_Copyright_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTMetaTwister_put_Copyright_Proxy( 
    IDXTMetaTwister __RPC_FAR * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IDXTMetaTwister_put_Copyright_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDXTMetaTwister_INTERFACE_DEFINED__ */


#ifndef __IDXTMetaBurnFilm_INTERFACE_DEFINED__
#define __IDXTMetaBurnFilm_INTERFACE_DEFINED__

/* interface IDXTMetaBurnFilm */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IDXTMetaBurnFilm;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("107045D0-06E0-11D2-8D6D-00C04F8EF8E0")
    IDXTMetaBurnFilm : public IDXEffect
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Copyright( 
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Copyright( 
            /* [in] */ BSTR newVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDXTMetaBurnFilmVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDXTMetaBurnFilm __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDXTMetaBurnFilm __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDXTMetaBurnFilm __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IDXTMetaBurnFilm __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IDXTMetaBurnFilm __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IDXTMetaBurnFilm __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IDXTMetaBurnFilm __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Capabilities )( 
            IDXTMetaBurnFilm __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Progress )( 
            IDXTMetaBurnFilm __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Progress )( 
            IDXTMetaBurnFilm __RPC_FAR * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_StepResolution )( 
            IDXTMetaBurnFilm __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Duration )( 
            IDXTMetaBurnFilm __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Duration )( 
            IDXTMetaBurnFilm __RPC_FAR * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Copyright )( 
            IDXTMetaBurnFilm __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Copyright )( 
            IDXTMetaBurnFilm __RPC_FAR * This,
            /* [in] */ BSTR newVal);
        
        END_INTERFACE
    } IDXTMetaBurnFilmVtbl;

    interface IDXTMetaBurnFilm
    {
        CONST_VTBL struct IDXTMetaBurnFilmVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDXTMetaBurnFilm_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDXTMetaBurnFilm_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDXTMetaBurnFilm_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDXTMetaBurnFilm_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IDXTMetaBurnFilm_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IDXTMetaBurnFilm_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IDXTMetaBurnFilm_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IDXTMetaBurnFilm_get_Capabilities(This,pVal)	\
    (This)->lpVtbl -> get_Capabilities(This,pVal)

#define IDXTMetaBurnFilm_get_Progress(This,pVal)	\
    (This)->lpVtbl -> get_Progress(This,pVal)

#define IDXTMetaBurnFilm_put_Progress(This,newVal)	\
    (This)->lpVtbl -> put_Progress(This,newVal)

#define IDXTMetaBurnFilm_get_StepResolution(This,pVal)	\
    (This)->lpVtbl -> get_StepResolution(This,pVal)

#define IDXTMetaBurnFilm_get_Duration(This,pVal)	\
    (This)->lpVtbl -> get_Duration(This,pVal)

#define IDXTMetaBurnFilm_put_Duration(This,newVal)	\
    (This)->lpVtbl -> put_Duration(This,newVal)


#define IDXTMetaBurnFilm_get_Copyright(This,pVal)	\
    (This)->lpVtbl -> get_Copyright(This,pVal)

#define IDXTMetaBurnFilm_put_Copyright(This,newVal)	\
    (This)->lpVtbl -> put_Copyright(This,newVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTMetaBurnFilm_get_Copyright_Proxy( 
    IDXTMetaBurnFilm __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB IDXTMetaBurnFilm_get_Copyright_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTMetaBurnFilm_put_Copyright_Proxy( 
    IDXTMetaBurnFilm __RPC_FAR * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IDXTMetaBurnFilm_put_Copyright_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDXTMetaBurnFilm_INTERFACE_DEFINED__ */


#ifndef __IDXTMetaJaws_INTERFACE_DEFINED__
#define __IDXTMetaJaws_INTERFACE_DEFINED__

/* interface IDXTMetaJaws */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IDXTMetaJaws;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("2A54C903-07AA-11D2-8D6D-00C04F8EF8E0")
    IDXTMetaJaws : public IDXEffect
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Copyright( 
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Copyright( 
            /* [in] */ BSTR newVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDXTMetaJawsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDXTMetaJaws __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDXTMetaJaws __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDXTMetaJaws __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IDXTMetaJaws __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IDXTMetaJaws __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IDXTMetaJaws __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IDXTMetaJaws __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Capabilities )( 
            IDXTMetaJaws __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Progress )( 
            IDXTMetaJaws __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Progress )( 
            IDXTMetaJaws __RPC_FAR * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_StepResolution )( 
            IDXTMetaJaws __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Duration )( 
            IDXTMetaJaws __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Duration )( 
            IDXTMetaJaws __RPC_FAR * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Copyright )( 
            IDXTMetaJaws __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Copyright )( 
            IDXTMetaJaws __RPC_FAR * This,
            /* [in] */ BSTR newVal);
        
        END_INTERFACE
    } IDXTMetaJawsVtbl;

    interface IDXTMetaJaws
    {
        CONST_VTBL struct IDXTMetaJawsVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDXTMetaJaws_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDXTMetaJaws_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDXTMetaJaws_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDXTMetaJaws_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IDXTMetaJaws_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IDXTMetaJaws_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IDXTMetaJaws_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IDXTMetaJaws_get_Capabilities(This,pVal)	\
    (This)->lpVtbl -> get_Capabilities(This,pVal)

#define IDXTMetaJaws_get_Progress(This,pVal)	\
    (This)->lpVtbl -> get_Progress(This,pVal)

#define IDXTMetaJaws_put_Progress(This,newVal)	\
    (This)->lpVtbl -> put_Progress(This,newVal)

#define IDXTMetaJaws_get_StepResolution(This,pVal)	\
    (This)->lpVtbl -> get_StepResolution(This,pVal)

#define IDXTMetaJaws_get_Duration(This,pVal)	\
    (This)->lpVtbl -> get_Duration(This,pVal)

#define IDXTMetaJaws_put_Duration(This,newVal)	\
    (This)->lpVtbl -> put_Duration(This,newVal)


#define IDXTMetaJaws_get_Copyright(This,pVal)	\
    (This)->lpVtbl -> get_Copyright(This,pVal)

#define IDXTMetaJaws_put_Copyright(This,newVal)	\
    (This)->lpVtbl -> put_Copyright(This,newVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTMetaJaws_get_Copyright_Proxy( 
    IDXTMetaJaws __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB IDXTMetaJaws_get_Copyright_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTMetaJaws_put_Copyright_Proxy( 
    IDXTMetaJaws __RPC_FAR * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IDXTMetaJaws_put_Copyright_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDXTMetaJaws_INTERFACE_DEFINED__ */


#ifndef __IDXTMetaColorFade_INTERFACE_DEFINED__
#define __IDXTMetaColorFade_INTERFACE_DEFINED__

/* interface IDXTMetaColorFade */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IDXTMetaColorFade;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("2A54C907-07AA-11D2-8D6D-00C04F8EF8E0")
    IDXTMetaColorFade : public IDXEffect
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Copyright( 
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Copyright( 
            /* [in] */ BSTR newVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDXTMetaColorFadeVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDXTMetaColorFade __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDXTMetaColorFade __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDXTMetaColorFade __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IDXTMetaColorFade __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IDXTMetaColorFade __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IDXTMetaColorFade __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IDXTMetaColorFade __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Capabilities )( 
            IDXTMetaColorFade __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Progress )( 
            IDXTMetaColorFade __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Progress )( 
            IDXTMetaColorFade __RPC_FAR * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_StepResolution )( 
            IDXTMetaColorFade __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Duration )( 
            IDXTMetaColorFade __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Duration )( 
            IDXTMetaColorFade __RPC_FAR * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Copyright )( 
            IDXTMetaColorFade __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Copyright )( 
            IDXTMetaColorFade __RPC_FAR * This,
            /* [in] */ BSTR newVal);
        
        END_INTERFACE
    } IDXTMetaColorFadeVtbl;

    interface IDXTMetaColorFade
    {
        CONST_VTBL struct IDXTMetaColorFadeVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDXTMetaColorFade_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDXTMetaColorFade_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDXTMetaColorFade_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDXTMetaColorFade_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IDXTMetaColorFade_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IDXTMetaColorFade_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IDXTMetaColorFade_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IDXTMetaColorFade_get_Capabilities(This,pVal)	\
    (This)->lpVtbl -> get_Capabilities(This,pVal)

#define IDXTMetaColorFade_get_Progress(This,pVal)	\
    (This)->lpVtbl -> get_Progress(This,pVal)

#define IDXTMetaColorFade_put_Progress(This,newVal)	\
    (This)->lpVtbl -> put_Progress(This,newVal)

#define IDXTMetaColorFade_get_StepResolution(This,pVal)	\
    (This)->lpVtbl -> get_StepResolution(This,pVal)

#define IDXTMetaColorFade_get_Duration(This,pVal)	\
    (This)->lpVtbl -> get_Duration(This,pVal)

#define IDXTMetaColorFade_put_Duration(This,newVal)	\
    (This)->lpVtbl -> put_Duration(This,newVal)


#define IDXTMetaColorFade_get_Copyright(This,pVal)	\
    (This)->lpVtbl -> get_Copyright(This,pVal)

#define IDXTMetaColorFade_put_Copyright(This,newVal)	\
    (This)->lpVtbl -> put_Copyright(This,newVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTMetaColorFade_get_Copyright_Proxy( 
    IDXTMetaColorFade __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB IDXTMetaColorFade_get_Copyright_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTMetaColorFade_put_Copyright_Proxy( 
    IDXTMetaColorFade __RPC_FAR * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IDXTMetaColorFade_put_Copyright_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDXTMetaColorFade_INTERFACE_DEFINED__ */


#ifndef __IDXTMetaFlowMotion_INTERFACE_DEFINED__
#define __IDXTMetaFlowMotion_INTERFACE_DEFINED__

/* interface IDXTMetaFlowMotion */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IDXTMetaFlowMotion;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("2A54C90A-07AA-11D2-8D6D-00C04F8EF8E0")
    IDXTMetaFlowMotion : public IDXEffect
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Copyright( 
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Copyright( 
            /* [in] */ BSTR newVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDXTMetaFlowMotionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDXTMetaFlowMotion __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDXTMetaFlowMotion __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDXTMetaFlowMotion __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IDXTMetaFlowMotion __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IDXTMetaFlowMotion __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IDXTMetaFlowMotion __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IDXTMetaFlowMotion __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Capabilities )( 
            IDXTMetaFlowMotion __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Progress )( 
            IDXTMetaFlowMotion __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Progress )( 
            IDXTMetaFlowMotion __RPC_FAR * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_StepResolution )( 
            IDXTMetaFlowMotion __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Duration )( 
            IDXTMetaFlowMotion __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Duration )( 
            IDXTMetaFlowMotion __RPC_FAR * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Copyright )( 
            IDXTMetaFlowMotion __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Copyright )( 
            IDXTMetaFlowMotion __RPC_FAR * This,
            /* [in] */ BSTR newVal);
        
        END_INTERFACE
    } IDXTMetaFlowMotionVtbl;

    interface IDXTMetaFlowMotion
    {
        CONST_VTBL struct IDXTMetaFlowMotionVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDXTMetaFlowMotion_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDXTMetaFlowMotion_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDXTMetaFlowMotion_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDXTMetaFlowMotion_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IDXTMetaFlowMotion_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IDXTMetaFlowMotion_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IDXTMetaFlowMotion_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IDXTMetaFlowMotion_get_Capabilities(This,pVal)	\
    (This)->lpVtbl -> get_Capabilities(This,pVal)

#define IDXTMetaFlowMotion_get_Progress(This,pVal)	\
    (This)->lpVtbl -> get_Progress(This,pVal)

#define IDXTMetaFlowMotion_put_Progress(This,newVal)	\
    (This)->lpVtbl -> put_Progress(This,newVal)

#define IDXTMetaFlowMotion_get_StepResolution(This,pVal)	\
    (This)->lpVtbl -> get_StepResolution(This,pVal)

#define IDXTMetaFlowMotion_get_Duration(This,pVal)	\
    (This)->lpVtbl -> get_Duration(This,pVal)

#define IDXTMetaFlowMotion_put_Duration(This,newVal)	\
    (This)->lpVtbl -> put_Duration(This,newVal)


#define IDXTMetaFlowMotion_get_Copyright(This,pVal)	\
    (This)->lpVtbl -> get_Copyright(This,pVal)

#define IDXTMetaFlowMotion_put_Copyright(This,newVal)	\
    (This)->lpVtbl -> put_Copyright(This,newVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTMetaFlowMotion_get_Copyright_Proxy( 
    IDXTMetaFlowMotion __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB IDXTMetaFlowMotion_get_Copyright_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTMetaFlowMotion_put_Copyright_Proxy( 
    IDXTMetaFlowMotion __RPC_FAR * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IDXTMetaFlowMotion_put_Copyright_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDXTMetaFlowMotion_INTERFACE_DEFINED__ */


#ifndef __IDXTMetaVacuum_INTERFACE_DEFINED__
#define __IDXTMetaVacuum_INTERFACE_DEFINED__

/* interface IDXTMetaVacuum */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IDXTMetaVacuum;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("2A54C90C-07AA-11D2-8D6D-00C04F8EF8E0")
    IDXTMetaVacuum : public IDXEffect
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Copyright( 
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Copyright( 
            /* [in] */ BSTR newVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDXTMetaVacuumVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDXTMetaVacuum __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDXTMetaVacuum __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDXTMetaVacuum __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IDXTMetaVacuum __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IDXTMetaVacuum __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IDXTMetaVacuum __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IDXTMetaVacuum __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Capabilities )( 
            IDXTMetaVacuum __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Progress )( 
            IDXTMetaVacuum __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Progress )( 
            IDXTMetaVacuum __RPC_FAR * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_StepResolution )( 
            IDXTMetaVacuum __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Duration )( 
            IDXTMetaVacuum __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Duration )( 
            IDXTMetaVacuum __RPC_FAR * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Copyright )( 
            IDXTMetaVacuum __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Copyright )( 
            IDXTMetaVacuum __RPC_FAR * This,
            /* [in] */ BSTR newVal);
        
        END_INTERFACE
    } IDXTMetaVacuumVtbl;

    interface IDXTMetaVacuum
    {
        CONST_VTBL struct IDXTMetaVacuumVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDXTMetaVacuum_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDXTMetaVacuum_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDXTMetaVacuum_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDXTMetaVacuum_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IDXTMetaVacuum_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IDXTMetaVacuum_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IDXTMetaVacuum_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IDXTMetaVacuum_get_Capabilities(This,pVal)	\
    (This)->lpVtbl -> get_Capabilities(This,pVal)

#define IDXTMetaVacuum_get_Progress(This,pVal)	\
    (This)->lpVtbl -> get_Progress(This,pVal)

#define IDXTMetaVacuum_put_Progress(This,newVal)	\
    (This)->lpVtbl -> put_Progress(This,newVal)

#define IDXTMetaVacuum_get_StepResolution(This,pVal)	\
    (This)->lpVtbl -> get_StepResolution(This,pVal)

#define IDXTMetaVacuum_get_Duration(This,pVal)	\
    (This)->lpVtbl -> get_Duration(This,pVal)

#define IDXTMetaVacuum_put_Duration(This,newVal)	\
    (This)->lpVtbl -> put_Duration(This,newVal)


#define IDXTMetaVacuum_get_Copyright(This,pVal)	\
    (This)->lpVtbl -> get_Copyright(This,pVal)

#define IDXTMetaVacuum_put_Copyright(This,newVal)	\
    (This)->lpVtbl -> put_Copyright(This,newVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTMetaVacuum_get_Copyright_Proxy( 
    IDXTMetaVacuum __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB IDXTMetaVacuum_get_Copyright_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTMetaVacuum_put_Copyright_Proxy( 
    IDXTMetaVacuum __RPC_FAR * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IDXTMetaVacuum_put_Copyright_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDXTMetaVacuum_INTERFACE_DEFINED__ */


#ifndef __IDXTMetaGriddler_INTERFACE_DEFINED__
#define __IDXTMetaGriddler_INTERFACE_DEFINED__

/* interface IDXTMetaGriddler */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IDXTMetaGriddler;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("2A54C910-07AA-11D2-8D6D-00C04F8EF8E0")
    IDXTMetaGriddler : public IDXEffect
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Copyright( 
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Copyright( 
            /* [in] */ BSTR newVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDXTMetaGriddlerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDXTMetaGriddler __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDXTMetaGriddler __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDXTMetaGriddler __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IDXTMetaGriddler __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IDXTMetaGriddler __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IDXTMetaGriddler __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IDXTMetaGriddler __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Capabilities )( 
            IDXTMetaGriddler __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Progress )( 
            IDXTMetaGriddler __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Progress )( 
            IDXTMetaGriddler __RPC_FAR * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_StepResolution )( 
            IDXTMetaGriddler __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Duration )( 
            IDXTMetaGriddler __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Duration )( 
            IDXTMetaGriddler __RPC_FAR * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Copyright )( 
            IDXTMetaGriddler __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Copyright )( 
            IDXTMetaGriddler __RPC_FAR * This,
            /* [in] */ BSTR newVal);
        
        END_INTERFACE
    } IDXTMetaGriddlerVtbl;

    interface IDXTMetaGriddler
    {
        CONST_VTBL struct IDXTMetaGriddlerVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDXTMetaGriddler_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDXTMetaGriddler_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDXTMetaGriddler_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDXTMetaGriddler_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IDXTMetaGriddler_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IDXTMetaGriddler_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IDXTMetaGriddler_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IDXTMetaGriddler_get_Capabilities(This,pVal)	\
    (This)->lpVtbl -> get_Capabilities(This,pVal)

#define IDXTMetaGriddler_get_Progress(This,pVal)	\
    (This)->lpVtbl -> get_Progress(This,pVal)

#define IDXTMetaGriddler_put_Progress(This,newVal)	\
    (This)->lpVtbl -> put_Progress(This,newVal)

#define IDXTMetaGriddler_get_StepResolution(This,pVal)	\
    (This)->lpVtbl -> get_StepResolution(This,pVal)

#define IDXTMetaGriddler_get_Duration(This,pVal)	\
    (This)->lpVtbl -> get_Duration(This,pVal)

#define IDXTMetaGriddler_put_Duration(This,newVal)	\
    (This)->lpVtbl -> put_Duration(This,newVal)


#define IDXTMetaGriddler_get_Copyright(This,pVal)	\
    (This)->lpVtbl -> get_Copyright(This,pVal)

#define IDXTMetaGriddler_put_Copyright(This,newVal)	\
    (This)->lpVtbl -> put_Copyright(This,newVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTMetaGriddler_get_Copyright_Proxy( 
    IDXTMetaGriddler __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB IDXTMetaGriddler_get_Copyright_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTMetaGriddler_put_Copyright_Proxy( 
    IDXTMetaGriddler __RPC_FAR * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IDXTMetaGriddler_put_Copyright_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDXTMetaGriddler_INTERFACE_DEFINED__ */


#ifndef __IDXTMetaGriddler2_INTERFACE_DEFINED__
#define __IDXTMetaGriddler2_INTERFACE_DEFINED__

/* interface IDXTMetaGriddler2 */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IDXTMetaGriddler2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("2A54C912-07AA-11D2-8D6D-00C04F8EF8E0")
    IDXTMetaGriddler2 : public IDXEffect
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Copyright( 
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Copyright( 
            /* [in] */ BSTR newVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDXTMetaGriddler2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDXTMetaGriddler2 __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDXTMetaGriddler2 __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDXTMetaGriddler2 __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IDXTMetaGriddler2 __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IDXTMetaGriddler2 __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IDXTMetaGriddler2 __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IDXTMetaGriddler2 __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Capabilities )( 
            IDXTMetaGriddler2 __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Progress )( 
            IDXTMetaGriddler2 __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Progress )( 
            IDXTMetaGriddler2 __RPC_FAR * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_StepResolution )( 
            IDXTMetaGriddler2 __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Duration )( 
            IDXTMetaGriddler2 __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Duration )( 
            IDXTMetaGriddler2 __RPC_FAR * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Copyright )( 
            IDXTMetaGriddler2 __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Copyright )( 
            IDXTMetaGriddler2 __RPC_FAR * This,
            /* [in] */ BSTR newVal);
        
        END_INTERFACE
    } IDXTMetaGriddler2Vtbl;

    interface IDXTMetaGriddler2
    {
        CONST_VTBL struct IDXTMetaGriddler2Vtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDXTMetaGriddler2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDXTMetaGriddler2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDXTMetaGriddler2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDXTMetaGriddler2_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IDXTMetaGriddler2_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IDXTMetaGriddler2_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IDXTMetaGriddler2_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IDXTMetaGriddler2_get_Capabilities(This,pVal)	\
    (This)->lpVtbl -> get_Capabilities(This,pVal)

#define IDXTMetaGriddler2_get_Progress(This,pVal)	\
    (This)->lpVtbl -> get_Progress(This,pVal)

#define IDXTMetaGriddler2_put_Progress(This,newVal)	\
    (This)->lpVtbl -> put_Progress(This,newVal)

#define IDXTMetaGriddler2_get_StepResolution(This,pVal)	\
    (This)->lpVtbl -> get_StepResolution(This,pVal)

#define IDXTMetaGriddler2_get_Duration(This,pVal)	\
    (This)->lpVtbl -> get_Duration(This,pVal)

#define IDXTMetaGriddler2_put_Duration(This,newVal)	\
    (This)->lpVtbl -> put_Duration(This,newVal)


#define IDXTMetaGriddler2_get_Copyright(This,pVal)	\
    (This)->lpVtbl -> get_Copyright(This,pVal)

#define IDXTMetaGriddler2_put_Copyright(This,newVal)	\
    (This)->lpVtbl -> put_Copyright(This,newVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTMetaGriddler2_get_Copyright_Proxy( 
    IDXTMetaGriddler2 __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB IDXTMetaGriddler2_get_Copyright_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTMetaGriddler2_put_Copyright_Proxy( 
    IDXTMetaGriddler2 __RPC_FAR * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IDXTMetaGriddler2_put_Copyright_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDXTMetaGriddler2_INTERFACE_DEFINED__ */


#ifndef __IDXTMetaThreshold_INTERFACE_DEFINED__
#define __IDXTMetaThreshold_INTERFACE_DEFINED__

/* interface IDXTMetaThreshold */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IDXTMetaThreshold;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("2A54C914-07AA-11D2-8D6D-00C04F8EF8E0")
    IDXTMetaThreshold : public IDXEffect
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Copyright( 
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Copyright( 
            /* [in] */ BSTR newVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDXTMetaThresholdVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDXTMetaThreshold __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDXTMetaThreshold __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDXTMetaThreshold __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IDXTMetaThreshold __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IDXTMetaThreshold __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IDXTMetaThreshold __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IDXTMetaThreshold __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Capabilities )( 
            IDXTMetaThreshold __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Progress )( 
            IDXTMetaThreshold __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Progress )( 
            IDXTMetaThreshold __RPC_FAR * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_StepResolution )( 
            IDXTMetaThreshold __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Duration )( 
            IDXTMetaThreshold __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Duration )( 
            IDXTMetaThreshold __RPC_FAR * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Copyright )( 
            IDXTMetaThreshold __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Copyright )( 
            IDXTMetaThreshold __RPC_FAR * This,
            /* [in] */ BSTR newVal);
        
        END_INTERFACE
    } IDXTMetaThresholdVtbl;

    interface IDXTMetaThreshold
    {
        CONST_VTBL struct IDXTMetaThresholdVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDXTMetaThreshold_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDXTMetaThreshold_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDXTMetaThreshold_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDXTMetaThreshold_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IDXTMetaThreshold_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IDXTMetaThreshold_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IDXTMetaThreshold_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IDXTMetaThreshold_get_Capabilities(This,pVal)	\
    (This)->lpVtbl -> get_Capabilities(This,pVal)

#define IDXTMetaThreshold_get_Progress(This,pVal)	\
    (This)->lpVtbl -> get_Progress(This,pVal)

#define IDXTMetaThreshold_put_Progress(This,newVal)	\
    (This)->lpVtbl -> put_Progress(This,newVal)

#define IDXTMetaThreshold_get_StepResolution(This,pVal)	\
    (This)->lpVtbl -> get_StepResolution(This,pVal)

#define IDXTMetaThreshold_get_Duration(This,pVal)	\
    (This)->lpVtbl -> get_Duration(This,pVal)

#define IDXTMetaThreshold_put_Duration(This,newVal)	\
    (This)->lpVtbl -> put_Duration(This,newVal)


#define IDXTMetaThreshold_get_Copyright(This,pVal)	\
    (This)->lpVtbl -> get_Copyright(This,pVal)

#define IDXTMetaThreshold_put_Copyright(This,newVal)	\
    (This)->lpVtbl -> put_Copyright(This,newVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTMetaThreshold_get_Copyright_Proxy( 
    IDXTMetaThreshold __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB IDXTMetaThreshold_get_Copyright_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTMetaThreshold_put_Copyright_Proxy( 
    IDXTMetaThreshold __RPC_FAR * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IDXTMetaThreshold_put_Copyright_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDXTMetaThreshold_INTERFACE_DEFINED__ */


#ifndef __IDXTMetaWormHole_INTERFACE_DEFINED__
#define __IDXTMetaWormHole_INTERFACE_DEFINED__

/* interface IDXTMetaWormHole */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IDXTMetaWormHole;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("0E6AE021-0C83-11D2-8CD4-00104BC75D9A")
    IDXTMetaWormHole : public IDXEffect
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Copyright( 
            /* [retval][out] */ BSTR __RPC_FAR *pVal) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Copyright( 
            /* [in] */ BSTR newVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDXTMetaWormHoleVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDXTMetaWormHole __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDXTMetaWormHole __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDXTMetaWormHole __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IDXTMetaWormHole __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IDXTMetaWormHole __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IDXTMetaWormHole __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IDXTMetaWormHole __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Capabilities )( 
            IDXTMetaWormHole __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Progress )( 
            IDXTMetaWormHole __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Progress )( 
            IDXTMetaWormHole __RPC_FAR * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_StepResolution )( 
            IDXTMetaWormHole __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Duration )( 
            IDXTMetaWormHole __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Duration )( 
            IDXTMetaWormHole __RPC_FAR * This,
            /* [in] */ float newVal);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Copyright )( 
            IDXTMetaWormHole __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pVal);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Copyright )( 
            IDXTMetaWormHole __RPC_FAR * This,
            /* [in] */ BSTR newVal);
        
        END_INTERFACE
    } IDXTMetaWormHoleVtbl;

    interface IDXTMetaWormHole
    {
        CONST_VTBL struct IDXTMetaWormHoleVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDXTMetaWormHole_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDXTMetaWormHole_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDXTMetaWormHole_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDXTMetaWormHole_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IDXTMetaWormHole_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IDXTMetaWormHole_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IDXTMetaWormHole_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IDXTMetaWormHole_get_Capabilities(This,pVal)	\
    (This)->lpVtbl -> get_Capabilities(This,pVal)

#define IDXTMetaWormHole_get_Progress(This,pVal)	\
    (This)->lpVtbl -> get_Progress(This,pVal)

#define IDXTMetaWormHole_put_Progress(This,newVal)	\
    (This)->lpVtbl -> put_Progress(This,newVal)

#define IDXTMetaWormHole_get_StepResolution(This,pVal)	\
    (This)->lpVtbl -> get_StepResolution(This,pVal)

#define IDXTMetaWormHole_get_Duration(This,pVal)	\
    (This)->lpVtbl -> get_Duration(This,pVal)

#define IDXTMetaWormHole_put_Duration(This,newVal)	\
    (This)->lpVtbl -> put_Duration(This,newVal)


#define IDXTMetaWormHole_get_Copyright(This,pVal)	\
    (This)->lpVtbl -> get_Copyright(This,pVal)

#define IDXTMetaWormHole_put_Copyright(This,newVal)	\
    (This)->lpVtbl -> put_Copyright(This,newVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE IDXTMetaWormHole_get_Copyright_Proxy( 
    IDXTMetaWormHole __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pVal);


void __RPC_STUB IDXTMetaWormHole_get_Copyright_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IDXTMetaWormHole_put_Copyright_Proxy( 
    IDXTMetaWormHole __RPC_FAR * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IDXTMetaWormHole_put_Copyright_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDXTMetaWormHole_INTERFACE_DEFINED__ */



#ifndef __DXTMSFTLib_LIBRARY_DEFINED__
#define __DXTMSFTLib_LIBRARY_DEFINED__

/* library DXTMSFTLib */
/* [helpstring][version][uuid] */ 


EXTERN_C const IID LIBID_DXTMSFTLib;

EXTERN_C const CLSID CLSID_DXTComposite;

#ifdef __cplusplus

class DECLSPEC_UUID("9A43A844-0831-11D1-817F-0000F87557DB")
DXTComposite;
#endif

EXTERN_C const CLSID CLSID_DXLUTBuilder;

#ifdef __cplusplus

class DECLSPEC_UUID("1E54333B-2A00-11d1-8198-0000F87557DB")
DXLUTBuilder;
#endif

EXTERN_C const CLSID CLSID_DXTGradientD;

#ifdef __cplusplus

class DECLSPEC_UUID("623E2882-FC0E-11d1-9A77-0000F8756A10")
DXTGradientD;
#endif

EXTERN_C const CLSID CLSID_DXTWipe;

#ifdef __cplusplus

class DECLSPEC_UUID("AF279B30-86EB-11D1-81BF-0000F87557DB")
DXTWipe;
#endif

EXTERN_C const CLSID CLSID_DXTConvolution;

#ifdef __cplusplus

class DECLSPEC_UUID("2BC0EF29-E6BA-11d1-81DD-0000F87557DB")
DXTConvolution;
#endif

EXTERN_C const CLSID CLSID_CrBlur;

#ifdef __cplusplus

class DECLSPEC_UUID("7312498D-E87A-11d1-81E0-0000F87557DB")
CrBlur;
#endif

EXTERN_C const CLSID CLSID_CrEmboss;

#ifdef __cplusplus

class DECLSPEC_UUID("F515306D-0156-11d2-81EA-0000F87557DB")
CrEmboss;
#endif

EXTERN_C const CLSID CLSID_CrEngrave;

#ifdef __cplusplus

class DECLSPEC_UUID("F515306E-0156-11d2-81EA-0000F87557DB")
CrEngrave;
#endif

EXTERN_C const CLSID CLSID_DXFade;

#ifdef __cplusplus

class DECLSPEC_UUID("16B280C5-EE70-11D1-9066-00C04FD9189D")
DXFade;
#endif

EXTERN_C const CLSID CLSID_FadePP;

#ifdef __cplusplus

class DECLSPEC_UUID("16B280C6-EE70-11D1-9066-00C04FD9189D")
FadePP;
#endif

EXTERN_C const CLSID CLSID_BasicImageEffects;

#ifdef __cplusplus

class DECLSPEC_UUID("16B280C8-EE70-11D1-9066-00C04FD9189D")
BasicImageEffects;
#endif

EXTERN_C const CLSID CLSID_BasicImageEffectsPP;

#ifdef __cplusplus

class DECLSPEC_UUID("16B280C9-EE70-11D1-9066-00C04FD9189D")
BasicImageEffectsPP;
#endif

EXTERN_C const CLSID CLSID_Pixelate;

#ifdef __cplusplus

class DECLSPEC_UUID("4CCEA634-FBE0-11d1-906A-00C04FD9189D")
Pixelate;
#endif

EXTERN_C const CLSID CLSID_PixelatePP;

#ifdef __cplusplus

class DECLSPEC_UUID("4CCEA635-FBE0-11d1-906A-00C04FD9189D")
PixelatePP;
#endif

EXTERN_C const CLSID CLSID_DXTWipePP;

#ifdef __cplusplus

class DECLSPEC_UUID("7FFE4D08-FBFD-11d1-9A77-0000F8756A10")
DXTWipePP;
#endif

EXTERN_C const CLSID CLSID_CrBlurPP;

#ifdef __cplusplus

class DECLSPEC_UUID("623E287E-FC0E-11d1-9A77-0000F8756A10")
CrBlurPP;
#endif

EXTERN_C const CLSID CLSID_GradientPP;

#ifdef __cplusplus

class DECLSPEC_UUID("623E2880-FC0E-11d1-9A77-0000F8756A10")
GradientPP;
#endif

EXTERN_C const CLSID CLSID_CompositePP;

#ifdef __cplusplus

class DECLSPEC_UUID("25B33660-FD83-11d1-8ADE-444553540001")
CompositePP;
#endif

EXTERN_C const CLSID CLSID_ConvolvePP;

#ifdef __cplusplus

class DECLSPEC_UUID("25B33661-FD83-11d1-8ADE-444553540001")
ConvolvePP;
#endif

EXTERN_C const CLSID CLSID_LUTBuilderPP;

#ifdef __cplusplus

class DECLSPEC_UUID("25B33662-FD83-11d1-8ADE-444553540001")
LUTBuilderPP;
#endif

EXTERN_C const CLSID CLSID_CrIris;

#ifdef __cplusplus

class DECLSPEC_UUID("3F69F351-0379-11D2-A484-00C04F8EFB69")
CrIris;
#endif

EXTERN_C const CLSID CLSID_CrIrisPP;

#ifdef __cplusplus

class DECLSPEC_UUID("80DE22C4-0F44-11d2-8B82-00A0C93C09B2")
CrIrisPP;
#endif

EXTERN_C const CLSID CLSID_CrSlide;

#ifdef __cplusplus

class DECLSPEC_UUID("810E402F-056B-11D2-A484-00C04F8EFB69")
CrSlide;
#endif

EXTERN_C const CLSID CLSID_CrSlidePP;

#ifdef __cplusplus

class DECLSPEC_UUID("CC8CEDE1-1003-11d2-8B82-00A0C93C09B2")
CrSlidePP;
#endif

EXTERN_C const CLSID CLSID_CrRadialWipe;

#ifdef __cplusplus

class DECLSPEC_UUID("424B71AF-0695-11D2-A484-00C04F8EFB69")
CrRadialWipe;
#endif

EXTERN_C const CLSID CLSID_CrRadialWipePP;

#ifdef __cplusplus

class DECLSPEC_UUID("33D932E0-0F48-11d2-8B82-00A0C93C09B2")
CrRadialWipePP;
#endif

EXTERN_C const CLSID CLSID_CrBarn;

#ifdef __cplusplus

class DECLSPEC_UUID("C3BDF740-0B58-11d2-A484-00C04F8EFB69")
CrBarn;
#endif

EXTERN_C const CLSID CLSID_CrBlinds;

#ifdef __cplusplus

class DECLSPEC_UUID("00C429C0-0BA9-11d2-A484-00C04F8EFB69")
CrBlinds;
#endif

EXTERN_C const CLSID CLSID_CrBlindPP;

#ifdef __cplusplus

class DECLSPEC_UUID("213052C1-100D-11d2-8B82-00A0C93C09B2")
CrBlindPP;
#endif

EXTERN_C const CLSID CLSID_CrStretch;

#ifdef __cplusplus

class DECLSPEC_UUID("7658F2A2-0A83-11d2-A484-00C04F8EFB69")
CrStretch;
#endif

EXTERN_C const CLSID CLSID_CrStretchPP;

#ifdef __cplusplus

class DECLSPEC_UUID("15FB95E0-0F77-11d2-8B82-00A0C93C09B2")
CrStretchPP;
#endif

EXTERN_C const CLSID CLSID_CrInset;

#ifdef __cplusplus

class DECLSPEC_UUID("93073C40-0BA5-11d2-A484-00C04F8EFB69")
CrInset;
#endif

EXTERN_C const CLSID CLSID_CrSpiral;

#ifdef __cplusplus

class DECLSPEC_UUID("ACA97E00-0C7D-11d2-A484-00C04F8EFB69")
CrSpiral;
#endif

EXTERN_C const CLSID CLSID_CrSpiralPP;

#ifdef __cplusplus

class DECLSPEC_UUID("C6A4FE81-1022-11d2-8B82-00A0C93C09B2")
CrSpiralPP;
#endif

EXTERN_C const CLSID CLSID_CrZigzag;

#ifdef __cplusplus

class DECLSPEC_UUID("E6E73D20-0C8A-11d2-A484-00C04F8EFB69")
CrZigzag;
#endif

EXTERN_C const CLSID CLSID_CrZigzagPP;

#ifdef __cplusplus

class DECLSPEC_UUID("1559A3C1-102B-11d2-8B82-00A0C93C09B2")
CrZigzagPP;
#endif

EXTERN_C const CLSID CLSID_CrWheel;

#ifdef __cplusplus

class DECLSPEC_UUID("5AE1DAE0-1461-11d2-A484-00C04F8EFB69")
CrWheel;
#endif

EXTERN_C const CLSID CLSID_CrWheelPP;

#ifdef __cplusplus

class DECLSPEC_UUID("FA9F6180-1464-11d2-A484-00C04F8EFB69")
CrWheelPP;
#endif

EXTERN_C const CLSID CLSID_DXTChroma;

#ifdef __cplusplus

class DECLSPEC_UUID("421516C1-3CF8-11D2-952A-00C04FA34F05")
DXTChroma;
#endif

EXTERN_C const CLSID CLSID_DXTChromaPP;

#ifdef __cplusplus

class DECLSPEC_UUID("EC7E0760-4C76-11D2-8ADE-00A0C98E6527")
DXTChromaPP;
#endif

EXTERN_C const CLSID CLSID_DXTDropShadow;

#ifdef __cplusplus

class DECLSPEC_UUID("ADC6CB86-424C-11D2-952A-00C04FA34F05")
DXTDropShadow;
#endif

EXTERN_C const CLSID CLSID_DXTDropShadowPP;

#ifdef __cplusplus

class DECLSPEC_UUID("EC7E0761-4C76-11D2-8ADE-00A0C98E6527")
DXTDropShadowPP;
#endif

EXTERN_C const CLSID CLSID_DXTMetaRoll;

#ifdef __cplusplus

class DECLSPEC_UUID("9C61F46E-0530-11D2-8F98-00C04FB92EB7")
DXTMetaRoll;
#endif

EXTERN_C const CLSID CLSID_DXTMetaRipple;

#ifdef __cplusplus

class DECLSPEC_UUID("AA0D4D03-06A3-11D2-8F98-00C04FB92EB7")
DXTMetaRipple;
#endif

EXTERN_C const CLSID CLSID_DXTMetaPageTurn;

#ifdef __cplusplus

class DECLSPEC_UUID("AA0D4D08-06A3-11D2-8F98-00C04FB92EB7")
DXTMetaPageTurn;
#endif

EXTERN_C const CLSID CLSID_DXTMetaLiquid;

#ifdef __cplusplus

class DECLSPEC_UUID("AA0D4D0A-06A3-11D2-8F98-00C04FB92EB7")
DXTMetaLiquid;
#endif

EXTERN_C const CLSID CLSID_DXTMetaCenterPeel;

#ifdef __cplusplus

class DECLSPEC_UUID("AA0D4D0C-06A3-11D2-8F98-00C04FB92EB7")
DXTMetaCenterPeel;
#endif

EXTERN_C const CLSID CLSID_DXTMetaPeelSmall;

#ifdef __cplusplus

class DECLSPEC_UUID("AA0D4D0E-06A3-11D2-8F98-00C04FB92EB7")
DXTMetaPeelSmall;
#endif

EXTERN_C const CLSID CLSID_DXTMetaPeelPiece;

#ifdef __cplusplus

class DECLSPEC_UUID("AA0D4D10-06A3-11D2-8F98-00C04FB92EB7")
DXTMetaPeelPiece;
#endif

EXTERN_C const CLSID CLSID_DXTMetaPeelSplit;

#ifdef __cplusplus

class DECLSPEC_UUID("AA0D4D12-06A3-11D2-8F98-00C04FB92EB7")
DXTMetaPeelSplit;
#endif

EXTERN_C const CLSID CLSID_DXTMetaWater;

#ifdef __cplusplus

class DECLSPEC_UUID("107045C5-06E0-11D2-8D6D-00C04F8EF8E0")
DXTMetaWater;
#endif

EXTERN_C const CLSID CLSID_DXTMetaLightWipe;

#ifdef __cplusplus

class DECLSPEC_UUID("107045C8-06E0-11D2-8D6D-00C04F8EF8E0")
DXTMetaLightWipe;
#endif

EXTERN_C const CLSID CLSID_DXTMetaRadialScaleWipe;

#ifdef __cplusplus

class DECLSPEC_UUID("107045CA-06E0-11D2-8D6D-00C04F8EF8E0")
DXTMetaRadialScaleWipe;
#endif

EXTERN_C const CLSID CLSID_DXTMetaWhiteOut;

#ifdef __cplusplus

class DECLSPEC_UUID("107045CC-06E0-11D2-8D6D-00C04F8EF8E0")
DXTMetaWhiteOut;
#endif

EXTERN_C const CLSID CLSID_DXTMetaTwister;

#ifdef __cplusplus

class DECLSPEC_UUID("107045CF-06E0-11D2-8D6D-00C04F8EF8E0")
DXTMetaTwister;
#endif

EXTERN_C const CLSID CLSID_DXTMetaBurnFilm;

#ifdef __cplusplus

class DECLSPEC_UUID("107045D1-06E0-11D2-8D6D-00C04F8EF8E0")
DXTMetaBurnFilm;
#endif

EXTERN_C const CLSID CLSID_DXTMetaJaws;

#ifdef __cplusplus

class DECLSPEC_UUID("2A54C904-07AA-11D2-8D6D-00C04F8EF8E0")
DXTMetaJaws;
#endif

EXTERN_C const CLSID CLSID_DXTMetaColorFade;

#ifdef __cplusplus

class DECLSPEC_UUID("2A54C908-07AA-11D2-8D6D-00C04F8EF8E0")
DXTMetaColorFade;
#endif

EXTERN_C const CLSID CLSID_DXTMetaFlowMotion;

#ifdef __cplusplus

class DECLSPEC_UUID("2A54C90B-07AA-11D2-8D6D-00C04F8EF8E0")
DXTMetaFlowMotion;
#endif

EXTERN_C const CLSID CLSID_DXTMetaVacuum;

#ifdef __cplusplus

class DECLSPEC_UUID("2A54C90D-07AA-11D2-8D6D-00C04F8EF8E0")
DXTMetaVacuum;
#endif

EXTERN_C const CLSID CLSID_DXTMetaGriddler;

#ifdef __cplusplus

class DECLSPEC_UUID("2A54C911-07AA-11D2-8D6D-00C04F8EF8E0")
DXTMetaGriddler;
#endif

EXTERN_C const CLSID CLSID_DXTMetaGriddler2;

#ifdef __cplusplus

class DECLSPEC_UUID("2A54C913-07AA-11D2-8D6D-00C04F8EF8E0")
DXTMetaGriddler2;
#endif

EXTERN_C const CLSID CLSID_DXTMetaThreshold;

#ifdef __cplusplus

class DECLSPEC_UUID("2A54C915-07AA-11D2-8D6D-00C04F8EF8E0")
DXTMetaThreshold;
#endif

EXTERN_C const CLSID CLSID_DXTMetaWormHole;

#ifdef __cplusplus

class DECLSPEC_UUID("0E6AE022-0C83-11D2-8CD4-00104BC75D9A")
DXTMetaWormHole;
#endif
#endif /* __DXTMSFTLib_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     unsigned long __RPC_FAR *, unsigned long            , BSTR __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  BSTR_UserMarshal(  unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, BSTR __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  BSTR_UserUnmarshal(unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, BSTR __RPC_FAR * ); 
void                      __RPC_USER  BSTR_UserFree(     unsigned long __RPC_FAR *, BSTR __RPC_FAR * ); 

unsigned long             __RPC_USER  LPSAFEARRAY_UserSize(     unsigned long __RPC_FAR *, unsigned long            , LPSAFEARRAY __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  LPSAFEARRAY_UserMarshal(  unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, LPSAFEARRAY __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  LPSAFEARRAY_UserUnmarshal(unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, LPSAFEARRAY __RPC_FAR * ); 
void                      __RPC_USER  LPSAFEARRAY_UserFree(     unsigned long __RPC_FAR *, LPSAFEARRAY __RPC_FAR * ); 

unsigned long             __RPC_USER  VARIANT_UserSize(     unsigned long __RPC_FAR *, unsigned long            , VARIANT __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  VARIANT_UserMarshal(  unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, VARIANT __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  VARIANT_UserUnmarshal(unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, VARIANT __RPC_FAR * ); 
void                      __RPC_USER  VARIANT_UserFree(     unsigned long __RPC_FAR *, VARIANT __RPC_FAR * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\setup\setbldno\makefile.inc ===
copyfiles:
  @if exist obj\$(TARGET_DIRECTORY)\$(TARGETNAME).exe  \
    copy obj\$(TARGET_DIRECTORY)\$(TARGETNAME).exe     \
         $(QBUILD_ROOT)\bin\*.*
  @if exist obj\$(TARGET_DIRECTORY)\$(TARGETNAME).dll  \
    copy obj\$(TARGET_DIRECTORY)\$(TARGETNAME).dll     \
         $(QBUILD_ROOT)\bin\*.*


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\extinc\dxvector.h ===
/*******************************************************************************
* DXVector.h *
*------------*
*   Description:
*       This is the header file for the vector and matrix classes.
*-------------------------------------------------------------------------------
*  Created By: Mike Arnstein                            Date: 04/11/97
*  Copyright (C) 1997 Microsoft Corporation
*  All Rights Reserved
*
*-------------------------------------------------------------------------------
*  Revisions:
*
*******************************************************************************/
#ifndef DXVector_h
#define DXVector_h

#ifndef _INC_MATH
#include <math.h>
#endif

#ifndef _INC_CRTDBG
#include <crtdbg.h>
#endif

//=== Constants ====================================================


//=== Class, Enum, Struct and Union Declarations ===================
class CDXMatrix4x4F;

//=== Enumerated Set Definitions ===================================

//=== Function Type Definitions ====================================
float det4x4( CDXMatrix4x4F *pIn );
float det3x3( float a1, float a2, float a3, float b1, float b2, float b3, 
              float c1, float c2, float c3 );
float det2x2( float a, float b, float c, float d );

//=== Class, Struct and Union Definitions ==========================

/*** CDXVec ************
*   This template implements basic vector operations for each of the
*   union types
*/
#define CDXV_C CDXVec<TYPE, eBndType>
#define CDXV_T ((TYPE*)u.D)
#define CDXV_O( OtherVec ) ((TYPE*)OtherVec.u.D)

template<class TYPE, DXBNDTYPE eBndType>
class CDXVec : public DXVEC
{
  /*=== Methods =======*/
  public:
    /*--- Constructors ---*/
    CDXVec() { eType = eBndType; ZeroVector(); }
    CDXVec(BOOL bInit) { eType = eBndType; if (bInit) ZeroVector(); }
    CDXVec( TYPE x, TYPE y, TYPE z, TYPE t )
        { eType = eBndType; CDXV_T[DXB_X] = x; CDXV_T[DXB_Y] = y;
                            CDXV_T[DXB_Z] = z; CDXV_T[DXB_T] = t; }
    CDXVec( const CDXVec& Other ) { memcpy( this, (void *)&Other, sizeof(DXVEC) ); }
    CDXVec( const DXVEC Other ) { memcpy( this, &Other, sizeof(DXVEC) ); }
    operator TYPE *() { return CDXV_T; }
    operator const TYPE *() { return CDXV_T; }

    /*--- operations ---*/
    void ZeroVector( void ) { memset( u.D, 0, sizeof(TYPE) * 4); }

    /*--- operators ---*/
    TYPE&  operator[]( int index ) const { return CDXV_T[index]; }
    TYPE&  operator[]( long index ) const { return CDXV_T[index]; }
    TYPE&  operator[]( USHORT index ) const { return CDXV_T[index]; }
    TYPE&  operator[]( DWORD index ) const { return CDXV_T[index]; }
    CDXV_C operator+(const CDXV_C& v);
    CDXV_C operator-(const CDXV_C& v);
    void   operator=(const CDXV_C& srcVector);
    void   operator+=(const CDXV_C& vOther);
    void   operator-=(const CDXV_C& vOther);
    BOOL   operator==(const CDXV_C& otherVector) const;
    BOOL   operator!=(const CDXV_C& otherVector) const;
};

template<class TYPE, DXBNDTYPE eBndType>
CDXV_C CDXV_C::operator+( const CDXV_C& srcVector )
{
    CDXV_C Result( this );
    CDXV_O( Result )[DXB_X] += CDXV_O( srcVector )[DXB_X];
    CDXV_O( Result )[DXB_Y] += CDXV_O( srcVector )[DXB_Y];
    CDXV_O( Result )[DXB_Z] += CDXV_O( srcVector )[DXB_Z];
    CDXV_O( Result )[DXB_T] += CDXV_O( srcVector )[DXB_T];
    return Result;
} /* CDXVec::operator+ */

template<class TYPE, DXBNDTYPE eBndType>
CDXV_C CDXV_C::operator-( const CDXV_C& srcVector )
{
    CDXV_C Result( this );
    CDXV_O( Result )[DXB_X] -= CDXV_O( srcVector )[DXB_X];
    CDXV_O( Result )[DXB_Y] -= CDXV_O( srcVector )[DXB_Y];
    CDXV_O( Result )[DXB_Z] -= CDXV_O( srcVector )[DXB_Z];
    CDXV_O( Result )[DXB_T] -= CDXV_O( srcVector )[DXB_T];
    return Result;
} /* CDXVec::operator- */

template<class TYPE, DXBNDTYPE eBndType>
void CDXV_C::operator=( const CDXV_C& srcVector )
{
    memcpy( this, &srcVector, sizeof(CDXVec) );
} /* CDXVec::operator= */

template<class TYPE, DXBNDTYPE eBndType>
BOOL CDXV_C::operator==(const CDXV_C& otherVector) const
{
    return !memcmp( this, &otherVector, sizeof(otherVector) );
} /* CDXVec::operator== */

template<class TYPE, DXBNDTYPE eBndType>
BOOL CDXV_C::operator!=(const CDXV_C& otherVector) const
{
    return memcmp( this, &otherVector, sizeof(otherVector) );
} /* CDXVec::operator!= */

template<class TYPE, DXBNDTYPE eBndType>
void CDXV_C::operator+=(const CDXV_C& vOther)
{
    CDXV_T[DXB_X] += CDXV_O( vOther )[DXB_X];
    CDXV_T[DXB_Y] += CDXV_O( vOther )[DXB_Y];
    CDXV_T[DXB_Z] += CDXV_O( vOther )[DXB_Z];
    CDXV_T[DXB_T] += CDXV_O( vOther )[DXB_T];
} /* CDXVec::operator+= */

template<class TYPE, DXBNDTYPE eBndType>
void CDXV_C::operator-=(const CDXVec& vOther)
{
    CDXV_T[DXB_X] -= CDXV_O( vOther )[DXB_X];
    CDXV_T[DXB_Y] -= CDXV_O( vOther )[DXB_Y];
    CDXV_T[DXB_Z] -= CDXV_O( vOther )[DXB_Z];
    CDXV_T[DXB_T] -= CDXV_O( vOther )[DXB_T];
} /* CDXVec::operator-= */

typedef CDXVec<long, DXBT_DISCRETE> CDXDVec;
typedef CDXVec<LONGLONG, DXBT_DISCRETE64> CDXDVec64;
typedef CDXVec<float, DXBT_CONTINUOUS> CDXCVec;
typedef CDXVec<double, DXBT_CONTINUOUS64> CDXCVec64;

/*** CDX2DXForm ************
*   This class implements basic matrix operation based on the GDI XFORM
*   structure.
*/
//const DX2DXFORM g_DX2DXFORMIdentity = { 1., 0., 0., 1., 0., 0., DX2DXO_IDENTITY };

class CDX2DXForm : public DX2DXFORM
{
  /*=== Methods =======*/
public:
    /*--- Constructors ---*/
    CDX2DXForm() { SetIdentity(); }
    CDX2DXForm( const CDX2DXForm& Other ) { memcpy( this, &Other, sizeof(*this) ); }
    CDX2DXForm( const DX2DXFORM& Other ) { memcpy( this, &Other, sizeof(*this) ); }

    /*--- methods ---*/
    void DetermineOp( void );
    void Set( const DX2DXFORM& Other ) { memcpy( this, &Other, sizeof(*this) ); DetermineOp(); }
    void ZeroMatrix( void ) { memset( this, 0, sizeof( *this ) ); }
    void SetIdentity( void ) {  
        eM11 = 1.;
        eM12 = 0.;
        eM21 = 0.;
        eM22 = 1.;
        eDx = 0.;
        eDy = 0.;
        eOp = DX2DXO_IDENTITY;
    }
    BOOL IsIdentity() const { return eOp == DX2DXO_IDENTITY; }
    void Scale( float sx, float sy );
    void Rotate( float Rotation );
    void Translate( float dx, float dy );
    BOOL Invert();
    void TransformBounds( const DXBNDS& Bnds, DXBNDS& ResultBnds ) const;
    void TransformPoints( const DXFPOINT InPnts[], DXFPOINT OutPnts[], ULONG ulCount ) const;
    void GetMinMaxScales( float& MinScale, float& MaxScale );

    /*--- operators ---*/
    DXFPOINT operator*( const DXFPOINT& v ) const;
    CDX2DXForm operator*( const CDX2DXForm& Other ) const;
};

//=== CDX2DXForm methods ==============================================================
inline void CDX2DXForm::DetermineOp( void )
{
    if( ( eM12 == 0. ) && ( eM21 == 0. ) )
    {
        if( ( eM11 == 1. ) && ( eM22 == 1. ) )
        {
            eOp = ( ( eDx == 0 ) && ( eDy == 0 ) )?(DX2DXO_IDENTITY):(DX2DXO_TRANSLATE);
        }
        else
        {
            eOp = ( ( eDx == 0 ) && ( eDy == 0 ) )?(DX2DXO_SCALE):(DX2DXO_SCALE_AND_TRANS);
        }
    }
    else
    {
        eOp = ( ( eDx == 0 ) && ( eDy == 0 ) )?(DX2DXO_GENERAL):(DX2DXO_GENERAL_AND_TRANS);
    }
} /* CDX2DXForm::DetermineOp */

inline float DXSq( float f ) { return f * f; }

// This function computes the Min and Max scale that a matrix represents.
// In other words, what is the maximum/minimum length that a line of length 1
// could get stretched/shrunk to if the line was transformed by this matrix.
//
// The function uses eigenvalues; and returns two float numbers. Both are
// non-negative; and MaxScale >= MinScale.
// 
inline void CDX2DXForm::GetMinMaxScales( float& MinScale, float& MaxScale )
{
    if( ( eM12 == 0. ) && ( eM21 == 0. ) )
    {
        // Let MinScale = abs(eM11)
        if (eM11 < 0)
            MinScale = -eM11;
        else
            MinScale = eM11;

        // Let MaxScale = abs(eM22)
        if (eM22 < 0)
            MaxScale = -eM22;
        else
            MaxScale = eM22;

        // Swap Min/Max if necessary
        if (MinScale > MaxScale)
        {
            float flTemp = MinScale;
            MinScale = MaxScale;
            MaxScale = flTemp;
        }
    }
    else
    {
        float t1 = DXSq(eM11) + DXSq(eM12) + DXSq(eM21) + DXSq(eM22);
        if( t1 == 0. )
        {
            MinScale = MaxScale = 0;
        }
        else
        {
            float t2 = (float)sqrt( (DXSq(eM12 + eM21) + DXSq(eM11 - eM22)) *
                                    (DXSq(eM12 - eM21) + DXSq(eM11 + eM22)) );

            // Due to floating point error; t1 may end up less than t2;
            // but that would mean that the min scale was small (relative
            // to max scale)
            if (t1 <= t2)
                MinScale = 0;
            else
                MinScale = (float)sqrt( (t1 - t2) * .5f );

            MaxScale = (float)sqrt( (t1 + t2) * .5f );
        }
    }
} /* CDX2DXForm::GetMinMaxScales */

inline void CDX2DXForm::Rotate( float Rotation )
{
    double Angle = Rotation * (3.1415926535/180.0);
    float CosZ   = (float)cos( Angle );
    float SinZ   = (float)sin( Angle );
    if (CosZ > 0.0F && CosZ < 0.0000005F)
    {
        CosZ = .0F;
    }
    if (SinZ > -0.0000005F && SinZ < .0F)
    {
        SinZ = .0F;
    }

    float M11 = ( CosZ * eM11 ) + ( SinZ * eM21 ); 
    float M21 = (-SinZ * eM11 ) + ( CosZ * eM21 );
    float M12 = ( CosZ * eM12 ) + ( SinZ * eM22 ); 
    float M22 = (-SinZ * eM12 ) + ( CosZ * eM22 );
    eM11 = M11; eM21 = M21; eM12 = M12; eM22 = M22;
    DetermineOp();
} /* CDX2DXForm::Rotate */

inline void CDX2DXForm::Scale( float sx, float sy )
{
    eM11 *= sx;
    eM12 *= sx;
    eDx  *= sx;
    eM21 *= sy;
    eM22 *= sy;
    eDy  *= sy;
    DetermineOp();
} /* CDX2DXForm::Scale */

inline void CDX2DXForm::Translate( float dx, float dy )
{
    eDx += dx;
    eDy += dy;
    DetermineOp();
} /* CDX2DXForm::Translate */

inline void CDX2DXForm::TransformBounds( const DXBNDS& Bnds, DXBNDS& ResultBnds ) const
{
    ResultBnds = Bnds;
    if( eOp != DX2DXO_IDENTITY )
    {
        ResultBnds.u.D[DXB_X].Min = (long)(( eM11 * Bnds.u.D[DXB_X].Min ) + ( eM12 * Bnds.u.D[DXB_Y].Min ) + eDx);
        ResultBnds.u.D[DXB_X].Max = (long)(( eM11 * Bnds.u.D[DXB_X].Max ) + ( eM12 * Bnds.u.D[DXB_Y].Max ) + eDx);
        ResultBnds.u.D[DXB_Y].Min = (long)(( eM21 * Bnds.u.D[DXB_X].Min ) + ( eM22 * Bnds.u.D[DXB_Y].Min ) + eDy);
        ResultBnds.u.D[DXB_Y].Max = (long)(( eM21 * Bnds.u.D[DXB_X].Max ) + ( eM22 * Bnds.u.D[DXB_Y].Max ) + eDy);
    }
} /* CDX2DXForm::TransformBounds */

inline void CDX2DXForm::TransformPoints( const DXFPOINT InPnts[], DXFPOINT OutPnts[], ULONG ulCount ) const
{
    ULONG i;
    switch( eOp )
    {
      case DX2DXO_IDENTITY:
        memcpy( OutPnts, InPnts, ulCount * sizeof( DXFPOINT ) );
        break;
      case DX2DXO_TRANSLATE:
        for( i = 0; i < ulCount; ++i )
        {
            OutPnts[i].x = InPnts[i].x + eDx;
            OutPnts[i].y = InPnts[i].y + eDy;
        }
        break;
      case DX2DXO_SCALE:
        for( i = 0; i < ulCount; ++i )
        {
            OutPnts[i].x = InPnts[i].x * eM11;
            OutPnts[i].y = InPnts[i].y * eM22;
        }
        break;
      case DX2DXO_SCALE_AND_TRANS:
        for( i = 0; i < ulCount; ++i )
        {
            OutPnts[i].x = (InPnts[i].x * eM11) + eDx;
            OutPnts[i].y = (InPnts[i].y * eM22) + eDy;
        }
        break;
      case DX2DXO_GENERAL:
        for( i = 0; i < ulCount; ++i )
        {
            OutPnts[i].x = ( InPnts[i].x * eM11 ) + ( InPnts[i].y * eM12 );
            OutPnts[i].y = ( InPnts[i].x * eM21 ) + ( InPnts[i].y * eM22 );
        }
        break;
      case DX2DXO_GENERAL_AND_TRANS:
        for( i = 0; i < ulCount; ++i )
        {
            OutPnts[i].x = ( InPnts[i].x * eM11 ) + ( InPnts[i].y * eM12 ) + eDx;
            OutPnts[i].y = ( InPnts[i].x * eM21 ) + ( InPnts[i].y * eM22 ) + eDy;
        }
        break;
      default:
        _ASSERT( 0 );   // invalid operation id
    }
} /* CDX2DXForm::TransformPoints */

inline DXFPOINT CDX2DXForm::operator*( const DXFPOINT& v ) const
{
    DXFPOINT NewPnt;
    NewPnt.x = ( v.x * eM11 ) + ( v.y * eM12 ) + eDx;
    NewPnt.y = ( v.x * eM21 ) + ( v.y * eM22 ) + eDy;
    return NewPnt;
} /* CDX2DXForm::operator* */

inline CDX2DXForm CDX2DXForm::operator*( const CDX2DXForm& Other ) const
{
    DX2DXFORM x;
    x.eM11 = ( eM11 * Other.eM11 ) + ( eM12 * Other.eM21 );
    x.eM12 = ( eM11 * Other.eM12 ) + ( eM12 * Other.eM22 );
    x.eDx  = ( eM11 * Other.eDx  ) + ( eM12 * Other.eDy  ) + eDx;

    x.eM21 = ( eM21 * Other.eM11 ) + ( eM22 * Other.eM21 );
    x.eM22 = ( eM21 * Other.eM12 ) + ( eM22 * Other.eM22 );
    x.eDy  = ( eM21 * Other.eDx  ) + ( eM22 * Other.eDy  ) + eDy;
    return x;
} /* CDX2DXForm::operator*= */

inline BOOL CDX2DXForm::Invert()
{
    switch( eOp )
    {
    case DX2DXO_IDENTITY:
        break;
    case DX2DXO_TRANSLATE:
        eDx = -eDx;
        eDy = -eDy;
        break;
    case DX2DXO_SCALE:

        if (eM11 == 0.0 || eM22 == 0.0)
            return false;
        eM11 = 1.0f / eM11;
        eM22 = 1.0f / eM22;
        break;

    case DX2DXO_SCALE_AND_TRANS:
        {
            if (eM11 == 0.0f || eM22 == 0.0f)
                return false;

            // Our old equation was F = aG + b
            // The inverse is G = F/a - b/a where a is eM11 and b is eDx
            float flOneOverA = 1.0f / eM11;
            eDx = -eDx * flOneOverA;
            eM11 = flOneOverA;

            // Our old equation was F = aG + b
            // The inverse is G = F/a - b/a where a is eM22 and b is eDy

            flOneOverA = 1.0f / eM22;
            eDy = -eDy * flOneOverA;
            eM22 = flOneOverA;
            break;
        }

    case DX2DXO_GENERAL:
    case DX2DXO_GENERAL_AND_TRANS:
        {
            // The inverse of A=  |a b| is | d -c|*(1/Det) where Det is the determinant of A
            //                    |c d|    |-b  a|
            // Det(A) = ad - bc

            // Compute determininant
            float flDet = (eM11 * eM22 -  eM12 * eM21);
            if (flDet == 0.0f)
                return FALSE;

            float flCoef = 1.0f / flDet;

            // Remember old value of eM11
            float flM11Original = eM11;

            eM11 = flCoef * eM22;
            eM12 = -flCoef * eM12;
            eM21 = -flCoef * eM21;
            eM22 = flCoef * flM11Original;

            // If we have a translation; then we need to 
            // compute new values for that translation
            if (eOp == DX2DXO_GENERAL_AND_TRANS)
            {
                // Remember original value of eDx
                float eDxOriginal = eDx;

                eDx = -eM11 * eDx - eM12 * eDy;
                eDy = -eM21 * eDxOriginal - eM22 * eDy;
            }
        }
        break;

    default:
        _ASSERT( 0 );   // invalid operation id
    }

    // We don't need to call DetermineOp here
    // because the op doesn't change when inverted
    // i.e. a scale remains a scale, etc.

    return true;
} /* CDX2DXForm::Invert */

/*** CDXMatrix4x4F ************
*   This class implements basic matrix operation based on a 4x4 array.
*/
//const float g_DXMat4X4Identity[4][4] =
//{
//    { 1.0, 0. , 0. , 0.  },
//    { 0. , 1.0, 0. , 0.  },
//    { 0. , 0. , 1.0, 0.  },
//    { 0. , 0. , 0. , 1.0 }
//};

class CDXMatrix4x4F
{
public:
  /*=== Member Data ===*/
    float m_Coeff[4][4];

  /*=== Methods =======*/
public:
    /*--- Constructors ---*/
    CDXMatrix4x4F() { SetIdentity(); }
    CDXMatrix4x4F( const CDXMatrix4x4F& Other )
        { CopyMemory( (void *)&m_Coeff, (void *)&Other.m_Coeff, sizeof(m_Coeff) ); }
    CDXMatrix4x4F( DX2DXFORM& XForm );

    /*--- operations ---*/
    void ZeroMatrix( void ) { memset( m_Coeff, 0, sizeof( m_Coeff ) ); }
    void SetIdentity( void ) {
        memset( m_Coeff, 0, sizeof( m_Coeff ) );
        m_Coeff[0][0] = m_Coeff[1][1] = m_Coeff[2][2] = m_Coeff[3][3] = 1.0;
    }
    void SetCoefficients( float Coeff[4][4] ) { memcpy( m_Coeff, Coeff, sizeof( m_Coeff )); }
    void GetCoefficients( float Coeff[4][4] ) { memcpy( Coeff, m_Coeff, sizeof( m_Coeff )); }

    //BOOL IsIdentity();
    void Scale( float sx, float sy, float sz );
    void Rotate( float rx, float ry, float rz );
    void Translate( float dx, float dy, float dz );
    BOOL Invert();
    BOOL GetInverse( CDXMatrix4x4F *pIn );
    void Transpose();
    void GetTranspose( CDXMatrix4x4F *pIn );
    void GetAdjoint( CDXMatrix4x4F *pIn );
    HRESULT InitFromSafeArray( SAFEARRAY *psa );
    HRESULT GetSafeArray( SAFEARRAY **ppsa ) const;
    void TransformBounds( DXBNDS& Bnds, DXBNDS& ResultBnds );

    /*--- operators ---*/
    CDXDVec operator*( CDXDVec& v) const;
    CDXCVec operator*( CDXCVec& v) const;
    CDXMatrix4x4F operator*(CDXMatrix4x4F Matrix) const;
    void operator*=(CDXMatrix4x4F Matrix) const;
    void CDXMatrix4x4F::operator=(const CDXMatrix4x4F srcMatrix);
    void CDXMatrix4x4F::operator+=(const CDXMatrix4x4F otherMatrix);
    void CDXMatrix4x4F::operator-=(const CDXMatrix4x4F otherMatrix);
    BOOL CDXMatrix4x4F::operator==(const CDXMatrix4x4F otherMatrix) const;
    BOOL CDXMatrix4x4F::operator!=(const CDXMatrix4x4F otherMatrix) const;
};

inline CDXMatrix4x4F::CDXMatrix4x4F( DX2DXFORM& XForm )
{
    SetIdentity();
    m_Coeff[0][0] = XForm.eM11;
    m_Coeff[0][1] = XForm.eM12;
    m_Coeff[1][0] = XForm.eM21;
    m_Coeff[1][1] = XForm.eM22;
    m_Coeff[0][3] = XForm.eDx;
    m_Coeff[1][3] = XForm.eDy;
}

// Additional Operations

inline void CDXMatrix4x4F::operator=(const CDXMatrix4x4F srcMatrix)
{
    CopyMemory( (void *)m_Coeff, (const void *)srcMatrix.m_Coeff, sizeof(srcMatrix.m_Coeff) );
} /* CDXMatrix4x4F::operator= */

inline BOOL CDXMatrix4x4F::operator==(const CDXMatrix4x4F otherMatrix) const
{
    return !memcmp( (void *)m_Coeff, (const void *)otherMatrix.m_Coeff, sizeof(otherMatrix.m_Coeff) );
} /* CDXMatrix4x4F::operator== */

inline BOOL CDXMatrix4x4F::operator!=(const CDXMatrix4x4F otherMatrix) const
{
    return memcmp( (void *)m_Coeff, (const void *)otherMatrix.m_Coeff, sizeof(otherMatrix.m_Coeff) );
} /* CDXMatrix4x4F::operator!= */

inline void CDXMatrix4x4F::operator+=(const CDXMatrix4x4F otherMatrix)
{
    for( int i = 0; i < 4; i++ )
        for( int j = 0; j < 4; j++ )
            m_Coeff[i][j] += otherMatrix.m_Coeff[i][j];
} /* CDXMatrix4x4F::operator+= */

inline void CDXMatrix4x4F::operator-=(const CDXMatrix4x4F otherMatrix) 
{
    for( int i = 0; i < 4; i++ )
        for( int j = 0; j < 4; j++ )
            m_Coeff[i][j] -= otherMatrix.m_Coeff[i][j];
} /* CDXMatrix4x4F::operator-= */

inline CDXDVec CDXMatrix4x4F::operator*(CDXDVec& v) const
{
    CDXDVec t;
    float temp;
    temp = v[0]*m_Coeff[0][0]+v[1]*m_Coeff[1][0]+v[2]*m_Coeff[2][0]+v[3]*m_Coeff[3][0];
    t[0] = (long)((temp < 0) ? temp -= .5 : temp += .5);
    temp = v[0]*m_Coeff[0][1]+v[1]*m_Coeff[1][1]+v[2]*m_Coeff[2][1]+v[3]*m_Coeff[3][1];
    t[1] = (long)((temp < 0) ? temp -= .5 : temp += .5);
    temp = v[0]*m_Coeff[0][2]+v[1]*m_Coeff[1][2]+v[2]*m_Coeff[2][2]+v[3]*m_Coeff[3][2];
    t[2] = (long)((temp < 0) ? temp -= .5 : temp += .5);
    temp = v[0]*m_Coeff[0][3]+v[1]*m_Coeff[1][3]+v[2]*m_Coeff[2][3]+v[3]*m_Coeff[3][3];
    t[3] = (long)((temp < 0) ? temp -= .5 : temp += .5);
    return t;
} /* CDXMatrix4x4F::operator*(DXDVEC) */

inline CDXCVec CDXMatrix4x4F::operator*(CDXCVec& v) const
{
    CDXCVec t;
    t[0] = v[0]*m_Coeff[0][0]+v[1]*m_Coeff[1][0]+v[2]*m_Coeff[2][0]+v[3]*m_Coeff[3][0];
    t[1] = v[0]*m_Coeff[0][1]+v[1]*m_Coeff[1][1]+v[2]*m_Coeff[2][1]+v[3]*m_Coeff[3][1];
    t[2] = v[0]*m_Coeff[0][2]+v[1]*m_Coeff[1][2]+v[2]*m_Coeff[2][2]+v[3]*m_Coeff[3][2];
    t[3] = v[0]*m_Coeff[0][3]+v[1]*m_Coeff[1][3]+v[2]*m_Coeff[2][3]+v[3]*m_Coeff[3][3];
    return t;
} /* CDXMatrix4x4F::operator*(DXCVEC) */

inline CDXMatrix4x4F CDXMatrix4x4F::operator*(CDXMatrix4x4F Mx) const
{
    CDXMatrix4x4F t;
    int i, j;

    for( i = 0; i < 4; i++ )
    {
        for( j = 0; j < 4; j++ )
        {
            t.m_Coeff[i][j] =   m_Coeff[i][0] * Mx.m_Coeff[0][j] + 
                                m_Coeff[i][1] * Mx.m_Coeff[1][j] +
                                m_Coeff[i][2] * Mx.m_Coeff[2][j] +
                                m_Coeff[i][3] * Mx.m_Coeff[3][j];
        }
    }

    return t;
} /* CDXMatrix4x4F::operator*(CDXMatrix4x4F) */
            
inline void CDXMatrix4x4F::operator*=(CDXMatrix4x4F Mx) const
{
    CDXMatrix4x4F t;
    int i, j;

    for( i = 0; i < 4; i++ )
    {
        for( j = 0; j < 4; j++ )
        {
            t.m_Coeff[i][j] =   m_Coeff[i][0] * Mx.m_Coeff[0][j] + 
                                m_Coeff[i][1] * Mx.m_Coeff[1][j] +
                                m_Coeff[i][2] * Mx.m_Coeff[2][j] +
                                m_Coeff[i][3] * Mx.m_Coeff[3][j];
        }
    }

    CopyMemory( (void *)m_Coeff, (void *)t.m_Coeff, sizeof(m_Coeff) );
} /* CDXMatrix4x4F::operator*=(CDXMatrix4x4F) */
            

inline void CDXMatrix4x4F::Scale( float sx, float sy, float sz )
{
    if( sx != 1. )
    {
        m_Coeff[0][0] *= sx;
        m_Coeff[0][1] *= sx;
        m_Coeff[0][2] *= sx;
        m_Coeff[0][3] *= sx;
    }
    if( sy != 1. )
    {
        m_Coeff[1][0] *= sy;
        m_Coeff[1][1] *= sy;
        m_Coeff[1][2] *= sy;
        m_Coeff[1][3] *= sy;
    }
    if( sz != 1. )
    {
        m_Coeff[2][0] *= sz;
        m_Coeff[2][1] *= sz;
        m_Coeff[2][2] *= sz;
        m_Coeff[2][3] *= sz;
    }
} /* CDXMatrix4x4F::Scale */

inline void CDXMatrix4x4F::Translate( float dx, float dy, float dz )
{
    float a, b, c, d;
    a = b = c = d = 0;
    if( dx != 0. )
    {
        a += m_Coeff[0][0]*dx;
        b += m_Coeff[0][1]*dx;
        c += m_Coeff[0][2]*dx;
        d += m_Coeff[0][3]*dx;
    }
    if( dy != 0. )
    {
        a += m_Coeff[1][0]*dy;
        b += m_Coeff[1][1]*dy;
        c += m_Coeff[1][2]*dy;
        d += m_Coeff[1][3]*dy;
    }
    if( dz != 0. )
    {
        a += m_Coeff[2][0]*dz;
        b += m_Coeff[2][1]*dz;
        c += m_Coeff[2][2]*dz;
        d += m_Coeff[2][3]*dz;
    }
    m_Coeff[3][0] += a;
    m_Coeff[3][1] += b;
    m_Coeff[3][2] += c;
    m_Coeff[3][3] += d;
} /* CDXMatrix4x4F::Translate */

inline void CDXMatrix4x4F::Rotate( float rx, float ry, float rz )
{
    const float l_dfCte = (const float)(3.1415926535/180.0);

    float lAngleY = 0.0;
    float lAngleX = 0.0;
    float lAngleZ = 0.0;
    float lCosX = 1.0;
    float lSinX = 0.0;
    float lCosY = 1.0;
    float lSinY = 0.0;
    float lCosZ = 1.0;
    float lSinZ = 0.0;

    // calculate rotation angle sines and cosines
    if( rx != 0 )
    {
        lAngleX = rx * l_dfCte;
        lCosX = (float)cos(lAngleX);
        lSinX = (float)sin(lAngleX);
        if (lCosX > 0.0F && lCosX < 0.0000005F)
        {
            lCosX = .0F;
        }
        if (lSinX > -0.0000005F && lSinX < .0F)
        {
            lSinX = .0F;
        }
    }
    if( ry != 0 )
    {
        lAngleY = ry * l_dfCte;
        lCosY = (float)cos(lAngleY);
        lSinY = (float)sin(lAngleY);
        if (lCosY > 0.0F && lCosY < 0.0000005F)
        {
            lCosY = .0F;
        }
        if (lSinY > -0.0000005F && lSinY < .0F)
        {
            lSinY = .0F;
        }
    }
    if( rz != 0 )
    {
        lAngleZ = rz * l_dfCte;
        lCosZ = (float)cos(lAngleZ);
        lSinZ = (float)sin(lAngleZ);
        if (lCosZ > 0.0F && lCosZ < 0.0000005F)
        {
            lCosZ = .0F;
        }
        if (lSinZ > -0.0000005F && lSinZ < .0F)
        {
            lSinZ = .0F;
        }
    }

    float u, v;
    int i;

    //--- X Rotation
    for( i = 0; i < 4; i++ )
    {
        u = m_Coeff[1][i]; 
        v = m_Coeff[2][i];
        m_Coeff[1][i] = lCosX*u+lSinX*v; 
        m_Coeff[2][i] = -lSinX*u+lCosX*v;
    }

    //--- Y Rotation
    for( i = 0; i < 4; i++ )
    {
        u = m_Coeff[0][i];
        v = m_Coeff[2][i];
        m_Coeff[0][i] = lCosY*u-lSinY*v; 
        m_Coeff[2][i] = lSinY*u+lCosY*v;
    }

    //--- Z Rotation
    for( i = 0; i < 4; i++ )
    {
        u = m_Coeff[0][i];
        v = m_Coeff[1][i];
        m_Coeff[0][i] = lCosZ*u+lSinZ*v; 
        m_Coeff[1][i] = -lSinZ*u+lCosZ*v;
    }
}

/*
inline BOOL CDXMatrix4x4F::IsIdentity()
{
    return  !memcmp( m_Coeff, g_DXMat4X4Identity, sizeof(g_DXMat4X4Identity) );
} /* CDXMatrix4x4F::IsIdentity */


/*
   Uses Gaussian elimination to invert the 4 x 4 non-linear matrix in t and
   return the result in Mx.  The matrix t is destroyed in the process.
*/
inline BOOL CDXMatrix4x4F::Invert()
{
    int i,j,k,Pivot;
    float PValue;
    CDXMatrix4x4F Mx;
    Mx.SetIdentity();

/* Find pivot element.  Use partial pivoting by row */
    for( i = 0;i < 4; i++ )
    {
        Pivot = 0;
        for( j = 0; j < 4; j++ )
        {
            if( fabs(m_Coeff[i][j]) > fabs(m_Coeff[i][Pivot]) ) Pivot = j;
        }

        if( m_Coeff[i][Pivot] == 0.0 )
        {
            ZeroMatrix();   /* Singular Matrix */
            return FALSE; 
        }

/* Normalize */
        PValue = m_Coeff[i][Pivot];
        for( j = 0; j < 4; j++ )
        {
            m_Coeff[i][j] /= PValue;
            Mx.m_Coeff[i][j] /= PValue;
        }

/* Zeroing */
        for( j = 0; j < 4; j++ )
        {
            if( j != i )
            {
                PValue = m_Coeff[j][Pivot];
                for( k = 0; k < 4; k++ )
                {
                    m_Coeff[j][k] -= PValue*m_Coeff[i][k];
                    Mx.m_Coeff[j][k] -= PValue*Mx.m_Coeff[i][k];
                }
            }
        }
    }

/* Reorder rows */
    for( i = 0; i < 4; i++ )
    {
        if( m_Coeff[i][i] != 1.0 )
        {
            for( j = i + 1; j < 4; j++ )
                if( m_Coeff[j][i] == 1.0 ) break;
            if( j >= 4 )
            {
                ZeroMatrix();
                return FALSE;
            }

            //--- swap rows i and j of original
            for( k = 0; k < 4; k++ )
            {
                m_Coeff[i][k] += m_Coeff[j][k];
                m_Coeff[j][k] = m_Coeff[i][k] - m_Coeff[j][k];
                m_Coeff[i][k] -= m_Coeff[j][k];
            }
            
            //--- swap rows i and j of result
            for( k = 0; k < 4; k++ )
            {
                Mx.m_Coeff[i][k] += Mx.m_Coeff[j][k];
                Mx.m_Coeff[j][k] = Mx.m_Coeff[i][k] - Mx.m_Coeff[j][k];
                Mx.m_Coeff[i][k] -= Mx.m_Coeff[j][k];
            }
        }
    }
    *this = Mx;
    return TRUE;
} /* CDXMatrix4x4F::Invert */

inline void CDXMatrix4x4F::Transpose()
{
    float temp;

    temp = m_Coeff[0][1];
    m_Coeff[0][1] = m_Coeff[1][0];
    m_Coeff[1][0] = temp;

    temp = m_Coeff[0][2];
    m_Coeff[0][2] = m_Coeff[2][0];
    m_Coeff[2][0] = temp;

    temp = m_Coeff[0][3];
    m_Coeff[0][3] = m_Coeff[3][0];
    m_Coeff[3][0] = temp;

    temp = m_Coeff[1][2];
    m_Coeff[1][2] = m_Coeff[2][1];
    m_Coeff[2][1] = temp;

    temp = m_Coeff[1][3];
    m_Coeff[1][3] = m_Coeff[3][1];
    m_Coeff[3][1] = temp;

    temp = m_Coeff[2][3];
    m_Coeff[2][3] = m_Coeff[3][2];
    m_Coeff[3][2] = temp;

} /* CDXMatrix4x4F::Transpose */

inline void CDXMatrix4x4F::GetTranspose( CDXMatrix4x4F *m )
{
    float temp;

    (*this) = *m;

    temp = m_Coeff[0][1];
    m_Coeff[0][1] = m_Coeff[1][0];
    m_Coeff[1][0] = temp;

    temp = m_Coeff[0][2];
    m_Coeff[0][2] = m_Coeff[2][0];
    m_Coeff[2][0] = temp;

    temp = m_Coeff[0][3];
    m_Coeff[0][3] = m_Coeff[3][0];
    m_Coeff[3][0] = temp;

    temp = m_Coeff[1][2];
    m_Coeff[1][2] = m_Coeff[2][1];
    m_Coeff[2][1] = temp;

    temp = m_Coeff[1][3];
    m_Coeff[1][3] = m_Coeff[3][1];
    m_Coeff[3][1] = temp;

    temp = m_Coeff[2][3];
    m_Coeff[2][3] = m_Coeff[3][2];
    m_Coeff[3][2] = temp;

} /* CDXMatrix4x4F::Transpose */


/*
Matrix Inversion
by Richard Carling
from "Graphics Gems", Academic Press, 1990
*/

#define SMALL_NUMBER    1.e-8
/* 
 *   inverse( original_matrix, inverse_matrix )
 * 
 *    calculate the inverse of a 4x4 matrix
 *
 *     -1     
 *     A  = ___1__ adjoint A
 *         det A
 */

inline BOOL CDXMatrix4x4F::GetInverse( CDXMatrix4x4F *pIn )
{
    int i, j;
    float det;

    /* calculate the adjoint matrix */

    GetAdjoint( pIn );

    /*  calculate the 4x4 determinant
     *  if the determinant is zero, 
     *  then the inverse matrix is not unique.
     */

    det = det4x4( pIn );

    if( fabs( det ) < SMALL_NUMBER )
    {
        //  Non-singular matrix, no inverse!
        return FALSE;;
    }

    /* scale the adjoint matrix to get the inverse */

    for( i = 0; i < 4; i++ )
        for( j = 0; j < 4; j++ )
            m_Coeff[i][j] = m_Coeff[i][j] / det;

    return TRUE;
}


/* 
 *   adjoint( original_matrix, inverse_matrix )
 * 
 *     calculate the adjoint of a 4x4 matrix
 *
 *      Let  a   denote the minor determinant of matrix A obtained by
 *           ij
 *
 *      deleting the ith row and jth column from A.
 *
 *                    i+j
 *     Let  b   = (-1)    a
 *          ij            ji
 *
 *    The matrix B = (b  ) is the adjoint of A
 *                     ij
 */
inline void CDXMatrix4x4F::GetAdjoint( CDXMatrix4x4F *pIn )
{
    float a1, a2, a3, a4, b1, b2, b3, b4;
    float c1, c2, c3, c4, d1, d2, d3, d4;

    /* assign to individual variable names to aid  */
    /* selecting correct values  */

    a1 = pIn->m_Coeff[0][0]; b1 = pIn->m_Coeff[0][1]; 
    c1 = pIn->m_Coeff[0][2]; d1 = pIn->m_Coeff[0][3];

    a2 = pIn->m_Coeff[1][0]; b2 = pIn->m_Coeff[1][1]; 
    c2 = pIn->m_Coeff[1][2]; d2 = pIn->m_Coeff[1][3];

    a3 = pIn->m_Coeff[2][0]; b3 = pIn->m_Coeff[2][1];
    c3 = pIn->m_Coeff[2][2]; d3 = pIn->m_Coeff[2][3];

    a4 = pIn->m_Coeff[3][0]; b4 = pIn->m_Coeff[3][1]; 
    c4 = pIn->m_Coeff[3][2]; d4 = pIn->m_Coeff[3][3];


    /* row column labeling reversed since we transpose rows & columns */

    m_Coeff[0][0]  =   det3x3( b2, b3, b4, c2, c3, c4, d2, d3, d4);
    m_Coeff[1][0]  = - det3x3( a2, a3, a4, c2, c3, c4, d2, d3, d4);
    m_Coeff[2][0]  =   det3x3( a2, a3, a4, b2, b3, b4, d2, d3, d4);
    m_Coeff[3][0]  = - det3x3( a2, a3, a4, b2, b3, b4, c2, c3, c4);
        
    m_Coeff[0][1]  = - det3x3( b1, b3, b4, c1, c3, c4, d1, d3, d4);
    m_Coeff[1][1]  =   det3x3( a1, a3, a4, c1, c3, c4, d1, d3, d4);
    m_Coeff[2][1]  = - det3x3( a1, a3, a4, b1, b3, b4, d1, d3, d4);
    m_Coeff[3][1]  =   det3x3( a1, a3, a4, b1, b3, b4, c1, c3, c4);
        
    m_Coeff[0][2]  =   det3x3( b1, b2, b4, c1, c2, c4, d1, d2, d4);
    m_Coeff[1][2]  = - det3x3( a1, a2, a4, c1, c2, c4, d1, d2, d4);
    m_Coeff[2][2]  =   det3x3( a1, a2, a4, b1, b2, b4, d1, d2, d4);
    m_Coeff[3][2]  = - det3x3( a1, a2, a4, b1, b2, b4, c1, c2, c4);
        
    m_Coeff[0][3]  = - det3x3( b1, b2, b3, c1, c2, c3, d1, d2, d3);
    m_Coeff[1][3]  =   det3x3( a1, a2, a3, c1, c2, c3, d1, d2, d3);
    m_Coeff[2][3]  = - det3x3( a1, a2, a3, b1, b2, b3, d1, d2, d3);
    m_Coeff[3][3]  =   det3x3( a1, a2, a3, b1, b2, b3, c1, c2, c3);
}
/*
 * float = det4x4( matrix )
 * 
 * calculate the determinant of a 4x4 matrix.
 */
inline float det4x4( CDXMatrix4x4F *pIn )
{
    float ans;
    float a1, a2, a3, a4, b1, b2, b3, b4, c1, c2, c3, c4, d1, d2, d3, d4;

    /* assign to individual variable names to aid selecting */
    /*  correct elements */

    a1 = pIn->m_Coeff[0][0]; b1 = pIn->m_Coeff[0][1]; 
    c1 = pIn->m_Coeff[0][2]; d1 = pIn->m_Coeff[0][3];

    a2 = pIn->m_Coeff[1][0]; b2 = pIn->m_Coeff[1][1]; 
    c2 = pIn->m_Coeff[1][2]; d2 = pIn->m_Coeff[1][3];

    a3 = pIn->m_Coeff[2][0]; b3 = pIn->m_Coeff[2][1]; 
    c3 = pIn->m_Coeff[2][2]; d3 = pIn->m_Coeff[2][3];

    a4 = pIn->m_Coeff[3][0]; b4 = pIn->m_Coeff[3][1]; 
    c4 = pIn->m_Coeff[3][2]; d4 = pIn->m_Coeff[3][3];

    ans = a1 * det3x3( b2, b3, b4, c2, c3, c4, d2, d3, d4 )
        - b1 * det3x3( a2, a3, a4, c2, c3, c4, d2, d3, d4 )
        + c1 * det3x3( a2, a3, a4, b2, b3, b4, d2, d3, d4 )
        - d1 * det3x3( a2, a3, a4, b2, b3, b4, c2, c3, c4 );
    return ans;
}

/*
 * float = det3x3(  a1, a2, a3, b1, b2, b3, c1, c2, c3 )
 * 
 * calculate the determinant of a 3x3 matrix
 * in the form
 *
 *     | a1,  b1,  c1 |
 *     | a2,  b2,  c2 |
 *     | a3,  b3,  c3 |
 */

inline float det3x3( float a1, float a2, float a3, 
                     float b1, float b2, float b3, 
                     float c1, float c2, float c3 )
{
    float ans;

    ans = a1 * det2x2( b2, b3, c2, c3 )
        - b1 * det2x2( a2, a3, c2, c3 )
        + c1 * det2x2( a2, a3, b2, b3 );
    return ans;
}

/*
 * float = det2x2( float a, float b, float c, float d )
 * 
 * calculate the determinant of a 2x2 matrix.
 */
inline float det2x2( float a, float b, float c, float d )
{
    float ans = a * d - b * c;
    return ans;
}

inline HRESULT CDXMatrix4x4F::InitFromSafeArray( SAFEARRAY * /*pSA*/ )
{
    HRESULT hr = S_OK;
#if 0
    long *pData;

    if( !pSA || ( pSA->cDims != 1 ) ||
         ( pSA->cbElements != sizeof(float) ) ||
         ( pSA->rgsabound->lLbound   != 1 ) ||
         ( pSA->rgsabound->cElements != 8 ) 
      )
    {
        hr = E_INVALIDARG;
    }
    else
    {
        hr = SafeArrayAccessData(pSA, (void **)&pData);

        if( SUCCEEDED( hr ) )
        {
            for( int i = 0; i < 4; ++i )
            {
                m_Bounds[i].Min = pData[i];
                m_Bounds[i].Max = pData[i+4];
                m_Bounds[i].SampleRate = SampleRate;
            }

            hr = SafeArrayUnaccessData( pSA );
        }
    }
#endif
    return hr;
} /* CDXMatrix4x4F::InitFromSafeArray */

inline HRESULT CDXMatrix4x4F::GetSafeArray( SAFEARRAY ** /*ppSA*/ ) const
{
    HRESULT hr = S_OK;
#if 0
    SAFEARRAY *pSA;

    if( !ppSA )
    {
        hr = E_POINTER;
    }
    else
    {
        SAFEARRAYBOUND rgsabound;
        rgsabound.lLbound   = 1;
        rgsabound.cElements = 16;

        if( !(pSA = SafeArrayCreate( VT_I4, 1, &rgsabound ) ) )
        {
            hr = E_OUTOFMEMORY;
        }
        else
        {
            long *pData;
            hr = SafeArrayAccessData( pSA, (void **)&pData );

            if( SUCCEEDED( hr ) )
            {
                for( int i = 0; i < 4; ++i )
                {
                    pData[i]   = m_Bounds[i].Min;
                    pData[i+4] = m_Bounds[i].Max;
                }

                hr = SafeArrayUnaccessData( pSA );
            }
        }

        if( SUCCEEDED( hr ) )
        {
            *ppSA = pSA;
        }
    }
#endif
    return hr;
} /* CDXMatrix4x4F::GetSafeArray */

inline void CDXMatrix4x4F::TransformBounds( DXBNDS& /*Bnds*/, DXBNDS& /*ResultBnds*/ )
{

} /* CDXMatrix4x4F::TransformBounds */

#endif  // DXVector_h
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\setup\setbldno\setbldno.c ===
// modified to spew out Month/Day as in 0509

#include <windows.h>
#include <stdio.h>

int _CRTAPI1 main(int argc, char* argv[])
{
  char achValue[128];
  char *szName = "BUILDNO";

  SYSTEMTIME st;
  FILETIME ft ;
  LARGE_INTEGER lt ;

  GetLocalTime(&st);

  SystemTimeToFileTime (&st, &ft) ;

  lt.LowPart = ft.dwLowDateTime ;
  lt.HighPart = ft.dwHighDateTime ;


  // Add 24hrs in 100ns units = 864000000000 100ns

  // if you want to add a day use lt.QuadPart = lt.QuadPart + (LONGLONG) 864000000000 ;

  ft.dwLowDateTime = lt.LowPart ;
  ft.dwHighDateTime = lt.HighPart ;

  FileTimeToSystemTime (&ft, &st) ;

  sprintf( achValue
         , "%02i%02i\n"
         , st.wMonth
         , st.wDay          );




  printf("Set %s=%s\n", szName, achValue);

  return 1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\apeldbg\allochk.cpp ===
/*++

Copyright (c) 1995 Microsoft Corporation

Abstract:

    allochk.cpp - Memory allocator hook to be statically linked into
    our dlls.

--*/


#include "headers.h"

#ifdef tagHookMemory
#undef tagHookMemory
#endif

#ifdef tagHookUnexpSysAlloc
#undef tagHookUnexpSysAlloc
#endif

#ifdef tagHookBreak
#undef tagHookBreak
#endif

#define tagHookMemory          TagHookMemory()
#define tagHookUnexpSysAlloc   TagHookUnexpSysAlloc()
#define tagHookBreak           TagHookBreak()

#ifdef _DEBUG
//+-------------------------------------------------------------------------
//
//  Function:   ApeldbgAllocHook
//
//  Synopsis:   Hooks the allocator for alloc, realloc and free calls.
//
//--------------------------------------------------------------------------

char * szAllocType[] = { "ALLOC", "REALLOC", "FREE" };

// TODO: Might want to make this MT-safe at some point
static unsigned char systemAllocExpected = 0;
// --ddalal trying to export this guy!
void __cdecl SystemAllocationExpected(unsigned char c) { systemAllocExpected = c; }
unsigned char IsSystemAllocationExpected() { return systemAllocExpected; }

int __cdecl
ApeldbgAllocHook(
        int nAllocType,
        void * pvData,
        size_t nSize,
        int nBlockUse,
        long lRequest,
        const unsigned char * szFile,
        int nLine)
{
    BOOL    fRet = TRUE;

    if (nBlockUse != _NORMAL_BLOCK)
        goto Cleanup;

    if (nAllocType == _HOOK_FREE)
    {
// Don't report free's anymore... not particularly useful.
//         TraceTag((
//             tagHookMemory,
//             "%s(%d): %s",
//             szFile,
//             nLine,
//             szAllocType[nAllocType - 1]));
    }
    else
    {
//  Only report 'unexpected' system heap usage.
//         TraceTag((
//             tagHookMemory,
//             "{%d} %s(%d): type=%s, size=%d",
//             lRequest,
//             szFile,
//             nLine,
//             szAllocType[nAllocType - 1],
//             nSize));

        // Only report this if system memory allocations are not
        // expected. 
        if (!IsSystemAllocationExpected()) {
            TraceTag((tagHookMemory,
                      "{%d} %s(%d): type=%s, size=%d",
                      lRequest,
                      szFile,
                      nLine,
                      szAllocType[nAllocType - 1],
                      nSize));
            
        }
        
        if (IsSimFailDlgVisible())
        {
            fRet = !FFail();
        }

        if ((fRet == FALSE) && IsTagEnabled(tagHookBreak))
        {
            DebugBreak();
        }
    }

  Cleanup:
    return fRet;
}

size_t
CRTMemoryUsed()
{
    _CrtMemState mem;
    _CrtMemCheckpoint(&mem);

    return (mem.lSizes[_NORMAL_BLOCK]);
}

void
DbgDumpMemoryLeaks()
{
    if (IsTagEnabled(tagLeaks))
    {
        TCHAR   achAppLoc[MAX_PATH];
        DWORD   dwRet;

        dwRet = GetModuleFileName(g_hinstMain, achAppLoc, ARRAY_SIZE(achAppLoc));
        Assert (dwRet != 0);

        TraceTag((tagLeaks,
                  "[%s] ---- Memory Leak Begin ----",
                  achAppLoc));
        
        _CrtDumpMemoryLeaks();

        TraceTag((tagLeaks,
                  "[%s] ---- Memory Leak End ----",
                  achAppLoc));
        
    }
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\apeldbg\apeldbg.h ===
/*******************************************************************************
Copyright (c) 1995-96 Microsoft Corporation

Abstract:
    Debugging stuff for use in Appelles.  See core/debug/apeldbg.txt for more
    information.

*******************************************************************************/

#ifndef _APELDBG_H_
#define _APELDBG_H_

#include "crtdbg.h"
#include "debug.h"
#include "pure.h"       // needed for Purify
#include <stdio.h>

#ifdef __cplusplus
extern "C"
{
#endif

//--------------------------------------------------------------------------
// Assert & Verify
//--------------------------------------------------------------------------

#if _DEBUG || _MEMORY_TRACKING
    #if defined(_M_IX86)
        #define F3DebugBreak() _asm { int 3 }
    #else
        #define F3DebugBreak() DebugBreak()
    #endif

    BOOL AssertImpl(char const * szFile, int iLine, char const * szMessage);
    BOOL AssertPopupDisabler(BOOL status);

    BOOL    ReturnFALSE();
#if _DEBUG
    #define DISABLE_ASSERT_POPUPS(x) AssertPopupDisabler(x)
#else
    #define DISABLE_ASSERT_POPUPS(x)
#endif
    #define Verify(x)   Assert(x)
    #define Assert(x)   do { if ( !(x?TRUE:FALSE) && AssertImpl(__FILE__, __LINE__, #x))\
                                   F3DebugBreak(); } while (ReturnFALSE())

    #define AssertStr(cond, str)   do { if (!(cond?TRUE:FALSE) && AssertImpl(__FILE__, __LINE__, str))\
                                   F3DebugBreak(); } while (ReturnFALSE())

    //
    // Startup assertion:
    // The assertion is called by initializing a global variable with
    // a function that performs the assertion and returns 1. The name
    // of the global variable and function name are suffixed with the
    // line number to make them unique. Unfortunatly, one cannot just
    // write StartupAssert_##__LINE__, because __LINE__ is not an
    // argument to the macro and so the expansion is, e.g. StartupAssert__##53.
    // So we indirect through another macro which concatenates its
    // two arguments.
    //

    #define concat_name(x, y) x##y
    #define concat_line_impl(x, y) concat_name(x, y)
    #define concat_LINE(x) concat_line_impl(x, __LINE__)

    #define StartupAssert(x) \
        static int \
        concat_LINE(StartupAssert_) () \
        { \
            Assert(x); \
            return 1; \
        } \
        \
        static int concat_LINE(g_StartupAssert_) = concat_LINE(StartupAssert_)() \

#else
    #define DISABLE_ASSERT_POPUPS(x)
    #define Assert(x)
    #define Verify(x)   x
    #define AssertStr(cond, str)
    #define StartupAssert(x)
#endif

//--------------------------------------------------------------------------
// Trace Tags
//--------------------------------------------------------------------------

typedef int TAG;

#if !_DEBUG 
    #define TraceTag(x)
    #define TraceTagEx(x)
    #define TraceCallers(tag, iStart, cTotal)
    #define DeclareTag(tag, szOwner, szDescription)
    #define DeclareTagOther(tag, szOwner, szDescription)
#else
    #define TraceTag(x)                         \
        do                                      \
        {                                       \
            if (TaggedTrace x)                  \
                F3DebugBreak();                 \
        } while  (ReturnFALSE())                \

    #define TraceTagEx(x)                       \
        do                                      \
        {                                       \
            if (TaggedTraceEx x)                \
                F3DebugBreak();                 \
        } while  (ReturnFALSE())                \

    #define TraceCallers(tag, iStart, cTotal)   \
        TaggedTraceCallers(tag, iStart, cTotal)

    #define DeclareTag(tag, szOwner, szDescrip) \
        TAG tag(TagRegisterTrace(szOwner, szDescrip));

    #define DeclareTagOther(tag, szOwner, szDescrip) \
        TAG tag(TagRegisterOther(szOwner, szDescrip));

    // Tag trace functions

    BOOL __cdecl TaggedTrace(TAG tag, CHAR * szFmt, ...);
    BOOL __cdecl TaggedTraceEx(TAG tag, USHORT usFlags, CHAR * szFmt, ...);
    BOOL __cdecl TaggedTraceListEx(TAG tag, USHORT usFlags, CHAR * szFmt, va_list valMarker);
    void TaggedTraceCallers(TAG tag, int iStart, int cTotal);

    // TaggedTraceEx usFlags parameter defines

    #define TAG_NONAME      1
    #define TAG_NONEWLINE   2
    #define TAG_USECONSOLE  4

    // Register a new tag.

    TAG TagRegisterTrace(
            CHAR * szOwner, CHAR * szDescrip, BOOL fEnabled = FALSE);

    TAG TagRegisterOther(
            CHAR * szOwner, CHAR * szDescrip, BOOL fEnabled = FALSE);

    // Standard tags
    #define tagError            TagError()
    #define tagWarning          TagWarning()
    #define tagLeakFilter       TagLeakFilter()
    #define tagHookMemory       TagHookMemory()
    #define tagHookBreak        TagHookBreak()
    #define tagLeaks            TagLeaks()
    #define tagCheckAlways      TagCheckAlways()
    #define tagCheckCRT         TagCheckCRT()
    #define tagDelayFree        TagDelayFree()

    TAG TagError( void );
    TAG TagWarning( void );
    TAG TagLeakFilter(void);
    TAG TagHookMemory(void);
    TAG TagHookBreak(void);
    TAG TagLeaks(void);
    TAG TagCheckAlways(void);
    TAG TagCheckCRT(void);
    TAG TagDelayFree(void);

    // Get/Set tag enabled status.
    BOOL IsTagEnabled(TAG tag);
    BOOL EnableTag(TAG tag, BOOL fEnable);

    // Console manipulation
    void SendLeaksToConsole(void);
    void SendDebugOutputToConsole(void);
#endif

//--------------------------------------------------------------------------
// Memory Allocation
//--------------------------------------------------------------------------

#if !_DEBUGMEM

    #define BEGIN_LEAK
    #define END_LEAK

    #define SET_ALLOC_HOOK
    #define DUMPMEMORYLEAKS

    #define DbgPreAlloc(cb)             cb
    #define DbgPostAlloc(pv)            pv
    #define DbgPreFree(pv)              pv
    #define DbgPostFree()
    #define DbgPreRealloc(pv, cb, ppv)  cb
    #define DbgPostRealloc(pv)          pv
    #define DbgPreGetSize(pv)           pv
    #define DbgPostGetSize(cb)          cb
    #define DbgPreDidAlloc(pv)          pv
    #define DbgPostDidAlloc(pv, fAct)   fAct
    #define DbgRegisterMallocSpy()
    #define DbgRevokeMallocSpy()
    #define DbgMemoryTrackDisable(fb)

    #define NEW         new

#else

    //
    //  In the debug build, we use the debug allocator in the CRT to
    //  track memory leaks.  Allocations need to have filename and line
    //  numbers associated with them.  The new operator is somewhat tricky;
    //  we map the macro, new, to the macro DEBUG_NEW.  DEBUG_NEW in turn
    //  is mapped to a call to a debug version of the new operator which
    //  passes in filename and line number information.  The _NORMAL_BLOCK
    //  identifier differentiates the allocation block type for the
    //  debug allocator.  Also, we check for DEBUG_NEW being already
    //  defined to handle cases where we're used in MFC code (like avtool).
    //

    #ifndef DEBUG_NEW
    #define DEBUG_NEW                   new(_NORMAL_BLOCK, __FILE__, __LINE__)
    #endif
    #define NEW                         DEBUG_NEW
    #define malloc(size)                _malloc_dbg(size, _NORMAL_BLOCK, __FILE__, __LINE__)
    #define free(p)                     _free_dbg(p, _NORMAL_BLOCK)
    #define calloc(c, s)                _calloc_dbg(c, s, _NORMAL_BLOCK, __FILE__, __LINE__)
    #define realloc(p, s)               _realloc_dbg(p, s, _NORMAL_BLOCK, __FILE__, __LINE__)
    #define _expand(p, s)               _expand_dbg(p, s, _NORMAL_BLOCK, __FILE__, __LINE__)
    #define _msize(p)                   _msize_dbg(p, _NORMAL_BLOCK)

    // --ddalal, trying to export this
    void __cdecl SystemAllocationExpected(unsigned char c);

    #define BEGIN_LEAK                                        \
       if (IsTagEnabled(tagLeakFilter))                       \
       {                                                      \
         _CrtSetDbgFlag(_CrtSetDbgFlag(_CRTDBG_REPORT_FLAG) & \
                        ~_CRTDBG_ALLOC_MEM_DF);               \
       }                                                      \
       SystemAllocationExpected(1);

    #define END_LEAK                                          \
       if (IsTagEnabled(tagLeakFilter))                       \
       {                                                      \
         _CrtSetDbgFlag(_CrtSetDbgFlag(_CRTDBG_REPORT_FLAG) & \
                        _CRTDBG_ALLOC_MEM_DF);                \
       }                                                      \
       SystemAllocationExpected(0);

    #define SET_ALLOC_HOOK _CrtSetAllocHook((_CRT_ALLOC_HOOK) ApeldbgAllocHook);

    void DbgDumpMemoryLeaks();
    #define DUMPMEMORYLEAKS  DbgDumpMemoryLeaks()

    size_t  DbgPreAlloc(size_t cb);
    void *  DbgPostAlloc(void *pv);
    void *  DbgPreFree(void *pv);
    void    DbgPostFree(void);
    size_t  DbgPreRealloc(void *pv, size_t cb, void **ppv);
    void *  DbgPostRealloc(void *pv);
    void *  DbgPreGetSize(void *pv);
    size_t  DbgPostGetSize(size_t cb);
    void *  DbgPreDidAlloc(void *pv);
    BOOL    DbgPostDidAlloc(void *pv, BOOL fActual);

    void    DbgRegisterMallocSpy(void);
    void    DbgRevokeMallocSpy(void);
    void    DbgMemoryTrackDisable(BOOL fDisable);

    void    TraceMemoryLeaks(void);
    BOOL    ValidateInternalHeap(void);
    void    LoadModuleDebugInfo(void);
    int     GetTotalAllocated(void);

    int __cdecl ApeldbgAllocHook(int, void *, size_t, int, long, const unsigned char *, int);

    size_t CRTMemoryUsed();
#endif


//+---------------------------------------------------------------------
//  Interface tracing.
//----------------------------------------------------------------------

#if _DEBUG
    void *WatchInterface(REFIID iid, void *pv, LPSTR pstr);
    #ifdef __cplusplus
        }
            template<class T> inline T WATCHINTERFACE(REFIID iid, T pt, LPSTR pstr)
            {
                return (T)WatchInterface(iid, pt, pstr);
            }
        extern "C" {
    #else
        #define WATCHINTERFACE(iid, p, pstr) WatchInterface(iid, p, pstr)
    #endif
#else
    #define WATCHINTERFACE(iid, p, pstr)  (p)
#endif

//--------------------------------------------------------------------------
// Miscelleanous
//--------------------------------------------------------------------------

#if _DEBUG
    void DoTracePointsDialog(BOOL fWait);
    void RestoreDefaultDebugState(void);
    #define DebugCode(block) block
#ifdef _DEBUGMEM
    #define RESTOREDEFAULTDEBUGSTATE                            \
        {                                                       \
            int iFlags = _CrtSetDbgFlag(_CRTDBG_REPORT_FLAG);   \
            RestoreDefaultDebugState();                         \
            SET_ALLOC_HOOK;                                     \
            if (IsTagEnabled(tagCheckAlways))                   \
                iFlags |= _CRTDBG_CHECK_ALWAYS_DF;              \
            if (IsTagEnabled(tagCheckCRT))                      \
                iFlags |= _CRTDBG_CHECK_CRT_DF;                 \
            if (IsTagEnabled(tagDelayFree))                     \
                iFlags |= _CRTDBG_DELAY_FREE_MEM_DF;            \
            _CrtSetDbgFlag(iFlags);                             \
        }
#else
    #define RESTOREDEFAULTDEBUGSTATE  RestoreDefaultDebugState()
#endif
    
#else
    #define RESTOREDEFAULTDEBUGSTATE
    #define DebugCode(block) // Nothing
#endif


//--------------------------------------------------------------------------
// Failure testing
//--------------------------------------------------------------------------

#if _DEBUG

    void    SetSimFailCounts(int firstFailure, int cInterval);
    void    ShowSimFailDlg(void);
    BOOL    IsSimFailDlgVisible(void);

    BOOL    FFail();
    int     GetFailCount();
    long    TraceFailL( long errTest, long errExpr, BOOL fIgnore, LPSTR pstrExpr, LPSTR pstrFile, int line);
    long    TraceWin32L(long errTest, long errExpr, BOOL fIgnore, LPSTR pstrExpr, LPSTR pstrFile, int line);
    HRESULT TraceHR(HRESULT hrTest, BOOL fIgnore, LPSTR pstrExpr, LPSTR pstrFile, int line);

    #define TFAIL(e, x)         (TraceFail( (FALSE ? (e) : (x)), (e), FALSE, #x, __FILE__, __LINE__))
    #define TW32(e, x)          (TraceWin32((FALSE ? (e) : (x)), (e), FALSE, #x, __FILE__, __LINE__))
    #define THR(x)              (TraceHR((FALSE ? E_FAIL : (x)), FALSE, #x, __FILE__, __LINE__))

    #define TFAIL_NOTRACE(e, x) (FALSE ? (e) : (x))
    #define TW32_NOTRACE(e, x)  (FALSE ? (e) : (x))
    #define THR_NOTRACE(x)      (FALSE ? E_FAIL : (x))

    #define IGNORE_FAIL(e, x)   ((void) TraceFail( (FALSE ? (e) : (x)), (e), TRUE, #x, __FILE__, __LINE__))
    #define IGNORE_W32(e,x)     ((void) TraceWin32((FALSE ? (e) : (x)), (e), TRUE, #x, __FILE__, __LINE__))
    #define IGNORE_HR(x)        ((void) TraceHR((FALSE ? E_FAIL : (x)), TRUE, #x, __FILE__, __LINE__))

#else // #if _DEBUG

    #define SetSimFailCounts(firstFailure, cInterval)
    #define ShowSimFailDlg()
    #define IsSimFailDlgVisible()

    #define TFAIL(e, x)             (x)
    #define TW32(e, x)              (x)
    #define THR(x)                  (x)

    #define TFAIL_NOTRACE(e, x)     (x)
    #define TW32_NOTRACE(e, x)      (x)
    #define THR_NOTRACE(x)          (x)

    #define IGNORE_FAIL(e, x)       (x)
    #define IGNORE_W32(e,x)         (x)
    #define IGNORE_HR(x)            (x)

#endif // #if _DEBUG

//+-------------------------------------------------------------------------
//  Return tracing
//--------------------------------------------------------------------------

#if _DEBUG

    STDAPI CheckAndReturnResult(
                HRESULT hr,
                BOOL    fTrace,
                LPSTR   lpstrFile,
                UINT    line,
                int     cSuccess,
                ...);

    #define SRETURN(hr) \
        return CheckAndReturnResult((hr), TRUE, __FILE__, __LINE__, -1)
    #define RRETURN(hr) \
        return CheckAndReturnResult((hr), TRUE, __FILE__, __LINE__, 0)
    #define RRETURN1(hr, s1) \
        return CheckAndReturnResult((hr), TRUE, __FILE__, __LINE__, 1, (s1))
    #define RRETURN2(hr, s1, s2) \
        return CheckAndReturnResult((hr), TRUE, __FILE__, __LINE__, 2, (s1), (s2))
    #define RRETURN3(hr, s1, s2, s3) \
        return CheckAndReturnResult((hr), TRUE, __FILE__, __LINE__, 3, (s1), (s2), (s3))

    #define SRETURN_NOTRACE(hr) \
        return CheckAndReturnResult((hr), FALSE, __FILE__, __LINE__, -1)
    #define RRETURN_NOTRACE(hr) \
        return CheckAndReturnResult((hr), FALSE, __FILE__, __LINE__, 0)
    #define RRETURN1_NOTRACE(hr, s1) \
        return CheckAndReturnResult((hr), FALSE, __FILE__, __LINE__, 1, (s1))
    #define RRETURN2_NOTRACE(hr, s1, s2) \
        return CheckAndReturnResult((hr), FALSE, __FILE__, __LINE__, 2, (s1), (s2))
    #define RRETURN3_NOTRACE(hr, s1, s2, s3) \
        return CheckAndReturnResult((hr), FALSE, __FILE__, __LINE__, 3, (s1), (s2), (s3))

#else

    #define SRETURN(hr)                 return (hr)
    #define RRETURN(hr)                 return (hr)
    #define RRETURN1(hr, s1)            return (hr)
    #define RRETURN2(hr, s1, s2)        return (hr)
    #define RRETURN3(hr, s1, s2, s3)    return (hr)

    #define SRETURN_NOTRACE(hr)                 return (hr)
    #define RRETURN_NOTRACE(hr)                 return (hr)
    #define RRETURN1_NOTRACE(hr, s1)            return (hr)
    #define RRETURN2_NOTRACE(hr, s1, s2)        return (hr)
    #define RRETURN3_NOTRACE(hr, s1, s2, s3)    return (hr)

#endif

//+-------------------------------------------------------------------------
//  Debug view
//--------------------------------------------------------------------------

void DebugView(HWND hwndOwner, IUnknown *pUnk);

#ifdef __cplusplus
}
#endif

template <class t> inline t
TraceFail(t errExpr, int errTest, BOOL fIgnore, LPSTR pstrExpr, LPSTR pstrFile, int line)
{
    return (t) TraceFailL((long) errExpr, errTest, fIgnore, pstrExpr, pstrFile, line);
}

template <class t> inline t
TraceWin32(t errExpr, int errTest, BOOL fIgnore, LPSTR pstrExpr, LPSTR pstrFile, int line)
{
    return (t) TraceWin32L((long) errExpr, errTest, fIgnore, pstrExpr, pstrFile, line);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\apeldbg\debug.h ===
// Debug init function

void    InitDebug(HINSTANCE hinstance, HWND hwnd);
void	DeinitDebug(void);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\apeldbg\assert.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1993 - 1993.
//
//  File:       assert.cxx
//
//  Contents:   Assertion stuff
//
//  History:    6-29-94   ErikGav   Created
//              10-13-94  RobBear   Brought to forms
//
//----------------------------------------------------------------------------

#include <headers.h>


#if DEVELOPER_DEBUG

//+------------------------------------------------------------
//
// Function:    PopUpError
//
// Synopsis:    Displays a dialog box using provided text,
//              and presents the user with the option to
//              continue or cancel.
//
// Arguments:
//      szMsg --        The string to display in main body of dialog
//      iLine --        Line number of file in error
//      szFile --       Filename of file in error
//
// Returns:
//      IDCANCEL --     User selected the CANCEL button
//      IDOK     --     User selected the OK button
//
//-------------------------------------------------------------

int
PopUpError(
    char const *szMsg,
    int iLine,
    char const *szFile)
{
    int id = IDOK;
    static char szAssert[MAX_PATH * 2];
    static char szModuleName[MAX_PATH];

    DWORD tid = GetCurrentThreadId();
    DWORD pid = GetCurrentProcessId();
    char * pszModuleName;

#ifndef _MAC
    if (GetModuleFileNameA(NULL, szModuleName, 128))
#else
    TCHAR   achAppLoc[MAX_PATH];

    if (GetModuleFileNameA(NULL, achAppLoc, ARRAY_SIZE(achAppLoc))
        && !GetFileTitle(achAppLoc,szModuleName,ARRAY_SIZE(szModuleName)) )
#endif
    {
        pszModuleName = strrchr(szModuleName, '\\');
        if (!pszModuleName)
        {
            pszModuleName = szModuleName;
        }
        else
        {
            pszModuleName++;
        }
    }
    else
    {
        pszModuleName = "Unknown";
    }

    sprintf(szAssert, "Process: %s Thread: %08x.%08x\nFile: %s [%d]\n%s",
            pszModuleName, pid, tid, szFile, iLine, szMsg);
// bugbug Mac MessageBox function fails with the following message:
//  Scratch DC already in use (wlmdc-1319)
#ifndef _MAC
    id = MessageBoxA(NULL,
                     szAssert,
                     "DirectAnimation Assert",
                      MB_SETFOREGROUND | MB_TASKMODAL |
                      MB_ICONEXCLAMATION | MB_OKCANCEL);

    //
    // If id == 0, then an error occurred.  There are two possibilities
    // that can cause the error:  Access Denied, which means that this
    // process does not have access to the default desktop, and everything
    // else (usually out of memory).
    //

    if (!id)
    {
        if (GetLastError() == ERROR_ACCESS_DENIED)
        {
            //
            // Retry this one with the SERVICE_NOTIFICATION flag on.  That
            // should get us to the right desktop.
            //
            id = MessageBoxA(   NULL,
                                szAssert,
                                "DirectAnimation Assert",
                                MB_SETFOREGROUND | MB_SERVICE_NOTIFICATION |
                                MB_TASKMODAL | MB_ICONEXCLAMATION | MB_OKCANCEL );

        }
        else
        {

        }
    }
#endif
    return id;

}

//+------------------------------------------------------------------------
//
//  Function:   AssertPopupDisabler(BOOL disable?)
//
//  Synopsis:   If disable? is TRUE then we will never popup asserts,
//    when false, we will if the trace tags allow us to.  The point of
//    this is to allow disabling of assert popups within the dynamic
//    scope of things like an OnDraw() method where popups are not
//    allowed and would freeze the system.  Use thread-local-storage
//    to have one of these per thread.
//
//-------------------------------------------------------------------------

// Use these values rather than 0 and 1 because TLS slots are
// allocated to 0 initially, and there's no reason to assume that
// we're going to set this before getting it.  Therefore, use two
// arbitrary, non-zero values.
static const int DISABLED_VALUE = 88;
static const int NOT_DISABLED_VALUE = 99;

static DWORD
GetTlsIndex()
{
    static DWORD index = NULL;
    static BOOL setYet = FALSE;
    
    if (!setYet) {
        index = TlsAlloc();
        setYet = TRUE;
    }

    return index;
}

static BOOL
ArePopupsDisabledOnThisThread()
{
    LPVOID lpv = TlsGetValue(GetTlsIndex());

    // Warning: 32bit legacy compare here requires func call
    if (PtrToInt(lpv) == DISABLED_VALUE) { 
        return TRUE;
    } else {
        return FALSE;
    }
}

BOOL
AssertPopupDisabler(BOOL disable)
{
    BOOL ret = ArePopupsDisabledOnThisThread();
    DWORD_PTR val = disable ? DISABLED_VALUE : NOT_DISABLED_VALUE;
    TlsSetValue(GetTlsIndex(), (LPVOID) val);
    return ret;
}

//+------------------------------------------------------------------------
//
//  Function:   AssertImpl
//
//  Synopsis:   Function called for all asserts.  Checks value, tracing
//              and/or popping up a message box if the condition is
//              FALSE.
//
//  Arguments:
//              szFile
//              iLine
//              szMessage
//
//-------------------------------------------------------------------------

BOOL
AssertImpl(
        char const *    szFile,
        int             iLine,
        char const *    szMessage)
{
    DWORD tid = GetCurrentThreadId();

#if _DEBUG
    TraceTag((
            tagError,
            "Assert failed:\n%s\nFile: %s [%u], thread id %08x",
            szMessage, szFile, iLine, tid));

    return IsTagEnabled(tagAssertPop) &&
            (ArePopupsDisabledOnThisThread() ||
            PopUpError(szMessage,iLine,szFile) == IDCANCEL);
#else // This should only be in developer debug
    char buf[1024];

    wsprintf (buf,
              "Assert failed:\n%s\nFile: %s [%u], thread id %08x\r\n",
              szMessage, szFile, iLine, tid);

    OutputDebugString (buf);

    return FALSE;
#endif
}

#endif // DEVELOPER_DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\apeldbg\debug.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1993 - 1993.
//
//  File:       debug.cxx
//
//  Contents:   Shell debugging functionality
//
//----------------------------------------------------------------------------


/*
 *  DEBUG.CXX
 *
 *  Developer's API to the Debug Module
 */

#include <headers.h>
#include "debug.h"
#include "dalibc.h"

#ifdef _DEBUG
//  Globals

HINSTANCE           g_hinstMain        = NULL;
HWND                g_hwndMain         = NULL;

ULONG               g_cInitCount       = 0;
BOOL                g_fInit            = FALSE;
BOOL                g_fOutputToConsole = FALSE;

CRITICAL_SECTION    g_csTrace;
CRITICAL_SECTION    g_csResDlg;

//  TAGS and stuff

/*
 *  Number of TAG's registered so far.
 *
 */
TAG     tagMac;


/*
 *  Mapping from TAG's to information about them.  Entries
 *  0...tagMac-1 are valid.
 */
TGRC    mptagtgrc[tagMax];


TAG     tagCom1                     = tagNull;
TAG     tagError                    = tagNull;
TAG     tagWarn                     = tagNull;
TAG     tagAssertPop                = tagNull;
TAG     tagTestFailures             = tagNull;
TAG     tagRRETURN                  = tagNull;
TAG     tagLeaks                    = tagNull;
TAG     tagMagic                    = tagNull;
TAG     tagIWatch                   = tagNull;
TAG     tagIWatch2                  = tagNull;
TAG     tagReadMapFile              = tagNull;
TAG     tagLeakFilter               = tagNull;
TAG     tagHookMemory               = tagNull;
TAG     tagHookBreak                = tagNull;
TAG     tagCheckAlways              = tagNull;
TAG     tagCheckCRT                 = tagNull;
TAG     tagDelayFree                = tagNull;

/*
 *  Handle for debug output file.  This file is opened during init,
 *  and output is sent to it when enabled.
 */
HANDLE      hfileDebugOutput    = NULL;


/*
 *  static variables to prevent infinite recursion when calling
 *  SpitPchToDisk
 */
static BOOL fInSpitPchToDisk    = FALSE;

static CHAR szNewline[]         = "\r\n";
static CHAR szBackslash[]       = "\\";

static CHAR szStateFileExt[]    = ".tag";
static CHAR szDbgOutFileExt[]   = ".log";
static CHAR szStateFileName[]   = "capone.dbg";
static CHAR szDbgOutFileName[]  = "capone.log";

/*
 *  Global temporary buffer for handling TraceTag output.  Since
 *  this code is non-reentrant and not recursive, a single buffer
 *  for all Demilayr callers will work ok.
 */
CHAR    rgchTraceTagBuffer[1024] = { 0 };

void    DeinitDebug(void);
const   LPTSTR GetHResultName(HRESULT r);
void    DebugOutput( CHAR * sz );
VOID    SpitPchToDisk(CHAR * pch, UINT cch, HANDLE hfile);
VOID    SpitSzToDisk( CHAR * sz, HANDLE hfile);
TAG     TagRegisterSomething(
        TGTY tgty, CHAR * szOwner, CHAR * szDescrip, BOOL fEnabled = FALSE);
BOOL    EnableTag(TAG tag, BOOL fEnable);

//  F u n c t i o n s

// for some reason GetModuleFileNameA(NULL, rgch, sizeof(rgch));
// seems to return a different length (one including the terminating null?)
// when run under NT and Purify.  So I made the dot detector non-fixed!
int findDot(char *string)
{
int value = -1; // default to return err
int index =  0; // start at the beggining

while(string[++index])
    if(string[index]=='.') {
        value = index;
        break;
    }

return(value);
}


/*
 *    InitDebug
 *
 *  Purpose:
 *      Called to initialize the Debug Module.  Sets up any debug
 *      structures.  This routine DOES NOT restore the state of the
 *      Debug Module, since TAGs can't be registered until after
 *      this routine exit.  The routine RestoreDefaultDebugState()
 *      should be called to restore the state of all TAGs after
 *      all TAGs have been registered.
 *
 *    Parameters:
 *        hinstance    Pointer to application instance
 *        phwnd        Pointer to main application window
 *
 *    Returns:
 *        error code
 */
void
InitDebug(HINSTANCE hinst, HWND hwnd)
{
    static struct
    {
        TAG *   ptag;
        TGTY    tgty;
        LPSTR   pszClass;
        LPSTR   pszDescr;
        BOOL    fEnabled;
    }
    g_ataginfo[] =
    {
        &tagCom1,           tgtyOther,  "!Debug",   "Enable Disk for debug output",             TRUE,
        &tagAssertPop,      tgtyOther,  "!Debug",   "Popups on asserts",                        TRUE,
        &tagReadMapFile,    tgtyOther,  "!Debug",   "Read MAP file for stack traces",           TRUE,
        &tagLeaks,          tgtyOther,  "!Memory",  "Memory Leaks",                             FALSE,
        &tagMagic,          tgtyOther,  "!Memory",  "Module/MAP file parsing",                  FALSE,
        &tagError,          tgtyTrace,  "!Trace",   "Errors",                                   TRUE,
        &tagWarn,           tgtyTrace,  "!Trace",   "Warnings",                                 FALSE,
        &tagTestFailures,   tgtyTrace,  "!Trace",   "THR, IGNORE_HR",                           TRUE,
        &tagRRETURN,        tgtyTrace,  "!Trace",   "RRETURN",                                  FALSE,
        &tagIWatch,         tgtyTrace,  "!Watch",   "Interface watch",                          FALSE,
        &tagIWatch2,        tgtyOther,  "!Watch",   "Interface watch (create wrap, no trace)",  FALSE,
        &tagLeakFilter,     tgtyOther,  "!Memory",  "Filter out known leaks",                   FALSE,
        &tagHookMemory,     tgtyOther,  "!Memory",  "Watch unexp sysmem allocs",                      FALSE,
        &tagHookBreak,      tgtyOther,  "!Memory",  "Break on simulated failure",               FALSE,
        &tagCheckAlways,    tgtyOther,  "!Memory",  "Check Mem on every alloc/free",            FALSE,
        &tagCheckCRT,       tgtyOther,  "!Memory",  "Include CRT types in leak detection",      FALSE,
        &tagDelayFree,      tgtyOther,  "!Memory",  "Keep freed blocks in heap list",           FALSE,
    };

    TGRC *  ptgrc;
    CHAR    rgch[MAX_PATH];
    int     i;

    g_cInitCount++;

    if (g_fInit)
        return;

    g_fInit = TRUE;

    g_hinstMain = hinst;
    g_hwndMain = hwnd;

    // don't want windows to put up message box on INT 24H errors.
    SetErrorMode(0x0001);

    InitializeCriticalSection(&g_csTrace);
    InitializeCriticalSection(&g_csResDlg);

    // Initialize simulated failures
    SetSimFailCounts(0, 1);

    // Initialize TAG array

    tagMac = tagMin;

    // enable tagNull at end of RestoreDefaultDebugState
    ptgrc = mptagtgrc + tagNull;
    ptgrc->tgty = tgtyNull;
    ptgrc->fEnabled = FALSE;
    ptgrc->ulBitFlags = TGRC_DEFAULT_FLAGS;
    ptgrc->szOwner = "dgreene";
    ptgrc->szDescrip = "NULL";

    // Open debug output file
    if (g_hinstMain)
    {
#ifndef _MAC
        UINT    cch = (UINT) GetModuleFileNameA(g_hinstMain, rgch, sizeof(rgch));
        int dotLoc = findDot(rgch);
        Assert(dotLoc!=-1);
        strcpy(&rgch[dotLoc], szDbgOutFileExt);
#else
        TCHAR   achAppLoc[MAX_PATH];
        DWORD   dwRet;
        short   iRet;

        dwRet = GetModuleFileName(g_hinstMain, achAppLoc, ARRAY_SIZE(achAppLoc));
        Assert (dwRet != 0);

        iRet = GetFileTitle(achAppLoc,rgch,sizeof(rgch));
        Assert(iRet == 0);

        strcat (rgch, szDbgOutFileExt);
#endif

    }
    else
        strcpy(rgch, szDbgOutFileName);

    hfileDebugOutput = CreateFileA(rgch,
                                   GENERIC_WRITE,
                                   FILE_SHARE_WRITE,
                                   NULL,
                                   CREATE_ALWAYS,
                                   FILE_ATTRIBUTE_NORMAL,
                                   (HANDLE) NULL);
    if (hfileDebugOutput != INVALID_HANDLE_VALUE)
    {
        char    rgch2[100];

        rgch2[(sizeof(rgch2)/sizeof(rgch2[0])) - 1] = 0;
        _snprintf(rgch2, (sizeof(rgch2)/sizeof(rgch2[0])) - 1, "logging hinst %p to %s\r\n", g_hinstMain, rgch);
        SpitSzToDisk(rgch2, hfileDebugOutput);
        Assert(hfileDebugOutput);
    }

    for (i = 0; i < ARRAY_SIZE(g_ataginfo); i++)
    {
        *g_ataginfo[i].ptag = TagRegisterSomething(
                g_ataginfo[i].tgty,
                g_ataginfo[i].pszClass,
                g_ataginfo[i].pszDescr,
                g_ataginfo[i].fEnabled);
    }

    fInSpitPchToDisk = FALSE;
}



/*
 *    DeinitDebug
 *
 *        Undoes InitDebug().
 */
void
DeinitDebug(void)
{
    TAG       tag;
    TGRC *    ptgrc;

    g_cInitCount--;

    if (g_cInitCount)
        return;

    // Close the debug output file
    if (hfileDebugOutput)
    {
        CHAR    rgch[100];

        rgch[(sizeof(rgch)/sizeof(rgch[0])) - 1] = 0;
        _snprintf(rgch, (sizeof(rgch)/sizeof(rgch[0])) - 1, "Done logging for hinst %d\r\n", (ULONG_PTR)g_hinstMain);
        SpitSzToDisk(rgch, hfileDebugOutput);
        CloseHandle(hfileDebugOutput);
        hfileDebugOutput = NULL;
    }

    // Free the tag strings if not already done
    for (tag = tagMin, ptgrc = mptagtgrc + tag;
         tag < tagMac; tag++, ptgrc++)
    {
        if (ptgrc->TestFlag(TGRC_FLAG_VALID))
        {
            LocalFree(ptgrc->szOwner);
            ptgrc->szOwner = NULL;
            LocalFree(ptgrc->szDescrip);
            ptgrc->szDescrip = NULL;
        }
    }

    //    Set flags to FALSE.  Need to separate from loop above so that
    //    final memory leak trace tag can work.

    for (tag=tagMin, ptgrc = mptagtgrc + tag;
         tag < tagMac; tag++, ptgrc++)
    {
        if (ptgrc->TestFlag(TGRC_FLAG_VALID))
        {
            ptgrc->fEnabled = FALSE;
            ptgrc->ClearFlag(TGRC_FLAG_VALID);
        }
    }

    DeleteCriticalSection(&g_csTrace);
    DeleteCriticalSection(&g_csResDlg);
}

//+---------------------------------------------------------------------------
//
//  Function:   SendDebugOutputToConsole
//
//  Synopsis:   If called, causes all debug output to go the the console as
//              well as the debugger.
//
//----------------------------------------------------------------------------

void
SendDebugOutputToConsole(void)
{
    g_fOutputToConsole = TRUE;
}


/*
 *  FReadDebugState
 *
 *  Purpose:
 *      Read the debug state information file whose name is given by the
 *      string szDebugFile.  Set up the tag records accordingly.
 *
 *  Parameters:
 *      szDebugFile     Name of debug file to read
 *
 *  Returns:
 *      TRUE if file was successfully read; FALSE otherwise.
 *
 */

BOOL
FReadDebugState( CHAR * szDebugFile )
{
    HANDLE      hfile = NULL;
    TGRC        tgrc;
    TGRC *      ptgrc;
    TAG         tag;
    INT         cchOwner;
    CHAR        rgchOwner[MAX_PATH];
    INT         cchDescrip;
    CHAR        rgchDescrip[MAX_PATH];
    BOOL        fReturn = FALSE;
    DWORD       cRead;

    hfile = CreateFileA(szDebugFile,
                        GENERIC_READ,
                        FILE_SHARE_READ,
                        NULL,
                        OPEN_EXISTING,
                        FILE_ATTRIBUTE_NORMAL,
                        (HANDLE) NULL);
    if (hfile != INVALID_HANDLE_VALUE)
    {
        for (;;)
        {
            if (!ReadFile(hfile, &tgrc, sizeof(TGRC), &cRead, NULL))
                break;

            if (cRead == 0)
                break;

            if (!ReadFile(hfile, &cchOwner, sizeof(UINT), &cRead, NULL))
                goto ErrorReturn;
            Assert(cchOwner <= sizeof(rgchOwner));
            if (!ReadFile(hfile, rgchOwner, cchOwner, &cRead, NULL))
                goto ErrorReturn;

            if (!ReadFile(hfile, &cchDescrip, sizeof(UINT), &cRead, NULL))
                goto ErrorReturn;
            Assert(cchDescrip <= sizeof(rgchDescrip));
            if (!ReadFile(hfile, rgchDescrip, cchDescrip, &cRead, NULL))
                goto ErrorReturn;

            ptgrc = mptagtgrc + tagMin;
            for (tag = tagMin; tag < tagMac; tag++)
            {
                if (ptgrc->TestFlag(TGRC_FLAG_VALID) &&
                    !strcmp(rgchOwner, ptgrc->szOwner) &&
                    !strcmp(rgchDescrip, ptgrc->szDescrip))
                {
                    ptgrc->fEnabled = tgrc.fEnabled;
                    Assert(tgrc.TestFlag(TGRC_FLAG_VALID));
                    ptgrc->ulBitFlags = tgrc.ulBitFlags;
                    break;
                }

                ptgrc++;
            }
        }

        CloseHandle(hfile);
        fReturn = TRUE;
    }

    goto Exit;

ErrorReturn:
    if (hfile)
        CloseHandle(hfile);

Exit:
    return fReturn;
}

/*
 *  FWriteDebugState
 *
 *  Purpose:
 *      Writes the current state of the Debug Module to the file
 *      name given.  The saved state can be restored later by calling
 *      FReadDebugState.
 *
 *  Parameters:
 *      szDebugFile     Name of the file to create and write the debug
 *                      state to.
 *
 *  Returns:
 *      TRUE if file was successfully written; FALSE otherwise.
 */
BOOL
FWriteDebugState( CHAR * szDebugFile )
{
    HANDLE      hfile = NULL;
    TAG         tag;
    UINT        cch;
    TGRC *      ptgrc;
    BOOL        fReturn = FALSE;
    DWORD       cWrite;

    hfile = CreateFileA(szDebugFile,
                        GENERIC_WRITE,
                        FILE_SHARE_WRITE,
                        NULL,
                        CREATE_ALWAYS,
                        FILE_ATTRIBUTE_NORMAL,
                        (HANDLE) NULL);
    if (hfile != INVALID_HANDLE_VALUE)
    {
        for (tag = tagMin; tag < tagMac; tag++)
        {
            ptgrc = mptagtgrc + tag;

            if (!ptgrc->TestFlag(TGRC_FLAG_VALID))
                continue;

            Assert(ptgrc->szOwner);
            Assert(ptgrc->szDescrip);

            if (!WriteFile(hfile, ptgrc, sizeof(TGRC), &cWrite, NULL))
                goto ErrorReturn;

            // SZ fields will be overwritten when read back

            cch = strlen(ptgrc->szOwner) + 1;
            if (!WriteFile(hfile, &cch, sizeof(UINT), &cWrite, NULL))
                goto ErrorReturn;
            if (!WriteFile(hfile, ptgrc->szOwner, cch, &cWrite, NULL))
                goto ErrorReturn;

            cch = strlen(ptgrc->szDescrip) + 1;
            if (!WriteFile(hfile, &cch, sizeof(UINT), &cWrite, NULL))
                goto ErrorReturn;
            if (!WriteFile(hfile, ptgrc->szDescrip, cch, &cWrite, NULL))
                goto ErrorReturn;
        }

        CloseHandle(hfile);
        fReturn = TRUE;
    }

    goto Exit;

ErrorReturn:
    if (hfile)
        CloseHandle(hfile);
    DeleteFileA(szDebugFile);

Exit:
    return fReturn;
}


//+------------------------------------------------------------------------
//
//  Function:   SaveDefaultDebugState
//
//  Synopsis:   Saves the debug state of the executing program to a file
//              of the same name, substituting the ".tag" suffix.
//
//  Arguments:  [void]
//
//-------------------------------------------------------------------------

void
SaveDefaultDebugState( void )
{
    CHAR    rgch[MAX_PATH] = "";

    if (g_hinstMain)
    {
#ifndef _MAC
        UINT cch = (UINT) GetModuleFileNameA(g_hinstMain, rgch, sizeof(rgch));
        int dotLoc = findDot(rgch);
        Assert(dotLoc!=-1);
        strcpy(&rgch[dotLoc], szStateFileExt);
#else
        TCHAR   achAppLoc[MAX_PATH];
        DWORD   dwRet;
        short   iRet;

        dwRet = GetModuleFileNameA(g_hinstMain, achAppLoc, ARRAY_SIZE(achAppLoc));
        Assert (dwRet != 0);

        iRet = GetFileTitle(achAppLoc,rgch,sizeof(rgch));
        Assert(iRet == 0);

        strcat (rgch, szStateFileExt);
#endif
    }
    else
    {
        strcat(rgch, szStateFileName);
    }
    FWriteDebugState(rgch);
}


//+------------------------------------------------------------------------
//
//  Function:   RestoreDefaultDebugState
//
//  Synopsis:   Restores the debug state for the executing program from
//              the state file of the same name, substituting the ".tag"
//              suffix.
//
//  Arguments:  [void]
//
//-------------------------------------------------------------------------

void
RestoreDefaultDebugState( void )
{
    CHAR    rgch[MAX_PATH] = "";

    if (!g_fInit)
    {
        DebugOutput("RestoreDefaultDebugState: Debug library not initialized\n");
        return;
    }

    if (g_hinstMain)
    {
#ifndef _MAC
        UINT cch = (UINT) GetModuleFileNameA(g_hinstMain, rgch, sizeof(rgch));
        int dotLoc = findDot(rgch);
        Assert(dotLoc!=-1);
        strcpy(&rgch[dotLoc], szStateFileExt);
#else
        TCHAR   achAppLoc[MAX_PATH];
        DWORD   dwRet;
        short   iRet;

        dwRet = GetModuleFileName(g_hinstMain, achAppLoc, ARRAY_SIZE(achAppLoc));
        Assert (dwRet != 0);

        iRet = GetFileTitle(achAppLoc,rgch,sizeof(rgch));
        Assert(iRet == 0);

        strcat (rgch, szStateFileExt);
#endif
    }
    else
    {
        strcat(rgch, szStateFileName);
    }
    FReadDebugState(rgch);

    mptagtgrc[tagNull].fEnabled = TRUE;
}

/*
 *  IsTagEnabled
 *
 *  Purpose:
 *      Returns a boolean value indicating whether the given TAG
 *      has been enabled or disabled by the user.
 *
 *  Parameters:
 *      tag     The TAG to check
 *
 *  Returns:
 *      TRUE    if the TAG has been enabled.
 *      FALSE   if the TAG has been disabled.
 */

BOOL
IsTagEnabled(TAG tag)
{
    return  mptagtgrc[tag].TestFlag(TGRC_FLAG_VALID) &&
            mptagtgrc[tag].fEnabled;
}

/*
 *  EnableTag
 *
 *  Purpose:
 *      Sets or resets the TAG value given.  Allows code to enable or
 *      disable TAG'd assertions and trace switches.
 *
 *  Parameters:
 *      tag         The TAG to enable or disable
 *      fEnable     TRUE if TAG should be enabled, FALSE if it should
 *                  be disabled.
 *  Returns:
 *      old state of tag (TRUE if tag was enabled, otherwise FALSE)
 *
 */

BOOL EnableTag( TAG tag, BOOL fEnable )
{
    BOOL    fOld;

    Assert(mptagtgrc[tag].TestFlag(TGRC_FLAG_VALID));
    fOld = mptagtgrc[tag].fEnabled;
    mptagtgrc[tag].fEnabled = fEnable;
    return fOld;
}


/*
 *  SpitPchToDisk
 *
 *  Purpose:
 *      Writes the given string to the (previously opened) debug module
 *      disk file. Does NOT write newline-return; caller should embed it
 *      in string.
 *
 *  Parameters:
 *      pch     Pointer to an array of characters.
 *      cch     Number of characters to spit.
 *      pfile   file to which to write, or NULL to use
 *              debug output file.
 */

void
SpitPchToDisk( CHAR * pch, UINT cch, HANDLE hfile )
{
    DWORD       cWrite;

    if (fInSpitPchToDisk)       // already inside this function
        return;                     // aVOID recursion

    if (hfile && pch && cch)
    {

        fInSpitPchToDisk = TRUE;

        WriteFile(hfile, pch, cch, &cWrite, NULL);

        fInSpitPchToDisk = FALSE;
    }
}


/*
 *  SpitSzToDisk
 *
 *  Purpose:
 *      Writes the given string to the (previously opened) debug module
 *      disk file. Does NOT write newline-return; caller should embed it
 *      in string.
 *
 *  Parameters:
 *      sz      String to spit.
 *      pfile   file to which to write, or NULL to use
 *              debug output file.
 *
 *      Because this function calls fflush(), we're assuming for the
 *      sake of reasonable performance that only debug functions making
 *      output to disk are calling this function. We can't put this in
 *      SpitPchToDisk because calls that function, and any
 *      enabled trace tag would degrade performance.
 */

VOID
SpitSzToDisk( CHAR * sz, HANDLE hfile )
{
    if (hfile && sz)
    {
        SpitPchToDisk(sz, strlen(sz), hfile);
    }
}



/*
 *  TagRegisterSomething
 *
 *  Purpose:
 *      Does actual work of allocating TAG, and initializing TGRC.
 *      The owner and description strings are duplicated from the
 *      arguments passed in.
 *
 *  Parameters:
 *      tgty        Tag type to register.
 *      szOwner     Owner.
 *      szDescrip   Description.
 *
 *  Returns:
 *      New TAG, or tagNull if none is available.
 */

TAG
TagRegisterSomething(
        TGTY    tgty,
        CHAR *  szOwner,
        CHAR *  szDescrip,
        BOOL    fEnabled)
{
    TAG     tag;
    TAG     tagNew          = tagNull;
    TGRC *  ptgrc;
    CHAR *  szOwnerDup      = NULL;
    CHAR *  szDescripDup    = NULL;
    UINT    cb;

    for (tag = tagMin, ptgrc = mptagtgrc + tag; tag < tagMac;
            tag++, ptgrc++)
    {
        if (ptgrc->TestFlag(TGRC_FLAG_VALID))
        {
            if(!(strcmp(szOwner, ptgrc->szOwner) ||
                strcmp(szDescrip, ptgrc->szDescrip)))
            {
                return tag;
            }
        }
        else if (tagNew == tagNull)
            tagNew= tag;
    }

    // Make duplicate copies.

    Assert(szOwner);
    Assert(szDescrip);
    cb = strlen(szOwner) + 1;

    // we use LocalAlloc here instead of new so
    // we don't interfere with leak reporting because of the
    // dependency between the debug library and the
    // leak reporting code (i.e., don't touch this --Erik)

    szOwnerDup = (LPSTR) LocalAlloc(LMEM_FIXED, cb);
    if (szOwnerDup == NULL)
    {
        goto Error;
    }

    strcpy(szOwnerDup, szOwner);

    cb = strlen(szDescrip) + 1;
    szDescripDup = (LPSTR) LocalAlloc(LMEM_FIXED, cb);
    if (szDescripDup == NULL)
    {
        goto Error;
    }

    strcpy(szDescripDup, szDescrip);

    if (tagNew == tagNull)
    {
        if (tagMac >= tagMax)
        {
#ifdef  NEVER
            AssertSz(FALSE, "Too many tags registered already!");
#endif
            Assert(FALSE);
            return tagNull;
        }

        tag = tagMac++;
    }
    else
        tag = tagNew;

    ptgrc = mptagtgrc + tag;

    ptgrc->fEnabled = fEnabled;
    ptgrc->ulBitFlags = TGRC_DEFAULT_FLAGS;
    ptgrc->tgty = tgty;
    ptgrc->szOwner = szOwnerDup;
    ptgrc->szDescrip = szDescripDup;

    return tag;

Error:
    LocalFree(szOwnerDup);
    LocalFree(szDescripDup);
    return tagNull;
}


/*
 *  DeregisterTag
 *
 *  Purpose:
 *      Deregisters tag, removing it from tag table.
 *
 *  Parameters:
 *      tag     Tag to deregister.
 */

void
DeregisterTag(TAG tag)
{
    //  don't allow deregistering the tagNull entry
    //  but exit gracefully
    if (!tag)
        return;

    Assert(tag < tagMac);
    Assert(mptagtgrc[tag].TestFlag(TGRC_FLAG_VALID));

    mptagtgrc[tag].fEnabled = FALSE;
    mptagtgrc[tag].ClearFlag(TGRC_FLAG_VALID);
    LocalFree(mptagtgrc[tag].szOwner);
    mptagtgrc[tag].szOwner = NULL;
    LocalFree(mptagtgrc[tag].szDescrip);
    mptagtgrc[tag].szDescrip = NULL;
}


/*
 *  TagRegisterTrace
 *
 *  Purpose:
 *      Registers a class of trace points, and returns an identifying
 *      TAG for that class.
 *
 *  Parameters:
 *      szOwner     The email name of the developer writing the code
 *                  that registers the class.
 *      szDescrip   A short description of the class of trace points.
 *                  For instance: "All calls to PvAlloc() and HvFree()"
 *
 *  Returns:
 *      TAG identifying class of trace points, to be used in calls to
 *      the trace routines.
 */

TAG
TagRegisterTrace( CHAR * szOwner, CHAR * szDescrip, BOOL fEnabled )
{
    if (!g_fInit)
    {
        DebugOutput("TagRegisterTrace: Debug library not initialized\n");
        return tagNull;
    }

    return TagRegisterSomething(tgtyTrace, szOwner, szDescrip, fEnabled);
}



TAG
TagRegisterOther( CHAR * szOwner, CHAR * szDescrip, BOOL fEnabled )
{
    if (!g_fInit)
    {
        OutputDebugStringA("TagRegisterOther: Debug library not initialized");
        return tagNull;
    }

    return TagRegisterSomething(tgtyOther, szOwner, szDescrip, fEnabled);
}



TAG
TagError( void )
{
    return tagError;
}


TAG
TagWarning( void )
{
    return tagWarn;
}


TAG
TagLeakFilter( void )
{
    return tagLeakFilter;
}


TAG
TagHookMemory(void)
{
    return tagHookMemory;
}


TAG
TagHookBreak(void)
{
    return tagHookBreak;
}


TAG
TagLeaks(void)
{
    return tagLeaks;
}


TAG
TagCheckAlways(void)
{
    return tagCheckAlways;
}


TAG
TagCheckCRT(void)
{
    return tagCheckCRT;
}


TAG
TagDelayFree(void)
{
    return tagDelayFree;
}


/*
 *  Purpose:
 *      Clears the debug screen
 */

void
ClearDebugScreen( void )
{
#ifndef _MAC
    TraceTag((tagNull, "\x1B[2J"));
#endif
}


/*
 *  DebugOutput
 *
 *  Purpose:
 *      Writes the given string out the debug port.
 *      Does NOT write newline-return; caller should embed it in string.
 *
 *  Parameters:
 *      sz      String to spit.
 */

void DebugOutput( CHAR * sz )
{
#ifdef NEVER
    HANDLE      hfile;

    hfile = CreateFileA("COM1", GENERIC_READ | GENERIC_WRITE,
                        0, NULL, OPEN_EXISTING,
                        FILE_ATTRIBUTE_NORMAL, NULL);

    if (hfile != INVALID_HANDLE_VALUE)
    {
        DWORD   lcbWritten;
        WriteFile(hfile, sz, (DWORD) strlen(sz), &lcbWritten, NULL);
        CloseHandle(hfile);
    }
#endif  // NEVER
    OutputDebugStringA(sz);
}


/*
 *  TaggedTrace
 *
 *  Purpose:
 *      Uses the given format string and parameters to render a
 *      string into a buffer.  The rendered string is sent to the
 *      destination indicated by the given tag, or sent to the bit
 *      bucket if the tag is disabled.
 *
 *  Arguments:
 *      tag     Identifies the tag group
 *      szFmt   Format string for _snprintf (qqv)
 */

BOOL __cdecl
TaggedTrace(TAG tag, CHAR * szFmt, ...)
{
    BOOL    f;

    va_list valMarker;

    va_start(valMarker, szFmt);
    f = TaggedTraceListEx(tag, 0, szFmt, valMarker);
    va_end(valMarker);

    return f;
}

BOOL __cdecl
TaggedTraceEx(TAG tag, USHORT usFlags, CHAR * szFmt, ...)
{
    BOOL    f;

    va_list valMarker;

    va_start(valMarker, szFmt);
    f = TaggedTraceListEx(tag, usFlags, szFmt, valMarker);
    va_end(valMarker);

    return f;
}

BOOL __cdecl
TaggedTraceListEx(TAG tag, USHORT usFlags, CHAR * szFmt, va_list valMarker)
{
    static CHAR szFmtOwner[] = "DA %s (%lx): ";
    static CHAR szFmtHR[] = "<%ls (0x%lx)>";
    static CHAR szHRID[] = "%hr";
    TGRC *      ptgrc;
    int         cch;

    if (!g_fInit)
    {
        DebugOutput("TaggedTrace: Debug library not initialized\n");
        return FALSE;
    }

    if (tag == tagNull)
        ptgrc = mptagtgrc + tagCom1;
    else
        ptgrc = mptagtgrc + tag;

    if (!ptgrc->fEnabled)
        return FALSE;

        EnterCriticalSection(&g_csTrace);

    Assert(ptgrc->TestFlag(TGRC_FLAG_VALID));

    if (!(usFlags & TAG_NONAME))
    {
        cch = _snprintf(
                    rgchTraceTagBuffer,
                    ARRAY_SIZE(rgchTraceTagBuffer),
                    szFmtOwner,
                    ptgrc->szOwner,
                    GetCurrentThreadId());
    }
    else
    {
        cch = 0;
    }

    hrvsnprintf(
                rgchTraceTagBuffer + cch,
                ARRAY_SIZE(rgchTraceTagBuffer) - cch,
                szFmt,
                valMarker);

    if (ptgrc->TestFlag(TGRC_FLAG_DISK))
        {
            SpitSzToDisk(rgchTraceTagBuffer, hfileDebugOutput);
            SpitSzToDisk(szNewline, hfileDebugOutput);
        }

        if ((usFlags & TAG_USECONSOLE) || g_fOutputToConsole)
            printf(rgchTraceTagBuffer);

        if (!(usFlags & TAG_USECONSOLE))
            DebugOutput(rgchTraceTagBuffer);

        if (!(usFlags & TAG_NONEWLINE))
        {
            if ((usFlags & TAG_USECONSOLE) || g_fOutputToConsole)
                printf(szNewline);
            if (!(usFlags & TAG_USECONSOLE))
                DebugOutput(szNewline);
        }

        LeaveCriticalSection(&g_csTrace);

    if (ptgrc->TestFlag(TGRC_FLAG_BREAK))
    {
        return MessageBoxA(
                NULL,
                ptgrc->szDescrip,
                "Trace Tag Break, OK=Ignore, Cancel=Int3",
                MB_SETFOREGROUND | MB_TASKMODAL
                        | MB_ICONEXCLAMATION | MB_OKCANCEL) == IDCANCEL;
    }

    return FALSE;
}


#ifdef NEVER
void TaggedTraceCallers(TAG tag, int iStart, int cTotal)
{
    DWORD   adwEip[32];
    int     i;
    int     c;
    int     ib;
    LPSTR   pstr;

    if (!IsTagEnabled(tag))
        return;

    if (cTotal > ARRAY_SIZE(adwEip))
        cTotal = ARRAY_SIZE(adwEip);

    c = GetStackBacktrace(iStart + 1, cTotal, adwEip);
    for (i = 0; i < c; i++)
    {
        MapAddressToFunctionOffset((LPBYTE) adwEip[i], &pstr, &ib);
        TaggedTraceEx(tag, TAG_NONAME, "  %08x  %s + 0x%x",
            adwEip[i], pstr, ib);
    }
}
#endif  // NEVER



//+---------------------------------------------------------------
//
//  Function:   GetHResultName
//
//  Synopsis:   Returns a printable string for the given hresult
//
//  Arguments:  [scode] -- The status code to report.
//
//  Notes:      This function disappears in retail builds.
//
//----------------------------------------------------------------

const LPTSTR
GetHResultName(HRESULT r)
{
    LPTSTR lpstr;

#define CASE_SCODE(sc)  \
        case sc: lpstr = _T(#sc); break;

    switch (r) {
        /* SCODE's defined in SCODE.H */
        CASE_SCODE(S_OK)
        CASE_SCODE(S_FALSE)
        CASE_SCODE(OLE_S_USEREG)
        CASE_SCODE(OLE_S_STATIC)
        CASE_SCODE(OLE_S_MAC_CLIPFORMAT)
        CASE_SCODE(DRAGDROP_S_DROP)
        CASE_SCODE(DRAGDROP_S_USEDEFAULTCURSORS)
        CASE_SCODE(DRAGDROP_S_CANCEL)
        CASE_SCODE(DATA_S_SAMEFORMATETC)
        CASE_SCODE(VIEW_S_ALREADY_FROZEN)
        CASE_SCODE(CACHE_S_FORMATETC_NOTSUPPORTED)
        CASE_SCODE(CACHE_S_SAMECACHE)
        CASE_SCODE(CACHE_S_SOMECACHES_NOTUPDATED)
        CASE_SCODE(OLEOBJ_S_INVALIDVERB)
        CASE_SCODE(OLEOBJ_S_CANNOT_DOVERB_NOW)
        CASE_SCODE(OLEOBJ_S_INVALIDHWND)
        CASE_SCODE(INPLACE_S_TRUNCATED)
        CASE_SCODE(CONVERT10_S_NO_PRESENTATION)
        CASE_SCODE(MK_S_REDUCED_TO_SELF)
        CASE_SCODE(MK_S_ME)
        CASE_SCODE(MK_S_HIM)
        CASE_SCODE(MK_S_US)
        CASE_SCODE(MK_S_MONIKERALREADYREGISTERED)
        CASE_SCODE(STG_S_CONVERTED)

        CASE_SCODE(E_UNEXPECTED)
        CASE_SCODE(E_NOTIMPL)
        CASE_SCODE(E_OUTOFMEMORY)
        CASE_SCODE(E_INVALIDARG)
        CASE_SCODE(E_NOINTERFACE)
        CASE_SCODE(E_POINTER)
        CASE_SCODE(E_HANDLE)
        CASE_SCODE(E_ABORT)
        CASE_SCODE(E_FAIL)
        CASE_SCODE(E_ACCESSDENIED)

        /* SCODE's defined in DVOBJ.H */
        CASE_SCODE(DATA_E_FORMATETC)
// same as DATA_E_FORMATETC     CASE_SCODE(DV_E_FORMATETC)
        CASE_SCODE(VIEW_E_DRAW)
//  same as VIEW_E_DRAW         CASE_SCODE(E_DRAW)
        CASE_SCODE(CACHE_E_NOCACHE_UPDATED)

        /* SCODE's defined in OLE2.H */
        CASE_SCODE(OLE_E_OLEVERB)
        CASE_SCODE(OLE_E_ADVF)
        CASE_SCODE(OLE_E_ENUM_NOMORE)
        CASE_SCODE(OLE_E_ADVISENOTSUPPORTED)
        CASE_SCODE(OLE_E_NOCONNECTION)
        CASE_SCODE(OLE_E_NOTRUNNING)
        CASE_SCODE(OLE_E_NOCACHE)
        CASE_SCODE(OLE_E_BLANK)
        CASE_SCODE(OLE_E_CLASSDIFF)
        CASE_SCODE(OLE_E_CANT_GETMONIKER)
        CASE_SCODE(OLE_E_CANT_BINDTOSOURCE)
        CASE_SCODE(OLE_E_STATIC)
        CASE_SCODE(OLE_E_PROMPTSAVECANCELLED)
        CASE_SCODE(OLE_E_INVALIDRECT)
        CASE_SCODE(OLE_E_WRONGCOMPOBJ)
        CASE_SCODE(OLE_E_INVALIDHWND)
        CASE_SCODE(DV_E_DVTARGETDEVICE)
        CASE_SCODE(DV_E_STGMEDIUM)
        CASE_SCODE(DV_E_STATDATA)
        CASE_SCODE(DV_E_LINDEX)
        CASE_SCODE(DV_E_TYMED)
        CASE_SCODE(DV_E_CLIPFORMAT)
        CASE_SCODE(DV_E_DVASPECT)
        CASE_SCODE(DV_E_DVTARGETDEVICE_SIZE)
        CASE_SCODE(DV_E_NOIVIEWOBJECT)
        CASE_SCODE(CONVERT10_E_OLESTREAM_GET)
        CASE_SCODE(CONVERT10_E_OLESTREAM_PUT)
        CASE_SCODE(CONVERT10_E_OLESTREAM_FMT)
        CASE_SCODE(CONVERT10_E_OLESTREAM_BITMAP_TO_DIB)
        CASE_SCODE(CONVERT10_E_STG_FMT)
        CASE_SCODE(CONVERT10_E_STG_NO_STD_STREAM)
        CASE_SCODE(CONVERT10_E_STG_DIB_TO_BITMAP)
        CASE_SCODE(CLIPBRD_E_CANT_OPEN)
        CASE_SCODE(CLIPBRD_E_CANT_EMPTY)
        CASE_SCODE(CLIPBRD_E_CANT_SET)
        CASE_SCODE(CLIPBRD_E_BAD_DATA)
        CASE_SCODE(CLIPBRD_E_CANT_CLOSE)
        CASE_SCODE(DRAGDROP_E_NOTREGISTERED)
        CASE_SCODE(DRAGDROP_E_ALREADYREGISTERED)
        CASE_SCODE(DRAGDROP_E_INVALIDHWND)
        CASE_SCODE(OLEOBJ_E_NOVERBS)
        CASE_SCODE(INPLACE_E_NOTUNDOABLE)
        CASE_SCODE(INPLACE_E_NOTOOLSPACE)

        /* SCODE's defined in STORAGE.H */
        CASE_SCODE(STG_E_INVALIDFUNCTION)
        CASE_SCODE(STG_E_FILENOTFOUND)
        CASE_SCODE(STG_E_PATHNOTFOUND)
        CASE_SCODE(STG_E_TOOMANYOPENFILES)
        CASE_SCODE(STG_E_ACCESSDENIED)
        CASE_SCODE(STG_E_INVALIDHANDLE)
        CASE_SCODE(STG_E_INSUFFICIENTMEMORY)
        CASE_SCODE(STG_E_INVALIDPOINTER)
        CASE_SCODE(STG_E_NOMOREFILES)
        CASE_SCODE(STG_E_DISKISWRITEPROTECTED)
        CASE_SCODE(STG_E_SEEKERROR)
        CASE_SCODE(STG_E_WRITEFAULT)
        CASE_SCODE(STG_E_READFAULT)
        CASE_SCODE(STG_E_LOCKVIOLATION)
        CASE_SCODE(STG_E_FILEALREADYEXISTS)
        CASE_SCODE(STG_E_INVALIDPARAMETER)
        CASE_SCODE(STG_E_MEDIUMFULL)
        CASE_SCODE(STG_E_ABNORMALAPIEXIT)
        CASE_SCODE(STG_E_INVALIDHEADER)
        CASE_SCODE(STG_E_INVALIDNAME)
        CASE_SCODE(STG_E_UNKNOWN)
        CASE_SCODE(STG_E_UNIMPLEMENTEDFUNCTION)
        CASE_SCODE(STG_E_INVALIDFLAG)
        CASE_SCODE(STG_E_INUSE)
        CASE_SCODE(STG_E_NOTCURRENT)
        CASE_SCODE(STG_E_REVERTED)
        CASE_SCODE(STG_E_CANTSAVE)
        CASE_SCODE(STG_E_OLDFORMAT)
        CASE_SCODE(STG_E_OLDDLL)
        CASE_SCODE(STG_E_SHAREREQUIRED)

        /* SCODE's defined in COMPOBJ.H */
        CASE_SCODE(CO_E_NOTINITIALIZED)
        CASE_SCODE(CO_E_ALREADYINITIALIZED)
        CASE_SCODE(CO_E_CANTDETERMINECLASS)
        CASE_SCODE(CO_E_CLASSSTRING)
        CASE_SCODE(CO_E_IIDSTRING)
        CASE_SCODE(CO_E_APPNOTFOUND)
        CASE_SCODE(CO_E_APPSINGLEUSE)
        CASE_SCODE(CO_E_ERRORINAPP)
        CASE_SCODE(CO_E_DLLNOTFOUND)
        CASE_SCODE(CO_E_ERRORINDLL)
        CASE_SCODE(CO_E_WRONGOSFORAPP)
        CASE_SCODE(CO_E_OBJNOTREG)
        CASE_SCODE(CO_E_OBJISREG)
        CASE_SCODE(CO_E_OBJNOTCONNECTED)
        CASE_SCODE(CO_E_APPDIDNTREG)
        CASE_SCODE(CLASS_E_NOAGGREGATION)
        CASE_SCODE(CLASS_E_CLASSNOTAVAILABLE)
        CASE_SCODE(REGDB_E_READREGDB)
        CASE_SCODE(REGDB_E_WRITEREGDB)
        CASE_SCODE(REGDB_E_KEYMISSING)
        CASE_SCODE(REGDB_E_INVALIDVALUE)
        CASE_SCODE(REGDB_E_CLASSNOTREG)
        CASE_SCODE(REGDB_E_IIDNOTREG)
        CASE_SCODE(RPC_E_CALL_REJECTED)
        CASE_SCODE(RPC_E_CALL_CANCELED)
        CASE_SCODE(RPC_E_CANTPOST_INSENDCALL)
        CASE_SCODE(RPC_E_CANTCALLOUT_INASYNCCALL)
        CASE_SCODE(RPC_E_CANTCALLOUT_INEXTERNALCALL)
        CASE_SCODE(RPC_E_CONNECTION_TERMINATED)
#if defined(NO_NTOLEBUGS)
        CASE_SCODE(RPC_E_SERVER_DIED)
#endif // NO_NTOLEBUGS
        CASE_SCODE(RPC_E_CLIENT_DIED)
        CASE_SCODE(RPC_E_INVALID_DATAPACKET)
        CASE_SCODE(RPC_E_CANTTRANSMIT_CALL)
        CASE_SCODE(RPC_E_CLIENT_CANTMARSHAL_DATA)
        CASE_SCODE(RPC_E_CLIENT_CANTUNMARSHAL_DATA)
        CASE_SCODE(RPC_E_SERVER_CANTMARSHAL_DATA)
        CASE_SCODE(RPC_E_SERVER_CANTUNMARSHAL_DATA)
        CASE_SCODE(RPC_E_INVALID_DATA)
        CASE_SCODE(RPC_E_INVALID_PARAMETER)
        CASE_SCODE(RPC_E_UNEXPECTED)

        /* SCODE's defined in MONIKER.H */
        CASE_SCODE(MK_E_CONNECTMANUALLY)
        CASE_SCODE(MK_E_EXCEEDEDDEADLINE)
        CASE_SCODE(MK_E_NEEDGENERIC)
        CASE_SCODE(MK_E_UNAVAILABLE)
        CASE_SCODE(MK_E_SYNTAX)
        CASE_SCODE(MK_E_NOOBJECT)
        CASE_SCODE(MK_E_INVALIDEXTENSION)
        CASE_SCODE(MK_E_INTERMEDIATEINTERFACENOTSUPPORTED)
        CASE_SCODE(MK_E_NOTBINDABLE)
        CASE_SCODE(MK_E_NOTBOUND)
        CASE_SCODE(MK_E_CANTOPENFILE)
        CASE_SCODE(MK_E_MUSTBOTHERUSER)
        CASE_SCODE(MK_E_NOINVERSE)
        CASE_SCODE(MK_E_NOSTORAGE)
#if defined(NO_NTOLEBUGS)
        CASE_SCODE(MK_S_MONIKERALREADYREGISTERED)
#endif //NO_NTOLEBUGS

        // Forms error codes
//        CASE_SCODE(FORMS_E_NOPAGESSPECIFIED)
//        CASE_SCODE(FORMS_E_NOPAGESINTERSECT)

        // Dispatch error codes
        CASE_SCODE(DISP_E_MEMBERNOTFOUND)
        CASE_SCODE(DISP_E_PARAMNOTFOUND)
        CASE_SCODE(DISP_E_BADPARAMCOUNT)
        CASE_SCODE(DISP_E_BADINDEX)
        CASE_SCODE(DISP_E_UNKNOWNINTERFACE)
        CASE_SCODE(DISP_E_NONAMEDARGS)
        CASE_SCODE(DISP_E_EXCEPTION)
        CASE_SCODE(DISP_E_TYPEMISMATCH)
        CASE_SCODE(DISP_E_UNKNOWNNAME)

        // Typinfo error codes
        CASE_SCODE(TYPE_E_REGISTRYACCESS)
        CASE_SCODE(TYPE_E_LIBNOTREGISTERED)
        CASE_SCODE(TYPE_E_UNDEFINEDTYPE)
        CASE_SCODE(TYPE_E_WRONGTYPEKIND)
        CASE_SCODE(TYPE_E_ELEMENTNOTFOUND)
        CASE_SCODE(TYPE_E_INVALIDID)
        CASE_SCODE(TYPE_E_CANTLOADLIBRARY)

        default:
            lpstr = _T("UNKNOWN SCODE");
    }

#undef CASE_SCODE

    return lpstr;
}



//+---------------------------------------------------------------------------
//
//  Function:   hrvsnprintf
//
//  Synopsis:   Prints a string to a buffer, interpreting %hr as a
//              format string for an HRESULT.
//
//  Arguments:  [achBuf]    -- The buffer to print into.
//              [cchBuf]    -- The size of the buffer.
//              [pstrFmt]   -- The format string.
//              [valMarker] -- List of arguments to format string.
//
//  Returns:    Number of characters printed to the buffer not including
//              the terminating NULL.  In case of buffer overflow, returns
//              -1.
//
//  Modifies:   [achBuf]
//
//----------------------------------------------------------------------------

int
hrvsnprintf(char * achBuf, int cchBuf, const char * pstrFmt, va_list valMarker)
{
    static char achFmtHR[] = "<%ls (0x%lx)>";
    static char achHRID[] = "%hr";
    char * buf = NULL;

    int             cch;
    int             cchTotal;
    const char *    lpstr;
    const char *    lpstrLast;
    int             cFormat;
    HRESULT         hrVA;

    //
    // Scan for %hr tokens.  If found, print the corresponding
    // hresult into the buffer.
    //

    // Need to copy a const string since we plan to modify it below
    
    buf = (char *) malloc ((lstrlen(pstrFmt) + 1) * sizeof(char));
    lstrcpy(buf,pstrFmt);
    
    cch = 0;
    cchTotal = 0;
    cFormat = 0;
    lpstrLast = buf;
    lpstr = buf;
    while (*lpstr)
    {
        if (*lpstr != '%')
        {
            lpstr++;
        }
        else if (lpstr[1] == '%')
        {
            lpstr += 2;
        }
        else if (StrCmpNA(lpstr, achHRID, ARRAY_SIZE(achHRID) - 1))
        {
            cFormat++;
            lpstr++;
        }
        else
        {
            //
            // Print format string up to the hresult.
            //

            * (char *) lpstr = 0;
            cch = _vsnprintf(
                    achBuf + cchTotal,
                    cchBuf - cchTotal,
                    lpstrLast,
                    valMarker);
            * (char *) lpstr = '%';
            if (cch == -1)
                break;

            cchTotal += cch;

            //
            // Advance valMarker for each printed format.
            //

            while (cFormat-- > 0)
            {
                //
                // BUGBUG (adams): Won't work for floats, as their stack size
                // is not four bytes.
                //

                va_arg(valMarker, void *);
            }

            //
            // Print hresult into buffer.
            //

            hrVA = va_arg(valMarker, HRESULT);
            cch = _snprintf(
                    achBuf + cchTotal,
                    cchBuf - cchTotal,
                    achFmtHR,
                    GetHResultName(hrVA),
                    hrVA);
            if (cch == -1)
                break;

            cchTotal += cch;
            lpstr += ARRAY_SIZE(achHRID) - 1;
            lpstrLast = lpstr;
        }
    }

    if (cch != -1)
    {
        cch = _vsnprintf(
                achBuf + cchTotal,
                cchBuf - cchTotal,
                lpstrLast,
                valMarker);
    }

    free (buf);
    
    return (cch == -1) ? -1 : cchTotal + cch;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\apeldbg\debugui.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1993.
//
//  File:       debugui.cxx
//
//  Contents:   User interface for trace tags dialog
//
//  History:    ??
//              10-08-93   ErikGav  New UI
//              10-20-93   ErikGav  Unicode cleanup
//
//----------------------------------------------------------------------------

#include <headers.h>

#if _DEBUG

#include "resource.h"

// private typedefs
typedef int TMC;

// private function prototypes
void    DoTracePointsDialog(BOOL fWait);
VOID    EndButton(HWND hwndDlg, TMC tmc, BOOL fDirty);
WORD    TagFromSelection(HWND hwndDlg, TMC tmc);
INT_PTR CALLBACK DlgTraceEtc(HWND hwndDlg, UINT wm, WPARAM wparam, LPARAM lparam);

//  Debug UI Globals

//
//  Identifies the type of TAG with which the current modal dialog is
//  dealing.
//

static  BOOL    fDirtyDlg;

//+-------------------------------------------------------------------------
//
//  Function:   TraceTagDlgThread
//
//  Synopsis:   Thread entry point for trace tag dialog.  Keeps caller
//              of DoTracePointsDialog from blocking.
//
//--------------------------------------------------------------------------

DWORD
TraceTagDlgThread(void * pv)
{
    INT_PTR r;

    r = DialogBoxA(g_hinstMain, "TRCAST", g_hwndMain, DlgTraceEtc);
    if (r == -1)
    {
        MessageBoxA(NULL, "Couldn't create trace tag dialog", "Error",
                   MB_OK | MB_ICONSTOP);
    }

    return (DWORD) r;
}


//+---------------------------------------------------------------------------
//
//  Function:   DoTracePointsDialog
//
//  Synopsis:   Brings up and processes trace points dialog.  Any changes
//              made by the user are copied to the current debug state.
//
//  Arguments:  [fWait] -- If TRUE, this function will not return until the
//                         dialog has been closed.
//
//----------------------------------------------------------------------------

void
DoTracePointsDialog( BOOL fWait )
{
    HANDLE          hThread = NULL;
#ifndef _MAC
    DWORD           idThread;
#endif

    if (!g_fInit)
    {
        OutputDebugString(_T("DoTracePointsDialog: Debug library not initialized"));
        return;
    }

    if (fWait)
    {
        TraceTagDlgThread(NULL);
    }
    else
    {
#ifndef _MAC
        hThread = CreateThread(NULL, 0, (unsigned long (__stdcall *)(void *)) TraceTagDlgThread, NULL, 0, &idThread);
#else
#pragma message("   DEBUGUI.cxx CreateThread")
Assert (0 && "  DEBUGUI.cxx CreateThread");
#endif
        if (hThread == NULL)
        {
            MessageBox(NULL,
                       _T("Couldn't create trace tag dialog thread"),
                       _T("Error"),
                       MB_OK | MB_ICONSTOP);
        }
#ifndef _MAC
        else
        {
            CloseHandle(hThread);
        }
#endif
    }
}


/*
 *    FFillDebugListbox
 *
 *    Purpose:
 *        Initializes Windows debug listboxes by adding the correct strings
 *        to the listbox for the current dialog type.  This is only called
 *        once in the Windows interface when the dialog is initialized.
 *
 *    Parameters:
 *        hwndDlg    Handle to parent dialog box.
 *
 *    Returns:
 *        TRUE    if function is successful, FALSE otherwise.
 */
BOOL CALLBACK
FFillDebugListbox(HWND hwndDlg)
{
    TAG      tag;
    LRESULT  lresult;
    TGRC *   ptgrc;
    HWND     hwndListbox;
    CHAR     rgch[80];
    HFONT    hFont;

    // Get the listbox handle
    hwndListbox = GetDlgItem(hwndDlg, tmcListbox);
    Assert(hwndListbox);

    // Make sure it's clean
    SendMessageA(hwndListbox, CB_RESETCONTENT, 0, 0);

    hFont = (HFONT) GetStockObject(SYSTEM_FIXED_FONT);
    SendMessage(hwndListbox, WM_SETFONT, (WPARAM) hFont, FALSE);
    DeleteObject(hFont);

    // Enter strings into the listbox-check all tags.
    for (tag = tagMin; tag < tagMac; tag++)
    {
        // If tag is of correct type, enter the string for it.
        if (mptagtgrc[tag].TestFlag(TGRC_FLAG_VALID))
        {
            ptgrc = mptagtgrc + tag;

            #if 0   // old format
            _snprintf(rgch, sizeof(rgch), "%d : %s  %s",
                tag, ptgrc->szOwner, ptgrc->szDescrip);
            #endif

            _snprintf(rgch, sizeof(rgch), "%-17.17s  %s",
                ptgrc->szOwner, ptgrc->szDescrip);

            lresult = SendMessageA(hwndListbox, CB_ADDSTRING,
                                    0, (DWORD_PTR)(LPVOID)rgch);

            if (lresult == CB_ERR || lresult == CB_ERRSPACE)
                return FALSE;

            lresult = SendMessageA(
                    hwndListbox, CB_SETITEMDATA, lresult, tag);

            if (lresult == CB_ERR || lresult == CB_ERRSPACE)
                return FALSE;

        }
    }

    return TRUE;
}


/*
 *    FDlgTraceEtc
 *
 *    Purpose:
 *        Dialog procedure for Trace Points and Asserts dialogs.
 *        Keeps the state of the checkboxes identical to
 *        the state of the currently selected TAG in the listbox.
 *
 *    Parameters:
 *        hwndDlg    Handle to dialog window
 *        wm        SDM dialog message
 *        wparam
 *        lparam    Long parameter
 *
 *    Returns:
 *        TRUE if the function processed this message, FALSE if not.
 */
INT_PTR CALLBACK
DlgTraceEtc(HWND hwndDlg, UINT wm, WPARAM wparam, LPARAM lparam)
{
    TAG      tag;
    TGRC *   ptgrc;
    DWORD    wNew;
    BOOL     fEnable;        // enable all
    TGRC_FLAG   tf;
    BOOL        fTrace;
    HWND        hwndListBox;
    char        szTitle[MAX_PATH];

    switch (wm)
    {
    default:
        return FALSE;
        break;

    case WM_INITDIALOG:
        fDirtyDlg = FALSE;

        if (!FFillDebugListbox(hwndDlg))
        {
            MessageBoxA(hwndDlg,
                "Error initializing listbox. Cannot display dialog.",
                "Trace/Assert Dialog", MB_OK);
            EndButton(hwndDlg, 0, FALSE);
            break;
        }

        GetModuleFileNameA(NULL, szTitle, MAX_PATH);
        SetWindowText(hwndDlg, szTitle);

        hwndListBox = GetDlgItem(hwndDlg, tmcListbox);
        Assert(hwndListBox);
        SendMessage(hwndListBox, CB_SETCURSEL, 0, 0);
        SendMessage(
                hwndDlg,
                WM_COMMAND,
                MAKELONG(tmcListbox, CBN_SELCHANGE),
                (LPARAM) hwndListBox);

        SetForegroundWindow(hwndDlg);
        break;

    case WM_COMMAND:
        switch (LOWORD(wparam))
        {
        case tmcOk:
        case tmcCancel:
            EndButton(hwndDlg, LOWORD(wparam), fDirtyDlg);
            break;

        case tmcEnableAll:
        case tmcDisableAll:
            fDirtyDlg = TRUE;

            fEnable = FALSE;
            if (LOWORD(wparam) == tmcEnableAll)
                fEnable = TRUE;

            for (tag = tagMin; tag < tagMac; tag++)
            {
                    mptagtgrc[tag].fEnabled = fEnable;
            }

            tag = TagFromSelection(hwndDlg, tmcListbox);

            CheckDlgButton(hwndDlg, tmcEnabled, fEnable);

            break;

        case tmcListbox:
            if (HIWORD(wparam) != CBN_SELCHANGE
                && HIWORD(wparam) != CBN_DBLCLK)
                break;

            fDirtyDlg = TRUE;

            tag = TagFromSelection(hwndDlg, tmcListbox);
            Assert(tag != tagNull);
            ptgrc = mptagtgrc + tag;

            if (HIWORD(wparam) == CBN_DBLCLK)
                ptgrc->fEnabled = !ptgrc->fEnabled;

            CheckDlgButton(hwndDlg, tmcEnabled, ptgrc->fEnabled);
            CheckDlgButton(hwndDlg, tmcDisk, ptgrc->TestFlag(TGRC_FLAG_DISK));
            CheckDlgButton(hwndDlg, tmcCom1, ptgrc->TestFlag(TGRC_FLAG_COM1));
            CheckDlgButton(hwndDlg, tmcBreak, ptgrc->TestFlag(TGRC_FLAG_BREAK));
            fTrace = (ptgrc->tgty == tgtyTrace);
            EnableWindow(GetDlgItem(hwndDlg, tmcDisk),  fTrace);
            EnableWindow(GetDlgItem(hwndDlg, tmcCom1),  fTrace);
            EnableWindow(GetDlgItem(hwndDlg, tmcBreak), fTrace);
            break;

        case tmcEnabled:
        case tmcDisk:
        case tmcCom1:
        case tmcBreak:
            fDirtyDlg = TRUE;

            tag = TagFromSelection(hwndDlg, tmcListbox);
            ptgrc = mptagtgrc + tag;

            wNew = IsDlgButtonChecked(hwndDlg, LOWORD(wparam));

            if (LOWORD(wparam) == tmcEnabled)
            {
                ptgrc->fEnabled = wNew;
            }
            else
            {
                switch (LOWORD(wparam))
                {
            case tmcDisk:
                    tf = TGRC_FLAG_DISK;
                break;

            case tmcCom1:
                    tf = TGRC_FLAG_COM1;
                    break;

                case tmcBreak:
                    tf = TGRC_FLAG_BREAK;
                    break;

                default:
                    Assert(0 && "Logic error in DlgTraceEtc");
                    tf = (TGRC_FLAG) 0;
                break;
                }

                ptgrc->SetFlagValue(tf, wNew);
            }
        }
        break;
    }

    return TRUE;
}


/*
 *    EndButton
 *
 *    Purpose:
 *        Does necessary processing when either OK or Cancel is pressed in
 *        any of the debug dialogs.  If OK is pressed, the debug state is
 *        saved if dirty.  If Cancel is hit, the debug state is restored if
 *        dirty.
 *
 *    In Windows, the EndDialog function must also be called.
 *
 *    Parameters:
 *        tmc        tmc of the button pressed, either tmcOk or tmcCancel.
 *        fDirty    indicates if the debug state has been modified.
 */
void
EndButton(HWND hwndDlg, TMC tmc, BOOL fDirty)
{
    HCURSOR    hCursor;

    if (fDirty)
    {
        hCursor = SetCursor(LoadCursor(NULL, IDC_WAIT));
        ShowCursor(TRUE);
        if (tmc == tmcOk)
            SaveDefaultDebugState();
        else
            RestoreDefaultDebugState();
        ShowCursor(FALSE);
        SetCursor(hCursor);
    }


    EndDialog(hwndDlg, tmc == tmcOk);

    return;
}


/*
 *    TagFromSelection
 *
 *    Purpose:
 *        Isolation function for dialog procedures to eliminate a bunch of
 *         ifdef's everytime the index of the selection in the current listbox
 *        is requried.
 *
 *     Parameters:
 *        tmc        ID value of the listbox.
 *
 *     Returns:
 *        ctag for the currently selected listbox item.
 */

WORD
TagFromSelection(HWND hwndDlg, TMC tmc)
{
    HWND    hwndListbox;
    LRESULT lresult;

    hwndListbox = GetDlgItem(hwndDlg, tmcListbox);
    Assert(hwndListbox);

    lresult = SendMessageA(hwndListbox, CB_GETCURSEL, 0, 0);
    Assert(lresult >= 0);
    lresult = SendMessageA(hwndListbox, CB_GETITEMDATA, lresult, 0);
    Assert(tagMin <= lresult && lresult < tagMac);
    return (WORD) lresult;
}


#endif // _DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\apeldbg\headers.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       headers.hxx
//
//  Contents:   include files for Forms Debug DLL
//
//----------------------------------------------------------------------------

#ifndef FORMDBG_HEADERS_HXX
#define FORMDBG_HEADERS_HXX

#undef DBG
#define DBG  1

#include <w4warn.h>
#include <windows.h>
#include <w4warn.h> // windows.h reenables some pragmas
#include <windowsx.h>
#include <winuser.h>
#include <commdlg.h>

#include <process.h>
#include <conio.h>
#include <stdio.h>
#include <tchar.h>

#include <apeldbg.h>

#include "_apeldbg.h"

#include "Win2Mac.h"

#endif // FORMDBG_HEADERS_HXX
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\apeldbg\ffail.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1994.
//
//  File:       ffail.cxx
//
//  Contents:   Debug functions that you don't want to step into in
//              the debugger.  This module is compiled without the /Zi flag.
//
//----------------------------------------------------------------------------

#include "headers.h"

#if _DEBUG

BOOL g_fJustFailed;

//+---------------------------------------------------------------------------
//
//  Function:   FFail
//
//  Synopsis:   Fails if count of fails is positive and evenly divides
//              interval count.
//
//----------------------------------------------------------------------------

BOOL
FFail()
{
    g_fJustFailed = (++g_cFFailCalled < 0) ? FALSE : ! (g_cFFailCalled % g_cInterval);
    return g_fJustFailed;
}



//+---------------------------------------------------------------------------
//
//  Function:   JustFailed
//
//  Synopsis:   Returns result of last call to FFail
//
//----------------------------------------------------------------------------

BOOL
JustFailed()
{
    return g_fJustFailed;
}



//+------------------------------------------------------------------------
//
//  Function:   GetFailCount
//
//  Synopsis:   Returns the number of failure points that have been
//              passed since the last failure count reset
//
//  Returns:    int
//
//-------------------------------------------------------------------------

int
GetFailCount( )
{
    Assert(g_firstFailure >= 0);
    return g_cFFailCalled + ((g_firstFailure != 0) ? g_firstFailure : INT_MIN);
}

#endif

#if DEVELOPER_DEBUG


//+---------------------------------------------------------------------------
//
//  Function:   ReturnFALSE
//
//  Synopsis:   Returns FALSE.  Used for Assert.
//
//----------------------------------------------------------------------------

BOOL
ReturnFALSE()
{
    return FALSE;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\apeldbg\pure.h ===
/*
 * Header file of Pure API function declarations.
 *
 * Explicitly no copyright.
 * You may recompile and redistribute these definitions as required.
 *
 * Version 1.0
 */

#if defined(c_plusplus) || defined(__cplusplus)
extern "C" {
#endif

#define PURE_H_VERSION 1

//////////////////////////////
// API's Specific to Purify //
//////////////////////////////

// TRUE when Purify is running.
int __cdecl PurifyIsRunning(void)			;
//
// Print a string to the viewer.
//
int __cdecl PurePrintf(const char *fmt, ...)		;
int __cdecl PurifyPrintf(const char *fmt, ...)		;
//
// Purify functions for leak and memory-in-use functionalty.
//
int __cdecl PurifyNewInuse(void)			;
int __cdecl PurifyAllInuse(void) 			;
int __cdecl PurifyClearInuse(void)			;
int __cdecl PurifyNewLeaks(void)			;
int __cdecl PurifyAllLeaks(void)			;
int __cdecl PurifyClearLeaks(void)			;
//
// Purify functions for handle leakage.
//
int __cdecl PurifyAllHandlesInuse(void)			;
int __cdecl PurifyNewHandlesInuse(void)			;
//
// Functions that tell you about the state of memory.
//
int __cdecl PurifyDescribe(void *addr)			;
int __cdecl PurifyWhatColors(void *addr, int size) 	;
//
// Functions to test the state of memory.  If the memory is not
// accessable, an error is signaled just as if there were a memory
// reference and the function returns false.
//
int __cdecl PurifyAssertIsReadable(const void *addr, int size)	;
int __cdecl PurifyAssertIsWritable(const void *addr, int size)	;
//
// Functions to test the state of memory.  If the memory is not
// accessable, these functions return false.  No error is signaled.
//
int __cdecl PurifyIsReadable(const void *addr, int size)	;
int __cdecl PurifyIsWritable(const void *addr, int size)	;
int __cdecl PurifyIsInitialized(const void *addr, int size)	;
//
// Functions to set the state of memory.
//
void __cdecl PurifyMarkAsInitialized(void *addr, int size)	;
void __cdecl PurifyMarkAsUninitialized(void *addr, int size)	;
//
// Functions to do late detection of ABWs, FMWs, IPWs.
//
#define PURIFY_HEAP_CRT 					0xfffffffe
#define PURIFY_HEAP_ALL 					0xfffffffd
#define PURIFY_HEAP_BLOCKS_LIVE 			0x80000000
#define PURIFY_HEAP_BLOCKS_DEFERRED_FREE 	0x40000000
#define PURIFY_HEAP_BLOCKS_ALL 				(PURIFY_HEAP_BLOCKS_LIVE|PURIFY_HEAP_BLOCKS_DEFERRED_FREE)
int __cdecl PurifyHeapValidate(unsigned int hHeap, unsigned int dwFlags, const void *addr)	;
int __cdecl PurifySetLateDetectScanCounter(int counter);
int __cdecl PurifySetLateDetectScanInterval(int seconds);


////////////////////////////////
// API's Specific to Quantify //
////////////////////////////////

// TRUE when Quantify is running.
int __cdecl QuantifyIsRunning(void)			;

//
// Functions for controlling collection
//
int __cdecl QuantifyDisableRecordingData(void)		;
int __cdecl QuantifyStartRecordingData(void)		;
int __cdecl QuantifyStopRecordingData(void)		;
int __cdecl QuantifyClearData(void)			;
int __cdecl QuantifyIsRecordingData(void)		;

// Add a comment to the dataset
int __cdecl QuantifyAddAnnotation(char *)		;

// Save the current data, creating a "checkpoint" dataset
int __cdecl QuantifySaveData(void)			;

#if defined(c_plusplus) || defined(__cplusplus)
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\apeldbg\simfail.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1994.
//
//  File:       simfail.cxx
//
//  Contents:   Simulated failure testing.
//
//
//  History:
//              5-22-95     kfl     converted WCHAR to TCHAR
//----------------------------------------------------------------------------

#include "headers.h"

#ifdef _DEBUG

#include "resource.h"

// Timer used to update Count display.
const UINT ID_TIMER = 1;

// Interval of update, in milliseconds.
const UINT TIMER_INTERVAL = 500;

// Number of times FFail is called after g_cfirstFailure is hit.
int     g_cFFailCalled;

// Number of success calls before first failure.  If 0, all calls successful.
int     g_firstFailure;

// Interval to repeat failures after first failure.
int     g_cInterval = 1;

// User defined error for simulated win32 failures.
const DWORD ERR_SIMWIN32 = 0x0200ABAB;

// Handle of simulated failures dialog.
HWND    g_hwndSimFailDlg;

DWORD WINAPI SimFailDlgThread(LPVOID lpThreadParameter);
extern "C" INT_PTR CALLBACK SimFailDlgProc( HWND hwnd, UINT wMsg, WPARAM wParam, LPARAM lParam );

//+---------------------------------------------------------------------------
//
//  Function:   ResetFailCount
//
//  Synopsis:   Resets the count of calls to FFail.
//
//----------------------------------------------------------------------------

void
ResetFailCount()
{
    Assert(g_firstFailure >= 0);
    g_cFFailCalled = (g_firstFailure != 0) ? -g_firstFailure : INT_MIN;
}



//+---------------------------------------------------------------------------
//
//  Function:   SetSimFailCounts
//
//  Synopsis:   Sets the parameters for simulated failures, and resets the
//              count of failures.
//
//  Arguments:  [firstFailure] -- Number of successes - 1 before first failure.
//                                If 0, simulated failures are turned off.
//                                If -1, parameter is ignored.
//
//              [cInterval]    -- Interval at which success are repeated.
//                                If 0, set to 1.
//                                If -1, parameter is ignored.
//
//  Notes:      To reset the count of failures,
//              call SetSimFailCounts(-1, -1).
//
//----------------------------------------------------------------------------

void
SetSimFailCounts(int firstFailure, int cInterval)
{
    if (firstFailure >= 0)
    {
        g_firstFailure = firstFailure;
    }

    if (cInterval > 0)
    {
        g_cInterval = cInterval;
    }
    else if (cInterval == 0)
    {
        g_cInterval = 1;
    }

    ResetFailCount();
}


//+-------------------------------------------------------------------------
//
//  Function:   IsSimFailDlgVisible
//
//  Synopsis:   Returns whether the simfail dlg is up.
//
//--------------------------------------------------------------------------

BOOL
IsSimFailDlgVisible(void)
{
    return (g_hwndSimFailDlg != NULL);
}



//+---------------------------------------------------------------------------
//
//  Function:   ShowSimFailDlg
//
//  Synopsis:   Displays the simulated failures dialog in a separate thread.
//
//----------------------------------------------------------------------------

void
ShowSimFailDlg(void)
{
#ifndef _MAC
    HANDLE  hThread = NULL;
    ULONG   idThread;

    EnterCriticalSection(&g_csResDlg);

    if (g_hwndSimFailDlg)
    {
        BringWindowToTop(g_hwndSimFailDlg);
    }
    else
    {
        hThread = CreateThread(NULL, 0, SimFailDlgThread, NULL, 0, &idThread);
        if (!hThread)
        {
            TraceTag((tagError, "CreateThread failed ShowSimFailDlg"));
            goto Cleanup;
        }

        CloseHandle(hThread);
    }

Cleanup:
    LeaveCriticalSection(&g_csResDlg);
#else
    SimFailDlgThread(NULL);
#endif      // _MAC
}



//+---------------------------------------------------------------------------
//
//  Function:   SimFailDlgThread
//
//  Synopsis:   Creates the simulated failures dialog and runs a message loop
//              until the dialog is closed.
//
//----------------------------------------------------------------------------

DWORD WINAPI
SimFailDlgThread(LPVOID lpThreadParameter)
{
#ifndef _MAC
    MSG         msg;

    g_hwndSimFailDlg = CreateDialog(
            g_hinstMain,
            MAKEINTRESOURCE(IDD_SIMFAIL),
            NULL,
            SimFailDlgProc);

    if (!g_hwndSimFailDlg)
    {
        TraceTag((tagError, "CreateDialogA failed in SimFailDlgEntry"));
        return -1;
    }

    SetWindowPos(
            g_hwndSimFailDlg,
            HWND_TOP,
            0, 0, 0, 0,
            SWP_NOMOVE | SWP_NOSIZE | SWP_SHOWWINDOW);

    BOOL retVal;
    while ((retVal = GetMessage((LPMSG) &msg, (HWND) NULL, 0, 0)) == TRUE)
    {
        if (!g_hwndSimFailDlg || (!IsDialogMessage(g_hwndSimFailDlg, &msg)))
        {
            TranslateMessage(&msg);
            DispatchMessage(&msg);
        }
    }

    return retVal;
#else
    int r;
    r = DialogBox(g_hinstMain, MAKEINTRESOURCE(IDD_SIMFAIL),
                                    NULL, SimFailDlgProc);
    if (r == -1)
    {
        MessageBoxA(NULL, "Couldn't create sim failures dialog", "Error",
                   MB_OK | MB_ICONSTOP);
    }

    return (DWORD)(g_hwndSimFailDlg?TRUE:FALSE);
#endif  // _MAC
}



//+---------------------------------------------------------------------------
//
//  Function:   SimFailDlg_UpdateTextControls
//
//  Synopsis:   Updates the FirstFail and FailInterval text controls.
//
//----------------------------------------------------------------------------

void
SimFailDlg_UpdateTextControls(HWND hwnd)
{
    TCHAR   ach[16];

    ach[ARRAY_SIZE(ach) - 1] = 0;
    _sntprintf(ach, ARRAY_SIZE(ach) - 1, _T("%d"), g_firstFailure);
    Edit_SetText(GetDlgItem(hwnd, ID_TXTFAIL), ach);
    _sntprintf(ach, ARRAY_SIZE(ach) - 1, _T("%d"), g_cInterval);
    Edit_SetText(GetDlgItem(hwnd, ID_TXTINTERVAL), ach);
}



//+---------------------------------------------------------------------------
//
//  Function:   SimFailDlg_UpdateCount
//
//  Synopsis:   Updates the count text control.
//
//----------------------------------------------------------------------------

void
SimFailDlg_UpdateCount(HWND hwnd)
{
    TCHAR   ach[16];

    ach[ARRAY_SIZE(ach) - 1] = 0;
    _sntprintf(ach, ARRAY_SIZE(ach) - 1, _T("%d"), GetFailCount());
    Edit_SetText(GetDlgItem(hwnd, ID_TXTCOUNT), ach);
}



//+---------------------------------------------------------------------------
//
//  Function:   SimFailDlg_UpdateValues
//
//  Synopsis:   Sets the simulated failure counts with values from the
//              dialog.
//
//----------------------------------------------------------------------------

void
SimFailDlg_UpdateValues(HWND hwnd)
{
    TCHAR   ach[16];
    int     firstFail;
    int     cInterval;

    Edit_GetText(GetDlgItem(hwnd, ID_TXTFAIL), ach, ARRAY_SIZE(ach));
    firstFail = _ttoi(ach);
    if (firstFail < 0)
    {
        firstFail = 0;
    }

    Edit_GetText(GetDlgItem(hwnd, ID_TXTINTERVAL), ach, ARRAY_SIZE(ach));
    cInterval = _ttoi(ach);
    if (g_cInterval <= 0)
    {
        cInterval = 1;
    }

    SetSimFailCounts(firstFail, cInterval);
    SimFailDlg_UpdateTextControls(hwnd);
    SimFailDlg_UpdateCount(hwnd);
}



//+---------------------------------------------------------------------------
//
//  Function:   SimFailDlg_OnInitDialog
//
//  Synopsis:   Initializes the dialog.
//
//----------------------------------------------------------------------------

BOOL
SimFailDlg_OnInitDialog(HWND hwnd, HWND hwndFocus, LPARAM lParam)
{
    char    szName[MAX_PATH];
    char *  sz;

    Edit_LimitText(GetDlgItem(hwnd, ID_TXTFAIL), 9);
    Edit_LimitText(GetDlgItem(hwnd, ID_TXTINTERVAL), 9);
    SimFailDlg_UpdateTextControls(hwnd);
    SimFailDlg_UpdateCount(hwnd);
    SetTimer(hwnd, ID_TIMER, TIMER_INTERVAL, NULL);

    szName[0] = 0;
    if (GetModuleFileNameA(NULL, szName, ARRAY_SIZE(szName)))
    {
        sz = strrchr(szName, '\\');
        SetWindowTextA(hwnd, sz ? sz + 1 : szName);
    }

    SetForegroundWindow(hwnd);
    return TRUE;
}



//+---------------------------------------------------------------------------
//
//  Function:   SimFailDlg_OnCommand
//
//  Synopsis:   Handles button clicks.
//
//----------------------------------------------------------------------------

void
SimFailDlg_OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify)
{
    if (codeNotify != BN_CLICKED)
        return;

    switch (id)
    {
    case ID_BTNUPDATE:
        SimFailDlg_UpdateValues(hwnd);
        break;

    case ID_BTNNEVER:
        SetSimFailCounts(0, 1);
        SimFailDlg_UpdateTextControls(hwnd);
        SimFailDlg_UpdateCount(hwnd);
        break;

    case ID_BTNRESET:
        ResetFailCount();
        SimFailDlg_UpdateCount(hwnd);
        break;
    }
}



//+---------------------------------------------------------------------------
//
//  Function:   SimFailDlg_OnTimer
//
//  Synopsis:   Updates the failure count.
//
//----------------------------------------------------------------------------

void
SimFailDlg_OnTimer(HWND hwnd, UINT id)
{
    Assert(id == ID_TIMER);
    SimFailDlg_UpdateCount(hwnd);
}



//+---------------------------------------------------------------------------
//
//  Function:   SimFailDlg_OnClose
//
//  Synopsis:   Closes the dialog.
//
//----------------------------------------------------------------------------

void
SimFailDlg_OnClose(HWND hwnd)
{
    DestroyWindow(g_hwndSimFailDlg);
    g_hwndSimFailDlg = NULL;
}



//+---------------------------------------------------------------------------
//
//  Function:   SimFailDlg_OnDestroy
//
//  Synopsis:   Cleans up.
//
//----------------------------------------------------------------------------

void
SimFailDlg_OnDestroy(HWND hwnd)
{
    g_hwndSimFailDlg = NULL;
    KillTimer(hwnd, ID_TIMER);
}



//+---------------------------------------------------------------------------
//
//  Function:   SimFailDlgProc
//
//  Synopsis:   Dialog proc for simulated failures dialog.
//
//----------------------------------------------------------------------------

extern "C"
INT_PTR CALLBACK
SimFailDlgProc( HWND hwnd, UINT wMsg, WPARAM wParam, LPARAM lParam )
{
    switch (wMsg)
    {
    case WM_INITDIALOG:
        HANDLE_WM_INITDIALOG(hwnd, wParam, lParam, SimFailDlg_OnInitDialog);
        return TRUE;

    case WM_COMMAND:
        HANDLE_WM_COMMAND(hwnd, wParam, lParam, SimFailDlg_OnCommand);
        return TRUE;

    case WM_TIMER:
        HANDLE_WM_TIMER(hwnd, wParam, lParam, SimFailDlg_OnTimer);
        return TRUE;

    case WM_CLOSE:
        HANDLE_WM_CLOSE(hwnd, wParam, lParam, SimFailDlg_OnClose);
        return TRUE;

    case WM_DESTROY:
        HANDLE_WM_DESTROY(hwnd, wParam, lParam, SimFailDlg_OnDestroy);
        return TRUE;
    }

    return FALSE;
}



//+---------------------------------------------------------------------------
//
//  Function:   TraceFailL
//
//  Synopsis:   Traces failures.  Enable tagTestFailures to see trace output.
//
//              Don't call the function directly, but use the tracing macros
//              in apeldbg.h instead.
//
//  Arguments:  [errExpr]  -- The expression to test.
//              [errTest]  -- The fail code to test against.  The only
//                              distinguishing factor is whether it is
//                              zero, negative, or positive.
//              [fIgnore]  -- Is this error being ignored?
//              [pstrExpr] -- The expression as a string.
//              [pstrFile] -- File where expression occurs.
//              [line]     -- Line on which expression occurs.
//
//  Returns:    [errExpr].
//
//----------------------------------------------------------------------------

extern "C" long
TraceFailL(long errExpr, long errTest, BOOL fIgnore, LPSTR pstrExpr, LPSTR pstrFile, int line)
{
    LPSTR aapstr[2][2] =
    {
        "TFAIL: Failure of \"%s\" at %s:%d <%d>",
        "TFAIL: Simulated failure of \"%s\" at %s:%d <%d>",
        "IGNORE_FAIL: Failure of \"%s\" at %s:%d <%d>",
        "IGNORE_FAIL: Simulated failure of \"%s\" at %s:%d <%d>",
    };

    //
    // Check if errExpr is a success code:
    //     (a) If errTest < 0, then errExpr > 0.  This is for HRESULTs,
    //         list box error codes, etc.
    //     (b) If errTest == 0, the errExpr != 0.  This is for pointers.
    //     (c) If errTest > 0, then errExpr == 0.  This is for the case
    //         where any non-zero error code is an error.  Note that
    //         errTest must be less than the greatest signed integer
    //         (0x7FFFFFFF) for this to work.
    //

    if ((errTest < 0 && errExpr >= 0) ||
        (errTest == 0 && errExpr != 0) ||
        (errTest > 0 && errExpr == 0))
    {
        return errExpr;
    }

    TraceTagEx((
            tagTestFailures,
            0,
            aapstr[fIgnore][JustFailed()],
            pstrExpr,
            pstrFile,
            line,
            errExpr));

    return errExpr;
}



//+---------------------------------------------------------------------------
//
//  Function:   TraceWin32L
//
//  Synopsis:   Traces Win32 failures, displaying the value of GetLastError if
//              the failure is not simulated.  Enable tagTestFailures to see
//              trace output.
//
//              Don't call the function directly, but use the tracing macros
//              in apeldbg.h instead.
//
//  Arguments:  [errExpr]  -- The expression to test.
//              [errTest]  -- The fail code to test against.  The only
//                              distinguishing factor is whether it is
//                              zero, negative, or positive.
//              [fIgnore]  -- Is this error being ignored?
//              [pstrExpr] -- The expression as a string.
//              [pstrFile] -- File where expression occurs.
//              [line]     -- Line on which expression occurs.
//
//  Returns:    [errExpr].
//
//----------------------------------------------------------------------------

extern "C" long
TraceWin32L(long errExpr, long errTest, BOOL fIgnore, LPSTR pstrExpr, LPSTR pstrFile, int line)
{
    LPSTR aapstr[2][2] =
    {
        "TW32: Failure of \"%s\" at %s:%d <%d> GetLastError=<%d>",
        "TW32: Simulated failure of \"%s\" at %s:%d <%d>",
        "IGNORE_W32: Failure of \"%s\" at %s:%d <%d>",
        "IGNORE_W32: Simulated failure of \"%s\" at %s:%d <%d>",
    };

    //
    // Check if errExpr is a success code:
    //     (a) If errTest < 0, then errExpr > 0.  This is for HRESULTs,
    //         list box error codes, etc.
    //     (b) If errTest == 0, the errExpr != 0.  This is for pointers.
    //     (c) If errTest > 0, then errExpr == 0.  This is for the case
    //         where any non-zero error code is an error.  Note that
    //         errTest must be less than the greatest signed integer
    //         (0x7FFFFFFF) for this to work.
    //

    if ((errTest < 0 && errExpr >= 0) ||
        (errTest == 0 && errExpr != 0) ||
        (errTest > 0 && errExpr == 0))
    {
        return errExpr;
    }

    if (JustFailed())
    {
        SetLastError(ERR_SIMWIN32);
    }

    TraceTagEx((
            tagTestFailures,
            0,
            aapstr[fIgnore][JustFailed()],
            pstrExpr,
            pstrFile,
            line,
            errExpr,
            GetLastError()));

    return errExpr;
}



//+---------------------------------------------------------------------------
//
//  Function:   TraceHR
//
//  Synopsis:   Traces HRESULT failures.  Enable tagTestFailures to see
//              trace output.
//
//              Don't call the function directly, but use the tracing macros
//              in apeldbg.h instead.
//
//  Arguments:  [hrTest]   -- The expression to test.
//              [fIgnore]  -- Is this error being ignored?
//              [pstrExpr] -- The expression as a string.
//              [pstrFile] -- File where expression occurs.
//              [line]     -- Line on which expression occurs.
//
//  Returns:    [hrTest].
//
//----------------------------------------------------------------------------

extern "C" HRESULT
TraceHR(HRESULT hrTest, BOOL fIgnore, LPSTR pstrExpr, LPSTR pstrFile, int line)
{
    LPSTR aapstr[2][2] =
    {
        "THR: Failure of \"%s\" at %s:%d %hr",
        "THR: Simulated failure of \"%s\" at %s:%d %hr",
        "IGNORE_HR: Failure of \"%s\" at %s:%d %hr",
        "IGNORE_HR: Simulated failure of \"%s\" at %s:%d %hr",
    };

    if (SUCCEEDED(hrTest))
        return hrTest;

    TraceTagEx((
            tagTestFailures,
            0,
            aapstr[fIgnore][JustFailed()],
            pstrExpr,
            pstrFile,
            line,
            hrTest));

    return hrTest;
}



//+---------------------------------------------------------------------------
//
//  Function:   CheckAndReturnResult
//
//  Synopsis:   Issues a warning if the HRESULT indicates failure, and asserts
//              if the HRESULT is not a permitted success code.
//
//  Arguments:  [hr]        -- the HRESULT to be checked.
//              [pstrFile]  -- the file where the HRESULT is being checked.
//              [line]      -- the line in the file where the HRESULT is
//                                  being checked.
//              [cSuccess]  -- the number of permitted non-zero success codes
//                               or failure SCODES that should not be traced.
//              [...]       -- list of HRESULTS.
//
//  Returns:    The return value is exactly the HRESULT passed in.
//
//  Notes:      This function should not be used directly.  Use
//              the SRETURN and RRETURN macros instead.
//
// HRESULTs passed in should either be permitted success codes, permitted
// non-OLE error codes, or expected OLE error codes.  Expected OLE error codes
// prevent a warning from being printed to the debugger, while the rest cause
// asserts if they're not given as an argument.
//
// An OLE error code has a facility not equal to FACILITY_ITF or is equal to
// FACILITY_ITF and the code is less than 0x200.
//
//----------------------------------------------------------------------------

STDAPI
CheckAndReturnResult(
        HRESULT hr,
        BOOL    fTrace,
        LPSTR   pstrFile,
        UINT    line,
        int     cHResult,
        ...)
{
    BOOL    fOLEError;
    BOOL    fOKReturnCode;
    va_list va;
    int     i;
    HRESULT hrArg;

    //
    // Check if code is a permitted error or success.
    //

    fOLEError = (hr < 0 &&
                 (HRESULT_FACILITY(hr) != FACILITY_ITF ||
                  HRESULT_CODE(hr) < 0x0200));

    fOKReturnCode = ((cHResult == -1) || fOLEError || (hr == S_OK));

    if (cHResult > 0)
    {
        va_start(va, cHResult);
        for (i = 0; i < cHResult; i++)
        {
            hrArg = va_arg(va, HRESULT);
            if (hr == hrArg)
            {
                fOKReturnCode = TRUE;

                if (fOLEError)
                    fTrace = FALSE;

                va_end(va);
                break;
            }
        }

        va_end(va);
    }

    //
    // Assert on non-permitted success code.
    //

    if (!fOKReturnCode)
    {
        TraceTag((
                tagError,
                "%s:%d returned unpermitted HRESULT %hr",
                pstrFile,
                line,
                hr));

        Assert("An unpermitted success code was returned." && hr <= 0);
        Assert("An unpermitted FACILITY_ITF HRESULT was returned." &&
                !(HRESULT_FACILITY(hr) == FACILITY_ITF && HRESULT_CODE(hr) >= 0x0200));
    }

    //
    // Warn on error result.
    //

    if (fTrace && FAILED(hr))
    {
        TraceTagEx((
                tagRRETURN,
                0,
                "RRETURN: %s:%d returned %hr",
                pstrFile,
                line,
                hr));
    }

    return hr;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\apeldbg\pure_api.c ===
/*
 * Header file of Pure API function declarations.
 *
 * Explicitly no copyright.
 * You may recompile and redistribute these definitions as required.
 *
 * NOTE: In some situations when compiling with MFC, you should
 *       enable the setting 'Not using precompiled headers' in Visual C++
 *       to avoid a compiler diagnostic.
 *
 * NOTE: This file works through the use of deep magic.  Calls to functions
 *       in this file are replaced with calls into the OCI runtime system
 *       when an instrumented version of this program is run.
 */
#if DEVELOPER_DEBUG

__declspec(dllexport) int __cdecl PurePrintf(const char *fmt, ...) { return 0; }
__declspec(dllexport) int __cdecl PurifyIsRunning(void) { return 0; }
__declspec(dllexport) int __cdecl PurifyPrintf(const char *fmt, ...) { return 0; }
__declspec(dllexport) int __cdecl PurifyNewInuse(void) { return 0; }
__declspec(dllexport) int __cdecl PurifyAllInuse(void) { return 0; }
__declspec(dllexport) int __cdecl PurifyClearInuse(void) { return 0; }
__declspec(dllexport) int __cdecl PurifyNewLeaks(void) { return 0; }
__declspec(dllexport) int __cdecl PurifyAllLeaks(void) { return 0; }
__declspec(dllexport) int __cdecl PurifyClearLeaks(void) { return 0; }
__declspec(dllexport) int __cdecl PurifyAllHandlesInuse(void) { return 0; }
__declspec(dllexport) int __cdecl PurifyNewHandlesInuse(void) { return 0; }
__declspec(dllexport) int __cdecl PurifyDescribe(void *addr) { return 0; }
__declspec(dllexport) int __cdecl PurifyWhatColors(void *addr, int size) { return 0; }
__declspec(dllexport) int __cdecl PurifyAssertIsReadable(const void *addr, int size) { return 1; }
__declspec(dllexport) int __cdecl PurifyAssertIsWritable(const void *addr, int size) { return 1; }
__declspec(dllexport) int __cdecl PurifyIsReadable(const void *addr, int size) { return 1; }
__declspec(dllexport) int __cdecl PurifyIsWritable(const void *addr, int size) { return 1; }
__declspec(dllexport) int __cdecl PurifyIsInitialized(const void *addr, int size) { return 1; }
__declspec(dllexport) int __cdecl PurifyRed(void *addr, int size) { return 0; }
__declspec(dllexport) int __cdecl PurifyGreen(void *addr, int size) { return 0; }
__declspec(dllexport) int __cdecl PurifyYellow(void *addr, int size) { return 0; }
__declspec(dllexport) int __cdecl PurifyBlue(void *addr, int size) { return 0; }
__declspec(dllexport) int __cdecl PurifyMarkAsInitialized(void *addr, int size) { return 0; }
__declspec(dllexport) int __cdecl PurifyMarkAsUninitialized(void *addr, int size) { return 0; }
__declspec(dllexport) int __cdecl PurifyMarkForTrap(void *addr, int size) { return 0; }
__declspec(dllexport) int __cdecl PurifyMarkForNoTrap(void *addr, int size) { return 0; }
__declspec(dllexport) int __cdecl PurifyHeapValidate(unsigned int hHeap, unsigned int dwFlags, const void *addr) { return 1; }
__declspec(dllexport) int __cdecl PurifySetLateDetectScanCounter(int counter) { return 0; };
__declspec(dllexport) int __cdecl PurifySetLateDetectScanInterval(int seconds) { return 0; };
__declspec(dllexport) int __cdecl QuantifyIsRunning(void) { return 0; }
__declspec(dllexport) int __cdecl QuantifyDisableRecordingData(void) { return 0; }
__declspec(dllexport) int __cdecl QuantifyStartRecordingData(void) { return 0; }
__declspec(dllexport) int __cdecl QuantifyStopRecordingData(void) { return 0; }
__declspec(dllexport) int __cdecl QuantifyClearData(void) { return 0; }
__declspec(dllexport) int __cdecl QuantifyIsRecordingData(void) { return 0; }
__declspec(dllexport) int __cdecl QuantifyAddAnnotation(char *str) { return 0; }
__declspec(dllexport) int __cdecl QuantifySaveData(void) { return 0; }

#endif // DEVELOPER_DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\apeldbg\w4warn.h ===
/*----------------------------------------------------------------------------
*  Note that we don't want to use a single line comment before the warning is
*   disabled.
*
*   Microsoft Windows
*   Copyright (C) Microsoft Corporation, 1992 - 1994.
*
*   File:       w4warn.h
*
*   Contents:   #pragmas to adjust warning levels.
*
*---------------------------------------------------------------------------*/

/*
 *   Level 4 warnings to suppress.
 */

#pragma warning(disable:4001) /* nonstandard extension 'extension' was used                            */
#pragma warning(disable:4097) /* typedef name 'type' used as synonym for class 'class'                 */
#pragma warning(disable:4100) /* unreferenced formal parameter                                         */
#pragma warning(disable:4134) /* conversion between pointers to members of same class                  */
#pragma warning(disable:4152) /* nonstandard extension, function/data pointer conversion in expression */
#pragma warning(disable:4200) /* nonstandard extension used : zero-sized array in struct/union         */
#pragma warning(disable:4201) /* nonstandard extension used : nameless struct/union                    */
#pragma warning(disable:4204) /* nonstandard extension used : non-constant aggregate initializer       */
#pragma warning(disable:4209) /* nonstandard extension used : benign typedef redefinition              */
#pragma warning(disable:4214) /* nonstandard extension used : bit field types other than int           */
#pragma warning(disable:4505) /* unreferenced local function has been removed                          */
#pragma warning(disable:4511) /* 'class' : copy constructor could not be generated                     */
#pragma warning(disable:4512) /* 'class': assignment operator could not be generated                   */
#pragma warning(disable:4514) /* 'function' : unreferenced inline function has been removed            */
#pragma warning(disable:4710) /* function call not expanded                                            */
/*
 * Warning 4244 is benign more often than not, so if you don't want it then
 * uncomment this to filter out those errors.
 *
 */
#ifdef NEVER
#pragma warning(disable:4244) /* conversion from 'type' to 'type', possible loss of data               */
#endif

/*
 * This helps to track down "Illegal attempt to instantiate abstract class" messages
 */

#pragma warning(error:4259) /* pure virtual function not defined                                       */

/*
 *   Level 4 warnings that we want treated as level 3 warnings.
 */

//
// Leave 4127 at level 4.  Folks are doing things like ASSERT(FALSE) which
// triggers this warning.
//
// #pragma warning(3:4127) /* conditional expression is constant                                          */
//

#pragma warning(3:4702) /* unreachable code                                                            */
#pragma warning(3:4706) /* assignment within conditional expression                                    */

#pragma warning(disable:4041) /* compiler limit reached: terminating browser output                    */

#ifdef _MAC
#pragma warning(disable:4229) /* anachronism used : modifiers on data are ignored                      */
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\apeldbg\resource.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1993 - 1993.
//
//  File:       resource.h
//
//  History:    10-06-93   ErikGav   Created
//
//----------------------------------------------------------------------------


#define tmcOk                   IDOK
#define tmcCancel               IDCANCEL
#define tmcStatic               -1
#define tmcListbox              101
#define tmcEnabled              102
#define tmcDisk                 103
#define tmcCom1                 104
#define tmcBreak                105
#define tmcNative               106
#define tmcEnableAll            107
#define tmcDisableAll           108

// Simulate failure dialog resources
#define IDD_SIMFAIL                 200
#define ID_LBLFAIL                  201
#define ID_TXTFAIL                  202
#define ID_LBLINTERVAL              203
#define ID_TXTINTERVAL              204
#define ID_LBLCOUNT                 205
#define ID_TXTCOUNT                 206
#define ID_BTNRESET                 207
#define ID_BTNNEVER                 208
#define ID_BTNUPDATE                209
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\apeldbg\win2mac.h ===
//*******************************************************************
//
//
//                win2mac.h
//
//                Compatability transforms
//
//
//
//*******************************************************************
#ifndef _WIN2MAC_H_
#define _WIN2MAC_H_

#ifndef _MAC

#define REGISTERDRAGDROP    RegisterDragDrop 
#define DODRAGDROP          DoDragDrop 
#define REVOKEDRAGDROP      RevokeDragDrop 

#define BYTESWAPLONG(ul)                ul
#define BYTESWAPLONGPTR(pul)        pul
#define BYTESWAPDWORD(dw)                dw
#define BYTESWAPDWORDPTR(pdw)        pdw
#define BYTESWAPSHORT(us)                us
#define BYTESWAPWORD(w)                        w
#define BYTESWAPWORDPTR(pw)                pw
#define BYTESWAPINT(i)                        i
#define BYTESWAPINTPTR(pi)                pi
#define BYTESWAPCLSID(cl)                cl
#define BYTESWAPDISPID(l)                l

#define PROP_DESC_BYTESWAPCLSID
#define PROP_DESC_NOBYTESWAP
#define PROP_DESC_BYTESWAPLONG        
#define PROP_DESC_BYTESWAPSHORT        
#define PROP_DESC_BYTESWAPPOINTL        
#define PROP_DESC_BYTESWAPRECTL
#define PROP_DESC_BYTESWAPSIZEL        
#define PROP_DESC_BYTESWAP2INTS

#else // _MAC

#define REGISTERDRAGDROP    MacRegisterDragDrop 
#define DODRAGDROP          MacDoDragDrop 
#define REVOKEDRAGDROP      MacRevokeDragDrop 


ULONG MacByteSwapLong ( ULONG ul);
#define BYTESWAPLONG(ul)                MacByteSwapLong(ul)
#define BYTESWAPLONGPTR(pul)        MacByteSwapDWordPtr(pul)
#define BYTESWAPDWORD(dw)                MacByteSwapLong(dw)
#define BYTESWAPDWORDPTR(pdw)        MacByteSwapDWordPtr(pdw)
#define BYTESWAPINT(i)                        MacByteSwapLong(i)
#define BYTESWAPINTPTR(pi)                MacByteSwapDWordPtr(pi)

WORD MacByteSwapWord (WORD w);
#define BYTESWAPSHORT(us)                MacByteSwapWord(us)
#define BYTESWAPWORD(w)                        MacByteSwapWord(w)

CLSID MacByteSwapClsID (CLSID id);
#define BYTESWAPCLSID(id)                MacByteSwapClsID(id)
#define BYTESWAPDISPID(id)                MacByteSwapLong(id)


void *MacByteSwapClsIDPtr (void *id);
void *MacByteSwapDWordPtr (void *pdw);
void *MacByteSwapWordPtr (void *pw);
void *MacByteSwapPOINTLPtr (void *pw);
void *MacByteSwapRECTLPtr (void *prectl);
void *MacByteSwapSIZELPtr (void *psizel);
void *MacByteSwap2IntsPtr (void *pui);

//
//        the following macros are used in the PROP_DESC
//        structure to implement custom byteswaping of 
//        WPI_USERDEFINED structures.
//
#define PROP_DESC_BYTESWAPCLSID ,MacByteSwapClsIDPtr
#define PROP_DESC_NOBYTESWAP        ,NULL
#define PROP_DESC_BYTESWAPLONG        ,MacByteSwapDWordPtr
#define PROP_DESC_BYTESWAPSHORT        ,MacByteSwapWordPtr
#define PROP_DESC_BYTESWAPPOINTL , MacByteSwapPOINTLPtr        
#define PROP_DESC_BYTESWAPRECTL        ,MacByteSwapRECTLPtr
#define PROP_DESC_BYTESWAPSIZEL        ,MacByteSwapSIZELPtr
#define PROP_DESC_BYTESWAP2INTS        ,MacByteSwap2IntsPtr


extern TCHAR g_szCodeFragName[]; // defined in win2mac.cxx

inline STDMETHODIMP IUnknown::DummyMethodForMacInterface(void)
{
    Assert(0 && "DummyMethodForMacInterface should never be executed\n");
        return S_OK;
}


#define GetProcessHeap() (HANDLE)1
// the following functions are not defined for Macintosh
//
extern "C" {
LONG
APIENTRY
RegCloseKey ( HKEY hKey );
}
#define RegOpenKey                RegOpenKeyA
#define RegDeleteKey        RegDeleteKeyA
#define RegEnumKey                RegEnumKeyA
#define RegQueryValue        RegQueryValueA
#define RegQueryValueEx RegQueryValueExA
#define RegSetValue                RegSetValueA

/****** Default Memory Allocation ******************************************/
/*
WINOLEAPI_(LPVOID) CoTaskMemAlloc(ULONG cb);
WINOLEAPI_(void)   CoTaskMemFree(LPVOID pv);
*/

#ifdef SysStringByteLen
#undef SysStringByteLen
#endif
#define SysStringByteLen SysStringLen

#ifdef SysAllocStringByteLen
#undef SysAllocStringByteLen
#endif
#define SysAllocStringByteLen SysAllocStringLen


WINOLEAPI  MacRegisterDragDrop (    HWND hwnd, 
                                    LPDROPTARGET pDropTarget);
WINOLEAPI  MacRevokeDragDrop (HWND hwnd);
WINOLEAPI  MacDoDragDrop (  LPDATAOBJECT    pDataObj,
                            LPDROPSOURCE    pDropSource,
                            DWORD           dwOKEffects,
                            LPDWORD         pdwEffect);

// a utility function to simulate right/middle buttons on the mac
UINT MacSimulateMouseButtons (UINT msg);

#endif // _MAC


#endif // _WIN2MAC_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\apeldbg\_apeldbg.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1993 - 1993.
//
//  File:       _apeldbg.h
//
//  Contents:   Misc internal debug definitions.
//
//----------------------------------------------------------------------------

#include "limits.h"

//
// Shared macros
//

typedef void *  PV;
typedef char    CHAR;

#define ARRAY_SIZE(a)   (sizeof(a) / sizeof(a[0]))

#ifdef tagError
#undef tagError
#endif

#ifdef tagLeakFilter
#undef tagLeakFilter
#endif

#ifdef tagHookMemory
#undef tagHookMemory
#endif

#ifdef tagHookBreak
#undef tagHookBreak
#endif

#ifdef tagLeaks
#undef tagLeaks
#endif

#ifdef tagCheckAlways
#undef tagCheckAlways
#endif

#ifdef tagCheckCRT
#undef tagCheckCRT
#endif

#ifdef tagDelayFree
#undef tagDelayFree
#endif

#define tagNull     ((TAG) 0)
#define tagMin      ((TAG) 1)
#define tagMax      ((TAG) 512)



/*
 *  TGTY
 *
 *  Tag type.  Possible values:
 *
 *      tgtyTrace       Trace points
 *      tgtyOther       Other TAG'd switch
 */

typedef int TGTY;

#define tgtyNull    0
#define tgtyTrace   1
#define tgtyOther   2

/*
 *  Flags in TGRC that are written to disk.
 */

enum TGRC_FLAG
{
    TGRC_FLAG_VALID =   0x00000001,
    TGRC_FLAG_DISK =    0x00000002,
    TGRC_FLAG_COM1 =    0x00000004,
    TGRC_FLAG_BREAK =   0x00000008,
#ifdef _MAC
    TGRC_FLAG_MAX =     LONG_MAX    // needed to force enum to be dword
#endif

};

#define TGRC_DEFAULT_FLAGS (TGRC_FLAG_VALID | TGRC_FLAG_COM1)

/*
 *  TGRC
 *
 *  Tag record.  Gives the current state of a particular TAG.
 *  This includes enabled status, owner and description, and
 *  tag type.
 *
 */

struct TGRC
{
    /* For trace points, enabled means output will get sent */
    /* to screen or disk.  For native/pcode switching, enabled */
    /* means the native version will get called. */

    BOOL    fEnabled;

    DWORD   ulBitFlags;     /* Flags */
    CHAR *  szOwner;        /* Strings passed at init ... */
    CHAR *  szDescrip;
    TGTY    tgty;           /* TAG type */

    BOOL    TestFlag(TGRC_FLAG mask)
                { return (ulBitFlags & mask) != 0; }
    void    SetFlag(TGRC_FLAG mask)
                { (ULONG&) ulBitFlags |= mask; }
    void    ClearFlag(TGRC_FLAG mask)
                { (ULONG&) ulBitFlags &= ~mask; }
    void    SetFlagValue(TGRC_FLAG mask, BOOL fValue)
                { fValue ? SetFlag(mask) : ClearFlag(mask); }
};


//
// Shared globals
//

extern CRITICAL_SECTION     g_csTrace;
extern CRITICAL_SECTION     g_csResDlg;
extern BOOL                 g_fInit;
extern HINSTANCE            g_hinstMain;
extern HWND                 g_hwndMain;
extern TGRC                 mptagtgrc[];

extern TAG  tagLeaks;
extern TAG  tagMagic;
extern TAG  tagTestFailures;
extern TAG  tagRRETURN;
extern TAG  tagAssertPop;
extern TAG  tagError;
extern TAG  tagLeakFilter;
extern TAG  tagHookMemory;
extern TAG  tagHookBreak;
extern TAG  tagMac;
extern TAG  tagIWatch;
extern TAG  tagIWatch2;
extern TAG  tagReadMapFile;
extern TAG  tagCheckAlways;
extern TAG  tagCheckCRT;
extern TAG  tagDelayFree;

extern int  g_cFFailCalled;
extern int  g_firstFailure;
extern int  g_cInterval;

//
//  Shared function prototypes
//

BOOL            JustFailed();

VOID            SaveDefaultDebugState( void );
void            RestoreDefaultDebugState(void);
BOOL            IsTagEnabled(TAG tag);

BOOL            MapAddressToFunctionOffset(LPBYTE pbAddr, LPSTR * ppstr, int * pib);
int             GetStackBacktrace(int iStart, int cTotal, DWORD * pdwEip);


int             hrvsnprintf(char * achBuf, int cchBuf, const char * pstrFmt, va_list valMarker);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\apelutil\headers.h ===
/*******************************************************************************

Copyright (c) 1995_96 Microsoft Corporation

Abstract:

    {Insert General Comment Here}

*******************************************************************************/


#ifndef _HEADERS_H
#define _HEADERS_H

#include <windows.h>

#include <stdio.h>
#include <io.h>
#include <stddef.h>
#include <stdlib.h>
#ifndef _NO_CRT
#include <fstream.h>
#include <iostream.h>
#include <ostream.h>
#include <ctype.h>
#endif
#include <string.h>
#include <malloc.h>
#include <memory.h>
#include <apeldbg.h>

// Warning 4114 (same type qualifier used more than once) is sometimes
// incorrectly generated.  See PSS ID Q138752.
#pragma warning(disable:4114)

// Warning 4786 (identifier was truncated to 255 chars in the browser
// info) can be safely disabled, as it only has to do with generation
// of browsing information.
#pragma warning(disable:4786)

#endif /* _HEADERS_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\apelutil\msgfltr.cpp ===
/*******************************************************************************

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    {Insert General Comment Here}

*******************************************************************************/


#include "headers.h"
#include "danim.h"
#include "axadefs.h"
#include "apelutil.h"

DeclareTag(tagKeyTrace, "Message Filter", "key trace");
DeclareTag(tagMouseTrace, "Message Filter", "mouse trace");

inline BYTE
GetModifiers()
{
    BYTE mod = AXAEMOD_NONE ;

    if (GetKeyState(VK_SHIFT) & 0x8000) mod |= AXAEMOD_SHIFT_MASK ;
    if (GetKeyState(VK_CONTROL) & 0x8000) mod |= AXAEMOD_CTRL_MASK ;
    if (GetKeyState(VK_MENU) & 0x8000) mod |= AXAEMOD_MENU_MASK ;

    return mod ;
}

AXAMsgFilter::AXAMsgFilter()
: _view(NULL),
  _hwnd(NULL),
  _lastKeyMod(0),
  _lastKey(0),
  _curtime(0.0),
  _lasttick(0),
  _left(0),
  _top(0),
  _site(NULL)
{
}

AXAMsgFilter::AXAMsgFilter(IDA3View * v, HWND hwnd)
: _view(v),
  _hwnd(hwnd),
  _lastKeyMod(0),
  _lastKey(0),
  _curtime(0.0),
  _lasttick(0),
  _left(0),
  _top(0),
  _site(NULL)
{
}

AXAMsgFilter::AXAMsgFilter(IDA3View * v, IOleInPlaceSiteWindowless * site)
: _view(v),
  _hwnd(NULL),
  _lastKeyMod(0),
  _lastKey(0),
  _curtime(0.0),
  _lasttick(0),
  _left(0),
  _top(0),
  _site(site)
{
    if (_site) _site->AddRef();
}

AXAMsgFilter::~AXAMsgFilter()
{
    if (_site) _site->Release();
}

bool
AXAMsgFilter::Filter(DWORD dwMsgtime,
                     UINT msg,
                     WPARAM wParam,
                     LPARAM lParam)
{
    return Filter (ConvertMsgTime(dwMsgtime),msg,wParam,lParam) ;
}


bool
AXAMsgFilter::Filter (double when,
                      UINT msg,
                      WPARAM wParam,
                      LPARAM lParam)
{
    if (!_view) return false;
    
    switch (msg) {
      case WM_MOUSEMOVE:
        _view->OnMouseMove(when,
                           LOWORD(lParam) - _left,
                           HIWORD(lParam) - _top,
                           GetModifiers()) ; 
        break;
            
      case WM_LBUTTONDOWN:
      case WM_LBUTTONDBLCLK:
        _view->OnMouseButton(when,
                             LOWORD(lParam) - _left,
                             HIWORD(lParam) - _top,
                             AXA_MOUSE_BUTTON_LEFT,
                             AXA_STATE_DOWN,
                             GetModifiers()) ;
        if (_hwnd) SetCapture(_hwnd);
        if (_site) THR(_site->SetCapture(TRUE));
        break ;

      case WM_LBUTTONUP:
        _view->OnMouseButton(when,
                             LOWORD(lParam) - _left,
                             HIWORD(lParam) - _top,
                             AXA_MOUSE_BUTTON_LEFT,
                             AXA_STATE_UP,
                             GetModifiers()) ;
        if (_hwnd) ReleaseCapture();
        if (_site) THR(_site->SetCapture(FALSE));
        break ;

      case WM_MBUTTONDOWN:
      case WM_MBUTTONDBLCLK:
        _view->OnMouseButton(when,
                             LOWORD(lParam) - _left,
                             HIWORD(lParam) - _top,
                             AXA_MOUSE_BUTTON_MIDDLE,
                             AXA_STATE_DOWN,
                             GetModifiers()) ;
        if (_hwnd) SetCapture(_hwnd);
        if (_site) THR(_site->SetCapture(TRUE));
        break ;

      case WM_MBUTTONUP:
        _view->OnMouseButton(when,
                             LOWORD(lParam) - _left,
                             HIWORD(lParam) - _top,
                             AXA_MOUSE_BUTTON_MIDDLE,
                             AXA_STATE_UP,
                             GetModifiers()) ;
        if (_hwnd) ReleaseCapture();
        if (_site) THR(_site->SetCapture(FALSE));
        break ;

      case WM_RBUTTONDOWN:
      case WM_RBUTTONDBLCLK:
        _view->OnMouseButton(when,
                             LOWORD(lParam) - _left,
                             HIWORD(lParam) - _top,
                             AXA_MOUSE_BUTTON_RIGHT,
                             AXA_STATE_DOWN,
                             GetModifiers()) ;
        if (_hwnd) SetCapture(_hwnd);
        if (_site) THR(_site->SetCapture(TRUE));
        break ;
            
      case WM_RBUTTONUP:
        _view->OnMouseButton(when,
                             LOWORD(lParam) - _left,
                             HIWORD(lParam) - _top,
                             AXA_MOUSE_BUTTON_RIGHT,
                             AXA_STATE_UP,
                             GetModifiers()) ;
        if (_hwnd) ReleaseCapture();
        if (_site) THR(_site->SetCapture(FALSE));
        break ;
            
      case WM_KEYDOWN:
      case WM_SYSKEYDOWN:
        {
            TraceTag((tagKeyTrace,
                      "KeyDown: lParam - 0x%x, wParam - 0x%x",
                      lParam, wParam));

            WORD wKeyData = HIWORD(lParam) ;

            // Ignore repeat key event

            if (wKeyData & KF_REPEAT)
                return FALSE;

            // See if we got a keydown before a keyup for the last
            // known keydown
            ReportKeyup (when) ;
            
            // Get current key modifiers
            BYTE mod = GetModifiers () ;
            DWORD key ;
            
            // Check to see if the virtual key is one of the special keys
            if (AXAIsSpecialVK(wParam)) {
                key = VK_TO_AXAKEY((DWORD)wParam);  //for win64, explicitly truncate to 32 bits

            } else {
                // Call ToAscii to translate the key for us
                // TODO: Need to make sure this works like we expect

                BYTE kbstate[256] ;

                if (!GetKeyboardState (kbstate)) {
                    Assert (FALSE && "Could not get keyboard state") ;
                    return FALSE ;
                }
                    
                // - problem is that ctrl-?? gets ignored since it is
                // not a valid character - one possible solution is to
                // change the keyboard state passed to the function to
                // not have ctrl or alt set (but leaving shift)
                
                kbstate[VK_CONTROL] = 0 ;
                kbstate[VK_MENU] = 0 ;
                kbstate[VK_LCONTROL] = 0 ;
                kbstate[VK_RCONTROL] = 0 ;
                kbstate[VK_LMENU] = 0 ;
                kbstate[VK_RMENU] = 0 ;
                
                // Must init to 0 since we only want one characters
                
                WORD buf = 0 ;

                if (ToAscii ((UINT) wParam,
                             wKeyData & 0x00ff,
                             kbstate,
                             &buf,
                             (wKeyData & KF_MENUMODE)?1:0) != 1)
                    return FALSE ;
                
                // Ensure we only take the low order character
                
                key = buf & 0xff ;
            }

            TraceTag((tagKeyTrace,
                      "KeyDown: 0x%x", key));

            _view->OnKey (when,
                          key,
                          AXA_STATE_DOWN,
                          mod) ;

            _lastKey = key ;
            _lastKeyMod = mod ;
            
            break;
        }

      case WM_KEYUP:
      case WM_SYSKEYUP:
        TraceTag((tagKeyTrace,
                  "KeyUp: lParam - 0x%x, wParam - 0x%x",
                  lParam, wParam));

        ReportKeyup (when) ;
        break ;
        
      case WM_KILLFOCUS:
        _view->OnFocus (FALSE) ;
        ReportKeyup (when) ;
        break ;
        
      case WM_SETFOCUS:
        _view->OnFocus (TRUE) ;
        break ;
        
      case WM_PAINT:
        {
            if (_hwnd) {
                PAINTSTRUCT ps;
                BeginPaint (_hwnd, &ps) ;
                
                _view->RePaint (ps.rcPaint.left, ps.rcPaint.top,
                                (ps.rcPaint.right - ps.rcPaint.left + 1),
                                (ps.rcPaint.bottom - ps.rcPaint.top + 1)) ;
                
                EndPaint (_hwnd, &ps) ;
            }
        }
        break;
      case WM_SIZE:
        _view->SetViewport (0,0,LOWORD(lParam), HIWORD(lParam)) ;
        break ;
            
      case WM_QUERYNEWPALETTE:
        _view->PaletteChanged (TRUE) ;
        break ;
        
      case WM_PALETTECHANGED:
        if (_hwnd == (HWND) wParam)
            return FALSE ;
        
        _view->PaletteChanged (FALSE) ;
        break ;

#ifdef WM_MOUSELEAVE
      case WM_MOUSELEAVE:
        _view->OnMouseLeave(when);
        break;
#endif
        
      default:
        return false ;
    }

    return true ;
}

void
AXAMsgFilter::ReportKeyup (double when, BOOL bReset)
{
    if (_lastKey != 0) {
        _view->OnKey (when,
                      _lastKey,
                      AXA_STATE_UP,
                      _lastKeyMod) ;

        _lastKey = 0 ;
    }
}

double
AXAMsgFilter::GetCurTime() 
{
    if (_curtime == 0.0 && _lasttick == 0) {
        _lasttick = GetTickCount () ;
    } else {
        DWORD curtick = GetTickCount () ;
        
        if (curtick >= _lasttick) {
            _curtime += ((double) (curtick - _lasttick)) / 1000 ;
        } else {
            _curtime += ((double) (curtick + (0xffffffff - _lasttick))) / 1000 ;
        }

        _lasttick = curtick ;
    }

    return _curtime;
}

double
AXAMsgFilter::ConvertMsgTime (DWORD msgtime)
{
    // Ensure the updated time is after the message time to properly
    // detect wrap around
    
    GetCurTime();
    
    // Code to take care wrap around, which happens every 50 days.

    if (msgtime <= _lasttick)
        return (_curtime -
                ((double) (_lasttick - msgtime)) / 1000) ;
    else
        return (_curtime -
                ((double) (_lasttick + (0xffffffff - msgtime))) / 1000) ;
}

void
AXAMsgFilter::SetViewOrigin(unsigned short left, unsigned short top)
{
    _left = left;
    _top = top;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\project.inc ===
# project.inc - project specific settings

APPEL_INC_DIRS=$(SDKDIR) $(TOOLSINCLUDE) $(ATLINCLUDE) $(SRCROOT)\appel\include $(SRCROOT)\appel $(SRCROOT)\include
_USERCFLAGS=$(_USERCFLAGS) /DNDEBUG /DOS_WIN_NT_3_5 /DNOMINMAX
!if "$(_DEBUG)" == "1"
_USERCFLAGS=$(_USERCFLAGS) /GR
!endif
_NO_INCREMENTAL_LINK=1
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\api\apiprims.h ===
/*******************************************************************************

Copyright (c) 1995_96 Microsoft Corporation

Abstract:

    {Insert General Comment Here}

*******************************************************************************/


#ifndef _APIPRIMS_H
#define _APIPRIMS_H

#if DEVELOPER_DEBUG
extern DWORD CRConnectCount();
#endif

// Should assert that CRCount is greater than 0

#define APIPRECODEGEN1(x1,x2) \
    x1;     \
    __try { \
    x2;

#define APIPOSTCODEGEN1 \
    } __except ( HANDLE_ANY_DA_EXCEPTION ) { }


#define APIPRECODE  APIPRECODEGEN1(DynamicHeapPusher __dhp (GetGCHeap()), 0)
#define APIPOSTCODE APIPOSTCODEGEN1

#define APIVIEWPRECODE APIPRECODEGEN1(0,0)
#define APIVIEWPOSTCODE APIPOSTCODEGEN1

#define APIVIEWPRECODE_NOLOCK(v) APIPRECODEGEN1(ViewPusher __vp(v), 0)
#define APIVIEWPOSTCODE_NOLOCK(v) APIPOSTCODEGEN1
        
#define APIVIEWPRECODE_LOCK(v) APIPRECODEGEN1(ViewPusher __vp(v,true), 0)
#define APIVIEWPOSTCODE_LOCK(v) APIPOSTCODEGEN1

#define APIVIEWPRECODE_RENDERLOCK(v) \
        APIPRECODEGEN1(ViewPusher __vp(v,true,true), __vp.CheckLock();)
#define APIVIEWPOSTCODE_RENDERLOCK(v) APIPOSTCODEGEN1
        
#endif /* _APIPRIMS_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\api\conv.h ===
/*******************************************************************************

Copyright (c) 1995_96 Microsoft Corporation

Abstract:

    {Insert General Comment Here}

*******************************************************************************/


#ifndef _CONV_H
#define _CONV_H

#include "backend/jaxaimpl.h"

inline Bvr StringToBvr(WideString str) {
    return ConstBvr(NEW AxAString(str)) ;
}

inline Bvr BoolToBvr(bool b) {
    return ConstBvr(NEW AxABoolean(b)) ;
}

inline Bvr DoubleToNumBvr(double d) {
    return NumToBvr(d);
}

inline Bvr RGBToNumBvr(short rbg) {
    return NumToBvr (((double) CLAMP(rbg,0,255)) / 255.0);
}

inline Bvr PointToNumBvr(double d) {
    return DoubleToNumBvr (d * METERS_PER_POINT);
}

UntilNotifier WrapUntilNotifier(CRUntilNotifierPtr un);

inline Bvr LPWSTRToStrBvr(LPWSTR b) {
    return ConstBvr(NEW AxAString(b));
}

inline Bvr VARIANTToVariantBvr(VARIANT v) {
    return ConstBvr(NEW AxAVariant(v));
}

double ExtractNum(Bvr num);
WideString ExtractString(Bvr str);
bool ExtractBool(Bvr b);

extern AxAValue GetConstVal(Bvr b);
#define GETCONSTBVR(type, bvr) SAFE_CAST(class type, GetConstVal(bvr))

DXMTypeInfo GetTypeInfoFromTypeId(CR_BVR_TYPEID tid);

#if DEVELOPER_DEBUG
void CheckBvrParam(void *);
void CheckPtrParam(void *);

#define CHECK_BVR_PARAM(x) (CheckBvrParam(x),(x))
#define CHECK_PTR_PARAM(x) (CheckPtrParam(x),(x))
#else
#define CHECK_BVR_PARAM(x) x
#define CHECK_PTR_PARAM(x) x
#endif

#endif /* _CONV_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\api\apigen.cpp ===
/*******************************************************************************
Copyright (c) 1995-1998 Microsoft Corporation.  All rights reserved.
*******************************************************************************/

#include "headers.h"
#include "apiprims.h"
#include "backend/values.h"
#include "backend/gc.h"
#include "backend/jaxaimpl.h"
#include "conv.h"
#include "privinc/vec2i.h"
#include "privinc/xform2i.h"

struct CRTypeMap {
    CR_BVR_TYPEID typeId;
    DXMTypeInfo * typeInfo;
};

Bvr
CreatePrim1(AxAPrimOp *fp , Bvr arg1)
{
    Bvr ret = NULL;

    APIPRECODE;
    Assert(fp);
    CHECK_PTR_PARAM(arg1);

    ret = PrimApplyBvr(fp, 1 , arg1);
    APIPOSTCODE;

    return ret;
}

Bvr
CreatePrim2(AxAPrimOp *fp , Bvr arg1, Bvr arg2)
{
    Bvr ret = NULL;

    APIPRECODE;
    Assert(fp);
    CHECK_PTR_PARAM(arg1);
    CHECK_PTR_PARAM(arg2);

    ret = PrimApplyBvr(fp, 2 , arg1, arg2);
    APIPOSTCODE;

    return ret;
}

Bvr
CreatePrim3(AxAPrimOp *fp , Bvr arg1, Bvr arg2, Bvr arg3)
{
    Bvr ret = NULL;

    APIPRECODE;
    Assert(fp);
    CHECK_PTR_PARAM(arg1);
    CHECK_PTR_PARAM(arg2);
    CHECK_PTR_PARAM(arg3);

    ret = PrimApplyBvr(fp, 3 , arg1, arg2, arg3);
    APIPOSTCODE;

    return ret;
}

Bvr
CreatePrim4(AxAPrimOp *fp , Bvr arg1, Bvr arg2, Bvr arg3, Bvr arg4)
{
    Bvr ret = NULL;

    APIPRECODE;
    Assert(fp);
    CHECK_PTR_PARAM(arg1);
    CHECK_PTR_PARAM(arg2);
    CHECK_PTR_PARAM(arg3);
    CHECK_PTR_PARAM(arg4);

    ret = PrimApplyBvr(fp, 4 , arg1, arg2, arg3, arg4);
    APIPOSTCODE;

    return ret;
}

extern AxANumber *RealPower    (AxANumber *a, AxANumber *b);
AxAPrimOp *RealPowerOp;
CRSTDAPI_(CRNumber *) CRPow(CRNumber * arg0, CRNumber * arg1)
{
    TraceTag((tagAPIEntry, "CRPow"));

    return (CRNumber *) CreatePrim2(RealPowerOp, arg0, arg1);
}

extern AxANumber *RealAbs     (AxANumber *a);
AxAPrimOp *RealAbsOp;
CRSTDAPI_(CRNumber *) CRAbs(CRNumber * arg0)
{
    TraceTag((tagAPIEntry, "CRAbs"));

    return (CRNumber *) CreatePrim1(RealAbsOp, arg0);
}

extern AxANumber *RealSqrt    (AxANumber *a);
AxAPrimOp *RealSqrtOp;
CRSTDAPI_(CRNumber *) CRSqrt(CRNumber * arg0)
{
    TraceTag((tagAPIEntry, "CRSqrt"));

    return (CRNumber *) CreatePrim1(RealSqrtOp, arg0);
}

extern AxANumber *RealFloor   (AxANumber *a);
AxAPrimOp *RealFloorOp;
CRSTDAPI_(CRNumber *) CRFloor(CRNumber * arg0)
{
    TraceTag((tagAPIEntry, "CRFloor"));

    return (CRNumber *) CreatePrim1(RealFloorOp, arg0);
}

extern AxANumber *RealRound   (AxANumber *a);
AxAPrimOp *RealRoundOp;
CRSTDAPI_(CRNumber *) CRRound(CRNumber * arg0)
{
    TraceTag((tagAPIEntry, "CRRound"));

    return (CRNumber *) CreatePrim1(RealRoundOp, arg0);
}

extern AxANumber *RealCeiling (AxANumber *a);
AxAPrimOp *RealCeilingOp;
CRSTDAPI_(CRNumber *) CRCeiling(CRNumber * arg0)
{
    TraceTag((tagAPIEntry, "CRCeiling"));

    return (CRNumber *) CreatePrim1(RealCeilingOp, arg0);
}

extern AxANumber *RealAsin    (AxANumber *a);
AxAPrimOp *RealAsinOp;
CRSTDAPI_(CRNumber *) CRAsin(CRNumber * arg0)
{
    TraceTag((tagAPIEntry, "CRAsin"));

    return (CRNumber *) CreatePrim1(RealAsinOp, arg0);
}

extern AxANumber *RealAcos    (AxANumber *a);
AxAPrimOp *RealAcosOp;
CRSTDAPI_(CRNumber *) CRAcos(CRNumber * arg0)
{
    TraceTag((tagAPIEntry, "CRAcos"));

    return (CRNumber *) CreatePrim1(RealAcosOp, arg0);
}

extern AxANumber *RealAtan    (AxANumber *a);
AxAPrimOp *RealAtanOp;
CRSTDAPI_(CRNumber *) CRAtan(CRNumber * arg0)
{
    TraceTag((tagAPIEntry, "CRAtan"));

    return (CRNumber *) CreatePrim1(RealAtanOp, arg0);
}

extern AxANumber *RealSin     (AxANumber *a);
AxAPrimOp *RealSinOp;
CRSTDAPI_(CRNumber *) CRSin(CRNumber * arg0)
{
    TraceTag((tagAPIEntry, "CRSin"));

    return (CRNumber *) CreatePrim1(RealSinOp, arg0);
}

extern AxANumber *RealCos     (AxANumber *a);
AxAPrimOp *RealCosOp;
CRSTDAPI_(CRNumber *) CRCos(CRNumber * arg0)
{
    TraceTag((tagAPIEntry, "CRCos"));

    return (CRNumber *) CreatePrim1(RealCosOp, arg0);
}

extern AxANumber *RealTan     (AxANumber *a);
AxAPrimOp *RealTanOp;
CRSTDAPI_(CRNumber *) CRTan(CRNumber * arg0)
{
    TraceTag((tagAPIEntry, "CRTan"));

    return (CRNumber *) CreatePrim1(RealTanOp, arg0);
}

extern AxANumber *RealExp     (AxANumber *a);
AxAPrimOp *RealExpOp;
CRSTDAPI_(CRNumber *) CRExp(CRNumber * arg0)
{
    TraceTag((tagAPIEntry, "CRExp"));

    return (CRNumber *) CreatePrim1(RealExpOp, arg0);
}

extern AxANumber *RealLn      (AxANumber *a);
AxAPrimOp *RealLnOp;
CRSTDAPI_(CRNumber *) CRLn(CRNumber * arg0)
{
    TraceTag((tagAPIEntry, "CRLn"));

    return (CRNumber *) CreatePrim1(RealLnOp, arg0);
}

extern AxANumber *RealLog10   (AxANumber *a);
AxAPrimOp *RealLog10Op;
CRSTDAPI_(CRNumber *) CRLog10(CRNumber * arg0)
{
    TraceTag((tagAPIEntry, "CRLog10"));

    return (CRNumber *) CreatePrim1(RealLog10Op, arg0);
}

extern AxANumber *RealRadToDeg(AxANumber *a);
AxAPrimOp *RealRadToDegOp;
CRSTDAPI_(CRNumber *) CRToDegrees(CRNumber * arg0)
{
    TraceTag((tagAPIEntry, "CRToDegrees"));

    return (CRNumber *) CreatePrim1(RealRadToDegOp, arg0);
}

extern AxANumber *RealDegToRad(AxANumber *a);
AxAPrimOp *RealDegToRadOp;
CRSTDAPI_(CRNumber *) CRToRadians(CRNumber * arg0)
{
    TraceTag((tagAPIEntry, "CRToRadians"));

    return (CRNumber *) CreatePrim1(RealDegToRadOp, arg0);
}

extern AxANumber *RealModulus(AxANumber *a, AxANumber *b);
AxAPrimOp *RealModulusOp;
CRSTDAPI_(CRNumber *) CRMod(CRNumber * arg0, CRNumber * arg1)
{
    TraceTag((tagAPIEntry, "CRMod"));

    return (CRNumber *) CreatePrim2(RealModulusOp, arg0, arg1);
}

extern AxANumber *RealAtan2(AxANumber *a, AxANumber *b);
AxAPrimOp *RealAtan2Op;
CRSTDAPI_(CRNumber *) CRAtan2(CRNumber * arg0, CRNumber * arg1)
{
    TraceTag((tagAPIEntry, "CRAtan2"));

    return (CRNumber *) CreatePrim2(RealAtan2Op, arg0, arg1);
}

extern Bvr FirstBvr (Bvr);
CRSTDAPI_(CRBvr *) CRFirst(CRPair * arg0)
{
    TraceTag((tagAPIEntry, "CRFirst"));

    CRBvr * ret = NULL;

    APIPRECODE ;
    ret = (CRBvr *) (::FirstBvr((arg0)));
    APIPOSTCODE ;
    return ret;
}

extern Bvr SecondBvr (Bvr);
CRSTDAPI_(CRBvr *) CRSecond(CRPair * arg0)
{
    TraceTag((tagAPIEntry, "CRSecond"));

    CRBvr * ret = NULL;

    APIPRECODE ;
    ret = (CRBvr *) (::SecondBvr((arg0)));
    APIPOSTCODE ;
    return ret;
}

extern AxANumber *RealAdd      (AxANumber *a, AxANumber *b);
AxAPrimOp *RealAddOp;
CRSTDAPI_(CRNumber *) CRAdd(CRNumber * arg0, CRNumber * arg1)
{
    TraceTag((tagAPIEntry, "CRAdd"));

    return (CRNumber *) CreatePrim2(RealAddOp, arg0, arg1);
}

extern AxANumber *RealSubtract (AxANumber *a, AxANumber *b);
AxAPrimOp *RealSubtractOp;
CRSTDAPI_(CRNumber *) CRSub(CRNumber * arg0, CRNumber * arg1)
{
    TraceTag((tagAPIEntry, "CRSub"));

    return (CRNumber *) CreatePrim2(RealSubtractOp, arg0, arg1);
}

extern AxANumber *RealMultiply (AxANumber *a, AxANumber *b);
AxAPrimOp *RealMultiplyOp;
CRSTDAPI_(CRNumber *) CRMul(CRNumber * arg0, CRNumber * arg1)
{
    TraceTag((tagAPIEntry, "CRMul"));

    return (CRNumber *) CreatePrim2(RealMultiplyOp, arg0, arg1);
}

extern AxANumber *RealDivide   (AxANumber *a, AxANumber *b);
AxAPrimOp *RealDivideOp;
CRSTDAPI_(CRNumber *) CRDiv(CRNumber * arg0, CRNumber * arg1)
{
    TraceTag((tagAPIEntry, "CRDiv"));

    return (CRNumber *) CreatePrim2(RealDivideOp, arg0, arg1);
}

extern AxABoolean *RealLT       (AxANumber *a, AxANumber *b);
AxAPrimOp *RealLTOp;
CRSTDAPI_(CRBoolean *) CRLT(CRNumber * arg0, CRNumber * arg1)
{
    TraceTag((tagAPIEntry, "CRLT"));

    return (CRBoolean *) CreatePrim2(RealLTOp, arg0, arg1);
}

extern AxABoolean *RealLTE      (AxANumber *a, AxANumber *b);
AxAPrimOp *RealLTEOp;
CRSTDAPI_(CRBoolean *) CRLTE(CRNumber * arg0, CRNumber * arg1)
{
    TraceTag((tagAPIEntry, "CRLTE"));

    return (CRBoolean *) CreatePrim2(RealLTEOp, arg0, arg1);
}

extern AxABoolean *RealGT       (AxANumber *a, AxANumber *b);
AxAPrimOp *RealGTOp;
CRSTDAPI_(CRBoolean *) CRGT(CRNumber * arg0, CRNumber * arg1)
{
    TraceTag((tagAPIEntry, "CRGT"));

    return (CRBoolean *) CreatePrim2(RealGTOp, arg0, arg1);
}

extern AxABoolean *RealGTE      (AxANumber *a, AxANumber *b);
AxAPrimOp *RealGTEOp;
CRSTDAPI_(CRBoolean *) CRGTE(CRNumber * arg0, CRNumber * arg1)
{
    TraceTag((tagAPIEntry, "CRGTE"));

    return (CRBoolean *) CreatePrim2(RealGTEOp, arg0, arg1);
}

extern AxABoolean *RealEQ       (AxANumber *a, AxANumber *b);
AxAPrimOp *RealEQOp;
CRSTDAPI_(CRBoolean *) CREQ(CRNumber * arg0, CRNumber * arg1)
{
    TraceTag((tagAPIEntry, "CREQ"));

    return (CRBoolean *) CreatePrim2(RealEQOp, arg0, arg1);
}

extern AxABoolean *RealNE       (AxANumber *a, AxANumber *b);
AxAPrimOp *RealNEOp;
CRSTDAPI_(CRBoolean *) CRNE(CRNumber * arg0, CRNumber * arg1)
{
    TraceTag((tagAPIEntry, "CRNE"));

    return (CRBoolean *) CreatePrim2(RealNEOp, arg0, arg1);
}

extern AxANumber *RealNegate  (AxANumber *a);
AxAPrimOp *RealNegateOp;
CRSTDAPI_(CRNumber *) CRNeg(CRNumber * arg0)
{
    TraceTag((tagAPIEntry, "CRNeg"));

    return (CRNumber *) CreatePrim1(RealNegateOp, arg0);
}

extern Bvr InterpolateBvr (Bvr, Bvr, Bvr);
CRSTDAPI_(CRNumber *) CRInterpolate(CRNumber * arg0, CRNumber * arg1, CRNumber * arg2)
{
    TraceTag((tagAPIEntry, "CRInterpolate"));

    CRNumber * ret = NULL;

    APIPRECODE ;
    ret = (CRNumber *) (::InterpolateBvr((arg0), (arg1), (arg2)));
    APIPOSTCODE ;
    return ret;
}

extern Bvr InterpolateBvr (DoubleValue, DoubleValue, DoubleValue);
CRSTDAPI_(CRNumber *) CRInterpolate(double arg0, double arg1, double arg2)
{
    TraceTag((tagAPIEntry, "CRInterpolate"));

    CRNumber * ret = NULL;

    APIPRECODE ;
    ret = (CRNumber *) (::InterpolateBvr(DoubleToNumBvr(arg0), DoubleToNumBvr(arg1), DoubleToNumBvr(arg2)));
    APIPOSTCODE ;
    return ret;
}

extern Bvr SlowInSlowOutBvr (Bvr, Bvr, Bvr, Bvr);
CRSTDAPI_(CRNumber *) CRSlowInSlowOut(CRNumber * arg0, CRNumber * arg1, CRNumber * arg2, CRNumber * arg3)
{
    TraceTag((tagAPIEntry, "CRSlowInSlowOut"));

    CRNumber * ret = NULL;

    APIPRECODE ;
    ret = (CRNumber *) (::SlowInSlowOutBvr((arg0), (arg1), (arg2), (arg3)));
    APIPOSTCODE ;
    return ret;
}

extern Bvr SlowInSlowOutBvr (DoubleValue, DoubleValue, DoubleValue, DoubleValue);
CRSTDAPI_(CRNumber *) CRSlowInSlowOut(double arg0, double arg1, double arg2, double arg3)
{
    TraceTag((tagAPIEntry, "CRSlowInSlowOut"));

    CRNumber * ret = NULL;

    APIPRECODE ;
    ret = (CRNumber *) (::SlowInSlowOutBvr(DoubleToNumBvr(arg0), DoubleToNumBvr(arg1), DoubleToNumBvr(arg2), DoubleToNumBvr(arg3)));
    APIPOSTCODE ;
    return ret;
}

extern Bvr MakeRenderedSound (Bvr, Bvr);
CRSTDAPI_(CRSound *) CRRenderSound(CRGeometry * arg0, CRMicrophone * arg1)
{
    TraceTag((tagAPIEntry, "CRRenderSound"));

    CRSound * ret = NULL;

    APIPRECODE ;
    ret = (CRSound *) (::MakeRenderedSound((arg0), (arg1)));
    APIPOSTCODE ;
    return ret;
}

extern Bvr MakeSoundSource (Bvr);
CRSTDAPI_(CRGeometry *) CRSoundSource(CRSound * arg0)
{
    TraceTag((tagAPIEntry, "CRSoundSource"));

    CRGeometry * ret = NULL;

    APIPRECODE ;
    ret = (CRGeometry *) (::MakeSoundSource((arg0)));
    APIPOSTCODE ;
    return ret;
}

extern Bvr SoundMix (Bvr, Bvr);
CRSTDAPI_(CRSound *) CRMix(CRSound * arg0, CRSound * arg1)
{
    TraceTag((tagAPIEntry, "CRMix"));

    CRSound * ret = NULL;

    APIPRECODE ;
    ret = (CRSound *) (::SoundMix((arg0), (arg1)));
    APIPOSTCODE ;
    return ret;
}

extern AxABoolean *BoolAnd(AxABoolean *a, AxABoolean *b);
AxAPrimOp *BoolAndOp;
CRSTDAPI_(CRBoolean *) CRAnd(CRBoolean * arg0, CRBoolean * arg1)
{
    TraceTag((tagAPIEntry, "CRAnd"));

    return (CRBoolean *) CreatePrim2(BoolAndOp, arg0, arg1);
}

extern AxABoolean *BoolOr(AxABoolean *a, AxABoolean *b);
AxAPrimOp *BoolOrOp;
CRSTDAPI_(CRBoolean *) CROr(CRBoolean * arg0, CRBoolean * arg1)
{
    TraceTag((tagAPIEntry, "CROr"));

    return (CRBoolean *) CreatePrim2(BoolOrOp, arg0, arg1);
}

extern AxABoolean *BoolNot(AxABoolean *a);
AxAPrimOp *BoolNotOp;
CRSTDAPI_(CRBoolean *) CRNot(CRBoolean * arg0)
{
    TraceTag((tagAPIEntry, "CRNot"));

    return (CRBoolean *) CreatePrim1(BoolNotOp, arg0);
}

extern Bvr IntegralBvr (Bvr);
CRSTDAPI_(CRNumber *) CRIntegral(CRNumber * arg0)
{
    TraceTag((tagAPIEntry, "CRIntegral"));

    CRNumber * ret = NULL;

    APIPRECODE ;
    ret = (CRNumber *) (::IntegralBvr((arg0)));
    APIPOSTCODE ;
    return ret;
}

extern Bvr DerivBvr (Bvr);
CRSTDAPI_(CRNumber *) CRDerivative(CRNumber * arg0)
{
    TraceTag((tagAPIEntry, "CRDerivative"));

    CRNumber * ret = NULL;

    APIPRECODE ;
    ret = (CRNumber *) (::DerivBvr((arg0)));
    APIPOSTCODE ;
    return ret;
}

extern Bvr IntegralVector2 (Bvr);
CRSTDAPI_(CRVector2 *) CRIntegral(CRVector2 * arg0)
{
    TraceTag((tagAPIEntry, "CRIntegral"));

    CRVector2 * ret = NULL;

    APIPRECODE ;
    ret = (CRVector2 *) (::IntegralVector2((arg0)));
    APIPOSTCODE ;
    return ret;
}

extern Bvr IntegralVector3 (Bvr);
CRSTDAPI_(CRVector3 *) CRIntegral(CRVector3 * arg0)
{
    TraceTag((tagAPIEntry, "CRIntegral"));

    CRVector3 * ret = NULL;

    APIPRECODE ;
    ret = (CRVector3 *) (::IntegralVector3((arg0)));
    APIPOSTCODE ;
    return ret;
}

extern Bvr DerivVector2 (Bvr);
CRSTDAPI_(CRVector2 *) CRDerivative(CRVector2 * arg0)
{
    TraceTag((tagAPIEntry, "CRDerivative"));

    CRVector2 * ret = NULL;

    APIPRECODE ;
    ret = (CRVector2 *) (::DerivVector2((arg0)));
    APIPOSTCODE ;
    return ret;
}

extern Bvr DerivVector3 (Bvr);
CRSTDAPI_(CRVector3 *) CRDerivative(CRVector3 * arg0)
{
    TraceTag((tagAPIEntry, "CRDerivative"));

    CRVector3 * ret = NULL;

    APIPRECODE ;
    ret = (CRVector3 *) (::DerivVector3((arg0)));
    APIPOSTCODE ;
    return ret;
}

extern Bvr DerivPoint2 (Bvr);
CRSTDAPI_(CRVector2 *) CRDerivative(CRPoint2 * arg0)
{
    TraceTag((tagAPIEntry, "CRDerivative"));

    CRVector2 * ret = NULL;

    APIPRECODE ;
    ret = (CRVector2 *) (::DerivPoint2((arg0)));
    APIPOSTCODE ;
    return ret;
}

extern Bvr DerivPoint3 (Bvr);
CRSTDAPI_(CRVector3 *) CRDerivative(CRPoint3 * arg0)
{
    TraceTag((tagAPIEntry, "CRDerivative"));

    CRVector3 * ret = NULL;

    APIPRECODE ;
    ret = (CRVector3 *) (::DerivPoint3((arg0)));
    APIPOSTCODE ;
    return ret;
}

extern Bvr KeyStateBvr (Bvr);
CRSTDAPI_(CRBoolean *) CRKeyState(CRNumber * arg0)
{
    TraceTag((tagAPIEntry, "CRKeyState"));

    CRBoolean * ret = NULL;

    APIPRECODE ;
    ret = (CRBoolean *) (::KeyStateBvr((arg0)));
    APIPOSTCODE ;
    return ret;
}

extern Bvr KeyUp (KeyCode);
CRSTDAPI_(CREvent *) CRKeyUp(LONG arg0)
{
    TraceTag((tagAPIEntry, "CRKeyUp"));

    CREvent * ret = NULL;

    APIPRECODE ;
    ret = (CREvent *) (::KeyUp((arg0)));
    APIPOSTCODE ;
    return ret;
}

extern Bvr KeyDown (KeyCode);
CRSTDAPI_(CREvent *) CRKeyDown(LONG arg0)
{
    TraceTag((tagAPIEntry, "CRKeyDown"));

    CREvent * ret = NULL;

    APIPRECODE ;
    ret = (CREvent *) (::KeyDown((arg0)));
    APIPOSTCODE ;
    return ret;
}

extern Bvr NumToBvr (double);
CRSTDAPI_(CRNumber *) CRCreateNumber(double arg0)
{
    TraceTag((tagAPIEntry, "CRCreateNumber"));

    CRNumber * ret = NULL;

    APIPRECODE ;
    ret = (CRNumber *) (::NumToBvr((arg0)));
    APIPOSTCODE ;
    return ret;
}

extern Bvr StringToBvr (WideString);
CRSTDAPI_(CRString *) CRCreateString(LPWSTR arg0)
{
    TraceTag((tagAPIEntry, "CRCreateString"));

    CRString * ret = NULL;

    APIPRECODE ;
    ret = (CRString *) (::StringToBvr((arg0)));
    APIPOSTCODE ;
    return ret;
}

extern Bvr BoolToBvr (bool);
CRSTDAPI_(CRBoolean *) CRCreateBoolean(bool arg0)
{
    TraceTag((tagAPIEntry, "CRCreateBoolean"));

    CRBoolean * ret = NULL;

    APIPRECODE ;
    ret = (CRBoolean *) (::BoolToBvr((arg0)));
    APIPOSTCODE ;
    return ret;
}

extern double ExtractNum (Bvr);
CRSTDAPI_(double) CRExtract(CRNumber * arg0)
{
    TraceTag((tagAPIEntry, "CRExtract"));

    double ret = NULL;

    APIPRECODE ;
    ret = (double) (::ExtractNum((arg0)));
    APIPOSTCODE ;
    return ret;
}

extern Bvr SeededRandom (double);
CRSTDAPI_(CRNumber *) CRSeededRandom(double arg0)
{
    TraceTag((tagAPIEntry, "CRSeededRandom"));

    CRNumber * ret = NULL;

    APIPRECODE ;
    ret = (CRNumber *) (::SeededRandom((arg0)));
    APIPOSTCODE ;
    return ret;
}

extern WideString ExtractString (Bvr);
CRSTDAPI_(LPWSTR) CRExtract(CRString * arg0)
{
    TraceTag((tagAPIEntry, "CRExtract"));

    LPWSTR ret = NULL;

    APIPRECODE ;
    ret = (LPWSTR) (::ExtractString((arg0)));
    APIPOSTCODE ;
    return ret;
}

extern bool ExtractBool (Bvr);
CRSTDAPI_(bool) CRExtract(CRBoolean * arg0)
{
    TraceTag((tagAPIEntry, "CRExtract"));

    bool ret = false;

    APIPRECODE ;
    ret = (bool) (::ExtractBool((arg0)));
    APIPOSTCODE ;
    return ret;
}

extern Bvr Nth (Bvr, Bvr);
CRSTDAPI_(CRBvr *) CRNth(CRArray * arg0, CRNumber * arg1)
{
    TraceTag((tagAPIEntry, "CRNth"));

    CRBvr * ret = NULL;

    APIPRECODE ;
    ret = (CRBvr *) (::Nth((arg0), (arg1)));
    APIPOSTCODE ;
    return ret;
}

extern AxANumber* ArrayLength(AxAArray *arr);
AxAPrimOp *ArrayLengthOp;
CRSTDAPI_(CRNumber *) CRLength(CRArray * arg0)
{
    TraceTag((tagAPIEntry, "CRLength"));

    return (CRNumber *) CreatePrim1(ArrayLengthOp, arg0);
}

extern Bvr Nth (Bvr, long);
CRSTDAPI_(CRBvr *) CRNth(CRTuple * arg0, long arg1)
{
    TraceTag((tagAPIEntry, "CRNth"));

    CRBvr * ret = NULL;

    APIPRECODE ;
    ret = (CRBvr *) (::Nth((arg0), (arg1)));
    APIPOSTCODE ;
    return ret;
}

extern long TupleLength (Bvr);
CRSTDAPI_(long) CRLength(CRTuple * arg0)
{
    TraceTag((tagAPIEntry, "CRLength"));

    long ret = NULL;

    APIPRECODE ;
    ret = (long) (::TupleLength((arg0)));
    APIPOSTCODE ;
    return ret;
}

extern Bvr mousePosition ;
CRSTDAPI_(CRPoint2 *) CRMousePosition()
{
    return (CRPoint2 *) mousePosition;
}
extern Bvr leftButtonState ;
CRSTDAPI_(CRBoolean *) CRLeftButtonState()
{
    return (CRBoolean *) leftButtonState;
}
extern Bvr rightButtonState ;
CRSTDAPI_(CRBoolean *) CRRightButtonState()
{
    return (CRBoolean *) rightButtonState;
}
extern Bvr trueBvr ;
CRSTDAPI_(CRBoolean *) CRTrue()
{
    return (CRBoolean *) trueBvr;
}
extern Bvr falseBvr ;
CRSTDAPI_(CRBoolean *) CRFalse()
{
    return (CRBoolean *) falseBvr;
}
extern Bvr timeBvr ;
CRSTDAPI_(CRNumber *) CRLocalTime()
{
    return (CRNumber *) timeBvr;
}
extern Bvr globalTimeBvr ;
CRSTDAPI_(CRNumber *) CRGlobalTime()
{
    return (CRNumber *) globalTimeBvr;
}
extern Bvr pixelBvr ;
CRSTDAPI_(CRNumber *) CRPixel()
{
    return (CRNumber *) pixelBvr;
}
extern Bvr MakeUserData (LPUNKNOWN);
CRSTDAPI_(CRUserData *) CRCreateUserData(IUnknown * arg0)
{
    TraceTag((tagAPIEntry, "CRCreateUserData"));

    CRUserData * ret = NULL;

    APIPRECODE ;
    ret = (CRUserData *) (::MakeUserData((arg0)));
    APIPOSTCODE ;
    return ret;
}

extern LPUNKNOWN GetUserData (Bvr);
CRSTDAPI_(IUnknown *) CRGetData(CRUserData * arg0)
{
    TraceTag((tagAPIEntry, "CRGetData"));

    IUnknown * ret = NULL;

    APIPRECODE ;
    ret = (IUnknown *) (::GetUserData((arg0)));
    APIPOSTCODE ;
    return ret;
}

extern Bvr JaxaUntil (Bvr, Bvr, UntilNotifier);
CRSTDAPI_(CRBvr *) CRUntilNotify(CRBvr * arg0, CREvent * arg1, CRUntilNotifier * arg2)
{
    TraceTag((tagAPIEntry, "CRUntilNotify"));

    CRBvr * ret = NULL;

    APIPRECODE ;
    ret = (CRBvr *) (::JaxaUntil((arg0), (arg1), WrapUntilNotifier(arg2)));
    APIPOSTCODE ;
    return ret;
}

extern Bvr Until3 (Bvr, Bvr, Bvr);
CRSTDAPI_(CRBvr *) CRUntil(CRBvr * arg0, CREvent * arg1, CRBvr * arg2)
{
    TraceTag((tagAPIEntry, "CRUntil"));

    CRBvr * ret = NULL;

    APIPRECODE ;
    ret = (CRBvr *) (::Until3((arg0), (arg1), (arg2)));
    APIPOSTCODE ;
    return ret;
}

extern Bvr Until (Bvr, Bvr);
CRSTDAPI_(CRBvr *) CRUntilEx(CRBvr * arg0, CREvent * arg1)
{
    TraceTag((tagAPIEntry, "CRUntilEx"));

    CRBvr * ret = NULL;

    APIPRECODE ;
    ret = (CRBvr *) (::Until((arg0), (arg1)));
    APIPOSTCODE ;
    return ret;
}

extern Bvr Sequence (Bvr, Bvr);
CRSTDAPI_(CRBvr *) CRSequence(CRBvr * arg0, CRBvr * arg1)
{
    TraceTag((tagAPIEntry, "CRSequence"));

    CRBvr * ret = NULL;

    APIPRECODE ;
    ret = (CRBvr *) (::Sequence((arg0), (arg1)));
    APIPOSTCODE ;
    return ret;
}

extern Bvr FollowPath (Bvr, double);
CRSTDAPI_(CRTransform2 *) CRFollowPath(CRPath2 * arg0, double arg1)
{
    TraceTag((tagAPIEntry, "CRFollowPath"));

    CRTransform2 * ret = NULL;

    APIPRECODE ;
    ret = (CRTransform2 *) (::FollowPath((arg0), (arg1)));
    APIPOSTCODE ;
    return ret;
}

extern Bvr FollowPathAngle (Bvr, double);
CRSTDAPI_(CRTransform2 *) CRFollowPathAngle(CRPath2 * arg0, double arg1)
{
    TraceTag((tagAPIEntry, "CRFollowPathAngle"));

    CRTransform2 * ret = NULL;

    APIPRECODE ;
    ret = (CRTransform2 *) (::FollowPathAngle((arg0), (arg1)));
    APIPOSTCODE ;
    return ret;
}

extern Bvr FollowPathAngleUpright (Bvr, double);
CRSTDAPI_(CRTransform2 *) CRFollowPathAngleUpright(CRPath2 * arg0, double arg1)
{
    TraceTag((tagAPIEntry, "CRFollowPathAngleUpright"));

    CRTransform2 * ret = NULL;

    APIPRECODE ;
    ret = (CRTransform2 *) (::FollowPathAngleUpright((arg0), (arg1)));
    APIPOSTCODE ;
    return ret;
}

extern Bvr FollowPathEval (Bvr, Bvr);
CRSTDAPI_(CRTransform2 *) CRFollowPathEval(CRPath2 * arg0, CRNumber * arg1)
{
    TraceTag((tagAPIEntry, "CRFollowPathEval"));

    CRTransform2 * ret = NULL;

    APIPRECODE ;
    ret = (CRTransform2 *) (::FollowPathEval((arg0), (arg1)));
    APIPOSTCODE ;
    return ret;
}

extern Bvr FollowPathAngleEval (Bvr, Bvr);
CRSTDAPI_(CRTransform2 *) CRFollowPathAngleEval(CRPath2 * arg0, CRNumber * arg1)
{
    TraceTag((tagAPIEntry, "CRFollowPathAngleEval"));

    CRTransform2 * ret = NULL;

    APIPRECODE ;
    ret = (CRTransform2 *) (::FollowPathAngleEval((arg0), (arg1)));
    APIPOSTCODE ;
    return ret;
}

extern Bvr FollowPathAngleUprightEval (Bvr, Bvr);
CRSTDAPI_(CRTransform2 *) CRFollowPathAngleUprightEval(CRPath2 * arg0, CRNumber * arg1)
{
    TraceTag((tagAPIEntry, "CRFollowPathAngleUprightEval"));

    CRTransform2 * ret = NULL;

    APIPRECODE ;
    ret = (CRTransform2 *) (::FollowPathAngleUprightEval((arg0), (arg1)));
    APIPOSTCODE ;
    return ret;
}

extern Bvr FollowPathEval (Bvr, Bvr);
CRSTDAPI_(CRTransform2 *) CRFollowPath(CRPath2 * arg0, CRNumber * arg1)
{
    TraceTag((tagAPIEntry, "CRFollowPath"));

    CRTransform2 * ret = NULL;

    APIPRECODE ;
    ret = (CRTransform2 *) (::FollowPathEval((arg0), (arg1)));
    APIPOSTCODE ;
    return ret;
}

extern Bvr FollowPathAngleEval (Bvr, Bvr);
CRSTDAPI_(CRTransform2 *) CRFollowPathAngle(CRPath2 * arg0, CRNumber * arg1)
{
    TraceTag((tagAPIEntry, "CRFollowPathAngle"));

    CRTransform2 * ret = NULL;

    APIPRECODE ;
    ret = (CRTransform2 *) (::FollowPathAngleEval((arg0), (arg1)));
    APIPOSTCODE ;
    return ret;
}

extern Bvr FollowPathAngleUprightEval (Bvr, Bvr);
CRSTDAPI_(CRTransform2 *) CRFollowPathAngleUpright(CRPath2 * arg0, CRNumber * arg1)
{
    TraceTag((tagAPIEntry, "CRFollowPathAngleUpright"));

    CRTransform2 * ret = NULL;

    APIPRECODE ;
    ret = (CRTransform2 *) (::FollowPathAngleUprightEval((arg0), (arg1)));
    APIPOSTCODE ;
    return ret;
}

extern Bvr ImageAddId (Bvr, LPUNKNOWN, bool);
CRSTDAPI_(CRImage *) CRAddPickData(CRImage * arg0, IUnknown * arg1, bool arg2)
{
    TraceTag((tagAPIEntry, "CRAddPickData"));

    CRImage * ret = NULL;

    APIPRECODE ;
    ret = (CRImage *) (::ImageAddId((arg0), (arg1), (arg2)));
    APIPOSTCODE ;
    return ret;
}

extern Bvr GeometryAddId (Bvr, LPUNKNOWN, bool);
CRSTDAPI_(CRGeometry *) CRAddPickData(CRGeometry * arg0, IUnknown * arg1, bool arg2)
{
    TraceTag((tagAPIEntry, "CRAddPickData"));

    CRGeometry * ret = NULL;

    APIPRECODE ;
    ret = (CRGeometry *) (::GeometryAddId((arg0), (arg1), (arg2)));
    APIPOSTCODE ;
    return ret;
}

extern long ArrayAddElement (Bvr, Bvr, DWORD);
CRSTDAPI_(long) CRAddElement(CRArray * arg0, CRBvr * arg1, DWORD arg2)
{
    TraceTag((tagAPIEntry, "CRAddElement"));

    long ret = NULL;

    APIPRECODE ;
    ret = (long) (::ArrayAddElement((arg0), (arg1), (arg2)));
    APIPOSTCODE ;
    return ret;
}

extern void ArrayRemoveElement (Bvr, long);
CRSTDAPI_(bool) CRRemoveElement(CRArray * arg0, long arg1)
{
    TraceTag((tagAPIEntry, "CRRemoveElement"));

    bool ret = false;

    APIPRECODE ;
    ::ArrayRemoveElement((arg0), (arg1)) ; ret = true;
    APIPOSTCODE ;
    return ret;
}

extern void ArraySetElement (Bvr, long, Bvr, DWORD);
CRSTDAPI_(bool) CRSetElement(CRArray * arg0, long i, CRBvr * arg1, long arg2)
{
    TraceTag((tagAPIEntry, "CRSetElement"));

    bool ret = false;

    APIPRECODE ;
    ::ArraySetElement((arg0), i, (arg1), (arg2)); ret = true;
    APIPOSTCODE ;
    return ret;
}

extern Bvr ArrayGetElement (Bvr, long);
CRSTDAPI_(CRBvr *) CRGetElement(CRArray * arg0, long arg1)
{
    TraceTag((tagAPIEntry, "CRGetElement"));

    CRBvr *ret = NULL;

    APIPRECODE ;
    ret = (CRBvr *) (::ArrayGetElement((arg0), (arg1)));
    APIPOSTCODE ;
    return ret;
}

extern AxAString * Concat(AxAString *s1, AxAString *s2);
AxAPrimOp *ConcatOp;
CRSTDAPI_(CRString *) CRConcatString(CRString * arg0, CRString * arg1)
{
    TraceTag((tagAPIEntry, "CRConcatString"));

    return (CRString *) CreatePrim2(ConcatOp, arg0, arg1);
}

extern Point2Value *MinBbox2(Bbox2Value *box);
AxAPrimOp *MinBbox2Op;
CRSTDAPI_(CRPoint2 *) CRMin(CRBbox2 * arg0)
{
    TraceTag((tagAPIEntry, "CRMin"));

    return (CRPoint2 *) CreatePrim1(MinBbox2Op, arg0);
}

extern Point2Value *MaxBbox2(Bbox2Value *box);
AxAPrimOp *MaxBbox2Op;
CRSTDAPI_(CRPoint2 *) CRMax(CRBbox2 * arg0)
{
    TraceTag((tagAPIEntry, "CRMax"));

    return (CRPoint2 *) CreatePrim1(MaxBbox2Op, arg0);
}

extern Point3Value *MinBbox3(Bbox3 *box);
AxAPrimOp *MinBbox3Op;
CRSTDAPI_(CRPoint3 *) CRMin(CRBbox3 * arg0)
{
    TraceTag((tagAPIEntry, "CRMin"));

    return (CRPoint3 *) CreatePrim1(MinBbox3Op, arg0);
}

extern Point3Value *MaxBbox3(Bbox3 *box);
AxAPrimOp *MaxBbox3Op;
CRSTDAPI_(CRPoint3 *) CRMax(CRBbox3 * arg0)
{
    TraceTag((tagAPIEntry, "CRMax"));

    return (CRPoint3 *) CreatePrim1(MaxBbox3Op, arg0);
}

extern Camera *PerspectiveCamera (DoubleValue *focalDist, DoubleValue *nearClip);
AxAPrimOp *PerspectiveCameraOp;
CRSTDAPI_(CRCamera *) CRPerspectiveCamera(double arg0, double arg1)
{
    TraceTag((tagAPIEntry, "CRPerspectiveCamera"));

    CRCamera * ret = NULL;

    APIPRECODE ;
    ret = (CRCamera *) (PrimApplyBvr(PerspectiveCameraOp, 2, DoubleToNumBvr(arg0), DoubleToNumBvr(arg1)));
    APIPOSTCODE ;
    return ret;
}

extern Camera *PerspectiveCamera (AxANumber *focalDist, AxANumber *nearClip);
CRSTDAPI_(CRCamera *) CRPerspectiveCameraAnim(CRNumber * arg0, CRNumber * arg1)
{
    TraceTag((tagAPIEntry, "CRPerspectiveCameraAnim"));

    return (CRCamera *) CreatePrim2(PerspectiveCameraOp, arg0, arg1);
}

extern Camera *ParallelCamera (DoubleValue *nearClip);
AxAPrimOp *ParallelCameraOp;
CRSTDAPI_(CRCamera *) CRParallelCamera(double arg0)
{
    TraceTag((tagAPIEntry, "CRParallelCamera"));

    CRCamera * ret = NULL;

    APIPRECODE ;
    ret = (CRCamera *) (PrimApplyBvr(ParallelCameraOp, 1, DoubleToNumBvr(arg0)));
    APIPOSTCODE ;
    return ret;
}

extern Camera *ParallelCamera (AxANumber *nearClip);
CRSTDAPI_(CRCamera *) CRParallelCameraAnim(CRNumber * arg0)
{
    TraceTag((tagAPIEntry, "CRParallelCameraAnim"));

    return (CRCamera *) CreatePrim1(ParallelCameraOp, arg0);
}

extern Camera *TransformCamera (Transform3 *xf, Camera *cam);
AxAPrimOp *TransformCameraOp;
CRSTDAPI_(CRCamera *) CRTransform(CRCamera * arg1, CRTransform3 * arg0)
{
    TraceTag((tagAPIEntry, "CRTransform"));

    return (CRCamera *) CreatePrim2(TransformCameraOp, arg0, arg1);
}

extern Camera *Depth (DoubleValue *depth, Camera *cam);
AxAPrimOp *DepthOp;
CRSTDAPI_(CRCamera *) CRDepth(CRCamera * arg1, double arg0)
{
    TraceTag((tagAPIEntry, "CRDepth"));

    CRCamera * ret = NULL;

    APIPRECODE ;
    ret = (CRCamera *) (PrimApplyBvr(DepthOp, 2, DoubleToNumBvr(arg0), (arg1)));
    APIPOSTCODE ;
    return ret;
}

extern Camera *Depth (AxANumber *depth, Camera *cam);
CRSTDAPI_(CRCamera *) CRDepth(CRCamera * arg1, CRNumber * arg0)
{
    TraceTag((tagAPIEntry, "CRDepth"));

    return (CRCamera *) CreatePrim2(DepthOp, arg0, arg1);
}

extern Camera *DepthResolution (DoubleValue *resolution, Camera *cam);
AxAPrimOp *DepthResolutionOp;
CRSTDAPI_(CRCamera *) CRDepthResolution(CRCamera * arg1, double arg0)
{
    TraceTag((tagAPIEntry, "CRDepthResolution"));

    CRCamera * ret = NULL;

    APIPRECODE ;
    ret = (CRCamera *) (PrimApplyBvr(DepthResolutionOp, 2, DoubleToNumBvr(arg0), (arg1)));
    APIPOSTCODE ;
    return ret;
}

extern Camera *DepthResolution (AxANumber *resolution, Camera *cam);
CRSTDAPI_(CRCamera *) CRDepthResolution(CRCamera * arg1, CRNumber * arg0)
{
    TraceTag((tagAPIEntry, "CRDepthResolution"));

    return (CRCamera *) CreatePrim2(DepthResolutionOp, arg0, arg1);
}

extern Point2Value *ProjectPoint (Point3Value *pt, Camera *cam);
AxAPrimOp *ProjectPointOp;
CRSTDAPI_(CRPoint2 *) CRProject(CRPoint3 * arg0, CRCamera * arg1)
{
    TraceTag((tagAPIEntry, "CRProject"));

    return (CRPoint2 *) CreatePrim2(ProjectPointOp, arg0, arg1);
}

extern Color *RgbColor  (AxANumber *red, AxANumber *green, AxANumber *blue);
AxAPrimOp *RgbColorOp;
CRSTDAPI_(CRColor *) CRColorRgb(CRNumber * arg0, CRNumber * arg1, CRNumber * arg2)
{
    TraceTag((tagAPIEntry, "CRColorRgb"));

    return (CRColor *) CreatePrim3(RgbColorOp, arg0, arg1, arg2);
}

extern Color *RgbColorRRR (Real red, Real green, Real blue);
CRSTDAPI_(CRColor *) CRColorRgb(double arg0, double arg1, double arg2)
{
    TraceTag((tagAPIEntry, "CRColorRgb"));

    CRColor * ret = NULL;

    APIPRECODE ;
    ret = (CRColor *) ConstBvr((AxAValue) RgbColorRRR(arg0,arg1,arg2));
    APIPOSTCODE ;
    return ret;
}

extern Color *RgbColor  (RGBComponent * red,                            RGBComponent * green,                            RGBComponent * blue);
CRSTDAPI_(CRColor *) CRColorRgb255(short arg0, short arg1, short arg2)
{
    TraceTag((tagAPIEntry, "CRColorRgb255"));

    CRColor * ret = NULL;

    APIPRECODE ;
    ret = (CRColor *) (PrimApplyBvr(RgbColorOp, 3, RGBToNumBvr(arg0), RGBToNumBvr(arg1), RGBToNumBvr(arg2)));
    APIPOSTCODE ;
    return ret;
}

extern Color *HslColorRRR (Real hue, Real saturation, Real lum);
AxAPrimOp *HslColorOp;
CRSTDAPI_(CRColor *) CRColorHsl(double arg0, double arg1, double arg2)
{
    TraceTag((tagAPIEntry, "CRColorHsl"));

    CRColor * ret = NULL;

    APIPRECODE ;
    ret = (CRColor *) ConstBvr((AxAValue) HslColorRRR(arg0,arg1,arg2));
    APIPOSTCODE ;
    return ret;
}

extern Color *HslColor  (AxANumber *hue, AxANumber *saturation, AxANumber *lum);
CRSTDAPI_(CRColor *) CRColorHsl(CRNumber * arg0, CRNumber * arg1, CRNumber * arg2)
{
    TraceTag((tagAPIEntry, "CRColorHsl"));

    return (CRColor *) CreatePrim3(HslColorOp, arg0, arg1, arg2);
}

extern AxANumber *RedComponent   (Color *color);
AxAPrimOp *RedComponentOp;
CRSTDAPI_(CRNumber *) CRGetRed(CRColor * arg0)
{
    TraceTag((tagAPIEntry, "CRGetRed"));

    return (CRNumber *) CreatePrim1(RedComponentOp, arg0);
}

extern AxANumber *GreenComponent (Color *color);
AxAPrimOp *GreenComponentOp;
CRSTDAPI_(CRNumber *) CRGetGreen(CRColor * arg0)
{
    TraceTag((tagAPIEntry, "CRGetGreen"));

    return (CRNumber *) CreatePrim1(GreenComponentOp, arg0);
}

extern AxANumber *BlueComponent  (Color *color);
AxAPrimOp *BlueComponentOp;
CRSTDAPI_(CRNumber *) CRGetBlue(CRColor * arg0)
{
    TraceTag((tagAPIEntry, "CRGetBlue"));

    return (CRNumber *) CreatePrim1(BlueComponentOp, arg0);
}

extern AxANumber *HueComponent        (Color *color);
AxAPrimOp *HueComponentOp;
CRSTDAPI_(CRNumber *) CRGetHue(CRColor * arg0)
{
    TraceTag((tagAPIEntry, "CRGetHue"));

    return (CRNumber *) CreatePrim1(HueComponentOp, arg0);
}

extern AxANumber *SaturationComponent (Color *color);
AxAPrimOp *SaturationComponentOp;
CRSTDAPI_(CRNumber *) CRGetSaturation(CRColor * arg0)
{
    TraceTag((tagAPIEntry, "CRGetSaturation"));

    return (CRNumber *) CreatePrim1(SaturationComponentOp, arg0);
}

extern AxANumber *LuminanceComponent  (Color *color);
AxAPrimOp *LuminanceComponentOp;
CRSTDAPI_(CRNumber *) CRGetLightness(CRColor * arg0)
{
    TraceTag((tagAPIEntry, "CRGetLightness"));

    return (CRNumber *) CreatePrim1(LuminanceComponentOp, arg0);
}

extern Color * red;
CRColor * g_varCRRed;
CRSTDAPI_(CRColor *) CRRed()
{
    return g_varCRRed;
}
extern Color * green;
CRColor * g_varCRGreen;
CRSTDAPI_(CRColor *) CRGreen()
{
    return g_varCRGreen;
}
extern Color * blue;
CRColor * g_varCRBlue;
CRSTDAPI_(CRColor *) CRBlue()
{
    return g_varCRBlue;
}
extern Color * cyan;
CRColor * g_varCRCyan;
CRSTDAPI_(CRColor *) CRCyan()
{
    return g_varCRCyan;
}
extern Color * magenta;
CRColor * g_varCRMagenta;
CRSTDAPI_(CRColor *) CRMagenta()
{
    return g_varCRMagenta;
}
extern Color * yellow;
CRColor * g_varCRYellow;
CRSTDAPI_(CRColor *) CRYellow()
{
    return g_varCRYellow;
}
extern Color * black;
CRColor * g_varCRBlack;
CRSTDAPI_(CRColor *) CRBlack()
{
    return g_varCRBlack;
}
extern Color * white;
CRColor * g_varCRWhite;
CRSTDAPI_(CRColor *) CRWhite()
{
    return g_varCRWhite;
}
extern Color * aqua;
CRColor * g_varCRAqua;
CRSTDAPI_(CRColor *) CRAqua()
{
    return g_varCRAqua;
}
extern Color *fuchsia;
CRColor * g_varCRFuchsia;
CRSTDAPI_(CRColor *) CRFuchsia()
{
    return g_varCRFuchsia;
}
extern Color *gray;
CRColor * g_varCRGray;
CRSTDAPI_(CRColor *) CRGray()
{
    return g_varCRGray;
}
extern Color *lime;
CRColor * g_varCRLime;
CRSTDAPI_(CRColor *) CRLime()
{
    return g_varCRLime;
}
extern Color *maroon;
CRColor * g_varCRMaroon;
CRSTDAPI_(CRColor *) CRMaroon()
{
    return g_varCRMaroon;
}
extern Color *navy;
CRColor * g_varCRNavy;
CRSTDAPI_(CRColor *) CRNavy()
{
    return g_varCRNavy;
}
extern Color *olive;
CRColor * g_varCROlive;
CRSTDAPI_(CRColor *) CROlive()
{
    return g_varCROlive;
}
extern Color *purple;
CRColor * g_varCRPurple;
CRSTDAPI_(CRColor *) CRPurple()
{
    return g_varCRPurple;
}
extern Color *silver;
CRColor * g_varCRSilver;
CRSTDAPI_(CRColor *) CRSilver()
{
    return g_varCRSilver;
}
extern Color *teal;
CRColor * g_varCRTeal;
CRSTDAPI_(CRColor *) CRTeal()
{
    return g_varCRTeal;
}
extern Bvr PredicateEvent (Bvr);
CRSTDAPI_(CREvent *) CRPredicate(CRBoolean * arg0)
{
    TraceTag((tagAPIEntry, "CRPredicate"));

    CREvent * ret = NULL;

    APIPRECODE ;
    ret = (CREvent *) (::PredicateEvent((arg0)));
    APIPOSTCODE ;
    return ret;
}

extern Bvr NotEvent (Bvr);
CRSTDAPI_(CREvent *) CRNotEvent(CREvent * arg0)
{
    TraceTag((tagAPIEntry, "CRNotEvent"));

    CREvent * ret = NULL;

    APIPRECODE ;
    ret = (CREvent *) (::NotEvent((arg0)));
    APIPOSTCODE ;
    return ret;
}

extern Bvr AndEvent (Bvr, Bvr);
CRSTDAPI_(CREvent *) CRAndEvent(CREvent * arg0, CREvent * arg1)
{
    TraceTag((tagAPIEntry, "CRAndEvent"));

    CREvent * ret = NULL;

    APIPRECODE ;
    ret = (CREvent *) (::AndEvent((arg0), (arg1)));
    APIPOSTCODE ;
    return ret;
}

extern Bvr OrEvent (Bvr, Bvr);
CRSTDAPI_(CREvent *) CROrEvent(CREvent * arg0, CREvent * arg1)
{
    TraceTag((tagAPIEntry, "CROrEvent"));

    CREvent * ret = NULL;

    APIPRECODE ;
    ret = (CREvent *) (::OrEvent((arg0), (arg1)));
    APIPOSTCODE ;
    return ret;
}

extern Bvr ThenEvent (Bvr, Bvr);
CRSTDAPI_(CREvent *) CRThenEvent(CREvent * arg0, CREvent * arg1)
{
    TraceTag((tagAPIEntry, "CRThenEvent"));

    CREvent * ret = NULL;

    APIPRECODE ;
    ret = (CREvent *) (::ThenEvent((arg0), (arg1)));
    APIPOSTCODE ;
    return ret;
}

extern Bvr leftButtonDown ;
CRSTDAPI_(CREvent *) CRLeftButtonDown()
{
    return (CREvent *) leftButtonDown;
}
extern Bvr leftButtonUp ;
CRSTDAPI_(CREvent *) CRLeftButtonUp()
{
    return (CREvent *) leftButtonUp;
}
extern Bvr rightButtonDown ;
CRSTDAPI_(CREvent *) CRRightButtonDown()
{
    return (CREvent *) rightButtonDown;
}
extern Bvr rightButtonUp ;
CRSTDAPI_(CREvent *) CRRightButtonUp()
{
    return (CREvent *) rightButtonUp;
}
extern Bvr alwaysBvr ;
CRSTDAPI_(CREvent *) CRAlways()
{
    return (CREvent *) alwaysBvr;
}
extern Bvr neverBvr ;
CRSTDAPI_(CREvent *) CRNever()
{
    return (CREvent *) neverBvr;
}
extern Bvr TimerEvent (Bvr);
CRSTDAPI_(CREvent *) CRTimer(CRNumber * arg0)
{
    TraceTag((tagAPIEntry, "CRTimer"));

    CREvent * ret = NULL;

    APIPRECODE ;
    ret = (CREvent *) (::TimerEvent((arg0)));
    APIPOSTCODE ;
    return ret;
}

extern Bvr TimerEvent (DoubleValue);
CRSTDAPI_(CREvent *) CRTimer(double arg0)
{
    TraceTag((tagAPIEntry, "CRTimer"));

    CREvent * ret = NULL;

    APIPRECODE ;
    ret = (CREvent *) (::TimerEvent(DoubleToNumBvr(arg0)));
    APIPOSTCODE ;
    return ret;
}

extern Bvr NotifyEvent (Bvr, UntilNotifier);
CRSTDAPI_(CREvent *) CRNotify(CREvent * arg0, CRUntilNotifier * arg1)
{
    TraceTag((tagAPIEntry, "CRNotify"));

    CREvent * ret = NULL;

    APIPRECODE ;
    ret = (CREvent *) (::NotifyEvent((arg0), WrapUntilNotifier(arg1)));
    APIPOSTCODE ;
    return ret;
}

extern Bvr SnapshotEvent (Bvr, Bvr);
CRSTDAPI_(CREvent *) CRSnapshot(CREvent * arg0, CRBvr * arg1)
{
    TraceTag((tagAPIEntry, "CRSnapshot"));

    CREvent * ret = NULL;

    APIPRECODE ;
    ret = (CREvent *) (::SnapshotEvent((arg0), (arg1)));
    APIPOSTCODE ;
    return ret;
}

extern Bvr AppTriggeredEvent ();
CRSTDAPI_(CREvent *) CRAppTriggeredEvent()
{
    TraceTag((tagAPIEntry, "CRAppTriggeredEvent"));

    CREvent * ret = NULL;

    APIPRECODE ;
    ret = (CREvent *) (::AppTriggeredEvent());
    APIPOSTCODE ;
    return ret;
}

extern Bvr HandleEvent (Bvr, Bvr);
CRSTDAPI_(CREvent *) CRAttachData(CREvent * arg0, CRBvr * arg1)
{
    TraceTag((tagAPIEntry, "CRAttachData"));

    CREvent * ret = NULL;

    APIPRECODE ;
    ret = (CREvent *) (::HandleEvent((arg0), (arg1)));
    APIPOSTCODE ;
    return ret;
}

extern Geometry *UndetectableGeometry(Geometry *geo);
AxAPrimOp *UndetectableGeometryOp;
CRSTDAPI_(CRGeometry *) CRUndetectable(CRGeometry * arg0)
{
    TraceTag((tagAPIEntry, "CRUndetectable"));

    return (CRGeometry *) CreatePrim1(UndetectableGeometryOp, arg0);
}

extern Geometry *applyEmissiveColor (Color *col, Geometry *geo);
AxAPrimOp *applyEmissiveColorOp;
CRSTDAPI_(CRGeometry *) CREmissiveColor(CRGeometry * arg1, CRColor * arg0)
{
    TraceTag((tagAPIEntry, "CREmissiveColor"));

    return (CRGeometry *) CreatePrim2(applyEmissiveColorOp, arg0, arg1);
}

extern Geometry *applyDiffuseColor (Color *col, Geometry *geo);
AxAPrimOp *applyDiffuseColorOp;
CRSTDAPI_(CRGeometry *) CRDiffuseColor(CRGeometry * arg1, CRColor * arg0)
{
    TraceTag((tagAPIEntry, "CRDiffuseColor"));

    return (CRGeometry *) CreatePrim2(applyDiffuseColorOp, arg0, arg1);
}

extern Geometry *applySpecularColor (Color *col, Geometry *geo);
AxAPrimOp *applySpecularColorOp;
CRSTDAPI_(CRGeometry *) CRSpecularColor(CRGeometry * arg1, CRColor * arg0)
{
    TraceTag((tagAPIEntry, "CRSpecularColor"));

    return (CRGeometry *) CreatePrim2(applySpecularColorOp, arg0, arg1);
}

extern Geometry *applySpecularExponent (DoubleValue *power, Geometry *geo);
AxAPrimOp *applySpecularExponentOp;
CRSTDAPI_(CRGeometry *) CRSpecularExponent(CRGeometry * arg1, double arg0)
{
    TraceTag((tagAPIEntry, "CRSpecularExponent"));

    CRGeometry * ret = NULL;

    APIPRECODE ;
    ret = (CRGeometry *) (PrimApplyBvr(applySpecularExponentOp, 2, DoubleToNumBvr(arg0), (arg1)));
    APIPOSTCODE ;
    return ret;
}

extern Geometry *applySpecularExponent (AxANumber *power, Geometry *geo);
CRSTDAPI_(CRGeometry *) CRSpecularExponentAnim(CRGeometry * arg1, CRNumber * arg0)
{
    TraceTag((tagAPIEntry, "CRSpecularExponentAnim"));

    return (CRGeometry *) CreatePrim2(applySpecularExponentOp, arg0, arg1);
}

extern Geometry *applyTextureMap(Image *texture, Geometry *geo);
AxAPrimOp *applyTextureMapOp;
CRSTDAPI_(CRGeometry *) CRTexture(CRGeometry * arg1, CRImage * arg0)
{
    TraceTag((tagAPIEntry, "CRTexture"));

    return (CRGeometry *) CreatePrim2(applyTextureMapOp, arg0, arg1);
}

extern Geometry *applyOpacityLevel (DoubleValue *level, Geometry *geom);
AxAPrimOp *applyOpacityLevelOp;
CRSTDAPI_(CRGeometry *) CROpacity(CRGeometry * arg1, double arg0)
{
    TraceTag((tagAPIEntry, "CROpacity"));

    CRGeometry * ret = NULL;

    APIPRECODE ;
    ret = (CRGeometry *) (PrimApplyBvr(applyOpacityLevelOp, 2, DoubleToNumBvr(arg0), (arg1)));
    APIPOSTCODE ;
    return ret;
}

extern Geometry *applyOpacityLevel (AxANumber *level, Geometry *geom);
CRSTDAPI_(CRGeometry *) CROpacity(CRGeometry * arg1, CRNumber * arg0)
{
    TraceTag((tagAPIEntry, "CROpacity"));

    return (CRGeometry *) CreatePrim2(applyOpacityLevelOp, arg0, arg1);
}

extern Geometry *applyTransform (Transform3 *xf, Geometry *geo);
AxAPrimOp *applyTransformOp;
CRSTDAPI_(CRGeometry *) CRTransform(CRGeometry * arg1, CRTransform3 * arg0)
{
    TraceTag((tagAPIEntry, "CRTransform"));

    return (CRGeometry *) CreatePrim2(applyTransformOp, arg0, arg1);
}

extern Geometry *ShadowGeometry (Geometry *geoToShadow, Geometry *geoContainingLights,
                                 Point3Value *planePoint, Vector3Value  *planeNormal);
AxAPrimOp *ShadowGeometryOp;
CRSTDAPI_(CRGeometry *) CRShadow(CRGeometry * arg0, CRGeometry * arg1, CRPoint3 * arg2, CRVector3 * arg3)
{
    TraceTag((tagAPIEntry, "CRShadow"));

    return (CRGeometry *) CreatePrim4(ShadowGeometryOp, arg0, arg1, arg2, arg3);
}

extern Geometry *emptyGeometry;
CRGeometry * g_varCREmptyGeometry;
CRSTDAPI_(CRGeometry *) CREmptyGeometry()
{
    return g_varCREmptyGeometry;
}
extern Geometry *PlusGeomGeom (Geometry *g1, Geometry *g2);
AxAPrimOp *PlusGeomGeomOp;
CRSTDAPI_(CRGeometry *) CRUnionGeometry(CRGeometry * arg0, CRGeometry * arg1)
{
    TraceTag((tagAPIEntry, "CRUnionGeometry"));

    return (CRGeometry *) CreatePrim2(PlusGeomGeomOp, arg0, arg1);
}

extern Geometry *UnionArray(DM_ARRAYARG(Geometry*, AxAArray*) imgs);
AxAPrimOp *UnionArrayOp;
CRSTDAPI_(CRGeometry *) CRUnionGeometry(CRArrayPtr arg0)
{
    TraceTag((tagAPIEntry, "CRUnionGeometry"));

    CRGeometry * ret = NULL;

    APIPRECODE ;
    ret = (CRGeometry *) (PrimApplyBvr(UnionArrayOp, 1, arg0));
    APIPOSTCODE ;
    return ret;
}

extern Geometry *UnionArray(DM_SAFEARRAYARG(Geometry*, AxAArray*) imgs);
extern Bbox3 *GeomBoundingBox(Geometry *geo);
AxAPrimOp *GeomBoundingBoxOp;
CRSTDAPI_(CRBbox3 *) CRBoundingBox(CRGeometry * arg0)
{
    TraceTag((tagAPIEntry, "CRBoundingBox"));

    return (CRBbox3 *) CreatePrim1(GeomBoundingBoxOp, arg0);
}

extern Image * emptyImage;
CRImage * g_varCREmptyImage;
CRSTDAPI_(CRImage *) CREmptyImage()
{
    return g_varCREmptyImage;
}
extern Image *detectableEmptyImage;
CRImage * g_varCRDetectableEmptyImage;
CRSTDAPI_(CRImage *) CRDetectableEmptyImage()
{
    return g_varCRDetectableEmptyImage;
}
extern Image *RenderImage(Geometry *geo, Camera *cam);
AxAPrimOp *RenderImageOp;
CRSTDAPI_(CRImage *) CRRender(CRGeometry * arg0, CRCamera * arg1)
{
    TraceTag((tagAPIEntry, "CRRender"));

    return (CRImage *) CreatePrim2(RenderImageOp, arg0, arg1);
}

extern Image *SolidColorImage(Color *col);
AxAPrimOp *SolidColorImageOp;
CRSTDAPI_(CRImage *) CRSolidColorImage(CRColor * arg0)
{
    TraceTag((tagAPIEntry, "CRSolidColorImage"));

    return (CRImage *) CreatePrim1(SolidColorImageOp, arg0);
}

extern Image *GradientPolygon(DM_ARRAYARG(Point2Value*, AxAArray*) points,
                              DM_ARRAYARG(Color*, AxAArray*) colors);
AxAPrimOp *GradientPolygonOp;
CRSTDAPI_(CRImage *) CRGradientPolygon(CRArrayPtr arg0, CRArrayPtr arg1)
{
    TraceTag((tagAPIEntry, "CRGradientPolygon"));

    CRImage * ret = NULL;

    APIPRECODE ;
    ret = (CRImage *) (PrimApplyBvr(GradientPolygonOp, 2, arg0, arg1));
    APIPOSTCODE ;
    return ret;
}

extern Image *GradientPolygon(DM_SAFEARRAYARG(Point2Value*, AxAArray*) points,
                              DM_SAFEARRAYARG(Color*, AxAArray*) colors);

extern Image *RadialGradientPolygon(Color *inner,
                                    Color *outer,
                                    DM_ARRAYARG(Point2Value*, AxAArray*) points,
                                    DoubleValue *fallOff);
AxAPrimOp *RadialGradientPolygonOp;
CRSTDAPI_(CRImage *) CRRadialGradientPolygon(CRColor * arg0, CRColor * arg1, CRArrayPtr arg2, double arg3)
{
    TraceTag((tagAPIEntry, "CRRadialGradientPolygon"));

    CRImage * ret = NULL;

    APIPRECODE ;
    ret = (CRImage *) (PrimApplyBvr(RadialGradientPolygonOp, 4, (arg0), (arg1), arg2, DoubleToNumBvr(arg3)));
    APIPOSTCODE ;
    return ret;
}

extern Image *RadialGradientPolygon(Color *inner, Color *outer,                                      DM_SAFEARRAYARG(Point2Value*, AxAArray*) points,                                      DoubleValue *fallOff);
extern Image *RadialGradientPolygon(Color *inner, Color *outer,                                      DM_ARRAYARG(Point2Value*, AxAArray*) points,                                      AxANumber *fallOff);
CRSTDAPI_(CRImage *) CRRadialGradientPolygon(CRColor * arg0, CRColor * arg1, CRArrayPtr arg2, CRNumber * arg3)
{
    TraceTag((tagAPIEntry, "CRRadialGradientPolygon"));

    CRImage * ret = NULL;

    APIPRECODE ;
    ret = (CRImage *) (PrimApplyBvr(RadialGradientPolygonOp, 4, (arg0), (arg1), arg2, (arg3)));
    APIPOSTCODE ;
    return ret;
}

extern Image *RadialGradientPolygon(Color *inner, Color *outer,
                                    DM_SAFEARRAYARG(Point2Value*, AxAArray*) points,
                                    AxANumber *fallOff);

extern Image *GradientSquare(Color *lowerLeft,                               Color *upperLeft,                               Color *upperRight,                               Color *lowerRight);
AxAPrimOp *GradientSquareOp;
CRSTDAPI_(CRImage *) CRGradientSquare(CRColor * arg0, CRColor * arg1, CRColor * arg2, CRColor * arg3)
{
    TraceTag((tagAPIEntry, "CRGradientSquare"));

    return (CRImage *) CreatePrim4(GradientSquareOp, arg0, arg1, arg2, arg3);
}

extern Image *RadialGradientSquare(Color *inner, Color *outer, DoubleValue *fallOff);
AxAPrimOp *RadialGradientSquareOp;
CRSTDAPI_(CRImage *) CRRadialGradientSquare(CRColor * arg0, CRColor * arg1, double arg2)
{
    TraceTag((tagAPIEntry, "CRRadialGradientSquare"));

    CRImage * ret = NULL;

    APIPRECODE ;
    ret = (CRImage *) (PrimApplyBvr(RadialGradientSquareOp, 3, (arg0), (arg1), DoubleToNumBvr(arg2)));
    APIPOSTCODE ;
    return ret;
}

extern Image *RadialGradientSquare(Color *inner, Color *outer, AxANumber *fallOff);
CRSTDAPI_(CRImage *) CRRadialGradientSquare(CRColor * arg0, CRColor * arg1, CRNumber * arg2)
{
    TraceTag((tagAPIEntry, "CRRadialGradientSquare"));

    return (CRImage *) CreatePrim3(RadialGradientSquareOp, arg0, arg1, arg2);
}

extern Image *RadialGradientRegularPoly(Color *inner,
                                        Color *outer,
                                        DoubleValue *numEdges,
                                        DoubleValue *fallOff);
AxAPrimOp *RadialGradientRegularPolyOp;
CRSTDAPI_(CRImage *) CRRadialGradientRegularPoly(CRColor * arg0, CRColor * arg1, double arg2, double arg3)
{
    TraceTag((tagAPIEntry, "CRRadialGradientRegularPoly"));

    CRImage * ret = NULL;

    APIPRECODE ;
    ret = (CRImage *) (PrimApplyBvr(RadialGradientRegularPolyOp, 4, (arg0), (arg1), DoubleToNumBvr(arg2), DoubleToNumBvr(arg3)));
    APIPOSTCODE ;
    return ret;
}

extern Image *RadialGradientRegularPoly(Color *inner,
                                        Color *outer,
                                        AxANumber *numEdges,
                                        AxANumber *fallOff);
CRSTDAPI_(CRImage *) CRRadialGradientRegularPoly(CRColor * arg0, CRColor * arg1, CRNumber * arg2, CRNumber * arg3)
{
    TraceTag((tagAPIEntry, "CRRadialGradientRegularPoly"));

    return (CRImage *) CreatePrim4(RadialGradientRegularPolyOp, arg0, arg1, arg2, arg3);
}

extern Image *RadialGradientMulticolor(DM_ARRAYARG(AxANumber*, AxAArray*) offsets,
                                       DM_ARRAYARG(Color*, AxAArray*) colors);
AxAPrimOp *RadialGradientMulticolorOp;
CRSTDAPI_(CRImage *) CRRadialGradientMulticolor(CRArrayPtr arg0, CRArrayPtr arg1)
{
    TraceTag((tagAPIEntry, "CRRadialGradientMulticolor"));

    CRImage * ret = NULL;

    APIPRECODE ;
    ret = (CRImage *) (PrimApplyBvr(RadialGradientMulticolorOp, 2, (arg0), (arg1)));
    APIPOSTCODE ;
    return ret;
}



extern Image *LinearGradientMulticolor(DM_ARRAYARG(AxANumber*, AxAArray*) offsets,
                                       DM_ARRAYARG(Color*, AxAArray*) colors);
AxAPrimOp *LinearGradientMulticolorOp;
CRSTDAPI_(CRImage *) CRLinearGradientMulticolor(CRArrayPtr arg0, CRArrayPtr arg1)
{
    TraceTag((tagAPIEntry, "CRLinearGradientMulticolor"));

    CRImage * ret = NULL;

    APIPRECODE ;
    ret = (CRImage *) (PrimApplyBvr(LinearGradientMulticolorOp, 2, (arg0), (arg1)));
    APIPOSTCODE ;
    return ret;
}


extern Image *GradientHorizontal(Color *start, Color *stop, DoubleValue *fallOff);
AxAPrimOp *GradientHorizontalOp;
CRSTDAPI_(CRImage *) CRGradientHorizontal(CRColor * arg0, CRColor * arg1, double arg2)
{
    TraceTag((tagAPIEntry, "CRGradientHorizontal"));

    CRImage * ret = NULL;

    APIPRECODE ;
    ret = (CRImage *) (PrimApplyBvr(GradientHorizontalOp, 3, (arg0), (arg1), DoubleToNumBvr(arg2)));
    APIPOSTCODE ;
    return ret;
}

extern Image *GradientHorizontal(Color *start, Color *stop, AxANumber *fallOff);
CRSTDAPI_(CRImage *) CRGradientHorizontal(CRColor * arg0, CRColor * arg1, CRNumber * arg2)
{
    TraceTag((tagAPIEntry, "CRGradientHorizontal"));

    return (CRImage *) CreatePrim3(GradientHorizontalOp, arg0, arg1, arg2);
}

extern Image *HatchHorizontal(Color *lineClr, PixelValue *spacing);
AxAPrimOp *HatchHorizontalOp;
CRSTDAPI_(CRImage *) CRHatchHorizontal(CRColor * arg0, double arg1)
{
    TraceTag((tagAPIEntry, "CRHatchHorizontal"));

    CRImage * ret = NULL;

    APIPRECODE ;
    ret = (CRImage *) (PrimApplyBvr(HatchHorizontalOp, 2, (arg0), DoubleToNumBvr(arg1)));
    APIPOSTCODE ;
    return ret;
}

extern Image *HatchHorizontal(Color *lineClr, AnimPixelValue *spacing);
CRSTDAPI_(CRImage *) CRHatchHorizontal(CRColor * arg0, CRNumber * arg1)
{
    TraceTag((tagAPIEntry, "CRHatchHorizontal"));

    return (CRImage *) CreatePrim2(HatchHorizontalOp, arg0, arg1);
}

extern Image *HatchVertical(Color *lineClr, PixelValue *spacing);
AxAPrimOp *HatchVerticalOp;
CRSTDAPI_(CRImage *) CRHatchVertical(CRColor * arg0, double arg1)
{
    TraceTag((tagAPIEntry, "CRHatchVertical"));

    CRImage * ret = NULL;

    APIPRECODE ;
    ret = (CRImage *) (PrimApplyBvr(HatchVerticalOp, 2, (arg0), DoubleToNumBvr(arg1)));
    APIPOSTCODE ;
    return ret;
}

extern Image *HatchVertical(Color *lineClr, AnimPixelValue *spacing);
CRSTDAPI_(CRImage *) CRHatchVertical(CRColor * arg0, CRNumber * arg1)
{
    TraceTag((tagAPIEntry, "CRHatchVertical"));

    return (CRImage *) CreatePrim2(HatchVerticalOp, arg0, arg1);
}

extern Image *HatchForwardDiagonal(Color *lineClr, PixelValue *spacing);
AxAPrimOp *HatchForwardDiagonalOp;
CRSTDAPI_(CRImage *) CRHatchForwardDiagonal(CRColor * arg0, double arg1)
{
    TraceTag((tagAPIEntry, "CRHatchForwardDiagonal"));

    CRImage * ret = NULL;

    APIPRECODE ;
    ret = (CRImage *) (PrimApplyBvr(HatchForwardDiagonalOp, 2, (arg0), DoubleToNumBvr(arg1)));
    APIPOSTCODE ;
    return ret;
}

extern Image *HatchForwardDiagonal(Color *lineClr, AnimPixelValue *spacing);
CRSTDAPI_(CRImage *) CRHatchForwardDiagonal(CRColor * arg0, CRNumber * arg1)
{
    TraceTag((tagAPIEntry, "CRHatchForwardDiagonal"));

    return (CRImage *) CreatePrim2(HatchForwardDiagonalOp, arg0, arg1);
}

extern Image *HatchBackwardDiagonal(Color *lineClr, PixelValue *spacing);
AxAPrimOp *HatchBackwardDiagonalOp;
CRSTDAPI_(CRImage *) CRHatchBackwardDiagonal(CRColor * arg0, double arg1)
{
    TraceTag((tagAPIEntry, "CRHatchBackwardDiagonal"));

    CRImage * ret = NULL;

    APIPRECODE ;
    ret = (CRImage *) (PrimApplyBvr(HatchBackwardDiagonalOp, 2, (arg0), DoubleToNumBvr(arg1)));
    APIPOSTCODE ;
    return ret;
}

extern Image *HatchBackwardDiagonal(Color *lineClr, AnimPixelValue *spacing);
CRSTDAPI_(CRImage *) CRHatchBackwardDiagonal(CRColor * arg0, CRNumber * arg1)
{
    TraceTag((tagAPIEntry, "CRHatchBackwardDiagonal"));

    return (CRImage *) CreatePrim2(HatchBackwardDiagonalOp, arg0, arg1);
}

extern Image *HatchCross(Color *lineClr, PixelValue *spacing);
AxAPrimOp *HatchCrossOp;
CRSTDAPI_(CRImage *) CRHatchCross(CRColor * arg0, double arg1)
{
    TraceTag((tagAPIEntry, "CRHatchCross"));

    CRImage * ret = NULL;

    APIPRECODE ;
    ret = (CRImage *) (PrimApplyBvr(HatchCrossOp, 2, (arg0), DoubleToNumBvr(arg1)));
    APIPOSTCODE ;
    return ret;
}

extern Image *HatchCross(Color *lineClr, AnimPixelValue *spacing);
CRSTDAPI_(CRImage *) CRHatchCross(CRColor * arg0, CRNumber * arg1)
{
    TraceTag((tagAPIEntry, "CRHatchCross"));

    return (CRImage *) CreatePrim2(HatchCrossOp, arg0, arg1);
}

extern Image *HatchDiagonalCross(Color *lineClr, PixelValue *spacing);
AxAPrimOp *HatchDiagonalCrossOp;
CRSTDAPI_(CRImage *) CRHatchDiagonalCross(CRColor * arg0, double arg1)
{
    TraceTag((tagAPIEntry, "CRHatchDiagonalCross"));

    CRImage * ret = NULL;

    APIPRECODE ;
    ret = (CRImage *) (PrimApplyBvr(HatchDiagonalCrossOp, 2, (arg0), DoubleToNumBvr(arg1)));
    APIPOSTCODE ;
    return ret;
}

extern Image *HatchDiagonalCross(Color *lineClr, AnimPixelValue *spacing);
CRSTDAPI_(CRImage *) CRHatchDiagonalCross(CRColor * arg0, CRNumber * arg1)
{
    TraceTag((tagAPIEntry, "CRHatchDiagonalCross"));

    return (CRImage *) CreatePrim2(HatchDiagonalCrossOp, arg0, arg1);
}

extern Image *Overlay(Image *top, Image *bottom);
AxAPrimOp *OverlayOp;
CRSTDAPI_(CRImage *) CROverlay(CRImage * arg0, CRImage * arg1)
{
    TraceTag((tagAPIEntry, "CROverlay"));

    return (CRImage *) CreatePrim2(OverlayOp, arg0, arg1);
}

extern Image *OverlayArray(DM_ARRAYARG(Image*, AxAArray*) imgs);
AxAPrimOp *OverlayArrayOp;
CRSTDAPI_(CRImage *) CROverlay(CRArrayPtr arg0)
{
    TraceTag((tagAPIEntry, "CROverlay"));

    CRImage * ret = NULL;

    APIPRECODE ;
    ret = (CRImage *) (PrimApplyBvr(OverlayArrayOp, 1, arg0));
    APIPOSTCODE ;
    return ret;
}

extern Image *OverlayArray(DM_SAFEARRAYARG(Image*, AxAArray*) imgs);
extern Bbox2Value *BoundingBox(Image *image);
AxAPrimOp *BoundingBoxOp;
CRSTDAPI_(CRBbox2 *) CRBoundingBox(CRImage * arg0)
{
    TraceTag((tagAPIEntry, "CRBoundingBox"));

    return (CRBbox2 *) CreatePrim1(BoundingBoxOp, arg0);
}

extern Image *CropImage(Point2Value *min, Point2Value *max, Image *image);
AxAPrimOp *CropImageOp;
CRSTDAPI_(CRImage *) CRCrop(CRImage * arg2, CRPoint2 * arg0, CRPoint2 * arg1)
{
    TraceTag((tagAPIEntry, "CRCrop"));

    return (CRImage *) CreatePrim3(CropImageOp, arg0, arg1, arg2);
}

extern Image *TransformImage(Transform2 *xf, Image *image);
AxAPrimOp *TransformImageOp;
CRSTDAPI_(CRImage *) CRTransform(CRImage * arg1, CRTransform2 * arg0)
{
    TraceTag((tagAPIEntry, "CRTransform"));

    return (CRImage *) CreatePrim2(TransformImageOp, arg0, arg1);
}

extern Image *OpaqueImage(AxANumber *opacity, Image *image);
AxAPrimOp *OpaqueImageOp;
CRSTDAPI_(CRImage *) CROpacity(CRImage * arg1, CRNumber * arg0)
{
    TraceTag((tagAPIEntry, "CROpacity"));

    return (CRImage *) CreatePrim2(OpaqueImageOp, arg0, arg1);
}

extern Image *OpaqueImage(DoubleValue *opacity, Image *image);
CRSTDAPI_(CRImage *) CROpacity(CRImage * arg1, double arg0)
{
    TraceTag((tagAPIEntry, "CROpacity"));

    CRImage * ret = NULL;

    APIPRECODE ;
    ret = (CRImage *) (PrimApplyBvr(OpaqueImageOp, 2, DoubleToNumBvr(arg0), (arg1)));
    APIPOSTCODE ;
    return ret;
}

extern Image *UndetectableImage(Image *image);
AxAPrimOp *UndetectableImageOp;
CRSTDAPI_(CRImage *) CRUndetectable(CRImage * arg0)
{
    TraceTag((tagAPIEntry, "CRUndetectable"));

    return (CRImage *) CreatePrim1(UndetectableImageOp, arg0);
}

extern Image *TileImage(Image *image);
AxAPrimOp *TileImageOp;
CRSTDAPI_(CRImage *) CRTile(CRImage * arg0)
{
    TraceTag((tagAPIEntry, "CRTile"));

    return (CRImage *) CreatePrim1(TileImageOp, arg0);
}

extern Image *ClipImage(Matte *m, Image *image);
AxAPrimOp *ClipImageOp;
CRSTDAPI_(CRImage *) CRClip(CRImage * arg1, CRMatte * arg0)
{
    TraceTag((tagAPIEntry, "CRClip"));

    return (CRImage *) CreatePrim2(ClipImageOp, arg0, arg1);
}

extern Image *MapToUnitSquare(Image *image);
AxAPrimOp *MapToUnitSquareOp;
CRSTDAPI_(CRImage *) CRMapToUnitSquare(CRImage * arg0)
{
    TraceTag((tagAPIEntry, "CRMapToUnitSquare"));

    return (CRImage *) CreatePrim1(MapToUnitSquareOp, arg0);
}

extern Image *ClipPolygon(DM_ARRAYARG(Point2Value*, AxAArray*) points,                            Image* image);
AxAPrimOp *ClipPolygonOp;
CRSTDAPI_(CRImage *) CRClipPolygonImage(CRImage * arg1, CRArrayPtr arg0)
{
    TraceTag((tagAPIEntry, "CRClipPolygonImage"));

    CRImage * ret = NULL;

    APIPRECODE ;
    ret = (CRImage *) (PrimApplyBvr(ClipPolygonOp, 2, arg0, (arg1)));
    APIPOSTCODE ;
    return ret;
}

extern Image *ClipPolygon(DM_SAFEARRAYARG(Point2Value*, AxAArray*) points,                            Image* image);
extern Bvr RenderResolution (Bvr, long, long);
CRSTDAPI_(CRImage *) CRRenderResolution(CRImage * arg0, long arg1, long arg2)
{
    TraceTag((tagAPIEntry, "CRRenderResolution"));

    CRImage * ret = NULL;

    APIPRECODE ;
    ret = (CRImage *) (::RenderResolution((arg0), (arg1), (arg2)));
    APIPOSTCODE ;
    return ret;
}

extern Bvr ImageQuality (Bvr, DWORD);
CRSTDAPI_(CRImage *) CRImageQuality(CRImage * arg0, DWORD arg1)
{
    TraceTag((tagAPIEntry, "CRImageQuality"));

    CRImage * ret = NULL;

    APIPRECODE ;
    ret = (CRImage *) (::ImageQuality((arg0), (arg1)));
    APIPOSTCODE ;
    return ret;
}

extern Image *ConstructColorKeyedImage(Image *image, Color *colorKey);
AxAPrimOp *ConstructColorKeyedImageOp;
CRSTDAPI_(CRImage *) CRColorKey(CRImage * arg0, CRColor * arg1)
{
    TraceTag((tagAPIEntry, "CRColorKey"));

    return (CRImage *) CreatePrim2(ConstructColorKeyedImageOp, arg0, arg1);
}

extern Image *TransformColorRGBImage(Image *image, Transform3 *xf);
AxAPrimOp *TransformColorRGBImageOp;
CRSTDAPI_(CRImage *) CRTransformColorRGB(CRImage * arg0, CRTransform3 * arg1)
{
    TraceTag((tagAPIEntry, "CRTransformColorRGB"));

    return (CRImage *) CreatePrim2(TransformColorRGBImageOp, arg0, arg1);
}


extern Geometry *ambientLight;
CRGeometry * g_varCRAmbientLight;
CRSTDAPI_(CRGeometry *) CRAmbientLight()
{
    return g_varCRAmbientLight;
}
extern Geometry *directionalLight;
CRGeometry * g_varCRDirectionalLight;
CRSTDAPI_(CRGeometry *) CRDirectionalLight()
{
    return g_varCRDirectionalLight;
}
extern Geometry *pointLight;
CRGeometry * g_varCRPointLight;
CRSTDAPI_(CRGeometry *) CRPointLight()
{
    return g_varCRPointLight;
}
extern Geometry *SpotLight(AxANumber *fullcone, AxANumber *cutoff);
AxAPrimOp *SpotLightOp;
CRSTDAPI_(CRGeometry *) CRSpotLight(CRNumber * arg0, CRNumber * arg1)
{
    TraceTag((tagAPIEntry, "CRSpotLight"));

    return (CRGeometry *) CreatePrim2(SpotLightOp, arg0, arg1);
}

extern Geometry *SpotLight(AxANumber *fullcone, DoubleValue *cutoff);
CRSTDAPI_(CRGeometry *) CRSpotLight(CRNumber * arg0, double arg1)
{
    TraceTag((tagAPIEntry, "CRSpotLight"));

    CRGeometry * ret = NULL;

    APIPRECODE ;
    ret = (CRGeometry *) (PrimApplyBvr(SpotLightOp, 2, (arg0), DoubleToNumBvr(arg1)));
    APIPOSTCODE ;
    return ret;
}

extern Geometry *applyLightColor(Color *color, Geometry *geom);
AxAPrimOp *applyLightColorOp;
CRSTDAPI_(CRGeometry *) CRLightColor(CRGeometry * arg1, CRColor * arg0)
{
    TraceTag((tagAPIEntry, "CRLightColor"));

    return (CRGeometry *) CreatePrim2(applyLightColorOp, arg0, arg1);
}

extern Geometry *applyLightRange(AxANumber *range, Geometry *geom);
AxAPrimOp *applyLightRangeOp;
CRSTDAPI_(CRGeometry *) CRLightRange(CRGeometry * arg1, CRNumber * arg0)
{
    TraceTag((tagAPIEntry, "CRLightRange"));

    return (CRGeometry *) CreatePrim2(applyLightRangeOp, arg0, arg1);
}

extern Geometry *applyLightRange(DoubleValue *range, Geometry *geom);
CRSTDAPI_(CRGeometry *) CRLightRange(CRGeometry * arg1, double arg0)
{
    TraceTag((tagAPIEntry, "CRLightRange"));

    CRGeometry * ret = NULL;

    APIPRECODE ;
    ret = (CRGeometry *) (PrimApplyBvr(applyLightRangeOp, 2, DoubleToNumBvr(arg0), (arg1)));
    APIPOSTCODE ;
    return ret;
}

extern Geometry *applyLightAttenuation (AxANumber *constant,                                           AxANumber *linear,                                           AxANumber *quadratic, Geometry *geom) ;
AxAPrimOp *applyLightAttenuationOp;
CRSTDAPI_(CRGeometry *) CRLightAttenuation(CRGeometry * arg3, CRNumber * arg0, CRNumber * arg1, CRNumber * arg2)
{
    TraceTag((tagAPIEntry, "CRLightAttenuation"));

    return (CRGeometry *) CreatePrim4(applyLightAttenuationOp, arg0, arg1, arg2, arg3);
}

extern Geometry *applyLightAttenuation (DoubleValue *constant,                                           DoubleValue *linear,                                           DoubleValue *quadratic,                                           Geometry *geom) ;
CRSTDAPI_(CRGeometry *) CRLightAttenuation(CRGeometry * arg3, double arg0, double arg1, double arg2)
{
    TraceTag((tagAPIEntry, "CRLightAttenuation"));

    CRGeometry * ret = NULL;

    APIPRECODE ;
    ret = (CRGeometry *) (PrimApplyBvr(applyLightAttenuationOp, 4, DoubleToNumBvr(arg0), DoubleToNumBvr(arg1), DoubleToNumBvr(arg2), (arg3)));
    APIPOSTCODE ;
    return ret;
}

extern Geometry *BlendTextureDiffuse (Geometry *geometry, AxABoolean *blended);
AxAPrimOp *BlendTextureDiffuseOp;
CRSTDAPI_(CRGeometry *) CRBlendTextureDiffuse(CRGeometry * arg0, CRBoolean * arg1)
{
    TraceTag((tagAPIEntry, "CRBlendTextureDiffuse"));

    return (CRGeometry *) CreatePrim2(BlendTextureDiffuseOp, arg0, arg1);
}

extern Geometry *applyAmbientColor (Color *color, Geometry *geo);
AxAPrimOp *applyAmbientColorOp;
CRSTDAPI_(CRGeometry *) CRAmbientColor(CRGeometry * arg1, CRColor * arg0)
{
    TraceTag((tagAPIEntry, "CRAmbientColor"));

    return (CRGeometry *) CreatePrim2(applyAmbientColorOp, arg0, arg1);
}

extern Bvr applyD3DRMTexture (Bvr, LPUNKNOWN);
CRSTDAPI_(CRGeometry *) CRD3DRMTexture(CRGeometry * arg0, IUnknown * arg1)
{
    TraceTag((tagAPIEntry, "CRD3DRMTexture"));

    CRGeometry * ret = NULL;

    APIPRECODE ;
    ret = (CRGeometry *) (::applyD3DRMTexture((arg0), (arg1)));
    APIPOSTCODE ;
    return ret;
}

extern Geometry *applyModelClip (Point3Value *planePt, Vector3Value *planeVec, Geometry *geo);
AxAPrimOp *applyModelClipOp;
CRSTDAPI_(CRGeometry *) CRModelClip(CRGeometry * arg2, CRPoint3 * arg0, CRVector3 * arg1)
{
    TraceTag((tagAPIEntry, "CRModelClip"));

    return (CRGeometry *) CreatePrim3(applyModelClipOp, arg0, arg1, arg2);
}


extern Geometry *applyLighting (AxABoolean *lighting, Geometry *geo);
AxAPrimOp *applyLightingOp;
CRSTDAPI_(CRGeometry *) CRLighting(CRGeometry * arg1, CRBoolean * arg0)
{
    TraceTag((tagAPIEntry, "CRLighting"));

    return (CRGeometry *) CreatePrim2(applyLightingOp, arg0, arg1);
}


extern Geometry *applyTextureImage (Image *texture, Geometry *geo);
AxAPrimOp *applyTextureImageOp;
CRSTDAPI_(CRGeometry *) CRTextureImage(CRGeometry * arg1, CRImage * arg0)
{
    TraceTag((tagAPIEntry, "CRTextureImage"));

    return (CRGeometry *) CreatePrim2(applyTextureImageOp, arg0, arg1);
}


extern Geometry* Billboard (Geometry*, Vector3Value*);
AxAPrimOp *BillboardOp;
CRSTDAPI_(CRGeometry*) CRBillboard (CRGeometry *geo, CRVector3 *axis)
{
    TraceTag ((tagAPIEntry, "CRBillboard"));
    return (CRGeometry*) CreatePrim2 (BillboardOp, geo, axis);
}


class TriMeshData;
extern Bvr TriMeshBvr (TriMeshData&);
CRSTDAPI_(CRGeometry*) CRTriMesh (TriMeshData &tm)
{
    TraceTag ((tagAPIEntry, "CRTriMesh"));

    CRGeometry *trimesh;

    APIPRECODE;

    trimesh = (CRGeometry*) TriMeshBvr (tm);

    APIPOSTCODE;

    return trimesh;
}


extern LineStyle *defaultLineStyle;
CRLineStyle * g_varCRDefaultLineStyle;
CRSTDAPI_(CRLineStyle *) CRDefaultLineStyle()
{
    return g_varCRDefaultLineStyle;
}
extern LineStyle *emptyLineStyle;
CRLineStyle * g_varCREmptyLineStyle;
CRSTDAPI_(CRLineStyle *) CREmptyLineStyle()
{
    return g_varCREmptyLineStyle;
}
extern LineStyle *LineEndStyle(EndStyle *sty, LineStyle *lsty);
AxAPrimOp *LineEndStyleOp;
CRSTDAPI_(CRLineStyle *) CREnd(CRLineStyle * arg1, CREndStyle * arg0)
{
    TraceTag((tagAPIEntry, "CREnd"));

    return (CRLineStyle *) CreatePrim2(LineEndStyleOp, arg0, arg1);
}

extern LineStyle *LineJoinStyle(JoinStyle *sty, LineStyle *lsty);
AxAPrimOp *LineJoinStyleOp;
CRSTDAPI_(CRLineStyle *) CRJoin(CRLineStyle * arg1, CRJoinStyle * arg0)
{
    TraceTag((tagAPIEntry, "CRJoin"));

    return (CRLineStyle *) CreatePrim2(LineJoinStyleOp, arg0, arg1);
}

extern LineStyle *LineDashStyle(DashStyle *sty, LineStyle *lsty);
AxAPrimOp *LineDashStyleOp;
CRSTDAPI_(CRLineStyle *) CRDash(CRLineStyle * arg1, CRDashStyle * arg0)
{
    TraceTag((tagAPIEntry, "CRDash"));

    return (CRLineStyle *) CreatePrim2(LineDashStyleOp, arg0, arg1);
}

extern LineStyle *LineWidthStyle(AnimPointValue *sty, LineStyle *lsty);
AxAPrimOp *LineWidthStyleOp;
CRSTDAPI_(CRLineStyle *) CRWidth(CRLineStyle * arg1, CRNumber * arg0)
{
    TraceTag((tagAPIEntry, "CRWidth"));

    return (CRLineStyle *) CreatePrim2(LineWidthStyleOp, arg0, arg1);
}

extern LineStyle *LineWidthStyle(PointValue *sty, LineStyle *lsty);
CRSTDAPI_(CRLineStyle *) CRWidth(CRLineStyle * arg1, double arg0)
{
    TraceTag((tagAPIEntry, "CRWidth"));

    CRLineStyle * ret = NULL;

    APIPRECODE ;
    ret = (CRLineStyle *) (PrimApplyBvr(LineWidthStyleOp, 2, DoubleToNumBvr(arg0), (arg1)));
    APIPOSTCODE ;
    return ret;
}

extern LineStyle *LineAntiAliasing(DoubleValue *aaStyle, LineStyle *lsty);
AxAPrimOp *LineAntiAliasingOp;
CRSTDAPI_(CRLineStyle *) CRAntiAliasing(CRLineStyle * arg1, double arg0)
{
    TraceTag((tagAPIEntry, "CRAntiAliasing"));

    CRLineStyle * ret = NULL;

    APIPRECODE ;
    ret = (CRLineStyle *) (PrimApplyBvr(LineAntiAliasingOp, 2, DoubleToNumBvr(arg0), (arg1)));
    APIPOSTCODE ;
    return ret;
}

extern LineStyle *LineDetailStyle(LineStyle *lsty);
AxAPrimOp *LineDetailStyleOp;
CRSTDAPI_(CRLineStyle *) CRDetail(CRLineStyle * arg0)
{
    TraceTag((tagAPIEntry, "CRDetail"));

    return (CRLineStyle *) CreatePrim1(LineDetailStyleOp, arg0);
}

extern LineStyle *LineColor(Color *clr, LineStyle *lsty);
AxAPrimOp *LineColorOp;
CRSTDAPI_(CRLineStyle *) CRLineColor(CRLineStyle * arg1, CRColor * arg0)
{
    TraceTag((tagAPIEntry, "CRLineColor"));

    return (CRLineStyle *) CreatePrim2(LineColorOp, arg0, arg1);
}

extern JoinStyle *joinStyleBevel;
CRJoinStyle * g_varCRJoinStyleBevel;
CRSTDAPI_(CRJoinStyle *) CRJoinStyleBevel()
{
    return g_varCRJoinStyleBevel;
}
extern JoinStyle *joinStyleRound;
CRJoinStyle * g_varCRJoinStyleRound;
CRSTDAPI_(CRJoinStyle *) CRJoinStyleRound()
{
    return g_varCRJoinStyleRound;
}
extern JoinStyle *joinStyleMiter;
CRJoinStyle * g_varCRJoinStyleMiter;
CRSTDAPI_(CRJoinStyle *) CRJoinStyleMiter()
{
    return g_varCRJoinStyleMiter;
}
extern EndStyle *endStyleFlat;
CREndStyle * g_varCREndStyleFlat;
CRSTDAPI_(CREndStyle *) CREndStyleFlat()
{
    return g_varCREndStyleFlat;
}
extern EndStyle *endStyleSquare;
CREndStyle * g_varCREndStyleSquare;
CRSTDAPI_(CREndStyle *) CREndStyleSquare()
{
    return g_varCREndStyleSquare;
}
extern EndStyle *endStyleRound;
CREndStyle * g_varCREndStyleRound;
CRSTDAPI_(CREndStyle *) CREndStyleRound()
{
    return g_varCREndStyleRound;
}
extern DashStyle *dashStyleSolid;
CRDashStyle * g_varCRDashStyleSolid;
CRSTDAPI_(CRDashStyle *) CRDashStyleSolid()
{
    return g_varCRDashStyleSolid;
}
extern DashStyle *dashStyleDashed;
CRDashStyle * g_varCRDashStyleDashed;
CRSTDAPI_(CRDashStyle *) CRDashStyleDashed()
{
    return g_varCRDashStyleDashed;
}
extern Bvr ConstructLineStyleDashStyle (Bvr, DWORD);
CRSTDAPI_(CRLineStyle *) CRDashEx(CRLineStyle * arg0, DWORD arg1)
{
    TraceTag((tagAPIEntry, "CRDashEx"));

    CRLineStyle * ret = NULL;

    APIPRECODE ;
    ret = (CRLineStyle *) (::ConstructLineStyleDashStyle((arg0), (arg1)));
    APIPOSTCODE ;
    return ret;
}

extern LineStyle *ConstructLineStyleMiterLimit(LineStyle *ls, DoubleValue *mtrlim);
AxAPrimOp *ConstructLineStyleMiterLimitOp;
CRSTDAPI_(CRLineStyle *) CRMiterLimit(CRLineStyle * arg0, double arg1)
{
    TraceTag((tagAPIEntry, "CRMiterLimit"));

    CRLineStyle * ret = NULL;

    APIPRECODE ;
    ret = (CRLineStyle *) (PrimApplyBvr(ConstructLineStyleMiterLimitOp, 2, (arg0), DoubleToNumBvr(arg1)));
    APIPOSTCODE ;
    return ret;
}

extern LineStyle *ConstructLineStyleMiterLimit(LineStyle *ls, AxANumber *mtrlim);
CRSTDAPI_(CRLineStyle *) CRMiterLimit(CRLineStyle * arg0, CRNumber * arg1)
{
    TraceTag((tagAPIEntry, "CRMiterLimit"));

    return (CRLineStyle *) CreatePrim2(ConstructLineStyleMiterLimitOp, arg0, arg1);
}

extern Bvr ConstructLineStyleJoinStyle (Bvr, DWORD);
CRSTDAPI_(CRLineStyle *) CRJoinEx(CRLineStyle * arg0, DWORD arg1)
{
    TraceTag((tagAPIEntry, "CRJoinEx"));

    CRLineStyle * ret = NULL;

    APIPRECODE ;
    ret = (CRLineStyle *) (::ConstructLineStyleJoinStyle((arg0), (arg1)));
    APIPOSTCODE ;
    return ret;
}

extern Bvr ConstructLineStyleEndStyle (Bvr, DWORD);
CRSTDAPI_(CRLineStyle *) CREndEx(CRLineStyle * arg0, DWORD arg1)
{
    TraceTag((tagAPIEntry, "CREndEx"));

    CRLineStyle * ret = NULL;

    APIPRECODE ;
    ret = (CRLineStyle *) (::ConstructLineStyleEndStyle((arg0), (arg1)));
    APIPOSTCODE ;
    return ret;
}

extern Microphone *defaultMicrophone;
CRMicrophone * g_varCRDefaultMicrophone;
CRSTDAPI_(CRMicrophone *) CRDefaultMicrophone()
{
    return g_varCRDefaultMicrophone;
}
extern Microphone *TransformMicrophone(Transform3 *xf, Microphone *mic);
AxAPrimOp *TransformMicrophoneOp;
CRSTDAPI_(CRMicrophone *) CRTransform(CRMicrophone * arg1, CRTransform3 * arg0)
{
    TraceTag((tagAPIEntry, "CRTransform"));

    return (CRMicrophone *) CreatePrim2(TransformMicrophoneOp, arg0, arg1);
}

extern Matte *opaqueMatte;
CRMatte * g_varCROpaqueMatte;
CRSTDAPI_(CRMatte *) CROpaqueMatte()
{
    return g_varCROpaqueMatte;
}
extern Matte *clearMatte;
CRMatte * g_varCRClearMatte;
CRSTDAPI_(CRMatte *) CRClearMatte()
{
    return g_varCRClearMatte;
}
extern Matte *UnionMatte(Matte *m1, Matte *m2);
AxAPrimOp *UnionMatteOp;
CRSTDAPI_(CRMatte *) CRUnionMatte(CRMatte * arg0, CRMatte * arg1)
{
    TraceTag((tagAPIEntry, "CRUnionMatte"));

    return (CRMatte *) CreatePrim2(UnionMatteOp, arg0, arg1);
}

extern Matte *IntersectMatte(Matte *m1, Matte *m2);
AxAPrimOp *IntersectMatteOp;
CRSTDAPI_(CRMatte *) CRIntersectMatte(CRMatte * arg0, CRMatte * arg1)
{
    TraceTag((tagAPIEntry, "CRIntersectMatte"));

    return (CRMatte *) CreatePrim2(IntersectMatteOp, arg0, arg1);
}

extern Matte *SubtractMatte(Matte *m1, Matte *m2);
AxAPrimOp *SubtractMatteOp;
CRSTDAPI_(CRMatte *) CRDifferenceMatte(CRMatte * arg0, CRMatte * arg1)
{
    TraceTag((tagAPIEntry, "CRDifferenceMatte"));

    return (CRMatte *) CreatePrim2(SubtractMatteOp, arg0, arg1);
}

extern Matte *TransformMatte(Transform2 *xf, Matte *m);
AxAPrimOp *TransformMatteOp;
CRSTDAPI_(CRMatte *) CRTransform(CRMatte * arg1, CRTransform2 * arg0)
{
    TraceTag((tagAPIEntry, "CRTransform"));

    return (CRMatte *) CreatePrim2(TransformMatteOp, arg0, arg1);
}

extern Matte *RegionFromPath(Path2 *p);
AxAPrimOp *RegionFromPathOp;
CRSTDAPI_(CRMatte *) CRFillMatte(CRPath2 * arg0)
{
    TraceTag((tagAPIEntry, "CRFillMatte"));

    return (CRMatte *) CreatePrim1(RegionFromPathOp, arg0);
}

extern Matte *TextMatteConstructor(AxAString *str, FontStyle *fs);
AxAPrimOp *TextMatteConstructorOp;
CRSTDAPI_(CRMatte *) CRTextMatte(CRString * arg0, CRFontStyle * arg1)
{
    TraceTag((tagAPIEntry, "CRTextMatte"));

    return (CRMatte *) CreatePrim2(TextMatteConstructorOp, arg0, arg1);
}

extern Montage *emptyMontage;
CRMontage * g_varCREmptyMontage;
CRSTDAPI_(CRMontage *) CREmptyMontage()
{
    return g_varCREmptyMontage;
}
extern Montage *ImageMontage(Image *im, DoubleValue *depth);
AxAPrimOp *ImageMontageOp;
CRSTDAPI_(CRMontage *) CRImageMontage(CRImage * arg0, double arg1)
{
    TraceTag((tagAPIEntry, "CRImageMontage"));

    CRMontage * ret = NULL;

    APIPRECODE ;
    ret = (CRMontage *) (PrimApplyBvr(ImageMontageOp, 2, (arg0), DoubleToNumBvr(arg1)));
    APIPOSTCODE ;
    return ret;
}

extern Montage *ImageMontage(Image *im, AxANumber *depth);
CRSTDAPI_(CRMontage *) CRImageMontageAnim(CRImage * arg0, CRNumber * arg1)
{
    TraceTag((tagAPIEntry, "CRImageMontageAnim"));

    return (CRMontage *) CreatePrim2(ImageMontageOp, arg0, arg1);
}

extern Montage *UnionMontageMontage(Montage *m1, Montage *m2);
AxAPrimOp *UnionMontageMontageOp;
CRSTDAPI_(CRMontage *) CRUnionMontage(CRMontage * arg0, CRMontage * arg1)
{
    TraceTag((tagAPIEntry, "CRUnionMontage"));

    return (CRMontage *) CreatePrim2(UnionMontageMontageOp, arg0, arg1);
}

extern Image *Render(Montage *m);
AxAPrimOp *RenderOp;
CRSTDAPI_(CRImage *) CRRender(CRMontage * arg0)
{
    TraceTag((tagAPIEntry, "CRRender"));

    return (CRImage *) CreatePrim1(RenderOp, arg0);
}

extern Path2 *ConcatenatePath2(Path2 *p1, Path2 *p2);
AxAPrimOp *ConcatenatePath2Op;
CRSTDAPI_(CRPath2 *) CRConcat(CRPath2 * arg0, CRPath2 * arg1)
{
    TraceTag((tagAPIEntry, "CRConcat"));

    return (CRPath2 *) CreatePrim2(ConcatenatePath2Op, arg0, arg1);
}

extern Path2 *Concat2Array(DM_ARRAYARG(Path2*, AxAArray*) paths);
AxAPrimOp *Concat2ArrayOp;
CRSTDAPI_(CRPath2 *) CRConcat(CRArrayPtr arg0)
{
    TraceTag((tagAPIEntry, "CRConcat"));

    CRPath2 * ret = NULL;

    APIPRECODE ;
    ret = (CRPath2 *) (PrimApplyBvr(Concat2ArrayOp, 1, arg0));
    APIPOSTCODE ;
    return ret;
}

extern Path2 *Concat2Array(DM_SAFEARRAYARG(Path2*, AxAArray*) paths);
extern Path2 *TransformPath2(Transform2 *xf, Path2 *p);
AxAPrimOp *TransformPath2Op;
CRSTDAPI_(CRPath2 *) CRTransform(CRPath2 * arg1, CRTransform2 * arg0)
{
    TraceTag((tagAPIEntry, "CRTransform"));

    return (CRPath2 *) CreatePrim2(TransformPath2Op, arg0, arg1);
}

extern Bbox2Value *BoundingBoxPath(LineStyle *style, Path2 *p);
AxAPrimOp *BoundingBoxPathOp;
CRSTDAPI_(CRBbox2 *) CRBoundingBox(CRPath2 * arg1, CRLineStyle * arg0)
{
    TraceTag((tagAPIEntry, "CRBoundingBox"));

    return (CRBbox2 *) CreatePrim2(BoundingBoxPathOp, arg0, arg1);
}

extern Image *PathFill(LineStyle *border, Image *fill, Path2 *p);
AxAPrimOp *PathFillOp;
CRSTDAPI_(CRImage *) CRFill(CRPath2 * arg2, CRLineStyle * arg0, CRImage * arg1)
{
    TraceTag((tagAPIEntry, "CRFill"));

    return (CRImage *) CreatePrim3(PathFillOp, arg0, arg1, arg2);
}

extern Image *DrawPath(LineStyle *border, Path2 *p);
AxAPrimOp *DrawPathOp;
CRSTDAPI_(CRImage *) CRDraw(CRPath2 * arg1, CRLineStyle * arg0)
{
    TraceTag((tagAPIEntry, "CRDraw"));

    return (CRImage *) CreatePrim2(DrawPathOp, arg0, arg1);
}

extern Path2 *ClosePath2(Path2 *p);
AxAPrimOp *ClosePath2Op;
CRSTDAPI_(CRPath2 *) CRClose(CRPath2 * arg0)
{
    TraceTag((tagAPIEntry, "CRClose"));

    return (CRPath2 *) CreatePrim1(ClosePath2Op, arg0);
}

extern Path2 *Line2(Point2Value *p1, Point2Value *p2);
AxAPrimOp *Line2Op;
CRSTDAPI_(CRPath2 *) CRLine(CRPoint2 * arg0, CRPoint2 * arg1)
{
    TraceTag((tagAPIEntry, "CRLine"));

    return (CRPath2 *) CreatePrim2(Line2Op, arg0, arg1);
}

extern Path2 *RelativeLine2(Point2Value *pt);
AxAPrimOp *RelativeLine2Op;
CRSTDAPI_(CRPath2 *) CRRay(CRPoint2 * arg0)
{
    TraceTag((tagAPIEntry, "CRRay"));

    return (CRPath2 *) CreatePrim1(RelativeLine2Op, arg0);
}

extern Path2 *TextPath2Constructor(AxAString *str, FontStyle *fs);
AxAPrimOp *TextPath2ConstructorOp;
CRSTDAPI_(CRPath2 *) CRStringPath(CRString * arg0, CRFontStyle * arg1)
{
    TraceTag((tagAPIEntry, "CRStringPath"));

    return (CRPath2 *) CreatePrim2(TextPath2ConstructorOp, arg0, arg1);
}

extern Path2 *TextPath2Constructor(StringValue *str, FontStyle *fs);
CRSTDAPI_(CRPath2 *) CRStringPath(LPWSTR arg0, CRFontStyle * arg1)
{
    TraceTag((tagAPIEntry, "CRStringPath"));

    CRPath2 * ret = NULL;

    APIPRECODE ;
    ret = (CRPath2 *) (PrimApplyBvr(TextPath2ConstructorOp, 2, LPWSTRToStrBvr(arg0), (arg1)));
    APIPOSTCODE ;
    return ret;
}

extern Path2 *PolyLine2(DM_ARRAYARG(Point2Value *,AxAArray *) points);
AxAPrimOp *PolyLine2Op;
CRSTDAPI_(CRPath2 *) CRPolyline(CRArrayPtr arg0)
{
    TraceTag((tagAPIEntry, "CRPolyline"));

    CRPath2 * ret = NULL;

    APIPRECODE ;
    ret = (CRPath2 *) (PrimApplyBvr(PolyLine2Op, 1, arg0));
    APIPOSTCODE ;
    return ret;
}

extern Path2 *PolyLine2(DM_SAFEARRAYARG(Point2Value *,AxAArray *) points);
extern Path2 *PolydrawPath2(DM_ARRAYARG(Point2Value *,AxAArray *) points, DM_ARRAYARG(AxANumber *, AxAArray *) codes);
AxAPrimOp *PolydrawPath2Op;
CRSTDAPI_(CRPath2 *) CRPolydrawPath(CRArrayPtr arg0, CRArrayPtr arg1)
{
    TraceTag((tagAPIEntry, "CRPolydrawPath"));

    CRPath2 * ret = NULL;

    APIPRECODE ;
    ret = (CRPath2 *) (PrimApplyBvr(PolydrawPath2Op, 2, arg0, arg1));
    APIPOSTCODE ;
    return ret;
}

extern Path2 *PolydrawPath2Double(double *d0, unsigned int n0, double *d1, unsigned int n1);
CRSTDAPI_(CRPath2 *) CRPolydrawPath(double *d0, unsigned int n0, double *d1, unsigned int n1)
{
    TraceTag((tagAPIEntry, "CRPolydrawPath - double"));

    CRPath2 * ret = NULL;

    APIPRECODE ;
    ret = (CRPath2 *) ConstBvr((AxAValue) PolydrawPath2Double(d0,n0 / 2,d1,n1));
    APIPOSTCODE ;
    return ret;
}

extern Path2 *PolydrawPath2(DM_SAFEARRAYARG(Point2Value *,AxAArray *) points,                              DM_SAFEARRAYARG(AxANumber *, AxAArray *) codes);
extern Path2 *ArcValRRRR(Real startAngle, Real endAngle, Real arcWidth, Real arcHeight);
AxAPrimOp *ArcValOp;
CRSTDAPI_(CRPath2 *) CRArcRadians(double arg0, double arg1, double arg2, double arg3)
{
    TraceTag((tagAPIEntry, "CRArcRadians"));

    CRPath2 * ret = NULL;

    APIPRECODE ;
    ret = (CRPath2 *) ConstBvr((AxAValue) ArcValRRRR(arg0,arg1,arg2,arg3));
    APIPOSTCODE ;
    return ret;
}

extern Path2 *ArcVal(AxANumber *startAngle, AxANumber *endAngle, AnimPixelValue *arcWidth, AnimPixelValue *arcHeight);
CRSTDAPI_(CRPath2 *) CRArcRadians(CRNumber * arg0, CRNumber * arg1, CRNumber * arg2, CRNumber * arg3)
{
    TraceTag((tagAPIEntry, "CRArcRadians"));

    return (CRPath2 *) CreatePrim4(ArcValOp, arg0, arg1, arg2, arg3);
}

extern Path2 *ArcValRRRR(Real startAngle, Real endAngle, Real arcWidth, Real arcHeight);
CRSTDAPI_(CRPath2 *) CRArc(double arg0, double arg1, double arg2, double arg3)
{
    TraceTag((tagAPIEntry, "CRArc"));

    CRPath2 * ret = NULL;

    APIPRECODE ;
    ret = (CRPath2 *) ConstBvr((AxAValue) ArcValRRRR(arg0,arg1,arg2,arg3));
    APIPOSTCODE ;
    return ret;
}

extern Path2 *PieValRRRR(Real startAngle, Real endAngle, Real arcWidth, Real arcHeight);
AxAPrimOp *PieValOp;
CRSTDAPI_(CRPath2 *) CRPieRadians(double arg0, double arg1, double arg2, double arg3)
{
    TraceTag((tagAPIEntry, "CRPieRadians"));

    CRPath2 * ret = NULL;

    APIPRECODE ;
    ret = (CRPath2 *) ConstBvr((AxAValue) PieValRRRR(arg0,arg1,arg2,arg3));
    APIPOSTCODE ;
    return ret;
}

extern Path2 *PieVal(AxANumber *startAngle, AxANumber *endAngle, AnimPixelValue *arcWidth, AnimPixelValue *arcHeight);
CRSTDAPI_(CRPath2 *) CRPieRadians(CRNumber * arg0, CRNumber * arg1, CRNumber * arg2, CRNumber * arg3)
{
    TraceTag((tagAPIEntry, "CRPieRadians"));

    return (CRPath2 *) CreatePrim4(PieValOp, arg0, arg1, arg2, arg3);
}

extern Path2 *PieValRRRR(Real startAngle, Real endAngle, Real arcWidth, Real arcHeight);
CRSTDAPI_(CRPath2 *) CRPie(double arg0, double arg1, double arg2, double arg3)
{
    TraceTag((tagAPIEntry, "CRPie"));

    CRPath2 * ret = NULL;

    APIPRECODE ;
    ret = (CRPath2 *) ConstBvr((AxAValue) PieValRRRR(arg0,arg1,arg2,arg3));
    APIPOSTCODE ;
    return ret;
}

extern Path2 *OvalValRR(Real width, Real height);
AxAPrimOp *OvalValOp;
CRSTDAPI_(CRPath2 *) CROval(double arg0, double arg1)
{
    TraceTag((tagAPIEntry, "CROval"));

    CRPath2 * ret = NULL;

    APIPRECODE ;
    ret = (CRPath2 *) ConstBvr((AxAValue) OvalValRR(arg0,arg1));
    APIPOSTCODE ;
    return ret;
}

extern Path2 *OvalVal(AnimPixelValue *width, AnimPixelValue *height);
CRSTDAPI_(CRPath2 *) CROval(CRNumber * arg0, CRNumber * arg1)
{
    TraceTag((tagAPIEntry, "CROval"));

    return (CRPath2 *) CreatePrim2(OvalValOp, arg0, arg1);
}

extern Path2 *RectangleValRR(Real width, Real height);
AxAPrimOp *RectangleValOp;
CRSTDAPI_(CRPath2 *) CRRect(double arg0, double arg1)
{
    TraceTag((tagAPIEntry, "CRRect"));

    CRPath2 * ret = NULL;

    APIPRECODE ;
    ret = (CRPath2 *) ConstBvr((AxAValue) RectangleValRR(arg0,arg1));
    APIPOSTCODE ;
    return ret;
}

extern Path2 *RectangleVal(AnimPixelValue *width, AnimPixelValue *height);
CRSTDAPI_(CRPath2 *) CRRect(CRNumber * arg0, CRNumber * arg1)
{
    TraceTag((tagAPIEntry, "CRRect"));

    return (CRPath2 *) CreatePrim2(RectangleValOp, arg0, arg1);
}

extern Path2 *RoundRectValRRRR(Real width,Real height,Real cornerArcWidth,Real cornerArcHeight);
AxAPrimOp *RoundRectValOp;
CRSTDAPI_(CRPath2 *) CRRoundRect(double arg0, double arg1, double arg2, double arg3)
{
    TraceTag((tagAPIEntry, "CRRoundRect"));

    CRPath2 * ret = NULL;

    APIPRECODE ;
    ret = (CRPath2 *) ConstBvr((AxAValue) RoundRectValRRRR(arg0,arg1,arg2,arg3));
    APIPOSTCODE ;
    return ret;
}

extern Path2 *RoundRectVal(AnimPixelValue *width,                             AnimPixelValue *height,                             AnimPixelValue *cornerArcWidth,                             AnimPixelValue *cornerArcHeight);
CRSTDAPI_(CRPath2 *) CRRoundRect(CRNumber * arg0, CRNumber * arg1, CRNumber * arg2, CRNumber * arg3)
{
    TraceTag((tagAPIEntry, "CRRoundRect"));

    return (CRPath2 *) CreatePrim4(RoundRectValOp, arg0, arg1, arg2, arg3);
}

extern Path2 *CubicBSplinePath(DM_ARRAYARG(Point2Value *,AxAArray *) points,                                 DM_ARRAYARG(AxANumber*, AxAArray *) knots);
AxAPrimOp *CubicBSplinePathOp;
CRSTDAPI_(CRPath2 *) CRCubicBSplinePath(CRArrayPtr arg0, CRArrayPtr arg1)
{
    TraceTag((tagAPIEntry, "CRCubicBSplinePath"));

    CRPath2 * ret = NULL;

    APIPRECODE ;
    ret = (CRPath2 *) (PrimApplyBvr(CubicBSplinePathOp, 2, arg0, arg1));
    APIPOSTCODE ;
    return ret;
}

extern Path2 *CubicBSplinePath(DM_SAFEARRAYARG(Point2Value *,AxAArray *) points,                                 DM_SAFEARRAYARG(AxANumber*, AxAArray *) knots);
extern Path2 *TextPath2Constructor(AxAString *obsolete1, FontStyle *obsolete2);
CRSTDAPI_(CRPath2 *) CRTextPath(CRString * arg0, CRFontStyle * arg1)
{
    TraceTag((tagAPIEntry, "CRTextPath"));

    return (CRPath2 *) CreatePrim2(TextPath2ConstructorOp, arg0, arg1);
}

extern Sound *silence;
CRSound * g_varCRSilence;
CRSTDAPI_(CRSound *) CRSilence()
{
    return g_varCRSilence;
}
extern Sound *MixArray(DM_ARRAYARG(Sound *, AxAArray*) snds);
AxAPrimOp *MixArrayOp;
CRSTDAPI_(CRSound *) CRMix(CRArrayPtr arg0)
{
    TraceTag((tagAPIEntry, "CRMix"));

    CRSound * ret = NULL;

    APIPRECODE ;
    ret = (CRSound *) (PrimApplyBvr(MixArrayOp, 1, arg0));
    APIPOSTCODE ;
    return ret;
}

extern Sound *MixArray(DM_SAFEARRAYARG(Sound *, AxAArray*) snds);
extern Bvr ApplyPhase (Bvr, Bvr);
CRSTDAPI_(CRSound *) CRPhase(CRSound * arg1, CRNumber * arg0)
{
    TraceTag((tagAPIEntry, "CRPhase"));

    CRSound * ret = NULL;

    APIPRECODE ;
    ret = (CRSound *) (::ApplyPhase((arg0), (arg1)));
    APIPOSTCODE ;
    return ret;
}

extern Bvr ApplyPhase (Bvr, DoubleValue);
CRSTDAPI_(CRSound *) CRPhase(CRSound * arg1, double arg0)
{
    TraceTag((tagAPIEntry, "CRPhase"));

    CRSound * ret = NULL;

    APIPRECODE ;
    ret = (CRSound *) (::ApplyPhase(DoubleToNumBvr(arg0), (arg1)));
    APIPOSTCODE ;
    return ret;
}

extern Bvr ApplyPitchShift (Bvr, Bvr);
CRSTDAPI_(CRSound *) CRRate(CRSound * arg1, CRNumber * arg0)
{
    TraceTag((tagAPIEntry, "CRRate"));

    CRSound * ret = NULL;

    APIPRECODE ;
    ret = (CRSound *) (::ApplyPitchShift((arg0), (arg1)));
    APIPOSTCODE ;
    return ret;
}

extern Bvr ApplyPitchShift (Bvr, DoubleValue);
CRSTDAPI_(CRSound *) CRRate(CRSound * arg1, double arg0)
{
    TraceTag((tagAPIEntry, "CRRate"));

    CRSound * ret = NULL;

    APIPRECODE ;
    ret = (CRSound *) (::ApplyPitchShift(DoubleToNumBvr(arg0), (arg1)));
    APIPOSTCODE ;
    return ret;
}

extern Bvr ApplyPan (Bvr, Bvr);
CRSTDAPI_(CRSound *) CRPan(CRSound * arg1, CRNumber * arg0)
{
    TraceTag((tagAPIEntry, "CRPan"));

    CRSound * ret = NULL;

    APIPRECODE ;
    ret = (CRSound *) (::ApplyPan((arg0), (arg1)));
    APIPOSTCODE ;
    return ret;
}

extern Bvr ApplyPan (Bvr, DoubleValue);
CRSTDAPI_(CRSound *) CRPan(CRSound * arg1, double arg0)
{
    TraceTag((tagAPIEntry, "CRPan"));

    CRSound * ret = NULL;

    APIPRECODE ;
    ret = (CRSound *) (::ApplyPan(DoubleToNumBvr(arg0), (arg1)));
    APIPOSTCODE ;
    return ret;
}

extern Bvr ApplyGain (Bvr, Bvr);
CRSTDAPI_(CRSound *) CRGain(CRSound * arg1, CRNumber * arg0)
{
    TraceTag((tagAPIEntry, "CRGain"));

    CRSound * ret = NULL;

    APIPRECODE ;
    ret = (CRSound *) (::ApplyGain((arg0), (arg1)));
    APIPOSTCODE ;
    return ret;
}

extern Bvr ApplyGain (Bvr, DoubleValue);
CRSTDAPI_(CRSound *) CRGain(CRSound * arg1, double arg0)
{
    TraceTag((tagAPIEntry, "CRGain"));

    CRSound * ret = NULL;

    APIPRECODE ;
    ret = (CRSound *) (::ApplyGain(DoubleToNumBvr(arg0), (arg1)));
    APIPOSTCODE ;
    return ret;
}

extern Bvr ApplyLooping (Bvr);
CRSTDAPI_(CRSound *) CRLoop(CRSound * arg0)
{
    TraceTag((tagAPIEntry, "CRLoop"));

    CRSound * ret = NULL;

    APIPRECODE ;
    ret = (CRSound *) (::ApplyLooping((arg0)));
    APIPOSTCODE ;
    return ret;
}

extern Bvr sinSynth ;
CRSTDAPI_(CRSound *) CRSinSynth()
{
    return (CRSound *) sinSynth;
}
extern AxAString * NumberString(AxANumber *num, AxANumber *precision);
AxAPrimOp *NumberStringOp;
CRSTDAPI_(CRString *) CRToString(CRNumber * arg0, CRNumber * arg1)
{
    TraceTag((tagAPIEntry, "CRToString"));

    return (CRString *) CreatePrim2(NumberStringOp, arg0, arg1);
}

extern AxAString * NumberString(AxANumber *num, DoubleValue *precision);
CRSTDAPI_(CRString *) CRToString(CRNumber * arg0, double arg1)
{
    TraceTag((tagAPIEntry, "CRToString"));

    CRString * ret = NULL;

    APIPRECODE ;
    ret = (CRString *) (PrimApplyBvr(NumberStringOp, 2, (arg0), DoubleToNumBvr(arg1)));
    APIPOSTCODE ;
    return ret;
}

extern FontStyle *defaultFont;
CRFontStyle * g_varCRDefaultFont;
CRSTDAPI_(CRFontStyle *) CRDefaultFont()
{
    return g_varCRDefaultFont;
}
extern FontStyle *Font(AxAString *str, AxANumber *size, Color *col);
AxAPrimOp *FontOp;
CRSTDAPI_(CRFontStyle *) CRFont(CRString * arg0, CRNumber * arg1, CRColor * arg2)
{
    TraceTag((tagAPIEntry, "CRFont"));

    return (CRFontStyle *) CreatePrim3(FontOp, arg0, arg1, arg2);
}

extern FontStyle *Font(StringValue *str, DoubleValue *size, Color *col);
CRSTDAPI_(CRFontStyle *) CRFont(LPWSTR arg0, double arg1, CRColor * arg2)
{
    TraceTag((tagAPIEntry, "CRFont"));

    CRFontStyle * ret = NULL;

    APIPRECODE ;
    ret = (CRFontStyle *) (PrimApplyBvr(FontOp, 3, LPWSTRToStrBvr(arg0), DoubleToNumBvr(arg1), (arg2)));
    APIPOSTCODE ;
    return ret;
}

extern Image *ImageFromStringAndFontStyle(AxAString *str, FontStyle *fs);
AxAPrimOp *ImageFromStringAndFontStyleOp;
CRSTDAPI_(CRImage *) CRStringImage(CRString * arg0, CRFontStyle * arg1)
{
    TraceTag((tagAPIEntry, "CRStringImage"));

    return (CRImage *) CreatePrim2(ImageFromStringAndFontStyleOp, arg0, arg1);
}

extern Image *ImageFromStringAndFontStyle(StringValue *str, FontStyle *fs);
CRSTDAPI_(CRImage *) CRStringImage(LPWSTR arg0, CRFontStyle * arg1)
{
    TraceTag((tagAPIEntry, "CRStringImage"));

    CRImage * ret = NULL;

    APIPRECODE ;
    ret = (CRImage *) (PrimApplyBvr(ImageFromStringAndFontStyleOp, 2, LPWSTRToStrBvr(arg0), (arg1)));
    APIPOSTCODE ;
    return ret;
}

extern FontStyle *FontStyleBold(FontStyle *fs);
AxAPrimOp *FontStyleBoldOp;
CRSTDAPI_(CRFontStyle *) CRBold(CRFontStyle * arg0)
{
    TraceTag((tagAPIEntry, "CRBold"));

    return (CRFontStyle *) CreatePrim1(FontStyleBoldOp, arg0);
}

extern FontStyle *FontStyleItalic(FontStyle *fs);
AxAPrimOp *FontStyleItalicOp;
CRSTDAPI_(CRFontStyle *) CRItalic(CRFontStyle * arg0)
{
    TraceTag((tagAPIEntry, "CRItalic"));

    return (CRFontStyle *) CreatePrim1(FontStyleItalicOp, arg0);
}

extern FontStyle *FontStyleUnderline(FontStyle *fs);
AxAPrimOp *FontStyleUnderlineOp;
CRSTDAPI_(CRFontStyle *) CRUnderline(CRFontStyle * arg0)
{
    TraceTag((tagAPIEntry, "CRUnderline"));

    return (CRFontStyle *) CreatePrim1(FontStyleUnderlineOp, arg0);
}

extern FontStyle *FontStyleStrikethrough(FontStyle *fs);
AxAPrimOp *FontStyleStrikethroughOp;
CRSTDAPI_(CRFontStyle *) CRStrikethrough(CRFontStyle * arg0)
{
    TraceTag((tagAPIEntry, "CRStrikethrough"));

    return (CRFontStyle *) CreatePrim1(FontStyleStrikethroughOp, arg0);
}

extern FontStyle *FontStyleAntiAliasing(DoubleValue *aaStyle, FontStyle *fs);
AxAPrimOp *FontStyleAntiAliasingOp;
CRSTDAPI_(CRFontStyle *) CRAntiAliasing(CRFontStyle * arg1, double arg0)
{
    TraceTag((tagAPIEntry, "CRAntiAliasing"));

    CRFontStyle * ret = NULL;

    APIPRECODE ;
    ret = (CRFontStyle *) (PrimApplyBvr(FontStyleAntiAliasingOp, 2, DoubleToNumBvr(arg0), (arg1)));
    APIPOSTCODE ;
    return ret;
}

extern FontStyle *FontStyleColor(FontStyle *fs, Color *col);
AxAPrimOp *FontStyleColorOp;
CRSTDAPI_(CRFontStyle *) CRTextColor(CRFontStyle * arg0, CRColor * arg1)
{
    TraceTag((tagAPIEntry, "CRTextColor"));

    return (CRFontStyle *) CreatePrim2(FontStyleColorOp, arg0, arg1);
}

extern FontStyle *FontStyleFace(FontStyle *fs, AxAString *face);
AxAPrimOp *FontStyleFaceOp;
CRSTDAPI_(CRFontStyle *) CRFamily(CRFontStyle * arg0, CRString * arg1)
{
    TraceTag((tagAPIEntry, "CRFamily"));

    return (CRFontStyle *) CreatePrim2(FontStyleFaceOp, arg0, arg1);
}

extern FontStyle *FontStyleFace(FontStyle *fs, StringValue *face);
CRSTDAPI_(CRFontStyle *) CRFamily(CRFontStyle * arg0, LPWSTR arg1)
{
    TraceTag((tagAPIEntry, "CRFamily"));

    CRFontStyle * ret = NULL;

    APIPRECODE ;
    ret = (CRFontStyle *) (PrimApplyBvr(FontStyleFaceOp, 2, (arg0), LPWSTRToStrBvr(arg1)));
    APIPOSTCODE ;
    return ret;
}

extern FontStyle *FontStyleSize(FontStyle *fs, AxANumber *size);
AxAPrimOp *FontStyleSizeOp;
CRSTDAPI_(CRFontStyle *) CRSize(CRFontStyle * arg0, CRNumber * arg1)
{
    TraceTag((tagAPIEntry, "CRSize"));

    return (CRFontStyle *) CreatePrim2(FontStyleSizeOp, arg0, arg1);
}

extern FontStyle *FontStyleSize(FontStyle *fs, DoubleValue *size);
CRSTDAPI_(CRFontStyle *) CRSize(CRFontStyle * arg0, double arg1)
{
    TraceTag((tagAPIEntry, "CRSize"));

    CRFontStyle * ret = NULL;

    APIPRECODE ;
    ret = (CRFontStyle *) (PrimApplyBvr(FontStyleSizeOp, 2, (arg0), DoubleToNumBvr(arg1)));
    APIPOSTCODE ;
    return ret;
}

extern FontStyle *FontStyleWeight(FontStyle *fs, DoubleValue *weight);
AxAPrimOp *FontStyleWeightOp;
CRSTDAPI_(CRFontStyle *) CRWeight(CRFontStyle * arg0, double arg1)
{
    TraceTag((tagAPIEntry, "CRWeight"));

    CRFontStyle * ret = NULL;

    APIPRECODE ;
    ret = (CRFontStyle *) (PrimApplyBvr(FontStyleWeightOp, 2, (arg0), DoubleToNumBvr(arg1)));
    APIPOSTCODE ;
    return ret;
}

extern FontStyle *FontStyleWeight(FontStyle *fs, AxANumber *weight);
CRSTDAPI_(CRFontStyle *) CRWeight(CRFontStyle * arg0, CRNumber * arg1)
{
    TraceTag((tagAPIEntry, "CRWeight"));

    return (CRFontStyle *) CreatePrim2(FontStyleWeightOp, arg0, arg1);
}

extern Image *ImageFromStringAndFontStyle(AxAString *obsoleted1,                                            FontStyle *obsoleted2);
CRSTDAPI_(CRImage *) CRTextImage(CRString * arg0, CRFontStyle * arg1)
{
    TraceTag((tagAPIEntry, "CRTextImage"));

    return (CRImage *) CreatePrim2(ImageFromStringAndFontStyleOp, arg0, arg1);
}

extern Image *ImageFromStringAndFontStyle(StringValue *obsoleted1,                                            FontStyle *obsoleted2);
CRSTDAPI_(CRImage *) CRTextImage(LPWSTR arg0, CRFontStyle * arg1)
{
    TraceTag((tagAPIEntry, "CRTextImage"));

    CRImage * ret = NULL;

    APIPRECODE ;
    ret = (CRImage *) (PrimApplyBvr(ImageFromStringAndFontStyleOp, 2, LPWSTRToStrBvr(arg0), (arg1)));
    APIPOSTCODE ;
    return ret;
}

extern FontStyle *FontStyleTransformCharacters(FontStyle *style, Transform2 *transform);
AxAPrimOp *FontStyleTransformCharactersOp;
CRSTDAPI_(CRFontStyle *) CRTransformCharacters(CRFontStyle * arg0, CRTransform2 * arg1)
{
    TraceTag((tagAPIEntry, "CRTransformCharacters"));

    return (CRFontStyle *) CreatePrim2(FontStyleTransformCharactersOp, arg0, arg1);
}

extern Vector2Value *xVector2;
CRVector2 * g_varCRXVector2;
CRSTDAPI_(CRVector2 *) CRXVector2()
{
    return g_varCRXVector2;
}
extern Vector2Value *yVector2;
CRVector2 * g_varCRYVector2;
CRSTDAPI_(CRVector2 *) CRYVector2()
{
    return g_varCRYVector2;
}
extern Vector2Value *zeroVector2;
CRVector2 * g_varCRZeroVector2;
CRSTDAPI_(CRVector2 *) CRZeroVector2()
{
    return g_varCRZeroVector2;
}
extern Point2Value *origin2;
CRPoint2 * g_varCROrigin2;
CRSTDAPI_(CRPoint2 *) CROrigin2()
{
    return g_varCROrigin2;
}
extern Vector2Value *XyVector2 (AnimPixelValue *x, AnimPixelYValue *y);
AxAPrimOp *XyVector2Op;
CRSTDAPI_(CRVector2 *) CRCreateVector2(CRNumber * arg0, CRNumber * arg1)
{
    TraceTag((tagAPIEntry, "CRCreateVector2"));

    return (CRVector2 *) CreatePrim2(XyVector2Op, arg0, arg1);
}

extern Vector2Value *XyVector2RR (Real x, Real y);
CRSTDAPI_(CRVector2 *) CRCreateVector2(double arg0, double arg1)
{
    TraceTag((tagAPIEntry, "CRCreateVector2"));

    CRVector2 * ret = NULL;

    APIPRECODE ;
    ret = (CRVector2 *) ConstBvr((AxAValue) XyVector2RR(arg0,arg1));
    APIPOSTCODE ;
    return ret;
}

extern Point2Value *XyPoint2  (AnimPixelValue *x, AnimPixelYValue *y);
AxAPrimOp *XyPoint2Op;
CRSTDAPI_(CRPoint2 *) CRCreatePoint2(CRNumber * arg0, CRNumber * arg1)
{
    TraceTag((tagAPIEntry, "CRCreatePoint2"));

    return (CRPoint2 *) CreatePrim2(XyPoint2Op, arg0, arg1);
}

extern Point2Value *XyPoint2RR (Real x, Real y);
CRSTDAPI_(CRPoint2 *) CRCreatePoint2(double arg0, double arg1)
{
    TraceTag((tagAPIEntry, "CRCreatePoint2"));

    CRPoint2 * ret = NULL;

    APIPRECODE ;
    ret = (CRPoint2 *) ConstBvr((AxAValue) XyPoint2RR(arg0, arg1));
    APIPOSTCODE ;
    return ret;
}

extern Vector2Value *PolarVector2 (AxANumber *theta, AnimPixelValue *radius);
AxAPrimOp *PolarVector2Op;
CRSTDAPI_(CRVector2 *) CRVector2Polar(CRNumber * arg0, CRNumber * arg1)
{
    TraceTag((tagAPIEntry, "CRVector2Polar"));

    return (CRVector2 *) CreatePrim2(PolarVector2Op, arg0, arg1);
}

extern Vector2Value *PolarVector2RR (Real theta, Real radius);
CRSTDAPI_(CRVector2 *) CRVector2Polar(double arg0, double arg1)
{
    TraceTag((tagAPIEntry, "CRVector2Polar"));

    CRVector2 * ret = NULL;

    APIPRECODE ;
    ret = (CRVector2 *) ConstBvr((AxAValue) PolarVector2RR(arg0,arg1));
    APIPOSTCODE ;
    return ret;
}

extern Vector2Value *PolarVector2 (DegreesValue *theta, PixelValue *radius);
extern Point2Value *PolarPoint2  (AxANumber *theta, AnimPixelValue *radius);
AxAPrimOp *PolarPoint2Op;
CRSTDAPI_(CRPoint2 *) CRPoint2Polar(CRNumber * arg0, CRNumber * arg1)
{
    TraceTag((tagAPIEntry, "CRPoint2Polar"));

    return (CRPoint2 *) CreatePrim2(PolarPoint2Op, arg0, arg1);
}

extern Point2Value *PolarPoint2RR (Real theta, Real radius);
CRSTDAPI_(CRPoint2 *) CRPoint2Polar(double arg0, double arg1)
{
    TraceTag((tagAPIEntry, "CRPoint2Polar"));

    CRPoint2 * ret = NULL;

    APIPRECODE ;
    ret = (CRPoint2 *) ConstBvr((AxAValue) PolarPoint2RR(arg0,arg1));
    APIPOSTCODE ;
    return ret;
}

extern AxANumber *LengthVector2(Vector2Value *v);
AxAPrimOp *LengthVector2Op;
CRSTDAPI_(CRNumber *) CRLength(CRVector2 * arg0)
{
    TraceTag((tagAPIEntry, "CRLength"));

    return (CRNumber *) CreatePrim1(LengthVector2Op, arg0);
}

extern AxANumber *LengthSquaredVector2(Vector2Value *v);
AxAPrimOp *LengthSquaredVector2Op;
CRSTDAPI_(CRNumber *) CRLengthSquared(CRVector2 * arg0)
{
    TraceTag((tagAPIEntry, "CRLengthSquared"));

    return (CRNumber *) CreatePrim1(LengthSquaredVector2Op, arg0);
}

extern Vector2Value *NormalVector2(Vector2Value *v);
AxAPrimOp *NormalVector2Op;
CRSTDAPI_(CRVector2 *) CRNormalize(CRVector2 * arg0)
{
    TraceTag((tagAPIEntry, "CRNormalize"));

    return (CRVector2 *) CreatePrim1(NormalVector2Op, arg0);
}

extern AxANumber *DotVector2Vector2(Vector2Value *v, Vector2Value *u);
AxAPrimOp *DotVector2Vector2Op;
CRSTDAPI_(CRNumber *) CRDot(CRVector2 * arg0, CRVector2 * arg1)
{
    TraceTag((tagAPIEntry, "CRDot"));

    return (CRNumber *) CreatePrim2(DotVector2Vector2Op, arg0, arg1);
}

extern Vector2Value *NegateVector2(Vector2Value *v);
AxAPrimOp *NegateVector2Op;
CRSTDAPI_(CRVector2 *) CRNeg(CRVector2 * arg0)
{
    TraceTag((tagAPIEntry, "CRNeg"));

    return (CRVector2 *) CreatePrim1(NegateVector2Op, arg0);
}

extern Vector2Value *ScaleVector2Real(Vector2Value *v, AxANumber *scalar);
AxAPrimOp *ScaleVector2RealOp;
CRSTDAPI_(CRVector2 *) CRMul(CRVector2 * arg0, CRNumber * arg1)
{
    TraceTag((tagAPIEntry, "CRMul"));

    return (CRVector2 *) CreatePrim2(ScaleVector2RealOp, arg0, arg1);
}

extern Vector2Value *ScaleVector2Real(Vector2Value *v, DoubleValue *scalar);
CRSTDAPI_(CRVector2 *) CRMul(CRVector2 * arg0, double arg1)
{
    TraceTag((tagAPIEntry, "CRMul"));

    CRVector2 * ret = NULL;

    APIPRECODE ;
    ret = (CRVector2 *) (PrimApplyBvr(ScaleVector2RealOp, 2, (arg0), DoubleToNumBvr(arg1)));
    APIPOSTCODE ;
    return ret;
}

extern Vector2Value *DivideVector2Real(Vector2Value *v, AxANumber *scalar);
AxAPrimOp *DivideVector2RealOp;
CRSTDAPI_(CRVector2 *) CRDiv(CRVector2 * arg0, CRNumber * arg1)
{
    TraceTag((tagAPIEntry, "CRDiv"));

    return (CRVector2 *) CreatePrim2(DivideVector2RealOp, arg0, arg1);
}

extern Vector2Value *DivideVector2Real(Vector2Value *v, DoubleValue *scalar);
CRSTDAPI_(CRVector2 *) CRDiv(CRVector2 * arg0, double arg1)
{
    TraceTag((tagAPIEntry, "CRDiv"));

    CRVector2 * ret = NULL;

    APIPRECODE ;
    ret = (CRVector2 *) (PrimApplyBvr(DivideVector2RealOp, 2, (arg0), DoubleToNumBvr(arg1)));
    APIPOSTCODE ;
    return ret;
}

extern Vector2Value *MinusVector2Vector2(Vector2Value *v1, Vector2Value *v2);
AxAPrimOp *MinusVector2Vector2Op;
CRSTDAPI_(CRVector2 *) CRSub(CRVector2 * arg0, CRVector2 * arg1)
{
    TraceTag((tagAPIEntry, "CRSub"));

    return (CRVector2 *) CreatePrim2(MinusVector2Vector2Op, arg0, arg1);
}

extern Vector2Value *PlusVector2Vector2(Vector2Value *v1, Vector2Value *v2);
AxAPrimOp *PlusVector2Vector2Op;
CRSTDAPI_(CRVector2 *) CRAdd(CRVector2 * arg0, CRVector2 * arg1)
{
    TraceTag((tagAPIEntry, "CRAdd"));

    return (CRVector2 *) CreatePrim2(PlusVector2Vector2Op, arg0, arg1);
}

extern Point2Value *PlusPoint2Vector2(Point2Value *p, Vector2Value *v);
AxAPrimOp *PlusPoint2Vector2Op;
CRSTDAPI_(CRPoint2 *) CRAdd(CRPoint2 * arg0, CRVector2 * arg1)
{
    TraceTag((tagAPIEntry, "CRAdd"));

    return (CRPoint2 *) CreatePrim2(PlusPoint2Vector2Op, arg0, arg1);
}

extern Point2Value *MinusPoint2Vector2(Point2Value *p, Vector2Value *v);
AxAPrimOp *MinusPoint2Vector2Op;
CRSTDAPI_(CRPoint2 *) CRSub(CRPoint2 * arg0, CRVector2 * arg1)
{
    TraceTag((tagAPIEntry, "CRSub"));

    return (CRPoint2 *) CreatePrim2(MinusPoint2Vector2Op, arg0, arg1);
}

extern Vector2Value *MinusPoint2Point2(Point2Value *p1, Point2Value *p2);
AxAPrimOp *MinusPoint2Point2Op;
CRSTDAPI_(CRVector2 *) CRSub(CRPoint2 * arg0, CRPoint2 * arg1)
{
    TraceTag((tagAPIEntry, "CRSub"));

    return (CRVector2 *) CreatePrim2(MinusPoint2Point2Op, arg0, arg1);
}

extern AxANumber *DistancePoint2Point2(Point2Value *p, Point2Value *q);
AxAPrimOp *DistancePoint2Point2Op;
CRSTDAPI_(CRNumber *) CRDistance(CRPoint2 * arg0, CRPoint2 * arg1)
{
    TraceTag((tagAPIEntry, "CRDistance"));

    return (CRNumber *) CreatePrim2(DistancePoint2Point2Op, arg0, arg1);
}

extern AxANumber *DistanceSquaredPoint2Point2(Point2Value *p, Point2Value *q);
AxAPrimOp *DistanceSquaredPoint2Point2Op;
CRSTDAPI_(CRNumber *) CRDistanceSquared(CRPoint2 * arg0, CRPoint2 * arg1)
{
    TraceTag((tagAPIEntry, "CRDistanceSquared"));

    return (CRNumber *) CreatePrim2(DistanceSquaredPoint2Point2Op, arg0, arg1);
}

extern AxANumber *XCoordVector2(Vector2Value *v);
AxAPrimOp *XCoordVector2Op;
CRSTDAPI_(CRNumber *) CRGetX(CRVector2 * arg0)
{
    TraceTag((tagAPIEntry, "CRGetX"));

    return (CRNumber *) CreatePrim1(XCoordVector2Op, arg0);
}

extern AxANumber *YCoordVector2(Vector2Value *v);
AxAPrimOp *YCoordVector2Op;
CRSTDAPI_(CRNumber *) CRGetY(CRVector2 * arg0)
{
    TraceTag((tagAPIEntry, "CRGetY"));

    return (CRNumber *) CreatePrim1(YCoordVector2Op, arg0);
}

extern AxANumber *ThetaCoordVector2(Vector2Value *v);
AxAPrimOp *ThetaCoordVector2Op;
CRSTDAPI_(CRNumber *) CRPolarCoordAngle(CRVector2 * arg0)
{
    TraceTag((tagAPIEntry, "CRPolarCoordAngle"));

    return (CRNumber *) CreatePrim1(ThetaCoordVector2Op, arg0);
}

extern AxANumber *RhoCoordVector2(Vector2Value *v);
AxAPrimOp *RhoCoordVector2Op;
CRSTDAPI_(CRNumber *) CRPolarCoordLength(CRVector2 * arg0)
{
    TraceTag((tagAPIEntry, "CRPolarCoordLength"));

    return (CRNumber *) CreatePrim1(RhoCoordVector2Op, arg0);
}

extern AxANumber *XCoordPoint2(Point2Value *v);
AxAPrimOp *XCoordPoint2Op;
CRSTDAPI_(CRNumber *) CRGetX(CRPoint2 * arg0)
{
    TraceTag((tagAPIEntry, "CRGetX"));

    return (CRNumber *) CreatePrim1(XCoordPoint2Op, arg0);
}

extern AxANumber *YCoordPoint2(Point2Value *v);
AxAPrimOp *YCoordPoint2Op;
CRSTDAPI_(CRNumber *) CRGetY(CRPoint2 * arg0)
{
    TraceTag((tagAPIEntry, "CRGetY"));

    return (CRNumber *) CreatePrim1(YCoordPoint2Op, arg0);
}

extern AxANumber *ThetaCoordPoint2(Point2Value *v);
AxAPrimOp *ThetaCoordPoint2Op;
CRSTDAPI_(CRNumber *) CRPolarCoordAngle(CRPoint2 * arg0)
{
    TraceTag((tagAPIEntry, "CRPolarCoordAngle"));

    return (CRNumber *) CreatePrim1(ThetaCoordPoint2Op, arg0);
}

extern AxANumber *RhoCoordPoint2(Point2Value *v);
AxAPrimOp *RhoCoordPoint2Op;
CRSTDAPI_(CRNumber *) CRPolarCoordLength(CRPoint2 * arg0)
{
    TraceTag((tagAPIEntry, "CRPolarCoordLength"));

    return (CRNumber *) CreatePrim1(RhoCoordPoint2Op, arg0);
}

extern Vector3Value *xVector3;
CRVector3 * g_varCRXVector3;
CRSTDAPI_(CRVector3 *) CRXVector3()
{
    return g_varCRXVector3;
}
extern Vector3Value *yVector3;
CRVector3 * g_varCRYVector3;
CRSTDAPI_(CRVector3 *) CRYVector3()
{
    return g_varCRYVector3;
}
extern Vector3Value *zVector3;
CRVector3 * g_varCRZVector3;
CRSTDAPI_(CRVector3 *) CRZVector3()
{
    return g_varCRZVector3;
}
extern Vector3Value *zeroVector3;
CRVector3 * g_varCRZeroVector3;
CRSTDAPI_(CRVector3 *) CRZeroVector3()
{
    return g_varCRZeroVector3;
}
extern Point3Value *origin3;
CRPoint3 * g_varCROrigin3;
CRSTDAPI_(CRPoint3 *) CROrigin3()
{
    return g_varCROrigin3;
}
extern Vector3Value *XyzVector3(AnimPixelValue *x, AnimPixelYValue *y, AnimPixelValue *z);
AxAPrimOp *XyzVector3Op;
CRSTDAPI_(CRVector3 *) CRCreateVector3(CRNumber * arg0, CRNumber * arg1, CRNumber * arg2)
{
    TraceTag((tagAPIEntry, "CRCreateVector3"));

    return (CRVector3 *) CreatePrim3(XyzVector3Op, arg0, arg1, arg2);
}

extern Vector3Value *XyzVector3RRR(Real x, Real y, Real z);
CRSTDAPI_(CRVector3 *) CRCreateVector3(double arg0, double arg1, double arg2)
{
    TraceTag((tagAPIEntry, "CRCreateVector3"));

    CRVector3 * ret = NULL;

    APIPRECODE ;
    ret = (CRVector3 *) ConstBvr((AxAValue) XyzVector3RRR(arg0,arg1,arg2));
    APIPOSTCODE ;
    return ret;
}

extern Point3Value *XyzPoint3(AnimPixelValue *x, AnimPixelYValue *y, AnimPixelValue *z);
AxAPrimOp *XyzPoint3Op;
CRSTDAPI_(CRPoint3 *) CRCreatePoint3(CRNumber * arg0, CRNumber * arg1, CRNumber * arg2)
{
    TraceTag((tagAPIEntry, "CRCreatePoint3"));

    return (CRPoint3 *) CreatePrim3(XyzPoint3Op, arg0, arg1, arg2);
}

extern Point3Value *XyzPoint3RRR(Real x, Real y, Real z);
CRSTDAPI_(CRPoint3 *) CRCreatePoint3(double arg0, double arg1, double arg2)
{
    TraceTag((tagAPIEntry, "CRCreatePoint3"));

    CRPoint3 * ret = NULL;

    APIPRECODE ;
    ret = (CRPoint3 *) ConstBvr((AxAValue) XyzPoint3RRR(arg0,arg1,arg2));
    APIPOSTCODE ;
    return ret;
}

extern Vector3Value *SphericalVector3 (AxANumber *xyAngle, AxANumber *yzAngle, AnimPixelValue *radius);
AxAPrimOp *SphericalVector3Op;
CRSTDAPI_(CRVector3 *) CRVector3Spherical(CRNumber * arg0, CRNumber * arg1, CRNumber * arg2)
{
    TraceTag((tagAPIEntry, "CRVector3Spherical"));

    return (CRVector3 *) CreatePrim3(SphericalVector3Op, arg0, arg1, arg2);
}

extern Vector3Value *SphericalVector3RRR (Real xyAngle, Real yzAngle, Real radius);
CRSTDAPI_(CRVector3 *) CRVector3Spherical(double arg0, double arg1, double arg2)
{
    TraceTag((tagAPIEntry, "CRVector3Spherical"));

    CRVector3 * ret = NULL;

    APIPRECODE ;
    ret = (CRVector3 *) ConstBvr((AxAValue) SphericalVector3RRR(arg0,arg1,arg2));
    APIPOSTCODE ;
    return ret;
}

extern Point3Value *SphericalPoint3 (AxANumber *zxAngle, AxANumber *xyAngle, AnimPixelValue *radius);
AxAPrimOp *SphericalPoint3Op;
CRSTDAPI_(CRPoint3 *) CRPoint3Spherical(CRNumber * arg0, CRNumber * arg1, CRNumber * arg2)
{
    TraceTag((tagAPIEntry, "CRPoint3Spherical"));

    return (CRPoint3 *) CreatePrim3(SphericalPoint3Op, arg0, arg1, arg2);
}

extern Point3Value *SphericalPoint3RRR (Real zxAngle, Real xyAngle, Real radius);
CRSTDAPI_(CRPoint3 *) CRPoint3Spherical(double arg0, double arg1, double arg2)
{
    TraceTag((tagAPIEntry, "CRPoint3Spherical"));

    CRPoint3 * ret = NULL;

    APIPRECODE ;
    ret = (CRPoint3 *) ConstBvr((AxAValue) SphericalPoint3RRR(arg0,arg1,arg2));
    APIPOSTCODE ;
    return ret;
}

extern AxANumber *LengthVector3(Vector3Value *v);
AxAPrimOp *LengthVector3Op;
CRSTDAPI_(CRNumber *) CRLength(CRVector3 * arg0)
{
    TraceTag((tagAPIEntry, "CRLength"));

    return (CRNumber *) CreatePrim1(LengthVector3Op, arg0);
}

extern AxANumber *LengthSquaredVector3(Vector3Value *v);
AxAPrimOp *LengthSquaredVector3Op;
CRSTDAPI_(CRNumber *) CRLengthSquared(CRVector3 * arg0)
{
    TraceTag((tagAPIEntry, "CRLengthSquared"));

    return (CRNumber *) CreatePrim1(LengthSquaredVector3Op, arg0);
}

extern Vector3Value *NormalVector3(Vector3Value *v);
AxAPrimOp *NormalVector3Op;
CRSTDAPI_(CRVector3 *) CRNormalize(CRVector3 * arg0)
{
    TraceTag((tagAPIEntry, "CRNormalize"));

    return (CRVector3 *) CreatePrim1(NormalVector3Op, arg0);
}

extern AxANumber *DotVector3Vector3(Vector3Value *v, Vector3Value *u);
AxAPrimOp *DotVector3Vector3Op;
CRSTDAPI_(CRNumber *) CRDot(CRVector3 * arg0, CRVector3 * arg1)
{
    TraceTag((tagAPIEntry, "CRDot"));

    return (CRNumber *) CreatePrim2(DotVector3Vector3Op, arg0, arg1);
}

extern Vector3Value *CrossVector3Vector3(Vector3Value *v, Vector3Value *u);
AxAPrimOp *CrossVector3Vector3Op;
CRSTDAPI_(CRVector3 *) CRCross(CRVector3 * arg0, CRVector3 * arg1)
{
    TraceTag((tagAPIEntry, "CRCross"));

    return (CRVector3 *) CreatePrim2(CrossVector3Vector3Op, arg0, arg1);
}

extern Vector3Value *NegateVector3(Vector3Value *v);
AxAPrimOp *NegateVector3Op;
CRSTDAPI_(CRVector3 *) CRNeg(CRVector3 * arg0)
{
    TraceTag((tagAPIEntry, "CRNeg"));

    return (CRVector3 *) CreatePrim1(NegateVector3Op, arg0);
}

extern Vector3Value *ScaleRealVector3(AxANumber *scalar, Vector3Value *v);
AxAPrimOp *ScaleRealVector3Op;
CRSTDAPI_(CRVector3 *) CRMul(CRVector3 * arg1, CRNumber * arg0)
{
    TraceTag((tagAPIEntry, "CRMul"));

    return (CRVector3 *) CreatePrim2(ScaleRealVector3Op, arg0, arg1);
}

extern Vector3Value *ScaleRealVector3(DoubleValue *scalar, Vector3Value *v);
CRSTDAPI_(CRVector3 *) CRMul(CRVector3 * arg1, double arg0)
{
    TraceTag((tagAPIEntry, "CRMul"));

    CRVector3 * ret = NULL;

    APIPRECODE ;
    ret = (CRVector3 *) (PrimApplyBvr(ScaleRealVector3Op, 2, DoubleToNumBvr(arg0), (arg1)));
    APIPOSTCODE ;
    return ret;
}

extern Vector3Value *DivideVector3Real(Vector3Value *v, AxANumber *scalar);
AxAPrimOp *DivideVector3RealOp;
CRSTDAPI_(CRVector3 *) CRDiv(CRVector3 * arg0, CRNumber * arg1)
{
    TraceTag((tagAPIEntry, "CRDiv"));

    return (CRVector3 *) CreatePrim2(DivideVector3RealOp, arg0, arg1);
}

extern Vector3Value *DivideVector3Real(Vector3Value *v, DoubleValue *scalar);
CRSTDAPI_(CRVector3 *) CRDiv(CRVector3 * arg0, double arg1)
{
    TraceTag((tagAPIEntry, "CRDiv"));

    CRVector3 * ret = NULL;

    APIPRECODE ;
    ret = (CRVector3 *) (PrimApplyBvr(DivideVector3RealOp, 2, (arg0), DoubleToNumBvr(arg1)));
    APIPOSTCODE ;
    return ret;
}

extern Vector3Value *MinusVector3Vector3(Vector3Value *v1, Vector3Value *v2);
AxAPrimOp *MinusVector3Vector3Op;
CRSTDAPI_(CRVector3 *) CRSub(CRVector3 * arg0, CRVector3 * arg1)
{
    TraceTag((tagAPIEntry, "CRSub"));

    return (CRVector3 *) CreatePrim2(MinusVector3Vector3Op, arg0, arg1);
}

extern Vector3Value *PlusVector3Vector3(Vector3Value *v1, Vector3Value *v2);
AxAPrimOp *PlusVector3Vector3Op;
CRSTDAPI_(CRVector3 *) CRAdd(CRVector3 * arg0, CRVector3 * arg1)
{
    TraceTag((tagAPIEntry, "CRAdd"));

    return (CRVector3 *) CreatePrim2(PlusVector3Vector3Op, arg0, arg1);
}

extern Point3Value *PlusPoint3Vector3(Point3Value *p, Vector3Value *v);
AxAPrimOp *PlusPoint3Vector3Op;
CRSTDAPI_(CRPoint3 *) CRAdd(CRPoint3 * arg0, CRVector3 * arg1)
{
    TraceTag((tagAPIEntry, "CRAdd"));

    return (CRPoint3 *) CreatePrim2(PlusPoint3Vector3Op, arg0, arg1);
}

extern Point3Value *MinusPoint3Vector3(Point3Value *p, Vector3Value *v);
AxAPrimOp *MinusPoint3Vector3Op;
CRSTDAPI_(CRPoint3 *) CRSub(CRPoint3 * arg0, CRVector3 * arg1)
{
    TraceTag((tagAPIEntry, "CRSub"));

    return (CRPoint3 *) CreatePrim2(MinusPoint3Vector3Op, arg0, arg1);
}

extern Vector3Value *MinusPoint3Point3(Point3Value *p1, Point3Value *p2);
AxAPrimOp *MinusPoint3Point3Op;
CRSTDAPI_(CRVector3 *) CRSub(CRPoint3 * arg0, CRPoint3 * arg1)
{
    TraceTag((tagAPIEntry, "CRSub"));

    return (CRVector3 *) CreatePrim2(MinusPoint3Point3Op, arg0, arg1);
}

extern AxANumber *DistancePoint3Point3(Point3Value *p, Point3Value *q);
AxAPrimOp *DistancePoint3Point3Op;
CRSTDAPI_(CRNumber *) CRDistance(CRPoint3 * arg0, CRPoint3 * arg1)
{
    TraceTag((tagAPIEntry, "CRDistance"));

    return (CRNumber *) CreatePrim2(DistancePoint3Point3Op, arg0, arg1);
}

extern AxANumber *DistanceSquaredPoint3Point3(Point3Value *p, Point3Value *q);
AxAPrimOp *DistanceSquaredPoint3Point3Op;
CRSTDAPI_(CRNumber *) CRDistanceSquared(CRPoint3 * arg0, CRPoint3 * arg1)
{
    TraceTag((tagAPIEntry, "CRDistanceSquared"));

    return (CRNumber *) CreatePrim2(DistanceSquaredPoint3Point3Op, arg0, arg1);
}

extern AxANumber *XCoordVector3(Vector3Value *v);
AxAPrimOp *XCoordVector3Op;
CRSTDAPI_(CRNumber *) CRGetX(CRVector3 * arg0)
{
    TraceTag((tagAPIEntry, "CRGetX"));

    return (CRNumber *) CreatePrim1(XCoordVector3Op, arg0);
}

extern AxANumber *YCoordVector3(Vector3Value *v);
AxAPrimOp *YCoordVector3Op;
CRSTDAPI_(CRNumber *) CRGetY(CRVector3 * arg0)
{
    TraceTag((tagAPIEntry, "CRGetY"));

    return (CRNumber *) CreatePrim1(YCoordVector3Op, arg0);
}

extern AxANumber *ZCoordVector3(Vector3Value *v);
AxAPrimOp *ZCoordVector3Op;
CRSTDAPI_(CRNumber *) CRGetZ(CRVector3 * arg0)
{
    TraceTag((tagAPIEntry, "CRGetZ"));

    return (CRNumber *) CreatePrim1(ZCoordVector3Op, arg0);
}

extern AxANumber *ThetaCoordVector3(Vector3Value *v);
AxAPrimOp *ThetaCoordVector3Op;
CRSTDAPI_(CRNumber *) CRSphericalCoordXYAngle(CRVector3 * arg0)
{
    TraceTag((tagAPIEntry, "CRSphericalCoordXYAngle"));

    return (CRNumber *) CreatePrim1(ThetaCoordVector3Op, arg0);
}

extern AxANumber *PhiCoordVector3(Vector3Value *v);
AxAPrimOp *PhiCoordVector3Op;
CRSTDAPI_(CRNumber *) CRSphericalCoordYZAngle(CRVector3 * arg0)
{
    TraceTag((tagAPIEntry, "CRSphericalCoordYZAngle"));

    return (CRNumber *) CreatePrim1(PhiCoordVector3Op, arg0);
}

extern AxANumber *RhoCoordVector3(Vector3Value *v);
AxAPrimOp *RhoCoordVector3Op;
CRSTDAPI_(CRNumber *) CRSphericalCoordLength(CRVector3 * arg0)
{
    TraceTag((tagAPIEntry, "CRSphericalCoordLength"));

    return (CRNumber *) CreatePrim1(RhoCoordVector3Op, arg0);
}

extern AxANumber *XCoordPoint3(Point3Value *v);
AxAPrimOp *XCoordPoint3Op;
CRSTDAPI_(CRNumber *) CRGetX(CRPoint3 * arg0)
{
    TraceTag((tagAPIEntry, "CRGetX"));

    return (CRNumber *) CreatePrim1(XCoordPoint3Op, arg0);
}

extern AxANumber *YCoordPoint3(Point3Value *v);
AxAPrimOp *YCoordPoint3Op;
CRSTDAPI_(CRNumber *) CRGetY(CRPoint3 * arg0)
{
    TraceTag((tagAPIEntry, "CRGetY"));

    return (CRNumber *) CreatePrim1(YCoordPoint3Op, arg0);
}

extern AxANumber *ZCoordPoint3(Point3Value *v);
AxAPrimOp *ZCoordPoint3Op;
CRSTDAPI_(CRNumber *) CRGetZ(CRPoint3 * arg0)
{
    TraceTag((tagAPIEntry, "CRGetZ"));

    return (CRNumber *) CreatePrim1(ZCoordPoint3Op, arg0);
}

extern AxANumber *ThetaCoordPoint3(Point3Value *v);
AxAPrimOp *ThetaCoordPoint3Op;
CRSTDAPI_(CRNumber *) CRSphericalCoordXYAngle(CRPoint3 * arg0)
{
    TraceTag((tagAPIEntry, "CRSphericalCoordXYAngle"));

    return (CRNumber *) CreatePrim1(ThetaCoordPoint3Op, arg0);
}

extern AxANumber *PhiCoordPoint3(Point3Value *v);
AxAPrimOp *PhiCoordPoint3Op;
CRSTDAPI_(CRNumber *) CRSphericalCoordYZAngle(CRPoint3 * arg0)
{
    TraceTag((tagAPIEntry, "CRSphericalCoordYZAngle"));

    return (CRNumber *) CreatePrim1(PhiCoordPoint3Op, arg0);
}

extern AxANumber *RhoCoordPoint3(Point3Value *v);
AxAPrimOp *RhoCoordPoint3Op;
CRSTDAPI_(CRNumber *) CRSphericalCoordLength(CRPoint3 * arg0)
{
    TraceTag((tagAPIEntry, "CRSphericalCoordLength"));

    return (CRNumber *) CreatePrim1(RhoCoordPoint3Op, arg0);
}

extern Transform3 *identityTransform3;
CRTransform3 * g_varCRIdentityTransform3;
CRSTDAPI_(CRTransform3 *) CRIdentityTransform3()
{
    return g_varCRIdentityTransform3;
}
extern Transform3 *TranslateReal3 (AnimPixelValue* tx,                                     AnimPixelYValue* ty,                                     AnimPixelValue* tz);
AxAPrimOp *TranslateReal3Op;
CRSTDAPI_(CRTransform3 *) CRTranslate3(CRNumber * arg0, CRNumber * arg1, CRNumber * arg2)
{
    TraceTag((tagAPIEntry, "CRTranslate3"));

    return (CRTransform3 *) CreatePrim3(TranslateReal3Op, arg0, arg1, arg2);
}

extern Transform3 *Translate(PixelDouble tx,PixelYDouble ty,PixelDouble tz);
CRSTDAPI_(CRTransform3 *) CRTranslate3(double arg0, double arg1, double arg2)
{
    TraceTag((tagAPIEntry, "CRTranslate3"));

    CRTransform3 * ret = NULL;

    APIPRECODE ;
    ret = (CRTransform3 *) (ConstBvr((AxAValue) Translate((arg0), (arg1), (arg2))));
    APIPOSTCODE ;
    return ret;
}

extern Transform3 *TranslateReal3 (RatePixelValue *tx,                                     RatePixelYValue *ty,                                     RatePixelValue *tz);
extern Transform3 *TranslateVector3 (Vector3Value *delta);
AxAPrimOp *TranslateVector3Op;
CRSTDAPI_(CRTransform3 *) CRTranslate3(CRVector3 * arg0)
{
    TraceTag((tagAPIEntry, "CRTranslate3"));

    return (CRTransform3 *) CreatePrim1(TranslateVector3Op, arg0);
}

extern Transform3 *TranslatePoint3 (Point3Value *new_origin);
AxAPrimOp *TranslatePoint3Op;
CRSTDAPI_(CRTransform3 *) CRTranslate3(CRPoint3 * arg0)
{
    TraceTag((tagAPIEntry, "CRTranslate3"));

    return (CRTransform3 *) CreatePrim1(TranslatePoint3Op, arg0);
}

extern Transform3 *ScaleReal3   (AxANumber *x, AxANumber *y, AxANumber *z);
AxAPrimOp *ScaleReal3Op;
CRSTDAPI_(CRTransform3 *) CRScale3(CRNumber * arg0, CRNumber * arg1, CRNumber * arg2)
{
    TraceTag((tagAPIEntry, "CRScale3"));

    return (CRTransform3 *) CreatePrim3(ScaleReal3Op, arg0, arg1, arg2);
}

extern Transform3 *Scale (double x, double y, double z);
CRSTDAPI_(CRTransform3 *) CRScale3(double arg0, double arg1, double arg2)
{
    TraceTag((tagAPIEntry, "CRScale3"));

    CRTransform3 * ret = NULL;

    APIPRECODE ;
    ret = (CRTransform3 *) (ConstBvr((AxAValue) Scale((arg0), (arg1), (arg2))));
    APIPOSTCODE ;
    return ret;
}

extern Transform3 *ScaleReal3   (ScaleRateValue *x, ScaleRateValue *y, ScaleRateValue *z);
extern Transform3 *ScaleVector3 (Vector3Value *scale_vec);
AxAPrimOp *ScaleVector3Op;
CRSTDAPI_(CRTransform3 *) CRScale3(CRVector3 * arg0)
{
    TraceTag((tagAPIEntry, "CRScale3"));

    return (CRTransform3 *) CreatePrim1(ScaleVector3Op, arg0);
}

extern Transform3 *Scale3UniformNumber (AxANumber *uniform_scale);
AxAPrimOp *Scale3UniformNumberOp;
CRSTDAPI_(CRTransform3 *) CRScale3Uniform(CRNumber * arg0)
{
    TraceTag((tagAPIEntry, "CRScale3Uniform"));

    return (CRTransform3 *) CreatePrim1(Scale3UniformNumberOp, arg0);
}

extern Transform3 *Scale3UniformDouble (double uniform_scale);
CRSTDAPI_(CRTransform3 *) CRScale3Uniform(double arg0)
{
    TraceTag((tagAPIEntry, "CRScale3Uniform"));

    CRTransform3 * ret = NULL;

    APIPRECODE ;
    ret = (CRTransform3 *) (ConstBvr((AxAValue) Scale3UniformDouble((arg0))));
    APIPOSTCODE ;
    return ret;
}

extern Transform3 *Scale3UniformNumber (ScaleRateValue *uniform_scale);
extern Transform3 *RotateAxisReal (Vector3Value *axis, AxANumber *angle);
AxAPrimOp *RotateAxisRealOp;
CRSTDAPI_(CRTransform3 *) CRRotate3(CRVector3 * arg0, CRNumber * arg1)
{
    TraceTag((tagAPIEntry, "CRRotate3"));

    return (CRTransform3 *) CreatePrim2(RotateAxisRealOp, arg0, arg1);
}

extern Transform3 *RotateAxis (Vector3Value *axis, double angle);
CRSTDAPI_(CRTransform3 *) CRRotate3(CRVector3 * arg0, double arg1)
{
    TraceTag((tagAPIEntry, "CRRotate3"));

    CRTransform3 * ret = NULL;

    APIPRECODE ;
    ret = (CRTransform3 *) (ConstBvr((AxAValue) RotateAxis(GETCONSTBVR(Vector3Value *, (arg0)), (arg1))));
    APIPOSTCODE ;
    return ret;
}

extern Transform3 *RotateAxisReal (Vector3Value *axis, RateValue *angle);
extern Transform3 *RotateAxis (Vector3Value *axis, DegreesDouble *angle);
extern Transform3 *RotateAxisReal (Vector3Value *axis, RateDegreesValue *angle);
extern Vector3Value *TransformVec3 (Transform3 *xf, Vector3Value *vec);
AxAPrimOp *TransformVec3Op;
CRSTDAPI_(CRVector3 *) CRTransform(CRVector3 * arg1, CRTransform3 * arg0)
{
    TraceTag((tagAPIEntry, "CRTransform"));

    return (CRVector3 *) CreatePrim2(TransformVec3Op, arg0, arg1);
}

extern Point3Value *TransformPoint3(Transform3 *xf, Point3Value *pt);
AxAPrimOp *TransformPoint3Op;
CRSTDAPI_(CRPoint3 *) CRTransform(CRPoint3 * arg1, CRTransform3 * arg0)
{
    TraceTag((tagAPIEntry, "CRTransform"));

    return (CRPoint3 *) CreatePrim2(TransformPoint3Op, arg0, arg1);
}

extern Transform3 *XShear3Number (AxANumber *a, AxANumber *b);
AxAPrimOp *XShear3NumberOp;
CRSTDAPI_(CRTransform3 *) CRXShear3(CRNumber * arg0, CRNumber * arg1)
{
    TraceTag((tagAPIEntry, "CRXShear3"));

    return (CRTransform3 *) CreatePrim2(XShear3NumberOp, arg0, arg1);
}

extern Transform3 *XShear3Double (double a, double b);
CRSTDAPI_(CRTransform3 *) CRXShear3(double arg0, double arg1)
{
    TraceTag((tagAPIEntry, "CRXShear3"));

    CRTransform3 * ret = NULL;

    APIPRECODE ;
    ret = (CRTransform3 *) (ConstBvr((AxAValue) XShear3Double((arg0), (arg1))));
    APIPOSTCODE ;
    return ret;
}

extern Transform3 *XShear3Number (RateValue *a, RateValue *b);
extern Transform3 *YShear3Number (AxANumber *c, AxANumber *d);
AxAPrimOp *YShear3NumberOp;
CRSTDAPI_(CRTransform3 *) CRYShear3(CRNumber * arg0, CRNumber * arg1)
{
    TraceTag((tagAPIEntry, "CRYShear3"));

    return (CRTransform3 *) CreatePrim2(YShear3NumberOp, arg0, arg1);
}

extern Transform3 *YShear3Double (double c, double d);
CRSTDAPI_(CRTransform3 *) CRYShear3(double arg0, double arg1)
{
    TraceTag((tagAPIEntry, "CRYShear3"));

    CRTransform3 * ret = NULL;

    APIPRECODE ;
    ret = (CRTransform3 *) (ConstBvr((AxAValue) YShear3Double((arg0), (arg1))));
    APIPOSTCODE ;
    return ret;
}

extern Transform3 *YShear3Number (RateValue *c, RateValue *d);
extern Transform3 *ZShear3Number (AxANumber *e, AxANumber *f);
AxAPrimOp *ZShear3NumberOp;
CRSTDAPI_(CRTransform3 *) CRZShear3(CRNumber * arg0, CRNumber * arg1)
{
    TraceTag((tagAPIEntry, "CRZShear3"));

    return (CRTransform3 *) CreatePrim2(ZShear3NumberOp, arg0, arg1);
}

extern Transform3 *ZShear3Double (double e, double f);
CRSTDAPI_(CRTransform3 *) CRZShear3(double arg0, double arg1)
{
    TraceTag((tagAPIEntry, "CRZShear3"));

    CRTransform3 * ret = NULL;

    APIPRECODE ;
    ret = (CRTransform3 *) (ConstBvr((AxAValue) ZShear3Double((arg0), (arg1))));
    APIPOSTCODE ;
    return ret;
}

extern Transform3 *ZShear3Number (RateValue *e, RateValue *f);
extern Transform3 *MatrixTransform4x4(DM_ARRAYARG(AxANumber*, AxAArray*) m);
AxAPrimOp *MatrixTransform4x4Op;
CRSTDAPI_(CRTransform3 *) CRTransform4x4(CRArrayPtr arg0)
{
    TraceTag((tagAPIEntry, "CRTransform4x4"));

    CRTransform3 * ret = NULL;

    APIPRECODE ;
    ret = (CRTransform3 *) (PrimApplyBvr(MatrixTransform4x4Op, 1, arg0));
    APIPOSTCODE ;
    return ret;
}

extern Transform3 *MatrixTransform4x4(DM_SAFEARRAYARG(AxANumber*, AxAArray*) m);
extern Transform3* TimesXformXform (Transform3 *a, Transform3 *b);
AxAPrimOp *TimesXformXformOp;
CRSTDAPI_(CRTransform3 *) CRCompose3(CRTransform3 * arg0, CRTransform3 * arg1)
{
    TraceTag((tagAPIEntry, "CRCompose3"));

    return (CRTransform3 *) CreatePrim2(TimesXformXformOp, arg0, arg1);
}

extern Transform3 *Compose3Array(DM_ARRAYARG(Transform3*, AxAArray*) xfs);
AxAPrimOp *Compose3ArrayOp;
CRSTDAPI_(CRTransform3 *) CRCompose3(CRArrayPtr arg0)
{
    TraceTag((tagAPIEntry, "CRCompose3"));

    CRTransform3 * ret = NULL;

    APIPRECODE ;
    ret = (CRTransform3 *) (PrimApplyBvr(Compose3ArrayOp, 1, arg0));
    APIPOSTCODE ;
    return ret;
}

extern Transform3 *Compose3Array(DM_SAFEARRAYARG(Transform3*, AxAArray*) xfs);
extern Transform3 *ThrowingInverseTransform3 (Transform3 *xform);
AxAPrimOp *InverseTransform3Op;
CRSTDAPI_(CRTransform3 *) CRInverse(CRTransform3 * arg0)
{
    TraceTag((tagAPIEntry, "CRInverse"));

    return (CRTransform3 *) CreatePrim1(InverseTransform3Op, arg0);
}

extern AxABoolean *IsSingularTransform3 (Transform3 *xform);
AxAPrimOp *IsSingularTransform3Op;
CRSTDAPI_(CRBoolean *) CRIsSingular(CRTransform3 * arg0)
{
    TraceTag((tagAPIEntry, "CRIsSingular"));

    return (CRBoolean *) CreatePrim1(IsSingularTransform3Op, arg0);
}

extern Transform3 *LookAtFrom (Point3Value *to, Point3Value *from, Vector3Value *up);
AxAPrimOp *LookAtFromOp;
CRSTDAPI_(CRTransform3 *) CRLookAtFrom(CRPoint3 * arg0, CRPoint3 * arg1, CRVector3 * arg2)
{
    TraceTag((tagAPIEntry, "CRLookAtFrom"));

    return (CRTransform3 *) CreatePrim3(LookAtFromOp, arg0, arg1, arg2);
}

extern Transform2 *identityTransform2;
CRTransform2 * g_varCRIdentityTransform2;
CRSTDAPI_(CRTransform2 *) CRIdentityTransform2()
{
    return g_varCRIdentityTransform2;
}
extern Transform2 *TranslateRealReal (AnimPixelValue *Tx,                                        AnimPixelYValue *Ty);
AxAPrimOp *TranslateRealRealOp;
CRSTDAPI_(CRTransform2 *) CRTranslate2(CRNumber * arg0, CRNumber * arg1)
{
    TraceTag((tagAPIEntry, "CRTranslate2"));

    return (CRTransform2 *) CreatePrim2(TranslateRealRealOp, arg0, arg1);
}

extern Transform2 *TranslateRR (Real Tx,Real Ty);
CRSTDAPI_(CRTransform2 *) CRTranslate2(double arg0, double arg1)
{
    TraceTag((tagAPIEntry, "CRTranslate2"));

    CRTransform2 * ret = NULL;

    APIPRECODE ;
    ret = (CRTransform2 *) ConstBvr((AxAValue) TranslateRR(arg0,arg1));
    APIPOSTCODE ;
    return ret;
}

extern Transform2 *TranslateRealReal (RatePixelValue *Tx, RatePixelYValue *Ty);
extern Transform2 *TranslateVector2Value (Vector2Value *delta);
AxAPrimOp *TranslateVector2Op;
CRSTDAPI_(CRTransform2 *) CRTranslate2(CRVector2 * arg0)
{
    TraceTag((tagAPIEntry, "CRTranslate2"));

    return (CRTransform2 *) CreatePrim1(TranslateVector2Op, arg0);
}

extern Transform2 *Translate2PointValue(Point2Value *pos);
AxAPrimOp *Translate2PointOp;
CRSTDAPI_(CRTransform2 *) CRTranslate2(CRPoint2 * arg0)
{
    TraceTag((tagAPIEntry, "CRTranslate2"));

    return (CRTransform2 *) CreatePrim1(Translate2PointOp, arg0);
}

extern Transform2 *ScaleRealReal (AxANumber *x, AxANumber *y);
AxAPrimOp *ScaleRealRealOp;
CRSTDAPI_(CRTransform2 *) CRScale2(CRNumber * arg0, CRNumber * arg1)
{
    TraceTag((tagAPIEntry, "CRScale2"));

    return (CRTransform2 *) CreatePrim2(ScaleRealRealOp, arg0, arg1);
}

extern Transform2 *ScaleRR (Real x, Real y);
CRSTDAPI_(CRTransform2 *) CRScale2(double arg0, double arg1)
{
    TraceTag((tagAPIEntry, "CRScale2"));

    CRTransform2 * ret = NULL;

    APIPRECODE ;
    ret = (CRTransform2 *) ConstBvr((AxAValue) ScaleRR(arg0,arg1));
    APIPOSTCODE ;
    return ret;
}

extern Transform2 *ScaleRealReal (ScaleRateValue *x, ScaleRateValue *y);
extern Transform2 *ScaleVector2Value (Vector2Value *obsoleteMethod);
AxAPrimOp *ScaleVector2Op;
CRSTDAPI_(CRTransform2 *) CRScale2(CRVector2 * arg0)
{
    TraceTag((tagAPIEntry, "CRScale2"));

    return (CRTransform2 *) CreatePrim1(ScaleVector2Op, arg0);
}

extern Transform2 *ScaleVector2Value (Vector2Value *scale_vec);
extern Transform2 *Scale2 (AxANumber *uniform_scale);
AxAPrimOp *Scale2Op;
CRSTDAPI_(CRTransform2 *) CRScale2Uniform(CRNumber * arg0)
{
    TraceTag((tagAPIEntry, "CRScale2Uniform"));

    return (CRTransform2 *) CreatePrim1(Scale2Op, arg0);
}

CRSTDAPI_(CRTransform2 *) CRScale2Uniform(double arg0)
{
    TraceTag((tagAPIEntry, "CRScale2Uniform"));

    CRTransform2 * ret = NULL;

    APIPRECODE ;
    ret = (CRTransform2 *) ConstBvr((AxAValue) ScaleRR(arg0,arg0));
    APIPOSTCODE ;
    return ret;
}

extern Transform2 *Scale2 (RateValue *uniform_scale);
extern Transform2 *RotateReal(AxANumber *angle);
AxAPrimOp *RotateRealOp;
CRSTDAPI_(CRTransform2 *) CRRotate2(CRNumber * arg0)
{
    TraceTag((tagAPIEntry, "CRRotate2"));

    return (CRTransform2 *) CreatePrim1(RotateRealOp, arg0);
}

extern Transform2 *RotateRealR(Real angle);
CRSTDAPI_(CRTransform2 *) CRRotate2(double arg0)
{
    TraceTag((tagAPIEntry, "CRRotate2"));

    CRTransform2 * ret = NULL;

    APIPRECODE ;
    ret = (CRTransform2 *) ConstBvr((AxAValue) RotateRealR(arg0));
    APIPOSTCODE ;
    return ret;
}

CRSTDAPI_(CRTransform2 *) CRRotate2Degrees(double arg0)
{
    TraceTag((tagAPIEntry, "CRRotate2Degrees"));

    CRTransform2 * ret = NULL;

    APIPRECODE ;
    ret = (CRTransform2 *) ConstBvr((AxAValue) RotateRealR(arg0));
    APIPOSTCODE ;
    return ret;
}

extern Transform2 *RotateReal(RateDegreesValue *angle);
extern Transform2 *XShear2 (AxANumber *);
AxAPrimOp *XShear2Op;
CRSTDAPI_(CRTransform2 *) CRXShear2(CRNumber * arg0)
{
    TraceTag((tagAPIEntry, "CRXShear2"));

    return (CRTransform2 *) CreatePrim1(XShear2Op, arg0);
}

extern Transform2 *XShear2R (Real);
CRSTDAPI_(CRTransform2 *) CRXShear2(double arg0)
{
    TraceTag((tagAPIEntry, "CRXShear2"));

    CRTransform2 * ret = NULL;

    APIPRECODE ;
    ret = (CRTransform2 *) ConstBvr((AxAValue) XShear2R(arg0));
    APIPOSTCODE ;
    return ret;
}

extern Transform2 *XShear2 (RateValue *);
extern Transform2 *YShear2 (AxANumber *);
AxAPrimOp *YShear2Op;
CRSTDAPI_(CRTransform2 *) CRYShear2(CRNumber * arg0)
{
    TraceTag((tagAPIEntry, "CRYShear2"));

    return (CRTransform2 *) CreatePrim1(YShear2Op, arg0);
}

extern Transform2 *YShear2R (Real);
CRSTDAPI_(CRTransform2 *) CRYShear2(double arg0)
{
    TraceTag((tagAPIEntry, "CRYShear2"));

    CRTransform2 * ret = NULL;

    APIPRECODE ;
    ret = (CRTransform2 *) ConstBvr((AxAValue) YShear2R(arg0));
    APIPOSTCODE ;
    return ret;
}

extern Transform2 *YShear2 (RateValue *);
extern Transform2 *MatrixTransform(DM_ARRAYARG(AxANumber*, AxAArray*) m);
AxAPrimOp *MatrixTransformOp;
CRSTDAPI_(CRTransform2 *) CRTransform3x2(CRArrayPtr arg0)
{
    TraceTag((tagAPIEntry, "CRTransform3x2"));

    CRTransform2 * ret = NULL;

    APIPRECODE ;
    ret = (CRTransform2 *) (PrimApplyBvr(MatrixTransformOp, 1, arg0));
    APIPOSTCODE ;
    return ret;
}

CRSTDAPI_(CRTransform2 *) CRTransform3x2(double *m, unsigned int n)
{
    TraceTag((tagAPIEntry, "CRTransform3x2 - double"));

    CRTransform2 * ret = NULL;

    APIPRECODE ;
    ret = (CRTransform2 *) ConstBvr(FullXform(m[0], m[1], m[2],
                                              m[3], m[4], m[5]));
    APIPOSTCODE ;
    return ret;
}

extern Transform2 *MatrixTransform(DM_SAFEARRAYARG(AxANumber*, AxAArray*) m);
extern Transform2 *TimesTransform2Transform2(Transform2 *a, Transform2 *b);
AxAPrimOp *TimesTransform2Transform2Op;
CRSTDAPI_(CRTransform2 *) CRCompose2(CRTransform2 * arg0, CRTransform2 * arg1)
{
    TraceTag((tagAPIEntry, "CRCompose2"));

    return (CRTransform2 *) CreatePrim2(TimesTransform2Transform2Op, arg0, arg1);
}

extern Transform2 *Compose2Array(DM_ARRAYARG(Transform2*, AxAArray*) xfs);
AxAPrimOp *Compose2ArrayOp;
CRSTDAPI_(CRTransform2 *) CRCompose2(CRArrayPtr arg0)
{
    TraceTag((tagAPIEntry, "CRCompose2"));

    CRTransform2 * ret = NULL;

    APIPRECODE ;
    ret = (CRTransform2 *) (PrimApplyBvr(Compose2ArrayOp, 1, arg0));
    APIPOSTCODE ;
    return ret;
}

extern Transform2 *Compose2Array(DM_SAFEARRAYARG(Transform2*, AxAArray*) xfs);
extern Point2Value *TransformPoint2Value(Transform2 *xf, Point2Value *pt);
AxAPrimOp *TransformPoint2Op;
CRSTDAPI_(CRPoint2 *) CRTransform(CRPoint2 * arg1, CRTransform2 * arg0)
{
    TraceTag((tagAPIEntry, "CRTransform"));

    return (CRPoint2 *) CreatePrim2(TransformPoint2Op, arg0, arg1);
}

extern Vector2Value *TransformVector2Value(Transform2 *xf, Vector2Value *vec);
AxAPrimOp *TransformVector2Op;
CRSTDAPI_(CRVector2 *) CRTransform(CRVector2 * arg1, CRTransform2 * arg0)
{
    TraceTag((tagAPIEntry, "CRTransform"));

    return (CRVector2 *) CreatePrim2(TransformVector2Op, arg0, arg1);
}

extern Transform2 *ThrowingInverseTransform2 (Transform2 *theXf);
AxAPrimOp *InverseTransform2Op;
CRSTDAPI_(CRTransform2 *) CRInverse(CRTransform2 * arg0)
{
    TraceTag((tagAPIEntry, "CRInverse"));

    return (CRTransform2 *) CreatePrim1(InverseTransform2Op, arg0);
}

extern AxABoolean *IsSingularTransform2 (Transform2 *theXf);
AxAPrimOp *IsSingularTransform2Op;
CRSTDAPI_(CRBoolean *) CRIsSingular(CRTransform2 * arg0)
{
    TraceTag((tagAPIEntry, "CRIsSingular"));

    return (CRBoolean *) CreatePrim1(IsSingularTransform2Op, arg0);
}

extern Transform2 *ParallelTransform2(Transform3 *xf);
AxAPrimOp *ParallelTransform2Op;
CRSTDAPI_(CRTransform2 *) CRParallelTransform2(CRTransform3 * arg0)
{
    TraceTag((tagAPIEntry, "CRParallelTransform2"));

    return (CRTransform2 *) CreatePrim1(ParallelTransform2Op, arg0);
}

extern Bvr viewFrameRateBvr ;
CRSTDAPI_(CRNumber *) CRViewFrameRate()
{
    return (CRNumber *) viewFrameRateBvr;
}

extern Bvr viewTimeDeltaBvr ;
CRSTDAPI_(CRNumber *) CRViewTimeDelta()
{
    return (CRNumber *) viewTimeDeltaBvr;
}

extern Montage *UnionMontage(DM_ARRAYARG(Montage*, AxAArray*) mtgs);
AxAPrimOp *UnionMontageOp;
CRSTDAPI_(CRMontage *) CRUnionMontageArray(CRArrayPtr arg0)
{
    TraceTag((tagAPIEntry, "CRUnionMontageArray"));

    CRMontage * ret = NULL;

    APIPRECODE ;
    ret = (CRMontage *) (PrimApplyBvr(UnionMontageOp, 1, arg0));
    APIPOSTCODE ;
    return ret;
}

extern Montage *UnionMontage(DM_SAFEARRAYARG(Montage*, AxAArray*) mtgs);
extern Color * emptyColor;
CRColor * g_varCREmptyColor;
CRSTDAPI_(CRColor *) CREmptyColor()
{
    return g_varCREmptyColor;
}

void InitializeModule_API()
{
    RealPowerOp = ValPrimOp(::RealPower,2,"RealPower", AxANumberType);
    RealAbsOp = ValPrimOp(::RealAbs,1,"RealAbs", AxANumberType);
    RealSqrtOp = ValPrimOp(::RealSqrt,1,"RealSqrt", AxANumberType);
    RealFloorOp = ValPrimOp(::RealFloor,1,"RealFloor", AxANumberType);
    RealRoundOp = ValPrimOp(::RealRound,1,"RealRound", AxANumberType);
    RealCeilingOp = ValPrimOp(::RealCeiling,1,"RealCeiling", AxANumberType);
    RealAsinOp = ValPrimOp(::RealAsin,1,"RealAsin", AxANumberType);
    RealAcosOp = ValPrimOp(::RealAcos,1,"RealAcos", AxANumberType);
    RealAtanOp = ValPrimOp(::RealAtan,1,"RealAtan", AxANumberType);
    RealSinOp = ValPrimOp(::RealSin,1,"RealSin", AxANumberType);
    RealCosOp = ValPrimOp(::RealCos,1,"RealCos", AxANumberType);
    RealTanOp = ValPrimOp(::RealTan,1,"RealTan", AxANumberType);
    RealExpOp = ValPrimOp(::RealExp,1,"RealExp", AxANumberType);
    RealLnOp = ValPrimOp(::RealLn,1,"RealLn", AxANumberType);
    RealLog10Op = ValPrimOp(::RealLog10,1,"RealLog10", AxANumberType);
    RealRadToDegOp = ValPrimOp(::RealRadToDeg,1,"RealRadToDeg", AxANumberType);
    RealDegToRadOp = ValPrimOp(::RealDegToRad,1,"RealDegToRad", AxANumberType);
    RealModulusOp = ValPrimOp(::RealModulus,2,"RealModulus", AxANumberType);
    RealAtan2Op = ValPrimOp(::RealAtan2,2,"RealAtan2", AxANumberType);
    RealAddOp = ValPrimOp(::RealAdd,2,"RealAdd", AxANumberType);
    RealSubtractOp = ValPrimOp(::RealSubtract,2,"RealSubtract", AxANumberType);
    RealMultiplyOp = ValPrimOp(::RealMultiply,2,"RealMultiply", AxANumberType);
    RealDivideOp = ValPrimOp(::RealDivide,2,"RealDivide", AxANumberType);
    RealLTOp = ValPrimOp(::RealLT,2,"RealLT", AxABooleanType);
    RealLTEOp = ValPrimOp(::RealLTE,2,"RealLTE", AxABooleanType);
    RealGTOp = ValPrimOp(::RealGT,2,"RealGT", AxABooleanType);
    RealGTEOp = ValPrimOp(::RealGTE,2,"RealGTE", AxABooleanType);
    RealEQOp = ValPrimOp(::RealEQ,2,"RealEQ", AxABooleanType);
    RealNEOp = ValPrimOp(::RealNE,2,"RealNE", AxABooleanType);
    RealNegateOp = ValPrimOp(::RealNegate,1,"RealNegate", AxANumberType);
    BoolAndOp = ValPrimOp(::BoolAnd,2,"BoolAnd", AxABooleanType);
    BoolOrOp = ValPrimOp(::BoolOr,2,"BoolOr", AxABooleanType);
    BoolNotOp = ValPrimOp(::BoolNot,1,"BoolNot", AxABooleanType);
    ArrayLengthOp = ValPrimOp(::ArrayLength,1,"ArrayLength", AxANumberType);
    ConcatOp = ValPrimOp(::Concat,2,"Concat", AxAStringType);
    MinBbox2Op = ValPrimOp(::MinBbox2,1,"MinBbox2", Point2ValueType);
    MaxBbox2Op = ValPrimOp(::MaxBbox2,1,"MaxBbox2", Point2ValueType);
    MinBbox3Op = ValPrimOp(::MinBbox3,1,"MinBbox3", Point3ValueType);
    MaxBbox3Op = ValPrimOp(::MaxBbox3,1,"MaxBbox3", Point3ValueType);
    PerspectiveCameraOp = ValPrimOp(::PerspectiveCamera,2,"PerspectiveCamera", CameraType);
    ParallelCameraOp = ValPrimOp(::ParallelCamera,1,"ParallelCamera", CameraType);
    TransformCameraOp = ValPrimOp(::TransformCamera,2,"TransformCamera", CameraType);
    DepthOp = ValPrimOp(::Depth,2,"Depth", CameraType);
    DepthResolutionOp = ValPrimOp(::DepthResolution,2,"DepthResolution", CameraType);
    ProjectPointOp = ValPrimOp(::ProjectPoint,2,"ProjectPoint", Point2ValueType);
    RgbColorOp = ValPrimOp(::RgbColor,3,"RgbColor", ColorType);
    HslColorOp = ValPrimOp(::HslColor,3,"HslColor", ColorType);
    RedComponentOp = ValPrimOp(::RedComponent,1,"RedComponent", AxANumberType);
    GreenComponentOp = ValPrimOp(::GreenComponent,1,"GreenComponent", AxANumberType);
    BlueComponentOp = ValPrimOp(::BlueComponent,1,"BlueComponent", AxANumberType);
    HueComponentOp = ValPrimOp(::HueComponent,1,"HueComponent", AxANumberType);
    SaturationComponentOp = ValPrimOp(::SaturationComponent,1,"SaturationComponent", AxANumberType);
    LuminanceComponentOp = ValPrimOp(::LuminanceComponent,1,"LuminanceComponent", AxANumberType);
    g_varCRRed = (CRColor *) ConstBvr((AxAValue) ::red);
    g_varCRGreen = (CRColor *) ConstBvr((AxAValue) ::green);
    g_varCRBlue = (CRColor *) ConstBvr((AxAValue) ::blue);
    g_varCRCyan = (CRColor *) ConstBvr((AxAValue) ::cyan);
    g_varCRMagenta = (CRColor *) ConstBvr((AxAValue) ::magenta);
    g_varCRYellow = (CRColor *) ConstBvr((AxAValue) ::yellow);
    g_varCRBlack = (CRColor *) ConstBvr((AxAValue) ::black);
    g_varCRWhite = (CRColor *) ConstBvr((AxAValue) ::white);
    g_varCRAqua = (CRColor *) ConstBvr((AxAValue) ::aqua);
    g_varCRFuchsia = (CRColor *) ConstBvr((AxAValue) ::fuchsia);
    g_varCRGray = (CRColor *) ConstBvr((AxAValue) ::gray);
    g_varCRLime = (CRColor *) ConstBvr((AxAValue) ::lime);
    g_varCRMaroon = (CRColor *) ConstBvr((AxAValue) ::maroon);
    g_varCRNavy = (CRColor *) ConstBvr((AxAValue) ::navy);
    g_varCROlive = (CRColor *) ConstBvr((AxAValue) ::olive);
    g_varCRPurple = (CRColor *) ConstBvr((AxAValue) ::purple);
    g_varCRSilver = (CRColor *) ConstBvr((AxAValue) ::silver);
    g_varCRTeal = (CRColor *) ConstBvr((AxAValue) ::teal);
    UndetectableGeometryOp = ValPrimOp(::UndetectableGeometry,1,"UndetectableGeometry", GeometryType);
    applyEmissiveColorOp = ValPrimOp(::applyEmissiveColor,2,"applyEmissiveColor", GeometryType);
    applyDiffuseColorOp = ValPrimOp(::applyDiffuseColor,2,"applyDiffuseColor", GeometryType);
    applySpecularColorOp = ValPrimOp(::applySpecularColor,2,"applySpecularColor", GeometryType);
    applySpecularExponentOp = ValPrimOp(::applySpecularExponent,2,"applySpecularExponent", GeometryType);
    applyTextureMapOp = ValPrimOp(::applyTextureMap,2,"applyTextureMap", GeometryType);
    applyOpacityLevelOp = ValPrimOp(::applyOpacityLevel,2,"applyOpacityLevel", GeometryType);
    applyTransformOp = ValPrimOp(::applyTransform,2,"applyTransform", GeometryType);
    ShadowGeometryOp = ValPrimOp(::ShadowGeometry,4,"ShadowGeometry", GeometryType);
    g_varCREmptyGeometry = (CRGeometry *) ConstBvr((AxAValue) ::emptyGeometry);
    PlusGeomGeomOp = ValPrimOp(::PlusGeomGeom,2,"PlusGeomGeom", GeometryType);
    UnionArrayOp = ValPrimOp(::UnionArray,1,"UnionArray", GeometryType);
    GeomBoundingBoxOp = ValPrimOp(::GeomBoundingBox,1,"GeomBoundingBox", Bbox3Type);
    g_varCREmptyImage = (CRImage *) ConstBvr((AxAValue) ::emptyImage);
    g_varCRDetectableEmptyImage = (CRImage *) ConstBvr((AxAValue) ::detectableEmptyImage);
    RenderImageOp = ValPrimOp(::RenderImage,2,"RenderImage", ImageType);
    SolidColorImageOp = ValPrimOp(::SolidColorImage,1,"SolidColorImage", ImageType);
    GradientPolygonOp = ValPrimOp(::GradientPolygon,2,"GradientPolygon", ImageType);
    RadialGradientPolygonOp = ValPrimOp(::RadialGradientPolygon,4,"RadialGradientPolygon", ImageType);
    GradientSquareOp = ValPrimOp(::GradientSquare,4,"GradientSquare", ImageType);
    RadialGradientSquareOp = ValPrimOp(::RadialGradientSquare,3,"RadialGradientSquare", ImageType);
    RadialGradientRegularPolyOp = ValPrimOp(::RadialGradientRegularPoly,4,"RadialGradientRegularPoly", ImageType);
    RadialGradientMulticolorOp =  ValPrimOp(::RadialGradientMulticolor,2,"RadialGradientMulticolor", ImageType);
    LinearGradientMulticolorOp =  ValPrimOp(::LinearGradientMulticolor,2,"LinearGradientMulticolor", ImageType);
    GradientHorizontalOp = ValPrimOp(::GradientHorizontal,3,"GradientHorizontal", ImageType);
    HatchHorizontalOp = ValPrimOp(::HatchHorizontal,2,"HatchHorizontal", ImageType);
    HatchVerticalOp = ValPrimOp(::HatchVertical,2,"HatchVertical", ImageType);
    HatchForwardDiagonalOp = ValPrimOp(::HatchForwardDiagonal,2,"HatchForwardDiagonal", ImageType);
    HatchBackwardDiagonalOp = ValPrimOp(::HatchBackwardDiagonal,2,"HatchBackwardDiagonal", ImageType);
    HatchCrossOp = ValPrimOp(::HatchCross,2,"HatchCross", ImageType);
    HatchDiagonalCrossOp = ValPrimOp(::HatchDiagonalCross,2,"HatchDiagonalCross", ImageType);
    OverlayOp = ValPrimOp(::Overlay,2,"Overlay", ImageType);
    OverlayArrayOp = ValPrimOp(::OverlayArray,1,"OverlayArray", ImageType);
    BoundingBoxOp = ValPrimOp(::BoundingBox,1,"BoundingBox", Bbox2ValueType);
    CropImageOp = ValPrimOp(::CropImage,3,"CropImage", ImageType);
    TransformImageOp = ValPrimOp(::TransformImage,2,"TransformImage", ImageType);
    OpaqueImageOp = ValPrimOp(::OpaqueImage,2,"OpaqueImage", ImageType);
    UndetectableImageOp = ValPrimOp(::UndetectableImage,1,"UndetectableImage", ImageType);
    TileImageOp = ValPrimOp(::TileImage,1,"TileImage", ImageType);
    ClipImageOp = ValPrimOp(::ClipImage,2,"ClipImage", ImageType);
    MapToUnitSquareOp = ValPrimOp(::MapToUnitSquare,1,"MapToUnitSquare", ImageType);
    ClipPolygonOp = ValPrimOp(::ClipPolygon,2,"ClipPolygon", ImageType);
    ConstructColorKeyedImageOp = ValPrimOp(::ConstructColorKeyedImage,2,"ConstructColorKeyedImage", ImageType);
    TransformColorRGBImageOp = ValPrimOp(::TransformColorRGBImage,2,"TransformColorRGBImage", ImageType);
    g_varCRAmbientLight = (CRGeometry *) ConstBvr((AxAValue) ::ambientLight);
    g_varCRDirectionalLight = (CRGeometry *) ConstBvr((AxAValue) ::directionalLight);
    g_varCRPointLight = (CRGeometry *) ConstBvr((AxAValue) ::pointLight);
    SpotLightOp = ValPrimOp(::SpotLight,2,"SpotLight", GeometryType);
    applyLightColorOp = ValPrimOp(::applyLightColor,2,"applyLightColor", GeometryType);
    applyLightRangeOp = ValPrimOp(::applyLightRange,2,"applyLightRange", GeometryType);
    applyLightAttenuationOp = ValPrimOp(::applyLightAttenuation,4,"applyLightAttenuation", GeometryType);
    BlendTextureDiffuseOp = ValPrimOp(::BlendTextureDiffuse,2,"BlendTextureDiffuse", GeometryType);
    applyAmbientColorOp = ValPrimOp(::applyAmbientColor,2,"applyAmbientColor", GeometryType);
    applyModelClipOp = ValPrimOp(::applyModelClip,3,"applyModelClip", GeometryType);
    applyLightingOp = ValPrimOp(::applyLighting,2,"applyLighting", GeometryType);
    applyTextureImageOp = ValPrimOp(::applyTextureImage,2,"applyTextureImage", GeometryType);
    BillboardOp = ValPrimOp (::Billboard, 2, "Billboard", GeometryType);
    g_varCRDefaultLineStyle = (CRLineStyle *) ConstBvr((AxAValue) ::defaultLineStyle);
    g_varCREmptyLineStyle = (CRLineStyle *) ConstBvr((AxAValue) ::emptyLineStyle);
    LineEndStyleOp = ValPrimOp(::LineEndStyle,2,"LineEndStyle", LineStyleType);
    LineJoinStyleOp = ValPrimOp(::LineJoinStyle,2,"LineJoinStyle", LineStyleType);
    LineDashStyleOp = ValPrimOp(::LineDashStyle,2,"LineDashStyle", LineStyleType);
    LineWidthStyleOp = ValPrimOp(::LineWidthStyle,2,"LineWidthStyle", LineStyleType);
    LineAntiAliasingOp = ValPrimOp(::LineAntiAliasing,2,"LineAntiAliasing", LineStyleType);
    LineDetailStyleOp = ValPrimOp(::LineDetailStyle,1,"LineDetailStyle", LineStyleType);
    LineColorOp = ValPrimOp(::LineColor,2,"LineColor", LineStyleType);
    g_varCRJoinStyleBevel = (CRJoinStyle *) ConstBvr((AxAValue) ::joinStyleBevel);
    g_varCRJoinStyleRound = (CRJoinStyle *) ConstBvr((AxAValue) ::joinStyleRound);
    g_varCRJoinStyleMiter = (CRJoinStyle *) ConstBvr((AxAValue) ::joinStyleMiter);
    g_varCREndStyleFlat = (CREndStyle *) ConstBvr((AxAValue) ::endStyleFlat);
    g_varCREndStyleSquare = (CREndStyle *) ConstBvr((AxAValue) ::endStyleSquare);
    g_varCREndStyleRound = (CREndStyle *) ConstBvr((AxAValue) ::endStyleRound);
    g_varCRDashStyleSolid = (CRDashStyle *) ConstBvr((AxAValue) ::dashStyleSolid);
    g_varCRDashStyleDashed = (CRDashStyle *) ConstBvr((AxAValue) ::dashStyleDashed);
    ConstructLineStyleMiterLimitOp = ValPrimOp(::ConstructLineStyleMiterLimit,2,"ConstructLineStyleMiterLimit", LineStyleType);
    g_varCRDefaultMicrophone = (CRMicrophone *) ConstBvr((AxAValue) ::defaultMicrophone);
    TransformMicrophoneOp = ValPrimOp(::TransformMicrophone,2,"TransformMicrophone", MicrophoneType);
    g_varCROpaqueMatte = (CRMatte *) ConstBvr((AxAValue) ::opaqueMatte);
    g_varCRClearMatte = (CRMatte *) ConstBvr((AxAValue) ::clearMatte);
    UnionMatteOp = ValPrimOp(::UnionMatte,2,"UnionMatte", MatteType);
    IntersectMatteOp = ValPrimOp(::IntersectMatte,2,"IntersectMatte", MatteType);
    SubtractMatteOp = ValPrimOp(::SubtractMatte,2,"SubtractMatte", MatteType);
    TransformMatteOp = ValPrimOp(::TransformMatte,2,"TransformMatte", MatteType);
    RegionFromPathOp = ValPrimOp(::RegionFromPath,1,"RegionFromPath", MatteType);
    TextMatteConstructorOp = ValPrimOp(::TextMatteConstructor,2,"TextMatteConstructor", MatteType);
    g_varCREmptyMontage = (CRMontage *) ConstBvr((AxAValue) ::emptyMontage);
    ImageMontageOp = ValPrimOp(::ImageMontage,2,"ImageMontage", MontageType);
    UnionMontageMontageOp = ValPrimOp(::UnionMontageMontage,2,"UnionMontageMontage", MontageType);
    RenderOp = ValPrimOp(::Render,1,"Render", ImageType);
    ConcatenatePath2Op = ValPrimOp(::ConcatenatePath2,2,"ConcatenatePath2", Path2Type);
    Concat2ArrayOp = ValPrimOp(::Concat2Array,1,"Concat2Array", Path2Type);
    TransformPath2Op = ValPrimOp(::TransformPath2,2,"TransformPath2", Path2Type);
    BoundingBoxPathOp = ValPrimOp(::BoundingBoxPath,2,"BoundingBoxPath", Bbox2ValueType);
    PathFillOp = ValPrimOp(::PathFill,3,"PathFill", ImageType);
    DrawPathOp = ValPrimOp(::DrawPath,2,"DrawPath", ImageType);
    ClosePath2Op = ValPrimOp(::ClosePath2,1,"ClosePath2", Path2Type);
    Line2Op = ValPrimOp(::Line2,2,"Line2", Path2Type);
    RelativeLine2Op = ValPrimOp(::RelativeLine2,1,"RelativeLine2", Path2Type);
    TextPath2ConstructorOp = ValPrimOp(::TextPath2Constructor,2,"TextPath2Constructor", Path2Type);
    PolyLine2Op = ValPrimOp(::PolyLine2,1,"PolyLine2", Path2Type);
    PolydrawPath2Op = ValPrimOp(::PolydrawPath2,2,"PolydrawPath2", Path2Type);
    ArcValOp = ValPrimOp(::ArcVal,4,"ArcVal", Path2Type);
    PieValOp = ValPrimOp(::PieVal,4,"PieVal", Path2Type);
    OvalValOp = ValPrimOp(::OvalVal,2,"OvalVal", Path2Type);
    RectangleValOp = ValPrimOp(::RectangleVal,2,"RectangleVal", Path2Type);
    RoundRectValOp = ValPrimOp(::RoundRectVal,4,"RoundRectVal", Path2Type);
    CubicBSplinePathOp = ValPrimOp(::CubicBSplinePath,2,"CubicBSplinePath", Path2Type);
    g_varCRSilence = (CRSound *) ConstBvr((AxAValue) ::silence);
    MixArrayOp = ValPrimOp(::MixArray,1,"MixArray", SoundType);
    NumberStringOp = ValPrimOp(::NumberString,2,"NumberString", AxAStringType);
    g_varCRDefaultFont = (CRFontStyle *) ConstBvr((AxAValue) ::defaultFont);
    FontOp = ValPrimOp(::Font,3,"Font", FontStyleType);
    ImageFromStringAndFontStyleOp = ValPrimOp(::ImageFromStringAndFontStyle,2,"ImageFromStringAndFontStyle", ImageType);
    FontStyleBoldOp = ValPrimOp(::FontStyleBold,1,"FontStyleBold", FontStyleType);
    FontStyleItalicOp = ValPrimOp(::FontStyleItalic,1,"FontStyleItalic", FontStyleType);
    FontStyleUnderlineOp = ValPrimOp(::FontStyleUnderline,1,"FontStyleUnderline", FontStyleType);
    FontStyleStrikethroughOp = ValPrimOp(::FontStyleStrikethrough,1,"FontStyleStrikethrough", FontStyleType);
    FontStyleAntiAliasingOp = ValPrimOp(::FontStyleAntiAliasing,2,"FontStyleAntiAliasing", FontStyleType);
    FontStyleColorOp = ValPrimOp(::FontStyleColor,2,"FontStyleColor", FontStyleType);
    FontStyleFaceOp = ValPrimOp(::FontStyleFace,2,"FontStyleFace", FontStyleType);
    FontStyleSizeOp = ValPrimOp(::FontStyleSize,2,"FontStyleSize", FontStyleType);
    FontStyleWeightOp = ValPrimOp(::FontStyleWeight,2,"FontStyleWeight", FontStyleType);
    FontStyleTransformCharactersOp = ValPrimOp(::FontStyleTransformCharacters,2,"FontStyleTransformCharacters", FontStyleType);
    g_varCRXVector2 = (CRVector2 *) ConstBvr((AxAValue) ::xVector2);
    g_varCRYVector2 = (CRVector2 *) ConstBvr((AxAValue) ::yVector2);
    g_varCRZeroVector2 = (CRVector2 *) ConstBvr((AxAValue) ::zeroVector2);
    g_varCROrigin2 = (CRPoint2 *) ConstBvr((AxAValue) ::origin2);
    XyVector2Op = ValPrimOp(::XyVector2,2,"XyVector2", Vector2ValueType);
    XyPoint2Op = ValPrimOp(::XyPoint2,2,"XyPoint2", Point2ValueType);
    PolarVector2Op = ValPrimOp(::PolarVector2,2,"PolarVector2", Vector2ValueType);
    PolarPoint2Op = ValPrimOp(::PolarPoint2,2,"PolarPoint2", Point2ValueType);
    LengthVector2Op = ValPrimOp(::LengthVector2,1,"LengthVector2", AxANumberType);
    LengthSquaredVector2Op = ValPrimOp(::LengthSquaredVector2,1,"LengthSquaredVector2", AxANumberType);
    NormalVector2Op = ValPrimOp(::NormalVector2,1,"NormalVector2", Vector2ValueType);
    DotVector2Vector2Op = ValPrimOp(::DotVector2Vector2,2,"DotVector2Vector2", AxANumberType);
    NegateVector2Op = ValPrimOp(::NegateVector2,1,"NegateVector2", Vector2ValueType);
    ScaleVector2RealOp = ValPrimOp(::ScaleVector2Real,2,"ScaleVector2Real", Vector2ValueType);
    DivideVector2RealOp = ValPrimOp(::DivideVector2Real,2,"DivideVector2Real", Vector2ValueType);
    MinusVector2Vector2Op = ValPrimOp(::MinusVector2Vector2,2,"MinusVector2Vector2", Vector2ValueType);
    PlusVector2Vector2Op = ValPrimOp(::PlusVector2Vector2,2,"PlusVector2Vector2", Vector2ValueType);
    PlusPoint2Vector2Op = ValPrimOp(::PlusPoint2Vector2,2,"PlusPoint2Vector2", Point2ValueType);
    MinusPoint2Vector2Op = ValPrimOp(::MinusPoint2Vector2,2,"MinusPoint2Vector2", Point2ValueType);
    MinusPoint2Point2Op = ValPrimOp(::MinusPoint2Point2,2,"MinusPoint2Point2", Vector2ValueType);
    DistancePoint2Point2Op = ValPrimOp(::DistancePoint2Point2,2,"DistancePoint2Point2", AxANumberType);
    DistanceSquaredPoint2Point2Op = ValPrimOp(::DistanceSquaredPoint2Point2,2,"DistanceSquaredPoint2Point2", AxANumberType);
    XCoordVector2Op = ValPrimOp(::XCoordVector2,1,"XCoordVector2", AxANumberType);
    YCoordVector2Op = ValPrimOp(::YCoordVector2,1,"YCoordVector2", AxANumberType);
    ThetaCoordVector2Op = ValPrimOp(::ThetaCoordVector2,1,"ThetaCoordVector2", AxANumberType);
    RhoCoordVector2Op = ValPrimOp(::RhoCoordVector2,1,"RhoCoordVector2", AxANumberType);
    XCoordPoint2Op = ValPrimOp(::XCoordPoint2,1,"XCoordPoint2", AxANumberType);
    YCoordPoint2Op = ValPrimOp(::YCoordPoint2,1,"YCoordPoint2", AxANumberType);
    ThetaCoordPoint2Op = ValPrimOp(::ThetaCoordPoint2,1,"ThetaCoordPoint2", AxANumberType);
    RhoCoordPoint2Op = ValPrimOp(::RhoCoordPoint2,1,"RhoCoordPoint2", AxANumberType);
    g_varCRXVector3 = (CRVector3 *) ConstBvr((AxAValue) ::xVector3);
    g_varCRYVector3 = (CRVector3 *) ConstBvr((AxAValue) ::yVector3);
    g_varCRZVector3 = (CRVector3 *) ConstBvr((AxAValue) ::zVector3);
    g_varCRZeroVector3 = (CRVector3 *) ConstBvr((AxAValue) ::zeroVector3);
    g_varCROrigin3 = (CRPoint3 *) ConstBvr((AxAValue) ::origin3);
    XyzVector3Op = ValPrimOp(::XyzVector3,3,"XyzVector3", Vector3ValueType);
    XyzPoint3Op = ValPrimOp(::XyzPoint3,3,"XyzPoint3", Point3ValueType);
    SphericalVector3Op = ValPrimOp(::SphericalVector3,3,"SphericalVector3", Vector3ValueType);
    SphericalPoint3Op = ValPrimOp(::SphericalPoint3,3,"SphericalPoint3", Point3ValueType);
    LengthVector3Op = ValPrimOp(::LengthVector3,1,"LengthVector3", AxANumberType);
    LengthSquaredVector3Op = ValPrimOp(::LengthSquaredVector3,1,"LengthSquaredVector3", AxANumberType);
    NormalVector3Op = ValPrimOp(::NormalVector3,1,"NormalVector3", Vector3ValueType);
    DotVector3Vector3Op = ValPrimOp(::DotVector3Vector3,2,"DotVector3Vector3", AxANumberType);
    CrossVector3Vector3Op = ValPrimOp(::CrossVector3Vector3,2,"CrossVector3Vector3", Vector3ValueType);
    NegateVector3Op = ValPrimOp(::NegateVector3,1,"NegateVector3", Vector3ValueType);
    ScaleRealVector3Op = ValPrimOp(::ScaleRealVector3,2,"ScaleRealVector3", Vector3ValueType);
    DivideVector3RealOp = ValPrimOp(::DivideVector3Real,2,"DivideVector3Real", Vector3ValueType);
    MinusVector3Vector3Op = ValPrimOp(::MinusVector3Vector3,2,"MinusVector3Vector3", Vector3ValueType);
    PlusVector3Vector3Op = ValPrimOp(::PlusVector3Vector3,2,"PlusVector3Vector3", Vector3ValueType);
    PlusPoint3Vector3Op = ValPrimOp(::PlusPoint3Vector3,2,"PlusPoint3Vector3", Point3ValueType);
    MinusPoint3Vector3Op = ValPrimOp(::MinusPoint3Vector3,2,"MinusPoint3Vector3", Point3ValueType);
    MinusPoint3Point3Op = ValPrimOp(::MinusPoint3Point3,2,"MinusPoint3Point3", Vector3ValueType);
    DistancePoint3Point3Op = ValPrimOp(::DistancePoint3Point3,2,"DistancePoint3Point3", AxANumberType);
    DistanceSquaredPoint3Point3Op = ValPrimOp(::DistanceSquaredPoint3Point3,2,"DistanceSquaredPoint3Point3", AxANumberType);
    XCoordVector3Op = ValPrimOp(::XCoordVector3,1,"XCoordVector3", AxANumberType);
    YCoordVector3Op = ValPrimOp(::YCoordVector3,1,"YCoordVector3", AxANumberType);
    ZCoordVector3Op = ValPrimOp(::ZCoordVector3,1,"ZCoordVector3", AxANumberType);
    ThetaCoordVector3Op = ValPrimOp(::ThetaCoordVector3,1,"ThetaCoordVector3", AxANumberType);
    PhiCoordVector3Op = ValPrimOp(::PhiCoordVector3,1,"PhiCoordVector3", AxANumberType);
    RhoCoordVector3Op = ValPrimOp(::RhoCoordVector3,1,"RhoCoordVector3", AxANumberType);
    XCoordPoint3Op = ValPrimOp(::XCoordPoint3,1,"XCoordPoint3", AxANumberType);
    YCoordPoint3Op = ValPrimOp(::YCoordPoint3,1,"YCoordPoint3", AxANumberType);
    ZCoordPoint3Op = ValPrimOp(::ZCoordPoint3,1,"ZCoordPoint3", AxANumberType);
    ThetaCoordPoint3Op = ValPrimOp(::ThetaCoordPoint3,1,"ThetaCoordPoint3", AxANumberType);
    PhiCoordPoint3Op = ValPrimOp(::PhiCoordPoint3,1,"PhiCoordPoint3", AxANumberType);
    RhoCoordPoint3Op = ValPrimOp(::RhoCoordPoint3,1,"RhoCoordPoint3", AxANumberType);
    g_varCRIdentityTransform3 = (CRTransform3 *) ConstBvr((AxAValue) ::identityTransform3);
    TranslateReal3Op = ValPrimOp(::TranslateReal3,3,"TranslateReal3", Transform3Type);
    TranslateVector3Op = ValPrimOp(::TranslateVector3,1,"TranslateVector3", Transform3Type);
    TranslatePoint3Op = ValPrimOp(::TranslatePoint3,1,"TranslatePoint3", Transform3Type);
    ScaleReal3Op = ValPrimOp(::ScaleReal3,3,"ScaleReal3", Transform3Type);
    ScaleVector3Op = ValPrimOp(::ScaleVector3,1,"ScaleVector3", Transform3Type);
    Scale3UniformNumberOp = ValPrimOp(::Scale3UniformNumber,1,"Scale3UniformNumber", Transform3Type);
    RotateAxisRealOp = ValPrimOp(::RotateAxisReal,2,"RotateAxisReal", Transform3Type);
    TransformVec3Op = ValPrimOp(::TransformVec3,2,"TransformVec3", Vector3ValueType);
    TransformPoint3Op = ValPrimOp(::TransformPoint3,2,"TransformPoint3", Point3ValueType);
    XShear3NumberOp = ValPrimOp(::XShear3Number,2,"XShear3Number", Transform3Type);
    YShear3NumberOp = ValPrimOp(::YShear3Number,2,"YShear3Number", Transform3Type);
    ZShear3NumberOp = ValPrimOp(::ZShear3Number,2,"ZShear3Number", Transform3Type);
    MatrixTransform4x4Op = ValPrimOp(::MatrixTransform4x4,1,"MatrixTransform4x4", Transform3Type);
    TimesXformXformOp = ValPrimOp(::TimesXformXform,2,"TimesXformXform", Transform3Type);
    Compose3ArrayOp = ValPrimOp(::Compose3Array,1,"Compose3Array", Transform3Type);
    InverseTransform3Op = ValPrimOp(::ThrowingInverseTransform3,1,"InverseTransform3", Transform3Type);
    IsSingularTransform3Op = ValPrimOp(::IsSingularTransform3,1,"IsSingularTransform3", AxABooleanType);
    LookAtFromOp = ValPrimOp(::LookAtFrom,3,"LookAtFrom", Transform3Type);
    g_varCRIdentityTransform2 = (CRTransform2 *) ConstBvr((AxAValue) ::identityTransform2);
    TranslateRealRealOp = ValPrimOp(::TranslateRealReal,2,"TranslateRealReal", Transform2Type);
    TranslateVector2Op = ValPrimOp(::TranslateVector2Value,1,"TranslateVector2", Transform2Type);
    Translate2PointOp = ValPrimOp(::Translate2PointValue,1,"Translate2Point", Transform2Type);
    ScaleRealRealOp = ValPrimOp(::ScaleRealReal,2,"ScaleRealReal", Transform2Type);
    ScaleVector2Op = ValPrimOp(::ScaleVector2Value,1,"ScaleVector2", Transform2Type);
    Scale2Op = ValPrimOp(::Scale2,1,"Scale2", Transform2Type);
    RotateRealOp = ValPrimOp(::RotateReal,1,"RotateReal", Transform2Type);
    XShear2Op = ValPrimOp(::XShear2,1,"XShear2", Transform2Type);
    YShear2Op = ValPrimOp(::YShear2,1,"YShear2", Transform2Type);
    MatrixTransformOp = ValPrimOp(::MatrixTransform,1,"MatrixTransform", Transform2Type);
    TimesTransform2Transform2Op = ValPrimOp(::TimesTransform2Transform2,2,"TimesTransform2Transform2", Transform2Type);
    Compose2ArrayOp = ValPrimOp(::Compose2Array,1,"Compose2Array", Transform2Type);
    TransformPoint2Op = ValPrimOp(::TransformPoint2Value,2,"TransformPoint2", Point2ValueType);
    TransformVector2Op = ValPrimOp(::TransformVector2Value,2,"TransformVector2", Vector2ValueType);
    InverseTransform2Op = ValPrimOp(::ThrowingInverseTransform2,1,"InverseTransform2", Transform2Type);
    IsSingularTransform2Op = ValPrimOp(::IsSingularTransform2,1,"IsSingularTransform2", AxABooleanType);
    ParallelTransform2Op = ValPrimOp(::ParallelTransform2,1,"ParallelTransform2", Transform2Type);
    UnionMontageOp = ValPrimOp(::UnionMontage,1,"UnionMontage", MontageType);
    g_varCREmptyColor = (CRColor *) ConstBvr((AxAValue) ::emptyColor);
}
CRTypeMap CRTypeMapArray[] = {
    { CRBOOLEAN_TYPEID, & AxABooleanType } ,
    { CRCAMERA_TYPEID, & CameraType } ,
    { CRCOLOR_TYPEID, & ColorType } ,
    { CRGEOMETRY_TYPEID, & GeometryType } ,
    { CRIMAGE_TYPEID, & ImageType } ,
    { CRMATTE_TYPEID, & MatteType } ,
    { CRMICROPHONE_TYPEID, & MicrophoneType } ,
    { CRMONTAGE_TYPEID, & MontageType } ,
    { CRNUMBER_TYPEID, & AxANumberType } ,
    { CRPATH2_TYPEID, & Path2Type } ,
    { CRPOINT2_TYPEID, & Point2ValueType } ,
    { CRPOINT3_TYPEID, & Point3ValueType } ,
    { CRSOUND_TYPEID, & SoundType } ,
    { CRSTRING_TYPEID, & AxAStringType } ,
    { CRTRANSFORM2_TYPEID, & Transform2Type } ,
    { CRTRANSFORM3_TYPEID, & Transform3Type } ,
    { CRVECTOR2_TYPEID, & Vector2ValueType } ,
    { CRVECTOR3_TYPEID, & Vector3ValueType } ,
    { CRFONTSTYLE_TYPEID, & FontStyleType } ,
    { CRLINESTYLE_TYPEID, & LineStyleType } ,
    { CRENDSTYLE_TYPEID, & EndStyleType } ,
    { CRJOINSTYLE_TYPEID, & JoinStyleType } ,
    { CRDASHSTYLE_TYPEID, & DashStyleType } ,
    { CRBBOX2_TYPEID, & Bbox2ValueType } ,
    { CRBBOX3_TYPEID, & Bbox3Type } ,
    { CRPAIR_TYPEID, & AxAPairType } ,
    { CREVENT_TYPEID, & AxAEDataType } ,
    { CRARRAY_TYPEID, & AxAArrayType } ,
    { CRTUPLE_TYPEID, & TupleType } ,
    { CRUSERDATA_TYPEID, & UserDataType } ,
    { CRINVALID_TYPEID, NULL } ,
};

DXMTypeInfo
GetTypeInfoFromTypeId(CR_BVR_TYPEID tid)
{
    for (CRTypeMap * arr = CRTypeMapArray;
         arr->typeId != CRINVALID_TYPEID;
         arr++) {
        if (arr->typeId == tid) {
            Assert(arr->typeInfo);
            return *(arr->typeInfo);
        }
    }

    return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\api\crcb.cpp ===
/*******************************************************************************

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    {Insert General Comment Here}

*******************************************************************************/


#include "headers.h"
#include "crcb.h"
#include "crview.h"

// ================================================
// CRUntilNotifierCB
//
// ================================================

class CRUntilNotifierCB : public UntilNotifierImpl
{
  public:
    CRUntilNotifierCB(CRUntilNotifierPtr notifier)
    : _notifier(notifier)
    {
        _notifier->AddRef();
    }

    ~CRUntilNotifierCB()
    {
        SAFERELEASE(_notifier);
    }

    virtual Bvr Notify(Bvr eventData,
                       Bvr curRunningBvr) {
        Assert (_notifier) ;

        Bvr ret = _notifier->Notify((CRBvrPtr) eventData,
                                    (CRBvrPtr) curRunningBvr,
                                    &GetCurrentView());

        if (ret == NULL) {
            RaiseException_UserError(DAGetLastError(), IDS_ERR_BE_UNTILNOTIFY);
        }

        return ret;
    }

    virtual void DoKids(GCFuncObj) {}

  protected:
    CRUntilNotifier * _notifier ;
} ;

UntilNotifier WrapUntilNotifier(CRUntilNotifierPtr notifier)
{ return NEW CRUntilNotifierCB(notifier) ; }

// ================================================
// CRBvrHookCB
// ================================================

class CRBvrHookCB : public BvrHookImpl
{
  public:
    CRBvrHookCB(CRBvrHook * notifier)
    : _notifier(notifier)
    {
        _notifier->AddRef();
    }

    ~CRBvrHookCB()
    {
        SAFERELEASE(_notifier);
    }

    virtual Bvr Notify(int id,
                       bool start,
                       double startTime,
                       double globalTime,
                       double localTime,
                       Bvr sampleValue,
                       Bvr curRunningBvr) {
        Assert (_notifier) ;

        return _notifier->Notify(id,
                                 start,
                                 startTime,
                                 globalTime,
                                 localTime,
                                 (CRBvrPtr) sampleValue,
                                 (CRBvrPtr) curRunningBvr);
    }

    virtual void DoKids(GCFuncObj) {}

  protected:
    CRBvrHook * _notifier;
} ;

BvrHook WrapCRBvrHook(CRBvrHook * notifier)
{ return NEW CRBvrHookCB(notifier) ; }
    
// ================================================
// CRUserDataImpl
// ================================================

class CRUserDataImpl : public UserDataImpl
{
  public:
    CRUserDataImpl(LPUNKNOWN data)
    : _data(data)
    {
        _data->AddRef();
    }

    ~CRUserDataImpl()
    {
        SAFERELEASE(_data);
    }


    virtual void DoKids(GCFuncObj) {}

    LPUNKNOWN GetData() { if (_data) _data->AddRef(); return _data ; }
  protected:
    IUnknown * _data ;
} ;

UserData WrapUserData(LPUNKNOWN data)
{ return NEW CRUserDataImpl(data) ; }

LPUNKNOWN ExtractUserData(UserData data)
{ return SAFE_CAST(CRUserDataImpl *,data)->GetData() ; }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\api\crbvr.cpp ===
/*******************************************************************************

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    {Insert General Comment Here}

*******************************************************************************/


#include "headers.h"
#include "apiprims.h"
#include "crcb.h"
#include "conv.h"
#include "crimport.h"
#include "backend/values.h"
#include "backend/gc.h"
#include "backend/jaxaimpl.h"
#include "backend/timeln.h"
#include "backend/preference.h"

DeclareTag(tagCRBvr, "API", "CRBvr functions");

CRSTDAPI_(CR_BVR_TYPEID)
CRGetTypeId(CRBvrPtr bvr)
{
    Assert (bvr);

    TraceTag((tagCRBvr,
              "(%lx)CRGetTypeId()",
              bvr));
    
    CR_BVR_TYPEID ret = CRINVALID_TYPEID;
    
    APIPRECODE;
    ret = GetCRTypeId(bvr->GetTypeInfo());
    APIPOSTCODE;

    return ret;
}

CRSTDAPI_(CR_BVR_TYPEID)
CRGetArrayTypeId(CRBvrPtr bvr)
{
    Assert (bvr);

    TraceTag((tagCRBvr,
              "(%lx)CRGetArrayTypeId()",
              bvr));
    
    CR_BVR_TYPEID ret = CRINVALID_TYPEID;
    
    APIPRECODE;
    DXMTypeInfo ti;
    ti = bvr->GetTypeInfo();

    if (GetCRTypeId(ti) != CRARRAY_TYPEID) {
        DASetLastError(E_INVALIDARG, NULL);
    } else {
        ret = GetCRTypeId(GetArrayTypeInfo(ti));
    }
    APIPOSTCODE;

    return ret;
}

CRSTDAPI_(bool)
CRInit(CRBvrPtr bvr, CRBvrPtr toBvr)
{
    Assert (bvr);

    bool ret = false;
    
    APIPRECODE;
    ::SetInitBvr(bvr, toBvr);
    ret = true;
    APIPOSTCODE;

    return ret;
}

CRSTDAPI_(CRBvrPtr)
CRImportance(CRBvrPtr bvr, double relativeImportance)
{
    Assert (bvr);
    
    CRBvrPtr ret = NULL;
    
    APIPRECODE;
    ret = (CRBvrPtr) ImportanceBvr(relativeImportance, bvr) ;
    APIPOSTCODE;

    return ret;
}
    
CRSTDAPI_(CRBvrPtr)
CRRunOnce(CRBvrPtr bvr)
{
    Assert (bvr);
    
    CRBvrPtr ret = NULL;
    
    APIPRECODE;
    ret = (CRBvrPtr) AnchorBvr(bvr);
    APIPOSTCODE;

    return ret;
}
    
CRSTDAPI_(CRBvrPtr)
CRSubstituteTime(CRBvrPtr bvr, CRNumberPtr xform)
{
    Assert (bvr);
    
    CRBvrPtr ret = NULL;
    
    APIPRECODE;
    ret = (CRBvrPtr) TimeXformBvr(bvr, xform);
    APIPOSTCODE;

    return ret;
}
    
CRSTDAPI_(CRBvrPtr)
CRHook(CRBvrPtr bvr, CRBvrHookPtr notifier)
{
    Assert (bvr);
    
    CRBvrPtr ret = NULL;
    
    APIPRECODE;
    ret = (CRBvrPtr) ::BvrCallback(bvr, WrapCRBvrHook(notifier));
    APIPOSTCODE;

    return ret;
}
    
CRSTDAPI_(CRBvrPtr)
CRDuration(CRBvrPtr bvr, double duration)
{
    Assert (bvr);
    
    CRBvrPtr ret = NULL;
    
    APIPRECODE;
    ret = (CRBvrPtr) ::DurationBvr(bvr, ::DoubleToNumBvr(duration));
    APIPOSTCODE;

    return ret;
}
    
CRSTDAPI_(CRBvrPtr)
CRDuration(CRBvrPtr bvr, CRNumberPtr duration)
{
    Assert (bvr);
    
    CRBvrPtr ret = NULL;
    
    APIPRECODE;
    ret = (CRBvrPtr) ::DurationBvr(bvr, duration);
    APIPOSTCODE;

    return ret;
}
    
CRSTDAPI_(CRBvrPtr)
CRRepeat(CRBvrPtr bvr, long count)
{
    Assert (bvr);
    
    if (count<=0)
        return NULL;

    CRBvrPtr ret = NULL;
    
    APIPRECODE;
    ret = (CRBvrPtr) ::Repeat(bvr, count);
    APIPOSTCODE;

    return ret;
}
    
CRSTDAPI_(CRBvrPtr)
CRRepeatForever(CRBvrPtr bvr)
{
    Assert (bvr);
    
    CRBvrPtr ret = NULL;
    
    APIPRECODE;
    ret = (CRBvrPtr) ::RepeatForever(bvr);
    APIPOSTCODE;

    return ret;
}

CRSTDAPI_(CRBvrPtr)
CRBvrApplyPreference(CRBvrPtr bvr, BSTR pref, VARIANT val)
{
    Assert(bvr);

    CRBvrPtr ret = NULL;
    
    APIPRECODE;
    ret = (CRBvrPtr) ::PreferenceBvr(bvr, pref, val);
    APIPOSTCODE;

    return ret;
}

    
CRSTDAPI_(bool)
CRIsReady(CRBvrPtr bvr, bool bBlock)
{
    Assert (bvr);
    
    bool ret = false;
    
    APIPRECODE;
    ret = true;
    APIPOSTCODE;

    return ret;
}
    
CRSTDAPI_(CRBvrPtr)
CREndEvent(CRBvrPtr bvr)
{
    Assert (bvr);
    
    CRBvrPtr ret = NULL;
    
    APIPRECODE;
    ret = (CRBvrPtr) bvr->EndEvent(NULL);
    APIPOSTCODE;

    return ret;
}
    

CRSTDAPI_(bool)
CRIsImport(CRBvrPtr bvr)
{
    Assert (bvr);
    
    bool ret = false;
    
    APIPRECODE;
    ret = ::IsImport(bvr);
    APIPOSTCODE;

    return ret;
}
    
CRSTDAPI
CRImportStatus(CRBvrPtr bvr)
{
    Assert (bvr);
    
    HRESULT ret = E_FAIL;
    
    APIPRECODE;
    ret = ::ImportStatus(bvr);
    APIPOSTCODE;

    return ret;
}
    
CRSTDAPI_(bool)
CRImportCancel(CRBvrPtr bvr)
{
    Assert (bvr);
    
    bool ret = false;
    
    APIPRECODE;
    IImportSite * pIS = GetImportSite(bvr);

    if (pIS) {
        pIS->CancelImport();
        pIS->Release();
        ret = true;
    }

    APIPOSTCODE;

    return ret;
}
    
CRSTDAPI_(bool)
CRSetImportPriority(CRBvrPtr bvr, float prio)
{
    Assert (bvr);
    
    bool ret = false;
    
    APIPRECODE;
    IImportSite * pIS = GetImportSite(bvr);
    if (pIS) {
        pIS->SetImportPrio(prio);
        pIS->Release();
        ret = true;
    }
    APIPOSTCODE;

    return ret;
}
    
CRSTDAPI_(float)
CRGetImportPriority(CRBvrPtr bvr)
{
    Assert (bvr);
    
    float ret = -1;
    
    APIPRECODE;
    IImportSite * pIS = GetImportSite(bvr);
    if (pIS) {
        ret = pIS->GetImportPrio();
        pIS->Release();
    }
    APIPOSTCODE;

    return ret;
}
    

extern AxAValue ExtendedAttrib(AxAValue val,
                               StringValue *attrib,
                               VariantValue *var);

AxAPrimOp *extendedAttributeOp = NULL;

CRSTDAPI_(CRBvrPtr)
CRExtendedAttrib(CRBvr  *arg0,
                 LPWSTR  arg1,
                 VARIANT arg2)
{
    TraceTag((tagAPIEntry, "CRExtendedAttrib"));

    CRBvr * ret = NULL;

    APIPRECODE ;
    ret = (CRBvr *) (PrimApplyBvr(extendedAttributeOp,
                                  3,
                                  (arg0),
                                  LPWSTRToStrBvr(arg1),
                                  VARIANTToVariantBvr(arg2)));
    
    APIPOSTCODE ;
    return ret;
    
}

void
InitializeModule_APIBvr()
{
    // This is a special polymorphic AxAPrimOp that gets its type
    // information from its first argument (that's the '1'
    // parameter on the end.)
    extendedAttributeOp = ValPrimOp(::ExtendedAttrib,3,"ExtendedAttrib", NULL, 1);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\api\crcb.h ===
/*******************************************************************************

Copyright (c) 1995_96 Microsoft Corporation

Abstract:

    {Insert General Comment Here}

*******************************************************************************/


#ifndef _CRCB_H
#define _CRCB_H

#include "backend/jaxaimpl.h"

UntilNotifier WrapCRUntilNotifier(CRUntilNotifierPtr notifier);
BvrHook WrapCRBvrHook(CRBvrHookPtr hook);

UserData WrapUserData(LPUNKNOWN data);
LPUNKNOWN ExtractUserData(UserData data);

#endif /* _CRCB_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\api\crbasic.cpp ===
/*******************************************************************************

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    {Insert General Comment Here}

*******************************************************************************/

#include "headers.h"
#include "apiprims.h"
#include "ctx.h"
#include "server\import.h"

typedef list<HINSTANCE> ModuleList;
ModuleList * g_moduleList = NULL;
CritSect * g_moduleLock = NULL;

// ------------------------------------------------

#if DEVELOPER_DEBUG
extern "C"
CRSTDAPI_(DWORD)
GetTotalMemory()
{
    DWORD size = 0;

    size += DynamicHeapBytesUsed();

#if _DEBUGMEM
    // Ask the CRT for memory usage
    size += CRTMemoryUsed();
#endif
    
    return size;
}

#endif


#if _DEBUG
bool g_bFirstTime = true;

size_t g_MemoryLeaks;
size_t g_MemoryLeaksTotal;
size_t g_GCMemoryLeaks;
size_t g_GCMemoryLeaksTotal;
size_t g_SysMemoryLeaks;
size_t g_SysMemoryLeaksTotal;
size_t g_CRTMemoryLeaks;
size_t g_CRTMemoryLeaksTotal;

#if _DEBUGMEM
_CrtMemState g_MemState;
_CrtMemState g_MemStateOrig;
#endif

void
CheckPointMemory()
{
    g_MemoryLeaks = GetTotalMemory();
    g_GCMemoryLeaks = GetGCHeap().BytesUsed();
    g_SysMemoryLeaks = GetSystemHeap().BytesUsed();
    g_CRTMemoryLeaks = 0;
#if _DEBUGMEM
    g_CRTMemoryLeaks = CRTMemoryUsed();
    _CrtMemCheckpoint(&g_MemState);
#endif
    
    // If this is the first time (since we are 0) initialize
    // to some baseline
    
    if (g_bFirstTime) {
        g_MemoryLeaksTotal = g_MemoryLeaks;
        g_GCMemoryLeaksTotal = g_GCMemoryLeaks;
        g_SysMemoryLeaksTotal = g_SysMemoryLeaks;
        g_CRTMemoryLeaksTotal = g_CRTMemoryLeaks;
#if _DEBUGMEM
        _CrtMemCheckpoint(&g_MemStateOrig);
#endif
        g_bFirstTime = false;
    }
}

void
DumpMemLeaks()
{
    size_t totalmem = GetTotalMemory();
    size_t memdiff = totalmem - g_MemoryLeaks;
    size_t totalmemdiff = totalmem - g_MemoryLeaksTotal;
    
    size_t gctotalmem = GetGCHeap().BytesUsed();
    size_t gcmemdiff = gctotalmem - g_GCMemoryLeaks;
    size_t gctotalmemdiff = gctotalmem - g_GCMemoryLeaksTotal;
    
    size_t systotalmem = GetSystemHeap().BytesUsed();
    size_t sysmemdiff = systotalmem - g_SysMemoryLeaks;
    size_t systotalmemdiff = systotalmem - g_SysMemoryLeaksTotal;
    
#if _DEBUGMEM
    size_t crttotalmem = CRTMemoryUsed();
#else
    size_t crttotalmem = 0;
#endif
    size_t crtmemdiff = crttotalmem - g_CRTMemoryLeaks;
    size_t crttotalmemdiff = crttotalmem - g_CRTMemoryLeaksTotal;
    
    TraceTag((tagError,
              "CRDisconnect: Checkpoint(bytes): (gc - %d, sys - %d, crt - %d, total - %d) ",
              gcmemdiff, sysmemdiff, crtmemdiff, memdiff));
    TraceTag((tagError,
              "CRDisconnect: Total(bytes): (gc - %d, sys - %d, crt - %d, total - %d) ",
              gctotalmemdiff, systotalmemdiff, crttotalmemdiff, totalmemdiff));
    
    if (false && IsTagEnabled(tagLeaks)) {
#if _DEBUGMEM
        _CrtMemState newState;
        _CrtMemState diff;
        
        _CrtMemCheckpoint(&newState);
        _CrtMemDifference(&diff, &g_MemState, &newState);
        _CrtMemDumpStatistics(&diff);
        _CrtMemDumpAllObjectsSince(&diff);
#endif
    }
}

#endif

#if DEVELOPER_DEBUG
DWORD
CRConnectCount()
{
    CritSectGrabber _csg(*g_moduleLock);
    return g_moduleList->size();
}
#endif

// Initialization functions

CRSTDAPI_(bool)
CRConnect(HINSTANCE hinst)
{
    bool ret = false;
    
    // This must be outside the try block in APIPRECODE otherwise on
    // exception it will not get cleaned up
    
    CritSectGrabber _csg(*g_moduleLock);
        
    APIPRECODE;

    if (!CRIsConnected(hinst)) {
        if (g_moduleList->size() == 0) {
#if _DEBUG
            CheckPointMemory();
#endif
            StartCollector();
        }
        
        g_moduleList->push_back(hinst);
    }
    
    ret = true;
    
    APIPOSTCODE;

    return ret;
}

CRSTDAPI_(bool)
CRDisconnect(HINSTANCE hinst)
{
    bool ret = false;
    
    // This must be outside the try block in APIPRECODE otherwise on
    // exception it will not get cleaned up
    
    CritSectGrabber _csg(*g_moduleLock);
        
    APIPRECODE;

    g_moduleList->remove(hinst);
    
    if (g_moduleList->size() == 0) {
        StopCollector();
        StopImportThread();
        FreeSoundBufferCache();
        
#if DEVELOPER_DEBUG
        DumpGCRoots(GetCurrentGCRoots());
#endif
    
        // No need to GC since we know all the roots are freed and we
        // can just delete everything in the GC list
        
        CleanUpGCList(GetCurrentGCList(), GetCurrentGCRoots());

#if _DEBUG
        DumpMemLeaks();
#endif
    }
    
    ret = true;

    APIPOSTCODE;

    return ret;
}

CRSTDAPI_(bool)
CRIsConnected(HINSTANCE hinst)
{
    bool ret = false;
    
    // This must be outside the try block in APIPRECODE otherwise on
    // exception it will not get cleaned up
    
    CritSectGrabber _csg(*g_moduleLock);
        
    APIPRECODE;

    for (ModuleList::iterator i = g_moduleList->begin();
         i != g_moduleList->end();
         i++)
    {
        if ((*i) == hinst) {
            ret = true;
            break;
        }
    }

    APIPOSTCODE;

    return ret;
}

// GC Functions

CRSTDAPI_(bool)
CRAcquireGCLock()
{
    bool ret = false;
    
    APIPRECODE;

    AcquireGCLock(GCL_CREATE);

    ret = true;

    APIPOSTCODE;

    return ret;
}

CRSTDAPI_(bool)
CRReleaseGCLock()
{
    bool ret = false;
    
    APIPRECODE;

    ReleaseGCLock(GCL_CREATE);
    
    ret = true;

    APIPOSTCODE;

    return ret;
}

// TODO: May want to indicate error but currently we do not have any
// error code to report
CRSTDAPI_(bool)
CRDoGC()
{
    bool ret = false;
    
    APIPRECODE;

    GarbageCollect(true);

    ret = true;

    APIPOSTCODE;

    return ret;
}

CRSTDAPI_(bool)
CRAddRefGC(void *gc)
{
    bool ret = false;
    
    APIPRECODE;

    if (gc)
        GCAddToRoots((GCBase *)gc, GetCurrentGCRoots());

    ret = true;

    APIPOSTCODE;

    return ret;
}

CRSTDAPI_(bool)
CRReleaseGC(void *gc)
{
    bool ret = false;
    
    APIPRECODE;

    if (gc)
        GCRemoveFromRoots((GCBase *)gc, GetCurrentGCRoots());

    ret = true;

    APIPOSTCODE;

    return ret;
}


// Error functions will not throw exceptions

CRSTDAPI_(HRESULT)
CRGetLastError()
{
    return DAGetLastError();
}

CRSTDAPI_(LPCWSTR)
CRGetLastErrorString()
{
    return DAGetLastErrorString();
}

CRSTDAPI_(void)
CRClearLastError()
{
    DAClearLastError();
}

CRSTDAPI_(void)
CRSetLastError(HRESULT reason, LPCWSTR msg)
{
    DASetLastError(reason, msg);
}

// Misc Functions

CRSTDAPI_(bool)
CRAddSite(CRSitePtr s)
{
    bool ret = false;
    
    APIPRECODE;

    GetCurrentContext().AddSite(s);

    ret = true;

    APIPOSTCODE;

    return ret;
}

CRSTDAPI_(bool)
CRRemoveSite(CRSitePtr s)
{
    bool ret = false;
    
    APIPRECODE;

    GetCurrentContext().RemoveSite(s);

    ret = true;

    APIPOSTCODE;

    return ret;
}


// ------------------------------------------------

void
InitializeModule_APIBasic()
{
    g_moduleList = THROWING_ALLOCATOR(ModuleList);
    g_moduleLock = THROWING_ALLOCATOR(CritSect);
}

void
DeinitializeModule_APIBasic(bool bShutdown)
{
    if (g_moduleList && g_moduleList->size() != 0)
    {
        TraceTag((tagError,
                  "Error: Possible memory leak.  A module did not disconnect from DA"));
    }
    
    delete g_moduleList;
    g_moduleList = NULL;

    delete g_moduleLock;
    g_moduleLock = NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\api\crdxxf.cpp ===
/*******************************************************************************

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    {Insert General Comment Here}

*******************************************************************************/


#include "headers.h"
#include "apiprims.h"
#include "backend/values.h"
#include "backend/gc.h"
#include "privinc/dxxf.h"
#include <DXTrans.h>

DeclareTag(tagDXTransform, "API", "DXTransforms");

class CRDXTransformResult : public GCObj
{
  public:
    CRDXTransformResult(IUnknown * xf, CRBvrPtr xfbvr)
    : _xf(xf), _xfbvr(xfbvr) {}

    ~CRDXTransformResult() {
        CleanUp();
    }

    void CleanUp() {
        _xf.Release();
    }

    virtual void DoKids(GCFuncObj proc) {
        if (_xfbvr) (*proc)(_xfbvr);
    }

    CRBvrPtr GetOutputBvr() { return _xfbvr; }
    IUnknown * GetTransform() { return _xf; }
  protected:
    CRBvrPtr _xfbvr;
    DAComPtr<IUnknown> _xf;
};

CRDXTransformResult *
CreateAppliedTransform(IUnknown *theXfAsUnknown,
                       LONG      numInputs,
                       Bvr *inputs,
                       CRBvrPtr  evaluator)
{
    CRDXTransformResult *retPtr = NULL;
    IDXTransform *theXf = NULL;
    IDispatch    *theXfdisp = NULL;

    HRESULT hr;

    hr = theXfAsUnknown->QueryInterface(IID_IDXTransform,
                                        (void **)&theXf);

    __try {

        if (FAILED(hr))
            RaiseException_UserError(E_INVALIDARG, 0);
        
        // We don't care if this fails
        theXf->QueryInterface(IID_IDispatch,
                              (void **)&theXfdisp);
        
        Bvr transformApplierBvr = 
            ConstructDXTransformApplier(theXf,
                                        theXfdisp,
                                        numInputs,
                                        inputs,
                                        evaluator);
        
        retPtr = NEW CRDXTransformResult(theXfAsUnknown,
                                         (CRBvrPtr) transformApplierBvr);

        if(!retPtr)
            RaiseException_OutOfMemory("new CRDXTransformResult", sizeof(CRDXTransformResult));
        
    } __finally {

        // cleanup
        RELEASE(theXf);
        RELEASE(theXfdisp);

    }
    
    return retPtr;
}

CRSTDAPI_(CRBvrPtr)
CRGetOutputBvr(CRDXTransformResultPtr tr)
{
    return tr->GetOutputBvr();
}

CRSTDAPI_(IUnknown *)
CRGetTransform(CRDXTransformResultPtr tr)
{
    IUnknown * unk = tr->GetTransform();
    if (unk) unk->AddRef();
    return unk;
}

CRSTDAPI_(bool)
CRSetBvrAsProperty(CRDXTransformResultPtr tr,
                   LPCWSTR property,
                   CRBvrPtr bvr)
{
    bool ret = false;

    CComBSTR bstr(property);

    APIPRECODE;

    HRESULT hr;
    
    hr = DXXFAddBehaviorPropertyToDXTransformApplier(bstr,
                                                     bvr,
                                                     tr->GetOutputBvr());

    if (FAILED(hr))
        RaiseException_UserError(hr, 0);
    
    ret = true;
    
    APIPOSTCODE;
    
    return ret;
}

CRSTDAPI_(CRDXTransformResultPtr)
CRApplyDXTransform(IUnknown *theXf,
                   long numInputs,
                   CRBvrPtr *inputs,
                   CRBvrPtr evaluator)
{
    CRDXTransformResultPtr ret = NULL;
    APIPRECODE;
    // TODO: we need to make sure cleanup the array
    // We should make the class allocate and free the memory
    
    Bvr *bvrArray = (Bvr *) StoreAllocate(GetSystemHeap(),
                                          numInputs * sizeof(Bvr));

    memcpy(bvrArray, inputs, numInputs * sizeof(Bvr));

    ret =  CreateAppliedTransform(theXf, numInputs, bvrArray,
                                  evaluator);

    
    APIPOSTCODE;
    return ret;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\api\crevent.cpp ===
/*******************************************************************************

Copyright (c) 1995-96 Microsoft Corporation

Abstract:

    {Insert General Comment Here}

*******************************************************************************/

#include "headers.h"
#include "ctx.h"
#include "crview.h"
#include "guids.h"
#include "privinc/resource.h"
#include "axadefs.h"
#include "apiprims.h"

DeclareTag(tagCRViewEvent, "CRView", "Event functions");

//+-------------------------------------------------------------------------
//
//  Method:     CROnMouseMove
//
//  Synopsis:
//
//--------------------------------------------------------------------------

CRSTDAPI_(bool)
CROnMouseMove(CRViewPtr v,
              double when, 
              long x, long y,
              byte modifiers)
{
    APIVIEWPRECODE_NOLOCK(v) ;

    TraceTag((tagCRViewEvent,
              "CROnMouseMove(%lx,%lg, %ld, %ld, %hd)%s",
              v, when, x, y, modifiers,
              v->IsStarted()?"":" - ignoring - not started"));

    if (v->IsStarted()) {
        v->GetEventQ().Add(AXAWindEvent(AXAE_MOUSE_MOVE,
                                        when,
                                        x,y,
                                        modifiers,
                                        0,
                                        FALSE));
    }

    APIVIEWPOSTCODE_NOLOCK(v) ;
    
    return true;
}

//+-------------------------------------------------------------------------
//
//  Method:     CROnMouseLeave
//
//  Synopsis:
//
//--------------------------------------------------------------------------

CRSTDAPI_(bool)
CROnMouseLeave(CRViewPtr v,
               double when)
{
    APIVIEWPRECODE_NOLOCK(v) ;

    TraceTag((tagCRViewEvent,
              "CROnMouseLeave(%lx,%lg)%s",
              v, when,
              v->IsStarted()?"":" - ignoring - not started"));

    if (v->IsStarted()) {
        v->GetEventQ().MouseLeave(when);
    }

    APIVIEWPOSTCODE_NOLOCK(v) ;
    
    return true;
}

//+-------------------------------------------------------------------------
//
//  Method:     CROnMouseButton
//
//  Synopsis:
//
//--------------------------------------------------------------------------

CRSTDAPI_(bool)
CROnMouseButton(CRViewPtr v,
                double when, 
                long x, long y,
                byte button,
                bool bPressed,
                byte modifiers)
{
    APIVIEWPRECODE_NOLOCK(v) ;

    TraceTag((tagCRViewEvent,
              "CROnMouseButton(%lx,%lg, %ld, %ld, %hd, %s, %hd)%s",
              v, when, x, y,
              button, (bPressed?"Down":"Up"),
              modifiers,
              v->IsStarted()?"":" - ignoring - not started"));

#if _DEBUG
    if (IsTagEnabled(tagPick2Hit)) {
        DynamicHeapPusher h(GetGCHeap());

        GC_CREATE_BEGIN;

        Point2Value *pt = PixelPos2wcPos(x, y);
        
        TraceTag((tagPick2Hit,
                  "CRView(%lx)::OnMouseButton(%ld, %ld) mapped to (%f, %f)",
                  v, x, y, pt->x, pt->y));

        GC_CREATE_END;
    }
#endif _DEBUG
              
    if (v->IsStarted()) {
        v->GetEventQ().Add(AXAWindEvent(AXAE_MOUSE_BUTTON,
                                        when,
                                        x,y,
                                        modifiers,
                                        button,
                                        bPressed?AXA_STATE_DOWN:AXA_STATE_UP));
    }

#if _DEBUG
    if (button == AXA_MOUSE_BUTTON_RIGHT &&
        bPressed &&
        modifiers == AXAEMOD_SHIFT_MASK) {
        DoTracePointsDialog(FALSE);
    }
#endif

    APIVIEWPOSTCODE_NOLOCK(v) ;

    return true;
}

//+-------------------------------------------------------------------------
//
//  Method:     CROnKey
//
//  Synopsis:
//
//--------------------------------------------------------------------------

CRSTDAPI_(bool)
CROnKey(CRViewPtr v,
        double when, 
        long key,
        bool bPressed,
        byte modifiers)
{
    APIVIEWPRECODE_NOLOCK(v) ;

    TraceTag((tagCRViewEvent,
              "CROnKey(%lx,%lg, %lx, %s, %hd)%s",
              v, when, key,
              (bPressed?"Down":"Up"), modifiers,
              v->IsStarted()?"":" - ignoring - not started"));
    
    if (v->IsStarted()) {
        v->GetEventQ().Add(AXAWindEvent(AXAE_KEY,
                                        when,
                                        0,0,
                                        modifiers,
                                        key,
                                        bPressed?AXA_STATE_DOWN:AXA_STATE_UP));
    }
    
#if _DEBUG
    if (key == AXAKEY_F1 &&
        bPressed) {
        DebugCode
        (   DoTracePointsDialog(FALSE);
        )
    }
#endif

#if PERFORMANCE_REPORTING    
    if (key == AXAKEY_F2 &&
        bPressed) {

        BOOL res = SetProcessWorkingSetSize(GetCurrentProcess(),
                                            (DWORD)0xffffffff,
                                            (DWORD)0xffffffff);

        if (res) {
            PerfPrintLine("*** SetProcessWorkingSetSize succeeded");
        } else{
            PerfPrintLine("*** SetProcessWorkingSetSize failed");
        }
    }
#endif

    APIVIEWPOSTCODE_NOLOCK(v) ;

    return true;
}

//+-------------------------------------------------------------------------
//
//  Method:     CROnFocus
//
//  Synopsis:
//
//--------------------------------------------------------------------------

CRSTDAPI_(bool)
CROnFocus(CRViewPtr v,
          bool bHasFocus)
{
    APIVIEWPRECODE_NOLOCK(v) ;

    TraceTag((tagCRViewEvent,
              "CROnFocus(%lx,%s)%s",
              v,
              (bHasFocus?"TRUE":"FALSE"),
              v->IsStarted()?"":" - ignoring - not started"));
    
    if (v->IsStarted()) {
        v->GetEventQ().Add(AXAWindEvent(AXAE_FOCUS,
                                        0,
                                        0,0,
                                        0,
                                        0,
                                        bHasFocus));
    }

    APIVIEWPOSTCODE_NOLOCK(v) ;

    return true ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\api\crimport.h ===
/*******************************************************************************

Copyright (c) 1995_96 Microsoft Corporation

Abstract:

    {Insert General Comment Here}

*******************************************************************************/


#ifndef _CRIMPORT_H
#define _CRIMPORT_H

#include "server/import.h"

#endif /* _CRIMPORT_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\danim\src\appel\api\crimport.cpp ===
/*******************************************************************************
Copyright (c) 1995-96 Microsoft Corporation
*******************************************************************************/


#include "headers.h"
#include "ctx.h"
#include "apiprims.h"
#include "crimport.h"
#include "privinc/urlbuf.h"
#include "backend/jaxaimpl.h"
#include "privinc/soundi.h"
#include "privinc/rmvisgeo.h"
#include "privinc/importgeo.h"

class CRImportationResult : public GCObj
{
  public:
    CRImportationResult(CRImagePtr    img,
                        CRSoundPtr    snd,
                        CRGeometryPtr geo,
                        CRNumberPtr   duration,
                        CREventPtr    ev,
                        CRNumberPtr   progress,
                        CRNumberPtr   size)
    : _img(img),
      _snd(snd),
      _geo(geo),
      _duration(duration),
      _ev(ev),
      _progress(progress),
      _size(size)
        {}

    virtual void DoKids(GCFuncObj proc) {
        if (_img) (*proc)(_img);
        if (_snd) (*proc)(_snd);
        if (_geo) (*proc)(_geo);
        if (_duration) (*proc)(_duration);
        if (_ev) (*proc)(_ev);
        if (_progress) (*proc)(_progress);
        if (_size) (*proc)(_size);
    }

    CRImagePtr GetImage() { return _img; }
    CRSoundPtr GetSound() { return _snd; }
    CRGeometryPtr GetGeometry() { return _geo; }
    CRNumberPtr GetDuration() { return _duration; }
    CREventPtr GetEvent() { return _ev; }
    CRNumberPtr GetProgress() { return _progress; }
    CRNumberPtr GetSize() { return _size; }
  protected:
    CRImagePtr _img;
    CRSoundPtr _snd;
    CRGeometryPtr _geo;
    CRNumberPtr _duration;
    CREventPtr _ev;
    CRNumberPtr _progress;
    CRNumberPtr _size;
};

CRSTDAPI_(CRImportationResultPtr)
CRImportMedia(LPWSTR baseUrl,
              void * mediaSource,
              CR_MEDIA_SOURCE srcType,
              void * params[],
              DWORD flags,
              CRImportSitePtr s)
{
    CRImportationResultPtr ret = NULL;
    APIPRECODE;
    ret =  NEW CRImportationResult(NULL,
                                   NULL,
                                   NULL,
                                   NULL,
                                   NULL,
                                   NULL,
                                   NULL);
    APIPOSTCODE;
    return ret;
}

CRSTDAPI_(CRImagePtr)
CRGetImage(CRImportationResultPtr ir)
{
    return ir->GetImage();
}

CRSTDAPI_(CRSoundPtr)
CRGetSound(CRImportationResultPtr ir)
{
    return ir->GetSound();
}

CRSTDAPI_(CRGeometryPtr)
CRGetGeometry(CRImportationResultPtr ir)
{
    return ir->GetGeometry();
}

CRSTDAPI_(CRNumberPtr)
CRGetDuration(CRImportationResultPtr ir)
{
    return ir->GetDuration();
}

CRSTDAPI_(CREventPtr)
CRGetCompletionEvent(CRImportationResultPtr ir)
{
    return ir->GetEvent();
}

CRSTDAPI_(CRNumberPtr)
CRGetProgress(CRImportationResultPtr ir)
{
    return ir->GetProgress();
}

CRSTDAPI_(CRNumberPtr)
CRGetSize(CRImportationResultPtr ir)
{
    return ir->GetSize();
}

// Temporary APIs for imports

inline void
WideToAnsi(LPCWSTR wide, char *ansi) {
    if (wide) {
        WideCharToMultiByte(CP_ACP, 0,
                            wide, -1,
                            ansi,
                            INTERNET_MAX_URL_LENGTH - 1,
                            NULL, NULL);
        ansi[INTERNET_MAX_URL_LENGTH-1] = '\0';
    } else {
        ansi[0] = '\0';
    }
}

class URLCombineAndCanonicalizeOLESTR
{
  public:
    URLCombineAndCanonicalizeOLESTR(LPCWSTR wszbase, LPCWSTR path)
    {
        USES_CONVERSION;
        LPSTR szbase = wszbase?W2A(wszbase):NULL;

        WideToAnsi(path, _url);

        // HACK:  convert java errant file:/\\ to file://\\; future
        // javaVM will correct this
        if(StrCmpNIA(_url,"file:/\\\\",8)==0) {
            int ln = lstrlen(_url);
            memmove(&_url[8],&_url[7],(ln-6)*sizeof(char));
            _url[6]='/';
        }

        // Need to combine (takes care of canonicalization
        // internally)
        URLRelToAbsConverter absolutified(szbase, _url);
        char *resultURL = absolutified.GetAbsoluteURL();

        TraceTag((tagImport, "Combined URL from %s and %s, got %s",
                  (szbase ? szbase : "NULL"), _url, resultURL));

        lstrcpy(_url, resultURL);
    }

    LPSTR GetURL () { return _url; }

  protected:
    char _url[INTERNET_MAX_URL_LENGTH + 1] ;
} ;

void
GetExtension(char *filename, char *extension, int size) {

    char *ext = StrRChrA (filename,NULL, '.');  // get substring starting with '.'

    if(ext) {    // we found an extension
        ext++;   // strip off the '.'

        // Special case .wrl.gz, since it has an embedded period in extension
        if (lstrcmpi(ext, "gz") == 0 &&
            lstrlen(filename) > 7 &&
            StrCmpNIA(ext - 5, ".wrl", 4) == 0) {
            ext = ext - 4;  // Point extension pointer to wrl.gz, and continue
        }

        lstrcpyn(extension, ext,size); // return extension
    }
    else { // we didn't find an extension
        *extension = NULL;  // return null extension
    }
}


void
SubmitImport(IImportSite* pIIS,
             CREvent **ppEvent,
             CRNumber **ppProgress,
             CRNumber **ppsize)
{
    Assert (pIIS) ;

    if (ppEvent) {
        Bvr event = ImportEvent();
        *ppEvent = (CREventPtr) event;
        pIIS->SetEvent(event);
    }

    if (ppProgress) {
        Bvr bvrNum = ::NumToBvr(0);
        Bvr progress = ::ImportSwitcherBvr(bvrNum,true);
        *ppProgress = (CRNumberPtr) progress;
        pIIS->SetProgress(progress);
    }

    if (ppsize) {
        Bvr bvrNum = ::NumToBvr(-1);
        Bvr size = ::ImportSwitcherBvr(bvrNum,TRUE);
        *ppsize = (CRNumberPtr) size;
        pIIS->SetSize(size);
    }

    pIIS->StartDownloading();
}

CRSTDAPI_(DWORD)
CRImportImage(LPCWSTR baseUrl,
              LPCWSTR relUrl,
              CRImportSitePtr s,
              IBindHost * bh,
              bool useColorKey,
              BYTE ckRed,
              BYTE ckGreen,
              BYTE ckBlue,
              CRImage   *pImageStandIn,
              CRImage  **ppImage,
              CREvent  **ppEvent,
              CRNumber **ppProgress,
              CRNumber **size)
{
    Assert (relUrl);

    // Needs to be outside the try block - must not throw exception

    URLCombineAndCanonicalizeOLESTR canonURL(baseUrl,
                                             relUrl);

    DWORD ret = 0;

    APIPRECODE;

    Bvr constbvr = ImportSwitcherBvr(pImageStandIn?pImageStandIn:ConstBvr(emptyImage),
                                     pImageStandIn?true:false);
    if (ppImage)
        *ppImage = (CRImagePtr) constbvr;

    //Create Import Site
    //Note: site will be destroyed in destructor of bindstatuscallback
    IImportSite* pIIS = NEW ImportImageSite(canonURL.GetURL(),
                                            s,
                                            bh,
                                            pImageStandIn?true:false,
                                            constbvr,
                                            useColorKey, ckRed, ckGreen, ckBlue);

    __try {

        //import URL
        SubmitImport(pIIS,
                     ppEvent,
                     ppProgress,
                     size);

        ret = pIIS->GetImportId();

    } __finally {

        RELEASE(pIIS);
    }

    APIPOSTCODE;

    return ret;
}


CRSTDAPI_(DWORD)
CRImportMovie(LPCWSTR baseUrl,
              LPCWSTR relUrl,
              CRImportSitePtr s,
              IBindHost * bh,
              bool        stream,
              CRImage   *pImageStandIn,
              CRSound   *pSoundStandIn,
              CRImage  **ppImage,
              CRSound  **ppSound,
              CRNumber **length,
              CREvent  **ppEvent,
              CRNumber **ppProgress,
              CRNumber **size)
{
    Assert (relUrl);

    // Needs to be outside the try block - must not throw exception

    URLCombineAndCanonicalizeOLESTR canonURL(baseUrl,
                                             relUrl);

    DWORD ret = 0;

    APIPRECODE;

    Bvr constBvrImage = NULL, bvrSwSnd = NULL;

    constBvrImage = ImportSwitcherBvr(pImageStandIn?pImageStandIn:ConstBvr(emptyImage),
                                      pImageStandIn?true:false);

    if (ppImage)
        *ppImage = (CRImagePtr) constBvrImage;

    bvrSwSnd = ImportSwitcherBvr(pSoundStandIn?pSoundStandIn:ConstBvr(silence),
                                 pSoundStandIn?true:false);

    if (ppSound)
        *ppSound = (CRSoundPtr) bvrSwSnd;

    Bvr constBvrLength = NULL;
    Bvr bvrInitialNum = ::NumToBvr(HUGE_VAL);
    constBvrLength =::ImportSwitcherBvr(bvrInitialNum,true);

    if (length)
        *length = (CRNumberPtr) constBvrLength;

    //Create Import Site (destroyed in destructor of bindstatuscallback)

    IImportSite* pIIS = NEW ImportMovieSite(canonURL.GetURL(),
                                            s,
                                            bh,
                                            pSoundStandIn && pImageStandIn,
                                            constBvrImage,
                                            bvrSwSnd,
                                            constBvrLength);

    StreamableImportSite *streamableSite =
        SAFE_CAST(StreamableImportSite *, pIIS);
    streamableSite->SetStreaming(stream);

    __try {

        SubmitImport(pIIS, ppEvent, ppProgress, size);  //import URL

        ret = pIIS->GetImportId();

    } __finally {

        RELEASE(pIIS);
    }

    APIPOSTCODE;

    return ret;
}

CRSTDAPI_(DWORD)
CRImportSound(LPCWSTR baseUrl,
              LPCWSTR relUrl,
              CRImportSitePtr s,
              IBindHost * bh,
              bool        stream,
              CRSound   *pSoundStandIn,
              CRSound  **ppSound,
              CRNumber **length,
              CREvent  **ppEvent,
              CRNumber **ppProgress,
              CRNumber **size)
{
    Assert (relUrl);

    // Needs to be outside the try block - must not throw exception

    URLCombineAndCanonicalizeOLESTR canonURL(baseUrl,
                                             relUrl);

    DWORD ret = 0;

    APIPRECODE;

    char extension[20];
    GetExtension(canonURL.GetURL(), extension, 20);


    Bvr  bvrSwSnd = ImportSwitcherBvr(pSoundStandIn?pSoundStandIn:ConstBvr(silence),
                                      pSoundStandIn?true:false);

    if (ppSound)
        *ppSound = (CRSoundPtr) bvrSwSnd;

    Bvr constBvrLength = NULL;
    Bvr bvrInitialNum = ::NumToBvr(HUGE_VAL);
    constBvrLength = ::ImportSwitcherBvr(bvrInitialNum,TRUE);

    if (length)
        *length = (CRNumberPtr) constBvrLength;

    IImportSite* pIIS = NULL;

    Bvr bvrSwNum =::ImportSwitcherBvr(zeroBvr,TRUE);

    //create import site (destroyed in IBSC)
    if(lstrcmpi(extension, "mid")  == 0 ||   // special case MIDI
       lstrcmpi(extension, "midi") == 0 )
        // XXX streamize MIDI!
        pIIS = NEW ImportMIDIsite(canonURL.GetURL(),
                                  s,
                                  bh,
                                  pSoundStandIn?true:false,
                                  bvrSwSnd, constBvrLength);
    else
        pIIS = NEW ImportPCMsite(canonURL.GetURL(),
                                 s,
                                 bh,
                                 pSoundStandIn?true:false,
                                 bvrSwSnd,bvrSwNum,constBvrLength);

    StreamableImportSite *streamableSite =
        SAFE_CAST(StreamableImportSite *, pIIS);
    streamableSite->SetStreaming(
        stream);

    __try {

        SubmitImport(pIIS, ppEvent, ppProgress, size); //import URL

        ret = pIIS->GetImportId();

    } __finally {

        RELEASE(pIIS);
    }

    APIPOSTCODE;

    return ret;
}

CRSTDAPI_(DWORD)
CRImportGeometry(LPCWSTR baseUrl,
                 LPCWSTR relUrl,
               