eCallback (&HalCallback.SetSystemInformation, &ObjectAttributes, TRUE, TRUE);
    ExCreateCallback (&HalCallback.BusCheck, &ObjectAttributes, TRUE, TRUE);

    //
    // Connect to suspend callback to lock hal hibaration code
    //

    RtlInitUnicodeString(&unicodeString, rgzSuspendCallbackName);

    InitializeObjectAttributes(
        &ObjectAttributes,
        &unicodeString,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
    );

    Status = ExCreateCallback (&CallbackObject, &ObjectAttributes, FALSE, FALSE);

    if (NT_SUCCESS(Status)) {
        ExRegisterCallback (
            CallbackObject,
            HalpLockSuspendCode,
            NULL
            );

        ObDereferenceObject (CallbackObject);
    }
#endif
}


NTSTATUS
HaliQuerySystemInformation(
    IN HAL_QUERY_INFORMATION_CLASS  InformationClass,
    IN ULONG     BufferSize,
    OUT PVOID    Buffer,
    OUT PULONG   ReturnedLength
    )
{
    NTSTATUS    Status;
    PVOID       InternalBuffer;
    ULONG       Length;
    union {
        HAL_POWER_INFORMATION               PowerInf;
        HAL_PROCESSOR_SPEED_INFORMATION     ProcessorInf;
        HAL_DISPLAY_BIOS_INFORMATION        DisplayBiosInf;
    } U;

    BOOLEAN     bUseFrameBufferCaching;

    PAGED_CODE();

    Status = STATUS_SUCCESS;
    *ReturnedLength = 0;
    Length = 0;

    switch (InformationClass) {
        case HalInstalledBusInformation:
            Status = HalpQueryInstalledBusInformation (
                        Buffer,
                        BufferSize,
                        ReturnedLength
                        );
            break;

        case HalFrameBufferCachingInformation:

            // Note - we want to return TRUE here to enable USWC in all
            // cases except in a "Shared Memory Cluster" machine.
            bUseFrameBufferCaching = TRUE;
            InternalBuffer = &bUseFrameBufferCaching;
            Length = sizeof (BOOLEAN);
            break;


#ifdef _PNP_POWER_
        case HalPowerInformation:
            RtlZeroMemory (&U.PowerInf, sizeof(HAL_POWER_INFORMATION));

            InternalBuffer = &U.PowerInf;
            Length = sizeof (HAL_POWER_INFORMATION);
            break;


        case HalProcessorSpeedInformation:
            RtlZeroMemory (&U.ProcessorInf, sizeof(HAL_POWER_INFORMATION));

            U.ProcessorInf.MaximumProcessorSpeed = 100;
            U.ProcessorInf.CurrentAvailableSpeed = 100;
            U.ProcessorInf.ConfiguredSpeedLimit  = 100;

            InternalBuffer = &U.PowerInf;
            Length = sizeof (HAL_PROCESSOR_SPEED_INFORMATION);
            break;

        case HalCallbackInformation:
            InternalBuffer = &HalCallback;
            Length = sizeof (HAL_CALLBACKS);
            break;
#endif
        default:
            Status = STATUS_INVALID_LEVEL;
            break;
    }

    //
    // If non-zero Length copy data to callers buffer
    //

    if (Length) {
        if (BufferSize < Length) {
            Length = BufferSize;
        }

        *ReturnedLength = Length;
        RtlCopyMemory (Buffer, InternalBuffer, Length);
    }

    return Status;
}

NTSTATUS
HaliSetSystemInformation (
    IN HAL_SET_INFORMATION_CLASS    InformationClass,
    IN ULONG     BufferSize,
    IN PVOID     Buffer
    )
{
    NTSTATUS    Status;

    PAGED_CODE();

    Status = STATUS_SUCCESS;

    switch (InformationClass) {

        default:
            Status = STATUS_INVALID_LEVEL;
            break;
    }

    return Status;
}



#ifdef _PNP_POWER_

VOID
HalpLockSuspendCode (
    IN PVOID    CallbackContext,
    IN PVOID    Argument1,
    IN PVOID    Argument2
    )
{
    static PVOID    CodeLock;

    switch ((ULONG) Argument1) {
        case 0:
            //
            // Lock code down which might be needed to perform a suspend
            //

            ASSERT (CodeLock == NULL);
            CodeLock = MmLockPagableCodeSection (&HaliSuspendHibernateSystem);
            break;

        case 1:
            //
            // Release the code lock
            //

            MmUnlockPagableImageSection (CodeLock);
            CodeLock = NULL;
            break;
    }
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halssc\ia64\simclk.s ===
/**
***  Copyright  (C) 1996-97 Intel Corporation. All rights reserved.
***
*** The information and source code contained herein is the exclusive
*** property of Intel Corporation and may not be disclosed, examined
*** or reproduced in whole or in part without explicit written authorization
*** from the company.
**/

//      TITLE("Manipulate Interrupt Request Level")
//++
//
// Module Name:
//
//    emclk.s
//
// Abstract:
//
//    This module implements the code necessary to adjust the ITM for time slicing,
//    to calibrate the ITC to determine the Time Base fundamental unit value (the
//    closest value for an update of 100ns).    
//
//
// Author:
//
//    Edward G. Chron (echron) 29-Apr-1996
//
// Environment:
//
//    Kernel mode only.
//
// Revision History:
//
//    29-Apr-1996    Initial Version for EAS2.1
//
//--

#include "ksia64.h"

         .file    "emclk.s"
         
         .global  HalpPerformanceFrequency

//++
//
// VOID
// HalpCalibrateTB (
//    )
//
// Routine Description:
//
//    This function calibrates the time base by determining the frequency 
//    that the ITC is running at to determine the interval value for a
//    100 ns time increment (used by clock and profile).
//
// Arguments:
//
//    None.
//
// Return Value:
//
//    None.
//
//--

          LEAF_ENTRY(HalpCalibrateTB)

          add       t2 = @gprel(HalpPerformanceFrequency), gp  
          add       t1 = 1, r0
          ;;
          st8       [t2] = t1

  (p0)    br.ret.sptk brp

          LEAF_EXIT(HalpCalibrateTB)
//++
//
// VOID
// HalpUpdateITM (
//    ULONGLONG HalpClockCount
//    )
//
// Routine Description:
//
//    This function updates the ITM based on the current value of the
//    ITC combined with the arguement supplied.
//
// Arguments:
//
//    HalpClockCount (a0) - Supplies the increment to be added to the current ITC value.
//
// Return Value:
//
//    None.
//
//--

          LEAF_ENTRY(HalpUpdateITM)

          mov       t1 = ar.itc                   // get the current clock value
          ;;
          add       t1 = t1, a0                   // current time plus interval
          ;;
          mov       cr.itm = t1                   // update the itm with the new target time 

  (p0)    br.ret.sptk brp

          LEAF_EXIT(HalpUpdateITM)


//++
//
// VOID
// HalpEnableInterrupts (
//    )
//
// Routine Description:
//
//    This function enables interrupts.
//
// Arguments:
//
//    None.
//
// Return Value:
//
//    None.
//
//--

          LEAF_ENTRY(HalpEnableInterrupts)

          FAST_ENABLE_INTERRUPTS

  (p0)    br.ret.sptk brp

          LEAF_EXIT(HalpEnableInterrupts)


          LEAF_ENTRY(HalProcessorIdle)

          FAST_ENABLE_INTERRUPTS
          nop.m 0
          br.ret.sptk b0

          LEAF_EXIT(HalProcessorIdle)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halssc\ia64\simbus.c ===
//
// No Check-in Source Code.
//
// Do not make this code available to non-Microsoft personnel
// 	without Intel's express permission
//
/**
***  Copyright  (C) 1996-97 Intel Corporation. All rights reserved.
***
*** The information and source code contained herein is the exclusive
*** property of Intel Corporation and may not be disclosed, examined
*** or reproduced in whole or in part without explicit written authorization
*** from the company.
**/

/*++

Copyright (c) 1995  Intel Corporation

Module Name:

    simbus.c

Abstract:

    This module implements the routines to support the management
    of bus resources and translation of bus addresses.

Author:

    14-Apr-1995

Environment:

    Kernel mode

Revision History:


--*/

#include "halp.h"


BOOLEAN
HalTranslateBusAddress(
    IN INTERFACE_TYPE  InterfaceType,
    IN ULONG BusNumber,
    IN PHYSICAL_ADDRESS BusAddress,
    IN OUT PULONG AddressSpace,
    OUT PPHYSICAL_ADDRESS TranslatedAddress
    )
/*++

Routine Description:

    This function stores the value of argument BusAddress into the
    memory location referenced by argument TranslatedAddress.  The
    argument referenced by AddressSpace is always set to 0 because
    there is no I/O port space in IA64 architecture.

    In the simulation environment, this function may be called by
    the video miniport driver only to determine the frame buffer
    physical address.

Return Value:

    Returns TRUE.

--*/
{
    *AddressSpace = 0;
    *TranslatedAddress = BusAddress;
    return TRUE;
}

ULONG
HalGetBusData(
    IN BUS_DATA_TYPE  BusDataType,
    IN ULONG BusNumber,
    IN ULONG SlotNumber,
    IN PVOID Buffer,
    IN ULONG Length
    )
{
    return HalGetBusDataByOffset (BusDataType,BusNumber,SlotNumber,Buffer,0,Length);
}

ULONG
HalGetBusDataByOffset (
    IN BUS_DATA_TYPE  BusDataType,
    IN ULONG BusNumber,
    IN ULONG SlotNumber,
    IN PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Length
    )
/*++

Routine Description:

    This function always returns zero.

--*/
{
    return 0;
}

ULONG
HalSetBusData(
    IN BUS_DATA_TYPE  BusDataType,
    IN ULONG BusNumber,
    IN ULONG SlotNumber,
    IN PVOID Buffer,
    IN ULONG Length
    )
{
    return HalSetBusDataByOffset (BusDataType,BusNumber,SlotNumber,Buffer,0,Length);
}

ULONG
HalSetBusDataByOffset(
    IN BUS_DATA_TYPE  BusDataType,
    IN ULONG BusNumber,
    IN ULONG SlotNumber,
    IN PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Length
    )
/*++

Routine Description:

    This function always returns zero.

--*/
{
    return 0;
}

NTSTATUS
HalAssignSlotResources (
    IN PUNICODE_STRING          RegistryPath,
    IN PUNICODE_STRING          DriverClassName       OPTIONAL,
    IN PDRIVER_OBJECT           DriverObject,
    IN PDEVICE_OBJECT           DeviceObject          OPTIONAL,
    IN INTERFACE_TYPE           BusType,
    IN ULONG                    BusNumber,
    IN ULONG                    SlotNumber,
    IN OUT PCM_RESOURCE_LIST   *AllocatedResources
    )
/*++

Routine Description:

    Not supported.  This function returns STATUS_NOT_SUPPORTED.

--*/
{
    return STATUS_NOT_SUPPORTED;
}

NTSTATUS
HalAdjustResourceList (
    IN OUT PIO_RESOURCE_REQUIREMENTS_LIST   *pResourceList
    )
/*++

Routine Description:

    No resource to be processed.  The function always returns
	STATUS_SUCCESS.

--*/
{
    return STATUS_SUCCESS;
}

VOID
HalReportResourceUsage (
    VOID
    )
{
    return;
}

VOID
KeFlushWriteBuffer(
    VOID
    )

/*++

Routine Description:

    Flushes all write buffers and/or other data storing or reordering
    hardware on the current processor.  This ensures that all previous
    writes will occur before any new reads or writes are completed.

    In the simulation environment, there is no write buffer and nothing
    needs to be done.

Arguments:

    None

Return Value:

    None.

--*/

{
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halssc\ia64\simdma.c ===
//
// No Check-in Source Code.
//
// Do not make this code available to non-Microsoft personnel
// 	without Intel's express permission
//
/**
***  Copyright  (C) 1996-97 Intel Corporation. All rights reserved.
***
*** The information and source code contained herein is the exclusive
*** property of Intel Corporation and may not be disclosed, examined
*** or reproduced in whole or in part without explicit written authorization
*** from the company.
**/

/*++

Copyright (c) 1995  Intel Corporation

Module Name:

    simdma.c

Abstract:

    This module implements the DMA support routines for the HAL DLL.

Author:

    14-Apr-1995

Environment:

    Kernel mode

Revision History:

--*/

#include "halp.h"


PADAPTER_OBJECT
HalGetAdapter(
    IN PDEVICE_DESCRIPTION DeviceDescriptor,
    OUT PULONG NumberOfMapRegisters
    )

/*++

Routine Description:

    This function returns the appropriate adapter object for the DMA 
    device. However, there is no DMA device in the simulation 
    environment.  Therefore, the function returns NULL to indicate
    failure.

Arguments:

    DeviceDescriptor - Supplies a description of the deivce.

    NumberOfMapRegisters - Returns the maximum number of map registers which
    may be allocated by the device driver.

Return Value:

    NULL

--*/

{
    return NULL;
}

NTSTATUS
HalAllocateAdapterChannel(
    IN PADAPTER_OBJECT AdapterObject,
    IN PWAIT_CONTEXT_BLOCK Wcb,
    IN ULONG NumberOfMapRegisters,
    IN PDRIVER_CONTROL ExecutionRoutine
    )
/*++

Routine Description:

    As there is no DMA device in the simulation environment, this function 
    is not supported.

Arguments:

    AdapterObject - Pointer to the adapter control object to allocate to the
    driver.

    Wcb - Supplies a wait context block for saving the allocation parameters.
    The DeviceObject, CurrentIrp and DeviceContext should be initalized.

    NumberOfMapRegisters - The number of map registers that are to be allocated
    from the channel, if any.

    ExecutionRoutine - The address of the driver's execution routine that is
    invoked once the adapter channel (and possibly map registers) have been
    allocated.

Return Value:

    Returns STATUS_NOT_SUPPORTED

Notes:

    Note that this routine MUST be invoked at DISPATCH_LEVEL or above.

--*/
{
    return STATUS_NOT_SUPPORTED;
}

ULONG
HalReadDmaCounter(
    IN PADAPTER_OBJECT AdapterObject
    )
/*++

Routine Description:

    This function reads the DMA counter and returns the number of bytes left
    to be transfered.  As there is no DMA device, a value of zero is always
    returned.

Arguments:

    AdapterObject - Supplies a pointer to the adapter object to be read.

Return Value:

    Returns the number of bytes still be be transfered.

--*/

{
    return 0;
}

PVOID
HalAllocateCommonBuffer(
    IN PADAPTER_OBJECT AdapterObject,
    IN ULONG Length,
    OUT PPHYSICAL_ADDRESS LogicalAddress,
    IN BOOLEAN CacheEnabled
    )
/*++

Routine Description:

    This function allocates the memory for a common buffer and maps so
    that it can be accessed by a master device and the CPU.  As there
    is no DMA support, a value of NULL is always returned.

Arguments:

    AdapterObject - Supplies a pointer to the adapter object used by this
    device.

    Length - Supplies the length of the common buffer to be allocated.

    LogicalAddress - Returns the logical address of the common buffer.

    CacheEnable - Indicates whether the memeory is cached or not.

Return Value:

    Returns the virtual address of the common buffer.  If the buffer cannot
    be allocated then NULL is returned.

--*/

{
    return NULL;
}

BOOLEAN
HalFlushCommonBuffer(
    IN PADAPTER_OBJECT AdapterObject,
    IN ULONG Length,
    IN PHYSICAL_ADDRESS LogicalAddress,
    IN PVOID VirtualAddress
    )
/*++

Routine Description:

    This function is called to flush any hardware adapter buffers when the
    driver needs to read data written by an I/O master device to a common
    buffer.  As there is no DMA support, that implies no buffers to flush
    and TRUE is always returned.

Arguments:

    AdapterObject - Supplies a pointer to the adapter object used by this
    device.

    Length - Supplies the length of the common buffer. This should be the same
    value used for the allocation of the buffer.

    LogicalAddress - Supplies the logical address of the common buffer.  This
    must be the same value return by HalAllocateCommonBuffer.

    VirtualAddress - Supplies the virtual address of the common buffer.  This
    must be the same value return by HalAllocateCommonBuffer.

Return Value:

    Returns TRUE if no errors were detected; otherwise, FALSE is return.

--*/

{
    return TRUE;
}

VOID
HalFreeCommonBuffer(
    IN PADAPTER_OBJECT AdapterObject,
    IN ULONG Length,
    IN PHYSICAL_ADDRESS LogicalAddress,
    IN PVOID VirtualAddress,
    IN BOOLEAN CacheEnabled
    )
/*++

Routine Description:

    This function frees a common buffer and all of the resouces it uses.
    There is no buffer to be freed in the simulation environment. The
    function simply returns.

Arguments:

    AdapterObject - Supplies a pointer to the adapter object used by this
    device.

    Length - Supplies the length of the common buffer. This should be the same
    value used for the allocation of the buffer.

    LogicalAddress - Supplies the logical address of the common buffer.  This
    must be the same value return by HalAllocateCommonBuffer.

    VirtualAddress - Supplies the virtual address of the common buffer.  This
    must be the same value return by HalAllocateCommonBuffer.

    CacheEnable - Indicates whether the memeory is cached or not.

Return Value:

    None

--*/

{
    return;
}

PVOID
HalAllocateCrashDumpRegisters(
    IN PADAPTER_OBJECT AdapterObject,
    IN PULONG NumberOfMapRegisters
    )
/*++

Routine Description:

    This routine is called during the crash dump disk driver's initialization
    to allocate a number map registers permanently.  It is not supported and
    NULL is always returned to indicate allocation failure.  The lack of this
    capability implies that the crash dump disk driver is not supported.

Arguments:

    AdapterObject - Pointer to the adapter control object to allocate to the
    driver.
    NumberOfMapRegisters - Number of map registers requested. This field
    will be updated to reflect the actual number of registers allocated
    when the number is less than what was requested.

Return Value:

    Returns NULL.

--*/
{
    return NULL;
}

BOOLEAN
IoFlushAdapterBuffers(
    IN PADAPTER_OBJECT AdapterObject,
    IN PMDL Mdl,
    IN PVOID MapRegisterBase,
    IN PVOID CurrentVa,
    IN ULONG Length,
    IN BOOLEAN WriteToDevice
    )

/*++

Routine Description:

    This routine flushes the DMA adapter object buffers. In the simulation
    environment, nothing needs to be done and TRUE is always returned.

Arguments:

    AdapterObject - Pointer to the adapter object representing the DMA
    controller channel.

    Mdl - A pointer to a Memory Descriptor List (MDL) that maps the locked-down
    buffer to/from which the I/O occured.

    MapRegisterBase - A pointer to the base of the map registers in the adapter
    or DMA controller.

    CurrentVa - The current virtual address in the buffer described the the Mdl
    where the I/O operation occurred.

    Length - Supplies the length of the transfer.

    WriteToDevice - Supplies a BOOLEAN value that indicates the direction of
    the data transfer was to the device.

Return Value:

    TRUE - No errors are detected so the transfer must succeed.

--*/

{
    return TRUE;
}

VOID
IoFreeAdapterChannel(
    IN PADAPTER_OBJECT AdapterObject
    )

/*++

Routine Description:

    This routine is invoked to deallocate the specified adapter object.
    Any map registers that were allocated are also automatically deallocated.
    No checks are made to ensure that the adapter is really allocated to
    a device object.  However, if it is not, then kernel will bugcheck.

    If another device is waiting in the queue to allocate the adapter object
    it will be pulled from the queue and its execution routine will be
    invoked.
	
    In the simulation environment, this routine does nothing and returns.

Arguments:

    AdapterObject - Pointer to the adapter object to be deallocated.

Return Value:

    None.

--*/

{
    return;
}

VOID
IoFreeMapRegisters(
   PADAPTER_OBJECT AdapterObject,
   PVOID MapRegisterBase,
   ULONG NumberOfMapRegisters
   )
/*++

Routine Description:

    This routine deallocates the map registers for the adapter.  If there are
    any queued adapter waiting for an attempt is made to allocate the next
    entry.

    In the simulation environment, the routine does nothing and returns.

Arguments:

    AdapterObject - The adapter object to where the map register should be
    returned.

    MapRegisterBase - The map register base of the registers to be deallocated.

    NumberOfMapRegisters - The number of registers to be deallocated.

Return Value:

    None

--+*/
{
    return;
}

PHYSICAL_ADDRESS
IoMapTransfer(
    IN PADAPTER_OBJECT AdapterObject,
    IN PMDL Mdl,
    IN PVOID MapRegisterBase,
    IN PVOID CurrentVa,
    IN OUT PULONG Length,
    IN BOOLEAN WriteToDevice
    )

/*++

Routine Description:

    This routine is invoked to set up the map registers in the DMA controller
    to allow a transfer to or from a device.

    In the simulation environment, no map register is supported and a
    logical address of zero is always returned.


Arguments:

    AdapterObject - Pointer to the adapter object representing the DMA
    controller channel that has been allocated.

    Mdl - Pointer to the MDL that describes the pages of memory that are
    being read or written.

    MapRegisterBase - The address of the base map register that has been
    allocated to the device driver for use in mapping the transfer.

    CurrentVa - Current virtual address in the buffer described by the MDL
    that the transfer is being done to or from.

    Length - Supplies the length of the transfer.  This determines the
    number of map registers that need to be written to map the transfer.
    Returns the length of the transfer which was actually mapped.

    WriteToDevice - Boolean value that indicates whether this is a write
    to the device from memory (TRUE), or vice versa.

Return Value:

    Returns the logical address that should be used bus master controllers.

--*/

{
    PHYSICAL_ADDRESS result;

    result.HighPart = 0;
    result.LowPart = 0;
    return (result);
}

ULONG
HalGetDmaAlignmentRequirement (
    VOID
    )

/*++

Routine Description:

    This function returns the alignment requirements for DMA transfers on
    host system.

Arguments:

    None.

Return Value:

    The DMA alignment requirement is returned as the fucntion value.

--*/

{

    return 8;
}

VOID
HalFlushIoBuffers (
    IN PMDL Mdl,
    IN BOOLEAN ReadOperation,
    IN BOOLEAN DmaOperation
    )

/*++

Routine Description:

    This function flushes the I/O buffer specified by the memory descriptor
    list from the data cache on the current processor.

Arguments:

    Mdl - Supplies a pointer to a memory descriptor list that describes the
        I/O buffer location.

    ReadOperation - Supplies a boolean value that determines whether the I/O
        operation is a read into memory.

    DmaOperation - Supplies a boolean value that determines whether the I/O
        operation is a DMA operation.

Return Value:

    None.

--*/

{
    //
    // BUGBUG:  This still needs to be done
    //

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halssc\ia64\simkd.c ===
//
// No Check-in Source Code.
//
// Do not make this code available to non-Microsoft personnel
//     without Intel's express permission
//
/**
***  Copyright  (C) 1996-97 Intel Corporation. All rights reserved.
***
*** The information and source code contained herein is the exclusive
*** property of Intel Corporation and may not be disclosed, examined
*** or reproduced in whole or in part without explicit written authorization
*** from the company.
**/

/*++

Copyright (c) 1995  Intel Corporation

Module Name:

    simkd.c

Abstract:

    Kernel debug com support.

Author:

    14-Apr-1995

Environment:

    Kernel mode

Revision History:

--*/

#include "halp.h"

extern int sprintf(char *, const char *, ...);

// #define KDDBG 1

#define TIMEOUT_COUNT  100    // 1024 * 200 
#define GET_RETRY_COUNT  1024
#define MSG_DEBUG_ENABLE        "Kernel Debugger Using: COM%x (Port %p, Baud Rate %d)\n"
#define MSG2_DEBUG_ENABLE        "Kernel Debugger Using named pipe: COM%x (Port %p, Baud Rate %d)\n"

PUCHAR KdComPortInUse=NULL;


BOOLEAN
KdPortInitialize(
    PDEBUG_PARAMETERS DebugParameters,
    PLOADER_PARAMETER_BLOCK LoaderBlock,
    BOOLEAN Initialize
    )

/*++

Routine Description:

    This routine initialize a com port to support kernel debug.

Arguments:

    DebugParameters - Supplies a pointer a structure which optionally
                      sepcified the debugging port information.

    LoaderBlock - supplies a pointer to the loader parameter block.

    Initialize - Specifies a boolean value that determines whether the
                 debug port is initialized or just the debug port parameters
                 are captured.

Returned Value:

    TRUE - If a debug port is found.

--*/

{

    PUCHAR PortAddress = NULL;
    ULONG Com = 0;
    UCHAR DebugMessage[80];
    PHYSICAL_ADDRESS LPDebugParameters;


    if (Initialize) {
        LPDebugParameters = MmGetPhysicalAddress (DebugParameters);
        if ( !SscKdInitialize( (PVOID)LPDebugParameters.QuadPart, (SSC_BOOL)Initialize )) { 

           // SscKd initialized sucessfully

       Com = DebugParameters->CommunicationPort;

           if ( Com != 0 ) {     // initialize port struct if not named-pipe
                //
                // set port address to default value.
                //

                if (PortAddress == NULL) {
                    switch (Com) {
                    case 1:
                       PortAddress = (PUCHAR)(ULONG_PTR)0x3f8;
                       break;
                    case 2:
                       PortAddress = (PUCHAR)(ULONG_PTR)0x2f8;
                       break;
                    case 3:
                       PortAddress = (PUCHAR)(ULONG_PTR)0x3e8;
                       break;
                    case 4:
                       PortAddress = (PUCHAR)(ULONG_PTR)0x2e8;
                    }
                }

                KdComPortInUse= PortAddress;

                sprintf(DebugMessage, MSG_DEBUG_ENABLE,
                        Com, PortAddress, DebugParameters->BaudRate);
                HalDisplayString("\n");
                HalDisplayString(DebugMessage);
            }
            else {   // port=0, named-pipe
                sprintf(DebugMessage, MSG2_DEBUG_ENABLE,
                        Com, PortAddress, DebugParameters->BaudRate);
                HalDisplayString("\n");
                HalDisplayString(DebugMessage);
            }
            return(TRUE);
        }
        else {
            // SscKdinitialize() failed
            return(FALSE);
        }
    }
    else { //  By pass. do not initialize
        return(FALSE);
    }
}

ULONG
KdPortGetByte (
    OUT PUCHAR Input
    )

/*++

Routine Description:

    Fetch a byte from the debug port and return it.

    This routine does nothing in the simulation environment.

    N.B. It is assumed that the IRQL has been raised to the highest level, and
         necessary multiprocessor synchronization has been performed before this
         routine is called.

Arguments:

    Input - Returns the data byte.

Return Value:

    CP_GET_SUCCESS is returned if a byte is successfully read from the
        kernel debugger line.
    CP_GET_ERROR is returned if error encountered during reading.
    CP_GET_NODATA is returned if timeout.

--*/

{
    PHYSICAL_ADDRESS LPInput;
    UCHAR DebugMessage[80];
    ULONG   limitcount, status;

    LPInput = MmGetPhysicalAddress (Input);
    limitcount = GET_RETRY_COUNT;

    while (limitcount != 0) {
        limitcount--;

        status = SscKdPortGetByte((PVOID)LPInput.QuadPart);
        if (status == CP_GET_SUCCESS) {
#ifdef KDDBG
            sprintf(DebugMessage,"%02x ", *Input);
            HalDisplayString(DebugMessage);
#endif
            return(CP_GET_SUCCESS);
        }
#ifdef KDDBG
        else {
            HalDisplayString(".");
        }
#endif
    }
    return status;
}

ULONG
KdPortPollByte (
    OUT PUCHAR Input
    )

/*++

Routine Description:

    Fetch a byte from the debug port and return it if one is available.

    This routine does nothing in the simulation environment.

    N.B. It is assumed that the IRQL has been raised to the highest level, and
        necessary multiprocessor synchronization has been performed before this
        routine is called.

Arguments:

    Input - Returns the data byte.

Return Value:

    CP_GET_SUCCESS is returned if a byte is successfully read from the
    kernel debugger line.
    CP_GET_ERROR is returned if error encountered during reading.
    CP_GET_NODATA is returned if timeout.

--*/

{
    PHYSICAL_ADDRESS LPInput;
    UCHAR DebugMessage[80];
    ULONG   limitcount, status;
    
    LPInput = MmGetPhysicalAddress (Input);
    limitcount = TIMEOUT_COUNT;

    while (limitcount != 0) {
        limitcount--;

        status = SscKdPortGetByte((PVOID)LPInput.QuadPart);
        if (status == CP_GET_ERROR)
            return(CP_GET_ERROR);
        if (status == CP_GET_SUCCESS) {
#ifdef KDDBG
            sprintf(DebugMessage, "%02x ", *Input);
            HalDisplayString(DebugMessage);
#endif
            return(CP_GET_SUCCESS);
        }
#ifdef KDDBG
        HalDisplayString(".");
#endif
    }
    return (CP_GET_NODATA);
}

VOID
KdPortPutByte (
    IN UCHAR Output
    )

/*++

Routine Description:

    Write a byte to the debug port.  
    
    This routine does nothing in the simulation environment.

    N.B. It is assumed that the IRQL has been raised to the highest level, and
        necessary multiprocessor synchronization has been performed before this
        routine is called.

Arguments:

    Output - Supplies the output data byte.

Return Value:

    None.

--*/

{
#ifdef KDDBG
    UCHAR DebugMessage[80];

    sprintf(DebugMessage, "%02x-", Output);
    HalDisplayString(DebugMessage);
#endif
    SscKdPortPutByte(Output);
}

VOID
KdPortRestore (
    VOID
    )

/*++

Routine Description:

    This routine does nothing in the simulation environment.

    N.B. It is assumed that the IRQL has been raised to the highest level, and
        necessary multiprocessor synchronization has been performed before this
        routine is called.

Arguments:

    None.

Return Value:

    None.

--*/

{

}

VOID
KdPortSave (
    VOID
    )

/*++

Routine Description:

    This routine does nothing in the simulation environment.

    N.B. It is assumed that the IRQL has been raised to the highest level, and
        necessary multiprocessor synchronization has been performed before this
        routine is called.

Arguments:

    None.

Return Value:

    None.

--*/

{

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halssc\ia64\simio.c ===
//
// No Check-in Source Code.
//
// Do not make this code available to non-Microsoft personnel
// 	without Intel's express permission
//
/**
***  Copyright  (C) 1996-97 Intel Corporation. All rights reserved.
***
*** The information and source code contained herein is the exclusive
*** property of Intel Corporation and may not be disclosed, examined
*** or reproduced in whole or in part without explicit written authorization
*** from the company.
**/

/*++

Copyright (c) 1995  Intel Corporation

Module Name:

    simio.c

Abstract:

    This module implements the I/O port access routines.

Author:

    14-Apr-1995

Environment:

    Kernel mode

Revision History:


--*/

#include "halp.h"



UCHAR
READ_PORT_UCHAR (
    PUCHAR Port
    )
{
    return (*(volatile UCHAR * const)(Port));
}

USHORT
READ_PORT_USHORT (
    PUSHORT Port
    )
{
    return (*(volatile USHORT * const)(Port));
}

ULONG
READ_PORT_ULONG (
    PULONG Port
    )
{
    return (*(volatile ULONG * const)(Port));
}

VOID
WRITE_PORT_UCHAR (
    PUCHAR Port,
    UCHAR  Value
    )
{
    *(volatile UCHAR * const)(Port) = Value;
    KeFlushWriteBuffer();
}

VOID
WRITE_PORT_USHORT (
    PUSHORT Port,
    USHORT  Value
    )
{
    *(volatile USHORT * const)(Port) = Value;
    KeFlushWriteBuffer();
}

VOID
WRITE_PORT_ULONG (
    PULONG Port,
    ULONG  Value
    )
{
    *(volatile ULONG * const)(Port) = Value;
    KeFlushWriteBuffer();
}

VOID
READ_PORT_BUFFER_UCHAR (
    PUCHAR Port,
    PUCHAR Buffer,
    ULONG Count
    )
{
    PUCHAR ReadBuffer = Buffer;
    ULONG ReadCount;

    for (ReadCount = 0; ReadCount < Count; ReadCount++, ReadBuffer++) {
        *ReadBuffer = *(volatile UCHAR * const)(Port);
    }
}

VOID
READ_PORT_BUFFER_USHORT (
    PUSHORT Port,
    PUSHORT Buffer,
    ULONG Count
    )
{
    PUSHORT ReadBuffer = Buffer;
    ULONG ReadCount;

    for (ReadCount = 0; ReadCount < Count; ReadCount++, ReadBuffer++) {
        *ReadBuffer = *(volatile USHORT * const)(Port);
    }
}

VOID
READ_PORT_BUFFER_ULONG (
    PULONG Port,
    PULONG Buffer,
    ULONG Count
    )
{
    PULONG ReadBuffer = Buffer;
    ULONG ReadCount;

    for (ReadCount = 0; ReadCount < Count; ReadCount++, ReadBuffer++) {
        *ReadBuffer = *(volatile ULONG * const)(Port);
    }
}

VOID
WRITE_PORT_BUFFER_UCHAR (
    PUCHAR Port,
    PUCHAR Buffer,
    ULONG   Count
    )
{
    PUCHAR WriteBuffer = Buffer;
    ULONG WriteCount;

    for (WriteCount = 0; WriteCount < Count; WriteCount++, WriteBuffer++) {
        *(volatile UCHAR * const)(Port) = *WriteBuffer;
        KeFlushWriteBuffer();
    }
}

VOID
WRITE_PORT_BUFFER_USHORT (
    PUSHORT Port,
    PUSHORT Buffer,
    ULONG   Count
    )
{
    PUSHORT WriteBuffer = Buffer;
    ULONG WriteCount;

    for (WriteCount = 0; WriteCount < Count; WriteCount++, WriteBuffer++) {
        *(volatile USHORT * const)(Port) = *WriteBuffer;
        KeFlushWriteBuffer();
    }
}

VOID
WRITE_PORT_BUFFER_ULONG (
    PULONG Port,
    PULONG Buffer,
    ULONG   Count
    )
{
    PULONG WriteBuffer = Buffer;
    ULONG WriteCount;

    for (WriteCount = 0; WriteCount < Count; WriteCount++, WriteBuffer++) {
        *(volatile ULONG * const)(Port) = *WriteBuffer;
        KeFlushWriteBuffer();
    }
}

VOID
HalHandleNMI(
    IN OUT PVOID NmiInfo
    )
{
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halssc\ia64\simfw.c ===
//
// No Check-in Source Code.
//
// Do not make this code available to non-Microsoft personnel
// 	without Intel's express permission
//
/**
***  Copyright  (C) 1996-97 Intel Corporation. All rights reserved.
***
*** The information and source code contained herein is the exclusive
*** property of Intel Corporation and may not be disclosed, examined
*** or reproduced in whole or in part without explicit written authorization
*** from the company.
**/

/*++

Copyright (c) 1995  Intel Corporation

Module Name:

    simfw.c

Abstract:

    This module implements the routines that transfer control
    from the kernel to the TAL and SAL code.

Author:

    14-Apr-1995

Environment:

    Kernel mode

Revision History:


--*/

#include "halp.h"
#include "arc.h"
#include "arccodes.h"


VOID
HalReturnToFirmware(
    IN FIRMWARE_ENTRY Routine
    )

/*++

Routine Description:

    Returns control to the firmware routine specified.  Since the simulation
    does not provide TAL and SAL support, it just stops the system.

    System reboot can be done here.

Arguments:

    Routine - Supplies a value indicating which firmware routine to invoke.

Return Value:

    Does not return.

--*/

{
    switch (Routine) {
    case HalHaltRoutine:
    case HalPowerDownRoutine:
    case HalRestartRoutine:
    case HalRebootRoutine:
        SscExit(0);
        break;

    default:
        DbgPrint("HalReturnToFirmware called\n");
        DbgBreakPoint();
        break;
    }
}

ARC_STATUS
HalGetEnvironmentVariable (
    IN PCHAR Variable,
    IN USHORT Length,
    OUT PCHAR Buffer
    )

/*++

Routine Description:

    This function locates an environment variable and returns its value.

    The only environment variable this implementation supports is
    "LastKnownGood".  The returned value is always "FALSE".

Arguments:

    Variable - Supplies a pointer to a zero terminated environment variable
        name.

    Length - Supplies the length of the value buffer in bytes.

    Buffer - Supplies a pointer to a buffer that receives the variable value.

Return Value:

    ESUCCESS is returned if the enviroment variable is located. Otherwise,
    ENOENT is returned.

--*/

{
    if (_stricmp(Variable, "LastKnownGood") != 0) {
        return ENOENT;
    }

    strncpy(Buffer, "FALSE", Length);

    return ESUCCESS;
}

ARC_STATUS
HalSetEnvironmentVariable (
    IN PCHAR Variable,
    IN PCHAR Value
    )

/*++

Routine Description:

    This function creates an environment variable with the specified value.

    The only environment variable this implementation supports is
    "LastKnownGood".

Arguments:

    Variable - Supplies a pointer to an environment variable name.

    Value - Supplies a pointer to the environment variable value.

Return Value:

    ESUCCESS is returned if the environment variable is created. Otherwise,
    ENOMEM is returned.

--*/

{
    if (_stricmp(Variable, "LastKnownGood") != 0) {
        return ENOMEM;
    }

    if (_stricmp(Value, "TRUE") == 0) {
        return(ENOMEM);
    } else if (_stricmp(Value, "FALSE") == 0) {
        return ESUCCESS;
    } else {
        return(ENOMEM);
    }
}

VOID
HalSweepIcache (
    )

/*++

Routine Description:

    This function sweeps the entire I cache on the processor which it runs.

Arguments:

    None.

Return Value:

    None.

--*/

{
    return;
}

VOID
HalSweepDcache (
    )

/*++

Routine Description:

    This function sweeps the entire D cache on ths processor which it runs.

    Arguments:

    None.

    Return Value:

    None.

--*/

{
    return;
}

VOID
HalSweepIcacheRange (
     IN PVOID BaseAddress,
     IN ULONG Length
    )

/*++

Routine Description:
    This function sweeps the range of address in the I cache throughout the system.

Arguments:
    BaseAddress - Supplies the starting virtual address of a range of
      virtual addresses that are to be flushed from the data cache.

    Length - Supplies the length of the range of virtual addresses
      that are to be flushed from the data cache.


Return Value:

    None.

--*/

{
    return;
}

VOID
HalSweepDcacheRange (
    IN PVOID BaseAddress,
    IN ULONG Length
    )

/*++


Routine Description:
    This function sweeps the range of address in the I cache throughout the system.

Arguments:
    BaseAddress - Supplies the starting virtual address of a range of
      virtual addresses that are to be flushed from the data cache.

    Length - Supplies the length of the range of virtual addresses
      that are to be flushed from the data cache.


Return Value:

    None.

--*/

{
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halssc\ia64\simkrnl.c ===
/**
***  Copyright  (C) 1996-97 Intel Corporation. All rights reserved.
***
*** The information and source code contained herein is the exclusive
*** property of Intel Corporation and may not be disclosed, examined
*** or reproduced in whole or in part without explicit written authorization
*** from the company.
**/

/*++

Copyright (c) 1995  Intel Corporation

Module Name:

    simkrnl.c

Abstract:

    This module implements the kernel support routines for the HAL DLL.

Author:

    14-Apr-1995

Environment:

    Kernel mode

Revision History:

--*/

#include "halp.h"

extern VOID  HalpCalibrateTB(); 
static short HalpOwnDisplay = TRUE;

ULONG
HalpNoBusData (
    IN PVOID BusHandler,
    IN PVOID RootHandler,
    IN ULONG SlotNumber,
    IN PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Length
    );


BOOLEAN
HalAllProcessorsStarted (
    VOID
    )

/*++

Routine Description:

    This function returns TRUE if all the processors in the system started
    successfully.

Arguments:

    None.

Return Value:

    Returns TRUE.

--*/

{
    return TRUE;
}

BOOLEAN
HalStartNextProcessor (
    IN PLOADER_PARAMETER_BLOCK   pLoaderBlock,
    IN PKPROCESSOR_STATE         pProcessorState
    )

/*++

Routine Description:

    This function always returns FALSE on a uni-processor platform 
    because there is no second processor to be started.

Arguments:

    pLoaderBlock - Loader Block.

    pProcessorState - A description of the processor state.

Return Value:

    Returns TRUE.

--*/

{
    //
    // no other processors
    //

    return FALSE;
}

VOID
HalRequestIpi (
    IN ULONG Mask
    )

/*++

Routine Description:

    This function does nothing on a uni-processor platform.

Arguments:

    Mask - A mask that specifies the target processor(s) to which an
           IPI is to be sent.

Return Value:

    None.

--*/

{
    //
    // no other processors.
    //

    return;
}

BOOLEAN
HalMakeBeep (
    IN ULONG Frequency
    )

/*++

Routine Description:

    This function calls SSC function SscMakeBeep() to make a beep sound
    when the specified frequency has a non-zero value.

Arguments:

    Frequency - the frequency of the sound to be made.

Return Value:

    None.

--*/

{
    if (Frequency > 0) {
        SscMakeBeep(Frequency);
    }
    return TRUE;
}

BOOLEAN
HalQueryRealTimeClock (
    OUT PTIME_FIELDS TimeFields
    )

/*++

Routine Description:

    This function calls the SSC function SscQueryRealTimeClock to
    get the real time clock data from the host.  This function always
    succeeds in the simulation environment and should return TRUE at
    all times.

Arguments:

    TimeFields - Real Time Clock Data

Return Value:

    Returns TRUE if successful; otherwise, FALSE.

--*/

{
    PMDL Mdl;
    SSC_TIME_FIELDS SscTimeFields;
    PHYSICAL_ADDRESS physicalAddress;

/*
    Mdl = MmCreateMdl (NULL, TimeFields, sizeof(TIME_FIELDS));
    MmProbeAndLockPages (Mdl, KernelMode, IoModifyAccess);
*/

    physicalAddress = MmGetPhysicalAddress (&SscTimeFields);
    SscQueryRealTimeClock((PVOID)physicalAddress.QuadPart);

    TimeFields->Year = (USHORT)SscTimeFields.Year;
    TimeFields->Month = (USHORT)SscTimeFields.Month;
    TimeFields->Day = (USHORT)SscTimeFields.Day;
    TimeFields->Hour = (USHORT)SscTimeFields.Hour;
    TimeFields->Minute = (USHORT)SscTimeFields.Minute;
    TimeFields->Second = (USHORT)SscTimeFields.Second;
    TimeFields->Milliseconds = (USHORT)SscTimeFields.Milliseconds;
    TimeFields->Weekday = (USHORT)SscTimeFields.WeekDay;

/*
    MmUnlockPages (Mdl);
*/

    return TRUE;
}

BOOLEAN
HalSetRealTimeClock (
    IN PTIME_FIELDS TimeFields
    )

/*++

Routine Description:

    This function calls the SSC function SscQueryRealTimeClock to
    get the real time clock data from the host.

Arguments:

    TimeFields - Real Time Clock Data

Return Value:

    None.

--*/

{
    DbgPrint("HalSetRealTimeClock: Warning.\n");
    return TRUE;
}

VOID
KeStallExecutionProcessor (
    IN ULONG MicroSeconds
    )

/*++

Routine Description:

    This function does nothing in the simulation environment.

Arguments:

    MicroSeconds - Number of microseconds to stall the processor. 

Return Value:

    None.

--*/

{
    return;
}

VOID
HalQueryDisplayParameters (
    OUT PULONG WidthInCharacters,
    OUT PULONG HeightInLines,
    OUT PULONG CursorColumn,
    OUT PULONG CursorRow
    )

/*++

Routine Description:

    This routine returns information about the display area and current
    cursor position.  In the simulation environment, the function does 
    nothing.  Therefore, the kernel should either ignore the returned
    results or not call the function at all.

Arguments:

    WidthInCharacter - Supplies a pointer to a varible that receives
        the width of the display area in characters.

    HeightInLines - Supplies a pointer to a variable that receives the
        height of the display area in lines.

    CursorColumn - Supplies a pointer to a variable that receives the
        current display column position.

    CursorRow - Supplies a pointer to a variable that receives the
        current display row position.

Return Value:

    None.

--*/

{
    return;
}

VOID
HalSetDisplayParameters (
    IN ULONG CursorColumn,
    IN ULONG CursorRow
    )
/*++

Routine Description:

    This routine does nothing in the simulation environment.

Arguments:

    CursorColumn - Supplies the new display column position.

    CursorRow - Supplies a the new display row position.

Return Value:

    None.

--*/

{
    return;
}

VOID
HalDisplayString (
    PUCHAR String
    )

/*++

Routine Description:

    This routine calls the SSC function SscDisplayString to display 
    the specified character string in a window.

Arguments:

    String - Supplies a pointer to the characters that are to be displayed.

Return Value:

    None.

    N.B. The string must be resident in memory or it must be paged in.

--*/

{
    PHYSICAL_ADDRESS StringBufferPtr;

    if (String) {
        StringBufferPtr = MmGetPhysicalAddress (String);
        if (StringBufferPtr.QuadPart != 0ULL) {
            SscDisplayString((PVOID)StringBufferPtr.QuadPart);
        }
    }
}

VOID
HalAcquireDisplayOwnership (
    IN PHAL_RESET_DISPLAY_PARAMETERS  ResetDisplayParameters
    )

/*++

Routine Description:

    This routine switches ownership of the display away from the HAL to
    the system display driver. It is called when the system has reached
    a point during bootstrap where it is self supporting and can output
    its own messages. Once ownership has passed to the system display
    driver any attempts to output messages using HalDisplayString must
    result in ownership of the display reverting to the HAL and the
    display hardware reinitialized for use by the HAL.

Arguments:

    ResetDisplayParameters - if non-NULL the address of a function
    the hal can call to reset the video card.

Return Value:

    None.

--*/

{
    HalpOwnDisplay = FALSE;
    return;
}

VOID
HalInitializeProcessor (
    IN ULONG Number,
    IN PLOADER_PARAMETER_BLOCK LoaderBlock
    )

/*++

Routine Description:

    This function is called early in the initialization of the kernel
    to perform platform dependent initialization for each processor
    before the HAL Is fully functional.

    N.B. When this routine is called, the PCR is present but is not
         fully initialized.

Arguments:

    Number - Supplies the number of the processor to initialize.

Return Value:

    None.

--*/

{
    PCR->StallScaleFactor = 0;
    return;
}

BOOLEAN
HalInitSystem (
    IN ULONG Phase,
    IN PLOADER_PARAMETER_BLOCK LoaderBlock
    )

/*++

Routine Description:

    This function initializes the Hardware Architecture Layer (HAL) for
    IA64/NT in the simulation environment.

Arguments:

    Phase - A number that specifies the initialization phase that the
            kernel is in.

    LoaderBlock - Loader Block Data.

Return Value:

    A value of TRUE is returned is the initialization was successfully
    complete. Otherwise a value of FALSE is returend.

--*/

{

    PKPRCB Prcb;

    Prcb = PCR->Prcb;

    if (Phase == 0) {
        
        //
        // If processor 0 is being initialized, then initialize various
        // variables.
        //

        if (Prcb->Number == 0) {

            //
            // Set the interval clock increment value.
            //

            HalpCalibrateTB();
            
            // *** TBD define these constants
            //KeSetTimeIncrement(MAXIMUM_CLOCK_INTERVAL, MINIMUM_CLOCK_INTERVAL);
            KeSetTimeIncrement(100000, 10000);
        }

        //
        // Initialize the interrupt structures
        //

        HalpInitializeInterrupts ();

        //
        // Fill in handlers for APIs which this hal supports
        //

        HalQuerySystemInformation = HaliQuerySystemInformation;
        HalSetSystemInformation = HaliSetSystemInformation;

    } else {

        //
        // Phase 1 initialization
        //

        if (Prcb->Number == 0) {

            //
            //  If P0, then setup global vectors
            //

            HalpRegisterInternalBusHandlers ();

        }
    }

    return TRUE;
}



VOID
HalChangeColorPage (
    IN PVOID NewColor,
    IN PVOID OldColor,
    IN ULONG PageFrame
    )
/*++

Routine Description:

   This function changes the color of a page if the old and new colors
   do not match.  

   BUGBUG:  For now this is a stub.  Needs to be filled in.

Arguments:

   NewColor - Supplies the page aligned virtual address of the
      new color of the page to change.

   OldColor - Supplies the page aligned virtual address of the
      old color of the page to change.

   pageFrame - Supplies the page frame number of the page that
      is changed.

Return Value:

   None.

--*/
{
    return;
}

PBUS_HANDLER
HalpAllocateBusHandler (
    IN INTERFACE_TYPE   InterfaceType,
    IN BUS_DATA_TYPE    BusDataType,
    IN ULONG            BusNumber,
    IN INTERFACE_TYPE   ParentBusInterfaceType,
    IN ULONG            ParentBusNumber,
    IN ULONG            BusSpecificData
    )
/*++

Routine Description:

    Stub function to map old style code into new HalRegisterBusHandler code.

    Note we can add our specific bus handler functions after this bus
    handler structure has been added since this is being done during
    hal initialization.

--*/
{
    PBUS_HANDLER     Bus;


    //
    // Create bus handler - new style
    //

    HaliRegisterBusHandler (
        InterfaceType,
        BusDataType,
        BusNumber,
        ParentBusInterfaceType,
        ParentBusNumber,
        BusSpecificData,
        NULL,
        &Bus
    );

    return Bus;
}

ULONG
HalpGetSystemInterruptVector(
    IN PBUS_HANDLER BusHandler,
    IN PBUS_HANDLER RootHandler,
    IN ULONG BusInterruptLevel,
    IN ULONG BusInterruptVector,
    OUT PKIRQL Irql,
    OUT PKAFFINITY Affinity
    )

/*++

Routine Description:

Arguments:

    BusInterruptLevel - Supplies the bus specific interrupt level.

    BusInterruptVector - Supplies the bus specific interrupt vector.

    Irql - Returns the system request priority.

    Affinity - Returns the system wide irq affinity.

Return Value:

    Returns the system interrupt vector corresponding to the specified device.

--*/
{

    //
    // Just return the passed parameters.
    //

    *Irql = (KIRQL) BusInterruptLevel;
    *Affinity = 1;
    return( BusInterruptLevel << VECTOR_IRQL_SHIFT );
}

BOOLEAN
HalpTranslateSystemBusAddress(
    IN PBUS_HANDLER BusHandler,
    IN PBUS_HANDLER RootHandler,
    IN PHYSICAL_ADDRESS BusAddress,
    IN OUT PULONG AddressSpace,
    OUT PPHYSICAL_ADDRESS TranslatedAddress
    )

/*++

Routine Description:

    This function translates a bus-relative address space and address into
    a system physical address.

Arguments:

    BusAddress        - Supplies the bus-relative address

    AddressSpace      -  Supplies the address space number.
                         Returns the host address space number.

                         AddressSpace == 0 => memory space
                         AddressSpace == 1 => I/O space

    TranslatedAddress - Supplies a pointer to return the translated address

Return Value:

    A return value of TRUE indicates that a system physical address
    corresponding to the supplied bus relative address and bus address
    number has been returned in TranslatedAddress.

    A return value of FALSE occurs if the translation for the address was
    not possible

--*/
{
    *TranslatedAddress = BusAddress;
    return TRUE;
}

BOOLEAN
HalpTranslateIsaBusAddress(
    IN PBUS_HANDLER BusHandler,
    IN PBUS_HANDLER RootHandler,
    IN PHYSICAL_ADDRESS BusAddress,
    IN OUT PULONG AddressSpace,
    OUT PPHYSICAL_ADDRESS TranslatedAddress
    )

/*++

Routine Description:

    This function translates a bus-relative address space and address into
    a system physical address.

Arguments:

    BusAddress        - Supplies the bus-relative address

    AddressSpace      -  Supplies the address space number.
                         Returns the host address space number.

                         AddressSpace == 0 => memory space
                         AddressSpace == 1 => I/O space

    TranslatedAddress - Supplies a pointer to return the translated address

Return Value:

    A return value of TRUE indicates that a system physical address
    corresponding to the supplied bus relative address and bus address
    number has been returned in TranslatedAddress.

    A return value of FALSE occurs if the translation for the address was
    not possible

--*/
{
    BOOLEAN     Status;

    //
    // Translated normally
    //

    Status = HalpTranslateSystemBusAddress (
                    BusHandler,
                    RootHandler,
                    BusAddress,
                    AddressSpace,
                    TranslatedAddress
                );

    return Status;
}



VOID
HalpRegisterInternalBusHandlers (
    VOID
    )
{
    PBUS_HANDLER    Bus;

    if (KeGetCurrentPrcb()->Number) {
        // only need to do this once
        return ;
    }

    //
    // Initalize BusHandler data before registering any handlers
    //

    HalpInitBusHandler ();

    //
    // Build internal-bus 0, or system level bus
    //

    Bus = HalpAllocateBusHandler (
            Internal,
            ConfigurationSpaceUndefined,
            0,                              // Internal BusNumber 0
            InterfaceTypeUndefined,         // no parent bus
            0,
            0                               // no bus specfic data
            );

    Bus->GetInterruptVector  = HalpGetSystemInterruptVector;
    Bus->TranslateBusAddress = HalpTranslateSystemBusAddress;

    //
    // Build Isa/Eisa bus #0
    //

#if 0
    Bus = HalpAllocateBusHandler (Eisa, EisaConfiguration, 0, Internal, 0, 0);
    Bus->GetBusData = HalpGetEisaData;
    Bus->GetInterruptVector = HalpGetEisaInterruptVector;
    Bus->AdjustResourceList = HalpAdjustEisaResourceList;
    Bus->TranslateBusAddress = HalpTranslateEisaBusAddress;
#endif

    Bus = HalpAllocateBusHandler (Isa, ConfigurationSpaceUndefined, 0, Internal, 0,
0);
    Bus->GetBusData = HalpNoBusData;
    Bus->TranslateBusAddress = HalpTranslateIsaBusAddress;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halssc\ia64\simperfc.c ===
/**
***  Copyright  (C) 1996-97 Intel Corporation. All rights reserved.
***
*** The information and source code contained herein is the exclusive
*** property of Intel Corporation and may not be disclosed, examined
*** or reproduced in whole or in part without explicit written authorization
*** from the company.
**/

/*++

Copyright (c) 1995  Intel Corporation

Module Name:

    simperfc.c

Abstract:

    This module implements the routines to support performance counters.

Author:

    14-Apr-1995

Environment:

    Kernel mode

Revision History:


--*/

#include "halp.h"


LARGE_INTEGER
KeQueryPerformanceCounter (
    OUT PLARGE_INTEGER PerformanceFrequency OPTIONAL
    )

/*++

Routine Description:

    This routine returns current 64-bit performance counter and,
    optionally, the Performance Frequency.

    In the simulation environment, this support is not needed.
    However, the performance monitor of the architecture may be
    used to implement this feature.

Arguments:

    PerformanceFrequency - optionally, supplies the address
    of a variable to receive the performance counter frequency.

Return Value:

    Current value of the performance counter will be returned.

--*/
{
    LARGE_INTEGER Result;

    Result.QuadPart = __getReg(CV_IA64_ApITC);
    if (ARGUMENT_PRESENT(PerformanceFrequency)) {
        PerformanceFrequency->QuadPart = 10000000; // 100ns/10MHz clock
    }

    return Result;
}

VOID
HalCalibratePerformanceCounter (
    IN volatile PLONG Number,
    IN ULONGLONG NewCount
    )

/*++

Routine Description:

    This routine resets the performance counter value for the current
    processor to zero. The reset is done such that the resulting value
    is closely synchronized with other processors in the configuration.

    In the simulation environment, the performance counter feature is
    not supported.  This routine does nothing.

Arguments:

    Number - Supplies a pointer to count of the number of processors in
    the configuration.

Return Value:

    None.

--*/
{
    *Number = 0;
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halssc\ia64\simswint.c ===
//
// No Check-in Source Code.
//
// Do not make this code available to non-Microsoft personnel
// 	without Intel's express permission
//
/**
***  Copyright  (C) 1996-97 Intel Corporation. All rights reserved.
***
*** The information and source code contained herein is the exclusive
*** property of Intel Corporation and may not be disclosed, examined
*** or reproduced in whole or in part without explicit written authorization
*** from the company.
**/

/*++

Copyright (c) 1995  Intel Corporation

Module Name:

    simswint.c

Abstract:

    This module implements the routines to support software interrupts.

Author:

    14-Apr-1995

Environment:

    Kernel mode

Revision History:

--*/

#include "halp.h"
#include "ssc.h"


VOID
FASTCALL
HalRequestSoftwareInterrupt (
    IN KIRQL RequestIrql
    )

/*++

Routine Description:

    This routine is used to request a software interrupt to the
    system. Also, this routine calls the SSC function 
    SscGenerateInterrupt() to request the simulator to deliver
    the specified interrupt.  As a result, the associated bit in
    the EIRR will be set.

Arguments:

    RequestIrql - Supplies the request IRQL value

Return Value:

    None.

--*/
{
    switch (RequestIrql) {

    case APC_LEVEL:
        SscGenerateInterrupt (SSC_APC_INTERRUPT);
        break;

    case DISPATCH_LEVEL:
        SscGenerateInterrupt (SSC_DPC_INTERRUPT);
        break;

    default:
        DbgPrint("HalRequestSoftwareInterrupt: Undefined Software Interrupt!\n");
        break;

    }
}

VOID
HalClearSoftwareInterrupt (
    IN KIRQL RequestIrql
    )

/*++

Routine Description:

    This routine is used to clear a possible pending software interrupt.
    The kernel has already cleared the corresponding bit in the EIRR.
    The support for this function is optional, depending on the external
    interrupt control.
 
Arguments:

    RequestIrql - Supplies the request IRQL value

Return Value:

    None.

--*/
{
    switch (RequestIrql) {

    case APC_LEVEL:
    case DISPATCH_LEVEL:

        //
        // Nothing to do.
        //

        break;

    default:

        DbgPrint("HalClearSoftwareInterrupt: Undefined Software Interrupt!\n");
        break;

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halssc\ia64\simsxint.c ===
//
// No Check-in Source Code.
//
// Do not make this code available to non-Microsoft personnel
// 	without Intel's express permission
//
/**
***  Copyright  (C) 1996-97 Intel Corporation. All rights reserved.
***
*** The information and source code contained herein is the exclusive
*** property of Intel Corporation and may not be disclosed, examined
*** or reproduced in whole or in part without explicit written authorization
*** from the company.
**/

/*++

Copyright (c) 1995  Intel Corporation

Module Name:

    simsxint.c

Abstract:

    This module implements the routines to manage the 
    system interrupt and IRQL.

Author:

    William K. Cheung (wcheung) 14-Apr-1995

Environment:

    Kernel mode

Revision History:


--*/

#include "halp.h"


PULONGLONG HalEOITable[256];


VOID
HalpInitEOITable(
    VOID
)
{
USHORT Index;

    for (Index=0; Index < 256; Index++) {
        HalEOITable[Index] = 0;
    }
}

VOID
HalpInitializeInterrupts (
    VOID 
    )
{
    ULONG Index;
    ULONG InterruptVector;

    //
    // Interrupt routine table initialization in KiInitializeKernel.
    //

    //
    // interval timer interrupt; 10ms by default
    //

    InterruptVector = CLOCK_LEVEL << VECTOR_IRQL_SHIFT;
    PCR->InterruptRoutine[InterruptVector] = (PKINTERRUPT_ROUTINE)HalpClockInterrupt;

    SscConnectInterrupt(SSC_CLOCK_TIMER_INTERRUPT, InterruptVector);
    SscSetPeriodicInterruptInterval(
        SSC_CLOCK_TIMER_INTERRUPT,
        DEFAULT_CLOCK_INTERVAL * 100
        );

    //
    // profile timer interrupt; turned off initially
    //

    InterruptVector = PROFILE_LEVEL << VECTOR_IRQL_SHIFT;
    PCR->InterruptRoutine[InterruptVector] = (PKINTERRUPT_ROUTINE)HalpProfileInterrupt;

    SscConnectInterrupt(SSC_PROFILE_TIMER_INTERRUPT, InterruptVector);
    SscSetPeriodicInterruptInterval (SSC_PROFILE_TIMER_INTERRUPT, 0);

    //
    // s/w interrupts; corresponding ISRs provided by kernel.
    //

    SscConnectInterrupt (SSC_APC_INTERRUPT, APC_VECTOR);
    SscConnectInterrupt (SSC_DPC_INTERRUPT, DISPATCH_VECTOR);
}

BOOLEAN
HalEnableSystemInterrupt (
    IN ULONG Vector,
    IN KIRQL Irql,
    IN KINTERRUPT_MODE InterruptMode
    )

/*++

Routine Description:

    This routine enables the specified system interrupt.

    N.B. This routine assumes that the caller has provided any required
         synchronization to enable a system interrupt.

Arguments:

    Vector - Supplies the vector of the system interrupt that is enabled.

    Irql - Supplies the IRQL of the interrupting source.

    InterruptMode - Supplies the mode of the interrupt; LevelSensitive or
                    Latched.

Return Value:

    TRUE if the system interrupt was enabled

--*/

{
    KIRQL OldIrql;
    BOOLEAN Result = TRUE;

    //
    // Raise IRQL to the highest level.
    //

    KeRaiseIrql (HIGH_LEVEL, &OldIrql);

    switch (Irql) {

    case DISK_IRQL:
        SscConnectInterrupt (SSC_DISK_INTERRUPT, Vector);
        break;

    case MOUSE_IRQL:
        SscConnectInterrupt (SSC_MOUSE_INTERRUPT, Vector);
        break;

    case KEYBOARD_IRQL:
        SscConnectInterrupt (SSC_KEYBOARD_INTERRUPT, Vector);
        break;

    case SERIAL_IRQL:
        SscConnectInterrupt (SSC_SERIAL_INTERRUPT, Vector);
        break;

    default:
        //
        // Invalid Device Interrupt Source; only three devices 
        // defined in the Gambit platform.
        //
        Result = FALSE;
        DbgPrint("HalEnableSystemInterrupt: Invalid Device Interrupt Source");
        break;
    }

    //
    // Restore the original IRQL
    //

    KeLowerIrql (OldIrql);
	
    return (Result);
}

VOID
HalDisableSystemInterrupt (
    IN ULONG Vector,
    IN KIRQL Irql
    )

/*++

Routine Description:

    This routine disables the specified system interrupt.

    In the simulation environment, this function does nothing and returns.

    N.B. This routine assumes that the caller has provided any required
        synchronization to disable a system interrupt.

Arguments:

    Vector - Supplies the vector of the system interrupt that is disabled.

    Irql - Supplies the IRQL of the interrupting source.

Return Value:

    None.

--*/

{
    return;
}

ULONG
HalGetInterruptVector(
    IN INTERFACE_TYPE InterfaceType,
    IN ULONG BusNumber,
    IN ULONG BusInterruptLevel,
    IN ULONG BusInterruptVector,
    OUT PKIRQL Irql,
    OUT PKAFFINITY Affinity
    )

/*++

Routine Description:

    This function returns the system interrupt vector and IRQL level
    corresponding to the specified bus interrupt level and/or vector. The
    system interrupt vector and IRQL are suitable for use in a subsequent call
    to KeInitializeInterrupt.

    In the simulation environment, just return the parameters passed in 
    from the caller - the device driver.

Arguments:

    InterfaceType - Supplies the type of bus which the vector is for.

    BusNumber - Supplies the bus number for the device.

    BusInterruptLevel - Supplies the bus specific interrupt level.

    BusInterruptVector - Supplies the bus specific interrupt vector.

    Irql - Returns the system request priority.

    Affinity - Returns the affinity for the requested vector

Return Value:

    Returns the system interrupt vector corresponding to the specified device.

--*/

{
    //
    // Just return the passed parameters.
    //

    *Irql = (KIRQL) BusInterruptLevel;
    *Affinity = 1;
    return( BusInterruptLevel << VECTOR_IRQL_SHIFT );

}

BOOLEAN
HalBeginSystemInterrupt(
    IN KIRQL Irql,
    IN CCHAR Vector,
    OUT PKIRQL OldIrql
    )

/*++

Routine Description:

    This routine raises the IRQL to the level of the specified
    interrupt vector.  It is called by the hardware interrupt
    handler before any other interrupt service routine code is
    executed.  The CPU interrupt flag is set on exit.

Arguments:

    Irql   - Supplies the IRQL to raise to

    Vector - Supplies the vector of the interrupt to be
             dismissed

    OldIrql- Location to return OldIrql

Return Value:

    TRUE - Interrupt successfully dismissed and Irql raised.
           This routine cannot fail.

--*/

{
    return (TRUE);
}

VOID
HalEndSystemInterrupt (
   IN KIRQL NewIrql,
   IN ULONG Vector
   )

/*++

Routine Description:

    This routine is used to lower IRQL to the specified value.
    The IRQL and PIRQL will be updated accordingly.

    NOTE: This routine simulates software interrupt as long as
          any pending SW interrupt level is higher than the current
          IRQL, even when interrupts are disabled.

Arguments:

    NewIrql - the new irql to be set.

    Vector - Vector number of the interrupt

Return Value:

    None.

--*/

{
    return;
}


//
// Almost all of the last 4MB of virtual memory address range are available
// to the HAL to map physical memory.   The kernel may use some of these
// PTEs for special purposes.
//
//
// The kernel now uses one PTE in this
// area to map the area from which interrupt messages are to be retrieved.
//


#define HAL_VA_START  0xffd00000

PVOID HalpHeapStart=(PVOID)(KADDRESS_BASE+HAL_VA_START);


PVOID
HalMapPhysicalMemory(
    IN PHYSICAL_ADDRESS PhysicalAddress,
    IN ULONG NumberPages
    )

/*++

Routine Description:

    This routine maps physical memory into the area of virtual memory
    reserved for the HAL.  It does this by directly inserting the PTE
    into the Page Table which the OS Loader has provided.

    N.B.  This routine does *NOT* update the MemoryDescriptorList.  The
          caller is responsible for either removing the appropriate
          physical memory from the list, or creating a new descriptor to
          describe it.

Arguments:

    PhysicalAddress - Supplies the physical address of the start of the
                      area of physical memory to be mapped.

    NumberPages - Supplies the number of pages contained in the area of
                  physical memory to be mapped.

Return Value:

    PVOID - Virtual address at which the requested block of physical memory
            was mapped

    NULL - The requested block of physical memory could not be mapped.

--*/

{
    PHARDWARE_PTE PTE;
    ULONG PagesMapped;
    PVOID VirtualAddress;

    //
    // The OS Loader sets up hyperspace for us, so we know that the Page
    // Tables are magically mapped starting at V.A. 0xC0000000.
    //

    PagesMapped = 0;
    while (PagesMapped < NumberPages) {
        //
        // Look for enough consecutive free ptes to honor mapping
        //

        PagesMapped = 0;
        VirtualAddress = HalpHeapStart;

        while (PagesMapped < NumberPages) {
            PTE=MiGetPteAddress(VirtualAddress);
            if (*(PULONGLONG)PTE != 0) {

                //
                // Pte is not free, skip up to the next pte and start over
                //

                HalpHeapStart = (PVOID) ((ULONG_PTR)VirtualAddress + PAGE_SIZE);
                break;
            }
            VirtualAddress = (PVOID) ((ULONG_PTR)VirtualAddress + PAGE_SIZE);
            PagesMapped++;
        }

    }

    PagesMapped = 0;
    VirtualAddress = (PVOID) ((ULONG_PTR) HalpHeapStart | BYTE_OFFSET (PhysicalAddress.QuadPart));
    while (PagesMapped < NumberPages) {
        PTE=MiGetPteAddress(HalpHeapStart);

        PTE->PageFrameNumber = (PhysicalAddress.QuadPart >> PAGE_SHIFT);
        PTE->Valid = 1;
        PTE->Write = 1;

//  TBD    PTE->MemAttribute = 0;

        PhysicalAddress.QuadPart = PhysicalAddress.QuadPart + PAGE_SIZE;
        HalpHeapStart   = (PVOID)((ULONG_PTR)HalpHeapStart + PAGE_SIZE);

        ++PagesMapped;
    }

    return(VirtualAddress);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halssc\ia64\simtimer.c ===
//
// No Check-in Source Code.
//
// Do not make this code available to non-Microsoft personnel
// 	without Intel's express permission
//
/**
***  Copyright  (C) 1996-97 Intel Corporation. All rights reserved.
***
*** The information and source code contained herein is the exclusive
*** property of Intel Corporation and may not be disclosed, examined
*** or reproduced in whole or in part without explicit written authorization
*** from the company.
**/

/*++

Copyright (c) 1995  Intel Corporation

Module Name:

    simtimer.c

Abstract:

    This module implements the routines to provide timer (both
    interval and profile) interrupt support.

Author:

    14-Apr-1995

Environment:

    Kernel mode

Revision History:


--*/

#include "halp.h"
#include <ssc.h>


ULONGLONG 
    HalpUpdateITM(
    IN ULONGLONG HalpClockCount
    );

ULONG
HalpSetTimeIncrement (
    IN ULONG DesiredIncrement
    );

__declspec(dllimport)
BOOLEAN
KdPollBreakIn(
    VOID
    );

ULONGLONG HalpPerformanceFrequency;

static ULONGLONG HalpClockCount;
static ULONG   HalpCurrentTimeIncrement = DEFAULT_CLOCK_INTERVAL;
static ULONG   HalpNextTimeIncrement = DEFAULT_CLOCK_INTERVAL;
static ULONG   HalpNewTimeIncrement  = DEFAULT_CLOCK_INTERVAL;
#define GAMBIT 1
#ifdef GAMBIT
ULONG   HalpKdPollDelayCount = 0;
#endif

static ULONG_PTR   HalpProfileInterval = (ULONG_PTR)DEFAULT_PROFILE_INTERVAL;
static BOOLEAN    HalpProfileStopped = TRUE;


ULONG
HalSetTimeIncrement (
    IN ULONG DesiredIncrement
    )

/*++

Routine Description:

    This routine initialize system time clock to generate an
    interrupt at every DesiredIncrement interval.  It calls the
    SSC function SscSetPeriodicInterruptInterval to set the new
    interval.  The new interval takes effect after the next timer
    interval interrupt is deliverd.

Arguments:

    DesiredIncrement - desired interval between every timer tick (in 100ns unit.)

Return Value:

    The time increment set.

--*/

{
    SscSetPeriodicInterruptInterval (
        SSC_CLOCK_TIMER_INTERRUPT,
        100 * DesiredIncrement
        );
    HalpNextTimeIncrement = DesiredIncrement;
    HalpSetTimeIncrement(DesiredIncrement);
    return DesiredIncrement;
}

VOID
HalStartProfileInterrupt(
    IN KPROFILE_SOURCE ProfileSource
    )

/*++

Routine Description:

    This routine calls SscSetPeriodicInterruptInterval to request
    the simulator to send profile timer interrupt to the OS at the
    interval specified by HalpProfileInterval.

    It also sets HalpProfileStopped to FALSE.

Arguments:

    Reserved

Return Value:

    Returns nothing.

--*/

{
    SscSetPeriodicInterruptInterval (
        SSC_PROFILE_TIMER_INTERRUPT,
        100 * (ULONG)HalpProfileInterval
        );
    HalpProfileStopped = FALSE;
}

VOID
HalStopProfileInterrupt(
    IN KPROFILE_SOURCE ProfileSource
    )

/*++

Routine Description:

    What we do here is change the interrupt interval to 0. 
    Essentially, the simulator stop sending profile timer 
    interrupts to the OS.

    It also sets HalpProfileStopped to TRUE.

Arguments:

    Reserved

Return Value:

    Returns nothing.

--*/

{
    SscSetPeriodicInterruptInterval (SSC_PROFILE_TIMER_INTERRUPT, 0);
    HalpProfileStopped = TRUE;
}

ULONG_PTR
HalSetProfileInterval(
    IN ULONG_PTR Interval
    )

/*++

Routine Description:

    This procedure sets the interrupt rate (and thus the sampling
    interval) for the profiling interrupt.

    If profiling is active (HalpProfileStopped == FALSE), the SSC
    function SscSetPeriodicInterruptInterval is called to set the
    new profile timer interrupt interval.

    Otherwise, a simple rate validation computation is done.

Arguments:

    Interval - Time interval in 100ns units.

Return Value:

    Time interval actually used by the system.

--*/

{

    //
    // If the specified profile interval is less that the minimum profile
    // interval or greater than the maximum profile interval, then set the
    // profile interval to the minimum or maximum as appropriate.
    //

    //
    // Check to see if the Desired Interval is reasonable, if not adjust it.
    // We can probably remove this check once we've verified everything works
    // as anticipated.
    //
    
    if (Interval > MAXIMUM_PROFILE_INTERVAL) {
        HalpProfileInterval = MAXIMUM_PROFILE_INTERVAL;
    } else if (Interval < MINIMUM_PROFILE_INTERVAL) {   
        HalpProfileInterval = MINIMUM_PROFILE_INTERVAL;
    } else {
        HalpProfileInterval = Interval;
    }

    //
    // Profiling is active.  Make the new interrupt interval effective.
    //

    if (!HalpProfileStopped) {
        SscSetPeriodicInterruptInterval (
            SSC_PROFILE_TIMER_INTERRUPT, 
            100 * (ULONG)HalpProfileInterval
            );
    }

    return HalpProfileInterval;
}

VOID 
HalpClockInterrupt (
    IN PKINTERRUPT_ROUTINE Interrupt,
    IN PKTRAP_FRAME TrapFrame
    )

/*++

Routine Description:

    System Clock Interrupt Handler, for P0 processor only.
    
    N.B. Assumptions: Comes with IRQL set to CLOCK_LEVEL to disable
         interrupts. 

Arguments:

    TrapFrame - Trap frame address.

Return Value:

    None.

--*/

{
    //
    // Call the kernel to update system time.
    //  P0 updates System time and Run Time.
    //
    
    KeUpdateSystemTime(TrapFrame,HalpCurrentTimeIncrement);

    HalpCurrentTimeIncrement = HalpNextTimeIncrement;

    HalpNextTimeIncrement    = HalpNewTimeIncrement;

    //
    // Increment ITM, accounting for interrupt latency.
    //

    HalpUpdateITM(HalpClockCount);

#ifdef GAMBIT
    if (!HalpKdPollDelayCount) {
        HalpKdPollDelayCount = 4;
#endif
    if ( KdDebuggerEnabled && KdPollBreakIn() )
       KeBreakinBreakpoint();
#ifdef GAMBIT
    } else {
        HalpKdPollDelayCount--;
    }
#endif

}

VOID 
HalpClockInterruptPn (
    IN PKINTERRUPT_ROUTINE Interrupt,
    IN PKTRAP_FRAME TrapFrame
    )

/*++

Routine Description:

    System Clock Interrupt Handler, for processors other than P0.
    
    N.B. Assumptions: Comes with IRQL set to CLOCK_LEVEL to disable
         interrupts. 

Arguments:

    TrapFrame - Trap frame address.

Return Value:

    None.

--*/

{
    //
    // Call the kernel to update run time.
    //  Pn updates only Run time. 
    //

    KeUpdateRunTime(TrapFrame);

    //
    // Increment ITM, accounting for interrupt latency.
    //

    HalpUpdateITM(HalpClockCount);

}

VOID 
HalpProfileInterrupt (
    IN PKTRAP_FRAME TrapFrame
    )

/*++

Routine Description:

    System Profile Interrupt Handler.

Arguments:

    TrapFrame - Trap frame address.

Return Value:

    None.

--*/

{
//    KeProfileInterrupt (TrapFrame);
}

ULONG
HalpSetTimeIncrement (
    IN ULONG DesiredIncrement
    )

/*++

Routine Description:

    This function is called to set the clock interrupt rate to the frequency
    required by the specified time increment value.

    N.B. This function is only executed on the processor that keeps the
         system time.
         
         This function should eventually become the HalSetTimeIncrement once 
         we actually start using the ITC/ITM. Not currently supported by the
         simulator.

Arguments:

    DesiredIncrement - Supplies desired number of 100ns units between clock
        interrupts.

Return Value:

    The actual time increment in 100ns units.

--*/

{
    ULONGLONG NextIntervalCount;
    KIRQL     OldIrql;

    //
    // DesiredIncrement must map within the acceptable range.
    //
    if (DesiredIncrement < MINIMUM_CLOCK_INTERVAL)
        DesiredIncrement = MINIMUM_CLOCK_INTERVAL;
    else if (DesiredIncrement > MAXIMUM_CLOCK_INTERVAL)    
             DesiredIncrement = MAXIMUM_CLOCK_INTERVAL;
    
    //
    // Raise IRQL to the highest level, set the new clock interrupt
    // parameters, lower IRQl, and return the new time increment value.
    //

    KeRaiseIrql(HIGH_LEVEL, &OldIrql);

    //
    // Calculate the actual 64 bit time value which forms the target interval.
    // The resulting value is added to the ITC to form the new ITM value.
    // HalpPerformanceFrequency is the calibrated value for the ITC whose value
    // works out to be 100ns (or as close as we can come).
    //
        
    NextIntervalCount = HalpPerformanceFrequency * DesiredIncrement;

    //
    // Calculate the number of 100ns units to report to the kernel every
    // time the ITM matches the ITC with this new period.  Note, for small
    // values of DesiredIncrement (min being 10000, ie 1ms), truncation
    // in the above may result in a small decrement in the 5th decimal
    // place.  As we are effectively dealing with a 4 digit number, eg
    // 10000 becomes 9999.something, we really can't do any better than
    // the following.
    //

    HalpClockCount = NextIntervalCount;
    HalpNewTimeIncrement = DesiredIncrement;
    KeLowerIrql(OldIrql);
    return DesiredIncrement;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halsym\sources.inc ===
TARGETTYPE=NOTARGET
TARGETPATH=obj

INCLUDES=\
    ..;\
    $(DDK_INC_PATH)\wdm; \
    $(PROJECT_ROOT)\ntos\inc;\
    $(PROJECT_ROOT)\hals\inc; \
    $(DDK_INC_PATH);\
    $(HALKIT_INC_PATH)

!IF $(386)
INCLUDES=$(INCLUDES);\
         $(PROJECT_ROOT)\hals\halx86\i386;
!ENDIF

!IF $(IA64)
INCLUDES=$(INCLUDES);\
         $(PROJECT_ROOT)\hals\halia64\ia64;
!ENDIF

SOURCES=..\halsym.c

SOURCES_USED=..\sources.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halsym\halsym.c ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    halsym.c

--*/

#include "nthal.h"
#include "acpitabl.h"
#ifdef _X86_
#include "pcmp.inc"
#include "ntapic.inc"
#include "halp.h"
#include "ixisa.h"
#endif
#ifdef _IA64_
#include "halp.h"
#include "i64fw.h"
#include "mce.h"
#endif


#ifdef _X86_
ADAPTER_OBJECT                      a1;
#endif
CONTROLLER_OBJECT                   c1;
DESCRIPTION_HEADER                  descriptionheader;
FADT                                fadt;
RSDP                                rsdp;
FACS                                facs;
RSDT                                rsdt;
GEN_ADDR                            genaddr;
LARGE_INTEGER                       largeinteger;
MAPIC                               mapic;
PROCLOCALAPIC                       proclocalapic;
IOAPIC                              ioapic;
ISA_VECTOR                          isavector;
IO_NMISOURCE                        ionmisource;
LOCAL_NMISOURCE                     localnmisource;
PROCLOCALSAPIC                      proclocalsapic;
IOSAPIC                             iosapic;
PLATFORM_INTERRUPT                  platforminterrupt;

#ifdef _IA64_

// Stuff needed for the !MCA extension

ERROR_DEVICE_GUID                   errordeviceguid;
ERROR_SEVERITY_VALUE                errorseverityvalue;
ERROR_CACHE_CHECK                   errorcachecheck;
ERROR_TLB_CHECK                     errortlbcheck;
ERROR_BUS_CHECK                     errorbuscheck;
ERROR_REGFILE_CHECK                 errorregfilecheck;
ERROR_MS_CHECK                      errormscheck;
ERROR_MODINFO_VALID                 errormodinfovalid;
ERROR_MODINFO                       errormodinfo;
ERROR_PROCESSOR_STATIC_INFO_VALID   errorprocessorstaticinfovalid;
ERROR_PROCESSOR_STATIC_INFO         errorprocessorstaticinfo;
PAL_MINI_SAVE_AREA                  palminisavearea;
ERROR_PROCESSOR                     errorprocessor;
ERROR_PROCESSOR_CPUID_INFO          errorprocessorcpuidinfo;
ERROR_PROCESSOR_STATIC_INFO         errorprocessorstaticinfo;
ERROR_OEM_DATA                      erroroemdata;
ERROR_PLATFORM_SPECIFIC             errorplatformspecific;
ERROR_MEMORY                        errormemory;
ERROR_PCI_COMPONENT                 errorpcicomponent;
ERROR_PCI_BUS                       errorpcibus;
ERROR_PLATFORM_BUS                  errorplatformbus;
ERROR_SYSTEM_EVENT_LOG              errorsystemeventlog;
ERROR_PLATFORM_HOST_CONTROLLER      errorplatformhostcontroller;
ERROR_RECORD_HEADER                 errorrecordheader;
ERROR_SECTION_HEADER                errorsectionheader;
HALP_SAL_PAL_DATA                   halpsalpaldata;
HALP_FEATURE                        halpfeature;
ERROR_PCI_COMPONENT_VALID           errorpcicomponentvalid;
ERROR_PLATFORM_SPECIFIC_VALID       errorplatformspecificvalid;

#endif  // ifdef _IA64_

#ifdef _X86_
struct HalpMpInfo                   halpMpInfoTable;
#endif

int cdecl main() {
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halssc\ia64\x86bios.c ===
//
// No Check-in Source Code.
//
// Do not make this code available to non-Microsoft personnel
// 	without Intel's express permission
//
/**
***  Copyright  (C) 1996-97 Intel Corporation. All rights reserved.
***
*** The information and source code contained herein is the exclusive
*** property of Intel Corporation and may not be disclosed, examined
*** or reproduced in whole or in part without explicit written authorization
*** from the company.
**/

/*++

Copyright (c) 1996  Intel Corporation
Copyright (c) 1994  Microsoft Corporation

Module Name:

    x86bios.c

Abstract:


    This module implements the platform specific interface between a device
    driver and the execution of x86 ROM bios code for the device.

Author:

    William K. Cheung (wcheung) 20-Mar-1996

    based on the version by David N. Cutler (davec) 17-Jun-1994

Environment:

    Kernel mode only.

Revision History:

--*/

#include "halp.h"

//
// Define global data.
//

ULONG HalpX86BiosInitialized = FALSE;
ULONG HalpEnableInt10Calls = FALSE;

BOOLEAN
HalCallBios (
    IN ULONG BiosCommand,
    IN OUT PULONG Eax,
    IN OUT PULONG Ebx,
    IN OUT PULONG Ecx,
    IN OUT PULONG Edx,
    IN OUT PULONG Esi,
    IN OUT PULONG Edi,
    IN OUT PULONG Ebp
    )

/*++

Routine Description:

    This function provides the platform specific interface between a device
    driver and the execution of the x86 ROM bios code for the specified ROM
    bios command.

Arguments:

    BiosCommand - Supplies the ROM bios command to be emulated.

    Eax to Ebp - Supplies the x86 emulation context.

Return Value:

    A value of TRUE is returned if the specified function is executed.
    Otherwise, a value of FALSE is returned.

--*/

{

    CONTEXT86 Context;

    //
    // If the x86 BIOS Emulator has not been initialized, then return FALSE.
    //

    if (HalpX86BiosInitialized == FALSE) {
        return FALSE;
    }

    //
    // If the Video Adapter initialization failed and an Int10 command is
    // specified, then return FALSE.
    //

    if ((BiosCommand == 0x10) && (HalpEnableInt10Calls == FALSE)) {
        return FALSE;
    }

    //
    // Copy the x86 bios context and emulate the specified command.
    //

    Context.Eax = *Eax;
    Context.Ebx = *Ebx;
    Context.Ecx = *Ecx;
    Context.Edx = *Edx;
    Context.Esi = *Esi;
    Context.Edi = *Edi;
    Context.Ebp = *Ebp;

#if 0
    if (x86BiosExecuteInterrupt((UCHAR)BiosCommand,
                                &Context,
                                (PVOID)HalpIoControlBase,
                                (PVOID)HalpIoMemoryBase) != XM_SUCCESS) {
        return FALSE;
    }
#endif

    //
    // Copy the x86 bios context and return TRUE.
    //

    *Eax = Context.Eax;
    *Ebx = Context.Ebx;
    *Ecx = Context.Ecx;
    *Edx = Context.Edx;
    *Esi = Context.Esi;
    *Edi = Context.Edi;
    *Ebp = Context.Ebp;
    return TRUE;
}

VOID
HalpInitializeX86DisplayAdapter(
    VOID
    )

/*++

Routine Description:

    This function initializes a display adapter using the x86 bios emulator.

Arguments:

    None.

Return Value:

    None.

--*/

{

#if 0
    //
    // If I/O Ports or I/O memory could not be mapped, then don't
    // attempt to initialize the display adapter.
    //

    if (HalpIoControlBase == NULL || HalpIoMemoryBase == NULL) {
        return;
    }

    //
    // Initialize the x86 bios emulator.
    //

    x86BiosInitializeBios(HalpIoControlBase, HalpIoMemoryBase);
    HalpX86BiosInitialized = TRUE;

    //
    // Attempt to initialize the display adapter by executing its ROM bios
    // code. The standard ROM bios code address for PC video adapters is
    // 0xC000:0000 on the ISA bus.
    //

    if (x86BiosInitializeAdapter(0xc0000,
                                 NULL,
                                 (PVOID)HalpIoControlBase,
                                 (PVOID)HalpIoMemoryBase) != XM_SUCCESS) {



        HalpEnableInt10Calls = FALSE;
        return;
    }
#endif

    HalpEnableInt10Calls = TRUE;
    return;
}

VOID
HalpResetX86DisplayAdapter(
    VOID
    )

/*++

Routine Description:

    This function resets a display adapter using the x86 bios emulator.

Arguments:

    None.

Return Value:

    None.

--*/

{

    CONTEXT86 Context;

    //
    // Initialize the x86 bios context and make the INT 10 call to initialize
    // the display adapter to 80x25 color text mode.
    //

    Context.Eax = 0x0003;  // Function 0, Mode 3
    Context.Ebx = 0;
    Context.Ecx = 0;
    Context.Edx = 0;
    Context.Esi = 0;
    Context.Edi = 0;
    Context.Ebp = 0;

    HalCallBios(0x10,
                &Context.Eax,
                &Context.Ebx,
                &Context.Ecx,
                &Context.Edx,
                &Context.Esi,
                &Context.Edi,
                &Context.Ebp);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halx86\i386\halnls.h ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    halnls.h

Abstract:

    Strings which are used in the HAL

    English

--*/

#define MSG_HARDWARE_ERROR1     "\n*** Hardware Malfunction\n\n"
#define MSG_HARDWARE_ERROR2     "Call your hardware vendor for support\n\n"
#define MSG_HALT                "\n*** The system has halted ***\n"
#define MSG_NMI_PARITY          "NMI: Parity Check / Memory Parity Error\n"
#define MSG_NMI_CHANNEL_CHECK   "NMI: Channel Check / IOCHK\n"
#define MSG_NMI_FAIL_SAFE       "NMI: Fail-safe timer\n"
#define MSG_NMI_BUS_TIMEOUT     "NMI: Bus Timeout\n"
#define MSG_NMI_SOFTWARE_NMI    "NMI: Software NMI generated\n"
#define MSG_NMI_EISA_IOCHKERR   "NMI: Eisa IOCHKERR board %\n"

#define MSG_DEBUG_ENABLE        "Kernel Debugger Using: COM%x (Port 0x%x, Baud Rate %d)\n"
#define MSG_DEBUG_9600          "Switching debugger to 9600 baud\n"
#define MSG_MCE_PENDING         "Machine Check Exception pending, MCE exceptions not enabled\n"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halsym\acpiupapic\makefile.inc ===
$(O)\halaacpi.c : ..\halsym.c    
    $(CXX_COMPILER_NAME) @<<$(CL_RSP) /E $** > $@
$(CXX_COMPILER_FLAGS: =
)
<<NOKEEP
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halsym\mpsup\makefile.inc ===
$(O)\halapic.c : ..\halsym.c    
    $(CXX_COMPILER_NAME) @<<$(CL_RSP) /E $** > $@
$(CXX_COMPILER_FLAGS: =
)
<<NOKEEP
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halsym\halia64\makefile.inc ===
$(O)\hal.c : ..\halsym.c    
    $(CXX_COMPILER_NAME) @<<$(CL_RSP) /E $** > $@
$(CXX_COMPILER_FLAGS: =
)
<<NOKEEP
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halsym\mpsmp\makefile.inc ===
$(O)\halmps.c : ..\halsym.c    
    $(CXX_COMPILER_NAME) @<<$(CL_RSP) /E $** > $@
$(CXX_COMPILER_FLAGS: =
)
<<NOKEEP
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halsym\acpiuppic\makefile.inc ===
$(O)\halacpi.c : ..\halsym.c    
    $(CXX_COMPILER_NAME) @<<$(CL_RSP) /E $** > $@
$(CXX_COMPILER_FLAGS: =
)
<<NOKEEP
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halsym\acpimpapic\makefile.inc ===
$(O)\halmacpi.c : ..\halsym.c    
    $(CXX_COMPILER_NAME) @<<$(CL_RSP) /E $** > $@
$(CXX_COMPILER_FLAGS: =
)
<<NOKEEP
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halx86\i386\ixcmos.asm ===
title  "Cmos Access Routines"
;++
;
; Module Name:
;
;    ixcmos.asm
;
; Abstract:
;
;    Procedures necessary to access CMOS/ECMOS information.
;
; Author:
;
;    David Risner (o-ncrdr) 20 Apr 1992
;
; Revision History:
;
;    Landy Wang (corollary!landy) 04 Dec 1992
;    - Move much code from ixclock.asm to here so different HALs
;      can reuse the common functionality.
;
;--

.386p
        .xlist
include hal386.inc
include callconv.inc                    ; calling convention macros
include mac386.inc
include i386\ix8259.inc
include i386\ixcmos.inc
        .list

        EXTRNP  _DbgBreakPoint,0,IMPORT
        extrn   _HalpSystemHardwareLock:DWORD
        extrn   _HalpBusType:DWORD
        extrn   _HalpSerialLen:BYTE
        extrn   _HalpSerialNumber:BYTE

_DATA   SEGMENT  DWORD PUBLIC 'DATA'

;
; HalpRebootNow is a reboot vector.  Set in an MP system, to
; cause any processors which may be looping in HalpAcquireCmosSinLock
; to transfer control to the vector in HalpRebootNow
;

    public  _HalpRebootNow
_HalpRebootNow           dd      0

;
; Holds the value of the eflags register before a cmos spinlock is
; acquired (used in HalpAcquire/ReleaseCmosSpinLock().
;
_HalpHardwareLockFlags   dd      0

;
; Holds the offset to CMOS Century information.
;

    public _HalpCmosCenturyOffset
_HalpCmosCenturyOffset   dd      0

_DATA   ends

        subttl  "HalpGetCmosData"

;++
;
; CMOS space read and write functions.
;
;--

CmosAddressPort         equ     70H
CmosDataPort            equ     71H

ECmosAddressLsbPort     equ     74H
ECmosAddressMsbPort     equ     75H
ECmosDataPort           equ     76H


INIT    SEGMENT DWORD PUBLIC 'CODE'
        ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING

ifndef ACPI_HAL
;++
;
;   VOID
;   HalpInitializeCmos(
;       VOID
;       )
;
;   This routine reads CMOS and initializes globals required for
;   CMOS access, such as the location of the century byte.
;
;--

cPublicProc _HalpInitializeCmos,0

        push    ebx
        push    esi
        push    edi

;
; Assume default
;

        mov     eax, RTC_OFFSET_CENTURY
        mov     _HalpCmosCenturyOffset, eax

        cmp     _HalpBusType, MACHINE_TYPE_ISA
        jne     icm40


;
; If control comes here, this is ISA machine.  We need to check if this is
; IBM PS/1 or Pc/ValuePoint machine and use RTC_CENTURY_OFFSET_MCA to get
; Century byte from CMOS.
;

;
; Check if the CMOS 2e and 2f contains memory checksum.  On PS/1 machine
; the check should fail.
;

icm20:  mov     ecx, 2dh                ; from 10h to 2dh
        mov     eax, 0                  ; clear ax
        mov     edx, 0

icm30:  mov     al, cl
        CMOS_READ
        add     edx, eax
        dec     ecx
        cmp     ecx, 0fh
        jne     short icm30

        mov     eax, 2eh
        CMOS_READ
        mov     ah, al
        mov     al, 2fh
        CMOS_READ
        cmp     eax, edx
        je      short icm50             ; NOT PS/1

        mov     eax, RTC_OFFSET_CENTURY_MCA
        mov     _HalpCmosCenturyOffset, eax
        jmp     icm90

icm40:  cmp     _HalpBusType, MACHINE_TYPE_MCA
        jne     short icm50

;
; See if this is a P700 MCA machine
;

        in      al, 07fh                        ; get PD700 ID byte
        and     al, 0F0h                        ; Mask high nibble
        cmp     al, 0A0h                        ; Is the ID Ax?
        jz      short icm50
        cmp     al, 090h                        ; Or an 9X?
        jz      short icm50                     ; Yes, it's a 700

        mov     eax, RTC_OFFSET_CENTURY_MCA
        mov     _HalpCmosCenturyOffset, eax

icm50:

if 0

    - Selecting BANK1 causes some devices to mess up their month value
    - For now, I'm removing this code until this problem can be solved

;
; See if this is a Dallas Semiconductor DS17285 or later
; Switch to BANK 1
;
        mov     al, 0Ah
        CMOS_READ

        and     al, 7fh                         ; Don't write UIP
        mov     ah, al
        mov     esi, eax                        ; save it for restore
        or      ah, 10h                         ; Set DV0 = 1

        mov     al, 0Ah                         ; Write register A
        CMOS_WRITE

;
; Check for RTC serial # with matching crc
; (al)  = current byte
; (ah)  = scratch register
; (bl)  = current crc
; (bh)  = zero, non-zero, flag
; (ecx) = cmos offset
; (edx) = used by cmos_read macro
; (esi) = saved register 0A
;
        mov     ecx, 40h
        xor     ebx, ebx

icm60:  mov     al, cl
        CMOS_READ
        mov     byte ptr _HalpSerialNumber+2+-40h[ecx], al

        or      bh, al                  ; or to check for all zeros

        mov     ch, 8                   ; Bits per byte

icm65:  mov     ah, bl                  ; ah = crc
        xor     ah, al                  ; xor LSb
        shr     bl, 1                   ; shift crc
        shr     ah, 1                   ; mov LSb to carry
        sbb     ah, ah                  ; if carry set 1's else 0's
        and     ah, (118h shr 1)        ; crc polynomial
        xor     bl, ah                  ; apply it

        shr     al, 1                   ; next bit
        dec     ch                      ;
        jnz     short icm65             ; if ch non-zero, loop

        inc     cl                      ; next cmos location
        cmp     cl, 48h                 ; at end?
        jne     short icm60             ; no, loop
;
; (bh) = zero, non-zero flag
; (bl) = crc
;

        mov     eax, RTC_OFFSET_CENTURY_DS      ; Read century byte
        CMOS_READ

        BCD_TO_BIN
        movzx   ecx, ax                         ; save it

;
; Switch back to BANK 0
;

        mov     eax, esi
        mov     al, 0Ah
        CMOS_WRITE

;
; Check for valid DS data
;
        cmp     bh, 0                           ; Was data all zeros?
        je      short icm90

        cmp     bl, 0                           ; was CRC valid?
        jnz     short icm90

        cmp     ecx, 19                         ; Is century before 19?
        jb      short icm90

        cmp     ecx, 20                         ; Is century after 20?
        ja      short icm90

;
; Setup for DS century byte
;
        mov     byte ptr _HalpSerialNumber+0, 'D'
        mov     byte ptr _HalpSerialNumber+1, 'S'
        mov     _HalpSerialLen, 10

        mov     eax, RTC_OFFSET_CENTURY_DS
        mov     _HalpCmosCenturyOffset, eax
endif

icm90:  pop     edi
        pop     esi
        pop     ebx
        stdRET  _HalpInitializeCmos

stdENDP _HalpInitializeCmos

endif

INIT   ends

_TEXT   SEGMENT DWORD PUBLIC 'CODE'
        ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING


;++
;
;   ULONG
;   HalpGetCmosData(
;       IN ULONG    SourceLocation
;       IN ULONG    SourceAddress
;       IN ULONG    ReturnBuffer
;       IN PUCHAR   ByteCount
;       )
;
;   This routine reads the requested number of bytes from CMOS/ECMOS and
;   stores the data read into the supplied buffer in system memory.  If
;   the requested data amount exceeds the allowable extent of the source
;   location, the return data is truncated.
;
;   Arguments:
;
;       SourceLocation  : where data is to be read from CMOS or ECMOS
;                           0 - CMOS, 1 - ECMOS
;
;       SourceAddress   : address in CMOS/ECMOS where data is to be read from
;
;       ReturnBuffer    : address in system memory for return data
;
;       ByteCount       : number of bytes to be read
;
;   Returns:
;
;       Number of byte actually read.
;
;--

SourceLocation  equ     2*4[ebp]
SourceAddress   equ     3*4[ebp]
ReturnBuffer    equ     4*4[ebp]
ByteCount       equ     5*4[ebp]

cPublicProc _HalpGetCmosData    ,4

        push    ebp
        mov     ebp, esp
        push    ebx
        push    edi

    ;
    ; NOTE: The spinlock is needed even in the UP case, because
    ;    the resource is also used in an interrupt handler (profiler).
    ;    If we own the spinlock in this routine, and we service
    ;    the profiler interrupt (which will wait for the spinlock forever),
    ;    then we have a hosed system.
    ;
        stdCall _HalpAcquireCmosSpinLock

        xor     edx, edx                ; initialize return data length
        mov     ecx, ByteCount

        or      ecx, ecx                ; validate requested byte count
        jz      HalpGetCmosDataExit     ; if no work to do, exit

        mov     edx, SourceAddress
        mov     edi, ReturnBuffer

        mov     eax, SourceLocation     ; cmos or extended cmos?
        cmp     eax, 1
        je      ECmosReadByte
        cmp     eax, 0
        jne     HalpGetCmosDataExit

CmosReadByte:
        cmp     edx, 0ffH               ; validate cmos source address
        ja      HalpGetCmosDataExit     ; if out of range, exit
        mov     al, dl
        out     CmosAddressPort, al
        in      al, CmosDataPort
        mov     [edi], al
        inc     edx
        inc     edi
        dec     ecx
        jnz     CmosReadByte
        jmp     SHORT HalpGetCmosDataExit

ECmosReadByte:
        cmp     edx,0ffffH              ; validate ecmos source address
        ja      HalpGetCmosDataExit     ; if out of range, exit
        mov     al, dl
        out     ECmosAddressLsbPort, al
        mov     al, dh
        out     ECmosAddressMsbPort, al
        in      al, ECmosDataPort
        mov     [edi], al
        inc     edx
        inc     edi
        dec     ecx
        jnz     ECmosReadByte

HalpGetCmosDataExit:
        stdCall _HalpReleaseCmosSpinLock

        mov     eax, edx                ; return bytes read
        sub     eax, SourceAddress      ; subtract the initial offset

        pop     edi
        pop     ebx
        pop     ebp

        stdRET    _HalpGetCmosData

stdENDP _HalpGetCmosData


;++
;
;   VOID
;   HalpSetCmosData(
;       IN ULONG    SourceLocation
;       IN ULONG    SourceAddress
;       IN ULONG    ReturnBuffer
;       IN PUCHAR   ByteCount
;       )
;
;   This routine writes the requested number of bytes to CMOS/ECMOS
;
;   Arguments:
;
;       SourceLocation  : where data is to be written to CMOS or ECMOS
;                           0 - CMOS, 1 - ECMOS
;
;       SourceAddress   : address in CMOS/ECMOS where data is to write to.
;
;       ReturnBuffer    : address in system memory for data to write
;
;       ByteCount       : number of bytes to be write
;
;   Returns:
;
;       Number of byte actually written.
;
;--

cPublicProc _HalpSetCmosData    ,4

        push    ebp
        mov     ebp, esp
        push    ebx
        push    edi

        stdCall _HalpAcquireCmosSpinLock

        xor     edx, edx                ; initialize return data length
        mov     ecx, ByteCount

        or      ecx, ecx                ; validate requested byte count
        jz      HalpSetCmosDataExit     ; if no work to do, exit

        mov     edx, SourceAddress
        mov     edi, ReturnBuffer

        mov     eax, SourceLocation     ; cmos or extended cmos?
        cmp     eax, 1
        je      ECmosWriteByte
        cmp     eax, 0
        jne     HalpSetCmosDataExit

CmosWriteByte:
        cmp     edx, 0ffH               ; validate cmos source address
        ja      HalpSetCmosDataExit     ; if out of range, exit
        mov     al, dl
        out     CmosAddressPort, al
        mov     al, [edi]
        out     CmosDataPort, al
        inc     edx
        inc     edi
        dec     ecx
        jnz     CmosWriteByte
        jmp     SHORT HalpSetCmosDataExit

ECmosWriteByte:
        cmp     edx,0ffffH              ; validate ecmos source address
        ja      HalpSetCmosDataExit     ; if out of range, exit
        mov     al, dl
        out     ECmosAddressLsbPort, al
        mov     al, dh
        out     ECmosAddressMsbPort, al
        mov     al, [edi]
        out     ECmosDataPort, al
        inc     edx
        inc     edi
        dec     ecx
        jnz     ECmosWriteByte

HalpSetCmosDataExit:
        stdCall _HalpReleaseCmosSpinLock

        mov     eax, edx                ; return bytes written
        sub     eax, SourceAddress      ; subtract the initial offset
        
        pop     edi
        pop     ebx
        pop     ebp

        stdRET    _HalpSetCmosData

stdENDP _HalpSetCmosData


        page ,132
        subttl  "Read System Time"
;++
;
; VOID
; HalpReadCmosTime (
;    PTIME_FIELDS TimeFields
;    )
;
; Routine Description:
;
;    This routine reads current time from CMOS memory and stores it
;    in the TIME_FIELDS structure passed in by caller.
;
; Arguments:
;
;    TimeFields - A pointer to the TIME_FIELDS structure.
;
; Return Value:
;
;    None.
;
;--

;
; Parameters:
;

KrctPTimeFields equ [esp+4]

cPublicProc _HalpReadCmosTime ,1

if DBG
krctwait0:
        mov     ecx, 100
krctwait:
        push    ecx
else
krctwait:
endif
        stdCall   _HalpAcquireCmosSpinLock
        mov     ecx, 100
        align   4
krct00: mov     al, 0Ah                 ; Specify register A
        CMOS_READ                       ; (al) = CMOS register A
        test    al, CMOS_STATUS_BUSY    ; Is time update in progress?
        jz      short krct10            ; if z, no, go read CMOS time
        loop    short krct00            ; otherwise, try again.

;
; CMOS is still busy. Try again ...
;

        stdCall _HalpReleaseCmosSpinLock
if DBG
        pop     ecx
        loop    short krctwait
        stdCall _DbgBreakPoint
        jmp     short krctwait0
else
        jmp     short krctwait
endif
        align   4
if DBG
krct10:
        pop     ecx
else
krct10:
endif
        mov     edx, KrctPTimeFields    ; (edx)-> TIME_FIELDS structure
        xor     eax, eax                ; (eax) = 0

        ;
        ; The RTC is only accurate within one second.  So
        ; add a half a second so that we are closer, on average,
        ; to the right answer.
        ;
        mov     word ptr [edx].TfMilliseconds, 500      ; add a half a second
        
        mov     al, RTC_OFFSET_SECOND
        CMOS_READ                       ; (al) = second in BCD form
        BCD_TO_BIN                      ; (ax) = second
        mov     [edx].TfSecond, ax      ; set second in TIME_FIELDS
        
        mov     al, RTC_OFFSET_MINUTE
        CMOS_READ                       ; (al) = minute in BCD form
        BCD_TO_BIN                      ; (ax) = Minute
        mov     [edx].TfMinute, ax      ; set minute in TIME_FIELDS

        mov     al, RTC_OFFSET_HOUR
        CMOS_READ                       ; (al) = hour in BCD form
        BCD_TO_BIN                      ; (ax) = Hour
        mov     [edx].TfHour, ax        ; set hour in TIME_FIELDS

        mov     al, RTC_OFFSET_DAY_OF_WEEK
        CMOS_READ                       ; (al) = day-of-week in BCD form
        BCD_TO_BIN                      ; (ax) = day-of-week
        mov     [edx].TfWeekday, ax     ; set Weekday in TIME_FIELDS

        mov     al, RTC_OFFSET_DATE_OF_MONTH
        CMOS_READ                       ; (al) = date-of-month in BCD form
        BCD_TO_BIN                      ; (ax) = date_of_month
        mov     [edx].TfDay, ax         ; set day in TIME_FIELDS

        mov     al, RTC_OFFSET_MONTH
        CMOS_READ                       ; (al) = month in BCD form
        BCD_TO_BIN                      ; (ax) = month
        mov     [edx].TfMonth, ax       ; set month in TIME_FIELDS

        mov     al, RTC_OFFSET_YEAR
        CMOS_READ                       ; (al) = year in BCD form
        BCD_TO_BIN                      ; (ax) = year
        push    eax                     ; save year in stack

        push    edx                     ; preserve edx
        call    _HalpGetCmosCenturyByte ; (al)= century byte in BCD form
        BCD_TO_BIN                      ; (ax) = century
        pop     edx

        mov     ah, 100
        mul     ah                      ; (ax) = century * 100
        pop     ecx                     ; (cx) = year
        add     ax, cx                  ; (ax)= year

        cmp     ax, 1900                ; Is year > 1900
        jb      short krct40
        cmp     ax, 1920                ; and < 1920
        jae     short krct40
        add     ax, 100                 ; Compensate for century field

krct40:
        mov     [edx].TfYear, ax        ; set year in TIME_FIELDS

        stdCall   _HalpReleaseCmosSpinLock

        stdRET    _HalpReadCmosTime

stdENDP _HalpReadCmosTime

        page ,132
        subttl  "Write System Time"
;++
;
; VOID
; HalpWriteCmosTime (
;    PTIME_FIELDS TimeFields
;    )
;
; Routine Description:
;
;    This routine writes current time from TIME_FILEDS structure
;    to CMOS memory.
;
; Arguments:
;
;    TimeFields - A pointer to the TIME_FIELDS structure.
;
; Return Value:
;
;    None.
;
;--

;
; Parameters:
;

KrctPTimeFields equ [esp+4]

cPublicProc _HalpWriteCmosTime ,1

if DBG
kwctwait0:
        mov     ecx, 100
kwctwait:
        push    ecx
else
kwctwait:
endif
        stdCall   _HalpAcquireCmosSpinLock
        mov     ecx, 100
        align   4
kwct00: mov     al, 0Ah                 ; Specify register A
        CMOS_READ                       ; (al) = CMOS register A
        test    al, CMOS_STATUS_BUSY    ; Is time update in progress?
        jz      short kwct10            ; if z, no, go write CMOS time
        loop    short kwct00            ; otherwise, try again.

;
; CMOS is still busy. Try again ...
;

        stdCall _HalpReleaseCmosSpinLock
if DBG
        pop     ecx
        loop    short kwctwait
        stdCall _DbgBreakPoint
        jmp     short kwctwait0
else
        jmp     short kwctwait
endif
        align   4
if DBG
kwct10:
        pop     ecx
else
kwct10:
endif
        mov     edx, KrctPTimeFields    ; (edx)-> TIME_FIELDS structure

        mov     al, [edx].TfSecond      ; Read second in TIME_FIELDS
        BIN_TO_BCD
        mov     ah, al
        mov     al, RTC_OFFSET_SECOND
        CMOS_WRITE

        mov     al, [edx].TfMinute      ; Read minute in TIME_FIELDS
        BIN_TO_BCD
        mov     ah, al
        mov     al, RTC_OFFSET_MINUTE
        CMOS_WRITE

        mov     al, [edx].TfHour        ; Read Hour in TIME_FIELDS
        BIN_TO_BCD
        mov     ah, al
        mov     al, RTC_OFFSET_HOUR
        CMOS_WRITE

        mov     al, [edx].TfWeekDay     ; Read WeekDay in TIME_FIELDS
        BIN_TO_BCD
        mov     ah, al
        mov     al, RTC_OFFSET_DAY_OF_WEEK
        CMOS_WRITE

        mov     al, [edx].TfDay         ; Read day in TIME_FIELDS
        BIN_TO_BCD
        mov     ah, al
        mov     al, RTC_OFFSET_DATE_OF_MONTH
        CMOS_WRITE

        mov     al, [edx].TfMonth       ; Read month in TIME_FIELDS
        BIN_TO_BCD
        mov     ah, al
        mov     al, RTC_OFFSET_MONTH
        CMOS_WRITE

        mov     ax, [edx].TfYear        ; Read Year in TIME_FIELDS
        cmp     ax, 9999
        jbe     short kwct15
        mov     ax, 9999

        align   4
kwct15:
        mov     cl, 100
        div     cl                      ; [ax]/[cl]->al=quo, ah=rem
        push    eax
        BIN_TO_BCD

        push    eax
        call    _HalpSetCmosCenturyByte

        pop     eax
        mov     al, ah                  ; [al] = Year
        BIN_TO_BCD
        mov     ah, al                  ; [ah] = year in BCD
        mov     al, RTC_OFFSET_YEAR
        CMOS_WRITE

        stdCall   _HalpReleaseCmosSpinLock

        stdRET    _HalpWriteCmosTime

stdENDP _HalpWriteCmosTime


;++
;
; Routine Description:
;
;   Acquires a spinlock to access the cmos chip. The cmos chip is
;   accessed at different irql levels, so to be safe, we 'cli'.
;   We could replace that to raise irql to PROFILE_LEVEL, but that's
;   a lot of code.
;
; Arguments:
;
;    None
;
; Return Value:
;
;    Interrupt is disabled.
;    Irql level not affected.
;    Flags saved in _HalpHardwareLockFlags.
;--

cPublicProc _HalpAcquireCmosSpinLock  ,0
public _HalpAcquireSystemHardwareSpinLock@0
_HalpAcquireSystemHardwareSpinLock@0:
        push    eax

Arsl10: pushfd
        cli
        lea     eax, _HalpSystemHardwareLock
        ACQUIRE_SPINLOCK    eax, Arsl20
        pop     _HalpHardwareLockFlags          ; save flags for release S.L.
        pop     eax
        stdRET    _HalpAcquireCmosSpinLock

Arsl20: popfd

Arsl30:
        YIELD
ifndef NT_UP
        cmp     _HalpRebootNow, 0
        jnz     short Arsl50
endif
        TEST_SPINLOCK       eax, <short Arsl30>
        jmp     short ARsl10

Arsl50:
ifndef NT_UP
        mov     eax, _HalpRebootNow
        call    eax
        int 3                                 ; should not return
endif

stdENDP _HalpAcquireCmosSpinLock


;++
;
; Routine Description:
;
;   Release spinlock, and restore flags to the state it was before
;   acquiring the spinlock.
;
; Arguments:
;
;   None
;
; Return Value:
;
;   Interrupts restored to their state before acquiring spinlock.
;   Irql level not affected.
;
;--

cPublicProc _HalpReleaseCmosSpinLock  ,0
public _HalpReleaseSystemHardwareSpinLock@0
_HalpReleaseSystemHardwareSpinLock@0:
        push    eax
        ;
        ; restore eflags as it was before acquiring spinlock. Put it on
        ; stack before releasing spinlock (so other cpus cannot overwrite
        ; it with their own eflags).
        ;
        push    _HalpHardwareLockFlags          ; old eflags on stack.
        lea     eax, _HalpSystemHardwareLock
        RELEASE_SPINLOCK    eax
        popfd                                   ; restore eflags.
        pop   eax
        stdRET    _HalpReleaseCmosSpinLock
stdENDP _HalpReleaseCmosSpinLock

;++
;
; UCHAR
; HalpGetCmosCenturyByte (
;    VOID
;    )
;
; Routine Description:
;
;    This routine gets Century byte from CMOS.
;
; Arguments:
;
;    None
;
; Return Value:
;
;    (al) = Century byte in BCD form.
;
;--

cPublicProc _HalpGetCmosCenturyByte, 0

        mov     eax, _HalpCmosCenturyOffset

if DBG

;
; Make sure the HalpCmosCenturyOffset is initialized
;

        cmp     eax, 0
        jne     short @f

        int 3
@@:
endif
        test    eax, BANK1
        jnz     short rcb50

        CMOS_READ                       ; (al) = century in BCD form
        stdRET    _HalpGetCmosCenturyByte

rcb50:  mov     edx, eax

        mov     al, 0Ah
        CMOS_READ

        mov     dh, al                          ; save it for restore
        or      al, 10h                         ; Set DV0 = 1

        mov     ah, al
        mov     al, 0Ah                         ; Write register A
        CMOS_WRITE

        mov     al, dl                          ; century offset
        CMOS_READ
        mov     dl, al                          ; save it

        mov     ah, dh                          ; Restore DV0
        mov     al, 0Ah                         ; Write register A
        CMOS_WRITE

        mov     al, dl
        stdRET    _HalpGetCmosCenturyByte

stdENDP _HalpGetCmosCenturyByte


;++
;
; VOID
; HalpSetCmosCenturyByte (
;    UCHAR Century
;    )
;
; Routine Description:
;
;    This routine sets Century byte in CMOS.
;
; Arguments:
;
;    Century - Supplies the value for CMOS century byte
;
; Return Value:
;
;    None.
;
;--

cPublicProc _HalpSetCmosCenturyByte, 1

        mov     eax, _HalpCmosCenturyOffset
if DBG

;
; Make sure the HalpCmosCenturyOffset is initialized
;

        cmp     eax, 0
        jne     short @f

        int 3
@@:
endif

        test    eax, BANK1
        jnz     short scb50

        mov     ah, [esp+4]             ; (ah) = Century in BCD form
        CMOS_WRITE
        stdRET    _HalpSetCmosCenturyByte


scb50:  mov     edx, eax

        mov     al, 0Ah
        CMOS_READ

        mov     dh, al                          ; save it for restore
        or      al, 10h                         ; Set DV0 = 1

        mov     ah, al
        mov     al, 0Ah                         ; Write register A
        CMOS_WRITE

        mov     ah, [esp+4]                     ; (ah) = Century in BCD form
        mov     al, dl                          ; century offset
        CMOS_WRITE

        mov     ah, dh                          ; Restore DV0
        mov     al, 0Ah                         ; Write register A
        CMOS_WRITE
        stdRET    _HalpSetCmosCenturyByte

stdENDP _HalpSetCmosCenturyByte


;++
;
; VOID
; HalpCpuID (
;     ULONG   InEax,
;     PULONG  OutEax,
;     PULONG  OutEbx,
;     PULONG  OutEcx,
;     PULONG  OutEdx
;     );
;
; Routine Description:
;
;   Executes the CPUID instruction and returns the registers from it
;
;   Only available at INIT time
;
; Arguments:
;
; Return Value:
;
;--
cPublicProc _HalpCpuID,5

        push    ebx
        push    esi

        mov     eax, [esp+12]
        db      0fh, 0a2h       ; CPUID

        mov     esi, [esp+16]   ; return EAX
        mov     [esi], eax

        mov     esi, [esp+20]   ; return EBX
        mov     [esi], ebx

        mov     esi, [esp+24]   ; return ECX
        mov     [esi], ecx

        mov     esi, [esp+28]   ; return EDX
        mov     [esi], edx

        pop     esi
        pop     ebx

        stdRET  _HalpCpuID

stdENDP _HalpCpuID


;++
;
; VOID
; HalpFlushTLB (
;     VOID
;     );
;
; Routine Description:
;
;   Flush the current TLB.
;
; Arguments:
;
; Return Value:
;
;--
cPublicProc _HalpFlushTLB, 0
.586p
        pushfd
        push    ebx
        push    esi

        cli
        mov     esi, cr3

        mov     ecx, PCR[PcPrcb]
        cmp     byte ptr [ecx].PbCpuID, 0
        jz      short ftb50

        mov     eax, 1                  ; Get feature bits
        cpuid                           ; (note "cpuid" between CR3 reload fixes
                                        ; P6 B step errata #11)

        test    edx, 2000h              ; see if 'G' bit is supported
        jz      short ftb50

        mov     ecx, cr4                ; 'G' bit is supported, due global flush
        mov     edx, ecx                ; Save orginal cr4
        and     ecx, not CR4_PGE        ; Make sure global bit is disabled
        mov     cr4, ecx
        mov     cr3, esi                ; flush TLB
        mov     cr4, edx                ; restore cr4
        jmp     short ftp99

ftb50:  mov     cr3, esi

ftp99:  pop     esi
        pop     ebx
        popfd
        stdRET  _HalpFlushTLB

.486p
stdENDP _HalpFlushTLB

;++
;
; VOID
; HalpYieldProcessor (
;     VOID
;     );
;
; Routine Description:
;
; Arguments:
;
;       None
;
; Return Value:
;
;       None
;
;--
cPublicProc _HalpYieldProcessor
        YIELD
        stdRET  _HalpYieldProcessor
stdENDP _HalpYieldProcessor


_TEXT   ends

        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halx86\i386\ixdat.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    ixdat.c

Abstract:

    Declares various data which is initialize data, or pagable data.

Author:

Environment:

    Kernel mode only.

Revision History:

--*/

#include "halp.h"

#ifdef ALLOC_DATA_PRAGMA
#pragma data_seg("INIT")
#endif

//
// The following data is only valid during system initialiation
// and the memory will be re-claimed by the system afterwards
//

ADDRESS_USAGE HalpDefaultPcIoSpace = {
    NULL, CmResourceTypePort, DeviceUsage,
    {
        0x000,  0x20,   // ISA DMA
        0x0C0,  0x20,   // ISA DMA

        0x080,  0x10,   // DMA

        0x020,  0x2,    // PIC
        0x0A0,  0x2,    // Cascaded PIC

        0x040,  0x4,    // Timer1, Referesh, Speaker, Control Word
        0x048,  0x4,    // Timer2, Failsafe

#if 0   // HACKHACK Remove for now since Intelille mouse software claims it.
        0x061,  0x1,    // NMI  (system control port B)
#endif
        0x092,  0x1,    // system control port A

#ifndef ACPI_HAL
        0x070,  0x2,    // Cmos/NMI enable
#endif
#ifdef MCA
        0x074,  0x3,    // Extended CMOS

        0x090,  0x2,    // Arbritration Control Port, Card Select Feedback
        0x093,  0x2,    // Reserved, System board setup
        0x096,  0x2,    // POS channel select
#endif
        0x0F0,  0x10,   // coprocessor ports
#ifndef ACPI_HAL
        0xCF8,  0x8,    // PCI Config Space Access Pair
#endif
        0,0
    }
};

ADDRESS_USAGE HalpEisaIoSpace = {
    NULL, CmResourceTypePort, DeviceUsage,
    {
        0x0D0,  0x10,   // DMA
        0x400,  0x10,   // DMA
        0x480,  0x10,   // DMA
        0x4C2,  0xE,    // DMA
        0x4D4,  0x2C,   // DMA

        0x461,  0x2,    // Extended NMI
        0x464,  0x2,    // Last Eisa Bus Muster granted

        0x4D0,  0x2,    // edge/level control registers

        0xC84,  0x1,    // System board enable
        0, 0
    }
};

#ifndef ACPI_HAL

ADDRESS_USAGE HalpDetectedROM = {
    NULL,
    CmResourceTypeMemory,
    InternalUsage | RomResource,
    {
        0,0,                // 32 ROM blocks, get initialized in ixusage.c
        0,0,
        0,0,
        0,0,
        0,0,
        0,0,
        0,0,
        0,0,
        0,0,
        0,0,
        0,0,
        0,0,
        0,0,
        0,0,
        0,0,
        0,0,
        0,0,
        0,0,
        0,0,
        0,0,
        0,0,
        0,0,
        0,0,
        0,0,
        0,0,
        0,0,
        0,0,
        0,0,
        0,0,
        0,0,
        0,0,
        0,0,
        0,0
    }
};

#endif

//
// Strings used for boot.ini options
// from mphal.c
//

UCHAR HalpSzBreak[]     = "BREAK";
UCHAR HalpSzPciLock[]   = "PCILOCK";

//
// From ixcmos.asm
//

UCHAR HalpSerialLen = 0;
UCHAR HalpSerialNumber[31] = {0};

//
// From usage.c
//

WCHAR HalpSzSystem[] = L"\\Registry\\Machine\\Hardware\\Description\\System";
WCHAR HalpSzSerialNumber[] = L"Serial Number";

ADDRESS_USAGE  *HalpAddressUsageList = NULL;

//
// Misc hal stuff in the registry
//

WCHAR rgzHalClassName[] = L"Hardware Abstraction Layer";


//
// From ixpcibus.c
//

WCHAR rgzMultiFunctionAdapter[] = L"\\Registry\\Machine\\Hardware\\Description\\System\\MultifunctionAdapter";
WCHAR rgzConfigurationData[] = L"Configuration Data";
WCHAR rgzIdentifier[] = L"Identifier";
WCHAR rgzPCIIdentifier[] = L"PCI";
WCHAR rgzPCICardList[] = L"\\Registry\\Machine\\System\\CurrentControlSet\\Control\\PnP\\PCI\\CardList";

//
// From ixpcibrd.c
//

WCHAR rgzReservedResources[] = L"\\Registry\\Machine\\System\\CurrentControlSet\\Control\\SystemResources\\ReservedResources";

//
// From ixinfo.c
//

WCHAR rgzSuspendCallbackName[] = L"\\Callback\\SuspendHibernateSystem";

//
// From ixmca.c
//
UCHAR   MsgMCEPending[] = MSG_MCE_PENDING;
WCHAR   rgzSessionManager[] = L"Session Manager";
WCHAR   rgzEnableMCE[] = L"EnableMCE";
WCHAR   rgzEnableMCA[] = L"EnableMCA";
WCHAR   rgzEnableCMC[] = L"EnableCMC";
WCHAR   rgzNoMCABugCheck[] = L"NoMCABugCheck";

#ifdef ALLOC_DATA_PRAGMA
#pragma data_seg()
#endif

UCHAR   HalpGenuineIntel[]= "GenuineIntel";
UCHAR   HalpAuthenticAMD[]= "AuthenticAMD";


ULONG   HalpFeatureBits = 0;

//
// Stuff that we only need while we
// sleep or hibernate.
//

MOTHERBOARD_CONTEXT HalpMotherboardState = {0};

//
// PAGELK handle
//
PVOID   HalpSleepPageLock = NULL;
PVOID   HalpSleepPage16Lock = NULL;

USHORT  HalpPciIrqMask = 0;
USHORT  HalpEisaIrqMask = 0;
USHORT  HalpEisaIrqIgnore = 0x1000;
BOOLEAN HalpDisableHibernate = FALSE;

//
// Timer watchdog variables
//
ULONG   HalpTimerWatchdogEnabled = 0;
ULONG   HalpTimerWatchdogStorageOverflow = 0;
PVOID   HalpTimerWatchdogCurFrame = NULL;
PVOID   HalpTimerWatchdogLastFrame = NULL;
PCHAR   HalpTimerWatchdogStorage = NULL;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halx86\i386\ixbusdat.c ===
/*++


Copyright (c) 1989  Microsoft Corporation

Module Name:

    ixhwsup.c

Abstract:

    This module contains the IoXxx routines for the NT I/O system that
    are hardware dependent.  Were these routines not hardware dependent,
    they would reside in the iosubs.c module.

Author:

    Ken Reneris (kenr) July-28-1994

Environment:

    Kernel mode

Revision History:


--*/

#include "halp.h"

#define DMALIMIT 7

VOID HalpInitOtherBuses (VOID);


ULONG
HalpNoBusData (
    IN PVOID BusHandler,
    IN PVOID RootHandler,
    IN ULONG SlotNumber,
    IN PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Length
    );

ULONG HalpcGetCmosData (
    IN PVOID BusHandler,
    IN PVOID RootHandler,
    IN ULONG SlotNumber,
    IN PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Length
    );

ULONG HalpcSetCmosData (
    IN PVOID BusHandler,
    IN PVOID RootHandler,
    IN ULONG SlotNumber,
    IN PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Length
    );

ULONG HalpGetCmosData (
    IN ULONG BusNumber,
    IN ULONG SlotNumber,
    IN PVOID Buffer,
    IN ULONG Length
    );

ULONG HalpSetCmosData (
    IN ULONG BusNumber,
    IN ULONG SlotNumber,
    IN PVOID Buffer,
    IN ULONG Length
    );

HalpGetEisaData (
    IN PVOID BusHandler,
    IN PVOID RootHandler,
    IN ULONG SlotNumber,
    IN PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Length
    );


//
// Prototype for system bus handlers
//

NTSTATUS
HalpAdjustEisaResourceList (
    IN PVOID BusHandler,
    IN PVOID RootHandler,
    IN OUT PIO_RESOURCE_REQUIREMENTS_LIST   *pResourceList
    );

ULONG
HalpGetEisaInterruptVector (
    IN PVOID BusHandler,
    IN PVOID RootHandler,
    IN ULONG BusInterruptLevel,
    IN ULONG BusInterruptVector,
    OUT PKIRQL Irql,
    OUT PKAFFINITY Affinity
    );

BOOLEAN
HalpTranslateIsaBusAddress (
    IN PVOID BusHandler,
    IN PVOID RootHandler,
    IN PHYSICAL_ADDRESS BusAddress,
    IN OUT PULONG AddressSpace,
    OUT PPHYSICAL_ADDRESS TranslatedAddress
    );

BOOLEAN
HalpTranslateEisaBusAddress (
    IN PVOID BusHandler,
    IN PVOID RootHandler,
    IN PHYSICAL_ADDRESS BusAddress,
    IN OUT PULONG AddressSpace,
    OUT PPHYSICAL_ADDRESS TranslatedAddress
    );

VOID
HalpRegisterInternalBusHandlers (
    VOID
    );

NTSTATUS
HalpHibernateHal (
    IN PBUS_HANDLER BusHandler,
    IN PBUS_HANDLER RootHandler
    );

NTSTATUS
HalpResumeHal (
    IN PBUS_HANDLER  BusHandler,
    IN PBUS_HANDLER  RootHandler
    );

#ifdef MCA
//
// Default functionality of MCA handlers is the same as the Eisa handlers,
// just use them
//

#define HalpGetMCAInterruptVector   HalpGetEisaInterruptVector
#define HalpAdjustMCAResourceList   HalpAdjustEisaResourceList;

HalpGetPosData (
    IN PVOID BusHandler,
    IN PVOID RootHandler,
    IN ULONG SlotNumber,
    IN PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Length
    );


#endif


#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT,HalpRegisterInternalBusHandlers)
#pragma alloc_text(INIT,HalpAllocateBusHandler)
#endif


VOID
HalpRegisterInternalBusHandlers (
    VOID
    )
{
    PBUS_HANDLER    Bus;

    if (KeGetCurrentPrcb()->Number) {
        // only need to do this once
        return ;
    }

    //
    // Initalize BusHandler data before registering any handlers
    //

    HalpInitBusHandler ();

    //
    // Build internal-bus 0, or system level bus
    //

    Bus = HalpAllocateBusHandler (
            Internal,
            ConfigurationSpaceUndefined,
            0,                              // Internal BusNumber 0
            InterfaceTypeUndefined,         // no parent bus
            0,
            0                               // no bus specfic data
            );

    if (!Bus) {
        return;
    }

    Bus->GetInterruptVector  = HalpGetSystemInterruptVector;
    Bus->TranslateBusAddress = HalpTranslateSystemBusAddress;

#if 0
    //
    // Hibernate and resume the hal by getting notifications
    // for when this bus is hibernated or resumed.  Since it's
    // the first bus to be added, it will be the last to hibernate
    // and the first to resume
    //

    Bus->HibernateBus        = HalpHibernateHal;
    Bus->ResumeBus           = HalpResumeHal;
#endif

#if defined(NEC_98)
    Bus = HalpAllocateBusHandler (Isa, ConfigurationSpaceUndefined, 0, Internal, 0, 0);  // isa as child of Internal
    if (Bus) {
        Bus->GetBusData = HalpNoBusData;
        Bus->AdjustResourceList = HalpAdjustEisaResourceList;
        Bus->TranslateBusAddress = HalpTranslateEisaBusAddress;
    }

#else  //defined(NEC_98)
    //
    // Add handlers for Cmos config space.
    //

    Bus = HalpAllocateBusHandler (InterfaceTypeUndefined, Cmos, 0, -1, 0, 0);
    if (Bus) {
        Bus->GetBusData = HalpcGetCmosData;
        Bus->SetBusData = HalpcSetCmosData;
    }

    Bus = HalpAllocateBusHandler (InterfaceTypeUndefined, Cmos, 1, -1, 0, 0);
    if (Bus) {
        Bus->GetBusData = HalpcGetCmosData;
        Bus->SetBusData = HalpcSetCmosData;
    }

#ifndef MCA
    //
    // Build Isa/Eisa bus #0
    //

    Bus = HalpAllocateBusHandler (Eisa, EisaConfiguration, 0, Internal, 0, 0);
    if (Bus) {
        Bus->GetBusData = HalpGetEisaData;
        Bus->GetInterruptVector = HalpGetEisaInterruptVector;
        Bus->AdjustResourceList = HalpAdjustEisaResourceList;
        Bus->TranslateBusAddress = HalpTranslateEisaBusAddress;
    }

    Bus = HalpAllocateBusHandler (Isa, ConfigurationSpaceUndefined, 0, Eisa, 0, 0);
    if (Bus) {
        Bus->GetBusData = HalpNoBusData;
        Bus->BusAddresses->Memory.Limit = 0xFFFFFF;
        Bus->TranslateBusAddress = HalpTranslateIsaBusAddress;
    }

#else

    //
    // Build MCA bus #0
    //

    Bus = HalpAllocateBusHandler (MicroChannel, Pos, 0, Internal, 0, 0);
    if (Bus) {
        Bus->GetBusData = HalpGetPosData;
        Bus->GetInterruptVector = HalpGetMCAInterruptVector;
        Bus->AdjustResourceList = HalpAdjustMCAResourceList;
    }

#endif
#endif // defined(NEC_98)

    HalpInitOtherBuses ();
}



PBUS_HANDLER
HalpAllocateBusHandler (
    IN INTERFACE_TYPE   InterfaceType,
    IN BUS_DATA_TYPE    BusDataType,
    IN ULONG            BusNumber,
    IN INTERFACE_TYPE   ParentBusInterfaceType,
    IN ULONG            ParentBusNumber,
    IN ULONG            BusSpecificData
    )
/*++

Routine Description:

    Stub function to map old style code into new HalRegisterBusHandler code.

    Note we can add our specific bus handler functions after this bus
    handler structure has been added since this is being done during
    hal initialization.

--*/
{
    PBUS_HANDLER     Bus = NULL;


    //
    // Create bus handler - new style
    //

    HaliRegisterBusHandler (
        InterfaceType,
        BusDataType,
        BusNumber,
        ParentBusInterfaceType,
        ParentBusNumber,
        BusSpecificData,
        NULL,
        &Bus
    );

    if (!Bus) {
        return NULL;
    }

    if (InterfaceType != InterfaceTypeUndefined) {
        Bus->BusAddresses = ExAllocatePoolWithTag(SPRANGEPOOL,
                                                  sizeof(SUPPORTED_RANGES),
                                                  HAL_POOL_TAG);
        RtlZeroMemory(Bus->BusAddresses, sizeof(SUPPORTED_RANGES));
        Bus->BusAddresses->Version      = BUS_SUPPORTED_RANGE_VERSION;
        Bus->BusAddresses->Dma.Limit    = DMALIMIT;
        Bus->BusAddresses->Memory.Limit = 0xFFFFFFFF;
        Bus->BusAddresses->IO.Limit     = 0xFFFF;
        Bus->BusAddresses->IO.SystemAddressSpace = 1;
        Bus->BusAddresses->PrefetchMemory.Base = 1;
    }

    return Bus;
}


//
// C to Asm thunks for CMos
//

ULONG HalpcGetCmosData (
    IN PBUS_HANDLER BusHandler,
    IN PVOID RootHandler,
    IN ULONG SlotNumber,
    IN PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Length
    )
{
    // this interface should be rev'ed to support non-zero offsets
    if (Offset != 0) {
        return 0;
    }

    return HalpGetCmosData (BusHandler->BusNumber, SlotNumber, Buffer, Length);
}


ULONG HalpcSetCmosData (
    IN PBUS_HANDLER BusHandler,
    IN PVOID RootHandler,
    IN ULONG SlotNumber,
    IN PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Length
    )
{
    // this interface should be rev'ed to support non-zero offsets
    if (Offset != 0) {
        return 0;
    }

    return HalpSetCmosData (BusHandler->BusNumber, SlotNumber, Buffer, Length);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halx86\i386\ixbeep.asm ===
title "Hal Beep"
;++
;
;Copyright (c) 1991  Microsoft Corporation
;
;Module Name:
;
;    ixbeep.asm
;
;Abstract:
;
;    HAL routine to make noise.  It needs to synchronize its access to the
;    8254, since we also use the 8254 for the profiling interrupt.
;
;
;Author:
;
;    John Vert (jvert) 31-Jul-1991
;
;Revision History:
;
;--

.386p
        .xlist
include hal386.inc
include callconv.inc                    ; calling convention macros
include i386\kimacro.inc
include mac386.inc
        .list

        EXTRNP  _HalpAcquireSystemHardwareSpinLock,0
        EXTRNP  _HalpReleaseSystemHardwareSpinLock,0

;
; Defines used to program the i8254 for the speaker.
;

ifdef NEC_98
I8254_TIMER_CONTROL_PORT    equ   3fdfh     ; write mode port (for N mode)
I8254_TIMER_DATA_PORT       equ   3fdbh     ; count port (for N mode)
I8254_TIMER_CLOCK_IN        equ 2457600
I8254_TIMER_TONE_MAX        equ   65536
I8254_TIMER_CONTROL_SELECT  equ     76h
SPEAKER_CONTROL_PORT        equ     37h     ; system port C, set command port
SPEAKER_OFF                 equ     07h
SPEAKER_ON                  equ     06h
else  ; NEC_98
I8254_TIMER_CONTROL_PORT EQU    43h
I8254_TIMER_DATA_PORT    EQU    42h
I8254_TIMER_CLOCK_IN     EQU    1193167
I8254_TIMER_TONE_MAX     EQU    65536
I8254_TIMER_CONTROL_SELECT EQU  0B6h
SPEAKER_CONTROL_PORT     EQU    61h
SPEAKER_OFF_MASK         EQU    0FCh
SPEAKER_ON_MASK          EQU    03h
endif ; NEC_98

_TEXT$03   SEGMENT DWORD PUBLIC 'CODE'
           ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING

        page ,132
        subttl  "HalMakeBeep"
;++
;
; BOOLEAN
; HalMakeBeep(
;       IN ULONG Frequency
;       )
;
; Routine Description:
;
;     This function sets the frequency of the speaker, causing it to sound a
;     tone.  The tone will sound until the speaker is explicitly turned off,
;     so the driver is responsible for controlling the duration of the tone.
;
;Arguments:
;
;     Frequency - Supplies the frequency of the desired tone.  A frequency of
;                 0 means the speaker should be shut off.
;
;Return Value:
;
;     TRUE  - Operation was successful (frequency within range or zero)
;     FALSE - Operation was unsuccessful (frequency was out of range)
;             Current tone (if any) is unchanged.
;
;--

Frequency equ [ebp + 8]

cPublicProc _HalMakeBeep    , 1

        push    ebp                     ; save ebp
        mov     ebp, esp                ;

        stdCall   _HalpAcquireSystemHardwareSpinLock      ; intr disabled

        ;
        ; Stop the speaker.
        ;

ifdef NEC_98
        mov      al, SPEAKER_OFF
        out      SPEAKER_CONTROL_PORT, al
        out      5Fh, al                        ; IoDelay
else  ; NEC_98
        in       al, SPEAKER_CONTROL_PORT
        jmp      $+2
        and      al, SPEAKER_OFF_MASK
        out      SPEAKER_CONTROL_PORT, al
        jmp      $+2
endif ; NEC_98

        ;
        ; Calculate Tone:  Tone = 1.193MHz / Frequency.
        ; N.B.  Tone must fit in 16 bits.
        ;

        mov      ecx, DWORD PTR [Frequency]     ; ecx <- frequency
        or       ecx, ecx                       ; (ecx) == 0?
        je       SHORT Hmb30                    ;     goto Hmb30

        mov      eax, I8254_TIMER_CLOCK_IN      ; eax <- 1.193MHz, the clockin
                                                ;    for the speaker tone
        sub      edx, edx                       ; edx <- zero
        div      ecx                            ; eax <- 1.193MHz / frequency
        cmp      eax, I8254_TIMER_TONE_MAX      ; (eax) < 2**16?
        jb       SHORT Hmb20                    ;     goto Hmb20

        ;
        ; Invalid frequency.  Return FALSE.
        ;

        sub      al, al
        jmp      SHORT Hmb40
Hmb20:
        ;
        ; Program the 8254 with the calculated tone.
        ;

ifdef NEC_98
        mov      dx, I8254_TIMER_CONTROL_PORT      ; port address for N
        mov      cx, I8254_TIMER_DATA_PORT

        push     eax                             ; save Tone
        mov      al, I8254_TIMER_CONTROL_SELECT
        out      dx, al                          ; select timer control register
        out      5Fh, al                         ; IoDelay

        pop      eax                             ; restore Tone
        mov      dx, cx                          ; set 'write mode' port addr
        out      dx, al                          ; program 8254 with Tone lsb
        out      5Fh, al                         ; IoDelay
        mov      al, ah
        out      dx, al                          ; program 8254 with Tone msb
        out      5Fh, al                         ; IoDelay

        ;
        ; Turn the speaker on.
        ;

        mov      al,SPEAKER_ON
        out      SPEAKER_CONTROL_PORT, al
        out      5Fh, al                         ; IoDelay
else  ; NEC_98
        push     eax                             ; save Tone
        mov      al, I8254_TIMER_CONTROL_SELECT
        out      I8254_TIMER_CONTROL_PORT, al    ; select timer control register
        jmp      $+2

        pop      eax                             ; restore Tone
        out      I8254_TIMER_DATA_PORT, al       ; program 8254 with Tone lsb
        jmp      $+2
        mov      al, ah
        out      I8254_TIMER_DATA_PORT, al       ; program 8254 with Tone msb
        jmp      $+2

        ;
        ; Turn the speaker on.
        ;

        in       al, SPEAKER_CONTROL_PORT
        jmp      $+2
        or       al, SPEAKER_ON_MASK
        out      SPEAKER_CONTROL_PORT, al
        jmp      $+2
endif ; NEC_98

Hmb30:
        ;
        ; Return TRUE.
        ;

        mov      al, 1

Hmb40:
        stdCall   _HalpReleaseSystemHardwareSpinLock

        pop    ebp                     ; restore ebp
        stdRET    _HalMakeBeep

stdENDP _HalMakeBeep

_TEXT$03   ends
           end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halx86\i386\ixclock.asm ===
title  "Interval Clock Interrupt"
;++
;
; Copyright (c) 1989  Microsoft Corporation
;
; Module Name:
;
;    ixclock.asm
;
; Abstract:
;
;    This module implements the code necessary to field and process the
;    interval clock interrupt.
;
; Author:
;
;    Shie-Lin Tzong (shielint) 12-Jan-1990
;
; Environment:
;
;    Kernel mode only.
;
; Revision History:
;
;   bryanwi 20-Sep-90
;
;       Add KiSetProfileInterval, KiStartProfileInterrupt,
;       KiStopProfileInterrupt procedures.
;       KiProfileInterrupt ISR.
;       KiProfileList, KiProfileLock are delcared here.
;
;   shielint 10-Dec-90
;       Add performance counter support.
;       Move system clock to irq8, ie we now use RTC to generate system
;         clock.  Performance count and Profile use timer 1 counter 0.
;         The interval of the irq0 interrupt can be changed by
;         KiSetProfileInterval.  Performance counter does not care about the
;         interval of the interrupt as long as it knows the rollover count.
;       Note: Currently I implemented 1 performance counter for the whole
;       i386 NT.
;
;   John Vert (jvert) 11-Jul-1991
;       Moved from ke\i386 to hal\i386.  Removed non-HAL stuff
;
;   shie-lin tzong (shielint) 13-March-92
;       Move System clock back to irq0 and use RTC (irq8) to generate
;       profile interrupt.  Performance counter and system clock use time1
;       counter 0 of 8254.
;
;   Landy Wang (corollary!landy) 04-Dec-92
;       Move much code into separate modules for easy inclusion by various
;       HAL builds.
;
;--

.386p
        .xlist
include hal386.inc
include callconv.inc                    ; calling convention macros
include i386\ix8259.inc
include i386\kimacro.inc
include mac386.inc
include i386\ixcmos.inc
        .list

        EXTRNP  _KeUpdateSystemTime,0
        EXTRNP  Kei386EoiHelper,0,IMPORT
        EXTRNP  _KeSetTimeIncrement,2,IMPORT
        EXTRNP  _HalEndSystemInterrupt,2
        EXTRNP  _HalBeginSystemInterrupt,3
        EXTRNP  _HalpReleaseCmosSpinLock  ,0
        EXTRNP  _HalpMcaQueueDpc, 0
        extrn   _KdEnteredDebugger:DWORD
        extrn   _HalpTimerWatchdogEnabled:DWORD
        extrn   _HalpTimerWatchdogStorage:DWORD
        extrn   _HalpTimerWatchdogCurFrame:DWORD
        extrn   _HalpTimerWatchdogLastFrame:DWORD
        extrn   _HalpTimerWatchdogStorageOverflow:DWORD

;
; Constants used to initialize timer 0
;

TIMER1_DATA_PORT0       EQU     40H     ; Timer1, channel 0 data port
TIMER1_CONTROL_PORT0    EQU     43H     ; Timer1, channel 0 control port
TIMER2_DATA_PORT0       EQU     48H     ; Timer1, channel 0 data port
TIMER2_CONTROL_PORT0    EQU     4BH     ; Timer1, channel 0 control port
TIMER1_IRQ              EQU     0       ; Irq 0 for timer1 interrupt

COMMAND_8254_COUNTER0   EQU     00H     ; Select count 0
COMMAND_8254_RW_16BIT   EQU     30H     ; Read/Write LSB firt then MSB
COMMAND_8254_MODE2      EQU     4       ; Use mode 2
COMMAND_8254_BCD        EQU     0       ; Binary count down
COMMAND_8254_LATCH_READ EQU     0       ; Latch read command

PERFORMANCE_FREQUENCY   EQU     1193182

COUNTER_TICKS_AVG_SHIFT EQU     4
COUNTER_TICKS_FOR_AVG   EQU     16
PAGE_SIZE               EQU     1000H
FRAME_COPY_SIZE         EQU     64

;
; ==== Values used for System Clock ====
;


_DATA   SEGMENT  DWORD PUBLIC 'DATA'

;
; The following array stores the per microsecond loop count for each
; central processor.
;

;
; 8254 performance counter.
;

        public HalpPerfCounterLow, HalpPerfCounterHigh
        public HalpLastPerfCounterLow, HalpLastPerfCounterHigh
HalpPerfCounterLow      dd      0
HalpPerfCounterHigh     dd      0
HalpLastPerfCounterLow  dd      0
HalpLastPerfCounterHigh dd      0

        public HalpCurrentRollOver, HalpCurrentTimeIncrement
HalpCurrentRollOver         dd      0
HalpCurrentTimeIncrement    dd      0

        public _HalpClockWork, _HalpClockSetMSRate, _HalpClockMcaQueueDpc
_HalpClockWork label dword
    _HalpClockSetMSRate     db  0
    _HalpClockMcaQueueDpc   db  0
    _bReserved1             db  0
    _bReserved2             db  0

;
; timer latency watchdog variables
;

        public  _HalpWatchdogAvgCounter, _HalpWatchdogCountLow, _HalpWatchdogCountHigh
        public  _HalpWatchdogTscLow, _HalpWatchdogTscHigh

    _HalpWatchdogAvgCounter dd  0
    _HalpWatchdogCountLow   dd  0
    _HalpWatchdogCountHigh  dd  0
    _HalpWatchdogTscLow     dd  0
    _HalpWatchdogTscHigh    dd  0

_DATA   ends

_TEXT   SEGMENT  DWORD PUBLIC 'DATA'

;
; Convert the interval to rollover count for 8254 Timer1 device.
; Timer1 counts down a 16 bit value at a rate of 1.193181667M counts-per-sec.
; (The main crystal freq is 14.31818, and this is a divide by 12)
;
; The best fit value closest to 10ms is 10.0144012689ms:
;   ROLLOVER_COUNT      11949
;   TIME_INCREMENT      100144
;   Calculated error is -.0109472 s/day
;
;
; The following table contains 8254 values timer values to use at
; any given ms setting from 1ms - 15ms.  All values work out to the
; same error per day (-.0109472 s/day).
;

        public HalpRollOverTable

        ;                    RollOver   Time
        ;                    Count      Increment   MS
HalpRollOverTable       dd      1197,   10032       ;  1 ms
                        dd      2394,   20064       ;  2 ms
                        dd      3591,   30096       ;  3 ms
                        dd      4767,   39952       ;  4 ms
                        dd      5964,   49984       ;  5 ms
                        dd      7161,   60016       ;  6 ms
                        dd      8358,   70048       ;  7 ms
                        dd      9555,   80080       ;  8 ms
                        dd     10731,   89936       ;  9 ms
                        dd     11949,  100144       ; 10 ms
                        dd     13125,  110000       ; 11 ms
                        dd     14322,  120032       ; 12 ms
                        dd     15519,  130064       ; 13 ms
                        dd     16695,  139920       ; 14 ms
                        dd     17892,  149952       ; 15 ms

TimeIncr equ    4
RollOver equ    0

_TEXT   ends

_DATA   SEGMENT  DWORD PUBLIC 'DATA'

        public HalpLargestClockMS, HalpNextMSRate, HalpPendingMSRate
HalpLargestClockMS      dd      15      ; Table goes to 15MS
HalpNextMSRate          dd      0
HalpPendingMSRate       dd      0

_DATA   ends


PAGELK  SEGMENT DWORD PUBLIC 'CODE'
        ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING


        page ,132
        subttl  "Initialize Clock"
;++
;
; VOID
; HalpInitializeClock (
;    )
;
; Routine Description:
;
;    This routine initialize system time clock using 8254 timer1 counter 0
;    to generate an interrupt at every 15ms interval at 8259 irq0.
;
;    See the definitions of TIME_INCREMENT and ROLLOVER_COUNT if clock rate
;    needs to be changed.
;
; Arguments:
;
;    None
;
; Return Value:
;
;    None.
;
;--
cPublicProc _HalpInitializeClock      ,0

        mov     eax, PCR[PcPrcb]
        cmp     byte ptr [eax].PbCpuType, 4     ; 486 or better?
        jc      short @f                        ; no, skip

        mov     HalpLargestClockMS, 10          ; Limit 486's to 10MS
@@:
        mov     eax, HalpLargestClockMS
        mov     ecx, HalpRollOverTable.TimeIncr
        mov     edx, HalpRollOverTable[eax*8-8].TimeIncr
        mov     eax, HalpRollOverTable[eax*8-8].RollOver

        mov     HalpCurrentTimeIncrement, edx

;
; (ecx) = Min time_incr
; (edx) = Max time_incr
; (eax) = max roll over count
;

        push    eax
        stdCall _KeSetTimeIncrement, <edx, ecx>
        pop     ecx

;
; timer latency watchdog initialization
;
        cmp     _HalpTimerWatchdogEnabled, 0
        jz      short @f

        .586p
        rdtsc
        .386p
        mov     _HalpWatchdogAvgCounter, COUNTER_TICKS_FOR_AVG
        mov     _HalpWatchdogTscLow, eax
        mov     _HalpWatchdogTscHigh, edx
        xor     eax, eax
        mov     _HalpWatchdogCountLow, eax
        mov     _HalpWatchdogCountHigh, eax
@@:    

        pushfd                          ; save caller's eflag
        cli                             ; make sure interrupts are disabled

;
; Set clock rate
; (ecx) = RollOverCount
;

        mov     al,COMMAND_8254_COUNTER0+COMMAND_8254_RW_16BIT+COMMAND_8254_MODE2
        out     TIMER1_CONTROL_PORT0, al ;program count mode of timer 0
        IoDelay
        mov     al, cl
        out     TIMER1_DATA_PORT0, al   ; program timer 0 LSB count
        IoDelay
        mov     al,ch
        out     TIMER1_DATA_PORT0, al   ; program timer 0 MSB count

        popfd                             ; restore caller's eflag
        mov     HalpCurrentRollOver, ecx  ; Set RollOverCount & initialized

        stdRET    _HalpInitializeClock

stdENDP _HalpInitializeClock

PAGELK  ends


_TEXT$03  SEGMENT DWORD PUBLIC 'CODE'

        page ,132
        subttl  "Query Performance Counter"
;++
;
; LARGE_INTEGER
; KeQueryPerformanceCounter (
;    OUT PLARGE_INTEGER PerformanceFrequency OPTIONAL
;    )
;
; Routine Description:
;
;    This routine returns current 64-bit performance counter and,
;    optionally, the Performance Frequency.
;
;    Note this routine can NOT be called at Profiling interrupt
;    service routine.  Because this routine depends on IRR0 to determine
;    the actual count.
;
;    Also note that the performace counter returned by this routine
;    is not necessary the value when this routine is just entered.
;    The value returned is actually the counter value at any point
;    between the routine is entered and is exited.
;
; Arguments:
;
;    PerformanceFrequency [TOS+4] - optionally, supplies the address
;        of a variable to receive the performance counter frequency.
;
; Return Value:
;
;    Current value of the performance counter will be returned.
;
;--


;
; Parameter definitions
;

KqpcFrequency   EQU     [esp+12]        ; User supplied Performance Frequence

cPublicProc _KeQueryPerformanceCounter      ,1
;
; First check to see if the performance counter has been initialized yet.
; Since the kernel debugger calls KeQueryPerformanceCounter to support the
; !timer command, we need to return something reasonable before 8254
; initialization has occured.  Reading garbage off the 8254 is not reasonable.
;
        cmp     HalpCurrentRollOver, 0
        je      Kqpc50

        push    ebx
        push    esi

Kqpc01: pushfd
        cli
Kqpc20:

;
; Fetch the base value.  Note that interrupts are off.
;

        mov     ebx, HalpPerfCounterLow
        mov     esi, HalpPerfCounterHigh ; [esi:ebx] = Performance counter

;
; Fetch the current counter value from the hardware
;

        mov     al, COMMAND_8254_LATCH_READ+COMMAND_8254_COUNTER0
                                        ;Latch PIT Ctr 0 command.
        out     TIMER1_CONTROL_PORT0, al
        IODelay
        in      al, TIMER1_DATA_PORT0   ;Read PIT Ctr 0, LSByte.
        IODelay
        movzx   ecx,al                  ;Zero upper bytes of (ECX).
        in      al, TIMER1_DATA_PORT0   ;Read PIT Ctr 0, MSByte.
        mov     ch, al                  ;(CX) = PIT Ctr 0 count.

;
; Now enable interrupts such that if timer interrupt is pending, it can
; be serviced and update the PerformanceCounter.  Note that there could
; be a long time between the sti and cli because ANY interrupt could come
; in in between.
;

        popfd                           ; don't re-enable interrupts if
        nop                             ; the caller had them off!
                                        ; (kernel debugger calls this function
                                        ; with interrupts disabled)

        jmp     $+2                     ; allow interrupt in case counter
                                        ; has wrapped

        pushfd
        cli

;
; Fetch the base value again.
;
; Note: it's possible that the counter wrapped before we read the value
; and that the timer tick interrupt did not occur during while interrupts
; where enabled.  (ie, there's a delay between when the device raises the
; interrupt and when the processor see it).
;
;
; note *2 -


        mov     eax, HalpPerfCounterLow
        mov     edx, HalpPerfCounterHigh ; [edx:eax] = new counter value

;
; Compare the two reads of Performance counter.  If they are different,
; start over
;

        cmp     eax, ebx
        jne     short Kqpc20
        cmp     edx, esi
        jne     short Kqpc20

        neg     ecx                     ; PIT counts down from 0h
        add     ecx, HalpCurrentRollOver
        jnc     short Kqpc60

Kqpc30:
        add     eax, ecx
        adc     edx, 0                  ; [edx:eax] = Final result

        cmp     edx, HalpLastPerfCounterHigh
        jc      short Kqpc70            ; jmp if edx < lastperfcounterhigh
        jne     short Kqpc35            ; jmp if edx > lastperfcounterhigh

        cmp     eax, HalpLastPerfCounterLow
        jc      short Kqpc70            ; jmp if eax < lastperfcounterlow

Kqpc35:
        mov     HalpLastPerfCounterLow, eax
        mov     HalpLastPerfCounterHigh, edx

        popfd                           ; restore interrupt flag

;
;   Return the freq. if caller wants it.
;

        cmp     dword ptr KqpcFrequency, 0 ; is it a NULL variable?
        jz      short Kqpc40            ; if z, yes, go exit

        mov     ecx, KqpcFrequency      ; (ecx)-> Frequency variable
        mov     DWORD PTR [ecx], PERFORMANCE_FREQUENCY ; Set frequency
        mov     DWORD PTR [ecx+4], 0

Kqpc40:
        pop     esi                     ; restore esi and ebx
        pop     ebx
        stdRET    _KeQueryPerformanceCounter


Kqpc50:
; Initialization hasn't occured yet, so just return zeroes.
        mov     eax, 0
        mov     edx, 0
        stdRET    _KeQueryPerformanceCounter

Kqpc60:
;
; The current count is larger then the HalpCurrentRollOver.  The only way
; that could happen is if there is an interrupt in route to the processor
; but it was not processed  while interrupts were enabled.
;
        mov     esi, [esp]                  ; (esi) = flags
        mov     ecx, HalpCurrentRollOver    ; (ecx) = max possible value
        popfd                               ; restore flags

        test    esi, EFLAGS_INTERRUPT_MASK
        jnz     Kqpc01                  ; ints are enabled, problem should go away

        pushfd                          ; fix stack
        jmp     short Kqpc30            ; ints are disabled, use max count (ecx)


Kqpc70:
;
; The current count is smaller then the last returned count.  The only way
; this should occur is if there is an interrupt in route to the processor
; which was not been processed.
;

        mov     ebx, HalpLastPerfCounterLow
        mov     esi, HalpLastPerfCounterHigh

        mov     ecx, ebx
        or      ecx, esi                ; is last returned value 0?
        jz      short Kqpc35            ; Yes, then just return what we have

        ; sanity check - make sure count is not off by bogus amount
        sub     ebx, eax
        sbb     esi, edx
        jnz     short Kqpc75            ; off by bogus amount
        cmp     ebx, HalpCurrentRollOver
        jg      short Kqpc75            ; off by bogus amount

        sub     eax, ebx
        sbb     edx, esi                ; (edx:eax) = last returned count

        mov     ecx, [esp]              ; (ecx) = flags
        popfd

        test    ecx, EFLAGS_INTERRUPT_MASK
        jnz     Kqpc01                  ; ints enabled, problem should go away

        pushfd                          ; fix stack
        jmp     Kqpc35                  ; ints disabled, just return last count

Kqpc75:
        popfd
        xor     eax, eax                ; reset bogus values
        mov     HalpLastPerfCounterLow, eax
        mov     HalpLastPerfCounterHigh, eax
        jmp     Kqpc01                  ; go try again

stdENDP _KeQueryPerformanceCounter

;++
;
; VOID
; HalCalibratePerformanceCounter (
;     IN LONG volatile *Number,
;     IN ULONGLONG NewCount
;     )
;
; /*++
;
; Routine Description:
;
;     This routine resets the performance counter value for the current
;     processor to zero. The reset is done such that the resulting value
;     is closely synchronized with other processors in the configuration.
;
; Arguments:
;
;     Number - Supplies a pointer to count of the number of processors in
;     the configuration.
;
;     NewCount - Supplies the value to synchronize the counter too
;
;     Note: this hal does not currently set the counter
;
; Return Value:
;
;     None.
;--
cPublicProc _HalCalibratePerformanceCounter,3
        mov     eax, [esp+4]            ; ponter to Number
        pushfd                          ; save previous interrupt state
        cli                             ; disable interrupts (go to high_level)

    lock dec    dword ptr [eax]         ; count down

@@:     YIELD
        cmp     dword ptr [eax], 0      ; wait for all processors to signal
        jnz     short @b

    ;
    ; Nothing to calibrate on a UP machine...
    ;

        popfd                           ; restore interrupt flag
        stdRET    _HalCalibratePerformanceCounter

stdENDP _HalCalibratePerformanceCounter



        page ,132
        subttl  "System Clock Interrupt"
;++
;
; Routine Description:
;
;    This routine is entered as the result of an interrupt generated by CLOCK.
;    Its function is to dismiss the interrupt, raise system Irql to
;    CLOCK2_LEVEL, update performance counter and transfer control to the
;    standard system routine to update the system time and the execution
;    time of the current thread
;    and process.
;
; Arguments:
;
;    None
;    Interrupt is disabled
;
; Return Value:
;
;    Does not return, jumps directly to KeUpdateSystemTime, which returns
;
;    Sets Irql = CLOCK2_LEVEL and dismisses the interrupt
;
;--
        ENTER_DR_ASSIST Hci_a, Hci_t

cPublicProc _HalpClockInterrupt     ,0

;
; Save machine state in trap frame
;

        ENTER_INTERRUPT Hci_a, Hci_t

;
; (esp) - base of trap frame
;

;
; Dismiss interrupt and raise irq level to clock2 level
;

Hci10:
        push    CLOCK_VECTOR
        sub     esp, 4                  ; allocate space to save OldIrql
        stdCall   _HalBeginSystemInterrupt, <CLOCK2_LEVEL, CLOCK_VECTOR, esp>

        or      al,al                           ; check for spurious interrupt
        jz      Hci100

;
; Update performance counter
;

        xor     ebx, ebx
        mov     eax, HalpCurrentRollOver
        add     HalpPerfCounterLow, eax         ; update performace counter
        adc     HalpPerfCounterHigh, ebx

;
; Timer latency watchdog
;

        cmp     _HalpTimerWatchdogEnabled, 0
        jz      Hci14

        .586p
        rdtsc
        .386p

;
; Compare difference to watchdog count, while storing a copy of the
; current counter.
;

        push    eax
        push    edx

        sub     eax, _HalpWatchdogTscLow
        sbb     edx, _HalpWatchdogTscHigh

        pop     _HalpWatchdogTscHigh
        pop     _HalpWatchdogTscLow
        js      Hci115                      ; Was this a bogus counter?
                                            ;   (e.g, negative delta)

        push    eax
        mov     ecx, dword ptr _KdEnteredDebugger
        xor     eax, eax
        xchg    eax, [ecx]
        or      al, al                      
        pop     eax
        jnz     Hci14

        cmp     HalpPendingMSRate, ebx      ; Was a new rate set during last
        jnz     Hci14                       ; tick?  Yes, skip this compare

;
; If we need to compute the average of the time-stamp counter for
; the current period, add the delta to the counter.
;

        cmp     _HalpWatchdogAvgCounter, ebx
        jnz     Hci12

        cmp     edx, _HalpWatchdogCountHigh
        ja      short Hci11
        jb      Hci14

        cmp     eax, _HalpWatchdogCountLow
        jbe     Hci14

Hci11:  
        cmp     dword ptr [_HalpTimerWatchdogStorageOverflow], 0
        jne     short Hci115


;
; copy FRAME_COPY_SIZE dwords from the stack, or to next page boundary,
; whichever is less
;       

        push    esi
        push    edi
        lea     esi, [esp+8]
        lea     ecx, [esi + PAGE_SIZE - 1]
        and     ecx, NOT(PAGE_SIZE - 1)
        sub     ecx, esi
        shr     ecx, 2
        cmp     ecx, FRAME_COPY_SIZE
        jbe     short Hci111
        mov     ecx, FRAME_COPY_SIZE
Hci111:
        mov     edi, dword ptr _HalpTimerWatchdogCurFrame
        rep     movsd
        add     _HalpTimerWatchdogCurFrame, (FRAME_COPY_SIZE*4)
;
; If we didn't copy an entire FRAME_COPY_SIZE dwords, zero fill.
;
        mov     ecx, dword ptr _HalpTimerWatchdogCurFrame
        sub     ecx, edi
        shr     ecx, 2
        xor     eax, eax
        rep     stosd
        cmp     edi, dword ptr _HalpTimerWatchdogLastFrame
        jbe     short Hci112
        mov     dword ptr [_HalpTimerWatchdogStorageOverflow], 1
Hci112:

        pop     edi
        pop     esi

Hci115:


;
; reset last time so that we're accurate after the trap
;
        .586p
        rdtsc
        .386p
        mov     _HalpWatchdogTscHigh, edx
        mov     _HalpWatchdogTscLow, eax
        
        jmp     short Hci14

Hci12:
;
; Increment the total counter, perform average when the count is reached
;

        add     _HalpWatchdogCountLow, eax
        adc     _HalpWatchdogCountHigh, edx        
        dec     _HalpWatchdogAvgCounter
        jnz     short Hci14

        mov     edx, _HalpWatchdogCountHigh
        mov     eax, _HalpWatchdogCountLow

;
; compute the average * 2, this measures when we have missed 
; an interrupt at this rate.
;                 
        mov     ecx, COUNTER_TICKS_AVG_SHIFT - 1
Hci13:    
        shr     edx, 1
        rcr     eax, 1
        loop    short Hci13

        mov     _HalpWatchdogCountLow, eax
        mov     _HalpWatchdogCountHigh, edx

Hci14:

;
; Check for any more work
;

        mov     eax, HalpCurrentTimeIncrement

        cmp     _HalpClockWork, ebx         ; Any clock interrupt work desired?
        jz      _KeUpdateSystemTime@0       ; No, process tick

        cmp     _HalpClockMcaQueueDpc, bl
        je      short Hci20

        mov     _HalpClockMcaQueueDpc, bl

;
; Queue MCA Dpc
;

        push    eax
        stdCall _HalpMcaQueueDpc            ; Queue MCA Dpc
        pop     eax


Hci20:
;
; (esp)   = OldIrql
; (esp+4) = Vector
; (esp+8) = base of trap frame
; ebp = trap frame
; eax = time increment
; ebx = 0
;
        cmp     _HalpClockSetMSRate, bl     ; New clock rate desired?
        jz      _KeUpdateSystemTime@0       ; No, process tick

;
; Time of clock frequency is being changed.  See if the 8254 was
; was reprogrammed for a new rate during last tick
;
        cmp     HalpPendingMSRate, ebx      ; Was a new rate set durning last
        jnz     short Hci50                 ; tick?  Yes, go update globals

Hci40:
; (eax) = time increment for current tick

;
; A new clock rate needs to be set.  Setting the rate here will
; cause the tick after the next tick to be at the new rate.
; (the next tick is already in progress by the 8254 and will occur
; at the same rate as this tick)
;
        mov     ebx, HalpNextMSRate
        mov     HalpPendingMSRate, ebx  ; pending rate

        mov     ecx, HalpRollOverTable[ebx*8-8].RollOver

;
; Set clock rate
; (ecx) = RollOverCount
;
        push    eax                     ; save current tick's rate

        mov     al,COMMAND_8254_COUNTER0+COMMAND_8254_RW_16BIT+COMMAND_8254_MODE2
        out     TIMER1_CONTROL_PORT0, al ;program count mode of timer 0
        IoDelay
        mov     al, cl
        out     TIMER1_DATA_PORT0, al   ; program timer 0 LSB count
        IoDelay
        mov     al,ch
        out     TIMER1_DATA_PORT0, al   ; program timer 0 MSB count

        pop     eax

;
; (esp)   = OldIrql
; (esp+4) = Vector
; (esp+8) = base of trap frame
; ebp = trap frame
; eax = time increment
;
        jmp     _KeUpdateSystemTime@0   ; dispatch this tick

Hci50:
;
; The next tick will occur at the rate which was programmed during the last
; tick. Update globals for new rate which starts with the next tick.
;
; (eax) = time increment for current tick
;
        mov     ebx, HalpPendingMSRate
        mov     ecx, HalpRollOverTable[ebx*8-8].RollOver
        mov     edx, HalpRollOverTable[ebx*8-8].TimeIncr

        mov     HalpCurrentRollOver, ecx
        mov     HalpCurrentTimeIncrement, edx   ; next tick rate
        mov     HalpPendingMSRate, 0    ; no longer pending, clear it

        cmp     _HalpTimerWatchdogEnabled, 0
        jz      short @f

;
; Schedule to recalibrate watchdog counter
;
        push    eax
        .586p
        rdtsc
        .386p
        mov     _HalpWatchdogAvgCounter, COUNTER_TICKS_FOR_AVG
        mov     _HalpWatchdogTscLow, eax
        mov     _HalpWatchdogTscHigh, edx

        xor     eax,eax
        mov     _HalpWatchdogCountHigh, eax
        mov     _HalpWatchdogCountLow, eax
        pop     eax
@@:


        cmp     ebx, HalpNextMSRate     ; new rate == NextRate?
        jne     Hci40                   ; no, go set new pending rate

        mov     _HalpClockSetMSRate, 0  ; all done setting new rate

        jmp     _KeUpdateSystemTime@0   ; dispatch this tick

Hci100:
        add     esp, 8                  ; spurious, no EndOfInterrupt
        SPURIOUS_INTERRUPT_EXIT         ; exit interrupt without eoi

stdENDP _HalpClockInterrupt

;++
;
; ULONG
; HalSetTimeIncrement (
;     IN ULONG DesiredIncrement
;     )
;
; /*++
;
; Routine Description:
;
;    This routine initialize system time clock to generate an
;    interrupt at every DesiredIncrement interval.
;
; Arguments:
;
;     DesiredIncrement - desired interval between every timer tick (in
;                        100ns unit.)
;
; Return Value:
;
;     The *REAL* time increment set.
;--
cPublicProc _HalSetTimeIncrement,1

        mov     eax, [esp+4]                ; desired setting
        xor     edx, edx
        mov     ecx, 10000
        div     ecx                         ; round to MS

        cmp     eax, HalpLargestClockMS     ; MS > max?
        jc      short @f
        mov     eax, HalpLargestClockMS     ; yes, use max
@@:
        or      eax, eax                    ; MS < min?
        jnz     short @f
        inc     eax                         ; yes, use min
@@:
        mov     HalpNextMSRate, eax
        mov     _HalpClockSetMSRate, 1      ; New clock rate desired.

        mov     eax, HalpRollOverTable[eax*8-8].TimeIncr
        stdRET  _HalSetTimeIncrement

stdENDP _HalSetTimeIncrement
_TEXT$03   ends

        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halx86\i386\ixcmos.inc ===
;/*
;++
;
;   Copyright (c) 1989  Microsoft Corporation
;
;   Module Name:
;
;       ixcmos.inc
;
;   Abstract:
;
;       This module contains common definitions used by the CMOS.
;
;   Author:
;
;       Landy Wang (corollary!landy) 04-Dec-1992
;
;               (Moved from ixclock.asm)
;
;--

;
;	_HalpAcquireCmosSpinLock and _HalpReleaseCmosSpinLock
;	must be called before accessing the CMOS in both uniprocessor
;	and multiprocessor systems.

RTCIRQ                  EQU     8       ; IRQ number for RTC interrupt
CMOS_CONTROL_PORT       EQU     70h     ; command port for cmos
CMOS_DATA_PORT          EQU     71h     ; cmos data port

REGISTER_B_ENABLE_PERIODIC_INTERRUPT EQU     01000010B
                                        ; RT/CMOS Register 'B' Init byte
                                        ; Values for byte shown are
                                        ;  Bit 7 = Update inhibit
                                        ;  Bit 6 = Periodic interrupt enable
                                        ;  Bit 5 = Alarm interrupt disable
                                        ;  Bit 4 = Update interrupt disable
                                        ;  Bit 3 = Square wave disable
                                        ;  Bit 2 = BCD data format
                                        ;  Bit 1 = 24 hour time mode
                                        ;  Bit 0 = Daylight Savings disable

REGISTER_B_DISABLE_PERIODIC_INTERRUPT EQU    00000010B
REGISTER_B_ENABLE_ALARM_INTERRUPT     EQU    00100000B
REGISTER_B_DISABLE_ALARM_INTERRUPT    EQU    00000000B
REGISTER_B_24HOUR_MODE                EQU    00000010B

;
; CMOS_READ
;
; Description: This macro reads a byte from the CMOS register specified
;        in (AL).
;
; Parameter: (AL) = address/register to read
; Returns: (AL) = data
;

CMOS_READ       MACRO
        OUT     CMOS_CONTROL_PORT,AL    ; ADDRESS LOCATION AND DISABLE NMI
        IODelay                         ; I/O DELAY
        IN      AL,CMOS_DATA_PORT       ; READ IN REQUESTED CMOS DATA
        IODelay                         ; I/O DELAY
ENDM

;
; CMOS_WRITE
;
; Description: This macro reads a byte from the CMOS register specified
;        in (AL).
;
; Parameter: (AL) = address/register to read
;            (AH) = data to be written
;
; Return: None
;

CMOS_WRITE      MACRO
        OUT     CMOS_CONTROL_PORT,AL    ; ADDRESS LOCATION AND DISABLE NMI
        IODelay                         ; I/O DELAY
        MOV     AL,AH                   ; (AL) = DATA
        OUT     CMOS_DATA_PORT,AL       ; PLACE IN REQUESTED CMOS LOCATION
        IODelay                         ; I/O DELAY
ENDM


CMOS_STATUS_BUSY        EQU     80H     ; Time update in progress
RTC_OFFSET_SECOND       EQU     0       ; second field of RTC memory
RTC_OFFSET_SECOND_ALARM EQU     1       ; second alarm field of RTC memory
RTC_OFFSET_MINUTE       EQU     2       ; minute field of RTC memory
RTC_OFFSET_MINUTE_ALARM EQU     3       ; minute alarm field of RTC memory
RTC_OFFSET_HOUR         EQU     4       ; hour field of RTC memory
RTC_OFFSET_HOUR_ALARM   EQU     5       ; hour alarm field of RTC memory
RTC_OFFSET_DAY_OF_WEEK  EQU     6       ; day-of-week field of RTC memory
RTC_OFFSET_DATE_OF_MONTH EQU    7       ; date-of-month field of RTC memory
RTC_OFFSET_MONTH        EQU     8       ; month field of RTC memory
RTC_OFFSET_YEAR         EQU     9       ; year field of RTC memory
RTC_OFFSET_CENTURY_MCA  EQU     37h     ; Century field of RTC memory for MCA
RTC_OFFSET_CENTURY      EQU     32h     ; Century field of RTC memory
RTC_OFFSET_CENTURY_DS   EQU    148h     ; Bank 1, 48. Century field for DS
BANK1                   EQU    100h

;
; BCD_TO_BIN
;
; Description: Convert BCD value to binary
;
; Parameter:
;     Input: (AL) = 2 digit BCD number to convert
;     Output: (AX) = Binary equivalent (all in AL)
;
; Return: None.
;

BCD_TO_BIN      macro

        xor     ah,ah
        rol     ax,4
        ror     al,4
        aad
endm

;
; BIN_TO_BCD
;
; Description: Convert binary value to BCD.
;
; Parameter:
;     Input: (AL) = binary value to be converted.
;     Output: (AX) = BCD (all in AL)
;
; Return: None.
;

BIN_TO_BCD      macro

        aam
        rol     al, 4
        ror     ax, 4
endm
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halx86\i386\ix8259.inc ===
;/*
;++
;
;   Copyright (c) 1989  Microsoft Corporation
;
;   Module Name:
;
;       ix8259.inc
;
;   Abstract:
;
;       This module contains the definitions used by HAL to manipulate
;       8259 interrupt controller and 8259-specific constants.
;
;       WARNING: This file is included by both ASM and C files.
;
;   Author:
;
;       John Vert (jvert) 31-Dec-1991
;
;               (Moved from ke\i386\kimacro.inc)
;
;--
if 0        ; Begin C only code         */

//
// 8259 defines for C code
// BE SURE TO CHANGE THESE VALUES IN BOTH TABLES!
//

#define HIGHEST_LEVEL_FOR_8259  27          // Highest level for standard 8259
#define PRIMARY_VECTOR_BASE     0x30        // Vector base for standard 8259
#if defined(NEC_98)
#if defined(NT_UP_98)
#define PROFILE_VECTOR          (PRIMARY_VECTOR_BASE + 0)   // standard profile
#else 
#define PROFILE_VECTOR          (PRIMARY_VECTOR_BASE + 15)   // standard profile
#endif 
#else  // defined(NEC_98)
#define PROFILE_VECTOR          (PRIMARY_VECTOR_BASE + 8)   // standard profile
#endif // defined(NEC_98)
#define CLOCK_VECTOR            (PRIMARY_VECTOR_BASE + 0)   // standard clock
#define I386_80387_IRQ          0x0d                        // standard npx
#define I386_80387_IRQL         (HIGHEST_LEVEL_FOR_8259 - I386_80387_IRQ)
#define I386_80387_VECTOR       (PRIMARY_VECTOR_BASE + I386_80387_IRQ)
#define PIC_VECTORS             16
#define V2I(a)  (a-PRIMARY_VECTOR_BASE)     // Vector to interrupt macro
#define I386_80387_BUSY_PORT    (PUCHAR)0xF0

#ifndef NEC_98
#define PIC_SLAVE_IRQ           2
#define PIC_SLAVE_REDIRECT      9
#else
#define PIC_SLAVE_IRQ           7
#define PIC_SLAVE_REDIRECT      8
#endif


#define EISA_EDGE_LEVEL0        0x4D0
#define EISA_EDGE_LEVEL1        0x4D1


/*
endif

;
; Same 8259 defines for assemble code
; BE SURE TO CHANGE THESE VALUES IN BOTH TABLES!
;

HIGHEST_LEVEL_FOR_8259  equ 27
PRIMARY_VECTOR_BASE     equ 30h
ifdef NEC_98
ifdef NT_UP_98
PROFILE_VECTOR          equ (PRIMARY_VECTOR_BASE + 0)
else 
PROFILE_VECTOR          equ (PRIMARY_VECTOR_BASE + 15)
endif
else  ; NEC_98
PROFILE_VECTOR          equ (PRIMARY_VECTOR_BASE + 8)
endif ; NEC_98
CLOCK_VECTOR            equ (PRIMARY_VECTOR_BASE + 0)
I386_80387_IRQ          equ 0dh
I386_80387_IRQL         equ (HIGHEST_LEVEL_FOR_8259 - I386_80387_IRQ)
I386_80387_VECTOR       equ (PRIMARY_VECTOR_BASE + I386_80387_IRQ)
I386_80387_BUSY_PORT    equ 0f0h    ; port to dismiss busy error line

ifdef NEC_98
PIC_SLAVE_IRQ           equ 7
else
PIC_SLAVE_IRQ           equ 2
endif

;
; The rest of the file are macros used in assemble only.
;

;++
;
;   SET_8259_MASK
;
;   Macro Description:
;
;       This macro sets 8259 interrupt mask register with the mask
;       passed from eax register.
;
;       Note: Currently, only two 8259s are support.  As a result,
;       only ax contains valid mask.
;
;   Arguments:
;
;       (eax) = mask for setting 8259 interrupt mask register
;
;--

SET_8259_MASK   macro
local   a                               ; define local labels

        out     PIC1_PORT1, al          ; set master 8259 mask
        shr     eax, 8                  ; shift slave 8259 mask to al
        out     PIC2_PORT1, al          ; set slave 8259 mask
a:
endm

;
;  Interrupt controller register addresses
;

ifdef NEC_98
PIC1_PORT0 equ 00H
PIC1_PORT1 equ 02H
PIC2_PORT0 equ 08H
PIC2_PORT1 equ 0AH
else  ; NEC_98
PIC1_PORT0 equ 020H
PIC1_PORT1 equ 021H
PIC2_PORT0 equ 0A0H
PIC2_PORT1 equ 0A1H
endif ; NEC_98

EISA_EDGE_LEVEL0        EQU     4D0h
EISA_EDGE_LEVEL1        EQU     4D1h

;
;  Commands for Interrupt controller
;

PIC1_EOI_MASK equ 060H
ifdef NEC_98
PIC2_EOI equ 067H                       ; special EOI
else  ; NEC_98
PIC2_EOI equ 062H
endif ; NEC_98
OCW2_NON_SPECIFIC_EOI equ 020H
OCW2_SPECIFIC_EOI equ 060H
OCW3_READ_ISR equ 0BH
OCW3_READ_IRR equ 0AH


;++
;
;   IODELAY
;
;   Macro Description:
;
;       This macro simply does a jmp to next instruction to synchronize
;       IO port access.
;
;   Arguments:
;
;       None
;
;--

IODELAY         macro
ifdef NEC_98
        out     5fh,al              ; same effect with "stdcall IODelay8259"
else  ; NEC_98
        jmp     $+2
endif ; NEC_98
endm


;++
;
;   PICDELAY
;
;   Macro Description:
;
;       This macro does an inb on interrupt mask register to provide the
;       time for 8259 to get stabled.
;
;       Why do we need this?
;
;       This is because:
;       . The 80386 has a delayed write to memory and delayed output to IO
;         capability and
;       . 8259 needs some time to settle
;
;       It is possible for the actual output cycle to 8259 to occur after
;       the completion of instructions following the out instruction.  For
;       example, the STI instruction after SET_MASK and dismiss interrupt
;       macros may complete before 8259 actually drops the interrupt.  We don't
;       want this happen in MCA system.
;
;       You may argue that most OEMS add about 450ns delay to solve the
;       back-to-back IO (delay) problem.  But, remember that STI is not an IO
;       instruction.
;
;   Arguments:
;
;       None
;
;   NOTE: * The content of AL will be destroyed on return.
;
;--

PIC1DELAY       macro
        in      al, PIC1_PORT1
endm

PIC2DELAY       macro
        in      al, PIC2_PORT1
endm

;++
;
;   SOFT_INTERRUPT_EXIT
;
;   Macro Description:
;
;       This macro is executed on return from the soft interrupt
;       service routine.  Its function is to restore privileged processor
;       state, and continue thread execution.
;
;   Arguments:
;
;       (TOS) = previous irql
;       (TOS+4 ...) = machine_state frame
;
;--

SOFT_INTERRUPT_EXIT macro

        EXTRNP  _HalpEndSoftwareInterrupt,1
        cli
        call    _HalpEndSoftwareInterrupt@4     ; restore irql
        SPURIOUS_INTERRUPT_EXIT                 ; exit interrupt without EOI
endm
;*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halx86\i386\halp.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1991  Microsoft Corporation

Module Name:

    halp.h

Abstract:

    This header file defines the private Hardware Architecture Layer (HAL)
    interfaces, defines and structures.

Author:

    John Vert (jvert) 11-Feb-92


Revision History:

--*/

#ifndef _HALP_H_
#define _HALP_H_
#include "nthal.h"
#include "halnls.h"

//
//Pickup the pnp guid definitions.
//
#include "wdmguid.h"


#if defined(NEC_98)
#include "nec98.h"
#else
#if MCA
#include "mca.h"
#else
#include "eisa.h"
#endif
#endif // NEC_98

#ifndef _HALI_
#include "hali.h"
#endif

#ifdef RtlMoveMemory
#undef RtlMoveMemory

//  #undef RtlCopyMemory
//  #undef RtlFillMemory
//  #undef RtlZeroMemory

//#define RtlCopyMemory(Destination,Source,Length) RtlMoveMemory((Destination),(Source),(Length))

#if defined(_WIN64)

__inline
VOID
RtlMoveMemory (
   PVOID Destination,
   CONST VOID *Source,
   SIZE_T Length
   )
{
    memmove(Destination,Source,Length);
}

#else

VOID
RtlMoveMemory (
   PVOID Destination,
   CONST VOID *Source,
   SIZE_T Length
   );

#endif



//  VOID
//  RtlFillMemory (
//     PVOID Destination,
//     ULONG Length,
//     UCHAR Fill
//     );
//  
//  VOID
//  RtlZeroMemory (
//     PVOID Destination,
//     ULONG Length
//     );
//  

#endif

#if defined(_AMD64_)

//
// A temporary macro used to indicate that a particular piece of code
// has never been executed on AMD64 before, and should be examined
// carefully for correct operation.
// 

#define AMD64_COVERAGE_TRAP() DbgBreakPoint()

//
// The following prototypes are not available from the standard HAL headers
// due to the fact that NO_LEGACY_DRIVERS is defined while compiling the
// HAL... however, they are used internally.
//

NTSTATUS
HalAssignSlotResources (
    IN PUNICODE_STRING RegistryPath,
    IN PUNICODE_STRING DriverClassName OPTIONAL,
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT DeviceObject,
    IN INTERFACE_TYPE BusType,
    IN ULONG BusNumber,
    IN ULONG SlotNumber,
    IN OUT PCM_RESOURCE_LIST *AllocatedResources
    );

ULONG
HalGetInterruptVector(
    IN INTERFACE_TYPE  InterfaceType,
    IN ULONG BusNumber,
    IN ULONG BusInterruptLevel,
    IN ULONG BusInterruptVector,
    OUT PKIRQL Irql,
    OUT PKAFFINITY Affinity
    );

ULONG
HalGetBusData(
    IN BUS_DATA_TYPE BusDataType,
    IN ULONG BusNumber,
    IN ULONG SlotNumber,
    IN PVOID Buffer,
    IN ULONG Length
    );

ULONG
HalSetBusData(
    IN BUS_DATA_TYPE BusDataType,
    IN ULONG BusNumber,
    IN ULONG SlotNumber,
    IN PVOID Buffer,
    IN ULONG Length
    );

//
// We are sharing code that was written for the x86.  There are some
// macros with identical meanings but different names in AMD64.  Following
// are some definitions to abstract those differences.
//

//
// CLOCK2_LEVEL on x86 is CLOCK_LEVEL on AMD64.
//

#define CLOCK2_LEVEL CLOCK_LEVEL

//
// X86 EFLAGS_INTERRUPT_MASK == AMD64 EFLAGS_IF_MASK
// 

#define EFLAGS_INTERRUPT_MASK EFLAGS_IF_MASK

//
// The PCR's pointer to the current prcb is named Prcb, while on AMD64
// it is named CurrentPrcb.
//
// The CurrentPrcb() macro is used to abstract this difference.
//

#define CurrentPrcb(x) (x)->CurrentPrcb

//
// The x86 KiReturnHandlerAddressFromIDT() is the equivalent of the AMD64's
// KeGetIdtHandlerAddress()
// 

#define KiReturnHandlerAddressFromIDT(v) (ULONG_PTR)KeGetIdtHandlerAddress(v)

//
// More macro and structure name differences
//

#define RDMSR(m)   ReadMSR(m)
#define WRMSR(m,d) WriteMSR(m,d)
#define KGDTENTRY  KGDTENTRY64
#define PKGDTENTRY PKGDTENTRY64

#define PIOPM_SIZE (sizeof(KIO_ACCESS_MAP) + sizeof(ULONG))

//
// The AMD64 in long mode uses 8-byte PTE entries, which have the same format
// as Pentium PAE page tables.
//

#if !defined(_HALPAE_)
#define _HALPAE_ 1
#endif

#define HARDWARE_PTE_X86PAE HARDWARE_PTE
#define HARDWARE_PTE_X86    HARDWARE_PTE

#define PHARDWARE_PTE_X86PAE PHARDWARE_PTE
#define PHARDWARE_PTE_X86    PHARDWARE_PTE

#define PDE_BASE_X86PAE PDE_BASE
#define PDE_BASE_X86    PDE_BASE

#define PDI_SHIFT_X86PAE PDI_SHIFT
#define PDI_SHIFT_X86    PDI_SHIFT

//
// Fence instruction.
// 

__forceinline
VOID
HalpProcessorFence (
    VOID
    )
{
    CPU_INFO cpuInfo;
    KiCpuId (0,&cpuInfo); 
}

#define HalpGetProcessorFlags() __getcallerseflags()

//
// While _enable() and _disable() are intrinsics in both the AMD64 and X86
// compilers, they are disabled on X86.  HalpDisableInterruptsNoFlags and
// HalpEnableInterrupts are macros used to abstract this difference.
// 

#define HalpDisableInterruptsNoFlags _disable
#define HalpEnableInterrupts _enable

//
// There is no intrinsic for the hlt instruction on AMD64.  HalpHalt()
// is a function call on AMD64, and inline asm on X86.
//

VOID
HalpHalt (
    VOID
    );

//
// On x86, the variables HalpClockSetMSRate, HalpClockMcaQueueDpc and
// HalpClockWork are defined in an .asm module such that HalpClockWork
// is defined as a DWORD that overlapps HalpClockSetMSRate and
// HalpClockMcaQueueDpc.
//
// This is not directly representable in C, so instead HALP_CLOCKWORK_UNION
// is defined and the above variable names are instead redefined to reference
// elements of this union.
//

#define HalpClockSetMSRate   HalpClockWorkUnion.ClockSetMSRate
#define HalpClockMcaQueueDpc HalpClockWorkUnion.ClockMcaQueueDpc
#define HalpClockWork        HalpClockWorkUnion.ClockWork

typedef union {
    struct {
        UCHAR ClockMcaQueueDpc;
        UCHAR ClockSetMSRate;
        UCHAR bReserved1;
        UCHAR bReserved2;
    };
    ULONG ClockWork;
} HALP_CLOCKWORK_UNION;

extern HALP_CLOCKWORK_UNION HalpClockWorkUnion;

#else

//
// Following are X86 definitions that are used to help abstract differences
// between X86 and AMD64 platforms.
// 

#define AMD64_COVERAGE_TRAP()

//
// We are sharing code that was written for the x86.  There are some
// macros with identical meanings but different names in AMD64.  Following
// are some definitions to abstract those differences.
//

//
// The following _KPCR fields have different names but identical purposes.
// 

#define IdtBase IDT
#define GdtBase GDT
#define TssBase TSS

//
// The PCR's pointer to the current prcb is named Prcb, while on AMD64
// it is named CurrentPrcb.
//
// The CurrentPrcb() macro is used to abstract this difference.
//

#define CurrentPrcb(x) (x)->Prcb

//
// On X86, HalpGetProcessorFlags() can be implemented inline.
// 

__forceinline
ULONG
HalpGetProcessorFlags (
    VOID
    )

/*++

Routine Description:

    This procedure retrieves the contents of the EFLAGS register.

Arguments:

    None.

Return Value:

    The 32-bit contents of the EFLAGS register.

--*/

{
    ULONG flags;

    _asm {
        pushfd
        pop     eax
        mov     flags, eax
    }

    return flags;
}

//
// While _enable() and _disable() are intrinsics in both the AMD64 and X86
// compilers, they are disabled in the HAL on X86.
//
// HalpDisableInterruptsNoFlags and HalpEnableInterrupts are macros used
// to abstract this difference.
// 

#define HalpDisableInterruptsNoFlags() _asm cli
#define HalpEnableInterrupts() _asm sti

//
// There is no intrinsic for the hlt instruction on AMD64.  HalpHalt()
// is a function call on AMD64, and inline asm on X86.
//

#define HalpHalt() _asm hlt

//
// Fence instruction
//

__forceinline
VOID
HalpProcessorFence (
    VOID
    )
{
    _asm {
        xor eax, eax
        cpuid
    }
}


#endif

#define PROCESSOR_FENCE HalpProcessorFence()

__forceinline
ULONG
HalpDisableInterrupts(
    VOID
    )

/*++

Routine Description:

    This function saves the state of the processor flag register, clears the
    state of the interrupt flag (disables interrupts), and returns the
    previous contents of the processor flag register.

Arguments:

    None.

Return Value:

    The previous contents of the processor flag register.

--*/

{
    ULONG flags;

    flags = HalpGetProcessorFlags();
    HalpDisableInterruptsNoFlags();

    return flags;
}

__forceinline
VOID
HalpRestoreInterrupts(
    IN ULONG Flags
    )

/*++

Routine Description:

    This procedure restores the state of the interrupt flag based on a
    value returned by a previous call to HalpDisableInterrupts.

Arguments:

    Flags - Supplies the value returned by a previous call to
            HalpDisableInterrupts

Return Value:

    None.

--*/

{
    if ((Flags & EFLAGS_INTERRUPT_MASK) != 0) {
        HalpEnableInterrupts();
    }
}

#if defined(_WIN64)

//
// For AMD64 (and, ideally, all subsequent WIN64 platforms), interrupt
// service routines are C callable.
//

typedef PKSERVICE_ROUTINE PHAL_INTERRUPT_SERVICE_ROUTINE;

#define HAL_INTERRUPT_SERVICE_PROTOTYPE(RoutineName) \
BOOLEAN                                              \
RoutineName (                                        \
    IN PKINTERRUPT Interrupt,                        \
    IN PVOID ServiceContext                          \
)

#define PROCESSOR_CURRENT ((UCHAR)-1)

VOID
HalpSetHandlerAddressToIDTIrql (
    IN ULONG Vector,
    IN PHAL_INTERRUPT_SERVICE_ROUTINE ServiceRoutine,
    IN PVOID Context,
    IN KIRQL Irql
    );

#define KiSetHandlerAddressToIDT Dont_Use_KiSetHandlerAddressToIdt

//
// On AMD64, the HAL does not connect directly to the IDT, rather the
// kernel handles the interrupt and calls a C-callable interrupt routine.
//
// Therefore, HalpSetHandlerAddressToIDT() must supply a context and an
// IRQL in addition to the vector number and interrupt routine.
//
// On X86, the context and IRQL are ignored, as the vector is inserted
// directly into the IDT, such that the service routine is responsible for
// raising IRQL.
// 

#define KiSetHandlerAddressToIDTIrql(v,a,c,i)   \
    HalpSetHandlerAddressToIDTIrql (v,a,c,i);

#else

//
// On X86, the last two parameters of KiSetHandlerAddressToIDTIrql()
// (Context and Irql) are ignored.  The interrupt handlers themselves
// are responsible for raising IRQL.
//

#define KiSetHandlerAddressToIDTIrql(v,a,c,i) KiSetHandlerAddressToIDT(v,a)

//
// For X86, interrupt service routines must be written in assembler because
// they are referenced directly in the IDT and trasferred to directly by
// the processor with a convention that is not C callable.
//
// For purposes of C code that references ISRs, then, the prototype is
// very simple.
//

typedef
VOID
(*PHAL_INTERRUPT_SERVICE_ROUTINE)(
    VOID
    );

#define HAL_INTERRUPT_SERVICE_PROTOTYPE(RoutineName) \
VOID                                                 \
RoutineName (                                        \
    VOID                                             \
)

#endif

typedef  
VOID
(*HALP_MOVE_MEMORY_ROUTINE)(
   PVOID Destination,
   CONST VOID *Source,
   SIZE_T Length
   );

VOID 
HalpMovntiCopyBuffer(
   PVOID Destination,
   CONST VOID *Source,
   ULONG Length
   );

VOID
HalpSetInternalVector (
    IN ULONG    InternalVector,
    IN PHAL_INTERRUPT_SERVICE_ROUTINE HalInterruptSerivceRoutine,
    IN PVOID Context,
    IN KIRQL Irql
    );

extern HALP_MOVE_MEMORY_ROUTINE HalpMoveMemory;

#if MCA

#include "ixmca.h"

#else

#include "ixisa.h"

#endif

#include "ix8259.inc"

#if DBG
extern ULONG HalDebug;

#define HalPrint(x)         \
    if (HalDebug) {         \
        DbgPrint("HAL: ");  \
        DbgPrint x;         \
        DbgPrint("\n");     \
    }
#else
#define HalPrint(x)
#endif

//
// Define map register translation entry structure.
//

typedef struct _TRANSLATION_ENTRY {
    PVOID VirtualAddress;
    ULONG PhysicalAddress;
    ULONG Index;
} TRANSLATION_ENTRY, *PTRANSLATION_ENTRY;

//
// Some devices require a phyicially contiguous data buffers for DMA transfers.
// Map registers are used give the appearance that all data buffers are
// contiguous.  In order to pool all of the map registers a master
// adapter object is used.  This object is allocated and saved internal to this
// file.  It contains a bit map for allocation of the registers and a queue
// for requests which are waiting for more map registers.  This object is
// allocated during the first request to allocate an adapter which requires
// map registers.
//
// In this system, the map registers are translation entries which point to
// map buffers.  Map buffers are physically contiguous and have physical memory
// addresses less than 0x01000000.  All of the map registers are allocated
// initialially; however, the map buffers are allocated base in the number of
// adapters which are allocated.
//
// If the master adapter is NULL in the adapter object then device does not
// require any map registers.
//

extern POBJECT_TYPE *IoAdapterObjectType;

extern BOOLEAN LessThan16Mb;

extern BOOLEAN HalpEisaDma;

VOID
HalpGrowMapBufferWorker(
    IN PVOID Context
    );

//
// Work item to grow map buffers
//
typedef struct _BUFFER_GROW_WORK_ITEM {
    WORK_QUEUE_ITEM WorkItem;
    PADAPTER_OBJECT AdapterObject;
    ULONG MapRegisterCount;
} BUFFER_GROW_WORK_ITEM, *PBUFFER_GROW_WORK_ITEM;

//
// Map buffer prameters.  These are initialized in HalInitSystem
//

//
// PAE note:
//
// Previously, there was only one class of adapter that we had to double-buffer
// for: adapters with only 24 address lines that could access memory up to
// 16MB.
//
// The HAL tracked these map buffers with a single, global master adapter.
// Associated with this master adapter were three global variables:
//
// - MasterAdapterObject
// - HalpMapBufferSize
// - HalpMapBufferPhysicalAddress
//
// With PAE, we have another class of adapters that require double-buffering:
// specifically, adapters with only 32 address lines that can access memory
// up to 4G.
//
// This meant the introduction of another master adapter along with an
// associated set of variables.  For PAE-capable hals, this data has been
// reorganized into a MASTER_ADAPTER_OBJECT (see ixisa.h).
//
// So now we have two global MASTER_ADAPTER_OBJECT structures:
//
// MasterAdapter24
// MasterAdapter32
//
// The following macros are used in code that is included in PAE-capable
// hals.  It is important to note that in a non-PAE-capable HAL (i.e. one
// that does not have _HALPAE_ defined), the macros must resolve to the
// values that they replaced.
//

#if defined(_HALPAE_)

PADAPTER_OBJECT
HalpAllocateAdapterEx(
    IN ULONG MapRegistersPerChannel,
    IN PVOID AdapterBaseVa,
    IN PVOID ChannelNumber,
    IN BOOLEAN Dma32Bit
    );

extern MASTER_ADAPTER_OBJECT MasterAdapter24;
extern MASTER_ADAPTER_OBJECT MasterAdapter32;

#define HalpMasterAdapterStruc( Dma32Bit )                       \
    ((HalPaeEnabled() && (Dma32Bit)) ? &MasterAdapter32 : &MasterAdapter24)

#define HalpMaximumMapBufferRegisters( Dma32Bit )           \
    (HalpMasterAdapterStruc( Dma32Bit )->MaxBufferPages)

#define HalpMaximumMapRegisters( Dma32Bit )                 \
    (Dma32Bit ? MAXIMUM_PCI_MAP_REGISTER : MAXIMUM_ISA_MAP_REGISTER)

#define HalpMapBufferSize( Dma32Bit )                       \
    (HalpMasterAdapterStruc( Dma32Bit )->MapBufferSize)

#define HalpMapBufferPhysicalAddress( Dma32Bit )     \
    (HalpMasterAdapterStruc( Dma32Bit )->MapBufferPhysicalAddress)

#define HalpMasterAdapter( Dma32Bit ) \
    HalpMasterAdapterStruc( Dma32Bit )->AdapterObject

#else

extern PHYSICAL_ADDRESS HalpMapBufferPhysicalAddress;
extern ULONG HalpMapBufferSize;
extern PADAPTER_OBJECT MasterAdapterObject;

#define HalpAllocateAdapterEx( _m, _a, _c, _d ) \
    HalpAllocateAdapter( _m, _a, _c )

#define HalpMaximumMapBufferRegisters( Dma32Bit ) \
    (MAXIMUM_MAP_BUFFER_SIZE / PAGE_SIZE)

#define HalpMaximumMapRegisters( Dma32Bit ) \
    (MAXIMUM_ISA_MAP_REGISTER)

#define HalpMapBufferSize( Dma32Bit ) HalpMapBufferSize

#define HalpMapBufferPhysicalAddress( Dma32Bit ) \
    (HalpMapBufferPhysicalAddress)

#define HalpMasterAdapter( Dma32Bit ) MasterAdapterObject

#endif

extern ULONG HalpBusType;
extern ULONG HalpCpuType;
extern UCHAR HalpSerialLen;
extern UCHAR HalpSerialNumber[];

#if defined(_AMD64_)

//
// Amd64 decodes 48 bits of virtual address space.
// 

#define MI_DECODE_MASK (((ULONG64)1 << 48) - 1)
#define VA_TRUNC(x) ((ULONG64)(x) & MI_DECODE_MASK)

#else

#define VA_TRUNC(x) (x)

#endif


//
// The following macros are taken from mm\i386\mi386.h.  We need them here
// so the HAL can map its own memory before memory-management has been
// initialized, or during a BugCheck.
//
// MiGetPdeAddress returns the address of the PDE which maps the
// given virtual address.
//

#define MiGetPdeAddressX86(va)  ((PHARDWARE_PTE)(((((ULONG_PTR)(va)) >> 22) << 2) + PDE_BASE))

//
// MiGetPteAddress returns the address of the PTE which maps the
// given virtual address.
//

#define MiGetPteAddressX86(va) ((PHARDWARE_PTE)(((((ULONG_PTR)(va)) >> 12) << 2) + PTE_BASE))

//
// MiGetPteIndex returns the index within a page table of the PTE for the
// given virtual address
//

#define MiGetPteIndexX86(va) (((ULONG_PTR)(va) >> PAGE_SHIFT) & 0x3FF)
#define MiGetPteIndexPae(va) (((ULONG_PTR)(VA_TRUNC(va)) >> PAGE_SHIFT) & 0x1FF)

//
// The following macros are taken from mm\i386\mipae.h.  We need them here
// so the HAL can map its own memory before memory-management has been
// initialized, or during a BugCheck.
//
// MiGetPdeAddressPae returns the address of the PDE which maps the
// given virtual address.
//

#define MiGetPdeAddressPae(va)   ((PHARDWARE_PTE_X86PAE)(PDE_BASE_X86PAE + ((((ULONG_PTR)(VA_TRUNC(va))) >> 21) << 3)))

//
// MiGetPteAddressPae returns the address of the PTE which maps the
// given virtual address.
//

#define MiGetPteAddressPae(va)   ((PHARDWARE_PTE_X86PAE)(PTE_BASE + ((((ULONG_PTR)(VA_TRUNC(va))) >> 12) << 3)))

//
// Resource usage information
//

#pragma pack(1)
typedef struct {
    UCHAR   Flags;
} IDTUsageFlags;

typedef struct {
    KIRQL   Irql;
    UCHAR   BusReleativeVector;
} IDTUsage;

typedef struct _HalAddressUsage{
    struct _HalAddressUsage *Next;
    CM_RESOURCE_TYPE        Type;       // Port or Memory
    UCHAR                   Flags;      // same as IDTUsage.Flags
    struct {
        ULONG   Start;
        ULONG   Length;
    }                       Element[];
} ADDRESS_USAGE;
#pragma pack()

#define IDTOwned            0x01        // IDT is not available for others
#define InterruptLatched    0x02        // Level or Latched
#define RomResource         0x04        // ROM
#define InternalUsage       0x11        // Report usage on internal bus
#define DeviceUsage         0x21        // Report usage on device bus

extern IDTUsageFlags    HalpIDTUsageFlags[];
extern IDTUsage         HalpIDTUsage[];
extern ADDRESS_USAGE   *HalpAddressUsageList;

#define HalpRegisterAddressUsage(a) \
    (a)->Next = HalpAddressUsageList, HalpAddressUsageList = (a);

//
// Temp definitions to thunk into supporting new bus extension format
//

VOID
HalpRegisterInternalBusHandlers (
    VOID
    );

PBUS_HANDLER
HalpAllocateBusHandler (
    IN INTERFACE_TYPE   InterfaceType,
    IN BUS_DATA_TYPE    BusDataType,
    IN ULONG            BusNumber,
    IN INTERFACE_TYPE   ParentBusDataType,
    IN ULONG            ParentBusNumber,
    IN ULONG            BusSpecificData
    );

#define HalpHandlerForBus   HaliHandlerForBus
#define HalpSetBusHandlerParent(c,p)    (c)->ParentHandler = p;

//
// Define function prototypes.
//

VOID
HalInitSystemPhase2(
    VOID
    );

KIRQL
HaliRaiseIrqlToDpcLevel (
   VOID
   );

BOOLEAN
HalpGrowMapBuffers(
    PADAPTER_OBJECT AdapterObject,
    ULONG Amount
    );

PADAPTER_OBJECT
HalpAllocateAdapter(
    IN ULONG MapRegistersPerChannel,
    IN PVOID AdapterBaseVa,
    IN PVOID MapRegisterBase
    );

HAL_INTERRUPT_SERVICE_PROTOTYPE(HalpClockInterrupt);

KIRQL
HalpDisableAllInterrupts (
    VOID
    );

VOID
HalpReenableInterrupts (
    KIRQL NewIrql
    );

#if defined(_AMD64_)

VOID
HalpInitializeProfiling (
    ULONG Number
    );

NTSTATUS
HalpSetProfileSourceInterval(
    IN KPROFILE_SOURCE ProfileSource,
    IN OUT ULONG_PTR   *Interval
    );

NTSTATUS
HalpQueryProfileInformation(
    IN HAL_QUERY_INFORMATION_CLASS  InformationClass,
    IN ULONG     BufferSize,
    OUT PVOID    Buffer,
    OUT PULONG   ReturnedLength
    );

#endif

HAL_INTERRUPT_SERVICE_PROTOTYPE(HalpProfileInterrupt);

VOID
HalpInitializeClock(
    VOID
    );

VOID
HalpInitializeStallExecution(
    IN CCHAR ProcessorNumber
    );

VOID
HalpRemoveFences (
    VOID
    );

VOID
HalpInitializePICs(
    BOOLEAN EnableInterrupts
    );

VOID
HalpIrq13Handler (
    VOID
   );

VOID
HalpFlushTLB (
    VOID
    );

VOID
HalpSerialize (
    VOID
    );

PVOID
HalpMapPhysicalMemory64(
    IN PHYSICAL_ADDRESS PhysicalAddress,
    IN ULONG NumberPages
    );

PVOID
HalpMapPhysicalMemoryWriteThrough64(
    IN PHYSICAL_ADDRESS PhysicalAddress,
    IN ULONG  NumberPages
    );

ULONG
HalpAllocPhysicalMemory(
    IN PLOADER_PARAMETER_BLOCK LoaderBlock,
    IN ULONG MaxPhysicalAddress,
    IN ULONG NoPages,
    IN BOOLEAN bAlignOn64k
    );

VOID
HalpUnmapVirtualAddress(
    IN PVOID    VirtualAddress,
    IN ULONG    NumberPages
    );

PVOID
HalpRemapVirtualAddress64 (
    IN PVOID VirtualAddress,
    IN PHYSICAL_ADDRESS PhysicalAddress,
    IN BOOLEAN WriteThrough
    );

PHYSICAL_ADDRESS
__inline
HalpPtrToPhysicalAddress(
    IN PVOID Address
    )

/*++

Routine Description:

    This routine converts a physical address expressed as a PVOID into
    a physical address expresses as PHYSICAL_ADDRESS.

Arguments:

    Address - PVOID representation of the physical address.

Return Value:

    PHYSICAL_ADDRESS representation of the physical address.

--*/

{
    PHYSICAL_ADDRESS physicalAddress;

    physicalAddress.QuadPart = (ULONG_PTR)Address;

    return physicalAddress;
}

#if defined(_HALPAE_)

//
// This hal is to be PAE compatible.  Therefore, physical addresses must
// be treated as 64-bit entitites instead of PVOID.
//

#define _PHYS64_
#endif

#if defined(_PHYS64_)

//
// HALs with _PHYS64_ defined pass physical addresses as PHYSICAL_ADDRESS,
// so call the 64-bit versions of these routines directly.
//

#define HalpMapPhysicalMemory               HalpMapPhysicalMemory64
#define HalpMapPhysicalMemoryWriteThrough   HalpMapPhysicalMemoryWriteThrough64
#define HalpRemapVirtualAddress             HalpRemapVirtualAddress64

#define HalpMapPhysicalRange(_addr_,_len_)      \
        HalpMapPhysicalMemory((_addr_),         \
                              HalpRangePages((_addr_).QuadPart,(_len_)))

#define HalpUnMapPhysicalRange(_addr_,_len_)      \
        HalpUnmapVirtualAddress((_addr_),         \
                              HalpRangePages((ULONG_PTR)(_addr_),(_len_)))

#else

//
// HALs without _PHYS64_ defined pass physical addresses as PVOIDs.  Convert
// such parameters to PHYSICAL_ADDRESS before passing to the 64-bit routines.
//

PVOID
__inline
HalpMapPhysicalMemory(
    IN PVOID PhysicalAddress,
    IN ULONG NumberPages
    )
{
    PHYSICAL_ADDRESS physicalAddress;

    physicalAddress = HalpPtrToPhysicalAddress( PhysicalAddress );
    return HalpMapPhysicalMemory64( physicalAddress, NumberPages );
}

PVOID
__inline
HalpMapPhysicalMemoryWriteThrough(
    IN PVOID PhysicalAddress,
    IN ULONG NumberPages
    )
{
    PHYSICAL_ADDRESS physicalAddress;

    physicalAddress = HalpPtrToPhysicalAddress( PhysicalAddress );
    return HalpMapPhysicalMemoryWriteThrough64( physicalAddress, NumberPages );
}

PVOID
__inline
HalpRemapVirtualAddress(
    IN PVOID VirtualAddress,
    IN PVOID PhysicalAddress,
    IN BOOLEAN WriteThrough
    )
{
    PHYSICAL_ADDRESS physicalAddress;

    physicalAddress = HalpPtrToPhysicalAddress( PhysicalAddress );
    return HalpRemapVirtualAddress64( VirtualAddress,
                                      physicalAddress,
                                      WriteThrough );
}

#define HalpMapPhysicalRangeWriteThrough(_addr_,_len_)      \
        HalpMapPhysicalMemoryWriteThrough((_addr_),         \
                              HalpRangePages((ULONG_PTR)(_addr_),(_len_)))

#define HalpMapPhysicalRange(_addr_,_len_)      \
        HalpMapPhysicalMemory((_addr_),         \
                              HalpRangePages((ULONG_PTR)(_addr_),(_len_)))

#define HalpUnMapPhysicalRange(_addr_,_len_)      \
        HalpUnmapVirtualAddress((_addr_),         \
                              HalpRangePages((ULONG_PTR)(_addr_),(_len_)))


#endif

ULONG
__inline
HalpRangePages(
    IN ULONGLONG Address,
    IN ULONG Length
    )
{
    ULONG startPage;
    ULONG endPage;

    startPage = (ULONG)(Address / PAGE_SIZE);
    endPage = (ULONG)((Address + Length + PAGE_SIZE - 1) / PAGE_SIZE);

    return endPage - startPage;
}



BOOLEAN
HalpBiosDisplayReset(
    IN VOID
    );

HAL_DISPLAY_BIOS_INFORMATION
HalpGetDisplayBiosInformation (
    VOID
    );

VOID
HalpInitializeCmos (
   VOID
   );

VOID
HalpReadCmosTime (
   PTIME_FIELDS TimeFields
   );

VOID
HalpWriteCmosTime (
   PTIME_FIELDS TimeFields
   );

VOID
HalpAcquireCmosSpinLock (
    VOID
    );

VOID
HalpReleaseCmosSpinLock (
    VOID
    );

VOID
HalpResetAllProcessors (
    VOID
    );

VOID
HalpWriteResetCommand (
    VOID
    );


VOID
HalpCpuID (
    ULONG   InEax,
    PULONG  OutEax,
    PULONG  OutEbx,
    PULONG  OutEcx,
    PULONG  OutEdx
    );

#if defined(_WIN64)
#define HalpYieldProcessor()

#else

VOID
HalpYieldProcessor (
    VOID
    );
#endif

ULONGLONG
FASTCALL
RDMSR (
    IN ULONG MsrAddress
    );

VOID
WRMSR (
    IN ULONG        MsrAddress,
    IN ULONGLONG    MsrValue
    );


NTSTATUS
HalpEnableInterruptHandler (
    IN UCHAR    ReportFlags,
    IN ULONG    BusInterruptVector,
    IN ULONG    SystemInterruptVector,
    IN KIRQL    SystemIrql,
    IN PHAL_INTERRUPT_SERVICE_ROUTINE HalInterruptServiceRoutine,
    IN KINTERRUPT_MODE InterruptMode
    );

VOID
HalpRegisterVector (
    IN UCHAR    ReportFlags,
    IN ULONG    BusInterruptVector,
    IN ULONG    SystemInterruptVector,
    IN KIRQL    SystemIrql
    );

VOID
HalpReportResourceUsage (
    IN PUNICODE_STRING  HalName,
    IN INTERFACE_TYPE   DeviceInterfaceToUse
    );

VOID
HalpYearIs(
    IN ULONG Year
    );

VOID
HalpRecordEisaInterruptVectors(
    VOID
    );

VOID
HalpMcaCurrentProcessorSetConfig(
    VOID
    );

NTSTATUS
HalpGetNextProcessorApicId(
    IN ULONG ProcessorNumber,
    IN OUT UCHAR    *ApicId
    );

VOID
FASTCALL
HalpIoDelay (
   VOID
   );

//
// Defines for HalpFeatureBits
//

#define HAL_PERF_EVENTS     0x00000001
#define HAL_NO_SPECULATION  0x00000002
#define HAL_MCA_PRESENT     0x00000004  // Intel MCA Available
#define HAL_MCE_PRESENT     0x00000008  // ONLY Pentium style MCE available
#define HAL_CR4_PRESENT     0x00000010
#define HAL_WNI_PRESENT     0x00000020
#define HAL_NX_PRESENT      0x00000040  // from extended processor features

extern ULONG HalpFeatureBits;

extern USHORT HalpPciIrqMask;

//
// Defines for Processor Features returned from CPUID instruction
//

#define CPUID_MCA_MASK  0x4000
#define CPUID_MCE_MASK  0x0080
#define CPUID_VME_MASK  0x0002
#define CPUID_WNI_MASK  0x04000000
#define CPUID_NX_MASK   0x00100000


NTSTATUS
HalpGetMceInformation(
    IN  PHAL_ERROR_INFO ErrorInfo,
    OUT PULONG          ErrorInfoLength
    );

NTSTATUS
HalpMceRegisterKernelDriver(
    IN PKERNEL_ERROR_HANDLER_INFO KernelErrorHandler,
    IN ULONG                      InfoSize
    );

//
// Token passed in by WMI to distinguish it from the MCA logging driver.
//
#define HALP_KERNEL_TOKEN  0x59364117

NTSTATUS
HalpGetMcaLog(
    OUT PMCA_EXCEPTION  Exception,
    IN  ULONG           BufferSize,
    OUT PULONG          ReturnedLength
    );

NTSTATUS
HalpMcaRegisterDriver(
    IN PMCA_DRIVER_INFO pMcaDriverInfo  // Info about registering driver
    );

VOID
HalpMcaInit(
    VOID
    );

//
// Disable the Local APIC on UP (PIC 8259) PentiumPro systems to work around
// spurious interrupt errata.
//
#define APIC_BASE_MSR       0x1B
#define APIC_ENABLED        0x0000000000000800

//
// PnP stuff
//

#define HAL_BUS_INTERFACE_STD_VERSION   1
#define HAL_IRQ_TRANSLATOR_VERSION      0
#define HAL_MEMIO_TRANSLATOR_VERSION    1

VOID
HalTranslatorReference(
    PVOID Context
    );

VOID
HalTranslatorDereference(
    PVOID Context
    );

NTSTATUS
HalIrqTranslateResources(
    IN PVOID Context,
    IN PCM_PARTIAL_RESOURCE_DESCRIPTOR Source,
    IN RESOURCE_TRANSLATION_DIRECTION Direction,
    IN ULONG AlternativesCount, OPTIONAL
    IN IO_RESOURCE_DESCRIPTOR Alternatives[], OPTIONAL
    IN PDEVICE_OBJECT PhysicalDeviceObject,
    OUT PCM_PARTIAL_RESOURCE_DESCRIPTOR Target
    );

NTSTATUS
HalIrqTranslateResourcesRoot(
    IN PVOID Context,
    IN PCM_PARTIAL_RESOURCE_DESCRIPTOR Source,
    IN RESOURCE_TRANSLATION_DIRECTION Direction,
    IN ULONG AlternativesCount, OPTIONAL
    IN IO_RESOURCE_DESCRIPTOR Alternatives[], OPTIONAL
    IN PDEVICE_OBJECT PhysicalDeviceObject,
    OUT PCM_PARTIAL_RESOURCE_DESCRIPTOR Target
    );

NTSTATUS
HalIrqTranslateResourceRequirementsRoot(
    IN PVOID Context,
    IN PIO_RESOURCE_DESCRIPTOR Source,
    IN PDEVICE_OBJECT PhysicalDeviceObject,
    OUT PULONG TargetCount,
    OUT PIO_RESOURCE_DESCRIPTOR *Target
    );

NTSTATUS
HalIrqTranslateResourceRequirementsIsa(
    IN PVOID Context,
    IN PIO_RESOURCE_DESCRIPTOR Source,
    IN PDEVICE_OBJECT PhysicalDeviceObject,
    OUT PULONG TargetCount,
    OUT PIO_RESOURCE_DESCRIPTOR *Target
    );

NTSTATUS
HalIrqTranslateResourcesIsa(
    IN PVOID Context,
    IN PCM_PARTIAL_RESOURCE_DESCRIPTOR Source,
    IN RESOURCE_TRANSLATION_DIRECTION Direction,
    IN ULONG AlternativesCount, OPTIONAL
    IN IO_RESOURCE_DESCRIPTOR Alternatives[], OPTIONAL
    IN PDEVICE_OBJECT PhysicalDeviceObject,
    OUT PCM_PARTIAL_RESOURCE_DESCRIPTOR Target
    );

NTSTATUS
HalpTransMemIoResourceRequirement(
    IN PVOID Context,
    IN PIO_RESOURCE_DESCRIPTOR Source,
    IN PDEVICE_OBJECT PhysicalDeviceObject,
    OUT PULONG TargetCount,
    OUT PIO_RESOURCE_DESCRIPTOR *Target
    );

NTSTATUS
HalpTransMemIoResource(
    IN PVOID Context,
    IN PCM_PARTIAL_RESOURCE_DESCRIPTOR Source,
    IN RESOURCE_TRANSLATION_DIRECTION Direction,
    IN ULONG AlternativesCount, OPTIONAL
    IN IO_RESOURCE_DESCRIPTOR Alternatives[], OPTIONAL
    IN PDEVICE_OBJECT PhysicalDeviceObject,
    OUT PCM_PARTIAL_RESOURCE_DESCRIPTOR Target
    );

NTSTATUS
HalIrqTranslateRequirementsPciBridge(
    IN PVOID Context,
    IN PIO_RESOURCE_DESCRIPTOR Source,
    IN PDEVICE_OBJECT PhysicalDeviceObject,
    OUT PULONG TargetCount,
    OUT PIO_RESOURCE_DESCRIPTOR *Target
    );

NTSTATUS
HalIrqTranslateResourcesPciBridge(
    IN PVOID Context,
    IN PCM_PARTIAL_RESOURCE_DESCRIPTOR Source,
    IN RESOURCE_TRANSLATION_DIRECTION Direction,
    IN ULONG AlternativesCount, OPTIONAL
    IN IO_RESOURCE_DESCRIPTOR Alternatives[], OPTIONAL
    IN PDEVICE_OBJECT PhysicalDeviceObject,
    OUT PCM_PARTIAL_RESOURCE_DESCRIPTOR Target
    );

NTSTATUS
HalpIrqTranslateRequirementsPci(
    IN PVOID Context,
    IN PIO_RESOURCE_DESCRIPTOR Source,
    IN PDEVICE_OBJECT PhysicalDeviceObject,
    OUT PULONG TargetCount,
    OUT PIO_RESOURCE_DESCRIPTOR *Target
    );

NTSTATUS
HalpIrqTranslateResourcesPci(
    IN PVOID Context,
    IN PCM_PARTIAL_RESOURCE_DESCRIPTOR Source,
    IN RESOURCE_TRANSLATION_DIRECTION Direction,
    IN ULONG AlternativesCount, OPTIONAL
    IN IO_RESOURCE_DESCRIPTOR Alternatives[], OPTIONAL
    IN PDEVICE_OBJECT PhysicalDeviceObject,
    OUT PCM_PARTIAL_RESOURCE_DESCRIPTOR Target
    );

BOOLEAN
HalpTranslateSystemBusAddress(
    IN PBUS_HANDLER BusHandler,
    IN PBUS_HANDLER RootHandler,
    IN PHYSICAL_ADDRESS BusAddress,
    IN OUT PULONG AddressSpace,
    OUT PPHYSICAL_ADDRESS TranslatedAddress
    );

ULONG
HalpGetSystemInterruptVector(
    IN PBUS_HANDLER BusHandler,
    IN PBUS_HANDLER RootHandler,
    IN ULONG InterruptLevel,
    IN ULONG InterruptVector,
    OUT PKIRQL Irql,
    OUT PKAFFINITY Affinity
    );

ULONG
HalpGetIsaIrqState(
    ULONG   Vector
    );

extern INT_ROUTE_INTERFACE_STANDARD PciIrqRoutingInterface;

#if defined(_WIN64)
#define MM_HAL_RESERVED ((PVOID)HAL_VA_START)
#else
#define MM_HAL_RESERVED ((PVOID)0xffc00000)
#endif

#if defined(_HALPAE_)

#if defined(_AMD64_)

//
// For the purposes of the AMD64 HAL, "PAE" mode is always enabled, therefore
// no run-time PAE checks are necessary.
//

#define HalPaeEnabled() TRUE

#else   // _AMD64_

//
// This hal supports PAE mode.  Therefore checks need to be made at run-time
// to determine whether PAE is enabled or not.
//

BOOLEAN
__inline
HalPaeEnabled(
    VOID
    )
{
    return SharedUserData->ProcessorFeatures[PF_PAE_ENABLED] != FALSE;
}

#endif  // _AMD64_

#else

//
// This hal does not support PAE mode.  Therefore no run-time PAE checks
// are necessary.
//

#define HalPaeEnabled() FALSE

#endif

//
// The following inline functions and macros are used so that PHARDWARE_PTE
// can be used as a pointer to a four-byte legacy PTE or an eight-byte
// PAE PTE.
//
// With the exception of the PageFrameNumber field, all fields in these two
// different PTE formats are identical.  Therefore access to these fields
// can be made directly.
//
// However, code in a PAE-enabled HAL may not access the PageFrameNumber
// of a PTE directly, nor may it make any assumptions about the size of a
// PTE or the number of address bits decoded by the page directory pointer
// table, the page directory or the page table.  Instead, the following
// inline functions should be used.
//

ULONG
__inline
HalPteSize(
    VOID
    )

/*++

Routine Description:

    This routine returns the size, in bytes, of a PTE.

Arguments:

    None.

Return Value:

    The size, in bytes, of a PTE.

--*/

{
    if (HalPaeEnabled() != FALSE) {
        return sizeof(HARDWARE_PTE_X86PAE);
    } else {
        return sizeof(HARDWARE_PTE_X86);
    }
}

PHARDWARE_PTE
__inline
HalpIndexPteArray(
    IN PHARDWARE_PTE BasePte,
    IN ULONG Index
    )

/*++

Routine Description:

    This routine returns the address of a PTE within an array of PTEs.

Arguments:

    BasePte - Pointer to the PTE array.

    Index - Index within the PTE array.

Return Value:

    Address of BasePte[ Index ]

--*/

{
    PHARDWARE_PTE pointerPte;

    pointerPte = (PHARDWARE_PTE)((ULONG_PTR)BasePte + Index * HalPteSize());
    return pointerPte;
}

VOID
__inline
HalpAdvancePte(
    IN OUT PHARDWARE_PTE *PointerPte,
    IN     ULONG Count
    )

/*++

Routine Description:

    This routine advances the value of a PTE pointer by the specified number
    of PTEs.

Arguments:

    PointerPte - Pointer to the PTE pointer to increment.

    Count - Number of PTEs to advance the PTE pointer.

Return Value:

    None.

--*/

{
    *PointerPte = HalpIndexPteArray( *PointerPte, Count );
}

VOID
__inline
HalpIncrementPte(
    IN PHARDWARE_PTE *PointerPte
    )

/*++

Routine Description:

    This routine increments the value of a PTE pointer by one PTE.

Arguments:

    PointerPte - Pointer to the PTE pointer to increment.

Return Value:

    None.

--*/

{
    HalpAdvancePte( PointerPte, 1 );
}

VOID
__inline
HalpSetPageFrameNumber(
    IN OUT PHARDWARE_PTE PointerPte,
    IN ULONGLONG PageFrameNumber
    )

/*++

Routine Description:

    This routine sets the PageFrameNumber within a PTE.

Arguments:

    PointerPte - Pointer to the PTE to modify.

Return Value:

    None.

--*/

{
    PHARDWARE_PTE_X86PAE pointerPtePae;

    if (HalPaeEnabled() != FALSE) {

        pointerPtePae = (PHARDWARE_PTE_X86PAE)PointerPte;
        pointerPtePae->PageFrameNumber = PageFrameNumber;

    } else {

        PointerPte->PageFrameNumber = (ULONG_PTR)PageFrameNumber;
    }
}

ULONGLONG
__inline
HalpGetPageFrameNumber(
    IN PHARDWARE_PTE PointerPte
    )

/*++

Routine Description:

    This routine retrieves PageFrameNumber from within a PTE.

Arguments:

    PointerPte - Pointer to the PTE to read.

Return Value:

    The page frame number within the PTE.

--*/

{
    PHARDWARE_PTE_X86PAE pointerPtePae;
    ULONGLONG pageFrameNumber;

    if (HalPaeEnabled() != FALSE) {

        pointerPtePae = (PHARDWARE_PTE_X86PAE)PointerPte;
        pageFrameNumber = pointerPtePae->PageFrameNumber;

    } else {

        pageFrameNumber = PointerPte->PageFrameNumber;
    }

    return pageFrameNumber;
}

VOID
__inline
HalpCopyPageFrameNumber(
    OUT PHARDWARE_PTE DestinationPte,
    IN  PHARDWARE_PTE SourcePte
    )

/*++

Routine Description:

    This routine copies the page frame number from one PTE to another PTE.

Arguments:

    DestinationPte - Pointer to the PTE in which the new page frame number
        will be stored.

    PointerPte - Pointer to the PTE from which the page frame number will be
        read.

Return Value:

    None.

--*/

{
    ULONGLONG pageFrameNumber;

    pageFrameNumber = HalpGetPageFrameNumber( SourcePte );
    HalpSetPageFrameNumber( DestinationPte, pageFrameNumber );
}

BOOLEAN
__inline
HalpIsPteFree(
    IN PHARDWARE_PTE PointerPte
    )

/*++

Routine Description:

    This routine determines whether a PTE is free or not.  A free PTE is defined
    here as one containing all zeros.

Arguments:

    PointerPte - Pointer to the PTE for which the detmination is desired.

Return Value:

    TRUE - The PTE is free.

    FALSE - The PTE is not free.

--*/

{
    ULONGLONG pteContents;

    if (HalPaeEnabled() != FALSE) {
        pteContents = *(PULONGLONG)PointerPte;
    } else {
        pteContents = *(PULONG)PointerPte;
    }

    if (pteContents == 0) {
        return TRUE;
    } else {
        return FALSE;
    }
}

VOID
__inline
HalpFreePte(
    IN PHARDWARE_PTE PointerPte
    )

/*++

Routine Description:

    This routine sets a PTE to the free state.  It does this by setting the
    entire PTE to zero.

Arguments:

    PointerPte - Pointer to the PTE to free.

Return Value:

    None.

--*/

{
    if (HalPaeEnabled() != FALSE) {

        *((PULONGLONG)PointerPte) = 0;

    } else {

        *((PULONG)PointerPte) = 0;
    }
}


PHARDWARE_PTE
__inline
MiGetPteAddress(
    IN PVOID Va
    )

/*++

Routine Description:

    Given a virtual address, this routine returns a pointer to the mapping PTE.

Arguments:

    Va - Virtual Address for which a PTE pointer is desired.

Return Value:

    None.

--*/

{
    PHARDWARE_PTE pointerPte;

    if (HalPaeEnabled() != FALSE) {
        pointerPte = (PHARDWARE_PTE)MiGetPteAddressPae( Va );
    } else {
        pointerPte = MiGetPteAddressX86( Va );
    }

    return pointerPte;
}

PHARDWARE_PTE
__inline
MiGetPdeAddress(
    IN PVOID Va
    )

/*++

Routine Description:

    Given a virtual address, this routine returns a pointer to the mapping PDE.

Arguments:

    Va - Virtual Address for which a PDE pointer is desired.

Return Value:

    None.

--*/

{
    PHARDWARE_PTE pointerPte;

    if (HalPaeEnabled() != FALSE) {
        pointerPte = (PHARDWARE_PTE)MiGetPdeAddressPae( Va );
    } else {
        pointerPte = MiGetPdeAddressX86( Va );
    }

    return pointerPte;
}

ULONG
__inline
MiGetPteIndex(
    IN PVOID Va
    )

/*++

Routine Description:

    Given a virtual address, this routine returns the index of the mapping
    PTE within its page table.

Arguments:

    Va - Virtual Address for which the PTE index is desired.

Return Value:

    None.

--*/

{
    ULONG_PTR index;

    if (HalPaeEnabled() != FALSE) {
        index = MiGetPteIndexPae( Va );
    } else {
        index = MiGetPteIndexX86( Va );
    }

    return (ULONG)index;
}

ULONG
__inline
MiGetPdiShift(
    VOID
    )

/*++

Routine Description:

    Returns the number of bits that an address should be shifted right in order
    to right-justify the portion of the address mapped by a page directory
    entry.

Arguments:

    None.

Return Value:

    The number of bits to shift right.

--*/

{
    ULONG shift;

    if (HalPaeEnabled() != FALSE) {
        shift = PDI_SHIFT_X86PAE;
    } else {
        shift = PDI_SHIFT_X86;
    }

    return shift;
}

//
// ACPI specific stuff
//

NTSTATUS
HalpSetupAcpiPhase0(
    IN PLOADER_PARAMETER_BLOCK LoaderBlock
    );

NTSTATUS
HalpAcpiFindRsdtPhase0(
    IN PLOADER_PARAMETER_BLOCK LoaderBlock
    );

VOID
HaliHaltSystem(
    VOID
    );

VOID
HalpCheckPowerButton(
    VOID
    );

VOID
HalpRegisterHibernate(
    VOID
    );

VOID
FASTCALL
HalProcessorThrottle (
    IN UCHAR    Throttle
    );

VOID
HalpSaveInterruptControllerState(
    VOID
    );

VOID
HalpSaveDmaControllerState(
    VOID
    );

VOID
HalpSaveTimerState(
    VOID
    );

VOID
HalpRestoreInterruptControllerState(
    VOID
    );

VOID
HalpSetInterruptControllerWakeupState(
    ULONG   Context
    );

VOID
HalpRestorePicEdgeLevelRegister(
    VOID
    );

VOID
HalpSetAcpiEdgeLevelRegister(
    VOID
    );

VOID
HalpRestoreDmaControllerState(
    VOID
    );

VOID
HalpRestoreTimerState(
    VOID
    );

NTSTATUS
HalacpiGetInterruptTranslator(
    IN INTERFACE_TYPE ParentInterfaceType,
    IN ULONG ParentBusNumber,
    IN INTERFACE_TYPE BridgeInterfaceType,
    IN USHORT Size,
    IN USHORT Version,
    OUT PTRANSLATOR_INTERFACE Translator,
    OUT PULONG BridgeBusNumber
    );

VOID
HalpInitNonBusHandler (
    VOID
    );

VOID
HalpMapNvsArea(
    VOID
    );

VOID
HalpPreserveNvsArea(
    VOID
    );

VOID
HalpRestoreNvsArea(
    VOID
    );

VOID
HalpFreeNvsBuffers(
    VOID
    );

VOID
HalpPowerStateCallback(
    IN PVOID CallbackContext,
    IN PVOID Argument1,
    IN PVOID Argument2
    );

NTSTATUS
HalpBuildResumeStructures(
    VOID
    );

NTSTATUS
HalpFreeResumeStructures(
    VOID
    );

typedef struct {
    UCHAR   MasterMask;
    UCHAR   SlaveMask;
    UCHAR   MasterEdgeLevelControl;
    UCHAR   SlaveEdgeLevelControl;
} PIC_CONTEXT, *PPIC_CONTEXT;

#define EISA_DMA_CHANNELS 8

typedef struct {
    UCHAR           Dma1ExtendedModePort;
    UCHAR           Dma2ExtendedModePort;
    DMA1_CONTROL    Dma1Control;
    DMA2_CONTROL    Dma2Control;
} DMA_CONTEXT, *PDMA_CONTEXT;

typedef struct {
    UCHAR   nothing;
} TIMER_CONTEXT, *PTIMER_CONTEXT;

typedef struct {
    PIC_CONTEXT     PicState;
    DMA_CONTEXT     DmaState;
} MOTHERBOARD_CONTEXT, *PMOTHERBOARD_CONTEXT;

typedef struct {
    UCHAR                ChannelMode;
    UCHAR                ChannelExtendedMode;
    UCHAR                ChannelMask;
    BOOLEAN              ChannelProgrammed;  // Adapter created, mode set
#if DBG
    BOOLEAN           ChannelBusy;
#endif
} DMA_CHANNEL_CONTEXT;

extern MOTHERBOARD_CONTEXT  HalpMotherboardState;
extern PVOID                HalpSleepPageLock;
extern PVOID                HalpSleepPage16Lock;
extern DMA_CHANNEL_CONTEXT HalpDmaChannelState[];

ULONG 
HalpcGetCmosDataByType(
    IN CMOS_DEVICE_TYPE CmosType,
    IN ULONG            SourceAddress,
    IN PUCHAR           DataBuffer,
    IN ULONG            ByteCount
    );

ULONG 
HalpcSetCmosDataByType(
    IN CMOS_DEVICE_TYPE CmosType,
    IN ULONG            SourceAddress,
    IN PUCHAR           DataBuffer,
    IN ULONG            ByteCount
    );


NTSTATUS
HalpOpenRegistryKey(
    OUT PHANDLE Handle,
    IN HANDLE BaseHandle OPTIONAL,
    IN PUNICODE_STRING KeyName,
    IN ACCESS_MASK DesiredAccess,
    IN BOOLEAN Create
    );

#ifdef WANT_IRQ_ROUTING

NTSTATUS
HalpInitIrqArbiter (
    IN PDEVICE_OBJECT   DeviceObject
    );

NTSTATUS
HalpFillInIrqArbiter (
    IN     PDEVICE_OBJECT   HalFdo,
    IN     LPCGUID          InterfaceType,
    IN     USHORT           Version,
    IN     PVOID            InterfaceSpecificData,
    IN     ULONG            InterfaceBufferSize,
    IN OUT PINTERFACE       Interface,
    IN OUT PULONG           Length
    );

VOID
HalpIrqArbiterInterfaceReference(
    IN PVOID    Context
    );

VOID
HalpIrqArbiterInterfaceDereference(
    IN PVOID    Context
    );

#endif

//
// PnPBIOS specific stuff
//
VOID
HalpMarkChipsetDecode(
    BOOLEAN FullDecodeChipset
    );

ULONG
HalpPhase0SetPciDataByOffset (
    ULONG BusNumber,
    ULONG SlotNumber,
    PVOID Buffer,
    ULONG Offset,
    ULONG Length
    );

ULONG
HalpPhase0GetPciDataByOffset (
    ULONG BusNumber,
    ULONG SlotNumber,
    PVOID Buffer,
    ULONG Offset,
    ULONG Length
    );

NTSTATUS
HalpSetupPciDeviceForDebugging(
    IN     PLOADER_PARAMETER_BLOCK   LoaderBlock,   OPTIONAL    
    IN OUT PDEBUG_DEVICE_DESCRIPTOR  PciDevice
);

NTSTATUS
HalpReleasePciDeviceForDebugging(
    IN OUT PDEBUG_DEVICE_DESCRIPTOR  PciDevice
);

VOID
HalpRegisterKdSupportFunctions(
    IN PLOADER_PARAMETER_BLOCK LoaderBlock
    );

VOID
HalpRegisterPciDebuggingDeviceInfo(
    VOID
    );

#endif // _HALP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halx86\i386\ixfirm.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    ixreboot.c

Abstract:

    Provides the interface to the firmware for x86.  Since there is no
    firmware to speak of on x86, this is just reboot support.

Author:

    John Vert (jvert) 12-Aug-1991

Revision History:

--*/
#include "halp.h"
#include <inbv.h>

//
// Defines to let us diddle the CMOS clock and the keyboard
//

#define CMOS_CTRL   (PUCHAR )0x70
#define CMOS_DATA   (PUCHAR )0x71

#define RESET       0xfe
#define KEYBPORT    (PUCHAR )0x64

VOID  HalpVideoReboot(VOID);
VOID  HalpReboot(VOID);
#if defined(NEC_98)
BOOLEAN HalpPowerDownFlag;
#endif // defined(NEC_98)


VOID
HalReturnToFirmware(
    IN FIRMWARE_ENTRY Routine
    )

/*++

Routine Description:

    Returns control to the firmware routine specified.  Since the x86 has
    no useful firmware, it just stops the system.

Arguments:

    Routine - Supplies a value indicating which firmware routine to invoke.

Return Value:

    Does not return.

--*/

{
    switch (Routine) {
        case HalPowerDownRoutine:

#if defined(NEC_98)

            HalpPowerDownFlag = TRUE;

#endif // defined(NEC_98)

        case HalHaltRoutine:
        case HalRestartRoutine:
        case HalRebootRoutine:

            InbvAcquireDisplayOwnership();

            //
            // Never returns
            //

            HalpReboot();
            break;
        default:
            DbgPrint("HalReturnToFirmware called\n");
            DbgBreakPoint();
            break;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halx86\i386\ixidle.asm ===
title "Hal Processor Idle"
;++
;
;Copyright (c) 1991  Microsoft Corporation
;
;Module Name:
;
;    ixidle.asm
;
;Abstract:
;
;
;Author:
;
;
;Revision History:
;
;--

.386p
        .xlist
include hal386.inc
include callconv.inc                    ; calling convention macros
include i386\kimacro.inc
include mac386.inc
        .list

_TEXT$01   SEGMENT DWORD PUBLIC 'CODE'
           ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING

        page ,132
        subttl  "HalProcessorIdle"
;++
;
; VOID
; HalProcessorIdle(
;       VOID
;       )
;
; Routine Description:
;
;   This function is called when the current processor is idle.
;
;   This function is called with interrupts disabled, and the processor
;   is idle until it receives an interrupt.  The does not need to return
;   until an interrupt is received by the current processor.
;
;   This is the lowest level of processor idle.  It occurs frequently,
;   and this function (alone) should not put the processor into a
;   power savings mode which requeres large amount of time to enter & exit.
;
; Return Value:
;
;--

cPublicProc _HalProcessorIdle, 0
cPublicFpo 0,0

    ;
    ; the following code sequence "sti-halt" puts the processor
    ; into a Halted state, with interrupts enabled, without processing
    ; an interrupt before halting.   The STI instruction has a delay
    ; slot such that it does not take effect until after the instruction
    ; following it - this has the effect of HALTing without allowing
    ; a possible interrupt and then enabling interrupts while HALTed.
    ;

    ;
    ; On an MP hal we don't stop the processor, since that causes
    ; the SNOOP to slow down as well
    ;

        sti

ifdef NT_UP
        hlt
endif

    ;
    ; Now return to the system.  If there's still no work, then it
    ; will call us back to halt again.
    ;

        stdRET    _HalProcessorIdle

stdENDP _HalProcessorIdle

_TEXT$01   ends
           end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halx86\i386\ixipi.asm ===
title "Interprocessor Interrupt"
;++
;
;Copyright (c) 1991  Microsoft Corporation
;
;Module Name:
;
;    ixipi.asm
;
;Abstract:
;
;    Provides the HAL support for Interprocessor Interrupts.
;    This is the UP version.
;
;Author:
;
;    John Vert (jvert) 16-Jul-1991
;
;Revision History:
;
;--
.386p
        .xlist
include hal386.inc
include callconv.inc                    ; calling convention macros
include i386\kimacro.inc
include i386\ix8259.inc


        EXTRNP  _KiCoprocessorError,0,IMPORT
        EXTRNP  Kei386EoiHelper,0,IMPORT
        EXTRNP  _HalBeginSystemInterrupt,3
        EXTRNP  _HalEndSystemInterrupt,2
        EXTRNP  _HalpRegisterKdSupportFunctions,1
        extrn   _HalpDefaultInterruptAffinity:DWORD
        extrn   _HalpActiveProcessors:DWORD
IFDEF NEC_98
        EXTRNP  _HalpDetectCommonArea,0
endif ; NEC_98

        page ,132
        subttl  "Post InterProcessor Interrupt"
INIT    SEGMENT DWORD PUBLIC 'CODE'
        ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING

;++
;
; VOID
; HalInitializeProcessor(
;       ULONG   Number
;       PVOID   LoaderBlock
;       );
;
;Routine Description:
;
;    Initialize hal pcr values for current processor (if any)
;    (called shortly after processor reaches kernel, before
;    HalInitSystem if P0)
;
;    IPI's and KeReadir/LowerIrq's must be available once this function
;    returns.  (IPI's are only used once two or more processors are
;    available)
;
;Arguments:
;
;    Number - Logical processor number of calling processor
;
;Return Value:
;
;    None.
;
;--
cPublicProc _HalInitializeProcessor ,2

;
; Initialize PcIDR in PCR to enable slave IRQ
;

IFDEF NEC_98
        mov     fs:PcIDR, 0ffffff7fh
        stdCall    _HalpDetectCommonArea
else ; NEC_98
        mov     fs:PcIDR, 0fffffffbh
endif ; NEC_98
        mov     dword ptr fs:PcStallScaleFactor, INITIAL_STALL_COUNT

        mov     eax, dword ptr [esp+4]
        lock bts _HalpDefaultInterruptAffinity, eax
        lock bts _HalpActiveProcessors, eax
        
        ;
        ; This next call has nothing to do with processor init.
        ; But this is the only function in the HAL that gets 
        ; called before KdInit.
        ;
        stdCall _HalpRegisterKdSupportFunctions <[esp + 8]>

        stdRET    _HalInitializeProcessor
stdENDP _HalInitializeProcessor

INIT   ends


_TEXT$03   SEGMENT DWORD PUBLIC 'CODE'
        ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING

;++
;
; VOID
; HalRequestIpi(
;       IN ULONG Mask
;       );
;
;Routine Description:
;
;    Requests an interprocessor interrupt
;
;Arguments:
;
;    Mask - Supplies a mask of the processors to interrupt
;
;Return Value:
;
;    None.
;
;--

cPublicProc _HalRequestIpi  ,1

if DBG
        int 3
endif
        stdRET    _HalRequestIpi
stdENDP _HalRequestIpi


        page ,132
        subttl  "80387 Irq13 Interrupt Handler"
;++
;
; VOID
; HalpIrq13Handler (
;    );
;
; Routine Description:
;
;    When the 80387 detects an error, it raises its error line.  This
;    was supposed to be routed directly to the 386 to cause a trap 16
;    (which would actually occur when the 386 encountered the next FP
;    instruction).
;
;    However, the ISA design routes the error line to IRQ13 on the
;    slave 8259.  So an interrupt will be generated whenever the 387
;    discovers an error.
;
;    This routine handles that interrupt and passes control to the kernel
;    coprocessor error handler.
;
; Arguments:
;
;    None.
;    Interrupt is disabled.
;
; Return Value:
;
;    None.
;
;--

        ENTER_DR_ASSIST Hi13_a, Hi13_t

cPublicProc _HalpIrq13Handler       ,0

;
; Save machine state in trap frame
;

        ENTER_INTERRUPT Hi13_a, Hi13_t  ; (ebp) -> Trap frame

;
; Save previous IRQL
;

        push    13 + PRIMARY_VECTOR_BASE    ; Vector
        sub     esp, 4                      ; make space for OldIrql

        stdCall   _HalBeginSystemInterrupt, <I386_80387_IRQL,13 + PRIMARY_VECTOR_BASE,esp>

        stdCall   _KiCoprocessorError         ; call CoprocessorError handler

;
;       Clear the busy latch so that the 386 doesn't mistakenly think
;       that the 387 is still busy.
;

        xor     al,al
        out     I386_80387_BUSY_PORT, al

        INTERRUPT_EXIT                      ; will return to caller

stdENDP _HalpIrq13Handler

_TEXT$03   ENDS

        END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halx86\i386\ixenvirv.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    ixenvirv.c

Abstract:

    This module implements the HAL get and set environment variable routines
    for a x86 system.

    Note that this particular implementation only supports the LastKnownGood
    environment variable.  This is done by using the Daylight Savings Time
    bit in the Real Time Clock NVRAM.  (Not pretty, but it's all we've got)

    Attempts to read or write any environment variable other than
    LastKnownGood will fail.

Author:

    John Vert (jvert) 22-Apr-1992

Environment:

    Kernel mode

Revision History:

--*/

#include "halp.h"
#include "arc.h"
#include "arccodes.h"
#include "string.h"

#define CMOS_CONTROL_PORT ((PUCHAR)0x70)
#define CMOS_DATA_PORT    ((PUCHAR)0x71)
#define CMOS_STATUS_B     0x0B
#define CMOS_DAYLIGHT_BIT 1

const UCHAR LastKnownGood[] = "LastKnownGood";
const UCHAR True[] = "TRUE";
const UCHAR False[] = "FALSE";


ARC_STATUS
HalGetEnvironmentVariable (
    IN PCHAR Variable,
    IN USHORT Length,
    OUT PCHAR Buffer
    )

/*++

Routine Description:

    This function locates an environment variable and returns its value.

    The only environment variable this implementation supports is
    "LastKnownGood"  It uses the Daylight Savings Time bit in the Real
    TimeClock to indicate the state (TRUE/FALSE only) of this environment
    variable.

Arguments:

    Variable - Supplies a pointer to a zero terminated environment variable
        name.

    Length - Supplies the length of the value buffer in bytes.

    Buffer - Supplies a pointer to a buffer that receives the variable value.

Return Value:

    ESUCCESS is returned if the enviroment variable is located. Otherwise,
    ENOENT is returned.

--*/

{
    UCHAR StatusByte;
    
    UNREFERENCED_PARAMETER( Length );
    UNREFERENCED_PARAMETER( Buffer );

    if (_stricmp(Variable, LastKnownGood) != 0) {
        return ENOENT;
    }

    //
    // Read the Daylight Savings Bit out of the RTC to determine whether
    // the LastKnownGood environment variable is TRUE or FALSE.
    //

    HalpAcquireCmosSpinLock();

    WRITE_PORT_UCHAR(CMOS_CONTROL_PORT, CMOS_STATUS_B);
    StatusByte = READ_PORT_UCHAR(CMOS_DATA_PORT);

    
    HalpReleaseCmosSpinLock ();

    if (StatusByte & CMOS_DAYLIGHT_BIT) {
        strncpy(Buffer, True, Length);
    } else {
        strncpy(Buffer, False, Length);
    }

    return ESUCCESS;
}

ARC_STATUS
HalSetEnvironmentVariable (
    IN PCHAR Variable,
    IN PCHAR Value
    )

/*++

Routine Description:

    This function creates an environment variable with the specified value.

    The only environment variable this implementation supports is
    "LastKnownGood"  It uses the Daylight Savings Time bit in the Real
    TimeClock to indicate the state (TRUE/FALSE only) of this environment
    variable.

Arguments:

    Variable - Supplies a pointer to an environment variable name.

    Value - Supplies a pointer to the environment variable value.

Return Value:

    ESUCCESS is returned if the environment variable is created. Otherwise,
    ENOMEM is returned.

--*/

{
    UCHAR StatusByte;
    
    if (_stricmp(Variable, LastKnownGood) != 0) {
        return ENOMEM;
    }

    if (_stricmp(Value, True) == 0) {

        HalpAcquireCmosSpinLock();

        //
        // Turn Daylight Savings Bit on.
        //
        WRITE_PORT_UCHAR(CMOS_CONTROL_PORT, CMOS_STATUS_B);
        StatusByte = READ_PORT_UCHAR(CMOS_DATA_PORT);

        StatusByte |= CMOS_DAYLIGHT_BIT;

        WRITE_PORT_UCHAR(CMOS_CONTROL_PORT, CMOS_STATUS_B);
        WRITE_PORT_UCHAR(CMOS_DATA_PORT, StatusByte);

        
        HalpReleaseCmosSpinLock();

    } else if (_stricmp(Value, False) == 0) {

        HalpAcquireCmosSpinLock();

        //
        // Turn Daylight Savings Bit off.
        //

        WRITE_PORT_UCHAR(CMOS_CONTROL_PORT, CMOS_STATUS_B);
        StatusByte = READ_PORT_UCHAR(CMOS_DATA_PORT);

        StatusByte &= ~CMOS_DAYLIGHT_BIT;

        WRITE_PORT_UCHAR(CMOS_CONTROL_PORT, CMOS_STATUS_B);
        WRITE_PORT_UCHAR(CMOS_DATA_PORT, StatusByte);

        HalpReleaseCmosSpinLock();

    } else {
        return(ENOMEM);
    }

    return ESUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halx86\i386\ixhibrnt.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    ixhibrnt.c

Abstract:

    This file provides the code that changes the system from
    the ACPI S0 (running) state to S4 (hibernated).

Author:

    Jake Oshins (jakeo) May 6, 1997

Revision History:

--*/
#include "halp.h"
#include "ntapm.h"
#include "ixsleep.h"

NTSTATUS
HalpRegisterPowerStateChange(
    PVOID   ApmSleepVectorArg,
    PVOID   ApmOffVectorArg
    );

NTSTATUS
HaliLegacyPowerStateChange(
    IN PVOID                        Context,
    IN PENTER_STATE_SYSTEM_HANDLER  SystemHandler   OPTIONAL,
    IN PVOID                        SystemContext,
    IN LONG                         NumberProcessors,
    IN volatile PLONG               Number
    );

VOID
HalpPowerStateCallbackApm(
    IN PVOID CallbackContext,
    IN PVOID Argument1,
    IN PVOID Argument2
    );

VOID (*ApmSleepVector)() = NULL;
VOID (*ApmOffVector)() = NULL;

extern BOOLEAN HalpDisableHibernate;

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, HaliInitPowerManagement)
#pragma alloc_text(PAGE, HalpRegisterHibernate)
#pragma alloc_text(PAGE, HalpPowerStateCallbackApm)
#pragma alloc_text(PAGE, HalpRegisterPowerStateChange)
#pragma alloc_text(PAGELK, HaliLegacyPowerStateChange)
#pragma alloc_text(PAGELK, HalpSaveInterruptControllerState)
#pragma alloc_text(PAGELK, HalpRestoreInterruptControllerState)
#endif


NTSTATUS
HaliInitPowerManagement(
    IN PPM_DISPATCH_TABLE  PmDriverDispatchTable,
    IN OUT PPM_DISPATCH_TABLE *PmHalDispatchTable
    )
{
    NTSTATUS    status = STATUS_SUCCESS;
    PVOID       ApmSleepVectorArg;
    PVOID       ApmOffVectorArg;

    if (PmDriverDispatchTable->Signature != HAL_APM_SIGNATURE) {
        return STATUS_INVALID_PARAMETER;
    }

    if (PmDriverDispatchTable->Version != HAL_APM_VERSION) {
        return STATUS_INVALID_PARAMETER;
    }

    ApmSleepVectorArg = PmDriverDispatchTable->Function[HAL_APM_SLEEP_VECTOR];
    ApmOffVectorArg = PmDriverDispatchTable->Function[HAL_APM_OFF_VECTOR];

    status = HalpRegisterPowerStateChange(
        ApmSleepVectorArg,
        ApmOffVectorArg
        );

    return status;
}

NTSTATUS
HalpRegisterPowerStateChange(
    PVOID   ApmSleepVectorArg,
    PVOID   ApmOffVectorArg
    )
/*++
Routine Description:

    This function registers HaliLegacyPowerStateChange for
    the S3, S4, and OFF vectors.

Arguments:

    PVOID   ApmSleepVectorArg - pointer to a function which
            when called invokes the APM suspend/sleep function.

    PVOID   ApmOffVectorArg - pointer to a function which
            when called invokes the APM code to shut off the machine.

--*/
{
    POWER_STATE_HANDLER powerState;
    OBJECT_ATTRIBUTES   objAttributes;
    PCALLBACK_OBJECT    callback;
    UNICODE_STRING      callbackName;
    NTSTATUS            status;
    PSYSTEM_POWER_STATE_DISABLE_REASON pReasonNoOSPM;
    SYSTEM_POWER_LOGGING_ENTRY PowerLoggingEntry;
    NTSTATUS            ReasonStatus;

    PAGED_CODE();


    //
    // callbacks are set up for the hibernation case
    // at init, we just keep them.
    //

    
    //
    // Register the sleep3/suspend handler
    //
    if (ApmSleepVectorArg != NULL) {
        powerState.Type = PowerStateSleeping3;
        powerState.RtcWake = FALSE;
        powerState.Handler = &HaliLegacyPowerStateChange;
        powerState.Context = (PVOID)PowerStateSleeping3;

        status = ZwPowerInformation(SystemPowerStateHandler,
                                    &powerState,
                                    sizeof(POWER_STATE_HANDLER),
                                    NULL,
                                    0);

        if (!NT_SUCCESS(status)) {
            return status;
        }
    } else {
        //
        // we're not registering an S3 handler because APM is not present.
        // let the power manager know.
        //
        pReasonNoOSPM = ExAllocatePoolWithTag(
                            PagedPool,
                            sizeof(SYSTEM_POWER_STATE_DISABLE_REASON),
                            HAL_POOL_TAG
                            );
        if (pReasonNoOSPM) {
            RtlZeroMemory(pReasonNoOSPM, sizeof(SYSTEM_POWER_STATE_DISABLE_REASON));
            pReasonNoOSPM->AffectedState[PowerStateSleeping3] = TRUE;
            pReasonNoOSPM->PowerReasonCode = SPSD_REASON_NOOSPM;
    
            PowerLoggingEntry.LoggingType = LOGGING_TYPE_SPSD;
            PowerLoggingEntry.LoggingEntry = pReasonNoOSPM;
    
            ReasonStatus = ZwPowerInformation(
                                    SystemPowerLoggingEntry,
                                    &PowerLoggingEntry,
                                    sizeof(PowerLoggingEntry),
                                    NULL,
                                    0 );
    
            if (ReasonStatus != STATUS_SUCCESS) {
                ExFreePool(pReasonNoOSPM);
            }
        }        
    }

    //
    // Register the OFF handler.
    //

    powerState.Type = PowerStateShutdownOff;
    powerState.RtcWake = FALSE;
    powerState.Handler = &HaliLegacyPowerStateChange;
    powerState.Context = (PVOID)PowerStateShutdownOff;

    status = ZwPowerInformation(SystemPowerStateHandler,
                                &powerState,
                                sizeof(POWER_STATE_HANDLER),
                                NULL,
                                0);

    if (!NT_SUCCESS(status)) {
        //
        // n.b. We will return here with two vectors (sleep & hibernate) left in place.
        //
        return status;
    }

    ApmSleepVector = ApmSleepVectorArg;
    ApmOffVector = ApmOffVectorArg;

    return status;
}

VOID
HalpRegisterHibernate(
    VOID
    )
/*++
Routine Description:

    This function registers a hibernation handler (for
    state S4) with the Policy Manager.

Arguments:

--*/
{
    POWER_STATE_HANDLER powerState;
    OBJECT_ATTRIBUTES   objAttributes;
    PCALLBACK_OBJECT    callback;
    UNICODE_STRING      callbackName;
    PSYSTEM_POWER_STATE_DISABLE_REASON pReasonBios;
    SYSTEM_POWER_LOGGING_ENTRY PowerLoggingEntry;
    NTSTATUS            ReasonStatus;

    PAGED_CODE();


    //
    // Register callback that tells us to make
    // anything we need for sleeping non-pageable.
    //

    RtlInitUnicodeString(&callbackName, L"\\Callback\\PowerState");

    InitializeObjectAttributes(
        &objAttributes,
        &callbackName,
        OBJ_CASE_INSENSITIVE | OBJ_PERMANENT,
        NULL,
        NULL
        );

    ExCreateCallback(&callback,
                     &objAttributes,
                     FALSE,
                     TRUE);

    ExRegisterCallback(callback,
                       (PCALLBACK_FUNCTION)&HalpPowerStateCallbackApm,
                       NULL);

    //
    // Register the hibernation handler.
    //

    if (HalpDisableHibernate == FALSE) {
        powerState.Type = PowerStateSleeping4;
        powerState.RtcWake = FALSE;
        powerState.Handler = &HaliLegacyPowerStateChange;
        powerState.Context = (PVOID)PowerStateSleeping4;
    
        ZwPowerInformation(SystemPowerStateHandler,
                           &powerState,
                           sizeof(POWER_STATE_HANDLER),
                           NULL,
                           0);
    } else {
        //
        // we're not enabling hibernate because there is a hackflag
        // that disallows hibernate.  let the power manager know why.
        //
        pReasonBios = ExAllocatePoolWithTag(
                            PagedPool,
                            sizeof(SYSTEM_POWER_STATE_DISABLE_REASON),
                            HAL_POOL_TAG
                            );
        if (pReasonBios) {
            RtlZeroMemory(pReasonBios, sizeof(SYSTEM_POWER_STATE_DISABLE_REASON));
            pReasonBios->AffectedState[PowerStateSleeping4] = TRUE;
            pReasonBios->PowerReasonCode = SPSD_REASON_BIOSINCOMPATIBLE;

            PowerLoggingEntry.LoggingType = LOGGING_TYPE_SPSD;
            PowerLoggingEntry.LoggingEntry = pReasonBios;

            ReasonStatus = ZwPowerInformation(
                                    SystemPowerLoggingEntry,
                                    &PowerLoggingEntry,
                                    sizeof(PowerLoggingEntry),
                                    NULL,
                                    0 );

            if (ReasonStatus != STATUS_SUCCESS) {
                ExFreePool(pReasonBios);
            }

        }
    }

    return;
}

VOID
HalpPowerStateCallbackApm(
    IN PVOID CallbackContext,
    IN PVOID Argument1,
    IN PVOID Argument2
    )
{
    ULONG   action = (ULONG)Argument1;
    ULONG   state  = (ULONG)Argument2;

    if (action == PO_CB_SYSTEM_STATE_LOCK) {

        switch (state) {
        case 0:                 // lock down everything that can't page during sleep

            HalpSleepPageLock = MmLockPagableCodeSection((PVOID)HaliLegacyPowerStateChange);

            break;

        case 1:                 // unlock it all

            MmUnlockPagableImageSection(HalpSleepPageLock);
        }
    }
}

NTSTATUS
HaliLegacyPowerStateChange(
    IN PVOID                        Context,
    IN PENTER_STATE_SYSTEM_HANDLER  SystemHandler   OPTIONAL,
    IN PVOID                        SystemContext,
    IN LONG                         NumberProcessors,
    IN volatile PLONG               Number
    )
/*++
Routine Description:

    This function calls out to code in a driver supplied
    wrapper function that will call off to APM to sleep==suspend,
    or power off (for either hibernate or system off)

    It is also called for hibernate when no driver supplied callout
    is available, in which case it makes the system ready so we
    can print a message and tell the user to manually power off the box.

Arguments:

--*/
{
    extern ULONG HalpProfilingStopped;
    NTSTATUS status = STATUS_SUCCESS;

    ASSERT( (Context == (PVOID)PowerStateSleeping3) ||
            (Context == (PVOID)PowerStateSleeping4) ||
            (Context == (PVOID)PowerStateShutdownOff));

    ASSERT ( (ApmOffVector != NULL) || (SystemHandler != NULL) );

    //
    // Save motherboard state.
    //
    HalpSaveInterruptControllerState();

    HalpSaveDmaControllerState();

    HalpSaveTimerState();

    if (SystemHandler) {

        status = SystemHandler(SystemContext);

        //
        // System handler is present.  If it return success,
        // then all out to APM bios
        //
        if ((status == STATUS_SUCCESS) ||
            (status == STATUS_DEVICE_DOES_NOT_EXIST)) {

            if (Context == (PVOID)PowerStateSleeping3) {
                if (ApmSleepVector) {
                    ApmSleepVector();
                } else {
                    //
                    // this is expected path for odd operation,
                    // caller will do something rational.
                    //
                    return STATUS_DEVICE_DOES_NOT_EXIST;
                }
            } else {

                //
                // The ApmOffVector provides the means to turn
                // off the machine.  If the hibernation handler
                // returned STATUS_DEVICE_DOES_NOT_EXIST, however,
                // we don't want to turn the machine off, we want
                // to reset it.
                //

                if (ApmOffVector &&
                    !(status == STATUS_DEVICE_DOES_NOT_EXIST)) {

                    //
                    // This function should never return.  The
                    // machine should be off.  But if this actually
                    // does return, just fall through, as the return
                    // code will cause the message to turn off the
                    // machine to be displayed.
                    //
                    ApmOffVector();
                }

                //
                // this is expected case for old non-apm machines,
                // caller will respond to this by putting up
                // message telling user to turn off the box.
                // (for either shutdown or hibernate)
                //
                return STATUS_DEVICE_DOES_NOT_EXIST;
            }
        }
    } else {

        //
        // there is no system handler, so just call out
        // to the bios
        //
        if (Context == (PVOID)PowerStateSleeping3) {
            if (ApmSleepVector) {
                ApmSleepVector();
            } else {
                //
                // we're whistling in the wind here, we're
                // really probably hosed if this happens, but
                // this return is better than randomly puking.
                //
                return STATUS_DEVICE_DOES_NOT_EXIST;
            }
        } else {
            if (ApmOffVector) {
                ApmOffVector();
                //
                // if we are right here, we have *returned*
                // from Off, which should never happen.
                // so report failure so the caller will tell the
                // user to turn the box off manually.
                //
                return STATUS_DEVICE_DOES_NOT_EXIST;

            } else {
                //
                // same as right above
                //
                return STATUS_DEVICE_DOES_NOT_EXIST;
            }
        }
    }

    //
    // Restore motherboard state.
    //
    HalpRestoreInterruptControllerState();

    HalpRestoreDmaControllerState();

    HalpRestoreTimerState();


    if (HalpProfilingStopped == 0) {
        HalStartProfileInterrupt(0);
    }

    return status;
}

VOID
HalpSaveInterruptControllerState(
    VOID
    )
{
    HalpSavePicState();
}
VOID
HalpRestoreInterruptControllerState(
    VOID
    )
{
    HalpRestorePicState();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halx86\i386\ixinfo.c ===
/*++

Copyright (c) 1991-2000  Microsoft Corporation

Module Name:

    ixinfo.c

Abstract:

Author:

    Ken Reneris (kenr)  08-Aug-1994

Environment:

    Kernel mode only.

Revision History:

--*/


#include "halp.h"
#include "pci.h"
#include "pcip.h"

#ifdef _PNP_POWER_
HAL_CALLBACKS   HalCallback;
extern WCHAR    rgzSuspendCallbackName[];

VOID
HalInitSystemPhase2 (
    VOID
    );

VOID
HalpLockSuspendCode (
    IN PVOID    CallbackContext,
    IN PVOID    Argument1,
    IN PVOID    Argument2
    );
#endif

NTSTATUS
HalpQueryInstalledBusInformation (
    OUT PVOID   Buffer,
    IN  ULONG   BufferLength,
    OUT PULONG  ReturnedLength
    );



#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE,HaliQuerySystemInformation)
#pragma alloc_text(PAGE,HaliSetSystemInformation)
#pragma alloc_text(INIT,HalInitSystemPhase2)

#ifdef _PNP_POWER_
#pragma alloc_text(PAGE,HalpLockSuspendCode)
#endif

#endif

//
// HalQueryMcaInterface
//

VOID
HalpMcaLockInterface(
    VOID
    );

VOID
HalpMcaUnlockInterface(
    VOID
    );

NTSTATUS
HalpMcaReadRegisterInterface(
    IN     UCHAR           BankNumber,
    IN OUT PMCA_EXCEPTION  Exception
    );

#ifdef ACPI_HAL
extern PHYSICAL_ADDRESS HalpMaxHotPlugMemoryAddress;
#endif

#if defined(ACPI_HAL) && defined(_HALPAE_) && !defined(NT_UP)

extern PVOID HalpAcpiSrat;

NTSTATUS
HalpGetAcpiStaticNumaTopology(
    HAL_NUMA_TOPOLOGY_INTERFACE * NumaInfo
    );

#endif

HAL_AMLI_BAD_IO_ADDRESS_LIST BadIOAddrList[] =
{
    {0x000,  0x10,  0x1, NULL                           }, // ISA DMA
    {0x020,  0x2,   0x0, NULL                           }, // PIC
    {0x040,  0x4,   0x1, NULL                           }, // Timer1, Referesh, Speaker, Control Word
    {0x048,  0x4,   0x1, NULL                           }, // Timer2, Failsafe
    {0x070,  0x2,   0x1, NULL                           }, // Cmos/NMI enable
    {0x074,  0x3,   0x1, NULL                           }, // Extended Cmos
    {0x081,  0x3,   0x1, NULL                           }, // DMA
    {0x087,  0x1,   0x1, NULL                           }, // DMA
    {0x089,  0x1,   0x1, NULL                           }, // DMA
    {0x08a,  0x2,   0x1, NULL                           }, // DMA
    {0x08f,  0x1,   0x1, NULL                           }, // DMA
    {0x090,  0x2,   0x1, NULL                           }, // Arbritration Control Port, Card Select Feedback
    {0x093,  0x2,   0x1, NULL                           }, // Reserved, System board setup
    {0x096,  0x2,   0x1, NULL                           }, // POS channel select
    {0x0A0,  0x2,   0x0, NULL                           }, // Cascaded PIC
    {0x0C0,  0x20,  0x1, NULL                           }, // ISA DMA
    {0x4D0,  0x2,   0x0, NULL                           }, // Edge, level control registers for PIC
    {0xCF8,  0x8,   0x1, &HaliHandlePCIConfigSpaceAccess}, // PCI Config Space Access Pair
    {0x0,    0x0,   0x0, NULL                           }
};


VOID
HalInitSystemPhase2 (
    VOID
    )
{
#ifdef _PNP_POWER_
    OBJECT_ATTRIBUTES               ObjectAttributes;
    NTSTATUS                        Status;
    UNICODE_STRING                  unicodeString;
    PCALLBACK_OBJECT                CallbackObject;

    //
    // Create hal callbacks
    //

    InitializeObjectAttributes(
        &ObjectAttributes,
        NULL,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
    );


    ExCreateCallback (&HalCallback.SetSystemInformation, &ObjectAttributes, TRUE, TRUE);
    ExCreateCallback (&HalCallback.BusCheck, &ObjectAttributes, TRUE, TRUE);

    //
    // Connect to suspend callback to lock hal hibaration code
    //

    RtlInitUnicodeString(&unicodeString, rgzSuspendCallbackName);

    InitializeObjectAttributes(
        &ObjectAttributes,
        &unicodeString,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
    );

    Status = ExCreateCallback (&CallbackObject, &ObjectAttributes, FALSE, FALSE);

    if (NT_SUCCESS(Status)) {
        ExRegisterCallback (
            CallbackObject,
            HalpLockSuspendCode,
            NULL
            );

        ObDereferenceObject (CallbackObject);
    }
#endif
}

NTSTATUS
HaliQuerySystemInformation(
    IN HAL_QUERY_INFORMATION_CLASS  InformationClass,
    IN ULONG     BufferSize,
    OUT PVOID    Buffer,
    OUT PULONG   ReturnedLength
    )
{
    NTSTATUS    Status;
    PVOID       InternalBuffer;
    ULONG       Length;
    union {
        HAL_POWER_INFORMATION               PowerInf;
        HAL_PROCESSOR_SPEED_INFORMATION     ProcessorInf;
        MCA_EXCEPTION                       McaException;
        HAL_ERROR_INFO                      ErrorInfo;
        HAL_DISPLAY_BIOS_INFORMATION        DisplayBiosInf;
    } U;

    BOOLEAN     bUseFrameBufferCaching;

    PAGED_CODE();

    Status = STATUS_SUCCESS;
    *ReturnedLength = 0;
    Length = 0;

    switch (InformationClass) {
#ifndef ACPI_HAL
        case HalInstalledBusInformation:
            Status = HalpQueryInstalledBusInformation (
                        Buffer,
                        BufferSize,
                        ReturnedLength
                        );
            break;
#endif
        case HalFrameBufferCachingInformation:

            // Note - we want to return TRUE here to enable USWC in all
            // cases except in a "Shared Memory Cluster" machine.
            bUseFrameBufferCaching = TRUE;
            InternalBuffer = &bUseFrameBufferCaching;
            Length = sizeof (BOOLEAN);
            break;


        case HalMcaLogInformation:
        case HalCmcLogInformation:
            InternalBuffer = &U.McaException;
            Status = HalpGetMcaLog ((PMCA_EXCEPTION)Buffer,
                                    BufferSize,
                                    ReturnedLength);
            break;

        case HalErrorInformation:
            InternalBuffer = &U.ErrorInfo;
            Length = sizeof(HAL_ERROR_INFO);
            U.ErrorInfo.Version = ((PHAL_ERROR_INFO)Buffer)->Version;
            Status = HalpGetMceInformation( &U.ErrorInfo, &Length );
            break;

        case HalDisplayBiosInformation:
            InternalBuffer = &U.DisplayBiosInf;
            Length = sizeof(U.DisplayBiosInf);
            U.DisplayBiosInf = HalpGetDisplayBiosInformation ();
            break;

#ifdef _PNP_POWER_
        case HalPowerInformation:
            RtlZeroMemory (&U.PowerInf, sizeof(HAL_POWER_INFORMATION));

            InternalBuffer = &U.PowerInf;
            Length = sizeof (HAL_POWER_INFORMATION);
            break;


        case HalProcessorSpeedInformation:
            RtlZeroMemory (&U.ProcessorInf, sizeof(HAL_POWER_INFORMATION));

            U.ProcessorInf.MaximumProcessorSpeed = 100;
            U.ProcessorInf.CurrentAvailableSpeed = 100;
            U.ProcessorInf.ConfiguredSpeedLimit  = 100;

            InternalBuffer = &U.PowerInf;
            Length = sizeof (HAL_PROCESSOR_SPEED_INFORMATION);
            break;

        case HalCallbackInformation:
            InternalBuffer = &HalCallback;
            Length = sizeof (HAL_CALLBACKS);
            break;
#endif

#if defined(_HALPAE_) && !defined(NT_UP)

        case HalNumaTopologyInterface:
            if ((BufferSize == sizeof(HAL_NUMA_TOPOLOGY_INTERFACE)) &&
                (HalPaeEnabled() == TRUE)) {

                Status = STATUS_INVALID_LEVEL;

#if defined(ACPI_HAL)

                if (HalpAcpiSrat) {
                    Status = HalpGetAcpiStaticNumaTopology(Buffer);
                    if (NT_SUCCESS(Status)) {
                        *ReturnedLength = sizeof(HAL_NUMA_TOPOLOGY_INTERFACE);
                    }
                    break;
                }
#endif

            } else {

                //
                // Buffer size is wrong, we could return valid data
                // if the buffer is too big,.... but instead we will
                // use this as an indication that we're not compatible
                // with the kernel.
                //

                Status = STATUS_INFO_LENGTH_MISMATCH;
            }
            break;

#endif

#if 0
//
// [ChuckL 2002/08/12] This code was used by the kernel to read MCA information
// from a previous bugcheck and write it to the event log. This is now done
// through WMI, so this code is disabled.
//
        case HalQueryMcaInterface:
            if (BufferSize == sizeof(HAL_MCA_INTERFACE)) {
                HAL_MCA_INTERFACE *McaInterface;

                McaInterface = (HAL_MCA_INTERFACE *)Buffer;
                McaInterface->Lock         = HalpMcaLockInterface;
                McaInterface->Unlock       = HalpMcaUnlockInterface;
                McaInterface->ReadRegister = HalpMcaReadRegisterInterface;

                *ReturnedLength = sizeof(HAL_MCA_INTERFACE);
                Status = STATUS_SUCCESS;
            } else {
                Status = STATUS_INFO_LENGTH_MISMATCH;
            }
            break;
#endif

#if defined(_AMD64_)

        case HalProfileSourceInformation:
            Status = HalpQueryProfileInformation(InformationClass,
                                                 BufferSize,
                                                 Buffer,
                                                 ReturnedLength);
            break;

#endif
        case HalQueryMaxHotPlugMemoryAddress:
            if (BufferSize == sizeof(PHYSICAL_ADDRESS)) {
#ifdef ACPI_HAL
                *((PPHYSICAL_ADDRESS) Buffer) = HalpMaxHotPlugMemoryAddress;
                *ReturnedLength = sizeof(PHYSICAL_ADDRESS);
                Status = STATUS_SUCCESS;
#else
                Status = STATUS_NOT_IMPLEMENTED;
#endif
            } else {
                Status = STATUS_INFO_LENGTH_MISMATCH;
            }
            break;
        case HalQueryAMLIIllegalIOPortAddresses:
        {
            static HAL_AMLI_BAD_IO_ADDRESS_LIST BadIOAddrList[] =
                        {
                            {0x000,  0x10,  0x1, NULL                           }, // ISA DMA
                            {0x020,  0x2,   0x0, NULL                           }, // PIC
                            {0x040,  0x4,   0x1, NULL                           }, // Timer1, Referesh, Speaker, Control Word
                            {0x048,  0x4,   0x1, NULL                           }, // Timer2, Failsafe
                            {0x070,  0x2,   0x1, NULL                           }, // Cmos/NMI enable
                            {0x074,  0x3,   0x1, NULL                           }, // Extended Cmos
                            {0x081,  0x3,   0x1, NULL                           }, // DMA
                            {0x087,  0x1,   0x1, NULL                           }, // DMA
                            {0x089,  0x1,   0x1, NULL                           }, // DMA
                            {0x08a,  0x2,   0x1, NULL                           }, // DMA
                            {0x08f,  0x1,   0x1, NULL                           }, // DMA
                            {0x090,  0x2,   0x1, NULL                           }, // Arbritration Control Port, Card Select Feedback
                            {0x093,  0x2,   0x1, NULL                           }, // Reserved, System board setup
                            {0x096,  0x2,   0x1, NULL                           }, // POS channel select
                            {0x0A0,  0x2,   0x0, NULL                           }, // Cascaded PIC
                            {0x0C0,  0x20,  0x1, NULL                           }, // ISA DMA
                            {0x4D0,  0x2,   0x0, NULL                           }, // Edge, level control registers for PIC
                            {0xCF8,  0x8,   0x1, &HaliHandlePCIConfigSpaceAccess}, // PCI Config Space Access Pair
                            {0x0,    0x0,   0x0, NULL                           }
                        };

            if(BufferSize < sizeof(BadIOAddrList))
            {
                *ReturnedLength = sizeof(BadIOAddrList);
                Status = STATUS_INFO_LENGTH_MISMATCH;
            }
            else
            {
                Length = sizeof(BadIOAddrList);
                InternalBuffer = BadIOAddrList;
                Status = STATUS_SUCCESS;
            }
            break;
        }

        default:
            Status = STATUS_INVALID_LEVEL;
            break;
    }

    //
    // If non-zero Length copy data to callers buffer
    //

    if (Length) {
        if (BufferSize < Length) {
            Length = BufferSize;
        }

        *ReturnedLength = Length;
        RtlCopyMemory (Buffer, InternalBuffer, Length);
    }

    return Status;
}

NTSTATUS
HaliSetSystemInformation (
    IN HAL_SET_INFORMATION_CLASS    InformationClass,
    IN ULONG     BufferSize,
    IN PVOID     Buffer
    )
{
    NTSTATUS    Status;

    PAGED_CODE();

    Status = STATUS_SUCCESS;

    switch (InformationClass) {

        case HalKernelErrorHandler:
            Status = HalpMceRegisterKernelDriver( (PKERNEL_ERROR_HANDLER_INFO) Buffer, BufferSize );
            break;

        case HalMcaRegisterDriver:
            Status =  HalpMcaRegisterDriver(
                (PMCA_DRIVER_INFO) Buffer  // Info about registering driver
            );
            break;

        default:
            Status = STATUS_INVALID_LEVEL;
            break;
    }

    return Status;
}



#ifdef _PNP_POWER_

VOID
HalpLockSuspendCode (
    IN PVOID    CallbackContext,
    IN PVOID    Argument1,
    IN PVOID    Argument2
    )
{
    static PVOID    CodeLock;

    switch ((ULONG) Argument1) {
        case 0:
            //
            // Lock code down which might be needed to perform a suspend
            //

            ASSERT (CodeLock == NULL);
            CodeLock = MmLockPagableCodeSection (&HaliSuspendHibernateSystem);
            break;

        case 1:
            //
            // Release the code lock
            //

            MmUnlockPagableImageSection (CodeLock);
            CodeLock = NULL;
            break;
    }
}

#endif

/***  HaliHandlePCIConfigSpaceAccess - Check to see if the Firmware is attempting to 
 *                                     access to PCI Config space. If so, intercept 
 *                                     the read/write call and do it using HAL API's. 
 *                                     This way we can make these calls sync.
 *
 *  ENTRY
 *      BOOLEAN Read  - TRUE iff read 
 *      ULONG   Addr  - Address to do the operation on
 *      ULONG   Size  - Size of data
 *      PULONG  pData - Pointer to the data buffer.
 *      
 *  EXIT
 *      STATUS_SUCCESS if we do the PCI config space access.
 */
NTSTATUS HaliHandlePCIConfigSpaceAccess( BOOLEAN Read, 
                                                       ULONG   Addr,
                                                       ULONG   Size, 
                                                       PULONG  pData
                                                     )
{
    static      PCI_TYPE1_CFG_BITS CF8_Data = {0};
    static      BOOLEAN CF8_Called = FALSE;
    NTSTATUS    Status = STATUS_SUCCESS;
    
    if(Addr == 0xCF8)
    {
        CF8_Data.u.AsULONG = *pData;
        CF8_Called = TRUE;
    }
    else if(Addr >= 0xCFC && Addr <= 0xCFF)
    {
        if(CF8_Called)
        {
            ULONG Offset = 0;
            ULONG Return = 0;
            PCI_SLOT_NUMBER SlotNumber = {0};
            
            Offset = (CF8_Data.u.bits.RegisterNumber << 2) + (Addr - 0xCFC);
            SlotNumber.u.bits.FunctionNumber = CF8_Data.u.bits.FunctionNumber;
            SlotNumber.u.bits.DeviceNumber = CF8_Data.u.bits.DeviceNumber;    

            if (Read)
            {
                //
                // Do PCI config space read through HAL
                //
                Return = HaliPciInterfaceReadConfig( NULL,
                                                    (UCHAR)CF8_Data.u.bits.BusNumber,
                                                    SlotNumber.u.AsULONG,
                                                    pData,
                                                    Offset,
                                                    Size
                                                  );

                
            }
            else
            {
                //
                // Do PCI config space write through HAL
                //
                Return = HaliPciInterfaceWriteConfig( NULL,
                                                     (UCHAR)CF8_Data.u.bits.BusNumber,
                                                     SlotNumber.u.AsULONG,
                                                     pData,
                                                     Offset,
                                                     Size
                                                   );

                
            }
         
        }
        else
        {
            Status = STATUS_UNSUCCESSFUL;
        }
        
    }
    else
    {
        Status = STATUS_UNSUCCESSFUL;
    }
    
    return Status;
    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halx86\i386\ixirqarb.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    ixirqarb.c

Abstract:

    This module implements an arbiter for IRQs.

Author:

    Santosh Jodh (santoshj) 22-June-1998

Environment:

    NT Kernel Model Driver only

--*/
#include <nthal.h>
#include <arbiter.h>

#ifndef _IN_KERNEL_
#define _IN_KERNEL_
#include <regstr.h>
#undef _IN_KERNEL_
#else
#include <regstr.h>
#endif

#if defined(NEC_98)
#include <pci.h>
#endif
#include "ixpciir.h"

#define ARBITER_CONTEXT_TO_INSTANCE(x)  (x)

#define ARBITER_INTERRUPT_LEVEL         0x10
#define ARBITER_INTERRUPT_EDGE          0x20
#define ARBITER_INTERRUPT_BITS          (ARBITER_INTERRUPT_LEVEL | ARBITER_INTERRUPT_EDGE)

#define NUM_IRQS    16
#if defined(NEC_98)
#define PIC_SLAVE_IRQ           7
#else
#define PIC_SLAVE_IRQ           2
#endif

extern ULONG HalDebug;
#if defined(NEC_98)
extern ULONG NEC98SpecialIRQMask;
#endif

#if DBG
#define DEBUG_PRINT(Level, Message) {   \
    if (HalDebug >= Level) {            \
        DbgPrint("HAL: ");              \
        DbgPrint Message;               \
        DbgPrint("\n");                 \
    }                                   \
}
#else
#define DEBUG_PRINT(Level, Message)
#endif

typedef struct {
    ARBITER_INSTANCE    ArbiterState;
} HAL_ARBITER, *PHAL_ARBITER;

NTSTATUS
HalpInitIrqArbiter (
    IN PDEVICE_OBJECT   HalFdo
    );

NTSTATUS
HalpFillInIrqArbiter (
    IN     PDEVICE_OBJECT   DeviceObject,
    IN     LPCGUID          InterfaceType,
    IN     USHORT           Version,
    IN     PVOID            InterfaceSpecificData,
    IN     ULONG            InterfaceBufferSize,
    IN OUT PINTERFACE       Interface,
    IN OUT PULONG           Length
    );

NTSTATUS
HalpArbUnpackRequirement (
    IN PIO_RESOURCE_DESCRIPTOR Descriptor,
    OUT PULONGLONG Minimum,
    OUT PULONGLONG Maximum,
    OUT PULONG Length,
    OUT PULONG Alignment
    );

NTSTATUS
HalpArbPackResource (
    IN PIO_RESOURCE_DESCRIPTOR Requirement,
    IN ULONGLONG Start,
    OUT PCM_PARTIAL_RESOURCE_DESCRIPTOR Descriptor
    );

NTSTATUS
HalpArbUnpackResource (
    IN PCM_PARTIAL_RESOURCE_DESCRIPTOR Descriptor,
    OUT PULONGLONG Start,
    OUT PULONG Length
    );

LONG
HalpArbScoreRequirement (
    IN PIO_RESOURCE_DESCRIPTOR Descriptor
    );

NTSTATUS
HalpArbTestAllocation (
    IN PARBITER_INSTANCE Arbiter,
    IN OUT PLIST_ENTRY ArbitrationList
    );

NTSTATUS
HalpArbRetestAllocation (
    IN PARBITER_INSTANCE Arbiter,
    IN OUT PLIST_ENTRY ArbitrationList
    );

NTSTATUS
HalpArbCommitAllocation(
    IN PARBITER_INSTANCE Arbiter
    );

NTSTATUS
HalpArbRollbackAllocation (
    PARBITER_INSTANCE Arbiter
    );

NTSTATUS
HalpArbPreprocessEntry(
    IN PARBITER_INSTANCE Arbiter,
    IN PARBITER_ALLOCATION_STATE State
    );

BOOLEAN
HalpArbFindSuitableRange (
    PARBITER_INSTANCE   Arbiter,
    PARBITER_ALLOCATION_STATE State
    );

VOID
HalpArbAddAllocation (
     IN PARBITER_INSTANCE Arbiter,
     IN PARBITER_ALLOCATION_STATE State
     );

VOID
HalpArbBacktrackAllocation (
     IN PARBITER_INSTANCE Arbiter,
     IN PARBITER_ALLOCATION_STATE State
     );

NTSTATUS
HalpArbBootAllocation(
    IN PARBITER_INSTANCE Arbiter,
    IN OUT PLIST_ENTRY ArbitrationList
    );

BOOLEAN
HalpArbGetNextAllocationRange(
    IN PARBITER_INSTANCE Arbiter,
    IN OUT PARBITER_ALLOCATION_STATE State
    );

ULONG
HalpFindLinkInterrupt (
    IN PRTL_RANGE_LIST RangeList,
    IN ULONG Mask,
    IN ULONG Start,
    IN ULONG End,
    IN ULONG Flags,
    IN UCHAR UserFlags
    );

BOOLEAN
HalpArbQueryConflictCallback(
    IN PVOID Context,
    IN PRTL_RANGE Range
    );
VOID
HalpIrqArbiterInterfaceReference(
    IN PVOID    Context
    );
VOID
HalpIrqArbiterInterfaceDereference(
    IN PVOID    Context
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, HalpInitIrqArbiter)
#pragma alloc_text(PAGE, HalpFillInIrqArbiter)
#pragma alloc_text(PAGE, HalpArbUnpackRequirement)
#pragma alloc_text(PAGE, HalpArbPackResource)
#pragma alloc_text(PAGE, HalpArbUnpackResource)
#pragma alloc_text(PAGE, HalpArbScoreRequirement)
#pragma alloc_text(PAGE, HalpArbTestAllocation)
#pragma alloc_text(PAGE, HalpArbRetestAllocation)
#pragma alloc_text(PAGE, HalpArbCommitAllocation)
#pragma alloc_text(PAGE, HalpArbRollbackAllocation)
#pragma alloc_text(PAGE, HalpArbPreprocessEntry)
#pragma alloc_text(PAGE, HalpArbFindSuitableRange)
#pragma alloc_text(PAGE, HalpArbAddAllocation)
#pragma alloc_text(PAGE, HalpArbBacktrackAllocation)
#pragma alloc_text(PAGE, HalpArbBootAllocation)
#pragma alloc_text(PAGE, HalpArbGetNextAllocationRange)
#pragma alloc_text(PAGE, HalpFindLinkInterrupt)
#pragma alloc_text(PAGE, HalpArbQueryConflictCallback)
#pragma alloc_text(PAGE, HalpIrqArbiterInterfaceReference)
#pragma alloc_text(PAGE, HalpIrqArbiterInterfaceDereference)
#endif

#ifdef ALLOC_DATA_PRAGMA
#pragma data_seg()
#endif

HAL_ARBITER HalpArbiter = {{
    0,//Signature
    NULL,//MutexEvent
    NULL,//Name
    {0},//ResourceType
    NULL,//Allocation
    NULL,//PossibleAllocation
    {0},//OrderingList
    {0},//ReservedList
    0,//ReferenceCount
    NULL,//Interface
    0,//AllocationStackMaxSize
    NULL,//AllocationStack
    HalpArbUnpackRequirement,//UnpackRequirement
    HalpArbPackResource,//PackResource
    HalpArbUnpackResource,//UnpackResource
    HalpArbScoreRequirement,//ScoreRequirement
    HalpArbTestAllocation,//TestAllocation
    HalpArbRetestAllocation,//RetestAllocation
    HalpArbCommitAllocation,//CommitAllocation
    HalpArbRollbackAllocation,//RollbackAllocation
    HalpArbBootAllocation,//BootAllocation
    NULL,//QueryArbitrate
    NULL,//QueryConflict
    NULL,//AddReserved
    NULL,//StartArbiter
    HalpArbPreprocessEntry,//PreprocessEntry
    NULL,//AllocateEntry
    HalpArbGetNextAllocationRange,//GetNextAllocationRange
    HalpArbFindSuitableRange,//FindSuitableRange
    HalpArbAddAllocation,//AddAllocation
    HalpArbBacktrackAllocation,//BacktrackAllocation
    NULL,//OverrideConflict
    FALSE,//TransactionInProgress
    &HalpPciIrqRoutingInfo,//Extension
    NULL,//BusDeviceObject
    NULL,//ConflictCallbackContext
    NULL,//ConflictCallback
}};

BOOLEAN
HalpArbQueryConflictCallback(
    IN PVOID Context,
    IN PRTL_RANGE Range
    )
{
    PAGED_CODE();

    if (Range->Attributes & ARBITER_INTERRUPT_LEVEL)
    {
        if(Range->Flags & RTL_RANGE_SHARED)
        {
            return (TRUE);
        }
        else
        {
            DEBUG_PRINT(1, ("Exclusive level interrupt %02x cannot be shared!", (ULONG)Context));
            return (FALSE);
        }
    }

    DEBUG_PRINT(1, ("Refusing to share edge and level interrupts on %02x", (ULONG)Context));
    return (FALSE);
}

NTSTATUS
HalpArbPreprocessEntry(
    IN PARBITER_INSTANCE Arbiter,
    IN PARBITER_ALLOCATION_STATE State
    )
/*++

Routine Description:

    This routine is called from AllocateEntry to allow preprocessing of
    entries

Arguments:

    Arbiter - The instance data of the arbiter who was called.

    State - The state of the current arbitration.

Return Value:

    None.

--*/
{

#define CM_RESOURE_INTERRUPT_LEVEL_LATCHED_BITS 0x0001

    PARBITER_ALTERNATIVE current;

    PAGED_CODE();

    //
    // Validate arguments.
    //

    ASSERT(Arbiter);
    ASSERT(State);

    //
    // We should never be here if Pci Irq routing is not enabled.
    //

    ASSERT(IsPciIrqRoutingEnabled());

    //
    // Check if this is a level (PCI) or latched (ISA (edge)) interrupt and set
    // RangeAttributes accordingly so we set the appropriate flag when we add the
    // range
    //

    if ((State->Alternatives[0].Descriptor->Flags
            & CM_RESOURE_INTERRUPT_LEVEL_LATCHED_BITS)
                == CM_RESOURCE_INTERRUPT_LEVEL_SENSITIVE)
    {

        State->RangeAttributes &= ~ARBITER_INTERRUPT_BITS;
        State->RangeAttributes |= ARBITER_INTERRUPT_LEVEL;

    } else
    {
        ASSERT(State->Alternatives[0].Descriptor->Flags
                    & CM_RESOURCE_INTERRUPT_LATCHED);

        State->RangeAttributes &= ~ARBITER_INTERRUPT_BITS;
        State->RangeAttributes |= ARBITER_INTERRUPT_EDGE;
    }

    return (STATUS_SUCCESS);
}

BOOLEAN
HalpArbGetNextAllocationRange(
    IN PARBITER_INSTANCE Arbiter,
    IN OUT PARBITER_ALLOCATION_STATE State
    )
{
    //
    // Default to having no next range.
    //

    BOOLEAN nextRange = FALSE;

    PAGED_CODE();

    //
    // Try all possible interrupts on first call.
    //

    if (State->CurrentAlternative) {

        if (++State->CurrentAlternative < &State->Alternatives[State->AlternativeCount]) {

            DEBUG_PRINT(3, ("No next allocation range, exhausted all %08X alternatives", State->AlternativeCount));
            nextRange = TRUE;

        }
    }
    else {

        //
        // First call, try the first alternative.
        //

        State->CurrentAlternative = &State->Alternatives[0];
        nextRange = TRUE;

    }

    if (nextRange) {

        State->CurrentMinimum = State->CurrentAlternative->Minimum;
        State->CurrentMaximum = State->CurrentAlternative->Maximum;
        DEBUG_PRINT(3, ("Next allocation range 0x%I64x-0x%I64x", State->CurrentMinimum, State->CurrentMaximum));

    }

    return nextRange;
}

ULONG
HalpFindLinkInterrupt (
    IN PRTL_RANGE_LIST RangeList,
    IN ULONG Mask,
    IN ULONG Start,
    IN ULONG End,
    IN ULONG Flags,
    IN UCHAR UserFlags
    )

/*++

    Routine Description:

        This routine scans the mask from MSB to LSB for the first
        value that is available in the range list.

    Input Parameters:

        RangeList - List to be searched.

        Mask - Interrupt mask to be scanned.

        Start - Start scan AFTER this interrupt.

        Flags - Flags for the range list.

        UserFlags - Special flags.

    Return Value:

        First available interrupt from the mask iff successful. Else 0.

--*/

{
    ULONG       interrupt;
    ULONG       test;
    NTSTATUS    status;
    BOOLEAN     available;

    PAGED_CODE();

    if (Start > 0x0F)
    {
        Start = 0x0F;
    }
    if (Start != 0 && Start >= End)
    {
        interrupt = Start;
        test = 1 << interrupt;
        do
        {
            //
            // If this interrupt is supported, see if it is free.
            //

            if (Mask & test)
            {
                available = FALSE;
                status = RtlIsRangeAvailable(   RangeList,
                                                interrupt,
                                                interrupt,
                                                Flags,
                                                UserFlags,
                                                (PVOID)interrupt,
                                                HalpArbQueryConflictCallback,
                                                &available);
                if (NT_SUCCESS(status) && available)
                {
                    return (interrupt);
                }
            }
            interrupt--;
            test >>= 1;
        }
        while (interrupt > End);
    }

    return (0);
}

BOOLEAN
HalpArbFindSuitableRange (
    PARBITER_INSTANCE   Arbiter,
    PARBITER_ALLOCATION_STATE State
    )

/*++

    Routine Description:

        This
    Input Parameters:

    Return Value:

--*/

{
    PPCI_IRQ_ROUTING_INFO   pciIrqRoutingInfo;
    NTSTATUS                status;
    PLINK_NODE              linkNode;
    ULONG                   interrupt;
    ULONG                   freeInterrupt;
    PLINK_NODE              current;
    ULONG                   busNumber;
    ULONG                   slotNumber;
#if defined(NEC_98)
    PINT_ROUTE_INTERFACE_STANDARD   pciInterface;
    ULONG                   dummy;
    UCHAR                   classCode;
    UCHAR                   subClassCode;
    ROUTING_TOKEN           routingToken;
    UCHAR                   pin;
#endif

    PAGED_CODE();

    //
    // Validate arguments.
    //

    ASSERT(Arbiter);
    ASSERT(State);

    //
    // We should never be here if Pci Irq routing is not enabled.
    //

    ASSERT(IsPciIrqRoutingEnabled());

    pciIrqRoutingInfo = Arbiter->Extension;
    ASSERT(pciIrqRoutingInfo);
    ASSERT(pciIrqRoutingInfo == &HalpPciIrqRoutingInfo);

    if (State->Entry->InterfaceType == PCIBus)
    {
#if defined(NEC_98)
        pciInterface = pciIrqRoutingInfo->PciInterface;

        //
        // Call Pci driver to get info about the Pdo.
        //

        status = pciInterface->GetInterruptRouting( State->Entry->PhysicalDeviceObject,
                                                    &busNumber,
                                                    &slotNumber,
                                                    (PUCHAR)&dummy,
                                                    &pin,
                                                    &classCode,
                                                    &subClassCode,
                                                    (PDEVICE_OBJECT *)&dummy,
                                                    &routingToken,
                                                    (PUCHAR)&dummy);

        //
        // This means that it is not a Pci device.
        //

        if (!NT_SUCCESS(status))
        {
            return (FALSE);
        }
#endif
        busNumber = State->Entry->BusNumber;
        slotNumber = State->Entry->SlotNumber;
    }
    else
    {
        busNumber = (ULONG)-1;
        slotNumber = (ULONG)-1;
    }

    //
    // See if there is link information for this device.
    //

    linkNode = NULL;
    status = HalpFindLinkNode ( pciIrqRoutingInfo,
                                State->Entry->PhysicalDeviceObject,
                                busNumber,
                                slotNumber,
                                &linkNode);
    switch (status)
    {
        case STATUS_SUCCESS:

            if (linkNode == NULL)
            {
                DEBUG_PRINT(1, ("Link does not exist for Pci PDO %08x. Hopefully, device can live without an interrupt!", State->Entry->PhysicalDeviceObject));
                return (FALSE);
            }

            //
            // If we have already decided an interrupt for this link,
            // everyone using it gets the same interrupt.
            //

            if (linkNode->PossibleAllocation->RefCount > 0)
            {
                if (    State->CurrentMinimum <= linkNode->PossibleAllocation->Interrupt &&
                        linkNode->PossibleAllocation->Interrupt <= State->CurrentMaximum)
                {
                    State->Start = linkNode->PossibleAllocation->Interrupt;
                    State->End = State->Start;
                    State->CurrentAlternative->Length = 1;

                    DEBUG_PRINT(2, ("Found Irq (%04x) for Pci PDO %08x using link %02x", (ULONG)State->Start, State->Entry->PhysicalDeviceObject, linkNode->Link));

                    return (TRUE);
                }
                else
                {
                    DEBUG_PRINT(1, ("Found Irq (%04x) for Pci PDO %08x using link %02x but is outside the range (%04x-%04x)!", (ULONG)State->Start, State->Entry->PhysicalDeviceObject, linkNode->Link, State->CurrentMinimum, State->CurrentMaximum));

                    return (FALSE);
                }
            }
            else
            {

                //
                // We want to spread out the links as much as we can for
                // performance.
                //

                //
                // First see if this link is programmed for some IRQ.
                //

                interrupt = 0;
                status = PciirqmpGetIrq((PUCHAR)&interrupt, (UCHAR)linkNode->Link);

                if (NT_SUCCESS(status) && interrupt)
                {

                    if (State->CurrentMinimum <= interrupt && interrupt <= State->CurrentMaximum)
                    {
                        //
                        // Make sure the BIOS did not mess up
                        //

                        freeInterrupt = HalpFindLinkInterrupt ( Arbiter->PossibleAllocation,
                                                                linkNode->InterruptMap,
                                                                interrupt,
                                                                interrupt,
                                                                0,
                                                                0);
                        if(freeInterrupt == 0)
                        {
                            DEBUG_PRINT(1, ("BIOS failure. Assigned Irq (%02x) to link %02x which is unavailable or impossible according to mask %04x", interrupt, linkNode->Link, linkNode->InterruptMap));
                        }
                        interrupt = freeInterrupt;
                    }
                    else
                    {
                        DEBUG_PRINT(1, ("Found Irq (%04x) pre-programmedfor link %02x but is outside the range (%04x-%04x)!", interrupt, linkNode->Link, State->CurrentMinimum, State->CurrentMaximum));
                        return (FALSE);
                    }
                }


                if (interrupt == 0)
                {
#if defined(NEC_98)
                    if (NEC98SpecialIRQMask){
                        linkNode->InterruptMap &= ~( 1 << NEC98SpecialIRQMask);
                    }
#endif
                    //
                    // Try to get an interrupt by itself for this link.
                    //

                    interrupt = HalpFindLinkInterrupt ( Arbiter->PossibleAllocation,
                                                        linkNode->InterruptMap,
                                                        (ULONG)State->CurrentMaximum,
                                                        (ULONG)State->CurrentMinimum,
                                                        0,
                                                        0);
#if defined(NEC_98)
                    //
                    // Force to share CardBus IRQ with another PCI Device
                    //
                    if ( interrupt &&
                         classCode == PCI_CLASS_BRIDGE_DEV &&
                         subClassCode == PCI_SUBCLASS_BR_CARDBUS )
                    {
                        //
                        // Remember this.
                        //

                         freeInterrupt = interrupt;

                        do
                        {
                            //
                            // Is this being used by another link?
                            //
                            current = pciIrqRoutingInfo->LinkNodeHead;

                            while ( current != NULL) {

                                if ( current->PossibleAllocation->Interrupt == interrupt )
                                {
                                    //
                                    // somebody use this. Cardbus controller use this, too.
                                    //
                                    interrupt = 0;
                                    break;
                                }
                                current = current->Next;
                            }

                            if (interrupt){
                                interrupt = HalpFindLinkInterrupt ( Arbiter->PossibleAllocation,
                                                                    linkNode->InterruptMap,
                                                                    interrupt - 1,
                                                                    (ULONG)State->CurrentMinimum,
                                                                    0,
                                                                    0);
                                if (interrupt) {
                                    //
                                    // Remember this, if find new interrupt.
                                    //

                                    freeInterrupt = interrupt;
                                }
                            }

                        }
                        while (interrupt);

                        if (!interrupt)
                        {
                            interrupt = freeInterrupt;
                        }

                    } else if ( interrupt )
#else
                    if (interrupt)
#endif
                    {
                        //
                        // Remember this.
                        //

                        freeInterrupt = interrupt;

                        do
                        {
                            //
                            // Is this being used by another link?
                            //

                            for (   current = pciIrqRoutingInfo->LinkNodeHead;
                                    current && current->PossibleAllocation->Interrupt != interrupt;
                                    current = current->Next);
                            if (current == NULL)
                            {
                                break;
                            }

                            interrupt = HalpFindLinkInterrupt ( Arbiter->PossibleAllocation,
                                                                linkNode->InterruptMap,
                                                                interrupt - 1,
                                                                (ULONG)State->CurrentMinimum,
                                                                0,
                                                                0);
                        }
                        while (interrupt);

                        if (!interrupt)
                        {
                            if (!(pciIrqRoutingInfo->Parameters & PCIIR_FLAG_EXCLUSIVE)) {
                                interrupt = freeInterrupt;
                            }
                        }
                    }
                }

                if (interrupt)
                {
                    State->Start = interrupt;
                    State->End = interrupt;
                    State->CurrentAlternative->Length = 1;

                    DEBUG_PRINT(2, ("Found Irq (%04x) for Pci PDO %08x using link %02x", (ULONG)State->Start, State->Entry->PhysicalDeviceObject, linkNode->Link));

                    return (TRUE);
                }
            }

            //
            // There is no interrupt this link can use, too bad.
            //

            return (FALSE);

        case STATUS_RESOURCE_REQUIREMENTS_CHANGED:

            //
            // Pci Ide device does not share Irqs.
            //

            if (State->CurrentAlternative->Flags & ARBITER_ALTERNATIVE_FLAG_SHARED) {

                State->CurrentAlternative->Flags &= ~ARBITER_ALTERNATIVE_FLAG_SHARED;
            }

        default:


            //
            // Non Pci device.
            //

            break;
    }

    //
    // HACKHACK: This is to allow boot conflict on IRQ 14 and 15.
    // This is so that broken machines which report both PNP06xx and
    // the PCI IDE controller work. One of them (no order guarantee)
    // will come up with a conflict.
    //

    if (State->Entry->Flags & ARBITER_FLAG_BOOT_CONFIG) {
        if (    State->CurrentMinimum == State->CurrentMaximum &&
                (State->CurrentMinimum == 14 || State->CurrentMinimum == 15)) {
            State->RangeAvailableAttributes |= ARBITER_RANGE_BOOT_ALLOCATED;
        }
    }

    return (ArbFindSuitableRange(Arbiter, State));
}

VOID
HalpArbAddAllocation(
     IN PARBITER_INSTANCE Arbiter,
     IN PARBITER_ALLOCATION_STATE State
     )
{
    PPCI_IRQ_ROUTING_INFO   pciIrqRoutingInfo;
    NTSTATUS                status;
    PLINK_NODE              linkNode;

    PAGED_CODE();

    //
    // Validate arguments.
    //

    ASSERT(Arbiter);
    ASSERT(State);

    //
    // We should never be here if Pci Irq routing is not enabled.
    //

    ASSERT(IsPciIrqRoutingEnabled());

    pciIrqRoutingInfo = Arbiter->Extension;
    ASSERT(pciIrqRoutingInfo);
    ASSERT(pciIrqRoutingInfo == &HalpPciIrqRoutingInfo);

    DEBUG_PRINT(3, ("Adding Irq (%04x) allocation for PDO %08x", (ULONG)State->Start, State->Entry->PhysicalDeviceObject));

    linkNode = NULL;
    status = HalpFindLinkNode ( pciIrqRoutingInfo,
                                State->Entry->PhysicalDeviceObject,
                                State->Entry->BusNumber,
                                State->Entry->SlotNumber,
                                &linkNode);
    if (NT_SUCCESS(status) && status != STATUS_RESOURCE_REQUIREMENTS_CHANGED)
    {
        if (linkNode)
        {
            if (linkNode->PossibleAllocation->RefCount)
            {
                if (linkNode->PossibleAllocation->Interrupt != State->Start)
                {
                    DEBUG_PRINT(1, ("Two different interrupts (old = %08x, new = %08x) for the same link %08x!", linkNode->PossibleAllocation->Interrupt, State->Start, linkNode->Link));
                    ASSERT(linkNode->PossibleAllocation->Interrupt == State->Start);
                }
            }
            else
            {
                DEBUG_PRINT(3, ("Adding new Irq (%04x) allocation for Pci PDO %08x using link %02x", (ULONG)State->Start, State->Entry->PhysicalDeviceObject, linkNode->Link));

                linkNode->PossibleAllocation->Interrupt = (ULONG)State->Start;
            }

            linkNode->PossibleAllocation->RefCount++;
        }
        else
        {
            DEBUG_PRINT(1, ("This should never happen!"));
            ASSERT(linkNode);
        }
    }

    status = RtlAddRange(   Arbiter->PossibleAllocation,
                            State->Start,
                            State->End,
                            State->RangeAttributes,
                            RTL_RANGE_LIST_ADD_IF_CONFLICT +
                                ((State->CurrentAlternative->Flags &
                                    ARBITER_ALTERNATIVE_FLAG_SHARED)?
                                        RTL_RANGE_LIST_ADD_SHARED : 0),
                            linkNode, // This line is different from the default function
                            State->Entry->PhysicalDeviceObject);

    ASSERT(NT_SUCCESS(status));
}

VOID
HalpArbBacktrackAllocation (
     IN PARBITER_INSTANCE Arbiter,
     IN PARBITER_ALLOCATION_STATE State
     )
{
    PPCI_IRQ_ROUTING_INFO   pciIrqRoutingInfo;
    NTSTATUS                status;
    PLINK_NODE              linkNode;

    PAGED_CODE();

    //
    // Validate arguments.
    //

    ASSERT(Arbiter);
    ASSERT(State);

    //
    // We should never be here if Pci Irq routing is not enabled.
    //

    ASSERT(IsPciIrqRoutingEnabled());

    pciIrqRoutingInfo = Arbiter->Extension;
    ASSERT(pciIrqRoutingInfo);
    ASSERT(pciIrqRoutingInfo == &HalpPciIrqRoutingInfo);

    DEBUG_PRINT(3, ("Backtracking Irq (%04x) allocation for PDO %08x", (ULONG)State->Start, State->Entry->PhysicalDeviceObject));

    linkNode = NULL;
    status = HalpFindLinkNode ( pciIrqRoutingInfo,
                                State->Entry->PhysicalDeviceObject,
                                State->Entry->BusNumber,
                                State->Entry->SlotNumber,
                                &linkNode);
    if (NT_SUCCESS(status) && status == STATUS_SUCCESS)
    {
        if (linkNode)
        {
            if (linkNode->PossibleAllocation->RefCount == 0)
            {
                DEBUG_PRINT(1, ("Negative ref count during backtracking!"));
                ASSERT(linkNode->PossibleAllocation->RefCount);
            }
            else
            {
                DEBUG_PRINT(3, ("Backtracking Irq (%04x) allocation for Pci PDO %08x using link %02x", (ULONG)State->Start, State->Entry->PhysicalDeviceObject, linkNode->Link));

                linkNode->PossibleAllocation->RefCount--;
                if (linkNode->PossibleAllocation->RefCount == 0)
                {
                    linkNode->PossibleAllocation->Interrupt = 0;
                }
            }
        }
        else
        {
            DEBUG_PRINT(1, ("This should never happen!"));
            ASSERT(linkNode);
        }
    }

    //
    // Let the default function do most of the work.
    //

    ArbBacktrackAllocation(Arbiter, State);
}


NTSTATUS
HalpArbCommitAllocation(
    IN PARBITER_INSTANCE Arbiter
    )
{
    PPCI_IRQ_ROUTING_INFO   pciIrqRoutingInfo;
    RTL_RANGE_LIST_ITERATOR iterator;
    PRTL_RANGE              current;
    PLINK_NODE              linkNode;
    NTSTATUS                status;

    PAGED_CODE();

    //
    // Validate arguments.
    //

    ASSERT(Arbiter);

    //
    // We should never be here if Pci Irq routing is not enabled.
    //

    ASSERT(IsPciIrqRoutingEnabled());

    pciIrqRoutingInfo = Arbiter->Extension;
    ASSERT(pciIrqRoutingInfo);
    ASSERT(pciIrqRoutingInfo == &HalpPciIrqRoutingInfo);

    //
    // Program the int line register for all Pci devices.
    //

    FOR_ALL_RANGES(Arbiter->PossibleAllocation, &iterator, current)
    {
        if (current->UserData)
        {
            HalpProgramInterruptLine (  pciIrqRoutingInfo,
                                        current->Owner,
                                        (ULONG)current->Start);
        }
    }



    //
    // Program all links to their possible value if
    // there is a reference to them.
    //

    for (   linkNode = pciIrqRoutingInfo->LinkNodeHead;
            linkNode;
            linkNode = linkNode->Next)
    {
        status = HalpCommitLink(linkNode);
        if (!NT_SUCCESS(status))
        {
            return (status);
        }
    }

    //
    // Let the default function do the rest of the work.
    //

    return (ArbCommitAllocation(Arbiter));
}

NTSTATUS
HalpArbTestAllocation (
    IN PARBITER_INSTANCE Arbiter,
    IN OUT PLIST_ENTRY ArbitrationList
    )
{
    PPCI_IRQ_ROUTING_INFO   pciIrqRoutingInfo;
    PLINK_NODE              linkNode;
    NTSTATUS                status;
    PARBITER_LIST_ENTRY     current;
    PDEVICE_OBJECT          previousOwner;
    PDEVICE_OBJECT          currentOwner;
    RTL_RANGE_LIST_ITERATOR iterator;
    PRTL_RANGE              currentRange;

    PAGED_CODE();

    //
    // Validate arguments.
    //

    ASSERT(Arbiter);
    ASSERT(ArbitrationList);

    //
    // We should never be here if Pci Irq routing is not enabled.
    //

    ASSERT(IsPciIrqRoutingEnabled());

    pciIrqRoutingInfo = Arbiter->Extension;
    ASSERT(pciIrqRoutingInfo);
    ASSERT(pciIrqRoutingInfo == &HalpPciIrqRoutingInfo);

    //
    // Copy the allocation into the possible allocation for
    // for links.
    //

    for (   linkNode = pciIrqRoutingInfo->LinkNodeHead;
            linkNode;
            linkNode = linkNode->Next)
    {
        *linkNode->PossibleAllocation = *linkNode->Allocation;
    }

    previousOwner = NULL;

    FOR_ALL_IN_LIST(ARBITER_LIST_ENTRY, ArbitrationList, current)
    {
        currentOwner = current->PhysicalDeviceObject;

        if (previousOwner != currentOwner) {

            previousOwner = currentOwner;
            FOR_ALL_RANGES(Arbiter->Allocation, &iterator, currentRange)
            {
                if (currentRange->Owner == currentOwner)
                {
                    status = HalpFindLinkNode ( pciIrqRoutingInfo,
                                                                currentOwner,
                                        current->BusNumber,
                                        current->SlotNumber,
                                                                &linkNode);
                    if (NT_SUCCESS(status) && status == STATUS_SUCCESS)
                    {
                        if (linkNode)
                        {
                            if (linkNode->PossibleAllocation->RefCount > 0)
                            {
                                DEBUG_PRINT(3, ("Decrementing link (%02x) usage to %d during test allocation", linkNode->Link, linkNode->PossibleAllocation->RefCount - 1));

                                linkNode->PossibleAllocation->RefCount--;
                                if (linkNode->PossibleAllocation->RefCount == 0)
                                {
                                    DEBUG_PRINT(3, ("Deleting Irq (%04x) allocation for link (%02x) during test allocation", linkNode->PossibleAllocation->Interrupt, linkNode->Link));
                                    linkNode->PossibleAllocation->Interrupt = 0;
                                }
                            }
                        }
                    }
                }
            }
        }
    }

    //
    // Let the default function do most of the work.
    //

    return (ArbTestAllocation(Arbiter, ArbitrationList));
}

NTSTATUS
HalpArbRetestAllocation (
    IN PARBITER_INSTANCE Arbiter,
    IN OUT PLIST_ENTRY ArbitrationList
    )
{
    PPCI_IRQ_ROUTING_INFO   pciIrqRoutingInfo;
    PLINK_NODE              linkNode;
    NTSTATUS                status;
    PARBITER_LIST_ENTRY     current;
    PDEVICE_OBJECT          previousOwner;
    PDEVICE_OBJECT          currentOwner;
    RTL_RANGE_LIST_ITERATOR iterator;
    PRTL_RANGE                  currentRange;

    PAGED_CODE();

    //
    // Validate arguments.
    //

    ASSERT(Arbiter);
    ASSERT(ArbitrationList);

    //
    // We should never be here if Pci Irq routing is not enabled.
    //

    ASSERT(IsPciIrqRoutingEnabled());

    pciIrqRoutingInfo = Arbiter->Extension;
    ASSERT(pciIrqRoutingInfo);
    ASSERT(pciIrqRoutingInfo == &HalpPciIrqRoutingInfo);

    //
    // Copy the allocation into the possible allocation for
    // for links.
    //

    for (   linkNode = pciIrqRoutingInfo->LinkNodeHead;
            linkNode;
            linkNode = linkNode->Next)
    {
        *linkNode->PossibleAllocation = *linkNode->Allocation;
    }

    previousOwner = NULL;

    FOR_ALL_IN_LIST(ARBITER_LIST_ENTRY, ArbitrationList, current)
    {
        currentOwner = current->PhysicalDeviceObject;

        if (previousOwner != currentOwner) {

            previousOwner = currentOwner;
            FOR_ALL_RANGES(Arbiter->Allocation, &iterator, currentRange)
            {
                if (currentRange->Owner == currentOwner)
                {
                    status = HalpFindLinkNode ( pciIrqRoutingInfo,
                                                                currentOwner,
                                        current->BusNumber,
                                        current->SlotNumber,
                                                                &linkNode);
                    if (NT_SUCCESS(status) && status == STATUS_SUCCESS)
                    {
                        if (linkNode)
                        {
                            if (linkNode->PossibleAllocation->RefCount > 0)
                            {
                                DEBUG_PRINT(3, ("Decrementing link (%02x) usage to %d during retest allocation", linkNode->Link, linkNode->PossibleAllocation->RefCount - 1));

                                linkNode->PossibleAllocation->RefCount--;
                                if (linkNode->PossibleAllocation->RefCount == 0)
                                {
                                    DEBUG_PRINT(3, ("Deleting Irq (%04x) allocation for link (%02x) during retest allocation", linkNode->PossibleAllocation->Interrupt, linkNode->Link));
                                    linkNode->PossibleAllocation->Interrupt = 0;
                                }
                            }
                        }
                    }
                }
            }
        }
    }

    return (ArbRetestAllocation(Arbiter, ArbitrationList));
}

NTSTATUS
HalpArbBootAllocation(
    IN PARBITER_INSTANCE Arbiter,
    IN OUT PLIST_ENTRY ArbitrationList
    )
{
    PPCI_IRQ_ROUTING_INFO   pciIrqRoutingInfo;
    PLINK_NODE              linkNode;
    NTSTATUS                status;

    PAGED_CODE();

    //
    // Validate arguments.
    //

    ASSERT(Arbiter);
    ASSERT(ArbitrationList);

    //
    // We should never be here if Pci Irq routing is not enabled.
    //

    ASSERT(IsPciIrqRoutingEnabled());

    pciIrqRoutingInfo = Arbiter->Extension;
    ASSERT(pciIrqRoutingInfo);
    ASSERT(pciIrqRoutingInfo == &HalpPciIrqRoutingInfo);

    //
    // Copy the allocation into the possible allocation for
    // for links.
    //

    for (   linkNode = pciIrqRoutingInfo->LinkNodeHead;
            linkNode;
            linkNode = linkNode->Next)
    {
        *linkNode->PossibleAllocation = *linkNode->Allocation;
    }

    status = ArbBootAllocation(Arbiter, ArbitrationList);

    //
    // Copy possible allocation back into allocation for links.
    //

    for (   linkNode = pciIrqRoutingInfo->LinkNodeHead;
            linkNode;
            linkNode = linkNode->Next)
    {
        *linkNode->Allocation = *linkNode->PossibleAllocation;
    }

    return status;
}

NTSTATUS
HalpArbRollbackAllocation (
    PARBITER_INSTANCE Arbiter
    )
{
    PPCI_IRQ_ROUTING_INFO   pciIrqRoutingInfo;
    PLINK_NODE              linkNode;
    ULONG                   interrupt;

    PAGED_CODE();

    //
    // Validate arguments.
    //

    ASSERT(Arbiter);

    //
    // We should never be here if Pci Irq routing is not enabled.
    //

    ASSERT(IsPciIrqRoutingEnabled());

    pciIrqRoutingInfo = Arbiter->Extension;
    ASSERT(pciIrqRoutingInfo);
    ASSERT(pciIrqRoutingInfo == &HalpPciIrqRoutingInfo);

    //
    // Clear the possible allocation.
    //

    for (   linkNode = pciIrqRoutingInfo->LinkNodeHead;
            linkNode;
            linkNode = linkNode->Next)
    {
        linkNode->PossibleAllocation->Interrupt = 0;
        linkNode->PossibleAllocation->RefCount = 0;
    }

    //
    // Let the default function do rest of the work.
    //

    return (ArbRollbackAllocation(Arbiter));
}

NTSTATUS
HalpArbUnpackRequirement (
    IN PIO_RESOURCE_DESCRIPTOR Descriptor,
    OUT PULONGLONG Minimum,
    OUT PULONGLONG Maximum,
    OUT PULONG Length,
    OUT PULONG Alignment
    )

/*++

    Routine Description:

        This routine unpacks the requirement descriptor into a minimum, maximum value
        and the length and its alignment.

    Input Parameters:

        Descriptor - Requirement to be unpacked.

        Minimum - Receives the minimum value for the requirement.

        Maximum - Receives the maximum value for this requirement.

        Length - Length of the requirement.

        Alignment - Alignment of this requirement.

    Return Value:

        Standard NT status value.

--*/

{
    PAGED_CODE();

    //
    // Validate arguments.
    //

    ASSERT(Descriptor);
    ASSERT(Minimum);
    ASSERT(Maximum);
    ASSERT(Length);
    ASSERT(Alignment);

    //
    // Make sure we are dealing with the correct resource.
    //

    ASSERT(Descriptor->Type == CmResourceTypeInterrupt);

    //
    // We should never be here if Pci Irq routing is not enabled.
    //

    ASSERT(IsPciIrqRoutingEnabled());

    //
    // Do unpacking.
    //

    *Minimum = (ULONGLONG) Descriptor->u.Interrupt.MinimumVector;
    *Maximum = (ULONGLONG) Descriptor->u.Interrupt.MaximumVector;
    *Length = 1;
    *Alignment = 1;

    DEBUG_PRINT(3, ("Unpacking Irq requirement %p = 0x%04lx - 0x%04lx", Descriptor, *Minimum, *Maximum));

    return (STATUS_SUCCESS);
}

NTSTATUS
HalpArbPackResource (
    IN PIO_RESOURCE_DESCRIPTOR Requirement,
    IN ULONGLONG Start,
    OUT PCM_PARTIAL_RESOURCE_DESCRIPTOR Descriptor
    )

/*++

Routine Description:

    This routine packs the resource descriptor from a starting value and the requirement.

Input Parameters:

    Requirement - Resource requirement to be packed into the resource descriptor.

    Start - Starting value for this resource.

    Descriptor - Resource descriptor to be packed.

Return Value:

    STATUS_SUCCESS.

--*/

{
    PAGED_CODE();

    //
    // Validate arguments.
    //

    ASSERT(Requirement);
    ASSERT(Start < (ULONG)-1);
    ASSERT(Descriptor);

    //
    // Make sure we are dealing with the correct resource.
    //

    ASSERT(Requirement->Type == CmResourceTypeInterrupt);

    //
    // We should never be here if Pci Irq routing is not enabled.
    //

    ASSERT(IsPciIrqRoutingEnabled());

    Descriptor->Type = CmResourceTypeInterrupt;
    Descriptor->Flags = Requirement->Flags;
    Descriptor->ShareDisposition = Requirement->ShareDisposition;
    Descriptor->u.Interrupt.Vector = (ULONG) Start;
    Descriptor->u.Interrupt.Level = (ULONG) Start;
    Descriptor->u.Interrupt.Affinity = 0xFFFFFFFF;

    DEBUG_PRINT(3, ("Packing Irq resource %p = 0x%04lx", Descriptor, (ULONG)Start));

    return (STATUS_SUCCESS);
}

NTSTATUS
HalpArbUnpackResource (
    IN PCM_PARTIAL_RESOURCE_DESCRIPTOR Descriptor,
    OUT PULONGLONG Start,
    OUT PULONG Length
    )

/*++

Routine Description:

    This routine unpacks the resource descriptor into a starting value and length.

Input Parameters:

    Descriptor - Resource descriptor to be unpacked.

    Start - Receives the starting value for this descriptor.

    Length - Receives the length of this resource.

Return Value:

    STATUS_SUCCESS.

--*/

{
    PAGED_CODE();

    //
    // Validate arguments.
    //

    ASSERT(Descriptor);
    ASSERT(Start);
    ASSERT(Length);

    //
    // Make sure we are dealing with the correct resource.
    //

    ASSERT(Descriptor->Type == CmResourceTypeInterrupt);

    //
    // We should never be here if Pci Irq routing is not enabled.
    //

    ASSERT(IsPciIrqRoutingEnabled());

    //
    // Do unpacking.
    //

    *Start = Descriptor->u.Interrupt.Vector;
    *Length = 1;

    DEBUG_PRINT(3, ("Unpacking Irq resource %p = 0x%04lx", Descriptor, (ULONG)*Start));

    return (STATUS_SUCCESS);
}

LONG
HalpArbScoreRequirement (
    IN PIO_RESOURCE_DESCRIPTOR Descriptor
    )

/*++

Routine Description:

    This routine returns a score that indicates the flexibility of this
    device's requirements. Less flexible devices get low scores so that
    they get assigned resources before more flexible devices.

Input Parameters:

    Descriptor - Resource descriptor to be scored.

Return Value:

    Returns the score for the descriptor.

--*/

{
    LONG        score;

    PAGED_CODE();

    //
    // Validate argument.
    //

    ASSERT(Descriptor);

    //
    // Make sure we are dealing with the correct resource.
    //

    ASSERT(Descriptor->Type == CmResourceTypeInterrupt);

    //
    // We should never be here if Pci Irq routing is not enabled.
    //

    ASSERT(IsPciIrqRoutingEnabled());

    //
    // Score is directly determined by number of irqs in the decriptor.
    //

    score = Descriptor->u.Interrupt.MaximumVector -
                Descriptor->u.Interrupt.MinimumVector + 1;

    DEBUG_PRINT(3, ("Scoring Irq resource %p = %i", Descriptor, score));

    return (score);
}

NTSTATUS
HalpInitIrqArbiter (
    IN PDEVICE_OBJECT   HalFdo
    )
{
    NTSTATUS            status;

    PAGED_CODE();

    if (HalpArbiter.ArbiterState.MutexEvent)
    {
        return STATUS_SUCCESS;
    }

    DEBUG_PRINT(3, ("Initialzing Irq arbiter!"));

    status = ArbInitializeArbiterInstance(  &HalpArbiter.ArbiterState,
                                            HalFdo,
                                            CmResourceTypeInterrupt,
                                            L"HalIRQ",
                                            L"Root",
                                            NULL);

    if (NT_SUCCESS(status))
    {
        //
        // Make interrupts >= 16 unavailable.
        //

        status = RtlAddRange(   HalpArbiter.ArbiterState.Allocation,
                                16,
                                MAXULONGLONG,
                                0,
                                RTL_RANGE_LIST_ADD_IF_CONFLICT,
                                NULL,
                                NULL);

        status = RtlAddRange(   HalpArbiter.ArbiterState.Allocation,
                                PIC_SLAVE_IRQ,
                                PIC_SLAVE_IRQ,
                                0,
                                RTL_RANGE_LIST_ADD_IF_CONFLICT,
                                NULL,
                                NULL);

        DEBUG_PRINT(1, ("Irq arbiter successfully initialized!"));
    }
    else
    {
        //
        // Keep us "uninitialized"
        //
        HalpArbiter.ArbiterState.MutexEvent = NULL;
        ASSERT(NT_SUCCESS(status));
    }

    return (status);
}

VOID
HalpIrqArbiterInterfaceReference(
    IN PVOID    Context
    )
{
    //HalPnpInterfaceReference
    PAGED_CODE();
    return;
}

VOID
HalpIrqArbiterInterfaceDereference(
    IN PVOID    Context
    )
{
    //HalPnpInterfaceDereference
    PAGED_CODE();
    return;
}

#ifdef ALLOC_DATA_PRAGMA
#pragma const_seg("PAGECONST")
#endif // ALLOC_DATA_PRAGMA
const ARBITER_INTERFACE ArbInterface = {
    sizeof(ARBITER_INTERFACE),//Size
    1,//Version
    &HalpArbiter.ArbiterState,//Context
    HalpIrqArbiterInterfaceReference,//InterfaceReference
    HalpIrqArbiterInterfaceDereference,//InterfaceDereference
    &ArbArbiterHandler,//ArbiterHandler
    0//Flags -- Do not set ARBITER_PARTIAL here
};
#ifdef ALLOC_DATA_PRAGMA
#pragma const_seg()
#endif // ALLOC_DATA_PRAGMA

NTSTATUS
HalpFillInIrqArbiter (
    IN     PDEVICE_OBJECT   DeviceObject,
    IN     LPCGUID          InterfaceType,
    IN     USHORT           Version,
    IN     PVOID            InterfaceSpecificData,
    IN     ULONG            InterfaceBufferSize,
    IN OUT PINTERFACE       Interface,
    IN OUT PULONG           Length
    )
{
    PAGED_CODE();

    *Length = sizeof(ARBITER_INTERFACE);
    if (InterfaceBufferSize < sizeof(ARBITER_INTERFACE)) {
        return STATUS_BUFFER_TOO_SMALL;
    }

    *(PARBITER_INTERFACE)Interface = ArbInterface;

    DEBUG_PRINT(3, ("Providing Irq Arbiter for FDO %08x since Pci Irq Routing is enabled!", DeviceObject));
    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halx86\i386\ixhwsup.c ===
/*++


Copyright (c) 1989  Microsoft Corporation

Module Name:

    ixhwsup.c

Abstract:

    This module contains the IoXxx routines for the NT I/O system that
    are hardware dependent.  Were these routines not hardware dependent,
    they would reside in the iosubs.c module.

Author:

    Darryl E. Havens (darrylh) 11-Apr-1990

Environment:

    Kernel mode

Revision History:


--*/

#include "halp.h"
#include "halpnpp.h"
#include "eisa.h"

#define COMMON_BUFFER_ALLOCATION_ATTEMPTS 5


#ifdef ACPI_HAL
//
// Interface to the F-type control methods
//
extern ISA_FTYPE_DMA_INTERFACE HalpFDMAInterface;
#endif

#define HAL_WCB_DRIVER_BUFFER    1

typedef struct _HAL_WAIT_CONTEXT_BLOCK {
    ULONG Flags;
    PMDL Mdl;
    PMDL DmaMdl;
    PVOID MapRegisterBase;
    PVOID CurrentVa;
    ULONG Length;
    ULONG NumberOfMapRegisters;
    union {
        struct {
            WAIT_CONTEXT_BLOCK Wcb;
            PDRIVER_LIST_CONTROL DriverExecutionRoutine;
            PVOID DriverContext;
            PIRP CurrentIrp;
            PADAPTER_OBJECT AdapterObject;
            BOOLEAN WriteToDevice;
        };

        SCATTER_GATHER_LIST ScatterGather;
    };
} HAL_WAIT_CONTEXT_BLOCK, *PHAL_WAIT_CONTEXT_BLOCK;

//
// Due to Intel chipset bugs, we can only do
// certain processor power management functions
// when there is no DMA traffic.  So we need to
// know.  The nature of the bug (in the PIIX4)
// chip is such that we really only care about
// transactions from the IDE controller in PIIX4.
// And it uses the scatter/gather functions.
//
// Only the UP acpi hals require this value to be
// tracked.
//

LONG HalpOutstandingScatterGatherCount = 0;

extern KSPIN_LOCK HalpDmaAdapterListLock;
extern LIST_ENTRY HalpDmaAdapterList;

HALP_MOVE_MEMORY_ROUTINE HalpMoveMemory = RtlMoveMemory;

#if defined(TRACK_SCATTER_GATHER_COUNT)

#define INCREMENT_SCATTER_GATHER_COUNT() \
        InterlockedIncrement(&HalpOutstandingScatterGatherCount)
#define DECREMENT_SCATTER_GATHER_COUNT() \
        InterlockedDecrement(&HalpOutstandingScatterGatherCount)

#else

#define INCREMENT_SCATTER_GATHER_COUNT()
#define DECREMENT_SCATTER_GATHER_COUNT()

#endif

VOID
HalpGrowMapBufferWorker(
    IN PVOID Context
    );

IO_ALLOCATION_ACTION
HalpAllocateAdapterCallback (
    IN struct _DEVICE_OBJECT *DeviceObject,
    IN struct _IRP *Irp,
    IN PVOID MapRegisterBase,
    IN PVOID Context
    );

static KSPIN_LOCK HalpReservedPageLock;
static PVOID      HalpReservedPages = NULL;
static PFN_NUMBER HalpReservedPageMdl[(sizeof(MDL)/sizeof(PFN_NUMBER)) + 2];

#ifndef ACPI_HAL

#define HalpNewAdapter HalpBusDatabaseEvent
extern KEVENT   HalpNewAdapter;

#else

extern KEVENT   HalpNewAdapter;

#endif // ACPI_HAL

#define ACQUIRE_NEW_ADAPTER_LOCK()  \
{                                   \
    KeWaitForSingleObject (         \
        &HalpNewAdapter,            \
        WrExecutive,                \
        KernelMode,                 \
        FALSE,                      \
        NULL                        \
        );                          \
}

#define RELEASE_NEW_ADAPTER_LOCK()  \
    KeSetEvent (&HalpNewAdapter, 0, FALSE)

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, HalpAllocateMapRegisters)
#endif


VOID
HalpInitReservedPages(
    VOID
    )
/*++

Routine Description:

    Initalize the data structures necessary to continue DMA
    during low memory conditions

Aruments:

    None

Reurn Value:

    None

--*/
{
    PMDL Mdl;

    HalpReservedPages = MmAllocateMappingAddress(PAGE_SIZE, HAL_POOL_TAG);

    ASSERT(HalpReservedPages);

    Mdl = (PMDL)&HalpReservedPageMdl;
    MmInitializeMdl(Mdl, NULL, PAGE_SIZE);
    Mdl->MdlFlags |= MDL_PAGES_LOCKED;

    KeInitializeSpinLock(&HalpReservedPageLock);
}


VOID
HalpCopyBufferMapSafe(
    IN PMDL Mdl,
    IN PTRANSLATION_ENTRY TranslationEntry,
    IN PVOID CurrentVa,
    IN ULONG Length,
    IN BOOLEAN WriteToDevice
    )
/*++

Routine Description:

    This routine copies the specific data between an unmapped user buffer
    and the map register buffer.  We will map and unmap each page of the
    transfer using our emergency reserved mapping

Arguments:

    Mdl - Pointer to the MDL that describes the pages of memory that are
          being read or written.

    TranslationEntry - The address of the base map register that has been
                       allocated to the device driver for use in mapping
                       the transfer.

    CurrentVa - Current virtual address in the buffer described by the MDL
                that the transfer is being done to or from.

    Length - The length of the transfer.  This determines the number of map
        registers that need to be written to map the transfer.

    WriteToDevice - Boolean value that indicates whether this is a write
        to the device from memory (TRUE), or vice versa.

Return Value:

    None

--*/
{
    PCCHAR bufferAddress;
    PCCHAR mapAddress;
    ULONG bytesLeft;
    ULONG bytesThisCopy;
    ULONG bufferPageOffset;
    PTRANSLATION_ENTRY translationEntry;
    KIRQL Irql;
    PMDL ReserveMdl;
    MEMORY_CACHING_TYPE MCFlavor;
    PPFN_NUMBER SrcPFrame;
    PPFN_NUMBER ReservePFrame;

    //
    // Synchronize access to our reserve page data structures
    //
    KeAcquireSpinLock(&HalpReservedPageLock, &Irql);

    //
    // Get local copies of Length and TranslationEntry as they will be
    // decremented/incremented respectively
    //
    bytesLeft = Length;
    translationEntry = TranslationEntry;

    //
    // Find the PFN in our caller's MDL that describes the first page in
    // physical memory that we need to access
    //
    SrcPFrame = MmGetMdlPfnArray(Mdl);
    SrcPFrame += ((ULONG_PTR)CurrentVa - (ULONG_PTR)MmGetMdlBaseVa(Mdl)) >>
        PAGE_SHIFT;

    //
    // Initialize our reserve MDL's StartVa and ByteOffset
    //
    ReserveMdl = (PMDL)&HalpReservedPageMdl;
    ReservePFrame = MmGetMdlPfnArray(ReserveMdl);
    ReserveMdl->StartVa = (PVOID)PAGE_ALIGN(CurrentVa);
    ReserveMdl->ByteOffset = BYTE_OFFSET(CurrentVa);
    ReserveMdl->ByteCount = PAGE_SIZE - ReserveMdl->ByteOffset;

    //
    // Copy the data one translation entry at a time
    //
    while (bytesLeft > 0) {

        //
        // Copy current source PFN into our reserve MDL
        //      
        *ReservePFrame = *SrcPFrame;

        //
        // Enumerate thru cache flavors until we get our reserve mapping
        //
        bufferAddress = NULL;
        for (MCFlavor = MmNonCached;
             MCFlavor < MmMaximumCacheType;
             MCFlavor++) {
            
            bufferAddress =
                MmMapLockedPagesWithReservedMapping(HalpReservedPages,
                                                    HAL_POOL_TAG,
                                                    ReserveMdl,
                                                    MCFlavor);
            if (bufferAddress != NULL) {
                break;
            }
        }
        
        //
        // Could not establish a reserve mapping, we're totally screwed!
        //
        if (bufferAddress == NULL) {
            KeBugCheckEx(HAL_MEMORY_ALLOCATION,
                         PAGE_SIZE,
                         0xEF02,
                         (ULONG_PTR)__FILE__,
                         __LINE__
                         );
        }

        //
        // Find the buffer offset within the page
        //
        // N.B. bufferPageOffset can only be non-zero on the first iteration
        // 
        bufferPageOffset = BYTE_OFFSET(bufferAddress);

        //
        // Copy from bufferAddress up to the next page boundary...
        //
        bytesThisCopy = PAGE_SIZE - bufferPageOffset;

        //
        // ...but no more than bytesLeft
        //
        if (bytesThisCopy > bytesLeft) {
            bytesThisCopy = bytesLeft;
        }

        //
        // Calculate the base address of this translation entry and the
        // offset into it.
        //
        mapAddress = (PCCHAR) translationEntry->VirtualAddress +
            bufferPageOffset;

        //
        // Copy up to one page
        // 
        if (WriteToDevice) {
            HalpMoveMemory( mapAddress, bufferAddress, bytesThisCopy );

        } else {
            RtlCopyMemory( bufferAddress, mapAddress, bytesThisCopy );
        }

        //
        // Update locals and process the next translation entry.
        //
        bytesLeft -= bytesThisCopy;
        translationEntry += 1;
        MmUnmapReservedMapping(HalpReservedPages, HAL_POOL_TAG, ReserveMdl);
        SrcPFrame++;
        ReserveMdl->ByteOffset = 0;
        (PCCHAR)ReserveMdl->StartVa += PAGE_SIZE;
        ReserveMdl->ByteCount = (PAGE_SIZE > bytesLeft) ? bytesLeft: PAGE_SIZE;
    }
    
    KeReleaseSpinLock(&HalpReservedPageLock, Irql);
}


VOID
HalpCopyBufferMap(
    IN PMDL Mdl,
    IN PTRANSLATION_ENTRY TranslationEntry,
    IN PVOID CurrentVa,
    IN ULONG Length,
    IN BOOLEAN WriteToDevice
    )
/*++

Routine Description:

    This routine copies the specific data between the user's buffer and the
    map register buffer.  First a the user buffer is mapped if necessary, then
    the data is copied.  Finally the user buffer will be unmapped if
    necessary.

Arguments:

    Mdl - Pointer to the MDL that describes the pages of memory that are
        being read or written.

    TranslationEntry - The address of the base map register that has been
        allocated to the device driver for use in mapping the transfer.

    CurrentVa - Current virtual address in the buffer described by the MDL
        that the transfer is being done to or from.

    Length - The length of the transfer.  This determines the number of map
        registers that need to be written to map the transfer.

    WriteToDevice - Boolean value that indicates whether this is a write
        to the device from memory (TRUE), or vice versa.

Return Value:

    None.

--*/
{
    PCCHAR bufferAddress;
    PCCHAR mapAddress;
    ULONG bytesLeft;
    ULONG bytesThisCopy;
    ULONG bufferPageOffset;
    PTRANSLATION_ENTRY translationEntry;
    NTSTATUS Status;

    //
    // Get the system address of the MDL, if we run out of PTEs try safe
    // method
    //
    bufferAddress = MmGetSystemAddressForMdlSafe(Mdl, HighPagePriority);
    
    if (bufferAddress == NULL) {
        
        //
        // Our caller's buffer is unmapped, and the memory manager is out
        // of PTEs, try to use reserve page method
        //
        if (HalpReservedPages != NULL) {
            HalpCopyBufferMapSafe(Mdl,
                                  TranslationEntry,
                                  CurrentVa,
                                  Length,
                                  WriteToDevice);
            return;
        }

        //
        // The DMA transfer cannot be completed, the system is now unstable
        //
        KeBugCheckEx(HAL_MEMORY_ALLOCATION,
                     PAGE_SIZE,
                     0xEF01,
                     (ULONG_PTR)__FILE__,
                     __LINE__
                     );
    }

    //
    // Calculate the actual start of the buffer based on the system VA and
    // the current VA.
    //

    bufferAddress += (PCCHAR) CurrentVa - (PCCHAR) MmGetMdlVirtualAddress(Mdl);

    //
    // Get local copies of Length and TranslationEntry as they will be
    // decremented/incremented respectively.
    //

    bytesLeft = Length;
    translationEntry = TranslationEntry;

    //
    // Copy the data one translation entry at a time.
    //

    while (bytesLeft > 0) {

        //
        // Find the buffer offset within the page.
        //
        // N.B. bufferPageOffset can only be non-zero on the first iteration.
        // 

        bufferPageOffset = BYTE_OFFSET(bufferAddress);

        //
        // Copy from bufferAddress up to the next page boundary...
        //

        bytesThisCopy = PAGE_SIZE - bufferPageOffset;

        //
        // ...but no more than bytesLeft.
        //

        if (bytesThisCopy > bytesLeft) {
            bytesThisCopy = bytesLeft;
        }

        //
        // Calculate the base address of this translation entry and the
        // offset into it.
        //

        mapAddress = (PCCHAR) translationEntry->VirtualAddress +
            bufferPageOffset;

        //
        // Copy up to one page.
        // 

        if (WriteToDevice) {

            HalpMoveMemory( mapAddress, bufferAddress, bytesThisCopy );

        } else {

            RtlCopyMemory( bufferAddress, mapAddress, bytesThisCopy );

        }

        //
        // Update locals and process the next translation entry.
        //

        bytesLeft -= bytesThisCopy;
        bufferAddress += bytesThisCopy;
        translationEntry += 1;
    }
}

PVOID
HalAllocateCommonBuffer(
    IN PADAPTER_OBJECT AdapterObject,
    IN ULONG Length,
    OUT PPHYSICAL_ADDRESS LogicalAddress,
    IN BOOLEAN CacheEnabled
    )
/*++

Routine Description:

    This function allocates the memory for a common buffer and maps it so that
    it can be accessed by a master device and the CPU.

Arguments:

    AdapterObject - Supplies a pointer to the adapter object used by this
                    device.

    Length - Supplies the length of the common buffer to be allocated.

    LogicalAddress - Returns the logical address of the common buffer.

    CacheEnable - Indicates whether the memeory is cached or not.

Return Value:

    Returns the virtual address of the common buffer.  If the buffer cannot be
    allocated then NULL is returned.

--*/

{
    PSINGLE_LIST_ENTRY virtualAddress;
    PHYSICAL_ADDRESS minPhysicalAddress;
    PHYSICAL_ADDRESS maxPhysicalAddress;
    PHYSICAL_ADDRESS logicalAddress;
    PHYSICAL_ADDRESS boundaryPhysicalAddress;
    ULONGLONG boundaryMask;

    UNREFERENCED_PARAMETER( CacheEnabled );

    //
    // Determine the maximum physical address that this adapter can handle.
    //

    minPhysicalAddress.QuadPart = 0;
    maxPhysicalAddress = HalpGetAdapterMaximumPhysicalAddress( AdapterObject );

    //
    // Determine the boundary mask for this adapter.
    //

    if (HalpBusType != MACHINE_TYPE_ISA ||
        AdapterObject->MasterDevice != FALSE) {

        //
        // This is not an ISA system.  The buffer must not cross a 4GB boundary.
        // It is predicted that most adapters are incapable of reliably
        // transferring across a 4GB boundary.
        //

        boundaryPhysicalAddress.QuadPart = 0x0000000100000000;
        boundaryMask = 0xFFFFFFFF00000000;

    } else {

        //
        // This is an ISA system the common buffer cannot cross a 64K boundary.
        //

        boundaryPhysicalAddress.QuadPart = 0x10000;
        boundaryMask = 0xFFFFFFFFFFFF0000;
    }

    //
    // Allocate a contiguous buffer.
    //

    virtualAddress = MmAllocateContiguousMemorySpecifyCache(
                        Length,
                        minPhysicalAddress,
                        maxPhysicalAddress,
                        boundaryPhysicalAddress,
                        MmCached );

    if (virtualAddress != NULL) {

        //
        // Got a buffer, get the physical/logical address and see if it
        // meets our conditions.
        //
    
        logicalAddress = MmGetPhysicalAddress( virtualAddress );

#if DBG
        ASSERT (((logicalAddress.QuadPart ^
             (logicalAddress.QuadPart + Length - 1)) & boundaryMask) == 0);
#endif
    
        *LogicalAddress = logicalAddress;
    }

    return virtualAddress;
}



NTSTATUS
HalpAllocateMapRegisters(
    IN PADAPTER_OBJECT DmaAdapter,
    IN ULONG NumberOfMapRegisters,
    IN ULONG BaseAddressCount,
    OUT PMAP_REGISTER_ENTRY MapRegisterArray
    )
/*++

Routine Description:

    Allocates a chunk of map registers for use with MapTransfer/Flush

    NOTE:  Caller is responsible to free map registers for each base
           address, same as when calling AllocateAdapterChannel if
           a driver's execution routine returns  DeallocateObject-
           KeepRegisters

           This routine must be called at PASSIVE level

Arguments:

    DmaAdapter - Pointer to the dma adapter for this request

    NumberOfMapRegisters - Number of map registers per allocation

    BaseAddressCount - Number of base allocations

    MapRegisterArray - Pointer to a map register array to return base
                       addresses of allocations

Return Value:

    STATUS_SUCCESS or error

--*/
{
    KIRQL Irql;
    ULONG Index;
    ULONG MapRegisterNumber;
    PADAPTER_OBJECT MasterAdapter;

    PAGED_CODE();

    MasterAdapter = DmaAdapter->MasterAdapter;
   
    //
    // This routine directly munges the master adapter bitmap, and does not
    // deal with channels, or the legacy DMA hardware
    //
    if (DmaAdapter->LegacyAdapter) {
        return STATUS_INVALID_DEVICE_REQUEST;
    }

    //
    // This adapter doesn't require map registers, or they are asking
    // for zero, set each BaseAddress to NULL
    //
    if (((BaseAddressCount * NumberOfMapRegisters) == 0) ||
        (!DmaAdapter->NeedsMapRegisters)) {

        for (Index = 0; Index < BaseAddressCount; Index++) {
            MapRegisterArray[Index].MapRegister = NULL;
        }

        return STATUS_SUCCESS;
    }

    //
    // If this request is too piggy, or if the adapter has no map
    // registers, fail this request
    //
    if (((NumberOfMapRegisters * BaseAddressCount) >
         (4 * MAXIMUM_PCI_MAP_REGISTER)) ||
        (DmaAdapter->MapRegistersPerChannel == 0)) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Each individual allocation must not exceed the number of map
    // we returned from IoGetDmaAdapter
    //
    if (NumberOfMapRegisters > DmaAdapter->MapRegistersPerChannel) {
        return STATUS_INVALID_PARAMETER;
    }

    for (Index = 0; Index < BaseAddressCount; Index++) {

        MapRegisterNumber = (ULONG)-1;

        //
        // We need to lock the master adapter before we fondle its bitmap
        //
        KeAcquireSpinLock(&MasterAdapter->SpinLock, &Irql);
    
        //
        // This routine is meant to be called during init to allocate a wad
        // of map registers in one fell swoop, it's primary consumer is
        // NDIS, and it's primary purpose is to ease up map register
        // consumption, so, if there is already an adapter waiting for map
        // registers, then there are two possibilities, (1) a work item
        // has been queued to grow more translations, or (2) there are
        // none left and they are stuck waiting for a free, if it's the
        // latter then we are going to fail too, and if it's the former,
        // then our bid to allocate up to 64 map registers, out of
        // perhaps thousands, should not dramtically decrease the waiters
        // chances to have a reasonably sized request satisfied, moreover,
        // since this function is only used during init, we will not be
        // starving out other drivers during run time in low map register
        // situation, therfore, although it is rude for us to go back door
        // and allocate registers without checking and/or satifying any
        // requests made earlier during init, our cause is a noble one,
        // so we will ignore any queued requests
        //
        //if (IsListEmpty(&MasterAdapter->AdapterQueue)) {
        MapRegisterNumber = RtlFindClearBitsAndSet(
            MasterAdapter->MapRegisters,
            NumberOfMapRegisters,
            0
            );
        //}
        KeReleaseSpinLock(&MasterAdapter->SpinLock, Irql);

        if (MapRegisterNumber == -1) {
            BOOLEAN Allocated;
            ULONG BytesToGrow;

            //
            // HalpGrowMapBuffers() takes a byte count
            //
            BytesToGrow = (NumberOfMapRegisters * PAGE_SIZE) +
                INCREMENT_MAP_BUFFER_SIZE;
            
            //
            // We must own this lock in order to call the grow function
            //
            ACQUIRE_NEW_ADAPTER_LOCK();            
            Allocated = HalpGrowMapBuffers(MasterAdapter, BytesToGrow);
            RELEASE_NEW_ADAPTER_LOCK();
            
            if (Allocated) {
                
                //
                // Lock the master adapter before changing its bitmap
                //
                KeAcquireSpinLock(&MasterAdapter->SpinLock, &Irql);
    
                //
                // Again, we will ignore any queued requests (see note
                // above)
                //
                //if (IsListEmpty(&MasterAdapter->AdapterQueue)) {
                MapRegisterNumber = RtlFindClearBitsAndSet(
                    MasterAdapter->MapRegisters,
                    NumberOfMapRegisters,
                    0
                    );
                //}                
                KeReleaseSpinLock(&MasterAdapter->SpinLock, Irql);
                
                //
                // That's wierd!  We grew the bitmap, and still failed ?
                //
                if (MapRegisterNumber == -1) {
                    break;
                }
            
            //
            // We were unable to allocate additional translation
            // buffers
            //
            } else {
                break;
            }
        }

        //
        // Save the base address for these translation buffers
        //
        MapRegisterArray[Index].MapRegister =
            ((PTRANSLATION_ENTRY)MasterAdapter->MapRegisterBase +
             MapRegisterNumber);
    }

    //
    // Cleanup and fail, we couldn't allocate them all!
    //
    if (Index != BaseAddressCount) {

        while (Index > 0) {

            IoFreeMapRegisters(MasterAdapter,
                               MapRegisterArray[Index - 1].MapRegister,
                               NumberOfMapRegisters);
            Index--;
        }

        return STATUS_INSUFFICIENT_RESOURCES;
    }
 
    return STATUS_SUCCESS;
}



BOOLEAN
HalFlushCommonBuffer(
    IN PADAPTER_OBJECT AdapterObject,
    IN ULONG Length,
    IN PHYSICAL_ADDRESS LogicalAddress,
    IN PVOID VirtualAddress
    )
/*++

Routine Description:

    This function is called to flush any hardware adapter buffers when the
    driver needs to read data written by an I/O master device to a common
    buffer.

Arguments:

    AdapterObject - Supplies a pointer to the adapter object used by this
        device.

    Length - Supplies the length of the common buffer. This should be the same
        value used for the allocation of the buffer.

    LogicalAddress - Supplies the logical address of the common buffer.  This
        must be the same value return by HalAllocateCommonBuffer.

    VirtualAddress - Supplies the virtual address of the common buffer.  This
        must be the same value return by HalAllocateCommonBuffer.

Return Value:

    Returns TRUE if no errors were detected.  Otherwise, FALSE is returned.

--*/

{
    UNREFERENCED_PARAMETER( AdapterObject );
    UNREFERENCED_PARAMETER( Length );
    UNREFERENCED_PARAMETER( LogicalAddress );
    UNREFERENCED_PARAMETER( VirtualAddress );

    return(TRUE);

}

VOID
HalFreeCommonBuffer(
    IN PADAPTER_OBJECT AdapterObject,
    IN ULONG Length,
    IN PHYSICAL_ADDRESS LogicalAddress,
    IN PVOID VirtualAddress,
    IN BOOLEAN CacheEnabled
    )
/*++

Routine Description:

    This function frees a common buffer and all of the resources it uses.

Arguments:

    AdapterObject - Supplies a pointer to the adapter object used by this
        device.

    Length - Supplies the length of the common buffer. This should be the same
        value used for the allocation of the buffer.

    LogicalAddress - Supplies the logical address of the common buffer.  This
        must be the same value returned by HalAllocateCommonBuffer.

    VirtualAddress - Supplies the virtual address of the common buffer.  This
        must be the same value returned by HalAllocateCommonBuffer.

    CacheEnable - Indicates whether the memory is cached or not.

Return Value:

    None

--*/

{
    UNREFERENCED_PARAMETER( AdapterObject );
    UNREFERENCED_PARAMETER( Length );
    UNREFERENCED_PARAMETER( LogicalAddress );
    UNREFERENCED_PARAMETER( CacheEnabled );

    MmFreeContiguousMemory (VirtualAddress);

}

NTSTATUS
HalCalculateScatterGatherListSize(
    IN PADAPTER_OBJECT AdapterObject,
    IN OPTIONAL PMDL Mdl,
    IN PVOID CurrentVa,
    IN ULONG Length,
    OUT PULONG  ScatterGatherListSize,
    OUT OPTIONAL PULONG pNumberOfMapRegisters
    )
/*++

Routine Description:

    This routine calculates the size of the scatter/gather list that
    needs to be allocated for a given virtual address range or MDL.

Arguments:

    AdapterObject - Pointer to the adapter control object to allocate to the
        driver.

    Mdl - Pointer to the MDL that describes the pages of memory that are being
        read or written.

    CurrentVa - Current virtual address in the buffer described by the MDL
        that the transfer is being done to or from.

    Length - Supplies the length of the transfer.

Return Value:

    Returns STATUS_SUCCESS unless too many map registers are requested or
    memory for the scatter/gather list could not be allocated.

Notes:

--*/
{
    PHAL_WAIT_CONTEXT_BLOCK WaitBlock;
    PMDL TempMdl;
    PSCATTER_GATHER_LIST ScatterGather;
    PSCATTER_GATHER_ELEMENT Element;
    ULONG NumberOfMapRegisters;
    ULONG ContextSize;
    ULONG TransferLength;
    ULONG MdlLength;
    PUCHAR MdlVa;
    NTSTATUS Status;
    PULONG PageFrame;
    ULONG PageOffset;

    if (ARGUMENT_PRESENT(Mdl)) {
        MdlVa = MmGetMdlVirtualAddress(Mdl);

        //
        // Calculate the number of required map registers.
        //

        TempMdl = Mdl;
        TransferLength =
            TempMdl->ByteCount - (ULONG)((PUCHAR) CurrentVa - MdlVa);
        MdlLength = TransferLength;

        PageOffset = BYTE_OFFSET(CurrentVa);
        NumberOfMapRegisters = 0;

        //
        // The virtual address should fit in the first MDL.
        //

        ASSERT((ULONG)((PUCHAR)CurrentVa - MdlVa) <= TempMdl->ByteCount);

        //
        // Loop through the any chained MDLs accumulating the the required
        // number of map registers.
        //

        while (TransferLength < Length && TempMdl->Next != NULL) {

            NumberOfMapRegisters += (PageOffset + MdlLength + PAGE_SIZE - 1) >>
                                        PAGE_SHIFT;

            TempMdl = TempMdl->Next;
            PageOffset = TempMdl->ByteOffset;
            MdlLength = TempMdl->ByteCount;
            TransferLength += MdlLength;
        }

        if ((TransferLength + PAGE_SIZE) < (Length + PageOffset )) {
            ASSERT(TransferLength >= Length);
            return(STATUS_BUFFER_TOO_SMALL);
        }

        //
        // Calculate the last number of map registers based on the requested
        // length not the length of the last MDL.
        //

        ASSERT( TransferLength <= MdlLength + Length );

        NumberOfMapRegisters += (PageOffset + Length + MdlLength - TransferLength +
                                 PAGE_SIZE - 1) >> PAGE_SHIFT;


        if (NumberOfMapRegisters > AdapterObject->MapRegistersPerChannel) {
            return(STATUS_INSUFFICIENT_RESOURCES);
        }

    } else {

        //
        // Determine the number of pages required to map the buffer described
        // by CurrentVa and Length.
        //

        NumberOfMapRegisters = ADDRESS_AND_SIZE_TO_SPAN_PAGES(CurrentVa, Length);
    }

    //
    // Calculate how much memory is required for the context structure.
    //

    ContextSize = NumberOfMapRegisters * sizeof( SCATTER_GATHER_ELEMENT ) +
                  sizeof( SCATTER_GATHER_LIST );

    //
    // If the adapter does not need map registers then most of this code
    // can be bypassed.  Just build the scatter/gather list and give it
    // to the caller.
    //

    if (AdapterObject->NeedsMapRegisters) {

        ContextSize += FIELD_OFFSET( HAL_WAIT_CONTEXT_BLOCK, ScatterGather );
        if (ContextSize < sizeof( HAL_WAIT_CONTEXT_BLOCK )) {
            ContextSize = sizeof( HAL_WAIT_CONTEXT_BLOCK );
        }
    }

    //
    // Return the list size.
    //

    *ScatterGatherListSize = ContextSize;
    if (pNumberOfMapRegisters) {
        *pNumberOfMapRegisters = NumberOfMapRegisters;
    }

    return( STATUS_SUCCESS );
}


NTSTATUS
HalGetScatterGatherList (
    IN PADAPTER_OBJECT AdapterObject,
    IN PDEVICE_OBJECT DeviceObject,
    IN PMDL Mdl,
    IN PVOID CurrentVa,
    IN ULONG Length,
    IN PDRIVER_LIST_CONTROL ExecutionRoutine,
    IN PVOID Context,
    IN BOOLEAN WriteToDevice
    )
{
    return (HalBuildScatterGatherList(AdapterObject,
                              DeviceObject,
                              Mdl,
                              CurrentVa,
                              Length,
                              ExecutionRoutine,
                              Context,
                              WriteToDevice,
                              NULL,
                              0
                              ));
}

NTSTATUS
HalBuildScatterGatherList (
    IN PADAPTER_OBJECT AdapterObject,
    IN PDEVICE_OBJECT DeviceObject,
    IN PMDL Mdl,
    IN PVOID CurrentVa,
    IN ULONG Length,
    IN PDRIVER_LIST_CONTROL ExecutionRoutine,
    IN PVOID Context,
    IN BOOLEAN WriteToDevice,
    IN PVOID ScatterGatherBuffer,
    IN ULONG ScatterGatherBufferLength
    )
/*++

Routine Description:

    This routine allocates the adapter channel specified by the adapter
    object.  Next a scatter/gather list is built based on the MDL, the
    CurrentVa and the requested Length.  Finally the driver's execution
    function is called with the scatter/gather list.  The adapter is
    released when after the execution function returns.

    The scatter/gather list is allocated if a buffer is not passed and is 
    freed by calling PutScatterGatherList.

Arguments:

    AdapterObject - Pointer to the adapter control object to allocate to the
        driver.

    DeviceObject - Pointer to the device object that is allocating the
        adapter.

    Mdl - Pointer to the MDL that describes the pages of memory that are being
        read or written.

    CurrentVa - Current virtual address in the buffer described by the MDL
        that the transfer is being done to or from.

    Length - Supplies the length of the transfer.

    ExecutionRoutine - The address of the driver's execution routine that is
        invoked once the adapter channel (and possibly map registers) have been
        allocated.

    Context - An untyped longword context parameter passed to the driver's
        execution routine.

    WriteToDevice - Supplies the value that indicates whether this is a
        write to the device from memory (TRUE), or vice versa.

Return Value:

    Returns STATUS_SUCCESS unless too many map registers are requested or
    memory for the scatter/gather list could not be allocated.

Notes:

    Note that this routine MUST be invoked at DISPATCH_LEVEL or above.

    The data in the buffer cannot be accessed until the put scatter/gather function has been called.

--*/

{
    PHAL_WAIT_CONTEXT_BLOCK WaitBlock;
    PMDL TempMdl;
    PSCATTER_GATHER_LIST ScatterGather;
    PSCATTER_GATHER_ELEMENT Element;
    ULONG NumberOfMapRegisters;
    ULONG ContextSize;
    ULONG TransferLength;
    ULONG MdlLength;
    PUCHAR MdlVa;
    NTSTATUS Status;
    PPFN_NUMBER PageFrame;
    ULONG PageOffset;

    if (!Mdl) {
        return (STATUS_INVALID_PARAMETER);
    }

    //
    // If the adapter does not need map registers then most of this code
    // can be bypassed.  Just build the scatter/gather list and give it
    // to the caller.
    //

    INCREMENT_SCATTER_GATHER_COUNT();

    if (!AdapterObject->NeedsMapRegisters) {

        if (ScatterGatherBuffer) {

            //
            // Ensure that we at least have enough buffer length for the 
            // header.
            //

			if (ScatterGatherBufferLength < sizeof(SCATTER_GATHER_LIST)) {
                DECREMENT_SCATTER_GATHER_COUNT();
                return (STATUS_BUFFER_TOO_SMALL);
            }

            ScatterGather = ScatterGatherBuffer;

        } else {

			Status = HalCalculateScatterGatherListSize(AdapterObject,
													Mdl,
													CurrentVa,
													Length,
													&ContextSize,
													&NumberOfMapRegisters 
													);
    
			if (!NT_SUCCESS(Status)) {
                DECREMENT_SCATTER_GATHER_COUNT();
				return (Status);
			}

            ScatterGather = ExAllocatePoolWithTag( NonPagedPool,
                                                   ContextSize,
                                                   HAL_POOL_TAG );
            if (ScatterGather == NULL) {
                DECREMENT_SCATTER_GATHER_COUNT();
                return( STATUS_INSUFFICIENT_RESOURCES );
            }
        }

        MdlVa = MmGetMdlVirtualAddress(Mdl);

        ScatterGather->Reserved = 0;

        Element = ScatterGather->Elements;
        TempMdl = Mdl;
        TransferLength = Length;
        MdlLength = TempMdl->ByteCount - (ULONG)((PUCHAR) CurrentVa - MdlVa);
        PageOffset = BYTE_OFFSET(CurrentVa);

        //
        // Calculate where to start in the MDL.
        //

        PageFrame = MmGetMdlPfnArray(TempMdl);
        PageFrame += ((ULONG_PTR) CurrentVa - ((ULONG_PTR) MdlVa & ~(PAGE_SIZE - 1)))
                        >> PAGE_SHIFT;

        //
        // Loop build the list for each MDL.
        //

        while (TransferLength >  0) {


            if (MdlLength > TransferLength) {

                MdlLength = TransferLength;
            }

            TransferLength -= MdlLength;

            //
            // Loop building the list for the elements within the MDL.
            //

            while (MdlLength > 0) {

                //
                // Ensure that we never step outside the length of our buffer.
                // We need to validate the length because we don't validate the length at the beginning
                // if the buffer was allocated by the caller.
                //
                if (ScatterGatherBuffer &&  
                    ((PUCHAR)Element > 
                    ((PUCHAR)ScatterGatherBuffer + ScatterGatherBufferLength - sizeof(SCATTER_GATHER_ELEMENT)))) {
                    DECREMENT_SCATTER_GATHER_COUNT();
                    return (STATUS_BUFFER_TOO_SMALL);
                }

                //
                // Compute the starting address of the transfer.
                //

                Element->Address.QuadPart =
                    ((ULONGLONG)*PageFrame << PAGE_SHIFT) + PageOffset;

                Element->Length = PAGE_SIZE - PageOffset;

                if (Element->Length  > MdlLength ) {

                    Element->Length  = MdlLength;
                }

                ASSERT( (ULONG) MdlLength >= Element->Length );
                MdlLength -= Element->Length;

                //
                // Combine contiguous pages.
                //

                if (Element != ScatterGather->Elements ) {

                    if (Element->Address.QuadPart ==
                        (Element - 1)->Address.QuadPart + (Element - 1)->Length) {

                        //
                        // If the previous page frame is contiguous with this one,
                        // but it crosses a 4GB boundary don't coalesce 
                        //

                        if (((*PageFrame ^ (*PageFrame - 1)) & 0xFFFFFFFFFFF00000UI64) == 0) {

                            //
                            // Add the new length to the old length.
                            //

                            (Element - 1)->Length += Element->Length;

                            //
                            // Reuse the current element.
                            //

                            Element--;
                        }
                    }
                }

                PageOffset = 0;
	
				
				Element++;

                PageFrame++;
            }


            if (TempMdl->Next == NULL) {

                //
                // There are a few cases where the buffer described by the MDL
                // is less than the transfer length.  This occurs when the
                // file system is transfering the last page of the file and
                // MM defines the MDL to be the file size and the file system
                // rounds the write up to a sector.  This extra should never
                // cross a page boundary.  Add this extra to the length of
                // the last element.
                //

                ASSERT(((Element - 1)->Length & (PAGE_SIZE - 1)) + TransferLength <= PAGE_SIZE );
                (Element - 1)->Length += TransferLength;

                break;
            }

            //
            // Advance to the next MDL.  Update the current VA and the MdlLength.
            //

            TempMdl    = TempMdl->Next;
            PageOffset = MmGetMdlByteOffset(TempMdl);
            MdlLength  = TempMdl->ByteCount;
            PageFrame  = MmGetMdlPfnArray(TempMdl);

        }

        //
        // Set the number of elements actually used.
        //

        ScatterGather->NumberOfElements =
            (ULONG)(Element - ScatterGather->Elements);

        if (ScatterGatherBuffer) {
            ScatterGather->Reserved = HAL_WCB_DRIVER_BUFFER;
        }
        
        //
        // Call the driver with the scatter/gather list.
        //

        ExecutionRoutine( DeviceObject,
                          DeviceObject->CurrentIrp,
                          ScatterGather,
                          Context );
        
        return STATUS_SUCCESS;

    }

	Status = HalCalculateScatterGatherListSize(AdapterObject,
													Mdl,
													CurrentVa,
													Length,
													&ContextSize,
													&NumberOfMapRegisters 
													);

    if (!NT_SUCCESS(Status)) {
        return Status;
    }

    if (ScatterGatherBuffer) {

        if (ScatterGatherBufferLength < ContextSize) {
            DECREMENT_SCATTER_GATHER_COUNT();
            return (STATUS_BUFFER_TOO_SMALL);
        }

        WaitBlock = ScatterGatherBuffer;

    } else {

        WaitBlock = ExAllocatePoolWithTag(NonPagedPool, ContextSize, HAL_POOL_TAG);

        if (WaitBlock == NULL) {
            DECREMENT_SCATTER_GATHER_COUNT();
            return( STATUS_INSUFFICIENT_RESOURCES );
        }
    }

    //
    // Save the interesting data in the wait block.
    //

    if (ScatterGatherBuffer) {
        WaitBlock->Flags |= HAL_WCB_DRIVER_BUFFER;
    } else {
        WaitBlock->Flags = 0;
    }

    WaitBlock->Mdl = Mdl;
    WaitBlock->DmaMdl = NULL;
    WaitBlock->CurrentVa = CurrentVa;
    WaitBlock->Length = Length;
    WaitBlock->DriverExecutionRoutine = ExecutionRoutine;
    WaitBlock->DriverContext = Context;
    WaitBlock->AdapterObject = AdapterObject;
    WaitBlock->WriteToDevice = WriteToDevice;
	WaitBlock->NumberOfMapRegisters = NumberOfMapRegisters;

    WaitBlock->Wcb.DeviceContext = WaitBlock;
    WaitBlock->Wcb.DeviceObject = DeviceObject;
    WaitBlock->Wcb.CurrentIrp = DeviceObject->CurrentIrp;


    //
    // Call the HAL to allocate the adapter channel.
    // HalpAllocateAdapterCallback will fill in the scatter/gather list.
    //

	Status = HalAllocateAdapterChannel( AdapterObject,
										&WaitBlock->Wcb,
										NumberOfMapRegisters,
										HalpAllocateAdapterCallback );
	
    //
    // If HalAllocateAdapterChannel failed then free the wait block.
    //

    if (!NT_SUCCESS( Status)) {
        DECREMENT_SCATTER_GATHER_COUNT();
        ExFreePool( WaitBlock );
    }

    return( Status );
}

VOID
HalPutScatterGatherList (
    IN PADAPTER_OBJECT AdapterObject,
    IN PSCATTER_GATHER_LIST ScatterGather,
    IN BOOLEAN WriteToDevice
    )
/*++

Routine Description:

    This function frees the map registers allocated for the scatter gather list. It can also free the 
    scatter gather buffer and any associated MDLs.

Arguments:

    ScatterGather - The scatter gather buffer

    WriteToDevice - Supplies the value that indicates whether this is a
        write to the device from memory (TRUE), or vice versa.
    

Return Value:

    Returns a success or error status.

--*/
{
    PHAL_WAIT_CONTEXT_BLOCK WaitBlock = (PVOID) ScatterGather->Reserved;
    PTRANSLATION_ENTRY TranslationEntry;
    ULONG TransferLength;
    ULONG MdlLength;
    PMDL Mdl;
    PMDL tempMdl;
    PMDL nextMdl;
    PUCHAR CurrentVa;

    DECREMENT_SCATTER_GATHER_COUNT();

    //
    // If the reserved field was empty then just free the list and return.
    //

    if (WaitBlock == NULL) {

        ASSERT(!AdapterObject->NeedsMapRegisters);
        ExFreePool( ScatterGather );
        return;

    }

    if (WaitBlock == (PVOID)HAL_WCB_DRIVER_BUFFER) {
        ASSERT(!AdapterObject->NeedsMapRegisters);
        return;
    }

    ASSERT( WaitBlock == CONTAINING_RECORD( ScatterGather, HAL_WAIT_CONTEXT_BLOCK, ScatterGather ));

    //
    // Setup for the first MDL.  We expect the MDL pointer to be pointing
    // at the first used MDL.
    //

    Mdl = WaitBlock->Mdl;
    CurrentVa = WaitBlock->CurrentVa;

#if DBG
    ASSERT( CurrentVa >= (PUCHAR) MmGetMdlVirtualAddress(Mdl));

    if (MmGetMdlVirtualAddress(Mdl) < (PVOID)((PUCHAR) MmGetMdlVirtualAddress(Mdl) + Mdl->ByteCount )) {

        ASSERT( CurrentVa < (PUCHAR) MmGetMdlVirtualAddress(Mdl) + Mdl->ByteCount );
    }
#endif

    MdlLength = Mdl->ByteCount - (ULONG)(CurrentVa - (PUCHAR) MmGetMdlVirtualAddress(Mdl));
    TransferLength = WaitBlock->Length;

    TranslationEntry = WaitBlock->MapRegisterBase;

    //
    // Loop through the used MDLs, calling IoFlushAdapterBuffers.
    //

    while (TransferLength >  0) {

        //
        // Do not perform a flush for buffers of zero length.
        //

        if (MdlLength > 0) {

            if (MdlLength > TransferLength) {
    
                MdlLength = TransferLength;
            }
    
            TransferLength -= MdlLength;
    
            IoFlushAdapterBuffers(  AdapterObject,
                                    Mdl,
                                    TranslationEntry,
                                    CurrentVa,
                                    MdlLength,
                                    WriteToDevice );
    
            TranslationEntry += ADDRESS_AND_SIZE_TO_SPAN_PAGES( CurrentVa,
                                                                MdlLength );
        }

        if (Mdl->Next == NULL) {
            break;
        }

        //
        // Advance to the next MDL.  Update the current VA and the MdlLength.
        //

        Mdl = Mdl->Next;
        CurrentVa = MmGetMdlVirtualAddress(Mdl);
        MdlLength = Mdl->ByteCount;
    }

    IoFreeMapRegisters( AdapterObject,
                        WaitBlock->MapRegisterBase,
                        WaitBlock->NumberOfMapRegisters
                        );

    if (WaitBlock->DmaMdl) {
        tempMdl = WaitBlock->DmaMdl;
        while (tempMdl) {
            nextMdl = tempMdl->Next;

            //
            // If the MDL was mapped by the driver unmap it here.
            //

            if (tempMdl->MdlFlags & MDL_MAPPED_TO_SYSTEM_VA) {
                MmUnmapLockedPages(tempMdl->MappedSystemVa, tempMdl);
            }

            IoFreeMdl(tempMdl);
            tempMdl = nextMdl;
        }
    }

    if (!(WaitBlock->Flags & HAL_WCB_DRIVER_BUFFER)) {
        ExFreePool( WaitBlock );
    }
}

IO_ALLOCATION_ACTION
HalpAllocateAdapterCallback (
    IN struct _DEVICE_OBJECT *DeviceObject,
    IN struct _IRP *Irp,
    IN PVOID MapRegisterBase,
    IN PVOID Context
    )
/*++

Routine Description:

    This routine is called when the adapter object and map registers are
    available for the data transfer. This routines saves the map register
    base away.  If all of the required bases have not been saved then it
    returns. Otherwise it routine builds the entire scatter/gather
    list by calling IoMapTransfer.  After the list is built it is passed to
    the driver.

Arguments:

    DeviceObject - Pointer to the device object that is allocating the
        adapter.

    Irp - Supplies the map register offset assigned for this callback.

    MapRegisterBase - Supplies the map register base for use by the adapter
        routines.

    Context - Supplies a pointer to the xhal wait contorl block.

Return Value:

    Returns DeallocateObjectKeepRegisters.


--*/
{
    PHAL_WAIT_CONTEXT_BLOCK WaitBlock = Context;
    ULONG TransferLength;
    LONG MdlLength;
    PMDL Mdl;
    PUCHAR CurrentVa;
    PSCATTER_GATHER_LIST ScatterGather;
    PSCATTER_GATHER_ELEMENT Element;
    PTRANSLATION_ENTRY TranslationEntry = MapRegisterBase;
    PTRANSLATION_ENTRY NextEntry;
    PDRIVER_LIST_CONTROL DriverExecutionRoutine;
    PVOID DriverContext;
    PIRP CurrentIrp;
    PADAPTER_OBJECT AdapterObject;
    BOOLEAN WriteToDevice;

    //
    // Save the map register base.
    //

    WaitBlock->MapRegisterBase = MapRegisterBase;

    //
    // Save the data that will be overwritten by the scatter gather list.
    //

    DriverExecutionRoutine = WaitBlock->DriverExecutionRoutine;
    DriverContext = WaitBlock->DriverContext;
    CurrentIrp = WaitBlock->Wcb.CurrentIrp;
    AdapterObject = WaitBlock->AdapterObject;
    WriteToDevice = WaitBlock->WriteToDevice;

    //
    // Put the scatter gatther list after wait block. Add a back pointer to
    // the beginning of the wait block.
    //

    ScatterGather = &WaitBlock->ScatterGather;
    ScatterGather->Reserved = (ULONG_PTR) WaitBlock;
    Element = ScatterGather->Elements;

    //
    // Setup for the first MDL.  We expect the MDL pointer to be pointing
    // at the first used MDL.
    //

    Mdl = WaitBlock->Mdl;
    CurrentVa = WaitBlock->CurrentVa;

#if DBG
    ASSERT( CurrentVa >= (PUCHAR) MmGetMdlVirtualAddress(Mdl));

    if (MmGetMdlVirtualAddress(Mdl) < (PVOID)((PUCHAR) MmGetMdlVirtualAddress(Mdl) + Mdl->ByteCount )) {

        ASSERT( CurrentVa < (PUCHAR) MmGetMdlVirtualAddress(Mdl) + Mdl->ByteCount );
    }
#endif

    MdlLength = Mdl->ByteCount - (ULONG)(CurrentVa - (PUCHAR) MmGetMdlVirtualAddress(Mdl));

    TransferLength = WaitBlock->Length;

    //
    // Loop building the list for each MDL.
    //

    while (TransferLength >  0) {

        if ((ULONG) MdlLength > TransferLength) {

            MdlLength = TransferLength;
        }

        TransferLength -= MdlLength;

        NextEntry = TranslationEntry;
        if (MdlLength > 0) {

            NextEntry +=  ADDRESS_AND_SIZE_TO_SPAN_PAGES( CurrentVa,
                                                          MdlLength );

        }

        //
        // Loop building the list for the elments within an MDL.
        //

        while (MdlLength > 0) {

            Element->Length = MdlLength;
            Element->Address = IoMapTransfer( AdapterObject,
                                              Mdl,
                                              MapRegisterBase,
                                              CurrentVa,
                                              &Element->Length,
                                              WriteToDevice );

            ASSERT( (ULONG) MdlLength >= Element->Length );
            MdlLength -= Element->Length;
            CurrentVa += Element->Length;
            Element++;
        }

        if (Mdl->Next == NULL) {

            //
            // There are a few cases where the buffer described by the MDL
            // is less than the transfer length.  This occurs when the
            // file system transfering the last page of file and MM defines
            // the MDL to be the file size and the file system rounds the write
            // up to a sector.  This extra should never cross a page
            // boundary.  Add this extra to the length of the last element.
            //

            ASSERT(((Element - 1)->Length & (PAGE_SIZE - 1)) + TransferLength <= PAGE_SIZE );
            (Element - 1)->Length += TransferLength;

            break;
        }

        //
        // Advance to the next MDL.  Update the current VA and the MdlLength.
        //

        Mdl = Mdl->Next;
        CurrentVa = MmGetMdlVirtualAddress(Mdl);
        MdlLength = Mdl->ByteCount;
        TranslationEntry = NextEntry;

    }

    //
    // Set the number of elements actually used.
    //

    ScatterGather->NumberOfElements =
        (ULONG)(Element - ScatterGather->Elements);

    //
    // Call the driver with the scatter/gather list.
    //

    DriverExecutionRoutine( DeviceObject,
                            CurrentIrp,
                            ScatterGather,
                            DriverContext );

    return( DeallocateObjectKeepRegisters );
}


VOID
IoFreeAdapterChannel(
    IN PADAPTER_OBJECT AdapterObject
    )

/*++

Routine Description:

    This routine is invoked to deallocate the specified adapter object.
    Any map registers that were allocated are also automatically deallocated.
    No checks are made to ensure that the adapter is really allocated to
    a device object.  However, if it is not, the kernel will bugcheck.

    If another device is waiting in the queue to allocate the adapter object
    it will be pulled from the queue and its execution routine will be
    invoked.

Arguments:

    AdapterObject - Pointer to the adapter object to be deallocated.

Return Value:

    None.

--*/

{
    PKDEVICE_QUEUE_ENTRY Packet;
    PWAIT_CONTEXT_BLOCK Wcb;
    PADAPTER_OBJECT MasterAdapter;
    BOOLEAN Busy = FALSE;
    IO_ALLOCATION_ACTION Action;
    KIRQL Irql;
    LONG MapRegisterNumber;

    //
    // Begin by getting the address of the master adapter.
    //

    MasterAdapter = AdapterObject->MasterAdapter;

    //
    // Pull requests of the adapter's device wait queue as long as the
    // adapter is free and there are sufficient map registers available.
    //

    while( TRUE ) {

       //
       // Begin by checking to see whether there are any map registers that
       // need to be deallocated.  If so, then deallocate them now.
       //

       if (AdapterObject->NumberOfMapRegisters != 0) {
           IoFreeMapRegisters( AdapterObject,
                               AdapterObject->MapRegisterBase,
                               AdapterObject->NumberOfMapRegisters
                               );
       }

       //
       // Simply remove the next entry from the adapter's device wait queue.
       // If one was successfully removed, allocate any map registers that it
       // requires and invoke its execution routine.
       //

       Packet = KeRemoveDeviceQueue( &AdapterObject->ChannelWaitQueue );
       if (Packet == NULL) {

           //
           // There are no more requests - break out of the loop.
           //

           break;
       }

       Wcb = CONTAINING_RECORD( Packet,
            WAIT_CONTEXT_BLOCK,
            WaitQueueEntry );

       AdapterObject->CurrentWcb = Wcb;
       AdapterObject->NumberOfMapRegisters = Wcb->NumberOfMapRegisters;

        //
        // Check to see whether this driver wishes to allocate any map
        // registers.  If so, then queue the device object to the master
        // adapter queue to wait for them to become available.  If the driver
        // wants map registers, ensure that this adapter has enough total
        // map registers to satisfy the request.
        //

        if (Wcb->NumberOfMapRegisters != 0 &&
            AdapterObject->MasterAdapter != NULL) {

            //
            // Lock the map register bit map and the adapter queue in the
            // master adapter object. The channel structure offset is used as
            // a hint for the register search.
            //

            KeAcquireSpinLock( &MasterAdapter->SpinLock, &Irql );

            MapRegisterNumber = -1;

            if (IsListEmpty( &MasterAdapter->AdapterQueue)) {
               MapRegisterNumber = RtlFindClearBitsAndSet( MasterAdapter->MapRegisters,
                                                        Wcb->NumberOfMapRegisters,
                                                        0
                                                        );
            }
            if (MapRegisterNumber == -1) {

                //PBUFFER_GROW_WORK_ITEM bufferWorkItem;

               //
               // There were not enough free map registers.  Queue this request
               // on the master adapter where it will wait until some registers
               // are deallocated.
               //

               InsertTailList( &MasterAdapter->AdapterQueue,
                               &AdapterObject->AdapterQueue
                               );
               Busy = 1;

                //
                // Queue a work item to grow the map registers
                //
#if 0
                bufferWorkItem =
                    ExAllocatePoolWithTag( NonPagedPool,
                                           sizeof(BUFFER_GROW_WORK_ITEM),
                                           HAL_POOL_TAG);
                
                if (bufferWorkItem != NULL) {

                    ExInitializeWorkItem( &bufferWorkItem->WorkItem,
                                          HalpGrowMapBufferWorker,
                                          bufferWorkItem );

                    bufferWorkItem->AdapterObject = AdapterObject;
                    bufferWorkItem->MapRegisterCount =
                        Wcb->NumberOfMapRegisters;

                    ExQueueWorkItem( &bufferWorkItem->WorkItem,
                                     DelayedWorkQueue );
                }
#endif

            } else {

                AdapterObject->MapRegisterBase = ((PTRANSLATION_ENTRY)
                    MasterAdapter->MapRegisterBase + MapRegisterNumber);

                //
                // Set the no scatter/gather flag if scatter/gather is not
                // supported.
                //

                if (!AdapterObject->ScatterGather) {

                    AdapterObject->MapRegisterBase = (PVOID)
                        ((ULONG_PTR) AdapterObject->MapRegisterBase | NO_SCATTER_GATHER);

                }
            }

            KeReleaseSpinLock( &MasterAdapter->SpinLock, Irql );

        } else {

            AdapterObject->MapRegisterBase = NULL;
            AdapterObject->NumberOfMapRegisters = 0;

        }

        //
        // If there were either enough map registers available or no map
        // registers needed to be allocated, invoke the driver's execution
        // routine now.
        //

        if (!Busy) {
            AdapterObject->CurrentWcb = Wcb;
            Action = Wcb->DeviceRoutine( Wcb->DeviceObject,
                Wcb->CurrentIrp,
                AdapterObject->MapRegisterBase,
                Wcb->DeviceContext );

            //
            // If the execution routine would like to have the adapter
            // deallocated, then release the adapter object.
            //

            if (Action == KeepObject) {

               //
               // This request wants to keep the channel a while so break
               // out of the loop.
               //

               break;

            }

            //
            // If the driver wants to keep the map registers then set the
            // number allocated to 0.  This keeps the deallocation routine
            // from deallocating them.
            //

            if (Action == DeallocateObjectKeepRegisters) {
                AdapterObject->NumberOfMapRegisters = 0;
            }

        } else {

           //
           // This request did not get the requested number of map registers so
           // break out of the loop.
           //

           break;
        }
    }
}

VOID
IoFreeMapRegisters(
   PADAPTER_OBJECT AdapterObject,
   PVOID MapRegisterBase,
   ULONG NumberOfMapRegisters
   )
/*++

Routine Description:

   If NumberOfMapRegisters != 0, this routine deallocates the map registers
   for the adapter.

   If there are any queued adapters waiting then an attempt is made to allocate
   the next entry.

Arguments:

   AdapterObject - The adapter object where the map registers should be
        returned to.

   MapRegisterBase - The map register base of the registers to be deallocated.

   NumberOfMapRegisters - The number of registers to be deallocated.

Return Value:

   None

--+*/
{
   PADAPTER_OBJECT MasterAdapter;
   LONG MapRegisterNumber;
   PWAIT_CONTEXT_BLOCK Wcb;
   PLIST_ENTRY Packet;
   IO_ALLOCATION_ACTION Action;
   KIRQL Irql;


    //
    // Begin by getting the address of the master adapter.
    //

    if (AdapterObject->MasterAdapter != NULL && MapRegisterBase != NULL) {

        MasterAdapter = AdapterObject->MasterAdapter;

    } else {

        //
        // There are no map registers to return.
        //

        return;
    }

    if (NumberOfMapRegisters != 0) {

        //
        // Strip the no scatter/gather flag.
        //
        
        MapRegisterBase = (PVOID) ((ULONG_PTR) MapRegisterBase & ~NO_SCATTER_GATHER);
        
        MapRegisterNumber = (ULONG)((PTRANSLATION_ENTRY) MapRegisterBase -
             (PTRANSLATION_ENTRY) MasterAdapter->MapRegisterBase);
        
        //
        // Acquire the master adapter spinlock which locks the adapter queue and the
        // bit map for the map registers.
        //
        
        KeAcquireSpinLock(&MasterAdapter->SpinLock,&Irql);
        
        //
        // Return the registers to the bit map.
        //
        
        RtlClearBits( MasterAdapter->MapRegisters,
                      MapRegisterNumber,
                      NumberOfMapRegisters
                      );

    } else {

        KeAcquireSpinLock(&MasterAdapter->SpinLock,&Irql);
    }
   

   //
   // Process any requests waiting for map registers in the adapter queue.
   // Requests are processed until a request cannot be satisfied or until
   // there are no more requests in the queue.
   //

   while(TRUE) {

      if ( IsListEmpty(&MasterAdapter->AdapterQueue) ){
         break;
      }

      Packet = RemoveHeadList( &MasterAdapter->AdapterQueue );
      AdapterObject = CONTAINING_RECORD( Packet,
                                         ADAPTER_OBJECT,
                                         AdapterQueue
                                         );
      Wcb = AdapterObject->CurrentWcb;

      //
      // Attempt to allocate map registers for this request. Use the previous
      // register base as a hint.
      //

      MapRegisterNumber = RtlFindClearBitsAndSet( MasterAdapter->MapRegisters,
                                               AdapterObject->NumberOfMapRegisters,
                                               MasterAdapter->NumberOfMapRegisters
                                               );

      if (MapRegisterNumber == -1) {

         //
         // There were not enough free map registers.  Put this request back on
         // the adapter queue where is came from.
         //

         InsertHeadList( &MasterAdapter->AdapterQueue,
                         &AdapterObject->AdapterQueue
                         );

         break;

      }

     KeReleaseSpinLock( &MasterAdapter->SpinLock, Irql );

     AdapterObject->MapRegisterBase = (PVOID) ((PTRANSLATION_ENTRY)
        MasterAdapter->MapRegisterBase + MapRegisterNumber);

     //
     // Set the no scatter/gather flag if scatter/gather not
     // supported.
     //

     if (!AdapterObject->ScatterGather) {

        AdapterObject->MapRegisterBase = (PVOID)
            ((ULONG_PTR) AdapterObject->MapRegisterBase | NO_SCATTER_GATHER);

     }

     //
     // Invoke the driver's execution routine now.
     //

      Action = Wcb->DeviceRoutine( Wcb->DeviceObject,
        Wcb->CurrentIrp,
        AdapterObject->MapRegisterBase,
        Wcb->DeviceContext );

      //
      // If the driver wishes to keep the map registers then set the number
      // allocated to zero and set the action to deallocate object.
      //

      if (Action == DeallocateObjectKeepRegisters) {
          AdapterObject->NumberOfMapRegisters = 0;
          Action = DeallocateObject;
      }

      //
      // If the driver would like to have the adapter deallocated,
      // then deallocate any map registers allocated and then release
      // the adapter object.
      //

      if (Action == DeallocateObject) {

             //
             // The map registers registers are deallocated here rather than in
             // IoFreeAdapterChannel.  This limits the number of times
             // this routine can be called recursively possibly overflowing
             // the stack.  The worst case occurs if there is a pending
             // request for the adapter that uses map registers and whos
             // excution routine decallocates the adapter.  In that case if there
             // are no requests in the master adapter queue, then IoFreeMapRegisters
             // will get called again.
             //

          if (AdapterObject->NumberOfMapRegisters != 0) {

             //
             // Deallocate the map registers and clear the count so that
             // IoFreeAdapterChannel will not deallocate them again.
             //

             KeAcquireSpinLock( &MasterAdapter->SpinLock, &Irql );

             RtlClearBits( MasterAdapter->MapRegisters,
                           MapRegisterNumber,
                           AdapterObject->NumberOfMapRegisters
                           );

             AdapterObject->NumberOfMapRegisters = 0;

             KeReleaseSpinLock( &MasterAdapter->SpinLock, Irql );
          }

          IoFreeAdapterChannel( AdapterObject );
      }

      KeAcquireSpinLock( &MasterAdapter->SpinLock, &Irql );

   }

   KeReleaseSpinLock( &MasterAdapter->SpinLock, Irql );
}

VOID
HalPutDmaAdapter(
    IN PADAPTER_OBJECT AdapterObject
    )
/*++

Routine Description:

    This routine frees the DMA adapter if it is not one of the common
    DMA channel adapters.

Arguments:

    AdapterObject - Supplies a pointer to the DMA adapter to be freed.

Return Value:

    None.


--*/
{
    KIRQL Irql;

    //
    // This adapter can be freed if the channel number is zero and
    // it is not the channel zero adapter.
    //

    if ( AdapterObject->ChannelNumber == 0xFF ) {
        
        //
        // Remove this adapter from our list
        //
        KeAcquireSpinLock(&HalpDmaAdapterListLock,&Irql);
        RemoveEntryList(&AdapterObject->AdapterList);
        KeReleaseSpinLock(&HalpDmaAdapterListLock, Irql);

        ObDereferenceObject( AdapterObject );
    }

#ifdef ACPI_HAL
    //
    // Deal with Slave Objects that are F-Type, if we have F-DMA support
    //
    if (HalpFDMAInterface.IsaReleaseFTypeChannel &&
        (AdapterObject->ChannelNumber >= 0) &&
        (AdapterObject->ChannelNumber < EISA_DMA_CHANNELS)) {

        HalpFDMAInterface.IsaReleaseFTypeChannel(NULL,AdapterObject->ChannelNumber);
    }


#endif
}

struct _DMA_ADAPTER *
HaliGetDmaAdapter(
    IN PVOID Context,
    IN struct _DEVICE_DESCRIPTION *DeviceDescriptor,
    OUT PULONG NumberOfMapRegisters
    )
/*++

Routine Description:

    This function is a wrapper for HalGetAdapter.  Is is called through
    the HAL dispatch table.

Arguments:

    Context - Unused.

    DeviceDescriptor - Supplies the device descriptor used to allocate the dma
        adapter object.

    NubmerOfMapRegisters - Returns the maximum number of map registers a device
        can allocate at one time.

Return Value:

    Returns a DMA adapter or NULL.

--*/
{
    return (PDMA_ADAPTER) HalGetAdapter( DeviceDescriptor, NumberOfMapRegisters );
}

NTSTATUS
HalBuildMdlFromScatterGatherList(
    IN PADAPTER_OBJECT AdapterObject,
    IN PSCATTER_GATHER_LIST ScatterGather,
    IN PMDL OriginalMdl,
    OUT PMDL *TargetMdl
    )
/*++

Routine Description:

    This function builds an MDL from the scatter gather list. This is so if a driver wants to 
    construct a virtual address for the DMA buffer and write to it. The target MDL is freed when the 
    caller calls HalPutScatterGatherList.

Arguments:

    ScatterGather - The scatter gather buffer from which to build the MDL.

    OriginalMdl  - The MDL used to build the scatter gather list (using HalGet or HalBuild API)
    
    TargetMdl - Returns the new MDL in this.
    

Return Value:

    Returns a success or error status.

--*/
{
    PMDL    tempMdl;
    PMDL    newMdl;
    PMDL    targetMdl;
    PMDL    prevMdl;
    PMDL    nextMdl;
    CSHORT  mdlFlags;
    PHAL_WAIT_CONTEXT_BLOCK WaitBlock = (PVOID) ScatterGather->Reserved;
    ULONG    i,j;
    PSCATTER_GATHER_ELEMENT element;
    PPFN_NUMBER pfnArray;
    ULONG   pageFrame;
    ULONG   nPages;

    if (!OriginalMdl) {
        return  STATUS_INVALID_PARAMETER;
    }

    if (!AdapterObject->NeedsMapRegisters) {
        *TargetMdl = OriginalMdl;
        return STATUS_SUCCESS;
    }

    //
    // If this API is called more than once 
    if (WaitBlock && WaitBlock->DmaMdl) {
        return (STATUS_NONE_MAPPED);
    }

    //
    // Allocate a chain of target MDLs
    //

    prevMdl = NULL;
    targetMdl = NULL;

    for (tempMdl = OriginalMdl; tempMdl; tempMdl = tempMdl->Next) {
        PVOID va;
        ULONG byteCount;

        if(tempMdl == OriginalMdl) {
            va = WaitBlock->CurrentVa;

            //
            // This may be a little more than necessary.
            //

            byteCount = MmGetMdlByteCount(tempMdl);
        } else {
            va = MmGetMdlVirtualAddress(tempMdl);
            byteCount = MmGetMdlByteCount(tempMdl);
        }

        newMdl = IoAllocateMdl(va, byteCount, FALSE, FALSE, NULL);
        if (!newMdl) {

            //
            // Clean up previous allocated MDLs
            //

            tempMdl = targetMdl;
            while (tempMdl) {
                nextMdl = tempMdl->Next;
                IoFreeMdl(tempMdl);
                tempMdl = nextMdl;
            }

            return (STATUS_INSUFFICIENT_RESOURCES);
        }
        if (!prevMdl) {
            prevMdl = newMdl;
            targetMdl = newMdl;
        } else {
            prevMdl->Next = newMdl;
            prevMdl = newMdl;
        }
    }


    tempMdl = OriginalMdl;

    element = ScatterGather->Elements;
    for (tempMdl = targetMdl; tempMdl; tempMdl = tempMdl->Next) {

        targetMdl->MdlFlags |= MDL_PAGES_LOCKED;
        pfnArray = MmGetMdlPfnArray(tempMdl);

        for (i = 0; i < ScatterGather->NumberOfElements; i++, element++) {
            nPages = BYTES_TO_PAGES(BYTE_OFFSET(element->Address.QuadPart) + element->Length);

            pageFrame = (ULONG)(element->Address.QuadPart >> PAGE_SHIFT);
            for (j = 0; j < nPages; j++) {
                *pfnArray = pageFrame + j;
                pfnArray++;
                ASSERT((PVOID)pfnArray <= (PVOID)((PCHAR)tempMdl + tempMdl->Size));
            }
        }
    }

    *TargetMdl = targetMdl;
    if (WaitBlock) {
        WaitBlock->DmaMdl = targetMdl;
    }
    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halx86\i386\ixirql.asm ===
title  "Irql Processing"
;++
;
; Copyright (c) 1989  Microsoft Corporation
;
; Module Name:
;
;    ixirql.asm
;
; Abstract:
;
;    This module implements the code necessary to raise and lower i386
;    Irql and dispatch software interrupts with the 8259 PIC.
;
; Author:
;
;    Shie-Lin Tzong (shielint) 8-Jan-1990
;
; Environment:
;
;    Kernel mode only.
;
; Revision History:
;
;    John Vert (jvert) 27-Nov-1991
;       Moved from kernel into HAL
;
;--

.386p
        .xlist
include hal386.inc
include callconv.inc                    ; calling convention macros
include i386\ix8259.inc
include i386\kimacro.inc
include mac386.inc
        .list


        EXTRNP  _KeBugCheck,1,IMPORT
        EXTRNP  _KiDispatchInterrupt,0,IMPORT

        extrn   _HalpApcInterrupt:near
        extrn   _HalpDispatchInterrupt:near
        extrn   _KiUnexpectedInterrupt:near
        extrn   _HalpBusType:DWORD
        extrn   _HalpApcInterrupt2ndEntry:NEAR
        extrn   _HalpDispatchInterrupt2ndEntry:NEAR
        extrn   HalpSpecialDismissLevelTable:dword
        extrn   HalpSpecialDismissTable:dword
        extrn   _HalpEisaELCR:dword

;
; Initialization control words equates for the PICs
;

ICW1_ICW4_NEEDED                equ     01H
ICW1_CASCADE                    equ     00H
ICW1_INTERVAL8                  equ     00H
ICW1_LEVEL_TRIG                 equ     08H
ICW1_EDGE_TRIG                  equ     00H
ICW1_ICW                        equ     10H

ICW4_8086_MODE                  equ     001H
ICW4_NORM_EOI                   equ     000H
ICW4_NON_BUF_MODE               equ     000H
ICW4_SPEC_FULLY_NESTED          equ     010H
ICW4_NOT_SPEC_FULLY_NESTED      equ     000H

OCW2_NON_SPECIFIC_EOI           equ     020H
OCW2_SPECIFIC_EOI               equ     060H
OCW2_SET_PRIORITY               equ     0c0H

PIC_SLAVE_IRQ                   equ     2
PIC1_BASE                       equ     30H
PIC2_BASE                       equ     38H

;
; Interrupt flag bit maks for EFLAGS
;

EFLAGS_IF                       equ     200H
EFLAGS_SHIFT                    equ     9

;
; Hardware irq active masks
;

IRQ_ACTIVE_MASK                 equ     0fffffff0h

_TEXT   SEGMENT DWORD PUBLIC 'DATA'

;
; PICsInitializationString - Master PIC initialization command string
;

ifdef MCA

PICsInitializationString        dw      PIC1_PORT0

;
; Master PIC initialization command
;

                           db      ICW1_ICW + ICW1_LEVEL_TRIG + ICW1_INTERVAL8 +\
                                   ICW1_CASCADE + ICW1_ICW4_NEEDED
                           db      PIC1_BASE
                           db      1 SHL PIC_SLAVE_IRQ
                           db      ICW4_NOT_SPEC_FULLY_NESTED + \
                                   ICW4_NON_BUF_MODE + \
                                   ICW4_NORM_EOI + \
                                   ICW4_8086_MODE
;
; Slave PIC initialization command strings
;

                           dw      PIC2_PORT0
                           db      ICW1_ICW + ICW1_LEVEL_TRIG + ICW1_INTERVAL8 +\
                                   ICW1_CASCADE + ICW1_ICW4_NEEDED
                           db      PIC2_BASE
                           db      PIC_SLAVE_IRQ
                           db      ICW4_NOT_SPEC_FULLY_NESTED + \
                                   ICW4_NON_BUF_MODE + \
                                   ICW4_NORM_EOI + \
                                   ICW4_8086_MODE
                           dw      0               ; end of string

else

PICsInitializationString   dw      PIC1_PORT0

;
; Master PIC initialization command
;

                           db      ICW1_ICW + ICW1_EDGE_TRIG + ICW1_INTERVAL8 +\
                                   ICW1_CASCADE + ICW1_ICW4_NEEDED
                           db      PIC1_BASE
                           db      1 SHL PIC_SLAVE_IRQ
                           db      ICW4_NOT_SPEC_FULLY_NESTED + \
                                   ICW4_NON_BUF_MODE + \
                                   ICW4_NORM_EOI + \
                                   ICW4_8086_MODE
;
; Slave PIC initialization command strings
;

                           dw      PIC2_PORT0
                           db      ICW1_ICW + ICW1_EDGE_TRIG + ICW1_INTERVAL8 +\
                                   ICW1_CASCADE + ICW1_ICW4_NEEDED
                           db      PIC2_BASE
                           db      PIC_SLAVE_IRQ
                           db      ICW4_NOT_SPEC_FULLY_NESTED + \
                                   ICW4_NON_BUF_MODE + \
                                   ICW4_NORM_EOI + \
                                   ICW4_8086_MODE
                           dw      0               ; end of string
endif

            align   4
            public  KiI8259MaskTable
KiI8259MaskTable    label   dword
                dd      00000000000000000000000000000000B ; irql 0
                dd      00000000000000000000000000000000B ; irql 1
                dd      00000000000000000000000000000000B ; irql 2
                dd      00000000000000000000000000000000B ; irql 3
                dd      11111111100000000000000000000000B ; irql 4
                dd      11111111110000000000000000000000B ; irql 5
                dd      11111111111000000000000000000000B ; irql 6
                dd      11111111111100000000000000000000B ; irql 7
                dd      11111111111110000000000000000000B ; irql 8
                dd      11111111111111000000000000000000B ; irql 9
                dd      11111111111111100000000000000000B ; irql 10
                dd      11111111111111110000000000000000B ; irql 11
                dd      11111111111111111000000000000000B ; irql 12
                dd      11111111111111111100000000000000B ; irql 13
                dd      11111111111111111110000000000000B ; irql 14
                dd      11111111111111111111000000000000B ; irql 15
                dd      11111111111111111111100000000000B ; irql 16
                dd      11111111111111111111110000000000B ; irql 17
                dd      11111111111111111111111000000000B ; irql 18
                dd      11111111111111111111111000000000B ; irql 19
                dd      11111111111111111111111010000000B ; irql 20
                dd      11111111111111111111111011000000B ; irql 21
                dd      11111111111111111111111011100000B ; irql 22
                dd      11111111111111111111111011110000B ; irql 23
                dd      11111111111111111111111011111000B ; irql 24
                dd      11111111111111111111111011111000B ; irql 25
                dd      11111111111111111111111011111010B ; irql 26
                dd      11111111111111111111111111111010B ; irql 27
                dd      11111111111111111111111111111011B ; irql 28
                dd      11111111111111111111111111111011B ; irql 29
                dd      11111111111111111111111111111011B ; irql 30
                dd      11111111111111111111111111111011B ; irql 31

;
; This table is used to mask all pending interrupts below a given Irql
; out of the IRR
;
        align 4

        public FindHigherIrqlMask
FindHigherIrqlMask label dword
                dd    11111111111111111111111111111110B ; irql 0
                dd    11111111111111111111111111111100B ; irql 1 (APC)
                dd    11111111111111111111111111111000B ; irql 2 (DISPATCH)
                dd    11111111111111111111111111110000B ; irql 3
                dd    00000111111111111111111111110000B ; irql 4
                dd    00000011111111111111111111110000B ; irql 5
                dd    00000001111111111111111111110000B ; irql 6
                dd    00000000111111111111111111110000B ; irql 7
                dd    00000000011111111111111111110000B ; irql 8
                dd    00000000001111111111111111110000B ; irql 9
                dd    00000000000111111111111111110000B ; irql 10
                dd    00000000000011111111111111110000B ; irql 11
                dd    00000000000001111111111111110000B ; irql 12
                dd    00000000000000111111111111110000B ; irql 13
                dd    00000000000000011111111111110000B ; irql 14
                dd    00000000000000001111111111110000B ; irql 15
                dd    00000000000000000111111111110000B ; irql 16
                dd    00000000000000000011111111110000B ; irql 17
                dd    00000000000000000001111111110000B ; irql 18
                dd    00000000000000000001111111110000B ; irql 19
                dd    00000000000000000001011111110000B ; irql 20
                dd    00000000000000000001001111110000B ; irql 20
                dd    00000000000000000001000111110000B ; irql 22
                dd    00000000000000000001000011110000B ; irql 23
                dd    00000000000000000001000001110000B ; irql 24
                dd    00000000000000000001000000110000B ; irql 25
                dd    00000000000000000001000000010000B ; irql 26
                dd    00000000000000000000000000010000B ; irql 27
                dd    00000000000000000000000000000000B ; irql 28
                dd    00000000000000000000000000000000B ; irql 29
                dd    00000000000000000000000000000000B ; irql 30
                dd    00000000000000000000000000000000B ; irql 31

_TEXT   ENDS

_DATA   SEGMENT DWORD PUBLIC 'DATA'
        align   4
;
; The following tables define the addresses of software interrupt routers
;

;
; Use this table if there is NO machine state frame on stack already
;

        public  SWInterruptHandlerTable
SWInterruptHandlerTable label dword
        dd      offset FLAT:_KiUnexpectedInterrupt      ; irql 0
        dd      offset FLAT:_HalpApcInterrupt           ; irql 1
        dd      offset FLAT:_HalpDispatchInterrupt2     ; irql 2
        dd      offset FLAT:_KiUnexpectedInterrupt      ; irql 3
        dd      offset FLAT:HalpHardwareInterrupt00     ; 8259 irq#0
        dd      offset FLAT:HalpHardwareInterrupt01     ; 8259 irq#1
        dd      offset FLAT:HalpHardwareInterrupt02     ; 8259 irq#2
        dd      offset FLAT:HalpHardwareInterrupt03     ; 8259 irq#3
        dd      offset FLAT:HalpHardwareInterrupt04     ; 8259 irq#4
        dd      offset FLAT:HalpHardwareInterrupt05     ; 8259 irq#5
        dd      offset FLAT:HalpHardwareInterrupt06     ; 8259 irq#6
        dd      offset FLAT:HalpHardwareInterrupt07     ; 8259 irq#7
        dd      offset FLAT:HalpHardwareInterrupt08     ; 8259 irq#8
        dd      offset FLAT:HalpHardwareInterrupt09     ; 8259 irq#9
        dd      offset FLAT:HalpHardwareInterrupt10     ; 8259 irq#10
        dd      offset FLAT:HalpHardwareInterrupt11     ; 8259 irq#11
        dd      offset FLAT:HalpHardwareInterrupt12     ; 8259 irq#12
        dd      offset FLAT:HalpHardwareInterrupt13     ; 8259 irq#13
        dd      offset FLAT:HalpHardwareInterrupt14     ; 8259 irq#14
        dd      offset FLAT:HalpHardwareInterrupt15     ; 8259 irq#15

_DATA   ENDS

_TEXT   SEGMENT DWORD PUBLIC 'DATA'

;
; Use this table if there is already a machine state frame on stack
;

        public  SWInterruptHandlerTable2
SWInterruptHandlerTable2 label dword
        dd      offset FLAT:_KiUnexpectedInterrupt      ; irql 0
        dd      offset FLAT:_HalpApcInterrupt2ndEntry   ; irql 1
        dd      offset FLAT:_HalpDispatchInterrupt2ndEntry ; irql 2

;
; The following table picks up the highest pending software irq level
; from software irr
;

        public  SWInterruptLookUpTable
SWInterruptLookUpTable label byte
        db      0               ; SWIRR=0, so highest pending SW irql= 0
        db      0               ; SWIRR=1, so highest pending SW irql= 0
        db      1               ; SWIRR=2, so highest pending SW irql= 1
        db      1               ; SWIRR=3, so highest pending SW irql= 1
        db      2               ; SWIRR=4, so highest pending SW irql= 2
        db      2               ; SWIRR=5, so highest pending SW irql= 2
        db      2               ; SWIRR=6, so highest pending SW irql= 2
        db      2               ; SWIRR=7, so highest pending SW irql= 2

_TEXT   ENDS

_DATA   SEGMENT DWORD PUBLIC 'DATA'

ifdef IRQL_METRICS

        public HalRaiseIrqlCount
        public HalLowerIrqlCount
        public HalQuickLowerIrqlCount
        public HalApcSoftwareIntCount
        public HalDpcSoftwareIntCount
        public HalHardwareIntCount
        public HalPostponedIntCount
        public Hal8259MaskCount

HalRaiseIrqlCount       dd      0
HalLowerIrqlCount       dd      0
HalQuickLowerIrqlCount  dd      0
HalApcSoftwareIntCount  dd      0
HalDpcSoftwareIntCount  dd      0
HalHardwareIntCount     dd      0
HalPostponedIntCount    dd      0
Hal8259MaskCount        dd      0

endif
_DATA   ENDS

        page ,132
        subttl  "Raise Irql"

_TEXT$01   SEGMENT PARA PUBLIC 'CODE'
        ASSUME  DS:FLAT, ES:FLAT, SS:FLAT, FS:NOTHING, GS:NOTHING
;++
;
; KIRQL
; KfRaiseIrql (
;    IN KIRQL NewIrql,
;    )
;
; Routine Description:
;
;    This routine is used to raise IRQL to the specified value.
;    Also, a mask will be used to mask off all the lower lever 8259
;    interrupts.
;
; Arguments:
;
;    (cl) = NewIrql - the new irql to be raised to
;
; Return Value:
;
;    OldIrql - the addr of a variable which old irql should be stored
;
;--

cPublicFastCall KfRaiseIrql,1
cPublicFpo 0, 0

        movzx   ecx, cl
        mov     eax, PCR[PcIrql]         ; (al) = Old Irql
        mov     PCR[PcIrql], ecx         ; set new irql

ifdef IRQL_METRICS
        inc     HalRaiseIrqlCount
endif

if DBG
        cmp     eax, ecx                 ; old > new?
        ja      short Kri99              ; yes, go bugcheck

        fstRET  KfRaiseIrql

cPublicFpo 2, 2
Kri99:
        push    ecx                      ; put new irql where we can find it
        push    eax                      ; put old irql where we can find it
        mov     dword ptr PCR[PcIrql],0  ; avoid recursive error
        stdCall   _KeBugCheck, <IRQL_NOT_GREATER_OR_EQUAL>        ; never return
endif
        fstRET  KfRaiseIrql

fstENDP KfRaiseIrql

;++
;
; KIRQL
; KeRaiseIrqlToDpcLevel (
;    )
;
; Routine Description:
;
;    This routine is used to raise IRQL to DPC level.
;
; Arguments:
;
; Return Value:
;
;    OldIrql - the addr of a variable which old irql should be stored
;
;--

cPublicProc _KeRaiseIrqlToDpcLevel,0
cPublicFpo 0, 0

        mov     eax, PCR[PcIrql]        ; (eax) = Old Irql
        mov     dword ptr PCR[PcIrql], DISPATCH_LEVEL    ; set new irql

ifdef IRQL_METRICS
        inc     HalRaiseIrqlCount
endif
if DBG
        cmp     eax, DISPATCH_LEVEL     ; old > new?
        ja      short Krid99            ; yes, go bugcheck
endif

        stdRET  _KeRaiseIrqlToDpcLevel

if DBG
cPublicFpo 0,1
Krid99: push    eax                     ; put old irql where we can find it
        stdCall   _KeBugCheck, <IRQL_NOT_GREATER_OR_EQUAL>        ; never return
        stdRET  _KeRaiseIrqlToDpcLevel
endif

stdENDP _KeRaiseIrqlToDpcLevel


;++
;
; KIRQL
; KeRaiseIrqlToSynchLevel (
;    )
;
; Routine Description:
;
;    This routine is used to raise IRQL to SYNC level.
;
; Arguments:
;
; Return Value:
;
;    OldIrql - the addr of a variable which old irql should be stored
;
;--

cPublicProc _KeRaiseIrqlToSynchLevel,0
cPublicFpo 0, 0

        mov     eax, PCR[PcIrql]        ; (eax) = Old Irql
        mov     dword ptr PCR[PcIrql], SYNCH_LEVEL    ; set new irql

ifdef IRQL_METRICS
        inc     HalRaiseIrqlCount
endif
if DBG
        cmp     eax, SYNCH_LEVEL        ; old > new?
        ja      short Kris99            ; yes, go bugcheck
endif

        stdRET  _KeRaiseIrqlToSynchLevel

if DBG
cPublicFpo 0,1
Kris99: push    eax                     ; put old irql where we can find it
        stdCall   _KeBugCheck, <IRQL_NOT_GREATER_OR_EQUAL>        ; never return
        stdRET  _KeRaiseIrqlToSynchLevel
endif

stdENDP _KeRaiseIrqlToSynchLevel

;++
;
; VOID
; KfLowerIrql (
;    IN KIRQL NewIrql
;    )
;
; Routine Description:
;
;    This routine is used to lower IRQL to the specified value.
;    The IRQL and PIRQL will be updated accordingly.  Also, this
;    routine checks to see if any software interrupt should be
;    generated.  The following condition will cause software
;    interrupt to be simulated:
;      any software interrupt which has higher priority than
;        current IRQL's is pending.
;
;    NOTE: This routine simulates software interrupt as long as
;          any pending SW interrupt level is higher than the current
;          IRQL, even when interrupts are disabled.
;
; Arguments:
;
;    (cl) = NewIrql - the new irql to be set.
;
; Return Value:
;
;    None.
;
;--

cPublicFastCall KfLowerIrql,1
cPublicFpo 0, 0
        and     ecx, 0ffh

ifdef IRQL_METRICS
        inc     HalLowerIrqlCount
endif

if DBG
        cmp     ecx,PCR[PcIrql]         ; Make sure we are not lowering to
        ja      KliBug                  ; ABOVE current level
endif
        pushfd
        cli
        mov     PCR[PcIrql], ecx
        mov     edx, PCR[PcIRR]
        and     edx, FindHigherIrqlMask[ecx*4]  ; (edx) is the bitmask of
                                                ; pending interrupts we need to
                                                ; dispatch now.
        jnz     short Kli10                     ; go dispatch pending interrupts

;
; no interrupts pending, return quickly.
;

        popfd

ifdef IRQL_METRICS
        inc     HalQuickLowerIrqlCount
endif
        fstRET    KfLowerIrql

cPublicFpo 1, 1
align 4
Kli10:

;
; If there is a pending hardware interrupt, then the PICs have been
; masked to reflect the actual Irql.
;

        bsr     ecx, edx                        ; (ecx) = Pending irq level
        cmp     ecx, DISPATCH_LEVEL
        ja      short Kli40

        call    SWInterruptHandlerTable[ecx*4]  ; Dispatch the pending int.
        popfd

cPublicFpo 1, 0
        fstRET    KfLowerIrql

Kli40:
;
; Clear all the interrupt masks
;

         mov     eax, PCR[PcIDR]
        SET_8259_MASK

        mov     edx, 1
        shl     edx, cl
        xor     PCR[PcIRR], edx                 ; clear bit in IRR
        call    SWInterruptHandlerTable[ecx*4]  ; Dispatch the pending int.
        popfd

cPublicFpo 1, 0
        fstRET    KfLowerIrql

if DBG
cPublicFpo 1, 2
KliBug:
        push    ecx                             ; new irql for debugging
        push    dword ptr PCR[PcIrql]           ; old irql for debugging
        mov     byte ptr PCR[PcIrql],HIGH_LEVEL   ; avoid recursive error
        stdCall   _KeBugCheck, <IRQL_NOT_LESS_OR_EQUAL>   ; never return
endif

fstENDP KfLowerIrql

;++
;
; VOID
; HalEndSystemInterrupt
;    IN KIRQL NewIrql,
;    IN ULONG Vector
;    )
;
; Routine Description:
;
;    This routine is used to lower IRQL to the specified value.
;    The IRQL and PIRQL will be updated accordingly.  Also, this
;    routine checks to see if any software interrupt should be
;    generated.  The following condition will cause software
;    interrupt to be simulated:
;      any software interrupt which has higher priority than
;        current IRQL's is pending.
;
;    NOTE: This routine simulates software interrupt as long as
;          any pending SW interrupt level is higher than the current
;          IRQL, even when interrupts are disabled.
;
; Arguments:
;
;    NewIrql - the new irql to be set.
;
;    Vector - Vector number of the interrupt
;
;    Note that esp+12 is the beginning of interrupt/trap frame and upon
;    entering to this routine the interrupts are off.
;
; Return Value:
;
;    None.
;
;--

HeiNewIrql      equ     [esp + 4]

cPublicProc _HalEndSystemInterrupt  ,2
cPublicFpo 2, 0

        xor     ecx, ecx
        mov     cl, byte ptr HeiNewIrql         ; get new irql value

ifdef IRQL_METRICS
        inc     HalLowerIrqlCount
endif

        mov     edx, PCR[PcIRR]
        and     edx, FindHigherIrqlMask[ecx*4]  ; (edx) is the bitmask of
                                                ; pending interrupts we need to
                                                ; dispatch now.
        mov     PCR[PcIrql], ecx
        jnz     short Hei10                     ; go dispatch pending interrupts

;
; no interrupts pending, return quickly.
;


ifdef IRQL_METRICS
        inc      HalQuickLowerIrqlCount
endif
        stdRET    _HalEndSystemInterrupt

align 4
Hei10:

;
; If there is any delayed hardware interrupt being serviced, we leave
; the interrupt masked and simply return.
;

        test    PCR[PcIrrActive], IRQ_ACTIVE_MASK
        jnz     short Hei50

        bsr     ecx, edx                        ; (eax) = Pending irq level
        cmp     ecx, DISPATCH_LEVEL
        jle     short Hei40

;
; Clear all the interrupt masks
;

align 4
Hei15:
        mov     eax, PCR[PcIDR]
        SET_8259_MASK
;
; The pending interrupt is a hardware interrupt.  To prevent the delayed
; interrupts from overflowing stack, we check if the pending level is already
; active.  If yes, we simply return and let the higher level EndSystemInterrupt
; handle it.
;
; (ecx) = pending vector
;

        mov     edx, 1
        shl     edx, cl
        test    PCR[PcIrrActive], edx           ; if the pending int is being
                                                ; processed, just return.
        jne     short Hei50
        or      PCR[PcIrrActive], edx           ; Set Active bit
        xor     PCR[PcIRR], edx                 ; clear bit in IRR
        call    SWInterruptHandlerTable[ecx*4]  ; Note, it destroys eax
        xor     PCR[PcIrrActive], edx           ; Clear bit in ActiveIrql
        mov     eax, PCR[PcIRR]                 ; Reload IRR
        mov     ecx, PCR[PcIrql]
        and     eax, FindHigherIrqlMask[ecx*4]  ; Is any interrupt pending
        jz      short Hei50                     ; (Most time it will be zero.)
        bsr     ecx, eax                        ; (edx) = Pending irq level
        cmp     ecx, DISPATCH_LEVEL
        ja      short Hei15

Hei40:

;
; The pending interrupt is at Software Level.  We simply make current
; interrupt frame the new pending software interrupt's frame and
; jmp to the handler routine.
;

        add     esp, 12
        jmp     SWInterruptHandlerTable2[ecx*4] ; Note, it destroys eax


Hei50:
        stdRET    _HalEndSystemInterrupt

stdENDP _HalEndSystemInterrupt

;++
;
; VOID
; HalpEndSoftwareInterrupt
;    IN KIRQL NewIrql,
;    )
;
; Routine Description:
;
;    This routine is used to lower IRQL from software interrupt
;    leverl to the specified value.
;    The IRQL and PIRQL will be updated accordingly.  Also, this
;    routine checks to see if any software interrupt should be
;    generated.  The following condition will cause software
;    interrupt to be simulated:
;      any software interrupt which has higher priority than
;        current IRQL's is pending.
;
;    NOTE: This routine simulates software interrupt as long as
;          any pending SW interrupt level is higher than the current
;          IRQL, even when interrupts are disabled.
;
; Arguments:
;
;    NewIrql - the new irql to be set.
;
;    Note that esp+8 is the beginning of interrupt/trap frame and upon
;    entering to this routine the interrupts are off.
;
; Return Value:
;
;    None.
;
;--

HesNewIrql      equ     [esp + 4]

cPublicProc _HalpEndSoftwareInterrupt  ,1
cPublicFpo 1, 0

        movzx   ecx, byte ptr HesNewIrql        ; get new irql value
        mov     edx, PCR[PcIRR]
        and     edx, FindHigherIrqlMask[ecx*4]  ; (edx) is the bitmask of
                                                ; pending interrupts we need to
                                                ; dispatch now.
        mov     PCR[PcIrql], ecx
        jnz     short Hes10

        stdRET    _HalpEndSoftwareInterrupt

align 4
Hes10:
;
; Check if any delayed hardware interrupt is being serviced.  If yes, we
; simply return.
;

        test    PCR[PcIrrActive], IRQ_ACTIVE_MASK
        jnz     short Hes90

;
; If there is a pending hardware interrupt, then the PICs have been
; masked to reflect the actual Irql.
;

        bsr     ecx, edx                        ; (ecx) = Pending irq level
        cmp     ecx, DISPATCH_LEVEL
        ja      short Hes20

;
; Pending interrupt is a soft interrupt. Recycle stack frame
;

        add     esp, 8
        jmp     SWInterruptHandlerTable2[ecx*4] ; Note, it destroys eax

Hes20:
;
; Clear all the interrupt masks
;

        mov     eax, PCR[PcIDR]
        SET_8259_MASK

;
; (ecx) = Pending level
;

        mov     edx, 1
        shl     edx, cl

        or      PCR[PcIrrActive], edx           ; Set Active bit
        xor     PCR[PcIRR], edx                 ; clear bit in IRR

        call    SWInterruptHandlerTable[ecx*4]  ; Dispatch the pending int.

        xor     PCR[PcIrrActive], edx           ; Clear bit in ActiveIrql

        movzx   ecx, byte ptr HesNewIrql        ; get new irql value
        mov     edx, PCR[PcIRR]
        and     edx, FindHigherIrqlMask[ecx*4]  ; (edx) is the bitmask of
                                                ; pending interrupts we need to
                                                ; dispatch now.
        jnz     short Hes10

Hes90:  stdRET  _HalpEndSoftwareInterrupt

stdENDP _HalpEndSoftwareInterrupt

        page ,132
        subttl  "DispatchInterrupt 2"

;++
;
; VOID
; HalpDispatchInterrupt2(
;       VOID
;       );
;
; Routine Description:
;
;   The functional description is the same as HalpDispatchInterrupt.
;
;   This function differs from HalpDispatchInterrupt in how it has been
;   optimized.  This function is optimized for dispatching dispatch interrupts
;   for LowerIrql, ReleaseSpinLock, and RequestSoftwareInterrupt.
;
; Arguments:
;
;    None
;    Interrupt is disabled
;
; Return Value:
;
;    (edx) = 1 shl DISPATCH_LEVEL
;
; Warnings:
;
;   Not all SW int handles this hal uses save all the registers
;   callers to SWInterruptHandler for H/W interrupts assume that
;   ONLY EAX & ECX are destroyed.
;
;   Note: this function saves EBX since KiDispatchInterrupt uses
;   the value without preserving it.
;--

cPublicProc _HalpDispatchInterrupt2
cPublicFpo 0, 2

        and     dword ptr PCR[PcIRR], not (1 shl DISPATCH_LEVEL) ; clear the pending bit in IRR

        mov     ecx, PCR[PcIrql]

        mov     dword ptr PCR[PcIrql], DISPATCH_LEVEL; set new irql
        push    ecx                             ; Save OldIrql

;
; Now it is safe to enable interrupt to allow higher priority interrupt
; to come in.
;
        sti

        push    ebx
        stdCall _KiDispatchInterrupt            ; Handle DispatchInterrupt
        pop     ebx
        pop     ecx                             ; (ecx) = OldIrql
        mov     edx, 1 shl DISPATCH_LEVEL

        cli

        mov     eax, PCR[PcIRR]
        mov     PCR[PcIrql], ecx                ; restore current irql

        and     eax, FindHigherIrqlMask[ecx*4]  ; (eax) is the bitmask of
                                                ; pending interrupts we need to
                                                ; dispatch now.

        jnz     short diq10                     ; go dispatch pending interrupts
        stdRET  _HalpDispatchInterrupt2

diq10:
;
; If there is a pending hardware interrupt, then the PICs have been
; masked to reflect the actual Irql.
;

        bsr     ecx, eax                        ; (ecx) = Pending irq level
        cmp     ecx, DISPATCH_LEVEL
        jbe     short diq20

;
; Clear all the interrupt masks
;

        mov     eax, PCR[PcIDR]
        SET_8259_MASK

        mov     edx, 1
        shl     edx, cl
        xor     PCR[PcIRR], edx                 ; clear bit in IRR

diq20:
;
; (ecx) = Pending level
;

        jmp     SWInterruptHandlerTable[ecx*4]  ; Dispatch the pending int.
diq90:  stdRET  _HalpDispatchInterrupt2

stdENDP _HalpDispatchInterrupt2

        page ,132
        subttl  "Get current irql"

;++
;
; KIRQL
; KeGetCurrentIrql (VOID)
;
; Routine Description:
;
;    This routine returns to current IRQL.
;
; Arguments:
;
;    None.
;
; Return Value:
;
;    The current IRQL.
;
;--

cPublicProc _KeGetCurrentIrql   ,0
cPublicFpo 0, 0

        mov   eax, dword ptr PCR[PcIrql]   ; Current irql is in the PCR
        stdRET    _KeGetCurrentIrql
stdENDP _KeGetCurrentIrql



;++
;
; KIRQL
; HalpDisableAllInterrupts (VOID)
;
; Routine Description:
;
;   This routine is called during a system crash.  The hal needs all
;   interrupts disabled.
;
; Arguments:
;
;    None.
;
; Return Value:
;
;    Old Irql level
;
;--

cPublicProc _HalpDisableAllInterrupts,0
cPublicFpo 0, 0

    ;
    ; Mask interrupts off at PIC
    ; (raising to high_level does not work on lazy irql implementation)
    ;
        mov     eax, KiI8259MaskTable[HIGH_LEVEL*4]; get pic masks for the new irql
        or      eax, PCR[PcIDR]         ; mask irqs which are disabled
        SET_8259_MASK                   ; set 8259 masks

        mov     eax, dword ptr PCR[PcIrql]
        mov     dword ptr PCR[PcIrql], HIGH_LEVEL   ; set new irql

        stdRET  _HalpDisableAllInterrupts

stdENDP _HalpDisableAllInterrupts

;++
;
; VOID
; HalpReenableInterrupts (
;     IN KIRQL Irql
;     )
;
; Routine Description:
;
;   This routine restores the PIC to a given state.
;
; Arguments:
;
;    Irql - Irql state to restore to.
;
; Return Value:
;
;    None
;
;--

HriNewIrql      equ     [esp + 4]

cPublicProc _HalpReenableInterrupts,1
cPublicFpo 1, 0

        xor     eax, eax
        mov     al, HriNewIrql
        mov     dword ptr PCR[PcIrql],eax ; set new irql

        mov     eax, PCR[PcIDR]         ; mask irqs which are disabled
        SET_8259_MASK                   ; set 8259 masks

        stdRET  _HalpReenableInterrupts

stdENDP _HalpReenableInterrupts

        page ,132
        subttl  "Postponed Hardware Interrupt Dispatcher"
;++
;
; VOID
; HalpHardwareInterruptNN (
;       VOID
;       );
;
; Routine Description:
;
;    These routines branch through the IDT to simulate the appropriate
;    hardware interrupt.  They use the "INT nn" instruction to do this.
;
; Arguments:
;
;    None.
;
; Returns:
;
;    None.
;
; Environment:
;
;    IRET frame is on the stack
;
;--
cPublicProc _HalpHardwareInterruptTable, 0
cPublicFpo 0,0

        public HalpHardwareInterrupt00
HalpHardwareInterrupt00 label byte
ifdef IRQL_METRICS
        lock inc HalHardwareIntCount
endif
        int     PRIMARY_VECTOR_BASE + 0
        ret

        public HalpHardwareInterrupt01
HalpHardwareInterrupt01 label byte
ifdef IRQL_METRICS
        lock inc HalHardwareIntCount
endif
        int     PRIMARY_VECTOR_BASE + 1
        ret

        public HalpHardwareInterrupt02
HalpHardwareInterrupt02 label byte
ifdef IRQL_METRICS
        lock inc HalHardwareIntCount
endif
        int     PRIMARY_VECTOR_BASE + 2
        ret

        public HalpHardwareInterrupt03
HalpHardwareInterrupt03 label byte
ifdef IRQL_METRICS
        lock inc HalHardwareIntCount
endif
        int     PRIMARY_VECTOR_BASE + 3
        ret

        public HalpHardwareInterrupt04
HalpHardwareInterrupt04 label byte
ifdef IRQL_METRICS
        lock inc HalHardwareIntCount
endif
        int     PRIMARY_VECTOR_BASE + 4
        ret

        public HalpHardwareInterrupt05
HalpHardwareInterrupt05 label byte
ifdef IRQL_METRICS
        lock inc HalHardwareIntCount
endif
        int     PRIMARY_VECTOR_BASE + 5
        ret

        public HalpHardwareInterrupt06
HalpHardwareInterrupt06 label byte
ifdef IRQL_METRICS
        lock inc HalHardwareIntCount
endif
        int     PRIMARY_VECTOR_BASE + 6
        ret

        public HalpHardwareInterrupt07
HalpHardwareInterrupt07 label byte
ifdef IRQL_METRICS
        lock inc HalHardwareIntCount
endif
        int     PRIMARY_VECTOR_BASE + 7
        ret

        public HalpHardwareInterrupt08
HalpHardwareInterrupt08 label byte
ifdef IRQL_METRICS
        lock inc HalHardwareIntCount
endif
        int     PRIMARY_VECTOR_BASE + 8
        ret

        public HalpHardwareInterrupt09
HalpHardwareInterrupt09 label byte
ifdef IRQL_METRICS
        lock inc HalHardwareIntCount
endif
        int     PRIMARY_VECTOR_BASE + 9
        ret

        public HalpHardwareInterrupt10
HalpHardwareInterrupt10 label byte
ifdef IRQL_METRICS
        lock inc HalHardwareIntCount
endif
        int     PRIMARY_VECTOR_BASE + 10
        ret

        public HalpHardwareInterrupt11
HalpHardwareInterrupt11 label byte
ifdef IRQL_METRICS
        lock inc HalHardwareIntCount
endif
        int     PRIMARY_VECTOR_BASE + 11
        ret

        public HalpHardwareInterrupt12
HalpHardwareInterrupt12 label byte
ifdef IRQL_METRICS
        lock inc HalHardwareIntCount
endif
        int     PRIMARY_VECTOR_BASE + 12
        ret

        public HalpHardwareInterrupt13
HalpHardwareInterrupt13 label byte
ifdef IRQL_METRICS
        lock inc HalHardwareIntCount
endif
        int     PRIMARY_VECTOR_BASE + 13
        ret

        public HalpHardwareInterrupt14
HalpHardwareInterrupt14 label byte
ifdef IRQL_METRICS
        lock inc HalHardwareIntCount
endif
        int     PRIMARY_VECTOR_BASE + 14
        ret

        public HalpHardwareInterrupt15
HalpHardwareInterrupt15 label byte
ifdef IRQL_METRICS
        lock inc HalHardwareIntCount
endif
        int     PRIMARY_VECTOR_BASE + 15
        ret

        public HalpHardwareInterruptLevel
HalpHardwareInterruptLevel label byte
cPublicFpo 0,0
        mov     eax, PCR[PcIrql]
        mov     ecx, PCR[PcIRR]
        and     ecx, FindHigherIrqlMask[eax*4]  ; (ecx) is the bitmask of
                                                ; pending interrupts we need to
                                                ; dispatch now.
        jz      short lvl_90    ; no pending ints

        test    PCR[PcIrrActive], IRQ_ACTIVE_MASK
        jnz     short lvl_90    ; let guy furture down the stack handle it

        mov     eax, ecx                        ; (eax) = bitmask
        bsr     ecx, eax                        ; (cl) = set bit

        mov     eax, 1
        shl     eax, cl
        xor     PCR[PcIRR], eax                 ; clear bit in IRR

        call    SWInterruptHandlerTable[ecx*4]  ; Dispatch the pending int.
align 4
lvl_90:
        ret

stdENDP _HalpHardwareInterruptTable


_TEXT$01   ends

        page ,132
        subttl  "Interrupt Controller Chip Initialization"

_TEXT$02   SEGMENT DWORD PUBLIC 'CODE'
        ASSUME  DS:FLAT, ES:FLAT, SS:FLAT, FS:NOTHING, GS:NOTHING
;++
;
; VOID
; HalpInitializePICs (
;    BOOLEAN EnableInterrupts
;    )
;
; Routine Description:
;
;    This routine sends the 8259 PIC initialization commands and
;    masks all the interrupts on 8259s.
;
; Arguments:
;
;    EnableInterrupts - If this is true, then this function will
;                       explicitly enable interrupts at the end,
;                       as it always did in the past.  If this
;                       is false, then it will preserve the interrupt
;                       flag.
;
; Return Value:
;
;    None.
;
;--

EnableInterrupts equ [esp + 0ch]

cPublicProc _HalpInitializePICs       ,1
cPublicFpo 0, 0

        push    esi                             ; save caller's esi
        pushfd
        cli                                     ; disable interrupt
        
        lea     esi, PICsInitializationString
        lodsw                                   ; (AX) = PIC port 0 address
Hip10:  movzx   edx, ax
        outsb                                   ; output ICW1
        IODelay
        inc     edx                             ; (DX) = PIC port 1 address
        outsb                                   ; output ICW2
        IODelay
        outsb                                   ; output ICW3
        IODelay
        outsb                                   ; output ICW4
        IODelay
        mov     al, 0FFH                        ; mask all 8259 irqs
        out     dx,al                           ; write mask to PIC
        lodsw
        cmp     ax, 0                           ; end of init string?
        jne     short Hip10                     ; go init next PIC

;
; Read EISA defined ELCR.  If it looks good save it away.
; If a PCI interrupts is later connected, the vector will
; be assumed level if it's in the ELCR.
;
        mov     edx, 4d1h               ; Eisa Edge/Level port
        in      al, dx                  ; get e/l irq 8-f
        mov     ah, al
        dec     edx
        in      al, dx                  ; get e/l irq 0-7
        and     eax, 0def8h             ; clear reserved bits
        cmp     eax, 0def8h             ; all set?
        je      short Hip50             ; Yes, register not implemented

        mov     _HalpEisaELCR, eax      ; Save possible ELCR settings


;
; If this is an EISA machine, mark all interrupts in the EISA ELCR
; as level interrupts
;
        cmp     _HalpBusType, MACHINE_TYPE_EISA
        jne     short Hip50

;
; Verify this isn't an OPTI chipset machine which claims to be
; EISA, but neglects to follow the EISA spec...
;

        mov     edx, 0481h      ; DmaPageHighPort.Channel2
        mov     al, 055h
        out     dx, al          ; out to Eisa DMA register
        in      al, dx          ; read it back
        cmp     al, 055h        ; if it doesn't stick, then machine
        jne     short Hip50     ; isn't support all eisa registers

;
; Ok - loop and mark all EISA level interrupts
;

        mov     eax, _HalpEisaELCR
        xor     ecx, ecx                        ; start at irq 0
Hip30:
        test    eax, 1                          ; is level bit set?
        jz      short Hip40                     ; no, go to next

;
; Found a level sensitive interrupt:
;   Set the SWInterruptHandler for the irql to be a NOP.
;   Set the SpecialDismiss entry for the irq to be the level version
;
        mov     SWInterruptHandlerTable+4*4[ecx], offset HalpHardwareInterruptLevel

        mov     edx, HalpSpecialDismissLevelTable[ecx]
        mov     HalpSpecialDismissTable[ecx], edx

Hip40:
        add     ecx, 4                          ; next vector
        shr     eax, 1                          ; shift bits down
        jnz     short Hip30                     ; more set bits, then loop


Hip50:
        mov     al, EnableInterrupts
        .if     (al != 0)
        or      [esp], EFLAGS_INTERRUPT_MASK    ; enable interrupts
        .endif
        popfd
        pop     esi                             ; restore caller's esi
        stdRET    _HalpInitializePICs
stdENDP _HalpInitializePICs


_TEXT$02   ends

        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halx86\i386\ixisabus.c ===
/*++


Copyright (c) 1989  Microsoft Corporation

Module Name:

    ixisabus.c

Abstract:

Author:

Environment:

Revision History:


--*/

#include "halp.h"

ULONG
HalpGetEisaInterruptVector(
    IN PBUS_HANDLER BusHandler,
    IN PBUS_HANDLER RootHandler,
    IN ULONG BusInterruptLevel,
    IN ULONG BusInterruptVector,
    OUT PKIRQL Irql,
    OUT PKAFFINITY Affinity
    );

BOOLEAN
HalpTranslateIsaBusAddress (
    IN PVOID BusHandler,
    IN PVOID RootHandler,
    IN PHYSICAL_ADDRESS BusAddress,
    IN OUT PULONG AddressSpace,
    OUT PPHYSICAL_ADDRESS TranslatedAddress
    );

BOOLEAN
HalpTranslateEisaBusAddress (
    IN PVOID BusHandler,
    IN PVOID RootHandler,
    IN PHYSICAL_ADDRESS BusAddress,
    IN OUT PULONG AddressSpace,
    OUT PPHYSICAL_ADDRESS TranslatedAddress
    );

NTSTATUS
HalpAdjustEisaResourceList (
    IN PBUS_HANDLER BusHandler,
    IN PBUS_HANDLER RootHandler,
    IN OUT PIO_RESOURCE_REQUIREMENTS_LIST   *pResourceList
    );

HalpGetEisaData (
    IN PBUS_HANDLER BusHandler,
    IN PBUS_HANDLER RootHandler,
    IN ULONG SlotNumber,
    IN PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Length
    );

extern USHORT HalpEisaIrqMask;
extern USHORT HalpEisaIrqIgnore;

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE,HalpGetEisaInterruptVector)
#pragma alloc_text(PAGE,HalpAdjustEisaResourceList)
#pragma alloc_text(PAGE,HalpGetEisaData)
#pragma alloc_text(PAGE,HalIrqTranslateResourceRequirementsIsa)
#pragma alloc_text(PAGE,HalIrqTranslateResourcesIsa)
#pragma alloc_text(PAGE,HalpRecordEisaInterruptVectors)
#endif


#ifndef ACPI_HAL
ULONG
HalpGetEisaInterruptVector(
    IN PBUS_HANDLER BusHandler,
    IN PBUS_HANDLER RootHandler,
    IN ULONG BusInterruptLevel,
    IN ULONG BusInterruptVector,
    OUT PKIRQL Irql,
    OUT PKAFFINITY Affinity
    )

/*++

Routine Description:

    This function returns the system interrupt vector and IRQL level
    corresponding to the specified bus interrupt level and/or vector. The
    system interrupt vector and IRQL are suitable for use in a subsequent call
    to KeInitializeInterrupt.

Arguments:

    BusHandle - Per bus specific structure

    Irql - Returns the system request priority.

    Affinity - Returns the system wide irq affinity.

Return Value:

    Returns the system interrupt vector corresponding to the specified device.

--*/
{
    UNREFERENCED_PARAMETER( BusInterruptVector );

    //
    // On standard PCs, IRQ 2 is the cascaded interrupt, and it really shows
    // up on IRQ 9.
    //
#if defined(NEC_98)
    if (BusInterruptLevel == 7) {
        BusInterruptLevel = 8;
    }
#else  // defined(NEC_98)
    if (BusInterruptLevel == 2) {
        BusInterruptLevel = 9;
    }
#endif // defined(NEC_98)

    if (BusInterruptLevel > 15) {
        return 0;
    }

    //
    // Get parent's translation from here..
    //
    return  BusHandler->ParentHandler->GetInterruptVector (
                    BusHandler->ParentHandler,
                    RootHandler,
                    BusInterruptLevel,
                    BusInterruptVector,
                    Irql,
                    Affinity
                );
}

NTSTATUS
HalpAdjustEisaResourceList (
    IN PBUS_HANDLER BusHandler,
    IN PBUS_HANDLER RootHandler,
    IN OUT PIO_RESOURCE_REQUIREMENTS_LIST   *pResourceList
    )
{
    SUPPORTED_RANGE     InterruptRange;

    RtlZeroMemory (&InterruptRange, sizeof InterruptRange);
    InterruptRange.Base  = 0;
    InterruptRange.Limit = 15;

    return HaliAdjustResourceListRange (
                BusHandler->BusAddresses,
                &InterruptRange,
                pResourceList
                );
}

BOOLEAN
HalpTranslateIsaBusAddress(
    IN PBUS_HANDLER BusHandler,
    IN PBUS_HANDLER RootHandler,
    IN PHYSICAL_ADDRESS BusAddress,
    IN OUT PULONG AddressSpace,
    OUT PPHYSICAL_ADDRESS TranslatedAddress
    )

/*++

Routine Description:

    This function translates a bus-relative address space and address into
    a system physical address.

Arguments:

    BusAddress        - Supplies the bus-relative address

    AddressSpace      -  Supplies the address space number.
                         Returns the host address space number.

                         AddressSpace == 0 => memory space
                         AddressSpace == 1 => I/O space

    TranslatedAddress - Supplies a pointer to return the translated address

Return Value:

    A return value of TRUE indicates that a system physical address
    corresponding to the supplied bus relative address and bus address
    number has been returned in TranslatedAddress.

    A return value of FALSE occurs if the translation for the address was
    not possible

--*/

{
    BOOLEAN     Status;

    //
    // Translated normally
    //

    Status = HalpTranslateSystemBusAddress (
                    BusHandler,
                    RootHandler,
                    BusAddress,
                    AddressSpace,
                    TranslatedAddress
                );


    //
    // If it could not be translated, and it's memory space
    // then we allow the translation as it would occur on it's
    // corrisponding EISA bus.   We're allowing this because
    // many VLBus drivers are claiming to be ISA devices.
    // (yes, they should claim to be VLBus devices, but VLBus is
    // run by video cards and like everything else about video
    // there's no hope of fixing it.  (At least according to
    // Andre))
    //

    if (Status == FALSE  &&  *AddressSpace == 0) {
        Status = HalTranslateBusAddress (
                    Eisa,
                    BusHandler->BusNumber,
                    BusAddress,
                    AddressSpace,
                    TranslatedAddress
                    );
    }

    return Status;
}

BOOLEAN
HalpTranslateEisaBusAddress(
    IN PBUS_HANDLER BusHandler,
    IN PBUS_HANDLER RootHandler,
    IN PHYSICAL_ADDRESS BusAddress,
    IN OUT PULONG AddressSpace,
    OUT PPHYSICAL_ADDRESS TranslatedAddress
    )

/*++

Routine Description:

    This function translates a bus-relative address space and address into
    a system physical address.

Arguments:

    BusAddress        - Supplies the bus-relative address

    AddressSpace      -  Supplies the address space number.
                         Returns the host address space number.

                         AddressSpace == 0 => memory space
                         AddressSpace == 1 => I/O space

    TranslatedAddress - Supplies a pointer to return the translated address

Return Value:

    A return value of TRUE indicates that a system physical address
    corresponding to the supplied bus relative address and bus address
    number has been returned in TranslatedAddress.

    A return value of FALSE occurs if the translation for the address was
    not possible

--*/

{
    BOOLEAN     Status;

    //
    // Translated normally
    //

    Status = HalpTranslateSystemBusAddress (
                    BusHandler,
                    RootHandler,
                    BusAddress,
                    AddressSpace,
                    TranslatedAddress
                );


    //
    // If it could not be translated, and it's in the 640k - 1m
    // range then (for compatibility) try translating it on the
    // Internal bus for
    //

    if (Status == FALSE  &&
        *AddressSpace == 0  &&
        BusAddress.HighPart == 0  &&
        BusAddress.LowPart >= 0xA0000  &&
        BusAddress.LowPart <  0xFFFFF) {

        Status = HalTranslateBusAddress (
                    Internal,
                    0,
                    BusAddress,
                    AddressSpace,
                    TranslatedAddress
                    );
    }

    return Status;
}
#endif

HalpGetEisaData (
    IN PBUS_HANDLER BusHandler,
    IN PBUS_HANDLER RootHandler,
    IN ULONG SlotNumber,
    IN PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Length
    )
/*++

Routine Description:

    The function returns the Eisa bus data for a slot or address.

Arguments:

    Buffer - Supplies the space to store the data.

    Length - Supplies a count in bytes of the maximum amount to return.

Return Value:

    Returns the amount of data stored into the buffer.

--*/

{
    OBJECT_ATTRIBUTES ObjectAttributes;
    OBJECT_ATTRIBUTES BusObjectAttributes;
    PWSTR EisaPath = L"\\Registry\\Machine\\Hardware\\Description\\System\\EisaAdapter";
    PWSTR ConfigData = L"Configuration Data";
    ULONG BusNumber;
    WCHAR BusString[] = L"00";
    UNICODE_STRING RootName, BusName = {0};
    UNICODE_STRING ConfigDataName;
    NTSTATUS NtStatus;
    PKEY_VALUE_FULL_INFORMATION ValueInformation;
    PCM_FULL_RESOURCE_DESCRIPTOR Descriptor;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR PartialResource;
    PCM_EISA_SLOT_INFORMATION SlotInformation;
    ULONG PartialCount;
    ULONG TotalDataSize, SlotDataSize;
    HANDLE EisaHandle = INVALID_HANDLE;
    HANDLE BusHandle = INVALID_HANDLE;
    ULONG BytesWritten, BytesNeeded;
    PUCHAR KeyValueBuffer = NULL;
    ULONG i;
    ULONG DataLength = 0;
    PUCHAR DataBuffer = Buffer;
    BOOLEAN Found = FALSE;

    PAGED_CODE ();


    RtlInitUnicodeString(
                    &RootName,
                    EisaPath
                    );

    InitializeObjectAttributes(
                    &ObjectAttributes,
                    &RootName,
                    OBJ_CASE_INSENSITIVE,
                    (HANDLE)NULL,
                    NULL
                    );

    //
    // Open the EISA root
    //

    NtStatus = ZwOpenKey(
                    &EisaHandle,
                    KEY_READ,
                    &ObjectAttributes
                    );

    if (!NT_SUCCESS(NtStatus)) {
        DataLength = 0;
        goto HalpGetEisaDataExit;
    }

    //
    // Init bus number path
    //

    BusNumber = BusHandler->BusNumber;
    if (BusNumber > 99) {
        DataLength = 0;
        goto HalpGetEisaDataExit;
    }

    if (BusNumber > 9) {
        BusString[0] += (WCHAR) (BusNumber/10);
        BusString[1] += (WCHAR) (BusNumber % 10);
    } else {
        BusString[0] += (WCHAR) BusNumber;
        BusString[1] = '\0';
    }

    RtlInitUnicodeString(
                &BusName,
                BusString
                );

    InitializeObjectAttributes(
                    &BusObjectAttributes,
                    &BusName,
                    OBJ_CASE_INSENSITIVE,
                    (HANDLE)EisaHandle,
                    NULL
                    );

    //
    // Open the EISA root + Bus Number
    //

    NtStatus = ZwOpenKey(
                    &BusHandle,
                    KEY_READ,
                    &BusObjectAttributes
                    );

    // Done with Eisa Handle
    ZwClose(EisaHandle);
    EisaHandle = INVALID_HANDLE;

    if (!NT_SUCCESS(NtStatus)) {
        DbgPrint("HAL: Opening Bus Number: Status = %x\n",NtStatus);
        DataLength = 0;
        goto HalpGetEisaDataExit;
    }

    //
    // opening the configuration data. This first call tells us how
    // much memory we need to allocate
    //

    RtlInitUnicodeString(
                &ConfigDataName,
                ConfigData
                );

    //
    // This should fail.  We need to make this call so we can
    // get the actual size of the buffer to allocate.
    //

    ValueInformation = (PKEY_VALUE_FULL_INFORMATION) &i;
    NtStatus = ZwQueryValueKey(
                        BusHandle,
                        &ConfigDataName,
                        KeyValueFullInformation,
                        ValueInformation,
                        0,
                        &BytesNeeded
                        );

    KeyValueBuffer = ExAllocatePoolWithTag(
                            NonPagedPool,
                            BytesNeeded,
                            HAL_POOL_TAG
                            );

    if (KeyValueBuffer == NULL) {
#if DBG
        DbgPrint("HAL: Cannot allocate Key Value Buffer\n");
#endif
        ZwClose(BusHandle);
        DataLength = 0;
        goto HalpGetEisaDataExit;
    }

    ValueInformation = (PKEY_VALUE_FULL_INFORMATION)KeyValueBuffer;

    NtStatus = ZwQueryValueKey(
                        BusHandle,
                        &ConfigDataName,
                        KeyValueFullInformation,
                        ValueInformation,
                        BytesNeeded,
                        &BytesWritten
                        );


    ZwClose(BusHandle);

    if (!NT_SUCCESS(NtStatus)) {
#if DBG
        DbgPrint("HAL: Query Config Data: Status = %x\n",NtStatus);
#endif
        DataLength = 0;
        goto HalpGetEisaDataExit;
    }


    //
    // We get back a Full Resource Descriptor List
    //

    Descriptor = (PCM_FULL_RESOURCE_DESCRIPTOR)((PUCHAR)ValueInformation +
                                         ValueInformation->DataOffset);

    PartialResource = (PCM_PARTIAL_RESOURCE_DESCRIPTOR)
                          &(Descriptor->PartialResourceList.PartialDescriptors);
    PartialCount = Descriptor->PartialResourceList.Count;

    for (i = 0; i < PartialCount; i++) {

        //
        // Do each partial Resource
        //

        switch (PartialResource->Type) {
            case CmResourceTypeNull:
            case CmResourceTypePort:
            case CmResourceTypeInterrupt:
            case CmResourceTypeMemory:
            case CmResourceTypeDma:

                //
                // We dont care about these.
                //

                PartialResource++;

                break;

            case CmResourceTypeDeviceSpecific:

                //
                // Bingo!
                //

                TotalDataSize = PartialResource->u.DeviceSpecificData.DataSize;

                SlotInformation = (PCM_EISA_SLOT_INFORMATION)
                                    ((PUCHAR)PartialResource +
                                     sizeof(CM_PARTIAL_RESOURCE_DESCRIPTOR));

                while (((LONG)TotalDataSize) > 0) {

                    if (SlotInformation->ReturnCode == EISA_EMPTY_SLOT) {

                        SlotDataSize = sizeof(CM_EISA_SLOT_INFORMATION);

                    } else {

                        SlotDataSize = sizeof(CM_EISA_SLOT_INFORMATION) +
                                  SlotInformation->NumberFunctions *
                                  sizeof(CM_EISA_FUNCTION_INFORMATION);
                    }

                    if (SlotDataSize > TotalDataSize) {

                        //
                        // Something is wrong again
                        //

                        DataLength = 0;
                        goto HalpGetEisaDataExit;
                    }

                    if (SlotNumber != 0) {

                        SlotNumber--;

                        SlotInformation = (PCM_EISA_SLOT_INFORMATION)
                            ((PUCHAR)SlotInformation + SlotDataSize);

                        TotalDataSize -= SlotDataSize;

                        continue;

                    }

                    //
                    // This is our slot
                    //

                    Found = TRUE;
                    break;

                }

                //
                // End loop
                //

                i = PartialCount;

                break;

            default:

#if DBG
                DbgPrint("Bad Data in registry!\n");
#endif

                DataLength = 0;
                goto HalpGetEisaDataExit;
        }
    }

    if (Found) {
        i = Length + Offset;
        if (i > SlotDataSize) {
            i = SlotDataSize;
        }

        DataLength = i - Offset;
        RtlMoveMemory (Buffer, ((PUCHAR)SlotInformation + Offset), DataLength);
    }

HalpGetEisaDataExit:

    if (EisaHandle != INVALID_HANDLE)
    {
        ZwClose(EisaHandle);
    }

    if (KeyValueBuffer) ExFreePool(KeyValueBuffer);

    return DataLength;
}


NTSTATUS
HalIrqTranslateResourceRequirementsIsa(
    IN PVOID Context,
    IN PIO_RESOURCE_DESCRIPTOR Source,
    IN PDEVICE_OBJECT PhysicalDeviceObject,
    OUT PULONG TargetCount,
    OUT PIO_RESOURCE_DESCRIPTOR *Target
)
/*++

Routine Description:

    This function is basically a wrapper for
    HalIrqTranslateResourceRequirementsRoot that understands
    the weirdnesses of the ISA bus.

Arguments:

Return Value:

    status

--*/
{
    PIO_RESOURCE_DESCRIPTOR modSource, target, rootTarget;
    NTSTATUS                status;
    BOOLEAN                 picSlaveDeleted = FALSE;
    BOOLEAN                 deleteResource;
    ULONG                   sourceCount = 0;
    ULONG                   targetCount = 0;
    ULONG                   resource;
    ULONG                   rootCount;
    ULONG                   invalidIrq;
    BOOLEAN                 pciIsaConflict = FALSE;

    PAGED_CODE();
    ASSERT(Source->Type == CmResourceTypeInterrupt);

    modSource = ExAllocatePoolWithTag(PagedPool,
                                      // we will have at most nine ranges when we are done
                                      sizeof(IO_RESOURCE_DESCRIPTOR) * 9,
                                      HAL_POOL_TAG
                                      );

    if (!modSource) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(modSource, sizeof(IO_RESOURCE_DESCRIPTOR) * 9);

    //
    // Is the PIC_SLAVE_IRQ in this resource?
    //
    if ((Source->u.Interrupt.MinimumVector <= PIC_SLAVE_IRQ) &&
        (Source->u.Interrupt.MaximumVector >= PIC_SLAVE_IRQ)) {

        //
        // Clip the maximum
        //
        if (Source->u.Interrupt.MinimumVector < PIC_SLAVE_IRQ) {

            modSource[sourceCount] = *Source;

            modSource[sourceCount].u.Interrupt.MinimumVector =
                Source->u.Interrupt.MinimumVector;

            modSource[sourceCount].u.Interrupt.MaximumVector =
                PIC_SLAVE_IRQ - 1;

            sourceCount++;
        }

        //
        // Clip the minimum
        //
        if (Source->u.Interrupt.MaximumVector > PIC_SLAVE_IRQ) {

            modSource[sourceCount] = *Source;

            modSource[sourceCount].u.Interrupt.MaximumVector =
                Source->u.Interrupt.MaximumVector;

            modSource[sourceCount].u.Interrupt.MinimumVector =
                PIC_SLAVE_IRQ + 1;

            sourceCount++;
        }

        //
        // In ISA machines, the PIC_SLAVE_IRQ is rerouted
        // to PIC_SLAVE_REDIRECT.  So find out if PIC_SLAVE_REDIRECT
        // is within this list. If it isn't we need to add it.
        //
        if (!((Source->u.Interrupt.MinimumVector <= PIC_SLAVE_REDIRECT) &&
             (Source->u.Interrupt.MaximumVector >= PIC_SLAVE_REDIRECT))) {

            modSource[sourceCount] = *Source;

            modSource[sourceCount].u.Interrupt.MinimumVector = PIC_SLAVE_REDIRECT;
            modSource[sourceCount].u.Interrupt.MaximumVector = PIC_SLAVE_REDIRECT;

            sourceCount++;
        }

    } else {

        *modSource = *Source;
        sourceCount = 1;
    }

    //
    // Now that the PIC_SLAVE_IRQ has been handled, we have
    // to take into account IRQs that may have been steered
    // away to the PCI bus.
    //
    // N.B.  The algorithm used below may produce resources
    // with minimums greater than maximums.  Those will
    // be stripped out later.
    //

    for (invalidIrq = 0; invalidIrq < PIC_VECTORS; invalidIrq++) {

        //
        // Look through all the resources, possibly removing
        // this IRQ from them.
        //
        for (resource = 0; resource < sourceCount; resource++) {

            deleteResource = FALSE;

            if (HalpPciIrqMask & (1 << invalidIrq)) {

                //
                // This IRQ belongs to the PCI bus.
                //

                if (!((HalpBusType == MACHINE_TYPE_EISA) &&
                      ((modSource[resource].Flags == CM_RESOURCE_INTERRUPT_LEVEL_SENSITIVE)))) {

                    //
                    // And this resource is not an EISA-style,
                    // level-triggered interrupt.
                    //
                    // N.B.  Only the system BIOS truely knows
                    //       whether an IRQ on a PCI bus can be
                    //       shared with an IRQ on an ISA bus.
                    //       This code assumes that, in the case
                    //       that the BIOS set an EISA device to
                    //       the same interrupt as a PCI device,
                    //       the machine can actually function.
                    //
                    deleteResource = TRUE;
                }
            }

#ifndef MCA
            if ((HalpBusType == MACHINE_TYPE_EISA) &&
                !(HalpEisaIrqIgnore & (1 << invalidIrq))) {

                if (modSource[resource].Flags != HalpGetIsaIrqState(invalidIrq)) {

                    //
                    // This driver has requested a level-triggered interrupt
                    // and this particular interrupt is set to be edge, or
                    // vice-versa.
                    //
                    deleteResource = TRUE;
                    pciIsaConflict = TRUE;
                }
            }
#endif

            if (deleteResource) {

                if (modSource[resource].u.Interrupt.MinimumVector == invalidIrq) {

                    modSource[resource].u.Interrupt.MinimumVector++;

                } else if (modSource[resource].u.Interrupt.MaximumVector == invalidIrq) {

                    modSource[resource].u.Interrupt.MaximumVector--;

                } else if ((modSource[resource].u.Interrupt.MinimumVector < invalidIrq) &&
                    (modSource[resource].u.Interrupt.MaximumVector > invalidIrq)) {

                    //
                    // Copy the current resource into a new resource.
                    //
                    modSource[sourceCount] = modSource[resource];

                    //
                    // Clip the current resource to a range below invalidIrq.
                    //
                    modSource[resource].u.Interrupt.MaximumVector = invalidIrq - 1;

                    //
                    // Clip the new resource to a range above invalidIrq.
                    //
                    modSource[sourceCount].u.Interrupt.MinimumVector = invalidIrq + 1;

                    sourceCount++;
                }
            }
        }
    }


    target = ExAllocatePoolWithTag(PagedPool,
                                   sizeof(IO_RESOURCE_DESCRIPTOR) * sourceCount,
                                   HAL_POOL_TAG
                                   );

    if (!target) {
        ExFreePool(modSource);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Now send each of these ranges through
    // HalIrqTranslateResourceRequirementsRoot.
    //
    for (resource = 0; resource < sourceCount; resource++) {

        //
        // Skip over resources that we have previously
        // clobbered (while deleting PCI IRQs.)
        //
        if (modSource[resource].u.Interrupt.MinimumVector >
            modSource[resource].u.Interrupt.MaximumVector) {

            continue;
        }

        status = HalIrqTranslateResourceRequirementsRoot(
                    Context,
                    &modSource[resource],
                    PhysicalDeviceObject,
                    &rootCount,
                    &rootTarget
                    );

        if (!NT_SUCCESS(status)) {
            ExFreePool(target);
            goto HalIrqTranslateResourceRequirementsIsaExit;
        }

        //
        // HalIrqTranslateResourceRequirementsRoot should return
        // either one resource or, occasionally, zero.
        //
        ASSERT(rootCount <= 1);

        if (rootCount == 1) {

            target[targetCount] = *rootTarget;
            targetCount++;
            ExFreePool(rootTarget);
        }
    }

    status = STATUS_TRANSLATION_COMPLETE;
    *TargetCount = targetCount;

    if (targetCount > 0) {

        *Target = target;

    } else {

        ExFreePool(target);
        if (pciIsaConflict == TRUE) {
            status = STATUS_PNP_IRQ_TRANSLATION_FAILED;
        }
    }

HalIrqTranslateResourceRequirementsIsaExit:

    ExFreePool(modSource);
    return status;
}

NTSTATUS
HalIrqTranslateResourcesIsa(
    IN PVOID Context,
    IN PCM_PARTIAL_RESOURCE_DESCRIPTOR Source,
    IN RESOURCE_TRANSLATION_DIRECTION Direction,
    IN ULONG AlternativesCount, OPTIONAL
    IN IO_RESOURCE_DESCRIPTOR Alternatives[], OPTIONAL
    IN PDEVICE_OBJECT PhysicalDeviceObject,
    OUT PCM_PARTIAL_RESOURCE_DESCRIPTOR Target
    )
/*++

Routine Description:

    This function is basically a wrapper for
    HalIrqTranslateResourcesRoot that understands
    the weirdnesses of the ISA bus.

Arguments:

Return Value:

    status

--*/
{
    CM_PARTIAL_RESOURCE_DESCRIPTOR modSource;
    NTSTATUS    status;
    BOOLEAN     usePicSlave = FALSE;
    ULONG       i;

    modSource = *Source;

    if (Direction == TranslateChildToParent) {

        if (Source->u.Interrupt.Vector == PIC_SLAVE_IRQ) {
            modSource.u.Interrupt.Vector = PIC_SLAVE_REDIRECT;
            modSource.u.Interrupt.Level = PIC_SLAVE_REDIRECT;
        }
    }

    status = HalIrqTranslateResourcesRoot(
                Context,
                &modSource,
                Direction,
                AlternativesCount,
                Alternatives,
                PhysicalDeviceObject,
                Target);

    if (!NT_SUCCESS(status)) {
        return status;
    }

    if (Direction == TranslateParentToChild) {

        //
        // Because the ISA interrupt controller is
        // cascaded, there is one case where there is
        // a two-to-one mapping for interrupt sources.
        // (On a PC, both 2 and 9 trigger vector 9.)
        //
        // We need to account for this and deliver the
        // right value back to the driver.
        //

        if (Target->u.Interrupt.Level == PIC_SLAVE_REDIRECT) {

            //
            // Search the Alternatives list.  If it contains
            // PIC_SLAVE_IRQ but not PIC_SLAVE_REDIRECT,
            // we should return PIC_SLAVE_IRQ.
            //

            for (i = 0; i < AlternativesCount; i++) {

                if ((Alternatives[i].u.Interrupt.MinimumVector >= PIC_SLAVE_REDIRECT) &&
                    (Alternatives[i].u.Interrupt.MaximumVector <= PIC_SLAVE_REDIRECT)) {

                    //
                    // The list contains, PIC_SLAVE_REDIRECT.  Stop
                    // looking.
                    //

                    usePicSlave = FALSE;
                    break;
                }

                if ((Alternatives[i].u.Interrupt.MinimumVector >= PIC_SLAVE_IRQ) &&
                    (Alternatives[i].u.Interrupt.MaximumVector <= PIC_SLAVE_IRQ)) {

                    //
                    // The list contains, PIC_SLAVE_IRQ.  Use it
                    // unless we find PIC_SLAVE_REDIRECT later.
                    //

                    usePicSlave = TRUE;
                }
            }

            if (usePicSlave) {

                Target->u.Interrupt.Level  = PIC_SLAVE_IRQ;
                Target->u.Interrupt.Vector = PIC_SLAVE_IRQ;
            }
        }
    }

    return status;
}

VOID
HalpRecordEisaInterruptVectors(
    VOID
    )
{
    HalpEisaIrqMask = READ_PORT_UCHAR((PUCHAR)EISA_EDGE_LEVEL0) & 0xff;
    HalpEisaIrqMask |= READ_PORT_UCHAR((PUCHAR)EISA_EDGE_LEVEL1) << 8;

    if ((HalpEisaIrqMask == 0xffff) ||
        (HalpEisaIrqMask == 0x0000)) {

        HalpEisaIrqIgnore = 0xffff;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halx86\i386\ixisasup.c ===
/*++


Copyright (c) 1989  Microsoft Corporation

Module Name:

    ixhwsup.c

Abstract:

    This module contains the IoXxx routines for the NT I/O system that
    are hardware dependent.  Were these routines not hardware dependent,
    they would reside in the iosubs.c module.

Author:

    Darryl E. Havens (darrylh) 11-Apr-1990

Environment:

    Kernel mode

Revision History:


--*/

#include "halp.h"
#include "eisa.h"
#include "pci.h"

#include "pcip.h"


//
//Only take the prototype, don't instantiate
//
#include <wdmguid.h>

#include "halpnpp.h"

#ifdef ALLOC_PRAGMA
        #pragma alloc_text(PAGE,HalGetAdapter)
        #pragma alloc_text(PAGE,HalpGetIsaIrqState)
#endif

//
// The HalpNewAdapter event is used to serialize allocations
// of new adapter objects, additions to the HalpEisaAdapter
// array, and some global values (MasterAdapterObject) and some
// adapter fields modified by HalpGrowMapBuffers.
// (AdapterObject->NumberOfMapRegisters is assumed not to be
// growable while this even is held)
//
// Note: We don't really need our own an event object for this.
//

#ifndef ACPI_HAL

#define HalpNewAdapter HalpBusDatabaseEvent
extern KEVENT   HalpNewAdapter;

#else

KEVENT   HalpNewAdapter;

//
//F-Type DMA interface globals
//
ISA_FTYPE_DMA_INTERFACE HalpFDMAInterface;
ULONG  HalpFDMAAvail=FALSE;
ULONG  HalpFDMAChecked=FALSE;
#endif

#define ACQUIRE_NEW_ADAPTER_LOCK()  \
{                                   \
    KeWaitForSingleObject (         \
        &HalpNewAdapter,            \
        WrExecutive,                \
        KernelMode,                 \
        FALSE,                      \
        NULL                        \
        );                          \
}

#define RELEASE_NEW_ADAPTER_LOCK()  \
    KeSetEvent (&HalpNewAdapter, 0, FALSE)

PVOID HalpEisaControlBase = 0;
extern KSPIN_LOCK HalpSystemHardwareLock;

//
// Define save area for EISA adapter objects.
//

PADAPTER_OBJECT HalpEisaAdapter[8];

//
// DMA channel control values
// Global, so zero initialized by the compiler.
//
DMA_CHANNEL_CONTEXT HalpDmaChannelState [EISA_DMA_CHANNELS] ;


extern USHORT HalpEisaIrqMask;


//
// Keep a list of all the dma adapters for debugging purposes
//
LIST_ENTRY HalpDmaAdapterList;
KSPIN_LOCK HalpDmaAdapterListLock;

VOID
HalpCopyBufferMap(
                 IN PMDL Mdl,
                 IN PTRANSLATION_ENTRY TranslationEntry,
                 IN PVOID CurrentVa,
                 IN ULONG Length,
                 IN BOOLEAN WriteToDevice
                 );

PHYSICAL_ADDRESS
HalpMapTransfer(
               IN PADAPTER_OBJECT AdapterObject,
               IN PMDL Mdl,
               IN PVOID MapRegisterBase,
               IN PVOID CurrentVa,
               IN OUT PULONG Length,
               IN BOOLEAN WriteToDevice
               );

VOID
HalpMapTransferHelper(
                     IN PMDL Mdl,
                     IN PVOID CurrentVa,
                     IN ULONG TransferLength,
                     IN PPFN_NUMBER PageFrame,
                     IN OUT PULONG Length
                     );



NTSTATUS
HalAllocateAdapterChannel(
                         IN PADAPTER_OBJECT AdapterObject,
                         IN PWAIT_CONTEXT_BLOCK Wcb,
                         IN ULONG NumberOfMapRegisters,
                         IN PDRIVER_CONTROL ExecutionRoutine
                         )
/*++

Routine Description:

    This routine allocates the adapter channel specified by the adapter object.
    This is accomplished by placing the device object of the driver that wants
    to allocate the adapter on the adapter's queue.  If the queue is already
    "busy", then the adapter has already been allocated, so the device object
    is simply placed onto the queue and waits until the adapter becomes free.

    Once the adapter becomes free (or if it already is), then the driver's
    execution routine is invoked.

    Also, a number of map registers may be allocated to the driver by specifying
    a non-zero value for NumberOfMapRegisters.  Then the map register must be
    allocated from the master adapter.  Once there are a sufficient number of
    map registers available, then the execution routine is called and the
    base address of the allocated map registers in the adapter is also passed
    to the driver's execution routine.

Arguments:

    AdapterObject - Pointer to the adapter control object to allocate to the
        driver.

    Wcb - Supplies a wait context block for saving the allocation parameters.
        The DeviceObject, CurrentIrp and DeviceContext should be initalized.

    NumberOfMapRegisters - The number of map registers that are to be allocated
        from the channel, if any.

    ExecutionRoutine - The address of the driver's execution routine that is
        invoked once the adapter channel (and possibly map registers) have been
        allocated.

Return Value:

    Returns STATUS_SUCESS unless too many map registers are requested.

Notes:

    Note that this routine MUST be invoked at DISPATCH_LEVEL or above.

--*/
{

    PADAPTER_OBJECT MasterAdapter;
    BOOLEAN Busy = FALSE;
    IO_ALLOCATION_ACTION Action;
    KIRQL Irql;
    ULONG MapRegisterNumber;

    //
    // Begin by obtaining a pointer to the master adapter associated with this
    // request.
    //

    MasterAdapter = AdapterObject->MasterAdapter;

    //
    // Initialize the device object's wait context block in case this device
    // must wait before being able to allocate the adapter.
    //

    Wcb->DeviceRoutine = ExecutionRoutine;
    Wcb->NumberOfMapRegisters = NumberOfMapRegisters;

    //
    // Allocate the adapter object for this particular device.  If the
    // adapter cannot be allocated because it has already been allocated
    // to another device, then return to the caller now;  otherwise,
    // continue.
    //

    if (!KeInsertDeviceQueue( &AdapterObject->ChannelWaitQueue,
                              &Wcb->WaitQueueEntry )) {

        //
        // Save the parameters in case there are not enough map registers.
        //

        AdapterObject->NumberOfMapRegisters = NumberOfMapRegisters;
        AdapterObject->CurrentWcb = Wcb;

        //
        // The adapter was not busy so it has been allocated.  Now check
        // to see whether this driver wishes to allocate any map registers.
        // Ensure that this adapter has enough total map registers
        // to satisfy the request.
        //

        if (NumberOfMapRegisters != 0 && AdapterObject->NeedsMapRegisters) {

            //
            // Lock the map register bit map and the adapter queue in the
            // master adapter object. The channel structure offset is used as
            // a hint for the register search.
            //

            if (NumberOfMapRegisters > AdapterObject->MapRegistersPerChannel) {
                AdapterObject->NumberOfMapRegisters = 0;
                IoFreeAdapterChannel(AdapterObject);
                return (STATUS_INSUFFICIENT_RESOURCES);
            }

            KeAcquireSpinLock( &MasterAdapter->SpinLock, &Irql );

            MapRegisterNumber = (ULONG)-1;

            if (IsListEmpty( &MasterAdapter->AdapterQueue)) {

                MapRegisterNumber = RtlFindClearBitsAndSet(
                                                  MasterAdapter->MapRegisters,
                                                  NumberOfMapRegisters,
                                                  0
                                                  );
            }

            if (MapRegisterNumber == -1) {

                PBUFFER_GROW_WORK_ITEM bufferWorkItem;

                //
                // There were not enough free map registers.  Queue this request
                // on the master adapter where is will wait until some registers
                // are deallocated.
                //

                InsertTailList( &MasterAdapter->AdapterQueue,
                                &AdapterObject->AdapterQueue
                              );
                Busy = 1;

                //
                // Queue a work item to grow the map registers
                //

                bufferWorkItem =
                    ExAllocatePoolWithTag( NonPagedPool,
                                           sizeof(BUFFER_GROW_WORK_ITEM),
                                           HAL_POOL_TAG);
                if (bufferWorkItem != NULL) {

                    ExInitializeWorkItem( &bufferWorkItem->WorkItem,
                                          HalpGrowMapBufferWorker,
                                          bufferWorkItem );

                    bufferWorkItem->AdapterObject = AdapterObject;
                    bufferWorkItem->MapRegisterCount = NumberOfMapRegisters;

                    ExQueueWorkItem( &bufferWorkItem->WorkItem,
                                     DelayedWorkQueue );

               }

            } else {

                //
                // Calculate the map register base from the allocated map
                // register and base of the master adapter object.
                //

                AdapterObject->MapRegisterBase = ((PTRANSLATION_ENTRY)
                          MasterAdapter->MapRegisterBase + MapRegisterNumber);

                //
                // Set the no scatter/gather flag if scatter/gather not
                // supported.
                //

                if (!AdapterObject->ScatterGather) {

                    AdapterObject->MapRegisterBase = (PVOID)
                     ((ULONG_PTR) AdapterObject->MapRegisterBase | NO_SCATTER_GATHER);

                }
            }

            KeReleaseSpinLock( &MasterAdapter->SpinLock, Irql );

        } else {

            AdapterObject->MapRegisterBase = NULL;
            AdapterObject->NumberOfMapRegisters = 0;
        }

        //
        // If there were either enough map registers available or no map
        // registers needed to be allocated, invoke the driver's execution
        // routine now.
        //

        if (!Busy) {

            AdapterObject->CurrentWcb = Wcb;
            Action = ExecutionRoutine( Wcb->DeviceObject,
                                       Wcb->CurrentIrp,
                                       AdapterObject->MapRegisterBase,
                                       Wcb->DeviceContext );

            //
            // If the driver would like to have the adapter deallocated,
            // then release the adapter object.
            //

            if (Action == DeallocateObject) {

                IoFreeAdapterChannel( AdapterObject );

            } else if (Action == DeallocateObjectKeepRegisters) {

                //
                // Set the NumberOfMapRegisters  = 0 in the adapter object.
                // This will keep IoFreeAdapterChannel from freeing the
                // registers. After this it is the driver's responsiblity to
                // keep track of the number of map registers.
                //

                AdapterObject->NumberOfMapRegisters = 0;
                IoFreeAdapterChannel(AdapterObject);

            }
        }
    }

    return (STATUS_SUCCESS);

}

#if defined(_WIN64)

NTSTATUS
HalRealAllocateAdapterChannel(
    IN PADAPTER_OBJECT AdapterObject,
    IN PDEVICE_OBJECT DeviceObject,
    IN ULONG NumberOfMapRegisters,
    IN PDRIVER_CONTROL ExecutionRoutine,
    IN PVOID Context
    )

/*++

Routine Description:

    This routine allocates the adapter channel specified by the adapter object.
    This is accomplished by calling HalAllocateAdapterChannel which does all of
    the work.

Arguments:

    AdapterObject - Pointer to the adapter control object to allocate to the
        driver.

    DeviceObject - Pointer to the driver's device object that represents the
        device allocating the adapter.

    NumberOfMapRegisters - The number of map registers that are to be allocated
        from the channel, if any.

    ExecutionRoutine - The address of the driver's execution routine that is
        invoked once the adapter channel (and possibly map registers) have been
        allocated.

    Context - An untyped longword context parameter passed to the driver's
        execution routine.

Return Value:

    Returns STATUS_SUCESS unless too many map registers are requested.

Notes:

    Note that this routine MUST be invoked at DISPATCH_LEVEL or above.

--*/

{
    PWAIT_CONTEXT_BLOCK wcb;

    wcb = &DeviceObject->Queue.Wcb;

    wcb->DeviceObject = DeviceObject;
    wcb->CurrentIrp = DeviceObject->CurrentIrp;
    wcb->DeviceContext = Context;

    return( HalAllocateAdapterChannel( AdapterObject,
                                       wcb,
                                       NumberOfMapRegisters,
                                       ExecutionRoutine ) );
}

#endif

VOID
HalpGrowMapBufferWorker(
    IN PVOID Context
    )

/*++

Routine Description:

    This routine is called in the context of a work item from
    HalAllocateAdapterChannel() when it queues a map register allocation
    because map regiers are not available.

    Its purpose is to attempt to grow the map buffers for the adapter and,
    if successful, process queued adapter allocations.

Arguments:

    Context - Actually a pointer to a BUFFER_GROW_WORK_ITEM structure.

Return Value:

    None.

--*/

{
    PBUFFER_GROW_WORK_ITEM growWorkItem;
    PADAPTER_OBJECT masterAdapter;
    BOOLEAN allocated;
    ULONG bytesToGrow;
    KIRQL oldIrql;

    growWorkItem = (PBUFFER_GROW_WORK_ITEM)Context;
    masterAdapter = growWorkItem->AdapterObject->MasterAdapter;

    //
    // HalpGrowMapBuffers() takes a byte count
    //

    bytesToGrow = growWorkItem->MapRegisterCount * PAGE_SIZE +
                  INCREMENT_MAP_BUFFER_SIZE;

    ACQUIRE_NEW_ADAPTER_LOCK();

    allocated = HalpGrowMapBuffers( masterAdapter,
                                    bytesToGrow );

    RELEASE_NEW_ADAPTER_LOCK();

    if (allocated != FALSE) {

        KeRaiseIrql( DISPATCH_LEVEL, &oldIrql );

        //
        // The map buffers were grown.  It is likely that someone is waiting
        // in the adapter queue, so try to get things started.
        //
        // The code in IoFreeMapRegisters() does this, and it turns out
        // we can safely get it to do this work for us by freeing 0
        // map registers at a bogus (but non-NULL) register base.
        //

        IoFreeMapRegisters( growWorkItem->AdapterObject,
                            (PVOID)2,
                            0 );

        KeLowerIrql( oldIrql );

    }

    ExFreePool( growWorkItem );
}



PVOID
HalAllocateCrashDumpRegisters(
                             IN PADAPTER_OBJECT AdapterObject,
                             IN PULONG NumberOfMapRegisters
                             )
/*++

Routine Description:

    This routine is called during the crash dump disk driver's initialization
    to allocate a number map registers permanently.

Arguments:

    AdapterObject - Pointer to the adapter control object to allocate to the
        driver.
    NumberOfMapRegisters - Number of map registers requested. This field
        will be updated to reflect the actual number of registers allocated
        when the number is less than what was requested.

Return Value:

    Returns STATUS_SUCESS if map registers allocated.

--*/
{
    PADAPTER_OBJECT MasterAdapter;
    ULONG MapRegisterNumber;

    //
    // Begin by obtaining a pointer to the master adapter associated with this
    // request.
    //

    MasterAdapter = AdapterObject->MasterAdapter;

    //
    // Check to see whether this driver needs to allocate any map registers.
    //

    if (AdapterObject->NeedsMapRegisters) {

        //
        // Ensure that this adapter has enough total map registers to satisfy
        // the request.
        //

        if (*NumberOfMapRegisters > AdapterObject->MapRegistersPerChannel) {
            AdapterObject->NumberOfMapRegisters = 0;
            return NULL;
        }

        //
        // Attempt to allocate the required number of map registers w/o
        // affecting those registers that were allocated when the system
        // crashed.
        //

        MapRegisterNumber = (ULONG)-1;

        MapRegisterNumber = RtlFindClearBitsAndSet(
                                                  MasterAdapter->MapRegisters,
                                                  *NumberOfMapRegisters,
                                                  0
                                                  );

        if (MapRegisterNumber == (ULONG)-1) {

            //
            // Not enough free map registers were found, so they were busy
            // being used by the system when it crashed.  Force the appropriate
            // number to be "allocated" at the base by simply overjamming the
            // bits and return the base map register as the start.
            //

            RtlSetBits(
                      MasterAdapter->MapRegisters,
                      0,
                      *NumberOfMapRegisters
                      );
            MapRegisterNumber = 0;

        }

        //
        // Calculate the map register base from the allocated map
        // register and base of the master adapter object.
        //

        AdapterObject->MapRegisterBase = ((PTRANSLATION_ENTRY)
                      MasterAdapter->MapRegisterBase + MapRegisterNumber);

        //
        // Set the no scatter/gather flag if scatter/gather not
        // supported.
        //

        if (!AdapterObject->ScatterGather) {

            AdapterObject->MapRegisterBase = (PVOID)
                 ((ULONG_PTR) AdapterObject->MapRegisterBase | NO_SCATTER_GATHER);

        }

    } else {

        AdapterObject->MapRegisterBase = NULL;
        AdapterObject->NumberOfMapRegisters = 0;
    }

    return AdapterObject->MapRegisterBase;
}

#ifdef ACPI_HAL

NTSTATUS
HalpFDMANotificationCallback(
                            IN PVOID NotificationStructure,
                            IN PVOID Context
                            )
{
    PAGED_CODE();

    //
    // Something is happening to the ISA bus that we've registered on.
    //

    if (IsEqualGUID (&((PTARGET_DEVICE_REMOVAL_NOTIFICATION)NotificationStructure)->Event,
                     &GUID_TARGET_DEVICE_QUERY_REMOVE)) {

        //
        // It's a query remove, just get out.
        // dereference the interface, and clean up our internal data
        //

        ACQUIRE_NEW_ADAPTER_LOCK();
        HalpFDMAInterface.InterfaceDereference(HalpFDMAInterface.Context);

        HalpFDMAAvail=FALSE;

        //
        // Set checked to false, so that if a new bus arrives we can begin anew.
        //

        HalpFDMAChecked=FALSE;
        RELEASE_NEW_ADAPTER_LOCK();

    }

    return STATUS_SUCCESS;
}

#endif


VOID
HalpAddAdapterToList(
    IN PADAPTER_OBJECT AdapterObject
    )
/*++

Routine Description:

    Adds the adapter object to the HalpDmaAdapterList. This is a separate
    function because HalGetAdapter is paged code and cannot acquire a spinlock.

Arguments:

    AdapterObject - Supplies the adapter object to be added to HalpDmaAdapterList

Return Value:

    None

--*/

{
    KIRQL Irql;

    KeAcquireSpinLock(&HalpDmaAdapterListLock,&Irql);
    InsertTailList(&HalpDmaAdapterList, &AdapterObject->AdapterList);
    KeReleaseSpinLock(&HalpDmaAdapterListLock, Irql);

}

PADAPTER_OBJECT
HalGetAdapter(
             IN PDEVICE_DESCRIPTION DeviceDescriptor,
             OUT PULONG NumberOfMapRegisters
             )

/*++

Routine Description:

    This function returns the appropriate adapter object for the device defined
    in the device description structure.  This code works for Isa and Eisa
    systems.

Arguments:

    DeviceDescriptor - Supplies a description of the deivce.

    NumberOfMapRegisters - Returns the maximum number of map registers which
        may be allocated by the device driver.

Return Value:

    A pointer to the requested adapter object or NULL if an adapter could not
    be created.

--*/

{
    PADAPTER_OBJECT adapterObject;
    PVOID adapterBaseVa;
    ULONG channelNumber;
    ULONG controllerNumber;
    DMA_EXTENDED_MODE extendedMode;
    UCHAR adapterMode;
    ULONG numberOfMapRegisters;
    BOOLEAN useChannel;
    ULONG maximumLength;
    UCHAR DataByte;
    BOOLEAN dma32Bit;
    BOOLEAN ChannelEnabled;
    KIRQL Irql;      

#ifdef ACPI_HAL
    NTSTATUS Status;
#endif

    PAGED_CODE();

    //
    // Make sure this is the correct version.
    //

    if (DeviceDescriptor->Version > DEVICE_DESCRIPTION_VERSION2) {
        return ( NULL );
    }

#if DBG
    if (DeviceDescriptor->Version == DEVICE_DESCRIPTION_VERSION1) {
            ASSERT (DeviceDescriptor->Reserved1 == FALSE);
    }
#endif

    *((PUCHAR) &extendedMode) = 0;
    
    //
    // Determine if the the channel number is important.  Master cards on
    // Eisa and Mca do not use a channel number.
    //

    if (DeviceDescriptor->InterfaceType != Isa &&
        DeviceDescriptor->Master) {

        useChannel = FALSE;
    } else {

        useChannel = TRUE;
    }

    // Support for ISA local bus machines:
    // If the driver is a Master but really does not want a channel since it
    // is using the local bus DMA, just don't use an ISA channel.
    //

    if (DeviceDescriptor->InterfaceType == Isa &&
        DeviceDescriptor->DmaChannel > 7) {

        useChannel = FALSE;
    }

    //
    // Determine if Eisa DMA is supported.
    //

    if (HalpBusType == MACHINE_TYPE_EISA) {

        WRITE_PORT_UCHAR(&((PEISA_CONTROL) HalpEisaControlBase)->DmaPageHighPort.Channel2, 0x55);
        DataByte = READ_PORT_UCHAR(&((PEISA_CONTROL) HalpEisaControlBase)->DmaPageHighPort.Channel2);

        if (DataByte == 0x55) {
                HalpEisaDma = TRUE;
        }
    }

    //
    // Limit the maximum length to 2 GB this is done so that the BYTES_TO_PAGES
    // macro works correctly.
    //

    maximumLength = DeviceDescriptor->MaximumLength & 0x7fffffff;

    //
    // Channel 4 cannot be used since it is used for chaining. Return null if
    // it is requested.
    //

    if (DeviceDescriptor->DmaChannel == 4 && useChannel) {
        return (NULL);
    }

    if (DeviceDescriptor->InterfaceType == PCIBus &&
        DeviceDescriptor->Master != FALSE &&
        DeviceDescriptor->ScatterGather != FALSE) {

        //
        // This device can handle 32 bits, even if the caller forgot to
        // set Dma32BitAddresses.
        //

        DeviceDescriptor->Dma32BitAddresses = TRUE;
    }

    dma32Bit = DeviceDescriptor->Dma32BitAddresses;

    //
    // Determine the number of map registers for this device.
    //

    if (DeviceDescriptor->ScatterGather &&

        //
        // If we are not in PAE mode or the device can handle 64 bit addresses,
        // then the device can DMA to any physical location
        //

        (HalPaeEnabled() == FALSE ||
         DeviceDescriptor->Dma64BitAddresses != FALSE) &&

        (LessThan16Mb ||
         DeviceDescriptor->InterfaceType == Eisa ||
         DeviceDescriptor->InterfaceType == PCIBus) ) {

        //
        // Since the device support scatter/Gather then map registers are not
        // required.
        //

        numberOfMapRegisters = 0;

    } else {

        ULONG maximumMapRegisters;
        ULONG mapBufferSize;

        maximumMapRegisters = HalpMaximumMapRegisters( dma32Bit );

        //
        // Determine the number of map registers required based on the maximum
        // transfer length, up to a maximum number.
        //

        numberOfMapRegisters = BYTES_TO_PAGES(maximumLength) + 1;

        if (numberOfMapRegisters > maximumMapRegisters) {
            numberOfMapRegisters = maximumMapRegisters;
        }

        //
        // Make sure there where enough registers allocated initalize to support
        // this size relaibly.  This implies there must be to chunks equal to
        // the allocatd size. This is only a problem on Isa systems where the
        // map buffers cannot cross 64KB boundtires.
        //

        mapBufferSize = HalpMapBufferSize( dma32Bit );

        if (!HalpEisaDma &&
            numberOfMapRegisters > mapBufferSize / (PAGE_SIZE * 2)) {

            numberOfMapRegisters = (mapBufferSize / (PAGE_SIZE * 2));
        }

        //
        // If the device is not a master then it only needs one map register
        // and does scatter/Gather.
        //

        if (DeviceDescriptor->ScatterGather && !DeviceDescriptor->Master) {

            numberOfMapRegisters = 1;
        }
    }

    //
    // Set the channel number number.
    //

    if (useChannel != FALSE) {

        channelNumber = DeviceDescriptor->DmaChannel & 0x03;

        //
        // Set the adapter base address to the Base address register and
        // controller number.
        //

        if (!(DeviceDescriptor->DmaChannel & 0x04)) {

            controllerNumber = 1;
            adapterBaseVa =
                (PVOID) &((PEISA_CONTROL) HalpEisaControlBase)->Dma1BasePort;

        } else {

            controllerNumber = 2;
            adapterBaseVa =
                &((PEISA_CONTROL) HalpEisaControlBase)->Dma2BasePort;

        }
    } else {

        adapterBaseVa = NULL;
    }

    //
    // Determine if a new adapter object is necessary.  If so then allocate it.
    //

    if (useChannel && HalpEisaAdapter[DeviceDescriptor->DmaChannel] != NULL) {

        adapterObject = HalpEisaAdapter[DeviceDescriptor->DmaChannel];

        if (adapterObject->NeedsMapRegisters) {

            if (numberOfMapRegisters > adapterObject->MapRegistersPerChannel) {

                adapterObject->MapRegistersPerChannel = numberOfMapRegisters;
            }
        }

    } else {

        //
        // Serialize before allocating a new adapter
        //

        ACQUIRE_NEW_ADAPTER_LOCK();

        //
        // Determine if a new adapter object has already been allocated.
        // If so use it, otherwise allocate a new adapter object
        //

        if (useChannel && HalpEisaAdapter[DeviceDescriptor->DmaChannel] != NULL) {

            adapterObject = HalpEisaAdapter[DeviceDescriptor->DmaChannel];

            if (adapterObject->NeedsMapRegisters) {

                if (numberOfMapRegisters > adapterObject->MapRegistersPerChannel) {

                    adapterObject->MapRegistersPerChannel = numberOfMapRegisters;
                }
            }

        } else {

            //
            // Allocate an adapter object.
            //

            adapterObject =
                (PADAPTER_OBJECT) HalpAllocateAdapterEx( numberOfMapRegisters,
                                                         adapterBaseVa,
                                                         NULL,
                                                         dma32Bit );
            if (adapterObject == NULL) {
                RELEASE_NEW_ADAPTER_LOCK();
                return (NULL);
            }

            if (useChannel) {

                HalpEisaAdapter[DeviceDescriptor->DmaChannel] = adapterObject;

            }

            //
            // Set the maximum number of map registers for this channel bus on
            // the number requested and the type of device.
            //

            if (numberOfMapRegisters) {

                PADAPTER_OBJECT masterAdapterObject;

                masterAdapterObject =
                    HalpMasterAdapter( dma32Bit );

                //
                // The speicified number of registers are actually allowed to be
                // allocated.
                //

                adapterObject->MapRegistersPerChannel = numberOfMapRegisters;

                //
                // Increase the commitment for the map registers.
                //

                if (DeviceDescriptor->Master) {

                    //
                    // Master I/O devices use several sets of map registers double
                    // their commitment.
                    //

                    masterAdapterObject->CommittedMapRegisters +=
                    numberOfMapRegisters * 2;

                } else {

                    masterAdapterObject->CommittedMapRegisters +=
                    numberOfMapRegisters;

                }

                //
                // If the committed map registers is signicantly greater than the
                // number allocated then grow the map buffer.
                //

                if (masterAdapterObject->CommittedMapRegisters >
                    masterAdapterObject->NumberOfMapRegisters  ) {

                    HalpGrowMapBuffers(
                                      masterAdapterObject,
                                      INCREMENT_MAP_BUFFER_SIZE
                                      );
                }

                adapterObject->NeedsMapRegisters = TRUE;

            } else {

                //
                // No real map registers were allocated.  If this is a master
                // device, then the device can have as may registers as it wants.
                //

                adapterObject->NeedsMapRegisters = FALSE;

                if (DeviceDescriptor->Master) {

                    adapterObject->MapRegistersPerChannel =
                                BYTES_TO_PAGES( maximumLength ) + 1;

                } else {

                    //
                    // The device only gets one register.  It must call
                    // IoMapTransfer repeatedly to do a large transfer.
                    //

                    adapterObject->MapRegistersPerChannel = 1;
                }
            }
        }

        RELEASE_NEW_ADAPTER_LOCK();
    }

    adapterObject->IgnoreCount = FALSE;
    if (DeviceDescriptor->Version >= DEVICE_DESCRIPTION_VERSION1) {

        //
        // Move version 1 structure flags.
        // IgnoreCount is used on machines where the DMA Counter
        // is broken.  (Namely PS/1 model 1000s).  Setting this
        // bit informs the hal not to rely on the DmaCount to determine
        // how much data was DMAed.
        //

        adapterObject->IgnoreCount = DeviceDescriptor->IgnoreCount;
    }

    adapterObject->Dma32BitAddresses = DeviceDescriptor->Dma32BitAddresses;
    adapterObject->Dma64BitAddresses = DeviceDescriptor->Dma64BitAddresses;
    adapterObject->ScatterGather = DeviceDescriptor->ScatterGather;
    *NumberOfMapRegisters = adapterObject->MapRegistersPerChannel;
    adapterObject->LegacyAdapter = (DeviceDescriptor->InterfaceType != PCIBus);

    if (DeviceDescriptor->Master) {

        adapterObject->MasterDevice = TRUE;

    } else {

        adapterObject->MasterDevice = FALSE;

    }

    //
    // If the channel number is not used then we are finished.  The rest of
    // the work deals with channels.
    //

    if (!useChannel) {

        //
        // Add this adapter to our list
        //
        HalpAddAdapterToList(adapterObject);

        return (adapterObject);
    }

    //
    // Setup the pointers to all the random registers.
    //

    adapterObject->ChannelNumber = (UCHAR) channelNumber;

    if (controllerNumber == 1) {

        switch ((UCHAR)channelNumber) {

            case 0:
                adapterObject->PagePort = (PUCHAR) &((PDMA_PAGE) 0)->Channel0;
                break;

            case 1:
                adapterObject->PagePort = (PUCHAR) &((PDMA_PAGE) 0)->Channel1;
                break;

            case 2:
                adapterObject->PagePort = (PUCHAR) &((PDMA_PAGE) 0)->Channel2;
                break;

            case 3:
                adapterObject->PagePort = (PUCHAR) &((PDMA_PAGE) 0)->Channel3;
                break;
        }

        //
        // Set the adapter number.
        //

        adapterObject->AdapterNumber = 1;

        //
        // Save the extended mode register address.
        //

        adapterBaseVa =
        &((PEISA_CONTROL) HalpEisaControlBase)->Dma1ExtendedModePort;

    } else {

        switch (channelNumber) {
            case 1:
                adapterObject->PagePort = (PUCHAR) &((PDMA_PAGE) 0)->Channel5;
                break;

            case 2:
                adapterObject->PagePort = (PUCHAR) &((PDMA_PAGE) 0)->Channel6;
                break;

            case 3:
                adapterObject->PagePort = (PUCHAR) &((PDMA_PAGE) 0)->Channel7;
                break;
        }

        //
        // Set the adapter number.
        //

        adapterObject->AdapterNumber = 2;

        //
        // Save the extended mode register address.
        //
        adapterBaseVa =
        &((PEISA_CONTROL) HalpEisaControlBase)->Dma2ExtendedModePort;

    }


    adapterObject->Width16Bits = FALSE;


#ifdef ACPI_HAL


    //
    //Keep this code here, because if we ever support dynamic ISA buses (ok, ok, stop laughing)
    //We'll want to be able to re-instantiate the interface to the ISAPNP driver for the new bus
    //

    //
    //Get the interface to the ISA bridge iff it supports an
    //interface to F-type DMA support
    //
    if (DeviceDescriptor->DmaSpeed == TypeF) {
        if (!HalpFDMAChecked) {
            PWSTR HalpFDMAInterfaceList;

            Status=IoGetDeviceInterfaces (&GUID_FDMA_INTERFACE_PRIVATE,NULL,0,&HalpFDMAInterfaceList);

            if (!NT_SUCCESS (Status)) {
                HalpFDMAAvail=FALSE;
            } else {

                if (HalpFDMAInterfaceList) {
                    HalpFDMAAvail=TRUE;
                }
            }
            HalpFDMAChecked=TRUE;

            //
            // Motherboard devices TypeF dma support
            //

            if (HalpFDMAAvail) {

                PDEVICE_OBJECT HalpFDMADevObj;
                PFILE_OBJECT HalpFDMAFileObject;
                PIRP irp;
                KEVENT irpCompleted;
                IO_STATUS_BLOCK statusBlock;
                PIO_STACK_LOCATION irpStack;
                UNICODE_STRING localInterfaceName;

                //
                // Convert the symbolic link to an object reference
                //

                RtlInitUnicodeString (&localInterfaceName,HalpFDMAInterfaceList);
                Status = IoGetDeviceObjectPointer (&localInterfaceName,
                                                   FILE_ALL_ACCESS,
                                                   &HalpFDMAFileObject,
                                                   &HalpFDMADevObj);

                
                ExFreePool (HalpFDMAInterfaceList);

                if (NT_SUCCESS (Status)) {
                    PVOID HalpFDMANotificationHandle;

                    //
                    // Setup the IRP to get the interface
                    //

                    KeInitializeEvent(&irpCompleted, SynchronizationEvent, FALSE);

                    irp = IoBuildSynchronousFsdRequest(IRP_MJ_PNP,
                                                       HalpFDMADevObj,
                                                       NULL,    // Buffer
                                                       0,       // Length
                                                       0,       // StartingOffset
                                                       &irpCompleted,
                                                       &statusBlock
                                                      );


                    if (!irp) {
                            HalpFDMAAvail=FALSE;
                            goto noFtype;
                    }

                    irp->IoStatus.Status = STATUS_NOT_SUPPORTED;
                    irp->IoStatus.Information = 0;

                    //
                    // Initialize the stack location
                    //

                    irpStack = IoGetNextIrpStackLocation(irp);

                    ASSERT(irpStack->MajorFunction == IRP_MJ_PNP);

                    irpStack->MinorFunction = IRP_MN_QUERY_INTERFACE;
                    irpStack->Parameters.QueryInterface.InterfaceType =
                        &GUID_ISA_FDMA_INTERFACE;

                    irpStack->Parameters.QueryInterface.Size =
                        sizeof(ISA_FTYPE_DMA_INTERFACE);

                    irpStack->Parameters.QueryInterface.Version = 1;
                    irpStack->Parameters.QueryInterface.Interface =
                        (PINTERFACE) &HalpFDMAInterface;

                    //
                    // Call the driver and wait for completion
                    //

                    Status = IoCallDriver(HalpFDMADevObj, irp);

                    if (Status == STATUS_PENDING) {

                        KeWaitForSingleObject(&irpCompleted,
                                              Executive,
                                              KernelMode,
                                              FALSE,
                                              NULL);

                        Status = statusBlock.Status;
                    }

                    if (!NT_SUCCESS(Status)) {
                        HalpFDMAAvail=FALSE;
                        goto noFtype;
                    }

                    //
                    // Now, register a callback so that the ISA bus can go
                    // away.
                    //

                    IoRegisterPlugPlayNotification (EventCategoryTargetDeviceChange,
                                                    0,
                                                    HalpFDMAFileObject,
                                                    HalpFDMADevObj->DriverObject,
                                                    HalpFDMANotificationCallback,
                                                    0,
                                                    &HalpFDMANotificationHandle);

                    //
                    // Release the handle to the interface from IoGetDevicePointer
                    //

                    ObDereferenceObject (HalpFDMAFileObject);

                } else {

                    HalpFDMAAvail=FALSE;
                }
            }
        }

        if (HalpFDMAAvail) {
            ULONG chMask;

            //
            // Fence this, so that no two people can ask for F-Type at once.
            //

            ACQUIRE_NEW_ADAPTER_LOCK();
            Status = HalpFDMAInterface.IsaSetFTypeChannel (HalpFDMAInterface.Context,DeviceDescriptor->DmaChannel,&chMask);
            RELEASE_NEW_ADAPTER_LOCK();

#if DBG
            if (!(NT_SUCCESS (Status))) {

                DbgPrint ("HAL: Tried to get F-Type DMA for channel %d, "
                          "but channel Mask %X already has it!\n",
                          channelNumber,
                          chMask);
            }
#endif
        }

    }
    noFtype:

#endif

    if (HalpEisaDma) {

        //
        // Initialzie the extended mode port.
        //

        extendedMode.ChannelNumber = (UCHAR)channelNumber;

        switch (DeviceDescriptor->DmaSpeed) {
            case Compatible:
                extendedMode.TimingMode = COMPATIBLITY_TIMING;
                break;

            case TypeA:
                extendedMode.TimingMode = TYPE_A_TIMING;
                break;

            case TypeB:
                extendedMode.TimingMode = TYPE_B_TIMING;
                break;

            case TypeC:
                extendedMode.TimingMode = BURST_TIMING;
                break;

            case TypeF:

                //
                // DMA chip should be set to compatibility mode
                // and the bridge handles type-f
                //

                extendedMode.TimingMode = COMPATIBLITY_TIMING;
                break;

            default:
                ObDereferenceObject( adapterObject );
                return (NULL);

        }

        switch (DeviceDescriptor->DmaWidth) {
            case Width8Bits:
                extendedMode.TransferSize = BY_BYTE_8_BITS;
                break;

            case Width16Bits:
                extendedMode.TransferSize = BY_BYTE_16_BITS;

                //
                // Note Width16bits should not be set here because there is no need
                // to shift the address and the transfer count.
                //

                break;

            case Width32Bits:
                extendedMode.TransferSize = BY_BYTE_32_BITS;
                break;

            default:
                ObDereferenceObject( adapterObject );
                return (NULL);

        }

        WRITE_PORT_UCHAR( adapterBaseVa, *((PUCHAR) &extendedMode));

    } else if (!DeviceDescriptor->Master) {

        switch (DeviceDescriptor->DmaWidth) {
            case Width8Bits:

                //
                // The channel must use controller 1.
                //

                if (controllerNumber != 1) {
                    ObDereferenceObject( adapterObject );
                    return (NULL);
                }

                break;

            case Width16Bits:

                //
                // The channel must use controller 2.
                //

                if (controllerNumber != 2) {
                    ObDereferenceObject( adapterObject );
                    return (NULL);
                }

                adapterObject->Width16Bits = TRUE;
                break;

            default:
                ObDereferenceObject( adapterObject );
                return (NULL);

        }
    }

    //
    // Initialize the adapter mode register value to the correct parameters,
    // and save them in the adapter object.
    //
    ChannelEnabled = FALSE;
    adapterMode = 0;
    ((PDMA_EISA_MODE) &adapterMode)->Channel = adapterObject->ChannelNumber;

    if (DeviceDescriptor->Master) {
        ChannelEnabled = TRUE;

        ((PDMA_EISA_MODE) &adapterMode)->RequestMode = CASCADE_REQUEST_MODE;

        //
        // Set the mode, and enable the request.
        //

        if (adapterObject->AdapterNumber == 1) {

            //
            // This request is for DMA controller 1
            //

            PDMA1_CONTROL dmaControl;

            dmaControl = adapterObject->AdapterBaseVa;

            WRITE_PORT_UCHAR( &dmaControl->Mode, adapterMode );

            //
            // Unmask the DMA channel.
            //

            WRITE_PORT_UCHAR(
                        &dmaControl->SingleMask,
                        (UCHAR) (DMA_CLEARMASK | adapterObject->ChannelNumber)
                        );

        } else {

            //
            // This request is for DMA controller 2
            //

            PDMA2_CONTROL dmaControl;

            dmaControl = adapterObject->AdapterBaseVa;

            WRITE_PORT_UCHAR( &dmaControl->Mode, adapterMode );

            //
            // Unmask the DMA channel.
            //

            WRITE_PORT_UCHAR(
                        &dmaControl->SingleMask,
                        (UCHAR) (DMA_CLEARMASK | adapterObject->ChannelNumber)
                        );

        }

    } else if (DeviceDescriptor->DemandMode) {

        ((PDMA_EISA_MODE) &adapterMode)->RequestMode = DEMAND_REQUEST_MODE;

    } else {

        ((PDMA_EISA_MODE) &adapterMode)->RequestMode = SINGLE_REQUEST_MODE;

    }

    if (DeviceDescriptor->AutoInitialize) {

        ((PDMA_EISA_MODE) &adapterMode)->AutoInitialize = 1;

    }

    adapterObject->AdapterMode = adapterMode;

    //
    // Store the value we wrote to the Mode and Mask registers so that we
    // can restore it after the machine sleeps.
    //

    HalpDmaChannelState [adapterObject->ChannelNumber + ((adapterObject->AdapterNumber - 1) * 4)].ChannelMode =
    adapterMode;
    HalpDmaChannelState [adapterObject->ChannelNumber + ((adapterObject->AdapterNumber - 1) * 4)].ChannelExtendedMode =
    *((PUCHAR)&extendedMode);

    HalpDmaChannelState [adapterObject->ChannelNumber + ((adapterObject->AdapterNumber - 1) * 4)].ChannelMask = (ChannelEnabled) ?
        (UCHAR) (DMA_CLEARMASK | adapterObject->ChannelNumber):
            (UCHAR) (DMA_SETMASK | adapterObject->ChannelNumber);

    HalpDmaChannelState [adapterObject->ChannelNumber + ((adapterObject->AdapterNumber - 1) * 4)].ChannelProgrammed = TRUE;

    return (adapterObject);
}


PHYSICAL_ADDRESS
IoMapTransfer(
             IN PADAPTER_OBJECT AdapterObject,
             IN PMDL Mdl,
             IN PVOID MapRegisterBase,
             IN PVOID CurrentVa,
             IN OUT PULONG Length,
             IN BOOLEAN WriteToDevice
             )

/*++

Routine Description:

    This routine is invoked to set up the map registers in the DMA controller
    to allow a transfer to or from a device.

Arguments:

    AdapterObject - Pointer to the adapter object representing the DMA
        controller channel that has been allocated.

    Mdl - Pointer to the MDL that describes the pages of memory that are
        being read or written.

    MapRegisterBase - The address of the base map register that has been
        allocated to the device driver for use in mapping the transfer.

    CurrentVa - Current virtual address in the buffer described by the MDL
        that the transfer is being done to or from.

    Length - Supplies the length of the transfer.  This determines the
        number of map registers that need to be written to map the transfer.
        Returns the length of the transfer which was actually mapped.

    WriteToDevice - Boolean value that indicates whether this is a write
        to the device from memory (TRUE), or vice versa.

Return Value:

    Returns the logical address that should be used bus master controllers.

--*/

{
    ULONG transferLength;
    PHYSICAL_ADDRESS returnAddress;
    PPFN_NUMBER pageFrame;
    ULONG pageOffset;

    //
    // If the adapter is a 32-bit bus master, take the fast path,
    // otherwise call HalpMapTransfer for the slow path
    //

    if (MapRegisterBase == NULL) {

        pageOffset = BYTE_OFFSET(CurrentVa);

        //
        // Calculate how much of the transfer is contiguous
        //
        transferLength = PAGE_SIZE - pageOffset;
        pageFrame = MmGetMdlPfnArray(Mdl);
        pageFrame += ((ULONG_PTR) CurrentVa - (ULONG_PTR) MmGetMdlBaseVa(Mdl)) >> PAGE_SHIFT;

        //
        // Compute the starting address of the transfer
        //
        returnAddress.QuadPart =
            ((ULONG64)*pageFrame << PAGE_SHIFT) + pageOffset;

        //
        // If the transfer is not completely contained within
        // a page, call the helper to compute the appropriate
        // length.
        //
        if (transferLength < *Length) {
                HalpMapTransferHelper(Mdl, CurrentVa, transferLength, pageFrame, Length);
        }
        return (returnAddress);
    }

    return (HalpMapTransfer(AdapterObject,
                            Mdl,
                            MapRegisterBase,
                            CurrentVa,
                            Length,
                            WriteToDevice));

}


VOID
HalpMapTransferHelper(
                     IN PMDL Mdl,
                     IN PVOID CurrentVa,
                     IN ULONG TransferLength,
                     IN PPFN_NUMBER PageFrame,
                     IN OUT PULONG Length
                     )

/*++

Routine Description:

    Helper routine for bus master transfers that cross a page
    boundary.  This routine is separated out from the IoMapTransfer
    fast path in order to minimize the total instruction path
    length taken for the common network case where the entire
    buffer being mapped is contained within one page.

Arguments:

    Mdl - Pointer to the MDL that describes the pages of memory that are
        being read or written.

    CurrentVa - Current virtual address in the buffer described by the MDL
        that the transfer is being done to or from.

    TransferLength = Supplies the current transferLength

    PageFrame - Supplies a pointer to the starting page frame of the transfer

    Length - Supplies the length of the transfer.  This determines the
        number of map registers that need to be written to map the transfer.
        Returns the length of the transfer which was actually mapped.

Return Value:

    None.  *Length will be updated

--*/

{
    PFN_NUMBER thisPageFrame;
    PFN_NUMBER nextPageFrame;

    do {

        thisPageFrame = *PageFrame;
        PageFrame += 1;
        nextPageFrame = *PageFrame;

        if ((thisPageFrame + 1) != nextPageFrame) {

            //
            // The next page frame is not contiguous with this one,
            // so break the transfer here.
            //

            break;
        }

        if (((thisPageFrame ^ nextPageFrame) & 0xFFFFFFFFFFF00000UI64) != 0) {

            //
            // The next page frame is contiguous with this one,
            // but it crosses a 4GB boundary, another reason to
            // break the transfer.
            //

            break;
        }

        TransferLength += PAGE_SIZE;

    } while ( TransferLength < *Length );


    //
    // Limit the Length to the maximum TransferLength.
    //

    if (TransferLength < *Length) {
        *Length = TransferLength;
    }
}


PHYSICAL_ADDRESS
HalpMapTransfer(
               IN PADAPTER_OBJECT AdapterObject,
               IN PMDL Mdl,
               IN PVOID MapRegisterBase,
               IN PVOID CurrentVa,
               IN OUT PULONG Length,
               IN BOOLEAN WriteToDevice
               )

/*++

Routine Description:

    This routine is invoked to set up the map registers in the DMA controller
    to allow a transfer to or from a device.

Arguments:

    AdapterObject - Pointer to the adapter object representing the DMA
        controller channel that has been allocated.

    Mdl - Pointer to the MDL that describes the pages of memory that are
        being read or written.

    MapRegisterBase - The address of the base map register that has been
        allocated to the device driver for use in mapping the transfer.

    CurrentVa - Current virtual address in the buffer described by the MDL
        that the transfer is being done to or from.

    Length - Supplies the length of the transfer.  This determines the
        number of map registers that need to be written to map the transfer.
        Returns the length of the transfer which was actually mapped.

    WriteToDevice - Boolean value that indicates whether this is a write
        to the device from memory (TRUE), or vice versa.

Return Value:

    Returns the logical address that should be used bus master controllers.

--*/

{
    BOOLEAN useBuffer;
    ULONG transferLength;
    PHYSICAL_ADDRESS logicalAddress;
    PHYSICAL_ADDRESS returnAddress;
    ULONG index;
    PPFN_NUMBER pageFrame;
    PUCHAR bytePointer;
    UCHAR adapterMode;
    UCHAR dataByte;
    PTRANSLATION_ENTRY translationEntry;
    ULONG pageOffset;
    KIRQL   Irql;
    BOOLEAN masterDevice;
    PHYSICAL_ADDRESS maximumPhysicalAddress;

    masterDevice = AdapterObject == NULL || AdapterObject->MasterDevice ?
                   TRUE : FALSE;

    pageOffset = BYTE_OFFSET(CurrentVa);

#if DBG

    //
    // Catch slave mode devices that seem to want to try and have more than one
    // outstanding request.  If they do then the bus locks.
    //

    if (!masterDevice) {
        ASSERT (HalpDmaChannelState [AdapterObject->ChannelNumber + ((AdapterObject->AdapterNumber - 1) * 4)].ChannelBusy == FALSE);

        HalpDmaChannelState [AdapterObject->ChannelNumber + ((AdapterObject->AdapterNumber - 1) * 4)].ChannelBusy =
        TRUE;
    }
#endif

    //
    // Calculate how much of the transfer is contiguous.
    //

    transferLength = PAGE_SIZE - pageOffset;
    pageFrame = MmGetMdlPfnArray(Mdl);
    pageFrame += ((ULONG_PTR) CurrentVa - (ULONG_PTR) MmGetMdlBaseVa(Mdl)) >> PAGE_SHIFT;

    logicalAddress.QuadPart =
        (((ULONGLONG)*pageFrame) << PAGE_SHIFT) + pageOffset;

    //
    // If the buffer is contigous and does not cross a 64 K bountry then
    // just extend the buffer.  The 64 K bountry restriction does not apply
    // to Eisa systems.
    //

    if (HalpEisaDma) {

        while ( transferLength < *Length ) {

            if (*pageFrame + 1 != *(pageFrame + 1)) {
                break;
            }

            transferLength += PAGE_SIZE;
            pageFrame++;

        }

    } else {

        while ( transferLength < *Length ) {

            if (*pageFrame + 1 != *(pageFrame + 1) ||
                (*pageFrame & ~0x0f) != (*(pageFrame + 1) & ~0x0f)) {
                    break;
            }

            transferLength += PAGE_SIZE;
            pageFrame++;
        }
    }

    //
    // Limit the transferLength to the requested Length.
    //

    transferLength = transferLength > *Length ? *Length : transferLength;

    ASSERT(MapRegisterBase != NULL);

    //
    // Strip no scatter/gather flag.
    //

    translationEntry = (PTRANSLATION_ENTRY) ((ULONG_PTR) MapRegisterBase & ~NO_SCATTER_GATHER);

    if ((ULONG_PTR) MapRegisterBase & NO_SCATTER_GATHER
        && transferLength < *Length) {

        logicalAddress.QuadPart = translationEntry->PhysicalAddress + pageOffset;
        translationEntry->Index = COPY_BUFFER;
        index = 0;
        transferLength = *Length;
        useBuffer = TRUE;

    } else {

        //
        // If there are map registers, then update the index to indicate
        // how many have been used.
        //

        useBuffer = FALSE;
        index = translationEntry->Index;
        translationEntry->Index += ADDRESS_AND_SIZE_TO_SPAN_PAGES(
                                                                 CurrentVa,
                                                                 transferLength
                                                                 );
        //
        // PeterJ added the following to catch drivers which don't call
        // IoFlushAdapterBuffers.   Calling IoMapTransfer repeatedly
        // without calling IoFlushAdapterBuffers will run you out of
        // map registers,....  Some PCI device drivers think they can
        // get away with this because they do 32 bit direct transfers.
        // Try plugging one of these into a system with > 4GB and see
        // what happens to you.
        //
        ASSERT(translationEntry->Index <=
               AdapterObject->MapRegistersPerChannel);
    }

    //
    // It must require memory to be within the adapter's address range.  If the
    // logical address is greater than that which the adapter can directly
    // access then map registers must be used
    //

    maximumPhysicalAddress =
        HalpGetAdapterMaximumPhysicalAddress( AdapterObject );

    if ((ULONGLONG)(logicalAddress.QuadPart + transferLength - 1) >
        (ULONGLONG)maximumPhysicalAddress.QuadPart) {

        logicalAddress.QuadPart = (translationEntry + index)->PhysicalAddress +
                                  pageOffset;
        useBuffer = TRUE;

        if ((ULONG_PTR) MapRegisterBase & NO_SCATTER_GATHER) {

            translationEntry->Index = COPY_BUFFER;
            index = 0;

        }

    }

    //
    // Copy the data if necessary.
    //

    if (useBuffer  &&  WriteToDevice) {
        HalpCopyBufferMap(
                         Mdl,
                         translationEntry + index,
                         CurrentVa,
                         transferLength,
                         WriteToDevice
                         );
    }

    //
    // Return the length.
    //

    *Length = transferLength;

    //
    // Return the logical address to transfer to.
    //

    returnAddress = logicalAddress;

    //
    // If no adapter was specificed then there is no more work to do so
    // return.
    //

    if (AdapterObject == NULL || AdapterObject->MasterDevice) {

        return (returnAddress);
    }

    //
    // Determine the mode based on the transfer direction.
    //

    adapterMode = AdapterObject->AdapterMode;
    if (WriteToDevice) {
        ((PDMA_EISA_MODE) &adapterMode)->TransferType = (UCHAR) WRITE_TRANSFER;
    } else {
        ((PDMA_EISA_MODE) &adapterMode)->TransferType = (UCHAR) READ_TRANSFER;

        if (AdapterObject->IgnoreCount) {

            //
            // When the DMA is over there will be no way to tell how much
            // data was transfered, so the entire transfer length will be
            // copied.  To ensure that no stale data is returned to the
            // caller zero the buffer before hand.
            //

            RtlZeroMemory (
                          (PUCHAR) translationEntry[index].VirtualAddress + pageOffset,
                          transferLength
                          );
        }
    }

    bytePointer = (PUCHAR) &logicalAddress;

    if (AdapterObject->Width16Bits) {

        //
        // If this is a 16 bit transfer then adjust the length and the address
        // for the 16 bit DMA mode.
        //

        transferLength >>= 1;

        //
        // In 16 bit DMA mode the low 16 bits are shifted right one and the
        // page register value is unchanged. So save the page register value
        // and shift the logical address then restore the page value.
        //

        dataByte = bytePointer[2];
        logicalAddress.QuadPart >>= 1;
        bytePointer[2] = dataByte;

    }


    //
    // grab the spinlock for the system DMA controller
    //

    KeAcquireSpinLock( &AdapterObject->MasterAdapter->SpinLock, &Irql );

    //
    // Determine the controller number based on the Adapter number.
    //

    if (AdapterObject->AdapterNumber == 1) {

        //
        // This request is for DMA controller 1
        //

        PDMA1_CONTROL dmaControl;

        dmaControl = AdapterObject->AdapterBaseVa;

        WRITE_PORT_UCHAR( &dmaControl->ClearBytePointer, 0 );

        WRITE_PORT_UCHAR( &dmaControl->Mode, adapterMode );

        WRITE_PORT_UCHAR(
                        &dmaControl->DmaAddressCount[AdapterObject->ChannelNumber]
                        .DmaBaseAddress,
                        bytePointer[0]
                        );

        WRITE_PORT_UCHAR(
                        &dmaControl->DmaAddressCount[AdapterObject->ChannelNumber]
                        .DmaBaseAddress,
                        bytePointer[1]
                        );

        WRITE_PORT_UCHAR(
                        ((PUCHAR) &((PEISA_CONTROL) HalpEisaControlBase)->DmaPageLowPort) +
                        (ULONG_PTR)AdapterObject->PagePort,
                        bytePointer[2]
                        );

        if (HalpEisaDma) {

            //
            // Write the high page register with zero value. This enable a special mode
            // which allows ties the page register and base count into a single 24 bit
            // address register.
            //

            WRITE_PORT_UCHAR(
                            ((PUCHAR) &((PEISA_CONTROL) HalpEisaControlBase)->DmaPageHighPort) +
                            (ULONG_PTR)AdapterObject->PagePort,
                            0
                            );
        }

        //
        // Notify DMA chip of the length to transfer.
        //

        WRITE_PORT_UCHAR(
                        &dmaControl->DmaAddressCount[AdapterObject->ChannelNumber]
                        .DmaBaseCount,
                        (UCHAR) ((transferLength - 1) & 0xff)
                        );

        WRITE_PORT_UCHAR(
                        &dmaControl->DmaAddressCount[AdapterObject->ChannelNumber]
                        .DmaBaseCount,
                        (UCHAR) ((transferLength - 1) >> 8)
                        );


        //
        // Set the DMA chip to read or write mode; and unmask it.
        //

        WRITE_PORT_UCHAR(
                        &dmaControl->SingleMask,
                        (UCHAR) (DMA_CLEARMASK | AdapterObject->ChannelNumber)
                        );

    } else {

        //
        // This request is for DMA controller 2
        //

        PDMA2_CONTROL dmaControl;

        dmaControl = AdapterObject->AdapterBaseVa;

        WRITE_PORT_UCHAR( &dmaControl->ClearBytePointer, 0 );

        WRITE_PORT_UCHAR( &dmaControl->Mode, adapterMode );

        WRITE_PORT_UCHAR(
                        &dmaControl->DmaAddressCount[AdapterObject->ChannelNumber]
                        .DmaBaseAddress,
                        bytePointer[0]
                        );

        WRITE_PORT_UCHAR(
                        &dmaControl->DmaAddressCount[AdapterObject->ChannelNumber]
                        .DmaBaseAddress,
                        bytePointer[1]
                        );

        WRITE_PORT_UCHAR(
                        ((PUCHAR) &((PEISA_CONTROL) HalpEisaControlBase)->DmaPageLowPort) +
                        (ULONG_PTR)AdapterObject->PagePort,
                        bytePointer[2]
                        );

        if (HalpEisaDma) {

            //
            // Write the high page register with zero value. This enable a
            // special mode which allows ties the page register and base
            // count into a single 24 bit address register.
            //

            WRITE_PORT_UCHAR(
                            ((PUCHAR) &((PEISA_CONTROL) HalpEisaControlBase)->DmaPageHighPort) +
                            (ULONG_PTR)AdapterObject->PagePort,
                            0
                            );
        }

        //
        // Notify DMA chip of the length to transfer.
        //

        WRITE_PORT_UCHAR(
                        &dmaControl->DmaAddressCount[AdapterObject->ChannelNumber]
                        .DmaBaseCount,
                        (UCHAR) ((transferLength - 1) & 0xff)
                        );

        WRITE_PORT_UCHAR(
                        &dmaControl->DmaAddressCount[AdapterObject->ChannelNumber]
                        .DmaBaseCount,
                        (UCHAR) ((transferLength - 1) >> 8)
                        );


        //
        // Set the DMA chip to read or write mode; and unmask it.
        //

        WRITE_PORT_UCHAR(
                        &dmaControl->SingleMask,
                        (UCHAR) (DMA_CLEARMASK | AdapterObject->ChannelNumber)
                        );

    }

    //
    // Record what we wrote to the mask register.
    //

    HalpDmaChannelState [AdapterObject->ChannelNumber + ((AdapterObject->AdapterNumber - 1) * 4)].ChannelMask =
    (UCHAR) (DMA_CLEARMASK | AdapterObject->ChannelNumber);


    KeReleaseSpinLock (&AdapterObject->MasterAdapter->SpinLock, Irql);
    return (returnAddress);
}

BOOLEAN
IoFlushAdapterBuffers(
                     IN PADAPTER_OBJECT AdapterObject,
                     IN PMDL Mdl,
                     IN PVOID MapRegisterBase,
                     IN PVOID CurrentVa,
                     IN ULONG Length,
                     IN BOOLEAN WriteToDevice
                     )

/*++

Routine Description:

    This routine flushes the DMA adapter object buffers.  For the Jazz system
    its clears the enable flag which aborts the dma.

Arguments:

    AdapterObject - Pointer to the adapter object representing the DMA
        controller channel.

    Mdl - A pointer to a Memory Descriptor List (MDL) that maps the locked-down
        buffer to/from which the I/O occured.

    MapRegisterBase - A pointer to the base of the map registers in the adapter
        or DMA controller.

    CurrentVa - The current virtual address in the buffer described the the Mdl
        where the I/O operation occurred.

    Length - Supplies the length of the transfer.

    WriteToDevice - Supplies a BOOLEAN value that indicates the direction of
        the data transfer was to the device.

Return Value:

    TRUE - No errors are detected so the transfer must succeed.

--*/

{
    PTRANSLATION_ENTRY translationEntry;
    PPFN_NUMBER pageFrame;
    ULONG transferLength;
    ULONG partialLength;
    BOOLEAN masterDevice;
    PHYSICAL_ADDRESS maximumPhysicalAddress;
    ULONG maximumPhysicalPage;

    masterDevice = AdapterObject == NULL || AdapterObject->MasterDevice ?
                   TRUE : FALSE;

    //
    // If this is a slave device, then stop the DMA controller.
    //

    if (!masterDevice) {

        //
        // Mask the DMA request line so that DMA requests cannot occur.
        //

        if (AdapterObject->AdapterNumber == 1) {

            //
            // This request is for DMA controller 1
            //

            PDMA1_CONTROL dmaControl;

            dmaControl = AdapterObject->AdapterBaseVa;

            WRITE_PORT_UCHAR(
                            &dmaControl->SingleMask,
                            (UCHAR) (DMA_SETMASK | AdapterObject->ChannelNumber)
                            );

        } else {

            //
            // This request is for DMA controller 2
            //

            PDMA2_CONTROL dmaControl;

            dmaControl = AdapterObject->AdapterBaseVa;

            WRITE_PORT_UCHAR(
                            &dmaControl->SingleMask,
                            (UCHAR) (DMA_SETMASK | AdapterObject->ChannelNumber)
                            );

        }

        //
        // Record what we wrote to the mask register.
        //

        HalpDmaChannelState [AdapterObject->ChannelNumber + ((AdapterObject->AdapterNumber - 1) * 4)].ChannelMask =
        (UCHAR) (DMA_SETMASK | AdapterObject->ChannelNumber);

        //
        // Mark the channel as not in use
        //
#if DBG
        HalpDmaChannelState [AdapterObject->ChannelNumber + ((AdapterObject->AdapterNumber - 1) * 4)].ChannelBusy =
        FALSE;
#endif
    }

    if (MapRegisterBase == NULL) {
        return (TRUE);
    }

    //
    // Determine if the data needs to be copied to the orginal buffer.
    // This only occurs if the data tranfer is from the device, the
    // MapReisterBase is not NULL and the transfer spans a page.
    //

    if (!WriteToDevice) {

        //
        // Strip no scatter/gather flag.
        //

        translationEntry = (PTRANSLATION_ENTRY) ((ULONG_PTR) MapRegisterBase & ~NO_SCATTER_GATHER);

        //
        // If this is not a master device, then just transfer the buffer.
        //

        if ((ULONG_PTR) MapRegisterBase & NO_SCATTER_GATHER) {

            if (translationEntry->Index == COPY_BUFFER) {

                if (!masterDevice && !AdapterObject->IgnoreCount) {
                    ULONG DmaCount;

                    //
                    // Copy only the bytes that have actually been transfered.
                    //
                    //
                    DmaCount = HalReadDmaCounter(AdapterObject);
                    ASSERT(DmaCount <= Length);
                    Length -= DmaCount;
                }

                //
                // The adapter does not support scatter/gather copy the buffer.
                //

                HalpCopyBufferMap(
                                 Mdl,
                                 translationEntry,
                                 CurrentVa,
                                 Length,
                                 WriteToDevice
                                 );

            }

        } else {

            //
            // Cycle through the pages of the transfer to determine if there
            // are any which need to be copied back.
            //

            maximumPhysicalAddress =
                HalpGetAdapterMaximumPhysicalAddress( AdapterObject );

            maximumPhysicalPage =
                (ULONG)(maximumPhysicalAddress.QuadPart >> PAGE_SHIFT);

            transferLength = PAGE_SIZE - BYTE_OFFSET(CurrentVa);
            partialLength = transferLength;
            pageFrame = MmGetMdlPfnArray(Mdl);
            pageFrame += ((ULONG_PTR) CurrentVa - (ULONG_PTR) MmGetMdlBaseVa(Mdl)) >> PAGE_SHIFT;

            while ( transferLength <= Length ) {

                if (*pageFrame > maximumPhysicalPage) {

                    HalpCopyBufferMap(
                                     Mdl,
                                     translationEntry,
                                     CurrentVa,
                                     partialLength,
                                     WriteToDevice
                                     );

                }

                (PCCHAR) CurrentVa += partialLength;
                partialLength = PAGE_SIZE;

                //
                // Note that transferLength indicates the amount which will be
                // transfered after the next loop; thus, it is updated with the
                // new partial length.
                //

                transferLength += partialLength;
                pageFrame++;
                translationEntry++;
            }

            //
            // Process the any remaining residue.
            //

            partialLength = Length - transferLength + partialLength;
            if (partialLength && *pageFrame > maximumPhysicalPage) {

                HalpCopyBufferMap(
                                 Mdl,
                                 translationEntry,
                                 CurrentVa,
                                 partialLength,
                                 WriteToDevice
                                 );

            }
        }
    }

    //
    // Strip no scatter/gather flag.
    //

    translationEntry = (PTRANSLATION_ENTRY) ((ULONG_PTR) MapRegisterBase & ~NO_SCATTER_GATHER);

    //
    // Clear index in map register.
    //

    translationEntry->Index = 0;

    return TRUE;
}

ULONG
HalReadDmaCounter(
                 IN PADAPTER_OBJECT AdapterObject
                 )
/*++

Routine Description:

    This function reads the DMA counter and returns the number of bytes left
    to be transfered.

Arguments:

    AdapterObject - Supplies a pointer to the adapter object to be read.

Return Value:

    Returns the number of bytes still be be transfered.

--*/

{
    ULONG count;
    ULONG high;
    KIRQL Irql;

    //
    // Grab the spinlock for the system DMA controller.
    //

    KeAcquireSpinLock( &AdapterObject->MasterAdapter->SpinLock, &Irql );

    //
    // Determine the controller number based on the Adapter number.
    //

    if (AdapterObject->AdapterNumber == 1) {

        //
        // This request is for DMA controller 1
        //

        PDMA1_CONTROL dmaControl;

        dmaControl = AdapterObject->AdapterBaseVa;

        WRITE_PORT_UCHAR( &dmaControl->ClearBytePointer, 0 );


        //
        // Initialize count to a value which will not match.
        //

        count = 0xFFFF00;

        //
        // Loop until the same high byte is read twice.
        //

        do {

            high = count;

            WRITE_PORT_UCHAR( &dmaControl->ClearBytePointer, 0 );

            //
            // Read the current DMA count.
            //

            count = READ_PORT_UCHAR(
                                   &dmaControl->DmaAddressCount[AdapterObject->ChannelNumber]
                                   .DmaBaseCount
                                   );

            count |= READ_PORT_UCHAR(
                                    &dmaControl->DmaAddressCount[AdapterObject->ChannelNumber]
                                    .DmaBaseCount
                                    ) << 8;

        } while ((count & 0xFFFF00) != (high & 0xFFFF00));

    } else {

        //
        // This request is for DMA controller 2
        //

        PDMA2_CONTROL dmaControl;

        dmaControl = AdapterObject->AdapterBaseVa;

        WRITE_PORT_UCHAR( &dmaControl->ClearBytePointer, 0 );

        //
        // Initialize count to a value which will not match.
        //

        count = 0xFFFF00;

        //
        // Loop until the same high byte is read twice.
        //

        do {

            high = count;

            WRITE_PORT_UCHAR( &dmaControl->ClearBytePointer, 0 );

            //
            // Read the current DMA count.
            //

            count = READ_PORT_UCHAR(
                                   &dmaControl->DmaAddressCount[AdapterObject->ChannelNumber]
                                   .DmaBaseCount
                                   );

            count |= READ_PORT_UCHAR(
                                    &dmaControl->DmaAddressCount[AdapterObject->ChannelNumber]
                                    .DmaBaseCount
                                    ) << 8;

        } while ((count & 0xFFFF00) != (high & 0xFFFF00));

    }

    //
    // Release the spinlock for the system DMA controller.
    //

    KeReleaseSpinLock( &AdapterObject->MasterAdapter->SpinLock, Irql );

    //
    // The DMA counter has a bias of one and can only be 16 bit long.
    //

    count = (count + 1) & 0xFFFF;

    //
    // If this is a 16 bit dma the multiply the count by 2.
    //

    if (AdapterObject->Width16Bits) {

        count *= 2;

    }

    return (count);
}

ULONG
HalpGetIsaIrqState(
                  ULONG   Vector
                  )
{
    ULONG   vectorState = CM_RESOURCE_INTERRUPT_LATCHED;

    if (HalpBusType == MACHINE_TYPE_EISA) {

        if (HalpEisaIrqMask & (1 << Vector)) {

            vectorState = CM_RESOURCE_INTERRUPT_LEVEL_SENSITIVE;
        }
    }

    return vectorState;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halx86\i386\ixmovnti.asm ===
title "Hal Copy using Movnti"
;++
;
;Copyright (c) 2000  Microsoft Corporation
;
;Module Name:
;
;    ixmovnti.asm
;
;Abstract:
;
;    HAL routine that uses movnti instruction to copy buffer
;    similar to RtlMovememory but does not support backwards and
;    overlapped move 
;    Based on a previously tested fast copy by Jim crossland.
;Author:
;    Gautham chinya
;    Intel Corp 
;    
;Revision History:
;
;--

.386p

        .xlist
include callconv.inc                    ; calling convention macros
include mac386.inc
        .list
;
; Register Definitions (for instruction macros).
;

rEAX            equ     0
rECX            equ     1
rEDX            equ     2
rEBX            equ     3
rESP            equ     4
rEBP            equ     5
rESI            equ     6
rEDI            equ     7

MEMORY_ALIGNMENT_MASK0  = 63
MEMORY_ALIGNMENT_LOG2_0 = 6

MEMORY_ALIGNMENT_MASK1  = 3
MEMORY_ALIGNMENT_LOG2_1 = 2

sfence            macro
                   db      0FH, 0AEH, 0F8H
                  endm

prefetchnta_short macro   GeneralReg, Offset
                   db      0FH, 018H,  040H + GeneralReg, Offset
                  endm

prefetchnta_long  macro   GeneralReg, Offset
                   db      0FH, 018H,  080h + GeneralReg
                   dd      Offset
                  endm

movnti_eax        macro   GeneralReg, Offset
                   db  0FH, 0C3H, 040H + GeneralReg, Offset
                  endm

movnti_eax_0_disp macro   GeneralReg
                   db  0FH, 0C3H, 000H + GeneralReg
                  endm

movnti_ebx        macro   GeneralReg, Offset
                   db  0FH, 0C3H, 058H + GeneralReg, Offset
                  endm

;
;
; Macro that moves 64bytes (1 cache line using movnti (eax and ebx registers)
;
;

movnticopy64bytes  macro
                    mov    eax, [esi]
                    mov    ebx, [esi + 4]
                    movnti_eax_0_disp rEDI
                    movnti_ebx rEDI, 4

                    mov    eax, [esi + 8]
                    mov    ebx, [esi + 12]
                    movnti_eax rEDI, 8
                    movnti_ebx rEDI, 12

                    mov    eax, [esi + 16]
                    mov    ebx, [esi + 20]
                    movnti_eax rEDI, 16
                    movnti_ebx rEDI, 20

                    mov    eax, [esi + 24]
                    mov    ebx, [esi + 28]
                    movnti_eax rEDI, 24
                    movnti_ebx rEDI, 28

                    mov    eax, [esi + 32]
                    mov    ebx, [esi + 36]
                    movnti_eax rEDI,32
                    movnti_ebx rEDI, 36

                    mov    eax, [esi + 40]
                    mov    ebx, [esi + 44]
                    movnti_eax rEDI, 40
                    movnti_ebx rEDI,  44

                    mov    eax, [esi + 48]
                    mov    ebx, [esi + 52]
                    movnti_eax rEDI,48
                    movnti_ebx rEDI, 52

                    mov    eax, [esi + 56]
                    mov    ebx, [esi + 60]
                    movnti_eax rEDI, 56
                    movnti_ebx rEDI, 60
                  endm



_TEXT$03   SEGMENT DWORD PUBLIC 'CODE'
           ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING
           page ,132
           subttl  "HalpMovntiCopyBuffer"
;++
;
; VOID
; HalpMovntiCopyBuffer(
;    IN PVOID Destination,
;    IN PVOID Source,
;    IN ULONG Length
;    )
;
; Routine Description:
;
;    This function tries to copy buffers  
;    in 4-byte blocks using movnti, but also handles
;    smaller requests 
;
; Arguments:
;
;    Destination - Supplies a pointer to the destination of the move.
;
;    Source - Supplies a pointer to the memory to move.
;
;    Length - Supplies the Length, in bytes, of the memory to be moved.
;
; Return Value:
;
;    None.
;
;--

cPublicProc _HalpMovntiCopyBuffer ,3  

; Definitions of arguments
; (TOS) = Return address

EmmDestination  equ     [ebp + 4 + 4]
EmmSource       equ     [ebp + 4 + 8]
EmmLength       equ     [ebp + 4 + 12]

        push    ebp
        mov     ebp, esp
        push    esi
        push    edi
        push    ebx
       
        mov     esi, EmmSource
        mov     edi, EmmDestination
        mov     ecx, EmmLength

;
; Can't use movnti for this wee-quest
;
	cmp ecx, 4
	jl RemainingBytes
	
;
; Before prefetching we must guarantee the TLB is valid.
;
        mov     eax, [esi]

        cld

;
;Check if less than 64 bytes 
;
 
        mov     edx, ecx
        and     ecx, MEMORY_ALIGNMENT_MASK0
        shr     edx, MEMORY_ALIGNMENT_LOG2_0
        je      Copy4
        dec     edx
        je      copy64

        prefetchnta_short rESI, 128
        dec     edx
        je      copy128

        prefetchnta_short rESI, 192
        dec     edx
        je      copy192


         
copyLoop:

        prefetchnta_long rESI, 256

        movnticopy64bytes
        lea     esi, [esi + 64]
        lea     edi, [edi + 64]
        
        dec     edx
        jnz     copyLoop


copy192:


        movnticopy64bytes
        lea     esi, [esi + 64]
        lea     edi, [edi + 64]
       
copy128:


        movnticopy64bytes
        lea     esi, [esi + 64]
        lea     edi, [edi + 64]

copy64:

        movnticopy64bytes

        or     ecx, ecx  ; anything less than 64 to do?
        jz     ExitRoutine

        prefetchnta_short rESI, 0
;
;Update pointer for last copy    
;
        
        lea     esi, [esi + 64]
        lea     edi, [edi + 64]

;
;Handle extra bytes here in 32 bit chuncks and then 8-bit bytes    
;

Copy4:
         mov    edx, ecx
         and    ecx, MEMORY_ALIGNMENT_MASK1
         shr    edx, MEMORY_ALIGNMENT_LOG2_1

;
; If the number of 32-bit words to move is non-zero, then do it
;         
         jz     RemainingBytes 

Copy4Loop:
         mov    eax, [esi]
         movnti_eax_0_disp rEDI
         lea    esi, [esi+4]
         lea    edi, [edi+4]
         dec    edx
         jnz    Copy4Loop
         
RemainingBytes:
         or     ecx, ecx
         jz     ExitRoutine
         rep     movsb

ExitRoutine:     

        sfence            ;Make all stores globally visible 
        pop     ebx
        pop     edi
        pop     esi
        pop     ebp
        stdRET  _HalpMovntiCopyBuffer 

stdENDP _HalpMovntiCopyBuffer

_TEXT$03 ends
         end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halx86\i386\ixisa.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1991  Microsoft Corporation

Module Name:

    ixisa.h

Abstract:

    This header file defines the private Hardware Architecture Layer (HAL)
    EISA/ISA specific interfaces, defines and structures.

Author:

    Jeff Havens (jhavens) 20-Jun-91

Revision History:

--*/

#ifndef _IXISA_
#define _IXISA_


//
// The MAXIMUM_MAP_BUFFER_SIZE defines the maximum map buffers which the system
// will allocate for devices which require phyically contigous buffers.
//

#define MAXIMUM_ISA_MAP_BUFFER_SIZE      0x40000

#if !defined(_HALPAE_)
#define MAXIMUM_MAP_BUFFER_SIZE         MAXIMUM_ISA_MAP_BUFFER_SIZE
#endif

//
// MAXIMUM_PCI_MAP_BUFFER_SIZE defines the maximum map buffers which the system
// will allocate for 32-bit PCI devices on a 64-bit system.
//

#define MAXIMUM_PCI_MAP_BUFFER_SIZE  (64 * 1024 * 1024)

//
// Define the initial buffer allocation size for a map buffers for systems with
// no memory which has a physical address greater than MAXIMUM_PHYSICAL_ADDRESS.
//

#define INITIAL_MAP_BUFFER_SMALL_SIZE 0x10000

//
// Define the initial buffer allocation size for a map buffers for systems with
// no memory which has a physical address greater than MAXIMUM_PHYSICAL_ADDRESS.
//

#define INITIAL_MAP_BUFFER_LARGE_SIZE 0x30000

//
// Define the incremental buffer allocation for a map buffers.
//

#define INCREMENT_MAP_BUFFER_SIZE 0x10000

//
// Define the maximum number of map registers that can be requested at one time
// if actual map registers are required for the transfer.
//

#define MAXIMUM_ISA_MAP_REGISTER  16

#define MAXIMUM_PCI_MAP_REGISTER  16

//
// Define the maximum physical address which can be handled by an Isa card.
//

#define MAXIMUM_PHYSICAL_ADDRESS 0x01000000

//
// Define the scatter/gather flag for the Map Register Base.
//

#define NO_SCATTER_GATHER 0x00000001

//
// Define the copy buffer flag for the index.
//

#define COPY_BUFFER 0XFFFFFFFF

//
// Define adapter object structure.
//

typedef struct _ADAPTER_OBJECT {
    DMA_ADAPTER DmaHeader;
    struct _ADAPTER_OBJECT *MasterAdapter;
    ULONG MapRegistersPerChannel;
    PVOID AdapterBaseVa;
    PVOID MapRegisterBase;
    ULONG NumberOfMapRegisters;
    ULONG CommittedMapRegisters;
    struct _WAIT_CONTEXT_BLOCK *CurrentWcb;
    KDEVICE_QUEUE ChannelWaitQueue;
    PKDEVICE_QUEUE RegisterWaitQueue;
    LIST_ENTRY AdapterQueue;
    KSPIN_LOCK SpinLock;
    PRTL_BITMAP MapRegisters;
    PUCHAR PagePort;
    UCHAR ChannelNumber;
    UCHAR AdapterNumber;
    USHORT DmaPortAddress;
    UCHAR AdapterMode;
    BOOLEAN NeedsMapRegisters;
    BOOLEAN MasterDevice;
    BOOLEAN Width16Bits;
    BOOLEAN ScatterGather;
    BOOLEAN IgnoreCount;
    BOOLEAN Dma32BitAddresses;
    BOOLEAN Dma64BitAddresses;
    BOOLEAN LegacyAdapter;
    LIST_ENTRY AdapterList;
} ADAPTER_OBJECT;

typedef struct _MASTER_ADAPTER_OBJECT {

    PADAPTER_OBJECT AdapterObject;

    //
    // Maximum number of buffers to allocate for this master adapter.
    //

    ULONG MaxBufferPages;

    //
    // Number of map buffers allocated
    //

    ULONG MapBufferSize;

    PHYSICAL_ADDRESS MapBufferPhysicalAddress;

} MASTER_ADAPTER_OBJECT, *PMASTER_ADAPTER_OBJECT;

ULONG 
HalGetDmaAlignment (
    PVOID Conext
    );

NTSTATUS
HalCalculateScatterGatherListSize(
    IN PADAPTER_OBJECT AdapterObject,
    IN OPTIONAL PMDL Mdl,
    IN PVOID CurrentVa,
    IN ULONG Length,
    OUT PULONG  ScatterGatherListSize,
    OUT OPTIONAL PULONG pNumberOfMapRegisters
    );

NTSTATUS
HalBuildScatterGatherList (
    IN PADAPTER_OBJECT AdapterObject,
    IN PDEVICE_OBJECT DeviceObject,
    IN PMDL Mdl,
    IN PVOID CurrentVa,
    IN ULONG Length,
    IN PDRIVER_LIST_CONTROL ExecutionRoutine,
    IN PVOID Context,
    IN BOOLEAN WriteToDevice,
    IN PVOID ScatterGatherBuffer,
    IN ULONG ScatterGatherBufferLength
    );


NTSTATUS
HalBuildMdlFromScatterGatherList(
    IN PADAPTER_OBJECT AdapaterObject,
    IN PSCATTER_GATHER_LIST ScatterGather,
    IN PMDL OriginalMdl,
    OUT PMDL *TargetMdl
    );

NTSTATUS
HalpAllocateMapRegisters(
    IN PADAPTER_OBJECT DmaAdapter,
    IN ULONG NumberOfMapRegisters,
    IN ULONG BaseAddressCount,
    OUT PMAP_REGISTER_ENTRY MapRegisterArray
    );

PHYSICAL_ADDRESS
__inline
HalpGetAdapterMaximumPhysicalAddress(
    IN PADAPTER_OBJECT AdapterObject
    )

/*++

Routine Description:

    This routine determines and returns the maximum physical address that
    can be accessed by the given adapter.

Arguments:

    AdapterObject - Supplies a pointer to the adapter object used by this
        device.

Return Value:

    Returns the maximum physical address that can be accessed by this
        device.

--*/

{
    PHYSICAL_ADDRESS maximumAddress;

    //
    // Assume the device requires physical addresses < 16M.
    //

    maximumAddress.HighPart = 0;
    maximumAddress.LowPart = MAXIMUM_PHYSICAL_ADDRESS - 1;

    //
    // IoMapTransfer() is sometimes called with a NULL adapter object.  In
    // this case, assume the adapter is 24 bit.
    //

    if (AdapterObject == NULL) {
        return maximumAddress;
    }

    if (AdapterObject->MasterDevice) {

        if (AdapterObject->Dma64BitAddresses) {

            //
            // This device is a master and can handle 64 bit addresses.
            //

            maximumAddress.QuadPart = (ULONGLONG)-1;

        } else if(AdapterObject->Dma32BitAddresses) {

            //
            // This device is a master and can handle 32 bit addresses.
            //

            maximumAddress.LowPart = (ULONG)-1;
        }
    }

    return maximumAddress;
}

#if defined(_WIN64)

NTSTATUS
HalRealAllocateAdapterChannel(
    IN PADAPTER_OBJECT AdapterObject,
    IN PDEVICE_OBJECT DeviceObject,
    IN ULONG NumberOfMapRegisters,
    IN PDRIVER_CONTROL ExecutionRoutine,
    IN PVOID Context
    );

#endif



#endif // _IXISA_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halx86\i386\ixmcaa.asm ===
;++
;Module Name
;   imca.asm
;
;Abstract:
;   Assembly support needed for Intel MCA
;
; Author:
;   Anil Aggarwal (Intel Corp)
;
;Revision History:
;
;
;--

.586p
        .xlist
include hal386.inc
include callconv.inc
include i386\kimacro.inc
        .list

        EXTRNP  _HalpMcaExceptionHandler,0
        EXTRNP  _KeBugCheckEx,5,IMPORT

KGDT_MCA_TSS                EQU     0A0H
MINIMUM_TSS_SIZE            EQU     TssIoMaps

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;                           TEXT Segment
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


_TEXT   SEGMENT PARA PUBLIC 'CODE'
        ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

    .586p

;++
;
;VOID
;HalpSerialize(
;   VOID
;   )
;
;   Routine Description:
;       This function implements the fence operation for out-of-order execution
;
;   Arguments:
;       None
;
;   Return Value:
;       None
;
;--

cPublicProc _HalpSerialize,0

        push    ebx
        xor     eax, eax
        cpuid
        pop     ebx

        stdRET  _HalpSerialize

stdENDP _HalpSerialize
 
 
;++
;
; Routine Description:
;
;    Machine Check exception handler
;
;
; Arguments:
;
; Return value:
;
;   If the error is non-restartable, we will bugcheck.
;   Otherwise, we just return 
;
;--
        ASSUME  DS:NOTHING, SS:NOTHING, ES:NOTHING
align dword
        public  _HalpMcaExceptionHandlerWrapper
_HalpMcaExceptionHandlerWrapper       proc
.FPO (0, 0, 0, 0, 0, 2)

        cli

        ; 
        ; Set CR3, the I/O map base address, and LDT segment selector
        ; in the old TSS since they are not set on context
        ; switches. These values will be needed to return to the
        ; interrupted task.

        mov     eax, PCR[PcTss]                      ; get old TSS address
        mov     ecx, PCR[PcPrcbData+PbCurrentThread] ; get thread address
        mov     edi, [ecx].ThApcState.AsProcess      ; get process address
        mov     ecx, [edi]+PrDirectoryTableBase      ; get directory base
        mov     [eax]+TssCR3, ecx                    ; set previous cr3

        mov     cx, [edi]+PrIopmOffset               ; get IOPM offset
        mov     [eax]+TssIoMapBase, cx               ; set IOPM offset

        mov     ecx, [edi]+PrLdtDescriptor           ; get LDT descriptor
        test    ecx, ecx                             ; does task use LDT?
        jz      @f
        mov     cx, KGDT_LDT

@@:     mov     [eax]+TssLDT, cx                     ; set LDT into old TSS

        ;
        ; Update the TSS pointer in the PCR to point to the MCA TSS
        ; (which is what we're running on, or else we wouldn't be here)
        ;

        push    dword ptr PCR[PcTss]

        mov     eax, PCR[PcGdt]
        mov     ch, [eax+KGDT_MCA_TSS+KgdtBaseHi]
        mov     cl, [eax+KGDT_MCA_TSS+KgdtBaseMid]
        shl     ecx, 16
        mov     cx, [eax+KGDT_MCA_TSS+KgdtBaseLow]
        mov     PCR[PcTss], ecx

        ;
        ; Clear Nested Task bit in EFLAGS
        ;
        pushfd
        and     [esp], not 04000h
        popfd

        ;
        ; Clear the busy bit in the TSS selector
        ;
        mov     ecx, PCR[PcGdt]
        lea     eax, [ecx] + KGDT_MCA_TSS
        mov     byte ptr [eax+5], 089h  ; 32bit, dpl=0, present, TSS32, not busy

        ;
        ; Check if there is a bugcheck-able error. If need to bugcheck, the 
        ; caller does it.
        ;
        stdCall _HalpMcaExceptionHandler

        ;
        ; We're back which means that the error was restartable.
        ;

        pop     dword ptr PCR[PcTss]    ; restore PcTss

        mov     ecx, PCR[PcGdt]
        lea     eax, [ecx] + KGDT_TSS
        mov     byte ptr [eax+5], 08bh  ; 32bit, dpl=0, present, TSS32, *busy*

        pushfd                          ; Set Nested Task bit in EFLAGS
        or      [esp], 04000h           ; so iretd will do a tast switch
        popfd

        iretd                           ; Return from MCA Exception handler
        jmp     _HalpMcaExceptionHandlerWrapper   
                                        ; For next Machine check exception

_HalpMcaExceptionHandlerWrapper       endp

_TEXT   ends

INIT    SEGMENT DWORD PUBLIC 'CODE'

;++
;VOID
;HalpMcaCurrentProcessorSetTSS(
;   IN PULONG   pTSS   // MCE TSS area for this processor
;   )
;   Routine Description:
;       This function sets up the TSS for MCA exception 18
;
;   Arguments:
;       pTSS  : Pointer to the TSS to be used for MCE
;
;   Return Value:
;       None
;
;--

cPublicProc _HalpMcaCurrentProcessorSetTSS,1
    
        ;
        ; Edit IDT Entry for MCA Exception (18) to contain a task gate
        ;
        mov     ecx, PCR[PcIdt]                     ; Get IDT address
        lea     eax, [ecx] + 090h                   ; MCA Exception is 18
        mov     byte ptr [eax + 5], 085h            ; P=1,DPL=0,Type=5
        mov     word ptr [eax + 2], KGDT_MCA_TSS    ; TSS Segment Selector

        mov     edx, [esp+4]                        ; the address of TSS in edx

        ;
        ; Set various fields in TSS
        ;
        mov     eax, cr3
        mov     [edx + TssCR3], eax

        ; 
        ; Get double fault stack address
        ;
        lea     eax, [ecx] + 040h                ; DF Exception is 8

        ;
        ; Get to TSS Descriptor of double fault handler TSS
        ;
        xor     ecx, ecx
        mov     cx, word ptr [eax+2]
        add     ecx, PCR[PcGdt]

        ;
        ; Get the address of TSS from this TSS Descriptor
        ;
        mov     ah, [ecx+KgdtBaseHi]
        mov     al, [ecx+KgdtBaseMid]
        shl     eax, 16
        mov     ax, [ecx+KgdtBaseLow]

        ;
        ; Get ESP from DF TSS
        ;
        mov     ecx, [eax+038h]

        ; 
        ; Set address of MCA Exception stack to double fault stack address
        ;
        mov     dword ptr [edx+038h], ecx       ; Set ESP
        mov     dword ptr [edx+TssEsp0], ecx    ; Set ESP0

        mov     dword ptr [edx+020h], offset FLAT:_HalpMcaExceptionHandlerWrapper ; set EIP
        mov     dword ptr [edx+024h], 0             ; set EFLAGS
        mov     word ptr [edx+04ch],KGDT_R0_CODE    ; set value for CS
        mov     word ptr [edx+058h],KGDT_R0_PCR     ; set value for FS
        mov     [edx+050h], ss
        mov     word ptr [edx+048h],KGDT_R3_DATA OR RPL_MASK ; Es
        mov     word ptr [edx+054h],KGDT_R3_DATA OR RPL_MASK ; Ds

        ;
        ; Part that gets done in KiInitialiazeTSS()
        ;
        mov     word ptr [edx + 08], KGDT_R0_DATA   ; Set SS0
        mov     word ptr [edx + 060h],0             ; Set LDT
        mov     word ptr [edx + 064h],0             ; Set T bit
        mov     word ptr [edx + 066h],020adh        ; I/O Map base address = sizeof(KTSS)+1

        ;
        ; Edit GDT entry for KGDT_MCA_TSS to create a valid TSS Descriptor
        ;
        mov     ecx, PCR[PcGdt]                     ; Get GDT address
        lea     eax, [ecx] + KGDT_MCA_TSS           ; offset of MCA TSS in GDT
        mov     ecx, eax

        ;
        ; Set Type field of TSS Descriptor
        ;
        mov     byte ptr [ecx + 5], 089H            ; P=1, DPL=0, Type = 9

        ;
        ; Set Base Address field of TSS Descriptor
        ;
        mov     eax, edx                            ; TSS address in eax
        mov     [ecx + KgdtBaseLow], ax
        shr     eax, 16
        mov     [ecx + KgdtBaseHi],ah
        mov     [ecx + KgdtBaseMid],al

        ;
        ; Set Segment limit for TSS Descriptor
        ;
        mov     eax, MINIMUM_TSS_SIZE
        mov     [ecx + KgdtLimitLow],ax

        stdRET  _HalpMcaCurrentProcessorSetTSS

stdENDP _HalpMcaCurrentProcessorSetTSS

INIT   ends

PAGELK      SEGMENT DWORD PUBLIC 'CODE'
;++
;
;VOID
;HalpSetCr4MCEBit(
;   VOID
;   )
;
;   Routine Description:
;       This function sets the CR4.MCE bit
;
;   Arguments:
;       None
;
;   Return Value:
;       None
;
;--

cPublicProc _HalpSetCr4MCEBit,0

    mov     eax, cr4
    or      eax, CR4_MCE
    mov     cr4, eax
    stdRET  _HalpSetCr4MCEBit

stdENDP _HalpSetCr4MCEBit
 

PAGELK     ends
 
         end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halx86\i386\ixlock.asm ===
title  "Irql Processing"
;++
;
; Copyright (c) 1989  Microsoft Corporation
;
; Module Name:
;
;    ixlock.asm
;
; Abstract:
;
;    This module implements various locking functions optimized for this hal.
;
; Author:
;
;    Ken Reneris (kenr) 21-April-1994
;
; Environment:
;
;    Kernel mode only.
;
; Revision History:
;
;--

.486p
        .xlist
include hal386.inc
include callconv.inc                    ; calling convention macros
include i386\ix8259.inc
include i386\kimacro.inc
include mac386.inc
        .list

        EXTRNP _KeBugCheckEx,5,IMPORT
        EXTRNP _KeSetEventBoostPriority, 2, IMPORT
        EXTRNP _KeWaitForSingleObject,5, IMPORT

        extrn  FindHigherIrqlMask:DWORD
        extrn  SWInterruptHandlerTable:DWORD

        EXTRNP _KeRaiseIrql,2
        EXTRNP _KeLowerIrql,1

ifdef NT_UP
    LOCK_ADD  equ   add
    LOCK_DEC  equ   dec
    LOCK_CMPXCHG  equ   cmpxchg
else
    LOCK_ADD  equ   lock add
    LOCK_DEC  equ   lock dec
    LOCK_CMPXCHG  equ   lock cmpxchg
endif


_TEXT$01   SEGMENT PARA PUBLIC 'CODE'
        ASSUME  DS:FLAT, ES:FLAT, SS:FLAT, FS:NOTHING, GS:NOTHING

        PAGE
        subttl  "AcquireSpinLock"

;++
;
;  KIRQL
;  KfAcquireSpinLock (
;     IN PKSPIN_LOCK SpinLock
;     )
;
;  Routine Description:
;
;     This function raises to DISPATCH_LEVEL and then acquires a the
;     kernel spin lock.
;
;     In a UP hal spinlock serialization is accomplished by raising the
;     IRQL to DISPATCH_LEVEL.  The SpinLock is not used; however, for
;     debugging purposes if the UP hal is compiled with the NT_UP flag
;     not set (ie, MP) we take the SpinLock.
;
;  Arguments:
;
;     (ecx) = SpinLock Supplies a pointer to an kernel spin lock.
;
;  Return Value:
;
;     OldIrql
;
;--

cPublicFastCall KfAcquireSpinLock,1
cPublicFpo 0,0

        mov     eax, PCR[PcIrql]         ; (eax) = Old Irql
        mov     dword ptr PCR[PcIrql], DISPATCH_LEVEL    ; set new irql

ifndef NT_UP
asl10:  ACQUIRE_SPINLOCK    ecx,<short asl20>
endif

ifdef IRQL_METRICS
        inc     HalRaiseIrqlCount
endif
if DBG
        cmp     al, DISPATCH_LEVEL      ; old > new?
        ja      short asl99             ; yes, go bugcheck
endif
        fstRET    KfAcquireSpinLock

ifndef NT_UP
asl20:  SPIN_ON_SPINLOCK    ecx,<short asl10>
endif

if DBG
cPublicFpo 2,1
asl99:  movzx   eax, al
        stdCall  _KeBugCheckEx,<IRQL_NOT_GREATER_OR_EQUAL,eax,DISPATCH_LEVEL,0,1>
        ; never returns
endif
        fstRET    KfAcquireSpinLock
fstENDP KfAcquireSpinLock

;++
;
;  KIRQL
;  KeAcquireSpinLockRaiseToSynch (
;     IN PKSPIN_LOCK SpinLock
;     )
;
;  Routine Description:
;
;     This function acquires the SpinLock at SYNCH_LEVEL.  The function
;     is optmized for hoter locks (the lock is tested before acquired.
;     Any spin should occur at OldIrql; however, since this is a UP hal
;     we don't have the code for it)
;
;     In a UP hal spinlock serialization is accomplished by raising the
;     IRQL to SYNCH_LEVEL.  The SpinLock is not used; however, for
;     debugging purposes if the UP hal is compiled with the NT_UP flag
;     not set (ie, MP) we take the SpinLock.
;
;  Arguments:
;
;     (ecx) = SpinLock Supplies a pointer to an kernel spin lock.
;
;  Return Value:
;
;     OldIrql
;
;--

cPublicFastCall KeAcquireSpinLockRaiseToSynch,1
cPublicFpo 0,0

        mov     eax, PCR[PcIrql]         ; (eax) = Old Irql
        mov     dword ptr PCR[PcIrql], SYNCH_LEVEL   ; set new irql

ifndef NT_UP
asls10: ACQUIRE_SPINLOCK    ecx,<short asls20>
endif

ifdef IRQL_METRICS
        inc     HalRaiseIrqlCount
endif
if DBG
        cmp     al, SYNCH_LEVEL         ; old > new?
        ja      short asls99            ; yes, go bugcheck
endif
        fstRET  KeAcquireSpinLockRaiseToSynch

ifndef NT_UP
asls20: SPIN_ON_SPINLOCK    ecx,<short asls10>
endif

if DBG
cPublicFpo 2,1
asls99: movzx   eax, al
        stdCall  _KeBugCheckEx,<IRQL_NOT_GREATER_OR_EQUAL,eax,SYNCH_LEVEL,0,2>
        ; never returns
endif
        fstRET  KeAcquireSpinLockRaiseToSynch
fstENDP KeAcquireSpinLockRaiseToSynch

        PAGE
        SUBTTL "Release Kernel Spin Lock"

;++
;
;  VOID
;  KfReleaseSpinLock (
;     IN PKSPIN_LOCK SpinLock,
;     IN KIRQL       NewIrql
;     )
;
;  Routine Description:
;
;     This function releases a kernel spin lock and lowers to the new irql
;
;     In a UP hal spinlock serialization is accomplished by raising the
;     IRQL to DISPATCH_LEVEL.  The SpinLock is not used; however, for
;     debugging purposes if the UP hal is compiled with the NT_UP flag
;     not set (ie, MP) we use the SpinLock.
;
;  Arguments:
;
;     (ecx) = SpinLock Supplies a pointer to an executive spin lock.
;     (dl)  = NewIrql  New irql value to set
;
;  Return Value:
;
;     None.
;
;--

align 16
cPublicFastCall KfReleaseSpinLock  ,2
cPublicFpo 0,0
ifndef NT_UP
        RELEASE_SPINLOCK    ecx         ; release it
endif
        xor     ecx, ecx
if DBG
        cmp     dl, PCR[PcIrql]
        ja      short rsl99
endif
        pushfd
        cli

        movzx   edx, dl
        mov     PCR[PcIrql], edx        ; store old irql

        mov     cl, dl                  ; (ecx) = 32bit extended OldIrql
        mov     edx, PCR[PcIRR]
        and     edx, FindHigherIrqlMask[ecx*4]  ; (edx) is the bitmask of
                                                ; pending interrupts we need to
        jne     short rsl20                     ; dispatch now.

        popfd
        fstRet  KfReleaseSpinLock               ; all done

if DBG
rsl99:  mov     eax, PCR[PcIrql]
        movzx   edx, dl
        stdCall _KeBugCheckEx,<IRQL_NOT_LESS_OR_EQUAL,eax,edx,0,3>
        ; never returns
endif

cPublicFpo 0,1
rsl20:  bsr     ecx, edx                        ; (ecx) = Pending irq level
        cmp     ecx, DISPATCH_LEVEL
        jle     short rsl40

        mov     eax, PCR[PcIDR]                 ; Clear all the interrupt
        SET_8259_MASK                           ; masks
rsl40:
        mov     edx, 1
        shl     edx, cl
        xor     PCR[PcIRR], edx                 ; clear bit in IRR
        call    SWInterruptHandlerTable[ecx*4]  ; Dispatch the pending int.
        popfd

cPublicFpo 0, 0
        fstRet  KfReleaseSpinLock               ; all done

fstENDP KfReleaseSpinLock

;++
;
;  VOID
;  FASTCALL
;  ExAcquireFastMutex (
;     IN PFAST_MUTEX    FastMutex
;     )
;
;  Routine description:
;
;   This function acquires ownership of the FastMutex
;
;  Arguments:
;
;     (ecx) = FastMutex - Supplies a pointer to the fast mutex
;
;  Return Value:
;
;     None.
;
;--

cPublicFastCall ExAcquireFastMutex,1
cPublicFpo 0,0
        mov     eax, PCR[PcIrql]            ; (eax) = OldIrql
if DBG
        cmp     eax, APC_LEVEL              ; Is OldIrql > NewIrql?
        ja      short afm99                 ; Yes, bugcheck

        pushfd
        cli                                 ; prevent swapcontext while
                                            ; snapping current thread.
        mov     edx, PCR[PcPrcb]
        mov     edx, [edx].PbCurrentThread  ; (edx) = Current Thread
        popfd

        cmp     [ecx].FmOwner, edx          ; Already owned by this thread?
        je      short afm98                 ; Yes, error
endif

        mov     dword ptr PCR[PcIrql], APC_LEVEL     ; Set NewIrql
   LOCK_DEC     dword ptr [ecx].FmCount             ; Get count

        jnz     short afm10                 ; Not the owner, go wait.

	    ;
	    ; Leave a notion of owner behind.
	    ;
	    ; Note: if you change this, change ExAcquireFastMutexUnsafe.
        ;
	
if DBG
        pushfd
        cli                                     ; prevent swapcontext while
                                                ; snapping current thread.

        mov     edx, PCR[PcPrcb]
        mov     edx, [edx].PbCurrentThread  ; (edx) = Current Thread
        popfd

        mov     [ecx].FmOwner, edx          ; Save in Fast Mutex
else
        ;
        ; Use esp to track the owning thread for debugging purposes.
        ; !thread from kd will find the owning thread.  Note that the
        ; owner isn't cleared on release, check if the mutex is owned
        ; first.
        ;

        mov     [ecx].FmOwner, esp
endif
        mov     dword ptr [ecx].FmOldIrql, eax
        fstRet  ExAcquireFastMutex

afm10:
        inc     dword ptr [ecx].FmContention

cPublicFpo 0,2
        push    eax                         ; save OldIrql
        push    ecx                         ; Save FAST_MUTEX
        add     ecx, FmEvent                ; Wait on Event

        stdCall _KeWaitForSingleObject,<ecx,WrExecutive,0,0,0>

        pop     ecx                         ; (ecx) = FAST_MUTEX
        pop     eax                         ; (al) = OldIrql

cPublicFpo 1,0
afm_ret:

	    ;
	    ; Leave a notion of owner behind.
	    ;
	    ; Note: if you change this, change ExAcquireFastMutexUnsafe.
        ;
	
if DBG
        pushfd
        cli                                 ; prevent swapcontext while
                                            ; snapping current thread.

        mov     edx, PCR[PcPrcb]
        mov     edx, [edx].PbCurrentThread  ; (edx) = Current Thread
        popfd

        mov     [ecx].FmOwner, edx          ; Save in Fast Mutex
else
        ;
        ; Use esp to track the owning thread for debugging purposes.
        ; !thread from kd will find the owning thread.  Note that the
        ; owner isn't cleared on release, check if the mutex is owned
        ; first.
        ;

        mov     [ecx].FmOwner, esp
endif
        mov     byte ptr [ecx].FmOldIrql, al
        fstRet  ExAcquireFastMutex

if DBG

        ; KeBugCheckEx(MUTEX_ALREADY_OWNED, FastMutex, CurrentThread, 0, 4)
        ; (never returns)

afm98:  stdCall _KeBugCheckEx,<MUTEX_ALREADY_OWNED,ecx,edx,0,4>

        ; KeBugCheckEx(IRQL_NOT_LESS_OR_EQUAL, CurrentIrql, APC_LEVEL, 0, 5)
        ; (never returns)

afm99:  movzx   eax, al
        stdCall _KeBugCheckEx,<IRQL_NOT_LESS_OR_EQUAL,eax,APC_LEVEL,0,5>

        fstRet  ExAcquireFastMutex
endif

fstENDP ExAcquireFastMutex


;++
;
;  VOID
;  FASTCALL
;  ExReleaseFastMutex (
;     IN PFAST_MUTEX    FastMutex
;     )
;
;  Routine description:
;
;   This function releases ownership of the FastMutex
;
;  Arguments:
;
;     (ecx) = FastMutex - Supplies a pointer to the fast mutex
;
;  Return Value:
;
;     None.
;
;--

cPublicFastCall ExReleaseFastMutex,1
cPublicFpo 0,0
        xor     eax, eax
if DBG
        pushfd
        cli                                     ; prevent swapcontext while
                                                ; snapping current thread.
        mov     edx, PCR[PcPrcb]
        mov     edx, [edx].PbCurrentThread      ; (edx) = CurrentThread
        popfd
        cmp     [ecx].FmOwner, edx              ; Owner == CurrentThread?
        jne     short rfm_threaderror           ; No, bugcheck

        or      byte ptr [ecx].FmOwner, 1       ; not the owner anymore
endif

        mov     al, byte ptr [ecx].FmOldIrql    ; (eax) = OldIrql
   LOCK_ADD     dword ptr [ecx].FmCount, 1      ; Remove our count
        js      short rfm05                     ; if < 0, set event
        jnz     short rfm10                     ; if != 0, don't set event

rfm05:
cPublicFpo 0,2
        push    eax                             ; Save OldIrql
        add     ecx, FmEvent
        stdCall _KeSetEventBoostPriority, <ecx, 0>
        pop     eax

cPublicFpo 0,0
rfm10:
        cli
        mov     PCR[PcIrql], eax
        mov     edx, PCR[PcIRR]
        and     edx, FindHigherIrqlMask[eax*4]  ; (edx) is the bitmask of
                                                ; pending interrupts we need to
        jne     short rfm20                     ; dispatch now.

        sti
        fstRet  ExReleaseFastMutex              ; all done
if DBG

        ; KeBugCheck(THREAD_NOT_MUTEX_OWNER, FastMutex, Thread, Owner, 6)
        ; (never returns)

rfm_threaderror:
        stdCall _KeBugCheckEx,<THREAD_NOT_MUTEX_OWNER,ecx,edx,[ecx].FmOwner,6>

endif

rfm20:  bsr     ecx, edx                        ; (ecx) = Pending irq level
        cmp     ecx, DISPATCH_LEVEL
        jle     short rfm40

        mov     eax, PCR[PcIDR]                 ; Clear all the interrupt
        SET_8259_MASK                           ; masks
rfm40:
        mov     edx, 1
        shl     edx, cl
        xor     PCR[PcIRR], edx                 ; clear bit in IRR
        call    SWInterruptHandlerTable[ecx*4]  ; Dispatch the pending int.
        sti
        fstRet  ExReleaseFastMutex              ; all done
fstENDP ExReleaseFastMutex

;++
;
;  BOOLEAN
;  FASTCALL
;  ExTryToAcquireFastMutex (
;     IN PFAST_MUTEX    FastMutex
;     )
;
;  Routine description:
;
;   This function acquires ownership of the FastMutex
;
;  Arguments:
;
;     (ecx) = FastMutex - Supplies a pointer to the fast mutex
;
;  Return Value:
;
;     Returns TRUE if the FAST_MUTEX was acquired; otherwise false
;
;--

cPublicFastCall ExTryToAcquireFastMutex,1
cPublicFpo 0,0

if DBG
        mov     eax, PCR[PcIrql]                ; (al) = OldIrql
        cmp     eax, APC_LEVEL                  ; Is OldIrql > NewIrql?
        ja      short tam99                     ; Yes, bugcheck
        push    eax                             ; Save OldIrql
else
        push    dword ptr PCR[PcIrql]           ; Save OldIrql
endif

        ;
        ; Try to acquire.
        ;

        mov     edx, 0                          ; Value to set
        mov     eax, 1                          ; Value to compare against

        mov     dword ptr PCR[PcIrql], APC_LEVEL

   LOCK_CMPXCHG dword ptr [ecx].FmCount, edx    ; Attempt to acquire
        jnz     short tam20                     ; got it?

        pop     dword ptr [ecx].FmOldIrql       ; Store OldIrql

if DBG
        pushfd
        cli                                     ; prevent swapcontext while
                                                ; snapping current thread.
        mov     edx, PCR[PcPrcb]
        mov     edx, [edx].PbCurrentThread      ; (edx) = Current Thread
        popfd
        mov     [ecx].FmOwner, edx              ; Save in Fast Mutex
else
        ;
        ; Use esp to track the owning thread for debugging purposes.
        ; !thread from kd will find the owning thread.  Note that the
        ; owner isn't cleared on release, check if the mutex is owned
        ; first.
        ;

        mov	dword ptr [ecx].FmOwner, esp
endif
        mov     eax, 1                          ; return TRUE
        fstRet  ExTryToAcquireFastMutex

tam20:  pop     dword ptr PCR[PcIrql]           ; restore entry Irql
        YIELD
        xor     eax, eax                        ; return FALSE
        fstRet  ExTryToAcquireFastMutex         ; all done

if DBG
        ; KeBugCheckEx(IRQL_NOT_LESS_OR_EQUAL, CurrentIrql, APC_LEVEL, 0, 5)
        ; (never returns)

tam99:  movzx   eax, al
        stdCall _KeBugCheckEx,<IRQL_NOT_LESS_OR_EQUAL,eax,APC_LEVEL,0,7>

        xor     eax, eax                        ; return FALSE
        fstRet  ExTryToAcquireFastMutex
endif

fstENDP ExTryToAcquireFastMutex

        page    ,132
        subttl  "Acquire Queued SpinLock"

;++
;
; KIRQL
; KeAcquireQueuedSpinLock (
;     IN KSPIN_LOCK_QUEUE_NUMBER Number
;     )
;
; KIRQL
; KeAcquireQueuedSpinLockRaiseToSynch (
;     IN KSPIN_LOCK_QUEUE_NUMBER Number
;     )
;
; VOID
; KeAcquireInStackQueuedSpinLock (
;     IN PKSPIN_LOCK SpinLock,
;     IN PKLOCK_QUEUE_HANDLE LockHandle
;     )
;
; VOID
; KeAcquireInStackQueuedSpinLockRaiseToSynch (
;     IN PKSPIN_LOCK SpinLock,
;     IN PKLOCK_QUEUE_HANDLE LockHandle
;     )
;
; Routine Description:
;
;    This function raises the current IRQL to DISPATCH/SYNCH level
;    and acquires the specified queued spinlock.
;
; Arguments:
;
;    Number (ecx) - Supplies the queued spinlock number.
;
; Return Value:
;
;    The previous IRQL is returned as the function value.
;
;
; Routine Description:
;
;    The Kx versions use a LOCK_QUEUE_HANDLE structure rather than
;    LOCK_QUEUE structures in the PRCB.   Old IRQL is stored in the
;    LOCK_QUEUE_HANDLE.
;
; Arguments:
;
;    SpinLock   (ecx) Address of Actual Lock.
;    LockHandle (edx) Address of lock context.
;
; Return Value:
;
;   None.  Actually returns OldIrql because common code is used
;          for all implementations.
;
;--

        ; compile time assert sizeof(KSPIN_LOCK_QUEUE) == 8

        .errnz  (LOCK_QUEUE_HEADER_SIZE - 8)


; VOID
; KeAcquireInStackQueuedSpinLockRaiseToSynch (
;     IN PKSPIN_LOCK SpinLock,
;     IN PKLOCK_QUEUE_HANDLE LockHandle
;     )

align 16
cPublicFastCall KeAcquireInStackQueuedSpinLockRaiseToSynch,2
cPublicFpo 0,1

        push    SYNCH_LEVEL                     ; raise to SYNCH_LEVEL
        jmp     short aqsl5                     ; continue in common code

fstENDP KeAcquireInStackQueuedSpinLockRaiseToSynch


; VOID
; KeAcquireInStackQueuedSpinLockRaiseToSynch (
;     IN PKSPIN_LOCK SpinLock,
;     IN PKLOCK_QUEUE_HANDLE LockHandle
;     )

cPublicFastCall KeAcquireInStackQueuedSpinLock,2
cPublicFpo 0,1

        ; Get old IRQL and raise to DISPATCH_LEVEL

        push    DISPATCH_LEVEL
aqsl5:
        pop     eax
        push    dword ptr PCR[PcIrql]
        mov     dword ptr PCR[PcIrql], eax

if DBG
        cmp     [esp], eax
        ja      short aqsl
endif

ifndef NT_UP

        ; store OldIrql and address of actual lock in the queued
        ; spinlock structure in the lock queue handle structure.

        mov     eax, [esp]
        mov     [edx].LqhLock, ecx
        mov     dword ptr [edx].LqhNext, 0
        mov     [edx].LqhOldIrql, al

        ; continue in common code.  common code expects the
        ; address of the "lock structure" in edx, this is at
        ; offset LqhNext in the lock queue handle structure.
        ; not accidentally this offset is zero.

        .errnz  LqhNext
;;      lea     edx, [edx].LqhNext
        jmp     short aqsl15                    ; continue in common code

else

        pop     eax                             ; get old irql and set
        mov     [edx].LqhOldIrql, al            ; in lock queue handle.

ifdef IRQL_METRICS
        inc     HalRaiseIrqlCount
endif

        fstRET  KeAcquireInStackQueuedSpinLock

endif

fstENDP KeAcquireInStackQueuedSpinLock


; KIRQL
; KeAcquireQueuedSpinLockRaiseToSynch (
;     IN KSPIN_LOCK_QUEUE_NUMBER Number
;     )

cPublicFastCall KeAcquireQueuedSpinLockRaiseToSynch,1
cPublicFpo 0,1

        push    SYNCH_LEVEL
        jmp     short aqsl10                    ; continue in common code

fstENDP KeAcquireQueuedSpinLockRaiseToSynch


; KIRQL
; KeAcquireQueuedSpinLock (
;     IN KSPIN_LOCK_QUEUE_NUMBER Number
;     )
;

cPublicFastCall KeAcquireQueuedSpinLock,1
cPublicFpo 0,1

        ; Get old IRQL and raise to DISPATCH_LEVEL

        push    DISPATCH_LEVEL
aqsl10:
        pop     eax
        push    dword ptr PCR[PcIrql]
        mov     dword ptr PCR[PcIrql], eax

if DBG
        cmp     [esp], eax
        ja      short aqsl
endif

ifndef NT_UP

        ; Get address of Lock Queue entry

        mov     edx, PCR[PcPrcb]                ; get address of PRCB
        lea     edx, [edx+ecx*8].PbLockQueue    ; get &PRCB->LockQueue[Number]

        ; Get address of the actual lock.

        mov     ecx, [edx].LqLock
aqsl15:
        mov     eax, edx                        ; save Lock Queue entry address

        ; Exchange the value of the lock with the address of this
        ; Lock Queue entry.

        xchg    [ecx], edx

        cmp     edx, 0                          ; check if lock is held
        jnz     short @f                        ; jiff held

        ; note: the actual lock address will be word aligned, we use
        ; the bottom two bits as indicators, bit 0 is LOCK_QUEUE_WAIT,
        ; bit 1 is LOCK_QUEUE_OWNER.

        or      ecx, LOCK_QUEUE_OWNER           ; mark self as lock owner
        mov     [eax].LqLock, ecx

        ; lock has been acquired, return.

endif

aqsl20: pop     eax                             ; restore return value

ifdef IRQL_METRICS
        inc     HalRaiseIrqlCount
endif

        fstRET  KeAcquireQueuedSpinLock

ifndef NT_UP

@@:
        ; The lock is already held by another processor.  Set the wait
        ; bit in this processor's Lock Queue entry, then set the next
        ; field in the Lock Queue entry of the last processor to attempt
        ; to acquire the lock (this is the address returned by the xchg
        ; above) to point to THIS processor's lock queue entry.

        or      ecx, LOCK_QUEUE_WAIT            ; set lock bit
        mov     [eax].LqLock, ecx

        mov     [edx].LqNext, eax               ; set previous acquirer's
                                                ; next field.

        ; Wait.
@@:
        YIELD                                   ; fire avoidance.
        test    [eax].LqLock, LOCK_QUEUE_WAIT   ; check if still waiting
        jz      short aqsl20                    ; jif lock acquired
        jmp     short @b                        ; else, continue waiting

endif

if DBG

        ; Raising to a lower IRQL. BugCheck.
        ;
        ; KeBugCheckEx(IRQL_NOT_GREATER_OR_EQUAL,
        ;              current (old) IRQL,
        ;              desired IRQL,
        ;              lock number (only if Ke routine, not Kx),
        ;              8);

aqsl:   pop     edx
        stdCall _KeBugCheckEx,<IRQL_NOT_GREATER_OR_EQUAL,edx,eax,ecx,8>
        ; never returns (but help the debugger back-trace)
        int     3

endif

fstENDP KeAcquireQueuedSpinLock


        page    ,132
        subttl  "Release Queued SpinLock"

;++
;
; VOID
; KeReleaseInStackQueuedSpinLock (
;     IN PKLOCK_QUEUE_HANDLE LockHandle
;     )
;
; Routine Description:
;
;    This function releases a queued spinlock and lowers the IRQL to
;    its previous value.
;
;    This differs from KeReleaseQueuedSpinLock in that this version
;    uses a caller supplied lock context where that one uses a
;    predefined lock context in the processor's PRCB.
;
;    This version sets up a compatible register context and uses
;    KeReleaseQueuedSpinLock to do the actual work.
;
; Arguments:
;
;    LockHandle (ecx) - Address of Lock Queue Handle structure.
;
; Return Value:
;
;    None.
;
;--

cPublicFastCall KeReleaseInStackQueuedSpinLock,1
cPublicFpo 0,0

        movzx   edx, byte ptr [ecx].LqhOldIrql  ; get old irql

ifndef NT_UP

        lea     eax, [ecx].LqhNext              ; get address of lock struct
        jmp     short rqsl10                    ; continue in common code

else

        jmp     short rqsl30                    ; continue in common code

endif


fstENDP KeReleaseInStackQueuedSpinLock


;++
;
; VOID
; KeReleaseQueuedSpinLock (
;     IN KSPIN_LOCK_QUEUE_NUMBER Number,
;     IN KIRQL                   OldIrql
;     )
;
; Routine Description:
;
;    This function releases a queued spinlock and lowers the IRQL to
;    its previous value.
;
; Arguments:
;
;    Number  (ecx) - Supplies the queued spinlock number.
;    OldIrql (dl)  - Supplies the IRQL value to lower to.
;
; Return Value:
;
;    None.
;
;--

cPublicFastCall KeReleaseQueuedSpinLock,2
cPublicFpo 0,0

ifndef NT_UP

        ; Get address of Lock Queue entry

        mov     eax, PCR[PcPrcb]                ; get address of PRCB
        lea     eax, [eax+ecx*8].PbLockQueue    ; get &PRCB->LockQueue[Number]
rqsl10:
        push    ebx                             ; need another register
cPublicFpo 0,1

        ; Clear the lock field in the Lock Queue entry.
        mov     ebx, [eax].LqNext
        mov     ecx, [eax].LqLock
;;        and     ecx, NOT (LOCK_QUEUE_OWNER)     ; clear lock bit

        ; Quick check: If Lock Queue entry's Next field is not NULL,
        ; there is another waiter.  Don't bother with ANY atomic ops
        ; in this case.
        ;
        ; Note: test clears CF and sets ZF appropriately, the following
        ; btr sets CF appropriately for the owner check.

        test    ebx, ebx

        ; clear the "I am owner" bit in the Lock entry.

        btr     ecx, 1                          ; clear owner bit

if DBG

        jnc     short rqsl98                    ; bugcheck if was not set
                                                ; tests CF
endif

        mov     [eax].LqLock, ecx               ; clear lock bit in queue entry
        jnz     short rqsl40                    ; jif another processor waits

        ; ebx contains zero here which will be used to set the new owner NULL

        push    eax                             ; save &PRCB->LockQueue[Number]
cPublicFpo 0,2

        ; Use compare exchange to attempt to clear the actual lock.
        ; If there are still no processors waiting for the lock when
        ; the compare exchange happens, the old contents of the lock
        ; should be the address of this lock entry (eax).

        lock cmpxchg [ecx], ebx                 ; store 0 if no waiters
        pop     eax                             ; restore lock queue address
cPublicFpo 0,1
        jnz     short rqsl60                    ; jif store failed

        ; The lock has been released.  Lower IRQL and return to caller.

rqsl20:
        pop     ebx                             ; restore ebx
cPublicFpo 0,0

endif

rqsl30:
        pushfd                                  ; disable interrupts
        cli

        movzx   edx, dl
        xor     ecx, ecx
        mov     dword ptr PCR[PcIrql], edx      ; set new (lower) OldIrql
        mov     cl, dl                          ; ecx = zero extended OldIrql

        mov     edx, PCR[PcIRR]                 ; Check interrupt requests
        and     edx, FindHigherIrqlMask[ecx*4]  ; edx = pending interrupts
                                                ; enabled by lower IRQL.
        jne     short rqsl80                    ; Dispatch pending interrupts.

        popfd                                   ; restore interrupt state

        fstRET  KeReleaseQueuedSpinLock

ifndef NT_UP

        ; Another processor is waiting on this lock.   Hand the lock
        ; to that processor by getting the address of its LockQueue
        ; entry, turning ON its owner bit and OFF its wait bit.

rqsl40: xor     [ebx].LqLock, (LOCK_QUEUE_OWNER+LOCK_QUEUE_WAIT)

        ; Done, the other processor now owns the lock, clear the next
        ; field in my LockQueue entry (to preserve the order for entering
        ; the queue again) and proceed to lower IRQL and return.

        mov     [eax].LqNext, 0
        jmp     short rqsl20


        ; We get here if another processor is attempting to acquire
        ; the lock but had not yet updated the next field in this
        ; processor's Queued Lock Next field.   Wait for the next
        ; field to be updated.

rqsl60: mov     ebx, [eax].LqNext
        test    ebx, ebx                        ; check if still 0
        jnz     short rqsl40                    ; jif Next field now set.
        YIELD                                   ; wait a bit
        jmp     short rqsl60                    ; continue waiting

endif

cPublicFpo 0,1
rqsl80: bsr     ecx, edx                        ; (ecx) = Pending irq level
        cmp     ecx, DISPATCH_LEVEL             ; if new int at dispatch level
        jle     short @f                        ; no need to change 8259 masks

        mov     eax, PCR[PcIDR]                 ; Clear all the interrupt
        SET_8259_MASK                           ; masks
@@:
        mov     edx, 1
        shl     edx, cl
        xor     PCR[PcIRR], edx                 ; clear bit in IRR
        call    SWInterruptHandlerTable[ecx*4]  ; Dispatch the pending int.
        popfd

cPublicFpo 0, 0
        fstRet  KfReleaseSpinLock               ; all done

ifndef NT_UP

if DBG

cPublicFpo 0,1

rqsl98: stdCall _KeBugCheckEx,<SPIN_LOCK_NOT_OWNED,ecx,eax,0,1>
        int     3                               ; so stacktrace works

endif

endif

fstENDP KeReleaseQueuedSpinLock

        page    ,132
        subttl  "Try to Acquire Queued SpinLock"

;++
;
; LOGICAL
; KeTryToAcquireQueuedSpinLock (
;     IN  KSPIN_LOCK_QUEUE_NUMBER Number,
;     OUT PKIRQL OldIrql
;     )
;
; LOGICAL
; KeTryToAcquireQueuedSpinLockRaiseToSynch (
;     IN  KSPIN_LOCK_QUEUE_NUMBER Number,
;     OUT PKIRQL OldIrql
;     )
;
; Routine Description:
;
;    This function raises the current IRQL to DISPATCH/SYNCH level
;    and attempts to acquire the specified queued spinlock.  If the
;    spinlock is already owned by another thread, IRQL is restored
;    to its previous value and FALSE is returned.
;
; Arguments:
;
;    Number  (ecx) - Supplies the queued spinlock number.
;    OldIrql (edx) - A pointer to the variable to receive the old
;                    IRQL.
;
; Return Value:
;
;    TRUE if the lock was acquired, FALSE otherwise.
;    N.B. ZF is set if FALSE returned, clear otherwise.
;
;--


align 16
cPublicFastCall KeTryToAcquireQueuedSpinLockRaiseToSynch,2
cPublicFpo 0,0

        mov     eax, SYNCH_LEVEL                ; raise to SYNCH
        jmp     short taqsl10                   ; continue in common code

fstENDP KeTryToAcquireQueuedSpinLockRaiseToSynch


cPublicFastCall KeTryToAcquireQueuedSpinLock,2
cPublicFpo 0,0

        mov     eax, DISPATCH_LEVEL             ; raise to DPC level

        ; Attempt to get the lock with interrupts disabled, raising
        ; the priority in the interrupt controller only if acquisition
        ; is successful.
taqsl10:

if DBG
        cmp     al, PCR[PcIrql]
        jb      short taqsl98
endif

ifndef NT_UP

        push    edx                             ; save address of OldIrql
        pushfd                                  ; save interrupt state
        cli                                     ; disable interrupts

        ; Get address of Lock Queue entry

        mov     edx, PCR[PcPrcb]                ; get address of PRCB
        lea     edx, [edx+ecx*8].PbLockQueue    ; get &PRCB->LockQueue[Number]

        ; Get address of the actual lock.

        mov     ecx, [edx].LqLock

if DBG

        test    ecx, LOCK_QUEUE_OWNER+LOCK_QUEUE_WAIT
        jnz     short taqsl99                   ; jiff lock already held (or
                                                ; this proc already waiting).
endif

        cmp     dword ptr [ecx], 0              ; check if already taken
        push    eax                             ; save new IRQL
        jnz     taqsl60                         ; jif already taken
        xor     eax, eax                        ; comparison value (not locked)


        ; Store the Lock Queue entry address in the lock ONLY if the
        ; current lock value is 0.

        lock cmpxchg [ecx], edx
        jnz     short taqsl60

        ; Lock has been acquired.

        ; note: the actual lock address will be word aligned, we use
        ; the bottom two bits as indicators, bit 0 is LOCK_QUEUE_WAIT,
        ; bit 1 is LOCK_QUEUE_OWNER.

        or      ecx, LOCK_QUEUE_OWNER           ; mark self as lock owner
        mov     [edx].LqLock, ecx

        pop     eax

endif

        ; Raise IRQL and return success.

        mov     ecx, PCR[PcIrql]                ; ecx = OldIrql
        mov     dword ptr PCR[PcIrql], eax      ; set new IRQL

ifndef NT_UP

        popfd                                   ; restore interrupt state
        pop     edx

endif

        mov     [edx], cl                       ; *OldIrql = OldIrql
        xor     eax, eax
        or      eax, 1                          ; return TRUE

        fstRET  KeTryToAcquireQueuedSpinLock

ifndef NT_UP

taqsl60:
        ; The lock is already held by another processor.  Indicate
        ; failure to the caller.

        pop     eax                             ; pop new IRQL off stack
        popfd                                   ; restore interrupt state
        pop     edx                             ; pop saved OldIrql address
        xor     eax, eax                        ; return FALSE
        fstRET  KeTryToAcquireQueuedSpinLock

endif

if DBG

taqsl98: stdCall _KeBugCheckEx,<IRQL_NOT_GREATER_OR_EQUAL,PCR[PcIrql],eax,ecx,9>
taqsl99: stdCall _KeBugCheckEx,<SPIN_LOCK_ALREADY_OWNED,ecx,edx,0,0>
        ; never returns (help the debugger back-trace)
        int     3

endif

fstENDP KeTryToAcquireQueuedSpinLock
_TEXT$01   ends

        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halx86\i386\ixmca.c ===
/*++

Module Name:

    ixmca.c

Abstract:

    HAL component of the Machine Check Architecture.
    All exported MCA functionality is present in this file.

Author:

    Srikanth Kambhatla (Intel)

Revision History:

    Anil Aggarwal (Intel)
        Changes incorporated as per design review with Microsoft

--*/

#include <bugcodes.h>
#include <halp.h>
#include <stdlib.h>
#include <stdio.h>
#include <nthal.h>

//
// Structure to keep track of MCA features available on installed hardware
//

typedef struct _MCA_INFO {
    FAST_MUTEX          Mutex;
    UCHAR               NumBanks;           // Number of Banks present
    ULONGLONG           Bank0Config;        // Bank0 configuration setup by BIOS.
                                            // This will be used as mask when
                                            // setting up bank 0
    MCA_DRIVER_INFO     DriverInfo;         // Info about registered driver
    KERNEL_MCA_DELIVERY WmiMcaCallback;     // WMI corrected MC handler

} MCA_INFO, *PMCA_INFO;


//
// Default MCA Bank configuration
//
#define MCA_DEFAULT_BANK_CONF       0xFFFFFFFFFFFFFFFF

//
// MCA architecture related defines
//

#define MCA_NUM_REGS        4

#define MCE_VALID           0x01
#define MCA_VECTOR          18

//
// MSR register addresses for MCA
//

#define MCG_CAP             0x179
#define MCG_STATUS          0x17a
#define MCG_CTL             0x17b
#define MCG_EAX             0x180
#define MCG_EBX             0x181
#define MCG_ECX             0x182
#define MCG_EDX             0x183
#define MCG_ESI             0x184
#define MCG_EDI             0x185
#define MCG_EBP             0x186
#define MCG_ESP             0x187
#define MCG_EFLAGS          0x188
#define MCG_EIP             0x189
#define MC0_CTL             0x400
#define MC0_STATUS          0x401
#define MC0_ADDR            0x402
#define MC0_MISC            0x403

#define PENTIUM_MC_ADDR     0x0
#define PENTIUM_MC_TYPE     0x1

//
// Bit Masks for MCG_CAP
//
#define MCA_CNT_MASK        0xFF
#define MCG_CTL_PRESENT     0x100
#define MCG_EXT_PRESENT     0x200
typedef struct _MCG_CAPABILITY {
    union {
        struct {
            ULONG       McaCnt:8;
            ULONG       McaCntlPresent:1;
            ULONG       McaExtPresent:1;
            ULONG       Reserved_1: 6;
            ULONG       McaExtCnt: 8;
            ULONG       Reserved_2: 8;
            ULONG       Reserved_3;
        } hw;
        ULONGLONG       QuadPart;
    } u;
} MCG_CAPABILITY, *PMCG_CAPABILITY;

//
// V2 defines up through Eip
//

#define MCG_EFLAGS_OFFSET      (MCG_EFLAGS-MCG_EAX+1)

//
// Writing all 1's to MCG_CTL register enables logging.
//

#define MCA_MCGCTL_ENABLE_LOGGING      0xffffffffffffffff

//
// Bit interpretation of MCG_STATUS register
//

#define MCG_MC_INPROGRESS       0x4
#define MCG_EIP_VALID           0x2
#define MCG_RESTART_EIP_VALID   0x1

//
// Defines for the size of TSS and the initial stack to operate on
//
#define MINIMUM_TSS_SIZE 0x68

//
// Global Varibles
//

MCA_INFO            HalpMcaInfo;
BOOLEAN             HalpMcaInterfaceLocked = FALSE;
extern KAFFINITY    HalpActiveProcessors;
#if !defined(_WIN64) || defined(PICACPI)
extern UCHAR        HalpClockMcaQueueDpc;
#endif

extern UCHAR        MsgMCEPending[];
extern WCHAR        rgzSessionManager[];
extern WCHAR        rgzEnableMCE[];
extern WCHAR        rgzEnableMCA[];
extern WCHAR        rgzEnableCMC[];
extern WCHAR        rgzNoMCABugCheck[];
extern UCHAR        HalpGenuineIntel[];
extern UCHAR        HalpAuthenticAMD[];


//
// External prototypes
//

VOID
HalpMcaCurrentProcessorSetTSS (
    IN PULONG   pTSS
    );

VOID
HalpSetCr4MCEBit (
    VOID
    );

//
// Internal prototypes
//

VOID
HalpMcaInit (
    VOID
    );

NTSTATUS
HalpMcaReadProcessorException (
    IN OUT PMCA_EXCEPTION  Exception,
    IN BOOLEAN  NonRestartableOnly
    );

VOID
HalpMcaQueueDpc(
    VOID
    );

VOID
HalpMcaGetConfiguration (
    OUT PULONG  MCEEnabled,
    OUT PULONG  MCAEnabled,
    OUT PULONG  CMCEnabled,
    OUT PULONG  NoMCABugCheck
    );

VOID
HalpMcaLockInterface(
    VOID
    );

VOID
HalpMcaUnlockInterface(
    VOID
    );

NTSTATUS
HalpMcaReadRegisterInterface(
    IN     UCHAR           BankNumber,
    IN OUT PMCA_EXCEPTION  Exception
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT, HalpMcaInit)
#pragma alloc_text(PAGELK, HalpMcaCurrentProcessorSetConfig)
#pragma alloc_text(INIT, HalpMcaGetConfiguration)
#pragma alloc_text(PAGE, HalpGetMcaLog)
#pragma alloc_text(PAGE, HalpMceRegisterKernelDriver)
#pragma alloc_text(PAGE, HalpMcaRegisterDriver)
#pragma alloc_text(PAGE, HalpMcaLockInterface)
#pragma alloc_text(PAGE, HalpMcaUnlockInterface)
#pragma alloc_text(PAGE, HalpGetMceInformation)

#endif

// Set the following to check async capability

ULONG HalpCMCEnabled = 0;
ULONG HalpNoMCABugCheck = FALSE;
BOOLEAN HalpMcaBlockErrorClearing = FALSE;

//
// HalpClearMachineCheckStatusRegistersOnInit indicates whether this is a
// pre-P4 processor that needs to have its machine check status registers
// cleared during initialization (boot or resume from hibernate). See
// HalpMcaInit().
//

BOOLEAN HalpClearMachineCheckStatusRegistersOnInit = FALSE;

VOID
HalpMcaLockInterface(
    VOID
    )
{
    ExAcquireFastMutex(&HalpMcaInfo.Mutex);

#if DBG

    ASSERT(HalpMcaInterfaceLocked == FALSE);
    HalpMcaInterfaceLocked = TRUE;

#endif
        
}

VOID
HalpMcaUnlockInterface(
    VOID
    )
{
#if DBG

    ASSERT(HalpMcaInterfaceLocked == TRUE);
    HalpMcaInterfaceLocked = FALSE;

#endif
        
    ExReleaseFastMutex(&HalpMcaInfo.Mutex);

}

//
// All the initialization code for MCA goes here
//

VOID
HalpMcaInit (
    VOID
    )

/*++
    Routine Description:
        This routine is called to do all the initialization work

    Arguments:
        None

    Return Value:
        STATUS_SUCCESS if successful
        error status otherwise
--*/

{
    ULONGLONG   MsrCapability;
    KIRQL       OldIrql;
    KAFFINITY   ActiveProcessors, CurrentAffinity;
    ULONGLONG   MsrMceType;
    ULONG       MCEEnabled;
    ULONG       MCAEnabled;
    PULONG      pTSS;
    PKPRCB      Prcb;
    ULONG       Junk;

    //
    // This lock synchronises access to the log area when we call the
    // logger on multiple processors.
    //
    // Note: This must be initialized regardless of whether or not
    // this processor supports MCA.
    //

    ExInitializeFastMutex (&HalpMcaInfo.Mutex);

    //
    // If this processor does not support MCA, nothing more to do.
    //

    if ( (!(HalpFeatureBits & HAL_MCE_PRESENT)) &&
         (!(HalpFeatureBits & HAL_MCA_PRESENT)) ) {

         return;  // nothing to do
    }

    HalpMcaGetConfiguration(&MCEEnabled, &MCAEnabled, &HalpCMCEnabled, &HalpNoMCABugCheck);

    if ( (HalpFeatureBits & HAL_MCE_PRESENT) &&
         (!(HalpFeatureBits & HAL_MCA_PRESENT)) ) {

        if (MCEEnabled == FALSE) {

            // User has not enabled MCE capability.
            HalpFeatureBits &= ~(HAL_MCE_PRESENT | HAL_MCA_PRESENT);

            return;
        }

#if DBG
        DbgPrint("MCE feature is enabled via registry\n");
#endif // DBG

        MsrMceType = RDMSR(PENTIUM_MC_TYPE);

        if (((PLARGE_INTEGER)(&MsrMceType))->LowPart & MCE_VALID) {

            //
            // On an AST PREMMIA MX machine we seem to have a Machine
            // Check Pending always.
            //

            HalDisplayString(MsgMCEPending);
            HalpFeatureBits &= ~(HAL_MCE_PRESENT | HAL_MCA_PRESENT);
            return;
        }
    }

    //
    // If MCA is available, find out the number of banks available and
    // also get the platform specific bank 0 configuration
    //

    if ( HalpFeatureBits & HAL_MCA_PRESENT ) {

        if (MCAEnabled == FALSE) {

            //
            // User has disabled MCA capability.
            //
#if DBG
            DbgPrint("MCA feature is disabled via registry\n");
#endif // DBG

            HalpFeatureBits &= ~(HAL_MCE_PRESENT | HAL_MCA_PRESENT);
            return;
        }

        MsrCapability = RDMSR(MCG_CAP);
        HalpMcaInfo.NumBanks = (UCHAR)(MsrCapability & MCA_CNT_MASK);

        if (HalpMcaInfo.NumBanks == 0) {

            //
            // The processor claims to support MCA, but it doesn't have any
            // MCA error reporting banks. Don't enable either MCA or MCE.
            //
            // The VMWare "processor" falls into this category. It reports
            // HAL_MCE_PRESENT and HAL_MCA_PRESENT, but any attempt to read
            // MCA-related MSRs returns all zeros.
            //

            HalpFeatureBits &= ~(HAL_MCE_PRESENT | HAL_MCA_PRESENT);
            return;
        }

        //
        // Find out the Bank 0 configuration setup by BIOS. This will be used
        // as a mask when writing to Bank 0
        //

        HalpMcaInfo.Bank0Config = RDMSR(MC0_CTL);
    }

    ASSERT(HalpFeatureBits & HAL_MCE_PRESENT);

    //
    // If this is an older x86, we will clear the status register for each
    // bank during init. Pentium IIIs and older don't support the retention of
    // machine check information across a warm reset. However, some BIOSes
    // don't properly clear the machine check registers during init, resulting
    // in spurious eventlog entries that do not indicate a reliability problem.
    // We clear the status registers during init so that they are at least in a
    // consistent state.
    //
    // A similar situation seems to hold for pre-K8 AMD processors.
    //
    // Current IA32-compatible processors made by other manufacturers are known
    // not to support MCA, so there are no machine check registers.
    //
    // Assume that this is a processor for which we don't want trust the
    // state of the machine check registers across a reset. We will clear
    // the status registers on init.
    //

    HalpClearMachineCheckStatusRegistersOnInit = TRUE;

    //
    // Determine whether this is a processor on which warm boot MCA
    // information is to be trusted.
    //

    Prcb = KeGetCurrentPrcb();

    if (Prcb->CpuID) {

        UCHAR Buffer[13];

        //
        // Determine the processor type
        //

        HalpCpuID (0, &Junk, (PULONG) Buffer+0, (PULONG) Buffer+2, (PULONG) Buffer+1);
        Buffer[12] = 0;

        if ( ((strcmp(Buffer, HalpGenuineIntel) == 0) ||
              (strcmp(Buffer, HalpAuthenticAMD) == 0)) &&
             (Prcb->CpuType >= 0xF) ) {

            //
            // This is an:
            //     Intel P4 processor or greater
            //     AMD K8 processor or greater
            //
            // We can trust the state of the machine check registers on
            // this processor.
            //
        
            HalpClearMachineCheckStatusRegistersOnInit = FALSE;
        }
    }
        

    //
    // Initialize on each processor
    //

    ActiveProcessors = HalpActiveProcessors;
    for (CurrentAffinity = 1; ActiveProcessors; CurrentAffinity <<= 1) {

        if (ActiveProcessors & CurrentAffinity) {

            ActiveProcessors &= ~CurrentAffinity;
            KeSetSystemAffinityThread (CurrentAffinity);

            //
            // Initialize MCA support on this processor
            //

            //
            // Allocate memory for this processor's TSS and it's own
            // private stack
            //
            pTSS   = (PULONG)ExAllocatePoolWithTag(NonPagedPool,
                                                   MINIMUM_TSS_SIZE,
                                                   HAL_POOL_TAG
                                                   );

            if (!pTSS) {

                //
                // This allocation is critical.
                //

                KeBugCheckEx(HAL_MEMORY_ALLOCATION,
                             MINIMUM_TSS_SIZE,
                             2,
                             (ULONG_PTR)__FILE__,
                             __LINE__
                             );
            }

            RtlZeroMemory(pTSS, MINIMUM_TSS_SIZE);
           
            OldIrql = KfRaiseIrql(HIGH_LEVEL);

            HalpMcaCurrentProcessorSetTSS(pTSS);
            HalpMcaCurrentProcessorSetConfig();

            KeLowerIrql(OldIrql);
        }
    }

    //
    // Restore threads affinity
    //

    KeRevertToUserAffinityThread();
}


VOID
HalpMcaCurrentProcessorSetConfig (
    VOID
    )
/*++

    Routine Description:

        This routine sets/modifies the configuration of the machine check
        architecture on the current processor. Input is specification of
        the control register MCi_CTL for each bank of the MCA architecture.
        which controls the generation of machine check exceptions for errors
        logged to that bank.

        If MCA is not available on this processor, check if MCE is available.
        If so, enable MCE in CR4

    Arguments:

        Context: Array of values of MCi_CTL for each bank of MCA.
                    If NULL, use MCA_DEFAULT_BANK_CONF values for each bank

    Return Value:

        None

--*/
{
    ULONGLONG   MciCtl;
    ULONGLONG   McgCap;
    ULONGLONG   McgCtl;
    ULONG       BankNum;
    if (HalpFeatureBits & HAL_MCA_PRESENT) {
        //
        // MCA is available. Initialize MCG_CTL register if present
        // Writing all 1's enable MCE or MCA Error Exceptions
        //

        McgCap = RDMSR(MCG_CAP);

        if (McgCap & MCG_CTL_PRESENT) {
            McgCtl = MCA_MCGCTL_ENABLE_LOGGING;
            WRMSR(MCG_CTL, McgCtl);
        }

        //
        // Enable all MCA errors
        //
        for ( BankNum = 0; BankNum < HalpMcaInfo.NumBanks; BankNum++ ) {

            //
            // If this is an older x86, clear the status register for this
            // bank. See HalpMcaInit() for more information about why this
            // is necessary.
            //

            if (HalpClearMachineCheckStatusRegistersOnInit) {
                WRMSR(MC0_STATUS + (BankNum * MCA_NUM_REGS), 0);
            }

            //
            // Use MCA_DEFAULT_BANK_CONF for each bank
            //

            MciCtl = MCA_DEFAULT_BANK_CONF;

            //
            // If this is bank 0, use HalpMcaInfo.Bank0Config as a mask
            //
            if (BankNum == 0) {
                MciCtl &= HalpMcaInfo.Bank0Config;
            }

            WRMSR(MC0_CTL + (BankNum * MCA_NUM_REGS), MciCtl);
        }
    }

    //
    // Enable MCE bit in CR4
    //

    HalpSetCr4MCEBit();
}

NTSTATUS
HalpMceRegisterKernelDriver(
    IN PKERNEL_ERROR_HANDLER_INFO DriverInfo,
    IN ULONG                      InfoSize
    )
/*++
    Routine Description:
        This routine is called by the kernel (via HalSetSystemInformation)
        to register its presence. This is mostly for WMI callbacks registration.

    Arguments:
        DriverInfo: Contains kernel info about the callbacks and associated objects.

    Return Value:
        Unless a MCA driver is already registered OR one of the two callback
        routines are NULL, this routine returns Success.

    Implementation Notes:
        - the current implementation assumes the kernel registers its callbacks
          earlier than a driver will. The current kernel registration is done by
          WMI and should be done at WMI-Phase 0.
        - the registrations do not consider if the HAL supports or not the MCA
          functionalities. It simply registers the callbacks if no other callback was
          registered before. This allows us to allow some flexibility if a machine event
          functionality is enabled AFTER the hal initialization (e.g. HalpGetFeatureBits())
          through the mean of a registry key or driver event, for example.

--*/

{
    NTSTATUS status;
    
    PAGED_CODE();

    if ( DriverInfo == NULL )  {
        return STATUS_INVALID_PARAMETER;
    }

    //
    // Backward compatibility only.
    //

    if ( (DriverInfo->Version != 0) && 
         (DriverInfo->Version > KERNEL_ERROR_HANDLER_VERSION) )  {
        return STATUS_REVISION_MISMATCH;
    }

    //
    // Register Kernel MCA notification.
    //

    status = STATUS_UNSUCCESSFUL;

    HalpMcaLockInterface();
    if ( HalpMcaInfo.WmiMcaCallback == NULL ) {
        HalpMcaInfo.WmiMcaCallback = DriverInfo->KernelMcaDelivery;
        status = STATUS_SUCCESS;
    }
    HalpMcaUnlockInterface();

    return status;

} // HalpMceRegisterKernelDriver

NTSTATUS
HalpMcaRegisterDriver(
    IN PMCA_DRIVER_INFO DriverInfo
    )
/*++
    Routine Description:
        This routine is called by the driver (via HalSetSystemInformation)
        to register its presence. Only one driver can be registered at a time.

    Arguments:
        DriverInfo: Contains info about the callback routine and the DriverObject

    Return Value:
        Unless a MCA driver is already registered OR one of the two callback
        routines are NULL, this routine returns Success.
--*/

{
    KIRQL       OldIrql;
    PVOID       UnlockHandle;
    NTSTATUS    Status;

    PAGED_CODE();


    Status = STATUS_UNSUCCESSFUL;

    if ( (HalpFeatureBits & HAL_MCE_PRESENT) && (DriverInfo->ExceptionCallback != NULL) ) {

        HalpMcaLockInterface();

        //
        // Register driver
        //

        if ( HalpMcaInfo.DriverInfo.ExceptionCallback == NULL ) {

            // register driver
            HalpMcaInfo.DriverInfo.ExceptionCallback = DriverInfo->ExceptionCallback;
            HalpMcaInfo.DriverInfo.DeviceContext = DriverInfo->DeviceContext;
            Status = STATUS_SUCCESS;
        }

        HalpMcaUnlockInterface();

    } else if ( DriverInfo->ExceptionCallback == NULL) {

        HalpMcaLockInterface();

        // Only deregistering myself is permitted
        if (HalpMcaInfo.DriverInfo.DeviceContext == DriverInfo->DeviceContext) {
            HalpMcaInfo.DriverInfo.ExceptionCallback = NULL;
            HalpMcaInfo.DriverInfo.DeviceContext = NULL;
            Status = STATUS_SUCCESS;
        }

        HalpMcaUnlockInterface();
    }

    return Status;
}

#define MAX_MCA_NONFATAL_RETRIES 50000 // BUGBUG
#define MCA_NONFATAL_ERORRS_BEFORE_WBINVD 3

NTSTATUS
HalpGetMcaLog (
    IN OUT PMCA_EXCEPTION  Exception,
    IN     ULONG           BufferSize,
    OUT    PULONG          Length
    )

/*++
 
Routine Description:

    This is the entry point for driver to read the bank logs
    Called by HaliQuerySystemInformation()

Arguments:

    Exception:     Buffer into which the error is reported
    BufferSize: Size of the passed buffer
    Length:     of the result

Return Value:

    Success or failure

--*/

{
    KAFFINITY        ActiveProcessors, CurrentAffinity;
    NTSTATUS         Status;
    ULONG            p1, p2;
    ULONGLONG        p3;
    static ULONG     McaStatusCount = 0;
    static ULONG     SavedBank = 0;
    static ULONGLONG SavedMcaStatus = 0;
    static KAFFINITY SavedAffinity = 0;


    PAGED_CODE();

    if (! (HalpFeatureBits & HAL_MCA_PRESENT)) {
        return(STATUS_NO_SUCH_DEVICE);
    }

    //
    // The following is a hack added for RC2 of the .NET Server release.
    // It should be removed when the HAL is changed in such a way that
    // HalpMcaCurrentProcessorSetConfig() is called on resume from
    // hibernate.
    //
    // Pentium IIIs don't support the retention of machine check
    // information across a warm reset. However, some BIOSes don't
    // properly clear the machine check registers during init, resulting
    // in spurious eventlog entries that do not indicate a reliability
    // problem. HalpMcaCurrentProcessorSetConfig() clears the status
    // registers so that they are at least in a consistent state.
    //
    // A similar situation seems to hold for pre-K8 AMD processors.
    //
    // But on resume from hibernate, HalpMcaCurrentProcessorSetConfig()
    // currently is not called. This means that spurious machine checks
    // might be present in the machine check MSRs when we get here. So
    // on older Intel x86 machines, we never return anything from the MSRs.
    //

    if (HalpClearMachineCheckStatusRegistersOnInit) {

        //
        // This is a processor for which we cannot trust the contents of the
        // MSRs. Do not return any machine check information.
        //

        return STATUS_NOT_FOUND;
    }
    
    //
    // Don't allow the logging driver to read machine check information.
    // Only WMI is allowed to retrieve this information.
    //

    if ( *(PULONG)Exception != HALP_KERNEL_TOKEN ) {
        return STATUS_NOT_FOUND;
    }

    switch (BufferSize) {

    case MCA_EXCEPTION_V1_SIZE:
        Exception->VersionNumber = 1;
        break;

    case MCA_EXCEPTION_V2_SIZE:
        Exception->VersionNumber = 2;
        break;

    default:
        return(STATUS_INVALID_PARAMETER);
    }

    ActiveProcessors = HalpActiveProcessors;
    Status = STATUS_NOT_FOUND;

    HalpMcaLockInterface();

    *Length = 0;
    for (CurrentAffinity = 1; ActiveProcessors; CurrentAffinity <<= 1) {

        if (ActiveProcessors & CurrentAffinity) {

            ActiveProcessors &= ~CurrentAffinity;
            KeSetSystemAffinityThread (CurrentAffinity);

            //
            // Check this processor for an exception
            //

            Status = HalpMcaReadProcessorException (Exception, FALSE);

            //
            // Avoiding going into an infinite loop  reporting a non-fatal 
            // single bit MCA error.  This can be the result of the same
            // error being generated repeatedly by the hardware.
            //

            if (Status == STATUS_SUCCESS) {

                //
                // Check to see if the same processor is reporting the
                // same MCA status.
                //

                if ((CurrentAffinity == SavedAffinity) &&
                    (SavedBank == Exception->u.Mca.BankNumber) &&
                    (SavedMcaStatus == Exception->u.Mca.Status.QuadPart)) {

                    //
                    // Check to see if the same error is generated more than
                    // n times.  Currently n==5.  If so, bugcheck the system.
                    //
                    // N.B. This code disabled because it can cause unnecessary
                    //      bugchecks if the same error is reported infrequently
                    //      during a long system uptime.
                    //

#if 0
                    if (McaStatusCount >= MAX_MCA_NONFATAL_RETRIES) {

                        if (Exception->VersionNumber == 1) {

                            //
                            // Parameters for bugcheck
                            //

                            p1 = ((PLARGE_INTEGER)(&Exception->u.Mce.Type))->LowPart;
                            p2 = 0;
                            p3 = Exception->u.Mce.Address;

                        } else {

                            //
                            // Parameters for bugcheck
                            //

                            p1 = Exception->u.Mca.BankNumber;
                            p2 = Exception->u.Mca.Address.Address;
                            p3 = Exception->u.Mca.Status.QuadPart;
                        }
                         
                        //
                        // We need a new bugcheck code for this case.
                        //

                        KeBugCheckEx (
                            MACHINE_CHECK_EXCEPTION,
                            p1,
                            p2,
                            ((PLARGE_INTEGER)(&p3))->HighPart,
                            ((PLARGE_INTEGER)(&p3))->LowPart
                        );

                    } else
#endif
                    {

                        //
                        // This error is seen more than 1 once.  If it has
                        // occurred more than
                        // MCA_NONFATAL_ERORRS_BEFORE_WBINVD times, write
                        // back and Invalid cache to see if the error can be
                        // cleared.
                        //

                        McaStatusCount++;
                        if (McaStatusCount >=
                            MCA_NONFATAL_ERORRS_BEFORE_WBINVD) {
                            _asm {
                                wbinvd
                            }
                        } 
                    }

                } else {

                    //
                    // First time we have seen this error, save the Status,
                    // affinity and clear the count.
                    //

                    SavedMcaStatus = Exception->u.Mca.Status.QuadPart;
                    SavedBank = Exception->u.Mca.BankNumber;
                    McaStatusCount = 0;
                    SavedAffinity = CurrentAffinity;
                }

            } else {

                //
                // Either we did not get an error or it will be fatal.
                // If we did not get an error and we are doing the processor
                // that reported the last error, clear things so we do not
                // match previous errors.  Since each time we look for an
                // error we start over with the first processor we do not
                // have to worry about multiple processor having stuck
                // errors.  We will only be able to see the first one.
                //

                if (SavedAffinity == CurrentAffinity) {
                    SavedMcaStatus = 0;
                    SavedBank = 0;
                    McaStatusCount = 0;
                    SavedAffinity = 0;
                }
            }

            //
            // If found, return current information
            //

            if (Status != STATUS_NOT_FOUND) {
                ASSERT (Status != STATUS_SEVERITY_ERROR);
                *Length = BufferSize;
                break;
            }
        }
    }

    //
    // Restore threads affinity, release mutex, and return
    //

    KeRevertToUserAffinityThread();
    HalpMcaUnlockInterface();
    return Status;
}


VOID
HalpMcaExceptionHandler (
    VOID
    )

/*++
    Routine Description:
        This is the MCA exception handler.

    Arguments:
        None

    Return Value:
        None
--*/

{
    NTSTATUS        Status;
    MCA_EXCEPTION   BankLog;
    ULONG           p1;
    ULONGLONG       McgStatus, p3;

    //
    // In the event that we are going to bugcheck (likely outcome of
    // entering this routine), don't clear the MCA error logs in the
    // hardware.   We want them to be available at boot time so they
    // can be copied to the system event log.
    //

    HalpMcaBlockErrorClearing = TRUE;

    if (!(HalpFeatureBits & HAL_MCA_PRESENT) ) {

        //
        // If we have ONLY MCE (and not MCA), read the MC_ADDR and MC_TYPE
        // MSRs, print the values and bugcheck as the errors are not
        // restartable.
        //

        BankLog.VersionNumber = 1;
        BankLog.ExceptionType = HAL_MCE_RECORD;
        BankLog.u.Mce.Address = RDMSR(PENTIUM_MC_ADDR);
        BankLog.u.Mce.Type = RDMSR(PENTIUM_MC_TYPE);
        Status = STATUS_SEVERITY_ERROR;

        //
        // Parameters for bugcheck
        //

        p1 = ((PLARGE_INTEGER)(&BankLog.u.Mce.Type))->LowPart;
        p3 = BankLog.u.Mce.Address;

    } else {

        McgStatus = RDMSR(MCG_STATUS);
        ASSERT( (McgStatus & MCG_MC_INPROGRESS) != 0);

        BankLog.VersionNumber = 2;
        Status = HalpMcaReadProcessorException (&BankLog, TRUE);

        //
        // Clear MCIP bit in MCG_STATUS register
        //

        McgStatus = 0;
        WRMSR(MCG_STATUS, McgStatus);

        //
        // Parameters for bugcheck
        //

        p1 = BankLog.u.Mca.BankNumber;
        p3 = BankLog.u.Mca.Status.QuadPart;
    }

    if (Status == STATUS_SEVERITY_ERROR) {

        //
        // Call the exception callback of the driver so that
        // the error can be logged to NVRAM
        //

        if (HalpMcaInfo.DriverInfo.ExceptionCallback) {
            HalpMcaInfo.DriverInfo.ExceptionCallback (
                         HalpMcaInfo.DriverInfo.DeviceContext,
                         &BankLog
                         );
        }

        if (HalpNoMCABugCheck == FALSE) {

            //
            // Bugcheck
            //

            KeBugCheckEx(MACHINE_CHECK_EXCEPTION,
                         p1,
                         (ULONG_PTR) &BankLog,
                         ((PLARGE_INTEGER)(&p3))->HighPart,
                         ((PLARGE_INTEGER)(&p3))->LowPart);

            // NOT REACHED
        }
    }

    HalpMcaBlockErrorClearing = FALSE;

    //
    // Must be restartable. Indicate to the timer tick routine that a
    // DPC needs to be queued for WMI.
    //
    // NOTE: This used to check for the MCA logging driver being registered.
    // We no longer deliver corrected machine checks to the driver. They only
    // go to WMI.
    //

    if ( HalpMcaInfo.WmiMcaCallback != NULL ) {
        HalpClockMcaQueueDpc = 1;
    }

}

VOID
HalpMcaQueueDpc(
    VOID
    )

/*++

  Routine Description: 

    Gets called from the timer tick to tell WMI about a corrected machine
    check.

--*/

{
    ASSERT( HalpMcaInfo.WmiMcaCallback != NULL );

    HalpMcaInfo.WmiMcaCallback( (PVOID)HALP_KERNEL_TOKEN, McaAvailable, NULL );
    
}

NTSTATUS
HalpMcaReadRegisterInterface(
    IN     UCHAR           BankNumber,
    IN OUT PMCA_EXCEPTION  Exception
    )

/*++

Routine Description:

    This routine reads the given MCA register number from the
    current processor and returns the result in the Exception
    structure.

Arguments:

    BankNumber  Number of MCA Bank to be examined.
    Exception   Buffer into which the error is reported

Return Value:

    STATUS_SUCCESS      if an error was found and the data copied into
                        the excption buffer.
    STATUS_UNSUCCESSFUL if the register contains no error information.
    STATUS_NOT_FOUND    if the register number exceeds the maximum number
                        of registers.
    STATUS_INVALID_PARAMETER if the Exception record is of an unknown type.

--*/

{
    ULONGLONG   McgStatus;
    MCI_STATS   istatus;
    NTSTATUS    ReturnStatus;
    MCG_CAPABILITY cap;
    ULONG       Reg;

    //
    // Are they asking for a valid register?
    //

    if (BankNumber >= HalpMcaInfo.NumBanks) {
        return STATUS_NOT_FOUND;
    }

    //
    // The exception buffer should tell us if it's version 1 or
    // 2.   Anything else we don't know how to deal with.
    //

    if ((Exception->VersionNumber < 1) ||
        (Exception->VersionNumber > 2)) {
        return STATUS_INVALID_PARAMETER;
    }

    //
    // Read the global status register
    //

    McgStatus = RDMSR(MCG_STATUS);

    //
    // Read the Status MSR of the requested bank
    //

    istatus.QuadPart = RDMSR(MC0_STATUS + BankNumber * MCA_NUM_REGS);

    if (istatus.MciStats.Valid == 0) {

        //
        // No error in this bank.
        //

        return STATUS_UNSUCCESSFUL;
    }

    //
    // Set the return status to indicate whether execution can be continued.
    // STATUS_SUCCESS means "An exception was found, and execution can be
    // continued." STATUS_SEVERITY_ERROR means "An exception was found, and
    // execution must not be continued."
    //
    // If a machine check exception is not in progress, then execution can be
    // continued. This happens when polling for hardware-corrected errors
    // finds an error that the hardware corrected without interrupting
    // execution. (Note that this case also applies to an error that was fatal
    // to an earlier boot. The system bugchecked, and initial polling on the
    // reboot is now finding the error.)
    //
    // If a machine check exception is in progress, then execution can be
    // restarted only if the error has been corrected and the necessary
    // restart information is intact (restart EIP valid and processor context
    // not corrupt).
    //
    // This code used to check only for the restart information being valid.
    // These bits do indicate whether there is valid context for restarting
    // from an error, but there has still been an error, and unless we plan
    // to correct the error, we should not continue. Currently we do not do
    // any correction or containment in software, so all uncorrected errors
    // are fatal.
    //

    ReturnStatus = STATUS_SUCCESS;

    if ( ((McgStatus & MCG_MC_INPROGRESS) != 0) &&
         ( (istatus.MciStats.UnCorrected == 1) ||
           ((McgStatus & MCG_RESTART_EIP_VALID) == 0) ||
           (istatus.MciStats.Damage == 1) ) ) {

        ReturnStatus = STATUS_SEVERITY_ERROR;
    }

    //
    // Complete extended exception record, if requested.
    //

    if (Exception->VersionNumber == 2) {
        cap.u.QuadPart = RDMSR(MCG_CAP);
        if (cap.u.hw.McaExtCnt > 0) {
            // Get Version 2 stuff from MSRs.
            Exception->ExtCnt = cap.u.hw.McaExtCnt;
            if (Exception->ExtCnt > MCA_EXTREG_V2MAX) {
                Exception->ExtCnt = MCA_EXTREG_V2MAX;
            }
            for (Reg = 0; Reg < Exception->ExtCnt; Reg++) {
                Exception->ExtReg[Reg] = RDMSR(MCG_EAX+Reg);
            }
            if (cap.u.hw.McaExtCnt >= MCG_EFLAGS_OFFSET) {
                if (RDMSR(MCG_EFLAGS) == 0) {
                    // Let user know he got only Version 1 data.
                    Exception->VersionNumber = 1;
                }
            }
        } else {
            // Let user know he got only Version 1 data.
            Exception->VersionNumber = 1;
        }
    }

    //
    // Complete exception record
    //

    Exception->ExceptionType = HAL_MCA_RECORD;
    Exception->TimeStamp.QuadPart = 0;
    Exception->ProcessorNumber = KeGetCurrentProcessorNumber();
    Exception->Reserved1 = 0;
    Exception->u.Mca.BankNumber = BankNumber;
    RtlZeroMemory(Exception->u.Mca.Reserved2, sizeof(Exception->u.Mca.Reserved2));
    Exception->u.Mca.Status = istatus;
    Exception->u.Mca.Address.QuadPart = 0;
    Exception->u.Mca.Misc = 0;

    if (KeGetCurrentIrql() != CLOCK2_LEVEL) {
        KeQuerySystemTime(&Exception->TimeStamp);
    }

    if (istatus.MciStats.AddressValid) {
        Exception->u.Mca.Address.QuadPart =
                RDMSR(MC0_ADDR + BankNumber * MCA_NUM_REGS);
    }

    //
    // Although MiscValid should never be set on P6 it
    // seems that sometimes it is.   It is not implemented
    // on P6 and above so don't read it there.
    //

    if (istatus.MciStats.MiscValid &&
        (KeGetCurrentPrcb()->CpuType != 6)) {
        Exception->u.Mca.Misc =
                RDMSR(MC0_MISC + BankNumber * MCA_NUM_REGS);
    }

    //
    // Clear Machine Check in MCi_STATUS register
    //

    if (HalpMcaBlockErrorClearing == FALSE) {

        WRMSR(MC0_STATUS + Exception->u.Mca.BankNumber * MCA_NUM_REGS, 0);

        //
        // Clear Register state in MCG_EFLAGS
        //

        if (Exception->VersionNumber != 1) {
            WRMSR(MCG_EFLAGS, 0);
        }
    }

    //
    // When the Valid bit of status register is cleared, hardware may write
    // a new buffered error report into the error reporting area. The
    // serializing instruction is required to permit the update to complete
    //

    HalpSerialize();
    return(ReturnStatus);
}


NTSTATUS
HalpMcaReadProcessorException (
    IN OUT PMCA_EXCEPTION  Exception,
    IN BOOLEAN  NonRestartableOnly
    )

/*++

Routine Description:

    This routine logs the errors from the MCA banks on one processor.
    Necessary checks for the restartability are performed. The routine
    1> Checks for restartability, and for each bank identifies valid bank
        entries and logs error.
    2> If the error is not restartable provides additional information about
        bank and the MCA registers.
    3> Resets the Status registers for each bank

Arguments:
    Exception:  Into which we log the error if found
    NonRestartableOnly: Get any error vs. look for error that is not-restartable

Return Values:
   STATUS_SEVERITY_ERROR:   Detected non-restartable error.
   STATUS_SUCCESS:          Successfully logged bank values
   STATUS_NOT_FOUND:        No error found on any bank

--*/

{
    UCHAR       BankNumber;
    NTSTATUS    ReturnStatus = STATUS_NOT_FOUND;

    //
    // scan banks on current processor and log contents of first valid bank
    // reporting error. Once we find a valid error, no need to read remaining
    // banks. It is the application responsibility to read more errors.
    //

    for (BankNumber = 0; BankNumber < HalpMcaInfo.NumBanks; BankNumber++) {

        ReturnStatus = HalpMcaReadRegisterInterface(BankNumber, Exception);

        if ((ReturnStatus == STATUS_UNSUCCESSFUL) ||
            ((ReturnStatus == STATUS_SUCCESS) &&
             (NonRestartableOnly == TRUE))) {

            //
            // No error in this bank or only looking for non-restartable
            // errors, skip this one.
            //

            ReturnStatus = STATUS_NOT_FOUND;
            continue;
        }

        ASSERT((ReturnStatus == STATUS_SUCCESS) || 
               (ReturnStatus == STATUS_SEVERITY_ERROR));
        break;
    }

    return(ReturnStatus);
}


VOID
HalpMcaGetConfiguration (
    OUT PULONG  MCEEnabled,
    OUT PULONG  MCAEnabled,
    OUT PULONG  CMCEnabled,
    OUT PULONG  NoMCABugCheck
)

/*++

Routine Description:

    This routine stores the Machine Check configuration information.

Arguments:

    MCEEnabled - Pointer to the MCEEnabled indicator.
                 0 = False, 1 = True (0 if value not present in Registry).

    MCAEnabled - Pointer to the MCAEnabled indicator.
                 0 = False, 1 = True (1 if value not present in Registry).

Return Value:

    None.

--*/

{

    RTL_QUERY_REGISTRY_TABLE    Parameters[5];
    ULONG                       DefaultDataMCE;
    ULONG                       DefaultDataMCA;
    ULONG                       DefaultDataCMC;
    ULONG                       DefaultNoMCABugCheck;


    RtlZeroMemory(Parameters, sizeof(Parameters));
    DefaultDataMCE = *MCEEnabled = FALSE;
    DefaultDataMCA = *MCAEnabled = TRUE;
    DefaultDataCMC = *CMCEnabled = 60; // default polling interval
    DefaultNoMCABugCheck = *NoMCABugCheck = FALSE;

    //
    // Gather all of the "user specified" information from
    // the registry.
    //

    Parameters[0].Flags = RTL_QUERY_REGISTRY_DIRECT;
    Parameters[0].Name = rgzEnableMCE;
    Parameters[0].EntryContext = MCEEnabled;
    Parameters[0].DefaultType = REG_DWORD;
    Parameters[0].DefaultData = &DefaultDataMCE;
    Parameters[0].DefaultLength = sizeof(ULONG);

    Parameters[1].Flags = RTL_QUERY_REGISTRY_DIRECT;
    Parameters[1].Name = rgzEnableMCA;
    Parameters[1].EntryContext =  MCAEnabled;
    Parameters[1].DefaultType = REG_DWORD;
    Parameters[1].DefaultData = &DefaultDataMCA;
    Parameters[1].DefaultLength = sizeof(ULONG);

    Parameters[2].Flags = RTL_QUERY_REGISTRY_DIRECT;
    Parameters[2].Name = rgzEnableCMC;
    Parameters[2].EntryContext = CMCEnabled;
    Parameters[2].DefaultType = REG_DWORD;
    Parameters[2].DefaultData = &DefaultDataCMC;
    Parameters[2].DefaultLength = sizeof(ULONG);

    Parameters[3].Flags = RTL_QUERY_REGISTRY_DIRECT;
    Parameters[3].Name = rgzNoMCABugCheck;
    Parameters[3].EntryContext =  NoMCABugCheck;
    Parameters[3].DefaultType = REG_DWORD;
    Parameters[3].DefaultData = &DefaultNoMCABugCheck;
    Parameters[3].DefaultLength = sizeof(ULONG);

    RtlQueryRegistryValues(
        RTL_REGISTRY_CONTROL | RTL_REGISTRY_OPTIONAL,
        rgzSessionManager,
        Parameters,
        NULL,
        NULL
        );

    //
    // Make sure the value for CMCEnabled is valid. If less than 0, set it to
    // 0 (disabled). If greater than 0, make sure polling isn't too frequent.
    //

    if ( *(PLONG)CMCEnabled <= 0 ) {
        *CMCEnabled = 0;
    } else if ( *CMCEnabled < 15 ) {
        *CMCEnabled = 15;
    }
}

VOID
HalHandleMcheck (
    IN PKTRAP_FRAME TrapFrame,
    IN PKEXCEPTION_FRAME ExceptionFrame
    )
{
    HalpMcaExceptionHandler();
}

NTSTATUS
HalpGetMceInformation(
    PHAL_ERROR_INFO ErrorInfo,
    PULONG ErrorInfoLength
    )
/*++
    Routine Description:
        This routine is called by HaliQuerySystemInformation for the HalErrorInformation class.

    Arguments:
        ErrorInfo : pointer to HAL_ERROR_INFO structure.

        ErrorInfoLength : size of the valid memory structure pointed by ErrorInfo.

    Return Value:
        STATUS_SUCCESS if successful
        error status otherwise
--*/
{
    NTSTATUS status;
    ULONG savedVersion;

    PAGED_CODE();

    ASSERT( ErrorInfo != NULL );
    ASSERT( *ErrorInfoLength == sizeof(HAL_ERROR_INFO) );

    //
    // Backward compatibility only.
    //

    if ( (ErrorInfo->Version == 0) || (ErrorInfo->Version > HAL_ERROR_INFO_VERSION) ) {
        return STATUS_REVISION_MISMATCH;
    }

    ASSERT( ErrorInfo->Version == HAL_ERROR_INFO_VERSION );

    //
    // Zero the output structure, then in the few fields that are meaningful.
    //

    savedVersion = ErrorInfo->Version;

    RtlZeroMemory( ErrorInfo, sizeof(HAL_ERROR_INFO) );

    ErrorInfo->Version = savedVersion;

    ErrorInfo->McaMaxSize = sizeof(MCA_EXCEPTION);
    ErrorInfo->CmcMaxSize = sizeof(MCA_EXCEPTION);
    ErrorInfo->McaPreviousEventsCount = 1; // Set to 1 to get WMI to poll immediately

    if ( (HalpFeatureBits & HAL_MCA_PRESENT) == 0 ) {
        ErrorInfo->CmcPollingInterval = HAL_CMC_DISABLED;
    } else {
        ErrorInfo->CmcPollingInterval = HalpCMCEnabled;
    }

    ErrorInfo->CpePollingInterval = HAL_CPE_DISABLED;

    ErrorInfo->McaKernelToken = HALP_KERNEL_TOKEN;
    ErrorInfo->CmcKernelToken = HALP_KERNEL_TOKEN;

    *ErrorInfoLength = sizeof(HAL_ERROR_INFO);

    return STATUS_SUCCESS;

} // HalpGetMceInformation
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halx86\i386\ixphwsup.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    ixphwsup.c

Abstract:

    This module contains the HalpXxx routines for the NT I/O system that
    are hardware dependent.  Were these routines not hardware dependent,
    they would normally reside in the internal.c module.

Author:

    Darryl E. Havens (darrylh) 11-Apr-1990

Environment:

    Kernel mode, local to I/O system

Revision History:


--*/

#include "halp.h"
#if MCA

#include "mca.h"

#else

#include "eisa.h"

#endif

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE,HalpAllocateAdapter)
#pragma alloc_text(PAGELK,HalpGrowMapBuffers)
#endif


//
// Some devices require a physically contiguous data buffer for DMA transfers.
// Map registers are used to give the appearance that all data buffers are
// contiguous.  In order to pool all of the map registers a master
// adapter object is used.  This object is allocated and saved internal to this
// file.  It contains a bit map for allocation of the registers and a queue
// for requests which are waiting for more map registers.  This object is
// allocated during the first request to allocate an adapter which requires
// map registers.
//

#if defined(_HALPAE_)
MASTER_ADAPTER_OBJECT MasterAdapter24;
MASTER_ADAPTER_OBJECT MasterAdapter32;
#else
PADAPTER_OBJECT MasterAdapterObject;
#endif

BOOLEAN LessThan16Mb;
BOOLEAN HalpEisaDma;

#define ADAPTER_BASE_MASTER    ((PVOID)-1)


#if !defined(_HALPAE_)

//
// Map buffer prameters.  These are initialized in HalInitSystem.
//

PHYSICAL_ADDRESS HalpMapBufferPhysicalAddress;
ULONG HalpMapBufferSize;

#endif

//
// Define DMA operations structure.
//

const DMA_OPERATIONS HalpDmaOperations = {
    sizeof(DMA_OPERATIONS),
    (PPUT_DMA_ADAPTER) HalPutDmaAdapter,
    (PALLOCATE_COMMON_BUFFER) HalAllocateCommonBuffer,
    (PFREE_COMMON_BUFFER) HalFreeCommonBuffer,
#if defined(_WIN64)
    (PALLOCATE_ADAPTER_CHANNEL) HalRealAllocateAdapterChannel,
#else
    (PALLOCATE_ADAPTER_CHANNEL) IoAllocateAdapterChannel,
#endif
    (PFLUSH_ADAPTER_BUFFERS) IoFlushAdapterBuffers,
    (PFREE_ADAPTER_CHANNEL) IoFreeAdapterChannel,
    (PFREE_MAP_REGISTERS) IoFreeMapRegisters,
    (PMAP_TRANSFER) IoMapTransfer,
    (PGET_DMA_ALIGNMENT) HalGetDmaAlignment,
    (PREAD_DMA_COUNTER) HalReadDmaCounter,
    (PGET_SCATTER_GATHER_LIST) HalGetScatterGatherList,
    (PPUT_SCATTER_GATHER_LIST) HalPutScatterGatherList,
    (PCALCULATE_SCATTER_GATHER_LIST_SIZE)HalCalculateScatterGatherListSize,
    (PBUILD_SCATTER_GATHER_LIST) HalBuildScatterGatherList,
    (PBUILD_MDL_FROM_SCATTER_GATHER_LIST) HalBuildMdlFromScatterGatherList
    };



BOOLEAN
HalpGrowMapBuffers(
    PADAPTER_OBJECT AdapterObject,
    ULONG Amount
    )
/*++

Routine Description:

    This function attempts to allocate additional map buffers for use by I/O
    devices.  The map register table is updated to indicate the additional
    buffers.

    Caller owns the HalpNewAdapter event

Arguments:

    AdapterObject - Supplies the adapter object for which the buffers are to be
        allocated.

    Amount - Indicates the size of the map buffers which should be allocated.

Return Value:

    TRUE is returned if the memory could be allocated.

    FALSE is returned if the memory could not be allocated.

--*/
{
    ULONG MapBufferPhysicalAddress;
    PVOID MapBufferVirtualAddress;
    PTRANSLATION_ENTRY TranslationEntry;
    LONG NumberOfPages;
    LONG i;
    PHYSICAL_ADDRESS physicalAddressMinimum;
    PHYSICAL_ADDRESS physicalAddressMaximum;
    PHYSICAL_ADDRESS boundaryAddress;
    KIRQL Irql;
    PVOID CodeLockHandle;
    ULONG maximumBufferPages;
    BOOLEAN dma32Bit;
    ULONG bytesToAllocate;

    PAGED_CODE();

    dma32Bit = AdapterObject->Dma32BitAddresses;
    boundaryAddress.QuadPart = 0;

    NumberOfPages = BYTES_TO_PAGES(Amount);

    //
    // Make sure there is room for the additional pages.  The maximum number of
    // slots needed is equal to NumberOfPages + Amount / 64K + 1.
    //

    maximumBufferPages =
        HalpMaximumMapBufferRegisters( dma32Bit );

    i = maximumBufferPages - (NumberOfPages +
        (NumberOfPages * PAGE_SIZE) / 0x10000 + 1 +
        AdapterObject->NumberOfMapRegisters);

    if (i < 0) {

        //
        // Reduce the allocation amount so it will fit.
        //

        NumberOfPages += i;
    }

    if (NumberOfPages <= 0) {

        //
        // No more memory can be allocated.
        //

        return(FALSE);
    }

    if (AdapterObject->NumberOfMapRegisters == 0  &&
        HalpMapBufferSize( dma32Bit )) {

        NumberOfPages =
            BYTES_TO_PAGES( HalpMapBufferSize( dma32Bit ));

        //
        // Since this is the initial allocation, use the buffer allocated by
        // HalInitSystem rather than allocating a new one.
        //

        MapBufferPhysicalAddress =
            HalpMapBufferPhysicalAddress( dma32Bit ).LowPart;

        //
        // Map the buffer for access.
        //

        MapBufferVirtualAddress = MmMapIoSpace(
            HalpMapBufferPhysicalAddress( dma32Bit ),
            HalpMapBufferSize( dma32Bit ),
            TRUE                                // Cache enable.
            );

        if (MapBufferVirtualAddress == NULL) {

            //
            // The buffer could not be mapped.
            //

            HalpMapBufferSize( dma32Bit ) = 0;
            return(FALSE);
        }


    } else {

        //
        // Allocate the map buffers.
        //

        physicalAddressMaximum =
            HalpGetAdapterMaximumPhysicalAddress( AdapterObject );

        if (physicalAddressMaximum.LowPart == (ULONG)-1) {

            //
            // This adapter can handle at least 32-bit addresses.  In an effort
            // to leave memory to 24-bit adapters, try to make this allocation
            // above the 24 bit line.
            //

            physicalAddressMinimum.QuadPart = MAXIMUM_PHYSICAL_ADDRESS;

        } else {

            physicalAddressMinimum.QuadPart = 0;
        }

        bytesToAllocate = NumberOfPages * PAGE_SIZE;

        //
        // This loop is executed a maximum of two times.
        //

        while(TRUE) {

            MapBufferVirtualAddress =
                MmAllocateContiguousMemorySpecifyCache( bytesToAllocate,
                                                        physicalAddressMinimum,
                                                        physicalAddressMaximum,
                                                        boundaryAddress,
                                                        MmCached );

            if (MapBufferVirtualAddress != NULL) {

                //
                // The memory was allocated.
                //

                break;
            }

            //
            // The allocation attempt failed.
            //

            if (physicalAddressMinimum.QuadPart != 0) {

                //
                // We were trying to allocate memory above the 16M line as
                // an optimization.  Relax that requirement and try again.
                //

                physicalAddressMinimum.QuadPart = 0;

            } else {

                //
                // The memory could not be allocated.
                //

                return FALSE;
            }
        }

        //
        // Get the physical address of the map base.
        //

        MapBufferPhysicalAddress = MmGetPhysicalAddress(
            MapBufferVirtualAddress
            ).LowPart;

    }

    //
    // Initialize the map registers where memory has been allocated.
    // Serialize with master adapter object.
    //

    CodeLockHandle = MmLockPagableCodeSection (&HalpGrowMapBuffers);
    KeAcquireSpinLock( &AdapterObject->SpinLock, &Irql );

    TranslationEntry = ((PTRANSLATION_ENTRY) AdapterObject->MapRegisterBase) +
        AdapterObject->NumberOfMapRegisters;

    for (i = 0; (LONG) i < NumberOfPages; i++) {

        //
        // Make sure the perivous entry is physically contiguous with the next
        // entry and that a 64K physical bountry is not crossed unless this
        // is an Eisa system.
        //

        if (TranslationEntry != AdapterObject->MapRegisterBase &&
            (((TranslationEntry - 1)->PhysicalAddress + PAGE_SIZE) !=
            MapBufferPhysicalAddress || (!HalpEisaDma &&
            ((TranslationEntry - 1)->PhysicalAddress & ~0x0ffff) !=
            (MapBufferPhysicalAddress & ~0x0ffff)))) {

            //
            // An entry needs to be skipped in the table.  This entry will
            // remain marked as allocated so that no allocation of map
            // registers will cross this bountry.
            //

            TranslationEntry++;
            AdapterObject->NumberOfMapRegisters++;
        }

        //
        // Clear the bits where the memory has been allocated.
        //

        RtlClearBits(
            AdapterObject->MapRegisters,
            (ULONG)(TranslationEntry - (PTRANSLATION_ENTRY)
                AdapterObject->MapRegisterBase),
            1
            );

        TranslationEntry->VirtualAddress = MapBufferVirtualAddress;
        TranslationEntry->PhysicalAddress = MapBufferPhysicalAddress;
        TranslationEntry++;
        (PCCHAR) MapBufferVirtualAddress += PAGE_SIZE;
        MapBufferPhysicalAddress += PAGE_SIZE;

    }

    //
    // Remember the number of pages that were allocated.
    //

    AdapterObject->NumberOfMapRegisters += NumberOfPages;

    //
    // Release master adapter object.
    //

    KeReleaseSpinLock( &AdapterObject->SpinLock, Irql );
    MmUnlockPagableImageSection (CodeLockHandle);
    return(TRUE);
}

#if defined(HalpAllocateAdapterEx)
#undef HalpAllocateAdapterEx
#endif


PADAPTER_OBJECT
HalpAllocateAdapterEx(
    IN ULONG MapRegistersPerChannel,
    IN PVOID AdapterBaseVa,
    IN PVOID ChannelNumber,
    IN BOOLEAN Dma32Bit
    )

/*++

Routine Description:

    This routine allocates and initializes an adapter object to represent an
    adapter or a DMA controller on the system.  If no map registers are required
    then a standalone adapter object is allocated with no master adapter.

    If map registers are required, then a master adapter object is used to
    allocate the map registers.  For Isa systems these registers are really
    physically contiguous memory pages.

    Caller owns the HalpNewAdapter event


Arguments:

    MapRegistersPerChannel - Specifies the number of map registers that each
                             channel provides for I/O memory mapping.

    AdapterBaseVa - Address of the the DMA controller or ADAPTER_BASE_MASTER.

    ChannelNumber - Unused.

    Dma32Bit - Indicates whether the adapter is 24 bit or 32 bit.

Return Value:

    The function value is a pointer to the allocate adapter object.

--*/

{

    PADAPTER_OBJECT AdapterObject;
    OBJECT_ATTRIBUTES ObjectAttributes;
    ULONG Size;
    ULONG BitmapSize;
    HANDLE Handle;
    NTSTATUS Status;
    ULONG mapBuffers;
    BOOLEAN creatingMaster;

    UNREFERENCED_PARAMETER(ChannelNumber);

    PAGED_CODE();

    if (AdapterBaseVa == ADAPTER_BASE_MASTER) {
        creatingMaster = TRUE;
    } else {
        creatingMaster = FALSE;
    }

    //
    // Initialize the master adapter if necessary.
    //

    if (creatingMaster == FALSE &&
        MapRegistersPerChannel != 0) {

        //
        // This is not a recursive master adapter allocation, and map registers
        // are necessary.  Allocate a master adapter object of the appropriate
        // type if necessary.
        //

        if (HalpMasterAdapter( Dma32Bit ) == NULL) {

            AdapterObject = HalpAllocateAdapterEx( MapRegistersPerChannel,
                                                   ADAPTER_BASE_MASTER,
                                                   NULL,
                                                   Dma32Bit );

            //
            // If we could not allocate the master adapter then give up.
            //

            if (AdapterObject == NULL) {
                return NULL;
            }

            AdapterObject->Dma32BitAddresses = Dma32Bit;
            AdapterObject->MasterDevice = Dma32Bit;
            HalpMasterAdapter( Dma32Bit ) = AdapterObject;
        }
    }

    //
    // Begin by initializing the object attributes structure to be used when
    // creating the adapter object.
    //

    InitializeObjectAttributes( &ObjectAttributes,
                                NULL,
                                OBJ_PERMANENT | OBJ_KERNEL_HANDLE,
                                (HANDLE) NULL,
                                (PSECURITY_DESCRIPTOR) NULL
                              );

    //
    // Determine the size of the adapter object. If this is the master object
    // then allocate space for the register bit map; otherwise, just allocate
    // an adapter object.
    //

    if (creatingMaster != FALSE) {

       //
       // Allocate a bit map large enough MAXIMUM_MAP_BUFFER_SIZE / PAGE_SIZE
       // of map register buffers.
       //

       mapBuffers = HalpMaximumMapBufferRegisters( Dma32Bit );

       BitmapSize = (((sizeof( RTL_BITMAP ) +
            ((mapBuffers + 7) >> 3)) + 3) & ~3);

       Size = sizeof( ADAPTER_OBJECT ) + BitmapSize;

    } else {

       Size = sizeof( ADAPTER_OBJECT );

    }

    //
    // Now create the adapter object.
    //

    Status = ObCreateObject( KernelMode,
                             *IoAdapterObjectType,
                             &ObjectAttributes,
                             KernelMode,
                             (PVOID) NULL,
                             Size,
                             0,
                             0,
                             (PVOID *)&AdapterObject );

    //
    // Reference the object.
    //

    if (NT_SUCCESS(Status)) {

        Status = ObReferenceObjectByPointer(
            AdapterObject,
            FILE_READ_DATA | FILE_WRITE_DATA,
            *IoAdapterObjectType,
            KernelMode
            );

    }

    //
    // If the adapter object was successfully created, then attempt to insert
    // it into the object table.
    //

    if (NT_SUCCESS( Status )) {

        RtlZeroMemory (AdapterObject, sizeof (ADAPTER_OBJECT));

        Status = ObInsertObject( AdapterObject,
                                 NULL,
                                 FILE_READ_DATA | FILE_WRITE_DATA,
                                 0,
                                 (PVOID *) NULL,
                                 &Handle );

        if (NT_SUCCESS( Status )) {

            ZwClose( Handle );

            //
            // Initialize the adapter object itself.
            //

            AdapterObject->DmaHeader.Version = IO_TYPE_ADAPTER;
            AdapterObject->DmaHeader.Size = (USHORT) Size;
            AdapterObject->MapRegistersPerChannel = 1;
            AdapterObject->AdapterBaseVa = AdapterBaseVa;
            AdapterObject->ChannelNumber = 0xff;
            AdapterObject->DmaHeader.DmaOperations = (PDMA_OPERATIONS)&HalpDmaOperations;
            AdapterObject->Dma32BitAddresses = Dma32Bit;

            if (MapRegistersPerChannel) {

                AdapterObject->MasterAdapter = HalpMasterAdapter( Dma32Bit );

            } else {

                AdapterObject->MasterAdapter = NULL;

            }

            //
            // Initialize the channel wait queue for this adapter.
            //

            KeInitializeDeviceQueue( &AdapterObject->ChannelWaitQueue );

            //
            // If this is the MasterAdatper then initialize the register bit map,
            // AdapterQueue and the spin lock.
            //

            if (creatingMaster != FALSE) {

               KeInitializeSpinLock( &AdapterObject->SpinLock );

               InitializeListHead( &AdapterObject->AdapterQueue );

               AdapterObject->MapRegisters = (PVOID) ( AdapterObject + 1);

               RtlInitializeBitMap( AdapterObject->MapRegisters,
                                    (PULONG) (((PCHAR) (AdapterObject->MapRegisters)) + sizeof( RTL_BITMAP )),
                                    ( mapBuffers )
                                    );
               //
               // Set all the bits in the memory to indicate that memory
               // has not been allocated for the map buffers.
               //

               RtlSetAllBits( AdapterObject->MapRegisters );
               AdapterObject->NumberOfMapRegisters = 0;
               AdapterObject->CommittedMapRegisters = 0;

               //
               // Allocate the memory map registers.
               //

               AdapterObject->MapRegisterBase =
                   ExAllocatePoolWithTag(
                       NonPagedPool,
                       mapBuffers * sizeof(TRANSLATION_ENTRY),
                       HAL_POOL_TAG
                       );

               if (AdapterObject->MapRegisterBase == NULL) {

                   ObDereferenceObject( AdapterObject );
                   AdapterObject = NULL;
                   return(NULL);

               }

               //
               // Zero the map registers.
               //

               RtlZeroMemory(
                    AdapterObject->MapRegisterBase,
                    mapBuffers * sizeof(TRANSLATION_ENTRY)
                    );

               if (!HalpGrowMapBuffers(AdapterObject, INITIAL_MAP_BUFFER_SMALL_SIZE))
               {

                   //
                   // If no map registers could be allocated then free the
                   // object.
                   //

                   ObDereferenceObject( AdapterObject );
                   AdapterObject = NULL;
                   return(NULL);

               }
           }

        } else {

            //
            // An error was incurred for some reason.  Set the return value
            // to NULL.
            //

            AdapterObject = (PADAPTER_OBJECT) NULL;
        }
    } else {

        AdapterObject = (PADAPTER_OBJECT) NULL;

    }


    return AdapterObject;

}

PADAPTER_OBJECT
HalpAllocateAdapter(
    IN ULONG MapRegistersPerChannel,
    IN PVOID AdapterBaseVa,
    IN PVOID ChannelNumber
    )

/*++

Routine Description:

    This routine allocates and initializes an adapter object to represent an
    adapter or a DMA controller on the system.  If no map registers are required
    then a standalone adapter object is allocated with no master adapter.

    If map registers are required, then a master adapter object is used to
    allocate the map registers.  For Isa systems these registers are really
    physically contiguous memory pages.

    Caller owns the HalpNewAdapter event


Arguments:

    MapRegistersPerChannel - Specifies the number of map registers that each
                             channel provides for I/O memory mapping.

    AdapterBaseVa - Address of the DMA controller or ADAPTER_BASE_MASTER.

    ChannelNumber - Unused.

Return Value:

    The function value is a pointer to the allocate adapter object.

--*/

{
    return HalpAllocateAdapterEx( MapRegistersPerChannel,
                                  AdapterBaseVa,
                                  ChannelNumber,
                                  FALSE );
}


ULONG
HalGetDmaAlignment (
    PVOID Conext
    )
{
    return HalGetDmaAlignmentRequirement();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halx86\i386\ixpciint.c ===
/*++


Copyright (c) 1989  Microsoft Corporation

Module Name:

    ixpciint.c

Abstract:

    All PCI bus interrupt mapping is in this module, so that a real
    system which doesn't have all the limitations which PC PCI
    systems have can replaced this code easly.
    (bus memory & i/o address mappings can also be fix here)

Author:

    Ken Reneris

Environment:

    Kernel mode

Revision History:


--*/

#include "halp.h"
#include "pci.h"
#include "pcip.h"

#ifdef WANT_IRQ_ROUTING
#include "ixpciir.h"
#endif

ULONG   HalpEisaELCR;
BOOLEAN HalpDoingCrashDump;
BOOLEAN HalpPciLockSettings;


#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE,HalpGetPCIIntOnISABus)
#pragma alloc_text(PAGE,HalpAdjustPCIResourceList)
#pragma alloc_text(PAGE,HalpGetISAFixedPCIIrq)
#endif


ULONG
HalpGetPCIIntOnISABus (
    IN PBUS_HANDLER BusHandler,
    IN PBUS_HANDLER RootHandler,
    IN ULONG BusInterruptLevel,
    IN ULONG BusInterruptVector,
    OUT PKIRQL Irql,
    OUT PKAFFINITY Affinity
    )
{
    if (BusInterruptLevel < 1) {
        // bogus bus level
        return 0;
    }


    //
    // Current PCI buses just map their IRQs ontop of the ISA space,
    // so foreward this to the isa handler for the isa vector
    // (the isa vector was saved away at either HalSetBusData or
    // IoAssignReosurces time - if someone is trying to connect a
    // PCI interrupt without performing one of those operations first,
    // they are broken).
    //

    return HalGetInterruptVector (
#ifndef MCA
                Isa, 0,
#else
                MicroChannel, 0,
#endif
                BusInterruptLevel ^ IRQXOR,
                0,
                Irql,
                Affinity
            );
}


VOID
HalpPCIPin2ISALine (
    IN PBUS_HANDLER          BusHandler,
    IN PBUS_HANDLER          RootHandler,
    IN PCI_SLOT_NUMBER      SlotNumber,
    IN PPCI_COMMON_CONFIG   PciData
    )
/*++

    This function maps the device's InterruptPin to an InterruptLine
    value.

    On the current PC implementations, the bios has already filled in
    InterruptLine as it's ISA value and there's no portable way to
    change it.

    On a DBG build we adjust InterruptLine just to ensure driver's
    don't connect to it without translating it on the PCI bus.

--*/
{
    if (!PciData->u.type0.InterruptPin) {
        return ;
    }

    //
    // On a PC there's no Slot/Pin/Line mapping which needs to
    // be done.
    //

    PciData->u.type0.InterruptLine ^= IRQXOR;
}



VOID
HalpPCIISALine2Pin (
    IN PBUS_HANDLER          BusHandler,
    IN PBUS_HANDLER          RootHandler,
    IN PCI_SLOT_NUMBER      SlotNumber,
    IN PPCI_COMMON_CONFIG   PciNewData,
    IN PPCI_COMMON_CONFIG   PciOldData
    )
/*++

    This functions maps the device's InterruptLine to it's
    device specific InterruptPin value.

    On the current PC implementations, this information is
    fixed by the BIOS.  Just make sure the value isn't being
    editted since PCI doesn't tell us how to dynically
    connect the interrupt.

--*/
{
    if (!PciNewData->u.type0.InterruptPin) {
        return ;
    }

    PciNewData->u.type0.InterruptLine ^= IRQXOR;

#if DBG
    if (PciNewData->u.type0.InterruptLine != PciOldData->u.type0.InterruptLine ||
        PciNewData->u.type0.InterruptPin  != PciOldData->u.type0.InterruptPin) {
        DbgPrint ("HalpPCILine2Pin: System does not support changing the PCI device interrupt routing\n");
        DbgBreakPoint ();
    }
#endif
}

#if !defined(SUBCLASSPCI)

VOID
HalpPCIAcquireType2Lock (
    PKSPIN_LOCK SpinLock,
    PKIRQL      Irql
    )
{
    if (!HalpDoingCrashDump) {
        *Irql = KfRaiseIrql (HIGH_LEVEL);
        KiAcquireSpinLock (SpinLock);
    } else {
        *Irql = HIGH_LEVEL;
    }
}


VOID
HalpPCIReleaseType2Lock (
    PKSPIN_LOCK SpinLock,
    KIRQL       Irql
    )
{
    if (!HalpDoingCrashDump) {
        KiReleaseSpinLock (SpinLock);
        KfLowerIrql (Irql);
    }
}

#endif

NTSTATUS
HalpAdjustPCIResourceList (
    IN PBUS_HANDLER BusHandler,
    IN PBUS_HANDLER RootHandler,
    IN OUT PIO_RESOURCE_REQUIREMENTS_LIST   *pResourceList
    )
/*++
    Rewrite the callers requested resource list to fit within
    the supported ranges of this bus
--*/
{
    NTSTATUS                Status;
    PPCIPBUSDATA            BusData;
    PCI_SLOT_NUMBER         PciSlot;
    PSUPPORTED_RANGE        Interrupt;
    PSUPPORTED_RANGE        Range, HoldRange;
    PSUPPORTED_RANGES       SupportedRanges;
    PPCI_COMMON_CONFIG      PciData, PciOrigData;
    UCHAR                   buffer[PCI_COMMON_HDR_LENGTH];
    UCHAR                   buffer2[PCI_COMMON_HDR_LENGTH];
    BOOLEAN                 UseBusRanges;
    ULONG                   i, j, RomIndex, length, ebit;
    ULONG                   Base[PCI_TYPE0_ADDRESSES + 1];
    PULONG                  BaseAddress[PCI_TYPE0_ADDRESSES + 1];


    BusData = (PPCIPBUSDATA) BusHandler->BusData;
    PciSlot = *((PPCI_SLOT_NUMBER) &(*pResourceList)->SlotNumber);

    //
    // Determine PCI device's interrupt restrictions
    //

    Status = BusData->GetIrqRange(BusHandler, RootHandler, PciSlot, &Interrupt);

    if (!NT_SUCCESS(Status)) {
        return Status;
    }

    SupportedRanges = NULL;
    UseBusRanges    = TRUE;
    Status          = STATUS_INSUFFICIENT_RESOURCES;

    if (HalpPciLockSettings) {

        PciData = (PPCI_COMMON_CONFIG) buffer;
        PciOrigData = (PPCI_COMMON_CONFIG) buffer2;
        HalpReadPCIConfig (BusHandler, PciSlot, PciData, 0, PCI_COMMON_HDR_LENGTH);

        //
        // If this is a device, and it current has its decodes enabled,
        // then use the currently programmed ranges only
        //

        if (PCI_CONFIG_TYPE(PciData) == 0 &&
            (PciData->Command & (PCI_ENABLE_IO_SPACE | PCI_ENABLE_MEMORY_SPACE))) {

            //
            // Save current settings
            //

            RtlMoveMemory (PciOrigData, PciData, PCI_COMMON_HDR_LENGTH);


            for (j=0; j < PCI_TYPE0_ADDRESSES; j++) {
                BaseAddress[j] = &PciData->u.type0.BaseAddresses[j];
            }
            BaseAddress[j] = &PciData->u.type0.ROMBaseAddress;
            RomIndex = j;

            //
            // Write all one-bits to determine lengths for each address
            //

            for (j=0; j < PCI_TYPE0_ADDRESSES + 1; j++) {
                Base[j] = *BaseAddress[j];
                *BaseAddress[j] = 0xFFFFFFFF;
            }

            PciData->Command &= ~(PCI_ENABLE_IO_SPACE | PCI_ENABLE_MEMORY_SPACE);
            *BaseAddress[RomIndex] &= ~PCI_ROMADDRESS_ENABLED;
            HalpWritePCIConfig (BusHandler, PciSlot, PciData, 0, PCI_COMMON_HDR_LENGTH);
            HalpReadPCIConfig  (BusHandler, PciSlot, PciData, 0, PCI_COMMON_HDR_LENGTH);

            //
            // restore original settings
            //

            HalpWritePCIConfig (
                BusHandler,
                PciSlot,
                &PciOrigData->Status,
                FIELD_OFFSET (PCI_COMMON_CONFIG, Status),
                PCI_COMMON_HDR_LENGTH - FIELD_OFFSET (PCI_COMMON_CONFIG, Status)
                );

            HalpWritePCIConfig (
                BusHandler,
                PciSlot,
                PciOrigData,
                0,
                FIELD_OFFSET (PCI_COMMON_CONFIG, Status)
                );

            //
            // Build a memory & io range list of just the ranges already
            // programmed into the device
            //

            UseBusRanges    = FALSE;
            SupportedRanges = HalpAllocateNewRangeList();
            if (!SupportedRanges) {
                goto CleanUp;
            }

            *BaseAddress[RomIndex] &= ~PCI_ADDRESS_IO_SPACE;
            for (j=0; j < PCI_TYPE0_ADDRESSES + 1; j++) {

                i = *BaseAddress[j];

                if (i & PCI_ADDRESS_IO_SPACE) {
                    length = 1 << 2;
                    Range  = &SupportedRanges->IO;
                    ebit   = PCI_ENABLE_IO_SPACE;

                } else {
                    length = 1 << 4;
                    Range  = &SupportedRanges->Memory;
                    ebit   = PCI_ENABLE_MEMORY_SPACE;

                    if (i & PCI_ADDRESS_MEMORY_PREFETCHABLE) {
                        Range = &SupportedRanges->PrefetchMemory;
                    }
                }

                Base[j] &= ~(length-1);
                while (!(i & length)  &&  length) {
                    length <<= 1;
                }

                if (j == RomIndex &&
                    !(PciOrigData->u.type0.ROMBaseAddress & PCI_ROMADDRESS_ENABLED)) {

                    // range not enabled, don't use it
                    length = 0;
                }

                if (length) {
                    if (!(PciOrigData->Command & ebit)) {
                        // range not enabled, don't use preprogrammed values
                        UseBusRanges = TRUE;
                    }

                    if (Range->Limit >= Range->Base) {
                        HoldRange = Range->Next;
                        Range->Next = ExAllocatePoolWithTag(
                                          PagedPool,
                                          sizeof(SUPPORTED_RANGE),
                                          HAL_POOL_TAG
                                          );
                        Range = Range->Next;
                        if (!Range) {
                            goto CleanUp;
                        }

                        Range->Next = HoldRange;
                    }

                    Range->Base  = Base[j];
                    Range->Limit = Base[j] + length - 1;
                }

                if (Is64BitBaseAddress(i)) {
                    // skip upper half of 64 bit address since this processor
                    // only supports 32 bits of address space
                    j++;
                }
            }
        }
    }

    //
    // Adjust resources
    //

    Status = HaliAdjustResourceListRange (
                UseBusRanges ? BusHandler->BusAddresses : SupportedRanges,
                Interrupt,
                pResourceList
                );

CleanUp:
    if (SupportedRanges) {
        HalpFreeRangeList (SupportedRanges);
    }

    ExFreePool (Interrupt);
    return Status;
}



NTSTATUS
HalpGetISAFixedPCIIrq (
    IN PBUS_HANDLER         BusHandler,
    IN PBUS_HANDLER         RootHandler,
    IN PCI_SLOT_NUMBER      PciSlot,
    OUT PSUPPORTED_RANGE    *Interrupt
    )
{
    UCHAR                   buffer[PCI_COMMON_HDR_LENGTH];
    PPCI_COMMON_CONFIG      PciData;


    PciData = (PPCI_COMMON_CONFIG) buffer;
    HalGetBusData (
        PCIConfiguration,
        BusHandler->BusNumber,
        PciSlot.u.AsULONG,
        PciData,
        PCI_COMMON_HDR_LENGTH
        );

    if (PciData->VendorID == PCI_INVALID_VENDORID) {

        return STATUS_UNSUCCESSFUL;
    }

    *Interrupt = ExAllocatePoolWithTag(PagedPool,
                                       sizeof(SUPPORTED_RANGE),
                                       HAL_POOL_TAG);
    if (!*Interrupt) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory (*Interrupt, sizeof (SUPPORTED_RANGE));
    (*Interrupt)->Base = 1;                 // base = 1, limit = 0

    if (!PciData->u.type0.InterruptPin) {
        return STATUS_SUCCESS;
    }

#ifdef WANT_IRQ_ROUTING

    //  
    // Let the arbiter decide which Irq this device gets.
    //
    
    if (IsPciIrqRoutingEnabled()) {

        //
        // If a video card has been enabled by the BIOS
        // and the BIOS did not assign any interrupt to it
        // then assume this device does not need an interrupt.
        //

        if (PciData->Command & (PCI_ENABLE_IO_SPACE | PCI_ENABLE_MEMORY_SPACE)) {

            if (    (PciData->BaseClass == PCI_CLASS_PRE_20 && PciData->SubClass == PCI_SUBCLASS_VID_XGA_CTLR) ||
                    (PciData->BaseClass == PCI_CLASS_DISPLAY_CTLR && 
                        (PciData->SubClass == PCI_SUBCLASS_VID_VGA_CTLR || PciData->SubClass == PCI_SUBCLASS_VID_XGA_CTLR))) {

                if (    PciData->u.type0.InterruptLine == (0 ^ IRQXOR)  ||
                        PciData->u.type0.InterruptLine == (0xFF ^ IRQXOR)) {
                    
#if DBG
                    DbgPrint ("HalpGetValidPCIFixedIrq: BIOS did not assign an interrupt to the video device %04X%04X\n", PciData->VendorID, PciData->DeviceID);
#endif
        //
        // We need to let the caller continue, since the caller may
        // not care that the interrupt vector is connected or not
        //

                    return STATUS_SUCCESS;
                }
            }
        }
        //
        // Return all possible interrupts since Pci Irq Routing is enabled.
        //
        
        (*Interrupt)->Base  = 0;
        (*Interrupt)->Limit = 0xFF;    
        
        return STATUS_SUCCESS;        
    }  
    
#endif

    if (PciData->u.type0.InterruptLine == (0 ^ IRQXOR)  ||
        PciData->u.type0.InterruptLine == (0xFF ^ IRQXOR)) {

#if DBG
        DbgPrint ("HalpGetValidPCIFixedIrq: BIOS did not assign an interrupt vector for the device\n");
#endif
        //
        // We need to let the caller continue, since the caller may
        // not care that the interrupt vector is connected or not
        //

        return STATUS_SUCCESS;
    }

    (*Interrupt)->Base  = PciData->u.type0.InterruptLine;
    (*Interrupt)->Limit = PciData->u.type0.InterruptLine;
    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halx86\i386\ixpciir.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    ixpciir.h

Abstract:

    This header file defines the private interfaces, defines and structures
    for Pci Irq Routing support.

Author:

    Santosh Jodh (santoshj) 10-June-1998

Environment:

    Kernel mode only.

Revision History:

--*/

#include <pciirqmp.h>

#define PCI_LINK_SIGNATURE  'KNLP'

#define IsPciIrqRoutingEnabled()    \
    (HalpPciIrqRoutingInfo.PciIrqRoutingTable && HalpPciIrqRoutingInfo.PciInterface)

typedef struct _LINK_STATE LINK_STATE, *PLINK_STATE;
typedef struct _LINK_NODE LINK_NODE, *PLINK_NODE;
typedef struct _PCI_IRQ_ROUTING_INFO PCI_IRQ_ROUTING_INFO, *PPCI_IRQ_ROUTING_INFO;

struct _LINK_STATE {
    ULONG           Interrupt;      // Interrupt for this link.
    ULONG           RefCount;       // Number of devices using this link.
};

struct _LINK_NODE {
    ULONG       Signature;      // Signature 'PLNK'.
    PLINK_NODE  Next;
    ULONG       Link;           // Link value.
    ULONG       InterruptMap;   // Possible Irq map.
    PLINK_STATE Allocation;
    PLINK_STATE PossibleAllocation;
};

struct _PCI_IRQ_ROUTING_INFO {
    PPCI_IRQ_ROUTING_TABLE          PciIrqRoutingTable;
    PINT_ROUTE_INTERFACE_STANDARD   PciInterface;
    PLINK_NODE                      LinkNodeHead;
    ULONG                           Parameters;
};

NTSTATUS
HalpInitPciIrqRouting (
    OUT PPCI_IRQ_ROUTING_INFO PciIrqRoutingInfo
    );

NTSTATUS
HalpFindLinkNode (
    IN PPCI_IRQ_ROUTING_INFO PciIrqRoutingInfo,
    IN PDEVICE_OBJECT Pdo,
    IN ULONG Bus,
    IN ULONG Slot,
    OUT PLINK_NODE *LinkNode
    );

NTSTATUS
HalpCommitLink (
    IN PLINK_NODE LinkNode
    );

VOID
HalpProgramInterruptLine (
    IN PPCI_IRQ_ROUTING_INFO PciIrqRoutingInfo,
    IN PDEVICE_OBJECT Pdo,
    IN ULONG Interrupt
    );

extern PCI_IRQ_ROUTING_INFO HalpPciIrqRoutingInfo;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halx86\i386\ixpciir.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    ixpciir.c

Abstract:

    This module implements the code to provide Pci Irq Routing
    support. It reads the routing table, provides the Irq arbiter
    and uses the chipset miniport library to program the links.

Author:

    Santosh Jodh (santoshj) 10-June-1998

Environment:

    Kernel mode only.

Revision History:

--*/

//
// This module is compatible with PAE mode and therefore treats physical
// addresses as 64-bit entities.
//

#if !defined(_PHYS64_)
#define _PHYS64_
#endif

#include "halp.h"
#include <pci.h>
#include <stdio.h>

#ifndef _IN_KERNEL_
#define _IN_KERNEL_
#include <regstr.h>
#undef _IN_KERNEL_
#else
#include <regstr.h>
#endif

#include "pcip.h"
#include "ixpciir.h"

#ifndef MAXIMUM_VALUE_NAME_LENGTH
#define MAXIMUM_VALUE_NAME_LENGTH   256
#endif

//
// MS specification for PCI IRQ Routing specifies that the BIOS
// provide the table in the ROM between the physical addresses
// of 0xF0000 and 0xFFFFF. The table starts on a 16-byte boundary
// with a 4-byte signature of "$PIR".
//
// Other restrictions:
//
// Version:     Should be 1.0
// Size:        Must be integral multiple of 16 bytes and > 32 bytes
// Checksum:    The entire table should checksum to 0.
//

#define PIRT_BIOS_START     0xf0000
#define PIRT_BIOS_END       0xfffff
#define PIRT_BIOS_SIZE      (PIRT_BIOS_END - PIRT_BIOS_START + 1)
#define PIRT_ALIGNMENT      16

#define PIRT_SIGNATURE      'RIP$'      // $PIR little endian

#define PIRT_VERSION        0x0100

ULONG
HalpGetIrqRoutingTable (
    OUT PPCI_IRQ_ROUTING_TABLE   *PciIrqRoutingTable,
    IN ULONG Options
    );

ULONG
HalpInitializeMiniport (
    IN OUT PPCI_IRQ_ROUTING_INFO  PciIrqRoutingInfo
    );

NTSTATUS
HalpInitLinkNodes (
    PPCI_IRQ_ROUTING_INFO   PciIrqRoutingInfo
    );

PPCI_IRQ_ROUTING_TABLE
HalpGetRegistryTable (
    IN const WCHAR*  KeyName,
    IN const WCHAR*  ValueName,
    IN ULONG    HeaderSize OPTIONAL
    );

PPCI_IRQ_ROUTING_TABLE
HalpGetPCIBIOSTableFromRealMode(
    VOID
    );

PPCI_IRQ_ROUTING_TABLE
HalpGet$PIRTable (
    VOID
    );

PPCI_IRQ_ROUTING_TABLE
HalpCopy$PIRTable (
    IN PUCHAR   BiosPtr,
    IN PUCHAR   BiosEnd
    );

BOOLEAN
HalpSanityCheckTable (
    IN PPCI_IRQ_ROUTING_TABLE PciIrqRoutingTable,
    IN BOOLEAN IgnoreChecksum
    );

PSLOT_INFO
HalpBarberPole (
    IN PPCI_IRQ_ROUTING_INFO PciIrqRoutingInfo,
    IN PDEVICE_OBJECT Pdo,
    IN ULONG Bus,
    IN ULONG Slot,
    IN OUT PUCHAR Pin
    );

BOOLEAN
HalpBarberPolePin (
    IN PPCI_IRQ_ROUTING_INFO PciIrqRoutingInfo,
    IN PDEVICE_OBJECT Parent,
    IN ULONG Bus,
    IN ULONG Device,
    IN OUT PUCHAR Pin
    );

PSLOT_INFO
HalpGetSlotInfo (
    IN PPCI_IRQ_ROUTING_TABLE PciIrqRoutingTable,
    IN UCHAR   Bus,
    IN UCHAR   Device
    );

NTSTATUS
HalpReadRegistryDwordValue (
    IN HANDLE  Root,
    IN const WCHAR*  KeyName,
    IN const WCHAR*  ValueName,
    OUT PULONG  Data
    );

NTSTATUS
HalpWriteRegistryDwordValue (
    IN HANDLE  Root,
    IN const WCHAR*  KeyName,
    IN const WCHAR*  ValueName,
    IN ULONG   Value
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT, HalpInitPciIrqRouting)
#pragma alloc_text(INIT, HalpGetIrqRoutingTable)
#pragma alloc_text(INIT, HalpInitializeMiniport)
#pragma alloc_text(INIT, HalpInitLinkNodes)
#pragma alloc_text(INIT, HalpGetRegistryTable)
#pragma alloc_text(INIT, HalpGetPCIBIOSTableFromRealMode)
#pragma alloc_text(INIT, HalpGet$PIRTable)
#pragma alloc_text(INIT, HalpCopy$PIRTable)
#pragma alloc_text(INIT, HalpSanityCheckTable)
#pragma alloc_text(PAGE, HalpBarberPole)
#pragma alloc_text(PAGE, HalpBarberPolePin)
#pragma alloc_text(PAGE, HalpFindLinkNode)
#pragma alloc_text(PAGE, HalpGetSlotInfo)
#pragma alloc_text(PAGE, HalpReadRegistryDwordValue)
#pragma alloc_text(PAGE, HalpWriteRegistryDwordValue)
#pragma alloc_text(PAGE, HalpProgramInterruptLine)
#pragma alloc_text(PAGELK, HalpCommitLink)
#endif

extern PULONG InitSafeBootMode;

#ifdef ALLOC_DATA_PRAGMA
#pragma const_seg("PAGECONST")
#endif // ALLOC_DATA_PRAGMA
//
// Global key for Pci Irq Routing.
//

const WCHAR   rgzPciIrqRouting[] = REGSTR_PATH_PCIIR;

//
// Pci Irq Routing options value.
//

const WCHAR   rgzOptions[] = REGSTR_VAL_OPTIONS;

//
// Pci Irq Routing status values.
//

const WCHAR   rgzStatus[] = REGSTR_VAL_STAT;

//
// Pci Irq Routing Table status values.
//

const WCHAR   rgzTableStatus[] = REGSTR_VAL_TABLE_STAT;

//
// Pci Irq Routing Miniport status values.
//

const WCHAR   rgzMiniportStatus[] = REGSTR_VAL_MINIPORT_STAT;

//
// Offset from 0xF0000 where $PIR table was last found.
//

const WCHAR   rgz$PIROffset[] = L"$PIROffset";

//
// Irq Miniports key under rgzPciIrqRouting.
// This key contains keys whose name is the device-vendor id
// for the chipsets we support.
//

const WCHAR   rgzIrqMiniports[] = REGSTR_PATH_PCIIR L"\\IrqMiniports";

//
// Each miniport key contains a instance value which
// corresponds to the entry for the chipset in the
// miniport table.
//

const WCHAR   rgzInstance[] = L"Instance";

//
// This key overrides all miniports if present.
//

const WCHAR   rgzOverride[] = L"Override";

//
// Registry key for the routing table.
//

const WCHAR   rgzIrqRoutingTable[] = REGSTR_PATH_PCIIR L"\\IrqRoutingTables";

//
// Registry key for BIOS attributes.
//

const WCHAR   rgzBiosInfo[] = REGSTR_PATH_BIOSINFO L"\\PciIrqRouting";
const WCHAR   rgzAttributes[] = L"Attributes";

const WCHAR   rgzPciParameters[] = L"Parameters";

#ifdef ALLOC_DATA_PRAGMA
#pragma const_seg()
#endif // ALLOC_DATA_PRAGMA

PCI_IRQ_ROUTING_INFO    HalpPciIrqRoutingInfo = {0};
ULONG                   HalpIrqMiniportInitialized = 0;

NTSTATUS
HalpInitPciIrqRouting(
    OUT PPCI_IRQ_ROUTING_INFO PciIrqRoutingInfo
    )

/*++

    Routine Description:

        This routine initializes Pci Irq Routing by reading the
        Irq routing table, initializing the chipset miniport and
        initializing the Pci Interrupt Routing interface.

    Input Parameters:

        PciIrqRoutingInfo - Pci Irq Routing information.

    Return Value:

--*/

{
    NTSTATUS    status;
    ULONG       pirStatus;
    ULONG       tableStatus;
    ULONG       miniportStatus;
    ULONG       pirOptions;

    PAGED_CODE();

    //
    // Setup to return failure.
    //

    HalpIrqMiniportInitialized = 0;
    status = STATUS_UNSUCCESSFUL;
    pirStatus = PIR_STATUS_MAX;
    tableStatus = PIR_STATUS_TABLE_MAX | (PIR_STATUS_TABLE_MAX << 16);
    miniportStatus = PIR_STATUS_MINIPORT_MAX | (PIR_STATUS_MINIPORT_MAX << 16);

    //
    // No IRQ routing in safe boot.
    //

    if (!(*InitSafeBootMode))
    {
        pirStatus = PIR_STATUS_DISABLED;

        //
        // Read Pci Interrupt Routing options set by the user.
        //

        pirOptions = 0;
        HalpReadRegistryDwordValue(NULL, rgzPciIrqRouting, rgzOptions, &pirOptions);

        //
        //  Make sure Pci Interrupt Routing is not disabled.
        //

        if (pirOptions & PIR_OPTION_ENABLED)
        {
            //
            // First get the interface from Pci.
            //

            if (PciIrqRoutingInfo->PciInterface)
            {
                HalPrint(("Obtained the Pci Interrupt Routing Interface from Pci driver!"));

                status = STATUS_UNSUCCESSFUL;

                //
                // Get the Pci Interrupt Routing table for this motherboard.
                //

                tableStatus = HalpGetIrqRoutingTable(&PciIrqRoutingInfo->PciIrqRoutingTable, pirOptions);
                if ((tableStatus & 0xFFFF) < PIR_STATUS_TABLE_NONE)
                {
                    //
                    // Get the miniport instance for this motherboard.
                    //

                    miniportStatus = HalpInitializeMiniport(PciIrqRoutingInfo);
                    if ((miniportStatus & 0xFFFF) < PIR_STATUS_MINIPORT_NONE)
                    {

                        //
                        // Validate the Pci Irq Routing table with the miniport.
                        //

                        status = PciirqmpValidateTable( PciIrqRoutingInfo->PciIrqRoutingTable,
                                                        ((tableStatus & 0xFFFF) == PIR_STATUS_TABLE_REALMODE)? 1 : 0);
                        if (!NT_SUCCESS(status))
                        {
                            HalPrint(("Pci irq miniport failed to validate the routing table!"));
                            miniportStatus |= (PIR_STATUS_MINIPORT_INVALID << 16);
                        }
                        else
                        {
                            HalPrint(("Pci irq miniport validated routing table!"));
                            miniportStatus |= (PIR_STATUS_MINIPORT_SUCCESS << 16);
                            pirStatus = PIR_STATUS_ENABLED;
                            HalpIrqMiniportInitialized = TRUE;
                        }
                    }
                }
            }
            else
            {
                pirStatus = PIR_STATUS_ERROR;
            }
        }
        else
        {
            HalPrint(("Pci Irq Routing disabled!"));
        }

        //
        // Create list of links.
        //

        if (NT_SUCCESS(status))
        {
            status = HalpInitLinkNodes(PciIrqRoutingInfo);
        }

        //
        // Free the memory for the routing table if there was any error.
        //

        if (!NT_SUCCESS(status))
        {
            if (PciIrqRoutingInfo->PciIrqRoutingTable != NULL)
            {
                ExFreePool(PciIrqRoutingInfo->PciIrqRoutingTable);
                PciIrqRoutingInfo->PciIrqRoutingTable = NULL;
            }

            if (PciIrqRoutingInfo->PciInterface)
            {
                PciIrqRoutingInfo->PciInterface = NULL;
            }
        }

        //
        // Initialize the miniport if not done yet.
        //

        if (!HalpIrqMiniportInitialized)
        {
            PCI_IRQ_ROUTING_TABLE table;

            //
            // Use a local routing table variable since the miniport initialization
            // just needs to look at certain fields in the table.
            //

            PciIrqRoutingInfo->PciIrqRoutingTable = &table;
            PciIrqRoutingInfo->PciIrqRoutingTable->RouterBus = 0;
            PciIrqRoutingInfo->PciIrqRoutingTable->RouterDevFunc = 0;
            PciIrqRoutingInfo->PciIrqRoutingTable->CompatibleRouter = 0xFFFFFFFF;
            PciIrqRoutingInfo->PciIrqRoutingTable->MiniportData = 0;
            HalpIrqMiniportInitialized = ((HalpInitializeMiniport(PciIrqRoutingInfo) & 0xFFFF) < PIR_STATUS_MINIPORT_NONE)? TRUE : FALSE;

            //
            // Reset the routing table to NULL since we dont need it any more.
            //

            PciIrqRoutingInfo->PciIrqRoutingTable = NULL;
        }
    }

    //
    // Record the status in the registry for user display.
    //

    HalpWriteRegistryDwordValue(NULL, rgzPciIrqRouting, rgzStatus, pirStatus);
    HalpWriteRegistryDwordValue(NULL, rgzPciIrqRouting, rgzTableStatus, tableStatus);
    HalpWriteRegistryDwordValue(NULL, rgzPciIrqRouting, rgzMiniportStatus, miniportStatus);

    return (status);
}

ULONG
HalpGetIrqRoutingTable(
    OUT PPCI_IRQ_ROUTING_TABLE   *PciIrqRoutingTable,
    IN ULONG Options
    )

/*++

Routine Description:

    Reads the Pci Irq Routing table. First tries to
    read the table from the registry if available. Otherwise
    scans the BIOS ROM for the $PIR table.

Input Parameters:

    PciIrqRoutingTable is the pointer to the variable
    that recieves the pointer to the routing table.

Return Value:

    Status value indicating the source of the table.

--*/

{
    ULONG tableStatus = PIR_STATUS_TABLE_NONE | (PIR_STATUS_TABLE_MAX << 16);
    ULONG biosAttributes = 0;

    PAGED_CODE();

    *PciIrqRoutingTable = NULL;

    HalpReadRegistryDwordValue(NULL, rgzBiosInfo, rgzAttributes, &biosAttributes);

    if (Options & PIR_OPTION_REGISTRY)
    {
        //
        // First try getting it from the registry.
        //

        *PciIrqRoutingTable = HalpGetRegistryTable(rgzIrqRoutingTable, rgzOverride, 0);
        if (*PciIrqRoutingTable != NULL)
        {
            HalPrint(("Pci Irq Table read from the registry!"));
            tableStatus = PIR_STATUS_TABLE_REGISTRY;
        }
    }

    if ((Options & PIR_OPTION_MSSPEC) && !(biosAttributes & PIR_OPTION_MSSPEC))
    {
        if (*PciIrqRoutingTable == NULL)
        {
            //
            // Next try getting it by scanning the BIOS ROM for $PIR table.
            //

            *PciIrqRoutingTable = HalpGet$PIRTable();
            if (*PciIrqRoutingTable != NULL)
            {
                HalPrint(("Pci Irq Routing table read from $PIR table in BIOS ROM!"));
                tableStatus = PIR_STATUS_TABLE_MSSPEC;
            }
        }
    }

    if ((Options & PIR_OPTION_REALMODE) && !(biosAttributes & PIR_OPTION_REALMODE))
    {
        if (*PciIrqRoutingTable == NULL)
        {
            //
            // First try getting it from the registry.
            //

            *PciIrqRoutingTable = HalpGetPCIBIOSTableFromRealMode();
            if (*PciIrqRoutingTable != NULL)
            {
                HalPrint(("Pci Irq Table read from PCI BIOS using real-mode interface!"));
                tableStatus = PIR_STATUS_TABLE_REALMODE;
            }
        }
    }

    if (*PciIrqRoutingTable == NULL)
    {
        if (biosAttributes)
        {
            tableStatus = PIR_STATUS_TABLE_BAD | (PIR_STATUS_TABLE_MAX << 16);
        }

        HalPrint(("No Pci Irq Routing table found for this system!"));
    }
    else
    {
        tableStatus |= (PIR_STATUS_TABLE_SUCCESS << 16);
    }

    return (tableStatus);
}

ULONG
HalpInitializeMiniport(
    IN OUT PPCI_IRQ_ROUTING_INFO    PciIrqRoutingInfo
    )

/*++

Routine Description:

    Initializes the appropriate miniport for this motherboard.

Input Parameters:

    PciIrqRoutingTable - Routing Table for which miniport
    needs to be initialized.

Return Value:

    Status value indicating whether the miniport initialized or not.

--*/

{
    ULONG                   miniportStatus;
    NTSTATUS                status;
    PBUS_HANDLER            busHandler;
    PCI_SLOT_NUMBER         slotNumber;
    ULONG                   device;
    ULONG                   function;
    ULONG                   routerId;
    ULONG                   miniportInstance;
    HANDLE                  irqMiniport;
    UCHAR                   headerType;
    WCHAR                   buffer[10];
    UNICODE_STRING          keyName;
    PPCI_IRQ_ROUTING_TABLE  pciIrqRoutingTable = PciIrqRoutingInfo->PciIrqRoutingTable;

    PAGED_CODE();
    //
    // Setup to return failure.
    //

    miniportStatus = PIR_STATUS_MINIPORT_NONE;

    //
    // Open the Pci Interrupt Miniport key.
    //

    RtlInitUnicodeString( &keyName, rgzIrqMiniports);

    status = HalpOpenRegistryKey(   &irqMiniport,
                                    NULL,
                                    &keyName,
                                    KEY_READ,
                                    FALSE);
    if (NT_SUCCESS(status))
    {
        //
        // First see if there is any overriding miniport.
        //

        status = HalpReadRegistryDwordValue( irqMiniport,
                                        rgzOverride,
                                        rgzInstance,
                                        &miniportInstance);
        if (!NT_SUCCESS(status))
        {
            //
            // Next see if there is an entry for the specified device.
            //

            busHandler = HalpHandlerForBus(PCIBus, pciIrqRoutingTable->RouterBus);
            if (busHandler)
            {
                slotNumber.u.bits.DeviceNumber = pciIrqRoutingTable->RouterDevFunc >> 3;
                slotNumber.u.bits.FunctionNumber = pciIrqRoutingTable->RouterDevFunc & 0x07;
                routerId = 0xFFFFFFFF;
                HalpReadPCIConfig(  busHandler,
                                    slotNumber,
                                    &routerId,
                                    0,
                                    4);
                if (routerId != 0xFFFFFFFF)
                {

                    _snwprintf(buffer, sizeof(buffer) / sizeof(*buffer), L"%08X", routerId);
                    buffer[(sizeof(buffer) / sizeof(*buffer)) - 1] = UNICODE_NULL;

                    status = HalpReadRegistryDwordValue( irqMiniport,
                                                    buffer,
                                                    rgzInstance,
                                                    &miniportInstance);
                    if (NT_SUCCESS(status))
                    {
                        HalPrint(("Found miniport instance %08X for this motherboard!", miniportInstance));
                        miniportStatus = PIR_STATUS_MINIPORT_NORMAL;
                        HalpReadRegistryDwordValue(irqMiniport, buffer, rgzPciParameters, &PciIrqRoutingInfo->Parameters);
                    }
                }
            }
        }
        else
        {
            HalPrint(("Overriding miniport instance %08X found for this motherboard!", miniportInstance));
            miniportStatus = PIR_STATUS_MINIPORT_OVERRIDE;
        }

        //
        // Next see if we have a miniport for the compatible router.
        //

        if (miniportStatus == PIR_STATUS_MINIPORT_NONE)
        {

            //
            // Make sure there is a valid compatible router.
            //

            if (    pciIrqRoutingTable->CompatibleRouter != 0xFFFFFFFF &&
                    pciIrqRoutingTable->CompatibleRouter != 0)
            {
                _snwprintf(buffer, sizeof(buffer) / sizeof(*buffer), L"%08X", pciIrqRoutingTable->CompatibleRouter);
                buffer[(sizeof(buffer) / sizeof(*buffer)) - 1] = UNICODE_NULL;

                status = HalpReadRegistryDwordValue( irqMiniport,
                                                buffer,
                                                rgzInstance,
                                                &miniportInstance);
                if (NT_SUCCESS(status))
                {
                    HalPrint(("Found miniport instance %08X for this motherboard using compatible router %08X!", miniportInstance, pciIrqRoutingTable->CompatibleRouter));
                    miniportStatus = PIR_STATUS_MINIPORT_COMPATIBLE;
                    HalpReadRegistryDwordValue(irqMiniport, buffer, rgzPciParameters, &PciIrqRoutingInfo->Parameters);
                }
            }
        }

        if (miniportStatus == PIR_STATUS_MINIPORT_NONE)
        {
            //
            // Last see if any device on bus 0 matches any of our supported
            // routers.
            //

            busHandler = HalpHandlerForBus(PCIBus, 0);
            if (busHandler)
            {
                slotNumber.u.AsULONG = 0;
                for (   device = 0;
                        device < PCI_MAX_DEVICES && (miniportStatus == PIR_STATUS_MINIPORT_NONE);
                        device++)
                {
                    slotNumber.u.bits.DeviceNumber = device;

                    for (function = 0; function < PCI_MAX_FUNCTION; function++)
                    {
                        slotNumber.u.bits.FunctionNumber = function;

                        routerId = 0xFFFFFFFF;
                        HalpReadPCIConfig(  busHandler,
                                            slotNumber,
                                            &routerId,
                                            0,
                                            4);
                        if (routerId == 0xFFFFFFFF)
                            continue;

                        _snwprintf(buffer, sizeof(buffer) / sizeof(*buffer), L"%08X", routerId);
                        buffer[(sizeof(buffer) / sizeof(*buffer)) - 1] = UNICODE_NULL;

                        status = HalpReadRegistryDwordValue( irqMiniport,
                                                        buffer,
                                                        rgzInstance,
                                                        &miniportInstance);
                        if (NT_SUCCESS(status))
                        {
                            HalPrint(("Found miniport instance %08X for this motherboard for bus 0 device %08X", miniportInstance, routerId));
                            pciIrqRoutingTable->RouterBus = 0;
                            pciIrqRoutingTable->RouterDevFunc = (UCHAR)((device << 3) + function);
                            miniportStatus = PIR_STATUS_MINIPORT_NORMAL;
                            HalpReadRegistryDwordValue(irqMiniport, buffer, rgzPciParameters, &PciIrqRoutingInfo->Parameters);
                            break;
                        }
                        //
                        // Dont waste time if this is not a multifunction device.
                        //
                        if (function == 0)
                        {
                            headerType = 0;
                            HalpReadPCIConfig(  busHandler,
                                                slotNumber,
                                                &headerType,
                                                0x0E,
                                                sizeof(headerType));
                            if (!(headerType & PCI_MULTIFUNCTION))
                                break;
                        }
                    }
                }
            }
        }

        ZwClose(irqMiniport);

        //
        // Initialize the miniport if we found one.
        //

        if (miniportStatus != PIR_STATUS_MINIPORT_NONE)
        {
            status = PciirqmpInit(  miniportInstance,
                                    pciIrqRoutingTable->RouterBus,
                                    pciIrqRoutingTable->RouterDevFunc);
            if (!NT_SUCCESS(status))
            {
                HalPrint(("Pci Irq miniport %08X failed to initialize!", miniportInstance));
                miniportStatus |= (PIR_STATUS_MINIPORT_ERROR << 16);
            }
            else
            {
                HalPrint(("Pci Irq miniport %08X successfully initialized!", miniportInstance));
            }
        }
        else
        {
            HalPrint(("No Pci Irq miniport found for this system!"));
            miniportStatus |= (PIR_STATUS_MINIPORT_MAX << 16);
        }
    }
    else
    {
        HalPrint(("Could not open the Pci Irq Miniports key, no miniports provided!"));
        miniportStatus = PIR_STATUS_MINIPORT_NOKEY | (PIR_STATUS_MINIPORT_MAX << 16);
    }

    return (miniportStatus);
}

NTSTATUS
HalpInitLinkNodes(
    PPCI_IRQ_ROUTING_INFO   PciIrqRoutingInfo
    )

/*++

    Routine Description:

        This routine creates a singly linked list of link nodes
        structures from the Pci Irq Routing table.

    Input Parameters:

        PciIrqRoutingInfo - Pci Irq Routing Information.

    Return Value:

        STATUS_SUCCESS iff successful. Else STATUS_UNSUCCESSFUL.

--*/

{
    PPCI_IRQ_ROUTING_TABLE  pciIrqRoutingTable;
    PSLOT_INFO              slotInfo;
    PSLOT_INFO              lastSlot;
    PPIN_INFO               pinInfo;
    PPIN_INFO               lastPin;
    PLINK_NODE              linkNode;
    NTSTATUS                status = STATUS_SUCCESS;
    PLINK_NODE              temp;

    PAGED_CODE();

    ASSERT(PciIrqRoutingInfo);

    pciIrqRoutingTable = PciIrqRoutingInfo->PciIrqRoutingTable;

    PciIrqRoutingInfo->LinkNodeHead = NULL;

    //
    // Process all slots in this table.
    //

    slotInfo = (PSLOT_INFO)((PUCHAR)pciIrqRoutingTable +
                                        sizeof(PCI_IRQ_ROUTING_TABLE));
    lastSlot = (PSLOT_INFO)((PUCHAR)pciIrqRoutingTable +
                                        pciIrqRoutingTable->TableSize);
    while (slotInfo < lastSlot)
    {
        //
        // Process all pins.
        //

        pinInfo = &slotInfo->PinInfo[0];
        lastPin = &slotInfo->PinInfo[NUM_IRQ_PINS];
        while (pinInfo < lastPin)
        {
            //
            // Only process valid link values.
            //

            if(pinInfo->Link)
            {
                //
                // Have we seen this link before.
                //

                for (   linkNode = PciIrqRoutingInfo->LinkNodeHead;
                        linkNode && linkNode->Link != pinInfo->Link;
                        linkNode = linkNode->Next);
                if (linkNode == NULL)
                {
                    //
                    // Allocate memory for new link info.
                    //

                    linkNode = ExAllocatePoolWithTag(   NonPagedPool,
                                                        sizeof(LINK_NODE),
                                                        HAL_POOL_TAG);
                    if (linkNode)
                    {
                        linkNode->Allocation = ExAllocatePoolWithTag(   NonPagedPool,
                                                                        sizeof(LINK_STATE),
                                                                        HAL_POOL_TAG);

                        linkNode->PossibleAllocation = ExAllocatePoolWithTag(   NonPagedPool,
                                                                                sizeof(LINK_STATE),
                                                                                HAL_POOL_TAG);
                        if (    linkNode->Allocation &&
                                linkNode->PossibleAllocation)
                        {
                            linkNode->Signature = PCI_LINK_SIGNATURE;
                            linkNode->Next = PciIrqRoutingInfo->LinkNodeHead;
                            PciIrqRoutingInfo->LinkNodeHead = linkNode;
                            linkNode->Link = pinInfo->Link;
                            linkNode->InterruptMap = pinInfo->InterruptMap;
                            linkNode->Allocation->Interrupt = 0;
                            linkNode->Allocation->RefCount = 0;
                            linkNode->PossibleAllocation->Interrupt = 0;
                            linkNode->PossibleAllocation->RefCount = 0;
                        }
                        else
                        {
                            status = STATUS_UNSUCCESSFUL;
                            break;
                        }
                    }
                    else
                    {
                        status = STATUS_UNSUCCESSFUL;
                        break;
                    }
                }
            }

            //
            // Next pin.
            //

            pinInfo++;
        }

        //
        // Next slot.
        //

        slotInfo++;
    }

    //
    // Clean up if there was an error.
    //

    if (!NT_SUCCESS(status))
    {
        linkNode = PciIrqRoutingInfo->LinkNodeHead;
        while (linkNode)
        {
            if (linkNode->Allocation)
            {
                ExFreePool(linkNode->Allocation);
            }
            if (linkNode->PossibleAllocation)
            {
                ExFreePool(linkNode->PossibleAllocation);
            }

            temp = linkNode;
            linkNode = linkNode->Next;
            ExFreePool(temp);
        }

        PciIrqRoutingInfo->LinkNodeHead = NULL;
    }

    return (status);
}

PPCI_IRQ_ROUTING_TABLE
HalpGetRegistryTable(
    IN const WCHAR*  KeyName,
    IN const WCHAR*  ValueName,
    IN ULONG    HeaderSize OPTIONAL
    )

/*++

Routine Description:

    Reads the Pci Irq Routing Table from the registry. The table is
    saved as Override value under IrqRoutingTable key.

Input Parameters:

    KeyName - Name of key that needs to be read.
    
    ValueName - Name of the value to be read.
    
    HeaderSize - Header to be skipped from the value read.

Return Value:

    Pointer to the Pci Irq Routing Table if successful.
    NULL if there is no valid table in the registry.

--*/

{
    PVOID                           table = NULL;
    NTSTATUS                        status;
    HANDLE                          hPIR;
    ULONG                           tableSize;
    PKEY_VALUE_FULL_INFORMATION     valueInfo;
    PVOID                           buffer;
    UNICODE_STRING                  override;
    UNICODE_STRING                  keyName;

    PAGED_CODE();
    //
    // Open the PciInterruptRouting registry key.
    //

    RtlInitUnicodeString(&keyName, KeyName);
    status = HalpOpenRegistryKey(&hPIR, NULL, &keyName, KEY_READ, FALSE);
    if (NT_SUCCESS(status))
    {
        //
        // Get the size of the table.
        //

        tableSize = 0;
        RtlInitUnicodeString(&override, ValueName);
        status = ZwQueryValueKey(   hPIR,
                                    &override,
                                    KeyValueFullInformation,
                                    NULL,
                                    0,
                                    &tableSize);
        if ((status == STATUS_BUFFER_OVERFLOW || status == STATUS_BUFFER_TOO_SMALL) && tableSize != 0)
        {

            //
            // Allocate memory for the table.
            //

            buffer = ExAllocatePoolWithTag( PagedPool,
                                            tableSize,
                                            HAL_POOL_TAG);
            if (buffer != NULL)
            {
                //
                // Read the table.
                //

                status = ZwQueryValueKey(   hPIR,
                                            &override,
                                            KeyValueFullInformation,
                                            buffer,
                                            tableSize,
                                            &tableSize);
                if (NT_SUCCESS(status))
                {
                    valueInfo = (PKEY_VALUE_FULL_INFORMATION)buffer;

                    table = ExAllocatePoolWithTag(  PagedPool,
                                                    valueInfo->DataLength - HeaderSize,
                                                    HAL_POOL_TAG);
                    if (table != NULL)
                    {
                        RtlCopyMemory( table,
                                (PUCHAR)buffer + valueInfo->DataOffset + HeaderSize,
                                valueInfo->DataLength - HeaderSize);

                        if (HalpSanityCheckTable(table, TRUE) == FALSE)
                        {
                            ExFreePool(table);
                            table = NULL;
                        }
                    }
                    else
                    {
                        HalPrint(("Could not allocate memory to read the Pci Irq Routing Table from the registry!"));
                        ASSERT(table);
                    }
                }

                ExFreePool(buffer);
            }
            else
            {
                HalPrint(("Could not allocate memory to read the Pci Irq Routing Table from the registry!"));
                ASSERT(buffer);
            }
        }

        ZwClose(hPIR);
    }

    return (table);
}

PPCI_IRQ_ROUTING_TABLE
HalpGet$PIRTable(
    VOID
    )

/*++

Routine Description:

    Reads the Pci Irq Routing Table from $PIR table in the BIOS ROM.

Input Parameters:

    None.

Return Value:

    Pointer to the Pci Irq Routing Table if successful.
    NULL if there is no valid table in the ROM.

--*/

{
    PUCHAR                          biosStart;
    PUCHAR                          biosEnd;
    PUCHAR                          searchPtr;
    NTSTATUS                        status;
    ULONG                           offset;
    PPCI_IRQ_ROUTING_TABLE          table;
    PHYSICAL_ADDRESS                biosStartPhysical;

    PAGED_CODE();
    //
    // Setup to return failure.
    //

    table = NULL;

    biosStartPhysical.QuadPart = PIRT_BIOS_START;
    biosStart = (PUCHAR)HalpMapPhysicalMemory(  biosStartPhysical,
                                                PIRT_BIOS_SIZE >> PAGE_SHIFT);
    if (biosStart != NULL)
    {
        biosEnd = biosStart + PIRT_BIOS_SIZE;

        //
        // First try the cached location from the registry.
        //

        status = HalpReadRegistryDwordValue( NULL,
                                        rgzPciIrqRouting,
                                        rgz$PIROffset,
                                        &offset);
        if (NT_SUCCESS(status))
        {
            table = HalpCopy$PIRTable(biosStart + offset, biosEnd);
        }

        if (table == NULL)
        {
            for (   searchPtr = biosStart;
                    searchPtr < biosEnd;
                    searchPtr += PIRT_ALIGNMENT)
            {
                table = HalpCopy$PIRTable(searchPtr, biosEnd);
                if (table != NULL)
                {
                    //
                    // Record this offset so it can be used on the next boot.
                    //

                    offset = searchPtr - biosStart;
                    HalPrint(("Recording location %08X of $PIR table in the registry!", PIRT_BIOS_START + offset));
                    HalpWriteRegistryDwordValue( NULL,
                                            rgzPciIrqRouting,
                                            rgz$PIROffset,
                                            offset);
                    break;
                }
            }
        }
        else
        {
            HalPrint(("Used cached location %08X to read $PIR table!", PIRT_BIOS_START + offset));
        }
        //
        // Unmap now that we are done.
        //
        HalpUnmapVirtualAddress(biosStart, PIRT_BIOS_SIZE >> PAGE_SHIFT);
    }
    else
    {
        HalPrint(("Failed to map BIOS ROM to scan for $PIR Pci Irq Routing Table!"));
        ASSERT(biosStart);
    }

    return (table);
}

PPCI_IRQ_ROUTING_TABLE
HalpGetPCIBIOSTableFromRealMode(
    VOID
    )

/*++

Routine Description:

    Gets the PCI IRQ routing table from PCI BIOS using real-mode
    interface. The table is read by ntdetect.com and added to the
    ARC tree in the registry.

Input Parameters:

    None.

Return Value:

    Pointer to the Pci Irq Routing Table if successful.
    NULL if there is no valid table.

--*/

{
    PPCI_IRQ_ROUTING_TABLE      table = NULL;
    NTSTATUS                    status;
    HANDLE                      mf;
    HANDLE                      child = NULL;
    UNICODE_STRING              unicodeString;
    ULONG                       index;
    ULONG                       length;
    ULONG                       temp;
    BOOLEAN                     done;
    BOOLEAN                     error;
    PKEY_BASIC_INFORMATION      keyInfo;
    PKEY_VALUE_FULL_INFORMATION childInfo;

    PAGED_CODE();

    length = PAGE_SIZE;
    keyInfo = ExAllocatePoolWithTag(    PagedPool,
                                        length,
                                        HAL_POOL_TAG);

    if (keyInfo == NULL)
    {
        HalPrint(("Could not allocate memory to enumerate keys!"));
        return (table);
    }

    childInfo = ExAllocatePoolWithTag(  PagedPool,
                                        length,
                                        HAL_POOL_TAG);

    if (childInfo == NULL)
    {
        ExFreePool(keyInfo);
        HalPrint(("Could not allocate memory to query value!"));
        return (table);
    }

    //
    // Search for the IRQ routing table under the multifunction branch of the registry.
    //

    RtlInitUnicodeString(   &unicodeString,
                            L"\\Registry\\MACHINE\\HARDWARE\\DESCRIPTION\\System\\MultiFunctionAdapter");
    status = HalpOpenRegistryKey(&mf, NULL, &unicodeString, MAXIMUM_ALLOWED, FALSE);
    if (NT_SUCCESS(status))
    {
        index = 0;
        done = FALSE;
        error = FALSE;
        while (!done && !error)
        {
            error = TRUE;
            status = ZwEnumerateKey(    mf,
                                        index++,
                                        KeyBasicInformation,
                                        keyInfo,
                                        length,
                                        &temp);
            if (NT_SUCCESS(status))
            {
                keyInfo->Name[keyInfo->NameLength / sizeof(WCHAR)] = UNICODE_NULL;
                RtlInitUnicodeString(&unicodeString, keyInfo->Name);
                status = HalpOpenRegistryKey(   &child,
                                                mf,
                                                &unicodeString,
                                                MAXIMUM_ALLOWED,
                                                FALSE);
                if (NT_SUCCESS(status))
                {
                    //
                    // Read the "identifier".
                    //

                    RtlInitUnicodeString(&unicodeString, L"Identifier");
                    status = ZwQueryValueKey(   child,
                                                &unicodeString,
                                                KeyValueFullInformation,
                                                childInfo,
                                                length,
                                                &temp);
                    if (NT_SUCCESS(status))
                    {
                        error = FALSE;
                        if ((8 * sizeof(WCHAR) + sizeof(UNICODE_NULL)) == childInfo->DataLength)
                        {
                            done = RtlEqualMemory( (PCHAR)childInfo + childInfo->DataOffset,
                                                    L"PCI BIOS",
                                                    childInfo->DataLength);
                        }
                    }
                    else
                    {
                        HalPrint(("Failed to query value!"));
                    }
                }
                else
                {
                    HalPrint(("Could not open child key!"));
                }
            }
            else
            {
                HalPrint(("Failed to enumerate keys!"));
            }

            //
            // Close the child key if it was successfully opened.
            //

            if (child)
            {
                ZwClose(child);
                child = NULL;
            }
        }

        //
        // Close the MF adapter key.
        //

        ZwClose(mf);

        if (done && !error)
        {
            unicodeString.Length = 0;
            unicodeString.MaximumLength = (USHORT)(256 * sizeof(WCHAR) + keyInfo->NameLength);
            unicodeString.Buffer = ExAllocatePoolWithTag(   PagedPool,
                                                            unicodeString.MaximumLength,
                                                            HAL_POOL_TAG);
            if (unicodeString.Buffer)
            {
                RtlAppendUnicodeToString(   &unicodeString,
                                            L"\\Registry\\MACHINE\\HARDWARE\\DESCRIPTION\\System\\MultiFunctionAdapter\\");
                RtlAppendUnicodeToString(&unicodeString, keyInfo->Name);
                RtlAppendUnicodeToString(&unicodeString, L"\\RealModeIrqRoutingTable\\0");
                table = HalpGetRegistryTable(unicodeString.Buffer, L"Configuration Data", sizeof(CM_FULL_RESOURCE_DESCRIPTOR));
                if (table == NULL)
                {
                    HalPrint(("Could not read table from PCIBIOS using real-mode interface!"));
                }
                ExFreePool(unicodeString.Buffer);
            }
            else
            {
                HalPrint(("Could not allocate memory to read routing table from PCIBIOS real-mode interface!"));
            }
        }

        ExFreePool(keyInfo);
        ExFreePool(childInfo);
    }

    return (table);
}

PPCI_IRQ_ROUTING_TABLE
HalpCopy$PIRTable(
    IN PUCHAR   BiosPtr,
    IN PUCHAR   BiosEnd
    )

/*++

Routine Description:

    Allocates memory and copies the $PIR table if found at the specified
    address.

Input Parameters:

    BiosPtr - Location that possibly contains the $PIR table.
    
    BiosEnd - Last possible BIOS ROM address.

Return Value:

    Pointer to the Pci Irq Routing Table if successful.
    NULL if there is no valid table at the specified address.

--*/

{
    PPCI_IRQ_ROUTING_TABLE  table = (PPCI_IRQ_ROUTING_TABLE)BiosPtr;
    PVOID                   buffer = NULL;

    PAGED_CODE();
    //
    // Validate this table.
    //

    if (    (table->Signature == PIRT_SIGNATURE) &&
            (BiosPtr + table->TableSize <= BiosEnd) &&
            (table->Signature == PIRT_SIGNATURE) &&
            (table->TableSize > 0) )
    {
        //
        // Allocate memory for the table.
        //

        buffer = ExAllocatePoolWithTag( PagedPool,
                                        table->TableSize,
                                        HAL_POOL_TAG);
        if (buffer != NULL)
        {
            //
            // Copy the table from the ROM into the allocated memory.
            //

            RtlCopyMemory(buffer, table, table->TableSize);
            if (!HalpSanityCheckTable(buffer, FALSE))
            {
                ExFreePool(buffer);
                buffer = NULL;
            }
        }
        else
        {
            HalPrint(("Failed to allocate memory for $PIR Pci Irq Routing Table!"));
            ASSERT(buffer);
        }
    }

    return (buffer);
}

BOOLEAN
HalpSanityCheckTable(
    IN PPCI_IRQ_ROUTING_TABLE PciIrqRoutingTable,
    IN BOOLEAN IgnoreChecksum
    )

/*++

Routine Description:

    Validate the Pci Irq Routing Table.

Input Parameters:

    PciIrqRoutingTable - Pointer to the Pci Irq Routing Table.
    
    IgnoreChecksum - Ignore checksum iff TRUE.

Return Value:

    TRUE if this is a valid table, else FALSE.

--*/

{
    CHAR        checkSum;
    PUCHAR      tablePtr;
    PUCHAR      tableEnd;
    PSLOT_INFO  slotInfo;
    PSLOT_INFO  lastSlot;
    PPIN_INFO   pinInfo;
    PPIN_INFO   lastPin;
    BOOLEAN     hasNonZeroBusEntries = FALSE;
    BOOLEAN     valid = TRUE;
    PSLOT_INFO  testSlot;
    ULONG       pin;

    PAGED_CODE();

    //
    // Test1: Should have a valid signature.
    //

    if (PciIrqRoutingTable->Signature != PIRT_SIGNATURE)
    {
        HalPrint(("Pci Irq Routing Table has invalid signature %08X!", PciIrqRoutingTable->Signature));
        valid = FALSE;
    }

    //
    // Test2 - Should have a valid version.
    //

    else if (PciIrqRoutingTable->Version != PIRT_VERSION)
    {
        HalPrint(("Pci Irq Routing Table has invalid version %04X!", PciIrqRoutingTable->Version));
        valid = FALSE;
    }

    //
    // Test3 - Should have a valid size.
    //

    else if (   PciIrqRoutingTable->TableSize % 16 != 0 ||
                PciIrqRoutingTable->TableSize <= sizeof (PCI_IRQ_ROUTING_TABLE))
    {
        HalPrint(("Pci Irq Routing Table has invalid size %04X!", PciIrqRoutingTable->TableSize));
        valid = FALSE;
    }
    else if (!IgnoreChecksum)
    {
        //
        // Test4 - Should have a valid checksum.
        //

        checkSum = 0;
        tablePtr = (PUCHAR)PciIrqRoutingTable;

        for (   tableEnd = tablePtr + PciIrqRoutingTable->TableSize;
                tablePtr < tableEnd;
                tablePtr++)
        {
            checkSum += *tablePtr;
        }

        if (checkSum != 0)
        {
            HalPrint(("Pci Irq Routing Table checksum is invalid!"));
            valid = FALSE;
        }
    }

    if(valid)
    {
        //
        // First get rid of sutpid entries.
        //

        slotInfo = (PSLOT_INFO)((PUCHAR)PciIrqRoutingTable + sizeof(PCI_IRQ_ROUTING_TABLE));
        lastSlot = (PSLOT_INFO)((PUCHAR)PciIrqRoutingTable + PciIrqRoutingTable->TableSize);

        while (slotInfo < lastSlot && valid)
        {
            //
            // Process all pins.
            //

            pinInfo = &slotInfo->PinInfo[0];
            lastPin = &slotInfo->PinInfo[NUM_IRQ_PINS];

            while (pinInfo < lastPin)
            {
                //
                // Check for bad cases.
                //

                if(pinInfo->Link)
                {
                    if (    pinInfo->InterruptMap == 0x0000 ||
                            pinInfo->InterruptMap == 0x0001)
                    {
                        HalPrint(("Removing stupid maps (%04X) from IRQ routing table entry (b=%02X, d=%02X, s=%02X)!", pinInfo->InterruptMap, slotInfo->BusNumber, slotInfo->DeviceNumber>>3, slotInfo->SlotNumber));
                        pinInfo->InterruptMap = 0;
                        pinInfo->Link = 0;
                    }
                }

                //
                // Next pin.
                //

                pinInfo++;
            }

            //
            // Remove this entry if all pins have NULL links.
            //

            if (    slotInfo->PinInfo[0].Link == 0 &&
                    slotInfo->PinInfo[1].Link == 0 &&
                    slotInfo->PinInfo[2].Link == 0 &&
                    slotInfo->PinInfo[3].Link == 0)
            {
                HalPrint(("Removed redundant entry (b=%02X, d=%02X, s=%02X) from IRQ routing table!", slotInfo->BusNumber, slotInfo->DeviceNumber>>3, slotInfo->SlotNumber));
                *slotInfo = *(--lastSlot);
                PciIrqRoutingTable->TableSize -= sizeof(SLOT_INFO);

                //
                // Need to test the newly copied entry.
                //

                continue;
            }

            //
            // Merge entries for MF devices.
            //

            testSlot = slotInfo + 1;
            while (testSlot < lastSlot)
            {
                if (    (testSlot->DeviceNumber & 0xF8) == (slotInfo->DeviceNumber & 0xF8) &&
                        testSlot->BusNumber == slotInfo->BusNumber)
                {
                    //
                    // Process all pins.
                    //
                    for (pin = 0; pin < NUM_IRQ_PINS; pin++)
                    {
                        if (testSlot->PinInfo[pin].Link)
                        {
                            if (slotInfo->PinInfo[pin].Link)
                            {
                                HalPrint(("Multiple entries for the same device (b=%02X, d=%02X, s=%02X) and link (%04X) in IRQ routing table!", slotInfo->BusNumber, slotInfo->DeviceNumber>>3, slotInfo->SlotNumber, slotInfo->PinInfo[pin].Link));
                                valid = FALSE;
                                break;
                            }
                            else
                            {
                                HalPrint(("Merging multiple entries for same device (b=%02X, d=%02X, s=%02X) in IRQ routing table!", slotInfo->BusNumber, slotInfo->DeviceNumber>>3, slotInfo->SlotNumber));
                                slotInfo->PinInfo[pin] = testSlot->PinInfo[pin];
                            }
                        }
                    }
                    if (!valid)
                    {
                        break;
                    }
                    *testSlot = *(--lastSlot);
                    PciIrqRoutingTable->TableSize -= sizeof(SLOT_INFO);

                    //
                    // Need to test the newly copied entry.
                    //

                    continue;
                }
                testSlot++;
            }

            if (slotInfo->BusNumber > 0)
            {
                hasNonZeroBusEntries = TRUE;
            }

            //
            // Next slot.
            //

            slotInfo++;
        }

        if (valid && PciIrqRoutingTable->TableSize == sizeof(PCI_IRQ_ROUTING_TABLE))
        {
            HalPrint(("No IRQ routing table left after sanity checking!"));
            valid = FALSE;
        }
    }

    //
    // Make sure there are entries for all bus 0 devices in the table.
    //

    if (valid)
    {
        PBUS_HANDLER        busHandler;
        PCI_SLOT_NUMBER     slotNumber;
        ULONG               device;
        ULONG               function;
        UCHAR               buffer[PCI_COMMON_HDR_LENGTH];
        PPCI_COMMON_CONFIG  pciData = (PPCI_COMMON_CONFIG)&buffer[0];


        busHandler = HalpHandlerForBus(PCIBus, 0);
        if (busHandler)
        {
            slotNumber.u.AsULONG = 0;
            for (   device = 0;
                    device < PCI_MAX_DEVICES && valid;
                    device++)
            {
                slotNumber.u.bits.DeviceNumber = device;

                for (function = 0; function < PCI_MAX_FUNCTION && valid; function++)
                {
                    slotNumber.u.bits.FunctionNumber = function;

                    //
                    // Read the standard config space.
                    //

                    HalpReadPCIConfig(busHandler, slotNumber, pciData, 0, PCI_COMMON_HDR_LENGTH);

                    //
                    // Make sure this is a valid device.
                    //

                    if (pciData->VendorID != 0xFFFF && pciData->DeviceID != 0xFFFF)
                    {

                        //
                        // Ignore IDE devices.
                        //

                        if (    (pciData->BaseClass != PCI_CLASS_MASS_STORAGE_CTLR && pciData->SubClass != PCI_SUBCLASS_MSC_IDE_CTLR) ||
                                (pciData->ProgIf & 0x05))
                        {
                            //
                            // Handle P-P bridges separately.
                            //

                            if (    ((pciData->HeaderType & 0x7F) == PCI_BRIDGE_TYPE) &&
                                    pciData->BaseClass == PCI_CLASS_BRIDGE_DEV && pciData->SubClass == PCI_SUBCLASS_BR_PCI_TO_PCI)
                            {
                                //
                                // P-P bridge.
                                //

                                if (!hasNonZeroBusEntries)
                                {
                                    //
                                    // Must have the bridge with at least one entry.
                                    //

                                    slotInfo = (PSLOT_INFO)((PUCHAR)PciIrqRoutingTable + sizeof(PCI_IRQ_ROUTING_TABLE));
                                    lastSlot = (PSLOT_INFO)((PUCHAR)PciIrqRoutingTable + PciIrqRoutingTable->TableSize);
                                    valid = FALSE;
                                    while (slotInfo < lastSlot && !valid)
                                    {
                                        if ((slotInfo->DeviceNumber>>3) == (UCHAR)device)
                                        {
                                            //
                                            // Process all pins.
                                            //

                                            pinInfo = &slotInfo->PinInfo[0];
                                            lastPin = &slotInfo->PinInfo[NUM_IRQ_PINS];

                                            while (pinInfo < lastPin)
                                            {
                                                if(pinInfo->Link)
                                                {
                                                    valid = TRUE;
                                                    break;
                                                }
                                                pinInfo++;
                                            }
                                        }
                                        slotInfo++;
                                    }
                                    if (!valid)
                                    {
                                        HalPrint(("All links missing for bridge (b=%02X, d=%02X, s=%02X)!", slotInfo->BusNumber, slotInfo->DeviceNumber>>3, slotInfo->SlotNumber));
                                    }
                                }
                            }
                            else
                            {
                                UCHAR   intLine;
                                UCHAR   intPin;

                                //
                                // Normal device.
                                //

                                if ((pciData->HeaderType & 0x7F) == PCI_CARDBUS_BRIDGE_TYPE)
                                {
                                    intPin = pciData->u.type2.InterruptPin;
                                    intLine = pciData->u.type2.InterruptLine;
                                }
                                else
                                {
                                    intPin = pciData->u.type0.InterruptPin;
                                    intLine = pciData->u.type0.InterruptLine;
                                }

                                if (intPin && intPin <= NUM_IRQ_PINS)
                                {
                                    if (    !(pciData->Command & (PCI_ENABLE_IO_SPACE | PCI_ENABLE_MEMORY_SPACE)) ||
                                            (intLine && intLine <= 0x0F))
                                    {
                                        intPin--;
                                        slotInfo = (PSLOT_INFO)((PUCHAR)PciIrqRoutingTable + sizeof(PCI_IRQ_ROUTING_TABLE));
                                        lastSlot = (PSLOT_INFO)((PUCHAR)PciIrqRoutingTable + PciIrqRoutingTable->TableSize);
                                        valid = FALSE;
                                        while (slotInfo < lastSlot)
                                        {
                                            if (    (slotInfo->DeviceNumber>>3) == (UCHAR)device &&
                                                    slotInfo->PinInfo[intPin].Link)
                                            {
                                                valid = TRUE;
                                                break;
                                            }
                                            slotInfo++;
                                        }
                                        if (!valid)
                                        {
                                            HalPrint(("Missing entry for device (b=%02X, d=%02X, s=%02X) in the IRQ routing table!", slotInfo->BusNumber, slotInfo->DeviceNumber>>3, slotInfo->SlotNumber));
                                        }
                                    }
                                }
                            }
                        }
                        //
                        // Dont waste time if this is not a multifunction device or
                        // device does not exist.
                        //

                        if ((function == 0 && !(pciData->HeaderType & PCI_MULTIFUNCTION)))
                        {
                            break;
                        }
                    }

                }
            }
        }
    }


    if (!valid) {
        HalPrint (("Failing IRQ routing table. IRQ routing will be disabled"));
    }

    return (valid);
}

NTSTATUS
HalpFindLinkNode(
    IN PPCI_IRQ_ROUTING_INFO PciIrqRoutingInfo,
    IN PDEVICE_OBJECT Pdo,
    IN ULONG Bus,
    IN ULONG Slot,
    OUT PLINK_NODE *LinkNode
    )

/*++

    Routine Description:

        This routine finds the link node for the specified PCI PDO.
        
    Input Parameters:

        PciIrqRoutingInfo - Pci Irq Routing information.

        Pdo - Pci device object for which we barber pole.

        Bus - Bus number for the device.

        Slot - Slot number for the device.
        
        LinkNode - Recieves the link node for the PCI PDO.
                                                        
    Return Value:

        NTSTATUS.

--*/

{
    PINT_ROUTE_INTERFACE_STANDARD   pciInterface;
    NTSTATUS        status;
    ULONG           dummy;
    UCHAR           classCode;
    UCHAR           subClassCode;
    ROUTING_TOKEN   routingToken;
    PSLOT_INFO      slotInfo;
    PLINK_NODE      linkNode;
    UCHAR           pin;
    PBUS_HANDLER    busHandler;
    PCI_SLOT_NUMBER ideSlotInfo;
    UCHAR           buffer[PCI_COMMON_HDR_LENGTH];
    PPCI_COMMON_CONFIG  pciData;
    BOOLEAN nativeMode;

    PAGED_CODE();

    ASSERT(IsPciIrqRoutingEnabled());

    *LinkNode = NULL;
    pciInterface = PciIrqRoutingInfo->PciInterface;

    //
    // Call Pci driver to get info about the Pdo.
    //

    status = pciInterface->GetInterruptRouting( Pdo,
                                                &Bus,
                                                &Slot,
                                                (PUCHAR)&dummy,
                                                &pin,
                                                &classCode,
                                                &subClassCode,
                                                (PDEVICE_OBJECT *)&dummy,
                                                &routingToken,
                                                (PUCHAR)&dummy);

    //
    // This means that it is not a Pci device.
    //

    if (!NT_SUCCESS(status))
    {
        return (STATUS_NOT_FOUND);
    }

    //
    // Pci Ide Irqs behave differently than other Pci devices.
    //

    if (    classCode == PCI_CLASS_MASS_STORAGE_CTLR &&
            subClassCode == PCI_SUBCLASS_MSC_IDE_CTLR)
    {
        nativeMode = FALSE;
        //
        // Check for native mode IDE controller.
        //

        busHandler = HalpHandlerForBus(PCIBus, Bus);
        if (busHandler)
        {
            pciData = (PPCI_COMMON_CONFIG)&buffer[0];
            ideSlotInfo.u.AsULONG = Slot;
            HalpReadPCIConfig(busHandler, ideSlotInfo, pciData, 0, PCI_COMMON_HDR_LENGTH);
            if (    pciData->VendorID != 0xFFFF &&
                    pciData->DeviceID != 0xFFFF &&
                    pciData->BaseClass == classCode &&
                    pciData->SubClass == subClassCode)
            {
                //
                // Check if either channel is in native mode?
                //

                if (pciData->ProgIf & 0x05)
                {
                    nativeMode = TRUE;
                }
            }
        }

        if (!nativeMode)
        {
            return (STATUS_RESOURCE_REQUIREMENTS_CHANGED);
        }
    }

    //
    // Have we cached this before?
    //

    if (routingToken.LinkNode != NULL)
    {
        ASSERT(((PLINK_NODE)routingToken.LinkNode)->Signature == PCI_LINK_SIGNATURE);

        *LinkNode = (PLINK_NODE)routingToken.LinkNode;

        return (STATUS_SUCCESS);
    }

    //
    // Get the slot info for this device.
    //

    slotInfo = HalpBarberPole(  PciIrqRoutingInfo,
                                Pdo,
                                Bus,
                                Slot,
                                &pin);
    if (slotInfo != NULL)
    {
        ASSERT(pin <4);

        for (   linkNode = PciIrqRoutingInfo->LinkNodeHead;
                linkNode && linkNode->Link != slotInfo->PinInfo[pin].Link;
                linkNode = linkNode->Next);

        if (linkNode != NULL)
        {
            *LinkNode = linkNode;

            //
            // Initialize the routing token.
            //

            routingToken.LinkNode = linkNode;
            routingToken.StaticVector = 0;
            routingToken.Flags = 0;

            //
            // Save the routing token.
            //

            status = pciInterface->SetInterruptRoutingToken(    Pdo,
                                                                &routingToken);
            if (!NT_SUCCESS(status))
            {
                HalPrint(("Failed to set Pci routing token!"));
                ASSERT(NT_SUCCESS(status));
            }
        }
    }

    return (STATUS_SUCCESS);
}

PSLOT_INFO
HalpBarberPole(
    IN PPCI_IRQ_ROUTING_INFO PciIrqRoutingInfo,
    IN PDEVICE_OBJECT Pdo,
    IN ULONG Bus,
    IN ULONG Slot,
    IN OUT PUCHAR Pin
    )

/*++

    Routine Description:

        This routine implements the "barber pole" algorithm to determine the interrupt
        pin for Pci devices behind bridges.

    Input Parameters:

        PciIrqRoutingInfo - Pci Irq Routing information.

        Pdo - Pci device object for which we barber pole.

        Bus - Child device objects bus number.

        Slot - Slot number for the device.
        
        Pin - Interrupt pin for the Pci device entry in the routing table we reached.

    Return Value:

        Slot info for the specified device iff successful.

--*/

{
    ULONG                           dummy;
    UCHAR                           pin;
    PDEVICE_OBJECT                  parent;
    ROUTING_TOKEN                   routingToken;
    BOOLEAN                         success;
    PSLOT_INFO                      slotInfo;
    NTSTATUS                        status;
    PINT_ROUTE_INTERFACE_STANDARD   pciInterface;

    PAGED_CODE();

    ASSERT(IsPciIrqRoutingEnabled());

    pciInterface = PciIrqRoutingInfo->PciInterface;

    //
    // This device MUST be a PCI device with a valid interrupt pin.
    //

    status = pciInterface->GetInterruptRouting( Pdo,
                                                &Bus,
                                                &Slot,
                                                (PUCHAR)&dummy,
                                                &pin,
                                                (PUCHAR)&dummy,
                                                (PUCHAR)&dummy,
                                                &parent,
                                                &routingToken,
                                                (PUCHAR)&dummy);
    if (!NT_SUCCESS(status) || pin == 0)
    {
        return (NULL);
    }

    //
    // Normalize the pin.
    //

    pin--;
    success = TRUE;
    while (success)
    {
        slotInfo = HalpGetSlotInfo( PciIrqRoutingInfo->PciIrqRoutingTable,
                                    (UCHAR)Bus,
                                    (UCHAR)(Slot & 0x1F));

        if (slotInfo != NULL)
        {
            break;
        }

        //
        // Get barber pole info for the parent.
        //

        success = HalpBarberPolePin(    PciIrqRoutingInfo,
                                        parent,
                                        Bus,
                                        Slot & 0x1F,
                                        &pin);

        Bus = (ULONG)-1;
        Slot = (ULONG)-1;

        //
        // Get parent's info.
        //

        status = pciInterface->GetInterruptRouting( parent,
                                                    &Bus,
                                                    &Slot,
                                                    (PUCHAR)&dummy,
                                                    (PUCHAR)&dummy,
                                                    (PUCHAR)&dummy,
                                                    (PUCHAR)&dummy,
                                                    &parent,
                                                    &routingToken,
                                                    (PUCHAR)&dummy);
        if (!NT_SUCCESS(status))
        {
            success = FALSE;
            break;
        }
    }

    //
    // Return unsuccessfully if we encountered any weird error.
    //

    if (success == FALSE)
        slotInfo = NULL;

    if (slotInfo)
    {
        *Pin = pin;
    }

    return (slotInfo);
}

BOOLEAN
HalpBarberPolePin(
    IN PPCI_IRQ_ROUTING_INFO PciIrqRoutingInfo,
    IN PDEVICE_OBJECT Parent,
    IN ULONG Bus,
    IN ULONG Device,
    IN OUT PUCHAR Pin
    )

/*++

    Routine Description:

        This routine returns the info used for barber poling.

    Input Parameters:

        PciIrqRoutingInfo - Pci Irq Routing information.

        Parent - Parent device object as we barber pole.

        Bus - Child device objects bus number.

        Device - Device number for the child device.

        Pin - Child device objects interrupt pin number (normalized) on entry.

    Return Value:

        TRUE iff successful.

--*/

{
    ULONG                           parentBus;
    ULONG                           parentSlot;
    ULONG                           dummy;
    UCHAR                           parentPin;
    UCHAR                           classCode;
    UCHAR                           subClassCode;
    ROUTING_TOKEN                   routingToken;
    NTSTATUS                        status;
    PINT_ROUTE_INTERFACE_STANDARD   pciInterface;

    PAGED_CODE();

    ASSERT(IsPciIrqRoutingEnabled());

    pciInterface = PciIrqRoutingInfo->PciInterface;

    //
    // Read the registry flags and see if this device supports straight
    // through routing.
    //

    //
    // Check if the pin table is present in the registry.
    //

    parentBus = (ULONG)-1;
    parentSlot = (ULONG)-1;

    //
    // Get info about the parent from Pci.
    //

    status = pciInterface->GetInterruptRouting( Parent,
                                                &parentBus,
                                                &parentSlot,
                                                (PUCHAR)&dummy,
                                                &parentPin,
                                                &classCode,
                                                &subClassCode,
                                                (PDEVICE_OBJECT *)&dummy,
                                                &routingToken,
                                                (PUCHAR)&dummy);
    if (NT_SUCCESS(status) && classCode == PCI_CLASS_BRIDGE_DEV)
    {
        switch (subClassCode)
        {
            case PCI_SUBCLASS_BR_PCI_TO_PCI:

                *Pin = (*Pin + (UCHAR)Device) % 4;
                break;

            case PCI_SUBCLASS_BR_CARDBUS:

                *Pin = parentPin - 1;
                break;

            default:

                HalPrint(("Pci device (bus=%02lx, slot=%02lx) does not have a PCI bridge as its parent!", Bus, Device));
                ASSERT(FALSE);
                return (FALSE);
        }
    }

    return (TRUE);
}

PSLOT_INFO
HalpGetSlotInfo(
    IN PPCI_IRQ_ROUTING_TABLE PciIrqRoutingTable,
    IN UCHAR   Bus,
    IN UCHAR   Device
    )

/*++

    Routine Description:

        This routine searches the Pci Irq Routing Table for an entry for the specified
        Pci device on the given bus number.

    Input Parameters:

        PciIrqRoutingInfo - Pci Irq Routing information.

        Bus - Bus number of the Pci device.

        Device - Device number of the Pci device.

    Return Value:

        Pointer to the slot info for the specified device iff successful.

--*/
{
    PSLOT_INFO slotInfo;
    PSLOT_INFO lastSlot;

    PAGED_CODE();

    ASSERT(IsPciIrqRoutingEnabled());

    //
    // Process all slots in this table.
    //

    slotInfo = (PSLOT_INFO)((PUCHAR)PciIrqRoutingTable +
                                        sizeof(PCI_IRQ_ROUTING_TABLE));
    lastSlot = (PSLOT_INFO)((PUCHAR)PciIrqRoutingTable +
                                        PciIrqRoutingTable->TableSize);

    while (slotInfo < lastSlot)
    {
        if (    slotInfo->BusNumber == Bus &&
                (slotInfo->DeviceNumber >> 3) == Device)
        {
            return (slotInfo);
        }
        slotInfo++;
    }

    return (NULL);
}

NTSTATUS
HalpReadRegistryDwordValue(
    IN HANDLE  Root,
    IN const WCHAR*  KeyName,
    IN const WCHAR*  ValueName,
    OUT PULONG  Data
    )

/*++

Routine Description:

    Reads the value for the valuename under the key specified.

Input Parameters:

    Root - Handle of the root key, if any.
    
    KeyName - Name of the key under which this value appears.
    
    ValueName - Name of the value to be read.
    
    Data - Variable that receives the value read.

Return Value:

    NTSTATUS.

--*/

{
    UNICODE_STRING      valueName;
    HANDLE              hKey;
    NTSTATUS            status;
    ULONG               cbData;
    UNICODE_STRING      keyName;
    PKEY_VALUE_FULL_INFORMATION p;

    PAGED_CODE();

    RtlInitUnicodeString( &keyName, KeyName);

    status = HalpOpenRegistryKey(&hKey, Root, &keyName, KEY_READ, FALSE);
    if (NT_SUCCESS(status))
    {
        cbData = 0;
        RtlInitUnicodeString(&valueName, ValueName);
        status = ZwQueryValueKey(   hKey,
                                    &valueName,
                                    KeyValueFullInformation,
                                    NULL,
                                    0,
                                    &cbData);
        if ((status == STATUS_BUFFER_OVERFLOW || status == STATUS_BUFFER_TOO_SMALL) && cbData) 
        {
            p  = ExAllocatePoolWithTag(
                    PagedPool,
                    cbData,
                    HAL_POOL_TAG);
            if (p) 
            {
                status = ZwQueryValueKey(   hKey,
                                            &valueName,
                                            KeyValueFullInformation,
                                            p,
                                            cbData,
                                            &cbData);
                if (NT_SUCCESS(status) && p->Type == REG_DWORD && p->DataLength == sizeof(ULONG))
                {
                    *Data = *(PULONG)((PUCHAR)p + p->DataOffset);
                }
                ExFreePool(p);
            }
        }

        ZwClose(hKey);
    }

    return (status);
}

NTSTATUS
HalpWriteRegistryDwordValue(
    IN HANDLE  Root,
    IN const WCHAR*  KeyName,
    IN const WCHAR*  ValueName,
    IN ULONG   Value
    )

/*++

Routine Description:

    Writes the value for the valuename under the key specified.

Input Parameters:

    Root - Handle of the root key, if any.
    
    KeyName - Name of the key under which this value appears.
    
    ValueName - Name of the value to be read.
    
    Value - Value to be written.

Return Value:

    Standard NT status value.

--*/

{
    NTSTATUS        status;
    UNICODE_STRING  valueName;
    HANDLE          hKey;
    UNICODE_STRING  keyName;

    PAGED_CODE();

    RtlInitUnicodeString(&keyName, KeyName);

    status = HalpOpenRegistryKey(&hKey, Root, &keyName, KEY_WRITE, FALSE);
    if (NT_SUCCESS(status))
    {
        RtlInitUnicodeString(&valueName, ValueName);
        status = ZwSetValueKey( hKey,
                                &valueName,
                                0,
                                REG_DWORD,
                                &Value,
                                sizeof(Value));
        ZwClose(hKey);
    }

    return (status);
}

NTSTATUS
HalpCommitLink(
    IN PLINK_NODE LinkNode
    )

/*++

Routine Description:

    Calls the IRQ miniport to program the link.

Input Parameters:

    LinkNode - Link that needs to be programmed.

Return Value:

    STATUS_SUCCESS.

--*/

{
    NTSTATUS status;
    ULONG interrupt;
    PLINK_STATE temp;
    BOOLEAN disableInterrupt;
    PLINK_NODE node;

    //
    // Read the current state of this link.
    //

    interrupt = 0;
    status = PciirqmpGetIrq((PUCHAR)&interrupt, (UCHAR)LinkNode->Link);
    if (LinkNode->PossibleAllocation->RefCount)
    {
        //
        // Program the link.
        //

        if (NT_SUCCESS(status) && interrupt != LinkNode->PossibleAllocation->Interrupt)
        {
            PciirqmpSetIrq((UCHAR)LinkNode->PossibleAllocation->Interrupt, (UCHAR)LinkNode->Link);
        }
    }
    else if (LinkNode->Allocation->RefCount)
    {
        //
        // Disable the link.
        //

        if (NT_SUCCESS(status) && interrupt)
        {
            //
            // If this is the last link with this interrupt, disable it in case
            // the driver did not do the right thing. Just checking the linknodes 
            // should be good enough even for the case where we change assignment 
            // for an IRQ from PCI to ISA device. When the ISA device gets 
            // started, on the subsequent connect, the interrupt would get enabled.
            //

            disableInterrupt = TRUE;
            for (   node = HalpPciIrqRoutingInfo.LinkNodeHead;
                    node;
                    node = node->Next)
            {
                if (node->PossibleAllocation->RefCount && interrupt == node->PossibleAllocation->Interrupt) 
                {
                    //
                    // Interrupt in use.
                    //

                    disableInterrupt = FALSE;
                }
            }

            if (disableInterrupt) 
            {
                HalPrint(("Disabling IRQ %08x since the last link %08x programmed to it is getting disabled\n", interrupt, LinkNode->Link));
                HalDisableSystemInterrupt(interrupt + PRIMARY_VECTOR_BASE, 0);
            } else {

                HalPrint(("Not disabling IRQ %08x since some other link is still programmed to it\n", interrupt));
            }

            PciirqmpSetIrq((UCHAR)0, (UCHAR)LinkNode->Link);
        }
    }
#if defined(NEC_98)
    else if (!(LinkNode->PossibleAllocation->Interrupt))
    {
        //
        // Disable the link.
        //

        PciirqmpSetIrq((UCHAR)0, (UCHAR)LinkNode->Link);
    }
#endif

    //
    // Swap the possible with the allocation.
    //

    temp = LinkNode->Allocation;
    LinkNode->Allocation = LinkNode->PossibleAllocation;
    LinkNode->PossibleAllocation = temp;

    return (STATUS_SUCCESS);
}

VOID
HalpProgramInterruptLine(
    IN PPCI_IRQ_ROUTING_INFO PciIrqRoutingInfo,
    IN PDEVICE_OBJECT Pdo,
    IN ULONG Interrupt
    )

/*++

Routine Description:

    Calls the PCI interface to write the interrupt value to config space.

Input Parameters:

    PciIrqRoutingInfo - Pointer to IRQ routing info.
    
    Pdo - PCI PDO whose interrupt line needs to be written.   
    
    Interrupt - Interrupt value to be written.

Return Value:

    None.

--*/

{
    PAGED_CODE();

    //
    // We should never be here if Pci Irq routing is not enabled.
    //

    ASSERT(IsPciIrqRoutingEnabled());

    PciIrqRoutingInfo->PciInterface->UpdateInterruptLine(Pdo, (UCHAR)Interrupt);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halx86\i386\ixpcibrd.c ===
/*++


Copyright (c) 1989  Microsoft Corporation

Module Name:

    ixpcibrd.c

Abstract:

    Get PCI-PCI bridge information

Author:

    Ken Reneris (kenr) 14-June-1994

Environment:

    Kernel mode

Revision History:

--*/

#include "halp.h"
#include "pci.h"
#include "pcip.h"
#include "stdio.h"

// debugging only...
// #define INIT_PCI_BRIDGE 1

extern WCHAR rgzMultiFunctionAdapter[];
extern WCHAR rgzConfigurationData[];
extern WCHAR rgzIdentifier[];
extern WCHAR rgzReservedResources[];


#if DBG
#define DBGMSG(a)   DbgPrint(a)
#else
#define DBGMSG(a)
#endif



#define IsPciBridge(a)                                         \
            ((a)->VendorID != PCI_INVALID_VENDORID          && \
             PCI_CONFIG_TYPE(a) == PCI_BRIDGE_TYPE          && \
             (a)->BaseClass == PCI_CLASS_BRIDGE_DEV         && \
             (a)->SubClass  == PCI_SUBCLASS_BR_PCI_TO_PCI)

#define IsCardbusBridge(a)                                     \
            ((a)->VendorID != PCI_INVALID_VENDORID          && \
             PCI_CONFIG_TYPE(a) == PCI_CARDBUS_BRIDGE_TYPE  && \
             (a)->BaseClass == PCI_CLASS_BRIDGE_DEV         && \
             (a)->SubClass  == PCI_SUBCLASS_BR_CARDBUS)

typedef struct {
    ULONG               BusNo;
    PBUS_HANDLER        BusHandler;
    PPCIPBUSDATA        BusData;
    PCI_SLOT_NUMBER     SlotNumber;
    PPCI_COMMON_CONFIG  PciData;
    ULONG               IO, Memory, PFMemory;
    UCHAR               Buffer[PCI_COMMON_HDR_LENGTH];
} CONFIGBRIDGE, *PCONFIGBRIDGE;

//
// Internal prototypes
//


#ifdef INIT_PCI_BRIDGE
VOID
HalpGetPciBridgeNeeds (
    IN ULONG            HwType,
    IN PUCHAR           MaxPciBus,
    IN PCONFIGBRIDGE    Current
    );
#endif

VOID
HalpSetPciBridgedVgaCronk (
    IN ULONG BusNumber,
    IN ULONG Base,
    IN ULONG Limit
    );


ULONG
HalpGetBridgedPCIInterrupt (
    IN PBUS_HANDLER BusHandler,
    IN PBUS_HANDLER RootHandler,
    IN ULONG BusInterruptLevel,
    IN ULONG BusInterruptVector,
    OUT PKIRQL Irql,
    OUT PKAFFINITY Affinity
    );

ULONG
HalpGetBridgedPCIISAInt (
    IN PBUS_HANDLER BusHandler,
    IN PBUS_HANDLER RootHandler,
    IN ULONG BusInterruptLevel,
    IN ULONG BusInterruptVector,
    OUT PKIRQL Irql,
    OUT PKAFFINITY Affinity
    );

VOID
HalpPCIBridgedPin2Line (
    IN PBUS_HANDLER         BusHandler,
    IN PBUS_HANDLER         RootHandler,
    IN PCI_SLOT_NUMBER      SlotNumber,
    IN PPCI_COMMON_CONFIG   PciData
    );


VOID
HalpPCIBridgedLine2Pin (
    IN PBUS_HANDLER         BusHandler,
    IN PBUS_HANDLER         RootHandler,
    IN PCI_SLOT_NUMBER      SlotNumber,
    IN PPCI_COMMON_CONFIG   PciNewData,
    IN PPCI_COMMON_CONFIG   PciOldData
    );

NTSTATUS
HalpGetBridgedPCIIrqTable (
    IN PBUS_HANDLER     BusHandler,
    IN PBUS_HANDLER     RootHandler,
    IN PCI_SLOT_NUMBER  PciSlot,
    OUT PUCHAR          IrqTable
    );




#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT,HalpGetPciBridgeConfig)
#pragma alloc_text(INIT,HalpSetPciBridgedVgaCronk)
#pragma alloc_text(INIT,HalpFixupPciSupportedRanges)

#ifdef INIT_PCI_BRIDGE
#pragma alloc_text(PAGE,HalpGetBridgedPCIInterrupt)
//#pragma alloc_text(PAGE,HalpGetBridgedPCIIrqTable)
#pragma alloc_text(INIT,HalpGetPciBridgeNeeds)
#endif
#endif

VOID
HalpCardBusPin2Line(
    IN PBUS_HANDLER         BusHandler,
    IN PBUS_HANDLER         RootHandler,
    IN PCI_SLOT_NUMBER      SlotNumber,
    IN PPCI_COMMON_CONFIG   PciData
    )

/*++

Routine Description:

    Devices on CardBus busses use the interrupt assigned to the bridge.
    That's how it works.

Arguments:

    BusHandler      Bus Handler for the bus this (cardbus) device.  That
                    is, the bus handler which was created for the bridge
                    under which this device resides.
    RootHandler     Pointer to the bus handler for the root.
    SlotNumber      Slot number for the cardbus device (typically 0).
    PciData         PCI Config space common header (64 bytes).

Return Value:

    None.

--*/

{
    PPCIPBUSDATA        ChildBusData;
    ULONG               Length;
    UCHAR               ParentInterruptLine;

    //
    // If this device doesn't use interrupts, do nothing.
    //

    if (!PciData->u.type0.InterruptPin) {
        return;
    }

    ChildBusData  = (PPCIPBUSDATA)BusHandler->BusData;

    //
    // Read the interrupt information from the parent, ie the 
    // cardbus bridge's config space.
    //
    // Note: We use HalGetBusData because it will do the Pin2Line
    // function in the parent for us.

    Length = HalGetBusDataByOffset(
                 PCIConfiguration,
                 ChildBusData->ParentBus,
                 ChildBusData->CommonData.ParentSlot.u.AsULONG,
                 &ParentInterruptLine,
                 FIELD_OFFSET(PCI_COMMON_CONFIG, u.type2.InterruptLine),
                 sizeof(ParentInterruptLine)
                 );

    //
    // Return the parent's interrupt line value.
    //

    PciData->u.type0.InterruptLine = ParentInterruptLine;
}
   
VOID
HalpPciMakeBusAChild(
    IN PBUS_HANDLER Child,
    IN PBUS_HANDLER Parent
    )

/*++

Routine Description:

    Make bus 'Child' a child of bus 'Parent'.   This routine is used
    when the child bus is disabled or not really present.   The child
    bus consumes no resources.

Arguments:

    Child       The bus which is to become a child.
    Parent      The bus Child is a child of.

Return Value:

    None.

--*/

{
    HalpSetBusHandlerParent(Child, Parent);
    ((PPCIPBUSDATA)(Child->BusData))->ParentBus = (UCHAR)Parent->BusNumber;

    //
    // Give the bus an empty range list so it isn't
    // consumed from the parent.
    //

    HalpFreeRangeList(Child->BusAddresses);
    Child->BusAddresses = HalpAllocateNewRangeList();
}

BOOLEAN
HalpGetPciBridgeConfig (
    IN ULONG            HwType,
    IN PUCHAR           MaxPciBus
    )
/*++

Routine Description:

    Scan the devices on all known pci buses trying to locate any
    pci to pci bridges.  Record the hierarchy for the buses, and
    which buses have what addressing limits.

Arguments:

    HwType      - Configuration type.
    MaxPciBus   - # of PCI buses reported by the bios

--*/
{
    PBUS_HANDLER        ChildBus;
    PBUS_HANDLER        LastKnownRoot;
    PPCIPBUSDATA        ChildBusData;
    ULONG               d, f, i, j, BusNo;
    ULONG               ChildBusNo, ChildSubNo, ChildPrimaryBusNo;
    ULONG               FixupBusNo;
    UCHAR               Rescan, TestLimit1, TestLimit2;
    BOOLEAN             FoundDisabledBridge;
    BOOLEAN             FoundSomeFunction;
    CONFIGBRIDGE        CB;

    Rescan = 0;
    FoundDisabledBridge = FALSE;

    //
    // Find each bus on a bridge and initialize it's base and limit information
    //

    CB.PciData = (PPCI_COMMON_CONFIG) CB.Buffer;
    CB.SlotNumber.u.bits.Reserved = 0;
    for (BusNo=0; BusNo < *MaxPciBus; BusNo++) {

        CB.BusHandler = HalpHandlerForBus (PCIBus, BusNo);
        CB.BusData = (PPCIPBUSDATA) CB.BusHandler->BusData;
        FoundSomeFunction = FALSE;

        for (d = 0; d < PCI_MAX_DEVICES; d++) {
            CB.SlotNumber.u.bits.DeviceNumber = d;

            for (f = 0; f < PCI_MAX_FUNCTION; f++) {
                CB.SlotNumber.u.bits.FunctionNumber = f;

                //
                // Read PCI configuration information
                //

                HalpReadPCIConfig (
                    CB.BusHandler,
                    CB.SlotNumber,
                    CB.PciData,
                    0,
                    PCI_COMMON_HDR_LENGTH
                    );

                if (CB.PciData->VendorID == PCI_INVALID_VENDORID) {
                    // function not populated
                    continue;
                }

                FoundSomeFunction = TRUE;

                if (IsPciBridge(CB.PciData)) {

                    //
                    // PCI-PCI bridge
                    //

                    ChildBusNo = (ULONG)CB.PciData->u.type1.SecondaryBus;
                    ChildSubNo = (ULONG)CB.PciData->u.type1.SubordinateBus;
                    ChildPrimaryBusNo = (ULONG)CB.PciData->u.type1.PrimaryBus;

                } else if (IsCardbusBridge(CB.PciData)) {

                    //
                    // PCI-Cardbus bridge
                    //

                    ChildBusNo = (ULONG)CB.PciData->u.type2.SecondaryBus;
                    ChildSubNo = (ULONG)CB.PciData->u.type2.SubordinateBus;
                    ChildPrimaryBusNo = (ULONG)CB.PciData->u.type2.PrimaryBus;

                } else {

                    //
                    // Not a known bridge type, next function.
                    //

                    continue;
                }

                //
                // Whenever we find a bridge, mark all all bus nodes that
                // have not already been processed between this bus and
                // the new child as children of this bus.
                //
                // eg if, on bus 0, we find a bridge to bus 6 thru 8, mark
                // busses 1 thru 8 as a child of 0.  (unless they have
                // already been processed).
                //
                // This stops non-existant busses in the gap between the
                // primary bus and the first child bus from looking like
                // additional root busses.
                //

                for (FixupBusNo = CB.BusHandler->BusNumber + 1;
                     FixupBusNo <= ChildSubNo;
                     FixupBusNo++) {

                    ChildBus = HalpHandlerForBus(PCIBus, FixupBusNo);

                    if (ChildBus == NULL) {
                        continue;
                    }
    
                    ChildBusData = (PPCIPBUSDATA) ChildBus->BusData;

                    if (ChildBusData->BridgeConfigRead) {

                        //
                        // This child bus's relationships already processed
                        //

                        continue;
                    }
    
                    HalpPciMakeBusAChild(ChildBus, CB.BusHandler);
                    ChildBusData->CommonData.ParentSlot = CB.SlotNumber;
                }

                if (!(CB.PciData->Command & 
                      (PCI_ENABLE_IO_SPACE | PCI_ENABLE_MEMORY_SPACE))) {
                    // this PCI bridge is not enabled - skip it for now
                    
                    FoundDisabledBridge = TRUE;

                    // Even though the bridge is disabled the bus number
                    // may have been set.  If so then update the parent
                    // child relation ship so that the we do not see this
                    // as a root bus.
                    
                    if (ChildBusNo <= CB.BusHandler->BusNumber) {
                        continue;
                    }

                    ChildBus = HalpHandlerForBus (PCIBus, ChildBusNo);
                    if (ChildBus == NULL) {

                        //
                        // Even though the bus is currently disabled,
                        // the system may configure it so we still 
                        // want a bus handler created for it.
                        //

                        if (ChildBusNo > Rescan) {
                            Rescan = (UCHAR)ChildBusNo;
                        }
                        continue;
                    }
    
                    ChildBusData = (PPCIPBUSDATA) ChildBus->BusData;
                    if (ChildBusData->BridgeConfigRead) {
                        // this child buses relationships already processed
                        continue;
                    }
    
                    HalpPciMakeBusAChild(ChildBus, CB.BusHandler);
                    ChildBusData->CommonData.ParentSlot = CB.SlotNumber;

                    //
                    // Even though we won't actually configure the
                    // bridge, mark the configuration as read so we 
                    // don't mistake it for a root bus.
                    //

                    ChildBusData->BridgeConfigRead = TRUE;
                    continue;
                }

                if (ChildPrimaryBusNo != CB.BusHandler->BusNumber) {

                    DBGMSG ("HAL GetPciData: bad primarybus!!!\n");
                    // skip it...
                    continue;
                }

                if (ChildBusNo <= CB.BusHandler->BusNumber) {

                    // secondary bus number doesn't make any sense.  HP Omnibook may
                    // not fill this field in on a virtually disabled pci-pci bridge

                    FoundDisabledBridge = TRUE;
                    continue;
                }

                //
                // Found a PCI-PCI bridge.  Determine it's parent child
                // releationships
                //

                ChildBus = HalpHandlerForBus (PCIBus, ChildBusNo);
                if (!ChildBus) {
                    DBGMSG ("HAL GetPciData: found configured pci bridge\n");

                    // up the number of buses
                    if (ChildBusNo > Rescan) {
                        Rescan = (UCHAR)ChildBusNo;
                    }
                    continue;
                }

                ChildBusData = (PPCIPBUSDATA) ChildBus->BusData;
                if (ChildBusData->BridgeConfigRead) {
                    // this child buses releationships already processed
                    continue;
                }

                //
                // Remember the limits which are programmed into this bridge
                //

                ChildBusData->BridgeConfigRead = TRUE;
                HalpSetBusHandlerParent (ChildBus, CB.BusHandler);
                ChildBusData->ParentBus = (UCHAR) CB.BusHandler->BusNumber;
                ChildBusData->CommonData.ParentSlot = CB.SlotNumber;

                if (IsCardbusBridge(CB.PciData)) {

                    //
                    // Cardbus handled by the PCI driver, don't try to
                    // interpret here.
                    //

                    HalpFreeRangeList(ChildBus->BusAddresses);
                    ChildBus->BusAddresses = HalpAllocateNewRangeList();

                    //
                    // Pin to Line (and vis-versa) for a device plugged
                    // into the cardbus bus, get the same values as the
                    // bridge itself.  Override the line2pin routine in
                    // the cardbus bridge handler to use the parent's
                    // slot value.   Note:  line2pin doesn't do much.
                    // In DBG PC/AT builds, it simply undoes the IRQXOR
                    // used to catch drivers that are accessing the h/w
                    // directly.   The normal routine will do this just
                    // fine so we don't need to override it as well.
                    //

                    ChildBusData->CommonData.Pin2Line = HalpCardBusPin2Line;
                    continue;
                }

                ChildBus->BusAddresses->IO.Base =
                            PciBridgeIO2Base(
                                CB.PciData->u.type1.IOBase,
                                CB.PciData->u.type1.IOBaseUpper16
                                );

                ChildBus->BusAddresses->IO.Limit =
                            PciBridgeIO2Limit(
                                CB.PciData->u.type1.IOLimit,
                                CB.PciData->u.type1.IOLimitUpper16
                                );

                ChildBus->BusAddresses->IO.SystemAddressSpace = 1;

                //
                // Special VGA address remapping occuring on this bridge?
                //

                if (CB.PciData->u.type1.BridgeControl & PCI_ENABLE_BRIDGE_VGA) {

                    //
                    // Yes, then this bridge is positively decoding the
                    // range 0xA0000 thru 0xBFFFF regardless of the memory
                    // range settings.  Add this range, if it overlaps it
                    // will get cleaned up later.
                    //
                    // Also, IO ranges 3b0 thru 3bb and 3c0 thru 3df.
                    //

                    HalpAddRange(
                        &ChildBus->BusAddresses->Memory,
                        0,              // address space
                        0,              // system base
                        0xa0000,        // range base
                        0xbffff         // range limit
                        );

                    HalpAddRange(
                        &ChildBus->BusAddresses->IO,
                        1,              // address space
                        0,              // system base
                        0x3b0,          // range base
                        0x3bb           // range limit
                        );

                    HalpAddRange(
                        &ChildBus->BusAddresses->IO,
                        1,              // address space
                        0,              // system base
                        0x3c0,          // range base
                        0x3df           // range limit
                        );

                    //
                    // Claim all aliases to these IO addresses.
                    // 
                    // Bits 15:10 are not decoded so anything in
                    // the same 10 bits as the above in the range
                    // 0x400 thru 0xffff is an alias.
                    //

                    HalpSetPciBridgedVgaCronk (
                        ChildBus->BusNumber,
                        0x0400,
                        0xffff
                        );
                }

                //
                // If supported I/O ranges on this bus are limitied to
                // 256bytes on every 1K aligned boundry within the
                // range, then redo supported IO BusAddresses to match
                //

                if (CB.PciData->u.type1.BridgeControl & PCI_ENABLE_BRIDGE_ISA  &&
                    ChildBus->BusAddresses->IO.Base < ChildBus->BusAddresses->IO.Limit) {

                    // assume Base is 1K aligned
                    i = (ULONG) ChildBus->BusAddresses->IO.Base;
                    j = (ULONG) ChildBus->BusAddresses->IO.Limit;

                    // convert head entry
                    ChildBus->BusAddresses->IO.Limit = i + 255;
                    i += 1024;

                    // add remaining ranges
                    while (i < j) {
                        HalpAddRange (
                            &ChildBus->BusAddresses->IO,
                            1,          // address space
                            0,          // system base
                            i,          // bus address
                            i + 255     // bus limit
                            );

                        // next range
                        i += 1024;
                    }
                }

                ChildBus->BusAddresses->Memory.Base =
                        PciBridgeMemory2Base(CB.PciData->u.type1.MemoryBase);

                ChildBus->BusAddresses->Memory.Limit =
                        PciBridgeMemory2Limit(CB.PciData->u.type1.MemoryLimit);

                // On x86 it's ok to clip Prefetch to 32 bits

                if (CB.PciData->u.type1.PrefetchBaseUpper32 == 0) {
                    ChildBus->BusAddresses->PrefetchMemory.Base =
                            PciBridgeMemory2Base(CB.PciData->u.type1.PrefetchBase);


                    ChildBus->BusAddresses->PrefetchMemory.Limit =
                            PciBridgeMemory2Limit(CB.PciData->u.type1.PrefetchLimit);

                    if (CB.PciData->u.type1.PrefetchLimitUpper32) {
                        ChildBus->BusAddresses->PrefetchMemory.Limit = 0xffffffff;
                    }
                }

                //
                // h/w hack the Win9x people allowed folks to make.  Determine
                // if the bridge is subtractive decode or not by seeing if
                // it's IObase/limit is read-only.
                //

                TestLimit1 = CB.PciData->u.type1.IOLimit + 1;
                if (!TestLimit1) {
                    TestLimit1 = 0xFE;
                }
#if 0
                DbgPrint ("PciBridge OrigLimit=%d TestLimit=%d ",
                    CB.PciData->u.type1.IOLimit,
                    TestLimit1
                    );
#endif

                HalpWritePCIConfig (
                    CB.BusHandler,
                    CB.SlotNumber,
                    &TestLimit1,
                    FIELD_OFFSET (PCI_COMMON_CONFIG, u.type1.IOLimit),
                    1
                    );

                HalpReadPCIConfig (
                    CB.BusHandler,
                    CB.SlotNumber,
                    &TestLimit2,
                    FIELD_OFFSET (PCI_COMMON_CONFIG, u.type1.IOLimit),
                    1
                    );

                HalpWritePCIConfig (
                    CB.BusHandler,
                    CB.SlotNumber,
                    &CB.PciData->u.type1.IOLimit,
                    FIELD_OFFSET (PCI_COMMON_CONFIG, u.type1.IOLimit),
                    1
                    );

                ChildBusData->Subtractive = TestLimit1 != TestLimit2;
#if 0
                DbgPrint ("Result=%d, Subtractive=%d\n",
                    TestLimit2,
                    ChildBusData->Subtractive
                    );

                DbgPrint ("Device buffer %x\n", CB.PciData);
#endif

                //
                // Now if its substractive,  assume no range means the entire
                // range.
                //

                if (ChildBusData->Subtractive) {

                    if (ChildBus->BusAddresses->IO.Base == PciBridgeIO2Base(0,0) &&
                        ChildBus->BusAddresses->IO.Limit <= PciBridgeIO2Limit(0,0)) {

                        ChildBus->BusAddresses->IO.Limit = 0x7FFFFFFFFFFFFFFF;

                        if (ChildBus->BusAddresses->Memory.Base == PciBridgeMemory2Base(0)) {
                            ChildBus->BusAddresses->Memory.Limit = 0x7FFFFFFFFFFFFFFF;
                        }
                    }
                }

                // should call HalpAssignPCISlotResources to assign
                // baseaddresses, etc...
            }
        }
        if (!((PPCIPBUSDATA)(CB.BusHandler->BusData))->BridgeConfigRead) {

            //
            // We believe this bus to be a root.
            //

            if ((FoundSomeFunction == FALSE) && (BusNo != 0)) {

                //
                // Nothing found on this bus. Assume it's not really
                // a root.   (Always assume 0 is a root).  (This bus
                // probably doesn't exist at all but ntdetect doesn't
                // tell us that).
                //
                // Pretend this bus is a child of the last known root.
                // At least this way it won't get a PDO and be handed
                // to the PCI driver.
                //

                HalpPciMakeBusAChild(CB.BusHandler, LastKnownRoot);

            } else {

                //
                // Found something on it (or it's zero), set as last
                // known root.
                //

                LastKnownRoot = CB.BusHandler;
            }
        }
    }

    if (Rescan) {
        *MaxPciBus = Rescan+1;
        return TRUE;
    }

    if (!FoundDisabledBridge) {
        return FALSE;
    }

    DBGMSG ("HAL GetPciData: found disabled pci bridge\n");

#ifdef INIT_PCI_BRIDGE
    //
    //  We've calculated all the parent's buses known bases & limits.
    //  While doing this a pci-pci bus was found that the bios didn't
    //  configure.  This is not expected, and we'll make some guesses
    //  at a configuration here and enable it.
    //
    //  (this code is primarily for testing the above code since
    //   currently no system bioses actually configure the child buses)
    //

    for (BusNo=0; BusNo < *MaxPciBus; BusNo++) {

        CB.BusHandler = HalpHandlerForBus (PCIBus, BusNo);
        CB.BusData = (PPCIPBUSDATA) CB.BusHandler->BusData;

        for (d = 0; d < PCI_MAX_DEVICES; d++) {
            CB.SlotNumber.u.bits.DeviceNumber = d;

            for (f = 0; f < PCI_MAX_FUNCTION; f++) {
                CB.SlotNumber.u.bits.FunctionNumber = f;

                HalpReadPCIConfig (
                    CB.BusHandler,
                    CB.SlotNumber,
                    CB.PciData,
                    0,
                    PCI_COMMON_HDR_LENGTH
                    );

                if (CB.PciData->VendorID == PCI_INVALID_VENDORID) {
                    continue;
                }

                if (!IsPciBridge (CB.PciData)) {
                    // not a PCI-PCI bridge
                    continue;
                }

                if ((CB.PciData->Command & 
                      (PCI_ENABLE_IO_SPACE | PCI_ENABLE_MEMORY_SPACE))) {
                    // this PCI bridge is enabled
                    continue;
                }

                //
                // We have a disabled bus - assign it a number, then
                // determine all the requirements of all devices
                // on the other side of this bridge
                //

                CB.BusNo = BusNo;
                HalpGetPciBridgeNeeds (HwType, MaxPciBus, &CB);
            }
        }
    }
    // preform Rescan
    return TRUE;

#else

    return FALSE;

#endif

}

VOID
HalpFixupPciSupportedRanges (
    IN ULONG MaxBuses
    )
/*++

Routine Description:

    PCI-PCI bridged buses only see addresses which their parent
    bueses support.   So adjust any PCI SUPPORT_RANGES to be
    a complete subset of all of it's parent buses.

    For PCI-PCI briges which use postive address decode to forward
    addresses, remove any addresses from any PCI bus which are bridged
    to a child PCI bus.

--*/
{
    ULONG               i;
    PBUS_HANDLER        Bus, ParentBus;
    PPCIPBUSDATA        BusData;
    PSUPPORTED_RANGES   HRanges;

    //
    // Pass 1 - shrink all PCI supported ranges to be a subset of
    // all of it's parent buses
    //

    for (i = 0; i < MaxBuses; i++) {

        Bus = HalpHandlerForBus (PCIBus, i);

        ParentBus = Bus->ParentHandler;
        while (ParentBus) {

            HRanges = Bus->BusAddresses;
            Bus->BusAddresses = HalpMergeRanges (
                                  ParentBus->BusAddresses,
                                  HRanges
                                  );

            HalpFreeRangeList (HRanges);
            ParentBus = ParentBus->ParentHandler;
        }
    }

    //
    // Pass 2 - remove all positive child PCI bus ranges from parent PCI buses
    //

    for (i = 0; i < MaxBuses; i++) {
        Bus = HalpHandlerForBus (PCIBus, i);
        BusData = (PPCIPBUSDATA) Bus->BusData;

        //
        // If the bridge is not subtractive, remove the ranges from the parents
        //

        if (!BusData->Subtractive) {

            ParentBus = Bus->ParentHandler;
            while (ParentBus) {

                if (ParentBus->InterfaceType == PCIBus) {
                    HalpRemoveRanges (
                          ParentBus->BusAddresses,
                          Bus->BusAddresses
                    );
                }

                ParentBus = ParentBus->ParentHandler;
            }
        }
    }

    //
    // Cleanup
    //

    for (i = 0; i < MaxBuses; i++) {
        Bus = HalpHandlerForBus (PCIBus, i);
        HalpConsolidateRanges (Bus->BusAddresses);
    }
}



VOID
HalpSetPciBridgedVgaCronk (
    IN ULONG BusNumber,
    IN ULONG BaseAddress,
    IN ULONG LimitAddress
    )
/*++

Routine Description:                                                           .

    The 'vga compatible addresses' bit is set in the bridge control regiter.
    This causes the bridge to pass any I/O address in the range of: 10bit
    decode 3b0-3bb & 3c0-3df, as TEN bit addresses.

    As far as I can tell this "feature" is an attempt to solve some problem
    which the folks solving it did not fully understand, so instead of doing
    it right we have this fine mess.

    The solution is to take the least of all evils which is to remove any
    I/O port ranges which are getting remapped from any IoAssignResource
    request.  (ie, IoAssignResources will never contimplate giving any
    I/O port out in the suspected ranges).

    note: memory allocation error here is fatal so don't bother with the
    return codes.

Arguments:

    Base    - Base of IO address range in question
    Limit   - Limit of IO address range in question

--*/
{
    UNICODE_STRING                      unicodeString;
    OBJECT_ATTRIBUTES                   objectAttributes;
    HANDLE                              handle;
    ULONG                               Length;
    PCM_RESOURCE_LIST                   ResourceList;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR     Descriptor;
    ULONG                               AddressMSBs;
    WCHAR                               ValueName[80];
    NTSTATUS                            status;

    //
    // Open reserved resource settings
    //

    RtlInitUnicodeString (&unicodeString, rgzReservedResources);
    InitializeObjectAttributes( &objectAttributes,
                                &unicodeString,
                                OBJ_CASE_INSENSITIVE,
                                NULL,
                                (PSECURITY_DESCRIPTOR) NULL
                                );

    status = ZwOpenKey( &handle, KEY_READ|KEY_WRITE, &objectAttributes);
    if (!NT_SUCCESS(status)) {
        return;
    }

    //
    // Build resource list of reseved ranges
    //

    Length = ((LimitAddress - BaseAddress) / 1024 + 2) * 2 *
                sizeof (CM_PARTIAL_RESOURCE_DESCRIPTOR) +
                sizeof (CM_RESOURCE_LIST);

    ResourceList = (PCM_RESOURCE_LIST)ExAllocatePoolWithTag(PagedPool,
                                                            Length,
                                                            HAL_POOL_TAG);
    if (!ResourceList) {

        //
        // Can't possibly be out of paged pool at this stage of the
        // game.  This system is very unwell, get out.
        //

        return;
    }
    RtlZeroMemory(ResourceList, Length);

    ResourceList->Count = 1;
    ResourceList->List[0].InterfaceType = PCIBus;
    ResourceList->List[0].BusNumber     = BusNumber;
    Descriptor = ResourceList->List[0].PartialResourceList.PartialDescriptors;

    while (BaseAddress < LimitAddress) {
        AddressMSBs = BaseAddress & ~0x3ff;     // get upper 10bits of addr

        //
        // Add xx3b0 through xx3bb
        //

        Descriptor->Type                  = CmResourceTypePort;
        Descriptor->ShareDisposition      = CmResourceShareDeviceExclusive;
        Descriptor->Flags                 = CM_RESOURCE_PORT_IO;
        Descriptor->u.Port.Start.QuadPart = AddressMSBs | 0x3b0;
        Descriptor->u.Port.Length         = 0xb;

        Descriptor += 1;
        ResourceList->List[0].PartialResourceList.Count += 1;

        //
        // Add xx3c0 through xx3df
        //

        Descriptor->Type                  = CmResourceTypePort;
        Descriptor->ShareDisposition      = CmResourceShareDeviceExclusive;
        Descriptor->Flags                 = CM_RESOURCE_PORT_IO;
        Descriptor->u.Port.Start.QuadPart = AddressMSBs | 0x3c0;
        Descriptor->u.Port.Length         = 0x1f;

        Descriptor += 1;
        ResourceList->List[0].PartialResourceList.Count += 1;

        //
        // Next range
        //

        BaseAddress += 1024;
    }

    //
    // Add the reserved ranges to avoid during IoAssignResource
    //

    swprintf(ValueName, L"HAL_PCI_%d", BusNumber);
    RtlInitUnicodeString(&unicodeString, ValueName);

    ZwSetValueKey(handle,
                  &unicodeString,
                  0L,
                  REG_RESOURCE_LIST,
                  ResourceList,
                  (ULONG) Descriptor - (ULONG) ResourceList
                  );


    ExFreePool(ResourceList);
    ZwClose(handle);
}



#ifdef INIT_PCI_BRIDGE

VOID
HalpGetPciBridgeNeeds (
    IN ULONG            HwType,
    IN PUCHAR           MaxPciBus,
    IN PCONFIGBRIDGE    Current
    )
{
    ACCESS_MASK                     DesiredAccess;
    UNICODE_STRING                  unicodeString;
    PUCHAR                          buffer;
    HANDLE                          handle;
    OBJECT_ATTRIBUTES               objectAttributes;
    PCM_FULL_RESOURCE_DESCRIPTOR    Descriptor;
    PCONFIGURATION_COMPONENT        Component;
    CONFIGBRIDGE                    CB;
    ULONG                           mnum, d, f, i;
    NTSTATUS                        status;

    buffer = ExAllocatePoolWithTag(PagedPool, 1024, HAL_POOL_TAG);

    if (!buffer) {

        //
        // Give up, we're not going anywhere anyway.
        //

        return;
    }

    //
    // Init CB structure
    //

    CB.PciData = (PPCI_COMMON_CONFIG) CB.Buffer;
    CB.SlotNumber.u.bits.Reserved = 0;
    Current->IO = Current->Memory = Current->PFMemory = 0;

    //
    // Assign this bridge an ID, and turn on configuration space
    //

    Current->PciData->u.type1.PrimaryBus = (UCHAR) Current->BusNo;
    Current->PciData->u.type1.SecondaryBus = (UCHAR) *MaxPciBus;
    Current->PciData->u.type1.SubordinateBus = (UCHAR) 0xFF;
    Current->PciData->u.type1.SecondaryStatus = 0xffff;
    Current->PciData->Status  = 0xffff;
    Current->PciData->Command = 0;

    Current->PciData->u.type1.BridgeControl = PCI_ASSERT_BRIDGE_RESET;

    HalpWritePCIConfig (
        Current->BusHandler,
        Current->SlotNumber,
        Current->PciData,
        0,
        PCI_COMMON_HDR_LENGTH
        );

    KeStallExecutionProcessor (100);

    Current->PciData->u.type1.BridgeControl = 0;
    HalpWritePCIConfig (
        Current->BusHandler,
        Current->SlotNumber,
        Current->PciData,
        0,
        PCI_COMMON_HDR_LENGTH
        );


    KeStallExecutionProcessor (100);

    //
    // Allocate new handler for bus
    //

    CB.BusHandler = HalpAllocateAndInitPciBusHandler (HwType, *MaxPciBus, FALSE);
    CB.BusData = (PPCIPBUSDATA) CB.BusHandler->BusData;
    CB.BusNo = *MaxPciBus;
    *MaxPciBus += 1;

    //
    // Add another PCI bus in the registry
    //

    mnum = 0;
    for (; ;) {
        //
        // Find next available MultiFunctionAdapter key
        //

        DesiredAccess = KEY_READ | KEY_WRITE;
        swprintf ((PWCHAR) buffer, L"%s\\%d", rgzMultiFunctionAdapter, mnum);
        RtlInitUnicodeString (&unicodeString, (PWCHAR) buffer);

        InitializeObjectAttributes( &objectAttributes,
                                    &unicodeString,
                                    OBJ_CASE_INSENSITIVE,
                                    NULL,
                                    (PSECURITY_DESCRIPTOR) NULL
                                    );

        status = ZwOpenKey( &handle, DesiredAccess, &objectAttributes);
        if (!NT_SUCCESS(status)) {
            break;
        }

        // already exists, next
        ZwClose (handle);
        mnum += 1;
    }

    ZwCreateKey (&handle,
                   DesiredAccess,
                   &objectAttributes,
                   0,
                   NULL,
                   REG_OPTION_VOLATILE,
                   &d
                );

    //
    // Add needed registry values for this MultifucntionAdapter entry
    //

    RtlInitUnicodeString (&unicodeString, rgzIdentifier);
    ZwSetValueKey (handle,
                   &unicodeString,
                   0L,
                   REG_SZ,
                   L"PCI",
                   sizeof (L"PCI")
                   );

    RtlInitUnicodeString (&unicodeString, rgzConfigurationData);
    Descriptor = (PCM_FULL_RESOURCE_DESCRIPTOR) buffer;
    Descriptor->InterfaceType = PCIBus;
    Descriptor->BusNumber = CB.BusNo;
    Descriptor->PartialResourceList.Version = 0;
    Descriptor->PartialResourceList.Revision = 0;
    Descriptor->PartialResourceList.Count = 0;
    ZwSetValueKey (handle,
                   &unicodeString,
                   0L,
                   REG_FULL_RESOURCE_DESCRIPTOR,
                   Descriptor,
                   sizeof (*Descriptor)
                   );


    RtlInitUnicodeString (&unicodeString, L"Component Information");
    Component = (PCONFIGURATION_COMPONENT) buffer;
    RtlZeroMemory (Component, sizeof (*Component));
    Component->AffinityMask = 0xffffffff;
    ZwSetValueKey (handle,
                   &unicodeString,
                   0L,
                   REG_BINARY,
                   Component,
                   FIELD_OFFSET (CONFIGURATION_COMPONENT, ConfigurationDataLength)
                   );

    ZwClose (handle);


    //
    // Since the BIOS didn't configure this bridge we'll assume that
    // the PCI interrupts are bridged.  (for BIOS configured buses we
    // assume that the BIOS put the ISA bus IRQ in the InterruptLine value)
    //

    CB.BusData->Pin2Line = (PciPin2Line) HalpPCIBridgedPin2Line;
    CB.BusData->Line2Pin = (PciLine2Pin) HalpPCIBridgedLine2Pin;
    //CB.BusData->GetIrqTable = (PciIrqTable) HalpGetBridgedPCIIrqTable;

    if (Current->BusHandler->GetInterruptVector == HalpGetPCIIntOnISABus) {

        //
        // The parent bus'es interrupt pin to vector mappings is not
        // a static function, and is determined by the boot firmware.
        //

        //CB.BusHandler->GetInterruptVector = (PGETINTERRUPTVECTOR) HalpGetBridgedPCIISAInt;

        // read each device on parent bus
        for (d = 0; d < PCI_MAX_DEVICES; d++) {
            CB.SlotNumber.u.bits.DeviceNumber = d;

            for (f = 0; f < PCI_MAX_FUNCTION; f++) {
                CB.SlotNumber.u.bits.FunctionNumber = f;

                HalpReadPCIConfig (
                    Current->BusHandler,
                    CB.SlotNumber,
                    CB.PciData,
                    0,
                    PCI_COMMON_HDR_LENGTH
                    );

                if (CB.PciData->VendorID == PCI_INVALID_VENDORID) {
                    continue;
                }

                if (CB.PciData->u.type0.InterruptPin  &&
                    (PCI_CONFIG_TYPE (CB.PciData) == PCI_DEVICE_TYPE  ||
                     PCI_CONFIG_TYPE (CB.PciData) == PCI_BRIDGE_TYPE)) {

                    // get bios supplied int mapping
                    i = CB.PciData->u.type0.InterruptPin + d % 4;
                    CB.BusData->SwizzleIn[i] = CB.PciData->u.type0.InterruptLine;
                }
            }
        }

    } else {
        _asm int 3;
    }

    //
    // Look at each device on the bus and determine it's resource needs
    //

    for (d = 0; d < PCI_MAX_DEVICES; d++) {
        CB.SlotNumber.u.bits.DeviceNumber = d;

        for (f = 0; f < PCI_MAX_FUNCTION; f++) {
            CB.SlotNumber.u.bits.FunctionNumber = f;

            HalpReadPCIConfig (
                CB.BusHandler,
                CB.SlotNumber,
                CB.PciData,
                0,
                PCI_COMMON_HDR_LENGTH
                );

            if (CB.PciData->VendorID == PCI_INVALID_VENDORID) {
                continue;
            }

            if (IsPciBridge (CB.PciData)) {
                // oh look - another bridge ...
                HalpGetPciBridgeNeeds (HwType, MaxPciBus, &CB);
                continue;
            }

            if (PCI_CONFIG_TYPE (CB.PciData) != PCI_DEVICE_TYPE) {
                continue;
            }

            // found a device - figure out the resources it needs
        }
    }

    //
    // Found all sub-buses set SubordinateBus accordingly
    //

    Current->PciData->u.type1.SubordinateBus = (UCHAR) *MaxPciBus - 1;

    HalpWritePCIConfig (
        Current->BusHandler,
        Current->SlotNumber,
        Current->PciData,
        0,
        PCI_COMMON_HDR_LENGTH
        );


    //
    // Set the bridges IO, Memory, and Prefetch Memory windows
    //

    // For now just pick some numbers & set everyone the same
    //  IO      0x6000 - 0xFFFF
    //  MEM     0x40000000 - 0x4FFFFFFF
    //  PFMEM   0x50000000 - 0x5FFFFFFF

    Current->PciData->u.type1.IOBase       = 0x6000     >> 12 << 4;
    Current->PciData->u.type1.IOLimit      = 0xffff     >> 12 << 4;
    Current->PciData->u.type1.MemoryBase   = 0x40000000 >> 20 << 4;
    Current->PciData->u.type1.MemoryLimit  = 0x4fffffff >> 20 << 4;
    Current->PciData->u.type1.PrefetchBase  = 0x50000000 >> 20 << 4;
    Current->PciData->u.type1.PrefetchLimit = 0x5fffffff >> 20 << 4;

    Current->PciData->u.type1.PrefetchBaseUpper32    = 0;
    Current->PciData->u.type1.PrefetchLimitUpper32   = 0;
    Current->PciData->u.type1.IOBaseUpper16         = 0;
    Current->PciData->u.type1.IOLimitUpper16        = 0;
    Current->PciData->u.type1.BridgeControl         =
        PCI_ENABLE_BRIDGE_ISA;

    HalpWritePCIConfig (
        Current->BusHandler,
        Current->SlotNumber,
        Current->PciData,
        0,
        PCI_COMMON_HDR_LENGTH
        );

    HalpReadPCIConfig (
        Current->BusHandler,
        Current->SlotNumber,
        Current->PciData,
        0,
        PCI_COMMON_HDR_LENGTH
        );

    // enable memory & io decodes

    Current->PciData->Command =
        PCI_ENABLE_IO_SPACE | PCI_ENABLE_MEMORY_SPACE | PCI_ENABLE_BUS_MASTER;

    HalpWritePCIConfig (
        Current->BusHandler,
        Current->SlotNumber,
        &Current->PciData->Command,
        FIELD_OFFSET (PCI_COMMON_CONFIG, Command),
        sizeof (Current->PciData->Command)
        );

    ExFreePool (buffer);
}

VOID
HalpPCIBridgedPin2Line (
    IN PBUS_HANDLER         BusHandler,
    IN PBUS_HANDLER         RootHandler,
    IN PCI_SLOT_NUMBER      SlotNumber,
    IN PPCI_COMMON_CONFIG   PciData
    )
/*++

    This function maps the device's InterruptPin to an InterruptLine
    value.

    test function particular to dec pci-pci bridge card

--*/
{
    PPCIPBUSDATA    BusData;
    ULONG           i;

    if (!PciData->u.type0.InterruptPin) {
        return ;
    }

    BusData = (PPCIPBUSDATA) BusHandler->BusData;

    //
    // Convert slot Pin into Bus INTA-D.
    //

    i = (PciData->u.type0.InterruptPin +
          SlotNumber.u.bits.DeviceNumber - 1) % 4;

    PciData->u.type0.InterruptLine = BusData->SwizzleIn[i] ^ IRQXOR;
    PciData->u.type0.InterruptLine = 0x0b ^ IRQXOR;
}


VOID
HalpPCIBridgedLine2Pin (
    IN PBUS_HANDLER         BusHandler,
    IN PBUS_HANDLER         RootHandler,
    IN PCI_SLOT_NUMBER      SlotNumber,
    IN PPCI_COMMON_CONFIG   PciNewData,
    IN PPCI_COMMON_CONFIG   PciOldData
    )
/*++

    This functions maps the device's InterruptLine to it's
    device specific InterruptPin value.

    test function particular to dec pci-pci bridge card

--*/
{
    PPCIPBUSDATA    BusData;
    ULONG           i;

    if (!PciNewData->u.type0.InterruptPin) {
        return ;
    }

    BusData = (PPCIPBUSDATA) BusHandler->BusData;

    i = (PciNewData->u.type0.InterruptPin +
          SlotNumber.u.bits.DeviceNumber - 1) % 4;

    PciNewData->u.type0.InterruptLine = BusData->SwizzleIn[i] ^ IRQXOR;
    PciNewData->u.type0.InterruptLine = 0x0b ^ IRQXOR;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halx86\i386\ixpcibus.c ===
/*++


Copyright (c) 1989  Microsoft Corporation

Module Name:

    ixpcibus.c

Abstract:

    Get/Set bus data routines for the PCI bus

Author:

    Ken Reneris (kenr) 14-June-1994

Environment:

    Kernel mode

Revision History:


--*/

#include "halp.h"
#include "pci.h"
#include "pcip.h"

extern const WCHAR rgzMultiFunctionAdapter[];
extern const WCHAR rgzConfigurationData[];
extern const WCHAR rgzIdentifier[];
extern const WCHAR rgzPCIIdentifier[];
extern const WCHAR rgzPCICardList[];

//
// Globals
//

KSPIN_LOCK          HalpPCIConfigLock;

PCI_CONFIG_HANDLER  PCIConfigHandler;

#ifdef ALLOC_DATA_PRAGMA
#pragma const_seg("INITCONST")
#endif // ALLOC_DATA_PRAGMA
const PCI_CONFIG_HANDLER  PCIConfigHandlerType1 = {
    HalpPCISynchronizeType1,
    HalpPCIReleaseSynchronzationType1,
    {
        HalpPCIReadUlongType1,          // 0
        HalpPCIReadUcharType1,          // 1
        HalpPCIReadUshortType1          // 2
    },
    {
        HalpPCIWriteUlongType1,         // 0
        HalpPCIWriteUcharType1,         // 1
        HalpPCIWriteUshortType1         // 2
    }
};

const PCI_CONFIG_HANDLER  PCIConfigHandlerType2 = {
    HalpPCISynchronizeType2,
    HalpPCIReleaseSynchronzationType2,
    {
        HalpPCIReadUlongType2,          // 0
        HalpPCIReadUcharType2,          // 1
        HalpPCIReadUshortType2          // 2
    },
    {
        HalpPCIWriteUlongType2,         // 0
        HalpPCIWriteUcharType2,         // 1
        HalpPCIWriteUshortType2         // 2
    }
};
#ifdef ALLOC_DATA_PRAGMA
#pragma const_seg()
#endif // ALLOC_DATA_PRAGMA

const UCHAR PCIDeref[4][4] = { {0,1,2,2},{1,1,1,1},{2,1,2,2},{1,1,1,1} };

#define SIZEOF_PARTIAL_INFO_HEADER FIELD_OFFSET(KEY_VALUE_PARTIAL_INFORMATION, Data)

#if DBG

ULONG HalpPCIIllegalBusScannerDetected;
ULONG HalpPCIStopOnIllegalBusScannerDetected;

#endif

extern BOOLEAN HalpDoingCrashDump;

VOID
HalpPCIConfig (
    IN PBUS_HANDLER     BusHandler,
    IN PCI_SLOT_NUMBER  Slot,
    IN PUCHAR           Buffer,
    IN ULONG            Offset,
    IN ULONG            Length,
    IN FncConfigIO      *ConfigIO
    );

VOID
HalpGetNMICrashFlag (
    VOID
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT,HalpQueryPciRegistryInfo)
#pragma alloc_text(INIT,HalpIsRecognizedCard)
#pragma alloc_text(INIT,HalpIsValidPCIDevice)
#pragma alloc_text(INIT,HalpGetNMICrashFlag)
#pragma alloc_text(PAGE,HalpAssignPCISlotResources)
#pragma alloc_text(PAGE,HalIrqTranslateRequirementsPciBridge)
#pragma alloc_text(PAGE,HalIrqTranslateResourcesPciBridge)
#pragma alloc_text(PAGELK,HalpPCISynchronizeOrionB0)
#pragma alloc_text(PAGELK,HalpPCIReleaseSynchronzationOrionB0)
#endif


PPCI_REGISTRY_INFO_INTERNAL
HalpQueryPciRegistryInfo (
    VOID
    )
/*++

Routine Description:

    Reads information from the registry concerning PCI, including the number
    of buses and the hardware access mechanism.

Arguments:

    None.

Returns:

    Buffer that must be freed by the caller, NULL if insufficient memory exists
    to complete the request, or the information cannot be located.

--*/
{
    PPCI_REGISTRY_INFO_INTERNAL     PCIRegInfo = NULL;
    PPCI_REGISTRY_INFO              PCIRegInfoHeader = NULL;
    UNICODE_STRING                  unicodeString, ConfigName, IdentName;
    HANDLE                          hMFunc, hBus, hCardList;
    OBJECT_ATTRIBUTES               objectAttributes;
    NTSTATUS                        status;
    UCHAR                           buffer [sizeof(PPCI_REGISTRY_INFO) + 99];
    PWSTR                           p;
    WCHAR                           wstr[8];
    ULONG                           i, junk;
    ULONG                           cardListIndex, cardCount, cardMax;
    PKEY_VALUE_FULL_INFORMATION     ValueInfo;
    PCM_FULL_RESOURCE_DESCRIPTOR    Desc;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR PDesc;
    UCHAR                           partialInfo[SIZEOF_PARTIAL_INFO_HEADER +
                                                sizeof(PCI_CARD_DESCRIPTOR)];
    PKEY_VALUE_PARTIAL_INFORMATION  partialInfoHeader;
    KEY_FULL_INFORMATION            keyFullInfo;

    //
    // Search the hardware description looking for any reported
    // PCI bus.  The first ARC entry for a PCI bus will contain
    // the PCI_REGISTRY_INFO.

    RtlInitUnicodeString (&unicodeString, rgzMultiFunctionAdapter);
    InitializeObjectAttributes (
        &objectAttributes,
        &unicodeString,
        OBJ_CASE_INSENSITIVE,
        NULL,       // handle
        NULL);


    status = ZwOpenKey (&hMFunc, KEY_READ, &objectAttributes);
    if (!NT_SUCCESS(status)) {
        return NULL;
    }

    unicodeString.Buffer = wstr;
    unicodeString.MaximumLength = sizeof (wstr);

    RtlInitUnicodeString (&ConfigName, rgzConfigurationData);
    RtlInitUnicodeString (&IdentName,  rgzIdentifier);

    ValueInfo = (PKEY_VALUE_FULL_INFORMATION) buffer;

    for (i=0; TRUE; i++) {
        RtlIntegerToUnicodeString (i, 10, &unicodeString);
        InitializeObjectAttributes (
            &objectAttributes,
            &unicodeString,
            OBJ_CASE_INSENSITIVE,
            hMFunc,
            NULL);

        status = ZwOpenKey (&hBus, KEY_READ, &objectAttributes);
        if (!NT_SUCCESS(status)) {
            //
            // Out of Multifunction adapter entries...
            //

            ZwClose (hMFunc);
            return NULL;
        }

        //
        // Check the Identifier to see if this is a PCI entry
        //

        status = ZwQueryValueKey (
                    hBus,
                    &IdentName,
                    KeyValueFullInformation,
                    ValueInfo,
                    sizeof (buffer),
                    &junk
                    );

        if (!NT_SUCCESS (status)) {
            ZwClose (hBus);
            continue;
        }

        p = (PWSTR) ((PUCHAR) ValueInfo + ValueInfo->DataOffset);
        if (p[0] != L'P' || p[1] != L'C' || p[2] != L'I' || p[3] != 0) {
            ZwClose (hBus);
            continue;
        }

        //
        // The first PCI entry has the PCI_REGISTRY_INFO structure
        // attached to it.
        //

        status = ZwQueryValueKey (
                    hBus,
                    &ConfigName,
                    KeyValueFullInformation,
                    ValueInfo,
                    sizeof (buffer),
                    &junk
                    );

        ZwClose (hBus);
        if (!NT_SUCCESS(status)) {
            continue ;
        }

        Desc  = (PCM_FULL_RESOURCE_DESCRIPTOR) ((PUCHAR)
                      ValueInfo + ValueInfo->DataOffset);
        PDesc = (PCM_PARTIAL_RESOURCE_DESCRIPTOR) ((PUCHAR)
                      Desc->PartialResourceList.PartialDescriptors);

        if (PDesc->Type == CmResourceTypeDeviceSpecific) {

            // got it..
            PCIRegInfoHeader = (PPCI_REGISTRY_INFO) (PDesc+1);
            ZwClose (hMFunc);
            break;
        }
    }

    if (!PCIRegInfoHeader) {

        return NULL;
    }

    //
    // Retrieve the list of interesting cards.
    //

    RtlInitUnicodeString (&unicodeString, rgzPCICardList);
    InitializeObjectAttributes (
        &objectAttributes,
        &unicodeString,
        OBJ_CASE_INSENSITIVE,
        NULL,       // handle
        NULL
        );

    status = ZwOpenKey (&hCardList, KEY_READ, &objectAttributes);
    if (NT_SUCCESS(status)) {

        status = ZwQueryKey( hCardList,
                             KeyFullInformation,
                             &keyFullInfo,
                             sizeof(keyFullInfo),
                             &junk );

        if ( NT_SUCCESS(status) ) {

            cardMax = keyFullInfo.Values;

            PCIRegInfo = (PPCI_REGISTRY_INFO_INTERNAL) ExAllocatePoolWithTag(
                NonPagedPool,
                sizeof(PCI_REGISTRY_INFO_INTERNAL) +
                cardMax * sizeof(PCI_CARD_DESCRIPTOR),
                HAL_POOL_TAG
                );

            if (PCIRegInfo) {

                //
                // Now that we've allocated enough room, enumerate again.
                //
                partialInfoHeader = (PKEY_VALUE_PARTIAL_INFORMATION) partialInfo;

                for(cardListIndex = cardCount = 0;
                    cardListIndex < cardMax;
                    cardListIndex++) {

                    status = ZwEnumerateValueKey(
                        hCardList,
                        cardListIndex,
                        KeyValuePartialInformation,
                        partialInfo,
                        sizeof(partialInfo),
                        &junk
                        );

                    //
                    // Note that STATUS_NO_MORE_ENTRIES is a failure code
                    //
                    if (!NT_SUCCESS( status )) {
                        break;
                    }

                    if (partialInfoHeader->DataLength != sizeof(PCI_CARD_DESCRIPTOR)) {

                        continue;
                    }

                    RtlCopyMemory(
                        PCIRegInfo->CardList + cardCount,
                        partialInfoHeader->Data,
                        sizeof(PCI_CARD_DESCRIPTOR)
                        );

                    cardCount++;
                } // next cardListIndex
            }

        }
        ZwClose (hCardList);
    }

    if (!PCIRegInfo) {

        PCIRegInfo = (PPCI_REGISTRY_INFO_INTERNAL) ExAllocatePoolWithTag(
            NonPagedPool,
            sizeof(PCI_REGISTRY_INFO_INTERNAL),
            HAL_POOL_TAG
            );

        if (!PCIRegInfo) {

            return NULL;
        }

        cardCount = 0;
    }

    RtlCopyMemory(
        PCIRegInfo,
        PCIRegInfoHeader,
        sizeof(PCI_REGISTRY_INFO)
        );

    PCIRegInfo->ElementCount = cardCount;

    return PCIRegInfo;
}

BOOLEAN
HalpIsRecognizedCard(
    IN PPCI_REGISTRY_INFO_INTERNAL  PCIRegInfo,
    IN PPCI_COMMON_CONFIG           PciData,
    IN ULONG                        FeatureMask
    )
/*++

Routine Description:

    Walks the internal registry info list to find any cards matching the passed
    in "feature" mask.

Arguments:

    PCIRegInfo    - Pointer to reg info with the list of "notable" devices.
    PciData       - Config space (with subsystem info for cardbus bridges)
    FeatureMask   - PCIFT flags to try to match

Returns:

    Buffer that must be freed by the caller, NULL if insufficient memory exists
    to complete the request, or the information cannot be located.

--*/
{
    ULONG element;

    //
    // Detect if this has a h
    //
    for(element = 0; element < PCIRegInfo->ElementCount; element++) {

        if (FeatureMask & PCIRegInfo->CardList[element].Flags) {

            if (PCIRegInfo->CardList[element].VendorID != PciData->VendorID) {

                continue;
            }

            if (PCIRegInfo->CardList[element].DeviceID != PciData->DeviceID) {

                continue;
            }

            if (PCIRegInfo->CardList[element].Flags & PCICF_CHECK_REVISIONID) {

                if (PCIRegInfo->CardList[element].RevisionID != PciData->RevisionID) {

                    continue;
                }
            }

            switch(PCI_CONFIGURATION_TYPE(PciData)) {

                case PCI_DEVICE_TYPE:
                    if (PCIRegInfo->CardList[element].Flags & PCICF_CHECK_SSVID) {

                        if (PCIRegInfo->CardList[element].SubsystemVendorID != PciData->u.type0.SubVendorID) {

                            continue;
                        }
                    }

                    if (PCIRegInfo->CardList[element].Flags & PCICF_CHECK_SSID) {

                        if (PCIRegInfo->CardList[element].SubsystemID != PciData->u.type0.SubSystemID) {

                            continue;
                        }
                    }
                    break;

                case PCI_BRIDGE_TYPE:
                    break;

                case PCI_CARDBUS_BRIDGE_TYPE:
                    if (PCIRegInfo->CardList[element].Flags & PCICF_CHECK_SSVID) {

                        if (PCIRegInfo->CardList[element].SubsystemVendorID !=
                           ((TYPE2EXTRAS *)(PciData->DeviceSpecific))->SubVendorID) {

                            continue;
                        }
                    }

                    if (PCIRegInfo->CardList[element].Flags & PCICF_CHECK_SSID) {

                        if (PCIRegInfo->CardList[element].SubsystemID !=
                           ((TYPE2EXTRAS *)(PciData->DeviceSpecific))->SubSystemID) {

                            continue;
                        }
                    }
                    break;
            }

            //
            // We found the device matching one of the passed in feature bits.
            //
            return TRUE;
        }
    }

    return FALSE;
}

BOOLEAN
HalpIsValidPCIDevice (
    IN PBUS_HANDLER    BusHandler,
    IN PCI_SLOT_NUMBER Slot
    )
/*++

Routine Description:

    Reads the device configuration data for the given slot and
    returns TRUE if the configuration data appears to be valid for
    a PCI device; otherwise returns FALSE.

Arguments:

    BusHandler  - Bus to check
    Slot        - Slot to check

--*/

{
    PPCI_COMMON_CONFIG  PciData;
    UCHAR               iBuffer[PCI_COMMON_HDR_LENGTH];
    ULONG               i, j;


    PciData = (PPCI_COMMON_CONFIG) iBuffer;

    //
    // Read device common header
    //

    HalpReadPCIConfig (BusHandler, Slot, PciData, 0, PCI_COMMON_HDR_LENGTH);

    //
    // Valid device header?
    //

    if (PciData->VendorID == PCI_INVALID_VENDORID  ||
        PCI_CONFIG_TYPE (PciData) != PCI_DEVICE_TYPE) {

        return FALSE;
    }

    //
    // Check fields for reasonable values
    //

    if ((PciData->u.type0.InterruptPin && PciData->u.type0.InterruptPin > 4) ||
        (PciData->u.type0.InterruptLine & 0x70)) {
        return FALSE;
    }

    for (i=0; i < PCI_TYPE0_ADDRESSES; i++) {
        j = PciData->u.type0.BaseAddresses[i];

        if (j & PCI_ADDRESS_IO_SPACE) {
            if (j > 0xffff) {
                // IO port > 64k?
                return FALSE;
            }
        } else {
            if (j > 0xf  &&  j < 0x80000) {
                // Mem address < 0x8000h?
                return FALSE;
            }
        }

        if (Is64BitBaseAddress(j)) {
            i += 1;
        }
    }

    //
    // Guess it's a valid device..
    //

    return TRUE;
}

ULONG
HalpGetPCIData (
    IN PBUS_HANDLER BusHandler,
    IN PBUS_HANDLER RootHandler,
    IN PCI_SLOT_NUMBER Slot,
    IN PUCHAR Buffer,
    IN ULONG Offset,
    IN ULONG Length
    )
/*++

Routine Description:

    The function returns the Pci bus data for a device.

Arguments:

    BusNumber - Indicates which bus.

    VendorSpecificDevice - The VendorID (low Word) and DeviceID (High Word)

    Buffer - Supplies the space to store the data.

    Length - Supplies a count in bytes of the maximum amount to return.

Return Value:

    Returns the amount of data stored into the buffer.

    If this PCI slot has never been set, then the configuration information
    returned is zeroed.


--*/
{
    PPCI_COMMON_CONFIG  PciData;
    UCHAR               iBuffer[PCI_COMMON_HDR_LENGTH];
    PPCIPBUSDATA        BusData;
    ULONG               Len;
    ULONG               i, bit;

    if (Length > sizeof (PCI_COMMON_CONFIG)) {
        Length = sizeof (PCI_COMMON_CONFIG);
    }

    Len = 0;
    PciData = (PPCI_COMMON_CONFIG) iBuffer;

    if (Offset >= PCI_COMMON_HDR_LENGTH) {
        //
        // The user did not request any data from the common
        // header.  Verify the PCI device exists, then continue
        // in the device specific area.
        //

        HalpReadPCIConfig (BusHandler, Slot, PciData, 0, sizeof(ULONG));

        if (PciData->VendorID == PCI_INVALID_VENDORID) {
            return 0;
        }

    } else {

        //
        // Caller requested at least some data within the
        // common header.  Read the whole header, effect the
        // fields we need to and then copy the user's requested
        // bytes from the header
        //

        BusData = (PPCIPBUSDATA) BusHandler->BusData;

        //
        // Read this PCI devices slot data
        //

        Len = PCI_COMMON_HDR_LENGTH;
        HalpReadPCIConfig (BusHandler, Slot, PciData, 0, Len);

        if (PciData->VendorID == PCI_INVALID_VENDORID) {
            PciData->VendorID = PCI_INVALID_VENDORID;
            Len = 2;       // only return invalid id

#if DBG

            //
            // If this read would have accessed beyond the common header
            // then it is highly likely we have detected a device driver
            // doing a legacy scan of the bus but reading more than the
            // allowed configuration header.   This can have catastrophic
            // side effects.
            //

            if ((Length + Offset) > PCI_COMMON_HDR_LENGTH) {
                if (++HalpPCIIllegalBusScannerDetected == 1) {
                    DbgPrint("HAL Warning: PCI Configuration Access had detected an invalid bus scan.\n");
                }
                if (HalpPCIStopOnIllegalBusScannerDetected) {
                    DbgBreakPoint();
                }
            }

#endif

        } else {

            BusData->CommonData.Pin2Line (BusHandler, RootHandler, Slot, PciData);
        }

        //
        // Has this PCI device been configured?
        //

#if 0

        //
        // On DBG build, if this PCI device has not yet been configured,
        // then don't report any current configuration the device may have.
        //

        bit = PciBitIndex(Slot.u.bits.DeviceNumber, Slot.u.bits.FunctionNumber);

        if (!RtlCheckBit(&BusData->DeviceConfigured, bit) &&
            PCI_CONFIG_TYPE (PciData) == PCI_DEVICE_TYPE) {

            for (i=0; i < PCI_TYPE0_ADDRESSES; i++) {
                PciData->u.type0.BaseAddresses[i] = 0;
            }

            PciData->u.type0.ROMBaseAddress = 0;
            PciData->Command &= ~(PCI_ENABLE_IO_SPACE | PCI_ENABLE_MEMORY_SPACE);
        }
#endif


        //
        // Copy whatever data overlaps into the callers buffer
        //

        if (Len < Offset) {
            // no data at caller's buffer
            return 0;
        }

        Len -= Offset;
        if (Len > Length) {
            Len = Length;
        }

        RtlMoveMemory(Buffer, iBuffer + Offset, Len);

        Offset += Len;
        Buffer += Len;
        Length -= Len;
    }

    if (Length) {
        if (Offset >= PCI_COMMON_HDR_LENGTH) {
            //
            // The remaining Buffer comes from the Device Specific
            // area - put on the kitten gloves and read from it.
            //
            // Specific read/writes to the PCI device specific area
            // are guarenteed:
            //
            //    Not to read/write any byte outside the area specified
            //    by the caller.  (this may cause WORD or BYTE references
            //    to the area in order to read the non-dword aligned
            //    ends of the request)
            //
            //    To use a WORD access if the requested length is exactly
            //    a WORD long.
            //
            //    To use a BYTE access if the requested length is exactly
            //    a BYTE long.
            //

            HalpReadPCIConfig (BusHandler, Slot, Buffer, Offset, Length);
            Len += Length;
        }
    }

    return Len;
}

ULONG
HalpSetPCIData (
    IN PBUS_HANDLER BusHandler,
    IN PBUS_HANDLER RootHandler,
    IN PCI_SLOT_NUMBER Slot,
    IN PUCHAR Buffer,
    IN ULONG Offset,
    IN ULONG Length
    )
/*++

Routine Description:

    The function returns the Pci bus data for a device.

Arguments:


    VendorSpecificDevice - The VendorID (low Word) and DeviceID (High Word)

    Buffer - Supplies the space to store the data.

    Length - Supplies a count in bytes of the maximum amount to return.

Return Value:

    Returns the amount of data stored into the buffer.

--*/
{
    PPCI_COMMON_CONFIG  PciData, PciData2;
    UCHAR               iBuffer[PCI_COMMON_HDR_LENGTH];
    UCHAR               iBuffer2[PCI_COMMON_HDR_LENGTH];
    PPCIPBUSDATA        BusData;
    ULONG               Len, cnt;


    if (Length > sizeof (PCI_COMMON_CONFIG)) {
        Length = sizeof (PCI_COMMON_CONFIG);
    }


    Len = 0;
    PciData = (PPCI_COMMON_CONFIG) iBuffer;
    PciData2 = (PPCI_COMMON_CONFIG) iBuffer2;


    if (Offset >= PCI_COMMON_HDR_LENGTH) {
        //
        // The user did not request any data from the common
        // header.  Verify the PCI device exists, then continue in
        // the device specific area.
        //

        HalpReadPCIConfig (BusHandler, Slot, PciData, 0, sizeof(ULONG));

        if (PciData->VendorID == PCI_INVALID_VENDORID) {
            return 0;
        }

    } else {

        //
        // Caller requested to set at least some data within the
        // common header.
        //

        Len = PCI_COMMON_HDR_LENGTH;
        HalpReadPCIConfig (BusHandler, Slot, PciData, 0, Len);
        if (PciData->VendorID == PCI_INVALID_VENDORID  ||
            PCI_CONFIG_TYPE (PciData) != PCI_DEVICE_TYPE) {

            // no device, or header type unkown
            return 0;
        }


        //
        // Set this device as configured
        //

        BusData = (PPCIPBUSDATA) BusHandler->BusData;
#if DBG && !defined(ACPI_HAL)
        cnt = PciBitIndex(Slot.u.bits.DeviceNumber, Slot.u.bits.FunctionNumber);
        RtlSetBits (&BusData->DeviceConfigured, cnt, 1);
#endif
        //
        // Copy COMMON_HDR values to buffer2, then overlay callers changes.
        //

        RtlMoveMemory (iBuffer2, iBuffer, Len);
        BusData->CommonData.Pin2Line (BusHandler, RootHandler, Slot, PciData2);

        Len -= Offset;
        if (Len > Length) {
            Len = Length;
        }

        RtlMoveMemory (iBuffer2+Offset, Buffer, Len);

        // in case interrupt line or pin was editted
        BusData->CommonData.Line2Pin (BusHandler, RootHandler, Slot, PciData2, PciData);

#if DBG
        //
        // Verify R/O fields haven't changed
        //
        if (PciData2->VendorID   != PciData->VendorID       ||
            PciData2->DeviceID   != PciData->DeviceID       ||
            PciData2->RevisionID != PciData->RevisionID     ||
            PciData2->ProgIf     != PciData->ProgIf         ||
            PciData2->SubClass   != PciData->SubClass       ||
            PciData2->BaseClass  != PciData->BaseClass      ||
            PciData2->HeaderType != PciData->HeaderType     ||
            PciData2->BaseClass  != PciData->BaseClass      ||
            PciData2->u.type0.MinimumGrant   != PciData->u.type0.MinimumGrant   ||
            PciData2->u.type0.MaximumLatency != PciData->u.type0.MaximumLatency) {
                DbgPrint ("PCI SetBusData: Read-Only configuration value changed\n");
        }
#endif
        //
        // Set new PCI configuration
        //

        HalpWritePCIConfig (BusHandler, Slot, iBuffer2+Offset, Offset, Len);

        Offset += Len;
        Buffer += Len;
        Length -= Len;
    }

    if (Length) {
        if (Offset >= PCI_COMMON_HDR_LENGTH) {
            //
            // The remaining Buffer comes from the Device Specific
            // area - put on the kitten gloves and write it
            //
            // Specific read/writes to the PCI device specific area
            // are guarenteed:
            //
            //    Not to read/write any byte outside the area specified
            //    by the caller.  (this may cause WORD or BYTE references
            //    to the area in order to read the non-dword aligned
            //    ends of the request)
            //
            //    To use a WORD access if the requested length is exactly
            //    a WORD long.
            //
            //    To use a BYTE access if the requested length is exactly
            //    a BYTE long.
            //

            HalpWritePCIConfig (BusHandler, Slot, Buffer, Offset, Length);
            Len += Length;
        }
    }

    return Len;
}

VOID
HalpReadPCIConfig (
    IN PBUS_HANDLER BusHandler,
    IN PCI_SLOT_NUMBER Slot,
    IN PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Length
    )
{
    if (!HalpValidPCISlot (BusHandler, Slot)) {
        //
        // Invalid SlotID return no data
        //

        RtlFillMemory (Buffer, Length, (UCHAR) -1);
        return ;
    }

    HalpPCIConfig (BusHandler, Slot, (PUCHAR) Buffer, Offset, Length,
                    PCIConfigHandler.ConfigRead);
}

VOID
HalpWritePCIConfig (
    IN PBUS_HANDLER BusHandler,
    IN PCI_SLOT_NUMBER Slot,
    IN PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Length
    )
{
    if (!HalpValidPCISlot (BusHandler, Slot)) {
        //
        // Invalid SlotID do nothing
        //
        return ;
    }

    HalpPCIConfig (BusHandler, Slot, (PUCHAR) Buffer, Offset, Length,
                    PCIConfigHandler.ConfigWrite);
}

BOOLEAN
HalpValidPCISlot (
    IN PBUS_HANDLER BusHandler,
    IN PCI_SLOT_NUMBER Slot
    )
{
    PCI_SLOT_NUMBER                 Slot2;
    PPCIPBUSDATA                    BusData;
    ULONG                           i;
    UCHAR Header[FIELD_OFFSET(PCI_COMMON_CONFIG, u)];
    PPCI_COMMON_CONFIG PciConfig = (PPCI_COMMON_CONFIG)&Header;

    BusData = (PPCIPBUSDATA) BusHandler->BusData;

    if (Slot.u.bits.Reserved != 0) {
        return FALSE;
    }

    if (Slot.u.bits.DeviceNumber >= BusData->MaxDevice) {
        return FALSE;
    }

    if (Slot.u.bits.FunctionNumber == 0) {
        return TRUE;
    }

    //
    // Non zero function numbers are only supported if the
    // device has the PCI_MULTIFUNCTION bit set in it's header
    //

    i = Slot.u.bits.DeviceNumber;

    //
    // Read DeviceNumber, Function zero, to determine if the
    // PCI supports multifunction devices
    //

    Slot2 = Slot;
    Slot2.u.bits.FunctionNumber = 0;

    HalpReadPCIConfig (
        BusHandler,
        Slot2,
        &Header,
        0,
        sizeof(Header)
        );

    if (PciConfig->VendorID == PCI_INVALID_VENDORID) {

        //
        // This device doesn't exist, therefore, this function
        // doesn't exist.
        //

        return FALSE;
    }

    if (PciConfig->HeaderType & PCI_MULTIFUNCTION) {

        //
        // It's a multifunction device.  Slot is valid.
        //

        return TRUE;
    }

    //
    // Special cases, ie HACKs for broken hardware.
    //

    if ((PciConfig->VendorID == 0x8086) &&
        (PciConfig->DeviceID == 0x122e)) {

        //
        // This device lies, it really is multifunction.
        // It's also writable so write back the correct value
        // to avoid coming down this path in future.
        //

        PciConfig->HeaderType |= PCI_MULTIFUNCTION;
        HalpWritePCIConfig(
            BusHandler,
            Slot2,
            &PciConfig->HeaderType,
            FIELD_OFFSET(PCI_COMMON_CONFIG, HeaderType),
            sizeof(PciConfig->HeaderType)
            );

        return TRUE;
    }

    //
    // None of the above, must not be a multifunction device.
    //

    return FALSE;
}


VOID
HalpPCIConfig (
    IN PBUS_HANDLER     BusHandler,
    IN PCI_SLOT_NUMBER  Slot,
    IN PUCHAR           Buffer,
    IN ULONG            Offset,
    IN ULONG            Length,
    IN FncConfigIO      *ConfigIO
    )
{
    KIRQL               OldIrql;
    ULONG               i;
    UCHAR               State[20];
    PPCIPBUSDATA        BusData;

    BusData = (PPCIPBUSDATA) BusHandler->BusData;
    PCIConfigHandler.Synchronize (BusHandler, Slot, &OldIrql, State);

    while (Length) {
        i = PCIDeref[Offset % sizeof(ULONG)][Length % sizeof(ULONG)];
        i = ConfigIO[i] (BusData, State, Buffer, Offset);

        Offset += i;
        Buffer += i;
        Length -= i;
    }

    PCIConfigHandler.ReleaseSynchronzation (BusHandler, OldIrql);
}

VOID
HalpPCISynchronizeType1 (
    IN PBUS_HANDLER         BusHandler,
    IN PCI_SLOT_NUMBER      Slot,
    IN PKIRQL               Irql,
    IN PPCI_TYPE1_CFG_BITS  PciCfg1
    )
{
    //
    // Initialize PciCfg1
    //

    PciCfg1->u.AsULONG = 0;
    PciCfg1->u.bits.BusNumber = BusHandler->BusNumber;
    PciCfg1->u.bits.DeviceNumber = Slot.u.bits.DeviceNumber;
    PciCfg1->u.bits.FunctionNumber = Slot.u.bits.FunctionNumber;
    PciCfg1->u.bits.Enable = TRUE;

    //
    // Synchronize with PCI type1 config space
    //

    if (!HalpDoingCrashDump) {
        *Irql = KfRaiseIrql (HIGH_LEVEL);
        KiAcquireSpinLock (&HalpPCIConfigLock);
    } else {
        *Irql = HIGH_LEVEL;
    }
}

VOID
HalpPCIReleaseSynchronzationType1 (
    IN PBUS_HANDLER     BusHandler,
    IN KIRQL            Irql
    )
{
    PCI_TYPE1_CFG_BITS  PciCfg1;
    PPCIPBUSDATA        BusData;

    //
    // Disable PCI configuration space
    //

    PciCfg1.u.AsULONG = 0;
    BusData = (PPCIPBUSDATA) BusHandler->BusData;
    WRITE_PORT_ULONG (BusData->Config.Type1.Address, PciCfg1.u.AsULONG);

    //
    // Release spinlock
    //

    if (!HalpDoingCrashDump) {
        KiReleaseSpinLock (&HalpPCIConfigLock);
        KeLowerIrql (Irql);
    }
}


VOID
HalpPCISynchronizeOrionB0 (
    IN PBUS_HANDLER         BusHandler,
    IN PCI_SLOT_NUMBER      Slot,
    IN PKIRQL               Irql,
    IN PPCI_TYPE1_CFG_BITS  PciCfg1
    )
{
    PCI_TYPE1_CFG_BITS      Cfg1;
    union {
        ULONG   dword;
        USHORT  word;
        UCHAR   byte[4];
    } Buffer;

    //
    // First perform normal type 1 synchronization
    //

    HalpPCISynchronizeType1 (BusHandler, Slot, Irql, PciCfg1);

    //
    // Apply Orion B0 workaround
    //

    Cfg1.u.AsULONG=0;
    Cfg1.u.bits.BusNumber = HalpOrionOPB.Handler->BusNumber;
    Cfg1.u.bits.DeviceNumber = HalpOrionOPB.Slot.u.bits.DeviceNumber;
    Cfg1.u.bits.FunctionNumber = HalpOrionOPB.Slot.u.bits.FunctionNumber;
    Cfg1.u.bits.Enable = TRUE;

    //
    // Read OPB until we get back the expected Vendor ID and device ID
    //

    do  {
        HalpPCIReadUlongType1 (HalpOrionOPB.Handler->BusData, &Cfg1, Buffer.byte, 0);
    } while (Buffer.dword != 0x84c48086);

    //
    // The bug is that the config read will return whatever value you
    // happened to read last. Read register 0x54 till we don't read the
    // last value read any more(Vendor ID/Device ID).
    //

    do  {
        HalpPCIReadUshortType1 (HalpOrionOPB.Handler->BusData, &Cfg1, Buffer.byte, 0x54);
    } while (Buffer.word == 0x8086);

    //
    // Disable inbound posting by clearing bit 0 of register 0x54
    //

    Buffer.word &= ~0x1;
    HalpPCIWriteUshortType1 (HalpOrionOPB.Handler->BusData, &Cfg1, Buffer.byte, 0x54);
}

VOID
HalpPCIReleaseSynchronzationOrionB0 (
    IN PBUS_HANDLER     BusHandler,
    IN KIRQL            Irql
    )
{

    PCI_TYPE1_CFG_BITS      PciCfg1;
    PPCIPBUSDATA            BusData;
    union {
        ULONG   dword;
        USHORT  word;
        UCHAR   byte[4];
    } Buffer;

    PciCfg1.u.AsULONG=0;
    PciCfg1.u.bits.BusNumber = HalpOrionOPB.Handler->BusNumber;
    PciCfg1.u.bits.DeviceNumber = HalpOrionOPB.Slot.u.bits.DeviceNumber;
    PciCfg1.u.bits.FunctionNumber = HalpOrionOPB.Slot.u.bits.FunctionNumber;
    PciCfg1.u.bits.Enable = TRUE;

    HalpPCIReadUshortType1 (HalpOrionOPB.Handler->BusData, &PciCfg1, Buffer.byte, 0x54);


    //
    // Enable Inbound posting by setting bit 0 of register 0x54 of ncOPB
    //

    Buffer.word |= 0x1;
    HalpPCIWriteUshortType1 (HalpOrionOPB.Handler->BusData, &PciCfg1, Buffer.byte, 0x54);

    //
    // Complete type 1 synchronization
    //

    HalpPCIReleaseSynchronzationType1 (BusHandler, Irql);
}



ULONG
HalpPCIReadUcharType1 (
    IN PPCIPBUSDATA         BusData,
    IN PPCI_TYPE1_CFG_BITS  PciCfg1,
    IN PUCHAR               Buffer,
    IN ULONG                Offset
    )
{
    ULONG               i;

    i = Offset % sizeof(ULONG);
    PciCfg1->u.bits.RegisterNumber = Offset / sizeof(ULONG);
    WRITE_PORT_ULONG (BusData->Config.Type1.Address, PciCfg1->u.AsULONG);
    *Buffer = READ_PORT_UCHAR ((PUCHAR) (ULONG_PTR)(BusData->Config.Type1.Data + i));
    return sizeof (UCHAR);
}

ULONG
HalpPCIReadUshortType1 (
    IN PPCIPBUSDATA         BusData,
    IN PPCI_TYPE1_CFG_BITS  PciCfg1,
    IN PUCHAR               Buffer,
    IN ULONG                Offset
    )
{
    ULONG               i;

    i = Offset % sizeof(ULONG);
    PciCfg1->u.bits.RegisterNumber = Offset / sizeof(ULONG);
    WRITE_PORT_ULONG (BusData->Config.Type1.Address, PciCfg1->u.AsULONG);
    *((PUSHORT) Buffer) = READ_PORT_USHORT ((PUSHORT) (ULONG_PTR)(BusData->Config.Type1.Data + i));
    return sizeof (USHORT);
}

ULONG
HalpPCIReadUlongType1 (
    IN PPCIPBUSDATA         BusData,
    IN PPCI_TYPE1_CFG_BITS  PciCfg1,
    IN PUCHAR               Buffer,
    IN ULONG                Offset
    )
{
    PciCfg1->u.bits.RegisterNumber = Offset / sizeof(ULONG);
    WRITE_PORT_ULONG (BusData->Config.Type1.Address, PciCfg1->u.AsULONG);
    *((PULONG) Buffer) = READ_PORT_ULONG ((PULONG) (ULONG_PTR)BusData->Config.Type1.Data);
    return sizeof (ULONG);
}


ULONG
HalpPCIWriteUcharType1 (
    IN PPCIPBUSDATA         BusData,
    IN PPCI_TYPE1_CFG_BITS  PciCfg1,
    IN PUCHAR               Buffer,
    IN ULONG                Offset
    )
{
    ULONG               i;

    i = Offset % sizeof(ULONG);
    PciCfg1->u.bits.RegisterNumber = Offset / sizeof(ULONG);
    WRITE_PORT_ULONG (BusData->Config.Type1.Address, PciCfg1->u.AsULONG);
    WRITE_PORT_UCHAR ((PUCHAR) (ULONG_PTR)(BusData->Config.Type1.Data + i), *Buffer);
    return sizeof (UCHAR);
}

ULONG
HalpPCIWriteUshortType1 (
    IN PPCIPBUSDATA         BusData,
    IN PPCI_TYPE1_CFG_BITS  PciCfg1,
    IN PUCHAR               Buffer,
    IN ULONG                Offset
    )
{
    ULONG               i;

    i = Offset % sizeof(ULONG);
    PciCfg1->u.bits.RegisterNumber = Offset / sizeof(ULONG);
    WRITE_PORT_ULONG (BusData->Config.Type1.Address, PciCfg1->u.AsULONG);
    WRITE_PORT_USHORT ((PUSHORT) (ULONG_PTR)(BusData->Config.Type1.Data + i), *((PUSHORT) Buffer));
    return sizeof (USHORT);
}

ULONG
HalpPCIWriteUlongType1 (
    IN PPCIPBUSDATA         BusData,
    IN PPCI_TYPE1_CFG_BITS  PciCfg1,
    IN PUCHAR               Buffer,
    IN ULONG                Offset
    )
{
    PciCfg1->u.bits.RegisterNumber = Offset / sizeof(ULONG);
    WRITE_PORT_ULONG (BusData->Config.Type1.Address, PciCfg1->u.AsULONG);
    WRITE_PORT_ULONG ((PULONG) (ULONG_PTR)BusData->Config.Type1.Data, *((PULONG) Buffer));
    return sizeof (ULONG);
}


VOID HalpPCISynchronizeType2 (
    IN PBUS_HANDLER             BusHandler,
    IN PCI_SLOT_NUMBER          Slot,
    IN PKIRQL                   Irql,
    IN PPCI_TYPE2_ADDRESS_BITS  PciCfg2Addr
    )
{
    PCI_TYPE2_CSE_BITS      PciCfg2Cse;
    PPCIPBUSDATA            BusData;

    BusData = (PPCIPBUSDATA) BusHandler->BusData;

    //
    // Initialize Cfg2Addr
    //

    PciCfg2Addr->u.AsUSHORT = 0;
    PciCfg2Addr->u.bits.Agent = (USHORT) Slot.u.bits.DeviceNumber;
    PciCfg2Addr->u.bits.AddressBase = (USHORT) BusData->Config.Type2.Base;

    //
    // Synchronize with type2 config space - type2 config space
    // remaps 4K of IO space, so we can not allow other I/Os to occur
    // while using type2 config space.
    //

    HalpPCIAcquireType2Lock (&HalpPCIConfigLock, Irql);

    PciCfg2Cse.u.AsUCHAR = 0;
    PciCfg2Cse.u.bits.Enable = TRUE;
    PciCfg2Cse.u.bits.FunctionNumber = (UCHAR) Slot.u.bits.FunctionNumber;
    PciCfg2Cse.u.bits.Key = 0xff;

    //
    // Select bus & enable type 2 configuration space
    //

    WRITE_PORT_UCHAR (BusData->Config.Type2.Forward, (UCHAR) BusHandler->BusNumber);
    WRITE_PORT_UCHAR (BusData->Config.Type2.CSE, PciCfg2Cse.u.AsUCHAR);
}


VOID HalpPCIReleaseSynchronzationType2 (
    IN PBUS_HANDLER         BusHandler,
    IN KIRQL                Irql
    )
{
    PCI_TYPE2_CSE_BITS      PciCfg2Cse;
    PPCIPBUSDATA            BusData;

    //
    // disable PCI configuration space
    //

    BusData = (PPCIPBUSDATA) BusHandler->BusData;

    PciCfg2Cse.u.AsUCHAR = 0;
    WRITE_PORT_UCHAR (BusData->Config.Type2.CSE, PciCfg2Cse.u.AsUCHAR);
    WRITE_PORT_UCHAR (BusData->Config.Type2.Forward, (UCHAR) 0);

    //
    // Restore interrupts, release spinlock
    //

    HalpPCIReleaseType2Lock (&HalpPCIConfigLock, Irql);
}


ULONG
HalpPCIReadUcharType2 (
    IN PPCIPBUSDATA             BusData,
    IN PPCI_TYPE2_ADDRESS_BITS  PciCfg2Addr,
    IN PUCHAR                   Buffer,
    IN ULONG                    Offset
    )
{
    PciCfg2Addr->u.bits.RegisterNumber = (USHORT) Offset;
    *Buffer = READ_PORT_UCHAR ((PUCHAR) PciCfg2Addr->u.AsUSHORT);
    return sizeof (UCHAR);
}

ULONG
HalpPCIReadUshortType2 (
    IN PPCIPBUSDATA             BusData,
    IN PPCI_TYPE2_ADDRESS_BITS  PciCfg2Addr,
    IN PUCHAR                   Buffer,
    IN ULONG                    Offset
    )
{
    PciCfg2Addr->u.bits.RegisterNumber = (USHORT) Offset;
    *((PUSHORT) Buffer) = READ_PORT_USHORT ((PUSHORT) PciCfg2Addr->u.AsUSHORT);
    return sizeof (USHORT);
}

ULONG
HalpPCIReadUlongType2 (
    IN PPCIPBUSDATA             BusData,
    IN PPCI_TYPE2_ADDRESS_BITS  PciCfg2Addr,
    IN PUCHAR                   Buffer,
    IN ULONG                    Offset
    )
{
    PciCfg2Addr->u.bits.RegisterNumber = (USHORT) Offset;
    *((PULONG) Buffer) = READ_PORT_ULONG ((PULONG) PciCfg2Addr->u.AsUSHORT);
    return sizeof(ULONG);
}


ULONG
HalpPCIWriteUcharType2 (
    IN PPCIPBUSDATA             BusData,
    IN PPCI_TYPE2_ADDRESS_BITS  PciCfg2Addr,
    IN PUCHAR                   Buffer,
    IN ULONG                    Offset
    )
{
    PciCfg2Addr->u.bits.RegisterNumber = (USHORT) Offset;
    WRITE_PORT_UCHAR ((PUCHAR) PciCfg2Addr->u.AsUSHORT, *Buffer);
    return sizeof (UCHAR);
}

ULONG
HalpPCIWriteUshortType2 (
    IN PPCIPBUSDATA             BusData,
    IN PPCI_TYPE2_ADDRESS_BITS  PciCfg2Addr,
    IN PUCHAR                   Buffer,
    IN ULONG                    Offset
    )
{
    PciCfg2Addr->u.bits.RegisterNumber = (USHORT) Offset;
    WRITE_PORT_USHORT ((PUSHORT) PciCfg2Addr->u.AsUSHORT, *((PUSHORT) Buffer));
    return sizeof (USHORT);
}

ULONG
HalpPCIWriteUlongType2 (
    IN PPCIPBUSDATA             BusData,
    IN PPCI_TYPE2_ADDRESS_BITS  PciCfg2Addr,
    IN PUCHAR                   Buffer,
    IN ULONG                    Offset
    )
{
    PciCfg2Addr->u.bits.RegisterNumber = (USHORT) Offset;
    WRITE_PORT_ULONG ((PULONG) PciCfg2Addr->u.AsUSHORT, *((PULONG) Buffer));
    return sizeof(ULONG);
}


NTSTATUS
HalpAssignPCISlotResources (
    IN PBUS_HANDLER             BusHandler,
    IN PBUS_HANDLER             RootHandler,
    IN PUNICODE_STRING          RegistryPath,
    IN PUNICODE_STRING          DriverClassName       OPTIONAL,
    IN PDRIVER_OBJECT           DriverObject,
    IN PDEVICE_OBJECT           DeviceObject          OPTIONAL,
    IN ULONG                    Slot,
    IN OUT PCM_RESOURCE_LIST   *pAllocatedResources
    )
/*++

Routine Description:

    Reads the targeted device to determine it's required resources.
    Calls IoAssignResources to allocate them.
    Sets the targeted device with it's assigned resoruces
    and returns the assignments to the caller.

Arguments:

Return Value:

    STATUS_SUCCESS or error

--*/
{
    NTSTATUS                        status;
    PUCHAR                          WorkingPool;
    PPCI_COMMON_CONFIG              PciData, PciOrigData, PciData2;
    PCI_SLOT_NUMBER                 PciSlot;
    PPCIPBUSDATA                    BusData;
    PIO_RESOURCE_REQUIREMENTS_LIST  CompleteList;
    PIO_RESOURCE_DESCRIPTOR         Descriptor;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR CmDescriptor;
    ULONG                           BusNumber;
    ULONG                           i, j, m, length, memtype;
    ULONG                           NoBaseAddress, RomIndex, Option;
    PULONG                          BaseAddress[PCI_TYPE0_ADDRESSES + 1];
    PULONG                          OrigAddress[PCI_TYPE0_ADDRESSES + 1];
    BOOLEAN                         Match, EnableRomBase, RequestedInterrupt;
    KIRQL                           Kirql;
    KAFFINITY                       Kaffinity;

    *pAllocatedResources = NULL;
    PciSlot = *((PPCI_SLOT_NUMBER) &Slot);
    BusNumber = BusHandler->BusNumber;
    BusData = (PPCIPBUSDATA) BusHandler->BusData;

    //
    // Allocate some pool for working space
    //

    i = sizeof (IO_RESOURCE_REQUIREMENTS_LIST) +
        sizeof (IO_RESOURCE_DESCRIPTOR) * (PCI_TYPE0_ADDRESSES + 2) * 2 +
        PCI_COMMON_HDR_LENGTH * 3;

    WorkingPool = (PUCHAR)ExAllocatePoolWithTag(PagedPool, i, HAL_POOL_TAG);
    if (!WorkingPool) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Zero initialize pool, and get pointers into memory
    //

    RtlZeroMemory (WorkingPool, i);
    CompleteList = (PIO_RESOURCE_REQUIREMENTS_LIST) WorkingPool;
    PciData     = (PPCI_COMMON_CONFIG) (WorkingPool + i - PCI_COMMON_HDR_LENGTH * 3);
    PciData2    = (PPCI_COMMON_CONFIG) (WorkingPool + i - PCI_COMMON_HDR_LENGTH * 2);
    PciOrigData = (PPCI_COMMON_CONFIG) (WorkingPool + i - PCI_COMMON_HDR_LENGTH * 1);

    //
    // Read the PCI device's configuration
    //

    HalpReadPCIConfig (BusHandler, PciSlot, PciData, 0, PCI_COMMON_HDR_LENGTH);
    if (PciData->VendorID == PCI_INVALID_VENDORID) {
        ExFreePool (WorkingPool);
        return STATUS_NO_SUCH_DEVICE;
    }

    //
    // For now since there's not PnP support in the OS, if the BIOS hasn't
    // enable a VGA device don't allow it to get enabled via this interface.
    //

    if ( (PciData->BaseClass == 0 && PciData->SubClass == 1) ||
         (PciData->BaseClass == 3 && PciData->SubClass == 0)) {

        if ((PciData->Command & (PCI_ENABLE_IO_SPACE | PCI_ENABLE_MEMORY_SPACE)) == 0) {
            ExFreePool (WorkingPool);
            return STATUS_DEVICE_NOT_CONNECTED;
        }
    }

    //
    // Make a copy of the device's current settings
    //

    RtlMoveMemory (PciOrigData, PciData, PCI_COMMON_HDR_LENGTH);

    //
    // Initialize base addresses base on configuration data type
    //

    switch (PCI_CONFIG_TYPE(PciData)) {
        case 0 :
            NoBaseAddress = PCI_TYPE0_ADDRESSES+1;
            for (j=0; j < PCI_TYPE0_ADDRESSES; j++) {
                BaseAddress[j] = &PciData->u.type0.BaseAddresses[j];
                OrigAddress[j] = &PciOrigData->u.type0.BaseAddresses[j];
            }
            BaseAddress[j] = &PciData->u.type0.ROMBaseAddress;
            OrigAddress[j] = &PciOrigData->u.type0.ROMBaseAddress;
            RomIndex = j;
            break;
        case 1:
            NoBaseAddress = PCI_TYPE1_ADDRESSES+1;
            for (j=0; j < PCI_TYPE1_ADDRESSES; j++) {
                BaseAddress[j] = &PciData->u.type1.BaseAddresses[j];
                OrigAddress[j] = &PciOrigData->u.type1.BaseAddresses[j];
            }
            BaseAddress[j] = &PciData->u.type1.ROMBaseAddress;
            OrigAddress[j] = &PciOrigData->u.type1.ROMBaseAddress;
            RomIndex = j;
            break;

        default:
            ExFreePool (WorkingPool);
            return STATUS_NO_SUCH_DEVICE;
    }

    //
    // If the BIOS doesn't have the device's ROM enabled, then we won't
    // enable it either.  Remove it from the list.
    //

    EnableRomBase = TRUE;
    if (!(*BaseAddress[RomIndex] & PCI_ROMADDRESS_ENABLED)) {
        ASSERT (RomIndex+1 == NoBaseAddress);
        EnableRomBase = FALSE;
        NoBaseAddress -= 1;
    }

    //
    // Set resources to all bits on to see what type of resources
    // are required.
    //

    for (j=0; j < NoBaseAddress; j++) {
        *BaseAddress[j] = 0xFFFFFFFF;
    }

    PciData->Command &= ~(PCI_ENABLE_IO_SPACE | PCI_ENABLE_MEMORY_SPACE);
    *BaseAddress[RomIndex] &= ~PCI_ROMADDRESS_ENABLED;
    HalpWritePCIConfig (BusHandler, PciSlot, PciData, 0, PCI_COMMON_HDR_LENGTH);
    HalpReadPCIConfig  (BusHandler, PciSlot, PciData, 0, PCI_COMMON_HDR_LENGTH);

    // note type0 & type1 overlay ROMBaseAddress, InterruptPin, and InterruptLine
    BusData->CommonData.Pin2Line (BusHandler, RootHandler, PciSlot, PciData);

    //
    // Build an IO_RESOURCE_REQUIREMENTS_LIST for the PCI device
    //

    CompleteList->InterfaceType = PCIBus;
    CompleteList->BusNumber = BusNumber;
    CompleteList->SlotNumber = Slot;
    CompleteList->AlternativeLists = 1;

    CompleteList->List[0].Version = 1;
    CompleteList->List[0].Revision = 1;

    Descriptor = CompleteList->List[0].Descriptors;

    //
    // If PCI device has an interrupt resource, add it
    //

    RequestedInterrupt = FALSE;
    if (PciData->u.type0.InterruptPin  &&
        PciData->u.type0.InterruptLine != (0 ^ IRQXOR)  &&
        PciData->u.type0.InterruptLine != (0xFF ^ IRQXOR) &&
        HalGetInterruptVector(PCIBus,
                              BusNumber,
                              PciData->u.type0.InterruptLine,
                              PciData->u.type0.InterruptLine,
                              &Kirql,
                              &Kaffinity)) {
        RequestedInterrupt = TRUE;
        CompleteList->List[0].Count++;

        Descriptor->Option = 0;
        Descriptor->Type   = CmResourceTypeInterrupt;
        Descriptor->ShareDisposition = CmResourceShareShared;
        Descriptor->Flags  = CM_RESOURCE_INTERRUPT_LEVEL_SENSITIVE;

        if (ARGUMENT_PRESENT(DeviceObject)) {

            //
            // Let the arbiter pick any interrupt.
            //

            Descriptor->u.Interrupt.MinimumVector = 0;
            Descriptor->u.Interrupt.MaximumVector = 0xff;

        } else {

            //
            // Translation is going to fail, because we won't
            // be able to identify this device by its device
            // object.  So trim the requested interrupt resources
            // down to what's in the interrupt line register.
            // The translator will punt and read this.
            //

            Descriptor->u.Interrupt.MinimumVector = PciData->u.type0.InterruptLine;
            Descriptor->u.Interrupt.MaximumVector = PciData->u.type0.InterruptLine;
        }
        Descriptor++;
    }

    //
    // Add a memory/port resoruce for each PCI resource
    //

    // Clear ROM reserved bits

    *BaseAddress[RomIndex] &= ~0x7FF;

    for (j=0; j < NoBaseAddress; j++) {
        if (*BaseAddress[j]) {
            i = *BaseAddress[j];

            // scan for first set bit, that's the length & alignment
            length = 1 << (i & PCI_ADDRESS_IO_SPACE ? 2 : 4);
            while (!(i & length)  &&  length) {
                length <<= 1;
            }

            // scan for last set bit, that's the maxaddress + 1
            for (m = length; i & m; m <<= 1) ;
            m--;

            // check for hosed PCI configuration requirements
            if (length & ~m) {
#if DBG
                DbgPrint ("PCI: defective device! Bus %d, Slot %d, Function %d\n",
                    BusNumber,
                    PciSlot.u.bits.DeviceNumber,
                    PciSlot.u.bits.FunctionNumber
                    );

                DbgPrint ("PCI: BaseAddress[%d] = %08lx\n", j, i);
#endif
                // the device is in error - punt.  don't allow this
                // resource any option - it either gets set to whatever
                // bits it was able to return, or it doesn't get set.

                if (i & PCI_ADDRESS_IO_SPACE) {
                    m = i & ~0x3;
                    Descriptor->u.Port.MinimumAddress.LowPart = m;
                } else {
                    m = i & ~0xf;
                    Descriptor->u.Memory.MinimumAddress.LowPart = m;
                }

                m += length;    // max address is min address + length
            }

            //
            // Add requested resource
            //

            Descriptor->Option = 0;
            if (i & PCI_ADDRESS_IO_SPACE) {
                memtype = 0;

                if (PciOrigData->Command & PCI_ENABLE_IO_SPACE) {

                    //
                    // The IO range is/was already enabled at some location, add that
                    // as it's preferred setting.
                    //

                    Descriptor->Type = CmResourceTypePort;
                    Descriptor->ShareDisposition = CmResourceShareDeviceExclusive;
                    Descriptor->Flags = CM_RESOURCE_PORT_IO;
                    Descriptor->Option = IO_RESOURCE_PREFERRED;

                    Descriptor->u.Port.Length = length;
                    Descriptor->u.Port.Alignment = length;
                    Descriptor->u.Port.MinimumAddress.LowPart = *OrigAddress[j] & ~0x3;
                    Descriptor->u.Port.MaximumAddress.LowPart =
                        Descriptor->u.Port.MinimumAddress.LowPart + length - 1;

                    CompleteList->List[0].Count++;
                    Descriptor++;

                    Descriptor->Option = IO_RESOURCE_ALTERNATIVE;
                }

                //
                // Add this IO range
                //

                Descriptor->Type = CmResourceTypePort;
                Descriptor->ShareDisposition = CmResourceShareDeviceExclusive;
                Descriptor->Flags = CM_RESOURCE_PORT_IO;

                Descriptor->u.Port.Length = length;
                Descriptor->u.Port.Alignment = length;
                Descriptor->u.Port.MaximumAddress.LowPart = m;

            } else {

                memtype = i & PCI_ADDRESS_MEMORY_TYPE_MASK;

                Descriptor->Flags  = CM_RESOURCE_MEMORY_READ_WRITE;
                if (j == RomIndex) {
                    // this is a ROM address
                    Descriptor->Flags = CM_RESOURCE_MEMORY_READ_ONLY;
                }

                if (i & PCI_ADDRESS_MEMORY_PREFETCHABLE) {
                    Descriptor->Flags |= CM_RESOURCE_MEMORY_PREFETCHABLE;
                }

                if ((j == RomIndex)  ||
                    ((PciOrigData->Command & PCI_ENABLE_MEMORY_SPACE) &&
                     ((!Is64BitBaseAddress(i)) || (*OrigAddress[j+1] == 0)))) {

                    //
                    // The memory range is/was already enabled at some location,
                    // add that as it's preferred setting.
                    //

                    Descriptor->Type = CmResourceTypeMemory;
                    Descriptor->ShareDisposition = CmResourceShareDeviceExclusive;
                    Descriptor->Option = IO_RESOURCE_PREFERRED;

                    Descriptor->u.Port.Length = length;
                    Descriptor->u.Port.Alignment = length;
                    Descriptor->u.Port.MinimumAddress.LowPart = *OrigAddress[j] & ~0xF;
                    Descriptor->u.Port.MaximumAddress.LowPart =
                        Descriptor->u.Port.MinimumAddress.LowPart + length - 1;

                    CompleteList->List[0].Count++;
                    Descriptor++;

                    Descriptor->Flags = Descriptor[-1].Flags;
                    Descriptor->Option = IO_RESOURCE_ALTERNATIVE;
                }

                //
                // Add this memory range
                //

                Descriptor->Type = CmResourceTypeMemory;
                Descriptor->ShareDisposition = CmResourceShareDeviceExclusive;

                Descriptor->u.Memory.Length = length;
                Descriptor->u.Memory.Alignment = length;
                Descriptor->u.Memory.MaximumAddress.LowPart = m;

                if (memtype == PCI_TYPE_20BIT && m > 0xFFFFF) {
                    // limit to 20 bit address
                    Descriptor->u.Memory.MaximumAddress.LowPart = 0xFFFFF;
                }
            }

            CompleteList->List[0].Count++;
            Descriptor++;


            if (Is64BitBaseAddress(i)) {
                // skip upper half of 64 bit address since this processor
                // only supports 32 bits of address space
                j++;
            }
        }
    }

    CompleteList->ListSize = (ULONG)
            ((PUCHAR) Descriptor - (PUCHAR) CompleteList);

    //
    // Restore the device settings as we found them, enable memory
    // and io decode after setting base addresses.  This is done in
    // case HalAdjustResourceList wants to read the current settings
    // in the device.
    //

    HalpWritePCIConfig (
        BusHandler,
        PciSlot,
        &PciOrigData->Status,
        FIELD_OFFSET (PCI_COMMON_CONFIG, Status),
        PCI_COMMON_HDR_LENGTH - FIELD_OFFSET (PCI_COMMON_CONFIG, Status)
        );

    HalpWritePCIConfig (
        BusHandler,
        PciSlot,
        PciOrigData,
        0,
        FIELD_OFFSET (PCI_COMMON_CONFIG, Status)
        );

    //
    // Have the IO system allocate resource assignments
    //

    status = IoAssignResources (
                RegistryPath,
                DriverClassName,
                DriverObject,
                DeviceObject,
                CompleteList,
                pAllocatedResources
            );

    if (!NT_SUCCESS(status)) {
        goto CleanUp;
    }

    //
    // Slurp the assigments back into the PciData structure and
    // perform them
    //

    CmDescriptor = (*pAllocatedResources)->List[0].PartialResourceList.PartialDescriptors;

    //
    // If PCI device has an interrupt resource then that was
    // passed in as the first requested resource
    //

    if (RequestedInterrupt) {
        PciData->u.type0.InterruptLine = (UCHAR) CmDescriptor->u.Interrupt.Vector;
        BusData->CommonData.Line2Pin (BusHandler, RootHandler, PciSlot, PciData, PciOrigData);
        CmDescriptor++;
    }

    //
    // Pull out resources in the order they were passed to IoAssignResources
    //

    for (j=0; j < NoBaseAddress; j++) {
        i = *BaseAddress[j];
        if (i) {
            if (i & PCI_ADDRESS_IO_SPACE) {
                *BaseAddress[j] = CmDescriptor->u.Port.Start.LowPart;
            } else {
                *BaseAddress[j] = CmDescriptor->u.Memory.Start.LowPart;
                if (Is64BitBaseAddress(i)) {

                    //
                    // 64 bit address occupies 2 BARs.  Reset the
                    // upper 32 bits to zero (currently FFFFFFFF
                    // from above).  Actually, set to upper 32 bits
                    // from assigned resource.
                    //

                    j++;
                    *BaseAddress[j] = CmDescriptor->u.Memory.Start.HighPart;
                }
            }
            CmDescriptor++;
        }
    }

    //
    // Turn off decodes, then set new addresses
    //

    HalpWritePCIConfig (BusHandler, PciSlot, PciData, 0, PCI_COMMON_HDR_LENGTH);

    //
    // Read configuration back and verify address settings took
    //

    HalpReadPCIConfig(BusHandler, PciSlot, PciData2, 0, PCI_COMMON_HDR_LENGTH);

    Match = TRUE;
    if (PciData->u.type0.InterruptLine  != PciData2->u.type0.InterruptLine ||
        PciData->u.type0.InterruptPin   != PciData2->u.type0.InterruptPin  ||
        PciData->u.type0.ROMBaseAddress != PciData2->u.type0.ROMBaseAddress) {
            Match = FALSE;
    }

    for (j=0; j < NoBaseAddress; j++) {
        if (*BaseAddress[j]) {
            if (*BaseAddress[j] & PCI_ADDRESS_IO_SPACE) {
                i = PCI_ADDRESS_IO_ADDRESS_MASK;
            } else {
                i = PCI_ADDRESS_MEMORY_ADDRESS_MASK;
            }

            if ((*BaseAddress[j] & i) !=
                (*((PULONG) ((PUCHAR) BaseAddress[j] -
                             (PUCHAR) PciData +
                             (PUCHAR) PciData2)) & i)) {

                    Match = FALSE;
            }

            if (Is64BitBaseAddress(*BaseAddress[j])) {
                // skip upper 32 bits
                j++;
            }
        }
    }

    if (!Match) {
#if DBG
        DbgPrint ("PCI: defective device! Bus %d, Slot %d, Function %d\n",
            BusNumber,
            PciSlot.u.bits.DeviceNumber,
            PciSlot.u.bits.FunctionNumber
            );
#endif
        status = STATUS_DEVICE_PROTOCOL_ERROR;
        goto CleanUp;
    }

    //
    // Settings took - turn on the appropiate decodes
    //

    if (EnableRomBase  &&  *BaseAddress[RomIndex]) {
        // a rom address was allocated and should be enabled
        *BaseAddress[RomIndex] |= PCI_ROMADDRESS_ENABLED;
        HalpWritePCIConfig (
            BusHandler,
            PciSlot,
            BaseAddress[RomIndex],
            (ULONG) ((PUCHAR) BaseAddress[RomIndex] - (PUCHAR) PciData),
            sizeof (ULONG)
            );
    }

    //
    // Enable IO, Memory, and BUS_MASTER decodes
    // (use HalSetBusData since valid settings now set)
    //

    PciData->Command |= PCI_ENABLE_IO_SPACE |
                        PCI_ENABLE_MEMORY_SPACE |
                        PCI_ENABLE_BUS_MASTER;

    HalSetBusDataByOffset (
        PCIConfiguration,
        BusHandler->BusNumber,
        PciSlot.u.AsULONG,
        &PciData->Command,
        FIELD_OFFSET (PCI_COMMON_CONFIG, Command),
        sizeof (PciData->Command)
        );

CleanUp:
    if (!NT_SUCCESS(status)) {

        //
        // Failure, if there are any allocated resources free them
        //

        if (*pAllocatedResources) {
            IoAssignResources (
                RegistryPath,
                DriverClassName,
                DriverObject,
                DeviceObject,
                NULL,
                NULL
                );

            ExFreePool (*pAllocatedResources);
            *pAllocatedResources = NULL;
        }

        //
        // Restore the device settings as we found them, enable memory
        // and io decode after setting base addresses
        //

        HalpWritePCIConfig (
            BusHandler,
            PciSlot,
            &PciOrigData->Status,
            FIELD_OFFSET (PCI_COMMON_CONFIG, Status),
            PCI_COMMON_HDR_LENGTH - FIELD_OFFSET (PCI_COMMON_CONFIG, Status)
            );

        HalpWritePCIConfig (
            BusHandler,
            PciSlot,
            PciOrigData,
            0,
            FIELD_OFFSET (PCI_COMMON_CONFIG, Status)
            );
    }

    ExFreePool (WorkingPool);
    return status;
}

VOID
HalpGetNMICrashFlag (
    VOID
    )
{
    UNICODE_STRING    unicodeString, NMICrashDumpName;
    OBJECT_ATTRIBUTES objectAttributes;
    HANDLE            hCrashControl;
    UCHAR             buffer [sizeof(PPCI_REGISTRY_INFO) + 99];
    ULONG             rsize;
    NTSTATUS          status;
    extern BOOLEAN    HalpNMIDumpFlag;

    //
    // Open Crash Control Registry Key
    //

    RtlInitUnicodeString (&unicodeString, L"\\Registry\\Machine\\System\\CurrentControlSet\\Control\\CrashControl");

    InitializeObjectAttributes (
        &objectAttributes,
        &unicodeString,
        OBJ_CASE_INSENSITIVE,
        NULL,       // handle
        NULL);

    HalpNMIDumpFlag = FALSE;

    status = ZwOpenKey (&hCrashControl, KEY_READ, &objectAttributes);

    if (NT_SUCCESS(status)) {

        //
        // Look for NMICrashDump Value
        //

        RtlInitUnicodeString (&NMICrashDumpName, L"NMICrashDump");

        status = ZwQueryValueKey (
                    hCrashControl,
                    &NMICrashDumpName,
                    KeyValuePartialInformation,
                    (PKEY_VALUE_PARTIAL_INFORMATION) buffer,
                    sizeof (buffer),
                    &rsize
                    );

        if ((NT_SUCCESS (status)) && (rsize == FIELD_OFFSET(KEY_VALUE_PARTIAL_INFORMATION, Data[0]) + sizeof(ULONG))) {
            HalpNMIDumpFlag = (BOOLEAN)(((PKEY_VALUE_PARTIAL_INFORMATION)buffer)->Data[0]);
        }

        ZwClose (hCrashControl);
    }
}

#ifndef ACPI_HAL
#define PciBridgeSwizzle(device, pin)       \
    ((((pin - 1) + device) % 4) + 1)

#define PCIPin2Int(Slot,Pin)                                                \
                     ((((Slot.u.bits.DeviceNumber << 2) | (Pin-1)) != 0) ?  \
                      (Slot.u.bits.DeviceNumber << 2) | (Pin-1) : 0x80);

#define PCIInt2Pin(interrupt)                                               \
            ((interrupt & 0x3) + 1)

#define PCIInt2Slot(interrupt)                                              \
            ((interrupt  & 0x7f ) >> 2)

NTSTATUS
HalIrqTranslateRequirementsPciBridge(
    IN PVOID Context,
    IN PIO_RESOURCE_DESCRIPTOR Source,
    IN PDEVICE_OBJECT PhysicalDeviceObject,
    OUT PULONG TargetCount,
    OUT PIO_RESOURCE_DESCRIPTOR *Target
    )
/*++

Routine Description:

    This function translates IRQ resource requirements to
    the parent PCI bus.  This is only to be used for devices
    on a PCI bus created by a PCI to PCI bridge where there
    is no other mechanism for determining the interrupt
    routing exists.  (i.e. this bus is generated by a
    plug-in bridge.)

Arguments:

    Context  - must hold the slot number of the bridge


Return Value:

    STATUS_SUCCESS, so long as we can allocate the necessary
    memory

--*/
{
    PIO_RESOURCE_DESCRIPTOR target;
    PCI_SLOT_NUMBER         bridgeSlot;
    NTSTATUS                status;
    ULONG                   bridgePin;
    ULONG                   pciBusNumber;
    PCI_SLOT_NUMBER         pciSlot;
    UCHAR                   interruptLine;
    UCHAR                   interruptPin;
    UCHAR                   dummy;
    PDEVICE_OBJECT          parentPdo;
    ROUTING_TOKEN           routingToken;

    PAGED_CODE();
    ASSERT(Source->Type == CmResourceTypeInterrupt);
    ASSERT(Source->u.Interrupt.MinimumVector == Source->u.Interrupt.MaximumVector);

    target = ExAllocatePoolWithTag(PagedPool,
                                   sizeof(IO_RESOURCE_DESCRIPTOR),
                                   HAL_POOL_TAG);

    if (!target) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Copy the source to fill in all the relevant fields.
    //

    *target = *Source;

    status = PciIrqRoutingInterface.GetInterruptRouting(
                PhysicalDeviceObject,
                &pciBusNumber,
                &pciSlot.u.AsULONG,
                &interruptLine,
                &interruptPin,
                &dummy,
                &dummy,
                &parentPdo,
                &routingToken,
                &dummy
                );

    ASSERT(NT_SUCCESS(status));

    //
    // Find the translated IRQ.
    //

    bridgeSlot.u.AsULONG = 0;
    bridgeSlot.u.bits.DeviceNumber = (ULONG)Context;

    bridgePin = PciBridgeSwizzle(PCIInt2Slot(Source->u.Interrupt.MinimumVector),
                                 PCIInt2Pin(Source->u.Interrupt.MinimumVector));

    //
    // The translated value is the the "PCI INT" of the pin
    // on the bridge.
    //

    target->u.Interrupt.MinimumVector =
        PCIPin2Int(bridgeSlot, bridgePin);

    target->u.Interrupt.MaximumVector = target->u.Interrupt.MinimumVector;

    *TargetCount = 1;
    *Target = target;

    return STATUS_SUCCESS;
}

NTSTATUS
HalIrqTranslateResourcesPciBridge(
    IN PVOID Context,
    IN PCM_PARTIAL_RESOURCE_DESCRIPTOR Source,
    IN RESOURCE_TRANSLATION_DIRECTION Direction,
    IN ULONG AlternativesCount, OPTIONAL
    IN IO_RESOURCE_DESCRIPTOR Alternatives[], OPTIONAL
    IN PDEVICE_OBJECT PhysicalDeviceObject,
    OUT PCM_PARTIAL_RESOURCE_DESCRIPTOR Target
    )
/*++

Routine Description:

    This function translates IRQ resources to and from
    the parent PCI bus.  This is only to be used for devices
    on a PCI bus created by a PCI to PCI bridge where there
    is no other mechanism for determining the interrupt
    routing exists.  (i.e. this bus is generated by a
    plug-in bridge.)

Arguments:

    Context  - must hold the slot number of the bridge


Return Value:

    STATUS_SUCCESS

--*/
{
    PCI_SLOT_NUMBER         bridgeSlot, deviceSlot, childSlot;
    ULONG                   bridgePin;
    ULONG                   pciBusNumber, targetPciBusNumber, bridgeBusNumber;
    UCHAR                   interruptPin;
    UCHAR                   dummy;
    PDEVICE_OBJECT          parentPdo;
    ROUTING_TOKEN           routingToken;
    NTSTATUS                status;
    UCHAR                   buffer[PCI_COMMON_HDR_LENGTH];
    PPCI_COMMON_CONFIG      pciData;
    ULONG                   d, f;
    PBUS_HANDLER            busHandler;

    PAGED_CODE();
    ASSERT(Source->Type == CmResourceTypeInterrupt);
    ASSERT(Source->u.Interrupt.Vector == Source->u.Interrupt.Level);
    ASSERT(PciIrqRoutingInterface.GetInterruptRouting);

    *Target = *Source;

    status = PciIrqRoutingInterface.GetInterruptRouting(
                PhysicalDeviceObject,
                &pciBusNumber,
                &deviceSlot.u.AsULONG,
                &dummy,
                &interruptPin,
                &dummy,
                &dummy,
                &parentPdo,
                &routingToken,
                &dummy
                );

    ASSERT(NT_SUCCESS(status));

    switch (Direction) {
    case TranslateChildToParent:

        //
        // Find the translated IRQ.
        //

        bridgeSlot.u.AsULONG = 0;
        bridgeSlot.u.bits.DeviceNumber = (ULONG_PTR)Context & 0xffff;

        bridgePin = PciBridgeSwizzle(PCIInt2Slot(Source->u.Interrupt.Vector),
                                     PCIInt2Pin(Source->u.Interrupt.Vector));

        //
        // The translated value is the the "PCI INT" of the pin
        // on the bridge.
        //

        Target->u.Interrupt.Vector =
            PCIPin2Int(bridgeSlot, bridgePin);

        Target->u.Interrupt.Level = Target->u.Interrupt.Vector;

        //
        // The affinity should have been inherited from Source
        // and it should be non-zero.
        //

        ASSERT(Target->u.Interrupt.Affinity != 0);

        break;

    case TranslateParentToChild:

        //
        // The child-relative representation of Vector and Level
        // is from the MPS spec.  And we need to know the device
        // number and interrupt pin value.
        //

        //
        // TEMPTEMP Use bushandlers until HALMPS is rid of them.
        //

        pciData = (PPCI_COMMON_CONFIG)&buffer;

        bridgeBusNumber = ((ULONG_PTR)Context >> 16) & 0xffff;
        busHandler = HaliHandlerForBus(PCIBus, bridgeBusNumber);
        bridgeSlot.u.AsULONG =  (ULONG_PTR)Context & 0xffff;

        HalpReadPCIConfig(busHandler,
                          bridgeSlot,
                          pciData,
                          0,
                          PCI_COMMON_HDR_LENGTH);

        if (pciData->u.type1.SecondaryBus == pciBusNumber) {

            //
            // This device is sitting on the bus that we are translating
            // into.  So create a vector based on the address of this device.
            //   (Are we at the bottom of the translation?)
            //

            Target->u.Interrupt.Vector = PCIPin2Int(deviceSlot, interruptPin);
            Target->u.Interrupt.Level = Target->u.Interrupt.Vector;

            return STATUS_SUCCESS;

        } else {

            //
            // This device is not sitting on the bus that we are translating
            // into.  This device must be a (grand) child of another bridge that
            // sits on this bus.  And that bridge will have our device's bus
            // within its Subordinate bus register.
            //

            targetPciBusNumber = pciData->u.type1.SecondaryBus;
            bridgeSlot.u.AsULONG = 0;

            for (d = 0; d < PCI_MAX_DEVICES; d++) {
                for (f = 0; f < PCI_MAX_FUNCTION; f++) {

                    bridgeSlot.u.bits.DeviceNumber = d;
                    bridgeSlot.u.bits.FunctionNumber = f;

                    busHandler = HaliHandlerForBus(PCIBus, targetPciBusNumber);
                    HalpReadPCIConfig(busHandler,
                                      bridgeSlot,
                                      pciData,
                                      0,
                                      PCI_COMMON_HDR_LENGTH);

                    if ((PCI_CONFIGURATION_TYPE(pciData) == PCI_BRIDGE_TYPE) ||
                        (PCI_CONFIGURATION_TYPE(pciData) == PCI_CARDBUS_BRIDGE_TYPE)) {

                        //
                        // This is a bridge.  Check the subordinate bus.
                        //

                        if (pciData->u.type1.SubordinateBus >= pciBusNumber) {

                            //
                            // Now we know the device number of the bridge on this
                            // bus that applies to this translation.  We still need
                            // to know what pin will be triggered.  To know that,
                            // we have to look one more bus down.
                            //
                            // There are two cases:
                            //
                            // 1)  The next bus down contains the device.
                            //
                            // 2)  The next bus down contains another bridge.
                            //
                            //

                            if (pciData->u.type1.SecondaryBus == pciBusNumber) {

                                //
                                // This is case 1).
                                //

                                interruptPin = (UCHAR)PciBridgeSwizzle(deviceSlot.u.bits.DeviceNumber,
                                                                       interruptPin);

                            } else {

                                //
                                // This is case 2).
                                //
                                // Technically, to get the right answer, we would have to
                                // figure out which pin the bridge is going to trigger.  But
                                // to do that, we would have to scan down busses until we found
                                // the device.  And the information gathered on that little
                                // journey would never get used.
                                //

                                interruptPin = 1;
                            }


                            Target->u.Interrupt.Vector = PCIPin2Int(bridgeSlot, interruptPin);
                            Target->u.Interrupt.Level = Target->u.Interrupt.Vector;

                            return STATUS_SUCCESS;
                        }
                    }
                }
            }
        }

        return STATUS_NOT_FOUND;
    }

    return STATUS_SUCCESS;
}
#endif

#if DBG
VOID
HalpTestPci (ULONG flag2)
{
    PCI_SLOT_NUMBER     SlotNumber;
    PCI_COMMON_CONFIG   PciData, OrigData;
    ULONG               i, f, j, k, bus;
    BOOLEAN             flag;


    if (!flag2) {
        return ;
    }

    DbgBreakPoint ();
    SlotNumber.u.bits.Reserved = 0;

    //
    // Read every possible PCI Device/Function and display it's
    // default info.
    //
    // (note this destories it's current settings)
    //

    flag = TRUE;
    for (bus = 0; flag; bus++) {

        for (i = 0; i < PCI_MAX_DEVICES; i++) {
            SlotNumber.u.bits.DeviceNumber = i;

            for (f = 0; f < PCI_MAX_FUNCTION; f++) {
                SlotNumber.u.bits.FunctionNumber = f;

                //
                // Note: This is reading the DeviceSpecific area of
                // the device's configuration - normally this should
                // only be done on device for which the caller understands.
                // I'm doing it here only for debugging.
                //

                j = HalGetBusData (
                    PCIConfiguration,
                    bus,
                    SlotNumber.u.AsULONG,
                    &PciData,
                    sizeof (PciData)
                    );

                if (j == 0) {
                    // out of buses
                    flag = FALSE;
                    break;
                }

                if (j < PCI_COMMON_HDR_LENGTH) {
                    continue;
                }

                HalSetBusData (
                    PCIConfiguration,
                    bus,
                    SlotNumber.u.AsULONG,
                    &PciData,
                    1
                    );

                HalGetBusData (
                    PCIConfiguration,
                    bus,
                    SlotNumber.u.AsULONG,
                    &PciData,
                    sizeof (PciData)
                    );

#if 0
                memcpy (&OrigData, &PciData, sizeof PciData);

                for (j=0; j < PCI_TYPE0_ADDRESSES; j++) {
                    PciData.u.type0.BaseAddresses[j] = 0xFFFFFFFF;
                }

                PciData.u.type0.ROMBaseAddress = 0xFFFFFFFF;

                HalSetBusData (
                    PCIConfiguration,
                    bus,
                    SlotNumber.u.AsULONG,
                    &PciData,
                    sizeof (PciData)
                    );

                HalGetBusData (
                    PCIConfiguration,
                    bus,
                    SlotNumber.u.AsULONG,
                    &PciData,
                    sizeof (PciData)
                    );
#endif

                DbgPrint ("PCI Bus %d Slot %2d %2d  ID:%04lx-%04lx  Rev:%04lx",
                    bus, i, f, PciData.VendorID, PciData.DeviceID,
                    PciData.RevisionID);


                if (PciData.u.type0.InterruptPin) {
                    DbgPrint ("  IntPin:%x", PciData.u.type0.InterruptPin);
                }

                if (PciData.u.type0.InterruptLine) {
                    DbgPrint ("  IntLine:%x", PciData.u.type0.InterruptLine);
                }

                if (PciData.u.type0.ROMBaseAddress) {
                        DbgPrint ("  ROM:%08lx", PciData.u.type0.ROMBaseAddress);
                }

                DbgPrint ("\n    Cmd:%04x  Status:%04x  ProgIf:%04x  SubClass:%04x  BaseClass:%04lx\n",
                    PciData.Command, PciData.Status, PciData.ProgIf,
                     PciData.SubClass, PciData.BaseClass);

                k = 0;
                for (j=0; j < PCI_TYPE0_ADDRESSES; j++) {
                    if (PciData.u.type0.BaseAddresses[j]) {
                        DbgPrint ("  Ad%d:%08lx", j, PciData.u.type0.BaseAddresses[j]);
                        k = 1;
                    }
                }

#if 0
                if (PciData.u.type0.ROMBaseAddress == 0xC08001) {

                    PciData.u.type0.ROMBaseAddress = 0xC00001;
                    HalSetBusData (
                        PCIConfiguration,
                        bus,
                        SlotNumber.u.AsULONG,
                        &PciData,
                        sizeof (PciData)
                        );

                    HalGetBusData (
                        PCIConfiguration,
                        bus,
                        SlotNumber.u.AsULONG,
                        &PciData,
                        sizeof (PciData)
                        );

                    DbgPrint ("\n  Bogus rom address, edit yields:%08lx",
                        PciData.u.type0.ROMBaseAddress);
                }
#endif

                if (k) {
                    DbgPrint ("\n");
                }

                if (PciData.VendorID == 0x8086) {
                    // dump complete buffer
                    DbgPrint ("Command %x, Status %x, BIST %x\n",
                        PciData.Command, PciData.Status,
                        PciData.BIST
                        );

                    DbgPrint ("CacheLineSz %x, LatencyTimer %x",
                        PciData.CacheLineSize, PciData.LatencyTimer
                        );

                    for (j=0; j < 192; j++) {
                        if ((j & 0xf) == 0) {
                            DbgPrint ("\n%02x: ", j + 0x40);
                        }
                        DbgPrint ("%02x ", PciData.DeviceSpecific[j]);
                    }
                    DbgPrint ("\n");
                }


#if 0
                //
                // now print original data
                //

                if (OrigData.u.type0.ROMBaseAddress) {
                        DbgPrint (" oROM:%08lx", OrigData.u.type0.ROMBaseAddress);
                }

                DbgPrint ("\n");
                k = 0;
                for (j=0; j < PCI_TYPE0_ADDRESSES; j++) {
                    if (OrigData.u.type0.BaseAddresses[j]) {
                        DbgPrint (" oAd%d:%08lx", j, OrigData.u.type0.BaseAddresses[j]);
                        k = 1;
                    }
                }

                //
                // Restore original settings
                //

                HalSetBusData (
                    PCIConfiguration,
                    bus,
                    SlotNumber.u.AsULONG,
                    &OrigData,
                    sizeof (PciData)
                    );
#endif

                //
                // Next
                //

                if (k) {
                    DbgPrint ("\n\n");
                }
            }
        }
    }
    DbgBreakPoint ();
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halx86\i386\ixnmi.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    ixnmi.c

Abstract:

    Provides standard x86 NMI handler

Author:

    kenr

Revision History:

--*/
#include "halp.h"
#include "bugcodes.h"
#include "inbv.h"

#define SYSTEM_CONTROL_PORT_A        0x92
#define SYSTEM_CONTROL_PORT_B        0x61
#define EISA_EXTENDED_NMI_STATUS    0x461

const UCHAR EisaNMIMsg[] = MSG_NMI_EISA_IOCHKERR;

// The IRET performed in HalpBiosCall() called from HalpBiosDisplayReset()
// under HalpDisplayString() allows a second NMI to occur. 
// This ends up causing a trap 0d because the NMI TSS is busy.  Because
// the normal trap 0d handler attempts to bugcheck which trashes the screen,
// this flag (HalpNMIInProgress) tells HalpBiosDisplayReset() to leave its
// trap 0d handler in place which will then just spin on a jump to self if
// a second NMI occurs.

volatile ULONG  HalpNMIInProgress;

BOOLEAN HalpNMIDumpFlag;

VOID
HalHandleNMI(
    IN OUT PVOID NmiInfo
    )
/*++

Routine Description:

    Called DURING an NMI.  The system will BugCheck when an NMI occurs.
    This function can return the proper bugcheck code, bugcheck itself,
    or return success which will cause the system to iret from the nmi.

    This function is called during an NMI - no system services are available.
    In addition, you don't want to touch any spinlock which is normally
    used since we may have been interrupted while owning it, etc, etc...

Warnings:

    Do NOT:
      Make any system calls
      Attempt to acquire any spinlock used by any code outside the NMI handler
      Change the interrupt state.  Do not execute any IRET inside this code

    Passing data to non-NMI code must be done using manual interlocked
    functions.  (xchg instructions).

Arguments:

    NmiInfo - Pointer to NMI information structure  (TBD)
            - NULL means no NMI information structure was passed

Return Value:

    BugCheck code

--*/
{
    UCHAR   StatusByte;
    UCHAR   EisaPort;
    UCHAR   c;
    ULONG   port, i;


#ifndef NT_UP

#if defined(_AMD64_)
    static ULONG NMILock;
    while (InterlockedCompareExchange(&NMILock,1,0) != 0) {
    };
#else
static volatile ULONG  NMILock;

    _asm {
LockNMILock:
    lock    bts NMILock, 0
    jc      LockNMILock
    }
#endif

    if (HalpNMIInProgress == 0) {
#endif
        HalpNMIInProgress++;

        StatusByte = READ_PORT_UCHAR((PUCHAR) SYSTEM_CONTROL_PORT_B);

        //
        // Enable InbvDisplayString calls to make it through to bootvid driver.
        //
        
        if (InbvIsBootDriverInstalled()) {
        
            InbvAcquireDisplayOwnership();
        
            InbvResetDisplay();
            InbvSolidColorFill(0,0,639,479,4); // make the screen blue
            InbvSetTextColor(15);
            InbvInstallDisplayStringFilter((INBV_DISPLAY_STRING_FILTER)NULL);
            InbvEnableDisplayString(TRUE);     // enable display string
            InbvSetScrollRegion(0,0,639,479);  // set to use entire screen
        }
        
        HalDisplayString (MSG_HARDWARE_ERROR1);
        HalDisplayString (MSG_HARDWARE_ERROR2);
    
        if (StatusByte & 0x80) {
            HalDisplayString (MSG_NMI_PARITY);
        } 

        if (StatusByte & 0x40) {
            HalDisplayString (MSG_NMI_CHANNEL_CHECK);
        }
    
        if (HalpBusType == MACHINE_TYPE_EISA) {
            //
            // This is an Eisa machine, check for extnded nmi information...
            //
    
            StatusByte = READ_PORT_UCHAR((PUCHAR) EISA_EXTENDED_NMI_STATUS);
    
            if (StatusByte & 0x80) {
                HalDisplayString (MSG_NMI_FAIL_SAFE);
            }
    
            if (StatusByte & 0x40) {
                HalDisplayString (MSG_NMI_BUS_TIMEOUT);
            }
    
            if (StatusByte & 0x20) {
                HalDisplayString (MSG_NMI_SOFTWARE_NMI);
            }
    
            //
            // Look for any Eisa expansion board.  See if it asserted NMI.
            //
    
            for (EisaPort = 1; EisaPort <= 0xf; EisaPort++) {
                port = (EisaPort << 12) + 0xC80;
                WRITE_PORT_UCHAR ((PUCHAR) (ULONG_PTR)port, 0xff);
                StatusByte = READ_PORT_UCHAR ((PUCHAR) (ULONG_PTR)port);
    
                if ((StatusByte & 0x80) == 0) {
                    //
                    // Found valid Eisa board,  Check to see if it's
                    // if IOCHKERR is asserted.
                    //
    
                    StatusByte = READ_PORT_UCHAR ((PUCHAR) (ULONG_PTR)port+4);
                    if (StatusByte & 0x2  &&  StatusByte != 0xff) {
                        UCHAR Msg[sizeof(EisaNMIMsg)];

                        RtlCopyMemory(Msg, EisaNMIMsg, sizeof(Msg));
                        c = (EisaPort > 9 ? 'A'-10 : '0') + EisaPort;
                        for (i=0; Msg[i]; i++) {
                            if (Msg[i] == '%') {
                                Msg[i] = c;
                                break;
                            }
                        }
                        HalDisplayString (Msg);
                    }
                }
            }
        }

        HalDisplayString (MSG_HALT);

        if (HalpNMIDumpFlag) {
            KeBugCheckEx(NMI_HARDWARE_FAILURE,(ULONG)'ODT',0,0,0);
        }

#ifndef NT_UP
    }

    NMILock = 0;         
#endif

    if ((*((PBOOLEAN)(*(PLONG_PTR)&KdDebuggerNotPresent)) == FALSE) &&
        (**((PUCHAR *)&KdDebuggerEnabled) != FALSE)) {
        KeEnterKernelDebugger();
    }

    while(TRUE) {
        // Just sit here so that screen does not get corrupted.
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halx86\i386\ixpcisup.c ===
/*++


Copyright (c) 1989  Microsoft Corporation

Module Name:

    ixpcisup.c

Abstract:

    Support functions for doing PCI the bus-handler
    way.

Author:

    Ken Reneris (kenr) 14-June-1994

Environment:

    Kernel mode

Revision History:

    Moved code into this file so that it would be
    easier to build a non-bus-handler HAL.  This
    file will only be compiled into HALs that
    use bus handlers.  -- Jake Oshins 2-Dec-1997

--*/

#include "halp.h"
#include "pci.h"
#include "pcip.h"
#include "chiphacks.h"

BOOLEAN
HalpIsIdeDevice(
    IN PPCI_COMMON_CONFIG PciData
    );

VOID
HalpGetNMICrashFlag (
    VOID
    );

extern BOOLEAN HalpDisableHibernate;

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT,HalpInitializePciBus)
#pragma alloc_text(INIT,HalpIsIdeDevice)
#pragma alloc_text(INIT,HalpAllocateAndInitPciBusHandler)
#endif

VOID
HalpInitializePciBus (
    VOID
    )
{
    PPCI_REGISTRY_INFO_INTERNAL  PCIRegInfo;
    ULONG                        i, d, HwType, BusNo, f;
    PBUS_HANDLER                 BusHandler;
    PCI_SLOT_NUMBER              SlotNumber;
    PPCI_COMMON_CONFIG           PciData;
    UCHAR                        iBuffer[PCI_COMMON_HDR_LENGTH + sizeof(TYPE2EXTRAS)];
    ULONG                        OPBNumber;
    BOOLEAN                      OPBA2B0Found, COPBInbPostingEnabled;
    UCHAR                        buffer [4];
    BOOLEAN                      fullDecodeChipset = FALSE;
    NTSTATUS                     Status;
    ULONG                        flags;

    PCIRegInfo = HalpQueryPciRegistryInfo();

    if (!PCIRegInfo) {
        return;
    }

    //
    // Initialize spinlock for synchronizing access to PCI space
    //

    KeInitializeSpinLock (&HalpPCIConfigLock);
    PciData = (PPCI_COMMON_CONFIG) iBuffer;

    //
    // PCIRegInfo describes the system's PCI support as indicated by the BIOS.
    //

    HwType = PCIRegInfo->HardwareMechanism & 0xf;

    //
    // Some AMI bioses claim machines are Type2 configuration when they
    // are really type1.   If this is a Type2 with at least one bus,
    // try to verify it's not really a type1 bus
    //

    if (PCIRegInfo->NoBuses  &&  HwType == 2) {

        //
        // Check each slot for a valid device.  Which every style configuration
        // space shows a valid device first will be used
        //

        SlotNumber.u.bits.Reserved = 0;
        SlotNumber.u.bits.FunctionNumber = 0;

        for (d = 0; d < PCI_MAX_DEVICES; d++) {
            SlotNumber.u.bits.DeviceNumber = d;

            //
            // First try what the BIOS claims - type 2.  Allocate type2
            // test handle for PCI bus 0.
            //

            HwType = 2;
            BusHandler = HalpAllocateAndInitPciBusHandler (HwType, 0, TRUE);

            if (!BusHandler) {
                break;
            }

            if (HalpIsValidPCIDevice (BusHandler, SlotNumber)) {
                break;
            }

            //
            // Valid device not found on Type2 access for this slot.
            // Reallocate the bus handler are Type1 and take a look.
            //

            HwType = 1;
            BusHandler = HalpAllocateAndInitPciBusHandler (HwType, 0, TRUE);

            if (HalpIsValidPCIDevice (BusHandler, SlotNumber)) {
                break;
            }

            HwType = 2;
        }

        //
        // Reset handler for PCI bus 0 to whatever style config space
        // was finally decided.
        //

        HalpAllocateAndInitPciBusHandler (HwType, 0, FALSE);
    }


    //
    // For each PCI bus present, allocate a handler structure and
    // fill in the dispatch functions
    //

    do {
        for (i=0; i < PCIRegInfo->NoBuses; i++) {

            //
            // If handler not already built, do it now
            //

            if (!HalpHandlerForBus (PCIBus, i)) {
                HalpAllocateAndInitPciBusHandler (HwType, i, FALSE);
            }
        }

        //
        // Bus handlers for all PCI buses have been allocated, go collect
        // pci bridge information.
        //

    } while (HalpGetPciBridgeConfig (HwType, &PCIRegInfo->NoBuses)) ;

    //
    // Fixup SUPPORTED_RANGES
    //

    HalpFixupPciSupportedRanges (PCIRegInfo->NoBuses);


    //
    // Look for PCI controllers which have known work-arounds, and make
    // sure they are applied.
    //
    // In addition, fill in the bitmask HalpPciIrqMask with all the
    // interrupts that PCI devices might use.
    //

    OPBNumber = 0;
    OPBA2B0Found = FALSE;
    COPBInbPostingEnabled = FALSE;

    SlotNumber.u.bits.Reserved = 0;
    for (BusNo=0; BusNo < PCIRegInfo->NoBuses; BusNo++) {
        BusHandler = HalpHandlerForBus (PCIBus, BusNo);

        for (d = 0; d < PCI_MAX_DEVICES; d++) {
            SlotNumber.u.bits.DeviceNumber = d;

            for (f = 0; f < PCI_MAX_FUNCTION; f++) {
                SlotNumber.u.bits.FunctionNumber = f;

                //
                // Read PCI configuration information
                //

                HalpReadPCIConfig (BusHandler, SlotNumber, PciData, 0, PCI_COMMON_HDR_LENGTH);

                if (*((PULONG)(PciData)) == 0xffffffff) {
                    continue;
                }

                if (PCI_CONFIGURATION_TYPE(PciData) == PCI_CARDBUS_BRIDGE_TYPE) {

                    HalpReadPCIConfig(
                        BusHandler,
                        SlotNumber,
                        PciData+1,
                        FIELD_OFFSET(PCI_COMMON_CONFIG, DeviceSpecific),
                        sizeof(TYPE2EXTRAS)
                        );
                }

#ifndef SUBCLASSPCI
                //
                // Look at interrupt line register and fill in HalpPciIrqMask,
                // but not for an IDE controller, as IDE controllers really
                // trigger interrupts like ISA devices.
                //
                if (PCI_CONFIGURATION_TYPE(PciData) != 1) {
                    if ((PciData->u.type0.InterruptPin != 0) &&
                        (PciData->u.type0.InterruptLine != 0) &&
                        (PciData->u.type0.InterruptLine < PIC_VECTORS) &&
                        !HalpIsIdeDevice(PciData)) {

                        HalpPciIrqMask |= 1 << PciData->u.type0.InterruptLine;
                    }
                }
#endif
                //
                // Check for chips with known work-arounds to apply
                //

                if (PciData->VendorID == 0x8086  &&
                    PciData->DeviceID == 0x04A3  &&
                    PciData->RevisionID < 0x11) {

                    //
                    // 82430 PCMC controller
                    //

                    HalpReadPCIConfig (BusHandler, SlotNumber, buffer, 0x53, 2);

                    buffer[0] &= ~0x08;     // turn off bit 3 register 0x53

                    if (PciData->RevisionID == 0x10) {  // on rev 0x10, also turn
                        buffer[1] &= ~0x01;             // bit 0 register 0x54
                    }

                    HalpWritePCIConfig (BusHandler, SlotNumber, buffer, 0x53, 2);
                }

                if (PciData->VendorID == 0x8086  &&
                    PciData->DeviceID == 0x0484  &&
                    PciData->RevisionID <= 3) {

                    //
                    // 82378 ISA bridge & SIO
                    //

                    HalpReadPCIConfig (BusHandler, SlotNumber, buffer, 0x41, 1);

                    buffer[0] &= ~0x1;      // turn off bit 0 register 0x41

                    HalpWritePCIConfig (BusHandler, SlotNumber, buffer, 0x41, 1);
                }

                //
                // Look for Orion PCI Bridge
                //

                if (PciData->VendorID == 0x8086 &&
                    PciData->DeviceID == 0x84c4 ) {

                    //
                    // 82450 Orion PCI Bridge Workaround
                    // Need a workaround if following conditions are true:
                    // i) 2 OPBs present
                    // ii)There is an A2/B0 step OPB present.
                    // iii) Inbound posting on the compatibility OPB is
                    //      enabled.
                    // NOTE: Inbound Posting on the non-compatibility OPB
                    // MUST BE disabled by BIOS
                    //

                    OPBNumber += 1;

                    if (PciData->RevisionID <= 4) {
                        OPBA2B0Found = TRUE;
                    }

                    if (SlotNumber.u.bits.DeviceNumber == (0xc8>>3)) {

                        // Found compatibility OPB. Determine if the compatibility
                        // OPB has inbound posting enabled by testing bit 0 of reg 54

                        HalpReadPCIConfig (BusHandler, SlotNumber, buffer, 0x54, 2);
                        COPBInbPostingEnabled = (buffer[0] & 0x1) ? TRUE : FALSE;

                    } else {

                        // The compatibility OPB ALWAYS has a device
                        // number 0xc8. Save the ncOPB slot number
                        // and BusHandler

                        HalpOrionOPB.Slot = SlotNumber;
                        HalpOrionOPB.Handler = BusHandler;
                    }
                }

                //
                // Check the list for host bridges who's existance will mark a
                // chipset as 16bit decode. We use this to cover for BIOS
                // writers who list "fixed" PnPBIOS resources without noticing
                // that such a descriptor implies their device is 10bit decode.
                //

                if ((!fullDecodeChipset) &&
                    HalpIsRecognizedCard(PCIRegInfo, PciData,
                                         PCIFT_FULLDECODE_HOSTBRIDGE)) {

                    fullDecodeChipset = TRUE;
                }

                //
                // Look for ICH, or any other Intel or VIA UHCI USB controller.
                //

                if ((PciData->BaseClass == PCI_CLASS_SERIAL_BUS_CTLR) &&
                    (PciData->SubClass == PCI_SUBCLASS_SB_USB) &&
                    (PciData->ProgIf == 0x00)) {
                    if (PciData->VendorID == 0x8086) {

                        HalpStopUhciInterrupt(BusNo,
                                              SlotNumber,
                                              TRUE);

                    } else if (PciData->VendorID == 0x1106) {

                        HalpStopUhciInterrupt(BusNo,
                                              SlotNumber,
                                              FALSE);

                    }
                }

                //
                // Look for an OHCI-compliant USB controller.
                //

                if ((PciData->BaseClass == PCI_CLASS_SERIAL_BUS_CTLR) &&
                    (PciData->SubClass == PCI_SUBCLASS_SB_USB) &&
                    (PciData->ProgIf == 0x10)) {

                    HalpStopOhciInterrupt(BusNo,
                                          SlotNumber);
                }

                Status = HalpGetChipHacks(PciData->VendorID,
                                          PciData->DeviceID,
                                          PciData->RevisionID,
                                          &flags);

                if (NT_SUCCESS(Status)) {

                    if (flags & DISABLE_HIBERNATE_HACK_FLAG) {
                        HalpDisableHibernate = TRUE;
                    }

                    if (flags & WHACK_ICH_USB_SMI_HACK_FLAG) {
                        HalpWhackICHUsbSmi(BusNo, SlotNumber);
                    }
                }

            }   // next function
        }   // next device
    }   // next bus

    //
    // Is Orion B0 workaround needed?
    //

    if (OPBNumber >= 2 && OPBA2B0Found && COPBInbPostingEnabled) {

        //
        // Replace synchronization functions with Orion specific functions
        //

        ASSERT (PCIConfigHandler.Synchronize == HalpPCISynchronizeType1);
        MmLockPagableCodeSection (&HalpPCISynchronizeOrionB0);
        PCIConfigHandler.Synchronize = HalpPCISynchronizeOrionB0;
        PCIConfigHandler.ReleaseSynchronzation = HalpPCIReleaseSynchronzationOrionB0;
    }

    //
    // Check if we should crashdump on NMI.
    //

    HalpGetNMICrashFlag();

#if DBG
    HalpTestPci (0);
#endif

    //
    // Mark the chipset appropriately.
    //
    HalpMarkChipsetDecode(fullDecodeChipset);

    ExFreePool(PCIRegInfo);
}

PBUS_HANDLER
HalpAllocateAndInitPciBusHandler (
    IN ULONG        HwType,
    IN ULONG        BusNo,
    IN BOOLEAN      TestAllocation
    )
{
    PBUS_HANDLER    Bus;
    PPCIPBUSDATA    BusData;

    Bus = HalpAllocateBusHandler (
                PCIBus,                 // Interface type
                PCIConfiguration,       // Has this configuration space
                BusNo,                  // bus #
                Internal,               // child of this bus
                0,                      //      and number
                sizeof (PCIPBUSDATA)    // sizeof bus specific buffer
                );

    if (!Bus) {
        return NULL;
    }
    
    //
    // Fill in PCI handlers
    //

    Bus->GetBusData = (PGETSETBUSDATA) HalpGetPCIData;
    Bus->SetBusData = (PGETSETBUSDATA) HalpSetPCIData;
    Bus->GetInterruptVector  = (PGETINTERRUPTVECTOR) HalpGetPCIIntOnISABus;
    Bus->AdjustResourceList  = (PADJUSTRESOURCELIST) HalpAdjustPCIResourceList;
    Bus->AssignSlotResources = (PASSIGNSLOTRESOURCES) HalpAssignPCISlotResources;
    Bus->BusAddresses->Dma.Limit = 0;

    BusData = (PPCIPBUSDATA) Bus->BusData;

    //
    // Fill in common PCI data
    //

    BusData->CommonData.Tag         = PCI_DATA_TAG;
    BusData->CommonData.Version     = PCI_DATA_VERSION;
    BusData->CommonData.ReadConfig  = (PciReadWriteConfig) HalpReadPCIConfig;
    BusData->CommonData.WriteConfig = (PciReadWriteConfig) HalpWritePCIConfig;
    BusData->CommonData.Pin2Line    = (PciPin2Line) HalpPCIPin2ISALine;
    BusData->CommonData.Line2Pin    = (PciLine2Pin) HalpPCIISALine2Pin;

    //
    // Set defaults
    //

    BusData->MaxDevice   = PCI_MAX_DEVICES;
    BusData->GetIrqRange = (PciIrqRange) HalpGetISAFixedPCIIrq;

    RtlInitializeBitMap (&BusData->DeviceConfigured,
                BusData->ConfiguredBits, 256);

    switch (HwType) {
        case 1:
            //
            // Initialize access port information for Type1 handlers
            //

            RtlCopyMemory (&PCIConfigHandler,
                           &PCIConfigHandlerType1,
                           sizeof (PCIConfigHandler));

            BusData->Config.Type1.Address = (PULONG)PCI_TYPE1_ADDR_PORT;
            BusData->Config.Type1.Data    = PCI_TYPE1_DATA_PORT;
            break;

        case 2:
            //
            // Initialize access port information for Type2 handlers
            //

            RtlCopyMemory (&PCIConfigHandler,
                           &PCIConfigHandlerType2,
                           sizeof (PCIConfigHandler));

            BusData->Config.Type2.CSE     = PCI_TYPE2_CSE_PORT;
            BusData->Config.Type2.Forward = PCI_TYPE2_FORWARD_PORT;
            BusData->Config.Type2.Base    = PCI_TYPE2_ADDRESS_BASE;

            //
            // Early PCI machines didn't decode the last bit of
            // the device id.  Shrink type 2 support max device.
            //
            BusData->MaxDevice            = 0x10;

            break;

        default:
            // unsupport type
            DBGMSG ("HAL: Unkown PCI type\n");
    }

    if (!TestAllocation) {
#ifdef SUBCLASSPCI
        HalpSubclassPCISupport (Bus, HwType);
#endif
    }

    return Bus;
}

BOOLEAN
HalpIsIdeDevice(
    IN PPCI_COMMON_CONFIG PciData
    )
{
    if ((PciData->BaseClass == PCI_CLASS_MASS_STORAGE_CTLR) &&
        (PciData->SubClass == PCI_SUBCLASS_MSC_IDE_CTLR)) {

        return TRUE;
    }

    //
    // Now look for old, hard to recognize controllers.
    //

    if (PciData->VendorID == 0x1c1c) {   // Old Symphony controller
        return TRUE;
    }

    if ((PciData->VendorID == 0x10B9) &&
        ((PciData->DeviceID == 0x5215) ||
         (PciData->DeviceID == 0x5219))) {  // ALI controllers
        return TRUE;
    }

    if ((PciData->VendorID == 0x1097) &&
        (PciData->DeviceID == 0x0038)) {    // Appian controller
        return TRUE;
    }

    if ((PciData->VendorID == 0x0E11) &&
        (PciData->DeviceID == 0xAE33)) {    // Compaq controller
        return TRUE;
    }

    if ((PciData->VendorID == 0x1042) &&
        (PciData->DeviceID == 0x1000)) {    // PCTECH controller
        return TRUE;
    }

    if ((PciData->VendorID == 0x1039) &&
        ((PciData->DeviceID == 0x0601) ||
         (PciData->DeviceID == 0x5513))) {  // SIS controllers
        return TRUE;
    }

    if ((PciData->VendorID == 0x10AD) &&
        ((PciData->DeviceID == 0x0001) ||
         (PciData->DeviceID == 0x0150))) {  // Newer Symphony controllers
        return TRUE;
    }

    if ((PciData->VendorID == 0x1060) &&
        (PciData->DeviceID == 0x0101)) {    // United Microelectronics controller
        return TRUE;
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halx86\i386\ixslpctx.inc ===
;
; Structure at the begining of a real-mode startup block
;

PxParamBlock struc
    SPx_Jmp_Inst    dd  ?
    SPx_flag        dd  ?
    SPx_flat_addr   dd  ?
    SPx_TiledCR3    dd  ?
    SPx_P0EBP       dd  ?
    SPx_PB          db  ProcessorStateLength dup (?)
PxParamBlock ends

SPX_FLAG_STARTED    EQU 1
SPX_FLAG_NX         EQU 2
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halx86\i386\ixproc.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    ixsproc.c

Abstract:

    Stub functions for UP hals.

Author:

    Ken Reneris (kenr) 22-Jan-1991

Environment:

    Kernel mode only.

Revision History:

--*/

#include "halp.h"

#ifdef ALLOC_DATA_PRAGMA
#pragma data_seg("INITCONST") // INITCONST is OK to use for data_seg
#endif // ALLOC_DATA_PRAGMA
WCHAR HalHardwareIdString[] = L"e_isa_up\0";

#ifdef ALLOC_DATA_PRAGMA
#pragma data_seg()
#endif // ALLOC_DATA_PRAGMA

const ULONG HalDisableFirmwareMapper = 0;
const UCHAR HalName[] = "PC Compatible Eisa/Isa HAL";
#define HalName        L"PC Compatible Eisa/Isa HAL"
ULONG   HalDisplayBusRanges;

BOOLEAN
HalpInitMP (
    IN ULONG Phase,
    IN PLOADER_PARAMETER_BLOCK LoaderBlock
    );

VOID
HalpMcaInit (
    VOID
    );

VOID HalpInitOtherBuses (VOID);
VOID HalpInitializePciBus (VOID);
VOID HalpInitializePciStubs (VOID);

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT,HalpInitMP)
#pragma alloc_text(INIT,HalStartNextProcessor)
#pragma alloc_text(INIT,HalAllProcessorsStarted)
#pragma alloc_text(INIT,HalReportResourceUsage)
#pragma alloc_text(INIT,HalpInitOtherBuses)
#endif



BOOLEAN
HalpInitMP (
    IN ULONG Phase,
    IN PLOADER_PARAMETER_BLOCK LoaderBlock
    )
{
    // do nothing
    return TRUE;
}


VOID
HalpResetAllProcessors (
    VOID
    )
{
    // Just return, that will invoke the standard PC reboot code
}


BOOLEAN
HalStartNextProcessor (
   IN PLOADER_PARAMETER_BLOCK   pLoaderBlock,
   IN PKPROCESSOR_STATE         pProcessorState
   )
{
    // no other processors
    return FALSE;
}

BOOLEAN
HalAllProcessorsStarted (
    VOID
    )
{
    if (HalpFeatureBits & HAL_NO_SPECULATION) {

        //
        // Processor doesn't perform speculative execeution,
        // remove fences in critical code paths
        //

        HalpRemoveFences ();
    }

    return TRUE;
}


VOID
HalReportResourceUsage (
    VOID
    )
{
    INTERFACE_TYPE  interfacetype;
    UNICODE_STRING  UHalName;

    HalInitSystemPhase2 ();

    //
    // Turn on MCA support if present
    //

    HalpMcaInit();

    //
    // Registry is now intialized, see if there are any PCI buses
    //

    HalpInitializePciBus ();
    HalpInitializePciStubs ();

    //
    // Complete ALL bus initialization before reporting resource usage.
    //

    switch (HalpBusType) {
        case MACHINE_TYPE_ISA:  interfacetype = Isa;            break;
        case MACHINE_TYPE_EISA: interfacetype = Eisa;           break;
        case MACHINE_TYPE_MCA:  interfacetype = MicroChannel;   break;
        default:                interfacetype = Internal;       break;
    }

    RtlInitUnicodeString (&UHalName, HalName);
    HalpReportResourceUsage (
        &UHalName,          // descriptive name
        interfacetype       // device space interface type
    );

#if DBG
    //
    // Display all buses & ranges
    //

    if (HalDisplayBusRanges) {
        HalpDisplayAllBusRanges ();
    }
#endif

    //
    // Declare that we are capable of
    // hibernation.
    //
    HalpRegisterHibernate ();

    HalpRegisterPciDebuggingDeviceInfo();
}


VOID
HalpInitOtherBuses (
    VOID
    )
{
    // no other internal buses supported
}

ULONG
FASTCALL
HalSystemVectorDispatchEntry (
    IN ULONG Vector,
    OUT PKINTERRUPT_ROUTINE **FlatDispatch,
    OUT PKINTERRUPT_ROUTINE *NoConnection
    )
{
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halx86\i386\ixsleep.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    ixsleep.h

Abstract:

    This file has all the common headers used
    for saving and restoring context for multiple
    processors.

Author:

    Jake Oshins (jakeo) March 25, 1998

Revision History:

--*/

VOID
HalpSavePicState(
    VOID
    );

VOID
HalpRestorePicState(
    VOID
    );

VOID
HalpRestoreTempPicState(
    VOID
    );

ULONG
HalpBuildTiledCR3Ex (
    IN PKPROCESSOR_STATE    ProcessorState,
    IN ULONG                ProcNum
    );

VOID
HalpFreeTiledCR3Ex (
    ULONG ProcNum
    );

VOID
HalpUnMapIOApics(
    VOID
    );

VOID
HalpSaveProcessorStateAndWait(
    IN PKPROCESSOR_STATE ProcessorState,
    IN PULONG            Count
    );

extern PVOID HalpResumeContext;
extern PKPROCESSOR_STATE HalpHiberProcState;
extern ULONG             CurTiledCr3LowPart;
extern PPHYSICAL_ADDRESS HalpTiledCr3Addresses;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halx86\i386\ixreboot.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    ixreboot.c

Abstract:

    Provides the interface to the firmware for x86.  Since there is no
    firmware to speak of on x86, this is just reboot support.

Author:

    John Vert (jvert) 12-Aug-1991

Revision History:

--*/

//
// This module is compatible with PAE mode and therefore treats physical
// addresses as 64-bit entities.
//

#if !defined(_PHYS64_)
#define _PHYS64_
#endif

#include "halp.h"
#include "pci.h"

#ifdef ACPI_HAL
#include "acpitabl.h"
#include "xxacpi.h"
extern UCHAR   HalpPiix4;
#endif


//
// Defines to let us diddle the CMOS clock and the keyboard
//

#define CMOS_CTRL   (PUCHAR )0x70
#define CMOS_DATA   (PUCHAR )0x71

#define RESET       0xfe
#define KEYBPORT    (PUCHAR )0x64

//
// Private function prototypes
//

VOID
HalpWriteResetCommand(
    VOID
    )
/*++

Routine Description:

    This procedure issues a reset command to the system to cause a warm boot.

    It either uses the ACPI defined reset register or the keyboard controller.
    

    N.B.

        Will NOT return.

--*/
{

#ifdef ACPI_HAL
    PCI_SLOT_NUMBER slot;
    PUCHAR  ResetAddress;

    //
    // if the system supports the ACPI specified RESET_REG capability we 
    // will use that.
    //
    if ((HalpFixedAcpiDescTable.Header.Revision > 1) && 
        (HalpFixedAcpiDescTable.flags & RESET_CAP)
#if !defined(NT_UP)
        //
        // to be safer on MP systems, we will only use RESET_REG if the
        // system is legacy free.  On UP systems this is not necessary 
        // because we've already tested systems with this functionality.
        // MP systems have not been tested extensively and we don't want
        // false positives where systems are using this functionality and
        // failing.  in the next major release this change can be removed.
        //
        && (!(HalpFixedAcpiDescTable.boot_arch & I8042))
#endif
        ) {

        switch (HalpFixedAcpiDescTable.reset_reg.AddressSpaceID) {
        case 0:         // Memory
            
            ResetAddress = 
                HalpMapPhysicalMemoryWriteThrough(HalpFixedAcpiDescTable.reset_reg.Address, 1);
            
            WRITE_REGISTER_UCHAR(ResetAddress, 
                                 HalpFixedAcpiDescTable.reset_val);
            break;

        case 1:         // I/O

            WRITE_PORT_UCHAR((PUCHAR)(ULONG_PTR)HalpFixedAcpiDescTable.reset_reg.Address.LowPart,
                             HalpFixedAcpiDescTable.reset_val);
            break;

        case 2:         // PCI Config

            slot.u.AsULONG = 0;
            slot.u.bits.DeviceNumber = 
                HalpFixedAcpiDescTable.reset_reg.Address.HighPart;
            slot.u.bits.FunctionNumber = 
                HalpFixedAcpiDescTable.reset_reg.Address.LowPart >> 16;
            
            HalSetBusDataByOffset(PCIBus,
                                  0,
                                  slot.u.AsULONG,
                                  &HalpFixedAcpiDescTable.reset_val,
                                  HalpFixedAcpiDescTable.reset_reg.Address.LowPart & 0xff,
                                  1);
            break;
        }
    }

#endif
    
    //
    // If we return, send the reset command to the keyboard controller
    //

    WRITE_PORT_UCHAR(KEYBPORT, RESET);

}

VOID
HalpReboot (
    VOID
    )

/*++

Routine Description:

    This procedure resets the CMOS clock to the standard timer settings
    so the bios will work, and then issues a reset command to the keyboard
    to cause a warm boot.

    It is very machine dependent, this implementation is intended for
    PC-AT like machines.

    This code copied from the "old debugger" sources.

    N.B.

        Will NOT return.

--*/

{
    UCHAR   Scratch;
    PUSHORT Magic;    
    PHYSICAL_ADDRESS zeroPhysical;
    
    //
    // By sticking 0x1234 at physical location 0x472, we can bypass the
    // memory check after a reboot.
    //

    zeroPhysical.QuadPart = 0;
    Magic = HalpMapPhysicalMemoryWriteThrough(zeroPhysical, 1);
    if (Magic) {
        Magic[0x472 / sizeof(USHORT)] = 0x1234;
    }

    //
    // Turn off interrupts
    //

    HalpAcquireCmosSpinLock();
    HalpDisableInterrupts();

    //
    // Reset the cmos clock to a standard value
    // (We are setting the periodic interrupt control on the MC147818)
    //

    //
    // Disable periodic interrupt
    //

    WRITE_PORT_UCHAR(CMOS_CTRL, 0x0b);      // Set up for control reg B.
    KeStallExecutionProcessor(1);

    Scratch = READ_PORT_UCHAR(CMOS_DATA);
    KeStallExecutionProcessor(1);

    Scratch &= 0xbf;                        // Clear periodic interrupt enable

    WRITE_PORT_UCHAR(CMOS_DATA, Scratch);
    KeStallExecutionProcessor(1);

    //
    // Set "standard" divider rate
    //

    WRITE_PORT_UCHAR(CMOS_CTRL, 0x0a);      // Set up for control reg A.
    KeStallExecutionProcessor(1);

    Scratch = READ_PORT_UCHAR(CMOS_DATA);
    KeStallExecutionProcessor(1);

    Scratch &= 0xf0;                        // Clear rate setting
    Scratch |= 6;                           // Set default rate and divider

    WRITE_PORT_UCHAR(CMOS_DATA, Scratch);
    KeStallExecutionProcessor(1);

    //
    // Set a "neutral" cmos address to prevent weirdness
    // (Why is this needed? Source this was copied from doesn't say)
    //

    WRITE_PORT_UCHAR(CMOS_CTRL, 0x15);
    KeStallExecutionProcessor(1);

    HalpResetAllProcessors();

    HalpWriteResetCommand();

    HalpHalt();
}



#ifndef ACPI_HAL

VOID
HaliHaltSystem (
    VOID
    )

/*++

Routine Description:

    This procedure is called when the machine has crashed and is to be
    halted

    N.B.

        Will NOT return.

--*/

{
    _asm {
        cli
        hlt
    }
}

VOID
HalpCheckPowerButton (
    VOID
    )
{
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halx86\i386\ixprofil.asm ===
title  "Interval Clock Interrupt"
;++
;
; Copyright (c) 1989  Microsoft Corporation
;
; Module Name:
;
;    ixprofile.asm
;
; Abstract:
;
;    This module implements the code necessary to initialize,
;    field and process the profile interrupt.
;
; Author:
;
;    Shie-Lin Tzong (shielint) 12-Jan-1990
;
; Environment:
;
;    Kernel mode only.
;
; Revision History:
;
;   bryanwi 20-Sep-90
;
;       Add KiSetProfileInterval, KiStartProfileInterrupt,
;       KiStopProfileInterrupt procedures.
;       KiProfileInterrupt ISR.
;       KiProfileList, KiProfileLock are delcared here.
;
;   shielint 10-Dec-90
;       Add performance counter support.
;       Move system clock to irq8, ie we now use RTC to generate system
;         clock.  Performance count and Profile use timer 1 counter 0.
;         The interval of the irq0 interrupt can be changed by
;         KiSetProfileInterval.  Performance counter does not care about the
;         interval of the interrupt as long as it knows the rollover count.
;       Note: Currently I implemented 1 performance counter for the whole
;       i386 NT.
;
;   John Vert (jvert) 11-Jul-1991
;       Moved from ke\i386 to hal\i386.  Removed non-HAL stuff
;
;   shie-lin tzong (shielint) 13-March-92
;       Move System clock back to irq0 and use RTC (irq8) to generate
;       profile interrupt.  Performance counter and system clock use time1
;       counter 0 of 8254.
;
;   Landy Wang (landy@corollary.com) 26-Mar-1992
;       Move much code into separate modules for easy inclusion by various
;       HAL builds.
;
;	Add HalBeginSystemInterrupt() call at beginning of ProfileInterrupt
;	code - this must be done before any sti.
;	Also add HalpProfileInterrupt2ndEntry for additional processors to
;	join the flow of things.
;
;--

.386p
        .xlist
include hal386.inc
include callconv.inc                    ; calling convention macros
include i386\kimacro.inc
include mac386.inc
include i386\ix8259.inc
include i386\ixcmos.inc
        .list

        EXTRNP  _DbgBreakPoint,0,IMPORT
        EXTRNP  _KeProfileInterrupt,1,IMPORT
        EXTRNP  Kei386EoiHelper,0,IMPORT
        EXTRNP  _HalEndSystemInterrupt,2
        EXTRNP  _HalBeginSystemInterrupt,3
        EXTRNP  _HalpAcquireCmosSpinLock  ,0
        EXTRNP  _HalpReleaseCmosSpinLock  ,0

;
; Constants used to initialize CMOS/Real Time Clock
;

D_INT032                EQU     8E00h   ; access word for 386 ring 0 interrupt gate

_TEXT   SEGMENT  DWORD PUBLIC 'DATA'

align 4
ProfileIntervalTable    dd      1221    ; unit = 100 ns
                        dd      2441
                        dd      4883
                        dd      9766
                        dd      19531
                        dd      39063
                        dd      78125
                        dd      156250
                        dd      312500
                        dd      625000
                        dd      1250000
                        dd      2500000
                        dd      5000000
                        dd      5000000 OR 80000000H

ProfileIntervalInitTable db     00100011B
                        db      00100100B
                        db      00100101B
                        db      00100110B
                        db      00100111B
                        db      00101000B
                        db      00101001B
                        db      00101010B
                        db      00101011B
                        db      00101100B
                        db      00101101B
                        db      00101110B
                        db      00101111B
                        db      00101111B

;
; HALs wishing to reuse the code in this module should set the HAL
; global variable IxProfileVector to their profile vector.
;
		public	_IxProfileVector
_IxProfileVector	dd	PROFILE_VECTOR

_TEXT   ends

_DATA   SEGMENT  DWORD PUBLIC 'DATA'

RegisterAProfileValue   db      00101000B ; default interval = 3.90625 ms

;
; The following array stores the per microsecond loop count for each
; central processor.
;

HalpProfileInterval     dd      -1

public _HalpProfilingStopped
_HalpProfilingStopped   dd      1

_DATA   ends

_TEXT   SEGMENT DWORD PUBLIC 'CODE'
        ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING

;++
;
;   HalStartProfileInterrupt(
;       IN ULONG Reserved
;       );
;
;   Routine Description:
;
;       What we do here is change the interrupt
;       rate from the slowest thing we can get away with to the value
;       that's been KeSetProfileInterval
;
;   All processors will run this routine, but it doesn't hurt to have
;   each one reinitialize the CMOS, since none of them will be let go
;   from the stall until they all finish.
;
;--

cPublicProc _HalStartProfileInterrupt    ,1

;   Mark profiling as active
;

        mov     dword ptr _HalpProfilingStopped, 0

;
;   Set the interrupt rate to what is actually needed
;
        stdCall   _HalpAcquireCmosSpinLock      ; intr disabled

        mov     al, RegisterAProfileValue
        shl     ax, 8
        mov     al, 0AH                 ; Register A
        CMOS_WRITE                      ; Initialize it
;
; Don't clobber the Daylight Savings Time bit in register B, because we
; stash the LastKnownGood "environment variable" there.
;
        mov     ax, 0bh
        CMOS_READ
        and     al, 1
        mov     ah, al
        or      ah, REGISTER_B_ENABLE_PERIODIC_INTERRUPT
        mov     al, 0bh
        CMOS_WRITE                      ; Initialize it
        mov     al,0CH                  ; Register C
        CMOS_READ                       ; Read to initialize
        mov     al,0DH                  ; Register D
        CMOS_READ                       ; Read to initialize

        stdCall   _HalpReleaseCmosSpinLock

        stdRET    _HalStartProfileInterrupt

stdENDP _HalStartProfileInterrupt



;++
;
;   HalStopProfileInterrupt(
;       IN ULONG Reserved
;       );
;
;   Routine Description:
;
;       What we do here is change the interrupt
;       rate from the high profiling rate to the slowest thing we
;       can get away with for PerformanceCounter rollover notification.
;
;--

cPublicProc _HalStopProfileInterrupt    ,1

;
;   Turn off profiling hit computation and profile interrupt
;

;
; Don't clobber the Daylight Savings Time bit in register B, because we
; stash the LastKnownGood "environment variable" there.

        stdCall   _HalpAcquireCmosSpinLock      ; intr disabled
        mov     ax, 0bh
        CMOS_READ
        and     al, 1
        mov     ah, al
        or      ah, REGISTER_B_DISABLE_PERIODIC_INTERRUPT
        mov     al, 0bh
        CMOS_WRITE                      ; Initialize it
        mov     al,0CH                  ; Register C
        CMOS_READ                       ; dismiss pending profiling interrupt
        mov     dword ptr _HalpProfilingStopped, 1
        stdCall   _HalpReleaseCmosSpinLock

        stdRET    _HalStopProfileInterrupt

stdENDP _HalStopProfileInterrupt

;++
;   ULONG
;   HalSetProfileInterval (
;       ULONG Interval
;       );
;
;   Routine Description:
;
;       This procedure sets the interrupt rate (and thus the sampling
;       interval) for the profiling interrupt.
;
;       If profiling is active (KiProfilingStopped == 0) the actual
;       hardware interrupt rate will be set.  Otherwise, a simple
;       rate validation computation is done.
;
;   Arguments:
;
;       (TOS+4) - Interval in 100ns unit.
;
;   Return Value:
;
;       Interval actually used by system.
;
;--

cPublicProc _HalSetProfileInterval    ,1

        mov     edx, [esp+4]            ; [edx] = interval in 100ns unit
        and     edx, 7FFFFFFFh          ; Remove highest bit.
        mov     ecx, 0                  ; index = 0

Hspi00:
        mov     eax, ProfileIntervalTable[ecx * 4]
        cmp     edx, eax                ; if request interval < suport interval
        jbe     short Hspi10            ; if be, find supported interval
        inc     ecx
        jmp     short Hspi00

Hspi10:
        and     eax, 7FFFFFFFh          ; remove highest bit from supported interval
        jecxz   short Hspi20            ; If first entry then use it

        push    esi                     ; See which is closer to requested
        mov     esi, eax                ; rate - current entry, or preceeding
        sub     esi, edx

        sub     edx, ProfileIntervalTable[ecx * 4 - 4]
        cmp     esi, edx
        pop     esi
        jc      short Hspi20

        dec     ecx                     ; use preceeding entry
        mov     eax, ProfileIntervalTable[ecx * 4]

Hspi20:
        push    eax                     ; save interval value
        mov     al, ProfileIntervalInitTable[ecx]
        mov     RegisterAProfileValue, al
        test    dword ptr _HalpProfilingStopped,-1
        jnz     short Hspi90

        stdCall   _HalStartProfileInterrupt,<0> ; Re-start profile interrupt
                                        ; with the new interval

Hspi90: pop     eax
        stdRET    _HalSetProfileInterval    ; (eax) = cReturn interval

stdENDP _HalSetProfileInterval

        page ,132
        subttl  "System Profile Interrupt"
;++
;
; Routine Description:
;
;    This routine is entered as the result of a profile interrupt.
;    Its function is to dismiss the interrupt, raise system Irql to
;    PROFILE_LEVEL and transfer control to
;    the standard system routine to process any active profiles.
;
; Arguments:
;
;    None
;    Interrupt is disabled
;
; Return Value:
;
;    Does not return, jumps directly to KeProfileInterrupt, which returns
;
;    Sets Irql = PROFILE_LEVEL and dismisses the interrupt
;
;--
        ENTER_DR_ASSIST Hpi_a, Hpi_t

cPublicProc _HalpProfileInterrupt     ,0

;
; Save machine state in trap frame
;

        ENTER_INTERRUPT Hpi_a, Hpi_t

;
; (esp) - base of trap frame
;
; HalBeginSystemInterrupt must be called before any sti's
;
;

        push    _IxProfileVector
        sub     esp, 4                  ; allocate space to save OldIrql
        stdCall	_HalBeginSystemInterrupt, <PROFILE_LEVEL,_IxProfileVector,esp>

        or      al,al                   ; check for spurious interrupt
        jz      Hpi100


;
; This is the RTC interrupt, so we have to clear the
; interrupt flag on the RTC.
;
        stdCall	_HalpAcquireCmosSpinLock

;
; clear interrupt flag on RTC by banging on the CMOS.  On some systems this
; doesn't work the first time we do it, so we do it twice.  It is rumored that
; some machines require more than this, but that hasn't been observed with NT.
;

        mov     al,0CH                  ; Register C
        CMOS_READ                       ; Read to initialize
        mov     al,0CH                  ; Register C
        CMOS_READ                       ; Read to initialize
if  DBG
        align   4
Hpi10:  test    al, 80h
        jz      short Hpi15
        mov     al,0CH                  ; Register C
        CMOS_READ                       ; Read to initialize
        jmp     short Hpi10
Hpi15:
endif   ; DBG

        stdCall _HalpReleaseCmosSpinLock

        sti
;
; This entry point is provided for symmetric multiprocessor HALs.
; Since it only makes sense for one processor to clear the CMOS,
; all other processors can instead jmp into this entry point.
;

	align 4
        public     _HalpProfileInterrupt2ndEntry@0
_HalpProfileInterrupt2ndEntry@0:

;
; (esp) = OldIrql
; (esp+4) = H/W vector
; (esp+8) = base of trap frame
;

;
;   Now check for any profiling stuff to do.
;

        cmp     _HalpProfilingStopped, dword ptr 1 ; Has profiling been stopped?
        jz      short Hpi90                 ; if z, prof disenabled

        stdCall _KeProfileInterrupt,<ebp>   ; (ebp) = trapframe

Hpi90:
        INTERRUPT_EXIT

	align	4
Hpi100:
        add     esp, 8                      ; spurious, no EndOfInterrupt
        SPURIOUS_INTERRUPT_EXIT             ; exit interrupt without eoi

stdENDP _HalpProfileInterrupt

_TEXT   ends

        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halx86\i386\ixpnpdrv.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    ixpnpdrv.c

Abstract:

    Implements functionality necessary for the
    HAL to become a PnP-style device driver
    after system initialization.  This is done
    so that the HAL can enumerate the PCI busses
    in the way that the PnP stuff expects.

Author:

    Jake Oshins (jakeo) 27-Jan-1997

Environment:

    Kernel mode only.

Revision History:

--*/

#include "halp.h"
#include "exboosts.h"
#include "wchar.h"
#include "pci.h"
#include "pcip.h"
#if defined(NT_UP) && defined(APIC_HAL)
#include "apic.inc"
#include "pcmp_nt.inc"
#endif

#ifdef ALLOC_DATA_PRAGMA
#pragma const_seg("PAGECONST")
#endif // ALLOC_DATA_PRAGMA
//Instantiate the guids here only.
#include "initguid.h"
#include "wdmguid.h"
#ifdef ALLOC_DATA_PRAGMA
#pragma const_seg()
#endif // ALLOC_DATA_PRAGMA

#ifdef WANT_IRQ_ROUTING
// Pci Irq Routing.
#include "ixpciir.h"
#endif

WCHAR rgzTranslated[] = L".Translated";
WCHAR rgzBusTranslated[] = L".Bus.Translated";
WCHAR rgzResourceMap[] = L"\\REGISTRY\\MACHINE\\HARDWARE\\RESOURCEMAP";

#if DBG
ULONG   HalDebug = 0;
#endif

extern WCHAR rgzTranslated[];
extern WCHAR rgzBusTranslated[];
extern WCHAR rgzResourceMap[];
extern WCHAR HalHardwareIdString[];
#if defined(NT_UP) && defined(APIC_HAL)
extern WCHAR MpHalHardwareIdString[];
#endif
extern struct   HalpMpInfo HalpMpInfoTable;

typedef enum {
    Hal = 0x80,
    PciDriver,
    IsaPnpDriver,
    McaDriver
} PDO_TYPE;

typedef enum {
    PdoExtensionType = 0xc0,
    FdoExtensionType
} EXTENSION_TYPE;

typedef struct _PDO_EXTENSION *PPDO_EXTENSION;
typedef struct _FDO_EXTENSION *PFDO_EXTENSION;

typedef struct _PDO_EXTENSION{
    EXTENSION_TYPE                  ExtensionType;
    PDEVICE_OBJECT                  Next;
    PDEVICE_OBJECT                  PhysicalDeviceObject;
    PFDO_EXTENSION                  ParentFdoExtension;
    PDO_TYPE                        PdoType;
    ULONG                           BusNumber;
    ULONG                           MaxSubordinateBusNumber;
    PBUS_HANDLER                    Bus;
    LONG                            InterfaceReferenceCount;
} PDO_EXTENSION, *PPDO_EXTENSION;

#define ASSERT_PDO_EXTENSION(x) ASSERT((x)->ExtensionType == PdoExtensionType );

typedef struct _FDO_EXTENSION{
    EXTENSION_TYPE        ExtensionType;
    PDEVICE_OBJECT        ChildPdoList;
    PDEVICE_OBJECT        PhysicalDeviceObject;  // PDO passed into AddDevice()
    PDEVICE_OBJECT        FunctionalDeviceObject;
    PDEVICE_OBJECT        AttachedDeviceObject;
    ULONG                 BusCount;
} FDO_EXTENSION, *PFDO_EXTENSION;

#define ASSERT_FDO_EXTENSION(x) ASSERT((x)->ExtensionType == FdoExtensionType );

INT_ROUTE_INTERFACE_STANDARD PciIrqRoutingInterface = {0};

NTSTATUS
HalpDriverEntry (
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    );

NTSTATUS
HalpAddDevice(
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT PhysicalDeviceObject
    );

NTSTATUS
HalpDispatchPnp(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    );

NTSTATUS
HalpDispatchPower(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    );

NTSTATUS
HalpDispatchWmi(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    );

VOID
HalpCompleteRequest(
    IN OUT PIRP Irp,
    IN NTSTATUS Status,
    IN ULONG Information
    );

NTSTATUS
HalpQueryDeviceRelations(
    IN PDEVICE_OBJECT       DeviceObject,
    IN DEVICE_RELATION_TYPE RelationType,
    OUT PDEVICE_RELATIONS *DeviceRelations
    );

NTSTATUS
HalpQueryIdPdo(
    IN PDEVICE_OBJECT PdoExtension,
    IN BUS_QUERY_ID_TYPE IdType,
    IN OUT PWSTR *BusQueryId
    );

NTSTATUS
HalpQueryIdFdo(
    IN PDEVICE_OBJECT PdoExtension,
    IN BUS_QUERY_ID_TYPE IdType,
    IN OUT PWSTR *BusQueryId
    );

NTSTATUS
HalpQueryCapabilities(
    IN PDEVICE_OBJECT Pdo,
    IN PDEVICE_CAPABILITIES Capabilities
    );

NTSTATUS
HalpQueryDeviceText(
    IN PDEVICE_OBJECT DeviceObject,
    IN DEVICE_TEXT_TYPE IdType,
    IN OUT PWSTR *BusQueryId
    );

NTSTATUS
HalpQueryInterface(
    IN     PDEVICE_OBJECT   DeviceObject,
    IN     LPCGUID          InterfaceType,
    IN     USHORT           Version,
    IN     PVOID            InterfaceSpecificData,
    IN     ULONG            InterfaceBufferSize,
    IN OUT PINTERFACE       Interface,
    IN OUT PULONG           Length
    );

#ifdef WANT_IRQ_ROUTING

NTSTATUS
HalpQueryInterfaceFdo(
    IN     PDEVICE_OBJECT   DeviceObject,
    IN     LPCGUID          InterfaceType,
    IN     USHORT           Version,
    IN     PVOID            InterfaceSpecificData,
    IN     ULONG            InterfaceBufferSize,
    IN OUT PINTERFACE       Interface,
    IN OUT PULONG           Length
    );

#endif

NTSTATUS
HalpQueryResources(
    PDEVICE_OBJECT DeviceObject,
    PCM_RESOURCE_LIST *Resources
    );

NTSTATUS
HalpQueryResourceRequirements(
    PDEVICE_OBJECT DeviceObject,
    PIO_RESOURCE_REQUIREMENTS_LIST *Requirements
    );

NTSTATUS
HalpRemoveAssignedResources(
    PBUS_HANDLER Bus
    );

VOID
HalpMarkNonAcpiHal(
    VOID
    );

//
//  Define the PNP interface functions.
//

VOID
HalPnpInterfaceReference(
    PVOID Context
    );

VOID
HalPnpInterfaceDereference(
    PVOID Context
    );

BOOLEAN
HalPnpTranslateBusAddress(
    IN PVOID Context,
    IN PHYSICAL_ADDRESS BusAddress,
    IN ULONG Length,
    IN OUT PULONG AddressSpace,
    OUT PPHYSICAL_ADDRESS TranslatedAddress
    );

struct _DMA_ADAPTER *
HalPnpGetDmaAdapter(
    IN PVOID Context,
    IN struct _DEVICE_DESCRIPTION *DeviceDescriptor,
    OUT PULONG NumberOfMapRegisters
    );

ULONG
HalPnpReadConfig(
    IN PVOID Context,
    IN ULONG Slot,
    IN PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Length
    );

ULONG
HalPnpWriteConfig(
    IN PVOID Context,
    IN ULONG Slot,
    IN PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Length
    );

NTSTATUS
HalpGetPciInterfaces(
    IN PDEVICE_OBJECT PciPdo
    );

#ifdef APIC_HAL
NTSTATUS
HalpPci2MpsBusNumber(
    IN UCHAR PciBusNumber,
    OUT UCHAR *MpsBusNumber
    );

BOOLEAN
HalpMpsBusIsRootBus(
    IN  UCHAR MpsBus
    );
#endif

#define PCI_HAL_DRIVER_NAME  L"\\Driver\\PCI_HAL"
#define ISA_HAL_DRIVER_NAME  L"\\Driver\\ISA_HAL"
#define MCA_HAL_DRIVER_NAME  L"\\Driver\\MCA_HAL"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, HaliInitPnpDriver)
#pragma alloc_text(PAGE, HalpDriverEntry)
#pragma alloc_text(PAGE, HalpAddDevice)
#pragma alloc_text(PAGE, HalpDispatchPnp)
#pragma alloc_text(PAGELK, HalpDispatchPower)
#pragma alloc_text(PAGE, HalpDispatchWmi)
#pragma alloc_text(PAGE, HalpQueryDeviceRelations)
#pragma alloc_text(PAGE, HalpQueryIdPdo)
#pragma alloc_text(PAGE, HalpQueryIdFdo)
#pragma alloc_text(PAGE, HalpQueryCapabilities)
#pragma alloc_text(PAGE, HalpQueryInterface)
#ifdef WANT_IRQ_ROUTING
#pragma alloc_text(PAGE, HalpQueryInterfaceFdo)
#endif
#pragma alloc_text(PAGE, HalpQueryDeviceText)
#pragma alloc_text(PAGE, HalpQueryResources)
#pragma alloc_text(PAGE, HalpQueryResourceRequirements)
#pragma alloc_text(PAGE, HalpRemoveAssignedResources)
#pragma alloc_text(PAGE, HalpMarkNonAcpiHal)
#pragma alloc_text(INIT, HalpMarkChipsetDecode)
#pragma alloc_text(PAGE, HalpOpenRegistryKey)
#pragma alloc_text(PAGE, HalpGetPciInterfaces)
#pragma alloc_text(PAGE, HalPnpInterfaceDereference)
#endif

PDRIVER_OBJECT HalpDriverObject;

NTSTATUS
HaliInitPnpDriver(
    VOID
    )
/*++

Routine Description:

    This routine starts the process of making the HAL into
    a "driver," which is necessary because we need to
    enumerate a Plug and Play PDO for the PCI driver and ISAPNP
    driver.

Arguments:

    None.

Return Value:

    NTSTATUS.

--*/
{

    UNICODE_STRING  DriverName;
    NTSTATUS Status;

    PAGED_CODE();

    //
    // For different bus pdo, we will use different hal name such that
    // it is less confusion.
    //

    if (HalpHandlerForBus (PCIBus, 0)) {
        RtlInitUnicodeString( &DriverName, PCI_HAL_DRIVER_NAME );
    } else if (HalpHandlerForBus(MicroChannel, 0)) {
        RtlInitUnicodeString( &DriverName, MCA_HAL_DRIVER_NAME );
    } else {
        RtlInitUnicodeString( &DriverName, ISA_HAL_DRIVER_NAME );
    }

    Status = IoCreateDriver( &DriverName, HalpDriverEntry );

    //
    // John Vert (jvert) 7/23/1998
    //   There is a value in the registry that the ACPI HAL sets to disable
    //   the firmware mapper. Unfortunately this value is persistent. So if
    //   you have an ACPI machine and "upgrade" it to a non-ACPI machine, the
    //   value is still present. Workaround here is to set the value to zero.
    //
    HalpMarkNonAcpiHal();

    if (!NT_SUCCESS( Status )) {
        ASSERT( NT_SUCCESS( Status ));
        return Status;
    }

    return STATUS_SUCCESS;

}

NTSTATUS
HalpDriverEntry (
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    )

/*++

Routine Description:

    This is the callback function when we call IoCreateDriver to create a
    PnP Driver Object.  In this function, we need to remember the DriverObject.

Arguments:

    DriverObject - Pointer to the driver object created by the system.

    RegistryPath - is NULL.

Return Value:

   STATUS_SUCCESS

--*/
{
    NTSTATUS Status;
    PDEVICE_OBJECT detectedDeviceObject = NULL;

    PAGED_CODE();

    //
    // File the pointer to our driver object away
    //

    HalpDriverObject = DriverObject;

    //
    // Fill in the driver object
    //

    DriverObject->DriverExtension->AddDevice = (PDRIVER_ADD_DEVICE) HalpAddDevice;
    DriverObject->MajorFunction[ IRP_MJ_PNP ] = HalpDispatchPnp;
    DriverObject->MajorFunction[ IRP_MJ_POWER ] = HalpDispatchPower;
    DriverObject->MajorFunction[ IRP_MJ_SYSTEM_CONTROL ] = HalpDispatchWmi;

    Status = IoReportDetectedDevice(DriverObject,
                                    InterfaceTypeUndefined,
                                    -1,
                                    -1,
                                    NULL,
                                    NULL,
                                    FALSE,
                                    &detectedDeviceObject);

    ASSERT( detectedDeviceObject != NULL );

    if (!(NT_SUCCESS(Status))) {
        HalPrint(("IoReportDetectedDevice failed"));
        return Status;
    }

    Status = HalpAddDevice(DriverObject, detectedDeviceObject);

    return Status;

}

NTSTATUS
HalpAddDevice(
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT PhysicalDeviceObject
    )

/*++

Routine Description:

    This routine handles AddDevice for an madeup PDO device.

Arguments:

    DriverObject - Pointer to our pseudo driver object.

    DeviceObject - Pointer to the device object for which this requestapplies.

Return Value:

    NT Status.

--*/
{
    PDEVICE_OBJECT FunctionalDeviceObject;
    PDEVICE_OBJECT ChildDeviceObject;
    PDEVICE_OBJECT AttachedDevice;
    NTSTATUS       Status;
    PFDO_EXTENSION FdoExtension;
    PPDO_EXTENSION PdoExtension;
    PDEVICE_OBJECT  Pdo2;
    ULONG BusNumber;
    ULONG BusCount = 0;
    PBUS_HANDLER Bus;
    WCHAR Buffer[40];
    UNICODE_STRING Unicode;
    PDO_TYPE PdoType;
    UCHAR MpsBusNumber;

    PAGED_CODE();

    //
    // We've been given the PhysicalDeviceObject.  Create the
    // FunctionalDeviceObject.  Our FDO will be nameless.
    //

    Status = IoCreateDevice(
                DriverObject,               // our driver object
                sizeof(FDO_EXTENSION),      // size of our extension
                NULL,                       // our name
                FILE_DEVICE_BUS_EXTENDER,   // device type
                0,                          // device characteristics
                FALSE,                      // not exclusive
                &FunctionalDeviceObject     // store new device object here
                );

    if( !NT_SUCCESS( Status )){

        DbgBreakPoint();
        return Status;
    }

    //
    // Fill in the FDO extension
    //

    FdoExtension = (PFDO_EXTENSION) FunctionalDeviceObject->DeviceExtension;
    FdoExtension->ExtensionType = FdoExtensionType;
    FdoExtension->PhysicalDeviceObject = PhysicalDeviceObject;
    FdoExtension->FunctionalDeviceObject = FunctionalDeviceObject;
    FdoExtension->ChildPdoList = NULL;

    //
    // Now attach to the PDO we were given.
    //

    AttachedDevice = IoAttachDeviceToDeviceStack(FunctionalDeviceObject,
                                                 PhysicalDeviceObject );
    if (AttachedDevice == NULL) {

        HalPrint(("Couldn't attach"));

        //
        // Couldn't attach.  Delete the FDO.
        //

        IoDeleteDevice( FunctionalDeviceObject );

        return STATUS_NO_SUCH_DEVICE;

    }

    FdoExtension->AttachedDeviceObject = AttachedDevice;

    //
    // Clear the device initializing flag.
    //

    FunctionalDeviceObject->Flags &= ~DO_DEVICE_INITIALIZING;

    //
    // Find any child PCI busses.
    //

    for ( BusNumber = 0;
          Bus = HaliReferenceHandlerForBus(PCIBus, BusNumber);
          BusNumber++ ) {

#ifdef APIC_HAL
        Status = HalpPci2MpsBusNumber((UCHAR)BusNumber, &MpsBusNumber);

        if (NT_SUCCESS(Status)) {

            if (!HalpMpsBusIsRootBus(MpsBusNumber)) {

                //
                // This is not a root PCI bus, so skip it.
                //
                continue;
            }
        }
#endif

        if (Bus->ParentHandler != NULL &&
            Bus->ParentHandler->InterfaceType == PCIBus) {

            //
            // Skip bridges.
            //

            HaliDereferenceBusHandler( Bus );
            continue;
        }

        //
        // Remove the system resoruces from the range lists.
        //

        Status = HalpRemoveAssignedResources( Bus );

        if (!NT_SUCCESS(Status)) {

            HaliDereferenceBusHandler( Bus );
            return Status;
        }

        _snwprintf( Buffer, sizeof(Buffer) / sizeof(Buffer[0]), L"\\Device\\Hal Pci %d", BusCount );
        RtlInitUnicodeString( &Unicode, Buffer );

        //
        // Next, create a PDO for the PCI driver.
        //

        Status = IoCreateDevice(
                    DriverObject,               // our driver object
                    sizeof(PDO_EXTENSION),      // size of our extension
                    &Unicode,                   // our name
                    FILE_DEVICE_BUS_EXTENDER,   // device type
                    0,                          // device characteristics
                    FALSE,                      // not exclusive
                    &ChildDeviceObject          // store new device object here
                    );

        if (!NT_SUCCESS(Status)) {

            HaliDereferenceBusHandler( Bus );
            return Status;
        }

        //
        // Fill in the PDO extension
        //

        PdoExtension = (PPDO_EXTENSION) ChildDeviceObject->DeviceExtension;
        PdoExtension->ExtensionType = PdoExtensionType;
        PdoExtension->PhysicalDeviceObject = ChildDeviceObject;
        PdoExtension->ParentFdoExtension = FdoExtension;
        PdoExtension->PdoType = PciDriver;
        PdoExtension->BusNumber = BusNumber;
        PdoExtension->MaxSubordinateBusNumber = 0xff;  // correct value later
        PdoExtension->Bus = Bus;

        BusCount++;

        //
        // Record this as a child of the HAL.  Add new childern at the
        // end of the list.
        //


        PdoExtension->Next = NULL;

        if (FdoExtension->ChildPdoList == NULL) {
            FdoExtension->ChildPdoList = ChildDeviceObject;
        } else {

            for (Pdo2 = FdoExtension->ChildPdoList;
                ((PPDO_EXTENSION) Pdo2->DeviceExtension)->Next != NULL;
                Pdo2 = ((PPDO_EXTENSION) Pdo2->DeviceExtension)->Next);

            ((PPDO_EXTENSION) Pdo2->DeviceExtension)->Next = ChildDeviceObject;
        }


        //
        // Clear the device initializing flag.
        //

        ChildDeviceObject->Flags &= ~DO_DEVICE_INITIALIZING;

    }

    //
    // Now loop through all the children PDOs making sure that
    // the MaxSubordinateBusNumbers are reasonable.  This loop
    // assumes that the list is sorted by BusNumber.
    //

    Pdo2 = FdoExtension->ChildPdoList;

    while (Pdo2) {

        if (!((PPDO_EXTENSION) Pdo2->DeviceExtension)->Next) {

            //
            // There is no next Pdo extension, which means that
            // this bus represents the last root bus, which means
            // that we can leave its subordinate bus number at 0xff.
            //

            break;
        }

        if (((PPDO_EXTENSION) Pdo2->DeviceExtension)->MaxSubordinateBusNumber >=
            ((PPDO_EXTENSION) ((PPDO_EXTENSION) Pdo2->DeviceExtension)->Next->DeviceExtension)->BusNumber) {

            //
            // Set the subordinate bus number at one less than the bus number of the
            // next root bus.
            //

            ((PPDO_EXTENSION)Pdo2->DeviceExtension)->MaxSubordinateBusNumber =
                ((PPDO_EXTENSION) ((PPDO_EXTENSION) Pdo2->DeviceExtension)->Next->DeviceExtension)->BusNumber - 1;
        }

        Pdo2 = ((PPDO_EXTENSION) Pdo2->DeviceExtension)->Next;
    }

    FdoExtension->BusCount = BusCount;

    if (BusCount == 0) {
        Bus = HaliReferenceHandlerForBus(Isa, 0);
        if (!Bus) {
            Bus = HaliReferenceHandlerForBus(Eisa, 0);
        }
        if (Bus) {
            RtlInitUnicodeString( &Unicode, L"\\Device\\Hal Isa 0" );
            PdoType = IsaPnpDriver;
        } else {
            Bus = HaliReferenceHandlerForBus(MicroChannel, 0);
            ASSERT(Bus);
            RtlInitUnicodeString( &Unicode, L"\\Device\\Hal Mca 0" );
            PdoType = McaDriver;
        }

        if (Bus) {

            //
            // Next, create a PDO for the PCI driver.
            //

            Status = IoCreateDevice(
                        DriverObject,               // our driver object
                        sizeof(PDO_EXTENSION),      // size of our extension
                        &Unicode,                   // our name
                        FILE_DEVICE_BUS_EXTENDER,   // device type
                        0,                          // device characteristics
                        FALSE,                      // not exclusive
                        &ChildDeviceObject          // store new device object here
                        );

            if (!NT_SUCCESS(Status)) {
                return Status;
            }

            //
            // Fill in the PDO extension
            //

            PdoExtension = (PPDO_EXTENSION) ChildDeviceObject->DeviceExtension;
            PdoExtension->ExtensionType = PdoExtensionType;
            PdoExtension->PhysicalDeviceObject = ChildDeviceObject;
            PdoExtension->ParentFdoExtension = FdoExtension;
            PdoExtension->BusNumber = 0;
            PdoExtension->MaxSubordinateBusNumber = 0;
            PdoExtension->Bus = Bus;
            PdoExtension->PdoType = PdoType;

            //
            // Record this as a child of the HAL
            //

            PdoExtension->Next = FdoExtension->ChildPdoList;
            FdoExtension->ChildPdoList = ChildDeviceObject;
            FdoExtension->BusCount = 1;

            //
            // Clear the device initializing flag.
            //

            ChildDeviceObject->Flags &= ~DO_DEVICE_INITIALIZING;
        }
    }
    return STATUS_SUCCESS;
}

NTSTATUS
HalpPassIrpFromFdoToPdo(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp
    )

/*++

Description:

    Given an FDO, pass the IRP to the next device object in the
    device stack.  This is the PDO if there are no lower level
    filters.

Arguments:

    DeviceObject - the Fdo
    Irp - the request

Return Value:

    Returns the result from calling the next level.

--*/

{

    PIO_STACK_LOCATION irpSp;       // our stack location
    PIO_STACK_LOCATION nextIrpSp;   // next guy's
    PFDO_EXTENSION     fdoExtension;

    HalPrint(("PassIrp ..."));

    //
    // Get the pointer to the device extension.
    //

    fdoExtension = (PFDO_EXTENSION)DeviceObject->DeviceExtension;

    IoSkipCurrentIrpStackLocation(Irp);

    //
    // Call the PDO driver with the request.
    //

    return IoCallDriver(fdoExtension->AttachedDeviceObject ,Irp);
}

NTSTATUS
HalpDispatchPnp(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    )

/*++

Routine Description:

    This routine handles all IRP_MJ_PNP_POWER IRPs for madeup PDO device.

Arguments:

    DeviceObject - Pointer to the device object for which this IRP applies.

    Irp - Pointer to the IRP_MJ_PNP_POWER IRP to dispatch.

Return Value:

    NT status.

--*/
{
    PIO_STACK_LOCATION irpSp;
    NTSTATUS Status;
    ULONG length;
    DEVICE_RELATION_TYPE relationType;
    EXTENSION_TYPE  extensionType;
    BOOLEAN passDown;
#if DBG
    PUCHAR objectTypeString;
#endif //DBG
    PPDO_EXTENSION pdoExtension;


    PAGED_CODE();

    pdoExtension = (PPDO_EXTENSION)DeviceObject->DeviceExtension;
    extensionType = ((PFDO_EXTENSION)pdoExtension)->ExtensionType;

    //
    // Get a pointer to our stack location and take appropriate action based
    // on the minor function.
    //

    irpSp = IoGetCurrentIrpStackLocation(Irp);
    switch (extensionType) {

    case PdoExtensionType:

#if DBG
        objectTypeString = "PDO";
#endif //DBG

        switch (irpSp->MinorFunction) {

        case IRP_MN_START_DEVICE:

            HalPrint(("(%s) Start_Device Irp received",
                       objectTypeString));

            Status = STATUS_SUCCESS;

            //
            // If we are starting a PCI PDO, then we want to
            // collect a little bit of information from the PCI driver.
            //

            if (pdoExtension->PdoType == PciDriver) {

                Status = HalpGetPciInterfaces(DeviceObject);
                ASSERT(NT_SUCCESS(Status));

                if (NT_SUCCESS(Status)) {

                    PciIrqRoutingInterface.InterfaceReference(PciIrqRoutingInterface.Context);

#ifdef WANT_IRQ_ROUTING

                    //
                    // Initialize Pci Irq Routing.
                    //

                    HalpPciIrqRoutingInfo.PciInterface = &PciIrqRoutingInterface;
                    if (NT_SUCCESS(HalpInitPciIrqRouting(&HalpPciIrqRoutingInfo)))
                    {
                        HalPrint(("Pci Irq Routing initialized successfully!"));
                    }
                    else
                    {
                        HalPrint(("No Pci Irq routing on this system!"));
                    }
#endif
                } else {

                    RtlZeroMemory(&PciIrqRoutingInterface, sizeof(INT_ROUTE_INTERFACE_STANDARD));
                }
            }

            break;


        case IRP_MN_QUERY_STOP_DEVICE:

            HalPrint(("(%s) Query_Stop_Device Irp received",
                       objectTypeString));

            Status = STATUS_SUCCESS;
            break;

        case IRP_MN_CANCEL_STOP_DEVICE:

            HalPrint(("(%s) Cancel_Stop_Device Irp received",
                       objectTypeString));

            Status = STATUS_SUCCESS;
            break;


        case IRP_MN_STOP_DEVICE:

            HalPrint(("(%s) Stop_Device Irp received",
                       objectTypeString));

            //
            // If we get a stop device request for a PDO, we simply
            // return success.
            //

            Status = STATUS_SUCCESS;
            break;

        case IRP_MN_QUERY_RESOURCES:

            HalPrint(("(%s) Query_Resources Irp received",
                       objectTypeString));

            Status = HalpQueryResources(DeviceObject,
                         (PCM_RESOURCE_LIST *)&Irp->IoStatus.Information);

            Status = STATUS_SUCCESS;
            break;

        case IRP_MN_QUERY_RESOURCE_REQUIREMENTS:

            HalPrint(("(%s) Query_Resource_Requirements Irp received",
                       objectTypeString));

            Status = HalpQueryResourceRequirements(DeviceObject,
                         (PIO_RESOURCE_REQUIREMENTS_LIST*)&Irp->IoStatus.Information);
            break;

        case IRP_MN_QUERY_REMOVE_DEVICE:

            HalPrint(("(%s) Query_Remove_device Irp for %x",
                       objectTypeString,
                       DeviceObject));

            Status = STATUS_UNSUCCESSFUL;
            break;

        case IRP_MN_CANCEL_REMOVE_DEVICE:

            HalPrint(("(%s) Cancel_Remove_device Irp for %x",
                       objectTypeString,
                       DeviceObject));

            Status = STATUS_SUCCESS;
            break;

        case IRP_MN_REMOVE_DEVICE:

            HalPrint(("(%s) Remove_device Irp for %x",
                       objectTypeString,
                       DeviceObject));

            if ((((PPDO_EXTENSION)(DeviceObject->DeviceExtension))->PdoType == PciDriver) &&
                (PciIrqRoutingInterface.InterfaceReference != NULL)) {

                PciIrqRoutingInterface.InterfaceDereference(PciIrqRoutingInterface.Context);
            }

            Status = STATUS_SUCCESS;
            break;

        case IRP_MN_QUERY_DEVICE_RELATIONS:

            HalPrint(("(%s) Query_Device_Relations Irp received",
                      objectTypeString));

            relationType = irpSp->Parameters.QueryDeviceRelations.Type;
            Status = HalpQueryDeviceRelations(DeviceObject,
                                              relationType,
                                              (PDEVICE_RELATIONS*)&Irp->IoStatus.Information);
            break;

        case IRP_MN_QUERY_DEVICE_TEXT:

            HalPrint(("(%s) Query Device Text Irp received",
                       objectTypeString));

            Status = HalpQueryDeviceText(DeviceObject,
                                         irpSp->Parameters.QueryDeviceText.DeviceTextType,
                                         (PWSTR*)&Irp->IoStatus.Information);

            break;

        case IRP_MN_QUERY_ID:

            HalPrint(("(%s) Query_Id Irp received",
                       objectTypeString));

            Status = HalpQueryIdPdo(DeviceObject,
                                 irpSp->Parameters.QueryId.IdType,
                                 (PWSTR*)&Irp->IoStatus.Information);

            break;

        case IRP_MN_QUERY_INTERFACE:

            HalPrint(("(%s) Query_Interface Irp received",
                       objectTypeString));

            Status = HalpQueryInterface(
                         DeviceObject,
                         irpSp->Parameters.QueryInterface.InterfaceType,
                         irpSp->Parameters.QueryInterface.Version,
                         irpSp->Parameters.QueryInterface.InterfaceSpecificData,
                         irpSp->Parameters.QueryInterface.Size,
                         irpSp->Parameters.QueryInterface.Interface,
                         &Irp->IoStatus.Information
                         );
            break;

        case IRP_MN_QUERY_CAPABILITIES:

            HalPrint(("(%s) Query_Capabilities Irp received",
                       objectTypeString));

            Status = HalpQueryCapabilities(DeviceObject,
                                           irpSp->Parameters.DeviceCapabilities.Capabilities);

            break;

        case IRP_MN_DEVICE_USAGE_NOTIFICATION:

            HalPrint(("(%s) Device_Usage_Notification Irp received",
                       objectTypeString));
            Status = STATUS_SUCCESS;

            break;

        default:

            HalPrint(("(%s) Unsupported Irp (%d) received",
                       objectTypeString,
                       irpSp->MinorFunction));

            Status = STATUS_NOT_SUPPORTED ;
            break;
        }

        break;  // end PDO cases

    case FdoExtensionType:

#if DBG
        objectTypeString = "FDO";
#endif //DBG
        passDown = TRUE;

        switch (irpSp->MinorFunction){

        case IRP_MN_QUERY_DEVICE_RELATIONS:

            HalPrint(("(%s) Query_Device_Relations Irp received",
                      objectTypeString));

            relationType = irpSp->Parameters.QueryDeviceRelations.Type;
            Status = HalpQueryDeviceRelations(DeviceObject,
                                              relationType,
                                              (PDEVICE_RELATIONS*)&Irp->IoStatus.Information);
            break;

        case IRP_MN_QUERY_ID:

            HalPrint(("(%s) Query_Id Irp received",
                       objectTypeString));

            Status = HalpQueryIdFdo(DeviceObject,
                                 irpSp->Parameters.QueryId.IdType,
                                 (PWSTR*)&Irp->IoStatus.Information);

            break;

#ifdef WANT_IRQ_ROUTING
        case IRP_MN_QUERY_INTERFACE:

            HalPrint(("(%s) Query_Interface Irp received",
                       objectTypeString));

            Status = HalpQueryInterfaceFdo(
                         DeviceObject,
                         irpSp->Parameters.QueryInterface.InterfaceType,
                         irpSp->Parameters.QueryInterface.Version,
                         irpSp->Parameters.QueryInterface.InterfaceSpecificData,
                         irpSp->Parameters.QueryInterface.Size,
                         irpSp->Parameters.QueryInterface.Interface,
                         &Irp->IoStatus.Information
                         );
            break;

#endif

        default:

            //
            // Ignore any PNP Irps unknown by the FDO but allow them
            // down to the PDO.
            //
            Status = STATUS_NOT_SUPPORTED ;
            break;
        }

        if (passDown && (NT_SUCCESS(Status) || (Status == STATUS_NOT_SUPPORTED))) {

            //
            // Pass FDO IRPs down to the PDO.
            //
            // Set Irp status first.
            //

            if (Status != STATUS_NOT_SUPPORTED) {

                Irp->IoStatus.Status = Status;
            }

            HalPrint(("(%s) Passing down Irp (%x)",
                      objectTypeString, irpSp->MinorFunction));
            return HalpPassIrpFromFdoToPdo(DeviceObject, Irp);
        }

        break;  // end FDO cases

    default:

        HalPrint(("Received IRP for unknown Device Object"));
        Status = STATUS_NOT_SUPPORTED;
        break;

    }

    //
    // Complete the Irp and return.
    //

    if (Status != STATUS_NOT_SUPPORTED) {

        Irp->IoStatus.Status = Status;

    } else {

        Status = Irp->IoStatus.Status ;

    }

    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    return Status;
}

NTSTATUS
HalpDispatchPower(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    )

/*++

Routine Description:

    This routine handles all IRP_MJ_POWER IRPs for madeup device.

Arguments:

    DeviceObject - Pointer to the device object for which this IRP applies.

    Irp - Pointer to the IRP_MJ_POWER IRP to dispatch.

Return Value:

    NT status.

--*/
{
    NTSTATUS Status;
    EXTENSION_TYPE  extensionType;
    PIO_STACK_LOCATION irpSp;

    HalPrint(("Power IRP for DevObj: %x", DeviceObject));

    //
    // Simply store the appropriate status and complete the request.
    //

    extensionType = ((PFDO_EXTENSION)(DeviceObject->DeviceExtension))->ExtensionType;

    irpSp = IoGetCurrentIrpStackLocation(Irp);

    //
    // Simply store the appropriate status and complete the request.
    //

    Status = Irp->IoStatus.Status;

    if ((irpSp->MinorFunction == IRP_MN_QUERY_POWER) ||
        (irpSp->MinorFunction == IRP_MN_SET_POWER)) {

        Irp->IoStatus.Status = Status = STATUS_SUCCESS;

    } else if (irpSp->MinorFunction == IRP_MN_WAIT_WAKE) {
        //
        // Fail this explicitly as we don't know how to wake the system...
        //
        Irp->IoStatus.Status = Status = STATUS_NOT_SUPPORTED;
    }

    PoStartNextPowerIrp(Irp);

    if (extensionType == PdoExtensionType) {

        IoCompleteRequest( Irp, IO_NO_INCREMENT );

    } else {

#ifdef APIC_HAL
        if (irpSp->MinorFunction == IRP_MN_SET_POWER) {
            if (irpSp->Parameters.Power.Type == SystemPowerState) {

                switch (irpSp->Parameters.Power.State.SystemState) {
                case PowerSystemHibernate:

                    HalpBuildResumeStructures();
                    break;

                case PowerSystemWorking:

                    HalpFreeResumeStructures();
                    break;

                default:
                    break;
                }
            }
        }
#endif

        Status = HalpPassIrpFromFdoToPdo(DeviceObject, Irp);
    }
    return Status;
}

NTSTATUS
HalpDispatchWmi(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    )
{
    NTSTATUS Status;
    EXTENSION_TYPE  extensionType;

    extensionType = ((PFDO_EXTENSION)(DeviceObject->DeviceExtension))->ExtensionType;

    if (extensionType == FdoExtensionType) {
        Status = HalpPassIrpFromFdoToPdo(DeviceObject, Irp);
    } else {
        Status = Irp->IoStatus.Status;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
    }

    return Status;
}


NTSTATUS
HalpQueryDeviceRelations(
    IN PDEVICE_OBJECT       DeviceObject,
    IN DEVICE_RELATION_TYPE RelationType,
    OUT PDEVICE_RELATIONS   *DeviceRelations
    )
/*++

Routine Description:

    This routine builds a DEVICE_RELATIONS structure that
    tells the PnP manager how many children we have.

Arguments:

    DeviceObject - FDO of PCI_HAL

    RelationType - we only respond to BusRelations

    DeviceRelations - pointer to the structure

Return Value:

    status

--*/
{
    PFDO_EXTENSION  FdoExtension;
    PDEVICE_RELATIONS   relations = NULL;
    ULONG count;
    PDEVICE_OBJECT  *Pdo;
    PDEVICE_OBJECT  Pdo2;
    EXTENSION_TYPE  extensionType;

    PAGED_CODE();

    FdoExtension = (PFDO_EXTENSION)DeviceObject->DeviceExtension;
    extensionType = FdoExtension->ExtensionType;
    count = FdoExtension->BusCount;

    switch (RelationType) {

        case BusRelations:

            if ((extensionType == PdoExtensionType)||(count == 0)) {

                //
                // Don't touch the IRP
                //
                return STATUS_NOT_SUPPORTED ;
            }

            if (*DeviceRelations != NULL) {
                count += (*DeviceRelations)->Count;
            }

            relations = ExAllocatePoolWithTag(
                PagedPool,
                sizeof(DEVICE_RELATIONS) +
                (count - 1) * sizeof( PDEVICE_OBJECT),
                HAL_POOL_TAG
                );

            if (relations == NULL) {
                HalPrint(("HalpQueryDeviceRelations: couldn't allocate pool"));
                return STATUS_INSUFFICIENT_RESOURCES;
            }

            relations->Count = count;
            Pdo = relations->Objects;

            count = 0;

            if (*DeviceRelations != NULL) {

                for ( count = 0; count < (*DeviceRelations)->Count; count++) {

                    *Pdo = (*DeviceRelations)->Objects[count];
                    Pdo++;
                }
                ExFreePool(*DeviceRelations);
            }

            //
            //  Add our PDO's to the list.
            //
            Pdo2 = FdoExtension->ChildPdoList;
            while (Pdo2 != NULL) {

                *Pdo = Pdo2;
                ObReferenceObject(Pdo2);
                Pdo2 = ((PPDO_EXTENSION) Pdo2->DeviceExtension)->Next;
                Pdo++;
                ASSERT( count++ < relations->Count );
            }

            *DeviceRelations = relations;
            return STATUS_SUCCESS;

        case TargetDeviceRelation:

            if (extensionType == FdoExtensionType) {

                //
                // Don't touch the IRP
                //
                return STATUS_NOT_SUPPORTED ;
            }

            relations = ExAllocatePoolWithTag(
                PagedPool,
                sizeof(DEVICE_RELATIONS),
                HAL_POOL_TAG
                );

            if (!relations) {

                return STATUS_INSUFFICIENT_RESOURCES;
            }

            relations->Count = 1;
            relations->Objects[0] = DeviceObject ;

            ObReferenceObject(relations->Objects[0]);
            *DeviceRelations = relations;

            return STATUS_SUCCESS ;

        default:

            break;
    }

    HalPrint(("We don't support this kind of device relation"));
    return STATUS_NOT_SUPPORTED ;
}

NTSTATUS
HalpQueryIdPdo(
    IN PDEVICE_OBJECT DeviceObject,
    IN BUS_QUERY_ID_TYPE IdType,
    IN OUT PWSTR *BusQueryId
    )
/*++

Routine Description:

    This routine identifies each of the children that were
    enumerated in HalpQueryDeviceRelations.

Arguments:

    DeviceObject - PDO of the child

    IdType - the type of ID to be returned.

    BusQueryId - pointer to the wide string being returned

Return Value:

    status

--*/
{
    PPDO_EXTENSION  PdoExtension = DeviceObject->DeviceExtension;
    PWSTR idString;
    PWCHAR sourceString = NULL;
    ULONG stringLen;
    UNICODE_STRING String;
    WCHAR Buffer[16];
    NTSTATUS Status;
    static WCHAR PciHardwareIdString[] = L"PCI_HAL\\PNP0A03";
    static WCHAR PciCompatibleString[] = L"*PNP0A03";
    static WCHAR IsaHardwareIdString[] = L"ISA_HAL\\PNP0A00";
    static WCHAR IsaCompatibleString[] = L"*PNP0A00";
    static WCHAR McaHardwareIdString[] = L"ISA_HAL\\PNP0A02";
    static WCHAR McaCompatibleString[] = L"*PNP0A02";

    PAGED_CODE();

    switch (IdType) {
    case BusQueryDeviceID:
    case BusQueryHardwareIDs:
        if (PdoExtension->PdoType == PciDriver) {
            sourceString = PciHardwareIdString;
            stringLen = sizeof(PciHardwareIdString);
        } else if (PdoExtension->PdoType == IsaPnpDriver) {
            sourceString = IsaHardwareIdString;
            stringLen = sizeof(IsaHardwareIdString);
        } else if (PdoExtension->PdoType == McaDriver) {
            sourceString = McaHardwareIdString;
            stringLen = sizeof(McaHardwareIdString);
        }
        break;

    case BusQueryCompatibleIDs:

        if (PdoExtension->PdoType == PciDriver) {
            sourceString = PciCompatibleString;
            stringLen = sizeof(PciCompatibleString);
        } else if (PdoExtension->PdoType == IsaPnpDriver) {
            sourceString = IsaCompatibleString;
            stringLen = sizeof(IsaCompatibleString);
        } else if (PdoExtension->PdoType == McaDriver) {
            sourceString = McaCompatibleString;
            stringLen = sizeof(McaCompatibleString);
        }
        break;

    case BusQueryInstanceID:

        String.Buffer = Buffer;
        String.MaximumLength = 16 * sizeof(WCHAR);
        Status = RtlIntegerToUnicodeString( PdoExtension->BusNumber, 10, &String );

        //
        //  Note the string length in this case does not include a NULL.
        //  the code below will terminate the string with NULL.
        //

        sourceString = Buffer;
        stringLen = String.Length;
        break;
    }
    if (sourceString) {

        //
        // Note that hardware IDs and compatible IDs must be terminated by
        // 2 NULLs.
        //

        idString = ExAllocatePoolWithTag(PagedPool,
                                         stringLen + sizeof(UNICODE_NULL),
                                         HAL_POOL_TAG);

        if (!idString) {
            HalPrint(("HalpQueryIdPdo: couldn't allocate pool\n"));
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        RtlCopyMemory(idString,
                      sourceString, stringLen);

        *(idString + stringLen / sizeof(WCHAR)) = UNICODE_NULL;

        *BusQueryId = idString;

        return STATUS_SUCCESS;
    } else {
        return STATUS_NOT_SUPPORTED;
    }
}
NTSTATUS
HalpQueryIdFdo(
    IN PDEVICE_OBJECT DeviceObject,
    IN BUS_QUERY_ID_TYPE IdType,
    IN OUT PWSTR *BusQueryId
    )
/*++

Routine Description:

    This routine identifies each of the children that were
    enumerated in HalpQueryDeviceRelations.

Arguments:

    DeviceObject - PDO of the child

    IdType - the type of ID to be returned.

    BusQueryId - pointer to the wide string being returned

Return Value:

    status

--*/
{
    PPDO_EXTENSION  PdoExtension = DeviceObject->DeviceExtension;
    PWSTR idString;
    PWCHAR sourceString = NULL;
    ULONG stringLen;
    UNICODE_STRING String;
    WCHAR Buffer[16];
    NTSTATUS Status;
    PWCHAR widechar;
    static WCHAR HalInstanceIdString[] = L"0";

    PAGED_CODE();

    switch (IdType) {
    case BusQueryDeviceID:
    case BusQueryHardwareIDs:

        //
        // For the UP version of the APIC HAL, we want to detect if there is more
        // than one processor installed. If so, we want to return the ID of
        // the MP HAL rather than the UP HAL. This will induce PNP to reconfigure
        // our devnode and setup the MP HAL for the next boot.
        //
        sourceString = HalHardwareIdString;
#if defined(NT_UP) && defined(APIC_HAL)
        if (HalpMpInfoTable.ProcessorCount > 1) {
            sourceString = MpHalHardwareIdString;
        }
#endif
        widechar = sourceString;
        while (*widechar != UNICODE_NULL) {
            widechar++;
        }
        stringLen =  (PUCHAR)widechar - ((PUCHAR)sourceString) + 2;
        break;

    case BusQueryInstanceID:

        sourceString = HalInstanceIdString;
        stringLen = sizeof(HalInstanceIdString);
        break;

    default:
        break;
    }
    if (sourceString) {

        //
        // Note that hardware IDs and compatible IDs must be terminated by
        // 2 NULLs.
        //

        idString = ExAllocatePoolWithTag(PagedPool,
                                         stringLen + sizeof(UNICODE_NULL),
                                         HAL_POOL_TAG);

        if (!idString) {
            HalPrint(("HalpQueryIdFdo: couldn't allocate pool\n"));
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        RtlCopyMemory(idString,
                      sourceString, stringLen);

        *(idString + stringLen / sizeof(WCHAR)) = UNICODE_NULL;

        *BusQueryId = idString;

        return STATUS_SUCCESS;
    } else {
        return STATUS_NOT_SUPPORTED;
    }
}

NTSTATUS
HalpQueryCapabilities(
    IN PDEVICE_OBJECT Pdo,
    IN PDEVICE_CAPABILITIES Capabilities
    )
/*++

Routine Description:

    This routine fills in the DEVICE_CAPABILITIES structure for
    a device.

Arguments:

    DeviceObject - PDO of the child

    Capabilities - pointer to the structure to be filled in.

Return Value:

    status

--*/
{
    PPDO_EXTENSION PdoExtension = (PPDO_EXTENSION) Pdo->DeviceExtension;
    PAGED_CODE();

    ASSERT_PDO_EXTENSION( PdoExtension );

    ASSERT(Capabilities->Version == 1);
    if (Capabilities->Version != 1) {

        return STATUS_NOT_SUPPORTED;

    }

    Capabilities->LockSupported = FALSE;
    Capabilities->EjectSupported = FALSE;
    Capabilities->Removable = FALSE;
    Capabilities->DockDevice = FALSE;
    Capabilities->UniqueID = TRUE;
    Capabilities->SilentInstall = TRUE;
    Capabilities->RawDeviceOK = FALSE;
    Capabilities->Address = PdoExtension->BusNumber;
    Capabilities->UINumber = PdoExtension->BusNumber;
    Capabilities->D1Latency = 0;
    Capabilities->D2Latency = 0;
    Capabilities->D3Latency = 0;

    //
    // Default S->D mapping
    //
    Capabilities->DeviceState[PowerSystemWorking] = PowerDeviceD0;
    Capabilities->DeviceState[PowerSystemHibernate] = PowerDeviceD3;
    Capabilities->DeviceState[PowerSystemShutdown] = PowerDeviceD3;

    //
    // Make it work on NTAPM --- note that we might have to check to see
    // if the machine supports APM before we do this
    //
    Capabilities->DeviceState[PowerSystemSleeping3] = PowerDeviceD3;

    return STATUS_SUCCESS;
}

NTSTATUS
HalpQueryInterface(
    IN     PDEVICE_OBJECT   DeviceObject,
    IN     LPCGUID          InterfaceType,
    IN     USHORT           Version,
    IN     PVOID            InterfaceSpecificData,
    IN     ULONG            InterfaceBufferSize,
    IN OUT PINTERFACE       Interface,
    IN OUT PULONG           Length
    )

/*++

Routine Description:

    This routine fills in the interface structure for
    a device.

Arguments:

    DeviceObject - PDO of the child

    InterfaceType - Pointer to the interface type GUID.

    Version - Supplies the requested interface version.

    InterfaceSpecificData - This is context that means something based on the
                            interface.

    InterfaceBufferSize - Supplies the length of the buffer for the interface
                          structure.

    Interface - Supplies a pointer where the interface informaiton should
        be returned.

    Length - This value is updated on return to actual number of bytes modified.

Return Value:

    status

--*/
{
    PPDO_EXTENSION PdoExtension = (PPDO_EXTENSION)DeviceObject->DeviceExtension;
    CM_RESOURCE_TYPE resource = (CM_RESOURCE_TYPE)InterfaceSpecificData;

    PAGED_CODE();

    ASSERT_PDO_EXTENSION(PdoExtension);

    if (IsEqualGUID(&GUID_BUS_INTERFACE_STANDARD, InterfaceType)) {

        PBUS_INTERFACE_STANDARD standard = (PBUS_INTERFACE_STANDARD)Interface;

        //
        // ASSERT we know about all of the fields in the structure.
        //

        ASSERT(sizeof(BUS_INTERFACE_STANDARD) == FIELD_OFFSET(BUS_INTERFACE_STANDARD, GetBusData) + sizeof(PGET_SET_DEVICE_DATA));

        *Length = sizeof(BUS_INTERFACE_STANDARD);

        if (InterfaceBufferSize < sizeof(BUS_INTERFACE_STANDARD)) {
            return STATUS_BUFFER_TOO_SMALL;
        }

        //
        //  The only version this code knows about is 1.
        //

        standard->Size = sizeof(BUS_INTERFACE_STANDARD);
        standard->Version = HAL_BUS_INTERFACE_STD_VERSION;
        standard->Context = DeviceObject;

        standard->InterfaceReference = HalPnpInterfaceReference;
        standard->InterfaceDereference = HalPnpInterfaceDereference;
        standard->TranslateBusAddress = HalPnpTranslateBusAddress;
        standard->GetDmaAdapter = HalPnpGetDmaAdapter;
        standard->SetBusData = NULL;
        standard->GetBusData = NULL;

    } else if ((IsEqualGUID(&GUID_PCI_BUS_INTERFACE_STANDARD, InterfaceType)) &&
               (PdoExtension->PdoType == PciDriver)) {

        PPCI_BUS_INTERFACE_STANDARD pciStandard = (PPCI_BUS_INTERFACE_STANDARD)Interface;

        *Length = sizeof(PCI_BUS_INTERFACE_STANDARD);

        if (InterfaceBufferSize < sizeof(PCI_BUS_INTERFACE_STANDARD)) {
            return STATUS_BUFFER_TOO_SMALL;
        }

        //
        // Fill in the interface, which is used for reading and
        // writing PCI configuration space.
        //

        pciStandard->Size = sizeof(PCI_BUS_INTERFACE_STANDARD);
        pciStandard->Version = PCI_BUS_INTERFACE_STANDARD_VERSION;
        pciStandard->Context = DeviceObject;

        pciStandard->InterfaceReference = HalPnpInterfaceReference;
        pciStandard->InterfaceDereference = HalPnpInterfaceDereference;
        pciStandard->ReadConfig = HaliPciInterfaceReadConfig;
        pciStandard->WriteConfig = HaliPciInterfaceWriteConfig;
        pciStandard->PinToLine = NULL;
        pciStandard->LineToPin = NULL;

#if 0

    } else if (IsEqualGUID(&GUID_TRANSLATOR_INTERFACE_STANDARD, InterfaceType)) {

        PTRANSLATOR_INTERFACE translator = (PTRANSLATOR_INTERFACE)Interface;

        if (InterfaceBufferSize < sizeof(TRANSLATOR_INTERFACE)) {

            *Length = sizeof(TRANSLATOR_INTERFACE);
            return STATUS_BUFFER_TOO_SMALL;
        }

        switch ((CM_RESOURCE_TYPE)InterfaceSpecificData) {

        case CmResourceTypeInterrupt:

            switch(PdoExtension->PdoType) {
            case PciDriver:
                translator->Context = (PVOID)PCIBus;
                break;
            case IsaPnpDriver:
                translator->Context = (PVOID)Isa;
                break;
            case McaDriver:
                translator->Context = (PVOID)MicroChannel;
                break;
            default:

                //
                // Don't know how to handle this.
                //

                HalPrint(("HAL: PDO %08x unknown Type 0x%x, failing QueryInterface\n",
                          DeviceObject,
                          PdoExtension->PdoType
                          ));

                return STATUS_NOT_SUPPORTED;
            }
            translator->Version = HAL_IRQ_TRANSLATOR_VERSION;
            translator->TranslateResources = HalIrqTranslateResourcesRoot;
            translator->TranslateResourceRequirements =
                HalIrqTranslateResourceRequirementsRoot;

            break;


//      Truth is, halx86 doesn't provide translators for memory or
//      io resources either.   But if it did, it would look like this.

        case CmResourceTypeMemory:
        case CmResourceTypePort:

            translator->Context = DeviceObject;
            translator->Version = HAL_MEMIO_TRANSLATOR_VERSION;
            translator->TranslateResources = HalpTransMemIoResource;
            translator->TranslateResourceRequirements =
                HalpTransMemIoResourceRequirement;
            break;


        default:
            return STATUS_NOT_SUPPORTED;
        }


        //
        // Common initialization
        //
        translator->Size = sizeof(TRANSLATOR_INTERFACE);
        translator->InterfaceReference = HalPnpInterfaceReference;
        translator->InterfaceDereference = HalPnpInterfaceDereference;

        *Length = sizeof(TRANSLATOR_INTERFACE);

#endif

#ifdef WANT_IRQ_ROUTING
    } else if ( IsPciIrqRoutingEnabled() &&
                IsEqualGUID(&GUID_TRANSLATOR_INTERFACE_STANDARD, InterfaceType) &&
                resource == CmResourceTypeInterrupt &&
                PdoExtension->PdoType == PciDriver) {

        //
        // We want to arbitrate on untranslated resources, so we get rid of Irq
        // translator provided by Pci iff Irq Routing is enabled.
        //

        HalPrint(("Getting rid of Pci Irq translator interface since Pci Irq Routing is enabled!"));

        RtlZeroMemory((LPGUID)InterfaceType, sizeof(GUID));

        return STATUS_NOT_SUPPORTED;

#endif

    } else {

        //
        //  Unsupport bus interface type.
        //

        return STATUS_NOT_SUPPORTED ;
    }

    //
    // Bump the reference count.
    //

    InterlockedIncrement(&PdoExtension->InterfaceReferenceCount);

    return STATUS_SUCCESS;
}

#ifdef WANT_IRQ_ROUTING

NTSTATUS
HalpQueryInterfaceFdo(
    IN     PDEVICE_OBJECT   DeviceObject,
    IN     LPCGUID          InterfaceType,
    IN     USHORT           Version,
    IN     PVOID            InterfaceSpecificData,
    IN     ULONG            InterfaceBufferSize,
    IN OUT PINTERFACE       Interface,
    IN OUT PULONG           Length
    )

/*++

Routine Description:

    This routine fills in the interface structure for
    a device.

Arguments:

    DeviceObject - FDO of the child

    InterfaceType - Pointer to the interface type GUID.

    Version - Supplies the requested interface version.

    InterfaceSpecificData - This is context that means something based on the
                            interface.

    InterfaceBufferSize - Supplies the length of the buffer for the interface
                          structure.

    Interface - Supplies a pointer where the interface informaiton should
        be returned.

    Length - Supplies the length of the buffer for the interface structure.
        This value is updated on return to actual number of bytes modified.

Return Value:

    status

--*/
{
    NTSTATUS                status = STATUS_NOT_SUPPORTED;
    CM_RESOURCE_TYPE        resource = (CM_RESOURCE_TYPE)InterfaceSpecificData;

    PAGED_CODE();

    if (    resource == CmResourceTypeInterrupt &&
            IsPciIrqRoutingEnabled()) {

        if (IsEqualGUID(&GUID_ARBITER_INTERFACE_STANDARD, InterfaceType)) {

            status = HalpInitIrqArbiter(DeviceObject);

            if (NT_SUCCESS(status))
            {
                status = HalpFillInIrqArbiter(
                    DeviceObject,
                    InterfaceType,
                    Version,
                    InterfaceSpecificData,
                    InterfaceBufferSize,
                    Interface,
                    Length
                    );
            }
        }
        else if (IsEqualGUID(&GUID_TRANSLATOR_INTERFACE_STANDARD, InterfaceType)) {

            PTRANSLATOR_INTERFACE   translator;

            *Length = sizeof(TRANSLATOR_INTERFACE);
            if (InterfaceBufferSize < sizeof(TRANSLATOR_INTERFACE)) {
                return STATUS_BUFFER_TOO_SMALL;
            }

            translator = (PTRANSLATOR_INTERFACE)Interface;

            //
            // Fill in the common bits.
            //

            RtlZeroMemory(translator, sizeof (TRANSLATOR_INTERFACE));
            translator->Size = sizeof(TRANSLATOR_INTERFACE);
            translator->Version = HAL_IRQ_TRANSLATOR_VERSION;
            translator->Context = DeviceObject;
            translator->InterfaceReference = HalTranslatorReference;
            translator->InterfaceDereference = HalTranslatorDereference;

            //
            // Set IRQ translator for PCI interrupts.
            //

            translator->TranslateResources = HalIrqTranslateResourcesRoot;
            translator->TranslateResourceRequirements =
                                            HalIrqTranslateResourceRequirementsRoot;

            status = STATUS_SUCCESS;

            HalPrint(("Providing Irq translator for FDO %08x since Pci Irq Routing is enabled!", DeviceObject));
        }
    }

    return (status);
}

#endif

NTSTATUS
HalpQueryDeviceText(
    IN PDEVICE_OBJECT DeviceObject,
    IN DEVICE_TEXT_TYPE IdType,
    IN OUT PWSTR *BusQueryId
    )
/*++

Routine Description:

    This routine identifies each of the children that were
    enumerated in HalpQueryDeviceRelations.

Arguments:

    DeviceObject - PDO of the child

    IdType - the type of ID to be returned.

    BusQueryId - pointer to the wide string being returned

Return Value:

    status

--*/
{
    PPDO_EXTENSION  PdoExtension = DeviceObject->DeviceExtension;
    PWSTR idString;
    PWCHAR sourceString = NULL;
    ULONG stringLen;
    NTSTATUS Status;
    static WCHAR PciDeviceNameText[] = L"Pci Root Bus";
    static WCHAR IsaDeviceNameText[] = L"Isa Root Bus";
    static WCHAR McaDeviceNameText[] = L"Mca Root Bus";

    PAGED_CODE();

    if (PdoExtension->PdoType == PciDriver) {
        sourceString = PciDeviceNameText;
        stringLen = sizeof(PciDeviceNameText);
    } else if (PdoExtension->PdoType == IsaPnpDriver) {
        sourceString = IsaDeviceNameText;
        stringLen = sizeof(IsaDeviceNameText);
    } else if (PdoExtension->PdoType == McaDriver) {
        sourceString = McaDeviceNameText;
        stringLen = sizeof(McaDeviceNameText);
    }
    if (sourceString) {
        switch (IdType) {
        case DeviceTextDescription:
        case DeviceTextLocationInformation:

            idString = ExAllocatePoolWithTag(PagedPool,
                                             stringLen,
                                             HAL_POOL_TAG);

            if (!idString) {
                HalPrint(("HalpQueryDeviceText: couldn't allocate pool\n"));
                return STATUS_INSUFFICIENT_RESOURCES;
            }

            RtlCopyMemory(idString,
                          sourceString, stringLen);

            *BusQueryId = idString;

            return STATUS_SUCCESS;
        }
    }

    return STATUS_NOT_SUPPORTED;
}

NTSTATUS
HalpQueryResources(
    IN  PDEVICE_OBJECT DeviceObject,
    IN  PCM_RESOURCE_LIST *Resources
    )
/*++

Routine Description:

    This routine handles IRP_MN_QUERY_RESOURCE_REQUIREMENTS.

Arguments:

    DeviceObject - PDO of the child

    Resources - pointer to be filled in with the devices
        resource list.

Return Value:

    status

--*/
{
    PPDO_EXTENSION  PdoExtension = DeviceObject->DeviceExtension;
    PCM_RESOURCE_LIST  ResourceList;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR Descriptor;
    PSUPPORTED_RANGE Range;
    ULONG ResourceListSize;
    ULONG Count = 1;


    if (PdoExtension->PdoType != PciDriver) {

        *Resources = NULL;
        return STATUS_SUCCESS;
    }

    //
    // Determine the number of resourse list needed.  Already counted
    // one for the Bus Number.
    //

    for (Range = &PdoExtension->Bus->BusAddresses->IO; Range != NULL; Range = Range->Next) {

        //
        // If the limit is zero then skip this entry.
        //

        if (Range->Limit == 0) {
            continue;
        }

        Count++;
    }

    for (Range = &PdoExtension->Bus->BusAddresses->Memory; Range != NULL; Range = Range->Next) {

        //
        // If the limit is zero then skip this entry.
        //

        if (Range->Limit == 0) {
            continue;
        }

        Count++;
    }

    for (Range = &PdoExtension->Bus->BusAddresses->PrefetchMemory; Range != NULL; Range = Range->Next) {

        //
        // If the limit is zero then skip this entry.
        //

        if (Range->Limit == 0) {
            continue;
        }

        Count++;
    }

    //
    // Convert this resourceListSize into the number of bytes that we
    // must allocate
    //

    ResourceListSize = sizeof(CM_RESOURCE_LIST) +
        ( (Count - 1) * sizeof(CM_PARTIAL_RESOURCE_DESCRIPTOR) );

    ResourceList = ExAllocatePoolWithTag(
                       PagedPool,
                       ResourceListSize,
                       HAL_POOL_TAG);

    if (ResourceList == NULL ) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory( ResourceList, ResourceListSize );

    //
    // Initialize the list header.
    //

    ResourceList->Count = 1;
    ResourceList->List[0].InterfaceType = PNPBus;
    ResourceList->List[0].BusNumber = -1;
    ResourceList->List[0].PartialResourceList.Version = 1;
    ResourceList->List[0].PartialResourceList.Revision = 1;
    ResourceList->List[0].PartialResourceList.Count = Count;
    Descriptor = ResourceList->List[0].PartialResourceList.PartialDescriptors;

    //
    // Create descriptor for the Bus Number.
    //

    Descriptor->Type = CmResourceTypeBusNumber;
    Descriptor->ShareDisposition = CmResourceShareShared;
    Descriptor->u.BusNumber.Start = PdoExtension->BusNumber;
    Descriptor->u.BusNumber.Length = PdoExtension->MaxSubordinateBusNumber -
                                        PdoExtension->BusNumber + 1;
    Descriptor++;

    for (Range = &PdoExtension->Bus->BusAddresses->IO; Range != NULL; Range = Range->Next) {

        //
        // If the limit is zero then skip this entry.
        //

        if (Range->Limit == 0) {
            continue;
        }

        Descriptor->Type = CmResourceTypePort;
        Descriptor->ShareDisposition = CmResourceShareShared;
        Descriptor->Flags = CM_RESOURCE_PORT_IO;
        Descriptor->u.Port.Length = (ULONG)(Range->Limit - Range->Base) + 1;
        Descriptor->u.Port.Start.QuadPart = Range->Base;
        Descriptor++;
    }

    for (Range = &PdoExtension->Bus->BusAddresses->Memory; Range != NULL; Range = Range->Next) {

        //
        // If the limit is zero then skip this entry.
        //

        if (Range->Limit == 0) {
            continue;
        }

        Descriptor->Type = CmResourceTypeMemory;
        Descriptor->ShareDisposition = CmResourceShareShared;
        Descriptor->Flags = CM_RESOURCE_MEMORY_READ_WRITE;
        Descriptor->u.Memory.Length = (ULONG)(Range->Limit - Range->Base) + 1;
        Descriptor->u.Memory.Start.QuadPart = Range->Base;
        Descriptor++;

    }

    for (Range = &PdoExtension->Bus->BusAddresses->PrefetchMemory; Range != NULL; Range = Range->Next) {

        //
        // If the limit is zero then skip this entry.
        //

        if (Range->Limit == 0) {
            continue;
        }

        Descriptor->Type = CmResourceTypeMemory;
        Descriptor->ShareDisposition = CmResourceShareShared;
        Descriptor->Flags = CM_RESOURCE_MEMORY_READ_WRITE | CM_RESOURCE_MEMORY_PREFETCHABLE;
        Descriptor->u.Memory.Length = (ULONG)(Range->Limit - Range->Base) + 1;
        Descriptor->u.Memory.Start.QuadPart = Range->Base;
        Descriptor++;
    }

    *Resources = ResourceList;

    return STATUS_SUCCESS;

}

NTSTATUS
HalpQueryResourceRequirements(
    IN  PDEVICE_OBJECT DeviceObject,
    IN  PIO_RESOURCE_REQUIREMENTS_LIST *Requirements
    )
/*++

Routine Description:

    This routine handles IRP_MN_QUERY_RESOURCE_REQUIREMENTS.

Arguments:

    DeviceObject - PDO of the child

    Requirements - pointer to be filled in with the devices
        resource requirements.

Return Value:

    status

--*/
{
    PPDO_EXTENSION  PdoExtension = DeviceObject->DeviceExtension;
    PIO_RESOURCE_REQUIREMENTS_LIST  ResourceList;
    PIO_RESOURCE_DESCRIPTOR Descriptor;
    PSUPPORTED_RANGE Range;
    ULONG ResourceListSize;
    ULONG Count = 0;


    if (PdoExtension->PdoType != PciDriver) {

        *Requirements = NULL;
        return STATUS_SUCCESS;
    }

    //
    // Determine the number of resourse list needed.
    //

    for (Range = &PdoExtension->Bus->BusAddresses->IO; Range != NULL; Range = Range->Next) {

        //
        // If the limit is zero then skip this entry.
        //

        if (Range->Limit == 0) {
            continue;
        }

        Count++;
    }

    for (Range = &PdoExtension->Bus->BusAddresses->Memory; Range != NULL; Range = Range->Next) {

        //
        // If the limit is zero then skip this entry.
        //

        if (Range->Limit == 0) {
            continue;
        }

        Count++;
    }

    for (Range = &PdoExtension->Bus->BusAddresses->PrefetchMemory; Range != NULL; Range = Range->Next) {

        //
        // If the limit is zero then skip this entry.
        //

        if (Range->Limit == 0) {
            continue;
        }

        Count++;
    }

    //
    // Convert this resourceListSize into the number of bytes that we
    // must allocate
    //

    ResourceListSize = sizeof(IO_RESOURCE_REQUIREMENTS_LIST) +
        ( (Count - 1) * sizeof(IO_RESOURCE_DESCRIPTOR) );

    ResourceList = ExAllocatePoolWithTag(
                       PagedPool,
                       ResourceListSize,
                       HAL_POOL_TAG);

    if (ResourceList == NULL ) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory( ResourceList, ResourceListSize );
    ResourceList->ListSize = ResourceListSize;

    //
    // Initialize the list header.
    //

    ResourceList->AlternativeLists = 1;
    ResourceList->InterfaceType = PNPBus;
    ResourceList->BusNumber = -1;
    ResourceList->List[0].Version = 1;
    ResourceList->List[0].Revision = 1;
    ResourceList->List[0].Count = Count;
    Descriptor = ResourceList->List[0].Descriptors;

    for (Range = &PdoExtension->Bus->BusAddresses->IO; Range != NULL; Range = Range->Next) {

        //
        // If the limit is zero then skip this entry.
        //

        if (Range->Limit == 0) {
            continue;
        }

        Descriptor->Type = CmResourceTypePort;
        Descriptor->ShareDisposition = CmResourceShareShared;
        Descriptor->Flags = CM_RESOURCE_PORT_IO;
        Descriptor->u.Port.Length = (ULONG) (Range->Limit - Range->Base + 1);
        Descriptor->u.Port.Alignment = 0x01;
        Descriptor->u.Port.MinimumAddress.QuadPart = Range->Base;
        Descriptor->u.Port.MaximumAddress.QuadPart = Range->Limit;
        Descriptor++;
    }

    for (Range = &PdoExtension->Bus->BusAddresses->Memory; Range != NULL; Range = Range->Next) {

        //
        // If the limit is zero then skip this entry.
        //

        if (Range->Limit == 0) {
            continue;
        }

        Descriptor->Type = CmResourceTypeMemory;
        Descriptor->ShareDisposition = CmResourceShareShared;
        Descriptor->Flags = CM_RESOURCE_MEMORY_READ_WRITE;
        Descriptor->u.Memory.Length = (ULONG) (Range->Limit - Range->Base + 1);
        Descriptor->u.Memory.Alignment = 0x01;
        Descriptor->u.Memory.MinimumAddress.QuadPart = Range->Base;
        Descriptor->u.Memory.MaximumAddress.QuadPart = Range->Limit;
        Descriptor++;

    }

    for (Range = &PdoExtension->Bus->BusAddresses->PrefetchMemory; Range != NULL; Range = Range->Next) {

        //
        // If the limit is zero then skip this entry.
        //

        if (Range->Limit == 0) {
            continue;
        }

        Descriptor->Type = CmResourceTypeMemory;
        Descriptor->ShareDisposition = CmResourceShareShared;
        Descriptor->Flags = CM_RESOURCE_MEMORY_READ_WRITE | CM_RESOURCE_MEMORY_PREFETCHABLE;
        Descriptor->u.Memory.Length = (ULONG) (Range->Limit - Range->Base + 1);
        Descriptor->u.Memory.Alignment = 0x01;
        Descriptor->u.Memory.MinimumAddress.QuadPart = Range->Base;
        Descriptor->u.Memory.MaximumAddress.QuadPart = Range->Limit;
        Descriptor++;
    }

    *Requirements = ResourceList;

    return STATUS_SUCCESS;

}

NTSTATUS
HalpRemoveAssignedResources (
    PBUS_HANDLER Bus
    )
/*

Routine Description:

    Reads the rgzResourceMap in the registry and builds a canonical list of
    all in use resources ranges by resource type.

Arguments:



*/
{
    HANDLE                          ClassKeyHandle, DriverKeyHandle;
    HANDLE                          ResourceMap;
    ULONG                           ClassKeyIndex, DriverKeyIndex, DriverValueIndex;
    PCM_RESOURCE_LIST               CmResList;
    PCM_FULL_RESOURCE_DESCRIPTOR    CmFResDesc;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR CmDesc;
    UNICODE_STRING                  KeyName;
    ULONG                           BufferSize;
    union {
        PVOID                       Buffer;
        PKEY_BASIC_INFORMATION      KeyBInf;
        PKEY_FULL_INFORMATION       KeyFInf;
        PKEY_VALUE_FULL_INFORMATION VKeyFInf;
    } U;
    PUCHAR                          LastAddr;
    ULONG                           Temp, Length, i, j;
    ULONG                           TranslatedStrLen;
    ULONG                           BusTranslatedStrLen;
    NTSTATUS                        Status;
    LONGLONG                        li;

    PAGED_CODE();

    //
    // Removed page zero.
    //

    HalpRemoveRange( &Bus->BusAddresses->Memory,
                     0i64,
                     (LONGLONG) (PAGE_SIZE - 1)
                     );

    //
    // Start out with one page of buffer.
    //

    BufferSize = PAGE_SIZE;

    U.Buffer = ExAllocatePoolWithTag(
                   PagedPool,
                   BufferSize,
                   HAL_POOL_TAG);
    if (U.Buffer == NULL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    for (TranslatedStrLen=0; rgzTranslated[TranslatedStrLen]; TranslatedStrLen++) ;
    for (BusTranslatedStrLen=0; rgzBusTranslated[BusTranslatedStrLen]; BusTranslatedStrLen++) ;
    TranslatedStrLen    *= sizeof (WCHAR);
    BusTranslatedStrLen *= sizeof (WCHAR);

    RtlInitUnicodeString( &KeyName, rgzResourceMap );

    Status = HalpOpenRegistryKey( &ResourceMap, NULL, &KeyName, KEY_READ, FALSE );

    if (!NT_SUCCESS( Status )) {
        HalPrint(("HalRemoveSystemResourcesFromPci: Failed to open resource map key Status = %lx\n", Status ));
        ExFreePool( U.Buffer );
        return Status;
    }


    //
    // Walk resource map and collect any inuse resources
    //

    ClassKeyIndex = 0;

    ClassKeyHandle  = INVALID_HANDLE;
    DriverKeyHandle = INVALID_HANDLE;
    Status = STATUS_SUCCESS;

    while (NT_SUCCESS(Status)) {

        //
        // Get the class information
        //

        Status = ZwEnumerateKey( ResourceMap,
                                 ClassKeyIndex++,
                                 KeyBasicInformation,
                                 U.KeyBInf,
                                 BufferSize,
                                 &Temp );

        if (!NT_SUCCESS( Status )) {
            break;
        }


        //
        // Create a UNICODE_STRING using the counted string passed back to
        // us in the information structure, and open the class key.
        //

        KeyName.Buffer = (PWSTR)  U.KeyBInf->Name;
        KeyName.Length = (USHORT) U.KeyBInf->NameLength;
        KeyName.MaximumLength = (USHORT) U.KeyBInf->NameLength;

        Status = HalpOpenRegistryKey( &ClassKeyHandle,
                                     ResourceMap,
                                     &KeyName,
                                     KEY_READ,
                                     FALSE  );

        if (!NT_SUCCESS( Status )) {
            break;
        }

        DriverKeyIndex = 0;
        while (NT_SUCCESS (Status)) {

            //
            // Get the class information
            //

            Status = ZwEnumerateKey( ClassKeyHandle,
                                     DriverKeyIndex++,
                                     KeyBasicInformation,
                                     U.KeyBInf,
                                     BufferSize,
                                     &Temp );

            if (!NT_SUCCESS( Status )) {
                break;
            }

            //
            // Create a UNICODE_STRING using the counted string passed back to
            // us in the information structure, and open the class key.
            //
            // This is read from the key we created, and the name
            // was NULL terminated.
            //

            KeyName.Buffer = (PWSTR)  U.KeyBInf->Name;
            KeyName.Length = (USHORT) U.KeyBInf->NameLength;
            KeyName.MaximumLength = (USHORT) U.KeyBInf->NameLength;

            Status = HalpOpenRegistryKey( &DriverKeyHandle,
                                         ClassKeyHandle,
                                         &KeyName,
                                         KEY_READ,
                                         FALSE);

            if (!NT_SUCCESS( Status )) {
                break;
            }

            //
            // Get full information for that key so we can get the
            // information about the data stored in the key.
            //

            Status = ZwQueryKey( DriverKeyHandle,
                                 KeyFullInformation,
                                 U.KeyFInf,
                                 BufferSize,
                                 &Temp );

            if (!NT_SUCCESS( Status )) {
                break;
            }

            Length = sizeof( KEY_VALUE_FULL_INFORMATION ) +
                U.KeyFInf->MaxValueNameLen + U.KeyFInf->MaxValueDataLen + sizeof(UNICODE_NULL);

            if (Length > BufferSize) {
                PVOID TempBuffer;

                //
                // Get a larger buffer
                //

                TempBuffer = ExAllocatePoolWithTag(
                                 PagedPool,
                                 Length,
                                 HAL_POOL_TAG);
                if (TempBuffer == NULL) {
                    Status = STATUS_INSUFFICIENT_RESOURCES;
                    break;
                }

                ExFreePool (U.Buffer);
                U.Buffer = TempBuffer;
                BufferSize = Length;
            }

            DriverValueIndex = 0;
            for (; ;) {
                Status = ZwEnumerateValueKey( DriverKeyHandle,
                                              DriverValueIndex++,
                                              KeyValueFullInformation,
                                              U.VKeyFInf,
                                              BufferSize,
                                              &Temp );

                if (!NT_SUCCESS( Status )) {
                    break;
                }

                //
                // If this is not a translated resource list, skip it.
                //

                i = U.VKeyFInf->NameLength;
                if (i < TranslatedStrLen ||
                    RtlCompareMemory (
                        ((PUCHAR) U.VKeyFInf->Name) + i - TranslatedStrLen,
                        rgzTranslated,
                        TranslatedStrLen
                        ) != TranslatedStrLen
                    ) {
                    // does not end in rgzTranslated
                    continue;
                }

                //
                // If this is a bus translated resource list, ????
                //

                if (i >= BusTranslatedStrLen &&
                    RtlCompareMemory (
                        ((PUCHAR) U.VKeyFInf->Name) + i - BusTranslatedStrLen,
                        rgzBusTranslated,
                        BusTranslatedStrLen
                        ) == BusTranslatedStrLen
                    ) {

                    // ends in rgzBusTranslated
                    continue;
                }


                //
                // Run the CmResourceList and save each InUse resource
                //

                CmResList = (PCM_RESOURCE_LIST) ( (PUCHAR) U.VKeyFInf + U.VKeyFInf->DataOffset);
                LastAddr  = (PUCHAR) CmResList + U.VKeyFInf->DataLength;
                CmFResDesc = &CmResList->List[0];

                for (i=0; i < CmResList->Count && NT_SUCCESS(Status) ; i++) {

                    for (j=0; j < CmFResDesc->PartialResourceList.Count && NT_SUCCESS(Status); j++) {

                        CmDesc = &CmFResDesc->PartialResourceList.PartialDescriptors[j];

                        if ((PUCHAR) (CmDesc+1) > LastAddr) {
                            if (i) {
                                HalPrint(("IopAssignResourcesPhase2: a. CmResourceList in regitry too short\n"));
                            }
                            break;
                        }


                        if ((PUCHAR) (CmDesc+1) > LastAddr) {
                            i = CmResList->Count;
                            HalPrint(("IopAssignResourcesPhase2: b. CmResourceList in regitry too short\n"));
                            break;
                        }

                        switch (CmDesc->Type) {
                        case CmResourceTypePort:

                            HalpRemoveRange( &Bus->BusAddresses->IO,
                                             CmDesc->u.Generic.Start.QuadPart,
                                             CmDesc->u.Generic.Start.QuadPart +
                                             CmDesc->u.Generic.Length - 1
                                             );

                            break;

                        case CmResourceTypeMemory:

                            //
                            // The HAL's notion of prefetchable may not be
                            // consistent.  So just remove any memory resource
                            // from both the prefetchable and non-prefetchable
                            // lists.
                            //

                            HalpRemoveRange( &Bus->BusAddresses->PrefetchMemory,
                                             CmDesc->u.Generic.Start.QuadPart,
                                             CmDesc->u.Generic.Start.QuadPart +
                                             CmDesc->u.Generic.Length - 1
                                             );


                            HalpRemoveRange( &Bus->BusAddresses->Memory,
                                             CmDesc->u.Generic.Start.QuadPart,
                                             CmDesc->u.Generic.Start.QuadPart +
                                             CmDesc->u.Generic.Length - 1
                                             );

                            break;

                        default:
                            break;
                        }
                    }

                  //
                  // Start at the end of the last CmDesc
                  // since the PCM_PARTIAL_RESOURCE_DESCRIPTOR array
                  // is variable size we can't just use the index.
                  //
                  (PCM_PARTIAL_RESOURCE_DESCRIPTOR) CmFResDesc = CmDesc+1;

                }

            }   // next DriverValueIndex

            if (DriverKeyHandle != INVALID_HANDLE) {
                ZwClose (DriverKeyHandle);
                DriverKeyHandle = INVALID_HANDLE;
            }

            if (Status == STATUS_NO_MORE_ENTRIES) {
                Status = STATUS_SUCCESS;
            }

            if (!NT_SUCCESS(Status)) {
                break;
            }
        }   // next DriverKeyIndex

        if (ClassKeyHandle != INVALID_HANDLE) {
            ZwClose (ClassKeyHandle);
            ClassKeyHandle = INVALID_HANDLE;
        }

        if (Status == STATUS_NO_MORE_ENTRIES) {
            Status = STATUS_SUCCESS;
        }

    }   // next ClassKeyIndex

    if (Status == STATUS_NO_MORE_ENTRIES) {
        Status = STATUS_SUCCESS;
    }

    ZwClose( ResourceMap );
    ExFreePool (U.Buffer);

    HalpConsolidateRanges (Bus->BusAddresses);

    return Status;
}


VOID
HalpMarkNonAcpiHal(
    VOID
    )

/*++

Routine Description:


Arguments:

    None.

Return Value:

    None.

--*/
{
    ULONG tmpValue;
    UNICODE_STRING unicodeString;
    HANDLE hCurrentControlSet, handle;
    NTSTATUS status;

    PAGED_CODE();

    //
    // Open/create System\CurrentControlSet key.
    //

    RtlInitUnicodeString(&unicodeString, L"\\REGISTRY\\MACHINE\\SYSTEM\\CURRENTCONTROLSET");
    status = HalpOpenRegistryKey (
                 &hCurrentControlSet,
                 NULL,
                 &unicodeString,
                 KEY_ALL_ACCESS,
                 FALSE
                 );
    if (!NT_SUCCESS(status)) {
        return;
    }

    //
    // Open HKLM\System\CurrentControlSet\Control\Pnp
    //

    RtlInitUnicodeString(&unicodeString, L"Control\\Pnp");
    status = HalpOpenRegistryKey (
                 &handle,
                 hCurrentControlSet,
                 &unicodeString,
                 KEY_ALL_ACCESS,
                 TRUE
                 );
    ZwClose(hCurrentControlSet);
    if (!NT_SUCCESS(status)) {
        return;
    }

    RtlInitUnicodeString(&unicodeString, L"DisableFirmwareMapper");
    tmpValue = 0;
    ZwSetValueKey(handle,
                  &unicodeString,
                  0,
                  REG_DWORD,
                  &tmpValue,
                  sizeof(tmpValue)
                  );
    ZwClose(handle);
}

VOID
HalpMarkChipsetDecode(
    BOOLEAN FullDecodeChipset
    )

/*++

Routine Description:


Arguments:

    FullDecodeChipset   - TRUE if NTOSKRNL should consider all fixed I/O
                          descriptors for PNPBIOS devices as 16bit. FALSE if
                          they should be taken at their word.

Return Value:

    None.

--*/
{
    ULONG tmpValue;
    UNICODE_STRING unicodeString;
    HANDLE hCurrentControlSet, handle;
    NTSTATUS status;

    PAGED_CODE();

    //
    // Open/create System\CurrentControlSet key.
    //

    RtlInitUnicodeString(&unicodeString, L"\\REGISTRY\\MACHINE\\SYSTEM\\CURRENTCONTROLSET");
    status = HalpOpenRegistryKey (
                 &hCurrentControlSet,
                 NULL,
                 &unicodeString,
                 KEY_ALL_ACCESS,
                 FALSE
                 );
    if (!NT_SUCCESS(status)) {
        return;
    }

    //
    // Open HKLM\System\CurrentControlSet\Control\Biosinfo\PNPBios
    //

    RtlInitUnicodeString(&unicodeString, L"Control\\Biosinfo\\PNPBios");
    status = HalpOpenRegistryKey (
                 &handle,
                 hCurrentControlSet,
                 &unicodeString,
                 KEY_ALL_ACCESS,
                 TRUE
                 );
    ZwClose(hCurrentControlSet);
    if (!NT_SUCCESS(status)) {
        return;
    }

    RtlInitUnicodeString(&unicodeString, L"FullDecodeChipsetOverride");
    tmpValue = (ULONG) FullDecodeChipset;
    ZwSetValueKey(handle,
                  &unicodeString,
                  0,
                  REG_DWORD,
                  &tmpValue,
                  sizeof(tmpValue)
                  );
    ZwClose(handle);
}

NTSTATUS
HalpOpenRegistryKey(
    OUT PHANDLE Handle,
    IN HANDLE BaseHandle OPTIONAL,
    IN PUNICODE_STRING KeyName,
    IN ACCESS_MASK DesiredAccess,
    IN BOOLEAN Create
    )

/*++

Routine Description:

    Opens or creates a VOLATILE registry key using the name passed in based
    at the BaseHandle node.

Arguments:

    Handle - Pointer to the handle which will contain the registry key that
        was opened.

    BaseHandle - Handle to the base path from which the key must be opened.

    KeyName - Name of the Key that must be opened/created.

    DesiredAccess - Specifies the desired access that the caller needs to
        the key.

    Create - Determines if the key is to be created if it does not exist.

Return Value:

   The function value is the final status of the operation.

--*/

{
    OBJECT_ATTRIBUTES objectAttributes;
    ULONG disposition;

    PAGED_CODE();

    //
    // Initialize the object for the key.
    //

    InitializeObjectAttributes( &objectAttributes,
                                KeyName,
                                OBJ_CASE_INSENSITIVE,
                                BaseHandle,
                                (PSECURITY_DESCRIPTOR) NULL );

    //
    // Create the key or open it, as appropriate based on the caller's
    // wishes.
    //

    if (Create) {
        return ZwCreateKey( Handle,
                            DesiredAccess,
                            &objectAttributes,
                            0,
                            (PUNICODE_STRING) NULL,
                            REG_OPTION_VOLATILE,
                            &disposition );
    } else {
        return ZwOpenKey( Handle,
                          DesiredAccess,
                          &objectAttributes );
    }
}


VOID
HalPnpInterfaceReference(
    PVOID Context
    )
/*++

Routine Description:

    This function increments the reference count on the interface context.

Arguments:

    Context - Supplies a pointer to the interface context.  This is actually
        the PDO for the root bus.

Return Value:

    None

--*/
{
    PPDO_EXTENSION  PdoExtension = ((PDEVICE_OBJECT) Context)->DeviceExtension;
    PAGED_CODE();

    ASSERT_PDO_EXTENSION( PdoExtension );

    InterlockedIncrement( &PdoExtension->InterfaceReferenceCount );
}

VOID
HalPnpInterfaceDereference(
    PVOID Context
    )
/*++

Routine Description:

    This function decrements the reference count on the interface context.

Arguments:

    Context - Supplies a pointer to the interface context.  This is actually
        the PDO for the root bus.

Return Value:

    None

--*/
{
    PPDO_EXTENSION  PdoExtension = ((PDEVICE_OBJECT) Context)->DeviceExtension;
    LONG Result;

    PAGED_CODE();

    ASSERT_PDO_EXTENSION( PdoExtension );

    Result = InterlockedDecrement( &PdoExtension->InterfaceReferenceCount );

    ASSERT( Result >= 0 );
}

BOOLEAN
HalPnpTranslateBusAddress(
    IN PVOID Context,
    IN PHYSICAL_ADDRESS BusAddress,
    IN ULONG Length,
    IN OUT PULONG AddressSpace,
    OUT PPHYSICAL_ADDRESS TranslatedAddress
    )
/*++

Routine Description:

    This function is used to translate bus addresses from legacy drivers.

Arguments:

    Context - Supplies a pointer to the interface context.  This is actually
        the PDO for the root bus.

    BusAddress - Supplies the orginal address to be translated.

    Length - Supplies the length of the range to be translated.

    AddressSpace - Points to the location of of the address space type such as
        memory or I/O port.  This value is updated by the translation.

    TranslatedAddress - Returns the translated address.

Return Value:

    Returns a boolean indicating if the operations was a success.

--*/
{
    PPDO_EXTENSION  PdoExtension = ((PDEVICE_OBJECT) Context)->DeviceExtension;
    PBUS_HANDLER Bus;
    PAGED_CODE();

    ASSERT_PDO_EXTENSION( PdoExtension );

    Bus = PdoExtension->Bus;

    return Bus->TranslateBusAddress( Bus,
                                          Bus,
                                          BusAddress,
                                          AddressSpace,
                                          TranslatedAddress );


}

ULONG
HalPnpReadConfig(
    IN PVOID Context,
    IN ULONG Slot,
    IN PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Length
    )
/*++

Routine Description:

    This function reads the PCI configuration space.

Arguments:

    Context - Supplies a pointer to the interface context.  This is actually
        the PDO for the root bus.

    Slot - Indicates the slot to be read or writen.

    Buffer - Supplies a pointer to where the data should be placed.

    Offset - Indicates the offset into the data where the reading should begin.

    Length - Indicates the count of bytes which should be read.

Return Value:

    Returns the number of bytes read.

--*/
{
    PPDO_EXTENSION  PdoExtension = ((PDEVICE_OBJECT) Context)->DeviceExtension;
    PBUS_HANDLER Bus;
    PAGED_CODE();

    ASSERT_PDO_EXTENSION( PdoExtension );

    Bus = PdoExtension->Bus;

    return Bus->GetBusData( Bus, Bus, Slot, Buffer, Offset, Length );

}

ULONG
HalPnpWriteConfig(
    IN PVOID Context,
    IN ULONG Slot,
    IN PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Length
    )
/*++

Routine Description:

    This function writes the PCI configuration space.

Arguments:

    Context - Supplies a pointer  to the interface context.  This is actually
        the PDO for the root bus.

    Slot - Indicates the slot to be read or writen.

    Buffer - Supplies a pointer to where the data to be written is.

    Offset - Indicates the offset into the data where the writing should begin.

    Length - Indicates the count of bytes which should be written.

Return Value:

    Returns the number of bytes read.

--*/
{
    PPDO_EXTENSION  PdoExtension = ((PDEVICE_OBJECT) Context)->DeviceExtension;
    PBUS_HANDLER Bus;
    PAGED_CODE();

    ASSERT_PDO_EXTENSION( PdoExtension );

    Bus = PdoExtension->Bus;

    return Bus->SetBusData( Bus, Bus, Slot, Buffer, Offset, Length );

}

PDMA_ADAPTER
HalPnpGetDmaAdapter(
    IN PVOID Context,
    IN struct _DEVICE_DESCRIPTION *DeviceDescriptor,
    OUT PULONG NumberOfMapRegisters
    )
/*++

Routine Description:

    This function writes the PCI configuration space.

Arguments:

    Context - Supplies a pointer  to the interface context.  This is actually
        the PDO for the root bus.

    DeviceDescriptor - Supplies the device descriptor used to allocate the dma
        adapter object.

    NubmerOfMapRegisters - Returns the maximum number of map registers a device
        can allocate at one time.

Return Value:

    Returns a DMA adapter or NULL.

--*/
{
    PPDO_EXTENSION  PdoExtension = ((PDEVICE_OBJECT) Context)->DeviceExtension;
    PBUS_HANDLER Bus;
    PAGED_CODE();

    ASSERT_PDO_EXTENSION( PdoExtension );

    Bus = PdoExtension->Bus;

    //
    //  Fill in the bus number.
    //

    DeviceDescriptor->BusNumber = Bus->BusNumber;
    return (PDMA_ADAPTER) HalGetAdapter( DeviceDescriptor, NumberOfMapRegisters );
}

NTSTATUS
HalpGetPciInterfaces(
    IN PDEVICE_OBJECT PciPdo
    )
/*++

Routine Description:

    This function queries the PCI driver for interfaces used in interrupt
    translation and arbitration.

Arguments:

    PciPdo - PDO of a PCI bus

Return Value:

--*/
{
    NTSTATUS            status;
    PDEVICE_OBJECT      topDeviceInStack;
    KEVENT              irpCompleted;
    PIRP                irp;
    IO_STATUS_BLOCK     statusBlock;
    PIO_STACK_LOCATION  irpStack;

    PAGED_CODE();

    KeInitializeEvent(&irpCompleted, SynchronizationEvent, FALSE);

    //
    // Send an IRP to the PCI driver to get the Interrupt Routing Interface.
    //
    topDeviceInStack = IoGetAttachedDeviceReference(PciPdo);

    irp = IoBuildSynchronousFsdRequest(IRP_MJ_PNP,
                                       topDeviceInStack,
                                       NULL,    // Buffer
                                       0,       // Length
                                       0,       // StartingOffset
                                       &irpCompleted,
                                       &statusBlock);

    if (!irp) {
        return STATUS_UNSUCCESSFUL;
    }

    irp->IoStatus.Status = STATUS_NOT_SUPPORTED;
    irp->IoStatus.Information = 0;

    irpStack = IoGetNextIrpStackLocation(irp);

    //
    // Set the function codes and parameters.
    //

    irpStack->MinorFunction = IRP_MN_QUERY_INTERFACE;
    irpStack->Parameters.QueryInterface.InterfaceType = &GUID_INT_ROUTE_INTERFACE_STANDARD;
    irpStack->Parameters.QueryInterface.Size = sizeof(INT_ROUTE_INTERFACE_STANDARD);
    irpStack->Parameters.QueryInterface.Version = 1;
    irpStack->Parameters.QueryInterface.Interface = (PINTERFACE) &PciIrqRoutingInterface;
    irpStack->Parameters.QueryInterface.InterfaceSpecificData = NULL;

    //
    // Call the driver and wait for completion
    //

    status = IoCallDriver(topDeviceInStack, irp);

    if (status == STATUS_PENDING) {

        KeWaitForSingleObject(&irpCompleted, Executive, KernelMode, FALSE, NULL);
        status = statusBlock.Status;
    }

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halx86\i386\ixqspin.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    isqspin.c

Abstract:

    This module provides an (optionally) instrumented, platform independent
    implementation of the Kernel Import Queued Spinlock routines.  Where
    optimal performance is required, platform dependent versions are
    used.   The code in this file can be used to bootstrap a system or
    on UP systems where them MP version is only used during installation.

    ref: ACM Transactions on Computer Systems, Vol. 9, No. 1, Feb 1991.
         Algorithms for Global Synchronization on Shared Memory
         Multiprocessors.

    The basic algorithm is as follows:

    When attempting to acquire the spinlock, the contents of the spinlock
    is atomically exchanged with the address of the context of the acquirer.
    If the previous value was zero, the acquisition attempt is successful.
    If non-zero, it is a pointer to the context of the most recent attempt
    to acquire the lock (which may have been successful or may be waiting).
    The next pointer in this most recent context is updated to point to
    the context of the new waiter (this attempt).

    When releasing the lock, a compare exchange is done with the contents
    of the lock and the address of the releasing context, if the compare
    succeeds, zero is stored in the lock and it has been released.  If
    not equal, another thread is waiting and that thread is granted the
    lock.

    Benefits:

    . Each processor spins on a local variable.  Standard spinlocks
    have each processor spinning on the same variable which is possibly
    in a dirty cache line causing this cache line to be passed from
    processor to processor repeatedly.
    . The lock is granted to the requestors in the order the requests
    for the lock were made (ie fair).
    . Atomic operations are reduced to one for each acquire and one
    for each release.

    In this implementation, the context structure for the commonly
    used (high frequency) system locks is in a table in the PRCB,
    and references to a lock are made by the lock's index.

Author:

    Peter L Johnston (peterj) 20-August-1998

Environment:

    Kernel Mode only.

Revision History:

--*/


#include "halp.h"

#if defined(_X86_)
#pragma intrinsic(_enable)
#pragma intrinsic(_disable)
#endif

//
// Define the YIELD instruction.
//

#if defined(_X86_) && !defined(NT_UP)

#define YIELD()     _asm { rep nop }

#else

#define YIELD()

#endif

#define INIT_DEBUG_BREAKER 0x10000000

#if !defined(NT_UP)

VOID
FASTCALL
HalpAcquireQueuedSpinLock (
    IN PKSPIN_LOCK_QUEUE Current
    )

/*++

Routine Description:

    This function acquires the specified queued spinlock.  IRQL must be
    high enough on entry to grarantee a processor switch cannot occur.

Arguments:

    Current     Address of Queued Spinlock structure.

Return Value:

    None.

--*/

{
    PKSPIN_LOCK_QUEUE Previous;
    PULONG            Lock;

#if DBG

    ULONG             DebugBreaker;

#endif

    //
    // Attempt to acquire the lock.
    //

    Lock = (PULONG)&Current->Lock;

    ASSERT((*Lock & 3) == 0);

    Previous = InterlockedExchangePointer(Current->Lock, Current);

    if (Previous == NULL) {

        *Lock |= LOCK_QUEUE_OWNER;

    } else {

        //
        // Lock is already held, update next pointer in previous
        // context to point to this new waiter and wait until the
        // lock is granted.
        //

        volatile ULONG * LockBusy = (ULONG *)&Current->Lock;

        ASSERT(Previous->Next == NULL);
        ASSERT(!(*LockBusy & LOCK_QUEUE_WAIT));

        *LockBusy |= LOCK_QUEUE_WAIT;

        Previous->Next = Current;

#if DBG

        DebugBreaker = INIT_DEBUG_BREAKER;

#endif

        while ((*LockBusy) & LOCK_QUEUE_WAIT) {
            YIELD();

#if DBG

            if (--DebugBreaker == 0) {
                DbgBreakPoint();
            }

#endif

        }

        ASSERT(*LockBusy & LOCK_QUEUE_OWNER);
    }
}

LOGICAL
FASTCALL
HalpTryToAcquireQueuedSpinLock (
    IN KSPIN_LOCK_QUEUE_NUMBER Number
    )

/*++

Routine Description:

    This function attempts to acquire the specified queued spinlock.
    Interrupts are disabled.

Arguments:

    Number      Queued Spinlock Number.

Return Value:

    TRUE    If the lock was acquired,
    FALSE   if it is already held by another processor.

--*/

{
    PKSPIN_LOCK_QUEUE Current;
    PKSPIN_LOCK_QUEUE Owner;

    //
    // See if the lock is available.
    //

    Current = &(KeGetCurrentPrcb()->LockQueue[Number]);

    ASSERT(((ULONG)Current->Lock & 3) == 0);

    if (!*(Current->Lock)) {
        Owner = InterlockedCompareExchangePointer(Current->Lock, Current, NULL);

        if (Owner == NULL) {

            //
            // Lock has been acquired.
            //

            Current->Lock = (PKSPIN_LOCK)
                            (((ULONG)Current->Lock) | LOCK_QUEUE_OWNER);
            return TRUE;
        }
    }

    return FALSE;
}

VOID
FASTCALL
HalpReleaseQueuedSpinLock (
    IN PKSPIN_LOCK_QUEUE Current
    )

/*++

Routine Description:

    Release a (queued) spinlock.   If other processors are waiting
    on this lock, hand the lock to the next in line.

Arguments:

    Current     Address of Queued Spinlock structure.

Return Value:

    None.

--*/

{
    PKSPIN_LOCK_QUEUE Next;
    PULONG            Lock;
    volatile VOID **  Waiting;

#if DBG

    ULONG             DebugBreaker = INIT_DEBUG_BREAKER;

#endif

    Lock = (PULONG)&Current->Lock;

    ASSERT((*Lock & 3) == LOCK_QUEUE_OWNER);

    //
    // Clear lock owner in my own struct.
    //

    *Lock ^= LOCK_QUEUE_OWNER;

    Next = Current->Next;

    if (!Next) {

        //
        // No waiter, attempt to release the lock.   As there is no other
        // waiter, the current lock value should be THIS lock structure
        // ie "Current".  We do a compare exchange Current against the
        // lock, if it succeeds, the lock value is replaced with NULL and
        // the lock has been released.  If the compare exchange fails it
        // is because someone else has acquired but hadn't yet updated
        // our next field (which we checked above).
        //

        Next = InterlockedCompareExchangePointer(Current->Lock, NULL, Current);

        if (Next == Current) {

            //
            // Lock has been released.
            //

            return;
        }

        //
        // There is another waiter,... but our next pointer hadn't been
        // updated when we checked earlier.   Wait for it to be updated.
        //

        Waiting = (volatile VOID **)&Current->Next;

        while (!*Waiting) {
            YIELD();

#if DBG

            if (--DebugBreaker == 0) {
                DbgBreakPoint();
            }

#endif

        }

        Next = (struct _KSPIN_LOCK_QUEUE *)*Waiting;
    }

    //
    // Hand the lock to the next waiter.
    //

    Lock = (PULONG)&Next->Lock;
    ASSERT((*Lock & 3) == LOCK_QUEUE_WAIT);

    Current->Next = NULL;

    *Lock ^= (LOCK_QUEUE_WAIT + LOCK_QUEUE_OWNER);
}

#endif


VOID
FASTCALL
KeReleaseQueuedSpinLock (
    IN KSPIN_LOCK_QUEUE_NUMBER Number,
    IN KIRQL OldIrql
    )

/*++

Routine Description:

    Release a (queued) spinlock.   If other processors are waiting
    on this lock, hand the lock to the next in line.

Arguments:

    Number      Queued Spinlock Number.
    OldIrql     IRQL to lower to once the lock has been released.

Return Value:

    None.

--*/

{

#if !defined(NT_UP)

    HalpReleaseQueuedSpinLock(&KeGetCurrentPrcb()->LockQueue[Number]);

#endif

    KfLowerIrql(OldIrql);
}

KIRQL
FASTCALL
KeAcquireQueuedSpinLock(
    IN KSPIN_LOCK_QUEUE_NUMBER Number
    )

/*++

Routine Description:

    Raise to DISPATCH_LEVEL and acquire the specified queued spinlock.

Arguments:

    Number      Queued Spinlock Number.

Return Value:

    OldIrql     The IRQL prior to raising to DISPATCH_LEVEL.

--*/

{
    KIRQL OldIrql;

    OldIrql = KfRaiseIrql(DISPATCH_LEVEL);

#if !defined(NT_UP)

    HalpAcquireQueuedSpinLock(&(KeGetCurrentPrcb()->LockQueue[Number]));

#endif

    return OldIrql;
}

KIRQL
FASTCALL
KeAcquireQueuedSpinLockRaiseToSynch (
    IN KSPIN_LOCK_QUEUE_NUMBER Number
    )

/*++

Routine Description:

    Raise to SYNCH_LEVEL and acquire the specified queued spinlock.

Arguments:

    Number      Queued Spinlock Number.

Return Value:

    OldIrql     The IRQL prior to raising to SYNCH_LEVEL.

--*/

{
    KIRQL OldIrql;

    OldIrql = KfRaiseIrql(SYNCH_LEVEL);

#if !defined(NT_UP)

    HalpAcquireQueuedSpinLock(&(KeGetCurrentPrcb()->LockQueue[Number]));

#endif

    return OldIrql;
}

LOGICAL
FASTCALL
KeTryToAcquireQueuedSpinLock(
    IN KSPIN_LOCK_QUEUE_NUMBER Number,
    IN PKIRQL OldIrql
    )

/*++

Routine Description:

    Attempt to acquire the specified queued spinlock.  If successful,
    raise IRQL to DISPATCH_LEVEL.

Arguments:

    Number      Queued Spinlock Number.
    OldIrql     Pointer to KIRQL to receive the old IRQL.

Return Value:

    TRUE        if the lock was acquired,
    FALSE       otherwise.

--*/

{

#if !defined(NT_UP)

    LOGICAL Success;

    _disable();
    Success = HalpTryToAcquireQueuedSpinLock(Number);
    if (Success) {
        *OldIrql = KfRaiseIrql(DISPATCH_LEVEL);
    }
    _enable();
    return Success;

#else

    *OldIrql = KfRaiseIrql(DISPATCH_LEVEL);
    return TRUE;

#endif
}

LOGICAL
FASTCALL
KeTryToAcquireQueuedSpinLockRaiseToSynch(
    IN KSPIN_LOCK_QUEUE_NUMBER Number,
    IN PKIRQL OldIrql
    )

/*++

Routine Description:

    Attempt to acquire the specified queued spinlock.  If successful,
    raise IRQL to SYNCH_LEVEL.

Arguments:

    Number      Queued Spinlock Number.
    OldIrql     Pointer to KIRQL to receive the old IRQL.

Return Value:

    TRUE        if the lock was acquired,
    FALSE       otherwise.

--*/

{

#if !defined(NT_UP)

    LOGICAL Success;

    _disable();
    Success = HalpTryToAcquireQueuedSpinLock(Number);
    if (Success) {
        *OldIrql = KfRaiseIrql(SYNCH_LEVEL);
    }
    _enable();
    return Success;

#else

    *OldIrql = KfRaiseIrql(SYNCH_LEVEL);
    return TRUE;

#endif
}

VOID
FASTCALL
KeAcquireInStackQueuedSpinLock (
    IN PKSPIN_LOCK SpinLock,
    IN PKLOCK_QUEUE_HANDLE LockHandle
    )

{

#if !defined(NT_UP)

    LockHandle->LockQueue.Next = NULL;
    LockHandle->LockQueue.Lock = SpinLock;

#endif

    LockHandle->OldIrql = KeRaiseIrqlToDpcLevel();

#if !defined(NT_UP)

    HalpAcquireQueuedSpinLock(&LockHandle->LockQueue);

#endif

    return;
}


VOID
FASTCALL
KeAcquireInStackQueuedSpinLockRaiseToSynch (
    IN PKSPIN_LOCK SpinLock,
    IN PKLOCK_QUEUE_HANDLE LockHandle
    )

{

#if !defined(NT_UP)

    LockHandle->LockQueue.Next = NULL;
    LockHandle->LockQueue.Lock = SpinLock;

#endif

    LockHandle->OldIrql = KeRaiseIrqlToSynchLevel();

#if !defined(NT_UP)

    HalpAcquireQueuedSpinLock(&LockHandle->LockQueue);

#endif

    return;
}


VOID
FASTCALL
KeReleaseInStackQueuedSpinLock (
    IN PKLOCK_QUEUE_HANDLE LockHandle
    )

{

#if !defined(NT_UP)

    HalpReleaseQueuedSpinLock(&LockHandle->LockQueue);

#endif

    KeLowerIrql(LockHandle->OldIrql);
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halx86\i386\ixslpctx.asm ===
title  "Sleep Context"
;++
;
; Copyright (c) 1989  Microsoft Corporation
;
; Module Name:
;
;    ixslpctx.asm
;
; Abstract:
;
;    This module implements the code for saving processor
;    context before putting the machine to sleep.  It also
;    contains the code for building a page that a processor
;    in real mode can jump to in order to transition into
;    p-mode and assume a thread context.
;
; Author:
;
;    Jake Oshins (jakeo) March 13, 1998
;
; Environment:
;
;    Kernel mode only.
;
; Revision History:
;
;    Much of this code has been moved from halmps\i386\mpsproca.asm.
;
;--

.386p
        .xlist
include hal386.inc
include callconv.inc                    ; calling convention macros
include apic.inc
include i386\ixslpctx.inc
include mac386.inc
        .list

        extrn   _HalpLowStub:DWORD
        extrn   _HalpIsNXEnabled@0:proc
        extrn   _KeSaveStateForHibernate:proc
ifdef ACPI_HAL        
        EXTRNP  HalpAcpiFlushCache, 0,,FASTCALL
endif

PAGELK16 SEGMENT DWORD PUBLIC USE16 'CODE'       ; start 16 bit code


;++
;
; VOID
; _StartPx_RMStub
;
; Routine Description:
;
;   When a new processor is started, it starts in real-mode and is
;   sent to a copy of this function which has been copied into low memory.
;   (below 1m and accessable from real-mode).
;
;   Once CR0 has been set, this function jmp's to a StartPx_PMStub
;
; Arguments:
;    none
;
; Return Value:
;    does not return, jumps to StartPx_PMStub
;
;--
cPublicProc _StartPx_RMStub  ,0
    cli

    db  066h                            ; load the GDT
    lgdt    fword ptr cs:[SPx_PB.PsSpecialRegisters.SrGdtr]

    db  066h                            ; load the IDT
    lidt    fword ptr cs:[SPx_PB.PsSpecialRegisters.SrIdtr]

    mov     eax, cs:[SPx_TiledCR3]

    nop                                 ; Fill - Ensure 13 non-page split
    nop                                 ; accesses before CR3 load
    nop                                 ; (P6 errata #11 stepping B0)
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop

    mov     cr3, eax

    ;
    ; Restore CR4 to enable Page Size Extensions
    ; before we got real CR3 which might use Large Page.
    ; If SrCr4 is non-zero, then CR4 exists
    ;

    mov     eax, dword ptr cs:[SPx_PB.PsSpecialRegisters.SrCr4]
    or      eax, eax
    jz      @f
.586p
    mov     cr4, eax
.386p
@@:

    ;
    ; Check whether NX should be enabled for this processor
    ;

    test    cs:[SPx_flag], SPX_FLAG_NX
    jz      @f

    ;
    ; NX should be enabled.  We can assume that this processor can
    ; support NX mode (and that it is in PAE mode)
    ;

.586p
    push    edx
    mov     ecx, 0c0000080h
    rdmsr
    or      eax, 0800h
    mov     ecx, 0c0000080h
    wrmsr
.386p
    pop     edx

@@:

    mov     ebp, dword ptr cs:[SPx_P0EBP]
    mov     ecx, dword ptr cs:[SPx_PB.PsContextFrame.CsSegDs]
    mov     ebx, dword ptr cs:[SPx_PB.PsSpecialRegisters.SrCr3]
    mov     eax, dword ptr cs:[SPx_PB.PsSpecialRegisters.SrCr0]
    mov     edi, dword ptr cs:[SPx_flat_addr]

    mov     cr0, eax                    ; into prot mode

    db  066h
    db  0eah                            ; reload cs:eip
SPrxPMStub  dd  0
SPrxFlatCS  dw  0

_StartPx_RMStub_Len      equ     $ - _StartPx_RMStub
stdENDP _StartPx_RMStub


PAGELK16 ends                            ; End 16 bit code

PAGELK    SEGMENT PARA PUBLIC 'CODE'       ; Start 32 bit code
        ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING

;++
;
; VOID
; StartPx_PMStub
;
; Routine Description:
;
;   This function completes the processor's state loading, and signals
;   the requesting processor that the state has been loaded.
;
; Arguments:
;    ebx    - requested CR3 for this processors_state
;    cx     - requested ds for this processors_state
;    ebp    - EBP of P0
;    edi    - p-mode address of startup block
;
; Return Value:
;    does not return - completes the loading of the processors_state
;
;--
    align   dword    ; to make sure we don't cross a page boundry
            ; before reloading CR3

cPublicProc _StartPx_PMStub  ,0

    ; process is now in the load image copy of this function.
    ; (ie, it's not the low memory copy)

    mov     cr3, ebx                    ; get real CR3
    mov     ds, cx                      ; set real ds

    lea     esi, [edi].SPx_PB.PsSpecialRegisters

    lldt    word ptr ds:[esi].SrLdtr    ; load ldtr

    ;
    ; Force the TSS descriptor into a non-busy state, so we don't fault
    ; when we load the TR.
    ;
    mov     eax, ds:[esi].SrGdtr+2      ; (eax)->GDT base
    xor     ecx, ecx
    mov     cx,  word ptr ds:[esi].SrTr
    add     eax, 5
    add     eax, ecx                    ; (eax)->TSS Desc. Byte
    and     byte ptr [eax],NOT 2

    ltr     word ptr ds:[esi].SrTr      ; load tss

    lea     edx, [edi].SPx_PB.PsContextFrame
    mov     es, word ptr ds:[edx].CsSegEs   ; Set other selectors
    mov     fs, word ptr ds:[edx].CsSegFs
    mov     gs, word ptr ds:[edx].CsSegGs
    mov     ss, word ptr ds:[edx].CsSegSs

    cld                                     ; make lodsd ascending (below)
    xor     eax, eax                        ; disable debug registers while
    mov     dr7, eax                        ; setting them.

    add     esi, SrKernelDr0

    .errnz  (SrKernelDr1 - SrKernelDr0 - 1 * 4)
    .errnz  (SrKernelDr2 - SrKernelDr0 - 2 * 4)
    .errnz  (SrKernelDr3 - SrKernelDr0 - 3 * 4)
    .errnz  (SrKernelDr6 - SrKernelDr0 - 4 * 4)
    .errnz  (SrKernelDr7 - SrKernelDr0 - 5 * 4)

    lodsd
    mov     dr0, eax                    ; load dr0-dr7
    lodsd
    mov     dr1, eax
    lodsd
    mov     dr2, eax
    lodsd
    mov     dr3, eax
    lodsd
    mov     dr6, eax
    lodsd
    mov     dr7, eax

    mov     esp, dword ptr ds:[edx].CsEsp
    mov     ecx, dword ptr ds:[edx].CsEcx

    push    dword ptr ds:[edx].CsEflags
    popfd                               ; load eflags

    push    dword ptr ds:[edx].CsEip    ; make a copy of remaining
    push    dword ptr ds:[edx].CsEax    ; registers which need
    push    dword ptr ds:[edx].CsEbx    ; loaded
    push    dword ptr ds:[edx].CsEdx
    push    dword ptr ds:[edx].CsEsi
    push    dword ptr ds:[edx].CsEdi
    push    dword ptr ds:[edx].CsEbp

    or      [edi.SPx_flag], SPX_FLAG_STARTED ; Signal p0 that we are
                                        ; done with it's data
    ; Set remaining registers
    pop     ebp
    pop     edi
    pop     esi
    pop     edx
    pop     ebx
    pop     eax
    stdRET  _StartPx_PMStub

stdENDP _StartPx_PMStub

;++
;
; VOID
; StartPx_BuildRealModeStart(
;     IN PUCHAR ParamBlock
;     )
;
; Routine Description:
;
;   This function sets up the real mode startup page
;
; Arguments:
;
;   PxParamBlock -- address of the structure that should end up
;                   at the beginning of HalpLowStub
;
;--

ParamBlockAddress      equ [ebp + 8]
cPublicProc _StartPx_BuildRealModeStart  ,1

        push    ebp
        mov     ebp, esp
        push    ebx
        push    esi
        push    edi

        ;
        ; Determine whether the new processor should have NX enabled
        ;
        ; N.B. The param block arrives here in an uninitialized
        ; state.
        ;


        call    _HalpIsNXEnabled@0
        mov     edx, ParamBlockAddress
        mov     DWORD PTR [edx].SPx_flag, 0
        or      al, al
        jz      spbrms_nonx
        or      [edx].SPx_flag, SPX_FLAG_NX

spbrms_nonx:

        ;
        ; Build a jmp to the start of the Real mode startup code
        ;
        ; This is needed because the Local APIC implementations
        ; use a Startup IPI that must be Page aligned.  The allocation
        ; code int MP_INIT ensures that this is page aligned.  The
        ; original code was written to place the parameter block first.
        ; By adding a jump instruction to the start of the parameter block
        ; we can run either way.
        ;


        mov     eax, size PxParamBlock - 3  ; Jump destination relative to
                                            ;  next instruction
        shl     eax, 8                      ; Need room for jmp instruction
        mov     al,0e9h
        mov     [edx].SPx_Jmp_Inst, eax

        ;
        ;  Save the p-mode address of PxParamBlock
        ;
        mov     eax, _HalpLowStub
        mov     [edx].SPx_flat_addr, eax

        ;
        ; Copy RMStub to low memory
        ;

        mov     esi, OFFSET FLAT:_StartPx_RMStub
        mov     ecx, _StartPx_RMStub_Len

        mov     edi, _HalpLowStub             ; Destination was allocated by MpInit
        add     edi, size PxParamBlock        ; Parameter Block is placed first
        rep     movsb

        ;
        ;  Copy the parameter block to low memory
        ;
        mov     ecx, size PxParamBlock          ; Structure length
        mov     esi, ParamBlockAddress          ; Parameter Block is placed first
        mov     edi, _HalpLowStub               ; Destination Address
        rep     movsb

        ;
        ;  Now we need to create a pointer allowing the Real Mode code to
        ;  Branch to the Protected mode code
        ;
        mov     eax, _HalpLowStub                 ; low memory Address
        add     eax, size PxParamBlock          ; Move past the Parameter block

        ;
        ;  In order to get to the label we need to compute the label offset relative
        ;  to the start of the routine and then use this as a offset from the start of
        ;  the routine ( HalpLowStub + (size PxParamBlock)) in low memory.
        ;
        ;  The following code creates a pointer to (RMStub - StartPx_RMStub)
        ;  which can then be used to access code locations via code labels directly.
        ;  Since the [eax.Label] results in the address (eax + Label) loading eax
        ;  with the pointer created above results in (RMStub - StartPx_RMStub + Label).
        ;
        mov     ebx, OFFSET FLAT:_StartPx_RMStub
        sub     eax, ebx                        ; (eax) = adjusted pointer

        ;
        ;  Patch the real mode code with a valid long jump address, first CS then offset
        ;
        mov     bx, word ptr [edx].SPx_PB.PsContextFrame.CsSegCs
        mov     [eax.SPrxFlatCS], bx
        mov     [eax.SPrxPMStub], offset _StartPx_PMStub

        pop     edi
        pop     esi
        pop     ebx
        pop     ebp

        stdRET  _StartPx_BuildRealModeStart

stdENDP _StartPx_BuildRealModeStart

        subttl  "Save Processor State"
;++
;
; VOID
; HalpSaveProcessorStateAndWait(
;    IN PKPROCESSOR_STATE ProcessorState
;   )
;
; Routine Description:
;
;   This function saves the volatile, non-volatile and special register
;   state of the current processor.
;
;   N.B.  Floating point state is NOT captured.
;
; Arguments:
;
;    ProcessorState  (esp+4) - Address of processor state record to fill in.
;
;    pBarrier  - Address of a value to use as a lock.
;
; Return Value:
;
;    None. This function does not return.
;
;--

ProcessorState  equ [esp + 8]
pBarrier        equ dword ptr [esp + 12]

cPublicProc _HalpSaveProcessorStateAndWait,2

        push    ebx
        mov     ebx, ProcessorState

        cmp     ebx, 0  ; if this isn't filled in, don't save context
        jz      hspsaw_statesaved
        
        ;
        ; Fill in ProcessorState
        ;

        push    ebx
        call    _KeSaveStateForHibernate        ; _cdecl function
        add     esp, 4

        ;; Save return address, not caller's return address
        mov     eax,[esp+4]
        mov     [ebx.PsContextFrame.CsEip],eax

        ;; Save caller's ebp, not caller's return ebp.
        mov     [ebx.PsContextFrame.CsEbp],ebp

        ;; Set ESP to value just before this function call
        lea     eax,[esp+16]
        mov     [ebx.PsContextFrame.CsEsp],eax

hspsaw_statesaved:
ifdef ACPI_HAL        
        ;
        ; Flush the cache, as the processor may be about
        ; to power off.
        ;
        
        fstCall HalpAcpiFlushCache
endif        
        ;
        ; Signal that this processor has saved its state
        ;

        mov     ebx, pBarrier
        lock inc dword ptr [ebx]

        ;
        ; Wait for the hibernation file to be written.
        ; Processor 0 will zero Barrier when it is
        ; finished.
        ;
        ; N.B.  We can't return from this function
        ; before the hibernation file is finished
        ; because we would be tearing down the very same
        ; stack that we will be jumping onto when the
        ; processor resumes.  But after the hibernation
        ; file is written, it doesn't matter, because
        ; the stack will be restored from disk.
        ;
hspsaw_spin:

        YIELD
        cmp     dword ptr [ebx], 0
        jne     hspsaw_spin

        ;
        ; Invalidate the processor cache so that any stray gamma
        ; rays (I'm serious) that may have flipped cache bits
        ; while in S1 will be ignored.
        ;
        ; Honestly.  Intel asked for this.  I'm serious.
        ;
;.586        
;        invd
;.386        

        pop     ebx

        stdRET    _HalpSaveProcessorStateAndWait

stdENDP _HalpSaveProcessorStateAndWait

PAGELK    ends                            ; end 32 bit code

    end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halx86\i386\ixthunk.c ===
/*++


Copyright (c) 1989  Microsoft Corporation

Module Name:

    ixthunk.c

Abstract:

    This module contains the standard call routines which thunk to
    fastcall routines.

Author:

    Ken Reneris (kenr) 04-May-1994

Environment:

    Kernel mode

Revision History:


--*/

#if !defined(_WIN64)

#include "halp.h"

#ifdef KeRaiseIrql
#undef KeRaiseIrql
#endif

VOID
KeRaiseIrql (
    IN KIRQL    NewIrql,
    OUT PKIRQL  OldIrql
    )
{
    *OldIrql = KfRaiseIrql (NewIrql);
}


#ifdef KeLowerIrql
#undef KeLowerIrql
#endif


VOID
KeLowerIrql (
    IN KIRQL    NewIrql
    )
{
    KfLowerIrql (NewIrql);
}

#ifdef KeAcquireSpinLock
#undef KeAcquireSpinLock
#endif

VOID
KeAcquireSpinLock (
    IN PKSPIN_LOCK  SpinLock,
    OUT PKIRQL      OldIrql
    )
{
    *OldIrql = KfAcquireSpinLock (SpinLock);
}


#ifdef KeReleaseSpinLock
#undef KeReleaseSpinLock
#endif

VOID
KeReleaseSpinLock (
    IN PKSPIN_LOCK  SpinLock,
    IN KIRQL        NewIrql
    )
{
    KfReleaseSpinLock (SpinLock, NewIrql);
}

#endif  // _WIN64
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halx86\i386\ncrdetct.c ===
/*++

Copyright (c) 1992  NCR Corporation

Module Name:

    ncrdetect.c

Abstract:

Authors:

    Richard Barton (o-richb) 24-Jan-1992
    Brian Weischedel         30-Nov-1992

Environment:

    Kernel mode only.

Revision History:

--*/

#ifndef _NTOS_
#include "nthal.h"
#endif

PVOID
HalpMapPhysicalMemory(
    IN PVOID PhysicalAddress,
    IN ULONG NumberPages
    );

VOID
ReadCMOS(
    IN ULONG StartingOffset,
    IN ULONG Count,
    IN PUCHAR ReturnValuePtr);

ULONG   NCRPlatform;

#define NCR3450 0x35333433              // Copied here to build standalone
#define NCR3550 0x30353834
#define NCR3360 0x33333630

//  WPD definitions:

PUCHAR  WPDStringID            =  "NCR Voyager-1";
PUCHAR  WPDPlatformName        =  "System 3360";
#define WPDStringIDLength         13
#define WPDStringIDRangeStart     (0xE000 << 4)       // physical address
#define WPDStringIDRangeSize      0x10000             // 1 segment (64k)

//  MSBU definitions:

PUCHAR  MSBUCopyrightString     = "Copyright (C) ???? NCR\0";
#define MSBUCopyrightStringLen          23
#define MSBUCopyrightPhysicalPtr        ((0xF000 << 4) + (0xE020))
typedef struct  {
        ULONG   ClassFromFirmware;
        PUCHAR  PlatformName;
}       MSBUPlatformMapEntry;
MSBUPlatformMapEntry    MSBUPlatformMap[]       = {{NCR3450, "System 3450"},
                                                   {NCR3550, "System 3550"},
                                                   {0, 0}};

PUCHAR
NCRDeterminePlatform(
    OUT PBOOLEAN IsConfiguredMp
)
/*++

Routine Description:
    Determine on which NCR platform we are running.  For now just display
    a message.  Later we may not continue the boot if we're on an
    unrecognized platform.

Arguments:
    none.

Return Value:
    Pointer to character string identifying which NCR platform.  NULL means
    it is unrecognized, and we shouldn't continue.

--*/
{
        BOOLEAN                 Matchfound;
        MSBUPlatformMapEntry    *MSBUPlatformMapPtr;
        PVOID                   BIOSPagePtr;
        PUCHAR                  StringPtr;
        PUCHAR                  CopyrightPtr;
        PUCHAR                  SearchPtr;
        UCHAR                   CpuFlags;


  // first check for a WPD platform by searching the 0xE000 BIOS segment
  // for a ROM string that identifies this system as a 3360


        // get virtual address to the BIOS region (assuming region is both
        // page aligned and multiple pages in size)

        BIOSPagePtr = HalpMapPhysicalMemory((PVOID) WPDStringIDRangeStart,
                                            (WPDStringIDRangeSize >> 12));

        if (BIOSPagePtr != NULL) {

                SearchPtr = BIOSPagePtr;   // begin search at start of region
                Matchfound = FALSE;

                // search until string is found or we are beyond the region

                while (!Matchfound && (SearchPtr <= (PUCHAR)((ULONG)BIOSPagePtr +
                                                     WPDStringIDRangeSize -
                                                     WPDStringIDLength))) {

                        // see if SearchPtr points to the desired string

                        StringPtr = (PUCHAR)((ULONG)SearchPtr++);
                        CopyrightPtr = WPDStringID;

                        // continue compare as long as characters compare
                        // and not at end of string

                        while ((Matchfound = (*CopyrightPtr++ == *StringPtr++)) &&
                              (CopyrightPtr < WPDStringID + WPDStringIDLength));
                }

                // see if string was found (i.e., if this is a 3360)

                if (Matchfound) {

                        // store system identifier ("3360") for later HAL use

                        NCRPlatform = NCR3360;

                        // read CPU good flags from CMOS and determine if MP

                        ReadCMOS(0x88A, 1, &CpuFlags);
                        // *IsConfiguredMp = (CpuFlags & (CpuFlags-1)) ? TRUE : FALSE;

                        // This is an MP hal
                        *IsConfiguredMp = TRUE;

                        return(WPDPlatformName);
                }

        }


  // now check for an MSBU platform


        /*
         *  Map in the BIOS text so we can look for our copyright string.
         */
        BIOSPagePtr = (PVOID)((ULONG)MSBUCopyrightPhysicalPtr &
                              ~(PAGE_SIZE - 1));
        BIOSPagePtr = HalpMapPhysicalMemory(BIOSPagePtr, 2);
        if (BIOSPagePtr == NULL)
                return(NULL);

        StringPtr = (PUCHAR)((ULONG)BIOSPagePtr +
                        ((ULONG)MSBUCopyrightPhysicalPtr & (PAGE_SIZE - 1)))
                        + (MSBUCopyrightStringLen - 1);
        CopyrightPtr = MSBUCopyrightString + (MSBUCopyrightStringLen - 1);
        do {
                Matchfound = ((*CopyrightPtr == '?') ||
                              (*CopyrightPtr == *StringPtr));
                --CopyrightPtr;
                --StringPtr;
        } while (Matchfound && (CopyrightPtr >= MSBUCopyrightString));

        //
        // /*
        //  *  Clear the mapping to BIOS. We mapped in two pages.
        //  */
        // BIOSPagePtr = MiGetPteAddress(BIOSPagePtr);
        // *(PULONG)BIOSPagePtr = 0;
        // *(((PULONG)BIOSPagePtr)+1) = 0;
        // /*
        //  *  Flush the TLB.
        //  */
        // _asm {
        //         mov     eax, cr3
        //         mov     cr3, eax
        // }
        //

        if (Matchfound) {
                /*
                 *  must be an MSBU machine..determine which.
                 */
                ReadCMOS(0xB16, 4, (PUCHAR)&NCRPlatform);
                for (MSBUPlatformMapPtr = MSBUPlatformMap;
                     (MSBUPlatformMapPtr->ClassFromFirmware != 0);
                     ++MSBUPlatformMapPtr) {
                        if (MSBUPlatformMapPtr->ClassFromFirmware ==
                                NCRPlatform) {

                                *IsConfiguredMp = TRUE;
                                return(MSBUPlatformMapPtr->PlatformName);
                        }
                }

                /*
                 *  prerelease version of firmware had this machine class
                 *  at the wrong offset into CMOS.  until all those versions
                 *  of firmware are extinguished from the face of the earth
                 *  we should recognize them with this:
                 */
                ReadCMOS(0xAB3, 4, (PUCHAR)&NCRPlatform);
                for (MSBUPlatformMapPtr = MSBUPlatformMap;
                     (MSBUPlatformMapPtr->ClassFromFirmware != 0);
                     ++MSBUPlatformMapPtr) {
                        if (MSBUPlatformMapPtr->ClassFromFirmware ==
                                NCRPlatform) {
                                *IsConfiguredMp = TRUE;
                                return(MSBUPlatformMapPtr->PlatformName);
                        }
                }
        }

        return(NULL);
}


#ifndef SETUP         // if built with Hal, must provide ReadCMOS routine

ULONG
HalpGetCmosData (
    IN ULONG SourceLocation,
    IN ULONG SourceAddress,
    IN PUCHAR Buffer,
    IN ULONG Length);

VOID
ReadCMOS(
    IN ULONG StartingOffset,
    IN ULONG Count,
    IN PUCHAR ReturnValuePtr
)
/*++

Routine Description:
    This routine simply converts a ReadCMOS call (a routine in setup) to
    the corresponding routine provided in the Hal (HalpGetCmosData).

--*/
{
    HalpGetCmosData(1, StartingOffset, ReturnValuePtr, Count);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halx86\i386\ixslpsup.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    ixslpsup.c

Abstract:

    This file provides the code that saves and restores
    state for traditional motherboard devices when the
    system goes into a sleep state that removes power.

    This code is included in multiple HALs.

Author:

    Jake Oshins (jakeo) May 6, 1997

Revision History:

--*/
#include "halp.h"
#include "ixsleep.h"

#if (defined(APIC_HAL) || defined(ACPI_HAL))
#include "apic.inc"
#include "..\..\halmps\i386\pcmp_nt.inc"

#if !defined(_AMD64_)

VOID
StartPx_RMStub(
    VOID
    );

#endif

#endif

typedef struct _SAVE_CONTEXT_DPC_CONTEXT {
    PVOID   SaveArea;
    volatile ULONG Complete;
} SAVE_CONTEXT_DPC_CONTEXT, *PSAVE_CONTEXT_DPC_CONTEXT;

VOID
HalpSaveContextTargetProcessor (
    IN PKDPC    Dpc,
    IN PVOID    DeferredContext,
    IN PVOID    SystemArgument1,
    IN PVOID    SystemArgument2
    );

#ifdef WANT_IRQ_ROUTING
#include "ixpciir.h"
#endif
extern UCHAR HalpAsmDataMarker;
extern PVOID   HalpEisaControlBase;
extern ULONG   HalpIrqMiniportInitialized;

PKPROCESSOR_STATE   HalpHiberProcState;
ULONG               CurTiledCr3LowPart;
PPHYSICAL_ADDRESS   HalpTiledCr3Addresses;

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, HaliLocateHiberRanges)
#pragma alloc_text(PAGELK, HalpSavePicState)
#pragma alloc_text(PAGELK, HalpSaveDmaControllerState)
#pragma alloc_text(PAGELK, HalpSaveTimerState)
#pragma alloc_text(PAGELK, HalpRestorePicState)
#pragma alloc_text(PAGELK, HalpRestoreDmaControllerState)
#pragma alloc_text(PAGELK, HalpRestoreTimerState)
#pragma alloc_text(PAGELK, HalpBuildResumeStructures)
#pragma alloc_text(PAGELK, HalpFreeResumeStructures)
#pragma alloc_text(PAGELK, HalpSaveContextTargetProcessor)
#endif


#define EISA_CONTROL (PUCHAR)&((PEISA_CONTROL) HalpEisaControlBase)


VOID
HalpPowerStateCallback(
    IN PVOID CallbackContext,
    IN PVOID Argument1,
    IN PVOID Argument2
    )
{
    ULONG       action = PtrToUlong(Argument1);
    ULONG       state  = PtrToUlong(Argument2);

    if (action == PO_CB_SYSTEM_STATE_LOCK) {

        switch (state) {
        case 0:

            //
            // Lock down everything in the PAGELK code section.  (We chose
            // HalpSaveDmaControllerState because it exists in every HAL.)
            //

            HalpSleepPageLock = MmLockPagableCodeSection((PVOID)HalpSaveDmaControllerState);
#if (defined(APIC_HAL) || defined(ACPI_HAL)) && !defined(_AMD64_)
            HalpSleepPage16Lock = MmLockPagableCodeSection((PVOID) StartPx_RMStub );
#endif

#ifdef ACPI_HAL

            HalpMapNvsArea();
#endif
            break;

        case 1:                 // unlock it all

            MmUnlockPagableImageSection(HalpSleepPageLock);
#if (defined(APIC_HAL) || defined(ACPI_HAL)) && !defined(_AMD64_)
            MmUnlockPagableImageSection(HalpSleepPage16Lock);
#endif

#ifdef ACPI_HAL
            HalpFreeNvsBuffers();
#endif
        }
    }

    return;
}

VOID
HalpSavePicState(
    VOID
    )
{
    HalpMotherboardState.PicState.MasterMask =
        READ_PORT_UCHAR(EISA_CONTROL->Interrupt1ControlPort1);

    HalpMotherboardState.PicState.SlaveMask =
        READ_PORT_UCHAR(EISA_CONTROL->Interrupt2ControlPort1);

#if !defined(ACPI_HAL)

#ifdef WANT_IRQ_ROUTING
    if(HalpIrqMiniportInitialized)
    {
        ULONG elcrMask = 0;

        PciirqmpGetTrigger(&elcrMask);
        HalpMotherboardState.PicState.MasterEdgeLevelControl = (UCHAR)((elcrMask >> 8) & 0xFF);
        HalpMotherboardState.PicState.SlaveEdgeLevelControl = (UCHAR)(elcrMask & 0xFF);
    }
    else
    {
#endif
        if (HalpBusType == MACHINE_TYPE_EISA) {
#endif
            HalpMotherboardState.PicState.MasterEdgeLevelControl =
                READ_PORT_UCHAR(EISA_CONTROL->Interrupt1EdgeLevel);

            HalpMotherboardState.PicState.SlaveEdgeLevelControl =
                READ_PORT_UCHAR(EISA_CONTROL->Interrupt2EdgeLevel);

#if !defined(ACPI_HAL)
        }
#ifdef WANT_IRQ_ROUTING
    }
#endif
#endif
}

VOID
HalpRestorePicState(
    VOID
    )
{
    ULONG flags;


    flags = HalpDisableInterrupts();

    HalpInitializePICs(FALSE);

    WRITE_PORT_UCHAR(EISA_CONTROL->Interrupt1ControlPort1,
                     HalpMotherboardState.PicState.MasterMask);

    WRITE_PORT_UCHAR(EISA_CONTROL->Interrupt2ControlPort1,
                     HalpMotherboardState.PicState.SlaveMask);

    //
    // For halx86, the PCI interrupt vector programming
    // is static, so this code can just restore everything.
    //

    HalpRestorePicEdgeLevelRegister();

    HalpRestoreInterrupts(flags);
}

VOID
HalpRestorePicEdgeLevelRegister(
    VOID
    )
{
#if !defined(ACPI_HAL)
#ifdef WANT_IRQ_ROUTING
    if(HalpIrqMiniportInitialized)
    {
        PLINK_NODE  linkNode;
        PLINK_STATE temp;
        ULONG       elcrMask = (HalpMotherboardState.PicState.MasterEdgeLevelControl << 8) |
                                           HalpMotherboardState.PicState.SlaveEdgeLevelControl;

        PciirqmpSetTrigger(elcrMask);

        //
        // Reprogram all links.
        //

        for (   linkNode = HalpPciIrqRoutingInfo.LinkNodeHead;
                linkNode;
                linkNode = linkNode->Next)
        {
            //
            // Swap the possible with the allocation.
            //

            temp = linkNode->Allocation;
            linkNode->Allocation = linkNode->PossibleAllocation;
            linkNode->PossibleAllocation = temp;
            HalpCommitLink(linkNode);
        }

    }
    else
    {
#endif
        if (HalpBusType == MACHINE_TYPE_EISA) {
#endif

            WRITE_PORT_UCHAR(EISA_CONTROL->Interrupt1EdgeLevel,
                             HalpMotherboardState.PicState.MasterEdgeLevelControl);

            WRITE_PORT_UCHAR(EISA_CONTROL->Interrupt2EdgeLevel,
                             HalpMotherboardState.PicState.SlaveEdgeLevelControl);
#if !defined(ACPI_HAL)
        }
#ifdef WANT_IRQ_ROUTING
    }
#endif
#endif
}

VOID
HalpSaveDmaControllerState(
    VOID
    )
{
}

VOID
HalpRestoreDmaControllerState(
    VOID
    )
/*++
Routine Description:

    This function puts the DMA controller back into the
    same state it was in before the machine went to sleep.

Arguments:

    None.

Notes:

    Normally, the DMA controller structures would be guarded
    by spinlocks.  But this function is called with interrupts
    turned off and all but one processor spinning.

--*/
{
    UCHAR   i;

    WRITE_PORT_UCHAR(EISA_CONTROL->Dma1BasePort.AllMask,0xF);
    WRITE_PORT_UCHAR(EISA_CONTROL->Dma2BasePort.AllMask,0xE);
    HalpIoDelay();

    //
    //Reset the DMA command registers
    //
#if defined(NEC_98)
    WRITE_PORT_UCHAR(EISA_CONTROL->Dma1BasePort.DmaStatus,0x40);
    WRITE_PORT_UCHAR(EISA_CONTROL->Dma2BasePort.DmaStatus,0x40);
#else
    WRITE_PORT_UCHAR(EISA_CONTROL->Dma1BasePort.DmaStatus,0);
    WRITE_PORT_UCHAR(EISA_CONTROL->Dma2BasePort.DmaStatus,0);
#endif
    HalpIoDelay();

    for (i = 0; i < (EISA_DMA_CHANNELS / 2); i++) {

        //
        // Check to see if the array contains a value for this channel.
        //
        if (HalpDmaChannelState[i].ChannelProgrammed) {

            WRITE_PORT_UCHAR(EISA_CONTROL->Dma1BasePort.Mode,
                             HalpDmaChannelState[i].ChannelMode);

            if (HalpEisaDma) {
                WRITE_PORT_UCHAR(EISA_CONTROL->Dma1ExtendedModePort,
                              HalpDmaChannelState[i].ChannelExtendedMode);
            }

            WRITE_PORT_UCHAR(EISA_CONTROL->Dma1BasePort.SingleMask,
                             HalpDmaChannelState[i].ChannelMask);

            HalpIoDelay();
        }
    }

    for (i = (EISA_DMA_CHANNELS / 2); i < EISA_DMA_CHANNELS; i++) {

        //
        // Check to see if the array contains a value for this channel.
        //
        if (HalpDmaChannelState[i].ChannelProgrammed) {

            WRITE_PORT_UCHAR(EISA_CONTROL->Dma2BasePort.Mode,
                             HalpDmaChannelState[i].ChannelMode);

            if (HalpEisaDma) {
                WRITE_PORT_UCHAR(EISA_CONTROL->Dma2ExtendedModePort,
                             HalpDmaChannelState[i].ChannelExtendedMode);
            }

            WRITE_PORT_UCHAR(EISA_CONTROL->Dma2BasePort.SingleMask,
                             HalpDmaChannelState[i].ChannelMask);

            HalpIoDelay();
        }
    }
}


VOID
HalpSaveTimerState(
    VOID
    )
{
}

VOID
HalpRestoreTimerState(
    VOID
    )
{
    HalpInitializeClock();
}

VOID
HaliLocateHiberRanges (
    IN PVOID MemoryMap
    )
{
    //
    // Mark the hal's data section as needed to be cloned
    //

    PoSetHiberRange (
        MemoryMap,
        PO_MEM_CLONE,
        (PVOID) &HalpFeatureBits,
        0,
        'dlah'
        );

#if defined(_HALPAE_)

    //
    // Mark DMA buffers as not needing to be saved.
    //

    if (MasterAdapter24.MapBufferSize != 0) {
        PoSetHiberRange( MemoryMap,
                         PO_MEM_DISCARD | PO_MEM_PAGE_ADDRESS,
                         (PVOID)(ULONG_PTR)(MasterAdapter24.MapBufferPhysicalAddress.LowPart >>
                                     PAGE_SHIFT),
                         MasterAdapter24.MapBufferSize >> PAGE_SHIFT,
                         'mlah' );
    }

    if (MasterAdapter32.MapBufferSize != 0) {
        PoSetHiberRange( MemoryMap,
                         PO_MEM_DISCARD | PO_MEM_PAGE_ADDRESS,
                         (PVOID)(ULONG_PTR)(MasterAdapter32.MapBufferPhysicalAddress.LowPart >>
                                     PAGE_SHIFT),
                         MasterAdapter32.MapBufferSize >> PAGE_SHIFT,
                         'mlah' );
    }

#else

    //
    // Mark DMA buffer has not needing saved
    //

    if (HalpMapBufferSize) {
        PoSetHiberRange (
            MemoryMap,
            PO_MEM_DISCARD | PO_MEM_PAGE_ADDRESS,
            (PVOID) (HalpMapBufferPhysicalAddress.LowPart >> PAGE_SHIFT),
            HalpMapBufferSize >> PAGE_SHIFT,
            'mlah'
            );
    }

#endif
}

NTSTATUS
HalpBuildResumeStructures(
    VOID
    )
{
    KAFFINITY   CurrentAffinity, ActiveProcessors;
    ULONG       ProcNum, Processor, NumberProcessors = 1;
    KDPC        Dpc;
    SAVE_CONTEXT_DPC_CONTEXT    Context;

    ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);

#if defined(APIC_HAL)
    //
    // If KeActiveProcessors() were callable at
    // DISPATCH_LEVEL, I would use that.
    //

    NumberProcessors = HalpMpInfoTable.NtProcessors;
#endif
    ActiveProcessors = (1 << NumberProcessors) - 1;

#if defined(APIC_HAL) || defined(ACPI_HAL)
    //
    // Allocate space to save processor context for other processors
    //

    HalpTiledCr3Addresses = NULL;

    HalpHiberProcState =
        ExAllocatePoolWithTag(NonPagedPool,
            (NumberProcessors * sizeof(KPROCESSOR_STATE)),
             HAL_POOL_TAG);

    if (!HalpHiberProcState) {
        goto BuildResumeStructuresError;
    }

    RtlZeroMemory(HalpHiberProcState,
                  NumberProcessors * sizeof(KPROCESSOR_STATE));

    //
    // Allocate space for tiled CR3 for all processors
    //

    HalpTiledCr3Addresses =
        ExAllocatePoolWithTag(NonPagedPool,
            (NumberProcessors * sizeof(PHYSICAL_ADDRESS)),
             HAL_POOL_TAG);

    if (!HalpTiledCr3Addresses) {
        goto BuildResumeStructuresError;
    }

    RtlZeroMemory(HalpTiledCr3Addresses,
                  (NumberProcessors * sizeof(PHYSICAL_ADDRESS)));

    //
    // Get IDT and GDT for all processors except BSP,
    // map and save tiled CR3
    //

    KeInitializeDpc (&Dpc, HalpSaveContextTargetProcessor, &Context);
    KeSetImportanceDpc (&Dpc, HighImportance);

    ProcNum = 0;
    CurrentAffinity = 1;
    Processor = 0;

    while (ActiveProcessors) {
        if (ActiveProcessors & CurrentAffinity) {

            ActiveProcessors &= ~CurrentAffinity;

            RtlZeroMemory(&Context, sizeof(Context));
            Context.SaveArea = &(HalpHiberProcState[ProcNum]);

            if (Processor == CurrentPrcb(KeGetPcr())->Number) {

                //
                // We're running on this processor.  Just call
                // the DPC routine from here.

                HalpSaveContextTargetProcessor(&Dpc, &Context, NULL, NULL);

            } else {

                //
                // Issue DPC to target processor
                //

                KeSetTargetProcessorDpc (&Dpc, (CCHAR) Processor);
                KeInsertQueueDpc (&Dpc, NULL, NULL);

                //
                // Wait for DPC to be complete.
                //
                while (Context.Complete == FALSE);
            }

            ProcNum++;
        }

        Processor++;
        CurrentAffinity <<= 1;
    }

    for (ProcNum = 0; ProcNum < NumberProcessors; ProcNum++) {
        HalpTiledCr3Addresses[ProcNum].LowPart =
                HalpBuildTiledCR3Ex(&(HalpHiberProcState[ProcNum]),ProcNum);
    }
#endif

    return STATUS_SUCCESS;

#if defined(APIC_HAL) || defined(ACPI_HAL)
BuildResumeStructuresError:

    if (HalpHiberProcState) ExFreePool(HalpHiberProcState);
    if (HalpTiledCr3Addresses) ExFreePool(HalpTiledCr3Addresses);
    return STATUS_UNSUCCESSFUL;
#endif
}

NTSTATUS
HalpFreeResumeStructures(
    VOID
    )
{
    ULONG       ProcNum, NumberProcessors = 1;

#if defined(APIC_HAL)
    NumberProcessors = HalpMpInfoTable.NtProcessors;
#endif

#if defined(APIC_HAL) || defined(ACPI_HAL)

    if (HalpHiberProcState)  {
        ExFreePool(HalpHiberProcState);
        HalpHiberProcState = NULL;
    }

    if (HalpTiledCr3Addresses) {
        ExFreePool(HalpTiledCr3Addresses);
        HalpTiledCr3Addresses = NULL;
    }

    for (ProcNum = 0; ProcNum < NumberProcessors; ProcNum++) {
            HalpFreeTiledCR3Ex(ProcNum);
    }
#endif
    return STATUS_SUCCESS;
}

VOID
HalpSaveContextTargetProcessor (
    IN PKDPC    Dpc,
    IN PVOID    DeferredContext,
    IN PVOID    SystemArgument1,
    IN PVOID    SystemArgument2
    )
{
    PSAVE_CONTEXT_DPC_CONTEXT Context = (PSAVE_CONTEXT_DPC_CONTEXT)DeferredContext;

    KeSaveStateForHibernate(Context->SaveArea);
    InterlockedIncrement(&Context->Complete);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halx86\i386\ixstall.asm ===
title  "Stall Execution Support"
;++
;
; Copyright (c) 1989  Microsoft Corporation
;
; Module Name:
;
;    ixstall.asm
;
; Abstract:
;
;    This module implements the code necessary to field and process the
;    interval clock interrupt.
;
; Author:
;
;    Shie-Lin Tzong (shielint) 12-Jan-1990
;
; Environment:
;
;    Kernel mode only.
;
; Revision History:
;
;   bryanwi 20-Sep-90
;
;       Add KiSetProfileInterval, KiStartProfileInterrupt,
;       KiStopProfileInterrupt procedures.
;       KiProfileInterrupt ISR.
;       KiProfileList, KiProfileLock are delcared here.
;
;   shielint 10-Dec-90
;       Add performance counter support.
;       Move system clock to irq8, ie we now use RTC to generate system
;         clock.  Performance count and Profile use timer 1 counter 0.
;         The interval of the irq0 interrupt can be changed by
;         KiSetProfileInterval.  Performance counter does not care about the
;         interval of the interrupt as long as it knows the rollover count.
;       Note: Currently I implemented 1 performance counter for the whole
;       i386 NT.
;
;   John Vert (jvert) 11-Jul-1991
;       Moved from ke\i386 to hal\i386.  Removed non-HAL stuff
;
;   shie-lin tzong (shielint) 13-March-92
;       Move System clock back to irq0 and use RTC (irq8) to generate
;       profile interrupt.  Performance counter and system clock use time1
;       counter 0 of 8254.
;
;   Landy Wang (corollary!landy) 04-Dec-92
;       Created this module by moving routines from ixclock.asm to here.
;
;--

.386p
        .xlist
include hal386.inc
include callconv.inc                    ; calling convention macros
include i386\ix8259.inc
include i386\kimacro.inc
include mac386.inc
include i386\ixcmos.inc
        .list

        EXTRNP  _DbgBreakPoint,0,IMPORT
        EXTRNP  _HalpAcquireCmosSpinLock  ,0
        EXTRNP  _HalpReleaseCmosSpinLock  ,0

;
; Constants used to initialize CMOS/Real Time Clock
;

D_INT032                EQU     8E00h   ; access word for 386 ring 0 interrupt gate
RTCIRQ                  EQU     8       ; IRQ number for RTC interrupt
REGISTER_B_ENABLE_PERIODIC_INTERRUPT EQU     01000010B
                                        ; RT/CMOS Register 'B' Init byte
                                        ; Values for byte shown are
                                        ;  Bit 7 = Update inhibit
                                        ;  Bit 6 = Periodic interrupt enable
                                        ;  Bit 5 = Alarm interrupt disable
                                        ;  Bit 4 = Update interrupt disable
                                        ;  Bit 3 = Square wave disable
                                        ;  Bit 2 = BCD data format
                                        ;  Bit 1 = 24 hour time mode
                                        ;  Bit 0 = Daylight Savings disable

REGISTER_B_DISABLE_PERIODIC_INTERRUPT EQU    00000010B

;
; RegisterAInitByte sets 8Hz clock rate, used during init to set up
; KeStallExecutionProcessor, etc.  (See RegASystemClockByte below.)
;

RegisterAInitByte       EQU     00101101B ; RT/CMOS Register 'A' init byte
                                        ; 32.768KHz Base divider rate
                                        ;  8Hz int rate, period = 125.0ms
PeriodInMicroSecond     EQU     125000  ;

_DATA   SEGMENT  DWORD PUBLIC 'DATA'

HalpStallCount  dd      0

_DATA   ends

INIT    SEGMENT PARA PUBLIC 'CODE'
        ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING

        page ,132
        subttl  "Initialize Stall Execution Counter"
;++
;
; VOID
; HalpInitializeStallExecution (
;    IN CCHAR ProcessorNumber
;    )
;
; Routine Description:
;
;    This routine initialize the per Microsecond counter for
;    KeStallExecutionProcessor
;
; Arguments:
;
;    ProcessorNumber - Processor Number
;
; Return Value:
;
;    None.
;
; Note:
;
;    Current implementation assumes that all the processors share
;    the same Real Time Clock.  So, the dispatcher database lock is
;    acquired before entering this routine to guarantee only one
;    processor can access the routine.
;
;--

KiseInterruptCount      equ     [ebp-12] ; local variable

cPublicProc _HalpInitializeStallExecution     ,1

ifndef NT_UP
;;
;; This function currently doesn't work from any processor but the
;; boot processor - for now stub out the others
;;

        mov     eax, PCR[PcPrcb]
        cmp     byte ptr [eax].PbNumber, 0
        je      @f

        mov     eax, HalpStallCount
        mov     PCR[PcStallScaleFactor], eax
        stdRET    _HalpInitializeStallExecution
@@:
endif

        push    ebp                     ; save ebp
        mov     ebp, esp                ; set up 12 bytes for local use
        sub     esp, 12

        pushfd                          ; save caller's eflag

;
; Initialize Real Time Clock to interrupt us for every 125ms at
; IRQ 8.
;

        cli                             ; make sure interrupts are disabled

;
; Get and save current 8259 masks
;

        xor     eax,eax

;
; Assume there is no third and fourth PICs
;
; Get interrupt Mask on PIC2
;

        in      al,PIC2_PORT1
        shl     eax, 8

;
; Get interrupt Mask on PIC1
;

        in      al,PIC1_PORT1
        push    eax                     ; save the masks
        mov     eax, NOT (( 1 SHL PIC_SLAVE_IRQ) + (1 SHL RTCIRQ))
                                        ; Mask all the irqs except irq 2 and 8
        SET_8259_MASK                   ; Set 8259's int mask register

;
; Since RTC interrupt will come from IRQ 8, we need to
; Save original irq 8 descriptor and set the descriptor to point to
; our own handler.
;

        sidt    fword ptr [ebp-8]       ; get IDT address
        mov     ecx, [ebp-6]            ; (ecx)->IDT

        mov     eax, (RTCIRQ+PRIMARY_VECTOR_BASE)

        shl     eax, 3                  ; 8 bytes per IDT entry
        add     ecx, eax                ; now at the correct IDT RTC entry

        push    dword ptr [ecx]         ; (TOS) = original desc of IRQ 8
        push    dword ptr [ecx + 4]     ; each descriptor has 8 bytes

        ;
        ; Pushing the appropriate entry address now (instead of
        ; the IDT start address later) to make the pop at the end simpler.
        ;
        push    ecx                     ; (TOS) -> &IDT[HalProfileVector]

        mov     eax, offset FLAT:RealTimeClockHandler

        mov     word ptr [ecx], ax              ; Lower half of handler addr
        mov     word ptr [ecx+2], KGDT_R0_CODE  ; set up selector
        mov     word ptr [ecx+4], D_INT032      ; 386 interrupt gate

        shr     eax, 16                 ; (ax)=higher half of handler addr
        mov     word ptr [ecx+6], ax

        mov     dword ptr KiseinterruptCount, 0 ; set no interrupt yet

        stdCall   _HalpAcquireCmosSpinLock      ; intr disabled

        mov     ax,(RegisterAInitByte SHL 8) OR 0AH ; Register A
        CMOS_WRITE                      ; Initialize it
;
; Don't clobber the Daylight Savings Time bit in register B, because we
; stash the LastKnownGood "environment variable" there.
;
        mov     ax, 0bh
        CMOS_READ
        and     al, 1
        mov     ah, al
        or      ah, REGISTER_B_ENABLE_PERIODIC_INTERRUPT
        mov     al, 0bh
        CMOS_WRITE                      ; Initialize it
        mov     al,0CH                  ; Register C
        CMOS_READ                       ; Read to initialize
        mov     al,0DH                  ; Register D
        CMOS_READ                       ; Read to initialize
        mov     dword ptr [KiseInterruptCount], 0

        stdCall   _HalpReleaseCmosSpinLock

;
; Now enable the interrupt and start the counter
; (As a matter of fact, only IRQ8 can come through.)
;
        xor     eax, eax                ; (eax) = 0, initialize loopcount
ALIGN 16
        sti
        jmp     kise10

ALIGN 16
kise10:
        sub     eax, 1                  ; increment the loopcount
        jnz     short kise10

if DBG
;
; Counter overflowed
;

        stdCall   _DbgBreakPoint
endif
        jmp     short kise10

;
; Our RealTimeClock interrupt handler.  The control comes here through
; irq 8.
; Note: we discard first real time clock interrupt and compute the
;       permicrosecond loopcount on receiving of the second real time
;       interrupt.  This is because the first interrupt is generated
;       based on the previous real time tick interval.
;

RealTimeClockHandler:

        inc     dword ptr KiseInterruptCount ; increment interrupt count
        cmp     dword ptr KiseInterruptCount,1 ; Is this the first interrupt?
        jnz     kise25                  ; no, its the second go process it
        pop     eax                     ; get rid of original ret addr
        push    offset FLAT:kise10      ; set new return addr


        stdCall   _HalpAcquireCmosSpinLock      ; intr disabled

        mov     ax,(RegisterAInitByte SHL 8) OR 0AH ; Register A
        CMOS_WRITE                      ; Initialize it
;
; Don't clobber the Daylight Savings Time bit in register B, because we
; stash the LastKnownGood "environment variable" there.
;
        mov     ax, 0bh
        CMOS_READ
        and     al, 1
        mov     ah, al
        or      ah, REGISTER_B_ENABLE_PERIODIC_INTERRUPT
        mov     al, 0bh
        CMOS_WRITE                      ; Initialize it
        mov     al,0CH                  ; Register C
        CMOS_READ                       ; Read to initialize
        mov     al,0DH                  ; Register D
        CMOS_READ                       ; Read to initialize

        stdCall   _HalpReleaseCmosSpinLock
;
; Dismiss the interrupt.
;
        mov     al, OCW2_NON_SPECIFIC_EOI ; send non specific eoi to slave
        out     PIC2_PORT0, al
        mov     al, PIC2_EOI            ; specific eoi to master for pic2 eoi
        out     PIC1_PORT0, al          ; send irq2 specific eoi to master

        xor     eax, eax                ; reset loop counter

        iretd

kise25:

;
; ** temporary - check for incorrect KeStallExecutionProcessorLoopCount
;

if DBG
        cmp     eax, 0
        jnz     short kise30
        stdCall   _DbgBreakPoint

endif
                                         ; never return
;
; ** End temporay code
;

kise30:
        neg     eax
        xor     edx, edx                ; (edx:eax) = divident
        mov     ecx, PeriodInMicroSecond; (ecx) = time spent in the loop
        div     ecx                     ; (eax) = loop count per microsecond
        cmp     edx, 0                  ; Is remainder =0?
        jz      short kise40            ; yes, go kise40
        inc     eax                     ; increment loopcount by 1
kise40:
        mov     PCR[PcStallScaleFactor], eax
        mov     HalpStallCount, eax

;
; Reset return address to kexit
;

        pop     eax                     ; discard original return address
        push    offset FLAT:kexit       ; return to kexit
        mov     eax, (HIGHEST_LEVEL_FOR_8259 - RTCIRQ)

;
; Shutdown periodic interrupt
;
        stdCall   _HalpAcquireCmosSpinLock
        mov     ax,(RegisterAInitByte SHL 8) OR 0AH ; Register A
        CMOS_WRITE                      ; Initialize it
        mov     ax, 0bh
        CMOS_READ
        and     al, 1
        mov     ah, al
        or      ah, REGISTER_B_DISABLE_PERIODIC_INTERRUPT
        mov     al, 0bh
        CMOS_WRITE                      ; Initialize it
        mov     al,0CH                  ; Register C
        CMOS_READ                       ; dismiss pending interrupt
        stdCall   _HalpReleaseCmosSpinLock

;
; Dismiss the interrupt.
;
        mov     eax, RTCIRQ
        mov     al, OCW2_NON_SPECIFIC_EOI ; send non specific eoi to slave
        out     PIC2_PORT0, al
        mov     al, PIC2_EOI            ; specific eoi to master for pic2 eoi
        out     PIC1_PORT0, al          ; send irq2 specific eoi to master

        and     word ptr [esp+8], NOT 0200H ; Disable interrupt upon return
        iretd

kexit:                                  ; Interrupts are disabled
        pop     ecx                     ; (ecx) -> &IDT[HalProfileVector]
        pop     [ecx+4]                 ; restore higher half of RTC desc
        pop     [ecx]                   ; restore lower half of RTC desc

        pop     eax                     ; (eax) = origianl 8259 int masks
        SET_8259_MASK

        popfd                           ; restore caller's eflags
        mov     esp, ebp
        pop     ebp                     ; restore ebp
        stdRET    _HalpInitializeStallExecution

stdENDP _HalpInitializeStallExecution

cPublicProc _HalpRemoveFences
        mov     word ptr fence1, 0c98bh
        stdRET    _HalpRemoveFences
stdENDP _HalpRemoveFences

INIT   ends

_TEXT   SEGMENT PARA PUBLIC 'CODE'
        ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING

        page ,132
        subttl  "Stall Execution"
;++
;
; VOID
; KeStallExecutionProcessor (
;    IN ULONG MicroSeconds
;    )
;
; Routine Description:
;
;    This function stalls execution for the specified number of microseconds.
;    KeStallExecutionProcessor
;
; Arguments:
;
;    MicroSeconds - Supplies the number of microseconds that execution is to be
;        stalled.
;
; Return Value:
;
;    None.
;
;--

MicroSeconds equ [esp + 4]


cPublicProc _KeStallExecutionProcessor       ,1
cPublicFpo 1, 0

;
; Issue a CPUID to implement a "fence"
;
        push    ebx                             ; cpuid uses eax, ebx, ecx, edx
        xor     eax, eax                        ; Processor zero
    .586p
fence1: cpuid
    .386p
        pop     ebx

        mov     ecx, MicroSeconds               ; (ecx) = Microseconds
        jecxz   short kese10                    ; return if no loop needed

        mov     eax, PCR[PcStallScaleFactor]    ; get per microsecond
                                                ; loop count for the processor
        mul     ecx                             ; (eax) = desired loop count

if   DBG
;
; Make sure we the loopcount is less than 4G and is not equal to zero
;

        cmp     edx, 0
        jz      short @f
        int 3

@@:     cmp     eax,0
        jnz     short @f
        int 3
@@:
endif
ALIGN 16
        jmp     kese05

ALIGN 16
kese05: sub     eax, 1                          ; (eax) = (eax) - 1
        jnz     short kese05
kese10:
        stdRET    _KeStallExecutionProcessor

stdENDP _KeStallExecutionProcessor

_TEXT   ends

        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halx86\i386\ixusage.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    ixusage.c

Abstract:

Author:

    Ken Reneris (kenr)

Environment:

    Kernel mode only.

Revision History:

--*/

#include "halp.h"
#include "kdcom.h"
#include "acpitabl.h"

#define KEY_VALUE_BUFFER_SIZE 1024

//
// Array to remember hal's IDT usage
//

#ifdef ALLOC_DATA_PRAGMA
#pragma data_seg("INITCONST") //Yes, this says INITCONST, but that is fine.
#endif

//
// IDT vector usage info
//
IDTUsage    HalpIDTUsage[MAXIMUM_IDTVECTOR+1] = {0};

#ifdef ALLOC_DATA_PRAGMA
#pragma data_seg()
#endif

//
// IDT vector usage info
//
IDTUsageFlags HalpIDTUsageFlags[MAXIMUM_IDTVECTOR+1] = {0};

extern WCHAR HalpSzSystem[];
extern WCHAR HalpSzSerialNumber[];
extern ADDRESS_USAGE HalpDetectedROM;
extern ULONG HalDisableFirmwareMapper;

KAFFINITY       HalpActiveProcessors;

PUCHAR KdComPortInUse = NULL;

ADDRESS_USAGE HalpComIoSpace = {
    NULL, CmResourceTypePort, DeviceUsage,
    {
        0x2F8,  0x8,    // Default is 2F8 for COM2.  This will be changed.
        0, 0
    }
};

BOOLEAN HalpGetInfoFromACPI = FALSE;

USHORT HalpComPortIrqMapping[5][2] = {
    {COM1_PORT, 4},
    {COM2_PORT, 3},
    {COM3_PORT, 4},
    {COM4_PORT, 3},
    {0,0}
};

VOID
HalpGetResourceSortValue (
    IN PCM_PARTIAL_RESOURCE_DESCRIPTOR  pRCurLoc,
    OUT PULONG                          sortscale,
    OUT PLARGE_INTEGER                  sortvalue
    );

VOID
HalpReportSerialNumber (
    VOID
    );

VOID
HalpMarkAcpiHal(
    VOID
    );

#ifndef ACPI_HAL

VOID
HalpInheritROMBlocks (
    VOID
    );

VOID
HalpAddROMRanges (
    VOID
    );

#endif

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT,HalpEnableInterruptHandler)
#pragma alloc_text(INIT,HalpRegisterVector)
#pragma alloc_text(INIT,HalpGetResourceSortValue)
#pragma alloc_text(INIT,HalpReportResourceUsage)
#pragma alloc_text(INIT,HalpReportSerialNumber)
#pragma alloc_text(PAGE, HalpMarkAcpiHal)

#ifndef ACPI_HAL
#pragma alloc_text(INIT,HalpInheritROMBlocks)
#pragma alloc_text(INIT,HalpAddROMRanges)
#endif

#endif


#if !defined(_WIN64)

NTSTATUS
HalpEnableInterruptHandler (
    IN UCHAR    ReportFlags,
    IN ULONG    BusInterruptVector,
    IN ULONG    SystemInterruptVector,
    IN KIRQL    SystemIrql,
    IN PHAL_INTERRUPT_SERVICE_ROUTINE HalInterruptServiceRoutine,
    IN KINTERRUPT_MODE InterruptMode
    )
/*++

Routine Description:

    This function connects & registers an IDT vectors usage by the HAL.

Arguments:

Return Value:

--*/
{
    
#ifndef ACPI_HAL
    //
    // Remember which vector the hal is connecting so it can be reported
    // later on
    //
    // If this is an ACPI HAL, the vectors will be claimed by the BIOS.
    // This is done for Win98 compatibility.
    //
    HalpRegisterVector (ReportFlags, BusInterruptVector, SystemInterruptVector, SystemIrql);
#endif

    //
    // Connect the IDT and enable the vector now
    //

    KiSetHandlerAddressToIDT(SystemInterruptVector, HalInterruptServiceRoutine);
    HalEnableSystemInterrupt(SystemInterruptVector, SystemIrql, InterruptMode);
    return STATUS_SUCCESS;
}
#endif



VOID
HalpRegisterVector (
    IN UCHAR    ReportFlags,
    IN ULONG    BusInterruptVector,
    IN ULONG    SystemInterruptVector,
    IN KIRQL    SystemIrql
    )
/*++

Routine Description:

    This registers an IDT vectors usage by the HAL.

Arguments:

Return Value:

--*/
{
#if DBG
    // There are only 0ff IDT entries...
    ASSERT (SystemInterruptVector <= MAXIMUM_IDTVECTOR  &&
            BusInterruptVector <= MAXIMUM_IDTVECTOR);
#endif

    //
    // Remember which vector the hal is connecting so it can be reported
    // later on
    //

    HalpIDTUsageFlags[SystemInterruptVector].Flags = ReportFlags;
    HalpIDTUsage[SystemInterruptVector].Irql  = SystemIrql;
    HalpIDTUsage[SystemInterruptVector].BusReleativeVector = (UCHAR) BusInterruptVector;
}


VOID
HalpGetResourceSortValue (
    IN PCM_PARTIAL_RESOURCE_DESCRIPTOR  pRCurLoc,
    OUT PULONG                          sortscale,
    OUT PLARGE_INTEGER                  sortvalue
    )
/*++

Routine Description:

    Used by HalpReportResourceUsage in order to properly sort
    partial_resource_descriptors.

Arguments:

    pRCurLoc    - resource descriptor

Return Value:

    sortscale   - scaling of resource descriptor for sorting
    sortvalue   - value to sort on


--*/
{
    switch (pRCurLoc->Type) {
        case CmResourceTypeInterrupt:
            *sortscale = 0;
            *sortvalue = RtlConvertUlongToLargeInteger(
                        pRCurLoc->u.Interrupt.Level );
            break;

        case CmResourceTypePort:
            *sortscale = 1;
            *sortvalue = pRCurLoc->u.Port.Start;
            break;

        case CmResourceTypeMemory:
            *sortscale = 2;
            *sortvalue = pRCurLoc->u.Memory.Start;
            break;

        default:
            *sortscale = 4;
            *sortvalue = RtlConvertUlongToLargeInteger (0);
            break;
    }
}

#ifndef ACPI_HAL

VOID
HalpInheritROMBlocks (void)
{
    PBUS_HANDLER        Bus;
    PCM_FULL_RESOURCE_DESCRIPTOR ResourceDescriptor;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR PartialResourceDescriptor;
    PKEY_VALUE_FULL_INFORMATION KeyValueBuffer;
    PCM_ROM_BLOCK BiosBlock;

    OBJECT_ATTRIBUTES ObjectAttributes;
    UNICODE_STRING SectionName;
    UNICODE_STRING WorkString;

    HANDLE RegistryHandle;
    NTSTATUS Status;

    LARGE_INTEGER ViewBase;

    PVOID BaseAddress;
    PVOID destination;

    ULONG ViewSize;
    ULONG ResultLength;
    ULONG Index;
    ULONG LastMappedAddress;

    Bus = HaliHandlerForBus (PCIBus, 0);
    if (!Bus) {
        //
        //No root bus????
        //
        return;
    }

    //
    // Set up and open KeyPath
    //

    RtlInitUnicodeString(&SectionName,HalpSzSystem);

    InitializeObjectAttributes(
        &ObjectAttributes,
        &SectionName,
        OBJ_CASE_INSENSITIVE,
        (HANDLE)NULL,
        NULL
        );

    Status = ZwOpenKey(
        &RegistryHandle,
        KEY_READ,
        &ObjectAttributes
        );

    if (!NT_SUCCESS(Status)) {
        return;
    }

    //
    // Allocate space for the data
    //

    KeyValueBuffer = ExAllocatePoolWithTag(
        PagedPool,
        KEY_VALUE_BUFFER_SIZE,
        ' MDV'
        );

    if (KeyValueBuffer == NULL) {
        ZwClose(RegistryHandle);
        return ;
    }

    //
    // Get the data for the rom information
    //

    RtlInitUnicodeString(
        &WorkString,
        L"Configuration Data"
        );

    Status = ZwQueryValueKey(
        RegistryHandle,
        &WorkString,
        KeyValueFullInformation,
        KeyValueBuffer,
        KEY_VALUE_BUFFER_SIZE,
        &ResultLength
        );

    if (!NT_SUCCESS(Status)) {
        ZwClose(RegistryHandle);
        ExFreePool(KeyValueBuffer);
        return ;
    }


    //
    //At this point, we have the data, so go ahead and
    //add in all of the range, except VGA, we can
    //assume we're not going to want to drop another card there
    //
    HalpAddRange( &Bus->BusAddresses->Memory,
                  0,
                  0,
                  0xC0000,
                  0xFFFFF
                  );



    ResourceDescriptor = (PCM_FULL_RESOURCE_DESCRIPTOR)
        ((PUCHAR) KeyValueBuffer + KeyValueBuffer->DataOffset);

    if ((KeyValueBuffer->DataLength < sizeof(CM_FULL_RESOURCE_DESCRIPTOR)) ||
        (ResourceDescriptor->PartialResourceList.Count < 2)
    ) {
        ZwClose(RegistryHandle);
        ExFreePool(KeyValueBuffer);
        // No rom blocks.
        return;
    }

    PartialResourceDescriptor = (PCM_PARTIAL_RESOURCE_DESCRIPTOR)
        ((PUCHAR)ResourceDescriptor +
        sizeof(CM_FULL_RESOURCE_DESCRIPTOR) +
        ResourceDescriptor->PartialResourceList.PartialDescriptors[0]
            .u.DeviceSpecificData.DataSize);


    if (KeyValueBuffer->DataLength < ((PUCHAR)PartialResourceDescriptor -
        (PUCHAR)ResourceDescriptor + sizeof(CM_PARTIAL_RESOURCE_DESCRIPTOR)
        + sizeof(CM_ROM_BLOCK))
    ) {
        ZwClose(RegistryHandle);
        ExFreePool(KeyValueBuffer);
        return;// STATUS_ILL_FORMED_SERVICE_ENTRY;
    }


    BiosBlock = (PCM_ROM_BLOCK)((PUCHAR)PartialResourceDescriptor +
        sizeof(CM_PARTIAL_RESOURCE_DESCRIPTOR));

    Index = PartialResourceDescriptor->u.DeviceSpecificData.DataSize /
        sizeof(CM_ROM_BLOCK);

    //
    // N.B.  Rom blocks begin on 2K (not necessarily page) boundaries
    //       They end on 512 byte boundaries.  This means that we have
    //       to keep track of the last page mapped, and round the next
    //       Rom block up to the next page boundary if necessary.
    //

    LastMappedAddress = 0xC0000;

    while (Index) {
#if 0
        DbgPrint(
            "Bios Block, PhysAddr = %lx, size = %lx\n",
            BiosBlock->Address,
            BiosBlock->Size
            );
#endif
        if ((Index > 1) &&
            ((BiosBlock->Address + BiosBlock->Size) == BiosBlock[1].Address)
        ) {
            //
            // Coalesce adjacent blocks
            //
            BiosBlock[1].Address = BiosBlock[0].Address;
            BiosBlock[1].Size += BiosBlock[0].Size;
            Index--;
            BiosBlock++;
            continue;
        }

        BaseAddress = (PVOID)(BiosBlock->Address);
        ViewSize = BiosBlock->Size;

        if ((ULONG)BaseAddress < LastMappedAddress) {
            if (ViewSize > (LastMappedAddress - (ULONG)BaseAddress)) {
                ViewSize = ViewSize - (LastMappedAddress - (ULONG)BaseAddress);
                BaseAddress = (PVOID)LastMappedAddress;
            } else {
                ViewSize = 0;
            }
        }

        ViewBase.LowPart = (ULONG)BaseAddress;

        if (ViewSize > 0) {

            HalpRemoveRange ( &Bus->BusAddresses->Memory,
                 ViewBase.LowPart,
                 ViewSize);


            LastMappedAddress = (ULONG)BaseAddress + ViewSize;
        }

        Index--;
        BiosBlock++;
    }

    //
    // Free up the handles
    //

    ZwClose(RegistryHandle);
    ExFreePool(KeyValueBuffer);


}

VOID
HalpAddROMRanges (
    VOID
    )
{
    PCM_FULL_RESOURCE_DESCRIPTOR resourceDescriptor;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR partialResourceDescriptor;
    PKEY_VALUE_FULL_INFORMATION keyValueBuffer;
    PCM_ROM_BLOCK biosBlock;
    ULONG resultLength;
    OBJECT_ATTRIBUTES objectAttributes;
    UNICODE_STRING sectionName;
    UNICODE_STRING workString;
    HANDLE registryHandle;
    NTSTATUS status;
    LARGE_INTEGER viewBase;
    PVOID baseAddress;
    ULONG viewSize;
    ULONG index;
    ULONG element;
    ULONG lastMappedAddress;
    ADDRESS_USAGE *addrUsage;

    RtlInitUnicodeString(&sectionName, HalpSzSystem);
    InitializeObjectAttributes( &objectAttributes,
                                &sectionName,
                                OBJ_CASE_INSENSITIVE,
                                (HANDLE)NULL,
                                NULL);
    status = ZwOpenKey( &registryHandle,
                        KEY_READ,
                        &objectAttributes);
    if (NT_SUCCESS(status)) {
        
        //
        // Allocate space for the data
        //
    
        keyValueBuffer = ExAllocatePoolWithTag( PagedPool,
                                                KEY_VALUE_BUFFER_SIZE,
                                                ' MDV');
        if (keyValueBuffer) {

            //
            // Get the data for the rom information
            //
        
            RtlInitUnicodeString(   &workString,
                                    L"Configuration Data");        
            status = ZwQueryValueKey(   registryHandle,
                                        &workString,
                                        KeyValueFullInformation,
                                        keyValueBuffer,
                                        KEY_VALUE_BUFFER_SIZE,
                                        &resultLength);
            if (NT_SUCCESS(status)) {

                resourceDescriptor = (PCM_FULL_RESOURCE_DESCRIPTOR)((PUCHAR)keyValueBuffer + keyValueBuffer->DataOffset);            
                if (    keyValueBuffer->DataLength >= sizeof(CM_FULL_RESOURCE_DESCRIPTOR) &&
                        resourceDescriptor->PartialResourceList.Count >= 2) {
                    
                    partialResourceDescriptor = (PCM_PARTIAL_RESOURCE_DESCRIPTOR)((PUCHAR)resourceDescriptor +
                                                    sizeof(CM_FULL_RESOURCE_DESCRIPTOR) +
                                                    resourceDescriptor->PartialResourceList.PartialDescriptors[0].u.DeviceSpecificData.DataSize);                                
                    if (    keyValueBuffer->DataLength >= 
                                ((PUCHAR)partialResourceDescriptor - (PUCHAR)resourceDescriptor + sizeof(CM_PARTIAL_RESOURCE_DESCRIPTOR) + sizeof(CM_ROM_BLOCK))) {

                    
                        addrUsage = &HalpDetectedROM;
                        
                        //
                        // N.B.  Rom blocks begin on 2K (not necessarily page) boundaries
                        //       They end on 512 byte boundaries.  This means that we have
                        //       to keep track of the last page mapped, and round the next
                        //       Rom block up to the next page boundary if necessary.
                        //

                        biosBlock = (PCM_ROM_BLOCK)((PUCHAR)partialResourceDescriptor + sizeof(CM_PARTIAL_RESOURCE_DESCRIPTOR));                                                              
                        lastMappedAddress = 0xC0000;                    
                        for (   index = partialResourceDescriptor->u.DeviceSpecificData.DataSize / sizeof(CM_ROM_BLOCK), element = 0;
                                index;
                                index--, biosBlock++) {

                            //
                            // Coalesce adjacent blocks
                            //

                            if (    index > 1 && (biosBlock->Address + biosBlock->Size) == biosBlock[1].Address) {

                                biosBlock[1].Address = biosBlock[0].Address;
                                biosBlock[1].Size += biosBlock[0].Size;
                                continue;

                            }

                            baseAddress = (PVOID)(biosBlock->Address);
                            viewSize = biosBlock->Size;                    
                            if ((ULONG)baseAddress < lastMappedAddress) {

                                if (viewSize > (lastMappedAddress - (ULONG)baseAddress)) {

                                    viewSize = viewSize - (lastMappedAddress - (ULONG)baseAddress);
                                    baseAddress = (PVOID)lastMappedAddress;

                                } else {

                                    viewSize = 0;

                                }
                            }

                            viewBase.LowPart = (ULONG)baseAddress;
                            if (viewSize > 0) {

                                addrUsage->Element[element].Start = viewBase.LowPart;
                                addrUsage->Element[element].Length = viewSize;
                                element++;
                                lastMappedAddress = (ULONG)baseAddress + viewSize;

                            }
                        }
                        
                        //
                        // Register address usage if we found at least one ROM block.
                        //
                            
                        if (element) {

                            addrUsage->Element[element].Start = 0;
                            addrUsage->Element[element].Length = 0;
                            HalpRegisterAddressUsage(addrUsage);

                        }                         
                    }
                }                
            }

            ExFreePool(keyValueBuffer);
        }

        ZwClose(registryHandle);        
    }
}

#endif

VOID
HalpReportResourceUsage (
    IN PUNICODE_STRING  HalName,
    IN INTERFACE_TYPE   DeviceInterfaceToUse
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    PCM_RESOURCE_LIST               RawResourceList, TranslatedResourceList;
    PCM_FULL_RESOURCE_DESCRIPTOR    pRFullDesc,      pTFullDesc;
    PCM_PARTIAL_RESOURCE_LIST       pRPartList,      pTPartList;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR pRCurLoc,        pTCurLoc;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR pRSortLoc,       pTSortLoc;
    CM_PARTIAL_RESOURCE_DESCRIPTOR  RPartialDesc,    TPartialDesc;
    ULONG   i, j, k, ListSize, Count;
    ULONG   curscale, sortscale;
    UCHAR   pass, reporton;
    INTERFACE_TYPE  interfacetype;
    ULONG           CurrentIDT, CurrentElement;
    ADDRESS_USAGE   *CurrentAddress;
    LARGE_INTEGER   curvalue, sortvalue;

#ifdef ACPI_HAL
    extern PDEBUG_PORT_TABLE HalpDebugPortTable;
#endif

    //
    // Claim the debugger com port resource if it is in use
    //
    if (KdComPortInUse != NULL) {
        HalpComIoSpace.Element[0].Start = (ULONG)(ULONG_PTR)KdComPortInUse;
        HalpRegisterAddressUsage(&HalpComIoSpace);

#ifdef ACPI_HAL
        if (HalpDebugPortTable) {
            if (HalpDebugPortTable->BaseAddress.AddressSpaceID == 1) {
                HalpGetInfoFromACPI = TRUE;
            }
        }
#endif

        //
        // The debugger does not use any interrupts. However for consistent
        // behaviour between a machine with and without a debugger, we claim
        // an interrupt for the debugger if the debugger port address is one
        // for COM1-4.
        //
        
        if (!HalpGetInfoFromACPI) {
            for (i = 0; HalpComPortIrqMapping[i][0]; i++) {
                
                if ((PUCHAR)HalpComPortIrqMapping[i][0] == KdComPortInUse) {
                    
                    HalpRegisterVector( DeviceUsage | InterruptLatched,
                                        HalpComPortIrqMapping[i][1],
                                        HalpComPortIrqMapping[i][1] +
                                        PRIMARY_VECTOR_BASE,
                                        HIGH_LEVEL);
                    break;
                }
            }
        }
    }
    
#ifndef ACPI_HAL  // ACPI HALs don't deal with address maps

    HalpInheritROMBlocks();

    HalpAddROMRanges();

#endif

    //
    // Allocate some space to build the resource structure
    //

    RawResourceList = (PCM_RESOURCE_LIST)ExAllocatePoolWithTag(
                                             NonPagedPool,
                                             PAGE_SIZE*2,
                                             HAL_POOL_TAG);
    TranslatedResourceList = (PCM_RESOURCE_LIST)ExAllocatePoolWithTag(
                                                    NonPagedPool,
                                                    PAGE_SIZE*2,
                                                    HAL_POOL_TAG);
    if (!RawResourceList || !TranslatedResourceList) {

        //
        // These allocations were critical.
        //

        KeBugCheckEx(HAL_MEMORY_ALLOCATION,
                     PAGE_SIZE*4,
                     1,
                     (ULONG_PTR)__FILE__,
                     __LINE__
                     );
    }

    // This functions assumes unset fields are zero
    RtlZeroMemory(RawResourceList, PAGE_SIZE*2);
    RtlZeroMemory(TranslatedResourceList, PAGE_SIZE*2);

    //
    // Initialize the lists
    //

    RawResourceList->List[0].InterfaceType = (INTERFACE_TYPE) -1;

    pRFullDesc = RawResourceList->List;
    pRCurLoc = (PCM_PARTIAL_RESOURCE_DESCRIPTOR) RawResourceList->List;
    pTCurLoc = (PCM_PARTIAL_RESOURCE_DESCRIPTOR) TranslatedResourceList->List;

    //
    // Make sure all vectors 00-2f are reserved
    // 00-1E reserved by Intel
    // 1F    reserved by Intel for APIC (apc priority level)
    // 20-2e reserved by Microsoft
    // 2f    reserved by Microsoft for APIC (dpc priority level)
    //

    for(i=0; i < PRIMARY_VECTOR_BASE; i++) {
        if (!(HalpIDTUsageFlags[i].Flags & IDTOwned)) {
             HalpIDTUsageFlags[i].Flags = InternalUsage;
             HalpIDTUsage[i].BusReleativeVector = (UCHAR) i;
        }
    }

    for(pass=0; pass < 2; pass++) {
        if (pass == 0) {
            //
            // First pass - build resource lists for resources reported
            // reported against device usage.
            //

            reporton = DeviceUsage & ~IDTOwned;
            interfacetype = DeviceInterfaceToUse;
        } else {

            //
            // Second pass = build reousce lists for resources reported
            // as internal usage.
            //

            reporton = InternalUsage & ~IDTOwned;
            interfacetype = Internal;
        }

        CurrentIDT = 0;
        CurrentElement = 0;
        CurrentAddress = HalpAddressUsageList;

        for (; ;) {
            if (CurrentIDT <= MAXIMUM_IDTVECTOR) {
                //
                // Check to see if CurrentIDT needs to be reported
                //

                if (!(HalpIDTUsageFlags[CurrentIDT].Flags & reporton)) {
                    // Don't report on this one
                    CurrentIDT++;
                    continue;
                }

                //
                // Report CurrentIDT resource
                //

                RPartialDesc.Type = CmResourceTypeInterrupt;
                RPartialDesc.ShareDisposition = CmResourceShareDriverExclusive;
                RPartialDesc.Flags =
                    HalpIDTUsageFlags[CurrentIDT].Flags & InterruptLatched ?
                    CM_RESOURCE_INTERRUPT_LATCHED :
                    CM_RESOURCE_INTERRUPT_LEVEL_SENSITIVE;
                RPartialDesc.u.Interrupt.Vector = HalpIDTUsage[CurrentIDT].BusReleativeVector;
                RPartialDesc.u.Interrupt.Level = HalpIDTUsage[CurrentIDT].BusReleativeVector;
                RPartialDesc.u.Interrupt.Affinity = HalpActiveProcessors;

                RtlCopyMemory (&TPartialDesc, &RPartialDesc, sizeof TPartialDesc);
                TPartialDesc.u.Interrupt.Vector = CurrentIDT;
                TPartialDesc.u.Interrupt.Level = HalpIDTUsage[CurrentIDT].Irql;

                CurrentIDT++;

            } else {
                //
                // Check to see if CurrentAddress needs to be reported
                //

                if (!CurrentAddress) {
                    break;                  // No addresses left
                }

                if (!(CurrentAddress->Flags & reporton)) {
                    // Don't report on this list
                    CurrentElement = 0;
                    CurrentAddress = CurrentAddress->Next;
                    continue;
                }

                if (!CurrentAddress->Element[CurrentElement].Length) {
                    // End of current list, go to next list
                    CurrentElement = 0;
                    CurrentAddress = CurrentAddress->Next;
                    continue;
                }

                //
                // Report CurrentAddress
                //

                RPartialDesc.Type = (UCHAR) CurrentAddress->Type;
                RPartialDesc.ShareDisposition = CmResourceShareDriverExclusive;

                if (RPartialDesc.Type == CmResourceTypePort) {
                    i = 1;              // address space port
                    RPartialDesc.Flags = CM_RESOURCE_PORT_IO;

                    if (HalpBusType == MACHINE_TYPE_EISA) {
                        RPartialDesc.Flags |= CM_RESOURCE_PORT_16_BIT_DECODE;
                    }
#ifdef ACPI_HAL
                    RPartialDesc.Flags |= CM_RESOURCE_PORT_16_BIT_DECODE;
#endif
                } else {
                    i = 0;              // address space memory
                    if (CurrentAddress->Flags & RomResource) {
                        RPartialDesc.Flags = CM_RESOURCE_MEMORY_READ_ONLY;
                    } else {
                        RPartialDesc.Flags = CM_RESOURCE_MEMORY_READ_WRITE;
                    }
                }

                // Notice: assuming u.Memory and u.Port have the same layout
                RPartialDesc.u.Memory.Start.HighPart = 0;
                RPartialDesc.u.Memory.Start.LowPart =
                    CurrentAddress->Element[CurrentElement].Start;

                RPartialDesc.u.Memory.Length =
                    CurrentAddress->Element[CurrentElement].Length;

                // translated address = Raw address
                RtlCopyMemory (&TPartialDesc, &RPartialDesc, sizeof TPartialDesc);
                HalTranslateBusAddress (
                    interfacetype,                  // device bus or internal
                    0,                              // bus number
                    RPartialDesc.u.Memory.Start,    // source address
                    &i,                             // address space
                    &TPartialDesc.u.Memory.Start ); // translated address

                if (RPartialDesc.Type == CmResourceTypePort  &&  i == 0) {
                    TPartialDesc.Flags = CM_RESOURCE_PORT_MEMORY;
                }

                CurrentElement++;
            }

            //
            // Include the current resource in the HALs list
            //

            if (pRFullDesc->InterfaceType != interfacetype) {
                //
                // Interface type changed, add another full section
                //

                RawResourceList->Count++;
                TranslatedResourceList->Count++;

                pRFullDesc = (PCM_FULL_RESOURCE_DESCRIPTOR) pRCurLoc;
                pTFullDesc = (PCM_FULL_RESOURCE_DESCRIPTOR) pTCurLoc;

                pRFullDesc->InterfaceType = interfacetype;
                pTFullDesc->InterfaceType = interfacetype;

                pRPartList = &pRFullDesc->PartialResourceList;
                pTPartList = &pTFullDesc->PartialResourceList;

                //
                // Bump current location pointers up
                //
                pRCurLoc = pRFullDesc->PartialResourceList.PartialDescriptors;
                pTCurLoc = pTFullDesc->PartialResourceList.PartialDescriptors;
            }


            pRPartList->Count++;
            pTPartList->Count++;
            RtlCopyMemory (pRCurLoc, &RPartialDesc, sizeof RPartialDesc);
            RtlCopyMemory (pTCurLoc, &TPartialDesc, sizeof TPartialDesc);

            pRCurLoc++;
            pTCurLoc++;
        }
    }

    ListSize = (ULONG) ( ((PUCHAR) pRCurLoc) - ((PUCHAR) RawResourceList) );

    //
    // The HAL's resource usage structures have been built
    // Sort the partial lists based on the Raw resource values
    //

    pRFullDesc = RawResourceList->List;
    pTFullDesc = TranslatedResourceList->List;

    for (i=0; i < RawResourceList->Count; i++) {

        pRCurLoc = pRFullDesc->PartialResourceList.PartialDescriptors;
        pTCurLoc = pTFullDesc->PartialResourceList.PartialDescriptors;
        Count = pRFullDesc->PartialResourceList.Count;

        for (j=0; j < Count; j++) {
            HalpGetResourceSortValue (pRCurLoc, &curscale, &curvalue);

            pRSortLoc = pRCurLoc;
            pTSortLoc = pTCurLoc;

            for (k=j; k < Count; k++) {
                HalpGetResourceSortValue (pRSortLoc, &sortscale, &sortvalue);

                if (sortscale < curscale ||
                    (sortscale == curscale &&
                     RtlLargeIntegerLessThan (sortvalue, curvalue)) ) {

                    //
                    // Swap the elements..
                    //

                    RtlCopyMemory (&RPartialDesc, pRCurLoc, sizeof RPartialDesc);
                    RtlCopyMemory (pRCurLoc, pRSortLoc, sizeof RPartialDesc);
                    RtlCopyMemory (pRSortLoc, &RPartialDesc, sizeof RPartialDesc);

                    // swap translated descriptor as well
                    RtlCopyMemory (&TPartialDesc, pTCurLoc, sizeof TPartialDesc);
                    RtlCopyMemory (pTCurLoc, pTSortLoc, sizeof TPartialDesc);
                    RtlCopyMemory (pTSortLoc, &TPartialDesc, sizeof TPartialDesc);

                    // get new curscale & curvalue
                    HalpGetResourceSortValue (pRCurLoc, &curscale, &curvalue);
                }

                pRSortLoc++;
                pTSortLoc++;
            }

            pRCurLoc++;
            pTCurLoc++;
        }

        pRFullDesc = (PCM_FULL_RESOURCE_DESCRIPTOR) pRCurLoc;
        pTFullDesc = (PCM_FULL_RESOURCE_DESCRIPTOR) pTCurLoc;
    }

    HalpMarkAcpiHal();

    //
    // Inform the IO system of our resources..
    //

    IoReportHalResourceUsage (
        HalName,
        RawResourceList,
        TranslatedResourceList,
        ListSize
    );

    ExFreePool (RawResourceList);
    ExFreePool (TranslatedResourceList);

    //
    // Add system's serial number
    //

    HalpReportSerialNumber ();
}

VOID
HalpReportSerialNumber (
    VOID
    )
{
    OBJECT_ATTRIBUTES   objectAttributes;
    UNICODE_STRING      unicodeString;
    HANDLE              hSystem;
    NTSTATUS            status;

    if (!HalpSerialLen) {
        return ;
    }

    //
    // Open HKEY_LOCAL_MACHINE\Hardware\Description\System
    //

    RtlInitUnicodeString (&unicodeString, HalpSzSystem);
    InitializeObjectAttributes (
        &objectAttributes,
        &unicodeString,
        OBJ_CASE_INSENSITIVE,
        NULL,       // handle
        NULL
        );


    status = ZwOpenKey (&hSystem, KEY_READ | KEY_WRITE, &objectAttributes);
    if (NT_SUCCESS(status)) {

        //
        // Add "Serial Number" as REG_BINARY
        //

        RtlInitUnicodeString (&unicodeString, HalpSzSerialNumber);

        ZwSetValueKey (
                hSystem,
                &unicodeString,
                0L,
                REG_BINARY,
                HalpSerialNumber,
                HalpSerialLen
                );

        ZwClose (hSystem);
    }
}

VOID
HalpMarkAcpiHal(
    VOID
    )

/*++

Routine Description:


Arguments:

    None.

Return Value:

    None.

--*/
{
    UNICODE_STRING unicodeString;
    HANDLE hCurrentControlSet, handle;
    NTSTATUS status;

    PAGED_CODE();

    //
    // Open/create System\CurrentControlSet key.
    //

    RtlInitUnicodeString(&unicodeString, L"\\REGISTRY\\MACHINE\\SYSTEM\\CURRENTCONTROLSET");
    status = HalpOpenRegistryKey (
                 &hCurrentControlSet,
                 NULL,
                 &unicodeString,
                 KEY_ALL_ACCESS,
                 FALSE
                 );
    if (!NT_SUCCESS(status)) {
        return;
    }

    //
    // Open HKLM\System\CurrentControlSet\Control\Pnp
    //

    RtlInitUnicodeString(&unicodeString, L"Control\\Pnp");
    status = HalpOpenRegistryKey (
                 &handle,
                 hCurrentControlSet,
                 &unicodeString,
                 KEY_ALL_ACCESS,
                 TRUE
                 );
    ZwClose(hCurrentControlSet);
    if (!NT_SUCCESS(status)) {
        return;
    }

    RtlInitUnicodeString(&unicodeString, L"DisableFirmwareMapper");
    ZwSetValueKey(handle,
                  &unicodeString,
                  0,
                  REG_DWORD,
                  &HalDisableFirmwareMapper,
                  sizeof(HalDisableFirmwareMapper)
                  );
    ZwClose(handle);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halx86\i386\ixswint.asm ===
title   "Software Interrupts"

;++
;
; Copyright (c) 1992  Microsoft Corporation
;
; Module Name:
;
;    ixswint.asm
;
; Abstract:
;
;    This module implements the software interrupt handlers
;    for x86 machines
;
; Author:
;
;    John Vert (jvert) 2-Jan-1992
;
; Environment:
;
;    Kernel mode only.
;
; Revision History:
;
;--

.386p
        .xlist
include hal386.inc
include callconv.inc                    ; calling convention macros
include i386\ix8259.inc
include i386\kimacro.inc
        .list

        EXTRNP  _KiDeliverApc,3,IMPORT
        EXTRNP  _KiDispatchInterrupt,0,IMPORT
        EXTRNP  Kei386EoiHelper,0,IMPORT
        EXTRNP  _HalEndSystemInterrupt,2
        extrn   SWInterruptHandlerTable:dword
        extrn   SWInterruptLookUpTable:byte
ifdef IRQL_METRICS
        extrn   HalApcSoftwareIntCount:dword
        extrn   HalDpcSoftwareIntCount:dword
endif

_TEXT$02   SEGMENT DWORD PUBLIC 'CODE'
        ASSUME  DS:FLAT, ES:FLAT, SS:FLAT, FS:NOTHING, GS:NOTHING

        page ,132
        subttl  "Request Software Interrupt"

;++
;
; VOID
; HalRequestSoftwareInterrupt (
;    IN KIRQL RequestIrql
;    )
;
; Routine Description:
;
;    This routine is used to request a software interrupt to the
;    system. Also, this routine checks to see if any software
;    interrupt should be generated.
;    The following condition will cause software interrupt to
;    be simulated:
;      any software interrupt which has higher priority than
;        current IRQL's is pending.
;
;    NOTE: This routine simulates software interrupt as long as
;          any pending SW interrupt level is higher than the current
;          IRQL, even when interrupts are disabled.
;
; Arguments:
;
;    (cl) = RequestIrql - Supplies the request IRQL value
;
; Return Value:
;
;    None.
;
;--

cPublicFastCall HalRequestSoftwareInterrupt ,1
cPublicFpo 0, 1

        mov     eax,1
        shl     eax, cl                 ; convert to mask
        pushfd                          ; save interrupt mode
        cli                             ; disable interrupt
        or      PCR[PcIRR], eax         ; set the request bit
        mov     ecx, PCR[PcIrql]        ; get current IRQL

        mov     eax, PCR[PcIRR]         ; get SW interrupt request register
        and     eax, 3                  ; mask off pending HW interrupts

        xor     edx, edx
        mov     dl, SWInterruptLookUpTable[eax] ; get the highest pending
                                        ; software interrupt level
        cmp     dl, cl                  ; Is highest SW int level > irql?
        jbe     short KsiExit           ; No, jmp ksiexit
        call    SWInterruptHandlerTable[edx*4] ; yes, simulate interrupt
                                        ; to the appropriate handler
KsiExit:
        popfd                           ; restore original interrupt mode
        fstRET  HalRequestSoftwareInterrupt

fstENDP HalRequestSoftwareInterrupt

        page ,132
        subttl  "Request Software Interrupt"

;++
;
; VOID
; HalClearSoftwareInterrupt (
;    IN KIRQL RequestIrql
;    )
;
; Routine Description:
;
;   This routine is used to clear a possible pending software interrupt.
;   Support for this function is optional, and allows the kernel to
;   reduce the number of spurious software interrupts it receives/
;
; Arguments:
;
;    (cl) = RequestIrql - Supplies the request IRQL value
;
; Return Value:
;
;    None.
;
;--

cPublicFastCall HalClearSoftwareInterrupt ,1
cPublicFpo 0, 0

        mov     eax,1
        shl     eax, cl                 ; convert to mask

        not     eax
        and     PCR[PcIRR], eax         ; clear pending irr bit

        fstRET  HalClearSoftwareInterrupt

fstENDP HalClearSoftwareInterrupt



        page ,132
        subttl  "Dispatch Interrupt"
;++
;
; VOID
; HalpDispatchInterrupt(
;       VOID
;       );
;
; Routine Description:
;
;    This routine is the interrupt handler for a software interrupt generated
;    at DISPATCH_LEVEL.  Its function is to save the machine state, raise
;    Irql to DISPATCH_LEVEL, dismiss the interrupt, and call the DPC
;    delivery routine.
;
; Arguments:
;
;    None
;    Interrupt is disabled
;
; Return Value:
;
;    None.
;
;--

        ENTER_DR_ASSIST hdpi_a, hdpi_t

        align dword
        public _HalpDispatchInterrupt
_HalpDispatchInterrupt proc
ifdef IRQL_METRICS
        lock inc HalDpcSoftwareIntCount
endif
;
; Create IRET frame on stack
;
        pop     eax
        pushfd
        push    cs
        push    eax

;
; Save machine state on trap frame
;

        ENTER_INTERRUPT hdpi_a, hdpi_t
.FPO ( FPO_LOCALS+1, 0, 0, 0, 0, FPO_TRAPFRAME )

        public  _HalpDispatchInterrupt2ndEntry
_HalpDispatchInterrupt2ndEntry:

; Save previous IRQL and set new priority level

        push    dword ptr PCR[PcIrql]            ; save previous IRQL
        mov     dword ptr PCR[PcIrql], DISPATCH_LEVEL; set new irql
        and     dword ptr PCR[PcIRR], not (1 shl DISPATCH_LEVEL) ; clear the pending bit in IRR

;
; Now it is safe to enable interrupt to allow higher priority interrupt
; to come in.
;

        sti

;
; Go do Dispatch Interrupt processing
;
        stdCall   _KiDispatchInterrupt

;
; Do interrupt exit processing
;

        SOFT_INTERRUPT_EXIT                          ; will do an iret

_HalpDispatchInterrupt endp

        page ,132
        subttl  "APC Interrupt"
;++
;
; HalpApcInterrupt(
;       VOID
;       );
;
; Routine Description:
;
;    This routine is entered as the result of a software interrupt generated
;    at APC_LEVEL. Its function is to save the machine state, raise Irql to
;    APC_LEVEL, dismiss the interrupt, and call the APC delivery routine.
;
; Arguments:
;
;    None
;    Interrupt is Disabled
;
; Return Value:
;
;    None.
;
;--

        ENTER_DR_ASSIST hapc_a, hapc_t

        align dword
        public _HalpApcInterrupt
_HalpApcInterrupt proc
ifdef IRQL_METRICS
        lock inc HalApcSoftwareIntCount
endif
;
; Create IRET frame on stack
;
        pop     eax
        pushfd
        push    cs
        push    eax

;
; Save machine state in trap frame
;
        ENTER_INTERRUPT hapc_a, hapc_t
.FPO ( FPO_LOCALS+1, 0, 0, 0, 0, FPO_TRAPFRAME )


        public     _HalpApcInterrupt2ndEntry
_HalpApcInterrupt2ndEntry:

;
; Save previous IRQL and set new priority level
;

        push    dword ptr PCR[PcIrql]             ; save previous Irql
        mov     dword ptr PCR[PcIrql], APC_LEVEL  ; set new Irql
        and     dword ptr PCR[PcIRR], not (1 shl APC_LEVEL) ; dismiss pending APC
;
; Now it is safe to enable interrupt to allow higher priority interrupt
; to come in.
;

        sti

;
; call the APC delivery routine.
;

        mov     eax, [ebp]+TsSegCs      ; get interrupted code's CS
        and     eax, MODE_MASK          ; extract the mode

        test    dword ptr [ebp]+TsEFlags, EFLAGS_V86_MASK
        jz      short @f

        or      eax, MODE_MASK          ; If v86 frame, then set user_mode
@@:

;
; call APC deliver routine
;       Previous mode
;       Null exception frame
;       Trap frame

        stdCall   _KiDeliverApc, <eax, 0,ebp>

;
;
; Do interrupt exit processing
;

        SOFT_INTERRUPT_EXIT                  ; will do an iret

_HalpApcInterrupt       endp

_TEXT$02   ends

        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halx86\i386\ixsysbus.c ===
/*++


Copyright (c) 1989  Microsoft Corporation

Module Name:

    ixsysbus.c

Abstract:

Author:

Environment:

Revision History:


--*/

#include "halp.h"
#ifdef WANT_IRQ_ROUTING
#include "ixpciir.h"
#endif

KAFFINITY HalpDefaultInterruptAffinity;

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE,HalpGetSystemInterruptVector)
#pragma alloc_text(PAGE,HalTranslatorReference)
#pragma alloc_text(PAGE,HalTranslatorDereference)
#pragma alloc_text(PAGE,HalIrqTranslateResourcesRoot)
#pragma alloc_text(PAGE,HalIrqTranslateResourceRequirementsRoot)
#pragma alloc_text(PAGE,HalpTransMemIoResource)
#pragma alloc_text(PAGE,HalpTransMemIoResourceRequirement)
#pragma alloc_text(PAGE,HaliGetInterruptTranslator)
#endif

BOOLEAN
HalpFindBusAddressTranslation(
    IN PHYSICAL_ADDRESS BusAddress,
    IN OUT PULONG AddressSpace,
    OUT PPHYSICAL_ADDRESS TranslatedAddress,
    IN OUT PULONG_PTR Context,
    IN BOOLEAN NextBus
    )

/*++

Routine Description:

    This routine performs a very similar function to HalTranslateBusAddress
    except that InterfaceType and BusNumber are not known by the caller.
    This function will walk all busses known by the HAL looking for a
    valid translation for the input BusAddress of type AddressSpace.

    This function is recallable using the input/output Context parameter.
    On the first call to this routine for a given translation the ULONG_PTR
    Context should be NULL.  Note:  Not the address of it but the contents.

    If the caller decides the returned translation is not the desired
    translation, it calls this routine again passing Context in as it
    was returned on the previous call.  This allows this routine to
    traverse the bus structures until the correct translation is found
    and is provided because on multiple bus systems, it is possible for
    the same resource to exist in the independent address spaces of
    multiple busses.

Arguments:

    BusAddress          Address to be translated.
    AddressSpace        0 = Memory
                        1 = IO (There are other possibilities).
                        N.B. This argument is a pointer, the value
                        will be modified if the translated address
                        is of a different address space type from
                        the untranslated bus address.
    TranslatedAddress   Pointer to where the translated address
                        should be stored.
    Context             Pointer to a ULONG_PTR. On the initial call,
                        for a given BusAddress, it should contain
                        0.  It will be modified by this routine,
                        on subsequent calls for the same BusAddress
                        the value should be handed in again,
                        unmodified by the caller.
    NextBus             FALSE if we should attempt this translation
                        on the same bus as indicated by Context,
                        TRUE if we should be looking for another
                        bus.

Return Value:

    TRUE    if translation was successful,
    FALSE   otherwise.

--*/

{
    //
    // First, make sure the context parameter was supplied and is
    // being used correctly.  This also ensures that the caller
    // doesn't get stuck in a loop looking for subsequent translations
    // for the same thing.  We won't succeed the same translation twice
    // unless the caller reinits the context.
    //

    if ((!Context) || (*Context && (NextBus == TRUE))) {
        return FALSE;
    }
    *Context = 1;

    //
    // PC/AT (halx86) case is simplest, there is no translation.
    //

    *TranslatedAddress = BusAddress;
    return TRUE;
}

BOOLEAN
HalpTranslateSystemBusAddress(
    IN PBUS_HANDLER BusHandler,
    IN PBUS_HANDLER RootHandler,
    IN PHYSICAL_ADDRESS BusAddress,
    IN OUT PULONG AddressSpace,
    OUT PPHYSICAL_ADDRESS TranslatedAddress
    )

/*++

Routine Description:

    This function translates a bus-relative address space and address into
    a system physical address.

Arguments:

    BusAddress        - Supplies the bus-relative address

    AddressSpace      -  Supplies the address space number.
                         Returns the host address space number.

                         AddressSpace == 0 => memory space
                         AddressSpace == 1 => I/O space

    TranslatedAddress - Supplies a pointer to return the translated address

Return Value:

    A return value of TRUE indicates that a system physical address
    corresponding to the supplied bus relative address and bus address
    number has been returned in TranslatedAddress.

    A return value of FALSE occurs if the translation for the address was
    not possible

--*/

{
    PSUPPORTED_RANGE    pRange;

    pRange = NULL;

    //
    // If this fails, it means someone has given us a RESOURCE_TYPE with some decode type flags
    // set. We should probably handle this.
    //

    ASSERT (*AddressSpace == 0 ||
            *AddressSpace == 1);

    //
    // The checking of bus ranges for PCI busses is performed by the PCI driver
    // in NT5 (or Windows 2000 or whatever its called) so only check for none
    // PCI busses.
    //


    switch (*AddressSpace) {
    case 0:

        if (BusHandler->InterfaceType != PCIBus) {

           // verify memory address is within buses memory limits
           for (pRange = &BusHandler->BusAddresses->PrefetchMemory; pRange; pRange = pRange->Next) {
                if (BusAddress.QuadPart >= pRange->Base &&
                    BusAddress.QuadPart <= pRange->Limit) {
                    break;
                }
           }

           if (!pRange) {
               for (pRange = &BusHandler->BusAddresses->Memory; pRange; pRange = pRange->Next) {
                    if (BusAddress.QuadPart >= pRange->Base &&
                        BusAddress.QuadPart <= pRange->Limit) {
                        break;
                    }
               }
           }

        } else {
            //
            // This is a PCI bus and SystemBase is constant for all ranges
            //

            pRange = &BusHandler->BusAddresses->Memory;
        }

        break;

    case 1:

        if (BusHandler->InterfaceType != PCIBus) {

            // verify IO address is within buses IO limits
            for (pRange = &BusHandler->BusAddresses->IO; pRange; pRange = pRange->Next) {
                if (BusAddress.QuadPart >= pRange->Base &&
                    BusAddress.QuadPart <= pRange->Limit) {
                    break;
                }
            }
            break;

        } else {
            //
            // This is a PCI bus and SystemBase is constant for all ranges
            //

            pRange = &BusHandler->BusAddresses->IO;

        }
    }


    if (pRange) {
        TranslatedAddress->QuadPart = BusAddress.QuadPart + pRange->SystemBase;
        *AddressSpace = pRange->SystemAddressSpace;
        return TRUE;
    }

    return FALSE;
}


ULONG
HalpGetRootInterruptVector(
    IN ULONG InterruptLevel,
    IN ULONG InterruptVector,
    OUT PKIRQL Irql,
    OUT PKAFFINITY Affinity
    )
{
    ULONG SystemVector;
    
    UNREFERENCED_PARAMETER( InterruptLevel );

    SystemVector = InterruptLevel + PRIMARY_VECTOR_BASE;
    
    if ((SystemVector < PRIMARY_VECTOR_BASE) ||
        (SystemVector > PRIMARY_VECTOR_BASE + HIGHEST_LEVEL_FOR_8259) ) {

        //
        // This is an illegal BusInterruptVector and cannot be connected.
        //

        return(0);
    }
    
    *Irql = (KIRQL)(HIGHEST_LEVEL_FOR_8259 + PRIMARY_VECTOR_BASE - SystemVector);
    *Affinity = HalpDefaultInterruptAffinity;
    ASSERT(HalpDefaultInterruptAffinity);

    return SystemVector;

}

ULONG
HalpGetSystemInterruptVector(
    IN PBUS_HANDLER BusHandler,
    IN PBUS_HANDLER RootHandler,
    IN ULONG BusInterruptLevel,
    IN ULONG BusInterruptVector,
    OUT PKIRQL Irql,
    OUT PKAFFINITY Affinity
    )

/*++

Routine Description:

Arguments:

    BusInterruptLevel - Supplies the bus specific interrupt level.

    BusInterruptVector - Supplies the bus specific interrupt vector.

    Irql - Returns the system request priority.

    Affinity - Returns the system wide irq affinity.

Return Value:

    Returns the system interrupt vector corresponding to the specified device.

--*/
{
    ULONG SystemVector;

    UNREFERENCED_PARAMETER( BusHandler );
    UNREFERENCED_PARAMETER( RootHandler );

    SystemVector = HalpGetRootInterruptVector(BusInterruptLevel,
                                              BusInterruptVector,
                                              Irql,
                                              Affinity);
    
    if (HalpIDTUsageFlags[SystemVector].Flags & IDTOwned ) {

        //
        // This is an illegal BusInterruptVector and cannot be connected.
        //

        return(0);
    }

    return SystemVector;
}

//
// This section implements a "translator," which is the PnP-WDM way
// of doing the same thing that the first part of this file does.
//
VOID
HalTranslatorReference(
    PVOID Context
    )
{
    return;
}

VOID
HalTranslatorDereference(
    PVOID Context
    )
{
    return;
}

NTSTATUS
HalIrqTranslateResourcesRoot(
    IN PVOID Context,
    IN PCM_PARTIAL_RESOURCE_DESCRIPTOR Source,
    IN RESOURCE_TRANSLATION_DIRECTION Direction,
    IN ULONG AlternativesCount, OPTIONAL
    IN IO_RESOURCE_DESCRIPTOR Alternatives[], OPTIONAL
    IN PDEVICE_OBJECT PhysicalDeviceObject,
    OUT PCM_PARTIAL_RESOURCE_DESCRIPTOR Target
    )
/*++

Routine Description:

    This function takes a CM_PARTIAL_RESOURCE_DESCRIPTOR and translates
    it to an IO-bus-relative from a Processor-bus-relative form, or the other
    way around.  In this x86-specific example, an IO-bus-relative form is the
    ISA IRQ and the Processor-bus-relative form is the IDT entry and the
    associated IRQL.

    N.B.  This funtion has an associated "Direction."  These are not exactly
          reciprocals.  This has to be the case because the output from
          HalIrqTranslateResourceRequirementsRoot will be used as the input
          for the ParentToChild case.

          ChildToParent:

            Level  (ISA IRQ)        -> IRQL
            Vector (ISA IRQ)        -> x86 IDT entry
            Affinity (not refereced)-> KAFFINITY

          ParentToChild:

            Level (not referenced)  -> (ISA IRQ)
            Vector (IDT entry)      -> (ISA IRQ)
            Affinity                -> 0xffffffff

Arguments:

    Context     - unused

    Source      - descriptor that we are translating

    Direction   - direction of translation (parent to child or child to parent)

    AlternativesCount   - unused

    Alternatives        - unused
    
    PhysicalDeviceObject- unused

    Target      - translated descriptor

Return Value:

    status

--*/
{
    NTSTATUS status = STATUS_UNSUCCESSFUL;
    KAFFINITY  affinity;
    KIRQL      irql;
    ULONG      vector;

    UNREFERENCED_PARAMETER(AlternativesCount);
    UNREFERENCED_PARAMETER(Alternatives);
    UNREFERENCED_PARAMETER(PhysicalDeviceObject);
    
    PAGED_CODE();

    ASSERT(Source->Type == CmResourceTypeInterrupt);

    //
    // Copy everything
    //
    *Target = *Source;

    switch (Direction) {
    case TranslateChildToParent:

        //
        // Translate the IRQ
        //

        vector = HalpGetRootInterruptVector(Source->u.Interrupt.Level,
                                            Source->u.Interrupt.Vector,
                                            &irql,
                                            &affinity);
        if (vector != 0) {

            Target->u.Interrupt.Level  = irql;
            Target->u.Interrupt.Vector = vector;
            Target->u.Interrupt.Affinity = affinity;
            status = STATUS_TRANSLATION_COMPLETE;
        }

        break;

    case TranslateParentToChild:                                        

        //
        // There is no inverse to HalpGetSystemInterruptVector, so we
        // just do what that function would do.
        //
        Target->u.Interrupt.Level = Target->u.Interrupt.Vector =
            Source->u.Interrupt.Vector - PRIMARY_VECTOR_BASE;
        Target->u.Interrupt.Affinity = 0xFFFFFFFF;

        status = STATUS_SUCCESS;

        break;

    default:
        status = STATUS_INVALID_PARAMETER;
    }
    return status;
}

NTSTATUS
HalIrqTranslateResourceRequirementsRoot(
    IN PVOID Context,
    IN PIO_RESOURCE_DESCRIPTOR Source,
    IN PDEVICE_OBJECT PhysicalDeviceObject,
    OUT PULONG TargetCount,
    OUT PIO_RESOURCE_DESCRIPTOR *Target
    )
/*++

Routine Description:

    This function takes an IO_RESOURCE_DESCRIPTOR and translates
    it from an IO-bus-relative to a Processor-bus-relative form.  In this
    x86-specific example, an IO-bus-relative form is the ISA IRQ and the
    Processor-bus-relative form is the IDT entry and the associated IRQL.
    This is essentially a PnP form of HalGetInterruptVector.

Arguments:

    Context     - unused

    Source      - descriptor that we are translating

    PhysicalDeviceObject- unused

    TargetCount - 1

    Target      - translated descriptor

Return Value:

    status

--*/
{
    KAFFINITY  affinity;
    KIRQL      irql;
    ULONG      vector;

    PAGED_CODE();

    ASSERT(Source->Type == CmResourceTypeInterrupt);

    //
    // The interrupt requirements were obtained by calling HalAdjustResourceList
    // so we don't need to call it again.
    //

    *Target = ExAllocatePoolWithTag(PagedPool,
                                    sizeof(IO_RESOURCE_DESCRIPTOR),
                                    HAL_POOL_TAG
                                    );
    if (!*Target) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    *TargetCount = 1;

    //
    // Copy the requirement unchanged
    //

    **Target = *Source;

    //
    // Perform the translation of the minimum & maximum
    //

    vector = HalpGetRootInterruptVector(Source->u.Interrupt.MinimumVector,
                                        Source->u.Interrupt.MinimumVector,
                                        &irql,
                                        &affinity);

    (*Target)->u.Interrupt.MinimumVector = vector;

    vector = HalpGetRootInterruptVector(Source->u.Interrupt.MaximumVector,
                                        Source->u.Interrupt.MaximumVector,
                                        &irql,
                                        &affinity);

    (*Target)->u.Interrupt.MaximumVector = vector;

    return STATUS_TRANSLATION_COMPLETE;
}

NTSTATUS
HalpTransMemIoResourceRequirement(
    IN PVOID Context,
    IN PIO_RESOURCE_DESCRIPTOR Source,
    IN PDEVICE_OBJECT PhysicalDeviceObject,
    OUT PULONG TargetCount,
    OUT PIO_RESOURCE_DESCRIPTOR *Target
    )

/*++

Routine Description:

    This routine translates memory and IO resource requirements.

Parameters:

    Context - The context from the TRANSLATOR_INTERFACE

    Source - The interrupt requirement to translate

    PhysicalDeviceObject - The device requesting the resource

    TargetCount - Pointer to where to return the number of descriptors this
        requirement translates into

    Target - Pointer to where a pointer to a callee allocated buffer containing
        the translated descriptors should be placed.

Return Value:

    STATUS_SUCCESS or an error status

Note:

    We do not perform any translation.

--*/

{
    ASSERT(Source);
    ASSERT(Target);
    ASSERT(TargetCount);
    ASSERT(Source->Type == CmResourceTypeMemory ||
           Source->Type == CmResourceTypePort);


    //
    // Allocate space for the target
    //

    *Target = ExAllocatePoolWithTag(PagedPool,
                                    sizeof(IO_RESOURCE_DESCRIPTOR),
                                    HAL_POOL_TAG
                                    );
    if (!*Target) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Copy the source to target and update the fields that have changed
    //

    **Target = *Source;
    *TargetCount = 1;

    return STATUS_SUCCESS;
}

NTSTATUS
HalpTransMemIoResource(
    IN PVOID Context,
    IN PCM_PARTIAL_RESOURCE_DESCRIPTOR Source,
    IN RESOURCE_TRANSLATION_DIRECTION Direction,
    IN ULONG AlternativesCount, OPTIONAL
    IN IO_RESOURCE_DESCRIPTOR Alternatives[], OPTIONAL
    IN PDEVICE_OBJECT PhysicalDeviceObject,
    OUT PCM_PARTIAL_RESOURCE_DESCRIPTOR Target
    )

/*++

Routine Description:

    This routine translates memory and IO resources.   On generic x86
    machines, such as those that use this HAL, there isn't actually
    any translation.

Parameters:

    Context - The context from the TRANSLATOR_INTERFACE

    Source - The interrupt resource to translate

    Direction - The direction in relation to the Pnp device tree translation
        should occur in.

    AlternativesCount - The number of alternatives this resource was selected
        from.

    Alternatives - Array of alternatives this resource was selected from.

    PhysicalDeviceObject - The device requesting the resource

    Target - Pointer to a caller allocated buffer to hold the translted resource
        descriptor.

Return Value:

    STATUS_SUCCESS or an error status

--*/

{
    NTSTATUS status;

    //
    // Copy the target to the source
    //

    *Target = *Source;

    switch (Direction) {
    case TranslateChildToParent:

        //
        // Make sure PnP knows it doesn't have to walk up the tree
        // translating at each point.
        //

        status = STATUS_TRANSLATION_COMPLETE;
        break;

    case TranslateParentToChild:

        //
        // We do not translate requirements so do nothing...
        //

        status = STATUS_SUCCESS;
        break;

    default:
        status = STATUS_INVALID_PARAMETER;
    }
    return status;
}

NTSTATUS
HaliGetInterruptTranslator(
        IN INTERFACE_TYPE ParentInterfaceType,
        IN ULONG ParentBusNumber,
        IN INTERFACE_TYPE BridgeInterfaceType,
        IN USHORT Size,
        IN USHORT Version,
        OUT PTRANSLATOR_INTERFACE Translator,
        OUT PULONG BridgeBusNumber
        )
/*++

Routine Description:


Arguments:

        ParentInterfaceType - The type of the bus the bridge lives on (normally PCI).

        ParentBusNumber - The number of the bus the bridge lives on.

        ParentSlotNumber - The slot number the bridge lives in (where valid).

        BridgeInterfaceType - The bus type the bridge provides (ie ISA for a PCI-ISA bridge).

        ResourceType - The resource type we want to translate.

        Size - The size of the translator buffer.

        Version - The version of the translator interface requested.

        Translator - Pointer to the buffer where the translator should be returned

        BridgeBusNumber - Pointer to where the bus number of the bridge bus should be returned

Return Value:

    Returns the status of this operation.

--*/
{
    PAGED_CODE();

    UNREFERENCED_PARAMETER(ParentInterfaceType);
    UNREFERENCED_PARAMETER(ParentBusNumber);

    ASSERT(Version == HAL_IRQ_TRANSLATOR_VERSION);
    ASSERT(Size >= sizeof(TRANSLATOR_INTERFACE));

#ifdef WANT_IRQ_ROUTING

        //
        // Dont provide Irq translator iff Pci Irq Routing
        // is enabled.
        //

        if (IsPciIrqRoutingEnabled()) {

            HalPrint(("Not providing Isa Irq Translator since Pci Irq routing is enabled!\n"));

            return STATUS_NOT_SUPPORTED;
        }

#endif
    
    //
    // Fill in the common bits.
    //

    RtlZeroMemory(Translator, sizeof (TRANSLATOR_INTERFACE));

    Translator->Size = sizeof(TRANSLATOR_INTERFACE);
    Translator->Version = HAL_IRQ_TRANSLATOR_VERSION;
    Translator->Context = (PVOID)BridgeInterfaceType;
    Translator->InterfaceReference = HalTranslatorReference;
    Translator->InterfaceDereference = HalTranslatorDereference;

    switch (BridgeInterfaceType) {
    case Eisa:
    case Isa:
    case InterfaceTypeUndefined:  // special "IDE" cookie

        //
        // Set IRQ translator for (E)ISA interrupts.
        //

        Translator->TranslateResources = HalIrqTranslateResourcesIsa;
        Translator->TranslateResourceRequirements =
            HalIrqTranslateResourceRequirementsIsa;

        return STATUS_SUCCESS;

    case MicroChannel:
    case PCIBus:

        //
        // Set IRQ translator for the MCA interrupts.
        //

        Translator->TranslateResources = HalIrqTranslateResourcesRoot;
        Translator->TranslateResourceRequirements =
            HalIrqTranslateResourceRequirementsRoot;

        return STATUS_SUCCESS;
    }
    
    //
    // If we got here, we don't have an interface.
    //

    return STATUS_NOT_SUPPORTED;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halx86\i386\ixsysint.asm ===
;++
;
;Copyright (c) 1991  Microsoft Corporation
;
;Module Name:
;
;    ixsysint.asm
;
;Abstract:
;
;    This module implements the HAL routines to enable/disable system
;    interrupts.
;
;Author:
;
;    John Vert (jvert) 22-Jul-1991
;
;Environment:
;
;    Kernel Mode
;
;Revision History:
;
;--


.386p
        .xlist
include hal386.inc
include callconv.inc                    ; calling convention macros
include i386\ix8259.inc
include i386\kimacro.inc
include mac386.inc
        .list

        extrn   KiI8259MaskTable:DWORD
        EXTRNP  _KeBugCheck,1,IMPORT

ifdef IRQL_METRICS
        extrn   HalPostponedIntCount:dword
endif
        extrn   _HalpEisaELCR:dword     ; Set bit indicates LEVEL
        extrn   _HalpEisaIrqIgnore:dword
        extrn   SWInterruptHandlerTable:dword
        extrn   _HalpIrqMiniportInitialized:dword
        extrn   HalpHardwareInterruptLevel:proc
        extrn   _PciirqmpGetTrigger@4:proc
        extrn   _PciirqmpSetTrigger@4:proc

;
; Constants used to initialize CMOS/Real Time Clock
;

CMOS_CONTROL_PORT       EQU     70h     ; command port for cmos
CMOS_DATA_PORT          EQU     71h     ; cmos data port

;
; Macros to Read/Write/Reset CMOS to initialize RTC
;

; CMOS_READ
;
; Description: This macro read a byte from the CMOS register specified
;        in (AL).
;
; Parameter: (AL) = address/register to read
; Return: (AL) = data
;

CMOS_READ       MACRO
        OUT     CMOS_CONTROL_PORT,al    ; ADDRESS LOCATION AND DISABLE NMI
        IODelay                         ; I/O DELAY
        IN      AL,CMOS_DATA_PORT       ; READ IN REQUESTED CMOS DATA
        IODelay                         ; I/O DELAY
ENDM

_DATA   SEGMENT DWORD PUBLIC 'DATA'

align   dword
;
; HalDismissSystemInterrupt does an indirect jump through this table so it
; can quickly execute specific code for different interrupts.
;
        public  HalpSpecialDismissTable
HalpSpecialDismissTable label   dword
        dd      offset FLAT:HalpDismissNormal   ; irq 0
        dd      offset FLAT:HalpDismissNormal   ; irq 1
        dd      offset FLAT:HalpDismissNormal   ; irq 2
        dd      offset FLAT:HalpDismissNormal   ; irq 3
        dd      offset FLAT:HalpDismissNormal   ; irq 4
        dd      offset FLAT:HalpDismissNormal   ; irq 5
        dd      offset FLAT:HalpDismissNormal   ; irq 6
        dd      offset FLAT:HalpDismissIrq07    ; irq 7
        dd      offset FLAT:HalpDismissNormal   ; irq 8
        dd      offset FLAT:HalpDismissNormal   ; irq 9
        dd      offset FLAT:HalpDismissNormal   ; irq A
        dd      offset FLAT:HalpDismissNormal   ; irq B
        dd      offset FLAT:HalpDismissNormal   ; irq C
        dd      offset FLAT:HalpDismissIrq0d    ; irq D
        dd      offset FLAT:HalpDismissNormal   ; irq E
        dd      offset FLAT:HalpDismissIrq0f    ; irq F
        dd      offset FLAT:HalpDismissNormal   ; irq 10
        dd      offset FLAT:HalpDismissNormal   ; irq 11
        dd      offset FLAT:HalpDismissNormal   ; irq 12
        dd      offset FLAT:HalpDismissNormal   ; irq 13
        dd      offset FLAT:HalpDismissNormal   ; irq 14
        dd      offset FLAT:HalpDismissNormal   ; irq 15
        dd      offset FLAT:HalpDismissNormal   ; irq 16
        dd      offset FLAT:HalpDismissNormal   ; irq 17
        dd      offset FLAT:HalpDismissNormal   ; irq 18
        dd      offset FLAT:HalpDismissNormal   ; irq 19
        dd      offset FLAT:HalpDismissNormal   ; irq 1A
        dd      offset FLAT:HalpDismissNormal   ; irq 1B
        dd      offset FLAT:HalpDismissNormal   ; irq 1C
        dd      offset FLAT:HalpDismissNormal   ; irq 1D
        dd      offset FLAT:HalpDismissNormal   ; irq 1E
        dd      offset FLAT:HalpDismissNormal   ; irq 1F
        dd      offset FLAT:HalpDismissNormal   ; irq 20
        dd      offset FLAT:HalpDismissNormal   ; irq 21
        dd      offset FLAT:HalpDismissNormal   ; irq 22
        dd      offset FLAT:HalpDismissNormal   ; irq 23
        dd      offset FLAT:HalpDismissInvalidVector  ;24
        dd      offset FLAT:HalpDismissInvalidVector  ;25
        dd      offset FLAT:HalpDismissInvalidVector  ;26
        dd      offset FLAT:HalpDismissInvalidVector  ;27
        dd      offset FLAT:HalpDismissInvalidVector  ;28
        dd      offset FLAT:HalpDismissInvalidVector  ;29
        dd      offset FLAT:HalpDismissInvalidVector  ;2a
        dd      offset FLAT:HalpDismissInvalidVector  ;2b
        dd      offset FLAT:HalpDismissInvalidVector  ;2c
        dd      offset FLAT:HalpDismissInvalidVector  ;2d
        dd      offset FLAT:HalpDismissInvalidVector  ;2e
        dd      offset FLAT:HalpDismissInvalidVector  ;2f
        dd      offset FLAT:HalpDismissInvalidVector  ;30
        dd      offset FLAT:HalpDismissInvalidVector  ;31
        dd      offset FLAT:HalpDismissInvalidVector  ;32
        dd      offset FLAT:HalpDismissInvalidVector  ;33
        dd      offset FLAT:HalpDismissInvalidVector  ;34
        dd      offset FLAT:HalpDismissInvalidVector  ;35
        dd      offset FLAT:HalpDismissInvalidVector  ;36
        dd      offset FLAT:HalpDismissInvalidVector  ;37
        dd      offset FLAT:HalpDismissInvalidVector  ;38
        dd      offset FLAT:HalpDismissInvalidVector  ;39
        dd      offset FLAT:HalpDismissInvalidVector  ;3a
        dd      offset FLAT:HalpDismissInvalidVector  ;3b
        dd      offset FLAT:HalpDismissInvalidVector  ;3c
        dd      offset FLAT:HalpDismissInvalidVector  ;3d
        dd      offset FLAT:HalpDismissInvalidVector  ;3e
        dd      offset FLAT:HalpDismissInvalidVector  ;3f
        dd      offset FLAT:HalpDismissInvalidVector  ;40
        dd      offset FLAT:HalpDismissInvalidVector  ;41
        dd      offset FLAT:HalpDismissInvalidVector  ;42
        dd      offset FLAT:HalpDismissInvalidVector  ;43
        dd      offset FLAT:HalpDismissInvalidVector  ;44
        dd      offset FLAT:HalpDismissInvalidVector  ;45
        dd      offset FLAT:HalpDismissInvalidVector  ;46
        dd      offset FLAT:HalpDismissInvalidVector  ;47
        dd      offset FLAT:HalpDismissInvalidVector  ;48
        dd      offset FLAT:HalpDismissInvalidVector  ;49
        dd      offset FLAT:HalpDismissInvalidVector  ;4a
        dd      offset FLAT:HalpDismissInvalidVector  ;4b
        dd      offset FLAT:HalpDismissInvalidVector  ;4c
        dd      offset FLAT:HalpDismissInvalidVector  ;4d
        dd      offset FLAT:HalpDismissInvalidVector  ;4e
        dd      offset FLAT:HalpDismissInvalidVector  ;4f
        dd      offset FLAT:HalpDismissInvalidVector  ;50
        dd      offset FLAT:HalpDismissInvalidVector  ;51
        dd      offset FLAT:HalpDismissInvalidVector  ;52
        dd      offset FLAT:HalpDismissInvalidVector  ;53
        dd      offset FLAT:HalpDismissInvalidVector  ;54
        dd      offset FLAT:HalpDismissInvalidVector  ;55
        dd      offset FLAT:HalpDismissInvalidVector  ;56
        dd      offset FLAT:HalpDismissInvalidVector  ;57
        dd      offset FLAT:HalpDismissInvalidVector  ;58
        dd      offset FLAT:HalpDismissInvalidVector  ;59
        dd      offset FLAT:HalpDismissInvalidVector  ;5a
        dd      offset FLAT:HalpDismissInvalidVector  ;5b
        dd      offset FLAT:HalpDismissInvalidVector  ;5c
        dd      offset FLAT:HalpDismissInvalidVector  ;5d
        dd      offset FLAT:HalpDismissInvalidVector  ;5e
        dd      offset FLAT:HalpDismissInvalidVector  ;5f
        dd      offset FLAT:HalpDismissInvalidVector  ;60
        dd      offset FLAT:HalpDismissInvalidVector  ;61
        dd      offset FLAT:HalpDismissInvalidVector  ;62
        dd      offset FLAT:HalpDismissInvalidVector  ;63
        dd      offset FLAT:HalpDismissInvalidVector  ;64
        dd      offset FLAT:HalpDismissInvalidVector  ;65
        dd      offset FLAT:HalpDismissInvalidVector  ;66
        dd      offset FLAT:HalpDismissInvalidVector  ;67
        dd      offset FLAT:HalpDismissInvalidVector  ;68
        dd      offset FLAT:HalpDismissInvalidVector  ;69
        dd      offset FLAT:HalpDismissInvalidVector  ;6a
        dd      offset FLAT:HalpDismissInvalidVector  ;6b
        dd      offset FLAT:HalpDismissInvalidVector  ;6c
        dd      offset FLAT:HalpDismissInvalidVector  ;6d
        dd      offset FLAT:HalpDismissInvalidVector  ;6e
        dd      offset FLAT:HalpDismissInvalidVector  ;6f
        dd      offset FLAT:HalpDismissInvalidVector  ;70
        dd      offset FLAT:HalpDismissInvalidVector  ;71
        dd      offset FLAT:HalpDismissInvalidVector  ;72
        dd      offset FLAT:HalpDismissInvalidVector  ;73
        dd      offset FLAT:HalpDismissInvalidVector  ;74
        dd      offset FLAT:HalpDismissInvalidVector  ;75
        dd      offset FLAT:HalpDismissInvalidVector  ;76
        dd      offset FLAT:HalpDismissInvalidVector  ;77
        dd      offset FLAT:HalpDismissInvalidVector  ;78
        dd      offset FLAT:HalpDismissInvalidVector  ;79
        dd      offset FLAT:HalpDismissInvalidVector  ;7a
        dd      offset FLAT:HalpDismissInvalidVector  ;7b
        dd      offset FLAT:HalpDismissInvalidVector  ;7c
        dd      offset FLAT:HalpDismissInvalidVector  ;7d
        dd      offset FLAT:HalpDismissInvalidVector  ;7e
        dd      offset FLAT:HalpDismissInvalidVector  ;7f
        dd      offset FLAT:HalpDismissInvalidVector  ;80
        dd      offset FLAT:HalpDismissInvalidVector  ;81
        dd      offset FLAT:HalpDismissInvalidVector  ;82
        dd      offset FLAT:HalpDismissInvalidVector  ;83
        dd      offset FLAT:HalpDismissInvalidVector  ;84
        dd      offset FLAT:HalpDismissInvalidVector  ;85
        dd      offset FLAT:HalpDismissInvalidVector  ;86
        dd      offset FLAT:HalpDismissInvalidVector  ;87
        dd      offset FLAT:HalpDismissInvalidVector  ;88
        dd      offset FLAT:HalpDismissInvalidVector  ;89
        dd      offset FLAT:HalpDismissInvalidVector  ;8a
        dd      offset FLAT:HalpDismissInvalidVector  ;8b
        dd      offset FLAT:HalpDismissInvalidVector  ;8c
        dd      offset FLAT:HalpDismissInvalidVector  ;8d
        dd      offset FLAT:HalpDismissInvalidVector  ;8e
        dd      offset FLAT:HalpDismissInvalidVector  ;8f
        dd      offset FLAT:HalpDismissInvalidVector  ;90
        dd      offset FLAT:HalpDismissInvalidVector  ;91
        dd      offset FLAT:HalpDismissInvalidVector  ;92
        dd      offset FLAT:HalpDismissInvalidVector  ;93
        dd      offset FLAT:HalpDismissInvalidVector  ;94
        dd      offset FLAT:HalpDismissInvalidVector  ;95
        dd      offset FLAT:HalpDismissInvalidVector  ;96
        dd      offset FLAT:HalpDismissInvalidVector  ;97
        dd      offset FLAT:HalpDismissInvalidVector  ;98
        dd      offset FLAT:HalpDismissInvalidVector  ;99
        dd      offset FLAT:HalpDismissInvalidVector  ;9a
        dd      offset FLAT:HalpDismissInvalidVector  ;9b
        dd      offset FLAT:HalpDismissInvalidVector  ;9c
        dd      offset FLAT:HalpDismissInvalidVector  ;9d
        dd      offset FLAT:HalpDismissInvalidVector  ;9e
        dd      offset FLAT:HalpDismissInvalidVector  ;9f
        dd      offset FLAT:HalpDismissInvalidVector  ;a0
        dd      offset FLAT:HalpDismissInvalidVector  ;a1
        dd      offset FLAT:HalpDismissInvalidVector  ;a2
        dd      offset FLAT:HalpDismissInvalidVector  ;a3
        dd      offset FLAT:HalpDismissInvalidVector  ;a4
        dd      offset FLAT:HalpDismissInvalidVector  ;a5
        dd      offset FLAT:HalpDismissInvalidVector  ;a6
        dd      offset FLAT:HalpDismissInvalidVector  ;a7
        dd      offset FLAT:HalpDismissInvalidVector  ;a8
        dd      offset FLAT:HalpDismissInvalidVector  ;a9
        dd      offset FLAT:HalpDismissInvalidVector  ;aa
        dd      offset FLAT:HalpDismissInvalidVector  ;ab
        dd      offset FLAT:HalpDismissInvalidVector  ;ac
        dd      offset FLAT:HalpDismissInvalidVector  ;ad
        dd      offset FLAT:HalpDismissInvalidVector  ;ae
        dd      offset FLAT:HalpDismissInvalidVector  ;af
        dd      offset FLAT:HalpDismissInvalidVector  ;b0
        dd      offset FLAT:HalpDismissInvalidVector  ;b1
        dd      offset FLAT:HalpDismissInvalidVector  ;b2
        dd      offset FLAT:HalpDismissInvalidVector  ;b3
        dd      offset FLAT:HalpDismissInvalidVector  ;b4
        dd      offset FLAT:HalpDismissInvalidVector  ;b5
        dd      offset FLAT:HalpDismissInvalidVector  ;b6
        dd      offset FLAT:HalpDismissInvalidVector  ;b7
        dd      offset FLAT:HalpDismissInvalidVector  ;b8
        dd      offset FLAT:HalpDismissInvalidVector  ;b9
        dd      offset FLAT:HalpDismissInvalidVector  ;ba
        dd      offset FLAT:HalpDismissInvalidVector  ;bb
        dd      offset FLAT:HalpDismissInvalidVector  ;bc
        dd      offset FLAT:HalpDismissInvalidVector  ;bd
        dd      offset FLAT:HalpDismissInvalidVector  ;be
        dd      offset FLAT:HalpDismissInvalidVector  ;bf
        dd      offset FLAT:HalpDismissInvalidVector  ;c0
        dd      offset FLAT:HalpDismissInvalidVector  ;c1
        dd      offset FLAT:HalpDismissInvalidVector  ;c2
        dd      offset FLAT:HalpDismissInvalidVector  ;c3
        dd      offset FLAT:HalpDismissInvalidVector  ;c4
        dd      offset FLAT:HalpDismissInvalidVector  ;c5
        dd      offset FLAT:HalpDismissInvalidVector  ;c6
        dd      offset FLAT:HalpDismissInvalidVector  ;c7
        dd      offset FLAT:HalpDismissInvalidVector  ;c8
        dd      offset FLAT:HalpDismissInvalidVector  ;c9
        dd      offset FLAT:HalpDismissInvalidVector  ;ca
        dd      offset FLAT:HalpDismissInvalidVector  ;cb
        dd      offset FLAT:HalpDismissInvalidVector  ;cc
        dd      offset FLAT:HalpDismissInvalidVector  ;cd
        dd      offset FLAT:HalpDismissInvalidVector  ;ce
        dd      offset FLAT:HalpDismissInvalidVector  ;cf

_DATA   ENDS

_TEXT   SEGMENT DWORD PUBLIC 'DATA'

        public  HalpSpecialDismissLevelTable
HalpSpecialDismissLevelTable label   dword
        dd      offset FLAT:HalpDismissLevel        ; irq 0
        dd      offset FLAT:HalpDismissLevel        ; irq 1
        dd      offset FLAT:HalpDismissLevel        ; irq 2
        dd      offset FLAT:HalpDismissLevel        ; irq 3
        dd      offset FLAT:HalpDismissLevel        ; irq 4
        dd      offset FLAT:HalpDismissLevel        ; irq 5
        dd      offset FLAT:HalpDismissLevel        ; irq 6
        dd      offset FLAT:HalpDismissIrq07Level   ; irq 7
        dd      offset FLAT:HalpDismissLevel        ; irq 8
        dd      offset FLAT:HalpDismissLevel        ; irq 9
        dd      offset FLAT:HalpDismissLevel        ; irq A
        dd      offset FLAT:HalpDismissLevel        ; irq B
        dd      offset FLAT:HalpDismissLevel        ; irq C
        dd      offset FLAT:HalpDismissIrq0dLevel   ; irq D
        dd      offset FLAT:HalpDismissLevel        ; irq E
        dd      offset FLAT:HalpDismissIrq0fLevel   ; irq F

_TEXT   ENDS

_TEXT$01   SEGMENT DWORD PUBLIC 'CODE'
        ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING


;++
;BOOLEAN
;HalBeginSystemInterrupt(
;    IN KIRQL Irql
;    IN CCHAR Vector,
;    OUT PKIRQL OldIrql
;    )
;
;
;
;Routine Description:
;
;    This routine is used to dismiss the specified vector number.  It is called
;    before any interrupt service routine code is executed.
;
;    N.B.  This routine does NOT preserve EAX or EBX
;
;    On a UP machine the interrupt dismissed at BeginSystemInterrupt time.
;    This is fine since the irql is being raise to mask it off.
;    HalEndSystemInterrupt is simply a LowerIrql request.
;
;
;Arguments:
;
;    Irql   - Supplies the IRQL to raise to
;
;    Vector - Supplies the vector of the interrupt to be dismissed
;
;    OldIrql- Location to return OldIrql
;
;
;Return Value:
;
;    FALSE - Interrupt is spurious and should be ignored
;
;    TRUE -  Interrupt successfully dismissed and Irql raised.
;
;--
align dword
HbsiIrql        equ     byte  ptr [esp+4]
HbsiVector      equ     byte  ptr [esp+8]
HbsiOldIrql     equ     dword ptr [esp+12]

cPublicProc _HalBeginSystemInterrupt ,3
.FPO ( 0, 3, 0, 0, 0, 0 )
        xor     ecx, ecx
        mov     cl, HbsiVector                  ; (ecx) = System Vector
        sub     ecx, PRIMARY_VECTOR_BASE        ; (ecx) = 8259 IRQ #
if DBG
        cmp     ecx, 1fh
        jbe     hbsi00
        int     3
hbsi00:

endif
        jmp     HalpSpecialDismissTable[ecx*4]

HalpDismissIrq0f:
;
; Check to see if this is a spurious interrupt
;
        mov     al, OCW3_READ_ISR       ; tell 8259 we want to read ISR
        out     PIC2_PORT0, al
        IODelay                         ; delay
        in      al, PIC2_PORT0          ; (al) = content of PIC 1 ISR
        test    al, 10000000B           ; Is In-Service register set?
        jnz     short HalpDismissNormal ; No, this is NOT a spurious int,
                                        ; go do the normal interrupt stuff
HalpIrq0fSpurious:
;
; This is a spurious interrupt.
; Because the slave PIC is cascaded to irq2 of master PIC, we need to
; dismiss the interupt on master PIC's irq2.
;

        mov     al, PIC2_EOI            ; Specific eoi to master for pic2 eoi
        out     PIC1_PORT0, al          ; send irq2 specific eoi to master
        mov     eax,0                   ; return FALSE
        stdRET    _HalBeginSystemInterrupt

HalpDismissIrq07:
;
; Check to see if this is a spurious interrupt
;
        mov     al, OCW3_READ_ISR       ; tell 8259 we want to read ISR
        out     PIC1_PORT0, al
        IODelay                         ; delay
        in      al, PIC1_PORT0          ; (al) = content of PIC 1 ISR
        test    al, 10000000B           ; Is In-Service register set?
        jnz     HalpDismissNormal       ; No, so this is NOT a spurious int
        mov     eax, 0                  ; return FALSE
        stdRET    _HalBeginSystemInterrupt

HalpDismissIrq0d:
;
; Clear the NPX busy latch.
;

        xor     al,al
        out     I386_80387_BUSY_PORT, al

align 4
HalpDismissNormal:
;
; Raise IRQL to requested level
;
        xor     eax, eax
        mov     al, HbsiIrql            ; (al) = New irql
                                        ; (ecx) = IRQ #
        mov     ebx, PCR[PcIrql]        ; (ebx) = Current Irql

;
; Now we check to make sure the Irql of this interrupt > current Irql.
; If it is not, we dismiss it as spurious and set the appropriate bit
; in the IRR so we can dispatch the interrupt when Irql is lowered
;
        cmp     al, bl
        jbe     Hdsi300

        mov     PCR[PcIrql], eax        ; set new Irql
        mov     edx, HbsiOldIrql        ; save current irql to OldIrql variable
        mov     byte ptr [edx], bl

;
; Dismiss interrupt.
;
        mov     eax, ecx                ; (eax) = IRQ #
        cmp     eax, 8                  ; EOI to master or slave?
        jae     short Hbsi100           ; EIO to both master and slave

        or      al, PIC1_EOI_MASK       ; create specific eoi mask for master
        out     PIC1_PORT0, al          ; dismiss the interrupt
        sti
        mov     eax, 1                  ; return TRUE
        stdRET    _HalBeginSystemInterrupt

align 4
Hbsi100:
        add     al, OCW2_SPECIFIC_EOI - 8   ; specific eoi to slave
        out     PIC2_PORT0, al

        mov     al, PIC2_EOI            ; specific eoi to master for pic2 eoi
        out     PIC1_PORT0, al          ; send irq2 specific eoi to master
        sti
        mov     eax, 1                  ; return TRUE
        stdRET    _HalBeginSystemInterrupt

align 4
HalpDismissInvalidVector:
        mov     eax,0                   ; return FALSE
        stdRET    _HalBeginSystemInterrupt

align 4
Hdsi300:
;
; An interrupt has come in at a lower Irql, so we dismiss it as spurious and
; set the appropriate bit in the IRR so that KeLowerIrql knows to dispatch
; it when Irql is lowered.
;
; (ecx) = 8259 IRQ#
; (al)  = New Irql
; (ebx) = Current Irql
;

        mov     eax, 1
        add     ecx, 4                  ; (ecx) = Irq # + 4
        shl     eax, cl
        or      PCR[PcIRR], eax

;
; Raise Irql to prevent it from happening again
;

;
; Get the PIC masks for Irql
;

        mov     eax, KiI8259MaskTable[ebx*4]
        or      eax, PCR[PcIDR]
;
; Write the new interrupt mask register back to the 8259
;
        SET_8259_MASK

Hbsi390:

ifdef IRQL_METRICS
        lock inc HalPostponedIntCount
endif

        xor     eax, eax                ; return FALSE, spurious interrupt
        stdRET    _HalBeginSystemInterrupt


HalpDismissIrq0fLevel:
;
; Check to see if this is a spurious interrupt
;
        mov     al, OCW3_READ_ISR       ; tell 8259 we want to read ISR
        out     PIC2_PORT0, al
        IODelay                         ; delay
        in      al, PIC2_PORT0          ; (al) = content of PIC 1 ISR
        test    al, 10000000B           ; Is In-Service register set?
        jnz     short HalpDismissLevel  ; No, this is NOT a spurious int,
                                        ; go do the normal interrupt stuff
        jmp     HalpIrq0fSpurious

HalpDismissIrq07Level:
;
; Check to see if this is a spurious interrupt
;
        mov     al, OCW3_READ_ISR       ; tell 8259 we want to read ISR
        out     PIC1_PORT0, al
        IODelay                         ; delay
        in      al, PIC1_PORT0          ; (al) = content of PIC 1 ISR
        test    al, 10000000B           ; Is In-Service register set?
        jnz     short HalpDismissLevel  ; No, so this is NOT a spurious int
        mov     eax, 0                  ; return FALSE
        stdRET    _HalBeginSystemInterrupt

HalpDismissIrq0dLevel:
;
; Clear the NPX busy latch.
;

        xor     al,al
        out     I386_80387_BUSY_PORT, al

align 4
HalpDismissLevel:
;
; Mask this level interrupt off
; (ecx) = 8259 IRQ#
;
        mov     al, HbsiIrql            ; (al) = New irql
        mov     eax, KiI8259MaskTable[eax*4]    ; get 8259's masks
        or      eax, PCR[PcIDR]         ; mask disabled irqs
        SET_8259_MASK                   ; send mask to 8259s
;
; The SWInterruptHandler for this vector has been set to a NOP.
; Set the vector's IRR so that Lower Irql will clear the 8259 mask for this
; Irq when the irql is lowered below this level.
;
        mov     eax, ecx                ; (eax) = Irq #
        mov     ebx, 1
        add     ecx, 4                  ; (ecx) = Irq # + 4
        shl     ebx, cl
        or      PCR[PcIRR], ebx

;
; Dismiss interrupt.  Current interrupt is already masked off.
; Then check to make sure the Irql of this interrupt > current Irql.
; If it is not, we dismiss it as spurious - since this is a level interrupt
; when the 8259's are unmasked the interrupt will reoccur
;
        mov     cl, HbsiIrql
        mov     bl, PCR[PcIrql]
        mov     edx, HbsiOldIrql

        cmp     eax, 8                  ; EOI to master or slave?
        jae     short Hbsi450           ; EIO to both master and slave

        or      al, PIC1_EOI_MASK       ; create specific eoi mask for master
        out     PIC1_PORT0, al          ; dismiss the interrupt

        cmp     cl, bl
        jbe     short Hbsi390           ; Spurious?

        movzx   ecx, cl
        mov     PCR[PcIrql], ecx        ; raise to new irql
        mov     byte ptr [edx], bl      ; return old irql
        sti
        mov     eax, 1                  ; return TRUE
        stdRET    _HalBeginSystemInterrupt

align 4
Hbsi450:
        add     al, OCW2_SPECIFIC_EOI - 8   ; specific eoi to slave
        out     PIC2_PORT0, al
        mov     al, PIC2_EOI            ; specific eoi to master for pic2 eoi
        out     PIC1_PORT0, al          ; send irq2 specific eoi to master

        cmp     cl, bl
        jbe     Hbsi390                 ; Spurious?

        movzx   ecx, cl
        mov     PCR[PcIrql], ecx        ; raise to new irql
        mov     byte ptr [edx], bl      ; return old irql
        sti
        mov     eax, 1                  ; return TRUE
        stdRET    _HalBeginSystemInterrupt

stdENDP _HalBeginSystemInterrupt


;++
;VOID
;HalDisableSystemInterrupt(
;    IN CCHAR Vector,
;    IN KIRQL Irql
;    )
;
;
;
;Routine Description:
;
;    Disables a system interrupt.
;
;Arguments:
;
;    Vector - Supplies the vector of the interrupt to be disabled
;
;    Irql   - Supplies the interrupt level of the interrupt to be disabled
;
;Return Value:
;
;    None.
;
;--
cPublicProc _HalDisableSystemInterrupt      ,2
.FPO ( 0, 2, 0, 0, 0, 0 )

;

        movzx   ecx, byte ptr [esp+4]           ; (ecx) = Vector
        sub     ecx, PRIMARY_VECTOR_BASE        ; (ecx) = 8259 irq #
        mov     edx, 1
        shl     edx, cl                         ; (ebx) = bit in IMR to disable
        cli
        or      PCR[PcIDR], edx
        xor     eax, eax

;
; Get the current interrupt mask register from the 8259
;
        in      al, PIC2_PORT1
        shl     eax, 8
        in      al, PIC1_PORT1
;
; Mask off the interrupt to be disabled
;
        or      eax, edx
;
; Write the new interrupt mask register back to the 8259
;
        out     PIC1_PORT1, al
        shr     eax, 8
        out     PIC2_PORT1, al
        PIC2DELAY

        sti
        stdRET    _HalDisableSystemInterrupt

stdENDP _HalDisableSystemInterrupt

;++
;
;BOOLEAN
;HalEnableSystemInterrupt(
;    IN ULONG Vector,
;    IN KIRQL Irql,
;    IN KINTERRUPT_MODE InterruptMode
;    )
;
;
;Routine Description:
;
;    Enables a system interrupt
;
;Arguments:
;
;    Vector - Supplies the vector of the interrupt to be enabled
;
;    Irql   - Supplies the interrupt level of the interrupt to be enabled.
;
;Return Value:
;
;    None.
;
;--
cPublicProc _HalEnableSystemInterrupt       ,3
.FPO ( 0, 3, 0, 0, 0, 0 )

        movzx   ecx, byte ptr [esp+4]           ; (ecx) = vector
        sub     ecx, PRIMARY_VECTOR_BASE
        jc      hes_error
        cmp     ecx, CLOCK2_LEVEL
        jnc     hes_error


;
; Use the IRQ miniport to get the HW state.
;
        cmp     _HalpIrqMiniportInitialized, 0
        jz      hes_noMPGet


        push    ecx
        lea     eax, _HalpEisaELCR
        push    eax
        call    _PciirqmpGetTrigger@4
        pop     ecx

hes_noMPGet:

        bt      _HalpEisaIrqIgnore,ecx ;;Is this Eisa Ignore bit set?
        jc      short hes_ProgPic
;
; Clear or set the edge\level mask bit depending on what the caller wants.
;
        btr     _HalpEisaELCR, ecx
        mov     al, [esp+12]
        cmp     al, 0
        jnz     short hes_edge

        bt      _HalpEisaELCR, ecx
        jc      short @F

        ; Caller wants level triggered interrupts
        ; if IRQ routing is turned on, try and provide it
        cmp     _HalpIrqMiniportInitialized, 0
        jz      short @F
        bts     _HalpEisaELCR, ecx


@@:
        mov     SWInterruptHandlerTable+4*4[ecx*4], offset HalpHardwareInterruptLevel

        mov     edx, HalpSpecialDismissLevelTable[ecx*4]
        mov     HalpSpecialDismissTable[ecx*4], edx

hes_edge:
        cmp     _HalpIrqMiniportInitialized, 0
        jz      hes_ProgPIC
;
; Program the HW to make it match the callers request.
;
        mov     eax, _HalpEisaELCR

        push    ecx
        push    eax
        call    _PciirqmpSetTrigger@4
        pop     ecx

if 0
.err

;;
;; We can't just arbitrarily blast ports. This makes machines do really weird things
;;
hes_noMPSet:
        mov     edx, 4d0h
        out     dx, al
        inc     edx
        mov     al, ah
        out     dx, al
endif


hes_ProgPIC:

        mov     eax, 1
        shl     eax, cl                         ; (ebx) = bit in IMR to enable
        not     eax

        cli
        and     PCR[PcIDR], eax

;
; Get the PIC masks for Irql 0
;
        mov     eax, KiI8259MaskTable[0]
        or      eax, PCR[PcIDR]
;
; Write the new interrupt mask register back to the 8259
;
        SET_8259_MASK

        sti
        mov     eax, 1                          ; return TRUE
        stdRET    _HalEnableSystemInterrupt

hes_error:
if DBG
        int 3
endif
        xor     eax, eax                        ; FALSE
        stdRET    _HalEnableSystemInterrupt

stdENDP _HalEnableSystemInterrupt


_TEXT$01   ENDS

        END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halx86\i386\xxioacc.asm ===
title  "ix ioaccess"
;++
;
; Copyright (c) 1989  Microsoft Corporation
;
; Module Name:
;
;    ixioacc.asm
;
; Abstract:
;
;    Procedures to correctly touch I/O registers.
;
; Author:
;
;    Bryan Willman (bryanwi) 16 May 1990
;
; Environment:
;
;    User or Kernel, although privledge (IOPL) may be required.
;
; Revision History:
;
;--

.386p
        .xlist
include hal386.inc
include callconv.inc                    ; calling convention macros
        .list

_TEXT$00   SEGMENT DWORD PUBLIC 'CODE'
        ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING

;++
;
; I/O port space read and write functions.
;
;  These have to be actual functions on the 386, because we need
;  to use assembler, but cannot return a value if we inline it.
;
;  This set of functions manipulates I/O registers in PORT space.
;  (Uses x86 in and out instructions)
;
;  WARNING: Port addresses must always be in the range 0 to 64K, because
;           that's the range the hardware understands.
;
;--



;++
;
;   UCHAR
;   READ_PORT_UCHAR(
;       PUCHAR  Port
;       )
;
;   Arguments:
;       (esp+4) = Port
;
;   Returns:
;       Value in Port.
;
;--
cPublicProc _READ_PORT_UCHAR ,1
cPublicFpo 1, 0

        xor     eax, eax        ; Eliminate partial stall on return to caller

        mov     edx,[esp+4]             ; (dx) = Port
        in      al,dx
        stdRET    _READ_PORT_UCHAR

stdENDP _READ_PORT_UCHAR



;++
;
;   USHORT
;   READ_PORT_USHORT(
;       PUSHORT Port
;       )
;
;   Arguments:
;       (esp+4) = Port
;
;   Returns:
;       Value in Port.
;
;--
cPublicProc _READ_PORT_USHORT ,1
cPublicFpo 1, 0

        xor     eax, eax        ; Eliminate partial stall on return to caller

        mov     edx,[esp+4]            ; (dx) = Port
        in      ax,dx
        stdRET    _READ_PORT_USHORT

stdENDP _READ_PORT_USHORT



;++
;
;   ULONG
;   READ_PORT_ULONG(
;       PULONG  Port
;       )
;
;   Arguments:
;       (esp+4) = Port
;
;   Returns:
;       Value in Port.
;
;--
cPublicProc _READ_PORT_ULONG ,1
cPublicFpo 1, 0

        mov     edx,[esp+4]            ; (dx) = Port
        in      eax,dx
        stdRET    _READ_PORT_ULONG

stdENDP _READ_PORT_ULONG



;++
;
;   VOID
;   READ_PORT_BUFFER_UCHAR(
;       PUCHAR  Port,
;       PUCHAR  Buffer,
;       ULONG   Count
;       )
;
;   Arguments:
;       (esp+4) = Port
;       (esp+8) = Buffer address
;       (esp+12) = Count
;
;--
cPublicProc _READ_PORT_BUFFER_UCHAR ,3
cPublicFpo 3, 0

        mov     eax, edi                ; Save edi

        mov     edx,[esp+4]             ; (dx) = Port
        mov     edi,[esp+8]             ; (edi) = buffer
        mov     ecx,[esp+12]            ; (ecx) = transfer count
    rep insb
        mov     edi, eax
        stdRET    _READ_PORT_BUFFER_UCHAR

stdENDP _READ_PORT_BUFFER_UCHAR


;++
;
;   VOID
;   READ_PORT_BUFFER_USHORT(
;       PUSHORT Port,
;       PUSHORT Buffer,
;       ULONG   Count
;       )
;
;   Arguments:
;       (esp+4) = Port
;       (esp+8) = Buffer address
;       (esp+12) = Count
;
;--
cPublicProc _READ_PORT_BUFFER_USHORT ,3
cPublicFpo 3, 0

        mov     eax, edi                ; Save edi

        mov     edx,[esp+4]             ; (dx) = Port
        mov     edi,[esp+8]             ; (edi) = buffer
        mov     ecx,[esp+12]            ; (ecx) = transfer count
    rep insw
        mov     edi, eax
        stdRET    _READ_PORT_BUFFER_USHORT

stdENDP _READ_PORT_BUFFER_USHORT


;++
;
;   VOID
;   READ_PORT_BUFFER_ULONG(
;       PULONG  Port,
;       PULONG  Buffer,
;       ULONG   Count
;       )
;
;   Arguments:
;       (esp+4) = Port
;       (esp+8) = Buffer address
;       (esp+12) = Count
;
;--
cPublicProc _READ_PORT_BUFFER_ULONG ,3
cPublicFpo 3, 0

        mov     eax, edi                ; Save edi

        mov     edx,[esp+4]             ; (dx) = Port
        mov     edi,[esp+8]             ; (edi) = buffer
        mov     ecx,[esp+12]            ; (ecx) = transfer count
    rep insd
        mov     edi, eax
        stdRET    _READ_PORT_BUFFER_ULONG

stdENDP _READ_PORT_BUFFER_ULONG



;++
;
;   VOID
;   WRITE_PORT_UCHAR(
;       PUCHAR  Port,
;       UCHAR   Value
;       )
;
;   Arguments:
;       (esp+4) = Port
;       (esp+8) = Value
;
;--
cPublicProc _WRITE_PORT_UCHAR ,2
cPublicFpo 2, 0

        mov     edx,[esp+4]             ; (dx) = Port
        mov     al,[esp+8]              ; (al) = Value
        out     dx,al
        stdRET    _WRITE_PORT_UCHAR

stdENDP _WRITE_PORT_UCHAR

;++
;
;   VOID
;   WRITE_PORT_USHORT(
;       PUSHORT Port,
;       USHORT  Value
;       )
;
;   Arguments:
;       (esp+4) = Port
;       (esp+8) = Value
;
;--
cPublicProc _WRITE_PORT_USHORT ,2
cPublicFpo 2, 0

        mov     edx,[esp+4]             ; (dx) = Port
        mov     eax,[esp+8]             ; (ax) = Value
        out     dx,ax
        stdRET    _WRITE_PORT_USHORT

stdENDP _WRITE_PORT_USHORT



;++
;
;   VOID
;   WRITE_PORT_ULONG(
;       PULONG  Port,
;       ULONG   Value
;       )
;
;   Arguments:
;       (esp+4) = Port
;       (esp+8) = Value
;
;--
cPublicProc _WRITE_PORT_ULONG ,2
cPublicFpo 2, 0

        mov     edx,[esp+4]             ; (dx) = Port
        mov     eax,[esp+8]             ; (eax) = Value
        out     dx,eax
        stdRET    _WRITE_PORT_ULONG

stdENDP _WRITE_PORT_ULONG


;++
;
;   VOID
;   HalpIoDelay (
;      VOID
;        )
;
;   Arguments:
;   None
;
;   Notes: Used to program the DMA controller. There exist some legacy parts that require
;   a delay after write. The chip recognizes the jmp $+2 sequence and flushes internal
;   buffers.
;
;--



cPublicFastCall HalpIoDelay,0
        jmp   $+2
        jmp   $+2                           ;Stall for IO out
        fstRET   HalpIoDelay

fstENDP HalpIoDelay



;++
;
;   VOID
;   WRITE_PORT_BUFFER_UCHAR(
;       PUCHAR  Port,
;       PUCHAR  Buffer,
;       ULONG   Count
;       )
;
;   Arguments:
;       (esp+4) = Port
;       (esp+8) = Buffer address
;       (esp+12) = Count
;
;--
cPublicProc _WRITE_PORT_BUFFER_UCHAR ,3
cPublicFpo 3, 0

        mov     eax,esi                 ; Save esi
        mov     edx,[esp+4]             ; (dx) = Port
        mov     esi,[esp+8]             ; (esi) = buffer
        mov     ecx,[esp+12]            ; (ecx) = transfer count
    rep outsb
        mov     esi,eax
        stdRET    _WRITE_PORT_BUFFER_UCHAR

stdENDP _WRITE_PORT_BUFFER_UCHAR


;++
;
;   VOID
;   WRITE_PORT_BUFFER_USHORT(
;       PUSHORT Port,
;       PUSHORT Buffer,
;       ULONG   Count
;       )
;
;   Arguments:
;       (esp+4) = Port
;       (esp+8) = Buffer address
;       (esp+12) = Count
;
;--
cPublicProc _WRITE_PORT_BUFFER_USHORT ,3
cPublicFpo 3, 0

        mov     eax,esi                 ; Save esi
        mov     edx,[esp+4]             ; (dx) = Port
        mov     esi,[esp+8]             ; (esi) = buffer
        mov     ecx,[esp+12]            ; (ecx) = transfer count
    rep outsw
        mov     esi,eax
        stdRET    _WRITE_PORT_BUFFER_USHORT

stdENDP _WRITE_PORT_BUFFER_USHORT


;++
;
;   VOID
;   WRITE_PORT_BUFFER_ULONG(
;       PULONG  Port,
;       PULONG  Buffer,
;       ULONG   Count
;       )
;
;   Arguments:
;       (esp+4) = Port
;       (esp+8) = Buffer address
;       (esp+12) = Count
;
;--
cPublicProc _WRITE_PORT_BUFFER_ULONG ,3
cPublicFpo 3, 0

        mov     eax,esi                 ; Save esi
        mov     edx,[esp+4]             ; (dx) = Port
        mov     esi,[esp+8]             ; (esi) = buffer
        mov     ecx,[esp+12]            ; (ecx) = transfer count
    rep outsd
        mov     esi,eax
        stdRET    _WRITE_PORT_BUFFER_ULONG

stdENDP _WRITE_PORT_BUFFER_ULONG

    .586p

;++
;ULONGLONG
;FASTCALL
;RDMSR(
;   IN  ULONG   MsrAddress
;   )
;   Routine Description:
;       This function reads an MSR
;
;   Arguments:
;       Msr:    The address of MSR to be read
;
;   Return Value:
;       Returns the low 32 bit of MSR in eax and high 32 bits of MSR in edx
;
;--
cPublicFastCall RDMSR,1

        rdmsr
        fstRET  RDMSR

fstENDP RDMSR

;++
;
;VOID
;WRMSR(
;   IN ULONG    MsrAddress,
;   IN ULONGLONG    MsrValue
;   )
;   Routine Description:
;       This function writes an MSR
;
;   Arguments:
;       Msr:    The address of MSR to be written
;       Data:   The value to be written to the MSR register
;
;   Return Value:
;       None
;
;--

cPublicProc _WRMSR,3

        mov     ecx, [esp + 4]  ; MsrAddress
        mov     eax, [esp + 8]  ; Low  32 bits of MsrValue
        mov     edx, [esp + 12] ; High 32 bits of MsrValue

        wrmsr
        stdRET  _WRMSR

stdENDP _WRMSR


_TEXT$00   ends

        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halx86\i386\xxflshbf.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    xxflshbf.c

Abstract:

    This module implements i386 machine dependent kernel functions to flush
    write buffers.

Author:

    David N. Cutler (davec) 26-Apr-1990

Environment:

    Kernel mode only.

Revision History:

--*/

#include "nthal.h"

VOID
KeFlushWriteBuffer (
    VOID
    )

/*++

Routine Description:

    This function flushes the write buffer on the current processor.

Arguments:

    None.

Return Value:

    None.

--*/

{

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halx86\i386\xxbiosa.asm ===
;++
;
; Copyright (c) 1991  Microsoft Corporation
;
; Module Name:
;
;     xxbiosa.asm
;
; Abstract:
;
;     This implements the necessary code to put the processor into
;     V86 mode, make a BIOS call, and return safely to protected mode.
;
; Author:
;
;     John Vert (jvert) 29-Oct-1991
;
; Environment:
;
;     Kernel mode
;
; Notes:
;
;     This module is intended for use in panic situations, such as a bugcheck.
;     As a result, we cannot rely on the integrity of the system so we must
;     handle everything ourselves.  Notably, we must map our own memory by
;     adding our own page tables and PTEs.
;
;     We also cannot call KeBugCheck when we notice something has gone wrong.
;
; Revision History:
;
;--
.386p
        .xlist
include hal386.inc
include callconv.inc                    ; calling convention macros
include i386\kimacro.inc
        .list

        extrn   _DbgPrint:proc
        EXTRNP  _DbgBreakPoint,0,IMPORT
        EXTRNP  Kei386EoiHelper,0,IMPORT

        public  _HalpRealModeStart
        public  _HalpRealModeEnd
;
; 32-bit override
;
OVERRIDE        equ     66h

;
; Reginfo structure
;

RegInfo struc
RiSegSs         dd 0
RiEsp           dd 0
RiEFlags        dd 0
RiSegCs         dd 0
RiEip           dd 0
RiTrapFrame     dd 0
RiCsLimit       dd 0
RiCsBase        dd 0
RiCsFlags       dd 0
RiSsLimit       dd 0
RiSsBase        dd 0
RiSsFlags       dd 0
RiPrefixFlags   dd 0
RegInfo ends
REGINFOSIZE     EQU 52

INT_NN_OPCODE   EQU     0CDH

        page ,132
_DATA   SEGMENT  DWORD PUBLIC 'DATA'

;
; In order to return to the calling function after we've trapped out of
; V86 mode, we save our ESP value here.
;
HalpSavedEsp    dd      0

_DATA   ENDS


_TEXT   SEGMENT DWORD PUBLIC 'CODE'
        ASSUME  DS:NOTHING, ES:NOTHING, SS:FLAT, FS:NOTHING, GS:NOTHING

if DBG
        page ,132
        subttl "Processing Exception occurred in ABIOS code"
;++
; VOID
; KiAbiosException (
;    VOID
;    )
;
; Routine Description:
;
;    This routine is called after an exception being detected
;    in ABIOS ROM code.  The system will switch 16 stack to 32 bit
;    stack and bugcheck.
;
;    N.B.  In fact this routine is simply used to resolve a reference
;          to KiAbiosException routine in the Kimacro.inc ENTER_TRAP
;          macro.
;
;
; Arguments:
;
;    None.
;
; Return value:
;
;    system stopped.
;
;--
        public  _KiAbiosException
_KiAbiosException proc
_Ki16BitStackException:
        ret

_KiAbiosException endp

endif


;++
; ULONG
; HalpBorrowTss (
;    VOID
;    )
;
; Routine Description:
;
;    This routine checks if the current TSS has IO MAP space.
;    if yes, it simply returns.  Otherwise, it switches to use
;    the regular TSS.
;
; Arguments:
;
;    None.
;
; Return value:
;
;    Return original TSS selector if the regular Tss is borrowed by us.
;
;--
cPublicProc _HalpBorrowTss, 0
cPublicFpo 0, 0

        xor     eax, eax
        str     ax
        mov     edx, PCR[PcGdt]
        add     edx, eax                        ; (edx)->Gdt Entry of current
                                                ;        TSS
        xor     ecx, ecx
        mov     cl, [edx].KgdtLimitHi
        shl     ecx, 16
        mov     cx, [edx].KgdtLimitLow          ; (ecx) = TSS limit
        cmp     ecx, 2000H                      ; Is Io map space available?
        ja      short Hbt99                     ; if a, yes, return

        sub     edx, eax                        ; (edx)->GDT table
        mov     ch, [edx+KGDT_TSS+KgdtBaseHi]
        mov     cl, [edx+KGDT_TSS+KgdtBaseMid]
        shl     ecx, 16
        mov     cx, [edx+KGDT_TSS+KgdtBaseLow]
        mov     PCR[PcTss], ecx
        mov     ecx, KGDT_TSS                   ; switch to use regular TSS
        mov     byte ptr [edx+KGDT_TSS+5], 089h ; 32bit, dpl=0, present, TSS32,
                                                ; not busy.
        ltr     cx
        stdRET  _HalpBorrowTss                  ; (eax) = Original TSS sel

Hbt99:
        xor     eax, eax                        ; No TSS swapped
        stdRET  _HalpBorrowTss

stdENDP _HalpBorrowTss


;++
; VOID
; HalpReturnTss (
;    ULONG TssSelector
;    )
;
; Routine Description:
;
;    This routine switches the current TSS from regular TSS back to
;    the panic TSS (NMI TSS or Double fault TSS).
;
; Arguments:
;
;    TssSelector - the TSS selector to return to.
;
; Return value:
;
;    None.
;
;--
cPublicProc _HalpReturnTss, 1
cPublicFpo 1, 0

        mov     edx, PCR[PcGdt]                 ; (edx)-> Gdt table
        mov     eax, [esp + 4]
        and     eax, 0FFFFh                     ; (eax)= New TSS sel
        add     edx, eax                        ; (edx)->Gdt Entry of new TSS

        mov     ch, [edx+KgdtBaseHi]
        mov     cl, [edx+KgdtBaseMid]
        shl     ecx, 16
        mov     cx, [edx+KgdtBaseLow]
        mov     PCR[PcTss], ecx
        mov     byte ptr [edx+5], 089h          ; 32bit, dpl=0, present, TSS32,
        ltr     ax
        stdRET  _HalpReturnTss                  ; return and clear stack

stdENDP _HalpReturnTss

;++
;
; VOID
; HalpBiosCall
;     VOID
;     )
;
; Routine Description:
;
;     This routine completes the transition to real mode, calls BIOS, and
;     returns to protected mode.
;
; Arguments:
;
;     None.
;
; Return Value:
;
;     None.
;
;--
;;ALIGN 4096
cPublicProc _HalpBiosCall   ,0

        push    ebp
        mov     ebp, esp
        pushfd
        push    edi
        push    esi
        push    ebx
        push    ds
        push    es
        push    fs
        push    gs
        push    offset FLAT:HbcProtMode         ; address where we will start
                                                ; protected mode again once
                                                ; V86 has completed.
        mov     HalpSavedEsp, esp

        mov     eax, cr0                        ; make sure alignment
        and     eax, not CR0_AM                 ; checks are disabled
        mov     cr0, eax

;
; Create space for the V86 trap frame and update the ESP0 value in the TSS
; to use this space.  We will set this up just below our current stack pointer.
; The stuff we push on the stack after we set ESP0 is irrelevant once we
; make it to V86 mode, so it's ok to blast it.
;
        mov     esi, fs:PcTss                   ; (esi) -> TSS
        mov     eax, esp
        sub     eax, NPX_FRAME_LENGTH           ; skip FP save area
        mov     [esi]+TssEsp0, eax

        push    dword ptr 0h                    ; V86 GS
        push    dword ptr 0h                    ; V86 FS
        push    dword ptr 0h                    ; V86 DS
        push    dword ptr 0h                    ; V86 ES
        push    dword ptr 2000h                 ; V86 SS

;
; We calculate the V86 sp by adding the difference between the linear address
; of the V86 ip (HbcReal) and the linear address of the V86 sp (HbcV86Stack)
; to the offset of the V86 ip (HbcReal & 0xfff).
;

        mov     eax, offset FLAT:HbcV86Stack-4
        sub     eax, offset FLAT:HbcReal
        mov     edx, offset HbcReal        
        and     edx, 0fffh
        add     eax, edx
        push    eax                              ; V86 esp

        pushfd
        or      dword ptr [esp], EFLAGS_V86_MASK; V86 eflags
        or      [esp], 03000h                   ; Give IOPL3
        push    dword ptr 2000h                 ; V86 CS
        mov     eax, offset HbcReal
        and     eax, 0fffh

        push    edx                             ; V86-mode EIP is offset
                                                ; into CS.
        iretd

_HalpRealModeStart      label   byte

HbcReal:
        db      OVERRIDE        ; make mov 32-bits
        mov     eax, 12h        ; 640x480x16 colors
        int     10h

        db      0c4h, 0c4h      ; BOP to indicate V86 mode is done.

;
; V86-mode stack
;
align 4
        db      2048 dup(0)
HbcV86Stack:

_HalpRealModeEnd        label   byte

HbcProtMode:
;
; We are back from V86 mode, so restore everything we saved and we are done.
;
        pop     gs
        pop     fs
        pop     es
        pop     ds
        pop     ebx
        pop     esi
        pop     edi
        popfd
        pop     ebp
        stdRET    _HalpBiosCall

        public  _HalpBiosCallEnd
_HalpBiosCallEnd label byte



_HalpBiosCall   endp


        subttl "HAL General Protection Fault"
;++
;
; Routine Description:
;
;    Handle General protection fault.
;
;    This fault handler is used by the HAL for V86 mode faults only.
;    It should NEVER be used except when running in V86 mode.  The HAL
;    replaces the general-purpose KiTrap0D handler entry in the IDT with
;    this routine.  This allows us to emulate V86-mode instructions which
;    cause a fault.  After we return from V86 mode, we can restore the
;    KiTrap0D handler in the IDT.
;
; Arguments:
;
;    At entry, the saved CS:EIP point to the faulting instruction
;    Error code (whose value depends on detected condition) is provided.
;
; Return value:
;
;    None
;
;--
        ASSUME  DS:FLAT, SS:NOTHING, ES:FLAT

        ENTER_DR_ASSIST Htd_a, Htd_t, NoAbiosAssist
cPublicProc _HalpTrap0D     ,0

        ENTER_TRAP Htd_a, Htd_t

;
;   Did the trap occur in V86 mode?  If not, something is completely messed up.
;
        test    dword ptr [ebp]+TsEFlags,00020000H
        jnz     Ht0d10

;
; The trap was not from V86 mode, so something is very wrong.  We cannot
; BugCheck, since we are probably already in a BugCheck.  So just stop.
;

if DBG
_TEXT segment
MsgBadHalTrap   db 'HAL: Trap0D while not in V86 mode',0ah,0dh,0
_TEXT ends

        push    offset FLAT:MsgBadHalTrap
        call    _DbgPrint
        add     esp,4
        stdCall   _DbgBreakPoint
endif
;
; We can't bugcheck, so just commit suicide.  Maybe we should reboot?
;
        jmp     $

Ht0d10:
        stdCall   HalpDispatchV86Opcode
        SPURIOUS_INTERRUPT_EXIT
stdENDP _HalpTrap0d

        subttl "HAL Invalid Opcode Fault"
;++
;
; Routine Description:
;
;    Handle invalid opcode fault
;
;    This fault handler is used by the HAL to indicate when V86 mode
;    execution is finished.  The V86 code attempts to execute an invalid
;    instruction (BOP) when it is done, and that brings us here.
;    This routine just removes the trap frame from the stack and does
;    a RET.  Note that this assumes that ESP0 in the TSS has been set
;    up to point to the top of the stack that we want to be running on
;    when the V86 call has completed.
;
;    This should NEVER be used except when running in V86 mode.  The HAL
;    replaces the general-purpose KiTrap06 handler entry in the IDT with
;    this routine.  It also sets up ESP0 in the TSS appropriately.  After
;    the V86 call has completed, it restores these to their previous values.
;
; Arguments:
;
;    At entry, the saved CS:EIP point to the faulting instruction
;    Error code (whose value depends on detected condition) is provided.
;
; Return value:
;
;    None
;
;--
        ASSUME  DS:FLAT, SS:NOTHING, ES:FLAT

cPublicProc _HalpTrap06     ,0
        mov     eax,KGDT_R3_DATA OR RPL_MASK
        mov     ds,ax
        mov     es,ax
        mov     esp, HalpSavedEsp
        ret

stdENDP _HalpTrap06

        subttl "Instruction Emulation Dispatcher"
;++
;
;   Routine Description:
;
;       This routine dispatches to the opcode specific emulation routine,
;       based on the first byte of the opcode.  Two byte opcodes, and prefixes
;       result in another level of dispatching, from the handling routine.
;
;       This code blatantly stolen from ke\i386\instemul.asm
;
;   Arguments:
;
;       ebp = pointer to trap frame
;
;   Returns:
;
;       Nothing
;

cPublicProc HalpDispatchV86Opcode ,0

RI      equ     [ebp - REGINFOSIZE]
        push    ebp
        mov     ebp,esp
        sub     esp,REGINFOSIZE
        push    esi
        push    edi

        ; Initialize RegInfo

        mov     esi,[ebp]
        mov     RI.RiTrapFrame,esi
        movzx   eax,word ptr [esi].TsHardwareSegSs
        mov     RI.RiSegSs,eax
        mov     eax,[esi].TsHardwareEsp
        mov     RI.RiEsp,eax
        mov     eax,[esi].TsEFlags
        mov     RI.RiEFlags,eax
        movzx   eax,word ptr [esi].TsSegCs
        mov     RI.RiSegCs,eax
        mov     eax,[esi].TsEip
        mov     RI.RiEip,eax

        xor     eax,eax
        mov     RI.RiPrefixFlags,eax
        lea     esi,RI

;
; Convert CS to a linear address
;

        mov     eax,[esi].RiSegCs
        shl     eax,4
        mov     [esi].RiCsBase,eax
        mov     [esi].RiCsLimit,0FFFFh
        mov     [esi].RiCsFlags,0

        mov     edi,RI.RiEip
        cmp     edi,RI.RiCsLimit
        ja      doerr

        add     edi,RI.RiCsBase
        mov     dl, [edi]                               ; get faulting opcode
        cmp     dl, INT_NN_OPCODE
        je      short @f

        stdCall HalpOpcodeInvalid
        jmp     short doerr

@@:
        stdCall HalpOpcodeINTnn
        test    eax,0FFFFh
        jz      do20

        mov     edi,RI.RiTrapFrame
        mov     eax,RI.RiEip                            ; advance eip
        mov     [edi].TsEip,eax
        mov     eax,1
do20:   pop     edi
        pop     esi
        mov     esp,ebp
        pop     ebp
        ret

doerr:  xor     eax,eax
        jmp     do20
stdENDP HalpDispatchV86Opcode

        page   ,132
        subttl "Invalid Opcode Handler"
;++
;
;   Routine Description:
;
;       This routine handles invalid opcodes.  It prints the invalid
;       opcode message, and breaks into the kernel debugger.
;
;   Arguments:
;
;       esi = address of reg info
;       edx = opcode
;
;   Returns:
;
;       nothing
;

_TEXT segment
HalpMsgInvalidOpcode db 'HAL: An invalid V86 opcode was encountered at '
                     db 'address %x:%x',0ah, 0dh, 0
_TEXT ends

cPublicProc HalpOpcodeInvalid ,0

        push    [esi].RiEip
        push    [esi].RiSegCs
        push    offset FLAT:HalpMsgInvalidOpcode
        call    _DbgPrint               ; display invalid opcode message
        add     esp,12
        int     3
        xor     eax,eax
        stdRET    HalpOpcodeInvalid

stdENDP HalpOpcodeInvalid

        subttl "INTnn Opcode Handler"
;++
;
;   Routine Description:
;
;       This routine emulates an INTnn opcode.  It retrieves the handler
;       from the IVT, pushes the current cs:ip and flags on the stack,
;       and dispatches to the handler.
;
;   Arguments:
;
;       esi = address of reg info
;       edx = opcode
;
;   Returns:
;
;       Current CS:IP on user stack
;       RiCs:RiEip -> handler from IVT
;

cPublicProc HalpOpcodeINTnn ,0

        push    ebp
        push    edi
        push    ebx

;
; Convert SS to linear address
;
        mov     eax,[esi].RiSegSs
        shl     eax,4
        mov     [esi].RiSsBase,eax
        mov     [esi].RiSsLimit,0FFFFh
        mov     [esi].RiSsFlags,0

        inc     [esi].RiEip                     ; point to int #
        mov     edi,[esi].RiEip
        cmp     edi,[esi].RiCsLimit
        ja      oinerr

        add     edi,[esi].RiCsBase
        movzx   ecx,byte ptr [edi]              ; get int #
        inc     [esi].RiEip                     ; inc past end of instruction
        stdCall   HalpPushInt
        test    eax,0FFFFh
        jz      oin20                           ; error!
;
;  Note:  Some sort of check for BOP should go here, or in push int.
;

        mov     ebp,[esi].RiTrapFrame
        mov     eax,[esi].RiSegSs
        mov     [ebp].TsHardwareSegSs,eax
        mov     eax,[esi].RiEsp
        mov     [ebp].TsHardwareEsp,eax
        mov     eax,[esi].RiSegCs
        mov     [ebp].TsSegCs,eax
        mov     eax,[esi].RiEFlags
        mov     [ebp].TsEFlags,eax
        mov     eax,1
oin20:  pop     ebx
        pop     edi
        pop     ebp
        stdRET    HalpOpcodeINTnn

oinerr: xor     eax,eax
        jmp     oin20

stdENDP HalpOpcodeINTnn

        page   ,132
        subttl "Push Interrupt frame on user stack"
;++
;
;   Routine Description:
;
;       This routine pushes an interrupt frame on the user stack
;
;   Arguments:
;
;       ecx = interrupt #
;       esi = address of reg info
;   Returns:
;
;       interrupt frame pushed on stack
;       reg info updated
;
cPublicProc HalpPushInt ,0
        push    ebx

        mov     edx,[esi].RiEsp
        mov     ebx,[esi].RiSsBase
        and     edx,0FFFFh              ; only use a 16 bit sp
        sub     dx,2
        mov     ax,word ptr [esi].RiEFlags
        mov     [ebx+edx],ax            ; push flags
        sub     dx,2
        mov     ax,word ptr [esi].RiSegCs
        mov     [ebx+edx],ax            ; push cs
        sub     dx,2
        mov     ax,word ptr [esi].RiEip
        mov     [ebx+edx],ax            ; push ip
        mov     eax,[ecx*4]             ; get new cs:ip value
        push    eax
        movzx   eax,ax
        mov     [esi].RiEip,eax
        pop     eax
        shr     eax,16
        mov     [esi].RiSegCs,eax
        mov     word ptr [esi].RiEsp,dx

;
; Convert CS to a linear address
;

        mov     eax,[esi].RiSegCs
        shl     eax,4
        mov     [esi].RiCsBase,eax
        mov     [esi].RiCsLimit,0FFFFh
        mov     [esi].RiCsFlags,0

        mov     eax,1                   ; success
pi80:   pop     ebx
        stdRET    HalpPushInt
stdENDP HalpPushInt


_TEXT   ends
        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halx86\i386\xxbiosc.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    xxbiosc.c

Abstract:

    This module implements the protect-mode routines necessary to make the
    transition to real mode and return to protected mode.

Author:

    John Vert (jvert) 29-Oct-1991


Environment:

    Kernel mode only.
    Probably a panic-stop, so we cannot use any system services.

Revision History:

--*/
#include "halp.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, HalpGetDisplayBiosInformation)
#endif // ALLOC_PRAGMA

//
// The IOPM should be mostly 0xff.  However it is possible a few
// bits may be cleared.  Build a table of what's not 0xff.
//

#define MAX_DIFFERENCES 0x20

typedef struct _IOPM_DIFF_ENTRY
{
    USHORT Entry;
    USHORT Value;
} IOPM_DIFF_ENTRY, *PIOPM_DIFF_ENTRY;

//
// Function definitions
//


ULONG
HalpBorrowTss(
    VOID
    );

VOID
HalpReturnTss(
    ULONG TssSelector
    );

VOID
HalpBiosCall(
    VOID
    );


VOID
HalpTrap06(
    VOID
    );


VOID
HalpTrap0D(
    VOID
    );


ULONG
HalpStoreAndClearIopm(
    PVOID Iopm,
    PIOPM_DIFF_ENTRY IopmDiffTable,
    ULONG MaxIopmTableEntries
    )

/*++

Routine Description:

    The primary function of this routine is to clear all the bits in the
    IOPM.  However, we will need to recover any of our changes later.

    It is very likely that the IOPM will be all 0xff's.  If there are
    deviations from this, they should be minimal.  So lets only store what's
    different.

Arguments:

    Iopm - Pointer to the IOPM to clear.

    IopmDiffTable - Pointer to the table of IOPM deviations from 0xff.

    MaxIopmTableEntries - The maximum number of entries in our table.

Returns:

    Number of entries added to the table.

--*/

{
    PUSHORT IoMap = Iopm;
    ULONG   IopmDiffTableEntries = 0;
    ULONG   i;

    for (i=0; i<(IOPM_SIZE / 2); i++) {

        if (*IoMap != 0xffff) {
            if (IopmDiffTableEntries < MaxIopmTableEntries) {
                IopmDiffTable[IopmDiffTableEntries].Entry = (USHORT) i;
                IopmDiffTable[IopmDiffTableEntries].Value = *IoMap;
                IopmDiffTableEntries++;
            } else {
                ASSERT(IopmDiffTableEntries < MaxIopmTableEntries);
            }
        }
        *IoMap++ = 0;
    }

    //
    // The end of the IOPM table must be followed by a string of FF's.
    //

    while (i < (PIOPM_SIZE / 2)) {
        *IoMap++ = 0xffff;
        i++;
    }

    return IopmDiffTableEntries;
}


VOID
HalpRestoreIopm(
    PVOID Iopm,
    PIOPM_DIFF_ENTRY IopmDiffTable,
    ULONG IopmTableEntries
    )

/*++

Routine Description:

    We expect that most IOPM's will be all FF's.  So we'll reset to that
    state, and then we'll apply any changes from our differences table.

Arguments:

    Iopm - Pointer to the IOPM to restore.

    IopmDiffTable - Pointer to the table of IOPM deviations from 0xff.

    IopmTableEntries - The number of entries in our table.

Returns:

    none

--*/

{
    PUSHORT IoMap = Iopm;

    memset(Iopm, 0xff, PIOPM_SIZE);

    while (IopmTableEntries--) {
        IoMap[IopmDiffTable[IopmTableEntries].Entry] =
            IopmDiffTable[IopmTableEntries].Value;
    }
}


BOOLEAN
HalpBiosDisplayReset(
    VOID
    )

/*++

Routine Description:

    Calls BIOS by putting the machine into V86 mode.  This involves setting up
    a physical==virtual identity mapping for the first 1Mb of memory, setting
    up V86-specific trap handlers, and granting I/O privilege to the V86
    process by editing the IOPM bitmap in the TSS.

Environment:

    Interrupts disabled.

Arguments:

    None

Return Value:

    Always returns TRUE

--*/

{
    HARDWARE_PTE OldPageTable;
    HARDWARE_PTE_X86PAE OldPageTablePae;
    ULONGLONG OldPageTablePfn;

    USHORT OldIoMapBase;
    ULONG OldEsp0;
    PHARDWARE_PTE Pte;
    PHARDWARE_PTE V86CodePte;
    ULONG OldTrap0DHandler;
    ULONG OldTrap06Handler;
    PUCHAR IoMap;
    ULONG Virtual;
    KIRQL OldIrql;
    ULONG OriginalTssSelector;
    extern PVOID HalpRealModeStart;
    extern PVOID HalpRealModeEnd;
    extern volatile ULONG  HalpNMIInProgress;
    PHARDWARE_PTE PointerPde;
    PHARDWARE_PTE IdtPte;
    ULONG   OldIdtWrite;
    ULONG   PageFrame;
    ULONG   PageFrameEnd;
    PKPCR   Pcr;
    IOPM_DIFF_ENTRY IopmDiffTable[MAX_DIFFERENCES];
    ULONG   IopmDiffTableEntries;

    //
    // Interrupts are off, but V86 mode might turn them back on again.
    //
    OldIrql = HalpDisableAllInterrupts ();
    Pcr = KeGetPcr();

    //
    // We need to set up an identity mapping in the first page table.  First,
    // we save away the old page table.
    //

    PointerPde = MiGetPdeAddress((PVOID)0);
    OldPageTablePfn = HalpGetPageFrameNumber( PointerPde );

    if (HalPaeEnabled() != FALSE) {

        OldPageTablePae = *(PHARDWARE_PTE_X86PAE)PointerPde;
        ((PHARDWARE_PTE_X86PAE)PointerPde)->reserved1 = 0;

    } else {

        OldPageTable = *PointerPde;

    }

    //
    // Now we put the HAL page table into the first slot of the page
    // directory.  Note that this page table is now the first and last
    // entries in the page directory.
    //

    Pte = MiGetPdeAddress((PVOID)0);

    HalpCopyPageFrameNumber( Pte,
                             MiGetPdeAddress( MM_HAL_RESERVED ));
    
    Pte->Valid = 1;
    Pte->Write = 1;
    Pte->Owner = 1;         // User-accessible
    Pte->LargePage = 0;

    //
    // Flush TLB
    //

    HalpFlushTLB();

    //
    // Map the first 1Mb of virtual memory to the first 1Mb of physical
    // memory
    //
    for (Virtual=0; Virtual < 0x100000; Virtual += PAGE_SIZE) {
        Pte = MiGetPteAddress((PVOID)Virtual);
        HalpSetPageFrameNumber( Pte, Virtual >> PAGE_SHIFT );
        Pte->Valid = 1;
        Pte->Write = 1;
        Pte->Owner = 1;         // User-accessible
    }

    //
    // Map our code into the virtual machine
    //

    Pte = MiGetPteAddress((PVOID)0x20000);
    PointerPde = MiGetPdeAddress(&HalpRealModeStart);

    if ( PointerPde->LargePage ) {

        //
        // Map real mode PTEs into virtual mapping.  The source PDE is
        // from the indenity large pte map, so map the virtual machine PTEs
        // based on the base of the large PDE frame.
        //

        PageFrame = MiGetPteIndex( &HalpRealModeStart );
        PageFrameEnd = MiGetPteIndex( &HalpRealModeEnd );
        do {

            HalpSetPageFrameNumber( Pte,
                                    HalpGetPageFrameNumber( PointerPde ) +
                                        PageFrame );

            HalpIncrementPte( &Pte );
            ++PageFrame;

        } while (PageFrame <= PageFrameEnd);

    } else {

        //
        // Map real mode PTEs into virtual machine PTEs, by copying the
        // page frames from the source to the virtual machine PTEs.
        //

        V86CodePte = MiGetPteAddress(&HalpRealModeStart);
        do {
            HalpCopyPageFrameNumber( Pte, V86CodePte );
            HalpIncrementPte( &Pte );
            HalpIncrementPte( &V86CodePte );
    
        } while ( V86CodePte <= MiGetPteAddress(&HalpRealModeEnd) );

    }

    //
    // Verify the IDT is writable
    //

    Pte = MiGetPteAddress(Pcr->IDT);
    PointerPde = MiGetPdeAddress(Pcr->IDT);
    IdtPte = PointerPde->LargePage ? PointerPde : Pte;

    OldIdtWrite = (ULONG)IdtPte->Write;
    IdtPte->Write = 1;

    //
    // Flush TLB
    //

    HalpFlushTLB();

    //
    // We need to replace the current TRAP D handler with our own, so
    // we can do instruction emulation for V86 mode
    //

    OldTrap0DHandler = KiReturnHandlerAddressFromIDT(0xd);
    KiSetHandlerAddressToIDT(0xd, HalpTrap0D);

    OldTrap06Handler = KiReturnHandlerAddressFromIDT(6);
    KiSetHandlerAddressToIDT(6, HalpTrap06);

    //
    // Make sure current TSS has IoMap space available.  If no, borrow
    // Normal TSS.
    //

    OriginalTssSelector = HalpBorrowTss();

    //
    // Overwrite the first access map with zeroes, so the V86 code can
    // party on all the registers.
    //
    IoMap = (PUCHAR)&(Pcr->TSS->IoMaps[0].IoMap);

    IopmDiffTableEntries =
        HalpStoreAndClearIopm(IoMap, IopmDiffTable, MAX_DIFFERENCES);

    OldIoMapBase = Pcr->TSS->IoMapBase;

    Pcr->TSS->IoMapBase = KiComputeIopmOffset(1);

    //
    // Save the current ESP0, as HalpBiosCall() trashes it.
    //
    OldEsp0 = Pcr->TSS->Esp0;

    //
    // Call the V86-mode code
    //
    HalpBiosCall();

    //
    // Restore the TRAP handlers
    //


    if ((HalpNMIInProgress == FALSE) ||
        ((*((PBOOLEAN)(*(PLONG)&KdDebuggerNotPresent)) == FALSE) &&
        (**((PUCHAR *)&KdDebuggerEnabled) != FALSE))) {

      // If we are here due to an NMI, the IRET performed in HalpBiosCall() 
      // allows a second NMI to occur.  The second NMI causes a trap 0d because
      // the NMI TSS is busy and proceeds to bugcheck which trashes the screen. 
      // Thus in this case we leave this trap 0d handler in place which will then
      // just spin on a jump to self if a second NMI occurs.

      KiSetHandlerAddressToIDT(0xd, OldTrap0DHandler);
    }

    KiSetHandlerAddressToIDT(6, OldTrap06Handler);
    IdtPte->Write = OldIdtWrite;

    //
    // Restore Esp0 value
    //
    Pcr->TSS->Esp0 = OldEsp0;

    //
    // Restore the IoMap to its previous state.
    //

    HalpRestoreIopm(IoMap, IopmDiffTable, IopmDiffTableEntries);

    Pcr->TSS->IoMapBase = OldIoMapBase;

    //
    // Return borrowed TSS if any.
    //

    if (OriginalTssSelector != 0) {
        HalpReturnTss(OriginalTssSelector);
    }

    //
    // Unmap the first 1Mb of virtual memory
    //
    for (Virtual = 0; Virtual < 0x100000; Virtual += PAGE_SIZE) {
        Pte = MiGetPteAddress((PVOID)Virtual);
        Pte->Valid = 0;
        Pte->Write = 0;
        HalpSetPageFrameNumber( Pte, 0 );
    }

    //
    // Restore the original page table that we replaced.
    //

    PointerPde = MiGetPdeAddress((PVOID)0);

    if (HalPaeEnabled() != FALSE) {

        *(PHARDWARE_PTE_X86PAE)PointerPde = OldPageTablePae;

    } else {

        *PointerPde = OldPageTable;

    }

    HalpSetPageFrameNumber( PointerPde, OldPageTablePfn );

    //
    // Flush TLB
    //

    HalpFlushTLB();

    //
    // Re-enable Interrupts
    //

    HalpReenableInterrupts(OldIrql);
    
    return TRUE;
}

HAL_DISPLAY_BIOS_INFORMATION
HalpGetDisplayBiosInformation (
    VOID
    )
{
    // this hal uses native int-10

    return HalDisplayInt10Bios;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halx86\i386\xxhal.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    xxhal.c

Abstract:


    This module implements the initialization of the system dependent
    functions that define the Hardware Architecture Layer (HAL) for an
    x86 system.

Author:

    David N. Cutler (davec) 25-Apr-1991

Environment:

    Kernel mode only.

Revision History:

--*/

#include "halp.h"

ULONG HalpBusType;

extern ADDRESS_USAGE HalpDefaultPcIoSpace;
extern ADDRESS_USAGE HalpEisaIoSpace;
extern UCHAR         HalpSzPciLock[];
extern UCHAR         HalpSzBreak[];
extern BOOLEAN       HalpPciLockSettings;
extern UCHAR         HalpAuthenticAMD[];
extern UCHAR         HalpGenuineIntel[];

extern PULONG KiEnableTimerWatchdog;
extern ULONG HalpTimerWatchdogEnabled;
extern PCHAR HalpTimerWatchdogStorage;
extern PVOID HalpTimerWatchdogCurFrame;
extern PVOID HalpTimerWatchdogLastFrame;
extern ULONG HalpTimerWatchdogStorageOverflow;

extern KSPIN_LOCK HalpDmaAdapterListLock;
extern LIST_ENTRY HalpDmaAdapterList;

#ifdef ACPI_HAL
extern KEVENT   HalpNewAdapter;
#endif


VOID
HalpGetParameters (
    IN PLOADER_PARAMETER_BLOCK LoaderBlock
    );

ULONG
HalpGetFeatureBits (
    VOID
    );

VOID
HalpInitReservedPages(
    VOID
    );

VOID
HalpAcpiTimerPerfCountHack(
    VOID
    );

#ifndef NT_UP
ULONG
HalpInitMP(
    IN ULONG Phase,
    IN PLOADER_PARAMETER_BLOCK LoaderBlock
    );
#endif


KSPIN_LOCK HalpSystemHardwareLock;

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT,HalpGetParameters)
#pragma alloc_text(INIT,HalInitSystem)
#endif


VOID
HalpGetParameters (
    IN PLOADER_PARAMETER_BLOCK LoaderBlock
    )
/*++

Routine Description:

    This gets any parameters from the boot.ini invocation line.

Arguments:

    None.

Return Value:

    None

--*/
{
    PCHAR       Options;

    if (LoaderBlock != NULL  &&  LoaderBlock->LoadOptions != NULL) {
        Options = LoaderBlock->LoadOptions;

        //
        // Check if PCI settings are locked down
        //

        if (strstr(Options, HalpSzPciLock)) {
            HalpPciLockSettings = TRUE;
        }

        //
        //  Has the user asked for an initial BreakPoint?
        //

        if (strstr(Options, HalpSzBreak)) {
            DbgBreakPoint();
        }
    }

    return;
}


VOID
HalpInitTimerWatchdog(
    IN ULONG Phase
    )
/*++

Routine Description:

    Determines if the system is running on a GenuineIntel part and initializes
    HalpTimerWatchdogEnabled accordingly.

Arguments:

    None.

Return Value:

    None.

--*/
{
    if (Phase == 0) {
        ULONG   GenuinePentiumOrLater = FALSE, Junk;
        PKPRCB  Prcb;

        Prcb = KeGetCurrentPrcb();

        if (Prcb->CpuID) {
            UCHAR Buffer[50];

            //
            // Determine the processor type
            //

            HalpCpuID (0, &Junk, (PULONG) Buffer+0, (PULONG) Buffer+2, (PULONG) Buffer+1);
            Buffer[12] = 0;

            GenuinePentiumOrLater =
                ((strcmp(Buffer, HalpGenuineIntel) == 0) && (Prcb->CpuType >= 5));

            HalpTimerWatchdogEnabled = GenuinePentiumOrLater;
        }
    } else if (HalpTimerWatchdogEnabled) {
        //
        // Allocate 2 pages for stack snapshots, each snapshot is 64 DWORDs.
        //
        if (HalpTimerWatchdogStorage =
                ExAllocatePoolWithTag( NonPagedPool, PAGE_SIZE * 2, HAL_POOL_TAG )) {
            HalpTimerWatchdogLastFrame =
                HalpTimerWatchdogStorage + (PAGE_SIZE * 2 - 64*4);
            HalpTimerWatchdogStorageOverflow = 0;
            HalpTimerWatchdogCurFrame = HalpTimerWatchdogStorage;
        } else {
            HalpTimerWatchdogEnabled = FALSE;
        }
    }
}


BOOLEAN
HalInitSystem (
    IN ULONG Phase,
    IN PLOADER_PARAMETER_BLOCK LoaderBlock
    )


/*++

Routine Description:

    This function initializes the Hardware Architecture Layer (HAL) for an
    x86 system.

Arguments:

    None.

Return Value:

    A value of TRUE is returned is the initialization was successfully
    complete. Otherwise a value of FALSE is returend.

--*/

{
    PMEMORY_ALLOCATION_DESCRIPTOR Descriptor;
    PLIST_ENTRY NextMd;
    KIRQL CurrentIrql;
    PKPRCB   pPRCB;
    ULONG mapBufferSize;
    ULONG mapBufferAddress;

    pPRCB = KeGetCurrentPrcb();

    if (Phase == 0) {

        HalpBusType = LoaderBlock->u.I386.MachineType & 0x00ff;
        HalpGetParameters (LoaderBlock);

        //
        // Verify Prcb version and build flags conform to
        // this image
        //

#if DBG
        if (!(pPRCB->BuildType & PRCB_BUILD_DEBUG)) {
            // This checked hal requires a checked kernel
            KeBugCheckEx (MISMATCHED_HAL,
                2, pPRCB->BuildType, PRCB_BUILD_DEBUG, 0);
        }
#else
        if (pPRCB->BuildType & PRCB_BUILD_DEBUG) {
            // This free hal requires a free kernel
            KeBugCheckEx (MISMATCHED_HAL, 2, pPRCB->BuildType, 0, 0);
        }
#endif
#ifndef NT_UP
        if (pPRCB->BuildType & PRCB_BUILD_UNIPROCESSOR) {
            // This MP hal requires an MP kernel
            KeBugCheckEx (MISMATCHED_HAL, 2, pPRCB->BuildType, 0, 0);
        }
#endif
        if (pPRCB->MajorVersion != PRCB_MAJOR_VERSION) {
            KeBugCheckEx (MISMATCHED_HAL,
                1, pPRCB->MajorVersion, PRCB_MAJOR_VERSION, 0);
        }

        //
        // Phase 0 initialization
        // only called by P0
        //

        //
        // Check to make sure the MCA HAL is not running on an ISA/EISA
        // system, and vice-versa.
        //
#if MCA
        if (HalpBusType != MACHINE_TYPE_MCA) {
            KeBugCheckEx (MISMATCHED_HAL,
                3, HalpBusType, MACHINE_TYPE_MCA, 0);
        }
#else
        if (HalpBusType == MACHINE_TYPE_MCA) {
            KeBugCheckEx (MISMATCHED_HAL,
                3, HalpBusType, 0, 0);
        }
#endif

#ifdef ACPI_HAL
        //
        // Make sure that this is really an ACPI machine and initialize
        // the ACPI structures.
        //
        HalpSetupAcpiPhase0(LoaderBlock);
#endif

        HalpInitializePICs(TRUE);

        //
        // Now that the PICs are initialized, we need to mask them to
        // reflect the current Irql
        //

        CurrentIrql = KeGetCurrentIrql();
        CurrentIrql = KfRaiseIrql(CurrentIrql);

        //
        // Initialize CMOS
        //

        HalpInitializeCmos();

        //
        // Fill in handlers for APIs which this hal supports
        //

        HalQuerySystemInformation = HaliQuerySystemInformation;
        HalSetSystemInformation = HaliSetSystemInformation;
        HalInitPnpDriver = HaliInitPnpDriver;
        HalGetDmaAdapter = HaliGetDmaAdapter;
        HalHaltSystem = HaliHaltSystem;
        HalResetDisplay = HalpBiosDisplayReset;
        HalAllocateMapRegisters = HalpAllocateMapRegisters;

#if !defined( HAL_SP )
#ifdef ACPI_HAL
        HalGetInterruptTranslator = HalacpiGetInterruptTranslator;
#else
        HalGetInterruptTranslator = HaliGetInterruptTranslator;
#endif
#endif

#if !defined( HAL_SP ) && !(MCA)
        HalInitPowerManagement = HaliInitPowerManagement;
        HalLocateHiberRanges = HaliLocateHiberRanges;
#endif


        //
        // Register cascade vector
        //

        HalpRegisterVector (
            InternalUsage,
            PIC_SLAVE_IRQ + PRIMARY_VECTOR_BASE,
            PIC_SLAVE_IRQ + PRIMARY_VECTOR_BASE,
            HIGH_LEVEL );

        //
        // Keep track of which IRQs are level triggered.
        //
        if (HalpBusType == MACHINE_TYPE_EISA) {
            HalpRecordEisaInterruptVectors();
        }

        //
        // Register base IO space used by hal
        //

        HalpRegisterAddressUsage (&HalpDefaultPcIoSpace);
        
        if (HalpBusType == MACHINE_TYPE_EISA) {
            HalpRegisterAddressUsage (&HalpEisaIoSpace);
        }

        //
        // Note that HalpInitializeClock MUST be called after
        // HalpInitializeStallExecution, because HalpInitializeStallExecution
        // reprograms the timer.
        //

        HalpInitializeStallExecution(0);

        //
        // Init timer watchdog if enabled.
        //

        HalpInitTimerWatchdog(Phase);

        //
        // Setup the clock
        //

        HalpInitializeClock();

        //
        // Make sure profile is disabled
        //

        HalStopProfileInterrupt(0);

        //
        // Remove this for the sake of the graphical boot driver.  There is
        // no negative effect of this.  If the display isn't initialized, it
        // will be initialized during HalDisplayString.
        //
        // HalpInitializeDisplay();

        //
        // Initialize spinlock used by HalGetBusData hardware access routines
        //

        KeInitializeSpinLock(&HalpSystemHardwareLock);

        //
        // Initialize data structures used to chain dma adapters
        // together for debugging purposes
        //
        KeInitializeSpinLock(&HalpDmaAdapterListLock);
        InitializeListHead(&HalpDmaAdapterList);

#ifdef ACPI_HAL
        //
        // Initialize synchronzation event used to serialize
        // new adapter events on the ACPI HAL (which has no notion of bus
        // handlers)
        //

        KeInitializeEvent (&HalpNewAdapter, SynchronizationEvent, TRUE);
#endif
        //
        // Determine if there is physical memory above 16 MB.
        //

        LessThan16Mb = TRUE;

        NextMd = LoaderBlock->MemoryDescriptorListHead.Flink;

        while (NextMd != &LoaderBlock->MemoryDescriptorListHead) {
            Descriptor = CONTAINING_RECORD( NextMd,
                                            MEMORY_ALLOCATION_DESCRIPTOR,
                                            ListEntry );

            if (Descriptor->MemoryType != LoaderFirmwarePermanent &&
                Descriptor->MemoryType != LoaderSpecialMemory  &&
                Descriptor->BasePage + Descriptor->PageCount > 0x1000) {
                LessThan16Mb = FALSE;
                break;
            }

            NextMd = Descriptor->ListEntry.Flink;
        }

#if !defined(_HALPAE_)

        HalpMapBufferSize = INITIAL_MAP_BUFFER_SMALL_SIZE;

        //
        // Allocate map buffers for the adapter objects
        //

        HalpMapBufferPhysicalAddress.LowPart =
            HalpAllocPhysicalMemory (LoaderBlock, MAXIMUM_PHYSICAL_ADDRESS,
                HalpMapBufferSize >> PAGE_SHIFT, TRUE);
        HalpMapBufferPhysicalAddress.HighPart = 0;


        if (!HalpMapBufferPhysicalAddress.LowPart) {

            //
            // There was not a satisfactory block.  Clear the allocation.
            //

            HalpMapBufferSize = 0;
        }

#else

        //
        // Initialize and allocate map buffers for the 24bit master adapter
        // object.
        //

        MasterAdapter24.MaxBufferPages =
            MAXIMUM_ISA_MAP_BUFFER_SIZE / PAGE_SIZE;

        mapBufferSize = INITIAL_MAP_BUFFER_SMALL_SIZE;
        mapBufferAddress =
            HalpAllocPhysicalMemory (LoaderBlock,
                                     MAXIMUM_PHYSICAL_ADDRESS,
                                     mapBufferSize >> PAGE_SHIFT,
                                     TRUE);

        if (mapBufferAddress == 0) {
            mapBufferSize = 0;
        }

        MasterAdapter24.MapBufferPhysicalAddress.LowPart = mapBufferAddress;
        MasterAdapter24.MapBufferPhysicalAddress.HighPart = 0;
        MasterAdapter24.MapBufferSize = mapBufferSize;

        if (HalPaeEnabled() != FALSE) {

            //
            // Initialize and allocate map buffers for the 32bit master adapter
            // object.  This should only be needed on a PAE-enabled system.
            //

            MasterAdapter32.MaxBufferPages =
                MAXIMUM_PCI_MAP_BUFFER_SIZE / PAGE_SIZE;

            mapBufferSize = INITIAL_MAP_BUFFER_LARGE_SIZE;
            mapBufferAddress =
                HalpAllocPhysicalMemory (LoaderBlock,
                                         (ULONG)-1,
                                         mapBufferSize >> PAGE_SHIFT,
                                         TRUE);

            if (mapBufferAddress == 0) {
                mapBufferSize = 0;
            }

            MasterAdapter32.MapBufferPhysicalAddress.LowPart = mapBufferAddress;
            MasterAdapter32.MapBufferPhysicalAddress.HighPart = 0;
            MasterAdapter32.MapBufferSize = mapBufferSize;
        }

#endif

    } else {

        //
        // Phase 1 initialization
        //

        if (pPRCB->Number == 0) {

            //
            // Back-pocket some PTEs for DMA during low mem
            //
            HalpInitReservedPages();

#ifndef ACPI_HAL
            //
            //  If P0, then setup global vectors
            //

            HalpRegisterInternalBusHandlers ();
#else
            HalpInitNonBusHandler();
#endif

            //
            // Set feature bits
            //

            HalpFeatureBits = HalpGetFeatureBits();

            //
            // Use movnti routine to copy memory if Movnti support is detected
            //

#if !defined(_WIN64)
            if (HalpFeatureBits & HAL_WNI_PRESENT) {
                HalpMoveMemory = HalpMovntiCopyBuffer;
            }
#endif

            //
            // Init timer watchdog if enabled (allocate stack snapshot buffer).
            //

            HalpInitTimerWatchdog(Phase);


            HalpEnableInterruptHandler (
                DeviceUsage | InterruptLatched, // Report as device vector
                V2I (CLOCK_VECTOR),             // Bus interrupt level
                CLOCK_VECTOR,                   // System IDT
                CLOCK2_LEVEL,                   // System Irql
                HalpClockInterrupt,             // ISR
                Latched );

            HalpEnableInterruptHandler (
                DeviceUsage | InterruptLatched, // Report as device vector
                V2I (PROFILE_VECTOR),           // Bus interrupt level
                PROFILE_VECTOR,                 // System IDT
                PROFILE_LEVEL,                  // System Irql
                HalpProfileInterrupt,           // ISR
                Latched );


#ifdef ACPI_HAL
#if !defined(_WIN64)

            //
            // Perf counter patch for non-compliant ACPI machines
            //
            HalpAcpiTimerPerfCountHack();

#endif
#endif

#if !defined(_WIN64)

            //
            // If 486, the FP error will be routed via trap10.  So we
            // don't enable irq13.  Otherwise (CPU=386), we will enable irq13
            // to handle FP error.
            //

            if (pPRCB->CpuType == 3) {
                HalpEnableInterruptHandler (
                    DeviceUsage,                // Report as device vector
                    V2I (I386_80387_VECTOR),    // Bus interrupt level
                    I386_80387_VECTOR,          // System IDT
                    I386_80387_IRQL,            // System Irql
                    HalpIrq13Handler,           // ISR
                    Latched );
            }
#endif
        }
    }

#ifndef NT_UP
    HalpInitMP (Phase, LoaderBlock);
#endif

    return TRUE;
}

ULONG
HalpGetFeatureBits (
    VOID
    )
{
    UCHAR   Buffer[50];
    ULONG   Junk, ProcessorFeatures, Bits;
    PKPRCB  Prcb;
    ULONGLONG ApicBits;

    Bits = 0;

    Prcb = KeGetCurrentPrcb();

    if (!Prcb->CpuID) {
        Bits |= HAL_NO_SPECULATION;
        return Bits;
    }

    //
    // Determine the processor type
    //

    HalpCpuID (0, &Junk, (PULONG) Buffer+0, (PULONG) Buffer+2, (PULONG) Buffer+1);
    Buffer[12] = 0;

    HalpCpuID (1, &Junk, &Junk, &Junk, &ProcessorFeatures);

    //
    // Determine which features are present.
    //

    if (strcmp (Buffer, HalpGenuineIntel) == 0) {

        //
        // Check Intel feature bits for HAL features needed
        //

        if (Prcb->CpuType == 6) {

            Bits |= HAL_PERF_EVENTS;

            //
            // Workaround for Pentium Pro Local APIC trap 0x0F and trap 0x00
            // spurious interrupt errata 5AP and 6AP. Disable the Local APIC
            // on UP Pentium Pro Systems. Interrupts are routed directly from
            // 8259 PIC to CPU.
            //

            ApicBits = RDMSR(APIC_BASE_MSR);

            if (ApicBits & APIC_ENABLED) {

                //
                // Local APIC is enabled - Disable it.
                //

                WRMSR(APIC_BASE_MSR, (ApicBits & ~APIC_ENABLED));
            }
        }

        if (Prcb->CpuType < 6) {
            Bits |= HAL_NO_SPECULATION;
        }
    } else if (strcmp (Buffer, HalpAuthenticAMD) == 0) {

        ULONG ExtendedProcessorFeatures;
        ULONG MaxExtendedFunc;

        MaxExtendedFunc = 0;
        HalpCpuID (0x80000000, &MaxExtendedFunc, &Junk, &Junk, &Junk);

        if (MaxExtendedFunc >= 0x80000001) {
            HalpCpuID (0x80000001, &Junk, &Junk, &Junk, &ExtendedProcessorFeatures);
            if (ExtendedProcessorFeatures & CPUID_NX_MASK) {
                Bits |= HAL_NX_PRESENT;
            }
        }
    }

    if (ProcessorFeatures & CPUID_MCA_MASK) {
        Bits |= HAL_MCA_PRESENT;
    }

    if (ProcessorFeatures & CPUID_MCE_MASK) {
        Bits |= HAL_MCE_PRESENT;
    }

    if (ProcessorFeatures & CPUID_VME_MASK) {
        Bits |= HAL_CR4_PRESENT;
    }

    if (ProcessorFeatures & CPUID_WNI_MASK) {
        Bits |= HAL_WNI_PRESENT;
    }
    return Bits;
}

#if !defined(_WIN64)

BOOLEAN
HalpIsNXEnabled (
    VOID
    )

/*++

Routine Description:

    This function returns a boolean indicating whether the current processor
    has the no-execute bit set in the EFER MSR.

Arguments:

    None.

Return Value:

    A value of TRUE is returned indicates that the current processor has
    enabled NX mode, otherwise FALSE is returned.

--*/

{
    ULONGLONG msrValue;
    BOOLEAN result;

    result = FALSE;
    if ((HalpGetFeatureBits() & HAL_NX_PRESENT) != 0) {

        msrValue = RDMSR(0xc0000080);
        if ((msrValue & 0x800) != 0) {
            result = TRUE;
        }
    }

    return result;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halx86\i386\pcip.h ===
//
// Hal specific PCI bus structures
//
// Copyright (c) 1995-1999  Microsoft Corporation
//

typedef struct _TYPE2EXTRAS {
    USHORT  SubVendorID;
    USHORT  SubSystemID;
    ULONG   LegacyModeBaseAddress;
} TYPE2EXTRAS;

typedef NTSTATUS
(*PciIrqRange) (
    IN PBUS_HANDLER     BusHandler,
    IN PBUS_HANDLER     RootHandler,
    IN PCI_SLOT_NUMBER  PciSlot,
    OUT PSUPPORTED_RANGE *Interrupt
    );

typedef struct tagPCIPBUSDATA {

    //
    // Defined PCI data
    //

    PCIBUSDATA      CommonData;

    //
    // Implementation specific data
    //

    union {
        struct {
            PULONG  Address;
            ULONG   Data;
        } Type1;
        struct {
            PUCHAR  CSE;
            PUCHAR  Forward;
            ULONG   Base;
        } Type2;
    } Config;

    ULONG           MaxDevice;
    PciIrqRange     GetIrqRange;

    BOOLEAN         BridgeConfigRead;
    UCHAR           ParentBus;
    BOOLEAN         Subtractive;
    UCHAR           reserved[1];
    UCHAR           SwizzleIn[4];

    RTL_BITMAP      DeviceConfigured;
    ULONG           ConfiguredBits[PCI_MAX_DEVICES * PCI_MAX_FUNCTION / 32];

    USHORT          IrqMask;
} PCIPBUSDATA, *PPCIPBUSDATA;

#define PciBitIndex(Dev,Fnc)   (Fnc*32 + Dev);

#define PCI_CONFIG_TYPE(PciData)    ((PciData)->HeaderType & ~PCI_MULTIFUNCTION)

#define Is64BitBaseAddress(a)   \
            (((a & PCI_ADDRESS_IO_SPACE) == 0)  &&  \
             ((a & PCI_ADDRESS_MEMORY_TYPE_MASK) == PCI_TYPE_64BIT))


//
// Orion B0 errata workaround
//

struct {
    PBUS_HANDLER        Handler;
    PCI_SLOT_NUMBER     Slot;
} HalpOrionOPB;

typedef ULONG (*FncConfigIO) (
    IN PPCIPBUSDATA     BusData,
    IN PVOID            State,
    IN PUCHAR           Buffer,
    IN ULONG            Offset
    );

typedef VOID (*FncSync) (
    IN PBUS_HANDLER     BusHandler,
    IN PCI_SLOT_NUMBER  Slot,
    IN PKIRQL           Irql,
    IN PVOID            State
    );

typedef VOID (*FncReleaseSync) (
    IN PBUS_HANDLER     BusHandler,
    IN KIRQL            Irql
    );

typedef struct _PCI_CONFIG_HANDLER {
    FncSync         Synchronize;
    FncReleaseSync  ReleaseSynchronzation;
    FncConfigIO     ConfigRead[3];
    FncConfigIO     ConfigWrite[3];
} PCI_CONFIG_HANDLER, *PPCI_CONFIG_HANDLER;

extern KSPIN_LOCK HalpPCIConfigLock;
extern PCI_CONFIG_HANDLER PCIConfigHandler;
extern const PCI_CONFIG_HANDLER PCIConfigHandlerType1;
extern const PCI_CONFIG_HANDLER PCIConfigHandlerType2;

//
// Feature types (for PCI_CARD_DESCRIPTOR)
//
#define PCIFT_FULLDECODE_HOSTBRIDGE   0x00001

//
// Card flags (for PCI_CARD_DESCRIPTOR)
//
#define PCICF_CHECK_REVISIONID        0x10000
#define PCICF_CHECK_SSVID             0x20000
#define PCICF_CHECK_SSID              0x40000

//
// Description of a PCI card.
//
typedef struct _PCI_CARD_DESCRIPTOR {

    ULONG   Flags;
    USHORT  VendorID;
    USHORT  DeviceID;
    USHORT  RevisionID;
    USHORT  SubsystemVendorID;
    USHORT  SubsystemID;
    USHORT  Reserved;

} PCI_CARD_DESCRIPTOR;

//
// Superclass of PCI_REGISTRY_INFO
//
typedef struct _PCI_REGISTRY_INFO_INTERNAL {

    struct              _PCI_REGISTRY_INFO; // unnamed structure.
    ULONG               ElementCount;
    PCI_CARD_DESCRIPTOR CardList[]; // Zero entries.

} PCI_REGISTRY_INFO_INTERNAL, *PPCI_REGISTRY_INFO_INTERNAL;

//
// The venerable IRQXOR has got to go, as it now has to extend into
// the PCI driver.  And that would require the PCI driver to match
// the HAL in its checked/free nature.
//

//#if DBG
//#define IRQXOR 0x2B
//#else
#define IRQXOR 0
//#endif


//
// Prototypes for functions in ixpcibus.c
//

VOID
HalpInitializePciBus (
    VOID
    );

VOID
HalpInitializePciStubs (
    VOID
    );

PPCI_REGISTRY_INFO_INTERNAL
HalpQueryPciRegistryInfo (
    VOID
    );

BOOLEAN
HalpIsRecognizedCard(
    IN PPCI_REGISTRY_INFO_INTERNAL  PCIRegInfo,
    IN PPCI_COMMON_CONFIG           PciData,
    IN ULONG                        FeatureMask
    );

VOID
HalpReadPCIConfig (
    IN PBUS_HANDLER BusHandler,
    IN PCI_SLOT_NUMBER Slot,
    IN PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Length
    );


VOID
HalpWritePCIConfig (
    IN PBUS_HANDLER BusHandler,
    IN PCI_SLOT_NUMBER Slot,
    IN PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Length
    );

PBUS_HANDLER
HalpAllocateAndInitPciBusHandler (
    IN ULONG        HwType,
    IN ULONG        BusNo,
    IN BOOLEAN      TestAllocation
    );


BOOLEAN
HalpIsValidPCIDevice (
    IN PBUS_HANDLER  BusHandler,
    IN PCI_SLOT_NUMBER Slot
    );

BOOLEAN
HalpValidPCISlot (
    IN PBUS_HANDLER     BusHandler,
    IN PCI_SLOT_NUMBER Slot
    );

VOID HalpPCISynchronizeType1 (
    IN PBUS_HANDLER     BusHandler,
    IN PCI_SLOT_NUMBER  Slot,
    IN PKIRQL           Irql,
    IN PVOID            State
    );

VOID HalpPCIReleaseSynchronzationType1 (
    IN PBUS_HANDLER     BusHandler,
    IN KIRQL            Irql
    );

VOID
HalpPCISynchronizeOrionB0 (
    IN PBUS_HANDLER         BusHandler,
    IN PCI_SLOT_NUMBER      Slot,
    IN PKIRQL               Irql,
    IN PPCI_TYPE1_CFG_BITS  PciCfg1
    );

VOID
HalpPCIReleaseSynchronzationOrionB0 (
    IN PBUS_HANDLER     BusHandler,
    IN KIRQL            Irql
    );

ULONG HalpPCIReadUlongType1 (
    IN PPCIPBUSDATA     BusData,
    IN PVOID            State,
    IN PUCHAR           Buffer,
    IN ULONG            Offset
    );

ULONG HalpPCIReadUcharType1 (
    IN PPCIPBUSDATA     BusData,
    IN PVOID            State,
    IN PUCHAR           Buffer,
    IN ULONG            Offset
    );

ULONG HalpPCIReadUshortType1 (
    IN PPCIPBUSDATA     BusData,
    IN PVOID            State,
    IN PUCHAR           Buffer,
    IN ULONG            Offset
    );

ULONG HalpPCIWriteUlongType1 (
    IN PPCIPBUSDATA     BusData,
    IN PVOID            State,
    IN PUCHAR           Buffer,
    IN ULONG            Offset
    );

ULONG HalpPCIWriteUcharType1 (
    IN PPCIPBUSDATA     BusData,
    IN PVOID            State,
    IN PUCHAR           Buffer,
    IN ULONG            Offset
    );

ULONG HalpPCIWriteUshortType1 (
    IN PPCIPBUSDATA     BusData,
    IN PVOID            State,
    IN PUCHAR           Buffer,
    IN ULONG            Offset
    );

VOID HalpPCISynchronizeType2 (
    IN PBUS_HANDLER     BusHandler,
    IN PCI_SLOT_NUMBER  Slot,
    IN PKIRQL           Irql,
    IN PVOID            State
    );

VOID HalpPCIReleaseSynchronzationType2 (
    IN PBUS_HANDLER     BusHandler,
    IN KIRQL            Irql
    );

ULONG HalpPCIReadUlongType2 (
    IN PPCIPBUSDATA     BusData,
    IN PVOID            State,
    IN PUCHAR           Buffer,
    IN ULONG            Offset
    );

ULONG HalpPCIReadUcharType2 (
    IN PPCIPBUSDATA     BusData,
    IN PVOID            State,
    IN PUCHAR           Buffer,
    IN ULONG            Offset
    );

ULONG HalpPCIReadUshortType2 (
    IN PPCIPBUSDATA     BusData,
    IN PVOID            State,
    IN PUCHAR           Buffer,
    IN ULONG            Offset
    );

ULONG HalpPCIWriteUlongType2 (
    IN PPCIPBUSDATA     BusData,
    IN PVOID            State,
    IN PUCHAR           Buffer,
    IN ULONG            Offset
    );

ULONG HalpPCIWriteUcharType2 (
    IN PPCIPBUSDATA     BusData,
    IN PVOID            State,
    IN PUCHAR           Buffer,
    IN ULONG            Offset
    );

ULONG HalpPCIWriteUshortType2 (
    IN PPCIPBUSDATA     BusData,
    IN PVOID            State,
    IN PUCHAR           Buffer,
    IN ULONG            Offset
    );

ULONG
HalpGetPCIData (
    IN PBUS_HANDLER BusHandler,
    IN PBUS_HANDLER RootHandler,
    IN PCI_SLOT_NUMBER SlotNumber,
    IN PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Length
    );

ULONG
HalpSetPCIData (
    IN PBUS_HANDLER BusHandler,
    IN PBUS_HANDLER RootHandler,
    IN PCI_SLOT_NUMBER SlotNumber,
    IN PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Length
    );

NTSTATUS
HalpAssignPCISlotResources (
    IN PBUS_HANDLER BusHandler,
    IN PBUS_HANDLER RootHandler,
    IN PUNICODE_STRING          RegistryPath,
    IN PUNICODE_STRING          DriverClassName       OPTIONAL,
    IN PDRIVER_OBJECT           DriverObject,
    IN PDEVICE_OBJECT           DeviceObject          OPTIONAL,
    IN ULONG                    SlotNumber,
    IN OUT PCM_RESOURCE_LIST   *AllocatedResources
    );

//
// Prototypes for functions in ixpciint.c
//

ULONG
HalpGetPCIIntOnISABus (
    IN PBUS_HANDLER BusHandler,
    IN PBUS_HANDLER RootHandler,
    IN ULONG BusInterruptLevel,
    IN ULONG BusInterruptVector,
    OUT PKIRQL Irql,
    OUT PKAFFINITY Affinity
    );

VOID
HalpPCIAcquireType2Lock (
    PKSPIN_LOCK SpinLock,
    PKIRQL      Irql
    );

VOID
HalpPCIReleaseType2Lock (
    PKSPIN_LOCK SpinLock,
    KIRQL       Irql
    );

NTSTATUS
HalpAdjustPCIResourceList (
    IN PBUS_HANDLER BusHandler,
    IN PBUS_HANDLER RootHandler,
    IN OUT PIO_RESOURCE_REQUIREMENTS_LIST   *pResourceList
    );

VOID
HalpPCIPin2ISALine (
    IN PBUS_HANDLER         BusHandler,
    IN PBUS_HANDLER         RootHandler,
    IN PCI_SLOT_NUMBER      SlotNumber,
    IN PPCI_COMMON_CONFIG   PciData
    );

VOID
HalpPCIISALine2Pin (
    IN PBUS_HANDLER         BusHandler,
    IN PBUS_HANDLER         RootHandler,
    IN PCI_SLOT_NUMBER      SlotNumber,
    IN PPCI_COMMON_CONFIG   PciNewData,
    IN PPCI_COMMON_CONFIG   PciOldData
    );

NTSTATUS
HalpGetISAFixedPCIIrq (
    IN PBUS_HANDLER      BusHandler,
    IN PBUS_HANDLER      RootHandler,
    IN PCI_SLOT_NUMBER   PciSlot,
    OUT PSUPPORTED_RANGE  *Interrupt
    );

//
// Prototypes for functions in ixpcibrd.c
//

BOOLEAN
HalpGetPciBridgeConfig (
    IN ULONG            HwType,
    IN PUCHAR           MaxPciBus
    );

VOID
HalpFixupPciSupportedRanges (
    IN ULONG MaxBuses
    );

//
// Prototypes for functions in pmpcisup.c
//

ULONG
HaliPciInterfaceReadConfig(
    IN PVOID Context,
    IN UCHAR BusOffset,
    IN ULONG Slot,
    IN PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Length
    );

ULONG
HaliPciInterfaceWriteConfig(
    IN PVOID Context,
    IN UCHAR BusOffset,
    IN ULONG Slot,
    IN PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Length
    );

#if DBG
#define DBGMSG(a)   DbgPrint(a)
VOID
HalpTestPci (
    ULONG
    );
#else
#define DBGMSG(a)
#endif

#ifdef SUBCLASSPCI

VOID
HalpSubclassPCISupport (
    IN PBUS_HANDLER BusHandler,
    IN ULONG        HwType
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halx86\i386\xxdisp.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    xxdisp.c

Abstract:

    This module implements the HAL display initialization and output routines
    for a x86 system.

Author:

    David N. Cutler (davec) 27-Apr-1991

Environment:

    Kernel mode

Revision History:

--*/

#include "halp.h"
#include <inbv.h>

VOID
HalAcquireDisplayOwnership (
    IN PHAL_RESET_DISPLAY_PARAMETERS  ResetDisplayParameters
    )
{
    return;
}

VOID
HalDisplayString (
    PUCHAR String
    )

{
    InbvDisplayString(String);  // lets forward for now...
}

VOID
HalQueryDisplayParameters (
    OUT PULONG WidthInCharacters,
    OUT PULONG HeightInLines,
    OUT PULONG CursorColumn,
    OUT PULONG CursorRow
    )

{
    return;
}

VOID
HalSetDisplayParameters (
    IN ULONG CursorColumn,
    IN ULONG CursorRow
    )
{
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halx86\i386\pmpcisup.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    pmpcibus.c

Abstract:

    Implements simplified PCI configuration
    read and write functions for use in
    an ACPI HAL.

Author:

    Jake Oshins (jakeo) 1-Dec-1997

Environment:

    Kernel mode only.

Revision History:

--*/

#include "halp.h"
#include "pci.h"
#include "pcip.h"
#include "cardbus.h"

#define MAX(a, b)       \
    ((a) > (b) ? (a) : (b))

#define MIN(a, b)       \
    ((a) < (b) ? (a) : (b))

NTSTATUS
HalpSearchForPciDebuggingDevice(
    IN OUT PDEBUG_DEVICE_DESCRIPTOR PciDevice,
    IN ULONG                        StartBusNumber,
    IN ULONG                        EndBusNumber,
    IN ULONG                        MinMem,
    IN ULONG                        MaxMem,
    IN USHORT                       MinIo,
    IN USHORT                       MaxIo,
    IN BOOLEAN                      ConfigureBridges
    );

PCIPBUSDATA HalpFakePciBusData = {
    {
        PCI_DATA_TAG,//Tag
        PCI_DATA_VERSION,//Version
        (PciReadWriteConfig)HalpReadPCIConfig,//ReadConfig
        (PciReadWriteConfig) HalpWritePCIConfig,//WriteConfig
        (PciPin2Line)HalpPCIPin2ISALine,//Pin2Line
        (PciLine2Pin)HalpPCIISALine2Pin,//Line2Pin
        {0},//ParentSlot
        NULL,NULL,NULL,NULL//Reserved[4]
    },
    {0},//Config
    PCI_MAX_DEVICES,//MaxDevice
};

BUS_HANDLER HalpFakePciBusHandler = {
    BUS_HANDLER_VERSION,//Version
    PCIBus,//InterfaceType
    PCIConfiguration,//ConfigurationType
    0,//BusNumber
    NULL,//DeviceObject
    NULL,//ParentHandler
    (PPCIBUSDATA)&HalpFakePciBusData,//BusData
    0,//DeviceControlExtensionSize
    NULL,//BusAddresses
    {0},//Reserved[4]
    (PGETSETBUSDATA)HalpGetPCIData,//GetBusData
    (PGETSETBUSDATA)HalpSetPCIData,//SetBusData
    NULL,//AdjustResourceList
    (PASSIGNSLOTRESOURCES)HalpAssignPCISlotResources,//AssignSlotResources
    NULL,//GetInterruptVector
    NULL,//TranslateBusAddress
};

ULONG       HalpMinPciBus = 0;
ULONG       HalpMaxPciBus = 0;

PCI_TYPE1_CFG_CYCLE_BITS HalpPciDebuggingDevice[MAX_DEBUGGING_DEVICES_SUPPORTED] = {0};

extern BOOLEAN HalpDoingCrashDump;

PVOID
HalpGetAcpiTablePhase0(
    IN  PLOADER_PARAMETER_BLOCK LoaderBlock,
    IN  ULONG   Signature
    );

VOID
HalpFindFreeResourceLimits(
    IN      ULONG   Bus,
    IN OUT  ULONG   *MinIo,
    IN OUT  ULONG   *MaxIo,
    IN OUT  ULONG   *MinMem,
    IN OUT  ULONG   *MaxMem,
    IN OUT  ULONG   *MinBus,
    IN OUT  ULONG   *MaxBus
    );

NTSTATUS
HalpSetupUnconfiguredDebuggingDevice(
    IN ULONG   Bus,
    IN ULONG   Slot,
    IN ULONG   IoMin,
    IN ULONG   IoMax,
    IN ULONG   MemMin,
    IN ULONG   MemMax,
    IN OUT PDEBUG_DEVICE_DESCRIPTOR PciDevice
    );

NTSTATUS
HalpConfigurePciBridge(
    IN      PDEBUG_DEVICE_DESCRIPTOR  PciDevice,
    IN      ULONG   Bus,
    IN      ULONG   Slot,
    IN      ULONG   IoMin,
    IN      ULONG   IoMax,
    IN      ULONG   MemMin,
    IN      ULONG   MemMax,
    IN      ULONG   BusMin,
    IN      ULONG   BusMax,
    IN OUT  PPCI_COMMON_CONFIG PciData
    );

NTSTATUS
HalpConfigureCardBusBridge(
    IN      PDEBUG_DEVICE_DESCRIPTOR  PciDevice,
    IN      ULONG   Bus,
    IN      ULONG   Slot,
    IN      ULONG   IoMin,
    IN      ULONG   IoMax,
    IN      ULONG   MemMin,
    IN      ULONG   MemMax,
    IN      ULONG   BusMin,
    IN      ULONG   BusMax,
    IN OUT  PPCI_COMMON_CONFIG PciData
    );

VOID
HalpUnconfigurePciBridge(
    IN  ULONG   Bus,
    IN  ULONG   Slot
    );

VOID
HalpUnconfigureCardBusBridge(
    IN  ULONG   Bus,
    IN  ULONG   Slot
    );

ULONG
HalpKdStallExecution(
    ULONG   LoopCount
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT,HalpInitializePciStubs)
#pragma alloc_text(INIT,HalpRegisterKdSupportFunctions)
#pragma alloc_text(INIT,HalpRegisterPciDebuggingDeviceInfo)
#pragma alloc_text(PAGEKD,HalpConfigurePciBridge)
#pragma alloc_text(PAGEKD,HalpConfigureCardBusBridge)
#pragma alloc_text(PAGEKD,HalpFindFreeResourceLimits)
#pragma alloc_text(PAGEKD,HalpPhase0GetPciDataByOffset)
#pragma alloc_text(PAGEKD,HalpPhase0SetPciDataByOffset)
#pragma alloc_text(PAGEKD,HalpReleasePciDeviceForDebugging)
#pragma alloc_text(PAGEKD,HalpSearchForPciDebuggingDevice)
#pragma alloc_text(PAGEKD,HalpSetupPciDeviceForDebugging)
#pragma alloc_text(PAGEKD,HalpSetupUnconfiguredDebuggingDevice)
#pragma alloc_text(PAGEKD,HalpUnconfigurePciBridge)
#pragma alloc_text(PAGEKD,HalpUnconfigureCardBusBridge)
#pragma alloc_text(PAGEKD,HalpKdStallExecution)
#endif

VOID
HalpInitializePciStubs (
    VOID
    )
{
    PPCI_REGISTRY_INFO_INTERNAL  PCIRegInfo;
    PPCIPBUSDATA                 BusData;
    UCHAR                        iBuffer[PCI_COMMON_HDR_LENGTH];
    ULONG                        HwType;
    ULONG                        BusNo = 0;
    ULONG                        Bytes;
    ULONG                        Slot;
    PCI_COMMON_CONFIG            PciData;

    PCIRegInfo = HalpQueryPciRegistryInfo();

    if (PCIRegInfo) {

        //
        // PCIRegInfo describes the system's PCI support as indicated by the BIOS.
        //
        HwType = PCIRegInfo->HardwareMechanism & 0xf;
        ExFreePool(PCIRegInfo);
    } else {
        //
        // no PCI bus information was gathered by NTDETECT,
        // assume type 1 access.
        //
        HwType = 1;
    }

    //
    // Initialize spinlock for synchronizing access to PCI space
    //

    KeInitializeSpinLock (&HalpPCIConfigLock);

    BusData = (PPCIPBUSDATA) HalpFakePciBusHandler.BusData;

    //
    // Set defaults
    //

    switch (HwType) {
        case 1:
            //
            // Initialize access port information for Type1 handlers
            //

            RtlCopyMemory (&PCIConfigHandler,
                           &PCIConfigHandlerType1,
                           sizeof (PCIConfigHandler));

            BusData->Config.Type1.Address = (PULONG)PCI_TYPE1_ADDR_PORT;
            BusData->Config.Type1.Data    = PCI_TYPE1_DATA_PORT;
            break;

        case 2:
            //
            // Initialize access port information for Type2 handlers
            //

            RtlCopyMemory (&PCIConfigHandler,
                           &PCIConfigHandlerType2,
                           sizeof (PCIConfigHandler));

            BusData->Config.Type2.CSE     = PCI_TYPE2_CSE_PORT;
            BusData->Config.Type2.Forward = PCI_TYPE2_FORWARD_PORT;
            BusData->Config.Type2.Base    = PCI_TYPE2_ADDRESS_BASE;

            //
            // Early PCI machines didn't decode the last bit of
            // the device id.  Shrink type 2 support max device.
            //
            BusData->MaxDevice            = 0x10;

            break;

        default:
            // unsupport type
            DBGMSG ("HAL: Unkown PCI type\n");
    }


    //
    // Make a good guess about how many PCI busses are in the system
    // and initialize HalpMaxPciBus with this guess.  When the PCI
    // driver starts, we will get a better answer here.
    //
    // Calling HaliPciInterfaceReadConfig has the side effect of
    // bumping up HalpMaxPciBus if it hits a populated device.  So
    // the algorithm here is to just keep searching for devices until
    // we have searched 0x10 busses higher than the current maximum.
    //

    while (BusNo < 0x100) {

        //
        // Scan across this bus.  As soon as we find a device,
        // then move on to another bus.
        //

        for (Slot = 0;
             Slot < PCI_MAX_DEVICES;
             Slot++) {

            Bytes = HaliPciInterfaceReadConfig(NULL,
                                               (UCHAR)BusNo,
                                               Slot,
                                               (PVOID)&PciData,
                                               0,
                                               4
                                               );
            if ((Bytes != 0) &&
                (PciData.VendorID != PCI_INVALID_VENDORID)) {

                //
                // This was a populated device.  Bump up HalpMaxPciBus.
                //

                HalpMaxPciBus = BusNo;
                break;
            }
        }

        BusNo++;
    }
}


ULONG
HaliPciInterfaceReadConfig(
    IN PVOID Context,
    IN UCHAR BusOffset,
    IN ULONG Slot,
    IN PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Length
    )
{
    PCI_SLOT_NUMBER slotNum;
    BUS_HANDLER     busHand;

    UNREFERENCED_PARAMETER(Context);

    slotNum.u.AsULONG = Slot;

    //
    // Fake a bus handler.
    //

    RtlCopyMemory(&busHand, &HalpFakePciBusHandler, sizeof(BUS_HANDLER));

    //
    // Calculate the right bus number.
    //

    busHand.BusNumber = BusOffset;

    HalpReadPCIConfig(&busHand,
                      slotNum,
                      Buffer,
                      Offset,
                      Length
                      );

    //
    // This is a hack.  The legacy HAL interfaces need to be able
    // to distinguish between busses that exist and busses that
    // don't.  And many users of the legacy interfaces implicitly
    // assume that PCI busses are tightly packed.  (i.e. All busses
    // between the lowest numbered one and the highest numbered one
    // exist.)  So here we are keeping track of the highest numbered
    // bus that we have seen so far.
    //

    if ((Length >= 2) &&
        (((PPCI_COMMON_CONFIG)Buffer)->VendorID != PCI_INVALID_VENDORID)) {

        //
        // This is a valid device.
        //

        if (busHand.BusNumber > HalpMaxPciBus) {

            //
            // This is the highest numbered bus we have
            // yet seen.
            //

            HalpMaxPciBus = busHand.BusNumber;
        }
    }

    return Length;
}

ULONG
HaliPciInterfaceWriteConfig(
    IN PVOID Context,
    IN UCHAR BusOffset,
    IN ULONG Slot,
    IN PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Length
    )
{
    PCI_SLOT_NUMBER slotNum;
    BUS_HANDLER     busHand;

    UNREFERENCED_PARAMETER(Context);

    slotNum.u.AsULONG = Slot;

    //
    // Fake a bus handler.
    //

    RtlCopyMemory(&busHand, &HalpFakePciBusHandler, sizeof(BUS_HANDLER));

    //
    // Calculate the right bus number.
    //

    busHand.BusNumber = BusOffset;

    HalpWritePCIConfig(&busHand,
                       slotNum,
                       Buffer,
                       Offset,
                       Length
                       );

    return Length;
}

VOID
HaliSetMaxLegacyPciBusNumber(
    IN ULONG BusNumber
    )
/*++

Routine Description:

    This routine bumps the Legacy PCI bus maximum up to whatever
    is passed in.  This may be necessary because the ACPI driver
    needs to run a configuration cycle to a PCI device before the
    PCI driver loads.  This happens mostly in the context of a
    _REG method.

Arguments:

    BusNumber - max PCI bus number

Return Value:

    none

Notes:

    Caller is responsible for acquiring any necessary PCI config
    spinlocks.

--*/
{
    if (BusNumber > HalpMaxPciBus) {
        HalpMaxPciBus = BusNumber;
    }
}

ULONG
HalpPhase0SetPciDataByOffset (
    ULONG BusNumber,
    ULONG SlotNumber,
    PVOID Buffer,
    ULONG Offset,
    ULONG Length
    )

/*++

Routine Description:

    This routine writes to PCI configuration space prior to bus handler
    installation.

Arguments:

    BusNumber   PCI Bus Number.  This is the 8 bit BUS Number which is
                bits 23-16 of the Configuration Address.  In support of
                multiple top level busses, the upper 24 bits of this
                argument will supply the index into the table of
                configuration address registers.
    SlotNumber  PCI Slot Number, 8 bits composed of the 5 bit device
                number (bits 15-11 of the configuration address) and
                the 3 bit function number (10-8).
    Buffer      Address of source data.
    Offset      Number of bytes to skip from base of PCI config area.
    Length      Number of bytes to write

Return Value:

    Returns length of data written.

Notes:

    Caller is responsible for acquiring any necessary PCI config
    spinlocks.

--*/

{
    PCI_TYPE1_CFG_BITS ConfigAddress;
    ULONG ReturnLength;
    PCI_SLOT_NUMBER slot;
    PUCHAR Bfr = (PUCHAR)Buffer;

    ASSERT(!(Offset & ~0xff));
    ASSERT(Length);
    ASSERT((Offset + Length) <= 256);

    if ( Length + Offset > 256 ) {
        if ( Offset > 256 ) {
            return 0;
        }
        Length = 256 - Offset;
    }

    ReturnLength = Length;
    slot.u.AsULONG = SlotNumber;

    ConfigAddress.u.bits.BusNumber = BusNumber;
    ConfigAddress.u.bits.DeviceNumber = slot.u.bits.DeviceNumber;
    ConfigAddress.u.bits.FunctionNumber = slot.u.bits.FunctionNumber;
    ConfigAddress.u.bits.RegisterNumber = (Offset & 0xfc) >> 2;
    ConfigAddress.u.bits.Enable = TRUE;

    if ( Offset & 0x3 ) {
        //
        // Access begins at a non-register boundary in the config
        // space.  We need to read the register containing the data
        // and rewrite only the changed data.   (I wonder if this
        // ever really happens?)
        //
        ULONG SubOffset = Offset & 0x3;
        ULONG SubLength = 4 - SubOffset;
        union {
            ULONG All;
            UCHAR Bytes[4];
        } Tmp;

        if ( SubLength > Length ) {
            SubLength = Length;
        }

        //
        // Adjust Length (remaining) and (new) Offset by amount covered
        // in this first word.
        //
        Length -= SubLength;
        Offset += SubLength;

        //
        // Get the first word (register), replace only those bytes that
        // need to be changed, then write the whole thing back out again.
        //
        WRITE_PORT_ULONG((PULONG)PCI_TYPE1_ADDR_PORT, ConfigAddress.u.AsULONG);
        Tmp.All = READ_PORT_ULONG((PULONG)PCI_TYPE1_DATA_PORT);

        while ( SubLength-- ) {
            Tmp.Bytes[SubOffset++] = *Bfr++;
        }

        WRITE_PORT_ULONG((PULONG)PCI_TYPE1_DATA_PORT, Tmp.All);

        //
        // Aim ConfigAddressRegister at the next word (register).
        //
        ConfigAddress.u.bits.RegisterNumber++;
    }

    //
    // Do the majority of the transfer 4 bytes at a time.
    //
    while ( Length > sizeof(ULONG) ) {
        ULONG Tmp = *(UNALIGNED PULONG)Bfr;
        WRITE_PORT_ULONG((PULONG)PCI_TYPE1_ADDR_PORT, ConfigAddress.u.AsULONG);
        WRITE_PORT_ULONG((PULONG)PCI_TYPE1_DATA_PORT, Tmp);
        ConfigAddress.u.bits.RegisterNumber++;
        Bfr += sizeof(ULONG);
        Length -= sizeof(ULONG);

    }

    //
    // Do bytes in last register.
    //
    if ( Length ) {
        union {
            ULONG All;
            UCHAR Bytes[4];
        } Tmp;
        ULONG i = 0;
        WRITE_PORT_ULONG((PULONG)PCI_TYPE1_ADDR_PORT, ConfigAddress.u.AsULONG);
        Tmp.All = READ_PORT_ULONG((PULONG)PCI_TYPE1_DATA_PORT);

        while ( Length-- ) {
            Tmp.Bytes[i++] = *(PUCHAR)Bfr++;
        }
        WRITE_PORT_ULONG((PULONG)PCI_TYPE1_DATA_PORT, Tmp.All);
    }

    return ReturnLength;
}

ULONG
HalpPhase0GetPciDataByOffset (
    ULONG BusNumber,
    ULONG SlotNumber,
    PVOID Buffer,
    ULONG Offset,
    ULONG Length
    )

/*++

Routine Description:

    This routine reads PCI config space prior to bus handlder installation.

Arguments:

    BusNumber   PCI Bus Number.  This is the 8 bit BUS Number which is
                bits 23-16 of the Configuration Address.  In support of
                multiple top level busses, the upper 24 bits of this
                argument will supply the index into the table of
                configuration address registers.
    SlotNumber  PCI Slot Number, 8 bits composed of the 5 bit device
                number (bits 15-11 of the configuration address) and
                the 3 bit function number (10-8).
    Buffer      Address of source data.
    Offset      Number of bytes to skip from base of PCI config area.
    Length      Number of bytes to write

Return Value:

    Amount of data read.

--*/

{
    PCI_TYPE1_CFG_BITS ConfigAddress;
    PCI_TYPE1_CFG_BITS ConfigAddressTemp;
    ULONG ReturnLength;
    ULONG i;
    PCI_SLOT_NUMBER slot;
    union {
        ULONG All;
        UCHAR Bytes[4];
    } Tmp;

    ASSERT(!(Offset & ~0xff));
    ASSERT(Length);
    ASSERT((Offset + Length) <= 256);

    if ( Length + Offset > 256 ) {
        if ( Offset > 256 ) {
            return 0;
        }
        Length = 256 - Offset;
    }

    ReturnLength = Length;
    slot.u.AsULONG = SlotNumber;

    ConfigAddress.u.bits.BusNumber = BusNumber;
    ConfigAddress.u.bits.DeviceNumber = slot.u.bits.DeviceNumber;
    ConfigAddress.u.bits.FunctionNumber = slot.u.bits.FunctionNumber;
    ConfigAddress.u.bits.RegisterNumber = (Offset & 0xfc) >> 2;
    ConfigAddress.u.bits.Enable = TRUE;

    //
    // If we are being asked to read data when function != 0, check
    // first to see if this device decares itself as a multi-function
    // device.  If it doesn't, don't do this read.
    //
    if (ConfigAddress.u.bits.FunctionNumber != 0) {

        ConfigAddressTemp.u.bits.RegisterNumber = 3; // contains header type
        ConfigAddressTemp.u.bits.FunctionNumber = 0; // look at base package
        ConfigAddressTemp.u.bits.DeviceNumber = ConfigAddress.u.bits.DeviceNumber;
        ConfigAddressTemp.u.bits.BusNumber    = ConfigAddress.u.bits.BusNumber;
        ConfigAddressTemp.u.bits.Enable       = TRUE;

        WRITE_PORT_ULONG((PULONG)PCI_TYPE1_ADDR_PORT, ConfigAddressTemp.u.AsULONG);
        Tmp.All = READ_PORT_ULONG((PULONG)PCI_TYPE1_DATA_PORT);

        if (!(Tmp.Bytes[2] & 0x80)) { // if the Header type field's multi-function bit is not set

            for (i = 0; i < Length; i++) {
                *((PUCHAR)Buffer)++ = 0xff; // Make this read as if the device isn't populated
            }

            return Length;
        }
    }

    i = Offset & 0x3;

    while ( Length ) {
        WRITE_PORT_ULONG((PULONG)PCI_TYPE1_ADDR_PORT, ConfigAddress.u.AsULONG);
        Tmp.All = READ_PORT_ULONG((PULONG)PCI_TYPE1_DATA_PORT);
        while ( (i < 4) && Length) {
            *((PUCHAR)Buffer)++ = Tmp.Bytes[i];
            i++;
            Length--;
        }
        i = 0;
        ConfigAddress.u.bits.RegisterNumber++;
    }
    return ReturnLength;
}

NTSTATUS
HalpSetupPciDeviceForDebugging(
    IN     PLOADER_PARAMETER_BLOCK   LoaderBlock,   OPTIONAL
    IN OUT PDEBUG_DEVICE_DESCRIPTOR  PciDevice
    )
/*++

Routine Description:

    This routine finds and initializes a PCI device to be
    used for communicating with a debugger.

    The caller fills in as much of DEBUG_DEVICE_DESCRIPTOR
    as it cares to, filling unused fields with (-1).

    This routine attempts to find a matching PCI device.  It
    matches first based on Bus and Slot, if the caller has
    provided them.  Then it matches on VendorID/DeviceID, if
    the caller has provided them.  Last, it matches on
    BaseClass/SubClass.

    This routine will fill in any unused fields in the structure
    so that the caller can know specifically which PCI
    device matched the criteria.

    If the matching PCI device is not enabled, or it is
    behind a PCI to PCI bridge that is not enabled, this
    routine makes a best-effort attempt to find a safe
    configuration that allows the device (and possibly bridges)
    to function, and enables them.

    If the PCI device implements memory mapped Base Address
    registers, this function will create a virtual to physical
    mapping for the memory ranges implied by the Base Address
    Registers and fill in the TranslatedAddress field with
    virtual pointers to the bases of the ranges.  It will then
    fill in the Type field with CmResourceTypeMemory.  And
    the Valid field with be TRUE.

    If the PCI device implements I/O port Base Address registers,
    this function will put the translated port address in
    TranslatedAddress, setting the Type field to CmResourceTypePort
    and the Valid field to TRUE.

    If the PCI device does not implement a specific Base Address
    Register, the Valid field will be FALSE.

Arguments:

    PciDevice - Structure indicating the device

Return Value:

    STATUS_SUCCESS if the device is configured and usable.

    STATUS_NO_MORE_MATCHES if no device matched the criteria.

    STATUS_INSUFFICIENT_RESOURCES if the memory requirements
    couldn't be met.

    STATUS_UNSUCCESSFUL if the routine failed for other reasons.

--*/
{
    NTSTATUS            status;
    PCI_SLOT_NUMBER     slot;
    ULONG               i, j;
    ULONG               maxPhys;

    status = HalpSearchForPciDebuggingDevice(
                PciDevice,
                0,
                0xff,
                0x10000000,
                0xfc000000,
                0x1000,
                0xffff,
                FALSE);

    if (!NT_SUCCESS(status)) {

        //
        // We didn't find the device using a conservative
        // search.  Try a more invasive one.
        //

        status = HalpSearchForPciDebuggingDevice(
                    PciDevice,
                    0,
                    0xff,
                    0x10000000,
                    0xfc000000,
                    0x1000,
                    0xffff,
                    TRUE);
    }

    //
    // Record the Bus/Dev/Func so that we can stuff it in the
    // registry later.
    //

    if (NT_SUCCESS(status)) {

        if (PciDevice->Initialized) {
            //
            // Here we were just asked to reconfigure the bridges since
            // we already
            //
            return status;
        }

        slot.u.AsULONG = PciDevice->Slot;

        for (i = 0;
             i < MAX_DEBUGGING_DEVICES_SUPPORTED;
             i++) {

            if ((HalpPciDebuggingDevice[i].u.bits.Reserved1 == TRUE) &&
                (HalpPciDebuggingDevice[i].u.bits.FunctionNumber ==
                 slot.u.bits.FunctionNumber)                         &&
                (HalpPciDebuggingDevice[i].u.bits.DeviceNumber ==
                 slot.u.bits.DeviceNumber)                           &&
                (HalpPciDebuggingDevice[i].u.bits.BusNumber ==
                 PciDevice->Bus)) {

                //
                // This device has already been set up for
                // debugging.  Thus we should refuse to set
                // it up again.
                //

                return STATUS_UNSUCCESSFUL;
            }
        }

        for (i = 0;
             i < MAX_DEBUGGING_DEVICES_SUPPORTED;
             i++) {

            if (HalpPciDebuggingDevice[i].u.bits.Reserved1 == FALSE) {

                //
                // This slot is available.
                //

                HalpPciDebuggingDevice[i].u.bits.FunctionNumber =
                    slot.u.bits.FunctionNumber;
                HalpPciDebuggingDevice[i].u.bits.DeviceNumber =
                    slot.u.bits.DeviceNumber;
                HalpPciDebuggingDevice[i].u.bits.BusNumber = PciDevice->Bus;
                HalpPciDebuggingDevice[i].u.bits.Reserved1 = TRUE;
                PciDevice->Initialized = TRUE;

                break;
            }
        }

        //
        // Check to see if the caller wants any memory.
        //

        if (PciDevice->Memory.Length != 0) {

            if (!LoaderBlock) {
                return STATUS_INVALID_PARAMETER_1;
            }

            if (PciDevice->Memory.MaxEnd.QuadPart == 0) {
                PciDevice->Memory.MaxEnd.QuadPart = -1;
            }

            maxPhys = PciDevice->Memory.MaxEnd.HighPart ? 0xffffffff : PciDevice->Memory.MaxEnd.LowPart;
            maxPhys -= PciDevice->Memory.Length;

            //
            // The HAL APIs will always return page-aligned
            // memory.  So ignore Aligned for now.
            //

            maxPhys = PtrToUlong(PAGE_ALIGN(maxPhys));
            maxPhys += ADDRESS_AND_SIZE_TO_SPAN_PAGES(maxPhys, PciDevice->Memory.Length);

            PciDevice->Memory.Start.HighPart = 0;
            PciDevice->Memory.Start.LowPart =
                HalpAllocPhysicalMemory(LoaderBlock,
                                        maxPhys,
                                        ADDRESS_AND_SIZE_TO_SPAN_PAGES(maxPhys, PciDevice->Memory.Length),
                                        FALSE);

            if (!PciDevice->Memory.Start.LowPart) {
                return STATUS_INSUFFICIENT_RESOURCES;
            }

            PciDevice->Memory.VirtualAddress =
                HalpMapPhysicalMemory64(PciDevice->Memory.Start,
                                        ADDRESS_AND_SIZE_TO_SPAN_PAGES(maxPhys, PciDevice->Memory.Length));
        }
    }

    return status;
}

VOID
HalpFindFreeResourceLimits(
    IN      ULONG   Bus,
    IN OUT  ULONG   *MinIo,
    IN OUT  ULONG   *MaxIo,
    IN OUT  ULONG   *MinMem,
    IN OUT  ULONG   *MaxMem,
    IN OUT  ULONG   *MinBus,
    IN OUT  ULONG   *MaxBus
    )
{
    UCHAR               buffer[PCI_COMMON_HDR_LENGTH];
    PPCI_COMMON_CONFIG  pciData;
    UCHAR               bus, dev, func, bytesRead;
    PCI_SLOT_NUMBER     pciSlot, targetSlot;
    ULONG               newMinMem, newMaxMem;
    ULONG               newMinIo, newMaxIo;
    ULONG               newMinBus, newMaxBus;
    UCHAR               barNo;

    pciData = (PPCI_COMMON_CONFIG)buffer;
    pciSlot.u.AsULONG = 0;
    newMinMem   = *MinMem;
    newMaxMem   = *MaxMem;
    newMinIo    = *MinIo;
    newMaxIo    = *MaxIo;
    newMinBus   = *MinBus;
    newMaxBus   = *MaxBus;

    for (dev = 0; dev < PCI_MAX_DEVICES; dev++) {
        for (func = 0; func < PCI_MAX_FUNCTION; func++) {

            pciSlot.u.bits.DeviceNumber = dev;
            pciSlot.u.bits.FunctionNumber = func;


            bytesRead = (UCHAR)HalpPhase0GetPciDataByOffset(Bus,
                                 pciSlot.u.AsULONG,
                                 pciData,
                                 0,
                                 PCI_COMMON_HDR_LENGTH);

            if (bytesRead == 0) continue;

            if (pciData->VendorID != PCI_INVALID_VENDORID) {

                switch (PCI_CONFIGURATION_TYPE(pciData)) {
                case PCI_DEVICE_TYPE:

                    //
                    // While we scan across the bus, keep track
                    // of the minimum decoder values that we've seen.
                    // This will be used if we have to configure the
                    // device.  This relies on the fact that most BIOSes
                    // assign addresses from the top down.
                    //

                    for (barNo = 0; barNo < PCI_TYPE0_ADDRESSES; barNo++) {

                        if (pciData->u.type0.BaseAddresses[barNo] &
                            PCI_ADDRESS_IO_SPACE) {

                            if (pciData->u.type0.BaseAddresses[barNo] &
                                PCI_ADDRESS_IO_ADDRESS_MASK) {

                                //
                                // This BAR is implemented
                                //

                                if ((pciData->u.type0.BaseAddresses[barNo] &
                                     PCI_ADDRESS_IO_ADDRESS_MASK) <
                                    ((newMaxIo / 2) + (newMinIo / 2))) {

                                    //
                                    // This BAR is at the bottom of the range.
                                    // Bump up the min.
                                    //

                                    newMinIo = (USHORT)MAX (newMinIo,
                                                            (pciData->u.type0.BaseAddresses[barNo] &
                                                             PCI_ADDRESS_IO_ADDRESS_MASK) + 0x100);

                                } else {

                                    //
                                    // This BAR is not at the bottom of the range.
                                    // Bump down the max.
                                    //

                                    newMaxIo = (USHORT)MIN (newMaxIo,
                                                            pciData->u.type0.BaseAddresses[barNo] &
                                                            PCI_ADDRESS_IO_ADDRESS_MASK);
                                }
                            }

                        } else {

                            if (pciData->u.type0.BaseAddresses[barNo] &
                                PCI_ADDRESS_MEMORY_ADDRESS_MASK) {

                                //
                                // The BAR is populated.
                                //

                                if ((pciData->u.type0.BaseAddresses[barNo] &
                                     PCI_ADDRESS_MEMORY_ADDRESS_MASK) <
                                    ((newMaxMem / 2) + (newMinMem / 2))) {

                                    //
                                    // This BAR is at the bottom of the range.
                                    // Bump up the min.
                                    //

                                    newMinMem = MAX (newMinMem,
                                                     (pciData->u.type0.BaseAddresses[barNo] &
                                                        PCI_ADDRESS_MEMORY_ADDRESS_MASK) + 0x10000);

                                } else {

                                    //
                                    // This BAR is not at the bottom of the range.
                                    // Bump down the max.
                                    //

                                    newMaxMem = MIN (newMaxMem,
                                                     (pciData->u.type0.BaseAddresses[barNo] &
                                                        PCI_ADDRESS_MEMORY_ADDRESS_MASK));

                                }
                            }
                        }
                    }

                    break;

                case PCI_CARDBUS_BRIDGE_TYPE:

                    {
                      ULONG  bridgeMemMin = 0, bridgeMemMax = 0;
                      USHORT bridgeIoMin, bridgeIoMax;
                      ULONG LegacyBaseAddress;
                      UCHAR bytesRead;

                      bytesRead = (UCHAR) HalpPhase0GetPciDataByOffset(Bus,
                                                                       pciSlot.u.AsULONG,
                                                                       &LegacyBaseAddress,
                                                                       CARDBUS_LEGACY_MODE_BASE_ADDR,
                                                                       4);

                      if (bytesRead != 4) continue;


                      if ((LegacyBaseAddress & ~1) &&
                          (pciData->u.type2.SecondaryBus != 0) &&
                          (pciData->u.type2.SubordinateBus !=0) &&
                          (pciData->u.type2.Range[0].Base != 0) &&
                          (pciData->u.type2.SocketRegistersBaseAddress != 0) &&
                          (pciData->Command & PCI_ENABLE_MEMORY_SPACE) &&
                          (pciData->Command & PCI_ENABLE_IO_SPACE)) {

                        bridgeMemMin = pciData->u.type2.Range[0].Base;
                        bridgeMemMax = pciData->u.type2.Range[0].Limit | 0xfff;
                        bridgeIoMin = (USHORT)pciData->u.type2.Range[2].Base;
                        bridgeIoMax = (USHORT)pciData->u.type2.Range[2].Limit | 0x3;

                        //
                        // Keep track of address space allocation.
                        //

                        if (bridgeIoMin > ((newMaxIo / 2) + (newMinIo / 2))) {
                            newMaxIo = MIN(newMaxIo, bridgeIoMin);
                        }

                        if (bridgeIoMax < ((newMaxIo / 2) + (newMinIo / 2))) {
                            newMinIo = MAX(newMinIo, bridgeIoMax) + 1;
                        }

                        if (bridgeMemMin > ((newMaxMem / 2) + (newMinMem / 2))) {
                            newMaxMem = MIN(newMaxMem, bridgeMemMin);
                        }

                        if (bridgeMemMax < ((newMaxMem / 2) + (newMinMem / 2))) {
                            newMinMem = MAX(newMinMem, bridgeMemMax) + 1;
                        }

                        //
                        // Keep track of bus numbers.
                        //

                        if (pciData->u.type2.PrimaryBus > ((newMaxBus / 2) + (newMinBus / 2))) {
                            newMaxBus = MIN(newMaxBus, pciData->u.type2.PrimaryBus);
                        }

                        if (pciData->u.type2.SubordinateBus < ((newMaxBus / 2) + (newMinBus / 2))) {
                            newMinBus = MAX(newMinBus, pciData->u.type2.SubordinateBus) + 1;
                        }
                      }
                    }

                    break;

                case PCI_BRIDGE_TYPE:

                    {
                      ULONG  bridgeMemMin = 0, bridgeMemMax = 0;
                      USHORT bridgeIoMin, bridgeIoMax;

                      if ((pciData->u.type1.SecondaryBus != 0) &&
                          (pciData->u.type1.SubordinateBus !=0) &&
                          (pciData->Command & PCI_ENABLE_MEMORY_SPACE) &&
                          (pciData->Command & PCI_ENABLE_IO_SPACE)) {

                        bridgeMemMin = PciBridgeMemory2Base(pciData->u.type1.MemoryBase);
                        bridgeMemMax = PciBridgeMemory2Limit(pciData->u.type1.MemoryLimit);
                        bridgeIoMin = (USHORT)PciBridgeIO2Base(pciData->u.type1.IOBase, 0);
                        bridgeIoMax = (USHORT)PciBridgeIO2Limit(pciData->u.type1.IOLimit, 0);

                        //
                        // Keep track of address space allocation.
                        //

                        if (bridgeIoMin > ((newMaxIo / 2) + (newMinIo / 2))) {
                            newMaxIo = MIN(newMaxIo, bridgeIoMin);
                        }

                        if (bridgeIoMax < ((newMaxIo / 2) + (newMinIo / 2))) {
                            newMinIo = MAX(newMinIo, bridgeIoMax) + 1;
                        }

                        if (bridgeMemMin > ((newMaxMem / 2) + (newMinMem / 2))) {
                            newMaxMem = MIN(newMaxMem, bridgeMemMin);
                        }

                        if (bridgeMemMax < ((newMaxMem / 2) + (newMinMem / 2))) {
                            newMinMem = MAX(newMinMem, bridgeMemMax) + 1;
                        }

                        //
                        // Keep track of bus numbers.
                        //

                        if (pciData->u.type1.PrimaryBus > ((newMaxBus / 2) + (newMinBus / 2))) {
                            newMaxBus = MIN(newMaxBus, pciData->u.type1.PrimaryBus);
                        }

                        if (pciData->u.type1.SubordinateBus < ((newMaxBus / 2) + (newMinBus / 2))) {
                            newMinBus = MAX(newMinBus, pciData->u.type1.SubordinateBus) + 1;
                        }
                      }

                      break;

                      default:
                        break;

                    }

                }

                if (!PCI_MULTIFUNCTION_DEVICE(pciData) &&
                    (func == 0)) {
                    break;
                }
            }
        }
    }

    *MinMem = newMinMem;
    *MaxMem = newMaxMem;
    *MinIo  = newMinIo;
    *MaxIo  = newMaxIo;
    *MinBus = newMinBus;
    *MaxBus = newMaxBus;
}

NTSTATUS
HalpSetupUnconfiguredDebuggingDevice(
    IN ULONG   Bus,
    IN ULONG   Slot,
    IN ULONG   IoMin,
    IN ULONG   IoMax,
    IN ULONG   MemMin,
    IN ULONG   MemMax,
    IN OUT PDEBUG_DEVICE_DESCRIPTOR PciDevice
    )
{

    UCHAR               buffer[PCI_COMMON_HDR_LENGTH];
    PPCI_COMMON_CONFIG  pciData;
    ULONG               barLength, bytesRead;
    ULONG               barContents = 0;
    PHYSICAL_ADDRESS    physicalAddress;
    PCI_SLOT_NUMBER     pciSlot;
    UCHAR               barNo;
    UCHAR               capPtr;
    PCI_PM_CAPABILITY   pmCap;

    //
    // Make sure the device is in D0
    //
    bytesRead = HalpPhase0GetPciDataByOffset(Bus, Slot, &capPtr,
                                             FIELD_OFFSET (PCI_COMMON_CONFIG, u.type0.CapabilitiesPtr), 1);

    if ((bytesRead == 1) && capPtr) {

        bytesRead = HalpPhase0GetPciDataByOffset(Bus, Slot, &pmCap, capPtr, sizeof(pmCap));

        if ((bytesRead == sizeof(pmCap)) &&
            (pmCap.Header.CapabilityID == PCI_CAPABILITY_ID_POWER_MANAGEMENT) &&
            (pmCap.PMCSR.ControlStatus.PowerState != 0)) {

            pmCap.PMCSR.ControlStatus.PowerState = 0; // set to D0

            HalpPhase0SetPciDataByOffset(Bus,
                                         Slot,
                                         &pmCap.PMCSR.ControlStatus,
                                         capPtr + FIELD_OFFSET(PCI_PM_CAPABILITY,PMCSR.ControlStatus),
                                         sizeof(pmCap.PMCSR.ControlStatus));


            HalpKdStallExecution(2000);

        }
    }

    pciSlot.u.AsULONG = Slot;
    pciData = (PPCI_COMMON_CONFIG)buffer;

    bytesRead = HalpPhase0GetPciDataByOffset(Bus,
                         pciSlot.u.AsULONG,
                         pciData,
                         0,
                         PCI_COMMON_HDR_LENGTH);

    ASSERT(bytesRead != 0);

    PciDevice->Bus = Bus;
    PciDevice->Slot = pciSlot.u.AsULONG;
    PciDevice->VendorID = pciData->VendorID;
    PciDevice->DeviceID = pciData->DeviceID;
    PciDevice->BaseClass = pciData->BaseClass;
    PciDevice->SubClass = pciData->SubClass;

  //DbgPrint("Configuring device between %x - %x\n",
  //         MemMin, MemMax);

    //
    // Cycle through the BARs, turning them on if necessary,
    // and mapping them.
    //

    for (barNo = 0; barNo < PCI_TYPE0_ADDRESSES; barNo++) {

        barContents = 0xffffffff;

        PciDevice->BaseAddress[barNo].Valid = FALSE;

        HalpPhase0SetPciDataByOffset(Bus,
                                     pciSlot.u.AsULONG,
                                     &barContents,
                                     0x10 + (4 * barNo),
                                     4);

        HalpPhase0GetPciDataByOffset(Bus,
                                     pciSlot.u.AsULONG,
                                     &barContents,
                                     0x10 + (4 * barNo),
                                     4);

        if (pciData->u.type0.BaseAddresses[barNo] &
            PCI_ADDRESS_IO_SPACE) {

            //
            // This is an I/O BAR.
            //

            barLength = (((USHORT)barContents & PCI_ADDRESS_IO_ADDRESS_MASK) - 1) ^
                0xffff;

            if (!(pciData->u.type0.BaseAddresses[barNo] &
                  PCI_ADDRESS_IO_ADDRESS_MASK)) {

                //
                // And it's empty.
                //

                //
                // Try to fit this I/O window half-way between the min and the max.
                //

                if ((ULONG)(IoMax - IoMin) >= (barLength * 3)) {

                    //
                    // There is plenty of room, make a safe guess.  Try
                    // to put it half-way between the upper and lower
                    // bounds, rounding up to the next natural alignment.
                    //

                    pciData->u.type0.BaseAddresses[barNo] =
                        (((IoMax / 2) + (IoMin / 2)) + barLength) & (barLength -1);

                } else if (barLength >= (IoMax -
                                         ((IoMin & (barLength -1)) ?
                                            ((IoMin + barLength) & (barLength -1)) :
                                            IoMin))) {
                    //
                    // Space is tight, make a not-so-safe guess.  Try
                    // to put it at the bottom of the range, rounded
                    // up the the next natural alignment.
                    //

                    pciData->u.type0.BaseAddresses[barNo] =
                        ((IoMin & (barLength -1)) ?
                                            ((IoMin + barLength) & (barLength -1)) :
                                            IoMin);
                }

                IoMin = (USHORT)pciData->u.type0.BaseAddresses[barNo];
            }

            pciData->Command |= PCI_ENABLE_IO_SPACE;

            PciDevice->BaseAddress[barNo].Type = CmResourceTypePort;
            PciDevice->BaseAddress[barNo].Valid = TRUE;
            PciDevice->BaseAddress[barNo].TranslatedAddress =
                (PUCHAR)(ULONG_PTR)(pciData->u.type0.BaseAddresses[barNo] &
                PCI_ADDRESS_IO_ADDRESS_MASK);
            PciDevice->BaseAddress[barNo].Length = barLength;

        } else {

            //
            // This is a memory BAR.
            //

            barLength = ((barContents & PCI_ADDRESS_MEMORY_ADDRESS_MASK) - 1) ^
                0xffffffff;

            if (!(pciData->u.type0.BaseAddresses[barNo] &
                  PCI_ADDRESS_MEMORY_ADDRESS_MASK)) {

                //
                // And it's empty.
                //

                if (barLength == 0) continue;

                //
                // Try to fit this memory window half-way between the min and the max.
                //

                if ((ULONG)(MemMax - MemMin) >= (barLength * 3)) {

                    //
                    // There is plenty of room, make a safe guess.  Try
                    // to put it half-way between the upper and lower
                    // bounds, rounding up to the next natural alignment.
                    //

                    pciData->u.type0.BaseAddresses[barNo] =
                        (ULONG)(((MemMax / 2) + (MemMin / 2))
                                 + barLength) & ~(barLength -1);

                } else if (barLength >= (ULONG)(MemMax -
                                         ((MemMin & ~(barLength -1)) ?
                                            ((MemMin + barLength) & ~(barLength -1)) :
                                            MemMin))) {
                    //
                    // Space is tight, make a not-so-safe guess.  Try
                    // to put it at the bottom of the range, rounded
                    // up the the next natural alignment.
                    //

                    pciData->u.type0.BaseAddresses[barNo] =
                        (ULONG)((MemMin & ~(barLength -1)) ?
                                    ((MemMin + barLength) & ~(barLength -1)) :
                                      MemMin);
                }

                MemMin = pciData->u.type0.BaseAddresses[barNo] &
                    PCI_ADDRESS_MEMORY_ADDRESS_MASK;
            }

            pciData->Command |= PCI_ENABLE_MEMORY_SPACE;

            physicalAddress.HighPart = 0;
            physicalAddress.LowPart = pciData->u.type0.BaseAddresses[barNo]
                & PCI_ADDRESS_MEMORY_ADDRESS_MASK;
            PciDevice->BaseAddress[barNo].Type = CmResourceTypeMemory;
            PciDevice->BaseAddress[barNo].Valid = TRUE;
            PciDevice->BaseAddress[barNo].TranslatedAddress =
                HalpMapPhysicalMemory64(physicalAddress,
                    ADDRESS_AND_SIZE_TO_SPAN_PAGES(physicalAddress.LowPart, barLength));
            PciDevice->BaseAddress[barNo].Length = barLength;
        }
    }

    pciData->Command |= PCI_ENABLE_BUS_MASTER;

    //
    // Write back any changes we made.
    //

    HalpPhase0SetPciDataByOffset(Bus,
                                 pciSlot.u.AsULONG,
                                 pciData,
                                 0,
                                 0x40);

    return STATUS_SUCCESS;
}


NTSTATUS
HalpSearchForPciDebuggingDevice(
    IN OUT PDEBUG_DEVICE_DESCRIPTOR PciDevice,
    IN ULONG                        StartBusNumber,
    IN ULONG                        EndBusNumber,
    IN ULONG                        MinMem,
    IN ULONG                        MaxMem,
    IN USHORT                       MinIo,
    IN USHORT                       MaxIo,
    IN BOOLEAN                      ConfigureBridges
    )
/*++

Routine Description:

    This routine is a helper function for
    HalpSetupPciDeviceForDebugging.

Arguments:

    PciDevice - Structure indicating the device

Return Value:

    STATUS_SUCCESS if the device is configured and usable.

    STATUS_NO_MORE_MATCHES if no device matched the criteria.

    STATUS_UNSUCCESSFUL if the routine fails for other reasons.
--*/
#define TARGET_DEVICE_NOT_FOUND 0x10000
{
    NTSTATUS            status;
    UCHAR               buffer[PCI_COMMON_HDR_LENGTH];
    PPCI_COMMON_CONFIG  pciData;
    UCHAR               bus, dev, func, bytesRead;
    PCI_SLOT_NUMBER     pciSlot, targetSlot;
    ULONG               newMinMem, newMaxMem;
    ULONG               newMinIo, newMaxIo;
    ULONG               newMinBus, newMaxBus;
    UCHAR               barNo;
    BOOLEAN             unconfigureBridge;

    pciData = (PPCI_COMMON_CONFIG)buffer;
    pciSlot.u.AsULONG = 0;
    newMinMem = MinMem;
    newMaxMem = MaxMem;
    newMinIo = MinIo;
    newMaxIo = MaxIo;
    newMinBus = StartBusNumber;
    newMaxBus = EndBusNumber;
    bus = (UCHAR)StartBusNumber;

  //DbgPrint("HalpSearchForPciDebuggingDevice:\n"
  //         "\tMem: %x-%x\n"
  //         "\tI/O: %x-%x\n"
  //         "\tBus: %x-%x\n"
  //         "\t%s Configuring Bridges\n",
  //         MinMem, MaxMem,
  //         MinIo, MaxIo,
  //         StartBusNumber, EndBusNumber,
  //         ConfigureBridges ? "" : "Not");

    //
    // This bit stays set to 1 until we find the device.
    //
    targetSlot.u.bits.Reserved = TARGET_DEVICE_NOT_FOUND;

    while (TRUE) {

        UCHAR nextBus;

        nextBus = bus + 1;

        HalpFindFreeResourceLimits(bus,
                                   &newMinIo,
                                   &newMaxIo,
                                   &newMinMem,
                                   &newMaxMem,
                                   &newMinBus,
                                   &newMaxBus
                                   );

        for (dev = 0; dev < PCI_MAX_DEVICES; dev++) {
            for (func = 0; func < PCI_MAX_FUNCTION; func++) {

                pciSlot.u.bits.DeviceNumber = dev;
                pciSlot.u.bits.FunctionNumber = func;


                bytesRead = (UCHAR)HalpPhase0GetPciDataByOffset(bus,
                                     pciSlot.u.AsULONG,
                                     pciData,
                                     0,
                                     PCI_COMMON_HDR_LENGTH);

                if (bytesRead == 0) continue;

                if (pciData->VendorID != PCI_INVALID_VENDORID) {

                  //DbgPrint("%04x:%04x - %x/%x/%x - \tSlot: %x\n",
                  //         pciData->VendorID,
                  //         pciData->DeviceID,
                  //         pciData->BaseClass,
                  //         pciData->SubClass,
                  //         pciData->ProgIf,
                  //         pciSlot.u.AsULONG);

                    switch (PCI_CONFIGURATION_TYPE(pciData)) {
                    case PCI_DEVICE_TYPE:

                        //
                        // Match first on Bus/Dev/Func
                        //

                        if ((PciDevice->Bus == bus) &&
                            (PciDevice->Slot == pciSlot.u.AsULONG)) {

                          //DbgPrint("\n\nMatched on Bus/Slot\n\n");

                            return HalpSetupUnconfiguredDebuggingDevice(
                                        bus,
                                        pciSlot.u.AsULONG,
                                        newMinIo,
                                        newMaxIo,
                                        newMinMem,
                                        newMaxMem,
                                        PciDevice
                                        );
                        }

                        if ((PciDevice->Bus == MAXULONG) &&
                            (PciDevice->Slot == MAXULONG)) {

                            //
                            // Bus and Slot weren't specified.  Match
                            // on VID/DID.
                            //

                            if ((pciData->VendorID == PciDevice->VendorID) &&
                                (pciData->DeviceID == PciDevice->DeviceID)) {

                              //DbgPrint("\n\nMatched on Vend/Dev\n\n");

                                return HalpSetupUnconfiguredDebuggingDevice(
                                            bus,
                                            pciSlot.u.AsULONG,
                                            newMinIo,
                                            newMaxIo,
                                            newMinMem,
                                            newMaxMem,
                                            PciDevice
                                            );
                            }

                            if ((PciDevice->VendorID == MAXUSHORT) &&
                                (PciDevice->DeviceID == MAXUSHORT)) {

                                //
                                // VID/DID weren't specified.  Match
                                // on class codes.
                                //

                                if ((pciData->BaseClass == PciDevice->BaseClass) &&
                                    (pciData->SubClass == PciDevice->SubClass)) {

                                  //DbgPrint("\n\nMatched on Base/Sub\n\n");
                                    //
                                    // Further match on Programming Interface,
                                    // if specified.
                                    //

                                    if ((PciDevice->ProgIf != MAXUCHAR) &&
                                        (PciDevice->ProgIf != pciData->ProgIf)) {

                                        break;
                                    }

                                  //DbgPrint("\n\nMatched on programming interface\n\n");

                                    return HalpSetupUnconfiguredDebuggingDevice(
                                                bus,
                                                pciSlot.u.AsULONG,
                                                newMinIo,
                                                newMaxIo,
                                                newMinMem,
                                                newMaxMem,
                                                PciDevice
                                                );
                                }
                            }

                        }

                        break;

                    case PCI_CARDBUS_BRIDGE_TYPE:

                        {
                          ULONG  bridgeMemMin = 0, bridgeMemMax = 0;
                          USHORT bridgeIoMin, bridgeIoMax;
                          ULONG LegacyBaseAddress;

                          unconfigureBridge = FALSE;

                        //DbgPrint("Found a CardBus bridge\n");

                          HalpPhase0GetPciDataByOffset(bus,
                                                       pciSlot.u.AsULONG,
                                                       &LegacyBaseAddress,
                                                       CARDBUS_LEGACY_MODE_BASE_ADDR,
                                                       4);

                          if (!(((LegacyBaseAddress & ~1) == 0) &&
                                (pciData->u.type2.SecondaryBus != 0) &&
                                (pciData->u.type2.SubordinateBus !=0) &&
                                (pciData->u.type2.Range[0].Base != 0) &&
                                (pciData->u.type2.SocketRegistersBaseAddress != 0) &&
                                (pciData->Command & PCI_ENABLE_MEMORY_SPACE) &&
                                (pciData->Command & PCI_ENABLE_IO_SPACE))) {

                              //
                              // The bridge is unconfigured.
                              //

                              if (ConfigureBridges){

                                  //
                                  // We should configure it now.
                                  //
                                  status = HalpConfigureCardBusBridge(
                                                PciDevice,
                                                bus,
                                                pciSlot.u.AsULONG,
                                                newMinIo,
                                                newMaxIo,
                                                newMinMem,
                                                newMaxMem,
                                                MAX((UCHAR)newMinBus, (bus + 1)),
                                                newMaxBus,
                                                pciData
                                                );

                                  if (!NT_SUCCESS(status)) {
                                      break;
                                  }

                                  unconfigureBridge = TRUE;

                              } else {

                                  //
                                  // We aren't configuring bridges
                                  // on this pass.
                                  //

                                  break;
                              }

                          }


                          bridgeMemMin = pciData->u.type2.Range[0].Base;
                          bridgeMemMax = pciData->u.type2.Range[0].Limit | 0xfff;
                          bridgeIoMin = (USHORT)pciData->u.type2.Range[2].Base;
                          bridgeIoMax = (USHORT)pciData->u.type2.Range[2].Limit | 0x3;

                        //DbgPrint("Configured:  I/O %x-%x  Mem %x-%x\n",
                        //         bridgeIoMin, bridgeIoMax,
                        //         bridgeMemMin, bridgeMemMax);

                          //
                          // Recurse.
                          //
                          status = HalpSearchForPciDebuggingDevice(
                              PciDevice,
                              (ULONG)pciData->u.type2.SecondaryBus,
                              (ULONG)pciData->u.type2.SubordinateBus,
                              bridgeMemMin,
                              bridgeMemMax,
                              bridgeIoMin,
                              bridgeIoMax,
                              ConfigureBridges);

                          if (NT_SUCCESS(status)) {
                              return status;
                          }

                          if (!unconfigureBridge) {

                              //
                              // Bump up the bus number so that we don't
                              // scan down the busses we just recursed into.
                              //

                              nextBus = pciData->u.type2.SubordinateBus + 1;

                          } else {

                              HalpUnconfigureCardBusBridge(bus,
                                                           pciSlot.u.AsULONG);
                          }
                        }

                        break;

                    case PCI_BRIDGE_TYPE:

                        {
                          ULONG  bridgeMemMin = 0, bridgeMemMax = 0;
                          USHORT bridgeIoMin, bridgeIoMax;

                          unconfigureBridge = FALSE;
                        //DbgPrint("Found a PCI to PCI bridge\n");

                          if (!((pciData->u.type1.SecondaryBus != 0) &&
                                (pciData->u.type1.SubordinateBus !=0) &&
                                (pciData->Command & PCI_ENABLE_MEMORY_SPACE) &&
                                (pciData->Command & PCI_ENABLE_IO_SPACE))) {

                              //
                              // The bridge is unconfigured.
                              //

                              if (ConfigureBridges){

                                  //
                                  // We should configure it now.
                                  //

                                  status = HalpConfigurePciBridge(
                                                PciDevice,
                                                bus,
                                                pciSlot.u.AsULONG,
                                                newMinIo,
                                                newMaxIo,
                                                newMinMem,
                                                newMaxMem,
                                                MAX((UCHAR)newMinBus, (bus + 1)),
                                                newMaxBus,
                                                pciData
                                                );

                                  if (!NT_SUCCESS(status)) {
                                      break;
                                  }

                                  unconfigureBridge = TRUE;

                              } else {

                                  //
                                  // We aren't configuring bridges
                                  // on this pass.
                                  //

                                  break;
                              }

                          }

                          bridgeMemMin = PciBridgeMemory2Base(pciData->u.type1.MemoryBase);
                          bridgeMemMax = PciBridgeMemory2Limit(pciData->u.type1.MemoryLimit);
                          bridgeIoMin = (USHORT)PciBridgeIO2Base(pciData->u.type1.IOBase, 0);
                          bridgeIoMax = (USHORT)PciBridgeIO2Limit(pciData->u.type1.IOLimit, 0);

                        //DbgPrint("Configured:  I/O %x-%x  Mem %x-%x\n",
                        //         bridgeIoMin, bridgeIoMax,
                        //         bridgeMemMin, bridgeMemMax);

                          //
                          // Recurse.
                          //

                          status = HalpSearchForPciDebuggingDevice(
                              PciDevice,
                              (ULONG)pciData->u.type1.SecondaryBus,
                              (ULONG)pciData->u.type1.SubordinateBus,
                              bridgeMemMin,
                              bridgeMemMax,
                              bridgeIoMin,
                              bridgeIoMax,
                              ConfigureBridges);

                          if (NT_SUCCESS(status)) {
                              return status;
                          }

                          if (!unconfigureBridge) {

                              //
                              // Bump up the bus number so that we don't
                              // scan down the busses we just recursed into.
                              //

                              nextBus = pciData->u.type1.SubordinateBus + 1;

                          } else {

                              HalpUnconfigurePciBridge(bus,
                                                       pciSlot.u.AsULONG);
                          }
                        }

                        break;
                    default:
                        break;

                    }

                }

                if (!PCI_MULTIFUNCTION_DEVICE(pciData) &&
                    (func == 0)) {
                    break;
                }
            }
        }

        if (nextBus >= EndBusNumber) {
            break;
        }

        bus = nextBus;
    }

    return STATUS_NOT_FOUND;
}



NTSTATUS
HalpReleasePciDeviceForDebugging(
    IN OUT PDEBUG_DEVICE_DESCRIPTOR  PciDevice
    )
/*++

Routine Description:

    This routine de-allocates any resources acquired in
    HalpSetupPciDeviceForDebugging.

Arguments:

    PciDevice - Structure indicating the device

Return Value:

--*/
{
    ULONG i;

    for (i = 0; i < PCI_TYPE0_ADDRESSES; i++) {

        if (PciDevice->BaseAddress[i].Valid &&
            PciDevice->BaseAddress[i].Type == CmResourceTypeMemory) {

            PciDevice->BaseAddress[i].Valid = FALSE;

            HalpUnmapVirtualAddress(PciDevice->BaseAddress[i].TranslatedAddress,
                                    ADDRESS_AND_SIZE_TO_SPAN_PAGES(
                                        PciDevice->BaseAddress[i].TranslatedAddress,
                                        PciDevice->BaseAddress[i].Length));
        }
    }

    return STATUS_SUCCESS;
}

VOID
HalpRegisterKdSupportFunctions(
    IN PLOADER_PARAMETER_BLOCK LoaderBlock
    )
/*++

Routine Description:

    This routine fills in the HalPrivateDispatchTable
    with the functions needed for debugging through
    PCI devices.

Arguments:

    LoaderBlock - The Loader Block

Return Value:

--*/
{

    KdSetupPciDeviceForDebugging = HalpSetupPciDeviceForDebugging;
    KdReleasePciDeviceForDebugging = HalpReleasePciDeviceForDebugging;

#ifdef ACPI_HAL
    KdGetAcpiTablePhase0 = HalpGetAcpiTablePhase0;
#endif

    KdCheckPowerButton = HalpCheckPowerButton;
    KdMapPhysicalMemory64 = HalpMapPhysicalMemory64;
    KdUnmapVirtualAddress = HalpUnmapVirtualAddress;
}

VOID
HalpRegisterPciDebuggingDeviceInfo(
    VOID
    )
{
    OBJECT_ATTRIBUTES   ObjectAttributes;
    UNICODE_STRING      UnicodeString;
    HANDLE              BaseHandle = NULL;
    HANDLE              Handle = NULL;
    ULONG               disposition;
    ULONG               bus;
    UCHAR               i;
    PCI_SLOT_NUMBER     slot;
    NTSTATUS            status;
    BOOLEAN             debuggerFound = FALSE;

    PAGED_CODE();

    for (i = 0;
         i < MAX_DEBUGGING_DEVICES_SUPPORTED;
         i++) {

        if (HalpPciDebuggingDevice[i].u.bits.Reserved1 == TRUE) {
            //
            // Must be using a PCI device for a debugger.
            //
            debuggerFound = TRUE;
        }
    }

    if (!debuggerFound) {
        return;
    }

    //
    // Open PCI service key.
    //

    RtlInitUnicodeString (&UnicodeString,
                          L"\\REGISTRY\\MACHINE\\SYSTEM\\CURRENTCONTROLSET\\SERVICES\\PCI");

    InitializeObjectAttributes(&ObjectAttributes,
                               &UnicodeString,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               (PSECURITY_DESCRIPTOR) NULL);

    status = ZwOpenKey (&BaseHandle,
                        KEY_READ,
                        &ObjectAttributes);

    if (!NT_SUCCESS(status)) {
        return;
    }

    // Get the right key

    RtlInitUnicodeString (&UnicodeString,
                          L"Debug");

    InitializeObjectAttributes(&ObjectAttributes,
                               &UnicodeString,
                               OBJ_CASE_INSENSITIVE,
                               BaseHandle,
                               (PSECURITY_DESCRIPTOR) NULL);

    status = ZwCreateKey (&Handle,
                          KEY_READ,
                          &ObjectAttributes,
                          0,
                          (PUNICODE_STRING) NULL,
                          REG_OPTION_VOLATILE,
                          &disposition);

    ZwClose(BaseHandle);
    BaseHandle = Handle;

    ASSERT(disposition == REG_CREATED_NEW_KEY);

    if (!NT_SUCCESS(status)) {
        return;
    }

    for (i = 0;
         i < MAX_DEBUGGING_DEVICES_SUPPORTED;
         i++) {

        if (HalpPciDebuggingDevice[i].u.bits.Reserved1 == TRUE) {

            //
            // This entry is populated.  Create a key for it.
            //

            RtlInitUnicodeString (&UnicodeString,
                                  L"0");

            (*(PCHAR)&(UnicodeString.Buffer[0])) += i;

            InitializeObjectAttributes(&ObjectAttributes,
                                       &UnicodeString,
                                       OBJ_CASE_INSENSITIVE,
                                       BaseHandle,
                                       (PSECURITY_DESCRIPTOR) NULL);

            status = ZwCreateKey (&Handle,
                                  KEY_READ,
                                  &ObjectAttributes,
                                  0,
                                  (PUNICODE_STRING) NULL,
                                  REG_OPTION_VOLATILE,
                                  &disposition);

            ASSERT(disposition == REG_CREATED_NEW_KEY);

            //
            // Fill in the values below this key.
            //

            bus = HalpPciDebuggingDevice[i].u.bits.BusNumber;

            RtlInitUnicodeString (&UnicodeString,
                                  L"Bus");

            status = ZwSetValueKey (Handle,
                                    &UnicodeString,
                                    0,
                                    REG_DWORD,
                                    &bus,
                                    sizeof(ULONG));

            //ASSERT(NT_SUCCESS(status));

            slot.u.AsULONG = 0;
            slot.u.bits.FunctionNumber = HalpPciDebuggingDevice[i].u.bits.FunctionNumber;
            slot.u.bits.DeviceNumber = HalpPciDebuggingDevice[i].u.bits.DeviceNumber;

            RtlInitUnicodeString (&UnicodeString,
                                  L"Slot");

            status = ZwSetValueKey (Handle,
                                    &UnicodeString,
                                    0,
                                    REG_DWORD,
                                    &slot.u.AsULONG,
                                    sizeof(ULONG));

            //ASSERT(NT_SUCCESS(status));

            ZwClose(Handle);
        }
    }

    ZwClose(BaseHandle);
    return;
}

NTSTATUS
HalpConfigurePciBridge(
    IN      PDEBUG_DEVICE_DESCRIPTOR  PciDevice,
    IN      ULONG   Bus,
    IN      ULONG   Slot,
    IN      ULONG   IoMin,
    IN      ULONG   IoMax,
    IN      ULONG   MemMin,
    IN      ULONG   MemMax,
    IN      ULONG   BusMin,
    IN      ULONG   BusMax,
    IN OUT  PPCI_COMMON_CONFIG PciData
    )
{
    USHORT  memUnits = 0;
    ULONG   memSize;

    PciData->u.type1.PrimaryBus = (UCHAR)Bus;
    PciData->u.type1.SecondaryBus = (UCHAR)BusMin;
    PciData->u.type1.SubordinateBus = (UCHAR)(MIN(BusMax, (BusMin + 2)));

    PciData->Command &= ~PCI_ENABLE_BUS_MASTER;

  //DbgPrint("HalpConfigurePciBridge: P: %x  S: %x  S: %x\n"
  //         "\tI/O  %x-%x  Mem %x-%x  Bus %x-%x\n",
  //         PciData->u.type1.PrimaryBus,
  //         PciData->u.type1.SecondaryBus,
  //         PciData->u.type1.SubordinateBus,
  //         IoMin, IoMax,
  //         MemMin, MemMax,
  //         BusMin, BusMax);

    //
    // Only enable I/O on the bridge if we are looking for
    // something besides a 1394 controller.
    //

    if (!((PciDevice->BaseClass == PCI_CLASS_SERIAL_BUS_CTLR) &&
          (PciDevice->SubClass == PCI_SUBCLASS_SB_IEEE1394))) {

        if (((IoMax & 0xf000) - (IoMin & 0xf000)) >= 0X1000) {

            //
            // There is enough I/O space here to enable
            // an I/O window.
            //

            PciData->u.type1.IOBase =
                (UCHAR)((IoMax & 0xf000) >> 12) - 1;
            PciData->u.type1.IOLimit = PciData->u.type1.IOBase;

            PciData->Command |= PCI_ENABLE_IO_SPACE;
            PciData->Command |= PCI_ENABLE_BUS_MASTER;
        }
    }

    //
    // Enable a memory window if possible.
    //

    memSize = ((MemMax + 1) & 0xfff00000) - (MemMin & 0xfff00000);

    if (memSize >= 0x100000) {

        memUnits = 1;
    }

    if (memSize >= 0x400000) {

        memUnits = 4;
    }

    if (memUnits > 0) {

        //
        // There is enough space.
        //

        PciData->u.type1.MemoryBase =
            (USHORT)((MemMax & 0xfff00000) >> 16) - (memUnits << 4);

        PciData->u.type1.MemoryLimit = PciData->u.type1.MemoryBase + ((memUnits - 1) << 4);

        PciData->Command |= PCI_ENABLE_MEMORY_SPACE;
        PciData->Command |= PCI_ENABLE_BUS_MASTER;

    }

    if (PciData->Command & PCI_ENABLE_BUS_MASTER) {

        HalpPhase0SetPciDataByOffset(Bus,
                                     Slot,
                                     PciData,
                                     0,
                                     0x24);

        return STATUS_SUCCESS;

    } else {
        return STATUS_UNSUCCESSFUL;
    }
}

VOID
HalpUnconfigurePciBridge(
    IN  ULONG   Bus,
    IN  ULONG   Slot
    )
{
    UCHAR   buffer[0x20] = {0};

    //
    // Zero the command register.
    //

    HalpPhase0SetPciDataByOffset(Bus,
                                 Slot,
                                 buffer,
                                 FIELD_OFFSET (PCI_COMMON_CONFIG, Command),
                                 2);

    //
    // Zero the address space and bus number registers.
    //

    HalpPhase0SetPciDataByOffset(Bus,
                                 Slot,
                                 buffer,
                                 FIELD_OFFSET (PCI_COMMON_CONFIG, u),
                                 0x20);
}



BOOLEAN
HalpValidateCardbusSocketRegs(
    IN PCARDBUS_SOCKET_REGS SocketRegs
    )
/*++

Routine Description:

    This routine looks to make sure the cardbus socket registers look
    reasonable, and also that there is a card in the slot.

Arguments:

    SocketRegs - virtual address of mapped socket registers

Return Value:

    returns TRUE if everything looks ok, FALSE otherwise

--*/
{
    ULONG mask;

    //
    // First verify there are no reserved bits on
    //

    if ((SocketRegs->Event & 0xFFFFFFF0) ||
        (SocketRegs->Mask & 0xFFFFFFF0) ||
        (SocketRegs->PresentState & 0x0FFF0000) ||
        (SocketRegs->ForceEvent) ||
        (SocketRegs->Control & 0xFFFFFF00)) {

        //
        // Some bits we don't expect to be on were on
        //
        return FALSE;
    }

    if ((SocketRegs->PresentState & SKTSTATE_3VSOCKET) == 0) {
        //
        // need to have a 3.3v socket for cardbus
        //
        return FALSE;
    }

    //
    // Stop here if there is no CardBus card in the slot
    //
    if ((SocketRegs->PresentState & SKTSTATE_CARDTYPE_MASK) != SKTSTATE_CBCARD) {
        return FALSE;
    }

    //
    // Also look to make sure this isn't on
    //

    if (SocketRegs->PresentState & SKTSTATE_NOTACARD) {
        return FALSE;
    }

    return TRUE;
}



NTSTATUS
HalpConfigureCardBusBridge(
    IN      PDEBUG_DEVICE_DESCRIPTOR  PciDevice,
    IN      ULONG   Bus,
    IN      ULONG   Slot,
    IN      ULONG   IoMin,
    IN      ULONG   IoMax,
    IN      ULONG   MemMin,
    IN      ULONG   MemMax,
    IN      ULONG   BusMin,
    IN      ULONG   BusMax,
    IN OUT  PPCI_COMMON_CONFIG PciData
    )
{
    NTSTATUS status = STATUS_UNSUCCESSFUL;
    ULONG   ulTemp;
    ULONG SocketRegBase, origSocketRegBase = 0;
    USHORT BridgeControl = 0;
    PCARDBUS_SOCKET_REGS SocketRegs;
    PHYSICAL_ADDRESS physicalAddress;
    ULONG bytesRead;
    USHORT command, origCmd;
    UCHAR capPtr = 0;
    PCI_PM_CAPABILITY pmCap;
    BOOLEAN cmdRegChanged = FALSE;
    BOOLEAN socketRegChanged = FALSE;
    BOOLEAN socketRegConfigured = FALSE;


    try{

        //
        // First look for a power management capability on this controller, and
        // if it exists (it should), put the cardbus controller into D0
        //

        bytesRead = HalpPhase0GetPciDataByOffset(Bus, Slot, &capPtr,
                                                 FIELD_OFFSET (PCI_COMMON_CONFIG, u.type2.CapabilitiesPtr), 1);

        if (bytesRead != 1) {
            // if we can't do this, things must be just too broken
            leave;
        }

        while (capPtr) {
            UCHAR capHeader[2];

            //
            // loop through the capabilities list and look for power management
            //

            if ((capPtr & 3) || (capPtr < 0x40)) {
                //
                // the capabilities pointer isn't valid
                //
                leave;
            }


            bytesRead = HalpPhase0GetPciDataByOffset(Bus, Slot, &capHeader, capPtr, 2);

            if (bytesRead != 2) {
                leave;
            }

            if (capHeader[0] == PCI_CAPABILITY_ID_POWER_MANAGEMENT) {
                //
                // found it
                //
                break;
            }

            if (capPtr == capHeader[1]) {
                //
                // this is bad config data. Avoid an infinite loop
                //
                leave;
            }

            capPtr = capHeader[1];
        }


        if (capPtr) {

            bytesRead = HalpPhase0GetPciDataByOffset(Bus, Slot, &pmCap, capPtr, sizeof(pmCap));

            if ((bytesRead == sizeof(pmCap)) &&
                (pmCap.Header.CapabilityID == PCI_CAPABILITY_ID_POWER_MANAGEMENT) &&
                (pmCap.PMCSR.ControlStatus.PowerState != 0)) {

                pmCap.PMCSR.ControlStatus.PowerState = 0; // set to D0

                HalpPhase0SetPciDataByOffset(Bus,
                                             Slot,
                                             &pmCap.PMCSR.ControlStatus,
                                             capPtr + FIELD_OFFSET(PCI_PM_CAPABILITY,PMCSR.ControlStatus),
                                             sizeof(pmCap.PMCSR.ControlStatus));

                HalpKdStallExecution(1000);
            }
        }

        //
        // Turn off legacy mode base address... this really should be done
        // via ACPI _INIT. This may not be sufficient to put the host in
        // cardbus mode.
        //
        ulTemp = 0;
        HalpPhase0SetPciDataByOffset(Bus,
                                     Slot,
                                     &ulTemp,
                                     CARDBUS_LEGACY_MODE_BASE_ADDR,
                                     4);

        //
        // save away original value of command register, socket reg base
        //

        bytesRead = HalpPhase0GetPciDataByOffset(Bus,
                                                 Slot,
                                                 &origCmd,
                                                 FIELD_OFFSET (PCI_COMMON_CONFIG, Command),
                                                 2);

        if (bytesRead != 2) {
            leave;
        }

        bytesRead = HalpPhase0GetPciDataByOffset(Bus,
                                                 Slot,
                                                 &origSocketRegBase,
                                                 FIELD_OFFSET (PCI_COMMON_CONFIG, u.type2.SocketRegistersBaseAddress),
                                                 4);

        if (bytesRead != 4) {
            leave;
        }

        //
        // Turn on socket registers in a suitable location
        //

        if (origSocketRegBase) {
            //
            // bios has configured socket reg base... see if it is working
            //
            physicalAddress.HighPart = 0;
            physicalAddress.LowPart = origSocketRegBase;
            SocketRegs = HalpMapPhysicalMemory64(physicalAddress, 1);

            if (!SocketRegs) {
                leave;
            }

            command = origCmd | PCI_ENABLE_MEMORY_SPACE;

            if (command != origCmd) {
                HalpPhase0SetPciDataByOffset(Bus,
                                             Slot,
                                             &command,
                                             FIELD_OFFSET (PCI_COMMON_CONFIG, Command),
                                             2);
                cmdRegChanged = TRUE;
            }

            HalpKdStallExecution(600);

            //
            // make sure it looks like cardbus socket registers
            //

            if (HalpValidateCardbusSocketRegs(SocketRegs)) {
                socketRegConfigured = TRUE;
                SocketRegBase = origSocketRegBase;
            } else {
                //
                // This didn't work... we'll try it again in a moment with a different address
                //
                HalpPhase0SetPciDataByOffset(Bus,
                                             Slot,
                                             &origCmd,
                                             FIELD_OFFSET (PCI_COMMON_CONFIG, Command),
                                             2);
                cmdRegChanged = FALSE;
            }
        }

        //
        // If the socket regs weren't working where they were originally configured by
        // the bios, or if the bios didn't configure them, we will configure them here
        //

        if (!socketRegConfigured) {
            SocketRegBase = ((MemMin + 0xfff) & 0xfffff000);

            if ((SocketRegBase + 0x1000) >= MemMax) {
                leave;
            }

            //
            // Adjust MemMin to allow the socket registers to remain visible
            //
            MemMin = SocketRegBase + 0x1000;

            HalpPhase0SetPciDataByOffset(Bus,
                                         Slot,
                                         &SocketRegBase,
                                         FIELD_OFFSET (PCI_COMMON_CONFIG, u.type2.SocketRegistersBaseAddress),
                                         4);
            socketRegChanged = TRUE;

            physicalAddress.HighPart = 0;
            physicalAddress.LowPart = SocketRegBase;
            SocketRegs = HalpMapPhysicalMemory64(physicalAddress, 1);

            if (!SocketRegs) {
                leave;
            }

            command = origCmd | PCI_ENABLE_MEMORY_SPACE;

            if (command != origCmd) {
                HalpPhase0SetPciDataByOffset(Bus,
                                             Slot,
                                             &command,
                                             FIELD_OFFSET (PCI_COMMON_CONFIG, Command),
                                             2);
                cmdRegChanged = TRUE;
            }

            HalpKdStallExecution(600);

            if (!HalpValidateCardbusSocketRegs(SocketRegs)) {
                //
                // The registers don't look right
                //
                leave;
            }

        }

        PciData->u.type2.SocketRegistersBaseAddress = SocketRegBase;

        //
        // make sure events are disabled
        //
        SocketRegs->Mask = 0;

        //
        // power up the card
        //

        SocketRegs->Control = SKTPOWER_VCC_033V | SKTPOWER_VPP_033V;

        HalpKdStallExecution(600);

        //
        // Make sure CBRST is off
        //

        HalpPhase0GetPciDataByOffset(Bus,
                                     Slot,
                                     &BridgeControl,
                                     FIELD_OFFSET (PCI_COMMON_CONFIG, u.type2.BridgeControl),
                                     2);

        if (BridgeControl & CARDBUS_BRIDGE_CONTROL_RESET) {

            BridgeControl &= ~CARDBUS_BRIDGE_CONTROL_RESET;
            HalpPhase0SetPciDataByOffset(Bus,
                                         Slot,
                                         &BridgeControl,
                                         FIELD_OFFSET (PCI_COMMON_CONFIG, u.type2.BridgeControl),
                                         2);
        }


        PciData->u.type2.PrimaryBus = (UCHAR)Bus;
        PciData->u.type2.SecondaryBus = (UCHAR)BusMin;
        PciData->u.type2.SubordinateBus = (UCHAR)(MIN(BusMax, (BusMin + 2)));

        PciData->Command &= ~PCI_ENABLE_BUS_MASTER;

        //DbgPrint("HalpConfigureCardBusBridge: P: %x  S: %x  S: %x\n"
        //         "\tI/O  %x-%x  Mem %x-%x  Bus %x-%x\n",
        //         PciData->u.type2.PrimaryBus,
        //         PciData->u.type2.SecondaryBus,
        //         PciData->u.type2.SubordinateBus,
        //         IoMin, IoMax,
        //         MemMin, MemMax,
        //         BusMin, BusMax);

        //
        // Only enable I/O on the bridge if we are looking for
        // something besides a 1394 controller.
        //

        if (!((PciDevice->BaseClass == PCI_CLASS_SERIAL_BUS_CTLR) &&
              (PciDevice->SubClass == PCI_SUBCLASS_SB_IEEE1394))) {

            PciData->u.type2.Range[2].Base = IoMin;
            PciData->u.type2.Range[2].Limit = IoMax & 0xffc;

            PciData->Command |= PCI_ENABLE_IO_SPACE;
            PciData->Command |= PCI_ENABLE_BUS_MASTER;
        }

        //
        // Enable a memory window if possible.
        //

        if (MemMax > MemMin) {

            PciData->u.type2.Range[0].Base = MemMin;
            PciData->u.type2.Range[0].Limit = MemMax & 0xfffff000;

            PciData->Command |= PCI_ENABLE_MEMORY_SPACE;
            PciData->Command |= PCI_ENABLE_BUS_MASTER;

        }


        if ((PciData->Command & PCI_ENABLE_BUS_MASTER) == 0) {
            leave;
        }

        HalpPhase0SetPciDataByOffset(Bus,
                                     Slot,
                                     PciData,
                                     0,
                                     0x3c);
        status = STATUS_SUCCESS;


    } finally {

        if (!NT_SUCCESS(status)) {
            if (cmdRegChanged) {
                HalpPhase0SetPciDataByOffset(Bus,
                                             Slot,
                                             &origCmd,
                                             FIELD_OFFSET (PCI_COMMON_CONFIG, Command),
                                             2);
            }

            //
            // restore socket register base
            //
            if (socketRegChanged) {
                HalpPhase0SetPciDataByOffset(Bus,
                                             Slot,
                                             &origSocketRegBase,
                                             FIELD_OFFSET (PCI_COMMON_CONFIG, u.type2.SocketRegistersBaseAddress),
                                             4);
            }
        }
    }
    return status;
}


VOID
HalpUnconfigureCardBusBridge(
    IN  ULONG   Bus,
    IN  ULONG   Slot
    )
{
    UCHAR   buffer[0x2c] = {0};
    ULONG SocketRegBase = 0xffffffff;
    PCARDBUS_SOCKET_REGS SocketRegs;
    PHYSICAL_ADDRESS physicalAddress;

    HalpPhase0GetPciDataByOffset(Bus,
                                 Slot,
                                 &SocketRegBase,
                                 FIELD_OFFSET (PCI_COMMON_CONFIG, u.type2.SocketRegistersBaseAddress),
                                 4);

    if (SocketRegBase) {
        physicalAddress.HighPart = 0;
        physicalAddress.LowPart = SocketRegBase;
        SocketRegs = HalpMapPhysicalMemory64(physicalAddress, 1);

        //
        // Turn power back off
        //

        if (SocketRegs) {
            SocketRegs->Control = 0;
        }

    }
    //
    // Zero the command register.
    //

    HalpPhase0SetPciDataByOffset(Bus,
                                 Slot,
                                 buffer,
                                 FIELD_OFFSET (PCI_COMMON_CONFIG, Command),
                                 2);

    //
    // Zero the address space and bus number registers.
    //

    HalpPhase0SetPciDataByOffset(Bus,
                                 Slot,
                                 buffer,
                                 FIELD_OFFSET (PCI_COMMON_CONFIG, u),
                                 0x2c);
}

ULONG
HalpKdStallExecution(
    ULONG   LoopCount
    )
{
    ULONG i,j,b,k,l;

    b = 1;

    for (k=0;k<LoopCount;k++) {

        for (i=1;i<100000;i++) {

            PAUSE_PROCESSOR
            b=b* (i>>k);

        }

    };

    return b;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\inc\chiphacks.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    chiphacks.h

Abstract:

    Implements utilities for finding and hacking
    various chipsets

Author:

    Jake Oshins (jakeo) 10/02/2000

Environment:

    Kernel mode only.

Revision History:

--*/

#include "halp.h"
#include "pci.h"

#define PM_TIMER_HACK_FLAG          1
#define DISABLE_HIBERNATE_HACK_FLAG 2
#define SET_ACPI_IRQSTACK_HACK_FLAG 4
#define WHACK_ICH_USB_SMI_HACK_FLAG 8


//
// The format of the registry hack entry is as follows
//
// 31..RevId..24 | 23..hacks..12 | 11..hacks..0
//
// There's room to define 8 more hack flags, and this allows us to specify
// a revision, at and above which we apply a different set of flags, this
// simple approach, while maintaining compatibility with the old registy
// hacks, allows both room for growth, and provides a mechanism for removing
// hacks based on chip revision
//
#define HACK_REVISION(hf) ((hf) >> 24)
#define BASE_HACKS(hf) ((hf) & 0xFFF)
#define REVISED_HACKS(hf) (((hf) & 0xFFF000) >> 12)


NTSTATUS
HalpGetChipHacks(
    IN  USHORT  VendorId,
    IN  USHORT  DeviceId,
    IN  UCHAR   RevisionId OPTIONAL,
    OUT ULONG   *HackFlags
    );

VOID
HalpStopOhciInterrupt(
    ULONG               BusNumber,
    PCI_SLOT_NUMBER     SlotNumber
    );

VOID
HalpStopUhciInterrupt(
    ULONG               BusNumber,
    PCI_SLOT_NUMBER     SlotNumber,
    BOOLEAN             ResetHostController
    );

VOID
HalpSetAcpiIrqHack(
    ULONG   Value
    );

VOID
HalpWhackICHUsbSmi(
    ULONG               BusNumber,
    PCI_SLOT_NUMBER     SlotNumber
    );

VOID
HalpClearSlpSmiStsInICH(
    VOID
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\inc\ntapic.inc ===
;/*++
;
;Module Name:
;
;    ntapic.inc
;
;Abstract:
;
;    This header file is intended to be included by any HAL
;    that uses APICs.
;
;Author:
;
;    Ron Mosgrove (Intel)
;
;Environment:
;
;    Kernel mode only.
;
;Revision History:
;
;    Separated out from pcmp_nt.inc -- 6-2-98 (jakeo)
;    
;
if 0        ; Begin C only code         */

#if !defined(_NTAPIC_INC_)

#define _NTAPIC_INC_ 1

//#define DEBUGGING       1

#ifndef DBGMSG
#ifdef DEBUGGING
extern CHAR Cbuf[];
#define DBGMSG(x) DbgPrint(x);
#else
#define DBGMSG(x)
#endif
#endif

//
//  To allow the user to specify command line options to the HAL.
//
#define USER_SETABLE_OPTIONS
// #define BUILD_FOR_OLD_IDW

//
//  Default BusType
//

#ifndef MCA
#define DEFAULT_PC_BUS      Eisa
#else
#define DEFAULT_PC_BUS      MicroChannel
#endif


//
//  Well known virtual address of local processor apic
//

#if defined(_WIN64)
#define LOCALAPIC   0xfffffffffffe0000
#else
#define LOCALAPIC   0xfffe0000
#endif

#define pLocalApic    ((ULONG volatile *) LOCALAPIC)
#define LOCAL_APIC(x) (*((ULONG volatile *)&pLocalApic[(x)/sizeof(ULONG)]))

//
//  Additional CpuFlags Bits used by NT in PC+MP Table
//
#define CPU_NT_STARTED      0x40    // CPU Has Been Started
#define CPU_NT_RUNNING      0x80    // CPU is Runing NT
#define MAX_PROCESSORS      32
#define MAX_CLUSTERS        15
#define MAX_IOAPICS         64

//
//  This OS specific structure holds useful MP information. This information
//  is obtained from the PC+MP table and stored here for convenience.
//
typedef struct HalpMpInfo {
    ULONG ApicVersion;      // 82489Dx or Not
    ULONG ProcessorCount;   // Number of Enabled Processors
    ULONG NtProcessors;     // Number of Running Processors
    ULONG BusCount;         // Number of buses in system
    ULONG IOApicCount;      // Number of Io Apics in system
    ULONG IntiCount;        // Number of Io Apic interrupt input entries
    ULONG LintiCount;       // Number of Local Apic interrupt input entries
    ULONG IMCRPresent;      // Indicates if the IMCR is present
    ULONG LocalApicBase;    // Base of local APIC
    PULONG IoApicBase[MAX_IOAPICS]; // The virtual addresses of the IoApics
    ULONG  IoApicPhys[MAX_IOAPICS]; // The physical addresses of the IoApics
#ifdef ACPI_HAL
    ULONG  IoApicIntiBase[MAX_IOAPICS];  // The 'number' of the first INTI  -- only used for ACPI
#else
    PPCMPPROCESSOR ProcessorEntryPtr;       // Ptr to 1st PC+MP processor entry
    PPCMPBUS       BusEntryPtr;             // Ptr to 1st PC+MP bus  entry
    PPCMPIOAPIC    IoApicEntryPtr;          // Ptr to 1st PC+MP IoApic entry
    PPCMPINTI      IntiEntryPtr;            // Ptr to 1st PC+MP Inti entry
    PPCMPLINTI     LintiEntryPtr;           // Ptr to 1st PC+MP Linti entry
    PMPS_EXTENTRY  ExtensionTable;          // Ptr to 1st extension table entry
    PMPS_EXTENTRY  EndOfExtensionTable;
#endif
} MP_INFO, *PMP_INFO;

typedef struct {
    PUCHAR                  PcMpType;
    BOOLEAN                 PhysicalInstance;
    UCHAR                   Level;
    INTERFACE_TYPE          NtType;
    PINSTALL_BUS_HANDLER    NewInstance;
    BUS_DATA_TYPE           NtConfig;
    ULONG                   BusExtensionSize;
} PCMPBUSTRANS, *PPCMPBUSTRANS;

#define CFG_MUST_BE         0x02
#define CFG_ERROR           0x80

#define CFG_HIGH            0x01
#define CFG_LOW             0x00

#define CFG_EDGE            0x00
#define CFG_LEVEL           0x01
#define CFG_MB_EDGE         (CFG_MUST_BE | CFG_EDGE)
#define CFG_MB_LEVEL        (CFG_MUST_BE | CFG_LEVEL)
#define CFG_ERR_EDGE        (CFG_ERROR | CFG_EDGE)
#define CFG_ERR_LEVEL       (CFG_ERROR | CFG_LEVEL)
#define CFG_ERR_MB_EDGE     (CFG_ERROR | CFG_MUST_BE | CFG_EDGE)
#define CFG_ERR_MB_LEVEL    (CFG_ERROR | CFG_MUST_BE | CFG_LEVEL)

#define CFG_TYPE(a)     (a & 1)

typedef union _INTERRUPT_DEST  {
    union _Cluster  {
        struct _Hw  {
            UCHAR   DestId:4;
            UCHAR   ClusterId:4;
        } Hw;
        UCHAR AsUchar;
    } Cluster;
    UCHAR   LogicalId;
} INTERRUPT_DEST, *PINTERRUPT_DEST;


#if defined(_X86_)

//
// The kernel leaves some space (64 byte) of the PCR for the HAL to use
// as it needs.  Currently this space is used for some efficiency in
// some of the MP specific code and is highly implementation-dependent.
//
typedef struct _HALPCR {
    UCHAR PcrNumber;   // Processor's number
    UCHAR ShortDpc;    // Short circut dpc interrupt
    UCHAR DpcPending;  // Dpc interrupt pending
    UCHAR Reserved;    // force dword alignment

    //
    // The next three dwords are used to manipulate the APIC counter
    //
    ULONG ApicClockFreqHz;   // Counter Freq in Hertz
    ULONG ApicClockFreqKhz;  // Counter Freq in Khertz (rounded)
    ULONG ProfileCountDown;  // Current Countdown Interval

    ULONGLONG TSCHz;         // Time stamp counter hertz

    ULONG PerfCounterLow;    // PerProcessor Counter
    ULONG PerfCounterHigh;
} HALPCR, *PHALPCR;

#elif defined(_AMD64_)

typedef struct _HALPCR {
    ULONG64 PerfCounter;
    ULONG64 TSCHz;		// time stamp counter frequency
    ULONG ProfileCountDown;	// current profile countdown interval
    ULONG ApicClockFreqHz;	// counter frequency
    ULONG StallScaleFactor;
    ULONG ApicId;               // APIC Id assigned this processor
} HALPCR, *PHALPCR;

C_ASSERT(sizeof(HALPCR) <= RTL_FIELD_SIZE(KPCR,HalReserved));

#else

#error "Platform not supported"

#endif

//
// The kernel leaves some space (64 byte) of the PCRB for the HAL to use
// as it needs.  Currently this space is used for some efficiency in
// some of the MP specific code and is highly implementation-dependent.
//

typedef struct {
    UCHAR           PCMPApicID;
    UCHAR           na[3];
} HALPRCB, *PHALPRCB;


#if defined(_AMD64_)

#define ZERO_VECTOR             0x00    // IRQL  0 placeholder
#define APC_VECTOR              0x1f    // IRQL  1 APC
#define DPC_VECTOR              0x2f    // IRQL  2 DPC

#define APIC_SPURIOUS_VECTOR    0x3f	// IRQL  3 Spurious handler

#define APIC_REBOOT_VECTOR      0x50    // IRQL  5 Vector used to reboot
#define APIC_GENERIC_VECTOR     0xC1    // IRQL 12 broadcast function call
#define APIC_CLOCK_VECTOR       0xD1    // IRQL 13 APIC INTI0 - CLOCK2_LEVEL
#define APIC_SYNCH_VECTOR       0xD1    // IRQL 13 IPI_LEVEL-1
#define APIC_IPI_VECTOR         0xE1    // IRQL 14 APIC IPI

#define APIC_FAULT_VECTOR       0xE3    // IRQL 14
#define POWERFAIL_VECTOR        0xEF    // IRQL 14 reserved. not used

#define APIC_PROFILE_VECTOR     0xFD    // IRQL 15
#define APIC_PERF_VECTOR        0xFE    // IRQL 15
#define NMI_VECTOR              0xFF    // IRQL 15

//
// The APIC hard-wires the four low-order bits of the spurious interrupt
// vector to 1.
//

C_ASSERT((APIC_SPURIOUS_VECTOR & 0x0f) == 0x0f);


#else

//
// interrupt vector definitions for C
//

#define ZERO_VECTOR             0x00    // IRQL 00 placeholder
#define APIC_SPURIOUS_VECTOR    0x1f    // IRQL    Spurious handler
#define APC_VECTOR              0x3D    // IRQL 01 APC
#define DPC_VECTOR              0x41    // IRQL 02 DPC
#define APIC_REBOOT_VECTOR      0x50    // IRQL    Vector used to reboot
#define APIC_GENERIC_VECTOR     0xC1    // IRQL 27 broadcast function call
#define APIC_CLOCK_VECTOR       0xD1    // IRQL 28 APIC INTI0 - CLOCK2_LEVEL

//
// If MP, define APIC_SYNCH_LEVEL as SYNCH_LEVEL, otherwise define
// to be the same as DPC_LEVEL.
//

#if (SYNCH_LEVEL != DISPATCH_LEVEL)

#define APIC_SYNCH_VECTOR       0xC1    // IRQL 28 IPI_LEVEL-1

#else

#define APIC_SYNCH_VECTOR       DPC_VECTOR // IRQL 02 if UNIPROCESSOR

#endif

#define APIC_IPI_VECTOR         0xE1    // IRQL 29 APIC IPI

#define APIC_FAULT_VECTOR       0xE3    //
#define POWERFAIL_VECTOR        0xEF    // IRQL 30 reserved. not used

#define APIC_PROFILE_VECTOR     0xFD    // IRQL 31
#define APIC_PERF_VECTOR        0xFE    // IRQL 31
#define NMI_VECTOR              0xFF    // IRQL 31

#endif

//
//  8259/ISP interrupt controller register addresses
//

#define PIC1_PORT0              0x20
#define PIC1_PORT1              0x21
#define PIC2_PORT0              0xA0
#define PIC2_PORT1              0xA1

#define PIC_SLAVE_IRQ           2
#define RTC_IRQ                 8

#define PIC1_ELCR_PORT          0x04D0  // ISP edge/level control registers
#define PIC2_ELCR_PORT          0x04D1

#define PIC1_SPURIOUS_VECTOR    0x37

//
// Defines for HalpFeatureBits
//

extern ULONG HalpFeatureBits;

//
//
//

#if defined(_AMD64_) && defined(NT_UP)

#define HalpAcquireHighLevelLock(lock) HalpDisableInterrupts()
#define HalpReleaseHighLevelLock(lock,irql) HalpRestoreInterrupts(irql)

#else

ULONG FASTCALL HalpAcquireHighLevelLock(PKSPIN_LOCK);
VOID  FASTCALL HalpReleaseHighLevelLock(PKSPIN_LOCK, ULONG);

#endif

extern KSPIN_LOCK   HalpAccountingLock;
extern KAFFINITY    HalpActiveProcessors;

//
// Prototypes
//

#define MAX_INTI         (MAX_IOAPICS*32) // Max interrupt inputs from APICs
#define MAX_SOURCE_IRQS  MAX_INTI         // Max different interrupts supported

//
// HalVectorToIDTEntry(vector) is defined in i386.h, because the kernel needs
// it.
#define MAX_NODES                       MAX_PROCESSORS
#define HalpVectorToNode(vector)        ((vector)>>8)
#define HalpVector(node, idtentry)      ((node)<<8|(idtentry))

extern struct HalpMpInfo HalpMpInfoTable;
extern UCHAR  HalpMaxProcsPerCluster;

extern BOOLEAN  HalpELCRChecked;
extern USHORT   HalpGlobal8259Mask;
extern USHORT   HalpVectorToINTI[];
extern UCHAR    HalpInitLevel[4][4];
extern UCHAR    HalpDevPolarity[4][2];
extern UCHAR    HalpDevLevel[2][4];

//
// Initialized from MPS table
//

typedef struct _INTI_INFO {
    UCHAR   Type:4;
    UCHAR   Level:2;
    UCHAR   Polarity:2;
    UCHAR   Destinations;
    USHORT  Entry;
} INTI_INFO, *PINTI_INFO;

extern INTI_INFO    HalpIntiInfo[];
extern USHORT       HalpMaxApicInti[];
extern PCMPBUSTRANS HalpTypeTranslation[];

extern ULONG HalpIpiClock;

#define BusIrq2Id(bus,no,irq)           \
    ((bus << 16) | (no << 8) | irq)
    
#define Id2BusIrq(id)                   \
    (id & 0xff)

VOID
HalpInitIntiInfo (
    VOID
    );

ULONG
HalpGetIoApicId(
    ULONG   ApicNo
    );
    
VOID
HalpSet8259Mask(
    IN USHORT Mask
        );

VOID
HalpInitializeLocalUnit (
    VOID
    );

VOID
HalpInitializeIOUnits (
    VOID
    );

VOID
HalpRestoreIoApicRedirTable (
    VOID
    );

VOID
HalpEnableNMI (
    VOID
    );

VOID
HalpEnableLocalNmiSources(
    VOID
    );
    
VOID
HalpSet8259Mask(
    IN USHORT Mask
    );

BOOLEAN
HalpGetApicInterruptDesc (
    IN INTERFACE_TYPE BusType,
    IN ULONG BusNumber,
    IN ULONG BusInterruptLevel,
    OUT PUSHORT PcMpInti
    );

VOID
HalpCheckELCR (
    VOID
    );

VOID
HalpGenericCall (
    VOID        (*Fnc)(ULONG_PTR),
    ULONG       Context,
    KAFFINITY   Processors
    );

VOID
HalpPollForBroadcast (
    VOID
    );

ULONG
FASTCALL
HalpWaitForPending (
    IN ULONG    Count,
    IN volatile ULONG *LuICR
    );

//
// Warning 4131 is "uses old-style declarator"
//

#pragma warning(disable:4131)

//
// Warning 4218 is "nonstandard extension used"
//

#pragma warning(disable:4218)

HAL_INTERRUPT_SERVICE_PROTOTYPE(HalpPerfInterrupt);

VOID
HalpEnablePerfInterupt (
    ULONG_PTR Context
    );

VOID
HalpEnableNMI (
    VOID
    );

NTSTATUS
HalpSetSystemInformation (
    IN HAL_SET_INFORMATION_CLASS    InformationClass,
    IN ULONG     BufferSize,
    IN PVOID     Buffer
    );
    
ULONG
HalpInti2BusInterruptLevel(
    ULONG   Inti
    );    

VOID
HalpUnMapIOApics(
    VOID
    );
    
VOID
HalpInitializeIOUnits (
    VOID
    );
    
VOID
HalpPostSleepMP(
    IN LONG           NumberProcessors,
    IN volatile PLONG Number
    );

VOID
HalpSetRedirEntry (
    IN USHORT InterruptInput,
    IN ULONG  Entry,
    IN ULONG  Destination
    );

VOID
HalpGetRedirEntry (
    IN USHORT InterruptInput,
    IN PULONG Entry,
    IN PULONG Destination
    );

/*++

HalpStallWhileApicBusy (
    VOID
    )

Routine Description:

    This routine waits until the local apic has completed sending
    an IPI.

Parameters:

    None.

Return Value:

    None.

--*/

#define HalpStallWhileApicBusy() \
    while ((LOCAL_APIC(LU_INT_CMD_LOW) & DELIVERY_PENDING) != 0) { }


#if defined(_AMD64_)

#define HalpGetHalPcr(pcr) ((PHALPCR)(pcr->HalReserved))
#define HalpGetCurrentHalPcr() HalpGetHalPcr(KeGetPcr())

#endif

#endif	// _NTAPIC_INC_


/*
endif
;
;  Begin assembly part of the definitions
;

;
;  Well known virtual address of local processor apic
;

LOCALAPIC   equ     0fffe0000h
APIC        equ     ds:[LOCALAPIC]

DEBUGGING       equ 0


if DEBUGGING
IRQL_METRICS        equ     0
endif
;
;  To allow the user to specify command line options to the HAL.
;
USER_SETABLE_OPTIONS    equ 1

MAX_PROCESSORS equ 32
MAX_NODES equ MAX_PROCESSORS
MAX_IOAPICS equ 64
;
;  This OS specific structure holds useful MP information. This information
;  is obtained from the PC+MP table and stored here for convenience.
;

HalpMpInfo struc
    ApicVersion     dd  0   ; 82489Dx or Not
    ProcessorCount  dd  0   ; Number of Enabled Processors
    NtProcessors    dd  0   ; Number of Running Processors
    BusCount        dd  0   ; Number of buses in system
    IOApicCount     dd  0   ; Number of Io Apics in system
    IntiCount       dd  0   ; Num of Io Apic interrupt inputs
    LintiCount      dd  0   ; Num of Local Apic interrupt inputs
    IMCRPresent     dd  0   ; Indicates if the IMCR is present
    LocalApicBase   dd  0   ; Base of local apic
    IoApicBase      dd  MAX_IOAPICS  dup (0) ; Virtual addresses of IoApics
    IoApicPhys      dd  MAX_IOAPICS  dup (0) ; Physical addresses of IoApics
ifdef ACPI_HAL
    IoApicIntiBase dd MAX_IOAPICS  dup (0) ; ACPI only.  First GSIV.
else
    ProcessorEntryPtr   dd  0   ; Ptr to 1st PC+MP processor entry
    BusEntryPtr     dd  0   ; Ptr to 1st PC+MP bus  entry
    IoApicEntryPtr  dd  0   ; Ptr to 1st PC+MP IoApic entry
    IntiEntryPtr    dd  0   ; Ptr to 1st PC+MP Inti entry
    LintiEntryPtr   dd  0   ; Ptr to 1st PC+MP Linti entry
    ExtensionTable  dd  0   ; Ptr to 1st extension table entry
    EndExtensionTable dd  0 ; Ptr to 1st extension table entry
endif
HalpMpInfo ends


;
;  interrupt vector definitions for assembler
;

ZERO_VECTOR             equ     000h    ;  IRQL 00 placeholder
APIC_SPURIOUS_VECTOR    equ     01fh    ;  Vector used for spurious handler
APC_VECTOR              equ     03Dh    ;  IRQL 01 APC
DPC_VECTOR              equ     041h    ;  IRQL 02 DPC
APIC_REBOOT_VECTOR      equ     050h    ;  Vector used to reboot
DEVICE_LEVEL1           equ     051h
DEVICE_LEVEL2           equ     061h
DEVICE_LEVEL3           equ     071h
DEVICE_LEVEL4           equ     081h
DEVICE_LEVEL5           equ     091h
DEVICE_LEVEL6           equ     0A1h
DEVICE_LEVEL7           equ     0B1h
APIC_GENERIC_VECTOR     equ     0C1h    ;  IRQL 27 broadcast function call
APIC_CLOCK_VECTOR       equ     0D1h    ;  IRQL 28 APIC INTI0 - CLOCK2_LEVEL

if SYNCH_LEVEL-DISPATCH_LEVEL

APIC_SYNCH_VECTOR       equ     0C1h    ;  IRQL 28 IPI_LEVEL-1

else

APIC_SYNCH_VECTOR       equ     DPC_VECTOR

endif

APIC_IPI_VECTOR         equ     0E1h    ;  IRQL 29 APIC IPI

APIC_FAULT_VECTOR       equ     0E3h    ;
POWERFAIL_VECTOR        equ     0EFh    ;  IRQL 30 reserved

APIC_PROFILE_VECTOR     equ     0FDh    ;  IRQL 27
APIC_PERF_VECTOR        equ     0FEh    ;  IRQL 27
NMI_VECTOR              equ     0FFh    ;  IRQL 31

HAL_PROFILE_LEVEL       equ     HIGH_LEVEL

;
;  8259/ISP interrupt controller register addresses
;

PIC1_PORT0          equ     020H
PIC1_PORT1          equ     021H
PIC2_PORT0          equ     0A0H
PIC2_PORT1          equ     0A1H

PIC1_ELCR_PORT      equ     04D0H   ; ISP edge/level control registers
PIC2_ELCR_PORT      equ     04D1H

;
; Initialization control words for the PICs
;

ICW1_ICW4_NEEDED                equ     01H
ICW1_CASCADE                    equ     00H
ICW1_INTERVAL8                  equ     00H
ICW1_LEVEL_TRIG                 equ     08H
ICW1_EDGE_TRIG                  equ     00H
ICW1_ICW                        equ     10H

ICW4_8086_MODE                  equ     001H
ICW4_AUTO_EOI                   equ     002H
ICW4_NORM_EOI                   equ     000H
ICW4_NON_BUF_MODE               equ     000H
ICW4_SPEC_FULLY_NESTED          equ     010H
ICW4_NOT_SPEC_FULLY_NESTED      equ     000H

PIC_SLAVE_IRQ                   equ     2

PIC1_BASE                       equ     30H
PIC2_BASE                       equ     38H
PIC_CLOCK_VECTOR                equ     30H
PIC_DMA_VECTOR                  equ     3DH
PIC1_SPURIOUS_VECTOR            equ     37H
PIC2_SPURIOUS_VECTOR            equ     3FH

;
;  Operation control words for the PICs
;

OCW2_NON_SPECIFIC_EOI   equ     020H
OCW2_SPECIFIC_EOI       equ     060H
OCW3_READ_ISR           equ     0BH
OCW3_READ_IRR           equ     0AH
OCW3_READ_POLLED        equ     0CH

;
; A couple of definitions that shouldn't change on a Compatible
;

TimerPicInti        equ     0
DmaPic2Inti         equ     5
SlavePicInti        equ     2
DmaPicInti          equ     13  ; DMA input relative to 0

cr                  equ 0ah
lf                  equ 0dh

;
; The kernel leaves some space (64 byte) of the PCR for the HAL to use
; as it needs.  Currently this space is used for some efficiency in
; some of the MP specific code and is highly implementation-dependent.
;


PcrE struc
    PcrNumber           db      0           ; Processor's number
    ShortDpc            db      0           ; Short circut dpc interrupt
    DpcPending          db      0           ; Dpc interrupt pending

                        db      0               ; force dword alignment
    ;
    ;   The next three dwords are used to manipulate the APIC counter
    ;

    ApicClockFreqHz     dd      0           ; Counter Freq in Hertz
    ApicClockFreqKhz    dd      0           ; Counter Freq in Khertz (rounded)
    ProfileCountDown    dd      0           ; Current Countdown Interval

    TSCHz               dq      0           ; Time stamp counter hertz


    PerfCounterLow      dd      0           ; PerProcessor Counter
    PerfCounterHigh     dd      0           ;
    ; ProfileCountLast    dd      0
    
    OEMPcr              db      size OEMPcr dup(?)

PcrE ends

PrcbE struc
    PrcbPCMPApicID      db      0           ; Processor's PCMP ApicID
                        db      3 dup (0)       ; force dword alignment
PrcbE ends


MsrTSC  equ     10h

;++
;
;   STALL_WHILE_APIC_BUSY
;
;   Wait for the APIC DELIVERY_PENDING bit to be clear
;
;--

STALL_WHILE_APIC_BUSY macro
    local   a, b
if 0

        push    eax
        mov     eax, 5000h

a:      test    dword ptr APIC[LU_INT_CMD_LOW],DELIVERY_PENDING
        jz      short b

        dec     eax
        jnz     short a

        int 3
        jmp     short a

b:      pop     eax

else

a:      test    dword ptr APIC[LU_INT_CMD_LOW],DELIVERY_PENDING
        jnz     short a

endif
endm

;++
;
;   APICFIX
;
;   Macro Description:
;
;       For internal testing use
;
;   Arguments:
;
;       None
;
;--

APICFIX macro reg1
    ;    inc     dword ptr PCR[PcKernel]           ; Count # of times patched
endm

;++
;
;   CHECKTPR
;
;   Macro Description:
;
;       For internal testing use
;
;   Arguments:
;
;       None
;
;--

CHECKTPR macro reg1, reg2
if DBG
        cmp     reg1, reg2
        je      short @f
        int 3
@@:
endif
endm

;++
;
;   IODELAY
;
;   Macro Description:
;
;       This macro delays the CPU just a little so the PIC has time to settle
;       between IO port accesses.  Current mechanism is to read an APIC local
;       unit register (eax is saved).  Note that PUSHF/POPF is worth 10 clocks.
;
;   Arguments:
;
;       None
;
;--

IODELAY macro
        pushf
        popf
        jmp     $+2
endm

;++
;
;   SET_8259_MASK
;
;   Macro Description:
;
;       This macro sets the 8259 PIC interrupt mask register with the mask
;       passed from eax register.  Bits 7:0 are the mask for the master PIC
;       and bits 15:8 are the mask for the slave PIC.
;
;   Arguments:
;
;       (eax) = mask for setting 8259 PIC interrupt mask register
;
;--

SET_8259_MASK   macro

        out     PIC1_PORT1, al          ; set master 8259 mask
        shr     eax, 8                  ; shift slave 8259 mask to al
        out     PIC2_PORT1, al          ; set slave 8259 mask
endm

;*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halx86\i386\xxtime.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    xxtime.c

Abstract:

    This module implements the HAL set/query realtime clock routines for
    an x86 system.

Author:

    David N. Cutler (davec) 5-May-1991

Environment:

    Kernel mode

Revision History:

--*/

#include "halp.h"

BOOLEAN
HalQueryRealTimeClock (
    OUT PTIME_FIELDS TimeFields
    )

/*++

Routine Description:

    This routine queries the realtime clock.

    N.B. This routine assumes that the caller has provided any required
        synchronization to query the realtime clock information.

Arguments:

    TimeFields - Supplies a pointer to a time structure that receives
        the realtime clock information.

Return Value:

    If the power to the realtime clock has not failed, then the time
    values are read from the realtime clock and a value of TRUE is
    returned. Otherwise, a value of FALSE is returned.

--*/

{

    HalpReadCmosTime(TimeFields);
    return TRUE;
}

BOOLEAN
HalSetRealTimeClock (
    IN PTIME_FIELDS TimeFields
    )

/*++

Routine Description:

    This routine sets the realtime clock.

    N.B. This routine assumes that the caller has provided any required
        synchronization to set the realtime clock information.

Arguments:

    TimeFields - Supplies a pointer to a time structure that specifies the
        realtime clock information.

Return Value:

    If the power to the realtime clock has not failed, then the time
    values are written to the realtime clock and a value of TRUE is
    returned. Otherwise, a value of FALSE is returned.

--*/

{
    HalpWriteCmosTime(TimeFields);
    return TRUE;
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\inc\hammernb.h ===
/*++

Copyright (c) 2002  Microsoft Corporation

Module Name:

    hammernb.h

Abstract:

    Definitions used to relocate physical memory on Hammer MP machines.

Author:

    Forrest Foltz (forrestf) 07/18/2002

Environment:

    Kernel mode only.

Revision History:

--*/


#if !defined(_HAMMERNB_H_)
#define _HAMMERNB_H_

#include "pci.h"

//
// Structures and definitions used to manipulate the variable MTRR ranges
//

#define MTRR_MSR_CAPABILITIES       0x0fe
#define MTRR_MSR_DEFAULT            0x2ff
#define MTRR_MSR_VARIABLE_BASE      0x200
#define MTRR_MSR_VARIABLE_MASK     (MTRR_MSR_VARIABLE_BASE+1)

#define _40_MASK (((ULONG64)1 << 41) - 1)

typedef union _MTRR_VARIABLE_BASE {
    struct {
        ULONG64 Type:8;
        ULONG64 Reserved0:4;
        ULONG64 Base:40;
    };
    ULONG64 QuadPart;
} MTRR_VARIABLE_BASE, *PMTRR_VARIABLE_BASE;

typedef union _MTRR_VARIABLE_MASK {
    struct {
        ULONG64 Reserved1:11;
        ULONG64 Valid:1;
        ULONG64 Mask:40;
    };
    ULONG64 QuadPart;
} MTRR_VARIABLE_MASK, *PMTRR_VARIABLE_MASK;

typedef union _MTRR_CAPABILITIES {
    struct {
        ULONG64 Vcnt:8;
        ULONG64 Fix:1;
        ULONG64 Reserved:1;
        ULONG64 WC:1;
    };
    ULONG64 QuadPart;
} MTRR_CAPABILITIES, *PMTRR_CAPABILITIES;

//
// Structures and definitions used to manipulate the northbridge physical
// memory map and MMIO map
// 

#define MSR_SYSCFG                  0xc0010010
#define MSR_TOP_MEM                 0xc001001a
#define MSR_TOP_MEM_2               0xc001001d

#define SYSCFG_MTRRTOM2EN           ((ULONG64)1 << 21)

#define MSR_TOP_MEM_MASK            (((1UI64 << (39-23+1))-1) << 23)

//
// Northbridge devices start here
//

#define NB_DEVICE_BASE  0x18

typedef struct _AMD_NB_DRAM_MAP {

    ULONG ReadEnable  : 1;
    ULONG WriteEnable : 1;
    ULONG Reserved1   : 6;
    ULONG InterleaveEnable : 3;
    ULONG Reserved2   : 5;
    ULONG Base        : 16;

    ULONG DestinationNode : 3;
    ULONG Reserved3   : 5;
    ULONG InterleaveSelect : 3;
    ULONG Reserved4   : 5;
    ULONG Limit       : 16;

} AMD_NB_DRAM_MAP, *PAMD_NB_DRAM_MAP;

typedef struct _AMD_NB_MMIO_MAP {

    ULONG ReadEnable  : 1;
    ULONG WriteEnable : 1;
    ULONG CpuDisable  : 1;
    ULONG Lock        : 1;
    ULONG Reserved1   : 4;
    ULONG Base        : 24;

    ULONG DstNode     : 3;
    ULONG Reserved2   : 1;
    ULONG DstLink     : 2;
    ULONG Reserved3   : 1;
    ULONG NonPosted   : 1;
    ULONG Limit       : 24;

} AMD_NB_MMIO_MAP, *PAMD_NB_MMIO_MAP;

typedef struct _AMD_NB_FUNC1_CONFIG {
    USHORT  VendorID;
    USHORT  DeviceID;
    USHORT  Command;
    USHORT  Status;
    UCHAR   RevisionID;
    UCHAR   ProgramInterface;
    UCHAR   SubClassCode;
    UCHAR   BaseClassCode;
    UCHAR   Reserved1[0x34];
    AMD_NB_DRAM_MAP DRAMMap[8];
    AMD_NB_MMIO_MAP MMIOMap[8];
} AMD_NB_FUNC1_CONFIG, *PAMD_NB_FUNC1_CONFIG;

C_ASSERT(FIELD_OFFSET(AMD_NB_FUNC1_CONFIG,DRAMMap) == 0x40);
C_ASSERT(FIELD_OFFSET(AMD_NB_FUNC1_CONFIG,MMIOMap) == 0x80);

BOOLEAN
__inline
BlAmd64ValidateBridgeDevice (
    IN PAMD_NB_FUNC1_CONFIG NodeConfig
    )

/*++

Routine Description:

    This routine verifies that the supplied PCI device configuration
    represents a Hammer northbridge address map function.

Arguments:

    NodeConfig - Supplies a pointer to the configuration data read
                 from a possible Hammer northbridge address map function.

Return Value:

    Returns TRUE if the configuration data matches that of a Hammer northbridge
    address map function, FALSE otherwise.

--*/

{
    if (NodeConfig->VendorID == 0x1022 &&
        NodeConfig->DeviceID == 0x1101 &&
        NodeConfig->ProgramInterface == 0x00 &&
        NodeConfig->SubClassCode == PCI_SUBCLASS_BR_HOST &&
        NodeConfig->BaseClassCode == PCI_CLASS_BRIDGE_DEV) {
        return TRUE;
    } else {
        return FALSE;
    }
}

#endif  // _HAMMERNB_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halx86\i386\xxstubs.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    stubs.c

Abstract:

    This implements the HAL routines which don't do anything on x86.

Author:

    John Vert (jvert) 11-Jul-1991

Revision History:

--*/
#include "nthal.h"
#include "arc.h"
#include "arccodes.h"

VOID
HalSaveState(
    VOID
    )

/*++

Routine Description:

    Saves the system state into the restart block.  Currently does nothing.

Arguments:

    None

Return Value:

    Does not return

--*/

{
    DbgPrint("HalSaveState called - System stopped\n");

    KeBugCheck(0);
}


BOOLEAN
HalDataBusError(
    VOID
    )

/*++

Routine Description:

    Called when a data bus error occurs.  There is no way to fix this on
    x86.

Arguments:

    None

Return Value:

    FALSE

--*/

{
    return(FALSE);

}

BOOLEAN
HalInstructionBusError(
    VOID
    )

/*++

Routine Description:

    Called when an instruction bus error occurs.  There is no way to fix this
    on x86.

Arguments:

    None

Return Value:

    FALSE

--*/

{
    return(FALSE);

}

VOID
KeFlushWriteBuffer(
    VOID
    )

/*++

Routine Description:

    Flushes all write buffers and/or other data storing or reordering
    hardware on the current processor.  This ensures that all previous
    writes will occur before any new reads or writes are completed.

Arguments:

    None

Return Value:

    None.

--*/

{

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halx86\i386\xxmemory.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    xxmemory.c

Abstract:

    Provides routines to allow the HAL to map physical memory.

Author:

    John Vert (jvert) 3-Sep-1991

Environment:

    Phase 0 initialization only.

Revision History:

--*/

//
// This module is compatible with PAE mode and therefore treats physical
// addresses as 64-bit entities.
//

#if !defined(_PHYS64_)
#define _PHYS64_
#endif

#include "halp.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT,HalpAllocPhysicalMemory)
#endif

#define EXTRA_ALLOCATION_DESCRIPTORS 64

MEMORY_ALLOCATION_DESCRIPTOR
    HalpAllocationDescriptorArray[ EXTRA_ALLOCATION_DESCRIPTORS ];

ULONG HalpUsedAllocDescriptors = 0;

//
// Almost all of the last 4Mb of memory are available to the HAL to map
// physical memory.  The kernel may use a couple of PTEs in this area for
// special purposes, so skip any which are not zero.
//
// Note that the HAL's heap only uses the last 3Mb.  This is so we can
// reserve the first 1Mb for use if we have to return to real mode.
// In order to return to real mode we need to identity-map the first 1Mb of
// physical memory.
//

#define HAL_HEAP_START ((PVOID)(((ULONG_PTR)MM_HAL_RESERVED) + 1024 * 1024))

PVOID HalpHeapStart=HAL_HEAP_START;


PVOID
HalpMapPhysicalMemory64(
    IN PHYSICAL_ADDRESS PhysicalAddress,
    IN ULONG NumberPages
    )

/*++

Routine Description:

    This routine maps physical memory into the area of virtual memory
    reserved for the HAL.  It does this by directly inserting the PTE
    into the Page Table which the OS Loader has provided.

    N.B.  This routine does *NOT* update the MemoryDescriptorList.  The
          caller is responsible for either removing the appropriate
          physical memory from the list, or creating a new descriptor to
          describe it.

Arguments:

    PhysicalAddress - Supplies the physical address of the start of the
                      area of physical memory to be mapped.

    NumberPages - Supplies the number of pages contained in the area of
                  physical memory to be mapped.

Return Value:

    PVOID - Virtual address at which the requested block of physical memory
            was mapped

    NULL - The requested block of physical memory could not be mapped.

--*/

{
    PHARDWARE_PTE PTE;
    ULONG PagesMapped;
    PVOID VirtualAddress;
    PVOID RangeStart;

    //
    // The OS Loader sets up hyperspace for us, so we know that the Page
    // Tables are magically mapped starting at V.A. 0xC0000000.
    //

    PagesMapped = 0;
    RangeStart = HalpHeapStart;

    while (PagesMapped < NumberPages) {

        //
        // Look for enough consecutive free ptes to honor mapping
        //

        PagesMapped = 0;
        VirtualAddress = RangeStart;

        //
        // If RangeStart has wrapped, there are not enough free pages
        // available.
        //

        if (RangeStart == NULL) {
            return NULL;
        }

        while (PagesMapped < NumberPages) {
            PTE=MiGetPteAddress(VirtualAddress);
            if (HalpIsPteFree(PTE) == FALSE) {

                //
                // Pte is not free, skip up to the next pte and start over
                //

                RangeStart = (PVOID) ((ULONG_PTR)VirtualAddress + PAGE_SIZE);
                break;
            }
            VirtualAddress = (PVOID) ((ULONG_PTR)VirtualAddress + PAGE_SIZE);
            PagesMapped++;
        }

    }


    VirtualAddress = (PVOID) ((ULONG_PTR) RangeStart |
                              BYTE_OFFSET (PhysicalAddress.LowPart));

    if (RangeStart == HalpHeapStart) {

        //
        // Push the start of heap beyond this range.
        //

        HalpHeapStart = (PVOID)((ULONG_PTR)RangeStart + (NumberPages * PAGE_SIZE));
    }

    while (PagesMapped) {
        PTE=MiGetPteAddress(RangeStart);

        HalpSetPageFrameNumber( PTE, PhysicalAddress.QuadPart >> PAGE_SHIFT );
        PTE->Valid = 1;
        PTE->Write = 1;

        PhysicalAddress.QuadPart += PAGE_SIZE;
        RangeStart   = (PVOID)((ULONG_PTR)RangeStart + PAGE_SIZE);

        --PagesMapped;
    }

    //
    // Flush TLB
    //
    HalpFlushTLB ();
    return(VirtualAddress);
}

PVOID
HalpMapPhysicalMemoryWriteThrough64(
    IN PHYSICAL_ADDRESS PhysicalAddress,
    IN ULONG            NumberPages
)
/*++

Routine Description:

    Maps a physical memory address into virtual space, same as
    HalpMapPhysicalMemory().  The difference is that this routine
    marks the pages as PCD/PWT so that writes to the memory mapped registers
    mapped here won't get delayed in the internal write-back caches.

Arguments:

    PhysicalAddress - Supplies a physical address of the memory to be mapped

    NumberPages - Number of pages to map

Return Value:

    Virtual address pointer to the requested physical address

--*/
{
    ULONG       Index;
    PHARDWARE_PTE   PTE;
    PVOID       VirtualAddress;

    VirtualAddress = HalpMapPhysicalMemory(PhysicalAddress, NumberPages);
    PTE = MiGetPteAddress(VirtualAddress);

    for (Index = 0; Index < NumberPages; Index++, HalpIncrementPte(&PTE)) {

            PTE->CacheDisable = 1;
            PTE->WriteThrough = 1;
    }

    return VirtualAddress;
}

PVOID
HalpRemapVirtualAddress64(
    IN PVOID VirtualAddress,
    IN PHYSICAL_ADDRESS PhysicalAddress,
    IN BOOLEAN WriteThrough
    )
/*++

Routine Description:

    This routine remaps a PTE to the physical memory address provided.

Arguments:

    PhysicalAddress - Supplies the physical address of the area to be mapped

    VirtualAddress  - Valid address to be remapped

    WriteThrough - Map as cachable or WriteThrough

Return Value:

    PVOID - Virtual address at which the requested block of physical memory
            was mapped

    NULL - The requested block of physical memory could not be mapped.

--*/
{
    PHARDWARE_PTE PTE;

    PTE = MiGetPteAddress (VirtualAddress);
    HalpSetPageFrameNumber( PTE, PhysicalAddress.QuadPart >> PAGE_SHIFT );
    PTE->Valid = 1;
    PTE->Write = 1;

    if (WriteThrough) {
        PTE->CacheDisable = 1;
        PTE->WriteThrough = 1;
    }

    //
    // Flush TLB
    //
    HalpFlushTLB();
    return(VirtualAddress);

}

VOID
HalpUnmapVirtualAddress(
    IN PVOID    VirtualAddress,
    IN ULONG    NumberPages
    )
/*++

Routine Description:

    This routine unmaps a PTE.

Arguments:

    VirtualAddress  - Valid address to be remapped

    NumberPages - No of pages to be unmapped

Return Value:

    None.

--*/
{
    PHARDWARE_PTE   Pte;
    PULONG          PtePtr;
    ULONG           Index;

    if (VirtualAddress < HAL_HEAP_START)
        return;

    VirtualAddress = (PVOID)((ULONG_PTR)VirtualAddress & ~(PAGE_SIZE - 1));

    Pte = MiGetPteAddress (VirtualAddress);
    for (Index = 0; Index < NumberPages; Index++, HalpIncrementPte(&Pte)) {
        HalpFreePte( Pte );
    }

    //
    // Flush TLB
    //

    HalpFlushTLB();

    //
    // Realign heap start so that VA space can be reused
    //

    if (HalpHeapStart > VirtualAddress) {
        HalpHeapStart = VirtualAddress;
    }
}

ULONG
HalpAllocPhysicalMemory(
    IN PLOADER_PARAMETER_BLOCK LoaderBlock,
    IN ULONG MaxPhysicalAddress,
    IN ULONG NoPages,
    IN BOOLEAN bAlignOn64k
    )
/*++

Routine Description:

    Carves out N pages of physical memory from the memory descriptor
    list in the desired location.  This function is to be called only
    during phase zero initialization.  (ie, before the kernel's memory
    management system is running)

Arguments:

    MaxPhysicalAddress - The max address where the physical memory can be

    NoPages - Number of pages to allocate

    bAlignOn64k - Whether caller wants resulting pages to be allocated
                  on a 64k byte boundry

Return Value:

    The physical address or NULL if the memory could not be obtained.

--*/
{
    PMEMORY_ALLOCATION_DESCRIPTOR Descriptor;
    PMEMORY_ALLOCATION_DESCRIPTOR NewDescriptor;
    PMEMORY_ALLOCATION_DESCRIPTOR TailDescriptor;
    PLIST_ENTRY NextMd;
    ULONG AlignmentOffset;
    ULONG MaxPageAddress;
    ULONG PhysicalAddress;

    MaxPageAddress = MaxPhysicalAddress >> PAGE_SHIFT;

    if ((HalpUsedAllocDescriptors + 2) > EXTRA_ALLOCATION_DESCRIPTORS) {

        //
        // This allocation will require one or more additional
        // descriptors, but we don't have that many in our static
        // array.  Fail the request.
        //
        // Note: Depending on the state of the existing descriptor
        //       list it is possible that this allocation would not
        //       need an two additional descriptor blocks.  However in
        //       the interest of repeatability and ease of testing we
        //       will fail the request now anyway, rather than a
        //       smaller number of configuration-dependent failures.
        //
    
        ASSERT(FALSE);
        return 0;
    }

    //
    // Scan the memory allocation descriptors and allocate map buffers
    //

    NextMd = LoaderBlock->MemoryDescriptorListHead.Flink;
    while (NextMd != &LoaderBlock->MemoryDescriptorListHead) {
        Descriptor = CONTAINING_RECORD(NextMd,
                                MEMORY_ALLOCATION_DESCRIPTOR,
                                ListEntry);

        AlignmentOffset = bAlignOn64k ?
            ((Descriptor->BasePage + 0x0f) & ~0x0f) - Descriptor->BasePage :
            0;

        //
        // Search for a block of memory which is contains a memory chuck
        // that is greater than size pages, and has a physical address less
        // than MAXIMUM_PHYSICAL_ADDRESS.
        //

        if ((Descriptor->MemoryType == LoaderFree ||
             Descriptor->MemoryType == MemoryFirmwareTemporary) &&
            (Descriptor->BasePage) &&
            (Descriptor->PageCount >= NoPages + AlignmentOffset) &&
            (Descriptor->BasePage + NoPages + AlignmentOffset < MaxPageAddress)) {

        PhysicalAddress =
           (Descriptor->BasePage + AlignmentOffset) << PAGE_SHIFT;
                break;
        }

        NextMd = NextMd->Flink;
    }

    //
    // Use the extra descriptor to define the memory at the end of the
    // original block.
    //


    ASSERT(NextMd != &LoaderBlock->MemoryDescriptorListHead);

    if (NextMd == &LoaderBlock->MemoryDescriptorListHead)
        return 0;

    //
    // The new descriptor will describe the memory being allocated as
    // having been reserved.
    //

    NewDescriptor =
        &HalpAllocationDescriptorArray[ HalpUsedAllocDescriptors];
    NewDescriptor->PageCount = NoPages;
    NewDescriptor->BasePage = Descriptor->BasePage + AlignmentOffset;
    NewDescriptor->MemoryType = LoaderHALCachedMemory;

    HalpUsedAllocDescriptors++;

    //
    // Adjust the existing memory descriptors and insert the new one
    // describing the allocation.
    //

    if (AlignmentOffset == 0) {

        //
        // Trim the source descriptor and insert the allocation
        // descriptor before it.
        //

        Descriptor->BasePage  += NoPages;
        Descriptor->PageCount -= NoPages;

        InsertTailList(
            &Descriptor->ListEntry,
            &NewDescriptor->ListEntry
            );

        if (Descriptor->PageCount == 0) {

            //
            // The whole block was allocated,
            // Remove the entry from the list completely.
            //
            // NOTE: This descriptor can't be recycled or freed since
            // we don't know the allocator.
            //

            RemoveEntryList(&Descriptor->ListEntry);

        }

    } else {

        if (Descriptor->PageCount - NoPages - AlignmentOffset) {

            // 
            // This allocation is coming out of the middle of a descriptor
            // block.  We can use the existing descriptor block to describe
            // the head portion, but we will need a new one to describe the
            // tail.
            //
            // Allocate one from the array in the data segment.  The check
            // at the top of the function ensures that one is available.
            //

            TailDescriptor =
                &HalpAllocationDescriptorArray[ HalpUsedAllocDescriptors];

            //
            // The extra descriptor is needed so intialize it and insert
            // it in the list.
            //

            TailDescriptor->PageCount =
                Descriptor->PageCount - NoPages - AlignmentOffset;

            TailDescriptor->BasePage =
                Descriptor->BasePage + NoPages + AlignmentOffset;

            TailDescriptor->MemoryType = MemoryFree;
            HalpUsedAllocDescriptors++;

            InsertHeadList(
                &Descriptor->ListEntry,
                &TailDescriptor->ListEntry
                );
        }


        //
        // Use the current entry as the descriptor for the first block.
        //

        Descriptor->PageCount = AlignmentOffset;

        //
        // Insert the allocation descriptor after the original
        // descriptor but before the tail descriptor if one was necessary.
        //

        InsertHeadList(
            &Descriptor->ListEntry,
            &NewDescriptor->ListEntry
            );
    }

    return PhysicalAddress;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\inc\hali.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1995  Microsoft Corporation

Module Name:

    hali.h

Abstract:

    This header file defines the private Hardware Architecture Layer (HAL)
    interfaces for bus range support.

Author:

    David N. Cutler (davec) 28-Mar-95


Revision History:

--*/

#ifndef _HALI_
#define _HALI_


// define INVALID_HANDLE for HAL routines
#define INVALID_HANDLE      (HANDLE) -1

//
// Define type of memory for bus range allocations.
//

#define SPRANGEPOOL NonPagedPoolMustSucceed

//
// General Pool Tag for HAL use (see pooltag.txt).
//

#define HAL_POOL_TAG    ' laH'

//
// Define bus range function prototypes.
//

PSUPPORTED_RANGES
HalpMergeRanges (
    IN PSUPPORTED_RANGES    Parent,
    IN PSUPPORTED_RANGES    Child
    );

VOID
HalpMergeRangeList (
    PSUPPORTED_RANGE    NewList,
    PSUPPORTED_RANGE    Source1,
    PSUPPORTED_RANGE    Source2
    );

PSUPPORTED_RANGES
HalpConsolidateRanges (
    PSUPPORTED_RANGES   Ranges
    );

PSUPPORTED_RANGES
HalpAllocateNewRangeList (
    VOID
    );

VOID
HalpFreeRangeList (
    PSUPPORTED_RANGES   Ranges
    );

PSUPPORTED_RANGES
HalpCopyRanges (
    PSUPPORTED_RANGES     Source
    );

VOID
HalpAddRangeList (
    IN OUT PSUPPORTED_RANGE DRange,
    OUT PSUPPORTED_RANGE    SRange
    );

VOID
HalpAddRange (
    PSUPPORTED_RANGE    HRange,
    ULONG               AddressSpace,
    LONGLONG            SystemBase,
    LONGLONG            Base,
    LONGLONG            Limit
    );

VOID
HalpRemoveRanges (
    IN OUT PSUPPORTED_RANGES    Minuend,
    IN PSUPPORTED_RANGES        Subtrahend
    );

VOID
HalpRemoveRangeList (
    IN OUT PSUPPORTED_RANGE     Minuend,
    IN PSUPPORTED_RANGE         Subtrahend
    );


VOID
HalpRemoveRange (
    PSUPPORTED_RANGE    HRange,
    LONGLONG            Base,
    LONGLONG            Limit
    );

VOID
HalpDisplayAllBusRanges (
    VOID
    );

#endif // _HALI_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\inc\pcmp.inc ===
;/*
;++
;
; Copyright (c) 1992  Intel Corporation
; All rights reserved
;
; INTEL CORPORATION PROPRIETARY INFORMATION
;
; This software is supplied to Microsoft under the terms
; of a license agreement with Intel Corporation and may not be
; copied nor disclosed except in accordance with the terms
; of that agreement.
;
;
;   Module Name:
;
;       pcmp.inc
;
;   Abstract:
;
;       include file for PC+MP system.
;
;       WARNING: This file is included by both ASM and C files.
;
;   Author:
;
;       Ron Mosgrove and Rajesh Shah (Intel) 30-July-1993
;
;--
;

if 0        ; Begin C only code         */

#pragma pack(1)

//
//  IMCR (Interrupt Mode Control Register) access definitions
//
#define ImcrDisableApic         0x00
#define ImcrEnableApic          0x01
#define ImcrRegPortAddr         0x22
#if defined(NEC_98)
#define ImcrDataPortAddr        0x700
#else  // defined(NEC_98)
#define ImcrDataPortAddr        0x23
#endif // defined(NEC_98)
#define ImcrPort                0x70

// Physical location where the Extended BIOS Data Area segment adress is stored
#define EBDA_SEGMENT_PTR    0x40e
#define BASE_MEM_PTR        0x413

//
//  The PC+MP configuration table Possible Entry Types
//
#define ENTRY_PROCESSOR     0
#define ENTRY_BUS           1
#define ENTRY_IOAPIC        2
#define ENTRY_INTI          3
#define ENTRY_LINTI         4

#define HEADER_SIZE     0x2c

// Number of default configurations for PC+MP version 1.1 
#define NUM_DEFAULT_CONFIGS  7

//
//  Processor Entry definitions
//

typedef struct _CPUIDENTIFIER {
    ULONG Stepping : 4;
    ULONG Model : 4;
    ULONG Family : 4;
    ULONG Reserved : 20;
} CPUIDENTIFIER, *PCPUIDENTIFIER;

//
// Bits used in the CpuFlags field of the Processor entry
//
#define CPU_DISABLED        0x0   // 1 Bit  - CPU Disabled
#define CPU_ENABLED         0x1   // 1 Bit  - CPU Enabled
#define BSP_CPU             0x2   // Bit #2 - CPU is BSP

//
//  APIC Versions used by PC+MP systems - this is used in the
//  Processor entries and the IoApic Entries
//
#define APIC_INTEGRATED     0x10  // 8 Bits-Apic Version Register
#define APIC_82489DX        0x0   // 8 Bits-Apic Version Register

typedef struct _PcMpProcessorEntry {
    UCHAR EntryType;
    UCHAR LocalApicId;
    UCHAR LocalApicVersion;
    UCHAR CpuFlags;
    CPUIDENTIFIER CpuIdentification;      // CPU Identification
    ULONG FeatureFlags;
    UCHAR Reserved[8];
} PCMPPROCESSOR , *PPCMPPROCESSOR;

//
//  Bus Entry definitions
//

typedef struct _PcMpBusEntry {
    UCHAR EntryType;
    UCHAR BusId;
    CHAR BusType[6];
} PCMPBUS, *PPCMPBUS;

//
//  Io Apic Entry definitions
//
//  Valid IoApicFlag values
//
#define IO_APIC_ENABLED         0x1
#define IO_APIC_DISABLED        0x0

//
// Default value for Io Apic ID.
//
#define IOUNIT_APIC_ID          0xE

typedef struct _PcMpIoApicEntry  {
    UCHAR EntryType;
    UCHAR IoApicId;
    UCHAR IoApicVersion;
    UCHAR IoApicFlag;
    PVOID IoApicAddress;
} PCMPIOAPIC, *PPCMPIOAPIC;

//
//  Bits that define the Interrupt logically
//
typedef struct _PolarityAndLevel {
    USHORT Polarity : 2;
    USHORT Level : 2;
    USHORT Reserved : 12;
} POLARITYANDLEVEL, *PPOLARITYANDLEVEL;

typedef struct _PcMpApicIntiEntry {
    UCHAR EntryType;
    UCHAR IntType;
    POLARITYANDLEVEL Signal;
    UCHAR SourceBusId;
    UCHAR SourceBusIrq;
    UCHAR IoApicId;
    UCHAR IoApicInti;
} PCMPINTI, *PPCMPINTI;

//
//  Local Apic Interrupt Entry definitions
//
typedef struct _PcMpLintiEntry  {
    UCHAR EntryType;
    UCHAR IntType;
    POLARITYANDLEVEL Signal;
    UCHAR SourceBusId;
    UCHAR SourceBusIrq;
    UCHAR DestLocalApicId;
    UCHAR DestLocalApicInti;
} PCMPLINTI, *PPCMPLINTI;

//
//  The PC+MP table definition
//    

struct PcMpTable {
    //
    // PC+MP config table HEADER part (HEADER_SIZE bytes long)
    //

    ULONG Signature;        // Must contain "P","C","M","P"
    USHORT TableLength;     // Length including the header
    UCHAR Revision;         // Rev 1.0 == 1
    UCHAR Checksum;         // Entire table including checksum byte
    CHAR OemId[8];          // OEM defined
    CHAR OemProductId[12];  // OEM defined
    PVOID OemTablePtr;      // OEM specific data
    USHORT OemTableSize;    // length in bytes of the OEM table
    USHORT NumOfEntries;    // Number of entries in the data portion    
    PVOID LocalApicAddress; // Physical address of Local units
    USHORT ExtTableLength;  // Extension table size
    UCHAR ExtTableChecksum; // Complete checksum including extension table
    UCHAR Reserved;         // Not Used
};

//
//  PC+MP Signature used to verify the PC+MP table
//  as valid
//
//          "P"=50H,"C"=43H,"M"=4dH,"P"=50H
//
#define PCMP_SIGNATURE      0x504d4350

//
//  PC+MP Signature used to identify the floating pointer
//  structure (in extended BIOS data segment) that contains
//  a pointer to the PC+MP table.
//
//          "_"=5fH, "M"=4dH, "P"=50H, "_"=5fH
//
#define MP_PTR_SIGNATURE    0x5f504d5f

//
//  This is the floating pointer structure 
//

// For PC+MP version 1.0
struct PcMpTableLocator  {
    ULONG MpPtrSignature;   // Must be "_MP_" (0x5f504d5f)
    PUCHAR TablePtr;        // ptr to the PC+MP Table
    UCHAR MpTableLength;    // Floating pointer structure length
    UCHAR TableRevision;    // Rev 1.0 == 1
    UCHAR TableChecksum;    // Checksum of PcMpTableLocator
    UCHAR Pad;
    ULONG Reserved;
};


struct FloatPtrStruct  {
    ULONG MpPtrSignature;   // Must be "_MP_" (0x5f504d5f)
    PUCHAR TablePtr;        // ptr to the PC+MP Table
    UCHAR MpTableLength;    // Floating pointer structure length
    UCHAR TableRevision;    // Rev 1.0 == 1
    UCHAR TableChecksum;    // Checksum of PcMpTableLocator
    UCHAR MpFeatureInfoByte1;   // MP feature info. byte 1
    UCHAR MpFeatureInfoByte2;   // MP feature info. byte 2
    UCHAR Pad;
    USHORT Reserved;
};


//
// Extension table definitions
//

#define EXTTYPE_BUS_ADDRESS_MAP           128
#define EXTTYPE_BUS_HIERARCHY             129
#define EXTTYPE_BUS_COMPATIBLE_MAP        130
#define EXTTYPE_PERSISTENT_STORE          131

typedef struct {
    UCHAR   Type;
    UCHAR   Length;
    union {
        struct {
            UCHAR           BusId;
            UCHAR           Type;
            LONGLONG        Base;
            LONGLONG        Length;
        } AddressMap;

        struct {
            UCHAR           BusId;
            UCHAR           SubtractiveDecode:1;
            UCHAR           ParentBusId;
        } BusHierarchy;

        struct {
            LONGLONG        Address;
            LONGLONG        Length;
        } PersistentStore;

        struct {
            UCHAR           BusId;
            UCHAR           Modifier:1;
            UCHAR           Reserved:7;
            ULONG           List;
        } CompatibleMap;

    } u;
} MPS_EXTENTRY, *PMPS_EXTENTRY;


#define MPS_ADDRESS_MAP_IO                  0
#define MPS_ADDRESS_MAP_MEMORY              1
#define MPS_ADDRESS_MAP_PREFETCH_MEMORY     2
#define MPS_ADDRESS_MAP_UNDEFINED           9

//
//  The System configuration table as used by a PC_MP system
//
//
// The offset is relative to the BIOS starting at f0000H
//
#define PTR_OFFSET          0x0000e6f5
#define BIOS_BASE           0x000f0000

#define PCMP_IMPLEMENTED    0x01    // In MpFeatureInfoByte1
#define PCMP_CONFIG_MASK    0x0e    // In MpFeatureInfoByte1
#define IMCR_MASK           0x80    // In MpFeatureInfoByte2
#define MULT_CLOCKS_MASK    0x40    // In MpFeatureInfoByte2

struct SystemConfigTable {
    UCHAR Reserved[PTR_OFFSET];
    USHORT NumOfBytes;      // Table can be variable length.
    UCHAR ModelType;        // AT=0xfc, unknown board=0xff
    UCHAR SubModelType;
    UCHAR BIOSRevision;     // First release = 0x0
    UCHAR FeatureInfoByte[3];   // Standard AT features
    UCHAR MpFeatureInfoByte1;   // MP feature info. byte 1
    UCHAR MpFeatureInfoByte2;   // MP feature info. byte 2
} ;

#pragma pack()

NTSTATUS
HalpPci2MpsBusNumber(
    IN UCHAR PciBusNumber,
    OUT UCHAR *MpsBusNumber
    );

PBUS_HANDLER
HalpFindIdeBus(
    IN  ULONG   Vector
    );

BOOLEAN
HalpInterruptsDescribedByMpsTable(
    IN UCHAR MpsBusNumber
    );

NTSTATUS
HalpMpsGetParentBus(
    IN  UCHAR MpsBus,
    OUT UCHAR *ParentMpsBus
    );

BOOLEAN
HalpMpsBusIsRootBus(
    IN  UCHAR MpsBus
    );

VOID
HalpMPSPCIChildren (
    VOID
    );

/*
endif

;
;  IMCR (Interrupt Mode Control Register) access definitions
;

ImcrDisableApic     equ     00H
ImcrEnableApic      equ     01H
ImcrRegPortAddr     equ     22H
ifdef NEC_98
ImcrDataPortAddr    equ     700H
else  ; NEC_98
ImcrDataPortAddr    equ     23H
endif ; NEC_98
ImcrPort        equ     70H

;
;   MP Configuration Table - Built by an MP BIOS for OS Support

;
;  PC+MP Signature used to identify the floating pointer
;  structure (in extended BIOS data segment) that contains
;  a pointer to the PC+MP table.
;
;          "_"=5fH, "M"=4dH, "P"=50H, "_"=5fH
;
MP_PTR_SIGNATURE    equ 5f504d5fH

;
;  PC+MP Signature used to verify the PC+MP table
;  as valid
;
;          "P"=50H,"C"=43H,"M"=4dH,"P"=50H
;
PCMP_SIGNATURE      equ 504d4350H

;
;  The PC+MP configuration table Possible Entry Types
;
ENTRY_PROCESSOR     equ 0H
ENTRY_BUS           equ 1H
ENTRY_IOAPIC        equ 2H
ENTRY_INTI          equ 3H
ENTRY_LINTI         equ 4H

;
; Bits used in the CpuFlags field of the Processor entry
;
CPU_ENABLED         equ     01H      
CPU_DISABLED        equ     00H      
BSP_CPU             equ 02H  

;
;  APIC Versions used by PC+MP systems - this is used in the
;  Processor entries and the IoApic Entries
;
APIC_INTEGRATED     equ     10H
APIC_82489DX        equ     00H      


;
;  Macros used in table definitions
;
HEADER_SIZE             equ 2CH

; Number of default configurations for PC+MP version 1.1 
NUM_DEFAULT_CONFIGS equ 7

;
;  Io Apic Entry definitions
;
IO_APIC_ENABLED     equ     01H
IO_APIC_DISABLED    equ     00H

;
; Default value for Io Apic ID.
;
IOUNIT_APIC_ID      equ     0EH     ;   ID of the IO Unit

PcMpTable struc
    ; HEADER portion of the PC+MP config table
    ;
    Signature           db       4 dup (0)  ; Must be "P","C","M","P"
    TableLength     dw   0     ; Length in bytes of table
    Revision        db   0     ; Table revision #
    Checksum        db   0     ; Table checksum
    OemId       db   8 dup (0) ; OemId string
    OemProductId    db  12 dup (0) ; Oem product id
    OemTablePtr     dd   0     ; Ptr to OEM table
    OemTableSize    dw   0     ; Size of OEM table
    NumOfEntries    dw   0     ; # of entries in table
    LocalApicAddress    dd      0       ; Physical address of Local units
    ExtTableLength      dw      0       ; Extension table size
    ExtTableChecksum    db      0       ; Complete checksum including extension table
    Reserved            db      0       ; Not Used

PcMpTable ends

;
;  Bios Constants. The offset is relative to the BIOS starting at 
;  f0000H.
;

PTR_OFFSET          equ     0e6f5H
BIOS_BASE           equ     0f0000H
PCMP_IMPLEMENTED    equ     01H
PCMP_CONFIG_MASK    equ     0eH
IMCR_MASK           equ     80H
MULT_CLOCKS_MASK    equ     40H

PcMpTableLocator struc
    MpPtrSignature  dd  0   ; Must be "_MP_" (0x5f504d5f)
    TablePtr        dd  0
    MpTableLength   db  0
    TableRevision   db  0
    TableChecksum   db  0
    Pad         db  0
    Reserved        dd  0
PcMpTableLocator ends

SystemConfigTable struc

                    db  PTR_OFFSET dup (0) ;Skip to 0e6f5
NumOfBytes          db  2       ; Table Length
ModelType       db  0       ; AT=0fc, unknown=0ff
SubModelType        db  0
BIOSRevision        db  0       ; 00=first release
FeatureInfoByte     db  3 dup (0)   ; AT features
MpFeatureInfoByte1  db  0       ; MP feature info. byte 1
MpFeatureInfoByte2  db  0       ; MP feature info. byte 2

SystemConfigTable ends

; */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\intfilter\src\config\addfiltr.h ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    addfiltr.h

Abstract:

    Functions for adding/removing filter drivers
    on a given device stack

Author:

    Chris Prince (t-chrpri)

Environment:

    User mode

Notes:

    - The filter is not checked for validity before it is added to the
        driver stack; if an invalid filter is added, the device may
        no longer be accessible.
    - All code works irrespective of character set (ANSI, Unicode, ...)
        //CPRINCE IS ^^^^^^ THIS STILL VALID ???
    - Some functions based on code by Benjamin Strautin (t-bensta)

Revision History:

--*/


#ifndef __ADDFILTR_H__
#define __ADDFILTR_H__

#include <windows.h>

// the SetupDiXXX api (from the DDK)
#include <setupapi.h>



//
// FUNCTION PROTOTYPES
//

// ------ Upper-Filter Fuctions ------
LPTSTR
GetUpperFilters(
    IN HDEVINFO DeviceInfoSet,
    IN PSP_DEVINFO_DATA DeviceInfoData
    );

BOOLEAN
AddUpperFilterDriver(
    IN HDEVINFO DeviceInfoSet,
    IN PSP_DEVINFO_DATA DeviceInfoData,
    IN LPTSTR Filter
    );

BOOLEAN
RemoveUpperFilterDriver(
    IN HDEVINFO DeviceInfoSet,
    IN PSP_DEVINFO_DATA DeviceInfoData,
    IN LPTSTR Filter
    );



// ------ Other Fuctions ------
PBYTE
GetDeviceRegistryProperty(
    IN  HDEVINFO DeviceInfoSet,
    IN  PSP_DEVINFO_DATA DeviceInfoData,
    IN  DWORD Property,
    IN  DWORD   ExpectedRegDataType,
    OUT PDWORD pPropertyRegDataType
    );

BOOLEAN
RestartDevice(
    IN HDEVINFO DeviceInfoSet,
    IN OUT PSP_DEVINFO_DATA DeviceInfoData
    );



#endif // __ADDFILTR_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\intfilter\src\config\resource.h ===
#ifndef __RESOURCE_H__
#define __RESOURCE_H__

#define IDC_STATIC                      (-1)

#define IDD_MAIN                        101
#define IDD_AFFINITY                    102

#define IDL_DEVICES                     1001
#define IDS_LOCATIONINFO                1002
#define IDS_DEVOBJNAME                  1003
#define IDL_UPPERFILTERS                1004
#define IDB_ADDFILTER                   1005
#define IDB_REMFILTER                   1006
#define IDC_DONTRESTART                 1007
#define IDB_SETAFFINITYMASK             1008
#define IDB_DELETEAFFINITYMASK          1009
#define IDS_CURRAFFINITYMASK            1010
#define IDB_DONE                        1011

#define IDC_CPU0                        2000
#define IDC_CPU1                        2001
#define IDC_CPU2                        2002
#define IDC_CPU3                        2003
#define IDC_CPU4                        2004
#define IDC_CPU5                        2005
#define IDC_CPU6                        2006
#define IDC_CPU7                        2007
#define IDC_CPU8                        2008
#define IDC_CPU9                        2009
#define IDC_CPU10                       2010
#define IDC_CPU11                       2011
#define IDC_CPU12                       2012
#define IDC_CPU13                       2013
#define IDC_CPU14                       2014
#define IDC_CPU15                       2015
#define IDC_CPU16                       2016
#define IDC_CPU17                       2017
#define IDC_CPU18                       2018
#define IDC_CPU19                       2019
#define IDC_CPU20                       2020
#define IDC_CPU21                       2021
#define IDC_CPU22                       2022
#define IDC_CPU23                       2023
#define IDC_CPU24                       2024
#define IDC_CPU25                       2025
#define IDC_CPU26                       2026
#define IDC_CPU27                       2027
#define IDC_CPU28                       2028
#define IDC_CPU29                       2029
#define IDC_CPU30                       2030
#define IDC_CPU31                       2031

#endif // __RESOURCE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\intfilter\src\config\multisz.c ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    multisz.c

Abstract:

    Functions for manipulating MultiSz strings

Author:

    Chris Prince (t-chrpri)

Environment:

    User mode

Notes:

    - Some functions based on code by Benjamin Strautin (t-bensta)

Revision History:

--*/


#include "MultiSz.h"

#include <stdlib.h>  // for malloc/free

// for all of the _t stuff (to allow compiling for both Unicode/Ansi)
#include <tchar.h>



#if DBG
#include <assert.h>
#define ASSERT(condition) assert(condition)
#else
#define ASSERT(condition)
#endif


//
// <CPRINCE> NOTE: a MultiSz cannot contain an empty string as one of its
// sub-strings (else could incorrectly interpret as end of MultiSz).
//
// Example:  string1 - "foo"
//           string2 - ""
//           string3 - "bar"
//
//           MultiSz - "foo\0\0bar\0\0"
//                         ^^^^
//                         This looks like end of MultiSz here -- but isn't!
//
// So can assume that won't have an empty (sub-)string in a MultiSz.
//








/*
 * Prepends the given string to a MultiSz.
 *
 * Returns TRUE if successful, FALSE if not (will only fail in memory
 * allocation)
 *
 * NOTE: This WILL allocate and free memory, so don't keep pointers to the
 * MultiSz passed in.
 *
 * Parameters:
 *   SzToPrepend - string to prepend
 *   MultiSz     - pointer to a MultiSz which will be prepended-to
 */
BOOLEAN
PrependSzToMultiSz(
    IN     LPCTSTR  SzToPrepend,
    IN OUT LPTSTR  *MultiSz
    )
{
    size_t szLen;
    size_t multiSzLen;
    LPTSTR newMultiSz = NULL;

    ASSERT( NULL != SzToPrepend );
    ASSERT( NULL != MultiSz );

    // get the size, in bytes, of the two buffers
    szLen = (_tcslen(SzToPrepend)+1)*sizeof(_TCHAR);
    multiSzLen = MultiSzLength(*MultiSz)*sizeof(_TCHAR);
    newMultiSz = (LPTSTR)malloc( szLen+multiSzLen );

    if( newMultiSz == NULL )
    {
        return FALSE;
    }

    // recopy the old MultiSz into proper position into the new buffer.
    // the (char*) cast is necessary, because newMultiSz may be a wchar*, and
    // szLen is in bytes.

    memcpy( ((char*)newMultiSz) + szLen, *MultiSz, multiSzLen );

    // copy in the new string
    _tcscpy( newMultiSz, SzToPrepend );

    free( *MultiSz );
    *MultiSz = newMultiSz;

    return TRUE;
}


/*
 * Returns the length (in characters) of the buffer required to hold this
 * MultiSz, INCLUDING the trailing null.
 *
 * Example: MultiSzLength("foo\0bar\0") returns 9
 *
 * NOTE: since MultiSz cannot be null, a number >= 1 will always be returned
 *
 * Parameters:
 *   MultiSz - the MultiSz to get the length of
 */
size_t
MultiSzLength(
    IN LPCTSTR MultiSz
    )
{
    size_t len = 0;
    size_t totalLen = 0;

    ASSERT( MultiSz != NULL );

    // search for trailing null character
    while( *MultiSz != _T('\0') )
    {
        len = _tcslen(MultiSz)+1;
        MultiSz += len;
        totalLen += len;
    }

    // add one for the trailing null character
    return (totalLen+1);
}


/*
 * Deletes all instances of a string from within a multi-sz.
 *
 * Return Value:
 *   Returns the number of instances that were deleted.
 *
 * Parameters:
 *   szFindThis      - the string to find and remove
 *   mszFindWithin   - the string having the instances removed
 *   NewStringLength - the new string length
 */
//CPRINCE: DO WE WANT TO MODIFY THIS TO TAKE ADVANTAGE OF MY "MultiSzSearch" FUNCTION ???
size_t
MultiSzSearchAndDeleteCaseInsensitive(
    IN  LPCTSTR  szFindThis,
    IN  LPTSTR   mszFindWithin,
    OUT size_t  *NewLength
    )
{
    LPTSTR search;
    size_t currentOffset;
    DWORD  instancesDeleted;
    size_t searchLen;

    ASSERT(szFindThis != NULL);
    ASSERT(mszFindWithin != NULL);
    ASSERT(NewLength != NULL);

    currentOffset = 0;
    instancesDeleted = 0;
    search = mszFindWithin;

    *NewLength = MultiSzLength(mszFindWithin);

    // loop while the multisz null terminator is not found
    while ( *search != _T('\0') )
    {
        // length of string + null char; used in more than a couple places
        searchLen = _tcslen(search) + 1;

        // if this string matches the current one in the multisz...
        if( _tcsicmp(search, szFindThis) == 0 )
        {
            // they match, shift the contents of the multisz, to overwrite the
            // string (and terminating null), and update the length
            instancesDeleted++;
            *NewLength -= searchLen;
            memmove( search,
                     search + searchLen,
                     (*NewLength - currentOffset) * sizeof(TCHAR) );
        }
        else
        {
            // they don't mactch, so move pointers, increment counters
            currentOffset += searchLen;
            search        += searchLen;
        }
    }

    return instancesDeleted;
}


//--------------------------------------------------------------------------
//
// Searches for a given string within a given MultiSz.
//
// Return Value:
//   Returns TRUE if string was found, or FALSE if not found or error occurs.
//
// Parameters:
//   szFindThis     - the string to look for
//   mszFindWithin  - the MultiSz to search within
//   fCaseSensitive - whether the search should be case-sensitive (TRUE==yes)
//   ppszMatch      - if search successful, will be set to point to first
//                      match in MultiSz; else undefined. (NOTE: is optional.
//                      If NULL, no value will be stored.)
//--------------------------------------------------------------------------
BOOL
MultiSzSearch( IN LPCTSTR szFindThis,
               IN LPCTSTR mszFindWithin,
               IN BOOL    fCaseSensitive,
               OUT LPCTSTR * ppszMatch OPTIONAL
             )
{
    LPCTSTR pCurrPosn;
    int (__cdecl * fnStrCompare)(const char *, const char *);  // convenient func ptr
    size_t  searchLen;


    ASSERT( NULL != szFindThis );
    ASSERT( NULL != mszFindWithin );


    // Setup function pointer
    if( fCaseSensitive )
    {
        fnStrCompare = _tcscmp;
    } else {
        fnStrCompare = _tcsicmp;
    }


    pCurrPosn   = mszFindWithin;

    // Loop until end of MultiSz is reached, or we find a match
    while( *pCurrPosn != _T('\0') )
    {
        if( 0 == fnStrCompare(pCurrPosn, szFindThis) )
        {
            break;  // exit loop
        }

        //
        // No match, so advance pointer to next string in the MultiSz
        //

        // length of string + null char
        searchLen = _tcslen(pCurrPosn) + 1;
        pCurrPosn += searchLen;
    }


    // If no match was found, can just return now.
    if( *pCurrPosn == _T('\0') )
    {
        return FALSE;  // no match
    }

    // Else match was found. Update 'ppszMatch', if caller wants that info.
    if( NULL != ppszMatch )
    {
        *ppszMatch = pCurrPosn;
    }


    return TRUE;  // found match
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\intfilter\src\config\multisz.h ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    multisz.h

Abstract:

    Functions for manipulating MultiSz strings

Author:

    Chris Prince (t-chrpri)

Environment:

    User mode

Notes:

    - Some functions based on code by Benjamin Strautin (t-bensta)

Revision History:

--*/


#ifndef __MULTISZ_H__
#define __MULTISZ_H__



#include <windows.h>



//
// FUNCTION PROTOTYPES
//

BOOLEAN
PrependSzToMultiSz(
    IN     LPCTSTR  SzToPrepend,
    IN OUT LPTSTR  *MultiSz
    );

size_t
MultiSzLength(
    IN LPCTSTR MultiSz
    );

size_t
MultiSzSearchAndDeleteCaseInsensitive(
    IN  LPCTSTR  szFindThis,
    IN  LPTSTR   mszFindWithin,
    OUT size_t  *NewStringLength
    );


BOOL
MultiSzSearch( IN LPCTSTR szFindThis,
               IN LPCTSTR mszFindWithin,
               IN BOOL    fCaseSensitive,
               OUT LPCTSTR * ppszMatch OPTIONAL
             );


#endif // __MULTISZ_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\intfilter\src\config\intfiltr.c ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    intfiltr.c

Abstract:

    Utility for installing/uninstalling the Interrupt-Affinity Filter
    (IntFiltr) on a given device stack, and for configuring IntFiltr
    settings.

Author:

    Chris Prince (t-chrpri)

Environment:

    User mode

Revision History:

--*/


#include <windows.h>

#include <setupapi.h>

#include <tchar.h>
#include <stdio.h>  // for certain sprintf functions
#include <stdlib.h>  // for malloc/free

#include "resource.h"

#include "addfiltr.h"
#include "MultiSz.h"



//CPRINCE: MIGHT BE GOOD TO PUT THE FOLLOWING GENERAL THINGS IN A "MAIN.H" FILE ???

#if DBG
#include <assert.h>
#define ASSERT(condition) assert(condition)
#else
#define ASSERT(condition)
#endif

#define  ARRAYSIZE(x)    ( sizeof((x)) / sizeof((x)[0]) )




//
// Defines
//
#if defined(_WIN64)
#define MAX_PROCESSOR   64
#else 
#define MAX_PROCESSOR   32    // I don't like this, but hey, it's what they do in TaskMgr...
#endif 

#define FILTER_SERVICE_NAME    "InterruptAffinityFilter" /*CPRINCE: NEED TO UNICODE-IZE THIS ? (AND SHOULD WE USE #define FOR CONST STRING ?) */
#define FILTER_REGISTRY_VALUE  "IntFiltr_AffinityMask"   /*CPRINCE: NEED TO UNICODE-IZE THIS ? (AND SHOULD WE USE #define FOR CONST STRING ?) */

#if defined(_WIN64)
#define REG_KAFFINITY    REG_QWORD
#else 
#define REG_KAFFINITY    REG_DWORD
#endif 

//
// SHARED/GLOBAL VARIABLES
//
HINSTANCE g_hInstance;
int       g_nDialogItems;
HCURSOR   g_hCursors[2];
KAFFINITY g_dwActiveProcessorMask;  // mask of CPUs in the system


//
// Function Prototypes
//
INT_PTR CALLBACK DlgProc_FilterConfig( HWND hwndDlg,
                                    UINT msg,
                                    WPARAM wParam,
                                    LPARAM lParam );
INT_PTR CALLBACK DlgProc_Affinity( HWND hwndDlg,
                                UINT uMsg,
                                WPARAM wParam,
                                LPARAM lParam );

void UI_UpdateAffinityMaskString( HWND hwndParentDlg,
                                  HDEVINFO hDevInfo,
                                  PSP_DEVINFO_DATA pDevInfoData );
void UI_UpdateUpperFilterList( HWND hwndParentDlg,
                               HDEVINFO hDevInfo,
                               PSP_DEVINFO_DATA pDevInfoData );
void UI_UpdateDevObjString( HWND hwndMainDlg,
                            HDEVINFO hDevInfo,
                            PSP_DEVINFO_DATA pDevInfoData );
void UI_UpdateLocationInfoString( HWND hwndMainDlg,
                                  HDEVINFO hDevInfo,
                                  PSP_DEVINFO_DATA pDevInfoData );
void UI_PromptForDeviceRestart( HWND hwndMainDlg,
                                HDEVINFO hDevInfo,
                                PSP_DEVINFO_DATA pDevInfoData );
void UI_PromptForInstallFilterOnDevice( HWND hwndMainDlg,
                                        HDEVINFO hDevInfo,
                                        PSP_DEVINFO_DATA pDevInfoData );

void RestartDevice_WithUI( HWND hwndParentDlg,
                           HDEVINFO hDevInfo,
                           PSP_DEVINFO_DATA pDevInfoData );

BOOL SetFilterAffinityMask( HDEVINFO hDevInfo,
                            PSP_DEVINFO_DATA pDevInfoData,
                            KAFFINITY affinityMask );
BOOL GetFilterAffinityMask( HDEVINFO hDevInfo,
                            PSP_DEVINFO_DATA pDevInfoData,
                            KAFFINITY* pAffinityMask );
BOOL DeleteFilterAffinityMask( HDEVINFO hDevInfo,
                               PSP_DEVINFO_DATA pDevInfoData );


void AddRemoveFilterOnDevice( HWND hwndMainDlg,
                              HDEVINFO hDevInfo,
                              PSP_DEVINFO_DATA pDevInfoData,
                              BOOL fAddingFilter );


BOOL FilterIsInstalledOnDevice( HDEVINFO hDevInfo,
                                PSP_DEVINFO_DATA pDevInfoData );



void ExitProgram( HWND hwndDlg, HDEVINFO * phDevInfo );


// Misc Helper Funcs
LPARAM GetItemDataCurrentSelection( HWND hwndListBox );
void MessageBox_FromErrorCode( LONG systemErrorCode );





//--------------------------------------------------------------------------
//
//--------------------------------------------------------------------------
int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance,
                    PSTR szCmdLine, int nCmdShow )
{
    // Initialize various things
    g_hInstance = hInstance;

    g_hCursors[0] = LoadCursor( 0, IDC_ARROW );
    g_hCursors[1] = LoadCursor( 0, IDC_WAIT );

    {
        SYSTEM_INFO sysInfo;

        GetSystemInfo( &sysInfo );
        g_dwActiveProcessorMask = (KAFFINITY)sysInfo.dwActiveProcessorMask;
    }


    // Create dialog box (everything is handled through it)
    DialogBox( g_hInstance,
               MAKEINTRESOURCE(IDD_MAIN),
               NULL,  // no parent window exists
               DlgProc_FilterConfig
             );


    // 'DialogBox()' func has returned, so user must be finished.
    return 0;
}


//--------------------------------------------------------------------------
//
//--------------------------------------------------------------------------
INT_PTR CALLBACK DlgProc_FilterConfig( HWND hwndDlg, UINT msg,
                                    WPARAM wParam, LPARAM lParam )
{

    static HDEVINFO hDevInfo = INVALID_HANDLE_VALUE;
    HWND hwndDeviceList;
    PSP_DEVINFO_DATA pDevInfoData;  // needed by various cases here...



    hwndDeviceList = GetDlgItem( hwndDlg, IDL_DEVICES );


// CPRINCE:
//FOR all except WM_INITDIALOG, should return:
//  TRUE if we did process the message, -or-
//  FALSE if we didn't process the message
// END CPRINCE


    switch( msg )
    {
        case WM_CLOSE:
            ExitProgram( hwndDlg, &hDevInfo );
        return TRUE;


        case WM_INITDIALOG:
        {
/*CPRINCE: MAYBE MOVE THIS WHOLE CASE INTO A FUNC SOMEWHERE ELSE? */

            int              deviceIndex; // index for stepping thru devices
            SP_DEVINFO_DATA  devInfoData;


            //
            // Get a list of devices
            //
            hDevInfo = SetupDiGetClassDevs( NULL,
                                            NULL,
                                            NULL,
                                            DIGCF_ALLCLASSES
                                            | DIGCF_PRESENT
                                            | DIGCF_PROFILE
                                          );

            if( INVALID_HANDLE_VALUE == hDevInfo)
            {
                MessageBox( NULL,
                            "Unable to get a list of devices.",
                            "Error",
                            MB_OK | MB_ICONERROR  //CPRINCE: NEED TO MAKE ARGS HERE UNICODE-HAPPY ???
                          );
                SendMessage( hwndDlg, WM_CLOSE, 0, 0 );
                return TRUE;
            }


            //
            // Initialize the list box (i.e., fill it with entries)
            //

            // Step through the list of devices for this handle.
            // We use 'SetupDiEnumDeviceInfo' to get device info at each index; the
            // function returns FALSE when there is no device at the given index
            // (and thus no more devices).

            devInfoData.cbSize = sizeof(SP_DEVINFO_DATA);  // first, need init this

            g_nDialogItems = 0;

            for( deviceIndex=0 ;
                 SetupDiEnumDeviceInfo( hDevInfo, deviceIndex, &devInfoData ) ;
                 deviceIndex++
               )
            {
                LPTSTR  deviceName;
                DWORD   regDataType;


                deviceName =
                    (LPTSTR) GetDeviceRegistryProperty( hDevInfo,
                                                        &devInfoData,
                                                        SPDRP_DEVICEDESC,
                                                        REG_SZ,
                                                        &regDataType
                                                      );
                if( NULL == deviceName )
                {
                    // ERROR: device description doesn't exist, or we
                    // just can't access it
                    MessageBox( NULL,
                                "Error in accessing a device description.\n\n"
                                  "Device will not be added to list.",
                                "Error",
                                MB_OK | MB_ICONERROR
                              );
                }
                else
                {
                    void* pCopy_devInfoData;


                    // Add string to the list box
                    SendMessage( hwndDeviceList,
                                 LB_ADDSTRING,
                                 0,
                                 (LPARAM)deviceName
                               );


                    // Save a copy of the DeviceInfoData
                    pCopy_devInfoData = malloc( sizeof(SP_DEVINFO_DATA) );
                    if( NULL != pCopy_devInfoData )
                    {
                        memcpy( pCopy_devInfoData, &devInfoData, sizeof(SP_DEVINFO_DATA) );
                    }


                    // Associate a piece of data with that listbox entry
                    SendMessage( hwndDeviceList,
                                 LB_SETITEMDATA,
                                 g_nDialogItems,
                                 (LPARAM) pCopy_devInfoData   //CPRINCE CHECK: PROBLEM W/POINTERS AND 64-BIT MACHINES ???
                               );
    // CPRINCE NOTE! - STORING POINTERS IN LIST-BOX 'ITEMDATA' MIGHT NOT BE 64-BIT COMPATIBLE ?!?

                    g_nDialogItems++;

                    free( deviceName );


                }

            }


            //
            // Select one of the elements of the "Devices" listbox, and then
            // update elements of the UI that display info about that device.
            // (We do all this so that things displayed in the UI aren't
            // invalid when the user first starts our program.)
            //
            SendMessage( hwndDeviceList,
                         LB_SETCURSEL, 
                         0,  // index in list to select
                         0
                       );

            pDevInfoData = (PSP_DEVINFO_DATA) GetItemDataCurrentSelection( hwndDeviceList );
            if( NULL != pDevInfoData )
            {
                UI_UpdateAffinityMaskString( hwndDlg, hDevInfo, pDevInfoData );
                UI_UpdateUpperFilterList( hwndDlg, hDevInfo, pDevInfoData );
                UI_UpdateDevObjString( hwndDlg, hDevInfo, pDevInfoData );
                UI_UpdateLocationInfoString( hwndDlg, hDevInfo, pDevInfoData );
            }



            //
            // Set the focus to one of the dialog-box elements.
            // We return FALSE so the system doesn't also try to set
            // the default keyboard focus.
            //
            SetFocus( hwndDeviceList );
            return FALSE;
        }

        case WM_COMMAND:

            //
            // See what DialogBox item this WM_COMMAND affects...
            //
            switch( LOWORD(wParam) )
            {
                // command that affects the Devices listbox...
                case IDL_DEVICES:

                    switch( HIWORD(wParam) )
                    {
                        case LBN_SELCHANGE:  // curr. selection was changed
                        {
                            pDevInfoData = (PSP_DEVINFO_DATA) GetItemDataCurrentSelection( hwndDeviceList );

                            if( NULL == pDevInfoData )
                            {
                                // No DeviceInfoData available
                                SetDlgItemText( hwndDlg,
                                                IDS_DEVOBJNAME,
                                                "NO DEVICE INFO AVAILABLE"  // CPRINCE: NEED UNICODE-IZE THIS ???
                                             );
                            }
                            else
                            {
                                //
                                // Update various on-screen UI values
                                //
                                UI_UpdateAffinityMaskString( hwndDlg, hDevInfo, pDevInfoData );
                                UI_UpdateUpperFilterList( hwndDlg, hDevInfo, pDevInfoData );
                                UI_UpdateDevObjString( hwndDlg, hDevInfo, pDevInfoData );
                                UI_UpdateLocationInfoString( hwndDlg, hDevInfo, pDevInfoData );
                            }

                        }
                        return TRUE;

                      default:
                        return FALSE;
                    } //END: switch( HIWORD(wParam) )

                    break;


                case IDB_DONE:
                    // Exit
                    SendMessage( hwndDlg, WM_CLOSE, 0, 0 );
                return TRUE;


                case IDB_DELETEAFFINITYMASK:
                {
                    pDevInfoData = (PSP_DEVINFO_DATA) GetItemDataCurrentSelection( hwndDeviceList );
                    if( NULL == pDevInfoData )
                    {
//CPRINCE: PUT ERROR MSG HERE, TOO!
                        return TRUE;  // we're done handling this msg
                    }

                    // Delete the registry key
                    DeleteFilterAffinityMask( hDevInfo, pDevInfoData );
                    UI_UpdateAffinityMaskString( hwndDlg, hDevInfo, pDevInfoData );

                    //CPRINCE: Maybe should prompt user for restart-device
                    //  here (if filter installed), since change won't take
                    //  effect until device is restarted.
                    //
                    //  But shouldn't prompt user if affinity-mask wasn't
                    //  actually set when they tried to delete it, b/c then
                    //  there really hasn't been a change! (So would need
                    //  to know success/fail status of the
                    //  'DeleteFilterAffinityMask' call.)

                }
                return TRUE;


                case IDB_SETAFFINITYMASK:
                {
                    //
                    // User wants to set/change the interrupt-affinity-mask
                    // for currently selected device.
                    //
                    
                    KAFFINITY dwAffinityMask;


                    pDevInfoData = (PSP_DEVINFO_DATA) GetItemDataCurrentSelection( hwndDeviceList );
                    if( NULL == pDevInfoData )
                    {
//CPRINCE: PUT ERROR MSG HERE, TOO!
                        return TRUE;  // we're done handling this msg
                    }


                    // Initially, set 'dwAffinityMask' to mask of the CPUs that
                    // are _currently_ selected in affinity-mask settings
                    if( ! GetFilterAffinityMask(hDevInfo, pDevInfoData, &dwAffinityMask) )
                    {
                        // Doesn't exist, or is invalid.  So by default,
                        // interrupt-filter assumes that _no_ interrupts are
                        // being masked off.
                        dwAffinityMask = (KAFFINITY)-1;
                    }

                    // Pop up the dialog box
                    if( IDOK == DialogBoxParam( g_hInstance,
                                                MAKEINTRESOURCE(IDD_AFFINITY),
                                                hwndDlg,  // parent window
                                                DlgProc_Affinity,
                                                (LPARAM) &dwAffinityMask  ) )
                    {
                        // Now, 'dwAffinityMask' contains the interrupt affinity
                        // mask that user selected.  Make necessary changes.
                        SetFilterAffinityMask( hDevInfo, pDevInfoData, dwAffinityMask );
                        UI_UpdateAffinityMaskString( hwndDlg, hDevInfo, pDevInfoData );


                        // If the filter is installed on this device, then
                        // change to affinity mask won't take effect until
                        // device is restarted.  And if filter _isn't_
                        // installed, then changes won't matter, well, ever.
                        //
                        // So here we prompt user, to make sure they know
                        // what they're doing, and so they aren't confused
                        // when their changes they just made here don't
                        // have any immediate effect.

                        if( FilterIsInstalledOnDevice(hDevInfo,pDevInfoData) )
                        {
                            // Filter _is_ currently installed.
                            // See if the user wants to try to restart the
                            // device now (since changes to affinity mask
                            // won't take effect until device is restarted)
                            UI_PromptForDeviceRestart( hwndDlg, hDevInfo, pDevInfoData );
                        }
                        else
                        {
                            // Filter _isn't_ currently installed.
                            // See if the user wants to install the filter
                            // on the device now (since the interrupt-
                            // affinity mask is useless if the filter isn't
                            // installed on the device)
                            UI_PromptForInstallFilterOnDevice( hwndDlg, hDevInfo, pDevInfoData );
                        }
                    }
                    //ELSE:  User hit 'Cancel'. Don't need to make any changes.


                }
                return TRUE;


                case IDB_ADDFILTER:
                case IDB_REMFILTER:
                {
                    BOOL             fAddingFilter;

                    //
                    // Get selected device, so we know which
                    // device's filter settings to change.
                    //
                    pDevInfoData = (PSP_DEVINFO_DATA) GetItemDataCurrentSelection( hwndDeviceList );
                    if( NULL == pDevInfoData )
                    {
                        // No DeviceInfoData available
                        
;//CPRINCE: HANDLE THIS !
//
//CPRINCE: 'return' IF ERROR !?! (so we don't do the following stuff; maybe 'else' will work, too)
                    }


                    //
                    // Call function to add (or remove) the filter on selected device
                    //
                    if( IDB_ADDFILTER == LOWORD(wParam) )
                    {
                        // Add filter
                        AddRemoveFilterOnDevice( hwndDlg, hDevInfo, pDevInfoData, TRUE );
                        UI_UpdateUpperFilterList( hwndDlg, hDevInfo, pDevInfoData );
                    }
                    else
                    {
                        // see if filter is installed...
                        if( FilterIsInstalledOnDevice(hDevInfo, pDevInfoData) )
                        {
                            // Remove filter
                            AddRemoveFilterOnDevice( hwndDlg, hDevInfo, pDevInfoData, FALSE );
                            UI_UpdateUpperFilterList( hwndDlg, hDevInfo, pDevInfoData );
                        } else {
                            // filter isn't currently installed, so can't remove it!
                            MessageBox( hwndDlg,
                                        "Filter isn't currently installed, so can't remove it!",
                                        "Notice",
                                        MB_OK
                                      );
                        }
                        
                    }

                }
                return TRUE;


                default:
                  return FALSE;
            }

        break; //END: case WM_COMMAND


        default:
            return FALSE;

    } //END: switch( msg )


}


//--------------------------------------------------------------------------
//
//--------------------------------------------------------------------------
void UI_UpdateAffinityMaskString( HWND hwndParentDlg,
                                  HDEVINFO hDevInfo,
                                  PSP_DEVINFO_DATA pDevInfoData )
{
    KAFFINITY dwAffinity;
    TCHAR szAffinityMask[64];  // BUGBUG (technically).  Fixed size, though this
                               // should be _way_ larger than we'll ever need.


    if( GetFilterAffinityMask(hDevInfo, pDevInfoData, &dwAffinity) )
    {
        // Got the affinity mask, so we'll display that
        _sntprintf( szAffinityMask, ARRAYSIZE(szAffinityMask), "0x%0IX", dwAffinity );
    }
    else
    {
        // Didn't get an affinity mask; we'll display appropriate alternative
        _sntprintf( szAffinityMask, ARRAYSIZE(szAffinityMask), "N/A" );
    }

    szAffinityMask[ARRAYSIZE(szAffinityMask)-1] = _T('\0');  // be safe

    SetDlgItemText( hwndParentDlg,
                    IDS_CURRAFFINITYMASK,
                    szAffinityMask
                 );

}


//--------------------------------------------------------------------------
//
//--------------------------------------------------------------------------
void UI_UpdateUpperFilterList( HWND hwndParentDlg,
                               HDEVINFO hDevInfo,
                               PSP_DEVINFO_DATA pDevInfoData )
{
    HWND    hwndUpperFilterList;
    LPTSTR  pMultiSzUpperFilters;

    //
    // Get a handle to the upper-filter listbox
    //
    hwndUpperFilterList = GetDlgItem( hwndParentDlg, IDL_UPPERFILTERS );


    //
    // Empty the listbox...
    //
    while( LB_ERR != SendMessage(hwndUpperFilterList, LB_DELETESTRING, 0, 0) )
        NULL;


    //
    // Add new entries to the upper-filter listbox
    //
    pMultiSzUpperFilters = GetUpperFilters( hDevInfo, pDevInfoData );

    if( NULL != pMultiSzUpperFilters )
    {
        // Go through the MultiSz, adding each item to our listbox
        int    filterPosition = 0;
        LPTSTR pCurrString    = pMultiSzUpperFilters;


        while( *pCurrString != _T('\0') )
        {
            SendMessage( hwndUpperFilterList, LB_ADDSTRING, 0, (LPARAM)pCurrString );  // NOTE: item automatically gets added at end of list (unless list sorted)

            // increment pointer to next item in the MultiSz
            pCurrString += _tcslen(pCurrString) + 1;
            filterPosition++;
        }

        // Now free this buffer that was allocated for us
        free( pMultiSzUpperFilters );
    }





}


//--------------------------------------------------------------------------
//
//CPRINCE:  must pass-in hwnd for Main dialog window here!!! (not just any
//          "parent" window.
//--------------------------------------------------------------------------
void UI_UpdateDevObjString( HWND hwndMainDlg,
                            HDEVINFO hDevInfo,
                            PSP_DEVINFO_DATA pDevInfoData )
{
    LPTSTR  szTemp;
    DWORD   regDataType;


    szTemp =
        (LPTSTR) GetDeviceRegistryProperty( hDevInfo,
                                            (PSP_DEVINFO_DATA) pDevInfoData,
                                            SPDRP_PHYSICAL_DEVICE_OBJECT_NAME,
                                            REG_SZ,
                                            &regDataType
                                          );
    if( NULL == szTemp )
    {
        // ERROR: registry property doesn't exist, or we can't access it
        SetDlgItemText( hwndMainDlg,
                        IDS_DEVOBJNAME,
                        "ERROR -- not accessible"  /* b/c this should be available for all devices */
                      );  //CPRINCE: DO WE NEED TO UNICODE-IZE THIS ???
    }
    else
    {
        // Use the data...
        SetDlgItemText( hwndMainDlg,
                        IDS_DEVOBJNAME,
                        szTemp
                      );

        // Free the buffer that was allocated for us
        free( szTemp );
    }

}


//--------------------------------------------------------------------------
//
//CPRINCE:  must pass-in hwnd for Main dialog window here!!! (not just any
//          "parent" window.
//--------------------------------------------------------------------------
void UI_UpdateLocationInfoString( HWND hwndMainDlg,
                                  HDEVINFO hDevInfo,
                                  PSP_DEVINFO_DATA pDevInfoData )
{
    LPTSTR  szTemp;
    DWORD   regDataType;


    szTemp =
        (LPTSTR) GetDeviceRegistryProperty( hDevInfo,
                                            (PSP_DEVINFO_DATA) pDevInfoData,
                                            SPDRP_LOCATION_INFORMATION,
                                            REG_SZ,
                                            &regDataType
                                          );
    if( NULL == szTemp )
    {
        // ERROR: registry property doesn't exist, or we can't access it
        SetDlgItemText( hwndMainDlg,
                        IDS_LOCATIONINFO,
                        "N/A"  /* b/c this might not be available for all devices */
                      );  //CPRINCE: DO WE NEED TO UNICODE-IZE THIS ???
    }
    else
    {
        // Use the data...
        SetDlgItemText( hwndMainDlg,
                        IDS_LOCATIONINFO,
                        szTemp
                      );

        // Free the buffer that was allocated for us
        free( szTemp );
    }

}


//--------------------------------------------------------------------------
//
//CPRINCE:  must pass-in hwnd for Main dialog window here!!! (not just any
//          "parent" window.
//--------------------------------------------------------------------------
void UI_PromptForDeviceRestart( HWND hwndMainDlg,
                                HDEVINFO hDevInfo,
                                PSP_DEVINFO_DATA pDevInfoData )
{

    if( BST_CHECKED == IsDlgButtonChecked(hwndMainDlg, IDC_DONTRESTART) )
    {
        // CheckBox indicates that user doesn't want to restart device.
        MessageBox( hwndMainDlg,
                    "Your changes will take effect the next time the device is restarted.",
                    "Notice",
                    MB_OK
                  );
    }
    else
    {
        int response;

        // Prompt the user to see if (s)he wants to restart the device
        // (in order for changes to take effect)
        response = MessageBox( hwndMainDlg,
                               "Your changes will not take effect until the device is restarted.\n\n"
                                 "Would you like to attempt to restart the device now?",
                               "Restart Device?",
                               MB_YESNO
                             );
        if( IDYES == response )
        {
            // Try to restart the device.
            RestartDevice_WithUI( hwndMainDlg, hDevInfo, pDevInfoData );
        }
        else if( IDNO == response )
        {
            // Don't try to restart the device.
            // (But let user know that changes won't take effect right away.)
            MessageBox( hwndMainDlg,
                        "Changes will take effect the next time you reboot.",
                        "Notice",
                        MB_OK );
        }
        else
        {
            // Some kind of error occurred.
            // Ignore it (what else can we do?)
        }
    }


}


//--------------------------------------------------------------------------
//CPRINCE NOTE: because of fact that we call UI_UpdateUpperFilterList(), we
//CPRINCE   must pass-in hwnd for Main dialog window here!!! (not just any
//          "parent" window.
//--------------------------------------------------------------------------
void UI_PromptForInstallFilterOnDevice( HWND hwndMainDlg,
                                        HDEVINFO hDevInfo,
                                        PSP_DEVINFO_DATA pDevInfoData )
{
    int response;

    // Prompt the user
    response = MessageBox( hwndMainDlg,
                           "Your changes will not have any effect unless the filter is "
                             "installed on this device.\n\n"
                             "Would you like to install the filter on this device now?",
                           "Install Filter On Device?",
                           MB_YESNO
                         );
    if( IDYES == response )
    {
        // Install the filter
        AddRemoveFilterOnDevice( hwndMainDlg, hDevInfo, pDevInfoData, TRUE );
        UI_UpdateUpperFilterList( hwndMainDlg, hDevInfo, pDevInfoData );
    }
    else if( IDNO == response )
    {
        // User said "No", so they probably know what they're doing.
        // So no response from us here.
    }
    else
    {
        // Some kind of error occurred.
        // Ignore it (what else can we do?)
    }

}


//--------------------------------------------------------------------------
//
//--------------------------------------------------------------------------
void RestartDevice_WithUI( HWND hwndParentDlg,
                           HDEVINFO hDevInfo,
                           PSP_DEVINFO_DATA pDevInfoData )
{
    BOOLEAN status;

    // Restart the device
    //   (but can take a while, so change cursor to
    //   hourglass while it's happening)
    SetCursor( g_hCursors[1] );  // hourglass
    status = RestartDevice( hDevInfo, pDevInfoData );
    SetCursor( g_hCursors[0] );  // back to normal

    if( status )
    {
        // Successfully restarted
        MessageBox( hwndParentDlg,
                    "Device successfully restarted.",
                    "Notice",
                    MB_OK );
//CPRINCE: NEED TO UNICODE-IZE ALL MessageBox CALLS, TOO ?!
//CPRINCE: SHOULD CHANGE hWndParent IN ALL MESSAGEBOX CALLS TO THE DIALOG BOX ???

    }
    else
    {
        // Couldn't restart; user must reboot for changes to take effect
        MessageBox( hwndParentDlg,
                    "Device could not be restarted.  Changes will take effect the next time you reboot.",
                    "Notice",
                    MB_OK );
    }

}




//--------------------------------------------------------------------------
//
// CPRINCE: THIS IS THE DIALOG-BOX CALLBACK FOR SETTING THE AFFINITY MASK
// <<NOTE: mostly ripped from TaskMgr>>
//
//--------------------------------------------------------------------------
INT_PTR CALLBACK DlgProc_Affinity( HWND hwndDlg,  UINT uMsg,
                                WPARAM wParam,  LPARAM lParam )
{
    static KAFFINITY * pdwAffinity = NULL;      // One of the joys of single threadedness
    int i;

    switch( uMsg )
    {
        case WM_INITDIALOG:
        {
            pdwAffinity = (KAFFINITY *) lParam;

            //
            // Initialize check-boxes in dialog box (to the correct
            // enabled/disabled and checked/unchecked states)
            //
            for( i=0 ; i<MAX_PROCESSOR ; i++ )
            {
                BOOL fIsActiveProcessor;  // CPU exists in system
                BOOL fIsSelectedProcessor;  // CPU is selected in affinity mask

                fIsActiveProcessor   = ( (g_dwActiveProcessorMask & ((KAFFINITY)1 << i)) != 0 );
                fIsSelectedProcessor = ( (*pdwAffinity            & ((KAFFINITY)1 << i)) != 0 );
                    
                EnableWindow( GetDlgItem(hwndDlg, IDC_CPU0 + i) ,
                              fIsActiveProcessor // enable or disable
                            );
                CheckDlgButton( hwndDlg,
                                IDC_CPU0 + i,
                                fIsActiveProcessor && fIsSelectedProcessor
                              );
            }
            return TRUE;
        }

        case WM_COMMAND:
        {
            switch( LOWORD(wParam) )
            {
                case IDCANCEL:
                    EndDialog( hwndDlg, IDCANCEL );
                    break;

                case IDOK:
                {
                    //
                    // Use user-selected CPUs to create affinity mask
                    //
                    *pdwAffinity = 0;
                    for( i=0 ; i<MAX_PROCESSOR ; i++ )
                    {
                        if( IsDlgButtonChecked(hwndDlg, IDC_CPU0 + i) )
                        {
                            ASSERT(  (1 << i) & g_dwActiveProcessorMask  );
                            *pdwAffinity |= ((KAFFINITY)1 << i);
                        }
                    }

                    //
                    // Make sure affinity isn't set to "none" (don't want to allow that)
                    //
                    if( *pdwAffinity == 0 )
                    {
                        // Oops - user set affinity to "none"

                        TCHAR szTitle[] = _T("Invalid Option");
                        TCHAR szBody[]  = _T("The affinity mask must contain at least one processor.");
/* CPRINCE: THE FOLLOWING BLOCK IS THE ORIGINAL VERSION FROM TASKMGR -- CAN REMOVE IT, OR IS IT "BETTER" WAY TO DO THINGS ? (FOR LOCALIZATION, ETC)
                        TCHAR szTitle[MAX_PATH];
                        TCHAR szBody[MAX_PATH];


                        if( 0 == LoadString(g_hInstance, IDS_INVALIDOPTION, szTitle, ARRAYSIZE(szTitle)) ||
                            0 == LoadString(g_hInstance, IDS_NOAFFINITYMASK, szBody,  ARRAYSIZE(szBody))    )
                        {
                            break; // out of this switch statement
                        }
END CPRINCE */
                        MessageBox( hwndDlg, szBody, szTitle, MB_OK | MB_ICONERROR );
                    }
                    else
                    {
                        // OK, got valid affinity mask. We can exit
                        EndDialog( hwndDlg, IDOK );
                    }
                }
                break;

                //no Default case needed

            } //END: switch( LOWORD(wParam) )
        }
    }

    return FALSE;
}



//--------------------------------------------------------------------------
//
// Sets the interrupt-filter's affinity mask on a particular device.
//
// Return Value:
//   Returns TRUE if function succeeds, or FALSE if an error occurs.
//--------------------------------------------------------------------------
BOOL SetFilterAffinityMask( HDEVINFO hDevInfo,
                            PSP_DEVINFO_DATA pDevInfoData,
                            KAFFINITY affinityMask )
{
    HKEY hkeyDeviceParams;
    LONG lRetVal;
    BOOL fToReturn = TRUE;  // success


    //
    // Get a handle to the device's "Device Parameters" registry subkey
    //
    hkeyDeviceParams = SetupDiOpenDevRegKey( hDevInfo,
                                             pDevInfoData,
                                             DICS_FLAG_GLOBAL,  //CPRINCE: SHOULD (CAN?) USE 'DICS_FLAG_CONFIGSPECIFIC' INSTEAD ???
                                             0,
                                             DIREG_DEV,
                                             KEY_WRITE  // desired access
                                           );

    if( INVALID_HANDLE_VALUE == hkeyDeviceParams )
    {
        // Error opening device registry key...
        //
        // If error occurred because "Device Parameters" sub-key does
        // not exist, then try to create that sub-key.

        // NOTE: when we call GetLastError() here, we're getting an invalid
        // error code.  So let's just _assume_ (yeah, I know) that the error
        // was because the key does not exist, and try to create it here.

        hkeyDeviceParams = SetupDiCreateDevRegKey( hDevInfo,
                                                   pDevInfoData,
                                                   DICS_FLAG_GLOBAL,  //CPRINCE: SHOULD (CAN?) USE 'DICS_FLAG_CONFIGSPECIFIC' INSTEAD ???
                                                   0,
                                                   DIREG_DEV,
                                                   NULL,
                                                   NULL
                                                 );
        if( INVALID_HANDLE_VALUE == hkeyDeviceParams )
        {
            // OK, we can't open and can't create the key.  Let's
            // face it, we've failed, so return now.
            MessageBox_FromErrorCode( GetLastError() );
            return FALSE;
        }
        //ELSE: we were able to create the key, so keep going...
    }


    //
    // Set the desired registry value
    //
    lRetVal = RegSetValueEx( hkeyDeviceParams,
                             FILTER_REGISTRY_VALUE,
                             0,
                             REG_KAFFINITY,
                             (BYTE*)&affinityMask,
                             sizeof(KAFFINITY)
                           );

    if( ERROR_SUCCESS != lRetVal )
    {
        MessageBox_FromErrorCode( lRetVal );
        fToReturn = FALSE;  // failure
    }


    //
    // Close the registry key(s) we opened
    //
    lRetVal = RegCloseKey( hkeyDeviceParams );
    if( ERROR_SUCCESS != lRetVal )
    {
        MessageBox_FromErrorCode( lRetVal );
        fToReturn = FALSE;  // failure
    }


    return fToReturn;
}



//--------------------------------------------------------------------------
//
// Retrieves the interrupt-filter's affinity mask on a particular device.
//
// NOTE: If function fails (ie returns FALSE), then the value stored into
// the 'pAffinityMask' parameter should be considered invalid.
//
// Return Value:
//   Returns TRUE if function succeeds, or FALSE if an error occurs.
//--------------------------------------------------------------------------
BOOL GetFilterAffinityMask( HDEVINFO hDevInfo,
                            PSP_DEVINFO_DATA pDevInfoData,
                            KAFFINITY* pAffinityMask )
{
    HKEY  hkeyDeviceParams;
    LONG  lRetVal;
    BOOL  fToReturn = TRUE;  // success
    DWORD regValueType;
    DWORD regValueSize;


    ASSERT( NULL != pAffinityMask );


    //
    // Get a handle to the device's "Device Parameters" registry subkey
    //
    hkeyDeviceParams = SetupDiOpenDevRegKey( hDevInfo,
                                             pDevInfoData,
                                             DICS_FLAG_GLOBAL,  //CPRINCE: SHOULD (CAN?) USE 'DICS_FLAG_CONFIGSPECIFIC' INSTEAD ???
                                             0,
                                             DIREG_DEV,
                                             KEY_QUERY_VALUE  // desired access
                                           );

    if( INVALID_HANDLE_VALUE == hkeyDeviceParams )
    {
        // Probably just means that the "Device Parameters" subkey
        // does not exist, so return, but _don't_ display error message.
        return FALSE;  // failure
    }


    //
    // Get the desired registry value
    //
    regValueSize = sizeof(KAFFINITY);
    lRetVal = RegQueryValueEx( hkeyDeviceParams,
                               FILTER_REGISTRY_VALUE,
                               0,
                               &regValueType,
                               (BYTE*)pAffinityMask,
                               &regValueSize
                             );

    if( ERROR_SUCCESS != lRetVal )
    {
        if( ERROR_FILE_NOT_FOUND == lRetVal )
        {
            // Just means key didn't already exist.
            // So don't display error message.
        }
        else
        {
            MessageBox_FromErrorCode( lRetVal );
        }
        fToReturn = FALSE; // failure
    }
    else if( REG_KAFFINITY != regValueType )
    {
        MessageBox( NULL,
                    "Registry value for affinity mask has unexpected type.",
                    "Error",
                    MB_OK | MB_ICONERROR
                  );
        fToReturn = FALSE;  // failure
    }


    //
    // Close the registry key(s) we opened
    //
    lRetVal = RegCloseKey( hkeyDeviceParams );
    if( ERROR_SUCCESS != lRetVal )
    {
        MessageBox_FromErrorCode( lRetVal );
        fToReturn = FALSE;  // failure
    }


    return fToReturn;
}


//--------------------------------------------------------------------------
//
// Deletes the interrupt-filter's affinity mask regkey for a particular device.
//
// Return Value:
//   Returns TRUE if regkey was successfully deleted (or never existed), or
//   FALSE otherwise.
//--------------------------------------------------------------------------
BOOL DeleteFilterAffinityMask( HDEVINFO hDevInfo,
                               PSP_DEVINFO_DATA pDevInfoData )
{
    HKEY hkeyDeviceParams;
    LONG lRetVal;
    BOOL fToReturn = TRUE;  // success


    //
    // Get a handle to the device's "Device Parameters" registry subkey
    //
    hkeyDeviceParams = SetupDiOpenDevRegKey( hDevInfo,
                                             pDevInfoData,
                                             DICS_FLAG_GLOBAL,  //CPRINCE: SHOULD (CAN?) USE 'DICS_FLAG_CONFIGSPECIFIC' INSTEAD ???
                                             0,
                                             DIREG_DEV,
                                             KEY_SET_VALUE  // desired access
                                           );

    if( INVALID_HANDLE_VALUE == hkeyDeviceParams )
    {
        // Probably means that the "Device Parameters" subkey
        // does not exist, so there wouldn't be any values stored
        // under this (non-existent) subkey.
        //
        // So return success, but display MessageBox just so
        // user knows we _did_ do something.
        MessageBox( NULL,
                    "There was no 'Device Parameters' registry key for this device.",
                    "Notice",
                    MB_OK );

        return TRUE;
    }


    //
    // Delete the desired registry key
    //
    lRetVal = RegDeleteValue( hkeyDeviceParams,
                              FILTER_REGISTRY_VALUE
                            );

    if( ERROR_SUCCESS != lRetVal )
    {
        // Was this truly an "error", or did we get
        // here because the RegVal just doesn't exist?
        if( ERROR_FILE_NOT_FOUND == lRetVal )
        {
            // RegVal just doesn't exist
            MessageBox( NULL,
                        "There was no interrupt-affinity-mask registry value for this device.",
                        "Notice",
                        MB_OK
                      );
        }
        else
        {
            // a "real" error
            MessageBox_FromErrorCode( lRetVal );
            fToReturn = FALSE;  // failure
        }
    }
    else
    {
        // MessageBox just so user gets some feedback, and knows 
        // that the deletion was successful (and actually occurred!)
        MessageBox( NULL,
                    "The interrupt-affinity-mask for this device was successully deleted from the registry.",
                    "Deletion Successful",
                    MB_OK
                  );
    }


    //
    // Close the registry key(s) we opened
    //
    lRetVal = RegCloseKey( hkeyDeviceParams );
    if( ERROR_SUCCESS != lRetVal )
    {
        MessageBox_FromErrorCode( lRetVal );
        fToReturn = FALSE;  // failure
    }


    return fToReturn;
}




//--------------------------------------------------------------------------
//
//CPRINCE:  must pass-in hwnd for Main dialog window here!!! (not just any
//          "parent" window.
//
// Parameters:
//   CPRINCE - NEED TO FILL IN THE REST OF THESE
//   fAddingFilter - set to TRUE to add filter, FALSE to remove filter
//--------------------------------------------------------------------------
void AddRemoveFilterOnDevice( HWND hwndMainDlg,
                              HDEVINFO hDevInfo,
                              PSP_DEVINFO_DATA pDevInfoData,
                              BOOL fAddingFilter )
{
    BOOLEAN (* fnChangeUpperFilter)( HDEVINFO, PSP_DEVINFO_DATA, LPTSTR );  // a convenient func ptr
    BOOLEAN status;


    //
    // Setup convenient value(s)
    //
    if( fAddingFilter )
        fnChangeUpperFilter = AddUpperFilterDriver;
    else
        fnChangeUpperFilter = RemoveUpperFilterDriver;


    //
    // Change the device's filter settings.
    // Then try to restart the device.
    //
    status = fnChangeUpperFilter( hDevInfo, pDevInfoData, FILTER_SERVICE_NAME );
    if( ! status )
    {
        // Unable to add (or remove) filter driver
        MessageBox( hwndMainDlg , "Unable to add/remove filter driver.", "Error", MB_OK | MB_ICONERROR );
    }
    else
    {
        // Filter successfully added/removed.
        // Now try to explicitly restart the device (if user wants to),
        // so that user doesn't need to reboot.
        if( BST_CHECKED == IsDlgButtonChecked(hwndMainDlg, IDC_DONTRESTART) )
        {
            // User has indicated that doesn't want to restart device when
            // filter is being added/removed, so don't try to restart the
            // device now.
            //
            // Thus nothing to do here.
        }
        else
        {
            MessageBox( hwndMainDlg,
                        "Filter driver has been successfully added/removed.  Will now attempt to restart device...",
                        "Success",
                        MB_OK );

            RestartDevice_WithUI( hwndMainDlg, hDevInfo, pDevInfoData );
        }

        //
        // Update (on-screen) the list of UpperFilters
        //
        UI_UpdateUpperFilterList( hwndMainDlg, hDevInfo, pDevInfoData );
    }

}





//--------------------------------------------------------------------------
//
// CPRINCE: RETRIEVES THE ITEM DATA ASSOCIATED WITH THE CURRENTLY SELECTED ITEM IN THE GIVEN LISTBOX
//--------------------------------------------------------------------------
LPARAM GetItemDataCurrentSelection( HWND hwndListBox )
{
    int    idxItem;

    idxItem = (int)SendMessage(hwndListBox, LB_GETCURSEL, 0, 0);
    return(  SendMessage(hwndListBox, LB_GETITEMDATA, idxItem, 0)  );
}


//--------------------------------------------------------------------------
//   MessageBox_FromErrorCode
//
// Given a system error code (such as that returned by 'GetLastError'),
// displays a MessageBox describing, in words, what the error was/means.
//--------------------------------------------------------------------------
void MessageBox_FromErrorCode( LONG systemErrorCode )
{
    void* pBuffer;

    FormatMessage(   FORMAT_MESSAGE_ALLOCATE_BUFFER
                       | FORMAT_MESSAGE_FROM_SYSTEM // using system error code
                       | FORMAT_MESSAGE_IGNORE_INSERTS // no translation of string
                   , NULL  // input string
                   , systemErrorCode // message ID
                   , 0   // language ID (0 == DontCare)
                   , (LPTSTR)(&pBuffer) // buffer for output
                   , 0
                   , NULL
                  );
    MessageBox( NULL, pBuffer, "Error", MB_OK | MB_ICONERROR );
    LocalFree( pBuffer );  // OK to pass null here
}




//--------------------------------------------------------------------------
//   FilterIsInstalledOnDevice
//
// Returns boolean value stating whether the filter is currently installed
// as an UpperFilter on the given device.
//
// Return Value:
//   Returns TRUE if installed, FALSE if not installed (or if error occurs)
//--------------------------------------------------------------------------
BOOL FilterIsInstalledOnDevice( HDEVINFO hDevInfo,
                                PSP_DEVINFO_DATA pDevInfoData )
{
    LPTSTR mszUpperFilterList;

    // Get MultiSz list of upper filters installed on device
    mszUpperFilterList = GetUpperFilters( hDevInfo, pDevInfoData );

    if( NULL == mszUpperFilterList )
    {
        return FALSE; // failure
    }

    // Search the list to see if our filter is there
    // (NOTE: filter names are case-INsensitive)
    if( MultiSzSearch(FILTER_SERVICE_NAME, mszUpperFilterList, FALSE, NULL) )
    {
        return TRUE; // found it!
    }
    //ELSE...
        return FALSE;  // not found, or error occurred
}


//--------------------------------------------------------------------------
//
//--------------------------------------------------------------------------

//CPRINCE: SHOULD HAVE BETTER NAME FOR THIS FUNCTION.... (PrepareForShutdown ???)
void ExitProgram( HWND hwndDlg, HDEVINFO* phDevInfo )
{
    int    i;
    HWND   hwndDeviceList;
    LPARAM itemData;

    
    hwndDeviceList = GetDlgItem( hwndDlg, IDL_DEVICES );



    //
    // Free all memory that was allocated for dialog-box list
    //
    for( i = 0  ;  i < g_nDialogItems  ;  i++ )
    {
        // Get item's associated data
        itemData = SendMessage( hwndDeviceList,
                                LB_GETITEMDATA,
                                i,
                                0
                              );
        // We stored pointer to alloc'd memory (or NULL, if error).
        // So free it now.
        free( (void*)itemData );    //CPRINCE CHECK: PROBLEM W/POINTERS AND 64-BIT MACHINES ???
    }


    //
    // Clean up the device list
    //
    if( *phDevInfo != INVALID_HANDLE_VALUE )
    {
        SetupDiDestroyDeviceInfoList( *phDevInfo );
//CPRINCE: WHAT TO DO IF THIS CALL FAILS ???  ANYTHING ???
        *phDevInfo = INVALID_HANDLE_VALUE;
    }



    //
    // Destroy the dialog box.
    //
    EndDialog( hwndDlg, TRUE );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\intfilter\src\config\addfiltr.c ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    addfiltr.c

Abstract:

    Functions for adding/removing filter drivers
    on a given device stack

Author:

    Chris Prince (t-chrpri)

Environment:

    User mode

Notes:

    - The filter is not checked for validity before it is added to the
        driver stack; if an invalid filter is added, the device may
        no longer be accessible.
    - All code works irrespective of character set (ANSI, Unicode, ...)
        //CPRINCE IS ^^^^^^ THIS STILL VALID ???
    - Some functions based on code by Benjamin Strautin (t-bensta)

Revision History:

--*/

#include "addfiltr.h"


#include <stdio.h>
#include <malloc.h>


// for all of the _t stuff (to allow compiling for both Unicode/Ansi)
#include <tchar.h>


#include "MultiSz.h"



#if DBG
#include <assert.h>
#define ASSERT(condition) assert(condition)
#else
#define ASSERT(condition)
#endif




//
// To add/remove filter drivers:
// -----------------------------
// 1. Use SetupDiGetClassDevs to get a list of devices
// 2. Use SetupDiEnumDeviceInfo to enumerate the items in that list and
//      obtain a SP_DEVINFO_DATA
// 3. Use SetupDiGetDeviceRegistryProperty to get a list of filter drivers
//      installed on some device
// 4. Add/remove items in this list of filter drivers
// 5. Use SetupDiSetDeviceRegistryProperty to put the (new) list back in place
//
//
// To restart a device:
// --------------------
// 1. Use SetupDiCallClassInstaller with DIF_PROPERTYCHANGE and DICS_STOP to
//      stop the device
// 2. Use SetupDiCallClassInstaller with DIF_PROPERTYCHANGE and DICS_START to
//      restart the device
//




/*
 * Returns a buffer containing the list of upper filters for the device.
 *
 * NOTE(S):  - The buffer must be freed by the caller.
 *           - If an error occurs, no buffer will be allocated, and NULL
 *             will be returned.
 * 
 * Parameters:
 *   DeviceInfoSet  - The device information set which contains DeviceInfoData
 *   DeviceInfoData - Information needed to deal with the given device
 */
LPTSTR
GetUpperFilters(
    IN HDEVINFO DeviceInfoSet,
    IN PSP_DEVINFO_DATA DeviceInfoData
    )
{
    DWORD  regDataType;
    LPTSTR buffer = (LPTSTR) GetDeviceRegistryProperty( DeviceInfoSet,
                                                        DeviceInfoData,
                                                        SPDRP_UPPERFILTERS,
                                                        REG_MULTI_SZ,
                                                        &regDataType );

    return buffer;
}




/*
 * Adds the given filter driver to the list of upper filter drivers for the
 * device.
 *
 * After the call, the device must be restarted in order for the new setting to
 * take effect. This can be accomplished with a call to RestartDevice(), or by
 * rebooting the machine.
 *
 * Returns TRUE if successful, FALSE otherwise
 *
 * NOTE: The filter is prepended to the list of drivers, which will put it at
 * the bottom of the stack of upper filters
 *
 * Parameters:
 *   DeviceInfoSet  - The device information set which contains DeviceInfoData
 *   DeviceInfoData - Information needed to deal with the given device
 *   Filter         - the filter to add
 */
BOOLEAN
AddUpperFilterDriver(
    IN HDEVINFO DeviceInfoSet,
    IN PSP_DEVINFO_DATA DeviceInfoData,
    IN LPTSTR Filter
    )
{
    size_t length = 0; // character length
    size_t size   = 0; // buffer size
    LPTSTR buffer = NULL;
    
    ASSERT(DeviceInfoData != NULL);
    ASSERT(Filter != NULL);

    buffer = GetUpperFilters( DeviceInfoSet, DeviceInfoData );

    if( NULL == buffer )
    {
        // Some error occurred while trying to read the 'UpperFilters'
        // registry value.  So maybe no such value exists yet, or it's
        // invalid, or some other error occurred.
        //
        // In any case, let's just try to install a new registry value for
        // 'UpperFilters'

        // make room for the string, string null terminator, and multisz null
        // terminator
        length = _tcslen(Filter) + 2;
        size   = length*sizeof(_TCHAR);
        buffer = malloc( size );
        if( NULL == buffer )
        {
            // Error: Unable to allocate memory
            return FALSE ;
        }

        // copy the string into the new buffer
        _tcscpy(buffer, Filter);
        // make the buffer a properly formed multisz
        buffer[length-1]=_T('\0');
    }
    else
    {
        // add the driver to the driver list
        PrependSzToMultiSz(Filter, &buffer);
    }

    length = MultiSzLength(buffer);
    size   = length*sizeof(_TCHAR);

    // set the new list of filters in place
    if( !SetupDiSetDeviceRegistryProperty( DeviceInfoSet,
                                           DeviceInfoData,
                                           SPDRP_UPPERFILTERS,
                                           (PBYTE)buffer,
                                           size )
        )
    {
        // Error: couldn't set device registry property
        free( buffer );
        return FALSE;
    }

    // no need for buffer anymore
    free( buffer );

    return TRUE;
}


/*
 * Removes all instances of the given filter driver from the list of upper
 * filter drivers for the device.
 *
 * After the call, the device must be restarted in order for the new setting to
 * take effect. This can be accomplished with a call to RestartDevice(), or by
 * rebooting the machine.
 *
 * Returns TRUE if successful, FALSE otherwise.
 *
 * Parameters:
 *   DeviceInfoSet  - The device information set which contains DeviceInfoData
 *   DeviceInfoData - Information needed to deal with the given device
 *   Filter - the filter to remove
 */
BOOLEAN
RemoveUpperFilterDriver(
    IN HDEVINFO DeviceInfoSet,
    IN PSP_DEVINFO_DATA DeviceInfoData,
    IN LPTSTR Filter
    )
{
    size_t length = 0; // character length
    size_t size   = 0; // buffer size
    LPTSTR buffer;
    BOOL   success = FALSE;

    ASSERT(DeviceInfoData != NULL);
    ASSERT(Filter != NULL);

    buffer = GetUpperFilters( DeviceInfoSet, DeviceInfoData );

    if( NULL == buffer )
    {
        // if there is no such value in the registry, then there are no upper
        // filter drivers loaded, and we are done
        return TRUE;
    }
    else
    {
        // remove all instances of filter from driver list
        MultiSzSearchAndDeleteCaseInsensitive( Filter, buffer, &length );
    }

    length = MultiSzLength(buffer);

    ASSERT ( length > 0 );

    if( 1 == length )
    {
        // if the length of the list is 1, the return value from
        // MultiSzLength() was just accounting for the trailing '\0', so we can
        // delete the registry key, by setting it to NULL.
        success = SetupDiSetDeviceRegistryProperty( DeviceInfoSet,
                                                    DeviceInfoData,
                                                    SPDRP_UPPERFILTERS,
                                                    NULL,
                                                    0 );
    }
    else
    {
        // set the new list of drivers into the registry
        size = length*sizeof(_TCHAR);
        success = SetupDiSetDeviceRegistryProperty( DeviceInfoSet,
                                                    DeviceInfoData,
                                                    SPDRP_UPPERFILTERS,
                                                    (PBYTE)buffer,
                                                    size );
    }

    // no need for buffer anymore
    free( buffer );

    if( !success )
    {
        // Error: couldn't set device registry property
        return FALSE;
    }

    return TRUE;
}




/*
 * A wrapper around SetupDiGetDeviceRegistryProperty, so that we don't have to
 * deal with memory allocation anywhere else, and so that we don't have to
 * duplicate a lot of error-checking code.
 *
 * If successful, returns pointer to newly allocated buffer containing the
 * requested registry property.  Otherwise returns NULL.
 *
 * NOTE: It is the caller's responsibility to free the buffer allocated here.
 *
 * Parameters:
 *   DeviceInfoSet  - The device information set which contains DeviceInfoData
 *   DeviceInfoData - Information needed to deal with the given device
 *   Property       - Which property to get (SPDRP_XXX)
 *   ExpectedRegDataType - The type of registry property the caller is
 *                         expecting (or REG_NONE if don't care)
 *   pPropertyRegDataType - The type of registry property actually retrieved
 */
PBYTE
GetDeviceRegistryProperty(
    IN HDEVINFO DeviceInfoSet,
    IN PSP_DEVINFO_DATA DeviceInfoData,
    IN DWORD Property,
    IN DWORD    ExpectedRegDataType,
    OUT PDWORD pPropertyRegDataType
    )
{
    DWORD length = 0;
    PBYTE buffer = NULL;

    //
    // Get the required length of the buffer
    //
    if( SetupDiGetDeviceRegistryProperty( DeviceInfoSet,
                                          DeviceInfoData,
                                          Property,
                                          NULL,   // registry data type
                                          NULL,   // buffer
                                          0,      // buffer size
                                          &length // [OUT] required size
        ) )
    {
        // We should not be successful at this point (since we passed in a
        // zero-length buffer), so this call succeeding is an error condition
        return NULL;
    }


    if( GetLastError() != ERROR_INSUFFICIENT_BUFFER )
    {
        // This is an error condition we didn't expect.  Something must have
        // gone wrong when trying to read the desired device property, so...
        //
        // NOTE: caller can use GetLastError() for more info
        return NULL;
    }


    // 
    // We didn't have a buffer before (hence the INSUFFICIENT_BUFFER error).
    // Now that we know required size, let's allocate a buffer and try again.
    //
    buffer = malloc( length );
    if( NULL == buffer )
    {
/* CPRINCE: SHOULD WE INDICATE EXACTLY _WHAT_ ERROR WAS VIA A RETURN CODE ??? (IE INFO THAT'S MORE USEFUL) */
        // Error: not enough memory
        return NULL;
    }
    if( !SetupDiGetDeviceRegistryProperty( DeviceInfoSet,
                                           DeviceInfoData,
                                           Property,
                                           pPropertyRegDataType,
                                           buffer,
                                           length, // buffer size
                                           NULL
        ) )
    {
        // Oops, error when trying to read the device property
        free( buffer );
        return NULL;
    }


    //
    // Successfully retrieved the device registry property.  Let's make
    // sure it has the right type.
    //
    if( ExpectedRegDataType != REG_NONE
        &&  ExpectedRegDataType != (*pPropertyRegDataType)  )
    {
        // Registry property has a type different from what caller expected.
        // So an error has occurred somewhere.
        free( buffer );
        return NULL;
    }


    //
    // OK, got device registry property.  Return ptr to buffer containing it.
    //
    return buffer;
}


/*
 * Restarts the given device.
 *
 * Returns TRUE if the device is successfully restarted, or FALSE if the
 *   device cannot be restarted or an error occurs.
 *
 * Parameters:
 *   DeviceInfoSet  - The device information set which contains DeviceInfoData
 *   DeviceInfoData - Information needed to deal with the given device
 */
BOOLEAN
RestartDevice(
    IN HDEVINFO DeviceInfoSet,
    IN OUT PSP_DEVINFO_DATA DeviceInfoData
    )
{
    SP_PROPCHANGE_PARAMS params;
    SP_DEVINSTALL_PARAMS installParams;

    // For future compatibility; this will zero out the entire struct, rather
    // than just the fields which exist now
    memset(&params, 0, sizeof(SP_PROPCHANGE_PARAMS));

    // Initialize the SP_CLASSINSTALL_HEADER struct at the beginning of the
    // SP_PROPCHANGE_PARAMS struct, so that SetupDiSetClassInstallParams will
    // work
    params.ClassInstallHeader.cbSize = sizeof(SP_CLASSINSTALL_HEADER);
    params.ClassInstallHeader.InstallFunction = DIF_PROPERTYCHANGE;

    // Initialize SP_PROPCHANGE_PARAMS such that the device will be stopped.
    params.StateChange = DICS_STOP;
    params.Scope       = DICS_FLAG_CONFIGSPECIFIC;
    params.HwProfile   = 0; // current profile

    // Prepare for the call to SetupDiCallClassInstaller (to stop the device)
    if( !SetupDiSetClassInstallParams( DeviceInfoSet,
                                       DeviceInfoData,
                                       (PSP_CLASSINSTALL_HEADER) &params,
                                       sizeof(SP_PROPCHANGE_PARAMS)
        ) )
    {
        // Error: couldn't set install params
        return FALSE;
    }

    // Stop the device
    if( !SetupDiCallClassInstaller( DIF_PROPERTYCHANGE,
                                    DeviceInfoSet,
                                    DeviceInfoData )
        )
    {
        // Error: call to class installer (for STOP) failed
        return FALSE;
    }

    // Restarting the device
    params.StateChange = DICS_START;

    // Prepare for the call to SetupDiCallClassInstaller (to restart the device)
    if( !SetupDiSetClassInstallParams( DeviceInfoSet,
                                       DeviceInfoData,
                                       (PSP_CLASSINSTALL_HEADER) &params,
                                       sizeof(SP_PROPCHANGE_PARAMS)
        ) )
    {
        // Error: couldn't set install params
        return FALSE;
    }

    // Restart the device
    if( !SetupDiCallClassInstaller( DIF_PROPERTYCHANGE,
                                    DeviceInfoSet,
                                    DeviceInfoData )
        )
    {
        // Error: call to class installer (for START) failed
        return FALSE;
    }

    installParams.cbSize = sizeof(SP_DEVINSTALL_PARAMS);

    // Same as above, the call will succeed, but we still need to check status
    if( !SetupDiGetDeviceInstallParams( DeviceInfoSet,
                                        DeviceInfoData,
                                        &installParams )
        )
    {
        // Error: couldn't get the device install params
        return FALSE;
    }

    // See if the machine needs to be rebooted
    if( installParams.Flags & DI_NEEDREBOOT )
    {
        return FALSE;
    }

    // If we get this far, then the device has been stopped and restarted
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\intfilter\src\filter\filter.h ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    filter.h

Abstract:

    Interrupt-affinity Filter
    (Roughly based on "NULL filter driver" in DDK, by ervinp and t-chrpri)

Author:

    t-chrpri

Environment:

    Kernel mode

Revision History:
    
--*/


enum deviceState {
        STATE_INITIALIZED,
        STATE_STARTING,
        STATE_STARTED,
        STATE_START_FAILED,
        STATE_STOPPED,  // implies device was previously started successfully
        STATE_SUSPENDED,
        STATE_REMOVING,
        STATE_REMOVED
};

#define DEVICE_EXTENSION_SIGNATURE 'tlFI'

typedef struct DEVICE_EXTENSION {

    /*
     *  Memory signature of a device extension, for debugging.
     */
    ULONG signature;

    /*
     *  Plug-and-play state of this device object.
     */
    enum deviceState state;

    /*
     *  The device object that this filter driver created.
     */
    PDEVICE_OBJECT filterDevObj;

    /*
     *  The device object created by the next lower driver.
     */
    PDEVICE_OBJECT physicalDevObj;

    /*
     *  The device object at the top of the stack that we attached to.
     *  This is often (but not always) the same as physicalDevObj.
     */
    PDEVICE_OBJECT topDevObj;

    /*
     *  deviceCapabilities includes a
     *  table mapping system power states to device power states.
     */
    DEVICE_CAPABILITIES deviceCapabilities;

    /*
     *  Keep track of the number of paging/hibernation/crashdump
     *  files that are opened on this device.
     */
    ULONG  pagingFileCount, hibernationFileCount, crashdumpFileCount;
    KEVENT deviceUsageNotificationEvent;
    PVOID  pagingPathUnlockHandle;  /* handle to lock certain code as non-pageable */

    /*
     *  Also, might need to lock certain driver code as non-pageable, based on
     *  initial conditions (as opposed to paging-file considerations).
     */
    PVOID  initUnlockHandle;
    ULONG  initialFlags;

    /*
     *  pendingActionCount is used to keep track of outstanding actions.
     *  removeEvent is used to wait until all pending actions are
     *  completed before complete the REMOVE_DEVICE IRP and let the
     *  driver get unloaded.
     */
    LONG   pendingActionCount;
    KEVENT removeEvent;


    /*
     *  Various parameters used to configure this filter.  Parameters can be
     *  different for each device that this filter gets installed on top of.
     */
    KAFFINITY desiredAffinityMask;  // interrupt affinity mask to use
};


/*
 *  Memory tag for memory blocks allocated by this driver
 *  (used in ExAllocatePoolWithTag() call).
 *  This DWORD appears as "IFlt" in a little-endian memory byte dump.
 */
#define FILTER_TAG (ULONG)'tlFI'


#if DBG
    #define DBGOUT(params_in_parentheses)   \
        {                                               \
            DbgPrint("'INTFILTR> "); \
            DbgPrint params_in_parentheses; \
            DbgPrint("\n"); \
        }
    #define TRAP(msg)  \
        {   \
            DBGOUT(("TRAP at file %s, line %d: '%s'.", __FILE__, __LINE__, msg)); \
            DbgBreakPoint(); \
        }
#else
    #define DBGOUT(params_in_parentheses)
    #define TRAP(msg)
#endif


typedef  unsigned char  BYTE;


/*
 *  Function externs
 */
NTSTATUS    DriverEntry(IN PDRIVER_OBJECT DriverObject, IN PUNICODE_STRING RegistryPath);
NTSTATUS    VA_AddDevice(IN PDRIVER_OBJECT driverObj, IN PDEVICE_OBJECT pdo);
VOID        VA_DriverUnload(IN PDRIVER_OBJECT DriverObject);
NTSTATUS    VA_Dispatch(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp);
NTSTATUS    VA_PnP(struct DEVICE_EXTENSION *devExt, PIRP irp);
NTSTATUS    VA_Power(struct DEVICE_EXTENSION *devExt, PIRP irp);
NTSTATUS    VA_PowerComplete(IN PDEVICE_OBJECT devObj, IN PIRP irp, IN PVOID context);
NTSTATUS    GetDeviceCapabilities(struct DEVICE_EXTENSION *devExt);
NTSTATUS    CallNextDriverSync(struct DEVICE_EXTENSION *devExt, PIRP irp);
NTSTATUS    CallDriverSync(PDEVICE_OBJECT devObj, PIRP irp);
NTSTATUS    CallDriverSyncCompletion(IN PDEVICE_OBJECT devObj, IN PIRP irp, IN PVOID Context);
VOID        IncrementPendingActionCount(struct DEVICE_EXTENSION *devExt);
VOID        DecrementPendingActionCount(struct DEVICE_EXTENSION *devExt);
VOID        RegistryAccessConfigInfo(struct DEVICE_EXTENSION *devExt, PDEVICE_OBJECT devObj);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\intfilter\src\filter\power.c ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    power.c

Abstract:

    Interrupt-affinity Filter
    (Roughly based on "NULL filter driver" in DDK, by ervinp and t-chrpri)

Author:

    t-chrpri

Environment:

    Kernel mode

Revision History:
    
--*/

#include <WDM.H>

#include "filter.h"

#ifdef ALLOC_PRAGMA
        #pragma alloc_text(PAGElock, VA_Power)
#endif


NTSTATUS VA_Power(struct DEVICE_EXTENSION *devExt, PIRP irp)
/*++

Routine Description:

    Dispatch routine for Power IRPs (MajorFunction == IRP_MJ_Power)

Arguments:

    devExt - device extension for targetted device object
    irp - Io Request Packet

Return Value:

    NT status code

--*/
{
    PIO_STACK_LOCATION irpSp;
    NTSTATUS status;

    irpSp = IoGetCurrentIrpStackLocation(irp);

    DBGOUT(("VA_Power, minorFunc = 0x%X ", (ULONG)irpSp->MinorFunction)); 


    switch (irpSp->MinorFunction){

        case IRP_MN_SET_POWER:

            switch (irpSp->Parameters.Power.Type) {

                case SystemPowerState:
                    /*
                     *  For system power states, just pass the IRP down.
                     */
                    break;

                case DevicePowerState:

                    switch (irpSp->Parameters.Power.State.DeviceState) {

                        case PowerDeviceD0:
                            /*
                             *  Resume from APM Suspend
                             *
                             *  Do nothing here; 
                             *  Send down the read IRPs in the completion
                             *  routine for this (the power) IRP.
                             */
                            break;

                        case PowerDeviceD1:
                        case PowerDeviceD2:
                        case PowerDeviceD3:
                            /*
                             *  Suspend
                             */
                            if (devExt->state == STATE_STARTED){
                                devExt->state = STATE_SUSPENDED;
                            }
                            break;

                    }
                    break;

            }
            break;

    }


    /*
     *  Send the IRP down the driver stack,
     *  using PoCallDriver (not IoCallDriver, as for non-power irps).
     */
    IncrementPendingActionCount(devExt);
    IoCopyCurrentIrpStackLocationToNext(irp);
    IoSetCompletionRoutine( irp, 
                            VA_PowerComplete, 
                            (PVOID)devExt,  // context
                            TRUE, 
                            TRUE, 
                            TRUE);
    status = PoCallDriver(devExt->topDevObj, irp);

    return status;
}


NTSTATUS VA_PowerComplete(
                            IN PDEVICE_OBJECT devObj, 
                            IN PIRP irp, 
                            IN PVOID context)
/*++

Routine Description:

      Completion routine for Power IRPs (MajorFunction == IRP_MJ_Power)

Arguments:

    devObj - targetted device object
    irp - Io Request Packet
    context - context value passed to IoSetCompletionRoutine by VA_Power

Return Value:

    NT status code

--*/
{
    PIO_STACK_LOCATION irpSp;
    struct DEVICE_EXTENSION *devExt = (struct DEVICE_EXTENSION *)context;

    ASSERT(devExt);
    ASSERT(devExt->signature == DEVICE_EXTENSION_SIGNATURE); 

    /*
     *  If the lower driver returned PENDING, mark our stack location as
     *  pending also.
     */
    if( irp->PendingReturned )
    {
        DBGOUT(( "in PowerComplete -- irp was 'PendingReturned'!" ));
        IoMarkIrpPending(irp);
    }
    
    irpSp = IoGetCurrentIrpStackLocation(irp);
    ASSERT(irpSp->MajorFunction == IRP_MJ_POWER);

    if (NT_SUCCESS(irp->IoStatus.Status)){
        switch (irpSp->MinorFunction){

            case IRP_MN_SET_POWER:

                switch (irpSp->Parameters.Power.Type){

                    case DevicePowerState:
                        switch (irpSp->Parameters.Power.State.DeviceState){
                            case PowerDeviceD0:
                                if (devExt->state == STATE_SUSPENDED){
                                    devExt->state = STATE_STARTED;
                                }
                                break;
                        }
                        break;

                }
                break;
        }

    }


    /*
     *  Whether we are completing or relaying this power IRP,
     *  we must call PoStartNextPowerIrp.
     */
    PoStartNextPowerIrp(irp);
    
    /*
     *  Decrement the pendingActionCount, which we incremented in VA_Power.
     */
    DecrementPendingActionCount(devExt);

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\intfilter\src\filter\pnp.c ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    pnp.c

Abstract:

    Interrupt-affinity Filter
    (Roughly based on "NULL filter driver" in DDK, by ervinp and t-chrpri)

Author:

    t-chrpri

Environment:

    Kernel mode

Revision History:
    
--*/

#include <WDM.H>

#include "filter.h"


#ifdef ALLOC_PRAGMA
        #pragma alloc_text(PAGE, VA_PnP)
        #pragma alloc_text(PAGE, GetDeviceCapabilities)
#endif

            
NTSTATUS VA_PnP(struct DEVICE_EXTENSION *devExt, PIRP irp)
/*++

Routine Description:

    Dispatch routine for PnP IRPs (MajorFunction == IRP_MJ_PNP)

Arguments:

    devExt - device extension for the targetted device object
    irp - IO Request Packet

Return Value:

    NT status code

--*/
{
    PIO_STACK_LOCATION irpSp;
    NTSTATUS status = STATUS_SUCCESS;
    BOOLEAN completeIrpHere = FALSE;
    BOOLEAN justReturnStatus = FALSE;

    PAGED_CODE();

    irpSp = IoGetCurrentIrpStackLocation(irp);

    DBGOUT(( "VA_PnP, (MnFunc=0x%X)", (ULONG)irpSp->MinorFunction )); 

    switch (irpSp->MinorFunction){

        case IRP_MN_START_DEVICE:
            DBGOUT(("START_DEVICE")); 

            devExt->state = STATE_STARTING;


            /*
             *  Look at the translated resource list, and modify the affinity
             *  mask for Interrupt resources, where desired.  As a result,
             *  lower drivers (which use entries in this resource list when
             *  setting up their ISRs) will have their ISRs installed only on
             *  the set of processors that we specify here.
             *  
             *  (NOTICE: must be done before pass-on this IRP to lower drivers)
             */
            if (    NULL != irpSp->Parameters.StartDevice.AllocatedResources
                 && NULL != irpSp->Parameters.StartDevice.AllocatedResourcesTranslated )
            {
                PCM_FULL_RESOURCE_DESCRIPTOR    pCurrFullResDesc; // ptr to an entry in AllocResTrans->List[]
                ULONG                           nFullResDesc;     // num entries in in AllocResTrans->List[]
                PCM_PARTIAL_RESOURCE_LIST       pPartialResList;
                PCM_PARTIAL_RESOURCE_DESCRIPTOR pCurrPartialResDesc; // ptr to an entry in PartialDescriptors[]
                ULONG                           nPartialResDesc;     // num entries in PartialDescriptors[]
                ULONG                           i, j;

                //
                // NOTE: this structure consists of a (continguous) list of
                // non-fixed-size lists, so we need to traverse carefully.
                //


                // Loop through all the CM_FULL_RESOURCE_DESCRIPTORs
                nFullResDesc     =   irpSp->Parameters.StartDevice.AllocatedResourcesTranslated->Count;
                pCurrFullResDesc = &(irpSp->Parameters.StartDevice.AllocatedResourcesTranslated->List[0]);

                for( i = 0  ;  i < nFullResDesc  ;  i++ )
                {
                    DBGOUT(( "Traversing FullResDesc number %d (of %d)" 
                             , i+1
                             , nFullResDesc
                          ));

                    // Loop through all the CM_PARTIAL_RESOURCE_DESCRIPTORS
                    // inside the current CM_FULL_RESOURCE_DESCRIPTOR
                    pPartialResList = &(pCurrFullResDesc->PartialResourceList);

                    nPartialResDesc     =   pPartialResList->Count;
                    pCurrPartialResDesc = &(pPartialResList->PartialDescriptors[0]);

                    for( j=0 ; j<nPartialResDesc ; j++,pCurrPartialResDesc++ )
                    {
                        switch( pCurrPartialResDesc->Type )
                        {
                            case CmResourceTypeInterrupt:
                                DBGOUT(( "    found an INTERRUPT resource (affinity=%08X)"
                                         , pCurrPartialResDesc->u.Interrupt.Affinity
                                      ));

                                //
                                // Set the affinity mask to new value.
                                // Affects lower drivers in this stack.
                                //
                                DBGOUT(( "      +-> desiredAffinityMask=%0IX"
                                         , devExt->desiredAffinityMask        ));

                                pCurrPartialResDesc->u.Interrupt.Affinity  &=  devExt->desiredAffinityMask;

                                DBGOUT(( "      +---> MASK NOW CHANGED TO affinity=%0IX"
                                         , pCurrPartialResDesc->u.Interrupt.Affinity ));
                            break;

                            default:
                                DBGOUT(( "    found a resource we don't care about (Type==%d)"
                                         , pCurrPartialResDesc->Type
                                      ));
                                //
                                // Nothing to do; don't care about this resource type
                                //
                                ;
                        }
                    }


                    // Get pointer to the next CM_FULL_RESOURCE_DESCRIPTOR
                    // 
                    // Explanation: pCurrPartialResDesc points to first byte
                    // after the last CM_PARTIAL_RESOURCE_DESCRIPTOR in this
                    // CM_PARTIAL_RESOURCE_LIST.  Therefore it also points to
                    // first byte after current CM_FULL_RESOURCE_DESCRIPTOR.
                    //
                    // And since a CM_RESOURCE_LIST contains a _contiguous_
                    // list of CM_FULL_RESOURCE_DESCRIPTORs, we're pointing at
                    // the start of the next CM_FULL_RESOURCE_DESCRIPTOR in
                    // the list.  So just need to cast the pointer here to get
                    // at the next CM_FULL_RESOURCE_DESCRIPTOR.
                    pCurrFullResDesc = (PCM_FULL_RESOURCE_DESCRIPTOR) pCurrPartialResDesc;

                }
            }
            else
            {
                DBGOUT(( "WARNING: received NULL resource list in START_DEVICE!..." ));
                DBGOUT(( "...[ AllocResources(Translated) = 0x%08X (0x%08X) ]"
                         , irpSp->Parameters.StartDevice.AllocatedResources
                         , irpSp->Parameters.StartDevice.AllocatedResourcesTranslated
                      ));
            }


            /*
             *  Send the START_DEVICE irp down the stack
             *  synchronously to start the lower stack.
             *  We cannot do anything with our device object
             *  before propagating the START_DEVICE this way.
             */
            IoCopyCurrentIrpStackLocationToNext(irp);
            status = CallNextDriverSync(devExt, irp);

            if (NT_SUCCESS(status)){
                /*
                 *  Now that the lower stack is started,
                 *  do any initialization required by this device object.
                 */
                status = GetDeviceCapabilities(devExt);
                if (NT_SUCCESS(status)){
                    devExt->state = STATE_STARTED;
                }
                else {
                    devExt->state = STATE_START_FAILED;
                }
            }
            else {
                devExt->state = STATE_START_FAILED;
            }
            completeIrpHere = TRUE;
            break;

        case IRP_MN_QUERY_STOP_DEVICE:
        case IRP_MN_QUERY_REMOVE_DEVICE:
            //
            // Need to fail these IRPs if a paging, hibernation, or crashdump
            // file is currently open on this device
            //
            if(    devExt->pagingFileCount      != 0
                || devExt->hibernationFileCount != 0
                || devExt->crashdumpFileCount   != 0 )
            {
                // Fail the IRP
                DBGOUT(( "Failing QUERY_(STOP,REMOVE)_DEVICE request b/c "
                         "paging, hiber, or crashdump file is present on device." ));
                status = STATUS_UNSUCCESSFUL;
                completeIrpHere = TRUE;
            }
            else
            {
                // We'll just pass this IRP down the driver stack.  But
                // first, must change the IRP's status to STATUS_SUCCESS
                // (default is STATUS_NOT_SUPPORTED)
                irp->IoStatus.Status = STATUS_SUCCESS;
            }

            break;

        case IRP_MN_STOP_DEVICE:
            if (devExt->state == STATE_SUSPENDED){
                status = STATUS_DEVICE_POWER_FAILURE;
                completeIrpHere = TRUE;
            }
            else {
                /*
                 *  Only set state to STOPPED if the device was
                 *  previously started successfully.
                 */
                if (devExt->state == STATE_STARTED){
                    devExt->state = STATE_STOPPED;
                }
            }
            break;

        case IRP_MN_SURPRISE_REMOVAL:
            DBGOUT(("SURPRISE_REMOVAL")); 

            /*
             *  We will pass this IRP down the driver stack.
             *  However, we need to change the default status
             *  from STATUS_NOT_SUPPORTED to STATUS_SUCCESS.
             */
            irp->IoStatus.Status = STATUS_SUCCESS;

            /*
             *  For now just set the STATE_REMOVING state so that
             *  we don't do any more IO.  We are guaranteed to get
             *  IRP_MN_REMOVE_DEVICE soon; we'll do the rest of
             *  the remove processing there.
             */
            devExt->state = STATE_REMOVING;

            break;

        case IRP_MN_REMOVE_DEVICE:
            /*
             *  Check the current state to guard against multiple
             *  REMOVE_DEVICE IRPs.
             */
            DBGOUT(("REMOVE_DEVICE")); 
            if (devExt->state != STATE_REMOVED){

                devExt->state = STATE_REMOVED;

                /*
                 *  Send the REMOVE IRP down the stack asynchronously.
                 *  Do not synchronize sending down the REMOVE_DEVICE
                 *  IRP, because the REMOVE_DEVICE IRP must be sent
                 *  down and completed all the way back up to the sender
                 *  before we continue.
                 */
                IoSkipCurrentIrpStackLocation(irp);
                status = IoCallDriver(devExt->topDevObj, irp);
                justReturnStatus = TRUE;

                DBGOUT(("REMOVE_DEVICE - waiting for %d irps to complete...",
                        devExt->pendingActionCount));  

                /*
                 *  We must for all outstanding IO to complete before
                 *  completing the REMOVE_DEVICE IRP.
                 *
                 *  First do an extra decrement on the pendingActionCount.
                 *  This will cause pendingActionCount to eventually
                 *  go to -1 once all asynchronous actions on this
                 *  device object are complete.
                 *  Then wait on the event that gets set when the
                 *  pendingActionCount actually reaches -1.
                 */
                DecrementPendingActionCount(devExt);
                KeWaitForSingleObject(  &devExt->removeEvent,
                                        Executive,      // wait reason
                                        KernelMode,
                                        FALSE,          // not alertable
                                        NULL );         // no timeout

                DBGOUT(("REMOVE_DEVICE - ... DONE waiting. ")); 


                /*
                 *  If we locked-down certain paged code sections earlier
                 *  because of this device, then need to unlock them now
                 *  (before calling IoDeleteDevice)
                 */
                if( NULL != devExt->pagingPathUnlockHandle )
                {
                    DBGOUT(( "UNLOCKing some driver code (non-pageable) (b/c paging path)" ));
                    MmUnlockPagableImageSection( devExt->pagingPathUnlockHandle );
                    devExt->pagingPathUnlockHandle = NULL;
                }

                if( NULL != devExt->initUnlockHandle )
                {
                    DBGOUT(( "UNLOCKing some driver code (non-pageable) (b/c init conditions)" ));
                    MmUnlockPagableImageSection( devExt->initUnlockHandle );
                    devExt->initUnlockHandle = NULL;
                }


                /*
                 *  Detach our device object from the lower 
                 *  device object stack.
                 */
                IoDetachDevice(devExt->topDevObj);

                /*
                 *  Delete our device object.
                 *  This will also delete the associated device extension.
                 */
                IoDeleteDevice(devExt->filterDevObj);
            }
            break;

        case IRP_MN_DEVICE_USAGE_NOTIFICATION:
        {
            BOOLEAN fSetPagable = FALSE;  // whether we set the PAGABLE bit
                                          /// before we passed-on this IRP

            DBGOUT(( "DEVICE_USAGE_NOTIFICATION (Type==%d , InPath==%d)"
                     , irpSp->Parameters.UsageNotification.Type
                     , irpSp->Parameters.UsageNotification.InPath
                  ));
            DBGOUT(( "    [devExt=0x%08X fltrDevObj=0x%08X]", devExt, devExt->filterDevObj ));


            /*
             *  T-CHRPRI: currently, we keep track of the _number_ of
             *  hibernation and crashdump files.  But we don't take _all_
             *  the actions that should be taken when one of these files is
             *  installed on a device, because we assume that the driver
             *  we're on top of will do that (i.e., handling certain power
             *  state transitions, etc).  However, we _do_ handle paging
             *  files fully.
             */

            //
            // Make sure the Type of this UsageNotification is one that we handle
            //
            if(    irpSp->Parameters.UsageNotification.Type != DeviceUsageTypePaging
                && irpSp->Parameters.UsageNotification.Type != DeviceUsageTypeHibernation
                && irpSp->Parameters.UsageNotification.Type != DeviceUsageTypeDumpFile )
            {
                break; // out of the big switch statement (and just forward this IRP)
            }
    
            //
            // Wait on the paging path event (to prevent several instances of
            // this IRP from being processed at once)
            //
            status = KeWaitForSingleObject( &devExt->deviceUsageNotificationEvent
                                            , Executive    // wait reason
                                            , KernelMode
                                            , FALSE        // not alertable
                                            , NULL         // no timeout
                                          );


            /*
             * IMPORTANT NOTE: When to modify our DO_POWER_PAGABLE bit depends
             * on whether it needs to be set or cleared.  If the IRP indicates
             * our PAGABLE bit should be set, then we must set it _before_
             * forwarding the IRP down the driver stack (and possibly clear it
             * afterward, if lower drivers fail the IRP).  But if the IRP
             * indicates that our PAGABLE bit should be cleared, then we must
             * first forward the IRP to lower drivers, and then clear our bit
             * only if the lower drivers return STATUS_SUCCESS.
             */

            //
            // If removing last paging file from this device...
            //
            if(    irpSp->Parameters.UsageNotification.Type == DeviceUsageTypePaging
                && !irpSp->Parameters.UsageNotification.InPath
                && devExt->pagingFileCount == 1       )
            {
                //
                // Set DO_POWER_PAGABLE bit (if it was set at startup).
                // If lower drivers fail this IRP, we'll clear it later.
                //
                DBGOUT(( "Removing last paging file..." ));

                if( devExt->initialFlags & DO_POWER_PAGABLE )
                {
                    DBGOUT(( "...so RE-setting PAGABLE bit" ));
                    devExt->filterDevObj->Flags |= DO_POWER_PAGABLE;
                    fSetPagable = TRUE;
                }
                else
                {
                    DBGOUT(( "...but PAGABLE bit wasn't set initially, so not setting it now." ));
                }

            }
    

            //
            // Forward the irp synchronously
            //
            IoCopyCurrentIrpStackLocationToNext( irp );
            status = CallNextDriverSync( devExt, irp );
    

            //
            // Now deal with the failure and success cases.
            //
            if( ! NT_SUCCESS(status) )
            {
                //
                // Lower drivers failed the IRP, so _undo_ any changes we
                // made before passing-on the IRP to those drivers.
                //
                if( fSetPagable )
                {
                    DBGOUT(( "IRP was failed, so UN-setting PAGABLE bit" ));
                    devExt->filterDevObj->Flags &= ~DO_POWER_PAGABLE;
                }
            }
            else
            {
                //
                // Lower drivers returned SUCCESS, so we can do everything
                // that must be done in response to this IRP...
                //

                switch( irpSp->Parameters.UsageNotification.Type )
                {
                    case DeviceUsageTypeHibernation:

                        // Adjust counter
                        IoAdjustPagingPathCount( &devExt->hibernationFileCount,
                                                 irpSp->Parameters.UsageNotification.InPath );
                        DBGOUT(( "Num. Hibernation files is now %d", devExt->hibernationFileCount ));
                        ASSERT( devExt->hibernationFileCount > 0 );
                    break;
    
                    case DeviceUsageTypeDumpFile:
                        
                        // Adjust counter
                        IoAdjustPagingPathCount( &devExt->crashdumpFileCount,
                                                 irpSp->Parameters.UsageNotification.InPath );
                        DBGOUT(( "Num. Crashdump files is now %d", devExt->crashdumpFileCount ));
                        ASSERT( devExt->crashdumpFileCount > 0 );
                    break;
    
                    case DeviceUsageTypePaging:
                        
                        // Adjust counter
                        IoAdjustPagingPathCount( &devExt->pagingFileCount,
                                                 irpSp->Parameters.UsageNotification.InPath );
                        DBGOUT(( "Num. Paging files is now %d", devExt->pagingFileCount ));
                        ASSERT( devExt->pagingFileCount > 0 );
    
                        //
                        // If we've just switched between being pageable<->nonpageable...
                        //
                        if(    irpSp->Parameters.UsageNotification.InPath
                            && devExt->pagingFileCount == 1  )
                        {
                            //
                            // Just added a paging file, so clear the PAGABLE
                            // flag, and lock-down the code for all routines
                            // that could be called at IRQL >= DISPATCH_LEVEL
                            // (so that they're _non-pageable_).
                            //
                            DBGOUT(( "Just added first paging file..." ));
                            DBGOUT(( "...so clearing PAGABLE bit" ));
                            devExt->filterDevObj->Flags &= ~DO_POWER_PAGABLE;
    
                            DBGOUT(( "LOCKing some driver code (non-pageable) (b/c paging path)" ));
                            devExt->pagingPathUnlockHandle = MmLockPagableCodeSection( VA_Power );  // some func that's inside the code section that we want to lock
                            ASSERT( NULL != devExt->pagingPathUnlockHandle );
                        }
                        else if (    !irpSp->Parameters.UsageNotification.InPath
                                  && devExt->pagingFileCount == 0  )
                        {
                            //
                            // Just removed the last paging file, but we
                            // already set the PAGABLE flag (if necessary)
                            // before forwarding IRP, so just remove the
                            // _paging-path_ lock from this driver. (NOTE:
                            // initial-condition lock might still be in place,
                            // but that's what we want.)
                            //
                            DBGOUT(( "UNLOCKing some driver code (pageable) (b/c paging path)" ));
                            ASSERT( NULL != devExt->pagingPathUnlockHandle );
                            MmUnlockPagableImageSection( devExt->pagingPathUnlockHandle );
                            devExt->pagingPathUnlockHandle = NULL;
                        }
                    break;
    
                    default:
                        ASSERT( FALSE );  // should never get here (b/c checked for invalid Type earlier)
    
                } //END: switch on Type of special-file


                //
                // Invalidate state, so that certain flags will get updated
                //
                IoInvalidateDeviceState( devExt->physicalDevObj );

            }//END: handling of irp success/failure cases


            //
            // Set event so that the next DEVICE_USAGE_NOTIFICATION IRP that
            // comes along can be processed.
            //
            KeSetEvent( &devExt->deviceUsageNotificationEvent
                        , IO_NO_INCREMENT
                        , FALSE
                      );
    
            //
            // Complete the irp
            //
            IoCompleteRequest( irp, IO_NO_INCREMENT );

            justReturnStatus = TRUE;
        }
        break;

        case IRP_MN_QUERY_PNP_DEVICE_STATE:
            //
            // If a paging, hibernation, or crashdump file is currently open
            // on this device, must set NOT_DISABLEABLE flag in DeviceState
            //
            if(    devExt->pagingFileCount      != 0
                || devExt->hibernationFileCount != 0
                || devExt->crashdumpFileCount   != 0  )
            {
                // Mark the device as not disableable
                PPNP_DEVICE_STATE pDeviceState;
                pDeviceState = (PPNP_DEVICE_STATE) &irp->IoStatus.Information;
                *pDeviceState |= PNP_DEVICE_NOT_DISABLEABLE;
            }

            //
            // We _did_ handle this IRP (as best we could), so set IRP's
            // status to STATUS_SUCCESS (default is STATUS_NOT_SUPPORTED)
            // before passing it down the driver stack
            //
            irp->IoStatus.Status = STATUS_SUCCESS;

            break;

        case IRP_MN_QUERY_DEVICE_RELATIONS:
        default:
            break;
    }



    if (justReturnStatus){
        /*
         *  We've already sent this IRP down the stack.
         */
    }
    else if (completeIrpHere){
        irp->IoStatus.Status = status;
        IoCompleteRequest(irp, IO_NO_INCREMENT);
    }
    else {
        IoSkipCurrentIrpStackLocation(irp);
        status = IoCallDriver(devExt->topDevObj, irp);
    }

    return status;
}





NTSTATUS GetDeviceCapabilities(struct DEVICE_EXTENSION *devExt)
/*++

Routine Description:

    Function retrieves the DEVICE_CAPABILITIES descriptor from the device

Arguments:

    devExt - device extension for targetted device object

Return Value:

    NT status code

--*/
{
    NTSTATUS status;
    PIRP irp;

    PAGED_CODE();

    irp = IoAllocateIrp(devExt->topDevObj->StackSize, FALSE);

    if (irp){
        PIO_STACK_LOCATION nextSp = IoGetNextIrpStackLocation(irp);

        // must initialize DeviceCapabilities before sending...
        RtlZeroMemory(  &devExt->deviceCapabilities, 
                        sizeof(DEVICE_CAPABILITIES)  );
        devExt->deviceCapabilities.Size    = sizeof(DEVICE_CAPABILITIES);
        devExt->deviceCapabilities.Version = 1;

        // setup irp stack location...
        nextSp->MajorFunction = IRP_MJ_PNP;
        nextSp->MinorFunction = IRP_MN_QUERY_CAPABILITIES;
        nextSp->Parameters.DeviceCapabilities.Capabilities = 
                        &devExt->deviceCapabilities;

        /*
         *  For any IRP you create, you must set the default status
         *  to STATUS_NOT_SUPPORTED before sending it.
         */
        irp->IoStatus.Status = STATUS_NOT_SUPPORTED;

        status = CallNextDriverSync(devExt, irp);

        IoFreeIrp(irp);
    }
    else {
        status = STATUS_INSUFFICIENT_RESOURCES;
    }

    ASSERT(NT_SUCCESS(status));
    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\intfilter\src\filter\filter.c ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    filter.c

Abstract:

    Interrupt-affinity Filter
    (Roughly based on "NULL filter driver" in DDK, by ervinp and t-chrpri)

Author:

    t-chrpri

Environment:

    Kernel mode

Revision History:
    
--*/

#include <WDM.H>

#include "filter.h"

#ifdef ALLOC_PRAGMA
        #pragma alloc_text(INIT, DriverEntry)
        #pragma alloc_text(PAGE, VA_AddDevice)
        #pragma alloc_text(PAGE, VA_DriverUnload)
#endif


NTSTATUS DriverEntry(
                        IN PDRIVER_OBJECT DriverObject, 
                        IN PUNICODE_STRING RegistryPath
                    )
/*++

Routine Description:

    Installable driver initialization entry point.
    This entry point is called directly by the I/O system.

Arguments:

    DriverObject - pointer to the driver object

    RegistryPath - pointer to a unicode string representing the path,
                   to driver-specific key in the registry.

Return Value:

    STATUS_SUCCESS if successful,
    STATUS_UNSUCCESSFUL otherwise

--*/
{
    ULONG i;

    PAGED_CODE();

    UNREFERENCED_PARAMETER(RegistryPath);

    DBGOUT(("DriverEntry")); 

    /*
     *  Route all IRPs on device objects created by this driver
     *  to our IRP dispatch routine.
     */
    for( i = 0 ; i <= IRP_MJ_MAXIMUM_FUNCTION ; i++ ) {
        DriverObject->MajorFunction[i] = VA_Dispatch; 
    }

    DriverObject->DriverExtension->AddDevice = VA_AddDevice;
    DriverObject->DriverUnload = VA_DriverUnload;

    return STATUS_SUCCESS;
}


NTSTATUS VA_AddDevice(
                        IN PDRIVER_OBJECT driverObj, 
                        IN PDEVICE_OBJECT physicalDevObj
                     )
/*++

Routine Description:

    The PlugPlay subsystem is handing us a brand new 
    PDO (Physical Device Object), for which we
    (by means of INF registration) have been asked to filter.

    We need to determine if we should attach or not.
    Create a filter device object to attach to the stack
    Initialize that device object
    Return status success.

    Remember: we can NOT actually send ANY non pnp IRPS to the given driver
    stack, UNTIL we have received an IRP_MN_START_DEVICE.

Arguments:

    driverObj - pointer to a device object.

    physicalDevObj -    pointer to a physical device object pointer 
                        created by the  underlying bus driver.

Return Value:

    NT status code.

--*/

{
    NTSTATUS status;
    PDEVICE_OBJECT filterDevObj = NULL;
    
    PAGED_CODE();

    DBGOUT(("VA_AddDevice: drvObj=%ph, pdo=%ph", driverObj, physicalDevObj)); 

    status = IoCreateDevice( driverObj, 
                             sizeof(struct DEVICE_EXTENSION),
                             NULL,            // name for this device
                             FILE_DEVICE_UNKNOWN, 
                             FILE_AUTOGENERATED_DEVICE_NAME,  // device characteristics
                             FALSE,           // not exclusive
                             &filterDevObj);  // our device object

    if( NT_SUCCESS(status) )
    {
        struct DEVICE_EXTENSION *devExt;

        ASSERT(filterDevObj);

        /*
         *  Initialize device extension for new device object
         */
        devExt = (struct DEVICE_EXTENSION *)filterDevObj->DeviceExtension;
        RtlZeroMemory(devExt, sizeof(struct DEVICE_EXTENSION));
        devExt->signature           = DEVICE_EXTENSION_SIGNATURE;
        devExt->state               = STATE_INITIALIZED;
        devExt->filterDevObj        = filterDevObj;
        devExt->physicalDevObj      = physicalDevObj;
        devExt->desiredAffinityMask = MAXULONG_PTR; // Default: won't change interrupt mask

        devExt->pendingActionCount = 0;
        KeInitializeEvent(&devExt->removeEvent, NotificationEvent, FALSE);
        KeInitializeEvent(&devExt->deviceUsageNotificationEvent, SynchronizationEvent, TRUE);


        /*
         *  Attach the new device object to the top of the device stack.
         */
        devExt->topDevObj = IoAttachDeviceToDeviceStack(filterDevObj, physicalDevObj);

        ASSERT(devExt->topDevObj);
        DBGOUT(("created filterDevObj %ph attached to %ph.", filterDevObj, devExt->topDevObj));



        //
        // As a filter driver, we do not want to change the power or I/O
        // behavior of the driver stack in any way.  Recall that a filter
        // driver should "appear" the same (almost) as the underlying device.
        // Therefore we must copy some bits from the device object _directly_
        // below us in the device stack (notice: DON'T copy from the PDO!)
        //


        /* Various I/O-related flags which should be maintained */
        /* (copy from lower device object) */
        filterDevObj->Flags |= (devExt->topDevObj->Flags & DO_BUFFERED_IO);
        filterDevObj->Flags |= (devExt->topDevObj->Flags & DO_DIRECT_IO);

        /* Various Power-related flags which should be maintained */
        /* (copy from lower device object) */
        filterDevObj->Flags |= (devExt->topDevObj->Flags & DO_POWER_INRUSH); 
        filterDevObj->Flags |= (devExt->topDevObj->Flags & DO_POWER_PAGABLE);


        //
        // To determine whether some of our routines should initially be
        // pageable, we must consider the DO_POWER_xxxx flags of the
        // device object directly below us in the device stack.
        //
        // * We make ourselves pageable if:
        //     - that devobj has its PAGABLE bit set (so we know our power
        //       routines won't be called at DISPATCH_LEVEL)
        // -OR-
        //     - that devobj has its NOOP bit set (so we know we won't be
        //       participating in power-management at all)
        //
        // * Otherwise, we make ourselves non-pageable because either:
        //     - that devobj has its INRUSH bit set (so we also have to be
        //       INRUSH, and code that handles INRUSH irps can't be pageable)
        // -OR-
        //     - that devobj does NOT have its PAGABLE bit set (and NOOP isn't
        //       set, so some of our code might be called at DISPATCH_LEVEL)
        //
        if(    devExt->topDevObj->Flags & DO_POWER_PAGABLE )
        {
            // We're initially pageable.
            //
            // Don't need to do anything else here, for now.
        }
        else
        {
            // We're initially non-pageable.
            //
            // We need to lock-down the code for all routines
            // that could be called at IRQL >= DISPATCH_LEVEL.
            DBGOUT(( "LOCKing some driver code (non-pageable) (b/c init conditions)" ));
            devExt->initUnlockHandle = MmLockPagableCodeSection( VA_Power );  // some func that's inside the code section that we want to lock
            ASSERT( NULL != devExt->initUnlockHandle );
        }


        /*
         *  Clear the initializing bit from the new device object's flags.
         *  NOTE: must not do this until *after* setting DO_POWER_xxxx flags
         */
        filterDevObj->Flags &= ~DO_DEVICE_INITIALIZING;

        /*
         *  Remember our initial flag settings.
         *  (Need remember initial settings to correctly handle
         *  setting of PAGABLE bit later.)
         */
        devExt->initialFlags = filterDevObj->Flags;




        /*
         *  Read driver-configuration info from the device's registry area.
         *
         *  Note that you cannot make this call on devExt->filterDevObj
         *  because a filter device object does not have a devNode.
         *  We pass devExt->physicalDevObj, which is the device object
         *  for which this driver is a filter driver.
         */
        RegistryAccessConfigInfo( devExt, devExt->physicalDevObj );

    } 

    ASSERT(NT_SUCCESS(status));
    return status;
}


VOID VA_DriverUnload(IN PDRIVER_OBJECT DriverObject)
/*++

Routine Description:

    Free all the allocated resources, etc.

    Note:  Although the DriverUnload function often does nothing,
           the driver must set a DriverUnload function in 
           DriverEntry; otherwise, the kernel will never unload
           the driver.

Arguments:

    DriverObject - pointer to a driver object.

Return Value:

    VOID.

--*/
{

    PAGED_CODE();
    

    DBGOUT(("VA_DriverUnload")); 
}


NTSTATUS VA_Dispatch(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp)
/*++

Routine Description:

    Common entrypoint for all Io Request Packets

Arguments:

    DeviceObject - pointer to a device object.
    Irp - Io Request Packet

Return Value:

    NT status code.

--*/

{
    struct DEVICE_EXTENSION *devExt;
    PIO_STACK_LOCATION irpSp;
    BOOLEAN passIrpDown = TRUE;
    UCHAR majorFunc, minorFunc;
    NTSTATUS status;

    devExt = DeviceObject->DeviceExtension;
    ASSERT(devExt->signature == DEVICE_EXTENSION_SIGNATURE);

    irpSp = IoGetCurrentIrpStackLocation(Irp);

    /*
     *  Get major/minor function codes in private variables
     *  so we can access them after the IRP is completed.
     */
    majorFunc = irpSp->MajorFunction;
    minorFunc = irpSp->MinorFunction;

    DBGOUT(( "VA_Dispatch: irp=[0x%X,0x%X]", 
             (ULONG)majorFunc, (ULONG)minorFunc )); 

    /*
     *  For all IRPs except REMOVE, we increment the PendingActionCount
     *  across the dispatch routine in order to prevent a race condition with
     *  the REMOVE_DEVICE IRP (without this increment, if REMOVE_DEVICE
     *  preempted another IRP, device object and extension might get
     *  freed while the second thread was still using it).
     */
    if (!((majorFunc == IRP_MJ_PNP) && (minorFunc == IRP_MN_REMOVE_DEVICE))){
        IncrementPendingActionCount(devExt);
    }

    if ((majorFunc != IRP_MJ_PNP) &&
        (majorFunc != IRP_MJ_CLOSE) &&
        ((devExt->state == STATE_REMOVING) ||
         (devExt->state == STATE_REMOVED))){

        /*
         *  While the device is being removed, 
         *  we only pass down the PNP and CLOSE IRPs.
         *  We fail all other IRPs.
         */
        status = Irp->IoStatus.Status = STATUS_DELETE_PENDING;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        passIrpDown = FALSE;
    }
    else {
        switch (majorFunc){

            case IRP_MJ_PNP:
                status = VA_PnP(devExt, Irp);
                passIrpDown = FALSE;
                break;

            case IRP_MJ_POWER:
                status = VA_Power(devExt, Irp);
                passIrpDown = FALSE;
                break;

            case IRP_MJ_CREATE:
            case IRP_MJ_CLOSE:
            case IRP_MJ_DEVICE_CONTROL:
            case IRP_MJ_SYSTEM_CONTROL:
            case IRP_MJ_INTERNAL_DEVICE_CONTROL:
            default:
                /*
                 *  For unsupported IRPs, we simply send the IRP
                 *  down the driver stack.
                 */
                break;
        }
    }

    if (passIrpDown){
        IoSkipCurrentIrpStackLocation(Irp);
        status = IoCallDriver(devExt->topDevObj, Irp);
    }

    /*
     *  Balance the increment to PendingActionCount above.
     */
    if (!((majorFunc == IRP_MJ_PNP) && (minorFunc == IRP_MN_REMOVE_DEVICE))){
        DecrementPendingActionCount(devExt);
    }

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\intfilter\src\filter\util.c ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    util.c

Abstract:

    Interrupt-affinity Filter
    (Roughly based on "NULL filter driver" in DDK, by ervinp and t-chrpri)

Author:

    t-chrpri

Environment:

    Kernel mode

Revision History:
    
--*/

#include <WDM.H>

#include "filter.h"


#ifdef ALLOC_PRAGMA
        #pragma alloc_text(PAGE, CallNextDriverSync)
        #pragma alloc_text(PAGE, CallDriverSync)
        #pragma alloc_text(PAGE, RegistryAccessConfigInfo)  
#endif


NTSTATUS CallNextDriverSync(struct DEVICE_EXTENSION *devExt, PIRP irp)
/*++

Routine Description:

        Pass the IRP down to the next device object in the stack
        synchronously, and bump the pendingActionCount around
        the call to prevent the current device object from getting
        removed before the IRP completes.

Arguments:

    devExt - device extension of one of our device objects
    irp - Io Request Packet

Return Value:

    NT status code, indicates result returned by lower driver for this IRP.

--*/
{
    NTSTATUS status;

    PAGED_CODE();

    IncrementPendingActionCount(devExt);
    status = CallDriverSync(devExt->topDevObj, irp);
    DecrementPendingActionCount(devExt);

    return status;
}



NTSTATUS CallDriverSync(PDEVICE_OBJECT devObj, PIRP irp)
/*++

Routine Description:

      Call IoCallDriver to send the irp to the device object;
      then, synchronize with the completion routine.
      When CallDriverSync returns, the action has completed
      and the irp again belongs to the current driver.

      NOTE:  In order to keep the device object from getting freed
             while this IRP is pending, you should call
             IncrementPendingActionCount() and 
             DecrementPendingActionCount()
             around the CallDriverSync call.

Arguments:

    devObj - targetted device object
    irp - Io Request Packet

Return Value:

    NT status code, indicates result returned by lower driver for this IRP.

--*/
{
    KEVENT event;
    NTSTATUS status;

    PAGED_CODE();

    KeInitializeEvent(&event, NotificationEvent, FALSE);

    IoSetCompletionRoutine( irp, 
                            CallDriverSyncCompletion, 
                            &event,     // context
                            TRUE, TRUE, TRUE);

    status = IoCallDriver(devObj, irp);

    KeWaitForSingleObject(  &event,
                            Executive,      // wait reason
                            KernelMode,
                            FALSE,          // not alertable
                            NULL );         // no timeout

    status = irp->IoStatus.Status;

    ASSERT(NT_SUCCESS(status));

    return status;
}


NTSTATUS CallDriverSyncCompletion(
                                    IN PDEVICE_OBJECT devObjOrNULL, 
                                    IN PIRP irp, 
                                    IN PVOID context)
/*++

Routine Description:

      Completion routine for CallDriverSync.

Arguments:

    devObjOrNULL - 
            Usually, this is this driver's device object.
             However, if this driver created the IRP, 
             there is no stack location in the IRP for this driver;
             so the kernel has no place to store the device object;
             ** so devObj will be NULL in this case **.

    irp - completed Io Request Packet
    context - context passed to IoSetCompletionRoutine by CallDriverSync. 

    
Return Value:

    NT status code, indicates result returned by lower driver for this IRP.

--*/
{
    PKEVENT event = context;

    ASSERT(irp->IoStatus.Status != STATUS_IO_TIMEOUT);

    KeSetEvent(event, 0, FALSE);

    return STATUS_MORE_PROCESSING_REQUIRED;
}



VOID IncrementPendingActionCount(struct DEVICE_EXTENSION *devExt)
/*++

Routine Description:

      Increment the pendingActionCount for a device object.
      This keeps the device object from getting freed before
      the action is completed.

Arguments:

    devExt - device extension of device object

Return Value:

    VOID

--*/
{
    ASSERT(devExt->pendingActionCount >= 0);
    InterlockedIncrement(&devExt->pendingActionCount);    
}



VOID DecrementPendingActionCount(struct DEVICE_EXTENSION *devExt)
/*++

Routine Description:

      Decrement the pendingActionCount for a device object.
      This is called when an asynchronous action is completed
      AND ALSO when we get the REMOVE_DEVICE IRP.
      If the pendingActionCount goes to -1, that means that all
      actions are completed and we've gotten the REMOVE_DEVICE IRP;
      in this case, set the removeEvent event so we can finish
      unloading.

Arguments:

    devExt - device extension of device object

Return Value:

    VOID

--*/
{
    ASSERT(devExt->pendingActionCount >= 0);
    InterlockedDecrement(&devExt->pendingActionCount);    

    if (devExt->pendingActionCount < 0){
        /*
         *  All pending actions have completed and we've gotten
         *  the REMOVE_DEVICE IRP.
         *  Set the removeEvent so we'll stop waiting on REMOVE_DEVICE.
         */
        ASSERT((devExt->state == STATE_REMOVING) || 
               (devExt->state == STATE_REMOVED));
        KeSetEvent(&devExt->removeEvent, 0, FALSE);
    }
}



VOID RegistryAccessConfigInfo( struct DEVICE_EXTENSION *devExt,
                               PDEVICE_OBJECT devObj             )
/*++

Routine Description:

    Access device-specific registry key(s) containing driver-config info

Arguments:

    devExt - device extension (for our _filter_ device object)
    devObj - device object pointer
               NOTE: This must not be the functional device object
                     created by this filter driver, because that
                     device object does not have a devnode area
                     in the registry; pass the device object of
                     the device object for which this driver is
                     a filter.  This is the device object passed
                     to VA_AddDevice.

Return Value:

    VOID

--*/
{
    NTSTATUS status;
    HANDLE   hDeviceRegKey;

    PAGED_CODE();


    // Open the registry key for the given device object
    status = IoOpenDeviceRegistryKey( devObj, 
                                      PLUGPLAY_REGKEY_DEVICE, 
                                      KEY_READ, 
                                      &hDeviceRegKey);
    /*
     *  NOTE: The device-specific registry value(s) are stored in the
     *  "Device Parameters" sub-key of the Enum key for the device
     *  (and NOT in the Enum key itself)!
     */

    if (NT_SUCCESS(status)){
        UNICODE_STRING keyName;
        ULONG          actualLength;
        BYTE keyValueInfoBuffer[ sizeof(KEY_VALUE_PARTIAL_INFORMATION)
                                 + sizeof( ULONG )  // space for 'Data' field
                               ];


        
        // Setup a UNICODE_STRING containing name of reg-value we're interested in
        RtlInitUnicodeString( &keyName, L"IntFiltr_AffinityMask" );
        
        // Get value(s) from this device's registry key
        status = ZwQueryValueKey( hDeviceRegKey,
                                  &keyName,
                                  KeyValuePartialInformation, // type of info requested (see WDM.H for details)
                                  (PVOID)keyValueInfoBuffer,  // ptr to caller-allocated buffer to receive requested data
                                  sizeof(keyValueInfoBuffer), // size of buffer, in bytes
                                  &actualLength
                                );

        if( NT_SUCCESS(status) )
        {
            // Type-cast, for convenience...
            PKEY_VALUE_PARTIAL_INFORMATION pKeyValueInfo =
                (PKEY_VALUE_PARTIAL_INFORMATION) keyValueInfoBuffer;

#if defined(_WIN64)
            ASSERT( pKeyValueInfo->Type == REG_QWORD );
            ASSERT( pKeyValueInfo->DataLength == sizeof(KAFFINITY) );
#else 
            ASSERT( pKeyValueInfo->Type == REG_DWORD );
            ASSERT( pKeyValueInfo->DataLength == sizeof(ULONG) );
#endif 

            // Store info in filter's device-extension so that it's
            // available to us later, when we need to use it
            devExt->desiredAffinityMask = *( (PKAFFINITY)(pKeyValueInfo->Data) );

            DBGOUT(( "RegistryAccessConfigInfo: got value IntFiltr_AffinityMask=0x%0IX"
                     , devExt->desiredAffinityMask
                  ));
        }
        else
        {
            DBGOUT(( "ZwQueryValueKey failed with %xh.", status ));
        }


        ZwClose(hDeviceRegKey);
    }
    else
    {
        // Unable to open device registry key...
        DBGOUT(("IoOpenDeviceRegistryKey failed with %xh.", status));
    }


}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\mcasample\imca\exe\mcalog.c ===
/*++

Module Name:

    MCALOG.C

Abstract:

    Sample Application for logging errors for Machine Check Architecture

Author:

    Anil Aggarwal (10/12/98)
    Intel Corporation

Revision History:

--*/

#include <windows.h>
#include <winioctl.h>
#include <stdio.h>
#include <stdlib.h>
#include <winbase.h>
#include <mce.h>
#include "imca.h"

//
// Variables for parsing command line arguments
//
extern int  opterr;
extern int  optind;
extern char *optarg;

//
// Print the usage information for MCA logging application
//

VOID
McaUsage(
    PCHAR Name
    )
{
    fprintf(stderr,"Usage\n\t%s: [-s] [-a]\n",Name);
    fprintf(stderr,"\n\t-s: Read Machine Check registers now\n");
    fprintf(stderr,"\n\t-a: Post asynchronous request for errors\n");

    ExitProcess(1);
}

//
// This routine prints the Machine Check registers
//

#if defined(_AMD64_)

VOID
McaPrintLog(
    PMCA_EXCEPTION  McaException
    )
{
    if (McaException->ExceptionType != HAL_MCA_RECORD) {
        fprintf(stderr, "Bad exception record type\n");
        //ExitProcess(1);
    }

    printf("Processor Number = %d\n", McaException->ProcessorNumber);

    printf("Bank Number = %d\n", McaException->u.Mca.BankNumber);
    printf("Mci_Status %I64X\n", McaException->u.Mca.Status.QuadPart);
    printf("Mci_Address %I64X\n", McaException->u.Mca.Address.QuadPart);
    printf("Mci_Misc %I64X\n", McaException->u.Mca.Misc);

} // McaPrintLog()

#endif // _AMD64_

#if defined(_X86_)

VOID
PrintX86McaLog(
    PMCA_EXCEPTION  McaException
    )
{
    if (McaException->ExceptionType != HAL_MCA_RECORD) {
        fprintf(stderr, "Bad exception record type\n");
        //ExitProcess(1);
    }

    printf("Processor Number = %d\n", McaException->ProcessorNumber);

    printf("Bank Number = %d\n", (__int64)McaException->u.Mca.BankNumber);
    printf("Mci_Status %I64X\n", (__int64)McaException->u.Mca.Status.QuadPart);
    printf("Mci_Address %I64X\n", (__int64)McaException->u.Mca.Address.QuadPart);
    printf("Mci_Misc %I64X\n", (__int64)McaException->u.Mca.Misc);

} // PrintX86McaLog()

#define McaPrintLog   PrintX86McaLog

#endif // _X86_

#if defined(_IA64_)

#define ERROR_RECORD_HEADER_FORMAT \
             "MCA Error Record Header\n"            \
             "\tId        : 0x%I64x\n"              \
             "\tRevision  : 0x%x\n"                 \
             "\t\tMajor : %x\n"                     \
             "\t\tMinor : %x\n"                     \
             "\tSeverity  : 0x%x\n"                 \
             "\tValid     : 0x%x\n"                 \
             "\t\tPlatformId: %x\n"                 \
             "\tLength    : 0x%x\n"                 \
             "\tTimeStamp : 0x%I64x\n"              \
             "\t\tSeconds: %x\n"                    \
             "\t\tMinutes: %x\n"                    \
             "\t\tHours  : %x\n"                    \
             "\t\tDay    : %x\n"                    \
             "\t\tMonth  : %x\n"                    \
             "\t\tYear   : %x\n"                    \
             "\t\tCentury: %x\n"                    \
             "\tPlatformId: %02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x\n" 

VOID
PrintIa64ErrorRecordHeader(
   PERROR_RECORD_HEADER Header
   )
{
    printf( ERROR_RECORD_HEADER_FORMAT,
             (ULONGLONG) Header->Id,
             (ULONG)     Header->Revision.Revision,
             (ULONG)     Header->Revision.Major, (ULONG) Header->Revision.Minor,
             (ULONG)     Header->ErrorSeverity,
             (ULONG)     Header->Valid.Valid,
             (ULONG)     Header->Valid.OemPlatformID,
             (ULONG)     Header->Length,
             (ULONGLONG) Header->TimeStamp.TimeStamp,
             (ULONG)     Header->TimeStamp.Seconds,
             (ULONG)     Header->TimeStamp.Minutes,
             (ULONG)     Header->TimeStamp.Hours,
             (ULONG)     Header->TimeStamp.Day,
             (ULONG)     Header->TimeStamp.Month,
             (ULONG)     Header->TimeStamp.Year,
             (ULONG)     Header->TimeStamp.Century,
             (ULONG)     Header->OemPlatformId[0],
             (ULONG)     Header->OemPlatformId[1],
             (ULONG)     Header->OemPlatformId[2],
             (ULONG)     Header->OemPlatformId[3],
             (ULONG)     Header->OemPlatformId[4],
             (ULONG)     Header->OemPlatformId[5],
             (ULONG)     Header->OemPlatformId[6],
             (ULONG)     Header->OemPlatformId[7],
             (ULONG)     Header->OemPlatformId[8],
             (ULONG)     Header->OemPlatformId[9],
             (ULONG)     Header->OemPlatformId[10],
             (ULONG)     Header->OemPlatformId[11],
             (ULONG)     Header->OemPlatformId[12],
             (ULONG)     Header->OemPlatformId[13],
             (ULONG)     Header->OemPlatformId[14],
             (ULONG)     Header->OemPlatformId[15]
            );

    return;

} // PrintIa64ErrorRecordHeader()

VOID
PrintIa64McaLog(
    PMCA_EXCEPTION  McaException
    )
{

    //
    // Start by printing the record header.
    //

    PrintIa64ErrorRecordHeader( McaException );

    //
    // Then print and/or process error device specific information here.
    //
    
    return;

} // PrintIa64McaLog()

#define McaPrintLog   PrintIa64McaLog

#endif // _IA64_

//
// This routine prints a user friendly error message based on GetLastError()
//

VOID
McaPrintError(
    VOID
    )
{
    LPVOID lpMsgBuf;
    DWORD Err = GetLastError();

    if (FormatMessage( 
            FORMAT_MESSAGE_ALLOCATE_BUFFER | 
            FORMAT_MESSAGE_FROM_SYSTEM | 
            FORMAT_MESSAGE_IGNORE_INSERTS,
            NULL,
            Err,
            MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
            (LPTSTR) &lpMsgBuf,
            0,
            NULL 
        )) {
        fprintf(stderr, "%s\n", lpMsgBuf);
    
        LocalFree( lpMsgBuf );
    } else {
        fprintf(stderr, "%d\n", Err);
    }
} 

//
// Main entry point
//

int
__cdecl
main(
    int argc,
    char *argv[]
    )
{
    CHAR            Option;
    BOOLEAN         ReadBanks = FALSE;
    BOOLEAN         PostAsyncRequest = FALSE;
    HANDLE          McaDeviceHandle;
    HANDLE          LogEvent;
    OVERLAPPED      Overlap;
    BOOL            ReturnStatus;
    DWORD           ActualCount;
    DWORD           WaitStatus;
    DWORD           NumberOfBytes;
    MCA_EXCEPTION   McaException;
    LONG            i;

    //
    // Process the command line arguments
    //
    for (i=1; i < argc; i++) {
        if (!((argv[i][0] == '-') || (argv[i][2] != 0)) ) {
            McaUsage(argv[0]);
        }

        Option = argv[i][1];

        switch (Option) {
            case 's':
                ReadBanks = TRUE;
                break;

            case 'a':
                PostAsyncRequest = TRUE;
                break;

            default:
                McaUsage(argv[0]);
        }
    }

    if ((ReadBanks != TRUE) && (PostAsyncRequest != TRUE)) {
        fprintf(stderr, "One of -s and -a options must be specified\n");
        ExitProcess(1);
    }

    if ((ReadBanks == TRUE) && (PostAsyncRequest == TRUE)) {
        fprintf(stderr, "Only one of -s and -a options can be specified\n");
        ExitProcess(1);
    }

    //
    // Open MCA device with overlap flag set
    //

    McaDeviceHandle = CreateFile(
                            MCA_DEVICE_NAME_WIN32,
                            GENERIC_READ|GENERIC_WRITE,
                            0,
                            (LPSECURITY_ATTRIBUTES)NULL,
                            OPEN_EXISTING,
                            FILE_ATTRIBUTE_NORMAL|FILE_FLAG_OVERLAPPED, 
                            (HANDLE)NULL
                            );

    if (McaDeviceHandle == INVALID_HANDLE_VALUE)  {
        fprintf(stderr, "%s: Error 0x%lx opening MCA device\n",
                                        argv[0], GetLastError());
        ExitProcess(1);
    }

    if (ReadBanks == TRUE) {
        
            //
            // Read the error logs on all banks on all procs.
            // IOCTL_READ_BANKS will read only one error at a time. So
            // we need to keep issuing this ioctl till all the errors are read
            //
    
        do {
            ReturnStatus = DeviceIoControl(
                                McaDeviceHandle,
                                (ULONG)IOCTL_READ_BANKS,
                                NULL,
                                0,
                                &McaException,
                                sizeof(MCA_EXCEPTION),
                                &ActualCount,
                                NULL
                                );

            if (ReturnStatus == 0)  {
                //
                // Some error has occurred. Either there are no more machine
                // check errors present or the processor does not have 
                // support for Intel Machine Check Architecture
                //

                if (GetLastError() == ERROR_NOT_FOUND) {
                    fprintf(stderr, "No Machine Check errors present\n");
                } else if (GetLastError() == ERROR_FILE_NOT_FOUND) {
                    fprintf(stderr, "Intel Machine Check support not available\n");
                    ExitProcess(1);
                } else {
                    fprintf(stderr, "%s: Error 0x%lx in DeviceIoControl\n",
                                        argv[0], GetLastError());
                    ExitProcess(1);
                }

            } else {
                //
                // Successfully read the error. Print it.
                //
                McaPrintLog(&McaException);
            }

        } while (ReturnStatus != 0);
    
        //
        // We are done
        //
        return 1;
    }

    //
    // If we are here, we are supposed to post asynchronous calls to MCA driver
    //
    
    //
    // Set up structures for asynchronous call for reading the log
    // Create the event object
    //

    LogEvent = CreateEvent(
                            NULL,   // No Security Attributes
                            FALSE,  // Auto Reset Event
                            FALSE,  // Initial State = non-signaled 
                            NULL    // Unnamed object
                            );
        
    if (LogEvent == NULL) {
        fprintf(stderr, "%s: Error 0x%lx creating event\n",
                                        argv[0], GetLastError());
        ExitProcess(1);
    }

    //
    // Initialize the overlap structure
    //

    Overlap.hEvent = LogEvent; // Specify event for overlapped object
    Overlap.Offset = 0;        // Offset is zero for devices
    Overlap.OffsetHigh = 0;    // OffsetHigh is zero for devices
    
    ReturnStatus = DeviceIoControl(
                        McaDeviceHandle,
                        (ULONG)IOCTL_READ_BANKS_ASYNC,
                        NULL,
                        0,
                        &McaException,
                        sizeof(MCA_EXCEPTION),    
                        &ActualCount,
                        &Overlap
                        );

    if ((ReturnStatus == 0) && (GetLastError() != ERROR_IO_PENDING))  {
        fprintf(stderr, "%s: Error 0x%lx in IOCTL_READ_BANKS_ASYNC\n",
                    argv[0], GetLastError());
        ExitProcess(1);
    } 

    //
    // Either Ioctl was successful or IO is currently pending
    // If successful then display the log else wait for specified interval
    //
    if (ReturnStatus == TRUE) {
        //
        // Read log async returned succesfully. Display it
        //

        McaPrintLog(&McaException);

    }
            
    //
    // Wait forever to get an error
    //

    WaitStatus = WaitForSingleObject(
                                    LogEvent,
                                    INFINITE
                                    );

    if (WaitStatus == WAIT_OBJECT_0) {
                 
        //
        // The state of the event object is signalled 
        // check if the I/O operation was successful
        //

        ReturnStatus = GetOverlappedResult(
                                        McaDeviceHandle,
                                        &Overlap,
                                        &NumberOfBytes,
                                        FALSE        // Return immediately
                                        );
                                                
        if (ReturnStatus == 0) {

                fprintf(stderr, "%s: Error 0x%lx in GetOverlappedResult\n",
                                        argv[0], GetLastError());
                ExitProcess(1);
        }

        if (NumberOfBytes) {

                //
                // Print the results
                //

                McaPrintLog(&McaException);

        } else {

                //
                // Error as the I/O operation was signalled complete before 
                // timeout but no data transferred
                //

                fprintf(stderr, "%s: No data from GetOverlappedResult\n",
                                argv[0]);
                ExitProcess(1);
        }

    } else {
    
        //
        // We should not get any other return value 
        //

        fprintf(stderr, "%s: Unexpected return value from WaitForSingleObject()\n", argv[0]);
        ExitProcess(1);
    }

    CloseHandle(McaDeviceHandle);

    return 1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\mcasample\mcamgmt\correctedengine.cpp ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    CorrectedEngine.cpp

Abstract:

    This module encapsulates the routines that are needed only for
    corrected error retrieval.
    
Author:

    Abdullah Ustuner (AUstuner) 28-August-2002
        
--*/

#include "mca.h"

extern IWbemServices *gPIWbemServices;
extern IWbemLocator *gPIWbemLocator;

//
// Event which signals the corrected error retrieval. 
//
HANDLE gErrorProcessedEvent;

//
// TimeOut period in minutes for corrected error retrieval.
//
INT gTimeOut;


BOOL
MCACreateProcessedEvent(
	VOID
	)
/*++

Routine Description:

    This function creates the "processed event", which is used to keep track of
    whether a corrected error record has been retrieved from WMI or not. When a 
    corrected error is retrieved from WMI then, this event is signaled which 
    causes the application to finish.

Arguments:

    none

Return Value:

    TRUE  - Successful.
    FALSE - Unsuccessful.

 --*/
{
    //
    // Create the processsed event.
    //
    gErrorProcessedEvent = CreateEvent(NULL,
                                       TRUE,
                                       FALSE,
                                       L"ErrorProcessedEvent"
                                       );

    return (gErrorProcessedEvent != NULL);
}


VOID
MCAErrorReceived(
	IN IWbemClassObject *ErrorObject
	)
/*++

Routine Description:

    This function is called by an instance of the MCAObjectSink class when a corrected
    error is retrieved from WMI. The error record data is extracted from the object and
    the contents of this record is displayed on the screen.
          
Arguments:

    ErrorObject  - Error object retrieved from WMI.    

Return Value:

    none

 --*/
{	
	PUCHAR pErrorRecordBuffer = NULL;

	//
	// Extract the actual MCA error record from the retrieved object.
	//
	if (!MCAExtractErrorRecord(ErrorObject, &pErrorRecordBuffer)) {
    
        wprintf(L"ERROR: Failed to get corrected error record data!\n");

        goto CleanUp;        
        
    }
	
	//
	// Display the corrected error record on the screen.
	//
    MCAPrintErrorRecord(pErrorRecordBuffer);

    CleanUp:
    	
    if (pErrorRecordBuffer) {
    	
        free(pErrorRecordBuffer);
        
    }
}


BOOL
MCAGetCorrectedError(
	VOID
	)
/*++

Routine Description:

    This function registers to WMI for corrected error notification and waits until
    TimeOut limit is reached or an error is retrieved. If an error is successfully
    retrieved then, the contents of the error record are displayed on the screen. 
          
Arguments:

    none
    
Return Value:

    TRUE  - Successful.
    FALSE - Unsuccessful.

 --*/
{
	BOOL isSuccess = TRUE;
	HRESULT hResult = WBEM_S_NO_ERROR;
	DWORD returnValue = 0;

	//
    // Create the Sink instances, which will be responsible for handling
    // the event callbacks from WMI.
    //	
	MCAObjectSink *pCMCSink = new MCAObjectSink();
	MCAObjectSink *pCPESink = new MCAObjectSink();

    //
    // Check if instance creation was successful.
    //
    if (pCMCSink == NULL || pCPESink == NULL) {

    	isSuccess = FALSE;

    	wprintf(L"ERROR: Memory allocation failed for object sinks!");

    	goto CleanUp;
    	
    }

   	//
	// Complete the required initialization tasks.
	//
	if (!MCAInitialize()) {

		isSuccess = FALSE;

		wprintf(L"ERROR: Initialization failed!\n");

		goto CleanUp;	
		
	}  

    //
    // Create processed event, which will be used to signal event retrieval from WMI.
    //
    if(!MCACreateProcessedEvent()){

        isSuccess = FALSE;

        wprintf(L"ERROR: Processed event creation failed!\n");

        goto CleanUp;          
            
    }

	//
	// Register to WMI for CMC event notification.
	//
	if (!MCARegisterCMCConsumer(pCMCSink)) {

		isSuccess = FALSE;

		goto CleanUp;
		
	}
	
	//
	// Register to WMI for CPE event notification.
	//
	if (!MCARegisterCPEConsumer(pCPESink)) {

		isSuccess = FALSE;

		goto CleanUp;
		
	}

	wprintf(L"INFO: Waiting for notification from WMI...\n");

    //
    // Wait for error retrieval until TimeOut limit is reached.
    //
    returnValue = WaitForSingleObjectEx(gErrorProcessedEvent,
                   				        gTimeOut*60*1000,
                          			    FALSE
                          				);

    if (returnValue == WAIT_TIMEOUT) {
    	
    	wprintf(L"INFO: No error notification is received during the timeout period.\n");
    	
    }

	CleanUp:	

	if (gPIWbemServices) { 

	    //
    	// Cancel any currently pending asynchronous call based on the MCAObjectSink pointers.
    	//
	    hResult = gPIWbemServices->CancelAsyncCall(pCMCSink);
    
    	if (hResult != WBEM_S_NO_ERROR){

        	wprintf(L"IWbemServices::CancelAsyncCall failed on CMCSink: %d\n", hResult);
        	
	    }

    	hResult = gPIWbemServices->CancelAsyncCall(pCPESink);
	
	    if(hResult != WBEM_S_NO_ERROR){

    	    wprintf(L"IWbemServices::CancelAsyncCall failed on CPESink: %d\n", hResult);
    	    
	    }

	    gPIWbemServices->Release();
	    
	}  

	//
	// Release the sink object associated with CMC notification.
	//
	if (pCMCSink != NULL) {
			
	   	pCMCSink->Release();
	    	
	}

	//
	// Release the sink object associated with CPE notification.
	//
	if (pCPESink != NULL) {
			
	    pCPESink->Release();
		    
	}

	if (gPIWbemLocator) {

		gPIWbemLocator->Release();
	}
			
	return isSuccess;
}


BOOL
MCARegisterCMCConsumer(
	MCAObjectSink *pCMCSink
	)
/*++

Routine Description:

    This function registers the provided object sink as a temporary consumer
    to WMI for CMC event notification.
          
Arguments:

    pCMCSink - Object sink that will be registered to WMI for CMC error notification.

Return Value:

    TRUE  - Successful.
    FALSE - Unsuccessful.

 --*/ 
{
	HRESULT hResult = 0;
	BOOL isSuccess = TRUE;
 	LPWSTR pQueryLanguage = L"WQL";
	LPWSTR pQueryStatement = L"select * from MSMCAInfo_RawCMCEvent";	

	BSTR bQueryLanguage = SysAllocString(pQueryLanguage);	
	BSTR bQueryStatement = SysAllocString(pQueryStatement);

	if (bQueryLanguage == NULL || bQueryStatement == NULL) {

		isSuccess = FALSE;

		wprintf(L"ERROR: Memory allocation for string failed!\n");

		goto CleanUp;
		
	}

    //
    // Register the object sink as a temporary consumer to WMI for CMC error notification.
    //
    hResult = gPIWbemServices->ExecNotificationQueryAsync(bQueryLanguage,
                                                          bQueryStatement,
                                                          WBEM_FLAG_SEND_STATUS,
                                                          NULL,
                                                          pCMCSink
                                                          );
    
    if (FAILED(hResult)) { 

    	isSuccess = FALSE;

        wprintf(L"ERROR: Temporary consumer registration for CMC failed!\n");

        wprintf(L"Result: 0x%x\n", hResult);

        goto CleanUp;
        
    }

    wprintf(L"INFO: Registered for CMC error notification successfully.\n");

    CleanUp:

    if (bQueryLanguage != NULL) {
		
		SysFreeString(bQueryLanguage);
			
	}

	if (bQueryStatement != NULL) {
		
		SysFreeString(bQueryStatement);
			
	}

    return isSuccess;    
}


BOOL
MCARegisterCPEConsumer(
	MCAObjectSink *pCPESink
	)
/*++

Routine Description:

    This function registers the provided object sink as a temporary consumer
    to WMI for CPE event notification.
          
Arguments:

    pCPESink - Object sink that will be registered to WMI for CPE error notification.

Return Value:

    TRUE  - Successful.
    FALSE - Unsuccessful.

 --*/
{
    HRESULT hResult = 0;
    BOOL isSuccess = TRUE;
    LPWSTR pQueryLanguage = L"WQL";
	LPWSTR pQueryStatement = L"select * from MSMCAInfo_RawCorrectedPlatformEvent";	

	BSTR bQueryLanguage = SysAllocString(pQueryLanguage);	
	BSTR bQueryStatement = SysAllocString(pQueryStatement);

	if (bQueryLanguage == NULL || bQueryStatement == NULL) {

		isSuccess = FALSE;

		wprintf(L"ERROR: Memory allocation for string failed!\n");

		goto CleanUp;
		
	}

    //
    // Register the object sink as a temporary consumer to WMI for CPE error notification.
    //
    hResult = gPIWbemServices->ExecNotificationQueryAsync(bQueryLanguage,
                                                          bQueryStatement,
                                                          WBEM_FLAG_SEND_STATUS,
                                                          NULL,
                                                          pCPESink
                                                          );
    if (FAILED(hResult)) {

    	isSuccess = FALSE;

        wprintf(L"ERROR: Temporary consumer registration for CPE failed!\n");

        wprintf(L"ERROR: Result: 0x%x\n", hResult);        

        goto CleanUp;
        
    }

    wprintf(L"INFO: Registered for CPE error notification successfully.\n");

    CleanUp:

    if (bQueryLanguage != NULL) {
		
		SysFreeString(bQueryLanguage);
			
	}

	if (bQueryStatement != NULL) {
		
		SysFreeString(bQueryStatement);
			
	}
       
    return isSuccess;    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\mcasample\mcamgmt\common.cpp ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    Common.cpp

Abstract:

    This module encapsulates the common routines that are used 
    during both fatal and corrected error retrieval.
    
Author:

    Abdullah Ustuner (AUstuner) 26-August-2002
        
--*/

#include "mca.h"

IWbemServices *gPIWbemServices = NULL;
IWbemLocator *gPIWbemLocator = NULL;


BOOL
MCAExtractErrorRecord(
    IN IWbemClassObject *PObject,
    OUT PUCHAR *PRecordBuffer    
)
/*++

Routine Description:

    This function retrieves embedded objects from the error record 
    (obtained from WMI) that contain both the record data and other
    information about the record (such as length). The data is saved
    into the output buffer provided.
          
Arguments:

    PObject  - Event object retrieved from WMI.
    PRecordBuffer - Pointer to a buffer to save the MCA error record.

Return Value:

    TRUE - Successful.
    FALSE - Unsuccessful.

 --*/
{    
    IWbemClassObject *pRecordsObject = NULL;
    VARIANT recordsPropertyVariant;
    VARIANT countPropertyVariant;
   	VARIANT recordLengthVariant;
   	VARIANT recordDataVariant;
    HRESULT hResult = WBEM_S_NO_ERROR;
    IUnknown *punk = NULL;
    LONG mcaRecordByte = 0, index = 0;
    UCHAR recordDataByte;
	BOOL isSuccess = TRUE;

    //
    // Retrieve the "Records" property value of the event object.
    //
    hResult = PObject->Get(L"Records",
                           0,
                           &recordsPropertyVariant,
                           NULL,
                           NULL
                           );
    
    if (FAILED(hResult)) {

    	isSuccess = FALSE;

    	wprintf(L"ERROR: \"Records\" property value couldn't be retrieved!\n");

        goto CleanUp;
        
    }

  	//
    // Retrieve the "Count" property value of the event object.
    //        
    hResult = PObject->Get(L"Count",
                           0,
                           &countPropertyVariant,
                           NULL,
                           NULL
                           );
    
    if (FAILED(hResult)) {

    	isSuccess = FALSE;

        wprintf(L"ERROR: \"Count\" property value couldn't be retrieved!\n");

        goto CleanUp;
        
    }

    //
    // Check the "Count" property to ensure that it is not zero.
    //            
    if (countPropertyVariant.lVal < 1) {

    	isSuccess = FALSE;

		wprintf(L"ERROR: \"Count\" is less than 1!\n");

		goto CleanUp;
		
    }

    //
    // The Records Property Variant.parray should contain a
    // pointer to an array of pointers. However, MCA should only
    // place one pointer in this array. Use the Safearray APIs to
    // get that pointer.
    //
    hResult = SafeArrayGetElement(recordsPropertyVariant.parray,
                                  &index,
                                  &punk
                                  );

    if(FAILED(hResult)){

    	isSuccess = FALSE;
       
		wprintf(L"ERROR: Couldn't retrieve array pointer!\n");

        goto CleanUp;
        
    }   

    //
    // Punk should contain an object of type IWbemClassObject. This should
    // be the MCA record object that will contain "Length" and "Data" elements.
    //
    hResult = (punk->QueryInterface(IID_IWbemClassObject,
                                    (PVOID*)&pRecordsObject)
                                    );
    
    if (FAILED(hResult)) {

    	isSuccess = FALSE;
        
        wprintf(L"ERROR: Interface pointer couldn't be retrieved!\n");

        goto CleanUp;
        
    }   
    
    //
    // Obtain the length of the error record.
    //
    hResult = pRecordsObject->Get(L"Length",
                                  0,
                                  &recordLengthVariant,
                                  NULL,
                                  NULL
                                  );

    if (FAILED(hResult)) {

    	isSuccess = FALSE;

    	wprintf(L"\"Length\" property value couldn't be retrieved!\n");

    	goto CleanUp;

    }
        
    //
    // Obtain the actual data from the records object. This should contain a parray
    // that points to the actual MCA data we are looking for.
    //
    hResult = pRecordsObject->Get(L"Data",
                                  0,
                                  &recordDataVariant,
                                  NULL,
                                  NULL
                                  );
    
    if (FAILED(hResult)) {

    	isSuccess = FALSE;
        
        wprintf(L"\"Data\" property value couldn't be retrieved!\n");

        goto CleanUp;

    } 

    //
    // Check if the "Data" field in the record contains any data.
    //
    if (recordDataVariant.parray == NULL) {       

    	isSuccess = FALSE;

        wprintf(L"ERROR: Error record contains to data!\n");

        goto CleanUp;
        
    }

    PUCHAR PTempBuffer = NULL;

    //
    // Allocate memory for the error record buffer. The size of the memory should be
    // equal to the size of the MCA error record data field.
    //    
    if ((*PRecordBuffer) == NULL) {
            
        *PRecordBuffer = (PUCHAR)(calloc(recordLengthVariant.lVal, sizeof(UINT8)));

        if((*PRecordBuffer) == NULL) {

        	isSuccess = FALSE;

	        wprintf(L"ERROR: Memory allocation for record buffer failed!\n");

    	    goto CleanUp;
    	    
        }
        
    } else{

        PTempBuffer = (PUCHAR)(realloc(*PRecordBuffer, (recordLengthVariant.lVal * sizeof(UINT8))));

        //
	    // If reallocation of memory for the buffer failed, then display error message and return.
    	//
        if (PTempBuffer == NULL) {

        	isSuccess = FALSE;

	        wprintf(L"ERROR: Memory reallocation for record buffer failed!\n");

    	    goto CleanUp;
        	
        } else {

        	*PRecordBuffer = PTempBuffer;

        	ZeroMemory(*PRecordBuffer, recordLengthVariant.lVal * sizeof(**PRecordBuffer));       
        
        }
        
    }       

    //
    // Get the MCA error record data byte by byte and save it into the allocated buffer.
    //        
    for (mcaRecordByte = 0; mcaRecordByte < recordLengthVariant.lVal; mcaRecordByte++){

        recordDataByte = 0;
            
        hResult = SafeArrayGetElement(recordDataVariant.parray,
                                      &mcaRecordByte,
                                      &recordDataByte
                                      );

        if (FAILED(hResult)) {

        	isSuccess = FALSE;

            wprintf(L"ERROR: Error record data couldn't be read!\n");

            goto CleanUp;
        }
 
        // Copy error record data byte into buffer.
        *((*PRecordBuffer) + (mcaRecordByte * sizeof(UINT8))) = recordDataByte;
        
    }           

    CleanUp:

    VariantClear(&recordDataVariant);
    
    VariantClear(&recordLengthVariant);

    VariantClear(&recordsPropertyVariant);

    VariantClear(&countPropertyVariant);
        
    return isSuccess;
}


BOOL
MCAInitialize(
	VOID
	)
/*++

Routine Description:

    This function accomplishes the required initialization tasks required by
    both fatal and corrected error retrieval.
          
Arguments:

    none

Return Value:

    TRUE - Successful.
    FALSE - Unsuccessful.

 --*/
{
	BOOL isSuccess = TRUE;
	
	//
	// Initialize COM Library
	//
	if (!MCAInitializeCOMLibrary()) {
		
		return FALSE;
		
	}

	//
	// Set Security
	//
	if(!MCAInitializeWMISecurity()){
            
        return FALSE;
            
    }

	return isSuccess;	
}


BOOL
MCAInitializeCOMLibrary(
	VOID
	)
/*++

Routine Description:

    This function initializes the COM library.
          
Arguments:

    none

Return Value:

    TRUE  - Successful.
    FALSE - Unsuccessful.

 --*/
{
    HRESULT hResult = 0;    
    
    hResult = CoInitializeEx(0, COINIT_MULTITHREADED); 
    
    if (FAILED(hResult)) {

        wprintf(L"ERROR: COM library initialization failed!\n");

        wprintf(L"ERROR: Result: 0x%x\n", hResult);

        return FALSE;
    }

    wprintf(L"INFO: COM library initialization is successfully completed.\n");
        
    return TRUE;
}


BOOL
MCAInitializeWMISecurity(
	VOID
	)
/*++

Routine Description:

    This function initializes the required security settings and establishes 
    the connection to the WMI server on the local system.
    
Arguments:

    none

Return Value:

    TRUE  - Successful.
    FALSE - Unsuccessful.

 --*/
{
	HRESULT hResult = 0;    
	LPWSTR pNamespace = L"ROOT\\WMI";

	//
	// Register security and set the security values for the current process.
	//
	hResult = CoInitializeSecurity(NULL,
                                   -1,
                                   NULL,
                                   NULL,
                                   RPC_C_AUTHN_LEVEL_CONNECT,
                                   RPC_C_IMP_LEVEL_IDENTIFY,
                                   NULL,
                                   EOAC_NONE,
                                   NULL
                                   );

	if (FAILED(hResult)) {

	    wprintf(L"ERROR: Security initialization failed!\n");

	    wprintf(L"ERROR: Result: 0x%x\n", hResult);

        return FALSE;
        
	}

	//
	// Create a single uninitialized object of class IWbemLocator on the local system.
	//
	hResult = CoCreateInstance(CLSID_WbemLocator,
                               0,
                               CLSCTX_INPROC_SERVER,
                               IID_IWbemLocator,
                               (LPVOID *) &gPIWbemLocator
                               );

	if (FAILED(hResult)) {

	    wprintf(L"ERROR: IWbemLocator instance creation failed!\n");

	    wprintf(L"ERROR: Result: 0x%x\n", hResult);

        return FALSE;
        
	}

	BSTR bNamespace = SysAllocString(pNamespace);	

	if (bNamespace == NULL) {	

		wprintf(L"ERROR: Memory allocation for string failed!\n");

		return FALSE;
		
	}

    //
	// Connect to the root\wmi namespace with the current user.
	//
    hResult = (gPIWbemLocator)->ConnectServer(bNamespace,
                                     		  NULL,
                                     		  NULL,
                                     		  NULL,
                                     		  NULL,
                                     		  NULL,
                                     		  NULL,
                                     		  &gPIWbemServices
                                     		  );

	if (FAILED(hResult)) {

	    wprintf(L"ERROR: Could not connect to the WMI Server!\n");
	    
	    wprintf(L"ERROR: Result: 0x%x\n", hResult);
        
        return FALSE;
        
	}

    //
    // Set the authentication information on the specified proxy such that
    // impersonation of the client occurs.
    //
	hResult = CoSetProxyBlanket(gPIWbemServices,
                                RPC_C_AUTHN_WINNT,
                                RPC_C_AUTHZ_NONE,
                                NULL,
                                RPC_C_AUTHN_LEVEL_CALL,
                                RPC_C_IMP_LEVEL_IMPERSONATE,
                                NULL,
                                EOAC_NONE
                                );

	if (FAILED(hResult)) {

	    wprintf(L"ERROR: Could not set proxy blanket!\n");

	    wprintf(L"ERROR: Result: 0x%x\n", hResult);
        
        return FALSE;
	
    }

	wprintf(L"INFO: WMI security is initialized successfully.\n");

	//
	// Free the string allocated for storing the namespace.
	//
	if (bNamespace != NULL) {
		
		SysFreeString(bNamespace);
			
	}

    return TRUE;    
}

#if defined(_X86_)

VOID
MCAPrintErrorRecordX86(
	PUCHAR PErrorData
	)
/*++

Routine Description:

    This function displays the machine check exception information on X86 
    systems to the standard output (console screen).

Arguments:

    PErrorData - Buffer containing the machine check exception information.

Return Value:

    none

 --*/
{

	PMCA_EXCEPTION pMCAException = NULL;

	pMCAException = (PMCA_EXCEPTION)PErrorData;

    wprintf(L"\n");
    
    wprintf(L"**************************************************\n");
    wprintf(L"*              X86 MCA EXCEPTION                 *\n");
    wprintf(L"**************************************************\n");
    wprintf(L"* VersionNumber   : 0x%08x\n", (ULONG) pMCAException->VersionNumber);
    wprintf(L"* ExceptionType   : 0x%08x\n", (INT)   pMCAException->ExceptionType);
    wprintf(L"* TimeStamp \n");
    wprintf(L"*     LowPart : 0x%08x\n",(ULONG) pMCAException->TimeStamp.LowPart);
    wprintf(L"*     HighPart: 0x%08x\n", (LONG)  pMCAException->TimeStamp.HighPart);
    wprintf(L"* ProcessorNumber : 0x%08x\n", (ULONG) pMCAException->ProcessorNumber);
    wprintf(L"* Reserved1       : 0x%08x\n", (ULONG) pMCAException->Reserved1);

    if (pMCAException->ExceptionType == HAL_MCE_RECORD) {

    	wprintf(L"* Mce \n");    	
    	wprintf(L"*     Address     : 0x%016I64x\n", (ULONGLONG) pMCAException->u.Mce.Address);
	    wprintf(L"*     Type        : 0x%016I64x\n", (ULONGLONG) pMCAException->u.Mce.Type);
	    
    } else {

        wprintf(L"* Mca \n");
    	wprintf(L"*     BankNumber  : 0x%02x\n", (UCHAR) pMCAException->u.Mca.BankNumber);

	    for (int index = 0 ; index < 7 ; index++) {
   		
   			wprintf(L"*     Reserved2[%d]: 0x%02x\n", index, (UCHAR) pMCAException->u.Mca.Reserved2[index]);

   		}
	    
	    wprintf(L"*     MciStats \n");	    
    	wprintf(L"*         McaCod      : 0x%04x\n", (USHORT) pMCAException->u.Mca.Status.MciStats.McaCod);
    	wprintf(L"*         MsCod       : 0x%04x\n", (USHORT) pMCAException->u.Mca.Status.MciStats.MsCod);
    	wprintf(L"*         OtherInfo   : 0x%01x\n", (ULONG) pMCAException->u.Mca.Status.MciStats.OtherInfo);
    	wprintf(L"*         Damage      : 0x%01x\n", (ULONG) pMCAException->u.Mca.Status.MciStats.Damage);
    	wprintf(L"*         AddressValid: 0x%01x\n", (ULONG) pMCAException->u.Mca.Status.MciStats.AddressValid);
    	wprintf(L"*         MiscValid   : 0x%01x\n", (ULONG) pMCAException->u.Mca.Status.MciStats.MiscValid);
    	wprintf(L"*         Enabled     : 0x%01x\n", (ULONG) pMCAException->u.Mca.Status.MciStats.Enabled);
    	wprintf(L"*         UnCorrected : 0x%01x\n", (ULONG) pMCAException->u.Mca.Status.MciStats.UnCorrected);
    	wprintf(L"*         OverFlow    : 0x%01x\n", (ULONG) pMCAException->u.Mca.Status.MciStats.OverFlow);
    	wprintf(L"*         Valid       : 0x%01x\n", (ULONG) pMCAException->u.Mca.Status.MciStats.Valid);    	
	    wprintf(L"*     Address \n");
	    wprintf(L"*         Address : 0x%08x\n", (ULONG) pMCAException->u.Mca.Address.Address);
	    wprintf(L"*         Reserved: 0x%08x\n", (ULONG) pMCAException->u.Mca.Address.Reserved);	    
    	wprintf(L"*     Misc        : 0x%016I64x\n", (ULONGLONG) pMCAException->u.Mca.Misc);
    	
    }

    wprintf(L"* ExtCnt          : 0x%08x\n", (ULONG) pMCAException->ExtCnt);
   	wprintf(L"* Reserved3       : 0x%08x\n", (ULONG) pMCAException->Reserved3);
  	
   	for (int index = 0 ; index < MCA_EXTREG_V2MAX ; index++) {
   		
   		wprintf(L"* ExtReg[%2d]     : 0x%016I64x\n" , index, (ULONGLONG) pMCAException->ExtReg[index]);

   	}
   	
   	wprintf(L"*********************************************\n\n");
}

#endif // _X86_

#if defined(_AMD64_)

VOID
MCAPrintErrorRecordAMD64(
	PUCHAR PErrorData
	)
/*++

Routine Description:

    This function displays the machine check exception information on AMD64
    systems to the standard output (console screen).

Arguments:

    PErrorData - Buffer containing the machine check exception information.

Return Value:

    none

 --*/
{
	PMCA_EXCEPTION pMCAException = NULL;

	pMCAException = (PMCA_EXCEPTION)PErrorData;

    wprintf(L"\n");
    
    wprintf(L"*********************************************\n");
    wprintf(L"*           X86-64 MCA EXCEPTION            *\n");
    wprintf(L"*********************************************\n");
    wprintf(L"* VersionNumber   : 0x%08x\n", (ULONG) pMCAException->VersionNumber);
    wprintf(L"* ExceptionType   : 0x%08x\n", (INT)   pMCAException->ExceptionType);
    wprintf(L"* TimeStamp \n");
    wprintf(L"*     LowPart : 0x%08x\n", (ULONG) pMCAException->TimeStamp.LowPart);
    wprintf(L"*     HighPart: 0x%08x\n", (LONG)  pMCAException->TimeStamp.HighPart);
    wprintf(L"* ProcessorNumber : 0x%08x\n", (ULONG) pMCAException->ProcessorNumber);
    wprintf(L"* Reserved1       : 0x%08x\n", (ULONG) pMCAException->Reserved1);

    if (pMCAException->ExceptionType == HAL_MCE_RECORD) {

   	   	wprintf(L"* Mce \n");
   	   	
    	wprintf(L"*     Address     : 0x%016I64x\n", (ULONGLONG) pMCAException->u.Mce.Address);
	    wprintf(L"*     Type        : 0x%016I64x\n", (ULONGLONG) pMCAException->u.Mce.Type);
	    
    } else {

	 	wprintf(L"* Mca \n");   
	   
    	wprintf(L"*     BankNumber  : 0x%02x\n", (UCHAR) pMCAException->u.Mca.BankNumber);

	    for (int index = 0 ; index < 7 ; index++) {
   		
   			wprintf(L"*     Reserved2[%d]: 0x%02x\n", index, (UCHAR) pMCAException->u.Mca.Reserved2[index]);

   		}
	    
    	wprintf(L"*     MciStatus\n");
   		wprintf(L"*         McaErrorCode    : 0x%04x\n", (USHORT) pMCAException->u.Mca.Status.MciStatus.McaErrorCode);
    	wprintf(L"*         ModelErrorCode  : 0x%04x\n", (USHORT) pMCAException->u.Mca.Status.MciStatus.ModelErrorCode);
    	wprintf(L"*         OtherInformation: 0x%01x\n", (ULONG) pMCAException->u.Mca.Status.MciStatus.OtherInformation);
    	wprintf(L"*         ContextCorrupt  : 0x%01x\n", (ULONG) pMCAException->u.Mca.Status.MciStatus.ContextCorrupt);
    	wprintf(L"*         AddressValid    : 0x%01x\n", (ULONG) pMCAException->u.Mca.Status.MciStatus.AddressValid);
    	wprintf(L"*         MiscValid       : 0x%01x\n", (ULONG) pMCAException->u.Mca.Status.MciStatus.MiscValid);
    	wprintf(L"*         ErrorEnabled    : 0x%01x\n", (ULONG) pMCAException->u.Mca.Status.MciStatus.ErrorEnabled);
    	wprintf(L"*         UncorrectedError: 0x%01x\n", (ULONG) pMCAException->u.Mca.Status.MciStatus.UncorrectedError);
    	wprintf(L"*         StatusOverFlow  : 0x%01x\n", (ULONG) pMCAException->u.Mca.Status.MciStatus.StatusOverFlow);
    	wprintf(L"*         Valid           : 0x%01x\n", (ULONG) pMCAException->u.Mca.Status.MciStatus.Valid);    	
   	    wprintf(L"*     Address \n");
	    wprintf(L"*         Address : 0x%08x\n", (ULONG) pMCAException->u.Mca.Address.Address);
	    wprintf(L"*         Reserved: 0x%08x\n", (ULONG) pMCAException->u.Mca.Address.Reserved);
    	wprintf(L"*     Misc        : 0x%016I64x\n", (ULONGLONG) pMCAException->u.Mca.Misc);
    	
    }  	
   	
   	wprintf(L"*********************************************\n\n");
}

#endif // _AMD64_

#if defined(_IA64_)

VOID
MCAPrintErrorRecordIA64(
	PUCHAR PErrorData
	)
/*++

Routine Description:

    This function displays the headers of the provided MCA error
    record on IA64 systems to the standard output (console screen).
    The Error Record Header and Section Headers are displayed in 
    a formatted manner.

Arguments:

    PErrorData - Buffer containing the MCA error record.

Return Value:

    none

 --*/
{
	PERROR_RECORD_HEADER pErrorRecordHeader = NULL;
    PERROR_SECTION_HEADER pErrorSectionHeader = NULL;
    ULONG sectionOffset = 0;
    INT sectionNumber = 0;

    //
    // The record header must be at the top of the record buffer.
    //
    pErrorRecordHeader = (PERROR_RECORD_HEADER)PErrorData;

    wprintf(L"\n");
    
    wprintf(L"***************************************************************************\n");
    wprintf(L"*                             IA64 MCA ERROR                              *\n");
    wprintf(L"***************************************************************************\n");
	wprintf(L"*                           Error Record Header                           *\n");
    wprintf(L"*-------------------------------------------------------------------------*\n");
    wprintf(L"* ID           : 0x%I64x\n", (ULONGLONG)pErrorRecordHeader->Id);
    wprintf(L"* Revision     : 0x%x\n"   , (ULONG) pErrorRecordHeader->Revision.Revision);
    wprintf(L"*     Major    : %x\n"	 , (ULONG) pErrorRecordHeader->Revision.Major);
    wprintf(L"*     Minor    : %x\n"	 , (ULONG) pErrorRecordHeader->Revision.Minor);
    wprintf(L"* Severity     : 0x%x\n"   , (ULONG) pErrorRecordHeader->ErrorSeverity);
    wprintf(L"* Validity     : 0x%x\n"   , (ULONG) pErrorRecordHeader->Valid.Valid);
    wprintf(L"*     OEMPlatformID : %x\n", (ULONG) pErrorRecordHeader->Valid.OemPlatformID);
    wprintf(L"* Length       : 0x%x\n"   , (ULONG) pErrorRecordHeader->Length);
    wprintf(L"* TimeStamp    : 0x%I64x\n", (ULONGLONG) pErrorRecordHeader->TimeStamp.TimeStamp);
    wprintf(L"*     Seconds : %x\n"      , (ULONG) pErrorRecordHeader->TimeStamp.Seconds);
    wprintf(L"*     Minutes : %x\n"      , (ULONG) pErrorRecordHeader->TimeStamp.Minutes);
    wprintf(L"*     Hours   : %x\n"      , (ULONG) pErrorRecordHeader->TimeStamp.Hours);
    wprintf(L"*     Day     : %x\n"      , (ULONG) pErrorRecordHeader->TimeStamp.Day);
    wprintf(L"*     Month   : %x\n"      , (ULONG) pErrorRecordHeader->TimeStamp.Month);
    wprintf(L"*     Year    : %x\n"      , (ULONG) pErrorRecordHeader->TimeStamp.Year);
    wprintf(L"*     Century : %x\n"      , (ULONG) pErrorRecordHeader->TimeStamp.Century);
    wprintf(L"* OEMPlatformID: %02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x\n",
    					  			 (ULONG) pErrorRecordHeader->OemPlatformId[0],
						             (ULONG) pErrorRecordHeader->OemPlatformId[1],
						             (ULONG) pErrorRecordHeader->OemPlatformId[2],
						             (ULONG) pErrorRecordHeader->OemPlatformId[3],
						             (ULONG) pErrorRecordHeader->OemPlatformId[4],
						             (ULONG) pErrorRecordHeader->OemPlatformId[5],
						             (ULONG) pErrorRecordHeader->OemPlatformId[6],
						             (ULONG) pErrorRecordHeader->OemPlatformId[7],
						             (ULONG) pErrorRecordHeader->OemPlatformId[8],
						             (ULONG) pErrorRecordHeader->OemPlatformId[9],
						             (ULONG) pErrorRecordHeader->OemPlatformId[10],
						             (ULONG) pErrorRecordHeader->OemPlatformId[11],
						             (ULONG) pErrorRecordHeader->OemPlatformId[12],
						             (ULONG) pErrorRecordHeader->OemPlatformId[13],
						             (ULONG) pErrorRecordHeader->OemPlatformId[14],
						             (ULONG) pErrorRecordHeader->OemPlatformId[15]);

	//
	// Now display each of the section headers in the error record.
	//	
    sectionOffset = sizeof(ERROR_RECORD_HEADER);

    while (sectionOffset < pErrorRecordHeader->Length) {

        pErrorSectionHeader = (PERROR_SECTION_HEADER)(PErrorData + sectionOffset);        

        wprintf(L"***************************************************************************\n");
	    wprintf(L"*                             Section Header                              *\n");
    	wprintf(L"***************************************************************************\n");
    	wprintf(L"* GUID: 0x%x, 0x%x, 0x%x, \n",
    								pErrorSectionHeader->Guid.Data1,
    								pErrorSectionHeader->Guid.Data2,
    								pErrorSectionHeader->Guid.Data3);
    	
    	wprintf(L"*       { 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x }\n",
    								pErrorSectionHeader->Guid.Data4[0],
    								pErrorSectionHeader->Guid.Data4[1], 
    								pErrorSectionHeader->Guid.Data4[2],
    								pErrorSectionHeader->Guid.Data4[3],
    								pErrorSectionHeader->Guid.Data4[4], 
    								pErrorSectionHeader->Guid.Data4[5],
    								pErrorSectionHeader->Guid.Data4[6], 
    								pErrorSectionHeader->Guid.Data4[7]);
    	
    	wprintf(L"* Revision: 0x%x\n", pErrorSectionHeader->Revision);
    	wprintf(L"*     Major    : %x\n"	 , (ULONG) pErrorSectionHeader->Revision.Major);
	    wprintf(L"*     Minor    : %x\n"	 , (ULONG) pErrorSectionHeader->Revision.Minor);
	    wprintf(L"* Recovery: 0x%x\n", (UCHAR)pErrorSectionHeader->RecoveryInfo.RecoveryInfo);
	    wprintf(L"* Reserved: 0x%x\n", (UCHAR)pErrorSectionHeader->Reserved);
	    wprintf(L"* Length  : 0x%x\n", (ULONG)pErrorSectionHeader->Length);

        sectionOffset += pErrorSectionHeader->Length;
        
        sectionNumber++;
        
    }    	

    wprintf(L"***************************************************************************\n\n");         
}

#endif // _IA64_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\mcasample\imca\sys\imca.c ===
/*++

Module Name:

    mca.c

Abstract:

    Sample device driver to register itself with the HAL and log Machine Check
    Errors on a Intel Architecture Platform

Author:

Environment:

    Kernel mode

Notes:

Revision History:

--*/

#include <stdarg.h>
#include <string.h>
#include <stdio.h>
#include <ntddk.h>
#include "imca.h"

//
// Device names for the MCA driver 
//

#define MCA_DEVICE_NAME       "\\Device\\imca"      // ANSI Name
#define MCA_DEVICE_NAME_U     L"\\Device\\imca"     // Unicode Name
#define MCA_DEVICE_NAME_DOS   "\\DosDevices\\imca"  // Device Name for Win32 App

NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    );

NTSTATUS
MCAOpen(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
MCAClose(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

VOID
MCAStartIo(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

#if defined(_AMD64_)

ERROR_SEVERITY
MCADriverExceptionCallback(
    IN PDEVICE_OBJECT DeviceObject,
    IN PKTRAP_FRAME TrapFrame,
    IN PKEXCEPTION_FRAME ExceptionFrame,
    IN PMCA_EXCEPTION InException
    );

#else

ERROR_SEVERITY
MCADriverExceptionCallback(
    IN PDEVICE_OBJECT DeviceObject,
    IN PMCA_EXCEPTION InException
    );

#endif

VOID
MCADriverDpcCallback(
    IN PKDPC    Dpc,
    IN PVOID    DeferredContext,
    IN PVOID    SystemContext1,
    IN PVOID    SystemContext2
    );

NTSTATUS
MCACleanup(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

VOID
McaCancelIrp(
    IN PDEVICE_OBJECT DeviceObject, 
    IN PIRP Irp 
    );

NTSTATUS
MCADeviceControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

VOID
MCAUnload(
    IN PDRIVER_OBJECT DriverObject
    );

NTSTATUS
MCACreateSymbolicLinkObject(
    VOID
    );

VOID
MCAProcessWorkItem(
    PVOID   Context
    );

//
// This temporary buffer holds the data between the Machine Check error 
// notification from HAL and the asynchronous IOCTL completion to the 
// application
//

typedef struct _MCA_DEVICE_EXTENSION {
    PDEVICE_OBJECT  DeviceObject;
    PIRP            SavedIrp;
    BOOLEAN         WorkItemQueued;
    WORK_QUEUE_ITEM WorkItem;
    // Place to log the exceptions. Whenever the exception callback 
    // routine is called by the HAL MCA component, record the exception here.
    // This can potentially be a link list.
    MCA_EXCEPTION   McaException; 

} MCA_DEVICE_EXTENSION, *PMCA_DEVICE_EXTENSION;

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT, DriverEntry)
#pragma alloc_text(INIT, MCACreateSymbolicLinkObject)
#endif // ALLOC_PRAGMA

NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    )

/*++
    Routine Description:
        This routine does the driver specific initialization at entry time

    Arguments:
        DriverObject:   Pointer to the driver object
        RegistryPath:   Path to driver's registry key

    Return Value:
        Success or failure

--*/

{
    UNICODE_STRING          UnicodeString;
    NTSTATUS                Status = STATUS_SUCCESS;
    PMCA_DEVICE_EXTENSION   Extension;
    PDEVICE_OBJECT          McaDeviceObject;
    MCA_DRIVER_INFO         McaDriverInfo;

    //
    // Create device object for MCA device.
    //

    RtlInitUnicodeString(&UnicodeString, MCA_DEVICE_NAME_U);

    //
    // Device is created as exclusive since only a single thread can send
    // I/O requests to this device
    //

    Status = IoCreateDevice(
                    DriverObject,
                    sizeof(MCA_DEVICE_EXTENSION),
                    &UnicodeString,
                    FILE_DEVICE_UNKNOWN,
                    0,
                    TRUE,
                    &McaDeviceObject
                    );

    if (!NT_SUCCESS( Status )) {
        DbgPrint("Mca DriverEntry: IoCreateDevice failed\n");
        return Status;
    }

    McaDeviceObject->Flags |= DO_BUFFERED_IO;

    Extension = McaDeviceObject->DeviceExtension;
    RtlZeroMemory(Extension, sizeof(MCA_DEVICE_EXTENSION));
    Extension->DeviceObject = McaDeviceObject;

    //
    // Make the device visible to Win32 subsystem
    //

    Status = MCACreateSymbolicLinkObject ();
    if (!NT_SUCCESS( Status )) {
        DbgPrint("Mca DriverEntry: McaCreateSymbolicLinkObject failed\n");
        return Status;
    }

    //
    // Set up the device driver entry points.
    //

    DriverObject->MajorFunction[IRP_MJ_CREATE] = MCAOpen;
    DriverObject->MajorFunction[IRP_MJ_CLOSE]  = MCAClose;
    DriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL] = MCADeviceControl;
    DriverObject->MajorFunction[IRP_MJ_CLEANUP] = MCACleanup;
    DriverObject->DriverUnload = MCAUnload;
    DriverObject->DriverStartIo = MCAStartIo;

    //
    // Register the driver with the HAL
    //

    McaDriverInfo.ExceptionCallback = MCADriverExceptionCallback;
    McaDriverInfo.DpcCallback = MCADriverDpcCallback;
    McaDriverInfo.DeviceContext = McaDeviceObject;

    Status = HalSetSystemInformation(
                    HalMcaRegisterDriver,
                    sizeof(MCA_DRIVER_INFO),
                    (PVOID)&McaDriverInfo
                    );

    if (!NT_SUCCESS( Status )) {
        DbgPrint("Mca DriverEntry: HalMcaRegisterDriver failed\n");
        //
        // Clean up whatever we have done so far
        //
        MCAUnload(DriverObject);
        return(STATUS_UNSUCCESSFUL);
    }

    //
    // This is the place where you would check non-volatile area (if any) for 
    // any Machine Check errros logged and process them.
    // ...
    //

    return STATUS_SUCCESS;
}

NTSTATUS
MCACreateSymbolicLinkObject(
    VOID
    )
/*++
    Routine Description:
        Makes MCA device visible to Win32 subsystem

    Arguments:
        None

    Return Value:
        Success or failure

--*/
{
    NTSTATUS        Status;
    STRING          DosString;
    STRING          NtString;
    UNICODE_STRING  DosUnicodeString;
    UNICODE_STRING  NtUnicodeString;

    //
    // Create a symbolic link for sharing. 
    //

    RtlInitAnsiString( &DosString, MCA_DEVICE_NAME_DOS );

    Status = RtlAnsiStringToUnicodeString(
                 &DosUnicodeString,
                 &DosString,
                 TRUE
                 );

    if ( !NT_SUCCESS( Status )) {
        return Status;
    }

    RtlInitAnsiString( &NtString, MCA_DEVICE_NAME );

    Status = RtlAnsiStringToUnicodeString(
                 &NtUnicodeString,
                 &NtString,
                 TRUE
                 );

    if ( !NT_SUCCESS( Status )) {
        return Status;
    }

    Status = IoCreateSymbolicLink(
        &DosUnicodeString,
        &NtUnicodeString
        );
    RtlFreeUnicodeString( &DosUnicodeString );
    RtlFreeUnicodeString( &NtUnicodeString );

    return (Status);
}

//
// Dispatch routine for close requests
//

NTSTATUS
MCAClose(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++
    Routine Description:
        Close dispatch routine

    Arguments:
        DeviceObject:   Pointer to the device object
        Irp:            Incoming Irp

    Return Value:
        Success or failure

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;

    //
    // Complete the request and return status.
    //

    Irp->IoStatus.Status = Status;
    Irp->IoStatus.Information = 0;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    return (Status);
}

NTSTATUS
MCAOpen(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++
    Routine Description:
        This routine is the dispatch routine for create/open requests.

    Arguments:
        DeviceObject:   Pointer to the device object
        Irp:            Incoming Irp

    Return Value:
        Success or failure

--*/

{
    //
    // Complete the request and return status.
    //

    Irp->IoStatus.Status = STATUS_SUCCESS;
    Irp->IoStatus.Information = FILE_OPENED;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    return (STATUS_SUCCESS);
}

ERROR_SEVERITY
MCADriverExceptionCallback(
    IN PDEVICE_OBJECT DeviceObject,
#if defined(_AMD64_)
    IN PKTRAP_FRAME TrapFrame,
    IN PKEXCEPTION_FRAME ExceptionFrame,
#endif
    IN PMCA_EXCEPTION InException
    )

/*++
    Routine Description:
        This is the callback routine for MCA exception. It was registered 
        by this driver at INIT time with the HAL as a callback when a 
        non-restartable error occurs. This routine simply copies the 
        information to a platform specific area

        NOTE: If the information needs to be saved in NVRAM, this is the place
        to do it.

        Once you return from this callback, the system is going to bugcheck.

    Arguments:
        DeviceObject:   Pointer to the device object
        InException:    Exception information record

    Return Value:
        None

--*/

{
    PMCA_DEVICE_EXTENSION   Extension = DeviceObject->DeviceExtension;
    PCHAR                   Destination, Source;
    UCHAR                   Bytes;

    //
    // An exception has occured on a processor.
    // Perform any vendor specific action here like saving stuff in NVRAM
    // NOTE : No system services of any kind can be used here.
    //

    //
    // Save the exception from HAL. May want to use link list for these 
    // exceptions. 
    //

    Destination = (PCHAR)&(Extension->McaException); // Put your platform 
                                                     // specific destination
    Source = (PCHAR)InException;

    //
    // Copy from source to destination here
    //

#if defined(_IA64_)

    //
    // Return information to the generic HAL MCA handler.
    //
    // Update it accordingly here, the default value being the ERROR_SEVERITY value
    // in the MCA exception.
    //

    return( InException->ErrorSeverity );

#endif // defined(_IA64_)

#if defined(_AMD64_)

    //
    // Return the error severity information to the HAL MCA handler.
    //
    // Chose from:
    //
    // ErrorRecoverable
    // ErrorFatal      
    // ErrorCorrected  
    //

    return ErrorRecoverable;

#endif

}

//
// DPC routine for IRP completion
//

VOID
MCADriverDpcCallback(
    IN PKDPC    Dpc,
    IN PVOID    DeferredContext,
    IN PVOID    SystemContext1,
    IN PVOID    SystemContext2
    )

/*++
    Routine Description:
        This is the DPC - callback routine for MCA exception. It was registered 
        by this driver at INIT time with the HAL as a DPC callback when a 
        restartable error occurs (which causes Machine Check exception)

    Arguments:
        Dpc:                The DPC Object itself
        DefferedContext:    Pointer to the device object
        SystemContext1:     Not used
        SystemContext2:     Not used

    Return Value:
        None

--*/

{
    PMCA_DEVICE_EXTENSION   Extension;

    Extension = ((PDEVICE_OBJECT)DeferredContext)->DeviceExtension;

    if (Extension->SavedIrp == NULL) {
        //
        // We got an MCA exception but no app was asking for anything.
        //
        return;
    }

    //
    // If we have reached this point, it means that the exception was
    // restartable. Since we cannot read the log at Dispatch level,
    // queue a work item to read the Machine Check log at Passive level
    //

    if (Extension->WorkItemQueued == FALSE) {

        //
        // Set a boolean to indicate that we have already queued a work item
        //
        Extension->WorkItemQueued = TRUE;

        //
        // Initialize the work item
        //
        ExInitializeWorkItem(&Extension->WorkItem, 
                             (PWORKER_THREAD_ROUTINE)MCAProcessWorkItem, 
                             (PVOID)DeferredContext
                             );

        //
        // Queue the work item for processing at PASSIVE level
        //
        ExQueueWorkItem(&Extension->WorkItem, CriticalWorkQueue);
    }

}

VOID
MCAProcessWorkItem(
    PVOID   Context
    )

/*++
    Routine Description:
        This routine gets invoked when a work item is queued from the DPC
        callback routine for a restartable machine check error.

        Its job is to read the machine check registers and copy the log
        to complete the asynchronous IRP

    Arguments:
        Context :  Pointer to the device object

    Return Value:
        None

--*/

{

    PMCA_DEVICE_EXTENSION   Extension;
    KIRQL                   CancelIrql;
    ULONG                   ReturnedLength;
    NTSTATUS                Status;

    Extension = ((PDEVICE_OBJECT)Context)->DeviceExtension;

    //
    // Mark this IRP as non-cancellable
    //
    IoAcquireCancelSpinLock(&CancelIrql);
    if (Extension->SavedIrp->Cancel == TRUE) {
        
        IoReleaseCancelSpinLock(CancelIrql);
        
    } else {
        
        IoSetCancelRoutine(Extension->SavedIrp, NULL);
        IoReleaseCancelSpinLock(CancelIrql);
        
	    //
	    // Call HalQuerySystemInformation() to obtain MCA log.
	    //
	
	    Status = HalQuerySystemInformation(
	                HalMcaLogInformation,
	                sizeof(MCA_EXCEPTION),
	                Extension->SavedIrp->AssociatedIrp.SystemBuffer,
	                &ReturnedLength
	                );
	
	    ASSERT(Status != STATUS_NO_SUCH_DEVICE);
	    ASSERT(Status != STATUS_NOT_FOUND);
	
	    IoStartPacket(((PDEVICE_OBJECT)Context), Extension->SavedIrp, 0, NULL);
	
	    Extension->SavedIrp = NULL;
	    Extension->WorkItemQueued = FALSE;
    }
}

VOID
MCAStartIo(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++
    Routine Description:
        This routine completes the async call from the app

    Arguments:
        DeviceObject:   Pointer to the device object
        Irp:            Incoming Irp

    Return Value:
        None

--*/

{
    //
    // The system Buffer has already been setup
    //

    Irp->IoStatus.Information = sizeof(MCA_EXCEPTION);
    Irp->IoStatus.Status = STATUS_SUCCESS;

    IoCompleteRequest( Irp, IO_NO_INCREMENT );

    IoStartNextPacket(DeviceObject, TRUE);  
}

VOID
McaCancelIrp(
    IN PDEVICE_OBJECT DeviceObject, 
    IN PIRP Irp 
    )

/*++

    Routine Description:
        This function gets called when the IRP is cancelled. When this routine 
        is called, we hold the cancel spin lock and we are at DISPATCH level

    Arguments:
        DeviceObject and the Irp to be cancelled.

    Return Value:
        None.

--*/

{
    ((PMCA_DEVICE_EXTENSION)(DeviceObject->DeviceExtension))->SavedIrp = NULL;

    Irp->IoStatus.Status = STATUS_CANCELLED;
    Irp->IoStatus.Information = 0;

    IoReleaseCancelSpinLock(Irp->CancelIrql);

    IoCompleteRequest(Irp, IO_NO_INCREMENT);
    
}

NTSTATUS
MCADeviceControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++
    Routine Description:
        This routine is the dispatch routine for the IOCTL requests to driver. 
        It accepts an I/O Request Packet, performs the request, and then 
        returns with the appropriate status.

    Arguments:
        DeviceObject:   Pointer to the device object
        Irp:            Incoming Irp

    Return Value:
        Success or failure

--*/

{
    NTSTATUS                Status;
    PIO_STACK_LOCATION      IrpSp;
    PMCA_DEVICE_EXTENSION   Extension = DeviceObject->DeviceExtension;
    KIRQL                   CancelIrql;
    ULONG                   ReturnedLength;
    ULONG                   PhysicalAddress;
    KIRQL                   OldIrql;

    //
    // Get a pointer to the current stack location in the IRP.  This is 
    // where the function codes and parameters are stored.
    //

    IrpSp = IoGetCurrentIrpStackLocation( Irp );

    //
    // The individual IOCTLs will return errors if HAL MCA is not installed
    //

    //
    // Switch on the IOCTL code that is being requested by the user.  If the
    // operation is a valid one for this device do the needful.
    //

    switch (IrpSp->Parameters.DeviceIoControl.IoControlCode) {

        case IOCTL_READ_BANKS: 

            //
            // we need a user buffer for this call to complete
            // Our user buffer is in SystemBuffer 
            //
            if (Irp->AssociatedIrp.SystemBuffer == NULL) {
                Status = STATUS_UNSUCCESSFUL;
                break;
            }


            if (IrpSp->Parameters.DeviceIoControl.OutputBufferLength !=
                    sizeof(MCA_EXCEPTION)) {

                Status = STATUS_UNSUCCESSFUL;
                break;
            }
            
            //
            // Call HalQuerySystemInformation() to obtain MCA log.
            // This call can also fail if the processor does not support
            // Intel Machine Check Architecture
            //

            Status = HalQuerySystemInformation(
                        HalMcaLogInformation,
                        sizeof(MCA_EXCEPTION),
                        Irp->AssociatedIrp.SystemBuffer,
                        &ReturnedLength
                        );

            if (NT_SUCCESS(Status)) {
                Irp->IoStatus.Information = ReturnedLength;
            } else {

                if (Status == STATUS_NO_SUCH_DEVICE) {
                    //
                    // MCA support not available\n");
                    //
                    NOTHING;
                }

                if (Status == STATUS_NOT_FOUND) {
                    //
                    // No machine check errors present\n");
                    //
                    NOTHING;
                }

                Irp->IoStatus.Information = 0;
            }

            break;

        case IOCTL_READ_BANKS_ASYNC: 

            if (Irp->AssociatedIrp.SystemBuffer == NULL) {
                Status = STATUS_UNSUCCESSFUL;
                break;
            }

            if (IrpSp->Parameters.DeviceIoControl.OutputBufferLength !=
                    sizeof(MCA_EXCEPTION)) {
                Status = STATUS_UNSUCCESSFUL;
                break;
            }
            
            //
            // Implementation Note:
            //
            // Our Async model is such that the next DeviceIoControl
            // does not start from the app until the previous one
            // completes (asynchronously). Since there is no inherent
            // parallelism that is needed here, we do not have to worry
            // about protecting data integrity in the face of more than
            // one app level ioctls active at the same time. 
            //

            // 
            // asynchronous reads provide a mechanism for the
            // app to asynchronously get input from the HAL on an
            // exception. This request is marked as pending at this time
            // but it will be completed when an MCA exception occurs.
            //

            IoMarkIrpPending(Irp);

            //
            // Complete the processing in StartIo Dispatch routine
            // ASSERT: at any given time there is only 1 async call pending
            // So just save the pointer
            //

            if (Extension->SavedIrp == NULL) {
                Extension->SavedIrp = Irp;
            } else {
                //
                // We can have ONLY one outstanding ASYNC request
                //
                Status = STATUS_DEVICE_BUSY;
                break;
            }

            //
            // Set the IRP to cancellable state
            //
            IoAcquireCancelSpinLock(&CancelIrql);
            IoSetCancelRoutine(Irp, McaCancelIrp);
            IoReleaseCancelSpinLock(CancelIrql);

            return(STATUS_PENDING);

            break;

        default:

            //
            // This should not happen
            //
                
            DbgPrint("MCA driver: Bad ioctl\n");
            Status = STATUS_NOT_IMPLEMENTED;

            break;
    }

    //
    // Copy the final status into the return status, complete the request and
    // get out of here.
    //

    if (Status != STATUS_PENDING) {
        
        //
        // Complete the Io Request
        //

        Irp->IoStatus.Status = Status;
        IoCompleteRequest( Irp, IO_NO_INCREMENT );
    }

    return (Status);
}

NTSTATUS
MCACleanup(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++
    Routine Description:
        This is the dispatch routine for cleanup requests.
        All queued IRPs are completed with STATUS_CANCELLED.

    Arguments:
        DeviceObject:   Pointer to the device object
        Irp:            Incoming Irp

    Return Value:
        Success or failure

--*/

{
    PIRP                    CurrentIrp;
    PMCA_DEVICE_EXTENSION   Extension = DeviceObject->DeviceExtension;

    //
    // Complete all queued requests with STATUS_CANCELLED.
    //

    if (Extension->SavedIrp != NULL) {

        CurrentIrp = Extension->SavedIrp;

        //
        // Acquire the Cancel Spinlock
        //

        IoAcquireCancelSpinLock(&CurrentIrp->CancelIrql);

        Extension->SavedIrp = NULL;

        if (CurrentIrp->Cancel == TRUE) {

            //
            // Cancel routine got called for this one.
            // No need to do anything else
            //

            IoReleaseCancelSpinLock(CurrentIrp->CancelIrql);

        } else {

            if (CurrentIrp->CancelRoutine == NULL) {
                //
                // Release the Cancel Spinlock
                //

                IoReleaseCancelSpinLock(CurrentIrp->CancelIrql);


            } else {
                (CurrentIrp->CancelRoutine)(DeviceObject, CurrentIrp );
            }
        }

    }

    //
    // Complete the Cleanup Dispatch with STATUS_SUCCESS
    //

    Irp->IoStatus.Status = STATUS_SUCCESS;
    Irp->IoStatus.Information = 0;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);
    return(STATUS_SUCCESS);
}

VOID
MCAUnload(
    IN PDRIVER_OBJECT DriverObject
    )

/*++
    Routine Description:
        Dispatch routine for unloads

    Arguments:
        DeviceObject:   Pointer to the device object

    Return Value:
        None

--*/

{
    NTSTATUS        Status;
    STRING          DosString;
    UNICODE_STRING  DosUnicodeString;

    //
    // Delete the user visible device name. 
    //

    RtlInitAnsiString( &DosString, MCA_DEVICE_NAME_DOS );

    Status = RtlAnsiStringToUnicodeString(
                 &DosUnicodeString,
                 &DosString,
                 TRUE
                 );

    if ( !NT_SUCCESS( Status )) {
        DbgPrint("MCAUnload: Error in RtlAnsiStringToUnicodeString\n");
        return;
    }
    
    Status = IoDeleteSymbolicLink(
                    &DosUnicodeString
                    );
               
    RtlFreeUnicodeString( &DosUnicodeString );
    
    //
    // Delete the device object
    //

    IoDeleteDevice(DriverObject->DeviceObject);

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\mcasample\mcamgmt\correctedengine.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    CorrectedEngine.h

Abstract:

    (See module header of CorrectedEngine.cpp)
    
Author:

    Abdullah Ustuner (AUstuner) 28-August-2002

[Notes:]

    Header file for CorrectedEngine.cpp
        
--*/

#ifndef CORRECTEDENGINE_H
#define CORRECTEDENGINE_H

class MCAObjectSink;

//
// Function prototypes for CorrectedEngine.cpp
//
BOOL
MCACreateProcessedEvent(
	VOID
	);

VOID
MCAErrorReceived(
	IN IWbemClassObject *ErrorObject
	);

BOOL
MCAGetCorrectedError(
	VOID
	);

BOOL
MCARegisterCMCConsumer(
	MCAObjectSink *pCMCSink
	);

BOOL
MCARegisterCPEConsumer(
	MCAObjectSink *pCPESink
	);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\mcasample\mcamgmt\common.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    Common.h

Abstract:

    (See module header of Common.cpp)
    
Author:

    Abdullah Ustuner (AUstuner) 28-August-2002

[Notes:]

    Header file for Common.cpp
        
--*/

#ifndef COMMON_H
#define COMMON_H

#if defined(_X86_)
#define MCAPrintErrorRecord MCAPrintErrorRecordX86
#elif defined (_AMD64_)
#define MCAPrintErrorRecord MCAPrintErrorRecordAMD64
#else
#define MCAPrintErrorRecord MCAPrintErrorRecordIA64
#endif

//
// Function prototypes for Common.cpp
//
BOOL
MCAExtractErrorRecord(
    IN IWbemClassObject *Object,
    OUT PUCHAR *PRecordBuffer    
	);

BOOL
MCAInitialize(
	VOID
	);

BOOL
MCAInitializeCOMLibrary(
	VOID
	);

BOOL
MCAInitializeWMISecurity(
	VOID
	);

VOID
MCAPrintErrorRecordX86(
	PUCHAR PErrorRecordBuffer
	);

VOID
MCAPrintErrorRecordAMD64(
	PUCHAR PErrorRecordBuffer
	);

VOID
MCAPrintErrorRecordIA64(
	PUCHAR PErrorRecordBuffer
	);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\mcasample\imca\sys\imca.h ===
/*++

Module Name:

    appmca.h

Abstract:

	Defines related to MCA for app and driver - device names, function codes 
	and ioctls

Author:

Revision History:


--*/

#ifndef APPMCA_H
#define APPMCA_H

//
// 16 bit device type definition.
// Device types 0-32767 are reserved by Microsoft.
//

#define FILE_DEVICE_MCA                     0xb000

//
// 12 bit function codes
// Function codes 0-2047 are reserved by Microsoft.
//

#define FUNCTION_READ_BANKS         0xb00
#define FUNCTION_READ_BANKS_ASYNC   0xb01

#define IOCTL_READ_BANKS  (CTL_CODE(FILE_DEVICE_MCA, FUNCTION_READ_BANKS,\
  		(METHOD_BUFFERED),(FILE_READ_ACCESS|FILE_WRITE_ACCESS)))

#define IOCTL_READ_BANKS_ASYNC  (CTL_CODE(FILE_DEVICE_MCA, \
  		FUNCTION_READ_BANKS_ASYNC,(METHOD_BUFFERED), \
  		(FILE_READ_ACCESS|FILE_WRITE_ACCESS)))

//
// IA64 uses MCA log terminology instead of banks.
//

#define FUNCTION_READ_MCALOG        FUNCTION_READ_BANKS
#define FUNCTION_READ_MCALOG_ASYNC  FUNCTION_READ_BANKS_ASYNC

#define IOCTL_READ_MCALOG  (CTL_CODE(FILE_DEVICE_MCA, FUNCTION_READ_MCALOG,\
  		(METHOD_BUFFERED),(FILE_READ_ACCESS|FILE_WRITE_ACCESS)))

#define IOCTL_READ_MCALOG_ASYNC  (CTL_CODE(FILE_DEVICE_MCA, \
  		FUNCTION_READ_MCALOG_ASYNC,(METHOD_BUFFERED), \
  		(FILE_READ_ACCESS|FILE_WRITE_ACCESS)))

#if defined(_X86_)

//
// HalMcaRegisterDriver:
//  Define x86 ERROR_SEVERITY as VOID for compatibility with IA64 prototype.
//  
// 10/21/2000:
//  It is being proposed to modify PDRIVER_EXCPTN_CALLBACK definition for x86 to match
//  the IA64 definition as a function pointer type returning an ERROR_SEVERITY value.
//  This change was created to allow OEM MCA handlers to return information to the HAL 
//  as a hint how to continue the processing of the MCA event.
//

#define ERROR_SEVERITY VOID

#endif // _X86_

//
// Name that Win32 front end will use to open the MCA device
//

#define MCA_DEVICE_NAME_WIN32      "\\\\.\\imca"

#endif // APPMCA_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\mcasample\mcamgmt\fatalengine.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    FatalEngine.h

Abstract:

    (See module header of FatalEngine.cpp)
    
Author:

    Abdullah Ustuner (AUstuner) 28-August-2002

[Notes:]

    Header file for FatalEngine.cpp
        
--*/

#ifndef FATALENGINE_H
#define FATALENGINE_H

//
// Function prototype for FatalEngine.cpp
//
BOOL
MCAGetFatalError(
	VOID
	);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\mcasample\mcamgmt\fatalengine.cpp ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    FatalEngine.cpp

Abstract:

    This module encapsulates the routines that are needed only for
    fatal error retrieval.
    
Author:

    Abdullah Ustuner (AUstuner) 28-August-2002
        
--*/

#include "mca.h"

extern IWbemServices *gPIWbemServices;
extern IWbemLocator *gPIWbemLocator;


BOOL
MCAGetFatalError(
	VOID
	)
/*++

Routine Description:

    This function queries WMI for a fatal error upon successful completion
    of required initialization tasks. By using the enumerator provided by
    WMI as a response to the query, the object list is parsed and for each
    object the MCA Error Record is extracted. But in reality, there should be
    just one MCA Error Record present.

Arguments:

    none

Return Value:

    TRUE  - Successful.
    FALSE - Unsuccessful.

 --*/
{
	BOOL isSuccess = TRUE;
	HRESULT hResult = 0;
	PUCHAR pErrorRecordBuffer = NULL;	
	INT errorRecordCount = 0;	
	IEnumWbemClassObject *pObjectEnumerator = NULL;	
	IWbemClassObject *apObjects[10];     
    ULONG uReturned = 0;
    ULONG objectIndex = 0;
   	LPWSTR pQueryLanguage = L"WQL";
	LPWSTR pQueryStatement = L"select * from MSMCAInfo_RawMCAData";	
    
	//
	// Complete the required initialization tasks.
	//
	if (!MCAInitialize()) {

		isSuccess = FALSE;

		wprintf(L"ERROR: Initialization failed!\n");

		goto CleanUp;
		
	}

	BSTR bQueryLanguage = SysAllocString(pQueryLanguage);	
	BSTR bQueryStatement = SysAllocString(pQueryStatement);

	if (bQueryLanguage == NULL || bQueryStatement == NULL) {

		isSuccess = FALSE;

		wprintf(L"ERROR: Memory allocation for string failed!\n");

		goto CleanUp;
		
	}
	
	//
    // Query WMI for the fatal error record.
    //
    hResult = gPIWbemServices->ExecQuery(bQueryLanguage,
                              			 bQueryStatement,
                              			 0,
                              			 0,
                              			 &pObjectEnumerator
                              			 ); 

	if (FAILED(hResult)) {

		isSuccess = FALSE;

	    wprintf(L"ERROR: Fatal error querying failed!\n");

	    wprintf(L"ERROR: Result: 0x%x\n", hResult);

	    goto CleanUp;
    
    }

    //
    // Now we will retrieve objects of type IWbemClassOject from this enumeration. 
    //
    do {    	
    	
        //
        // Retrieve objects until none is left in which case the final Next()
        // will return WBEM_S_FALSE.
        //
        hResult = pObjectEnumerator->Next(WBEM_INFINITE,
                            	 		  10,
                            	 		  apObjects,
                            	 		  &uReturned
                            	 		  );

        if (SUCCEEDED(hResult)) {

        	//
        	// Now extract the actual MCA error record from the objects. 
        	//
            for (objectIndex = 0; objectIndex < uReturned; objectIndex++) {

	            if (!MCAExtractErrorRecord(apObjects[objectIndex], &pErrorRecordBuffer)) {
        	    
        	    	isSuccess = FALSE;

                    wprintf(L"ERROR: Failed to get fatal error record data!\n");
                    
                    goto CleanUp;
                    
                }

                if (pErrorRecordBuffer) {

                	errorRecordCount++;

	                wprintf(L"INFO: Succesfully retrieved fatal cache error data.\n");
	    
    			    MCAPrintErrorRecord(pErrorRecordBuffer);
    			    
                }
                
                apObjects[objectIndex]->Release();

            }

        } else {

            wprintf(L"ERROR: Couldn't retrieve WMI objects!\n");

            goto CleanUp;
            
        }
        
	} while (hResult == WBEM_S_NO_ERROR);

    if (errorRecordCount == 0) {

    	wprintf(L"INFO: No fatal error record was found!\n");
    	
    }

	CleanUp:

	//
	// Release all WMI related objects.
	//
	if (pObjectEnumerator) {

        pObjectEnumerator->Release();
        
    }

	if (gPIWbemLocator) {

		gPIWbemLocator->Release();
		
	}

	if (gPIWbemServices) {

		gPIWbemServices->Release();
		
	}

	if (bQueryLanguage != NULL) {
		
		SysFreeString(bQueryLanguage);
			
	}

	if (bQueryStatement != NULL) {
		
		SysFreeString(bQueryStatement);
			
	}
	
	return isSuccess;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\mcasample\mcamgmt\mca.cpp ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    Mca.cpp

Abstract:

    This module is the entry point of the management application. It basically
    handles all user interactions and starts the appropriate operation.
    
Author:

    Abdullah Ustuner (AUstuner) 30-August-2002
        
--*/

#include "mca.h"


typedef enum {
    DISPLAY_USAGE,
    QUERY_FATAL,
    QUERY_CORRECTED
} OPERATION, *POPERATION;

//
// Enumeration which indicates the current operation of the application.
//
OPERATION gOperation = DISPLAY_USAGE;

//
// TimeOut period for corrected error retrieval.
//
extern INT gTimeOut;

INT __cdecl
wmain(
    INT ArgumentCount,
    PWCHAR ArgumentList[]
    )
/*++

Routine Description:

    This function is the main entry point of the application. According to the
    results of the argument-parsing, the appropriate action is taken by this
    function.

Arguments:

    ArgumentCount - Number of command-line arguments passed to the executable
    				(including the executable name).
    
    ArgumentList - Pointer to the actual command-line parameters.

Return Value:

    0  - Successful.
    Otherwise - Unsuccessful.

 --*/
{  
	//
	// Validate the command-line usage of the application.
	//
	if (!MCAParseArguments(ArgumentCount, ArgumentList)) {

		wprintf(L"Incorrect command-line usage!\n");
		wprintf(L"Run as: \"mcamgmt /?\" to view the correct usage.\n");

		return -1;
		
	}	

	MCAPrintTitle();

	//
	// Start the appropriate operation. 
	//
	switch(gOperation){

		case DISPLAY_USAGE: {
			
			MCAPrintUsage();

			return 0;							

		}
			
		case QUERY_FATAL: {

			if (!MCAGetFatalError()) {

				wprintf(L"ERROR: Fatal error retrieval failed!\n");

				return -1;
				
			}

			wprintf(L"INFO: Fatal error retrieval completed successfully.\n");

			return 0;
			
		}
		
		case QUERY_CORRECTED: {

			if (!MCAGetCorrectedError()) {

				wprintf(L"ERROR: Corrected error retrieval failed!\n");

				return -1;
			}

			wprintf(L"INFO: Corrected error retrieval completed successfully.\n");

			return 0;
			
		}
		
	}
   
}


BOOL
MCAParseArguments(
	IN INT ArgumentCount,
	IN PWCHAR ArgumentList[]
	)
/*++

Routine Description:

    This function examines the command line arguments. If the arguments are inaccurate
    then, it returns FALSE. If the arguments are correct then, the operation of the
    tool is set appropriately.
    
Arguments:

    ArgumentCount - Number of command-line arguments passed to the executable
    (including the executable name).
    
    ArgumentList - Pointer to the actual command-line parameters.

Return Value:

    TRUE  - Command-line arguments are correct and tool operation is set successfully.
    FALSE - Incorrect command-line usage. 

 --*/
{
	//
	// Check if number of command-line arguments are in the expected range.
	//
	if (ArgumentCount < 2 || ArgumentCount > 3) {

		return FALSE;
		
	}

	//
	// If switch is "/?" or "/usage".
	//
	if (_wcsicmp(ArgumentList[1], L"/?") == 0 || 
		_wcsicmp(ArgumentList[1], L"/usage") == 0) {

		gOperation = DISPLAY_USAGE;

		return TRUE;
		
	}

	//
	// If switch is "/fatal".
	//
	if (_wcsicmp(ArgumentList[1], L"/fatal") == 0) {

		gOperation = QUERY_FATAL;

		return TRUE;
		
	}

	//
	// If switch is "/corrected".
	//
	if (_wcsicmp(ArgumentList[1], L"/corrected") == 0) {		

		gTimeOut = _wtoi(ArgumentList[2]);

		//
		// The <TimeOut> period should be a positive integer not larger than the
		// maximum time out value, which is predefined.
		//
		if (gTimeOut <= 0 || gTimeOut > TIME_OUT_MAX) {

			wprintf(L"<TimeOut> must be a positive integer with a maximum value of 60(minutes)!\n");

			return FALSE;
			
		}

		gOperation = QUERY_CORRECTED;

		return TRUE;
		
	}

	return FALSE;	
}


VOID
MCAPrintUsage(
	VOID
	)
/*++

Routine Description:

    This function displays the command-line usage of the application on the
    standard output.
    
Arguments:

    none

Return Value:

    none

 --*/
{
	wprintf(L"\n--------------------------- COMMAND-LINE USAGE ----------------------------\n");
    wprintf(L"Usage:\n\n");
    
    wprintf(L"MCAMGMT (/fatal | (/corrected <TimeOut>) | /usage | /?)\n\n");   	
   	
    wprintf(L"    /fatal                Queries the operating system for fatal machine\n");
    wprintf(L"                          check error and retrieves if one exists.\n");
    wprintf(L"    /corrected <TimeOut>  Registers to the operating system for corrected\n");
    wprintf(L"                          machine check error notification and waits for\n");
    wprintf(L"                          <TimeOut> minutes to retrieve an error. <TimeOut>\n");
    wprintf(L"                          can be maximum 60 (minutes).\n");
    wprintf(L"    /usage or /?          Displays the command-line usage.\n\n");
    
    wprintf(L"SAMPLES:\n\n");

    wprintf(L"MCAMGMT /fatal\n\n");
    
    wprintf(L"MCAMGMT /corrected 10\n\n");

    wprintf(L"MCAMGMT /usage\n\n");

    wprintf(L"---------------------------------------------------------------------------\n");    
}


VOID
MCAPrintTitle(
    VOID
    )
/*++

Routine Description:

    This function displays the title of the application on the standard output.
    The title provides an abstract definition of the functionality of the application.
    
Arguments:

    none

Return Value:

    none

 --*/
{
    wprintf(L"*************************************************************************\n");
    wprintf(L"*                       MCA Management Application                      *\n");
    wprintf(L"*-----------------------------------------------------------------------*\n");
    wprintf(L"* Queries the operating system for machine check events and in case     *\n");
   	wprintf(L"* of existence then, retrieves the corresponding MCA event information, *\n");
    wprintf(L"* parses and displays it to the console screen. On IA64 platforms only  *\n");
    wprintf(L"* the error record header and section header contents are displayed     *\n");
    wprintf(L"* whereas on X86 and AMD64 platforms the complete MCA exception         *\n");
    wprintf(L"* information is displayed.                                             *\n");
    wprintf(L"*************************************************************************\n\n");    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\mcasample\mcamgmt\mca.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    Mca.h

Abstract:

    (See module header of Mca.cpp)
    
Author:

    Abdullah Ustuner (AUstuner) 30-August-2002

[Notes:]

    Header file for Mca.cpp
        
--*/

#ifndef MCA_H
#define MCA_H

#include <stdio.h>
#include <stdlib.h>
#include <windows.h>
#include <wbemcli.h>

#include "mce.h"
#include "MCAObjectSink.h"
#include "Common.h"
#include "CorrectedEngine.h"
#include "FatalEngine.h"

#define TIME_OUT_MAX 60

//
// Function prototypes for Mca.cpp
//
BOOL
MCAParseArguments(
	IN INT ArgumentCount,
	IN PWCHAR ArgumentList[]
	);

VOID
MCAPrintTitle(
    VOID
    );

VOID
MCAPrintUsage(
	VOID
	);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\mcasample\mcamgmt\mcaobjectsink.cpp ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    MCAObjectSink.cpp

Abstract:

    This class is used to register as a temporary consumer to WMI for CMC and CPE 
    event notifications. It functions as a IWbemObjectSink to retrieve the
    instances in the result of the query (WMI event notification). When a registered
    event occurs, WMI calls the Indicate function to notify about the event. 

    For more information look at MSDN for: IWbemObjectSink.
    
Author:

    Abdullah Ustuner (AUstuner) 28-August-2002
        
--*/

#include "MCAObjectSink.h"

extern HANDLE gErrorProcessedEvent;


MCAObjectSink::MCAObjectSink()
/*++

Routine Description:

    This function is the constructor of the class. It is responsible for initializing
    the member variables. 
    
Arguments:

    none

Return Value:

    none

 --*/
{    
    referenceCount = 0;
}


ULONG
MCAObjectSink::AddRef()
/*++

Routine Description:

    This function increases the object's reference count by one. The function prevents
    more than one thread to increase the value simultaneously.
    
Arguments:

    none

Return Value:

    Reference count to this object (after increment operation).

 --*/
{
    return InterlockedIncrement(&referenceCount);
}


ULONG
MCAObjectSink::Release()
/*++

Routine Description:

    This function decreases the object's reference count by one. The function prevents
    more than one thread to decrease the value simultaneously. If no other reference 
    is left, the object is deallocated.
    
Arguments:

    none

Return Value:

    lRef - Reference count to this object (after decrement operation).

 --*/
{
    LONG lRef = InterlockedDecrement(&referenceCount);
    
    if (lRef == 0) {
        
        delete this;
        
    }
    
    return lRef;
}


HRESULT
MCAObjectSink::QueryInterface(IN REFIID riid,
                              OUT VOID** ppv
                              )
/*++

Routine Description:

    This function determines if the object supports a particular COM interface.
    If it does, the system increases the object's reference count, and the
    application can use that interface immediately.

Arguments:

    riid - The COM interface identifier of the requested interface.

    ppv - Address of a pointer that will be filled with the interface pointer if
    	  the query succeeds.

Return Value:

    S_OK - Successful
    E_NOINTERFACE - Unsuccessful. Requested interface is not supported.

 --*/
{
    if (riid == IID_IUnknown || riid == IID_IWbemObjectSink) {
        
        *ppv = (IWbemObjectSink *) this;
        
        AddRef();
        
        return S_OK;
        
    }
    
    else return E_NOINTERFACE;
}


HRESULT
MCAObjectSink::Indicate(IN LONG lObjCount,
                        IN IWbemClassObject **pArray
                      )
/*++

Routine Description:

    This function receives the notifications from the WMI provider.

Arguments:

    lObjCount - The number of objects in the following array of pointers.

    pArray - An array of pointers to IWbemClassObject interfaces, that is the event objects.
             The array memory itself is read-only, and is owned by the caller of the method.
             Since this is an in-parameter, the interface called has the option of calling
             IWbemServices::AddRef on any object pointer in the array and holding it before
             returning. The interface called is only required to copy and then call 
             IWbemServices::AddRef on the pointers if the pointers will be used after the 
             call returns, according to COM rules. The interface called should not call 
             Release on the objects without corresponding calls to AddRef. For more 
             information on the IUnknown Interface methods, see the Microsoft Platform SDK.

Return Value:

    WBEM_S_NO_ERROR - Indicating successful processing of the notification.

 --*/
{
    LONG objectIndex = 0;

    //
    // Extract all of the event objects from the array and inform the test engine.
    //
    for (objectIndex = 0; objectIndex < lObjCount; objectIndex++) {      

        //
        // Inform the corrected engine about the event retrieval.
        //
        MCAErrorReceived(pArray[objectIndex]);      
     
        SetEvent(gErrorProcessedEvent);

    }

    return WBEM_S_NO_ERROR;
}


HRESULT
MCAObjectSink::SetStatus(IN LONG lFlags,
                         IN HRESULT hResult,
                         IN BSTR strParam,
                         IN IWbemClassObject __RPC_FAR *pObjParam
                         )
/*++

Routine Description:

    This function is called by sources to indicate the end of a notification sequence
    or the end of a result code of an asynchronous method of IWbemServices.

Arguments:

    lFlags - Reserved. It must be zero.

    hResult - Set to the HRESULT of the asynchronous operation or notification.

    strParam - Receives a pointer to a read-only BSTR, if the original asynchronous operation
               returns a string.

    pObjParam - In cases where a complex error or status object is returned, this contains
                a pointer to the object. If the object is required after the call returns,
                the called object must AddRef the pointer before returning.

Return Value:

    WBEM_S_NO_ERROR

 --*/
{
  return WBEM_S_NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\mcasample\mcamgmt\mcaobjectsink.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    MCAObjectSink.h

Abstract:

    (See module header of MCAObjectSink.cpp)

Author:

    Abdullah Ustuner (AUstuner) 28-August-2002

[Notes:]

    Header file for MCAObjectSink.cpp
     
--*/

#ifndef MCAOBJECTSINK_H
#define MCAOBJECTSINK_H

#include "mca.h"

class MCATestEngine;

class MCAObjectSink : public IWbemObjectSink
{ 

public:

    //
    // Public function prototypes
    //
    MCAObjectSink();
    ~MCAObjectSink(){}; 

    //
    // IUnknown functions
    //
    virtual ULONG STDMETHODCALLTYPE AddRef();
    virtual ULONG STDMETHODCALLTYPE Release();
    
    virtual HRESULT STDMETHODCALLTYPE QueryInterface(IN REFIID riid,
                                                     OUT VOID** ppv);

    // IWbemObjectSink methods
    virtual HRESULT STDMETHODCALLTYPE Indicate(IN LONG lObjectCount,
                                               IN IWbemClassObject __RPC_FAR *__RPC_FAR *apObjArray
                                               );
    
    virtual HRESULT STDMETHODCALLTYPE SetStatus(IN LONG lFlags,
                                                IN HRESULT hResult,
                                                IN BSTR strParam,
                                                IN IWbemClassObject __RPC_FAR *pObjParam
                                                );
private:
      
    //
    // Private variable declarations
    //    
    LONG referenceCount;      
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\pciirqmp\i386\cpq1000.c ===
/*
 *
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *
 *  CPQ1000.C - COMPAQ 1000 PCI chipset routines.
 *
 *  Notes:
 *  Algorithms from COMPAQ 1000 Data Sheet
 *
 */

#include "local.h"

#ifdef ALLOC_DATA_PRAGMA
#pragma data_seg()
#pragma const_seg()
#endif

const UCHAR LinkToIndex[]={0, 1, 6, 7, 4, 5};

#ifdef ALLOC_PRAGMA

#pragma alloc_text(INIT, CPQ1000ValidateTable)

#endif //ALLOC_PRAGMA

/****************************************************************************
 *
 *  CPQ1000SetIRQ - Set a CPQ1000 PCI link to a specific IRQ
 *
 *  Exported.
 *
 *  ENTRY:  bIRQNumber is the new IRQ to be used.
 *
 *      bLink is the Link to be set.
 *
 *  EXIT:   Standard PCIMP return value.
 *
 ***************************************************************************/
PCIMPRET CDECL
CPQ1000SetIRQ(UCHAR bIRQNumber, UCHAR bLink)
{
    UCHAR   bOldValue, bOldIndex, bIndex;
    //
    // Validate link number.
    //
    if (bLink > 6) {

        return(PCIMP_INVALID_LINK);
    }
    //
    // Get the index from the link.
    //
    bIndex=LinkToIndex[bLink-1];

    //
    // Save the old index value.
    //
    bOldIndex=READ_PORT_UCHAR((PUCHAR)0xC00);
    
    //
    // Setup to process the desired link.
    //
    WRITE_PORT_UCHAR((PUCHAR)0xC00, bIndex);

    //
    // Read the old IRQ value.
    //
    bOldValue=(UCHAR)(READ_PORT_UCHAR((PUCHAR)0xC01) & 0x0f);

    bOldValue|=(bIRQNumber<<4);
    
    //
    // Set the VESUVIUS IRQ register.
    //
    WRITE_PORT_UCHAR((PUCHAR)0xC01, bOldValue);

    //
    // Restore the old index value.
    //
    WRITE_PORT_UCHAR((PUCHAR)0xC00, bOldIndex);

    return(PCIMP_SUCCESS);
}

/****************************************************************************
 *
 *  CPQ1000GetIRQ - Get the IRQ of a CPQ1000 PCI link
 *
 *  Exported.
 *
 *  ENTRY:  pbIRQNumber is the buffer to fill.
 *
 *      bLink is the Link to be read.
 *
 *  EXIT:   Standard PCIMP return value.
 *
 ***************************************************************************/
PCIMPRET CDECL
CPQ1000GetIRQ(PUCHAR pbIRQNumber, UCHAR bLink)
{
    UCHAR   bOldValue, bOldIndex, bIndex;
    //
    // Validate link number.
    //
    if (bLink > 6) {

        return(PCIMP_INVALID_LINK);
    }
    //
    // Get the index from the link.
    //
    bIndex=LinkToIndex[bLink-1];

    //
    // Save the old index value.
    //
    bOldIndex=READ_PORT_UCHAR((PUCHAR)0xC00);

    //
    // Setup to read the correct link.
    //
    WRITE_PORT_UCHAR((PUCHAR)0xC00, bIndex);

    bOldValue=READ_PORT_UCHAR((PUCHAR)0xC01);
    
    *pbIRQNumber=(bOldValue>>4);

    //
    // Restore the old index value.
    //
    WRITE_PORT_UCHAR((PUCHAR)0xC00, bOldIndex);

    return(PCIMP_SUCCESS);
}

/****************************************************************************
 *
 *  CPQ1000ValidateTable - Validate an IRQ table
 *
 *  Exported.
 *
 *  ENTRY:  piihIRQInfoHeader points to an IRQInfoHeader followed
 *      by an IRQ Routing Table.
 *
 *      ulFlags are PCIMP_VALIDATE flags.
 *
 *  EXIT:   Standard PCIMP return value.
 *
 ***************************************************************************/
PCIMPRET CDECL
CPQ1000ValidateTable(PIRQINFOHEADER piihIRQInfoHeader, ULONG ulFlags)
{
    PAGED_CODE();
    //
    // If any link is above 6, it is an error.
    //
    if (GetMaxLink(piihIRQInfoHeader)>6)
        return(PCIMP_FAILURE);

    return(PCIMP_SUCCESS);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\pciirqmp\i386\compaq3.c ===
/*
 *
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *
 *  Comap3.C - Compaq MISC 3 PCI chipset routines.
 *
 *  Notes:
 *  Algorithms from Compaq MISC 3 Data Sheet
 *
 */

#include "local.h"

#ifdef ALLOC_PRAGMA

#pragma alloc_text(INIT, Compaq3ValidateTable)

#endif //ALLOC_PRAGMA


/****************************************************************************
 *
 *  Compaq3SetIRQ - Set a MISC 3 PCI link to a specific IRQ
 *
 *  Exported.
 *
 *  ENTRY:  bIRQNumber is the new IRQ to be used.
 *
 *      bLink is the Link to be set.
 *
 *  EXIT:   Standard PCIMP return value.
 *
 ***************************************************************************/
PCIMPRET CDECL
Compaq3SetIRQ(UCHAR bIRQNumber, UCHAR bLink)
{
    UCHAR   bBus, bDevFunc;

    //
    // Validate link number.
    //
    if (bLink >= 10 && bLink <= 12) {
        bLink -= 10;
        bBus = (UCHAR)bBusPIC;
        bDevFunc = (UCHAR)bDevFuncPIC;
    }
    else if (bLink >= 20 && bLink <= 25) {
        bLink -= 20;
        bBus = 0;
        bDevFunc = 0x78;
    }
    else {
        return(PCIMP_INVALID_LINK);
    }

    //
    // Write to the Interrupt Index Register (offset AE)
    //
    WriteConfigUchar(bBus, bDevFunc, (UCHAR)0xAE, bLink);

    //
    // Are we enabling/disabling IRQ?
    //
    if (bIRQNumber==0)
        bIRQNumber|=1;  // Disable IRQ.
    else
        bIRQNumber<<=4; // Enable the specified IRQ.

    //
    // Write to the interrupt map register.
    //
    WriteConfigUchar(bBus, bDevFunc, (UCHAR)0xAF, bIRQNumber);

    return(PCIMP_SUCCESS);
}

/****************************************************************************
 *
 *  Compaq3GetIRQ - Get the IRQ of a MISC 3 PCI link
 *
 *  Exported.
 *
 *  ENTRY:  pbIRQNumber is the buffer to fill.
 *
 *      bLink is the Link to be read.
 *
 *  EXIT:   Standard PCIMP return value.
 *
 ***************************************************************************/
PCIMPRET CDECL
Compaq3GetIRQ(PUCHAR pbIRQNumber, UCHAR bLink)
{
    UCHAR   bBus, bDevFunc;

    //
    // Validate link number.
    //
    if (bLink >= 10 && bLink <= 12) {
        bLink-=10;
        bBus = (UCHAR)bBusPIC;
        bDevFunc = (UCHAR)bDevFuncPIC;
    }
    else if (bLink >= 20 && bLink <= 25) {
        bLink -= 20;
        bBus = 0;
        bDevFunc = 0x78;
    }
    else {
        return(PCIMP_INVALID_LINK);
    }
    
    //
    // Write to the Interrupt Index Register.
    //
    WriteConfigUchar(bBus, bDevFunc, (UCHAR)0xAE, bLink);

    //
    // Read the old MISC 3 IRQ register.
    //
    *pbIRQNumber=(ReadConfigUchar(bBus, bDevFunc, (UCHAR)0xAF)>>4);

    return(PCIMP_SUCCESS);
}

/****************************************************************************
 *
 *  Compaq3ValidateTable - Validate an IRQ table
 *
 *  Exported.
 *
 *  ENTRY:  piihIRQInfoHeader points to an IRQInfoHeader followed
 *      by an IRQ Routing Table.
 *
 *      ulFlags are PCIMP_VALIDATE flags.
 *
 *  EXIT:   Standard PCIMP return value.
 *
 ***************************************************************************/
PCIMPRET CDECL
Compaq3ValidateTable(PIRQINFOHEADER piihIRQInfoHeader, ULONG ulFlags)
{
    PIRQINFO    pii=(PIRQINFO)(((PUCHAR) piihIRQInfoHeader)+sizeof(IRQINFOHEADER));
    ULONG       i, j;
    ULONG       cEntries=(piihIRQInfoHeader->TableSize-sizeof(IRQINFOHEADER))/sizeof(IRQINFO);

    PAGED_CODE();

    for (i=0; i<cEntries; i++) {

        for (j=0; j<4; j++) {

            if (    pii->PinInfo[j].Link == 0 ||
                (pii->PinInfo[j].Link >= 8 && pii->PinInfo[j].Link <= 12) ||
                (pii->PinInfo[j].Link >= 20 && pii->PinInfo[j].Link <= 25))

                continue;

            return PCIMP_FAILURE;
        }
        pii++;
    }

    return(i? PCIMP_SUCCESS : PCIMP_FAILURE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\pciirqmp\i386\cx5520.c ===
/*
 *
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *
 *  Cx5520.C - Cyrix Cx5520 PCI chipset routines.
 *
 *  Notes:
 *  Algorithms from Cyrix Cx5520 Data Sheet
 *
 */

#include "local.h"

#ifdef ALLOC_PRAGMA

#pragma alloc_text(INIT, Cx5520ValidateTable)

#endif //ALLOC_PRAGMA

/****************************************************************************
 *
 *  Cx5520SetIRQ - Set a Cx5520 PCI link to a specific IRQ
 *
 *  Exported.
 *
 *  ENTRY:  bIRQNumber is the new IRQ to be used.
 *
 *      bLink is the Link to be set.
 *
 *  EXIT:   Standard PCIMP return value.
 *
 ***************************************************************************/
PCIMPRET CDECL
Cx5520SetIRQ(UCHAR bIRQNumber, UCHAR bLink)
{
    UCHAR bOldValue, bNewValue, bOffset;
    
    //
    // Validate link number.
    //
    if (bLink > 4)
        return(PCIMP_INVALID_LINK);

    bOffset = (UCHAR)(((bLink - 1) / 2) + 0x5C);
    
    bOldValue = ReadConfigUchar(bBusPIC, bDevFuncPIC, bOffset);

    if (bLink & 1)
    {
        bNewValue = (UCHAR)((bOldValue & 0xF0) | (bIRQNumber & 0x0F));  
    }
    else
    {
        bNewValue = (UCHAR)((bOldValue & 0x0F) | (bIRQNumber << 4));        
    }
    
    WriteConfigUchar(bBusPIC, bDevFuncPIC, bOffset, bNewValue);
    
    return(PCIMP_SUCCESS);
}

/****************************************************************************
 *
 *  Cx5520GetIRQ - Get the IRQ of a Cx5520 PCI link
 *
 *  Exported.
 *
 *  ENTRY:  pbIRQNumber is the buffer to fill.
 *
 *      bLink is the Link to be read.
 *
 *  EXIT:   Standard PCIMP return value.
 *
 ***************************************************************************/
PCIMPRET CDECL
Cx5520GetIRQ(PUCHAR pbIRQNumber, UCHAR bLink)
{
    UCHAR bOldValue, bOffset;
    
    //
    // Validate link number.
    //
    if (bLink > 4)
        return(PCIMP_INVALID_LINK);
    
    bOffset = (UCHAR)(((bLink - 1) / 2) + 0x5C);
    
    bOldValue = ReadConfigUchar(bBusPIC, bDevFuncPIC, bOffset);

    if (!(bLink & 1))
    {
        bOldValue >>= 4;
    }
    
    *pbIRQNumber = (UCHAR)(bOldValue & 0x0F);

    return(PCIMP_SUCCESS);
}

/****************************************************************************
 *
 *  Cx5520ValidateTable - Validate an IRQ table
 *
 *  Exported.
 *
 *  ENTRY:  piihIRQInfoHeader points to an IRQInfoHeader followed
 *      by an IRQ Routing Table.
 *
 *      ulFlags are PCIMP_VALIDATE flags.
 *
 *  EXIT:   Standard PCIMP return value.
 *
 ***************************************************************************/
PCIMPRET CDECL
Cx5520ValidateTable(PIRQINFOHEADER piihIRQInfoHeader, ULONG ulFlags)
{
    PAGED_CODE();

    return ((GetMaxLink(piihIRQInfoHeader) > 4)? PCIMP_FAILURE : PCIMP_SUCCESS);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\pciirqmp\i386\eagle.c ===
/*
 *
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *
 *  EAGLE.C - VLSI Eagle PCI chipset routines.
 *
 *  Notes:
 *  Algorithms from VLSI VL82C534 Spec
 *
 */

#include "local.h"

#define NUM_EAGLE_LINKS 8

void CDECL
EagleUpdateSerialIRQ(
    IN UCHAR bIRQ, 
    IN ULONG fSet
    );


#ifdef ALLOC_DATA_PRAGMA
#pragma data_seg()
#pragma const_seg()
#endif

const UCHAR rgbIRQToBit[16] = {
//  IRQ=   0  1     2  3   4   5   6   7   8   9   10  11  12   13  14  15
    0xFF, 8, 0xFF, 9, 10, 11, 12,  0,  1,  2,  3,  4,  5, 0xFF,  6,  7,
};
const UCHAR rgbBitToIRQ[16] = {
//  Bit=0  1  2  3   4   5   6   7    8   9  10  11  12  13    14    15
    7, 8, 9, 10, 11, 12, 14, 15,  1,  3,  4,  5,  6, 0xFF, 0xFF, 0xFF, 
};

#ifdef ALLOC_PRAGMA

#pragma alloc_text(INIT, VLSIEagleValidateTable)

#endif //ALLOC_PRAGMA

/****************************************************************************
 *
 *  EagleUpdateSerialIRQ - Set or Reset the Eagle Serial IRQ registers
 *
 *  Not exported.
 *
 *  ENTRY:  bIRQ is the IRQ to modify.
 *
 *      fSet is TRUE to set bit, FALSE to reset bit.
 *
 *  EXIT:   None.
 *
 ***************************************************************************/
static void CDECL
EagleUpdateSerialIRQ(UCHAR bIRQ, ULONG fSet)
{
    UCHAR   bBitIndex, bReg;
    USHORT  wBit, wSerialIRQConnection;

    //
    // Validate bIRQ as a serial IRQ.
    //
    if (!bIRQ)
        return;
    bBitIndex=rgbIRQToBit[bIRQ];
    if (bBitIndex==0xFF)
        return;
    wBit=1<<bBitIndex;

    for (bReg=0x70; bReg<=0x72; bReg+=2) {

        wSerialIRQConnection=ReadConfigUshort(  bBusPIC, bDevFuncPIC,
                            bReg);

        if (fSet)
            wSerialIRQConnection|=wBit;
        else
            wSerialIRQConnection&=~wBit;

        WriteConfigUshort(  bBusPIC, bDevFuncPIC, bReg,
                    wSerialIRQConnection);
    }
}

/****************************************************************************
 *
 *  VLSIEagleSetIRQ - Set an Eagle PCI link to a specific IRQ
 *
 *  Exported.
 *
 *  ENTRY:  bIRQNumber is the new IRQ to be used.
 *
 *      bLink is the Link to be set.
 *
 *  EXIT:   Standard PCIMP return value.
 *
 ***************************************************************************/
PCIMPRET CDECL
VLSIEagleSetIRQ(UCHAR bIRQNumber, UCHAR bLink)
{
    ULONG   ulEagleRegister;
    UCHAR   bOldIRQ;
    ULONG   fUsingOldIRQ;
    ULONG   i;

    //
    // Make link number 0 based, and validate.
    //
    bLink--;
    if (bLink >= NUM_EAGLE_LINKS) {

        return(PCIMP_INVALID_LINK);
    }

    //
    // First, set the Eagle Interrupt Connection Register.
    //
    ulEagleRegister=ReadConfigUlong(bBusPIC, bDevFuncPIC, 0x74);
    bOldIRQ=(UCHAR)((ulEagleRegister >> (bLink*4))&0xF);
    ulEagleRegister&=~(0xF << (bLink*4));
    ulEagleRegister|=(bIRQNumber << (bLink*4));
    WriteConfigUlong(bBusPIC, bDevFuncPIC, 0x74, ulEagleRegister);

    //
    // Determine if we are still using the old IRQ.
    //
    fUsingOldIRQ=FALSE;
    for (i=0; i<NUM_EAGLE_LINKS; i++) {
        
        if ((ulEagleRegister >> (bLink*4))==bOldIRQ) {

            fUsingOldIRQ=TRUE;
        }
    }

    //
    // If not using old IRQ, enable the serial IRQs.
    //
    if (!fUsingOldIRQ) {

        EagleUpdateSerialIRQ(bOldIRQ, FALSE);
    }

    //
    // Prevent serial IRQs on the new IRQ.
    //
    EagleUpdateSerialIRQ(bIRQNumber, TRUE);

    return(PCIMP_SUCCESS);
}

/****************************************************************************
 *
 *  VLSIEagleGetIRQ - Get the IRQ of an Eagle PCI link
 *
 *  Exported.
 *
 *  ENTRY:  pbIRQNumber is the buffer to fill.
 *
 *      bLink is the Link to be read.
 *
 *  EXIT:   Standard PCIMP return value.
 *
 ***************************************************************************/
PCIMPRET CDECL
VLSIEagleGetIRQ(PUCHAR pbIRQNumber, UCHAR bLink)
{
    ULONG   ulEagleRegister;

    //
    // Make link number 0 based, and validate.
    //
    bLink--;
    if (bLink >= NUM_EAGLE_LINKS) {

        return(PCIMP_INVALID_LINK);
    }

    //
    // Read in the Eagle Interrupt Connection Register.
    //
    ulEagleRegister=ReadConfigUlong(bBusPIC, bDevFuncPIC, 0x74);

    //
    // Find the link's IRQ value.
    //
    *pbIRQNumber=(UCHAR)((ulEagleRegister >> (bLink*4)) & 0xF);

    return(PCIMP_SUCCESS);
}

/****************************************************************************
 *
 *  VLSIEagleSetTrigger - Set the IRQ triggering values for the Eagle.
 *
 *  Exported.
 *
 *  ENTRY:  ulTrigger has bits set for Level triggered IRQs.
 *
 *  EXIT:   Standard PCIMP return value.
 *
 ***************************************************************************/
PCIMPRET CDECL
VLSIEagleSetTrigger(ULONG ulTrigger)
{
    USHORT  wAssertionRegister;
    ULONG   i;
    UCHAR   bBitIndex;

    wAssertionRegister=0;

    //
    // For each IRQ...
    //
    for (i=0; i<16; i++)
    {
        //
        // If this is to be set level...
        //
        if (ulTrigger & (1<<i)) {

            //
            // If this is not a levelable IRQ, bail.
            //
            bBitIndex=rgbIRQToBit[i];
            if (bBitIndex==0xFF)
                return(PCIMP_INVALID_IRQ);

            //
            // Set the corresponding bit in our new mask.
            //
            wAssertionRegister|=1<<bBitIndex;
        }
    }

    //
    // Set the Assertion Register.
    //
    WriteConfigUshort(bBusPIC, bDevFuncPIC, 0x88, wAssertionRegister);

    return(PCIMP_SUCCESS);
}

/****************************************************************************
 *
 *  VLSIEagleGetTrigger - Get the IRQ triggering values for the Eagle.
 *
 *  Exported.
 *
 *  ENTRY:  pulTrigger will have bits set for Level triggered IRQs.
 *
 *  EXIT:   TRUE if successful.
 *
 ***************************************************************************/
PCIMPRET CDECL
VLSIEagleGetTrigger(PULONG pulTrigger)
{
    USHORT  wAssertionRegister;
    ULONG   i;

    //
    // Read in the Interrupt Assertion Level register.
    //
    wAssertionRegister=ReadConfigUshort(bBusPIC, bDevFuncPIC, 0x88);

    //
    // Clear the return buffer.
    //
    *pulTrigger = 0;

    //
    // For each bit...
    //
    for (i=0; i<16; i++)
    {
        //
        // If the bit set, and this bit corresponds to an IRQ...
        //
        if (    (wAssertionRegister & (1 << i)) &&
            (rgbBitToIRQ[i]!=0xFF))
        {
            //
            // Set the corresponding bit in the
            // return buffer.
            //
            *pulTrigger |= 1 << rgbBitToIRQ[i];
        }
    }

    return(PCIMP_SUCCESS);
}

/****************************************************************************
 *
 *  VLSIEagleValidateTable - Validate an IRQ table
 *
 *  Exported.
 *
 *  ENTRY:  piihIRQInfoHeader points to an IRQInfoHeader followed
 *      by an IRQ Routing Table.
 *
 *      ulFlags are PCIMP_VALIDATE flags.
 *
 *  EXIT:   Standard PCIMP return value.
 *
 ***************************************************************************/
PCIMPRET CDECL
VLSIEagleValidateTable(PIRQINFOHEADER piihIRQInfoHeader, ULONG ulFlags)
{
    PAGED_CODE();

    if (GetMaxLink(piihIRQInfoHeader)>NUM_EAGLE_LINKS) {

        return(PCIMP_FAILURE);
    }

    return(PCIMP_SUCCESS);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\pciirqmp\i386\cpqosb.c ===
/*
 *
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *
 *  CPQOSB.C - COMPAQ OSB PCI chipset routines.
 *
 *  Notes:
 *  Algorithms from COMPAQ OSB Data Sheet
 *
 */

#include "local.h"

#ifdef ALLOC_PRAGMA

#pragma alloc_text(INIT, CPQOSBValidateTable)

#endif //ALLOC_PRAGMA

/****************************************************************************
 *
 *  CPQOSBSetIRQ - Set a CPQOSB PCI link to a specific IRQ
 *
 *  Exported.
 *
 *  ENTRY:  bIRQNumber is the new IRQ to be used.
 *
 *      bLink is the Link to be set.
 *
 *  EXIT:   Standard PCIMP return value.
 *
 ***************************************************************************/
PCIMPRET CDECL
CPQOSBSetIRQ(UCHAR bIRQNumber, UCHAR bLink)
{
    UCHAR   bOldValue, bOldIndex;
    //
    // Validate link number.
    //
    if (bLink > 4) {

        return(PCIMP_INVALID_LINK);
    }
    //
    // Convert link to index.
    //
    bLink+=3;

    //
    // Save the old index value.
    //
    bOldIndex=READ_PORT_UCHAR((PUCHAR)0xC00);

    //
    // Setup to process the desired link.
    //
    WRITE_PORT_UCHAR((PUCHAR)0xC00, bLink);

    //
    // Read the old IRQ value.
    //
    bOldValue=(UCHAR)(READ_PORT_UCHAR((PUCHAR)0xC01) & 0xf0);

    bOldValue|=bIRQNumber;
    
    //
    // Set the OSB IRQ register.
    //
    WRITE_PORT_UCHAR((PUCHAR)0xC01, bOldValue);

    //
    // Restore the old index value.
    //
    WRITE_PORT_UCHAR((PUCHAR)0xC00, bOldIndex);

    return(PCIMP_SUCCESS);
}

/****************************************************************************
 *
 *  CPQOSBGetIRQ - Get the IRQ of a CPQOSB PCI link
 *
 *  Exported.
 *
 *  ENTRY:  pbIRQNumber is the buffer to fill.
 *
 *      bLink is the Link to be read.
 *
 *  EXIT:   Standard PCIMP return value.
 *
 ***************************************************************************/
PCIMPRET CDECL
CPQOSBGetIRQ(PUCHAR pbIRQNumber, UCHAR bLink)
{
    UCHAR   bOldValue, bOldIndex;
    //
    // Validate link number.
    //
    if (bLink > 4) {

        return(PCIMP_INVALID_LINK);
    }
    //
    // Convert link to index.
    //
    bLink+=3;

    //
    // Save the old index value.
    //
    bOldIndex=READ_PORT_UCHAR((PUCHAR)0xC00);

    //
    // Setup to read the correct link.
    //
    WRITE_PORT_UCHAR((PUCHAR)0xC00, bLink);

    bOldValue=READ_PORT_UCHAR((PUCHAR)0xC01);
    
    *pbIRQNumber=bOldValue&0x0f;

    //
    // Restore the old index value.
    //
    WRITE_PORT_UCHAR((PUCHAR)0xC00, bOldIndex);

    return(PCIMP_SUCCESS);
}

/****************************************************************************
 *
 *  CPQOSBValidateTable - Validate an IRQ table
 *
 *  Exported.
 *
 *  ENTRY:  piihIRQInfoHeader points to an IRQInfoHeader followed
 *      by an IRQ Routing Table.
 *
 *      ulFlags are PCIMP_VALIDATE flags.
 *
 *  EXIT:   Standard PCIMP return value.
 *
 ***************************************************************************/
PCIMPRET CDECL
CPQOSBValidateTable(PIRQINFOHEADER piihIRQInfoHeader, ULONG ulFlags)
{
    PAGED_CODE();

    //
    // If any link is above 4, it is an error.
    //
    if (GetMaxLink(piihIRQInfoHeader)>4)
        return(PCIMP_FAILURE);

    return(PCIMP_SUCCESS);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\pciirqmp\i386\local.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    local.h

Abstract:

    This contains the private header information (function prototypes,
    data and type declarations) for the PCI IRQ Miniport library.

Author:

    Santosh Jodh (santoshj) 09-June-1998

Revision History:

--*/
#include "nthal.h"
#include "hal.h"
#include "pci.h"
#include "pciirqmp.h"

#if DBG

#define PCIIRQMPPRINT(x) {                      \
        DbgPrint("PCIIRQMP: ");                 \
        DbgPrint x;                             \
        DbgPrint("\n");                         \
    }
    
#else

#define PCIIRQMPPRINT(x)

#endif

//
// Function prototypes for functions that every chipset module
// has to provide.
//

typedef
NTSTATUS
(*PIRQMINI_VALIDATE_TABLE) (
    PPCI_IRQ_ROUTING_TABLE  PciIrqRoutingTable,
    ULONG                   Flags
    );

typedef
NTSTATUS
(*PIRQMINI_GET_IRQ) (
    OUT PUCHAR  Irq,
    IN  UCHAR   Link
    );

typedef
NTSTATUS
(*PIRQMINI_SET_IRQ) (
    IN UCHAR Irq,
    IN UCHAR Link
    );

typedef
NTSTATUS
(*PIRQMINI_GET_TRIGGER) (
    OUT PULONG Trigger
    );

typedef
NTSTATUS
(*PIRQMINI_SET_TRIGGER) (
    IN ULONG Trigger
    );

//
// Chipset specific data contains a table of function pointers
// to program the chipset.
//

typedef struct _CHIPSET_DATA {
        PIRQMINI_VALIDATE_TABLE ValidateTable;
        PIRQMINI_GET_IRQ        GetIrq;
    PIRQMINI_SET_IRQ        SetIrq;
        PIRQMINI_GET_TRIGGER    GetTrigger;
        PIRQMINI_SET_TRIGGER    SetTrigger;
} CHIPSET_DATA, *PCHIPSET_DATA;

//
// Typedefs to keep source level compatibility with W9x
//

typedef PCI_IRQ_ROUTING_TABLE IRQINFOHEADER;
typedef PPCI_IRQ_ROUTING_TABLE PIRQINFOHEADER;
typedef SLOT_INFO IRQINFO;
typedef PSLOT_INFO PIRQINFO;

#define CDECL   
#define LOCAL_DATA                      static
#define GLOBAL_DATA

#define IO_Delay()

#define CATENATE(x, y)                  x ## y
#define XCATENATE(x, y)                 CATENATE(x, y)
#define DECLARE_MINIPORT_FUNCTION(x, y) XCATENATE(x, y)

//
// Macro to declare a table of function pointers for the chipset
// module.
//

#define DECLARE_CHIPSET(x)                                  \
    {   DECLARE_MINIPORT_FUNCTION(x, ValidateTable),        \
        DECLARE_MINIPORT_FUNCTION(x, GetIRQ),               \
        DECLARE_MINIPORT_FUNCTION(x, SetIRQ),               \
        DECLARE_MINIPORT_FUNCTION(x, GetTrigger),           \
        DECLARE_MINIPORT_FUNCTION(x, SetTrigger)            \
    }

//
// Macro to declare a table of function pointers for EISA
// compatible chipset module.
//

#define DECLARE_EISA_CHIPSET(x)                             \
    {   DECLARE_MINIPORT_FUNCTION(x, ValidateTable),        \
        DECLARE_MINIPORT_FUNCTION(x, GetIRQ),               \
        DECLARE_MINIPORT_FUNCTION(x, SetIRQ),               \
        EisaGetTrigger,                                     \
        EisaSetTrigger                                      \
    }

//
// Macro to declare the functions to be provided by the chipset
// module.
//

#define DECLARE_IRQ_MINIPORT(x)                             \
NTSTATUS                                                    \
DECLARE_MINIPORT_FUNCTION(x, ValidateTable) (               \
    IN PPCI_IRQ_ROUTING_TABLE   PciIrqRoutingTable,         \
    IN ULONG                    Flags                       \
    );                                                      \
NTSTATUS                                                    \
DECLARE_MINIPORT_FUNCTION(x, GetIRQ) (                      \
    OUT PUCHAR  Irq,                                        \
    IN  UCHAR   Link                                        \
    );                                                      \
NTSTATUS                                                    \
DECLARE_MINIPORT_FUNCTION( x, SetIRQ) (                     \
    IN UCHAR Irq,                                           \
    IN UCHAR Link                                           \
    );                                                      \
NTSTATUS                                                    \
DECLARE_MINIPORT_FUNCTION(x, GetTrigger) (                  \
    OUT PULONG Trigger                                      \
    );                                                      \
NTSTATUS                                                    \
DECLARE_MINIPORT_FUNCTION(x, SetTrigger) (                  \
    IN ULONG Trigger                                        \
    );

//
// Macro to declare the functions to be provided by the EISA
// compatible chipset.
//

#define DECLARE_EISA_IRQ_MINIPORT(x)                        \
NTSTATUS                                                    \
DECLARE_MINIPORT_FUNCTION(x, ValidateTable) (               \
    IN PPCI_IRQ_ROUTING_TABLE  PciIrqRoutingTable,          \
    IN ULONG                   Flags                        \
    );                                                      \
NTSTATUS                                                    \
DECLARE_MINIPORT_FUNCTION(x, GetIRQ) (                      \
    OUT PUCHAR  Irq,                                        \
    IN  UCHAR   Link                                        \
    );                                                      \
NTSTATUS                                                    \
DECLARE_MINIPORT_FUNCTION( x, SetIRQ) (                     \
    IN UCHAR Irq,                                           \
    IN UCHAR Link                                           \
    );

//
// Declare all miniports here.
//

DECLARE_EISA_IRQ_MINIPORT(Mercury)
DECLARE_EISA_IRQ_MINIPORT(Triton)
DECLARE_IRQ_MINIPORT(VLSI)
DECLARE_IRQ_MINIPORT(OptiViper)
DECLARE_EISA_IRQ_MINIPORT(SiS5503)
DECLARE_IRQ_MINIPORT(VLSIEagle)
DECLARE_EISA_IRQ_MINIPORT(M1523)
DECLARE_IRQ_MINIPORT(NS87560)
DECLARE_EISA_IRQ_MINIPORT(Compaq3)
DECLARE_EISA_IRQ_MINIPORT(M1533)
DECLARE_IRQ_MINIPORT(OptiFireStar)
DECLARE_EISA_IRQ_MINIPORT(VT586)
DECLARE_EISA_IRQ_MINIPORT(CPQOSB)
DECLARE_EISA_IRQ_MINIPORT(CPQ1000)
DECLARE_EISA_IRQ_MINIPORT(Cx5520)
DECLARE_IRQ_MINIPORT(Toshiba)
DECLARE_IRQ_MINIPORT(NEC)
DECLARE_IRQ_MINIPORT(VESUVIUS)

//
// Prototype for misc utility functions.
//

NTSTATUS    
EisaGetTrigger (
    OUT PULONG Trigger
    );    

NTSTATUS
EisaSetTrigger (
    IN ULONG Trigger
    );

UCHAR
ReadConfigUchar (
    IN ULONG           BusNumber,
    IN ULONG           DevFunc,
    IN UCHAR           Offset
    );

USHORT
ReadConfigUshort (
    IN ULONG           BusNumber,
    IN ULONG           DevFunc,
    IN UCHAR           Offset
    );

ULONG
ReadConfigUlong (
    IN ULONG           BusNumber,
    IN ULONG           DevFunc,
    IN UCHAR           Offset
    );

VOID
WriteConfigUchar (
    IN ULONG           BusNumber,
    IN ULONG           DevFunc,
    IN UCHAR           Offset,
    IN UCHAR           Data
    );

VOID
WriteConfigUshort (
    IN ULONG           BusNumber,
    IN ULONG           DevFunc,
    IN UCHAR           Offset,
    IN USHORT          Data
    );

VOID
WriteConfigUlong (
    IN ULONG           BusNumber,
    IN ULONG           DevFunc,
    IN UCHAR           Offset,
    IN ULONG           Data
    );

UCHAR
GetMinLink (
    IN PPCI_IRQ_ROUTING_TABLE PciIrqRoutingTable
    );

UCHAR
GetMaxLink (
    IN PPCI_IRQ_ROUTING_TABLE PciIrqRoutingTable
    );

VOID
NormalizeLinks (
    IN PPCI_IRQ_ROUTING_TABLE  PciIrqRoutingTable,
    IN UCHAR                   Adjustment
    );

//
// Bus number of the Pci Irq Router device.
//

extern ULONG    bBusPIC;

//
// Slot number of Pci Irq Router device (Bits 7:3 Dev, 2:0 Func).
//

extern ULONG    bDevFuncPIC;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\pciirqmp\i386\m1523.c ===
/*
 *
 *  Copyright (c) Microsoft Corporation. All rights reserved. 
 *
 *  M1523.C - ALI M1523 PCI chipset routines.
 *
 *  Notes:
 *  Algorithms from ALI M1523 Data Sheet
 *
 */

#include "local.h"

#ifdef ALLOC_DATA_PRAGMA
#pragma data_seg()
#pragma const_seg()
#endif

LOCAL_DATA  const UCHAR IrqToMaskTable[]={  0x00,0x00,0x00,0x02,
                                        0x04,0x05,0x07,0x06,
                                        0x00,0x01,0x03,0x09,
                                        0x0b,0x00,0x0d, 0x0f};

LOCAL_DATA  const UCHAR MaskToIRQTable[]={  0x00,0x09,0x03,0x0a,
                                        0x04,0x05,0x07,0x06,
                                        0x00,0x0b,0x00,0x0c,
                                        0x00, 0x0e,0x00,0x0f};

#ifdef ALLOC_PRAGMA

#pragma alloc_text(INIT, M1523ValidateTable)

#endif //ALLOC_PRAGMA

/****************************************************************************
 *
 *  M1523SetIRQ - Set a M1523 PCI link to a specific IRQ
 *
 *  Exported.
 *
 *  ENTRY:  bIRQNumber is the new IRQ to be used.
 *
 *      bLink is the Link to be set.
 *
 *  EXIT:   Standard PCIMP return value.
 *
 ***************************************************************************/
PCIMPRET CDECL
M1523SetIRQ(UCHAR bIRQNumber, UCHAR bLink)
{
    UCHAR   bOffset, bOldValue;
    //
    // Validate link number.
    //
    if (bLink > 8) {

        return(PCIMP_INVALID_LINK);
    }

    //
    // Get the IRQ number from the look-up table.
    //
    bIRQNumber=IrqToMaskTable[bIRQNumber&0x0f];

    //
    // Zero based.
    //
    bLink--;

    //
    // Set various values.
    //
    bOffset=(bLink/2)+0x48;

    //
    // Read the old M1523 IRQ register.
    //
    bOldValue=ReadConfigUchar(bBusPIC, bDevFuncPIC, bOffset);

    if (bLink&1) {
        bOldValue&=0x0f;
        bOldValue|=(bIRQNumber<<4);
    }
    else {
        bOldValue&=0xf0;
        bOldValue|=bIRQNumber;
    }

    //
    // Set the M1523 IRQ register.
    //
    WriteConfigUchar(bBusPIC, bDevFuncPIC, bOffset, bOldValue);

    return(PCIMP_SUCCESS);
}

/****************************************************************************
 *
 *  M1523GetIRQ - Get the IRQ of a M1523 PCI link
 *
 *  Exported.
 *
 *  ENTRY:  pbIRQNumber is the buffer to fill.
 *
 *      bLink is the Link to be read.
 *
 *  EXIT:   Standard PCIMP return value.
 *
 ***************************************************************************/
PCIMPRET CDECL
M1523GetIRQ(PUCHAR pbIRQNumber, UCHAR bLink)
{
    UCHAR   bOffset, bOldValue;
    //
    // Validate link number.
    //
    if (bLink > 8) {

        return(PCIMP_INVALID_LINK);
    }

    //
    // Zero based.
    //
    bLink--;

    //
    // Set various values.
    //
    bOffset=(bLink/2)+0x48;

    //
    // Read the old M1523 IRQ register.
    //
    bOldValue=ReadConfigUchar(bBusPIC, bDevFuncPIC, bOffset);

    if (bLink&1)
        bOldValue>>=4;

    *pbIRQNumber=MaskToIRQTable[bOldValue&0x0f];

    return(PCIMP_SUCCESS);
}

/****************************************************************************
 *
 *  M1523ValidateTable - Validate an IRQ table
 *
 *  Exported.
 *
 *  ENTRY:  piihIRQInfoHeader points to an IRQInfoHeader followed
 *      by an IRQ Routing Table.
 *
 *      ulFlags are PCIMP_VALIDATE flags.
 *
 *  EXIT:   Standard PCIMP return value.
 *
 ***************************************************************************/
PCIMPRET CDECL
M1523ValidateTable(PIRQINFOHEADER piihIRQInfoHeader, ULONG ulFlags)
{
    PAGED_CODE();
    //
    // If any link is above 8, it is an error.
    //
    if (GetMaxLink(piihIRQInfoHeader)>8)
        return(PCIMP_FAILURE);

    return(PCIMP_SUCCESS);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\pciirqmp\i386\m1533.c ===
/*
 *
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *
 *  M1533.C - ALI M1533 PCI chipset routines.
 *
 *  Notes:
 *  Algorithms from ALI M1533 Data Sheet
 *
 */

#include "local.h"

#ifdef ALLOC_DATA_PRAGMA
#pragma data_seg()
#pragma const_seg()
#endif

LOCAL_DATA  const UCHAR IrqToMaskTable[]={  0x00,0x00,0x00,0x02,
                        0x04,0x05,0x07,0x06,
                        0x00,0x01,0x03,0x09,
                        0x0b,0x00,0x0d, 0x0f};

LOCAL_DATA  const UCHAR MaskToIRQTable[]={      0x00,0x09,0x03,0x0a,
                        0x04,0x05,0x07,0x06,
                        0x00,0x0b,0x00,0x0c,
                        0x00, 0x0e,0x00,0x0f};

#ifdef ALLOC_PRAGMA

#pragma alloc_text(INIT, M1533ValidateTable)

#endif //ALLOC_PRAGMA

/****************************************************************************
 *
 *  M1533SetIRQ - Set a M1533 PCI link to a specific IRQ
 *
 *  Exported.
 *
 *  ENTRY:  bIRQNumber is the new IRQ to be used.
 *
 *      bLink is the Link to be set.
 *
 *  EXIT:   Standard PCIMP return value.
 *
 ***************************************************************************/
PCIMPRET CDECL
M1533SetIRQ(UCHAR bIRQNumber, UCHAR bLink)
{
    UCHAR   bOffset, bOldValue;
    //
    // Validate link number.
    //
    if (bLink > 8 && bLink != 0x59) {

        return(PCIMP_INVALID_LINK);
    }

    //
    // Get the IRQ number from the look-up table.
    //
    bIRQNumber=IrqToMaskTable[bIRQNumber&0x0f];

    //
    // Zero based.
    //
    bLink--;

    //
    // Set various values.
    //
    bOffset=(bLink/2)+0x48;

    //
    // Read the old M1533 IRQ register.
    //
    bOldValue=ReadConfigUchar(bBusPIC, bDevFuncPIC, bOffset);

    if (bLink&1) {
        bOldValue&=0x0f;
        bOldValue|=(bIRQNumber<<4);
    }
    else {
        bOldValue&=0xf0;
        bOldValue|=bIRQNumber;
    }

    //
    // Set the M1533 IRQ register.
    //
    WriteConfigUchar(bBusPIC, bDevFuncPIC, bOffset, bOldValue);

    return(PCIMP_SUCCESS);
}

/****************************************************************************
 *
 *  M1533GetIRQ - Get the IRQ of a M1533 PCI link
 *
 *  Exported.
 *
 *  ENTRY:  pbIRQNumber is the buffer to fill.
 *
 *      bLink is the Link to be read.
 *
 *  EXIT:   Standard PCIMP return value.
 *
 ***************************************************************************/
PCIMPRET CDECL
M1533GetIRQ(PUCHAR pbIRQNumber, UCHAR bLink)
{
    UCHAR   bOffset, bOldValue;
    //
    // Validate link number.
    //
    if (bLink > 8 && bLink != 0x59) {

        return(PCIMP_INVALID_LINK);
    }

    //
    // Zero based.
    //
    bLink--;

    //
    // Set various values.
    //
    bOffset=(bLink/2)+0x48;

    //
    // Read the old M1533 IRQ register.
    //
    bOldValue=ReadConfigUchar(bBusPIC, bDevFuncPIC, bOffset);

    if (bLink&1)
        bOldValue>>=4;

    *pbIRQNumber=MaskToIRQTable[bOldValue&0x0f];

    return(PCIMP_SUCCESS);
}

/****************************************************************************
 *
 *  M1533ValidateTable - Validate an IRQ table
 *
 *  Exported.
 *
 *  ENTRY:  piihIRQInfoHeader points to an IRQInfoHeader followed
 *      by an IRQ Routing Table.
 *
 *      ulFlags are PCIMP_VALIDATE flags.
 *
 *  EXIT:   Standard PCIMP return value.
 *
 ***************************************************************************/
PCIMPRET CDECL
M1533ValidateTable(PIRQINFOHEADER piihIRQInfoHeader, ULONG ulFlags)
{
    UCHAR bMaxLink = GetMaxLink(piihIRQInfoHeader);
    
    PAGED_CODE();

    if (bMaxLink <= 0x08)
        return PCIMP_SUCCESS;

    if (bMaxLink == 0x59)
        return PCIMP_SUCCESS;

    return PCIMP_FAILURE;       
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\pciirqmp\i386\nec.c ===
/*
 *
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *
 *  NEC.C - NEC C98Bus Bridge chipset routines.
 *
 */

#include "local.h"
 
#ifdef ALLOC_PRAGMA

#pragma alloc_text(INIT, NECValidateTable)

#endif //ALLOC_PRAGMA

/****************************************************************************
 *
 *  NECSetIRQ - Set a Triton PCI link to a specific IRQ
 *
 *  Exported.
 *
 *  ENTRY:  bIRQNumber is the new IRQ to be used.
 *
 *      bLink is the Link to be set.
 *
 *  EXIT:   Standard PCIMP return value.
 *
 ***************************************************************************/
PCIMPRET CDECL
NECSetIRQ(UCHAR bIRQNumber, UCHAR bLink)
{
    //
    // Validate link number.
    //
    if (bLink < 0x60) {

        return(PCIMP_INVALID_LINK);
    }

    //
    // Use 0x80 to disable.
    //
    if (!bIRQNumber)
        bIRQNumber=0x80;

    //
    // Set the Triton IRQ register.
    //
    WriteConfigUchar(bBusPIC, bDevFuncPIC, bLink, bIRQNumber);

    return(PCIMP_SUCCESS);
}

/****************************************************************************
 *
 *  NECGetIRQ - Get the IRQ of a Triton PCI link
 *
 *  Exported.
 *
 *  ENTRY:  pbIRQNumber is the buffer to fill.
 *
 *      bLink is the Link to be read.
 *
 *  EXIT:   Standard PCIMP return value.
 *
 ***************************************************************************/
PCIMPRET CDECL
NECGetIRQ(PUCHAR pbIRQNumber, UCHAR bLink)
{
    //
    // Validate link number.
    //
    if (bLink < 0x60) {

        return(PCIMP_INVALID_LINK);
    }

    //
    // Store the IRQ value.
    //
    *pbIRQNumber=ReadConfigUchar(bBusPIC, bDevFuncPIC, bLink);

    //
    // Return 0 if disabled.
    //
    if (*pbIRQNumber & 0x80)
        *pbIRQNumber=0;

    return(PCIMP_SUCCESS);
}

/****************************************************************************
 *
 *  NECSetTrigger - Set the IRQ triggering values for an Intel system.
 *
 *  Exported.
 *
 *  ENTRY:  ulTrigger has bits set for Level triggered IRQs.
 *
 *  EXIT:   Standard PCIMP return value.
 *
 ***************************************************************************/
PCIMPRET CDECL
NECSetTrigger(ULONG ulTrigger)
{
    // PC-9800 can not handle IRQ trigger.
    // we have nothing to do.

    return(PCIMP_SUCCESS);
}

/****************************************************************************
 *
 *  NECGetTrigger - Get the IRQ triggering values for an Intel system.
 *
 *  Exported.
 *
 *  ENTRY:  pulTrigger will have bits set for Level triggered IRQs.
 *
 *  EXIT:   Standard PCIMP return value.
 *
 ***************************************************************************/
PCIMPRET CDECL
NECGetTrigger(PULONG pulTrigger)
{
    // PC-9800 can not handle IRQ trigger.
    // We fake IRQ triggering value so that PCI.VXD works fine.

    *pulTrigger = 0xffff;
    return(PCIMP_SUCCESS);
}

/****************************************************************************
 *
 *  NECValidateTable - Validate an IRQ table
 *
 *  Exported.
 *
 *  ENTRY:  piihIRQInfoHeader points to an IRQInfoHeader followed
 *      by an IRQ Routing Table.
 *
 *      ulFlags are PCIMP_VALIDATE flags.
 *
 *  EXIT:   Standard PCIMP return value.
 *
 ***************************************************************************/
PCIMPRET CDECL
NECValidateTable(PIRQINFOHEADER piihIRQInfoHeader, ULONG ulFlags)
{
    PAGED_CODE();

    if ((ulFlags & PCIMP_VALIDATE_SOURCE_BITS)==PCIMP_VALIDATE_SOURCE_PCIBIOS) {

        //
        // If all links are above 60, we they are config space.
        //
        if (GetMinLink(piihIRQInfoHeader)>=0x60)
            return(PCIMP_SUCCESS);

        //
        // If there are links above 4, we are clueless.
        //
        if (GetMaxLink(piihIRQInfoHeader)>0x04)
            return(PCIMP_FAILURE);

        //
        // Assume 1,2,3,4 are the 60,61,62,63 links.
        //
        NormalizeLinks(piihIRQInfoHeader, 0x5F);
        
    } else {

        //
        // Validate that all config space addresses are above 60.
        //
        if (GetMinLink(piihIRQInfoHeader)<0x60)
            return(PCIMP_FAILURE);
    }

    return(PCIMP_SUCCESS);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\pciirqmp\i386\ns87560.c ===
/*
 *
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *
 *  NS87560.C - NS NS87560 PCI chipset routines.
 *
 *  Notes:
 *  Algorithms from National Semiconductor NS87560 Data Sheet
 *
 */

#include "local.h"

#ifdef ALLOC_PRAGMA

#pragma alloc_text(INIT, NS87560ValidateTable)

#endif //ALLOC_PRAGMA

/****************************************************************************
 *
 *  NS87560SetIRQ - Set a NS87560 PCI link to a specific IRQ
 *
 *  Exported.
 *
 *  ENTRY:  bIRQNumber is the new IRQ to be used.
 *
 *      bLink is the Link to be set.
 *
 *  EXIT:   Standard PCIMP return value.
 *
 ***************************************************************************/
PCIMPRET CDECL
NS87560SetIRQ(UCHAR bIRQNumber, UCHAR bLink)
{
    UCHAR   bOffset, bOldValue;
    //
    // Validate link number.
    //
    if (bLink > 4) {

        return(PCIMP_INVALID_LINK);
    }
    //
    // Zero based.
    //
    bLink--;

    //
    // Set various values.
    //
    bOffset=(bLink/2)+0x6C;

    //
    // Read the old NS87560 IRQ register.
    //
    bOldValue=ReadConfigUchar(bBusPIC, bDevFuncPIC, bOffset);

    if (bLink&1) {
        bOldValue&=0x0f;
        bOldValue|=(bIRQNumber<<4);
    }
    else {
        bOldValue&=0xf0;
        bOldValue|=bIRQNumber;
    }

    //
    // Set the NS87560 IRQ register.
    //
    WriteConfigUchar(bBusPIC, bDevFuncPIC, bOffset, bOldValue);

    return(PCIMP_SUCCESS);
}

/****************************************************************************
 *
 *  NS87560GetIRQ - Get the IRQ of a NS87560 PCI link
 *
 *  Exported.
 *
 *  ENTRY:  pbIRQNumber is the buffer to fill.
 *
 *      bLink is the Link to be read.
 *
 *  EXIT:   Standard PCIMP return value.
 *
 ***************************************************************************/
PCIMPRET CDECL
NS87560GetIRQ(PUCHAR pbIRQNumber, UCHAR bLink)
{
    UCHAR   bOffset, bOldValue;
    //
    // Validate link number.
    //
    if (bLink > 4) {

        return(PCIMP_INVALID_LINK);
    }

    //
    // Zero based.
    //
    bLink--;

    //
    // Set various values.
    //
    bOffset=(bLink/2)+0x6C;

    //
    // Read the old NS87560 IRQ register.
    //
    bOldValue=ReadConfigUchar(bBusPIC, bDevFuncPIC, bOffset);

    if (bLink&1)
        bOldValue>>=4;

    *pbIRQNumber=bOldValue&0x0f;

    return(PCIMP_SUCCESS);
}

/****************************************************************************
 *
 *  NS87560SetTrigger - Set the IRQ triggering values for the NS87560
 *
 *  Exported.
 *
 *  ENTRY:  ulTrigger has bits set for Level triggered IRQs.
 *
 *  EXIT:   Standard PCIMP return value.
 *
 ***************************************************************************/
PCIMPRET CDECL
NS87560SetTrigger(ULONG ulTrigger)
{
    WriteConfigUchar(bBusPIC, bDevFuncPIC, 0x67, (UCHAR)ulTrigger);
    WriteConfigUchar(bBusPIC, bDevFuncPIC, 0x68, (UCHAR)(ulTrigger >> 8));

    return (PCIMP_SUCCESS);
}

/****************************************************************************
 *
 *  NS87560GetTrigger - Get the IRQ triggering values for the NS87560
 *
 *  Exported.
 *
 *  ENTRY:  pulTrigger will have bits set for Level triggered IRQs.
 *
 *  EXIT:   Standard PCIMP return value.
 *
 ***************************************************************************/
PCIMPRET CDECL
NS87560GetTrigger(PULONG pulTrigger)
{
    //
    // Assume all edge.
    //
    *pulTrigger = 0;

    *pulTrigger |= ReadConfigUchar(bBusPIC, bDevFuncPIC, 0x67);
    *pulTrigger |= (ReadConfigUchar(bBusPIC, bDevFuncPIC, 0x68) << 8);

    return (PCIMP_SUCCESS);
}

/****************************************************************************
 *
 *  NS87560ValidateTable - Validate an IRQ table
 *
 *  Exported.
 *
 *  ENTRY:  piihIRQInfoHeader points to an IRQInfoHeader followed
 *      by an IRQ Routing Table.
 *
 *      ulFlags are PCIMP_VALIDATE flags.
 *
 *  EXIT:   Standard PCIMP return value.
 *
 ***************************************************************************/
PCIMPRET CDECL
NS87560ValidateTable(PIRQINFOHEADER piihIRQInfoHeader, ULONG ulFlags)
{
    PAGED_CODE();
    //
    // If any link is above 4, it is an error.
    //
    if (GetMaxLink(piihIRQInfoHeader)>4)
        return(PCIMP_FAILURE);

    return(PCIMP_SUCCESS);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\pciirqmp\i386\mercury.c ===
/*
 *
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *
 *  MERCURY.C - Intel Mercury PCI chipset routines.
 *
 *  Notes:
 *  Algorithms from Intel 82420/82430 PCISet EISA Bridge doc,
 *  82374EB/SB EISA System Component (ESC) spec.
 *
 */

#include "local.h"

#ifdef ALLOC_PRAGMA

#pragma alloc_text(INIT, MercuryValidateTable)

#endif //ALLOC_PRAGMA


/****************************************************************************
 *
 *  MercurySetIRQ - Set a Mercury PCI link to a specific IRQ
 *
 *  Exported.
 *
 *  ENTRY:  bIRQNumber is the new IRQ to be used.
 *
 *      bLink is the Link to be set.
 *
 *  EXIT:   Standard PCIMP return value.
 *
 ***************************************************************************/
PCIMPRET CDECL
MercurySetIRQ(UCHAR bIRQNumber, UCHAR bLink)
{
    //
    // Make link number 0 based, and validate.
    //
    bLink--;
    if (bLink > 3) {

        return(PCIMP_INVALID_LINK);
    }

    //
    // Use 0x80 to disable.
    //
    if (!bIRQNumber)
        bIRQNumber=0x80;

    //
    // Start talking to interrupt controller.
    //
    WRITE_PORT_UCHAR((PUCHAR)0x22, 0x02);
    WRITE_PORT_UCHAR((PUCHAR)0x23, 0x0f);

    //
    // Set our link to the new IRQ.
    //
    WRITE_PORT_UCHAR((PUCHAR)0x22, (UCHAR)(bLink+0x60));
    WRITE_PORT_UCHAR((PUCHAR)0x23, bIRQNumber);

    //
    // Done talking to interrupt controller.
    //
    WRITE_PORT_UCHAR((PUCHAR)0x22, 0x02);
    WRITE_PORT_UCHAR((PUCHAR)0x23, 0x00);

    return(PCIMP_SUCCESS);
}

/****************************************************************************
 *
 *  MercuryGetIRQ - Get the IRQ of a Mercury PCI link
 *
 *  Exported.
 *
 *  ENTRY:  pbIRQNumber is the buffer to fill.
 *
 *      bLink is the Link to be read.
 *
 *  EXIT:   Standard PCIMP return value.
 *
 ***************************************************************************/
PCIMPRET CDECL
MercuryGetIRQ(PUCHAR pbIRQNumber, UCHAR bLink)
{
    //
    // Make link number 0 based, and validate.
    //
    bLink--;
    if (bLink > 3) {

        return(PCIMP_INVALID_LINK);
    }

    //
    // Start talking to interrupt controller.
    //
    WRITE_PORT_UCHAR((PUCHAR)0x22, 0x02);
    WRITE_PORT_UCHAR((PUCHAR)0x23, 0x0f);

    //
    // Get our link's IRQ.
    //
    WRITE_PORT_UCHAR((PUCHAR)0x22, (UCHAR)(bLink+0x60));
    *pbIRQNumber=READ_PORT_UCHAR((PUCHAR)0x23);

    //
    // Done talking to interrupt controller.
    //
    WRITE_PORT_UCHAR((PUCHAR)0x22, 0x02);
    WRITE_PORT_UCHAR((PUCHAR)0x23, 0x00);

    //
    // Return 0 if disabled.
    //
    if (*pbIRQNumber & 0x80)
        *pbIRQNumber=0;

    return(PCIMP_SUCCESS);
}

/****************************************************************************
 *
 *  MercuryValidateTable - Validate an IRQ table
 *
 *  Exported.
 *
 *  ENTRY:  piihIRQInfoHeader points to an IRQInfoHeader followed
 *      by an IRQ Routing Table.
 *
 *      ulFlags are PCIMP_VALIDATE flags.
 *
 *  EXIT:   Standard PCIMP return value.
 *
 ***************************************************************************/
PCIMPRET CDECL
MercuryValidateTable(PIRQINFOHEADER piihIRQInfoHeader, ULONG ulFlags)
{
    UCHAR bMin=GetMinLink(piihIRQInfoHeader);
    UCHAR bMax=GetMaxLink(piihIRQInfoHeader);

    PAGED_CODE();

    if (bMax<=0x04) {

        return(PCIMP_SUCCESS);
    }

    if ((bMin<0x60) || (bMax>0x63)) {

        return(PCIMP_FAILURE);
    }

    NormalizeLinks(piihIRQInfoHeader, (UCHAR)(0-0x5F));

    return(PCIMP_SUCCESS);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\pciirqmp\i386\optifire.c ===
/*
 *
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *
 *  OptiFireStar.C - OPTI FIRESTAR PCI chipset routines.
 *
 *  Notes:
 *  Algorithms from OPTI FIRESTAR Data Sheet
 *  Opti contact: William@unixgate.opti.com     
 *
 */

#include "local.h"

#ifdef ALLOC_PRAGMA

#pragma alloc_text(INIT, OptiFireStarValidateTable)

#endif //ALLOC_PRAGMA


/****************************************************************************
 *
 *  OptiFireStarSetIRQ - Set a OPTI FIRESTAR PCI link to a specific IRQ
 *
 *  Exported.
 *
 *  ENTRY:  bIRQNumber is the new IRQ to be used.
 *
 *      bLink is the Link to be set.
 *
 *  EXIT:   Standard PCIMP return value.
 *
 ***************************************************************************/
PCIMPRET CDECL
OptiFireStarSetIRQ(UCHAR bIRQNumber, UCHAR bLink)
{
    UCHAR   bData, bOffset;
    
    switch (bLink & 0x07)
    {
        case 0:
        
            if (bLink == 0)
                return (PCIMP_FAILURE);
            else
                return (PCIMP_INVALID_LINK);
        case 1: 

            //
            // FireStar IRQ 
            //
            bLink = (UCHAR)((bLink & 0x70) >> 4);
            bData = ReadConfigUchar(bBusPIC, bDevFuncPIC, (UCHAR)(0xB0 + bLink));   
            bData = (bData & 0xf0) | bIRQNumber;
            if (bIRQNumber)
                bData |= 0x10;
            WriteConfigUchar(bBusPIC, bDevFuncPIC, (UCHAR)(0xB0 + bLink), bData);
            
            return (PCIMP_SUCCESS);
            
        case 2:

            //
            // FireStar PIO or Serial IRQ
            //
        case 3:

            //
            // FireBridge INTs
            //
            bOffset = (UCHAR)((bLink >> 5) & 1) + 0xB8;
            bData = ReadConfigUchar(bBusPIC, bDevFuncPIC, bOffset);
            if (bLink & (1<<4)) {
                bData &= 0x0f;
                bData |= (bIRQNumber<<4);
            }
            else {
                bData &= 0xf0;
                bData |= bIRQNumber;
            }
            WriteConfigUchar(bBusPIC, bDevFuncPIC, bOffset, bData);
            
            return (PCIMP_SUCCESS);
            
        default:
            return (PCIMP_INVALID_LINK);
    }   
    
    return (PCIMP_FAILURE);
}

/****************************************************************************
 *
 *  OptiFireStarGetIRQ - Get the IRQ of a OPTI FIRESTAR PCI link
 *
 *  Exported.
 *
 *  ENTRY:  pbIRQNumber is the buffer to fill.
 *
 *      bLink is the Link to be read.
 *
 *  EXIT:   Standard PCIMP return value.
 *
 ***************************************************************************/
PCIMPRET CDECL
OptiFireStarGetIRQ(PUCHAR pbIRQNumber, UCHAR bLink)
{
    UCHAR   bData, bOffset;
    
    switch (bLink & 0x07)
    {
        case 0:
            //
            // Valid link?
            //
            if (bLink == 0)
                return (PCIMP_FAILURE);
            else
                return (PCIMP_INVALID_LINK);
                
        case 1: 
            //
            // FireStar IRQ 
            //
            bLink = (UCHAR)((bLink & 0x70) >> 4);
            bData = ReadConfigUchar(bBusPIC, bDevFuncPIC, (UCHAR)(0xB0 + bLink));   
            *pbIRQNumber = (bData & 0x0f);
            
            return (PCIMP_SUCCESS);
            
        case 2:
            //
            // FireStar PIO or Serial IRQ
            //
            
        case 3:
            //
            // FireBridge INTs
            //
            bOffset = (UCHAR)((bLink >> 5) & 1) + 0xB8;
            bData = ReadConfigUchar(bBusPIC, bDevFuncPIC, bOffset);
            if (bLink & (1<<4)) 
                bData >>= 4;

            *pbIRQNumber = bData & 0x0f;
            
            return (PCIMP_SUCCESS);
            
        default:
            return (PCIMP_INVALID_LINK);
    }   
    
    return (PCIMP_FAILURE);
}

/****************************************************************************
 *
 *  OptiViperSetTrigger - Set the IRQ triggering values for the OptiViper
 *
 *  Exported.
 *
 *  ENTRY:  ulTrigger has bits set for Level triggered IRQs.
 *
 *  EXIT:   Standard PCIMP return value.
 *
 ***************************************************************************/
PCIMPRET CDECL
OptiFireStarSetTrigger(ULONG ulTrigger)
{
    ULONG i;
    UCHAR bData;

    for (i = 0; i < 8; i++) 
    {
        UCHAR bTemp;
        bData = ReadConfigUchar(bBusPIC, bDevFuncPIC, (UCHAR)(0xB0+i)); 
        bTemp = bData & 0x0F;
        if (bTemp && (ulTrigger & (1 << bTemp)))
        {
            bData |= 0x10;          
        }
        else
        {
            bData &= ~0x10;
        }
        WriteConfigUchar(bBusPIC, bDevFuncPIC, (UCHAR)(0xB0+i), bData);
    }
    
    return (PCIMP_SUCCESS);
}

/****************************************************************************
 *
 *  OptiViperGetTrigger - Get the IRQ triggering values for the OptiViper
 *
 *  Exported.
 *
 *  ENTRY:  pulTrigger will have bits set for Level triggered IRQs.
 *
 *  EXIT:   Standard PCIMP return value.
 *
 ***************************************************************************/
PCIMPRET CDECL
OptiFireStarGetTrigger(PULONG pulTrigger)
{
    ULONG i;
    UCHAR bData;
    
    //
    // Assume all are edge.
    //
    *pulTrigger = 0;

    //
    // Check PCIDV1 registers B0-B7.
    //
    for (i = 0; i < 8; i++)
    {
        bData = (UCHAR)(ReadConfigUchar(bBusPIC, bDevFuncPIC, (UCHAR)(0xB0 + i)) & 0x1F);
        if (bData & 0x10)               
            *pulTrigger |= (1 << (bData & 0x0f));       
    }

    //
    // Check PCIDV1 registers B8-B9.
    //
    for (i = 0; i < 2; i++)
    {
        bData = ReadConfigUchar(bBusPIC, bDevFuncPIC, (UCHAR)(0xB8 + i));
        *pulTrigger |= (1 << (bData & 0x0F));
        bData >>= 4;
        *pulTrigger |= (1 << (bData & 0x0F));
    }
    
    return (PCIMP_SUCCESS); 
}

/****************************************************************************
 *
 *  OptiFireStarValidateTable - Validate an IRQ table
 *
 *  Exported.
 *
 *  ENTRY:  piihIRQInfoHeader points to an IRQInfoHeader followed
 *      by an IRQ Routing Table.
 *
 *      ulFlags are PCIMP_VALIDATE flags.
 *
 *  EXIT:   Standard PCIMP return value.
 *
 ***************************************************************************/
PCIMPRET CDECL
OptiFireStarValidateTable(PIRQINFOHEADER piihIRQInfoHeader, ULONG ulFlags)
{
    PIRQINFO    pii=(PIRQINFO)(((PUCHAR) piihIRQInfoHeader)+sizeof(IRQINFOHEADER));
    ULONG       i, j;
    ULONG       cEntries=(piihIRQInfoHeader->TableSize-sizeof(IRQINFOHEADER))/sizeof(IRQINFO);

    PAGED_CODE();

    for (i=0; i<cEntries; i++) {

        for (j=0; j<4; j++) {

            switch (pii->PinInfo[j].Link & 0x07)
            {
                case 0:
                    //
                    // Valid link?
                    //
                    if (pii->PinInfo[j].Link & 0x70)
                        return (PCIMP_FAILURE);
                    break;
                    
                case 1:
                    //
                    // FireStar IRQ 
                    //              
                    break;                  

                case 2:
                    //
                    // FireStar PIO or Serial IRQ
                    //
                    
                case 3:
                    //
                    // FireBridge INTs
                    //
                    if ((pii->PinInfo[j].Link & 0x70) > 0x30)
                        return (PCIMP_FAILURE);
                    break;
                default:
                
                    return (PCIMP_FAILURE);
            }           
        }
        pii++;
    }

    return(i? PCIMP_SUCCESS : PCIMP_FAILURE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\pciirqmp\i386\misc.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    misc.c

Abstract:

    This contains the misc support functions used by the 
    PCI IRQ Miniport library.

Author:

    Santosh Jodh (santoshj) 09-June-1998

Environment:

    kernel mode only

Revision History:

--*/

#include "local.h"

#ifdef ALLOC_PRAGMA

#pragma alloc_text(INIT, NormalizeLinks)
#pragma alloc_text(INIT, GetMinLink)
#pragma alloc_text(INIT, GetMaxLink)

#endif //ALLOC_PRAGMA


NTSTATUS    
EisaGetTrigger (
    OUT PULONG Trigger
    )

/*++

Routine Description:

    This routine gets the EISA Irq trigger mask (1 - Level, 0 - Edge).
    
Parameters:

    Trigger - Trigger mask is returned in this argument.

Return Value:

    PCIIRQMP_STATUS_SUCCESS.

Notes:

--*/
         
{
    UCHAR   LowPart;
    UCHAR   HighPart;

    //
    // Read the edge\level mask for Irq 0-7.
    //
    
    LowPart = READ_PORT_UCHAR((PUCHAR)0x4D0);

    //
    // Allow delay before another I/O.
    //
    
    IO_Delay();

    //
    // Read the edge\level mask for Irq 8-15.
    //
    
    HighPart = READ_PORT_UCHAR((PUCHAR)0x4D1);

    //
    // Combine set the trigger to the mask for Irq 0-15.
    //
    
    *Trigger = (ULONG)((HighPart << 8) + LowPart) & 0xFFFF;
    
    return (PCIMP_SUCCESS);    
}

NTSTATUS
EisaSetTrigger (
    IN ULONG Trigger
    )

/*++

Routine Description:

    This routine sets the EISA Irq trigger mask (1 - Level, 0 - Edge).
    
Parameters:

    Trigger - Trigger mask to be set.

Return Value:

    PCIIRQMP_STATUS_SUCCESS.

Notes:

--*/
     
{
    //
    // Program the EISA edge\level control for Irq 0-7.
    //
    
    WRITE_PORT_UCHAR((PUCHAR)0x4D0, (CHAR)Trigger);

    //
    // Allow delay before another I/O.
    //
    
    IO_Delay();

    //
    // Program the EISA edge\level control for Irq 8-15.
    //
    
    WRITE_PORT_UCHAR((PUCHAR)0x4D1, (CHAR)(Trigger >> 8));

    return (PCIMP_SUCCESS);
}

UCHAR
ReadConfigUchar (
    IN ULONG           BusNumber,
    IN ULONG           DevFunc,
    IN UCHAR           Offset
    )

/*++

Routine Description:

    This routine calls the HAL to read the Pci config space.
    
Parameters:

    BusNumber - Bus number of the Pci device being read.    

    DevFunc - Slot number of the Pci device being read (Dev (7:3), Func(2:0)).

    Offset - Offset in the config space to be read.

Return Value:

    Value read from the specified offset in the config space.

Notes:

--*/
         
{
    UCHAR   Data;
    ULONG   slotNumber;

    slotNumber = (DevFunc >> 3) & 0x1F;
    slotNumber |= ((DevFunc & 0x07) << 5);
    
    //
    // Initialize data to invalid values.
    //
    
    Data = 0xFF;

    //
    // Call the HAL to do the actual reading.
    //
    
    HalGetBusDataByOffset(  PCIConfiguration,
                            BusNumber,
                            slotNumber,
                            &Data,
                            Offset,
                            sizeof(Data));

    //
    // Return data read to the caller.
    //
    
    return(Data);
}

USHORT
ReadConfigUshort (
    IN ULONG           BusNumber,
    IN ULONG           DevFunc,
    IN UCHAR           Offset
    )

/*++

Routine Description:

    This routine calls the HAL to read the Pci config space.
    
Parameters:

    BusNumber - Bus number of the Pci device being read.    

    DevFunc - Slot number of the Pci device being read (Dev (7:3), Func(2:0)).

    Offset - Offset in the config space to be read.

Return Value:

    Value read from the specified offset in the config space.

Notes:

--*/
         
{
    USHORT  Data;
    ULONG   slotNumber;

    slotNumber = (DevFunc >> 3) & 0x1F;
    slotNumber |= ((DevFunc & 0x07) << 5);

    //
    // Initialize data to invalid values.
    //
    
    Data = 0xFFFF;

    //
    // Call the HAL to do the actual reading.
    //
    
    HalGetBusDataByOffset(  PCIConfiguration,
                            BusNumber,
                            slotNumber,
                            &Data,
                            Offset,
                            sizeof(Data));

    //
    // Return data read to the caller.
    //
    
    return(Data);
}

ULONG
ReadConfigUlong (
    IN ULONG           BusNumber,
    IN ULONG           DevFunc,
    IN UCHAR           Offset
    )

/*++

Routine Description:

    This routine calls the HAL to read the Pci config space.
    
Parameters:

    BusNumber - Bus number of the Pci device being read.    

    DevFunc - Slot number of the Pci device being read (Dev (7:3), Func(2:0)).

    Offset - Offset in the config space to be read.

Return Value:

    Value read from the specified offset in the config space.

Notes:

--*/
         
{
    ULONG   Data;
    ULONG   slotNumber;

    slotNumber = (DevFunc >> 3) & 0x1F;
    slotNumber |= ((DevFunc & 0x07) << 5);

    //
    // Initialize data to invalid values.
    //
    
    Data = 0xFFFFFFFF;

    //
    // Call the HAL to do the actual reading.
    //
    
    HalGetBusDataByOffset(  PCIConfiguration,
                            BusNumber,
                            slotNumber,
                            &Data,
                            Offset,
                            sizeof(Data));

    //
    // Return data read to the caller.
    //
    
    return(Data);
}

VOID
WriteConfigUchar (
    IN ULONG           BusNumber,
    IN ULONG           DevFunc,
    IN UCHAR           Offset,
    IN UCHAR           Data
    )

/*++

Routine Description:

    This routine calls the HAL to write to the Pci config space.
    
Parameters:

    BusNumber - Bus number of the Pci device being written to.    

    DevFunc - Slot number of the Pci device being read (Dev (7:3), Func(2:0)).

    Offset - Offset in the config space to be written.

    Data - Value to be written.

Return Value:

    None.

Notes:

--*/
     
{
    ULONG   slotNumber;

    slotNumber = (DevFunc >> 3) & 0x1F;
    slotNumber |= ((DevFunc & 0x07) << 5);

    //
    // Call the HAL to do the actual writing.
    //
    
    HalSetBusDataByOffset(  PCIConfiguration,
                            BusNumber,
                            slotNumber,
                            &Data,
                            Offset,
                            sizeof(Data));
}

VOID
WriteConfigUshort (
    IN ULONG           BusNumber,
    IN ULONG           DevFunc,
    IN UCHAR           Offset,
    IN USHORT          Data
    )

/*++

Routine Description:

    This routine calls the HAL to write to the Pci config space.
    
Parameters:

    BusNumber - Bus number of the Pci device being written to.    

    DevFunc - Slot number of the Pci device being read (Dev (7:3), Func(2:0)).

    Offset - Offset in the config space to be written.

    Data - Value to be written.

Return Value:

    None.

Notes:

--*/
     
{
    ULONG   slotNumber;

    slotNumber = (DevFunc >> 3) & 0x1F;
    slotNumber |= ((DevFunc & 0x07) << 5);

    //
    // Call the HAL to do the actual writing.
    //

    HalSetBusDataByOffset(  PCIConfiguration,
                            BusNumber,
                            slotNumber,
                            &Data,
                            Offset,
                            sizeof(Data));
}

VOID
WriteConfigUlong (
    IN ULONG           BusNumber,
    IN ULONG           DevFunc,
    IN UCHAR           Offset,
    IN ULONG           Data
    )

/*++

Routine Description:

    This routine calls the HAL to write to the Pci config space.
    
Parameters:

    BusNumber - Bus number of the Pci device being written to.    

    DevFunc - Slot number of the Pci device being read (Dev (7:3), Func(2:0)).

    Offset - Offset in the config space to be written.

    Data - Value to be written.

Return Value:

    None.

Notes:

--*/
     
{
    ULONG   slotNumber;

    slotNumber = (DevFunc >> 3) & 0x1F;
    slotNumber |= ((DevFunc & 0x07) << 5);

    //
    // Call the HAL to do the actual writing.
    //
    
    HalSetBusDataByOffset(  PCIConfiguration,
                            BusNumber,
                            slotNumber,
                            &Data,
                            Offset,
                            sizeof(Data));
}

UCHAR
GetMinLink (
    IN PPCI_IRQ_ROUTING_TABLE PciIrqRoutingTable
    )

/*++

Routine Description:

    This routine finds and returns the minimum link value in the 
    given Pci Irq Routing Table.
    
Parameters:

    PciIrqRoutingTable - Pci Irq Routing Table to be processed.    

Return Value:

    Minimum link value in the table.

Notes:

--*/
        
{
    UCHAR       MinLink;
    PPIN_INFO   PinInfo;
    PPIN_INFO   LastPin;
    PSLOT_INFO  SlotInfo;
    PSLOT_INFO  LastSlot;

    PAGED_CODE();

    //
    // Start by setting the maximum link to the maximum possible value.
    //

    MinLink = 0xFF;

    //
    // Process all slots in this table.
    //

    SlotInfo = (PSLOT_INFO)((PUCHAR)PciIrqRoutingTable + sizeof(PCI_IRQ_ROUTING_TABLE));
    LastSlot = (PSLOT_INFO)((PUCHAR)PciIrqRoutingTable + PciIrqRoutingTable->TableSize);    

    while (SlotInfo < LastSlot)
    {
        //
        // Process all pins for this slot.
        //
     
        PinInfo = &SlotInfo->PinInfo[0];
        LastPin = &SlotInfo->PinInfo[NUM_IRQ_PINS];

        while (PinInfo < LastPin)
        {
            //
            // Update the min link found so far if the current link is
            // valid and smaller.
            //
    
            if (    PinInfo->Link &&
                    PinInfo->Link < MinLink)
            {
                MinLink = PinInfo->Link;
            }

            //
            // Next link.
            //
            
            PinInfo++;
        }

        //
        // Next slot.
        //
        
        SlotInfo++;
    }

    //
    // If we failed to find the minimum value, set the minimum to zero.
    //
    
    if (MinLink == 0xFF)
        MinLink = 0;

    //
    // Return the minimum link in the table to the caller.
    //
    
    return (MinLink);
}

UCHAR
GetMaxLink (
    IN PPCI_IRQ_ROUTING_TABLE PciIrqRoutingTable
    )

/*++

Routine Description:

    This routine finds and returns the maximum link value in the 
    given Pci Irq Routing Table.
    
Parameters:

    PciIrqRoutingTable - Pci Irq Routing Table to be processed.

Return Value:

    Maximum link value in the table.

Notes:

--*/
        
{
    UCHAR       MaxLink;
    PPIN_INFO   PinInfo;
    PPIN_INFO   LastPin;
    PSLOT_INFO  SlotInfo;
    PSLOT_INFO  LastSlot;

    PAGED_CODE();

    //
    // Start by setting the maximum link to the smallest possible value.
    //
    
    MaxLink = 0;
    
    //
    // Process all slots in this table.
    //

    SlotInfo = (PSLOT_INFO)((PUCHAR)PciIrqRoutingTable + sizeof(PCI_IRQ_ROUTING_TABLE));
    LastSlot = (PSLOT_INFO)((PUCHAR)PciIrqRoutingTable + PciIrqRoutingTable->TableSize);    

    while (SlotInfo < LastSlot)
    {
        //
        // Process all pins for this slot.
        //
        
        PinInfo = &SlotInfo->PinInfo[0];
        LastPin = &SlotInfo->PinInfo[NUM_IRQ_PINS];

        while (PinInfo < LastPin)
        {
            //
            // Update the max link found so far if the current link is
            // valid and larger.
            //
            
            if (    PinInfo->Link &&
                    PinInfo->Link > MaxLink)
            {
                MaxLink = PinInfo->Link;
            }

            //
            // Next pin.
            //
            
            PinInfo++;
        }

        //
        // Next slot.
        //
        
        SlotInfo++;
    }

    //
    // Return the maximum link in the table to the caller.
    //
    
    return (MaxLink);
}

VOID
NormalizeLinks (
    IN PPCI_IRQ_ROUTING_TABLE  PciIrqRoutingTable,
    IN UCHAR                   Adjustment
    )

/*++

Routine Description:

    This routine normalizes all link values in the Pci Irq Routing Table by
    adding the adjustment to all the links.

Parameters:

    PciIrqRoutingTable - Pci Irq Routing Table to be normalized.

    Adjustment - Amount to be added to each link.

Return Value:

    None.

Notes:

--*/
    
{
    PPIN_INFO   PinInfo;
    PPIN_INFO   LastPin;
    PSLOT_INFO  SlotInfo;
    PSLOT_INFO  LastSlot;

    PAGED_CODE();

    //
    // Process all slots in this table.
    //

    SlotInfo = (PSLOT_INFO)((PUCHAR)PciIrqRoutingTable + sizeof(PCI_IRQ_ROUTING_TABLE));
    LastSlot = (PSLOT_INFO)((PUCHAR)PciIrqRoutingTable + PciIrqRoutingTable->TableSize);

    while (SlotInfo < LastSlot)
    {    
        //
        // Process all pins.
        //
        
        PinInfo = &SlotInfo->PinInfo[0];
        LastPin = &SlotInfo->PinInfo[NUM_IRQ_PINS];

        while (PinInfo < LastPin)
        {        
            //
            // Only normalize valid link values.
            //
            
            if(PinInfo->Link)
            {
               PinInfo->Link += Adjustment; 
            }

            //
            // Next pin.
            //
            
            PinInfo++;
        }

        //
        // Next slot.
        //
        
        SlotInfo++;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\pciirqmp\i386\pciirqmp.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    pciirqmp.c

Abstract:

    This is the PCI IRQ Miniport library.

Author:

    Santosh Jodh (santoshj) 09-June-1998

Environment:

    kernel mode only

Revision History:

--*/

#include "local.h"

#define NUMBER_OF_CHIPSETS  (sizeof(rgChipData) / sizeof(CHIPSET_DATA))

#ifdef ALLOC_DATA_PRAGMA
#pragma data_seg()
#pragma const_seg()
#endif

//
// Table of chipset drivers.
//

const CHIPSET_DATA rgChipData[] = {
    DECLARE_EISA_CHIPSET(Mercury),          // Intel 82374EB\SB (80860482)
    DECLARE_EISA_CHIPSET(Triton),           // Intel 82430FX (8086122E)
    DECLARE_CHIPSET(VLSI),                  // VLSI VL82C596/7
    DECLARE_CHIPSET(OptiViper),             // OPTi Viper-M
    DECLARE_EISA_CHIPSET(SiS5503),          // SIS P54C
    DECLARE_CHIPSET(VLSIEagle),             // VLSI VL82C534
    DECLARE_EISA_CHIPSET(M1523),            // ALi M1523
    DECLARE_CHIPSET(NS87560),               // Nat Semi NS87560
    DECLARE_EISA_CHIPSET(Compaq3),          // Compaq MISC 3
    DECLARE_EISA_CHIPSET(M1533),            // ALi M1533
    DECLARE_CHIPSET(OptiFireStar),          // OPTI FIRESTAR
    DECLARE_EISA_CHIPSET(VT586),            // VIATECH 82C586B
    DECLARE_EISA_CHIPSET(CPQOSB),           // Conpaq OSB
    DECLARE_EISA_CHIPSET(CPQ1000),          // Conpaq 1000
    DECLARE_EISA_CHIPSET(Cx5520),           // Cyrix 5520
    DECLARE_CHIPSET(Toshiba),               // Toshiba
    DECLARE_CHIPSET(NEC),                   // NEC PC9800
    DECLARE_CHIPSET(VESUVIUS)               //
};

//
// Global variables shared by all modules.
//

ULONG           bBusPIC     = -1;
ULONG           bDevFuncPIC    = -1;
CHIPSET_DATA const* rgChipSet = NULL;

#ifdef ALLOC_PRAGMA

#pragma alloc_text(INIT, PciirqmpInit)
#pragma alloc_text(INIT, PciirqmpExit)
#pragma alloc_text(INIT, PciirqmpValidateTable)

#endif //ALLOC_PRAGMA

NTSTATUS
PciirqmpInit (
    ULONG   Instance,
    ULONG   RouterBus,
    ULONG   RouterDevFunc
    )

/*++

Routine Description:

    This routine initializes calls the individual chipset handler
    to validate the Pci Irq Routing Table.

Parameters:

    PciIrqRoutingTable - Pci Irq Routing Table.

    Flags - Flags specifying source of the Pci Irq Routing Table.

Return Value:

    Standard Pci Irq Miniport return value.

Notes:

--*/

{
    PAGED_CODE();
    //
    // Check to make sure that we are not already initialized.
    //

    if (rgChipSet != NULL)
    {
        PCIIRQMPPRINT(("IRQ miniport already initialized!"));
        return (PCIIRQMP_STATUS_ALREADY_INITIALIZED);
    }

    //
    // Check for invalid instance.
    //

    if (Instance >= NUMBER_OF_CHIPSETS)
    {
        PCIIRQMPPRINT(("Invalid IRQ miniport instance %08X", Instance));
        return (PCIIRQMP_STATUS_INVALID_INSTANCE);
    }

    //
    // Save our global data.
    //

    rgChipSet = &rgChipData[Instance];
    bBusPIC = RouterBus;
    bDevFuncPIC = RouterDevFunc;

    return (PCIMP_SUCCESS);
}

NTSTATUS
PciirqmpExit (
    VOID
    )

/*++

Routine Description:

    This routine cleans up after the Pci Irq Routing miniport library.

Parameters:

    None.

Return Value:

    Standard Pci Irq Miniport return value.

Notes:

--*/

{
    PAGED_CODE();
    //
    // Were we ever initialized?
    //

    if (rgChipSet == NULL)
    {
        PCIIRQMPPRINT(("Cannot exit without having been initialized!"));
        return (PCIIRQMP_STATUS_NOT_INITIALIZED);
    }

    //
    // Clean up.
    //

    rgChipSet = NULL;
    bBusPIC = -1;
    bDevFuncPIC = -1;

    return (PCIMP_SUCCESS);
}

NTSTATUS
PciirqmpValidateTable (
    IN PPCI_IRQ_ROUTING_TABLE  PciIrqRoutingTable,
    IN ULONG                   Flags
    )

/*++

Routine Description:

    This routine normalizes calls the individual chipset handler
    to validate the Pci Irq Routing Table.

Parameters:

    PciIrqRoutingTable - Pci Irq Routing Table.

    Flags - Flags specifying source of the Pci Irq Routing Table.

Return Value:

    Standard Pci Irq Miniport return value.

Notes:

--*/

{
    PAGED_CODE();
    //
    // Were we ever initialized?
    //

    if (rgChipSet == NULL)
    {
        PCIIRQMPPRINT(("Not initialized yet!"));
        return (PCIIRQMP_STATUS_NOT_INITIALIZED);
    }

    //
    // Call the chipset handler.
    //

    return (rgChipSet->ValidateTable(PciIrqRoutingTable, Flags));
}

NTSTATUS
PciirqmpGetIrq (
    OUT PUCHAR  Irq,
    IN  UCHAR   Link
    )

/*++

Routine Description:

    This routine calls the individual chipset handler
    to set the link to the specified Irq.

Parameters:

    Irq - Variable that receives the Irq.

    Link - Link to be read.

Return Value:

    Standard Pci Irq Miniport return value.

Notes:

--*/

{
    //
    // Were we ever initialized?
    //

    if (rgChipSet == NULL)
    {
        PCIIRQMPPRINT(("Not initialized yet!"));
        return (PCIIRQMP_STATUS_NOT_INITIALIZED);
    }

    //
    // Call the chipset handler.
    //

    return (rgChipSet->GetIrq(Irq, Link));
}

NTSTATUS
PciirqmpSetIrq (
    IN UCHAR   Irq,
    IN UCHAR   Link
    )

/*++

Routine Description:

    This routine calls the individual chipset handler
    to set the link to the specified Irq.

Parameters:

    Irq - Irq to be set.

    Link - Link to be programmed.

Return Value:

    Standard Pci Irq Miniport return value.

Notes:

--*/

{
    //
    // Were we ever initialized?
    //

    if (rgChipSet == NULL)
    {
        PCIIRQMPPRINT(("Not initialized yet!"));
        return (PCIIRQMP_STATUS_NOT_INITIALIZED);
    }

    //
    // Call the chipset handler.
    //

    return (rgChipSet->SetIrq(Irq, Link));
}

NTSTATUS
PciirqmpGetTrigger (
    OUT PULONG  Trigger
    )

/*++

Routine Description:

    This routine calls the individual chipset handler
    to get the interrupt edge\level mask.

Parameters:

    Trigger - Variable that receives edge\level mask.

Return Value:

    Standard Pci Irq Miniport return value.

Notes:

--*/

{
    //
    // Were we ever initialized?
    //

    if (rgChipSet == NULL)
    {
        PCIIRQMPPRINT(("Not initialized yet!"));
        return (PCIIRQMP_STATUS_NOT_INITIALIZED);
    }

    //
    // Call the chipset handler.
    //

    return (rgChipSet->GetTrigger(Trigger));
}

NTSTATUS
PciirqmpSetTrigger (
    IN ULONG   Trigger
    )

/*++

Routine Description:

    This routine calls the individual chipset handler
    to set the interrupt edge\level mask.

Parameters:

    Trigger - Edge\level mask to be set.

Return Value:

    Standard Pci Irq Miniport return value.

Notes:

--*/

{
    //
    // Were we ever initialized?
    //

    if (rgChipSet == NULL)
    {
        PCIIRQMPPRINT(("Not initialized yet!"));
        return (PCIIRQMP_STATUS_NOT_INITIALIZED);
    }

    //
    // Call the chipset handler and return the result.
    //

    return (rgChipSet->SetTrigger(Trigger));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\pciirqmp\i386\sis5503.c ===
/*
 *
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *
 *  SIS5503.C - SiS5503 PCI System I/O chipset routines
 *
 *  Notes:
 *  Algorithms from SiS Pentium/P54C PCI/ISA Chipset databook.
 *
 */

#include "local.h"

#ifdef ALLOC_PRAGMA

#pragma alloc_text(INIT, SiS5503ValidateTable)

#endif //ALLOC_PRAGMA

/****************************************************************************
 *
 *  SiS5503SetIRQ - Set an SiS PCI link to a specific IRQ
 *
 *  Exported.
 *
 *  ENTRY:  bIRQNumber is the new IRQ to be used.
 *
 *      bLink is the Link to be set.
 *
 *  EXIT:   Standard PCIMP return value.
 *
 ***************************************************************************/
PCIMPRET CDECL
SiS5503SetIRQ(UCHAR bIRQNumber, UCHAR bLink)
{
    UCHAR bRegValue;
    
    //
    // Validate link number.
    //
    if (bLink < 0x40) {

        return(PCIMP_INVALID_LINK);
    }

    //
    // Use 0x80 to disable.
    //
    if (!bIRQNumber)
        bIRQNumber=0x80;

    //
    // Preserve other bits.
    //  
    bRegValue= (ReadConfigUchar(bBusPIC, bDevFuncPIC, bLink)&(~0x8F))|(bIRQNumber&0x0F);
    
    //
    // Set the SiS IRQ register.
    //
    WriteConfigUchar(bBusPIC, bDevFuncPIC, bLink, bRegValue);

    return(PCIMP_SUCCESS);
}

/****************************************************************************
 *
 *  SiS5503GetIRQ - Get the IRQ of an SiS5503 PCI link
 *
 *  Exported.
 *
 *  ENTRY:  pbIRQNumber is the buffer to fill.
 *
 *      bLink is the Link to be read.
 *
 *  EXIT:   Standard PCIMP return value.
 *
 ***************************************************************************/
PCIMPRET CDECL
SiS5503GetIRQ(PUCHAR pbIRQNumber, UCHAR bLink)
{
    //
    // Validate link number.
    //
    if (bLink < 0x40) {

        return(PCIMP_INVALID_LINK);
    }

    //
    // Store the IRQ value.
    //
    *pbIRQNumber=(ReadConfigUchar(bBusPIC, bDevFuncPIC, bLink)&0x8F);

    //
    // Return 0 if disabled.
    //
    if (*pbIRQNumber & 0x80)
        *pbIRQNumber=0;

    return(PCIMP_SUCCESS);
}

/****************************************************************************
 *
 *  Sis5503ValidateTable - Validate an IRQ table
 *
 *  Exported.
 *
 *  ENTRY:  piihIRQInfoHeader points to an IRQInfoHeader followed
 *      by an IRQ Routing Table.
 *
 *      ulFlags are PCIMP_VALIDATE flags.
 *
 *  EXIT:   Standard PCIMP return value.
 *
 ***************************************************************************/
PCIMPRET CDECL
SiS5503ValidateTable(PIRQINFOHEADER piihIRQInfoHeader, ULONG ulFlags)
{
    PAGED_CODE();

    if ((ulFlags & PCIMP_VALIDATE_SOURCE_BITS)==PCIMP_VALIDATE_SOURCE_PCIBIOS) {

        //
        // If all links are above 40, we they are config space.
        //
        if (GetMinLink(piihIRQInfoHeader)>=0x40)
            return(PCIMP_SUCCESS);

        //
        // If there are links above 4, we are clueless.
        //
        if (GetMaxLink(piihIRQInfoHeader)>0x04)
            return(PCIMP_FAILURE);

        //
        // Assume 1,2,3,4 are the 41,42,43,44 links.
        //
        NormalizeLinks(piihIRQInfoHeader, 0x40);
        
    } else {

        //
        // Validate that all config space addresses are above 40.
        //
        if (GetMinLink(piihIRQInfoHeader)<0x40)
            return(PCIMP_FAILURE);
    }

    return(PCIMP_SUCCESS);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\pciirqmp\i386\optivip.c ===
/*
 *
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *
 *  OPTIVIP.C - OPTi Viper-M PCI chipset routines.
 *
 *  Notes:
 *  Algorithms from OPTi Viper-M 82C556M/82C557M/82C558M doc,
 *  82C558M spec.
 *
 */

#include "local.h"

#ifdef ALLOC_DATA_PRAGMA
#pragma data_seg()
#pragma const_seg()
#endif

//                  IRQ =   0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15
const UCHAR rgbIRQToBig[16]   = { 0, 0, 0, 0, 0, 1, 0, 0, 0, 2, 3, 4, 5, 0, 6, 7 };
const UCHAR rgbIRQToSmall[16] = { 0, 0, 0, 1, 2, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0 };

const UCHAR rgbBigToIRQ[8]   = { 0, 5, 9, 10, 11, 12, 14, 15 };
const UCHAR rgbSmallToIRQ[8] = { 0, 3, 4, 7 };

#ifdef ALLOC_PRAGMA

#pragma alloc_text(INIT, OptiViperValidateTable)

#endif //ALLOC_PRAGMA

/****************************************************************************
 *
 *  OptiViperSetIRQ - Set a OptiViper PCI link to a specific IRQ
 *
 *  Exported.
 *
 *  ENTRY:  bIRQNumber is the new IRQ to be used.
 *
 *      bLink is the Link to be set.
 *
 *  EXIT:   Standard PCIMP return value.
 *
 ***************************************************************************/
PCIMPRET CDECL
OptiViperSetIRQ(UCHAR bIRQNumber, UCHAR bLink)
{
    ULONG   ulIRQRegister;

    //
    // If not an OPTi IRQ, bail.
    //
    if (bIRQNumber &&   (!rgbIRQToBig[bIRQNumber] &&
                 !rgbIRQToSmall[bIRQNumber]))
    {
        return(PCIMP_INVALID_IRQ);
    }

    //
    // Make link number 0 based, and validate.
    //
    bLink--;
    if (bLink > 3) {

        return(PCIMP_INVALID_LINK);
    }

    //
    // Read in the big IRQ Register,
    // clear the old IRQ index for the link,
    // set the new IRQ index,
    // and write it back.
    //
    ulIRQRegister=ReadConfigUlong(bBusPIC, bDevFuncPIC, 0x40);
    ulIRQRegister &= ~(0x7 << (3 * bLink));
    ulIRQRegister |= rgbIRQToBig[bIRQNumber] << (3 * bLink);
    WriteConfigUlong(bBusPIC, bDevFuncPIC, 0x40, ulIRQRegister);

    //
    // Read in the small IRQ register,
    // clear the old IRQ index for the link,
    // set the new IRQ index,
    // and write it back.
    //
    ulIRQRegister=ReadConfigUlong(bBusPIC, bDevFuncPIC, 0x50);
    ulIRQRegister &= ~(0x3 << (2 * bLink));
    ulIRQRegister |= rgbIRQToSmall[bIRQNumber] << (2 * bLink);
    WriteConfigUlong(bBusPIC, bDevFuncPIC, 0x50, ulIRQRegister);

    return(PCIMP_SUCCESS);
}

/****************************************************************************
 *
 *  OptiViperGetIRQ - Get the IRQ of a OptiViper PCI link
 *
 *  Exported.
 *
 *  ENTRY:  pbIRQNumber is the buffer to fill.
 *
 *      bLink is the Link to be read.
 *
 *  EXIT:   Standard PCIMP return value.
 *
 ***************************************************************************/
PCIMPRET CDECL
OptiViperGetIRQ(PUCHAR pbIRQNumber, UCHAR bLink)
{
    ULONG   ulIRQRegister;
    ULONG   ulIndex;

    //
    // Make link number 0 based, and validate.
    //
    bLink--;
    if (bLink > 3) {

        return(PCIMP_INVALID_LINK);
    }

    //
    // Read in the big IRQ Register.
    //
    ulIRQRegister=ReadConfigUlong(bBusPIC, bDevFuncPIC, 0x40);

    //
    // If we have a big IRQ, we're done.
    //
    ulIndex = (ulIRQRegister >> (bLink * 3)) & 0x7;
    if ((*pbIRQNumber = rgbBigToIRQ[ulIndex]) != 0)
    {
        return(PCIMP_SUCCESS);
    }

    //
    // Read in the small IRQ register.
    //
    ulIRQRegister=ReadConfigUlong(bBusPIC, bDevFuncPIC, 0x50);

    //
    // Set the buffer to the small IRQ's value.
    //
    ulIndex = (ulIRQRegister >> (bLink * 2)) & 0x3;
    *pbIRQNumber = rgbSmallToIRQ[ulIndex];

    return(PCIMP_SUCCESS);
}

/****************************************************************************
 *
 *  OptiViperSetTrigger - Set the IRQ triggering values for the OptiViper
 *
 *  Exported.
 *
 *  ENTRY:  ulTrigger has bits set for Level triggered IRQs.
 *
 *  EXIT:   Standard PCIMP return value.
 *
 ***************************************************************************/
PCIMPRET CDECL
OptiViperSetTrigger(ULONG ulTrigger)
{
    ULONG   ulBigIRQRegister;
    ULONG   ulSmallIRQRegister;
    ULONG   i;

    //
    // Read in the big & small IRQ registers,
    // setting all IRQs to edge.
    //
    ulBigIRQRegister   = ReadConfigUlong(bBusPIC, bDevFuncPIC, 0x40) & ~0x00FE0000;
    ulSmallIRQRegister = ReadConfigUlong(bBusPIC, bDevFuncPIC, 0x50) & ~0x00000700;

    //
    // For each IRQ...
    //
    for (i=0; i<16; i++)
    {
        //
        // If we want this to be level triggered...
        //
        if (ulTrigger & (1 << i))
        {

            if (rgbIRQToBig[i])
            {
                //
                // If it's a big IRQ, set the
                // corresponding bit in the
                // big register.
                //
                ulBigIRQRegister |= 1 << (16 + rgbIRQToBig[i]);
            }
            else if (rgbIRQToSmall[i])
            {
                //
                // If it's a small IRQ, set the
                // corresponding bit in the
                // small register.
                //
                ulSmallIRQRegister |= 1 << (11 - rgbIRQToSmall[i]);
            }
            else
            {
                //
                // Trying to level set an unsupported IRQ.
                //
                return(PCIMP_INVALID_IRQ);
            }
        }
    }

    //
    // Write the new IRQ register values.
    //
    WriteConfigUlong(bBusPIC, bDevFuncPIC, 0x40, ulBigIRQRegister);
    WriteConfigUlong(bBusPIC, bDevFuncPIC, 0x50, ulSmallIRQRegister);

    return(PCIMP_SUCCESS);
}

/****************************************************************************
 *
 *  OptiViperGetTrigger - Get the IRQ triggering values for the OptiViper
 *
 *  Exported.
 *
 *  ENTRY:  pulTrigger will have bits set for Level triggered IRQs.
 *
 *  EXIT:   Standard PCIMP return value.
 *
 ***************************************************************************/
PCIMPRET CDECL
OptiViperGetTrigger(PULONG pulTrigger)
{
    ULONG   ulBigIRQRegister;
    ULONG   ulSmallIRQRegister;
    ULONG   i;

    //
    // Assume all edge.
    //
    *pulTrigger = 0;

    //
    // Read in the big&small IRQ registers.
    //
    ulBigIRQRegister   = ReadConfigUlong(bBusPIC, bDevFuncPIC, 0x40);
    ulSmallIRQRegister = ReadConfigUlong(bBusPIC, bDevFuncPIC, 0x50);

    //
    // For each IRQ...
    //
    for (i=0; i<16; i++)
    {
        //
        // If it's a big IRQ and it's level triggered,
        // or if it's a small IRQ and it's level triggered,
        // set the corresponding bit in pulTrigger.
        //
        if (    ((rgbIRQToBig[i]) &&
             (ulBigIRQRegister & (1 << (16 + rgbIRQToBig[i])))) ||
            ((rgbIRQToSmall[i]) &&
             (ulSmallIRQRegister & (1 << (11 - rgbIRQToSmall[i])))))
        {
            *pulTrigger |= 1 << i;
        }
    }

    return(PCIMP_SUCCESS);
}

/****************************************************************************
 *
 *  OptiViperValidateTable - Validate an IRQ table
 *
 *  Exported.
 *
 *  ENTRY:  piihIRQInfoHeader points to an IRQInfoHeader followed
 *      by an IRQ Routing Table.
 *
 *      ulFlags are PCIMP_VALIDATE flags.
 *
 *  EXIT:   Standard PCIMP return value.
 *
 ***************************************************************************/
PCIMPRET CDECL
OptiViperValidateTable(PIRQINFOHEADER piihIRQInfoHeader, ULONG ulFlags)
{
    PAGED_CODE();

    if (GetMaxLink(piihIRQInfoHeader)>0x04) {

        return(PCIMP_FAILURE);
    }

    return(PCIMP_SUCCESS);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\pciirqmp\i386\toshiba.c ===
/*
 *
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *
 *  TOSHIBA.C - Toshiba Tecra IRQ routing spec
 *
 *  Notes:
 *  Algorithms from TECS-1010-1001
 *
 */

#include "local.h"

BOOLEAN CDECL
CallSMI(
    IN ULONG rAX, 
    IN ULONG rBX, 
    IN ULONG rCX, 
    IN PULONG prCX
    );

#ifdef ALLOC_DATA_PRAGMA
#pragma data_seg()
#pragma const_seg()
#endif

GLOBAL_DATA ULONG   SMIPort=0xB2;

#ifdef ALLOC_PRAGMA

#pragma alloc_text(INIT, ToshibaValidateTable)

#endif //ALLOC_PRAGMA


/****************************************************************************
 *
 *  CallSMI - Get into SMI
 *
 *  Not exported.
 *
 *  ENTRY:  rAX is the value for AX as input.
 *
 *      rBX is the value for BX as input.
 *
 *      rCX is the value for CX as input.
 *
 *      prCX is filled with the returned CX, if not NULL.
 *
 *  EXIT:   TRUE iff no error.
 *
 ***************************************************************************/
BOOLEAN CDECL
CallSMI(ULONG rAX, ULONG rBX, ULONG rCX, PULONG prCX)
{
    ULONG   ulAX, ulCX;

    _asm    mov eax, rAX
    _asm    mov ebx, rBX
    _asm    mov ecx, rCX
    _asm    mov edx, SMIPort
    _asm    in  al, dx
    _asm    movzx   ecx, cx
    _asm    mov ulCX, ecx
    _asm    movzx   eax, ah
    _asm    mov ulAX, eax

    if (prCX)
        *prCX=ulCX;

    return(ulAX==0);
}

/****************************************************************************
 *
 *  ToshibaSetIRQ - Set a Toshiba PCI link to a specific IRQ
 *
 *  Exported.
 *
 *  ENTRY:  bIRQNumber is the new IRQ to be used.
 *
 *      bLink is the Link to be set.
 *
 *  EXIT:   Standard PCIMP return value.
 *
 ***************************************************************************/
PCIMPRET CDECL
ToshibaSetIRQ(UCHAR bIRQNumber, UCHAR bLink)
{
    //
    // Use 0xFF to disable.
    //
    if (!bIRQNumber)
        bIRQNumber=0xFF;

    //
    // Ask SMI to set the link.
    //
    return(CallSMI( 0xFF44,
            0x0701,
            (bLink<<8)+bIRQNumber,
            NULL) ?
                PCIMP_SUCCESS :
                PCIMP_FAILURE);
}

/****************************************************************************
 *
 *  ToshibaGetIRQ - Get the IRQ of a Toshiba PCI link
 *
 *  Exported.
 *
 *  ENTRY:  pbIRQNumber is the buffer to fill.
 *
 *      bLink is the Link to be read.
 *
 *  EXIT:   Standard PCIMP return value.
 *
 ***************************************************************************/
PCIMPRET CDECL
ToshibaGetIRQ(PUCHAR pbIRQNumber, UCHAR bLink)
{
    ULONG   ulCX;

    //
    // Ask SMI to get the link.
    //
    if (!CallSMI(   0xFE44,
            0x0701,
            bLink<<8,
            &ulCX))
        return(PCIMP_FAILURE);

    //
    // Get the byte only.
    //
    ulCX&=0xFF;

    //
    // Use 0xFF to disable.
    //
    if (ulCX==0xFF)
        ulCX=0;

    //
    // Store the IRQ value.
    //
    *pbIRQNumber=(UCHAR)ulCX;

    return(PCIMP_SUCCESS);
}

/****************************************************************************
 *
 *  ToshibaSetTrigger - Set the IRQ triggering values for the Toshiba
 *
 *  Exported.
 *
 *  ENTRY:  ulTrigger has bits set for Level triggered IRQs.
 *
 *  EXIT:   Standard PCIMP return value.
 *
 ***************************************************************************/
PCIMPRET CDECL
ToshibaSetTrigger(ULONG ulTrigger)
{
    //
    // Ask SMI to set the triggering mechanism.
    //
    return(CallSMI( 0xFF44,
            0x0702,
            ulTrigger,
            NULL) ?
                PCIMP_SUCCESS :
                PCIMP_FAILURE);
}

/****************************************************************************
 *
 *  ToshibaGetTrigger - Get the IRQ triggering values for the Toshiba
 *
 *  Exported.
 *
 *  ENTRY:  pulTrigger will have bits set for Level triggered IRQs.
 *
 *  EXIT:   Standard PCIMP return value.
 *
 ***************************************************************************/
PCIMPRET CDECL
ToshibaGetTrigger(PULONG pulTrigger)
{
    //
    // Assume all edge.
    //
    *pulTrigger = 0;

    //
    // Ask SMI to get the triggering mechanism.
    //
    return(CallSMI( 0xFE44,
            0x0702,
            0,
            pulTrigger) ?
                PCIMP_SUCCESS :
                PCIMP_FAILURE);
}

/****************************************************************************
 *
 *  ToshibaValidateTable - Validate an IRQ table
 *
 *  Exported.
 *
 *  ENTRY:  piihIRQInfoHeader points to an IRQInfoHeader followed
 *      by an IRQ Routing Table.
 *
 *      ulFlags are PCIMP_VALIDATE flags.
 *
 *  EXIT:   Standard PCIMP return value.
 *
 ***************************************************************************/
PCIMPRET CDECL
ToshibaValidateTable(PIRQINFOHEADER piihIRQInfoHeader, ULONG ulFlags)
{
    PAGED_CODE();

    SMIPort=*(((PUSHORT)&(piihIRQInfoHeader->MiniportData))+1);

    return(((ulFlags & PCIMP_VALIDATE_SOURCE_BITS)==PCIMP_VALIDATE_SOURCE_PCIBIOS) ?
        PCIMP_FAILURE : PCIMP_SUCCESS);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\pciirqmp\i386\triton.c ===
/*
 *
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *
 *  TRITON.C - Intel Triton PCI chipset routines.
 *
 *  Notes:
 *	Algorithms from Intel Triton 82430FX PCISET Data Sheet
 *	(Intel Secret) 82371FB PCI ISA IDE Xcelerator spec.
 *
 */

#include "local.h"

#ifdef ALLOC_PRAGMA

#pragma alloc_text(INIT, TritonValidateTable)

#endif //ALLOC_PRAGMA

/****************************************************************************
 *
 *	TritonSetIRQ - Set a Triton PCI link to a specific IRQ
 *
 *	Exported.
 *
 *	ENTRY:	bIRQNumber is the new IRQ to be used.
 *
 *		bLink is the Link to be set.
 *
 *	EXIT:	Standard PCIMP return value.
 *
 ***************************************************************************/
PCIMPRET CDECL
TritonSetIRQ(UCHAR bIRQNumber, UCHAR bLink)
{
	//
	// Validate link number.
	//
	if (bLink < 0x40) {

		return(PCIMP_INVALID_LINK);
	}

	//
	// Use 0x80 to disable.
	//
	if (!bIRQNumber)
		bIRQNumber=0x80;

	//
	// Set the Triton IRQ register.
	//
	WriteConfigUchar(bBusPIC, bDevFuncPIC, bLink, bIRQNumber);

	return(PCIMP_SUCCESS);
}

/****************************************************************************
 *
 *	TritonGetIRQ - Get the IRQ of a Triton PCI link
 *
 *	Exported.
 *
 *	ENTRY:	pbIRQNumber is the buffer to fill.
 *
 *		bLink is the Link to be read.
 *
 *	EXIT:	Standard PCIMP return value.
 *
 ***************************************************************************/
PCIMPRET CDECL
TritonGetIRQ(PUCHAR pbIRQNumber, UCHAR bLink)
{
	//
	// Validate link number.
	//
	if (bLink < 0x40) {

		return(PCIMP_INVALID_LINK);
	}

	//
	// Store the IRQ value.
	//
	*pbIRQNumber=ReadConfigUchar(bBusPIC, bDevFuncPIC, bLink);

	//
	// Return 0 if disabled.
	//
	if (*pbIRQNumber & 0x80)
		*pbIRQNumber=0;

	return(PCIMP_SUCCESS);
}

/****************************************************************************
 *
 *	TritonValidateTable - Validate an IRQ table
 *
 *	Exported.
 *
 *	ENTRY:	piihIRQInfoHeader points to an IRQInfoHeader followed
 *		by an IRQ Routing Table.
 *
 *		ulFlags are PCIMP_VALIDATE flags.
 *
 *	EXIT:	Standard PCIMP return value.
 *
 ***************************************************************************/
PCIMPRET CDECL
TritonValidateTable(PIRQINFOHEADER piihIRQInfoHeader, ULONG ulFlags)
{
    PAGED_CODE();

	if ((ulFlags & PCIMP_VALIDATE_SOURCE_BITS)==PCIMP_VALIDATE_SOURCE_PCIBIOS) {

		//
		// If all links are above 40, we they are config space.
		//
		if (GetMinLink(piihIRQInfoHeader)>=0x40)
			return(PCIMP_SUCCESS);

		//
		// If there are links above 4, we are clueless.
		//
		if (GetMaxLink(piihIRQInfoHeader)>0x04)
			return(PCIMP_FAILURE);

		//
		// Assume 1,2,3,4 are the 60,61,62,63 links.
		//
		NormalizeLinks(piihIRQInfoHeader, 0x5F);
		
	} else {

		//
		// Validate that all config space addresses are above 40.
		//
		if (GetMinLink(piihIRQInfoHeader)<0x40)
			return(PCIMP_FAILURE);
	}

	return(PCIMP_SUCCESS);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\pciirqmp\i386\vlsi.c ===
/*
 *
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *
 *  VLSI.C - VLSI Wildcat PCI chipset routines.
 *
 *  Notes:
 *  Algorithms from VLSI VL82C596/7 spec.
 *
 */

#include "local.h"

#define NUM_VLSI_IRQ    (sizeof(rgbIndexToIRQ)/sizeof(rgbIndexToIRQ[0]))
#define INDEX_UNUSED    ((ULONG)-1)

#ifdef ALLOC_DATA_PRAGMA
#pragma data_seg()
#pragma const_seg()
#endif

const UCHAR rgbIndexToIRQ[]  = { 3, 5, 9, 10, 11, 12, 14, 15 };

#ifdef ALLOC_PRAGMA

#pragma alloc_text(INIT, VLSIValidateTable)

#endif //ALLOC_PRAGMA


/****************************************************************************
 *
 *  VLSISetIRQ - Set a VLSI PCI link to a specific IRQ
 *
 *  Exported.
 *
 *  ENTRY:  bIRQNumber is the new IRQ to be used.
 *
 *      bLink is the Link to be set.
 *
 *  EXIT:   Standard PCIMP return value.
 *
 ***************************************************************************/
PCIMPRET CDECL
VLSISetIRQ(UCHAR bIRQNumber, UCHAR bLink)
{
    ULONG   ulNewIRQIndex;
    ULONG   rgbIRQSteering[NUM_IRQ_PINS];
    ULONG   ulMask;
    ULONG   ulUnusedIndex;
    ULONG   ulVLSIRegister;
    ULONG   ulIRQIndex;
    ULONG   i;

    //
    // Make link number 0 based, and validate.
    //
    bLink--;
    if (bLink > 3) {

        return(PCIMP_INVALID_LINK);
    }

    //
    // Find the VLSI index of the new IRQ.
    //
    if (bIRQNumber) {

        //
        // Look through the list of valid indicies.
        //
        for (ulNewIRQIndex=0; ulNewIRQIndex<NUM_VLSI_IRQ; ulNewIRQIndex++)
        {
            if (rgbIndexToIRQ[ulNewIRQIndex] == bIRQNumber)
                break;
        }

        //
        // If there is no VLSI equivalent, bail.
        //
        if (ulNewIRQIndex==NUM_VLSI_IRQ) {

            return(PCIMP_INVALID_IRQ);
        }

    } else {

        //
        // Blowing away this interrupt.
        //
        ulNewIRQIndex = INDEX_UNUSED;
    }

    //
    // Read in the VLSI Interrupt Steering Register.
    //
    ulVLSIRegister=ReadConfigUlong(bBusPIC, bDevFuncPIC, 0x74);

    //
    // Compute the complete IRQ mapping.
    //
    for (i=0, ulMask=0x07; i<NUM_IRQ_PINS; i++, ulMask<<=4)
    {
        ulIRQIndex = (ulVLSIRegister & ulMask) >> (i * 4);

        if ((ulVLSIRegister & (1 << (ulIRQIndex + 16))) != 0)
        {
            rgbIRQSteering[i] = ulIRQIndex;
        }
        else
        {
            rgbIRQSteering[i] = INDEX_UNUSED;
        }
    }

    //
    // Update the IRQ Mapping with the new IRQ.
    //
    rgbIRQSteering[bLink] = ulNewIRQIndex;

    //
    // Find an unused IRQ index.
    //
    for (ulUnusedIndex=0; ulUnusedIndex<NUM_VLSI_IRQ; ulUnusedIndex++)
    {
        for (i=0; i<NUM_IRQ_PINS; i++)
        {
            if (rgbIRQSteering[i] == ulUnusedIndex)
                break;
        }
        if (i == NUM_IRQ_PINS)
            break;
    }

    //
    // Compute the new VLSI Interrupt Steering Register.
    //
    ulVLSIRegister = 0x00000000;
    for (i=0; i<NUM_IRQ_PINS; i++)
    {
        if (rgbIRQSteering[i] == INDEX_UNUSED)
        {
            ulVLSIRegister |= ulUnusedIndex << (4*i);
        }
        else
        {
            ulVLSIRegister |= rgbIRQSteering[i] << (4*i);
            ulVLSIRegister |= 1 << (rgbIRQSteering[i] + 16);
        }
    }

    //
    // Write out the new VLSI Interrupt Steering Register.
    //
    WriteConfigUlong(bBusPIC, bDevFuncPIC, 0x74, ulVLSIRegister);

    return(PCIMP_SUCCESS);
}

/****************************************************************************
 *
 *  VLSIGetIRQ - Get the IRQ of a VLSI PCI link
 *
 *  Exported.
 *
 *  ENTRY:  pbIRQNumber is the buffer to fill.
 *
 *      bLink is the Link to be read.
 *
 *  EXIT:   Standard PCIMP return value.
 *
 ***************************************************************************/
PCIMPRET CDECL
VLSIGetIRQ(PUCHAR pbIRQNumber, UCHAR bLink)
{
    ULONG   ulVLSIRegister;
    ULONG   ulIndex;
    UCHAR   bIRQ;

    //
    // Make link number 0 based, and validate.
    //
    bLink--;
    if (bLink > 3) {

        return(PCIMP_INVALID_LINK);
    }

    //
    // Read in the VLSI Interrupt Steering Register.
    //
    ulVLSIRegister=ReadConfigUchar(bBusPIC, bDevFuncPIC, 0x74);

    //
    // Find the link's IRQ value.
    //
    ulIndex = (ulVLSIRegister >> (bLink*4)) & 0x7;
    bIRQ = rgbIndexToIRQ[ulIndex];

    //
    // Make sure the IRQ is marked as in use.
    //
    if ((ulVLSIRegister & (1 << (ulIndex + 16))) == 0)
    {
        bIRQ = 0;
    }

    //
    // Set the return buffer.
    //
    *pbIRQNumber = bIRQ;

    return(PCIMP_SUCCESS);
}

/****************************************************************************
 *
 *  VLSISetTrigger - Set the IRQ triggering values for the VLSI.
 *
 *  Exported.
 *
 *  ENTRY:  ulTrigger has bits set for Level triggered IRQs.
 *
 *  EXIT:   Standard PCIMP return value.
 *
 ***************************************************************************/
PCIMPRET CDECL
VLSISetTrigger(ULONG ulTrigger)
{
    ULONG   ulAssertionRegister;
    ULONG   ulPMAssertionRegister;
    ULONG   i;

    //
    // Read in the Interrupt Assertion Level register.
    //
    ulAssertionRegister = ReadConfigUlong(bBusPIC, bDevFuncPIC, 0x5C);

    //
    // Clear off the old edge/level settings.
    //
    ulAssertionRegister &= ~0xff;

    //
    // For each VLSI interrupt...
    //
    for (i=0; i<NUM_VLSI_IRQ; i++)
    {
        //
        // If the corresponding bit is set to level...
        //

        if (ulTrigger & (1 << rgbIndexToIRQ[i]))
        {
            //
            // Set the corresponding bit in the
            // Assertion Register.
            //
            ulAssertionRegister |= 1 << i;

            //
            // And clear the bit from ulTrigger.
            //
            ulTrigger &= ~(1 << rgbIndexToIRQ[i]);
        }
    }

    //
    // If the caller wanted some non-VLSI IRQs level, bail.
    //
    if (ulTrigger)
    {
        return(PCIMP_INVALID_IRQ);
    }

    //
    // Set the Assertion Register.
    //
    WriteConfigUlong(bBusPIC, bDevFuncPIC, 0x5C, ulAssertionRegister);

    //
    // Read in the Power Mgmt edge/level setting.
    //
    ulPMAssertionRegister = ReadConfigUlong(bBusPIC, bDevFuncPIC, 0x78);

    //
    // Clear off the old edge/level settings.
    //
    ulPMAssertionRegister &= ~0xff;

    //
    // Copy the new edge/level settings.
    //
    ulPMAssertionRegister |= ulAssertionRegister & 0xff;

    //
    // Set the Power Mgmt Assertion Register.
    //
    WriteConfigUlong(bBusPIC, bDevFuncPIC, 0x78, ulPMAssertionRegister);

    return(PCIMP_SUCCESS);
}

/****************************************************************************
 *
 *  VLSIGetTrigger - Get the IRQ triggering values for the VLSI.
 *
 *  Exported.
 *
 *  ENTRY:  pulTrigger will have bits set for Level triggered IRQs.
 *
 *  EXIT:   TRUE if successful.
 *
 ***************************************************************************/
PCIMPRET CDECL
VLSIGetTrigger(PULONG pulTrigger)
{
    ULONG   ulAssertionRegister;
    ULONG   i;

    //
    // Read in the Interrupt Assertion Level register.
    //
    ulAssertionRegister = ReadConfigUchar(bBusPIC, bDevFuncPIC, 0x5C);

    //
    // Clear the return buffer.
    //
    *pulTrigger = 0;

    //
    // For each VLSI interrupt...
    //
    for (i=0; i<NUM_VLSI_IRQ; i++)
    {
        //
        // If the corresponding bit is set to level...
        //
        if (ulAssertionRegister & (1 << i))
        {
            //
            // Set the corresponding bit in the
            // return buffer.
            //
            *pulTrigger |= 1 << rgbIndexToIRQ[i];
        }
    }

    return(PCIMP_SUCCESS);
}

/****************************************************************************
 *
 *  VLSIValidateTable - Validate an IRQ table
 *
 *  Exported.
 *
 *  ENTRY:  piihIRQInfoHeader points to an IRQInfoHeader followed
 *      by an IRQ Routing Table.
 *
 *      ulFlags are PCIMP_VALIDATE flags.
 *
 *  EXIT:   Standard PCIMP return value.
 *
 ***************************************************************************/
PCIMPRET CDECL
VLSIValidateTable(PIRQINFOHEADER piihIRQInfoHeader, ULONG ulFlags)
{
    PAGED_CODE();

    if (GetMaxLink(piihIRQInfoHeader)>0x04) {

        return(PCIMP_FAILURE);
    }

    return(PCIMP_SUCCESS);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\pciirqmp\i386\vesuvius.c ===
/*
 *
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *
 *  VESUVIUS.C - NS VESUVIUS PCI chipset routines.
 *
 *  Notes:
 *  Algorithms from NS VESUVIUS Data Sheet
 *
 */

#include "local.h"

UCHAR
ReadIndexRegisterByte(
    IN UCHAR bIndex
    );

VOID
WriteIndexRegisterByte(
    IN UCHAR bIndex, 
    IN UCHAR bValue
    );

#ifdef ALLOC_DATA_PRAGMA
#pragma data_seg()
#pragma const_seg()
#endif

LOCAL_DATA  PIRQINFOHEADER gpiihIRQInfoHeader=NULL;

#ifdef ALLOC_PRAGMA

#pragma alloc_text(INIT, VESUVIUSValidateTable)
              
#endif //ALLOC_PRAGMA


UCHAR
ReadIndexRegisterByte(
    IN UCHAR bIndex
    )
{
    UCHAR bOldIndex, bResult;

    bOldIndex=READ_PORT_UCHAR((PUCHAR)0x24);

    WRITE_PORT_UCHAR((PUCHAR)0x24, bIndex);

    bResult=READ_PORT_UCHAR((PUCHAR)0x26);

    WRITE_PORT_UCHAR((PUCHAR)0x24, bOldIndex);

    return(bResult);
}

VOID
WriteIndexRegisterByte(
    IN UCHAR bIndex, 
    IN UCHAR bValue
    )
{
    UCHAR bOldIndex;

    bOldIndex=READ_PORT_UCHAR((PUCHAR)0x24);

    WRITE_PORT_UCHAR((PUCHAR)0x24, bIndex);

    WRITE_PORT_UCHAR((PUCHAR)0x26, bValue);

    WRITE_PORT_UCHAR((PUCHAR)0x24, bOldIndex);
}

/****************************************************************************
 *
 *  VESUVIUSSetIRQ - Set a VESUVIUS PCI link to a specific IRQ
 *
 *  Exported.
 *
 *  ENTRY:  bIRQNumber is the new IRQ to be used.
 *
 *      bLink is the Link to be set.
 *
 *  EXIT:   Standard PCIMP return value.
 *
 ***************************************************************************/
PCIMPRET CDECL
VESUVIUSSetIRQ(UCHAR bIRQNumber, UCHAR bLink)
{
    UCHAR   bIndex, bOldValue;
    //
    // Validate link number.
    //
    if (bLink > 4) {

        return(PCIMP_INVALID_LINK);
    }
    //
    // Zero based.
    //
    bLink--;
    //
    // Set various values.
    //
    bIndex=(bLink/2)+0x10;

    //
    // Read the old VESUVIUS IRQ register.
    //
    bOldValue=ReadIndexRegisterByte(bIndex);

    if (bLink&1) {
        bOldValue&=0x0f;
        bOldValue|=(bIRQNumber<<4);
    }
    else {
        bOldValue&=0xf0;
        bOldValue|=bIRQNumber;
    }

    //
    // Set the VESUVIUS IRQ register.
    //
    WriteIndexRegisterByte(bIndex, bOldValue);

    return(PCIMP_SUCCESS);
}

/****************************************************************************
 *
 *  VESUVIUSGetIRQ - Get the IRQ of a VESUVIUS PCI link
 *
 *  Exported.
 *
 *  ENTRY:  pbIRQNumber is the buffer to fill.
 *
 *      bLink is the Link to be read.
 *
 *  EXIT:   Standard PCIMP return value.
 *
 ***************************************************************************/
PCIMPRET CDECL
VESUVIUSGetIRQ(PUCHAR pbIRQNumber, UCHAR bLink)
{
    UCHAR   bIndex, bOldValue;
    //
    // Validate link number.
    //
    if (bLink > 4) {

        return(PCIMP_INVALID_LINK);
    }
    //
    // Zero based.
    //
    bLink--;
    //
    // Set various values.
    //
    bIndex=(bLink/2)+0x10;
    //
    // Read the old VESUVIUS IRQ register.
    //
    bOldValue=ReadIndexRegisterByte(bIndex);

    if (bLink&1)
        bOldValue>>=4;

    *pbIRQNumber=bOldValue&0x0f;

    return(PCIMP_SUCCESS);
}

/****************************************************************************
 *
 *  VESUVIUSSetTrigger - Set the IRQ triggering values for the VESUVIUS
 *
 *  Exported.
 *
 *  ENTRY:  ulTrigger has bits set for Level triggered IRQs.
 *
 *  EXIT:   Standard PCIMP return value.
 *
 ***************************************************************************/
PCIMPRET CDECL
VESUVIUSSetTrigger(ULONG ulTrigger)
{
    ULONG i;
    UCHAR bMask;

    bMask=(UCHAR)(ReadIndexRegisterByte(0x12)&0x0f);

    for (i=0; i<4; i++)
    {
        UCHAR bIRQ=ReadIndexRegisterByte((UCHAR)((i/2)+0x10));
        if (i&1)
            bIRQ>>=4;
        bIRQ&=0x0f;

        //
        // PCI interrupts go through L-E conversion.
        //
        if(bIRQ && (ulTrigger & (1<<bIRQ)))
        {
            bMask&=~(1<<i);
            ulTrigger&=~(1<<bIRQ);
        }
    }

    //
    // Return error if PCI is goofing up.
    //
    if (ulTrigger)
        return (PCIMP_FAILURE);

    WriteIndexRegisterByte(0x12, bMask);

    return(PCIMP_SUCCESS);
}

/****************************************************************************
 *
 *  VESUVIUSGetTrigger - Get the IRQ triggering values for the VESUVIUS
 *
 *  Exported.
 *
 *  ENTRY:  pulTrigger will have bits set for Level triggered IRQs.
 *
 *  EXIT:   Standard PCIMP return value.
 *
 ***************************************************************************/
PCIMPRET CDECL
VESUVIUSGetTrigger(PULONG pulTrigger)
{
    UCHAR   bMask;
    ULONG   i;

    *pulTrigger=0;

    bMask=(UCHAR)(ReadIndexRegisterByte(0x12)&0x0f);

    for (i=0; i<4; i++)
    {
        if (!(bMask&(1<<i)))
        {
            UCHAR bIRQ=ReadIndexRegisterByte((UCHAR)((i/2)+0x10));
            if (i&1)
                bIRQ>>=4;
            bIRQ&=0x0f;
            if (bIRQ)
                *pulTrigger|=(1<<bIRQ);
        }
    }

    return(PCIMP_SUCCESS);
}

/****************************************************************************
 *
 *  VESUVIUSValidateTable - Validate an IRQ table
 *
 *  Exported.
 *
 *  ENTRY:  piihIRQInfoHeader points to an IRQInfoHeader followed
 *      by an IRQ Routing Table.
 *
 *      ulFlags are PCIMP_VALIDATE flags.
 *
 *  EXIT:   Standard PCIMP return value.
 *
 ***************************************************************************/
PCIMPRET CDECL
VESUVIUSValidateTable(PIRQINFOHEADER piihIRQInfoHeader, ULONG ulFlags)
{
    PAGED_CODE();

    gpiihIRQInfoHeader=piihIRQInfoHeader;
    //
    // If any link is above 4, it is an error.
    //
    if (GetMaxLink(piihIRQInfoHeader)>4)
        return(PCIMP_FAILURE);

    return(PCIMP_SUCCESS);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\pciirqmp\i386\vt586.c ===
/*
 *
 * Copyright (c) Microsoft Corporation. All rights reserved.
 *
 *  VT586.C - VIA Technologies PCI chipset routines.
 *
 *  Notes:
 *  Algorithms from VIATECH 82C586B Data Sheet
 *  Compaq contact:     
 *
 */

#include "local.h"

#ifdef ALLOC_PRAGMA

#pragma alloc_text(INIT, VT586ValidateTable)

#endif //ALLOC_PRAGMA

/****************************************************************************
 *
 *  VT586SetIRQ - Set a VIATECH 82C586B PCI link to a specific IRQ
 *
 *  Exported.
 *
 *  ENTRY:  bIRQNumber is the new IRQ to be used.
 *
 *      bLink is the Link to be set.
 *
 *  EXIT:   Standard PCIMP return value.
 *
 ***************************************************************************/
PCIMPRET CDECL
VT586SetIRQ(UCHAR bIRQNumber, UCHAR bLink)
{
    UCHAR bOffset, bOldValue;
    
    switch (bLink)
    {
        case 1: case 2:
        case 3: case 5:

            break;
            
        default:
        
            return (PCIMP_INVALID_LINK);
    }

    //
    // Compute the offset in config space.
    //
    bOffset=(bLink/2)+0x55;

    //
    // Read the old VT82C586 IRQ register.
    //
    bOldValue=ReadConfigUchar(bBusPIC, bDevFuncPIC, bOffset);

    if (bLink&1) {
        bOldValue&=0x0f;
        bOldValue|=(bIRQNumber<<4);
    }
    else {
        bOldValue&=0xf0;
        bOldValue|=bIRQNumber;
    }

    //
    // Set the VT82C586B IRQ register.
    //
    WriteConfigUchar(bBusPIC, bDevFuncPIC, bOffset, bOldValue);
        
    return(PCIMP_SUCCESS);
}

/****************************************************************************
 *
 *  VT586GetIRQ - Get the IRQ of a VIATECH 82C586B PCI link
 *
 *  Exported.
 *
 *  ENTRY:  pbIRQNumber is the buffer to fill.
 *
 *      bLink is the Link to be read.
 *
 *  EXIT:   Standard PCIMP return value.
 *
 ***************************************************************************/
PCIMPRET CDECL
VT586GetIRQ(PUCHAR pbIRQNumber, UCHAR bLink)
{
    UCHAR bOffset, bOldValue;
    
    switch (bLink)
    {
        case 1: case 2:
        case 3: case 5:

            break;
            
        default:
        
            return (PCIMP_INVALID_LINK);
    }

    //
    // Set various values.
    //
    bOffset=(bLink/2)+0x55;

    //
    // Read the old VT82C586 IRQ register.
    //
    bOldValue=ReadConfigUchar(bBusPIC, bDevFuncPIC, bOffset);

    if (bLink&1)
        bOldValue>>=4;

    *pbIRQNumber=bOldValue&0x0f;

    return(PCIMP_SUCCESS);
}

/****************************************************************************
 *
 *  VT586ValidateTable - Validate an IRQ table
 *
 *  Exported.
 *
 *  ENTRY:  piihIRQInfoHeader points to an IRQInfoHeader followed
 *      by an IRQ Routing Table.
 *
 *      ulFlags are PCIMP_VALIDATE flags.
 *
 *  EXIT:   Standard PCIMP return value.
 *
 ***************************************************************************/
PCIMPRET CDECL
VT586ValidateTable(PIRQINFOHEADER piihIRQInfoHeader, ULONG ulFlags)
{
    PIRQINFO    pii=(PIRQINFO)(((PUCHAR) piihIRQInfoHeader)+sizeof(IRQINFOHEADER));
    ULONG       i, j;
    ULONG       cEntries=(piihIRQInfoHeader->TableSize-sizeof(IRQINFOHEADER))/sizeof(IRQINFO);

    PAGED_CODE();

    for (i=0; i<cEntries; i++, pii++) {

        for (j=0; j<4; j++) {

            if (pii->PinInfo[j].Link<=3 || pii->PinInfo[j].Link==5)
                continue;
                
            return (PCIMP_FAILURE);                 
        }       
    }

    return(i? PCIMP_SUCCESS : PCIMP_FAILURE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\x86new\addops.c ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    addops.c

Abstract:

    This module implements the code to emulate the add, sub, adc, sbb,
    inc, dec, and neg opcodes.

Author:

    David N. Cutler (davec) 2-Sep-1994

Environment:

    Kernel mode only.

Revision History:

--*/

#include "nthal.h"
#include "emulate.h"

//
// Define forward referenced prototypes.
//

VOID
XmAddOperands (
    IN PRXM_CONTEXT P,
    IN ULONG Carry
    );

VOID
XmSubOperands (
    IN PRXM_CONTEXT P,
    IN ULONG Borrow
    );

VOID
XmAddOp (
    IN PRXM_CONTEXT P
    )

/*++

Routine Description:

    This function emulates an add opcode.

Arguments:

    P - Supplies a pointer to the emulation context structure.

Return Value:

    None.

--*/

{

    //
    // Add operands and store result.
    //

    XmAddOperands(P, 0);
    return;
}

VOID
XmAdcOp (
    IN PRXM_CONTEXT P
    )

/*++

Routine Description:

    This function emulates an add with carry opcode.

Arguments:

    P - Supplies a pointer to the emulation context structure.

Return Value:

    None.

--*/

{

    //
    // Add operands with carry and store result.
    //

    XmAddOperands(P, P->Eflags.EFLAG_CF);
    return;
}

VOID
XmSbbOp (
    IN PRXM_CONTEXT P
    )

/*++

Routine Description:

    This function emulates a subtract with borrow opcode.

Arguments:

    P - Supplies a pointer to the emulation context structure.

Return Value:

    None.

--*/

{

    ULONG Source;

    //
    // Subtract operands with borrow and store result.
    //

    XmSubOperands(P, P->Eflags.EFLAG_CF);
    return;
}

VOID
XmSubOp (
    IN PRXM_CONTEXT P
    )

/*++

Routine Description:

    This function emulates a subtract opcode.

Arguments:

    P - Supplies a pointer to the emulation context structure.

Return Value:

    None.

--*/

{

    //
    // Subtract operands and store result.
    //

    XmSubOperands(P, 0);
    return;
}

VOID
XmCmpOp (
    IN PRXM_CONTEXT P
    )

/*++

Routine Description:

    This function emulates a cmp opcode.

Arguments:

    P - Supplies a pointer to the emulation context structure.

Return Value:

    None.

--*/

{

    //
    // Subtract operands to perform comparison operation.
    //

    XmSubOperands(P, 0);
    return;
}

VOID
XmCmpxchgOp (
    IN PRXM_CONTEXT P
    )

/*++

Routine Description:

    This function emulates a cmpxchg opcode.

Arguments:

    P - Supplies a pointer to the emulation context structure.

Return Value:

    None.

--*/

{

    ULONG Accumulator;
    ULONG Destination;

    //
    // Compare the destination with the accumulator. If the destination
    // operand is equal to the accumulator, then set ZF and store the
    // source operand value in the destination opperand. Otherwise, clear
    // ZF and store the destination operand in the accumlator.
    //

    Destination = P->DstValue.Long;
    if (P->DataType == BYTE_DATA) {
        Accumulator = P->Gpr[AL].Xl;

    } else if (P->DataType == LONG_DATA) {
        Accumulator = P->Gpr[EAX].Exx;

    } else {
        Accumulator = P->Gpr[AX].Xx;
    }

    if (Destination == Accumulator) {
        P->Eflags.EFLAG_ZF = 1;
        XmStoreResult(P, P->SrcValue.Long);

    } else {
        P->Eflags.EFLAG_ZF = 0;
        P->DstLong = (ULONG UNALIGNED *)(&P->Gpr[EAX].Exx);
        XmStoreResult(P, P->DstValue.Long);
    }

    //
    // Subtract operands to perform comparison operation.
    //

    P->SrcValue.Long = P->DstValue.Long;
    P->DstValue.Long = Accumulator;
    XmSubOperands(P, 0);
    return;
}

VOID
XmDecOp (
    IN PRXM_CONTEXT P
    )

/*++

Routine Description:

    This function emulates a decrement opcode.

Arguments:

    P - Supplies a pointer to the emulation context structure.

Return Value:

    None.

--*/

{

    //
    // Subtract operands and store result.
    //
    //

    P->SrcValue.Long = 1;
    XmSubOperands(P, 0);
    return;
}

VOID
XmIncOp (
    IN PRXM_CONTEXT P
    )

/*++

Routine Description:

    This function emulates an increment opcode.

Arguments:

    P - Supplies a pointer to the emulation context structure.

Return Value:

    None.

--*/

{

    //
    // Add operands and store result.
    //

    P->SrcValue.Long = 1;
    XmAddOperands(P, 0);
    return;
}

VOID
XmNegOp (
    IN PRXM_CONTEXT P
    )

/*++

Routine Description:

    This function emulates a neg opcode.

Arguments:

    P - Supplies a pointer to the emulation context structure.

Return Value:

    None.

--*/

{


    //
    // Subtract operand from zero and store result.
    //

    P->SrcValue.Long = P->DstValue.Long;
    P->DstValue.Long = 0;
    XmSubOperands(P, 0);
    return;
}

VOID
XmXaddOp (
    IN PRXM_CONTEXT P
    )

/*++

Routine Description:

    This function emulates an xadd opcode.

Arguments:

    P - Supplies a pointer to the emulation context structure.

Return Value:

    None.

--*/

{

    ULONG Destination;

    //
    // Exchange add operands and store result.
    //

    Destination = P->DstValue.Long;
    XmAddOperands(P, 0);
    P->DstLong = P->SrcLong;
    XmStoreResult(P, Destination);
    return;
}

VOID
XmAddOperands (
    IN PRXM_CONTEXT P,
    IN ULONG Carry
    )

/*++

Routine Description:

    This function adds two operands and computes the resulting condition
    codes.

Arguments:

    P - Supplies a pointer to the emulation context structure.

    Carry - Supplies the carry value.

Return Value:

    None.

--*/

{

    ULONG CarryFlag;
    ULONG Shift;
    union {
        UCHAR ResultByte;
        ULONG ResultLong;
        USHORT ResultWord;
    } u;

    u.ResultLong = 0;
    if (P->DataType == BYTE_DATA) {
        u.ResultByte = P->SrcValue.Byte + (UCHAR)Carry;
        CarryFlag = u.ResultByte < (UCHAR)Carry;
        u.ResultByte += P->DstValue.Byte;
        CarryFlag |= (u.ResultByte < P->DstValue.Byte);
        Shift = 7;

    } else if (P->DataType == LONG_DATA) {
        u.ResultLong = P->SrcValue.Long + Carry;
        CarryFlag = (u.ResultLong < Carry);
        u.ResultLong += P->DstValue.Long;
        CarryFlag |= (u.ResultLong < P->DstValue.Long);
        Shift = 31;

    } else {
        u.ResultWord = P->SrcValue.Word + (USHORT)Carry;
        CarryFlag = (u.ResultWord < (USHORT)Carry);
        u.ResultWord += P->DstValue.Word;
        CarryFlag |= (u.ResultWord < P->DstValue.Word);
        Shift = 15;
    }

    //
    // Store the result.
    //

    XmStoreResult(P, u.ResultLong);

    //
    // If the function is not an increment, then store the carry flag.
    //

    if (P->FunctionIndex != X86_INC_OP) {
        P->Eflags.EFLAG_CF = CarryFlag;
    }

    //
    // Compute and store the parity and auxiliary carry flags.
    //

    P->Eflags.EFLAG_PF = XmComputeParity(u.ResultLong);
    P->Eflags.EFLAG_AF = ((P->DstValue.Byte & 0xf) +
                                        (P->SrcValue.Long & 0xf) + Carry) >> 4;

    //
    // Compute and store the zero and sign flags.
    //

    P->Eflags.EFLAG_ZF = (u.ResultLong == 0);
    P->Eflags.EFLAG_SF = u.ResultLong >> Shift;

    //
    // The overflow flag is computed as the carry into the sign bit
    // compared with the carry out of the sign bit.
    //

    P->Eflags.EFLAG_OF = (((P->SrcValue.Long ^ P->DstValue.Long) ^
                                        u.ResultLong) >> Shift) ^ CarryFlag;

    return;
}

VOID
XmSubOperands (
    IN PRXM_CONTEXT P,
    IN ULONG Borrow
    )

/*++

Routine Description:

    This function adds to operands and computes the resulting condition
    codes.

Arguments:

    P - Supplies a pointer to the emulation context structure.

    Borrow - Supplies the boorow value.

Return Value:

    None.

--*/

{

    ULONG CarryFlag;
    ULONG Shift;
    union {
        UCHAR ResultByte;
        ULONG ResultLong;
        USHORT ResultWord;
    } u;

    u.ResultLong = 0;
    if (P->DataType == BYTE_DATA) {
        CarryFlag = (P->DstValue.Byte < (UCHAR)Borrow);
        u.ResultByte = P->DstValue.Byte - (UCHAR)Borrow;
        CarryFlag |= (u.ResultByte < P->SrcValue.Byte);
        u.ResultByte -= P->SrcValue.Byte;
        Shift = 7;

    } else if (P->DataType == LONG_DATA) {
        CarryFlag = (P->DstValue.Long < Borrow);
        u.ResultLong = P->DstValue.Long - Borrow;
        CarryFlag |= (u.ResultLong < P->SrcValue.Long);
        u.ResultLong -= P->SrcValue.Long;
        Shift = 31;

    } else {
        CarryFlag = (P->DstValue.Word < (USHORT)Borrow);
        u.ResultWord = P->DstValue.Word - (USHORT)Borrow;
        CarryFlag |= (u.ResultWord < P->SrcValue.Word);
        u.ResultWord -= P->SrcValue.Word;
        Shift = 15;
    }

    //
    // If the fucntion is not a compare or a compare and swap, then store
    // result.
    //

    if ((P->FunctionIndex != X86_CMP_OP) && (P->FunctionIndex != X86_CMPXCHG_OP)) {
        XmStoreResult(P, u.ResultLong);
    }

    //
    // If the function is not a decrement, then store the carry flag.
    //

    if (P->FunctionIndex != X86_DEC_OP) {
        P->Eflags.EFLAG_CF = CarryFlag;
    }

    //
    // Compute and store the parity and auxiliary carry flags.
    //

    P->Eflags.EFLAG_PF = XmComputeParity(u.ResultLong);
    P->Eflags.EFLAG_AF = ((P->DstValue.Byte & 0xf) -
                                        (P->SrcValue.Byte & 0xf) - Borrow) >> 4;

    //
    // If the function is not a compare and swap, then compute the zero flag.
    //

    if (P->FunctionIndex != X86_CMPXCHG_OP) {
        P->Eflags.EFLAG_ZF = (u.ResultLong == 0);
    }

    //
    // Compute and store the sign flag.
    //

    P->Eflags.EFLAG_SF = u.ResultLong >> Shift;

    //
    // The overflow flag is computed as the borrow from the sign bit
    // compared with the borrow into the sign bit.
    //

    P->Eflags.EFLAG_OF = (((P->SrcValue.Long ^ P->DstValue.Long) ^ u.ResultLong) >> Shift) ^ CarryFlag;
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\x86new\bitops.c ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    bitops.c

Abstract:

    This module implements the code to emulate the bit opcodes.

Author:

    David N. Cutler (davec) 12-Nov-1994

Environment:

    Kernel mode only.

Revision History:

--*/

#include "nthal.h"
#include "emulate.h"

VOID
XmBsfOp (
    IN PRXM_CONTEXT P
    )

/*++

Routine Description:

    This function emulates an bsf opcode.

Arguments:

    P - Supplies a pointer to the emulation context structure.

Return Value:

    None.

--*/

{

    ULONG Result;
    ULONG Source;

    //
    // If the source operand is zero, then set ZF and set the destination
    // to zero, Otherwise, find the first bit set scanning from right to
    // left.
    //

    Result = 0;
    Source = P->SrcValue.Long;
    P->Eflags.EFLAG_ZF = 1;
    while (Source != 0) {
        if ((Source & 1) != 0) {
            P->Eflags.EFLAG_ZF = 0;
            break;
        }

        Result += 1;
        Source >>= 1;
    };

    XmStoreResult(P, Result);
    return;
}

VOID
XmBsrOp (
    IN PRXM_CONTEXT P
    )

/*++

Routine Description:

    This function emulates an bsr opcode.

Arguments:

    P - Supplies a pointer to the emulation context structure.

Return Value:

    None.

--*/

{

    ULONG Result;
    ULONG Source;

    //
    // If the source operand is zero, then set ZF and set the destination
    // to zero, Otherwise, find the first bit set scanning from left to
    // right.
    //

    Result = ((P->DataType + 1) << 3) - 1;
    Source = P->SrcValue.Long;
    P->Eflags.EFLAG_ZF = 1;
    while (Source != 0) {
        if (((Source >> Result) & 1) != 0) {
            P->Eflags.EFLAG_ZF = 0;
            break;
        }

        Result -= 1;
    };

    XmStoreResult(P, Result);
    return;
}

VOID
XmBtOp (
    IN PRXM_CONTEXT P
    )

/*++

Routine Description:

    This function emulates an bt opcode.

Arguments:

    P - Supplies a pointer to the emulation context structure.

Return Value:

    None.

--*/

{

    //
    // Test the specified bit and store the bit in CF.
    //

    P->Eflags.EFLAG_CF = P->DstValue.Long >> P->SrcValue.Long;
    return;
}

VOID
XmBtsOp (
    IN PRXM_CONTEXT P
    )

/*++

Routine Description:

    This function emulates an bts opcode.

Arguments:

    P - Supplies a pointer to the emulation context structure.

Return Value:

    None.

--*/

{

    //
    // Test and set the specified bit and store the bit in CF.
    //
    //

    P->Eflags.EFLAG_CF = P->DstValue.Long >> P->SrcValue.Long;
    P->DstValue.Long |= (1 << P->SrcValue.Long);
    XmStoreResult(P, P->DstValue.Long);
    return;
}

VOID
XmBtrOp (
    IN PRXM_CONTEXT P
    )

/*++

Routine Description:

    This function emulates an btr opcode.

Arguments:

    P - Supplies a pointer to the emulation context structure.

Return Value:

    None.

--*/

{

    //
    // Test and reset the specified bit and store the bit in CF.
    //
    //

    P->Eflags.EFLAG_CF = P->DstValue.Long >> P->SrcValue.Long;
    P->DstValue.Long &= ~(1 << P->SrcValue.Long);
    XmStoreResult(P, P->DstValue.Long);
    return;
}

VOID
XmBtcOp (
    IN PRXM_CONTEXT P
    )

/*++

Routine Description:

    This function emulates an btc opcode.

Arguments:

    P - Supplies a pointer to the emulation context structure.

Return Value:

    None.

--*/

{

    //
    // Test and reset the specified bit and store the bit in CF.
    //
    //

    P->Eflags.EFLAG_CF = P->DstValue.Long >> P->SrcValue.Long;
    P->DstValue.Long ^= (1 << P->SrcValue.Long);
    XmStoreResult(P, P->DstValue.Long);
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\x86new\asciiops.c ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    asciiops.c

Abstract:

    This module implements the code to emulate the ASCII opcodes.

Author:

    David N. Cutler (davec) 12-Nov-1994

Environment:

    Kernel mode only.

Revision History:

--*/

#include "nthal.h"
#include "emulate.h"

VOID
XmAaaOp (
    IN PRXM_CONTEXT P
    )

/*++

Routine Description:

    This function emulates an aaa opcode.

Arguments:

    P - Supplies a pointer to the emulation context structure.

Return Value:

    None.

--*/

{

    ULONG Carry;

    //
    // If AL if greater than 9 or AF is set, then adjust ASCII result.
    //

    if (((P->Gpr[AX].Xl & 0xf) > 9) || (P->Eflags.EFLAG_AF != 0)) {
        Carry = (P->Gpr[AX].Xl > 0xf9);
        P->Gpr[AX].Xl = (P->Gpr[AX].Xl + 6) & 0xf;
        P->Gpr[AX].Xh += (UCHAR)(1 + Carry);
        P->Eflags.EFLAG_CF = 1;
        P->Eflags.EFLAG_AF = 1;

    } else {
        P->Gpr[AX].Xl &= 0xf;
        P->Eflags.EFLAG_CF = 0;
        P->Eflags.EFLAG_AF = 0;
    }

    return;
}

VOID
XmAadOp (
    IN PRXM_CONTEXT P
    )

/*++

Routine Description:

    This function emulates an aad opcode.

Arguments:

    P - Supplies a pointer to the emulation context structure.

Return Value:

    None.

--*/

{

    //
    // Pack AH and AL into AX before division by scaling AH by 10 and
    // adding AL.
    //

    P->Gpr[AX].Xl = (P->Gpr[AX].Xh * P->SrcValue.Byte) + P->Gpr[AX].Xl;
    P->Gpr[AX].Xh = 0;
    P->Eflags.EFLAG_SF = (P->Gpr[AX].Xx >> 15) & 0x1;
    P->Eflags.EFLAG_ZF = (P->Gpr[AX].Xx == 0);
    P->Eflags.EFLAG_PF = XmComputeParity(P->Gpr[AX].Xx);
    return;
}

VOID
XmAamOp (
    IN PRXM_CONTEXT P
    )

/*++

Routine Description:

    This function emulates an aam opcode.

Arguments:

    P - Supplies a pointer to the emulation context structure.

Return Value:

    None.

--*/

{

    //
    // Unpack AL into AL and AH after multiplication by dividing by 10
    // and storing the quotient in AH and the remainder in AL.
    //

    P->Gpr[AX].Xh = P->Gpr[AX].Xl / P->SrcValue.Byte;
    P->Gpr[AX].Xl = P->Gpr[AX].Xl % P->SrcValue.Byte;
    P->Eflags.EFLAG_SF = (P->Gpr[AX].Xx >> 15) & 0x1;
    P->Eflags.EFLAG_ZF = (P->Gpr[AX].Xx == 0);
    P->Eflags.EFLAG_PF = XmComputeParity(P->Gpr[AX].Xx);
    return;
}

VOID
XmAasOp (
    IN PRXM_CONTEXT P
    )

/*++

Routine Description:

    This function emulates an aaa opcode.

Arguments:

    P - Supplies a pointer to the emulation context structure.

Return Value:

    None.

--*/

{

    ULONG Borrow;

    //
    // If AL if greater than 9 or AF is set, then adjust ASCII result.
    //

    if (((P->Gpr[AX].Xl & 0xf) > 9) || (P->Eflags.EFLAG_AF != 0)) {
        Borrow = (P->Gpr[AX].Xl < 0x6);
        P->Gpr[AX].Xl = (P->Gpr[AX].Xl - 6) & 0xf;
        P->Gpr[AX].Xh -= (UCHAR)(1 + Borrow);
        P->Eflags.EFLAG_CF = 1;
        P->Eflags.EFLAG_AF = 1;

    } else {
        P->Gpr[AX].Xl &= 0xf;
        P->Eflags.EFLAG_CF = 0;
        P->Eflags.EFLAG_AF = 0;
    }

    return;
}

VOID
XmDaaOp (
    IN PRXM_CONTEXT P
    )

/*++

Routine Description:

    This function emulates a daa opcode.

Arguments:

    P - Supplies a pointer to the emulation context structure.

Return Value:

    None.

--*/

{

    //
    // If AL if greater than 9 or AF is set, then adjust ASCII result.
    //

    if (((P->Gpr[AX].Xl & 0xf) > 0x9) || (P->Eflags.EFLAG_AF != 0)) {
        P->Gpr[AX].Xl = P->Gpr[AX].Xl + 6;
        P->Eflags.EFLAG_AF = 1;

    } else {
        P->Eflags.EFLAG_AF = 0;
    }

    //
    // If AL is greater than 9 or CF is set, then adjust ASCII result.
    //

    if ((P->Gpr[AX].Xl > 9) || (P->Eflags.EFLAG_CF != 0)) {
        P->Gpr[AX].Xl = P->Gpr[AX].Xl + 0x60;
        P->Eflags.EFLAG_CF = 1;

    } else {
        P->Eflags.EFLAG_CF = 0;
    }

    return;
}

VOID
XmDasOp (
    IN PRXM_CONTEXT P
    )

/*++

Routine Description:

    This function emulates a daa opcode.

Arguments:

    P - Supplies a pointer to the emulation context structure.

Return Value:

    None.

--*/

{

    //
    // If AL if greater than 9 or AF is set, then adjust ASCII result.
    //

    if (((P->Gpr[AX].Xl & 0xf) > 0x9) || (P->Eflags.EFLAG_AF != 0)) {
        P->Gpr[AX].Xl = P->Gpr[AX].Xl - 6;
        P->Eflags.EFLAG_AF = 1;

    } else {
        P->Eflags.EFLAG_AF = 0;
    }

    //
    // If AL is greater than 9 or CF is set, then adjust ASCII result.
    //

    if ((P->Gpr[AX].Xl > 9) || (P->Eflags.EFLAG_CF != 0)) {
        P->Gpr[AX].Xl = P->Gpr[AX].Xl - 0x60;
        P->Eflags.EFLAG_CF = 1;

    } else {
        P->Eflags.EFLAG_CF = 0;
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\x86new\condops.c ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    condops.c

Abstract:

    This module implements the code to emulate condition code opcodes.

Author:

    David N. Cutler (davec) 22-Sep-1994

Environment:

    Kernel mode only.

Revision History:

--*/

#include "nthal.h"
#include "emulate.h"

VOID
XmClcOp (
    PRXM_CONTEXT P
    )

/*++

Routine Description:

    This function emulates a clc opcode.

Arguments:

    P - Supplies a pointer to an emulator context structure.

Return Value:

    None.

--*/

{

    //
    // Clear carry flag.
    //

    P->Eflags.EFLAG_CF = 0;
    return;
}

VOID
XmCldOp (
    PRXM_CONTEXT P
    )

/*++

Routine Description:

    This function emulates a cld opcode.

Arguments:

    P - Supplies a pointer to an emulator context structure.

Return Value:

    None.

--*/

{

    //
    // Clear direction flag.
    //

    P->Eflags.EFLAG_DF = 0;
    return;
}

VOID
XmCliOp (
    PRXM_CONTEXT P
    )

/*++

Routine Description:

    This function emulates a cli opcode.

Arguments:

    P - Supplies a pointer to an emulator context structure.

Return Value:

    None.

--*/

{

    //
    // Clear interrupt flag.
    //

    P->Eflags.EFLAG_IF = 0;
    return;
}

VOID
XmCmcOp (
    PRXM_CONTEXT P
    )

/*++

Routine Description:

    This function emulates a cmc opcode.

Arguments:

    P - Supplies a pointer to an emulator context structure.

Return Value:

    None.

--*/

{

    //
    // Complement carry flag.
    //

    P->Eflags.EFLAG_CF ^= 1;
    return;
}

VOID
XmStcOp (
    PRXM_CONTEXT P
    )

/*++

Routine Description:

    This function emulates a stc opcode.

Arguments:

    P - Supplies a pointer to an emulator context structure.

Return Value:

    None.

--*/

{

    //
    // Set carry flag.
    //

    P->Eflags.EFLAG_CF = 1;
    return;
}

VOID
XmStdOp (
    PRXM_CONTEXT P
    )

/*++

Routine Description:

    This function emulates a std opcode.

Arguments:

    P - Supplies a pointer to an emulator context structure.

Return Value:

    None.

--*/

{

    //
    // Set direction flag.
    //

    P->Eflags.EFLAG_DF = 1;
    return;
}

VOID
XmStiOp (
    PRXM_CONTEXT P
    )

/*++

Routine Description:

    This function emulates a sti opcode.

Arguments:

    P - Supplies a pointer to an emulator context structure.

Return Value:

    None.

--*/

{

    //
    // Set interrupt flag.
    //

    P->Eflags.EFLAG_IF = 1;
    return;
}

VOID
XmLahfOp (
    PRXM_CONTEXT P
    )

/*++

Routine Description:

    This function emulates a lahf opcode.

Arguments:

    P - Supplies a pointer to an emulator context structure.

Return Value:

    None.

--*/

{

    //
    // Load flags into AH.
    //

    P->DataType = BYTE_DATA;
    P->DstByte = &P->Gpr[AX].Xh;
    XmStoreResult(P, (ULONG)P->AhFlags);
    return;
}

VOID
XmSahfOp (
    PRXM_CONTEXT P
    )

/*++

Routine Description:

    This function emulates a sahf opcode.

Arguments:

    P - Supplies a pointer to an emulator context structure.

Return Value:

    None.

--*/

{

    //
    // Store CF, PF, AF, ZF, SF of AH in flags.
    //

    P->AhFlags = P->Gpr[AX].Xh;
    P->Eflags.EFLAG_MBO = 1;
    P->Eflags.EFLAG_SBZ0 = 0;
    P->Eflags.EFLAG_SBZ1 = 0;
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\x86new\divops.c ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    mulops.c

Abstract:

    This module implements the code to emulate the div and idiv opcodes.

Author:

    David N. Cutler (davec) 21-Sep-1994

Environment:

    Kernel mode only.

Revision History:

--*/

#include "nthal.h"
#include "emulate.h"

VOID
XmDivOp (
    IN PRXM_CONTEXT P
    )

/*++

Routine Description:

    This function emulates an unsigned div opcode.

Arguments:

    P - Supplies a pointer to the emulation context structure.

Return Value:

    None.

--*/

{

    UNALIGNED ULONG *DstHigh;
    ULONG Dividend;
    ULONG Divisor;
    ULARGE_INTEGER Large;
    ULONG Quotient;
    ULONG Remainder;

    //
    // Divide the unsigned operands and store result.
    //

    Divisor = P->SrcValue.Long;
    if (Divisor == 0) {
        longjmp(&P->JumpBuffer[0], XM_DIVIDE_BY_ZERO);
    }

    if (P->DataType == BYTE_DATA) {
        Dividend = (ULONG)P->Gpr[AX].Xx;
        Quotient = Dividend / Divisor;
        Remainder = Dividend % Divisor;
        DstHigh = (UNALIGNED ULONG *)(&P->Gpr[AX].Xh);
        Dividend >>= 8;

    } else if (P->DataType == WORD_DATA) {
        Dividend = (P->Gpr[DX].Xx << 16) | P->Gpr[AX].Xx;
        Quotient = Dividend / Divisor;
        Remainder = Dividend % Divisor;
        DstHigh = (UNALIGNED ULONG *)(&P->Gpr[DX].Xx);
        Dividend >>= 16;

    } else {
        Dividend = P->Gpr[EDX].Exx;
        Large.HighPart = Dividend;
        Large.LowPart = P->Gpr[EAX].Exx;
        Quotient = (ULONG)(Large.QuadPart / (ULONGLONG)Divisor);
        Remainder = (ULONG)(Large.QuadPart % (ULONGLONG)Divisor);
        DstHigh = (UNALIGNED ULONG *)(&P->Gpr[EDX].Exx);
    }

    if (Dividend >= Divisor) {
        longjmp(&P->JumpBuffer[0], XM_DIVIDE_QUOTIENT_OVERFLOW);
    }

    XmStoreResult(P, Quotient);
    P->DstLong = DstHigh;
    XmStoreResult(P, Remainder);
    return;
}

VOID
XmIdivOp (
    IN PRXM_CONTEXT P
    )

/*++

Routine Description:

    This function emulates a signed idiv opcode.

Arguments:

    P - Supplies a pointer to the emulation context structure.

Return Value:

    None.

--*/

{

    UNALIGNED ULONG *DstHigh;
    LONG Dividend;
    LONG Divisor;
    LARGE_INTEGER Large;
    LONG Quotient;
    LONG Remainder;
    LARGE_INTEGER Result;

    //
    // Divide the signed operands and store result.
    //

    if (P->SrcValue.Long == 0) {
        longjmp(&P->JumpBuffer[0], XM_DIVIDE_BY_ZERO);
    }

    if (P->DataType == BYTE_DATA) {
        Divisor = (LONG)((SCHAR)P->SrcValue.Byte);
        Dividend = (LONG)((SHORT)P->Gpr[AX].Xx);
        Quotient = Dividend / Divisor;
        Remainder = Dividend % Divisor;
        DstHigh = (UNALIGNED ULONG *)(&P->Gpr[AX].Xh);
        if ((Quotient >> 8) != ((Quotient << 24) >> 31)) {
            longjmp(&P->JumpBuffer[0], XM_DIVIDE_QUOTIENT_OVERFLOW);
        }

        Quotient &= 0xff;
        Remainder &= 0xff;

    } else if (P->DataType == WORD_DATA) {
        Divisor = (LONG)((SHORT)P->SrcValue.Word);
        Dividend = (LONG)((P->Gpr[DX].Xx << 16) | P->Gpr[AX].Xx);
        Quotient = Dividend / Divisor;
        Remainder = Dividend % Divisor;
        DstHigh = (UNALIGNED ULONG *)(&P->Gpr[DX].Xx);
        if ((Quotient >> 16) != ((Quotient << 16) >> 31)) {
            longjmp(&P->JumpBuffer[0], XM_DIVIDE_QUOTIENT_OVERFLOW);
        }

        Quotient &= 0xffff;
        Remainder &= 0xfff;

    } else {
        Divisor = (LONG)(P->SrcValue.Long);
        Large.HighPart = (LONG)P->Gpr[EDX].Exx;
        Large.LowPart = P->Gpr[EAX].Exx;
        Result.QuadPart = Large.QuadPart / (LONGLONG)Divisor;
        Quotient = Result.LowPart;
        Remainder = (LONG)(Large.QuadPart % (LONGLONG)Divisor);
        DstHigh = (UNALIGNED ULONG *)(&P->Gpr[EDX].Exx);
        if (Result.HighPart != ((LONG)Result.LowPart >> 31)) {
            longjmp(&P->JumpBuffer[0], XM_DIVIDE_QUOTIENT_OVERFLOW);
        }
    }

    XmStoreResult(P, Quotient);
    P->DstLong = DstHigh;
    XmStoreResult(P, Remainder);
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\x86new\data.c ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    data.c

Abstract:

    This module contains global data for the x86 bios emulator.

Author:

    David N. Cutler (davec) 10-Sep-1994

Environment:

    Kernel mode only.

Revision History:

--*/

#include "nthal.h"
#include "emulate.h"

//
// Define emulator initialized variable.
//

BOOLEAN XmEmulatorInitialized = FALSE;

//
// Define emulator context structure.
//

XM_CONTEXT XmContext;

//
// Define operand decode table.
//
// This table contains the execution routine for each of the operand types.
//
// N.B. There is a cross indexing between the operand decode field of the
//      opcode control array and the decode table.
//

const POPERAND_DECODE XmOperandDecodeTable[] = {
    XmPushPopSegment,
    XmPushPopSegment,
    XmPushPopSegment,
    XmPushPopSegment,
    XmPushPopSegment,
    XmPushPopSegment,
    XmLoadSegment,
    XmLoadSegment,
    XmLoadSegment,
    XmLoadSegment,
    XmLoadSegment,
    XmLoadSegment,
    XmGroup1General,
    XmGroup1Immediate,
    XmGroup2By1,
    XmGroup2ByCL,
    XmGroup2ByByte,
    XmGroup3General,
    XmGroup45General,
    XmGroup45General,
    XmGroup8BitOffset,
    XmOpcodeRegister,
    XmLongJump,
    XmShortJump,
    XmSetccByte,
    XmAccumImmediate,
    XmAccumRegister,
    XmMoveGeneral,
    XmMoveImmediate,
    XmMoveRegImmediate,
    XmSegmentOffset,
    XmMoveSegment,
    XmMoveXxGeneral,
    XmFlagsRegister,
    XmPushImmediate,
    XmPopGeneral,
    XmImulImmediate,
    XmStringOperands,
    XmEffectiveOffset,
    XmImmediateJump,
    XmImmediateEnter,
    XmGeneralBitOffset,
    XmShiftDouble,
    XmPortImmediate,
    XmPortDX,
    XmBitScanGeneral,
    XmByteImmediate,
    XmXlatOpcode,
    XmGeneralRegister,
    XmNoOperands,
    XmOpcodeEscape,
    XmPrefixOpcode
};

//
// Define opcode function table.
//
// This table contains the execution routine for each opcode.
//
// N.B. There is cross indexing between the function index field of the
//      opcode control array and the function table. The function index
//      in the opcode control array may be the index of the execution
//      function, the base index of the execution function, or a switch
//      value to be used in selecting the function (i.e., prefix opcodes).
//

const POPCODE_FUNCTION XmOpcodeFunctionTable[] = {

    //
    // ASCII operators.
    //

    XmAaaOp,
    XmAadOp,
    XmAamOp,
    XmAasOp,
    XmDaaOp,
    XmDasOp,

    //
    // Group 1 operators.
    //

    XmAddOp,
    XmOrOp,
    XmAdcOp,
    XmSbbOp,
    XmAndOp,
    XmSubOp,
    XmXorOp,
    XmCmpOp,

    //
    // Group 2 operators.
    //

    XmRolOp,
    XmRorOp,
    XmRclOp,
    XmRcrOp,
    XmShlOp,
    XmShrOp,
    XmIllOp,
    XmSarOp,

    //
    // Group 3 operators.
    //

    XmTestOp,
    XmIllOp,
    XmNotOp,
    XmNegOp,
    XmMulOp,
    XmImulxOp,
    XmDivOp,
    XmIdivOp,

    //
    // Group 4 and 5 operators.
    //

    XmIncOp,
    XmDecOp,
    XmCallOp,
    XmCallOp,
    XmJmpOp,
    XmJmpOp,
    XmPushOp,
    XmIllOp,

    //
    // Group 8 operators.
    //

    XmBtOp,
    XmBtsOp,
    XmBtrOp,
    XmBtcOp,

    //
    // Stack push and pop operators.
    //

    XmPopOp,
    XmPushaOp,
    XmPopaOp,

    //
    // Conditional jump operators.
    //

    XmJxxOp,
    XmLoopOp,
    XmJcxzOp,

    //
    // Control operators.
    //

    XmEnterOp,
    XmHltOp,
    XmIntOp,
    XmIretOp,
    XmLeaveOp,
    XmRetOp,

    //
    // Set boolean byte value based on condition.
    //

    XmSxxOp,

    //
    // Condition code operators.
    //

    XmCmcOp,
    XmClcOp,
    XmStcOp,
    XmCliOp,
    XmStiOp,
    XmCldOp,
    XmStdOp,
    XmLahfOp,
    XmSahfOp,

    //
    // General move operators.
    //

    XmMovOp,
    XmXchgOp,

    //
    // Convert operators.
    //

    XmCbwOp,
    XmCwdOp,

    //
    // Single multiply operator.
    //

    XmImulOp,

    //
    // String operators.
    //

    XmCmpsOp,
    XmInsOp,
    XmLodsOp,
    XmMovsOp,
    XmOutsOp,
    XmScasOp,
    XmStosOp,

    //
    // Effective address operators.
    //

    XmBoundOp,
    XmMovOp,

    //
    // Double Shift operators.
    //

    XmShldOp,
    XmShrdOp,

    //
    // I/O operators.
    //

    XmInOp,
    XmOutOp,

    //
    // Bit scan operators.
    //

    XmBsfOp,
    XmBsrOp,

    //
    // Byte swap operators.
    //

    XmBswapOp,

    //
    // Add/Compare exchange operators.
    //

    XmXaddOp,
    XmCmpxchgOp,

    //
    // No operation.
    //

    XmNopOp,

    //
    // Illegal opcode.
    //

    XmIllOp
};

//
// Define opcode control table.
//
// There are two opcode tables which control the emulation of each x86
// opcode. One table is for single byte opcodes and the other is for
// two byte opcodes.
//

const OPCODE_CONTROL XmOpcodeControlTable1[] = {
    {X86_ADD_OP,   FormatGroup1General},     // 0x00 - add Eb,Gb
    {X86_ADD_OP,   FormatGroup1General},     // 0x01 - add Ev,Gv
    {X86_ADD_OP,   FormatGroup1General},     // 0x02 - add Gb,Eb
    {X86_ADD_OP,   FormatGroup1General},     // 0x03 - add Gv,Ev
    {X86_ADD_OP,   FormatAccumImmediate},    // 0x04 - add AL,Ib
    {X86_ADD_OP,   FormatAccumImmediate},    // 0x05 - add eAX,Iv
    {X86_PUSH_OP,  FormatSegmentES},         // 0x06 - push ES
    {X86_POP_OP,   FormatSegmentES},         // 0x07 - pop  ES
    {X86_OR_OP,    FormatGroup1General},     // 0x08 - or Eb,Gb
    {X86_OR_OP,    FormatGroup1General},     // 0x09 - or Ev,Gv
    {X86_OR_OP,    FormatGroup1General},     // 0x0a - or Gb,Eb
    {X86_OR_OP,    FormatGroup1General},     // 0x0b - or Gv,Ev
    {X86_OR_OP,    FormatAccumImmediate},    // 0x0c - or AL,Ib
    {X86_OR_OP,    FormatAccumImmediate},    // 0x0d - or eAX,Iv
    {X86_PUSH_OP,  FormatSegmentCS},         // 0x0e - push CS
    {0,            FormatOpcodeEscape},      // 0x0f - escape:
    {X86_ADC_OP,   FormatGroup1General},     // 0x10 - adc Eb,Gb
    {X86_ADC_OP,   FormatGroup1General},     // 0x11 - adc Ev,Gv
    {X86_ADC_OP,   FormatGroup1General},     // 0x12 - adc Gb,Eb
    {X86_ADC_OP,   FormatGroup1General},     // 0x13 - adc Gv,Ev
    {X86_ADC_OP,   FormatAccumImmediate},    // 0x14 - adc AL,Ib
    {X86_ADC_OP,   FormatAccumImmediate},    // 0x15 - adc eAX,Iv
    {X86_PUSH_OP,  FormatSegmentSS},         // 0x16 - push SS
    {X86_POP_OP,   FormatSegmentSS},         // 0x17 - pop  SS
    {X86_SBB_OP,   FormatGroup1General},     // 0x18 - sbb Eb,Gb
    {X86_SBB_OP,   FormatGroup1General},     // 0x19 - sbb Ev,Gv
    {X86_SBB_OP,   FormatGroup1General},     // 0x1a - sbb Gb,Eb
    {X86_SBB_OP,   FormatGroup1General},     // 0x1b - sbb Gv,Ev
    {X86_SBB_OP,   FormatAccumImmediate},    // 0x1c - sbb AL,Ib
    {X86_SBB_OP,   FormatAccumImmediate},    // 0x1d - sbb eAX,Iv
    {X86_PUSH_OP,  FormatSegmentDS},         // 0x1e - push DS
    {X86_POP_OP,   FormatSegmentDS},         // 0x1f - pop  DS
    {X86_AND_OP,   FormatGroup1General},     // 0x20 - and Eb,Gb
    {X86_AND_OP,   FormatGroup1General},     // 0x21 - and Ev,Gv
    {X86_AND_OP,   FormatGroup1General},     // 0x22 - and Gb,Eb
    {X86_AND_OP,   FormatGroup1General},     // 0x23 - and Gv,Ev
    {X86_AND_OP,   FormatAccumImmediate},    // 0x24 - and AL,Ib
    {X86_AND_OP,   FormatAccumImmediate},    // 0x25 - and eAX,Iv
    {X86_ES_OP,    FormatPrefixOpcode},      // 0x26 - ES:
    {X86_DAA_OP,   FormatNoOperands},        // 0x27 - daa
    {X86_SUB_OP,   FormatGroup1General},     // 0x28 - sub Eb,Gb
    {X86_SUB_OP,   FormatGroup1General},     // 0x29 - sub Ev,Gv
    {X86_SUB_OP,   FormatGroup1General},     // 0x2a - sub Gb,Eb
    {X86_SUB_OP,   FormatGroup1General},     // 0x2b - sub Gv,Ev
    {X86_SUB_OP,   FormatAccumImmediate},    // 0x2c - sub AL,Ib
    {X86_SUB_OP,   FormatAccumImmediate},    // 0x2d - sub eAX,Iv
    {X86_CS_OP,    FormatPrefixOpcode},      // 0x2e - CS:
    {X86_DAS_OP,   FormatNoOperands},        // 0x2f - das
    {X86_XOR_OP,   FormatGroup1General},     // 0x30 - xor Eb,Gb
    {X86_XOR_OP,   FormatGroup1General},     // 0x31 - xor Ev,Gv
    {X86_XOR_OP,   FormatGroup1General},     // 0x32 - xor Gb,Eb
    {X86_XOR_OP,   FormatGroup1General},     // 0x33 - xor Gv,Ev
    {X86_XOR_OP,   FormatAccumImmediate},    // 0x34 - xor AL,Ib
    {X86_XOR_OP,   FormatAccumImmediate},    // 0x35 - xor eAX,Iv
    {X86_SS_OP,    FormatPrefixOpcode},      // 0x36 - SS:
    {X86_AAA_OP,   FormatNoOperands},        // 0x37 - aaa
    {X86_CMP_OP,   FormatGroup1General},     // 0x38 - cmp Eb,Gb
    {X86_CMP_OP,   FormatGroup1General},     // 0x39 - cmp Ev,Gv
    {X86_CMP_OP,   FormatGroup1General},     // 0x3a - cmp Gb,Eb
    {X86_CMP_OP,   FormatGroup1General},     // 0x3b - cmp Gv,Ev
    {X86_CMP_OP,   FormatAccumImmediate},    // 0x3c - cmp AL,Ib
    {X86_CMP_OP,   FormatAccumImmediate},    // 0x3d - cmp eAX,Iv
    {X86_DS_OP,    FormatPrefixOpcode},      // 0x3e - DS:
    {X86_AAS_OP,   FormatNoOperands},        // 0x3f - aas
    {X86_INC_OP,   FormatOpcodeRegister},    // 0x40 - inc eAX
    {X86_INC_OP,   FormatOpcodeRegister},    // 0x41 - inc eCX
    {X86_INC_OP,   FormatOpcodeRegister},    // 0x42 - inc eDX
    {X86_INC_OP,   FormatOpcodeRegister},    // 0x43 - inc eBX
    {X86_INC_OP,   FormatOpcodeRegister},    // 0x44 - inc eSP
    {X86_INC_OP,   FormatOpcodeRegister},    // 0x45 - inc eBP
    {X86_INC_OP,   FormatOpcodeRegister},    // 0x46 - inc eSI
    {X86_INC_OP,   FormatOpcodeRegister},    // 0x47 - inc eDI
    {X86_DEC_OP,   FormatOpcodeRegister},    // 0x48 - dec eAX
    {X86_DEC_OP,   FormatOpcodeRegister},    // 0x49 - dec eCX
    {X86_DEC_OP,   FormatOpcodeRegister},    // 0x4a - dec eDX
    {X86_DEC_OP,   FormatOpcodeRegister},    // 0x4b - dec eBX
    {X86_DEC_OP,   FormatOpcodeRegister},    // 0x4c - dec eSP
    {X86_DEC_OP,   FormatOpcodeRegister},    // 0x4d - dec eBP
    {X86_DEC_OP,   FormatOpcodeRegister},    // 0x4e - dec eSI
    {X86_DEC_OP,   FormatOpcodeRegister},    // 0x4f - dec eDI
    {X86_PUSH_OP,  FormatOpcodeRegister},    // 0x50 - push eAX
    {X86_PUSH_OP,  FormatOpcodeRegister},    // 0x51 - push eCX
    {X86_PUSH_OP,  FormatOpcodeRegister},    // 0x52 - push eDX
    {X86_PUSH_OP,  FormatOpcodeRegister},    // 0x53 - push eBX
    {X86_PUSH_OP,  FormatOpcodeRegister},    // 0x54 - push eSP
    {X86_PUSH_OP,  FormatOpcodeRegister},    // 0x55 - push eBP
    {X86_PUSH_OP,  FormatOpcodeRegister},    // 0x56 - push eSI
    {X86_PUSH_OP,  FormatOpcodeRegister},    // 0x57 - push eDI
    {X86_POP_OP,   FormatOpcodeRegister},    // 0x58 - pop eAX
    {X86_POP_OP,   FormatOpcodeRegister},    // 0x59 - pop eCX
    {X86_POP_OP,   FormatOpcodeRegister},    // 0x5a - pop eDX
    {X86_POP_OP,   FormatOpcodeRegister},    // 0x5b - pop eBX
    {X86_POP_OP,   FormatOpcodeRegister},    // 0x5c - pop eSP
    {X86_POP_OP,   FormatOpcodeRegister},    // 0x5d - pop eBP
    {X86_POP_OP,   FormatOpcodeRegister},    // 0x5e - pop eSI
    {X86_POP_OP,   FormatOpcodeRegister},    // 0x5f - pop eDI
    {X86_PUSHA_OP, FormatNoOperands},        // 0x60 - pusha
    {X86_POPA_OP,  FormatNoOperands},        // 0x61 - popa
    {X86_BOUND_OP, FormatEffectiveOffset},   // 0x62 - bound Gv,Ma
    {X86_ILL_OP,   FormatNoOperands},        // 0x63 - arpl Ew,Rw
    {X86_FS_OP,    FormatPrefixOpcode},      // 0x64 - FS:
    {X86_GS_OP,    FormatPrefixOpcode},      // 0x65 - GS:
    {X86_OPSZ_OP,  FormatPrefixOpcode},      // 0x66 - opsize
    {X86_ADSZ_OP,  FormatPrefixOpcode},      // 0x67 - opaddr
    {X86_PUSH_OP,  FormatPushImmediate},     // 0x68 - push iv
    {X86_IMUL_OP,  FormatImulImmediate},     // 0x69 - imul
    {X86_PUSH_OP,  FormatPushImmediate},     // 0x6a - push ib
    {X86_IMUL_OP,  FormatImulImmediate},     // 0x6b - imul
    {X86_INS_OP,   FormatPortDX},            // 0x6c - insb
    {X86_INS_OP,   FormatPortDX},            // 0x6d - insw/d
    {X86_OUTS_OP,  FormatPortDX},            // 0x6e - outsb
    {X86_OUTS_OP,  FormatPortDX},            // 0x6f - outsw/d
    {X86_JXX_OP,   FormatShortJump},         // 0x70 - jo   jb
    {X86_JXX_OP,   FormatShortJump},         // 0x71 - jno  jb
    {X86_JXX_OP,   FormatShortJump},         // 0x72 - jb   jb
    {X86_JXX_OP,   FormatShortJump},         // 0x73 - jnb  jb
    {X86_JXX_OP,   FormatShortJump},         // 0x74 - jz   jb
    {X86_JXX_OP,   FormatShortJump},         // 0x75 - jnz  jb
    {X86_JXX_OP,   FormatShortJump},         // 0x76 - jbe  jb
    {X86_JXX_OP,   FormatShortJump},         // 0x77 - jnbe jb
    {X86_JXX_OP,   FormatShortJump},         // 0x78 - js   jb
    {X86_JXX_OP,   FormatShortJump},         // 0x79 - jns  jb
    {X86_JXX_OP,   FormatShortJump},         // 0x7a - jp   jb
    {X86_JXX_OP,   FormatShortJump},         // 0x7b - jnp  jb
    {X86_JXX_OP,   FormatShortJump},         // 0x7c - jl   jb
    {X86_JXX_OP,   FormatShortJump},         // 0x7d - jnl  jb
    {X86_JXX_OP,   FormatShortJump},         // 0x7e - jle  jb
    {X86_JXX_OP,   FormatShortJump},         // 0x7f - jnle jb
    {X86_ADD_OP,   FormatGroup1Immediate},   // 0x80 - group1 Eb,Ib
    {X86_ADD_OP,   FormatGroup1Immediate},   // 0x81 - group1 Ev,Iv
    {X86_ILL_OP,   FormatNoOperands},        // 0x82 - illegal
    {X86_ADD_OP,   FormatGroup1Immediate},   // 0x83 - group1 Ev,Ib
    {X86_TEST_OP,  FormatGroup1General},     // 0x84 - test Eb,Gb
    {X86_TEST_OP,  FormatGroup1General},     // 0x85 - test Ev,Gv
    {X86_XCHG_OP,  FormatGroup1General},     // 0x86 - xchg Eb,Gb
    {X86_XCHG_OP,  FormatGroup1General},     // 0x87 = xchg Ev,Gv
    {X86_MOV_OP,   FormatMoveGeneral},       // 0x88 - mov Eb,Gb
    {X86_MOV_OP,   FormatMoveGeneral},       // 0x89 - mov Ev,Gv
    {X86_MOV_OP,   FormatMoveGeneral},       // 0x8a - mov Gb,Eb
    {X86_MOV_OP,   FormatMoveGeneral},       // 0x8b - mov Gv,Ev
    {X86_MOV_OP,   FormatMoveSegment},       // 0x8c - mov Ew,Sw
    {X86_LEA_OP,   FormatEffectiveOffset},   // 0x8d - lea Gv,Ma
    {X86_MOV_OP,   FormatMoveSegment},       // 0x8e - mov Sw,Ew
    {X86_POP_OP,   FormatPopGeneral},        // 0x8f - pop Ev
    {X86_NOP_OP,   FormatNoOperands},        // 0x90 - nop
    {X86_XCHG_OP,  FormatAccumRegister},     // 0x91 - xchg eCX,eAX
    {X86_XCHG_OP,  FormatAccumRegister},     // 0x92 - xchg eDX,eAX
    {X86_XCHG_OP,  FormatAccumRegister},     // 0x93 - xchg eBX,eAX
    {X86_XCHG_OP,  FormatAccumRegister},     // 0x94 - xchg eSP,eAX
    {X86_XCHG_OP,  FormatAccumRegister},     // 0x95 - xchg eBP,eAX
    {X86_XCHG_OP,  FormatAccumRegister},     // 0x96 - xchg eSI,eAX
    {X86_XCHG_OP,  FormatAccumRegister},     // 0x97 - xchg eDI,eAX
    {X86_CBW_OP,   FormatNoOperands},        // 0x98 - cbw
    {X86_CWD_OP,   FormatNoOperands},        // 0x99 - cwd
    {X86_CALL_OP,  FormatImmediateJump},     // 0x9a - call Ap
    {X86_NOP_OP,   FormatNoOperands},        // 0x9b - wait
    {X86_PUSH_OP,  FormatFlagsRegister},     // 0x9c - pushf
    {X86_POP_OP,   FormatFlagsRegister},     // 0x9d - popf
    {X86_SAHF_OP,  FormatNoOperands},        // 0x9e - sahf
    {X86_LAHF_OP,  FormatNoOperands},        // 0x9f - lahf
    {X86_MOV_OP,   FormatSegmentOffset},     // 0xa0 - mov AL,Ob
    {X86_MOV_OP,   FormatSegmentOffset},     // 0xa1 - mov eAX,Ov
    {X86_MOV_OP,   FormatSegmentOffset},     // 0xa2 - mov Ob,AL
    {X86_MOV_OP,   FormatSegmentOffset},     // 0xa3 - mov Ov,eAX
    {X86_MOVS_OP,  FormatStringOperands},    // 0xa4 - movsb
    {X86_MOVS_OP,  FormatStringOperands},    // 0xa5 - movsw/d
    {X86_CMPS_OP,  FormatStringOperands},    // 0xa6 - cmpsb
    {X86_CMPS_OP,  FormatStringOperands},    // 0xa7 - cmpsw/d
    {X86_TEST_OP,  FormatAccumImmediate},    // 0xa8 - test AL,Ib
    {X86_TEST_OP,  FormatAccumImmediate},    // 0xa9 - test eAX,Iv
    {X86_STOS_OP,  FormatStringOperands},    // 0xaa - stosb
    {X86_STOS_OP,  FormatStringOperands},    // 0xab - stosw/d
    {X86_LODS_OP,  FormatStringOperands},    // 0xac - lodsb
    {X86_LODS_OP,  FormatStringOperands},    // 0xad - lodsw.d
    {X86_SCAS_OP,  FormatStringOperands},    // 0xae - scasb
    {X86_SCAS_OP,  FormatStringOperands},    // 0xaf - scasw/d
    {X86_MOV_OP,   FormatMoveRegImmediate},  // 0xb0 mov AL,Ib
    {X86_MOV_OP,   FormatMoveRegImmediate},  // 0xb1 mov Cl,Ib
    {X86_MOV_OP,   FormatMoveRegImmediate},  // 0xb2 mov DL,Ib
    {X86_MOV_OP,   FormatMoveRegImmediate},  // 0xb3 mov BL,Ib
    {X86_MOV_OP,   FormatMoveRegImmediate},  // 0xb4 mov AH,Ib
    {X86_MOV_OP,   FormatMoveRegImmediate},  // 0xb5 mov CH,Ib
    {X86_MOV_OP,   FormatMoveRegImmediate},  // 0xb6 mov DH,Ib
    {X86_MOV_OP,   FormatMoveRegImmediate},  // 0xb7 mov BH,Ib
    {X86_MOV_OP,   FormatMoveRegImmediate},  // 0xb8 mov eAX,Iv
    {X86_MOV_OP,   FormatMoveRegImmediate},  // 0xb9 mov eCX,Iv
    {X86_MOV_OP,   FormatMoveRegImmediate},  // 0xba mov eDX,Iv
    {X86_MOV_OP,   FormatMoveRegImmediate},  // 0xbb mov eBX,Iv
    {X86_MOV_OP,   FormatMoveRegImmediate},  // 0xbc mov eSP,Iv
    {X86_MOV_OP,   FormatMoveRegImmediate},  // 0xbd mov eBP,Iv
    {X86_MOV_OP,   FormatMoveRegImmediate},  // 0xbe mov eSI,Iv
    {X86_MOV_OP,   FormatMoveRegImmediate},  // 0xbf mov eDI,Iv
    {X86_ROL_OP,   FormatGroup2ByByte},      // 0xc0 - group2 Eb,Ib
    {X86_ROL_OP,   FormatGroup2ByByte},      // 0xc1 - group2 Ev,Ib
    {X86_RET_OP,   FormatNoOperands},        // 0xc2 - ret Iw (near)
    {X86_RET_OP,   FormatNoOperands},        // 0xc3 - ret (near)
    {X86_MOV_OP,   FormatLoadSegmentES},     // 0xc4 - les Gv,Mp
    {X86_MOV_OP,   FormatLoadSegmentDS},     // 0xc5 - lds Gv,Mp
    {X86_MOV_OP,   FormatMoveImmediate},     // 0xc6 - mov Eb,Ib
    {X86_MOV_OP,   FormatMoveImmediate},     // 0xc7 - mov Ev,Iv
    {X86_ENTER_OP, FormatImmediateEnter},    // 0xc8 - enter Iw,Ib
    {X86_LEAVE_OP, FormatNoOperands},        // 0xc9 - leave
    {X86_RET_OP,   FormatNoOperands},        // 0xca - ret Iw (far)
    {X86_RET_OP,   FormatNoOperands},        // 0xcb - ret (far)
    {X86_INT_OP,   FormatNoOperands},        // 0xcc - int 3
    {X86_INT_OP,   FormatByteImmediate},     // 0xcd - int Ib
    {X86_INT_OP,   FormatNoOperands},        // 0xce - into
    {X86_IRET_OP,  FormatNoOperands},        // 0xcf - iret
    {X86_ROL_OP,   FormatGroup2By1},         // 0xd0 - group2 Eb,1
    {X86_ROL_OP,   FormatGroup2By1},         // 0xd1 - group2 Ev,1
    {X86_ROL_OP,   FormatGroup2ByCL},        // 0xd2 - group2 Eb,CL
    {X86_ROL_OP,   FormatGroup2ByCL},        // 0xd3 - group2 Ev,CL
    {X86_AAM_OP,   FormatByteImmediate},     // 0xd4 - aam
    {X86_AAD_OP,   FormatByteImmediate},     // 0xd5 - aad
    {X86_ILL_OP,   FormatNoOperands},        // 0xd6 - illegal
    {X86_MOV_OP,   FormatXlatOpcode},        // 0xd7 - xlat
    {X86_ILL_OP,   FormatNoOperands},        // 0xd8 - esc0
    {X86_ILL_OP,   FormatNoOperands},        // 0xd9 - esc1
    {X86_ILL_OP,   FormatNoOperands},        // 0xda - esc2
    {X86_ILL_OP,   FormatNoOperands},        // 0xdb - esc3
    {X86_ILL_OP,   FormatNoOperands},        // 0xdc - esc4
    {X86_ILL_OP,   FormatNoOperands},        // 0xdd - esc5
    {X86_ILL_OP,   FormatNoOperands},        // 0xde - esc6
    {X86_ILL_OP,   FormatNoOperands},        // 0xdf - esc7
    {X86_LOOP_OP,  FormatShortJump},         // 0xe0 - loopnz
    {X86_LOOP_OP,  FormatShortJump},         // 0xe1 - loopz
    {X86_LOOP_OP,  FormatShortJump},         // 0xe2 - loop
    {X86_JCXZ_OP,  FormatShortJump},         // 0xe3 - jcxz
    {X86_IN_OP,    FormatPortImmediate},     // 0xe4 - inb AL,Ib
    {X86_IN_OP,    FormatPortImmediate},     // 0xe5 - inw/d eAX,Ib
    {X86_OUT_OP,   FormatPortImmediate},     // 0xe6 - outb Ib,AL
    {X86_OUT_OP,   FormatPortImmediate},     // 0xe7 - outw/d Ib,eAX
    {X86_CALL_OP,  FormatLongJump},          // 0xe8 - call Jv
    {X86_JMP_OP,   FormatLongJump},          // 0xe9 - jmp Jv
    {X86_JMP_OP,   FormatImmediateJump},     // 0xea - jmp Ap
    {X86_JMP_OP,   FormatShortJump},         // 0xeb - jmp Jb
    {X86_IN_OP,    FormatPortDX},            // 0xec - inb AL,DX
    {X86_IN_OP,    FormatPortDX},            // 0xed - inw/d eAX,DX
    {X86_OUT_OP,   FormatPortDX},            // 0xee - outb Ib,DX
    {X86_OUT_OP,   FormatPortDX},            // 0xef - outw/d eAX,DX
    {X86_LOCK_OP,  FormatPrefixOpcode},      // 0xf0 - lock
    {X86_ILL_OP,   FormatNoOperands},        // 0xf1 - illegal
    {X86_REPNZ_OP, FormatPrefixOpcode},      // 0xf2 - repnz
    {X86_REPZ_OP,  FormatPrefixOpcode},      // 0xf3 - repz
    {X86_HLT_OP,   FormatNoOperands},        // 0xf4 - hlt
    {X86_CMC_OP,   FormatNoOperands},        // 0xf5 - cmc
    {X86_TEST_OP,  FormatGroup3General},     // 0xf6 - group3 Eb,?
    {X86_TEST_OP,  FormatGroup3General},     // 0xf7 - group3 Ev,?
    {X86_CLC_OP,   FormatNoOperands},        // 0xf8 - clc
    {X86_STC_OP,   FormatNoOperands},        // 0xf9 - stc
    {X86_CLI_OP,   FormatNoOperands},        // 0xfa - cli
    {X86_STI_OP,   FormatNoOperands},        // 0xfb - sti
    {X86_CLD_OP,   FormatNoOperands},        // 0xfc - cld
    {X86_STD_OP,   FormatNoOperands},        // 0xfd - std
    {X86_INC_OP,   FormatGroup4General},     // 0xfe - group4 Eb
    {X86_INC_OP,   FormatGroup5General},     // 0xff - group5 Ev
};

const OPCODE_CONTROL XmOpcodeControlTable2[] = {
    {X86_ILL_OP,   FormatNoOperands},        // 0x00 - group6
    {X86_ILL_OP,   FormatNoOperands},        // 0x01 - group7
    {X86_ILL_OP,   FormatNoOperands},        // 0x02 - lar
    {X86_ILL_OP,   FormatNoOperands},        // 0x03 - lsl
    {X86_ILL_OP,   FormatNoOperands},        // 0x04 - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0x05 - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0x06 - clts
    {X86_ILL_OP,   FormatNoOperands},        // 0x07 - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0x08 - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0x09 - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0x0a - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0x0b - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0x0c - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0x0d - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0x0e - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0x0f - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0x10 - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0x11 - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0x12 - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0x13 - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0x14 - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0x15 - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0x16 - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0x17 - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0x18 - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0x19 - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0x1a - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0x1b - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0x1c - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0x1d - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0x1e - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0x1f - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0x20 - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0x21 - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0x22 - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0x23 - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0x34 - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0x25 - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0x26 - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0x27 - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0x28 - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0x29 - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0x2a - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0x2b - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0x2c - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0x2d - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0x2e - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0x2f - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0x30 - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0x31 - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0x32 - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0x33 - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0x34 - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0x35 - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0x36 - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0x37 - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0x38 - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0x39 - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0x3a - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0x3b - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0x3c - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0x3d - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0x3e - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0x3f - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0x40 - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0x41 - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0x42 - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0x43 - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0x44 - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0x45 - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0x46 - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0x47 - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0x48 - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0x49 - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0x4a - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0x4b - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0x4c - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0x4d - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0x4e - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0x4f - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0x50 - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0x51 - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0x52 - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0x53 - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0x54 - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0x55 - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0x56 - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0x57 - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0x58 - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0x59 - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0x5a - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0x5b - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0x5c - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0x5d - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0x5e - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0x5f - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0x60 - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0x61 - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0x62 - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0x63 - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0x64 - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0x65 - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0x66 - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0x67 - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0x68 - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0x69 - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0x6a - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0x6b - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0x6c - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0x6d - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0x6e - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0x6f - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0x70 - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0x71 - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0x72 - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0x73 - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0x74 - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0x75 - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0x76 - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0x77 - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0x78 - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0x79 - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0x7a - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0x7b - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0x7c - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0x7d - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0x7e - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0x7f - illegal
    {X86_JXX_OP,   FormatLongJump},          // 0x80 - jo   jv
    {X86_JXX_OP,   FormatLongJump},          // 0x81 - jno  jv
    {X86_JXX_OP,   FormatLongJump},          // 0x82 - jb   jv
    {X86_JXX_OP,   FormatLongJump},          // 0x83 - jnb  jv
    {X86_JXX_OP,   FormatLongJump},          // 0x84 - jz   jv
    {X86_JXX_OP,   FormatLongJump},          // 0x85 - jnz  jv
    {X86_JXX_OP,   FormatLongJump},          // 0x86 - jbe  jv
    {X86_JXX_OP,   FormatLongJump},          // 0x87 - jnbe jv
    {X86_JXX_OP,   FormatLongJump},          // 0x88 - js   jv
    {X86_JXX_OP,   FormatLongJump},          // 0x89 - jns  jv
    {X86_JXX_OP,   FormatLongJump},          // 0x8a - jp   jv
    {X86_JXX_OP,   FormatLongJump},          // 0x8b - jnp  jv
    {X86_JXX_OP,   FormatLongJump},          // 0x8c - jl   jv
    {X86_JXX_OP,   FormatLongJump},          // 0x8d - jnl  jv
    {X86_JXX_OP,   FormatLongJump},          // 0x8e - jle  jv
    {X86_JXX_OP,   FormatLongJump},          // 0x8f - jnle jv
    {X86_SXX_OP,   FormatSetccByte},         // 0x90 - seto   Eb
    {X86_SXX_OP,   FormatSetccByte},         // 0x91 - setno  Eb
    {X86_SXX_OP,   FormatSetccByte},         // 0x92 - setb   Eb
    {X86_SXX_OP,   FormatSetccByte},         // 0x93 - setnb  Eb
    {X86_SXX_OP,   FormatSetccByte},         // 0x94 - setz   Eb
    {X86_SXX_OP,   FormatSetccByte},         // 0x95 - setnz  Eb
    {X86_SXX_OP,   FormatSetccByte},         // 0x96 - setbe  Eb
    {X86_SXX_OP,   FormatSetccByte},         // 0x97 - setnbe Eb
    {X86_SXX_OP,   FormatSetccByte},         // 0x98 - sets   Eb
    {X86_SXX_OP,   FormatSetccByte},         // 0x99 - setns  Eb
    {X86_SXX_OP,   FormatSetccByte},         // 0x9a - setp   Eb
    {X86_SXX_OP,   FormatSetccByte},         // 0x9b - setnp  Eb
    {X86_SXX_OP,   FormatSetccByte},         // 0x9c - setl   Eb
    {X86_SXX_OP,   FormatSetccByte},         // 0x9d - setnl  Eb
    {X86_SXX_OP,   FormatSetccByte},         // 0x9e - setle  Eb
    {X86_SXX_OP,   FormatSetccByte},         // 0x9f - setnle Eb
    {X86_PUSH_OP,  FormatSegmentFS},         // 0xa0 - push FS
    {X86_POP_OP,   FormatSegmentFS},         // 0xa1 - pop  FS
    {X86_ILL_OP,   FormatNoOperands},        // 0xa2 - illegal
    {X86_BT_OP,    FormatGeneralBitOffset},  // 0xa3 - bt Ev,Gv
    {X86_SHLD_OP,  FormatShiftDouble},       // 0xa4 - shld Ev,Gv,Ib
    {X86_SHLD_OP,  FormatShiftDouble},       // 0xa5 - shld Ev,Gv,cl
    {X86_ILL_OP,   FormatNoOperands},        // 0xa6 - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0xa6 - illegal
    {X86_PUSH_OP,  FormatSegmentGS},         // 0xa8 - push GS
    {X86_POP_OP,   FormatSegmentGS},         // 0xa9 - pop  GS
    {X86_ILL_OP,   FormatNoOperands},        // 0xaa - illegal
    {X86_BTS_OP,   FormatGeneralBitOffset},  // 0xab - bts Ev,Gv
    {X86_SHRD_OP,  FormatShiftDouble},       // 0xac - shdr Ev,Gv,Ib
    {X86_SHRD_OP,  FormatShiftDouble},       // 0xad - shdr Rv,Gv,cl
    {X86_ILL_OP,   FormatNoOperands},        // 0xae - illegal
    {X86_IMUL_OP,  FormatGroup1General},     // 0xaf - imul Gv,Ev
    {X86_CMPXCHG_OP, FormatGroup1General},   // 0xb0 - cmpxchg Eb,Gb
    {X86_CMPXCHG_OP, FormatGroup1General},   // 0xb1 - cmpxchg Ev,Gv
    {X86_MOV_OP,   FormatLoadSegmentSS},     // 0xb2 - lss Gv,Mp
    {X86_BTR_OP,   FormatGeneralBitOffset},  // 0xb3 - btr Ev,Gv
    {X86_MOV_OP,   FormatLoadSegmentFS},     // 0xb4 - lfs Gv,Mp
    {X86_MOV_OP,   FormatLoadSegmentGS},     // 0xb5 - lgd Gv,Mp
    {X86_MOV_OP,   FormatMoveXxGeneral},     // 0xb6 - movzb Gv,Eb
    {X86_MOV_OP,   FormatMoveXxGeneral},     // 0xb7 - movsw Gv,Ew
    {X86_ILL_OP,   FormatNoOperands},        // 0xb8 - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0xb9 - illegal
    {X86_BT_OP,    FormatGroup8BitOffset},   // 0xba - group8 Ev,Ib
    {X86_BTC_OP,   FormatGeneralBitOffset},  // 0xbb - btc Ev,Gv
    {X86_BSF_OP,   FormatBitScanGeneral},    // 0xbc - bsf Gv,Ev
    {X86_BSR_OP,   FormatBitScanGeneral},    // 0xbd - bsr Gv,Ev
    {X86_MOV_OP,   FormatMoveXxGeneral},     // 0xbe - movsb Gv,Eb
    {X86_MOV_OP,   FormatMoveXxGeneral},     // 0xbf - movsw Gv,Ew
    {X86_XADD_OP,  FormatGroup1General},     // 0xc0 - xadd Eb,Gb
    {X86_XADD_OP,  FormatGroup1General},     // 0xc1 - xadd Ev,Gv
    {X86_ILL_OP,   FormatNoOperands},        // 0xc2 - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0xc3 - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0xc4 - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0xc5 - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0xc6 - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0xc7 - illegal
    {X86_BSWAP_OP, FormatGeneralRegister},   // 0xc8 - bswap Gv
    {X86_ILL_OP,   FormatNoOperands},        // 0xc9 - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0xca - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0xcb - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0xcc - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0xcd - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0xce - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0xcf - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0xd0 - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0xd1 - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0xd2 - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0xd3 - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0xd4 - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0xd5 - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0xd6 - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0xd7 - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0xd8 - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0xd9 - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0xda - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0xdb - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0xdc - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0xdd - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0xde - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0xdf - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0xe0 - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0xe1 - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0xe2 - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0xe3 - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0xe4 - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0xe5 - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0xe6 - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0xe7 - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0xe8 - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0xe9 - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0xea - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0xeb - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0xec - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0xed - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0xee - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0xef - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0xf0 - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0xf1 - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0xf2 - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0xf3 - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0xf4 - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0xf5 - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0xf6 - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0xf7 - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0xf8 - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0xf9 - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0xfa - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0xfb - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0xfc - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0xfd - illegal
    {X86_ILL_OP,   FormatNoOperands},        // 0xfe - illegal
    {X86_ILL_OP,   FormatNoOperands}         // 0xff - illegal
};

//
// Define opcode name tables.
//

#if defined(XM_DEBUG)

const PCHAR XmOpcodeNameTable1[] = {
    "add Eb,Gb    ", // 0x00
    "add Ev,Gv    ", // 0x01
    "add Gb,Eb    ", // 0x02
    "add Gv,Ev    ", // 0x03
    "add AL,Ib    ", // 0x04
    "add eAX,Iv   ", // 0x05
    "push ES      ", // 0x06
    "pop  ES      ", // 0x07
    "or  Eb,Gb    ", // 0x08
    "or  Ev,Gv    ", // 0x09
    "or  Gb,Eb    ", // 0x0a
    "or  Gv,Ev    ", // 0x0b
    "or  AL,Ib    ", // 0x0c
    "or  eAX,Iv   ", // 0x0d
    "push CS      ", // 0x0e
    "escape:      ", // 0x0f
    "adc Eb,Gb    ", // 0x10
    "adc Ev,Gv    ", // 0x11
    "adc Gb,Eb    ", // 0x12
    "adc Gv,Ev    ", // 0x13
    "adc AL,Ib    ", // 0x14
    "adc eAX,Iv   ", // 0x15
    "push SS      ", // 0x16
    "pop  SS      ", // 0x17
    "sbb Eb,Gb    ", // 0x18
    "sbb Ev,Gv    ", // 0x19
    "sbb Gb,Eb    ", // 0x1a
    "sbb Gv,Ev    ", // 0x1b
    "sbb AL,Ib    ", // 0x1c
    "sbb eAX,Iv   ", // 0x1d
    "push DS      ", // 0x1e
    "pop  DS      ", // 0x1f
    "and Eb,Gb    ", // 0x20
    "and Ev,Gv    ", // 0x21
    "and Gb,Eb    ", // 0x22
    "and Gv,Ev    ", // 0x23
    "and AL,Ib    ", // 0x24
    "and eAX,Iv   ", // 0x25
    "ES:          ", // 0x26
    "daa          ", // 0x27
    "sub Eb,Gb    ", // 0x28
    "sub Ev,Gv    ", // 0x29
    "sub Gb,Eb    ", // 0x2a
    "sub Gv,Ev    ", // 0x2b
    "sub AL,Ib    ", // 0x2c
    "sub eAX,Iv   ", // 0x2d
    "CS:          ", // 0x2e
    "das          ", // 0x2f
    "xor Eb,Gb    ", // 0x30
    "xor Ev,Gv    ", // 0x31
    "xor Gb,Eb    ", // 0x32
    "xor Gv,Ev    ", // 0x33
    "xor AL,Ib    ", // 0x34
    "xor eAX,Iv   ", // 0x35
    "SS:          ", // 0x36
    "aaa          ", // 0x37
    "cmp Eb,Gb    ", // 0x38
    "cmp Ev,Gv    ", // 0x39
    "cmp Gb,Eb    ", // 0x3a
    "cmp Gv,Ev    ", // 0x3b
    "cmp AL,Ib    ", // 0x3c
    "cmp eAX,Iv   ", // 0x3d
    "DS:          ", // 0x3e
    "aas          ", // 0x3f
    "inc eAX      ", // 0x40
    "inc eCX      ", // 0x41
    "inc eDX      ", // 0x42
    "inc eBX      ", // 0x43
    "inc eSP      ", // 0x44
    "inc eBP      ", // 0x45
    "inc eSI      ", // 0x46
    "inc eDI      ", // 0x47
    "dec eAX      ", // 0x48
    "dec eCX      ", // 0x49
    "dec eDX      ", // 0x4a
    "dec eBX      ", // 0x4b
    "dec eSP      ", // 0x4c
    "dec eBP      ", // 0x4d
    "dec eSI      ", // 0x4e
    "dec eDI      ", // 0x4f
    "push eAX     ", // 0x50
    "push eCX     ", // 0x51
    "push eDX     ", // 0x52
    "push eBX     ", // 0x53
    "push eSP     ", // 0x54
    "push eBP     ", // 0x55
    "push eSI     ", // 0x56
    "push eDI     ", // 0x57
    "pop eAX      ", // 0x58
    "pop eCX      ", // 0x59
    "pop eDX      ", // 0x5a
    "pop eBX      ", // 0x5b
    "pop eSP      ", // 0x5c
    "pop eBP      ", // 0x5d
    "pop eSI      ", // 0x5e
    "pop eDI      ", // 0x5f
    "pusha        ", // 0x60
    "popa         ", // 0x61
    "bound Gv,Ma  ", // 0x62
    "arpl Ew,Rw   ", // 0x63
    "FS:          ", // 0x64
    "GS:          ", // 0x65
    "opsize:      ", // 0x66
    "opaddr:      ", // 0x67
    "push Iv      ", // 0x68
    "imul Gv,Ev,Iv ", // 0x69
    "push Ib      ", // 0x6a
    "imul Gv,Ev,Ib ", // 0x6b
    "insb         ", // 0x6c
    "insw/d       ", // 0x6d
    "outsb        ", // 0x6e
    "outsw/d      ", // 0x6f
    "jo Jb        ", // 0x70
    "jno Jb       ", // 0x71
    "jb Jb        ", // 0x72
    "jnb Jb       ", // 0x73
    "jz Jb        ", // 0x74
    "jnz Jb       ", // 0x75
    "jbe Jb       ", // 0x76
    "jnbe Jb      ", // 0x77
    "js Jb        ", // 0x78
    "jns Jb       ", // 0x79
    "jp Jb        ", // 0x7a
    "jnp Jb       ", // 0x7b
    "jl Jb        ", // 0x7c
    "jnl Jb       ", // 0x7d
    "jle Jb       ", // 0x7e
    "jnle Jb      ", // 0x7f
    "group1 Eb,Ib ", // 0x80
    "group1 Ev,Ib ", // 0x81
    "illegal      ", // 0x82
    "group1 Ev,Ib ", // 0x83
    "test Eb,Gb   ", // 0x84
    "test Ev,Gv   ", // 0x85
    "xchg Eb,Gb   ", // 0x86
    "xchg Ev,Gv   ", // 0x87
    "mov Eb,Gb    ", // 0x88
    "mov Ev,Gv    ", // 0x89
    "mov Gb,Eb    ", // 0x8a
    "mov Gv,Ev    ", // 0x8b
    "mov Ew,Sw    ", // 0x8c
    "lea Gv,Ma    ", // 0x8d
    "mov Sw,Ew    ", // 0x8e
    "pop Ev       ", // 0x8f
    "nop          ", // 0x90
    "xchg eCX,eAX ", // 0x91
    "xchg eDX,eAX ", // 0x92
    "xchg eBX,eAX ", // 0x93
    "xchg eSP,eAX ", // 0x94
    "xchg eBP,eAX ", // 0x95
    "xchg eSI,eAX ", // 0x96
    "xchg eDI,eAX ", // 0x97
    "cbw          ", // 0x98
    "cwd          ", // 0x99
    "call Ap      ", // 0x9a
    "wait         ", // 0x9b
    "pushf        ", // 0x9c
    "popf         ", // 0x9d
    "sahf         ", // 0x9e
    "lahf         ", // 0x9f
    "mov AL,Ob    ", // 0xa0
    "mov eAX,Ov   ", // 0xa1
    "mov Ob,AL    ", // 0xa2
    "mov Ov,eAX   ", // 0xa3
    "movsb        ", // 0xa4
    "movsw/d      ", // 0xa5
    "cmpsb        ", // 0xa6
    "cmpsw/d      ", // 0xa7
    "test AL,Ib   ", // 0xa8
    "test eAX,Iv  ", // 0xa9
    "stosb        ", // 0xaa
    "stosw/d      ", // 0xab
    "lodsb        ", // 0xac
    "lodsw/d      ", // 0xad
    "scasb        ", // 0xae
    "scasw/d      ", // 0xaf
    "mov AL,Ib    ", // 0xb0
    "mov Cl,Ib    ", // 0xb1
    "mov DL,Ib    ", // 0xb2
    "mov BL,Ib    ", // 0xb3
    "mov AH,Ib    ", // 0xb4
    "mov CH,Ib    ", // 0xb5
    "mov DH,Ib    ", // 0xb6
    "mov BH,Ib    ", // 0xb7
    "mov eAX,Iv   ", // 0xb8
    "mov eCX,Iv   ", // 0xb9
    "mov eDX,Iv   ", // 0xba
    "mov eBX,Iv   ", // 0xbb
    "mov eSP,Iv   ", // 0xbc
    "mov eBP,Iv   ", // 0xbd
    "mov eSI,Iv   ", // 0xbe
    "mov eDI,Iv   ", // 0xbf
    "group2 Eb,Ib ", // 0xc0
    "group2 Ev,Ib ", // 0xc1
    "ret Iw near  ", // 0xc2
    "ret near     ", // 0xc3
    "les Gv,Mp    ", // 0xc4
    "lds Gv,Mp    ", // 0xc5
    "mov Eb,Ib    ", // 0xc6
    "mov Ev,Iv    ", // 0xc7
    "enter Iw,Ib  ", // 0xc8
    "leave        ", // 0xc9
    "ret Iw far   ", // 0xca
    "ret far      ", // 0xcb
    "int 3        ", // 0xcc
    "int Ib       ", // 0xcd
    "into         ", // 0xce
    "iret         ", // 0xcf
    "group2 Eb,1  ", // 0xd0
    "group2 Ev,1  ", // 0xd1
    "group2 Eb,CL ", // 0xd2
    "group2 Ev,Cl ", // 0xd3
    "aam          ", // 0xd4
    "aad          ", // 0xd5
    "illegal      ", // 0xd6
    "xlat         ", // 0xd7
    "illegal      ", // 0xd8
    "illegal      ", // 0xd9
    "illegal      ", // 0xda
    "illegal      ", // 0xdb
    "illegal      ", // 0xdc
    "illegal      ", // 0xdd
    "illegal      ", // 0xde
    "illegal      ", // 0xdf
    "loopnz       ", // 0xe0
    "loopz        ", // 0xe1
    "loop         ", // 0xe2
    "jcxz         ", // 0xe3
    "inb AL,Ib    ", // 0xe4
    "inw/d eAX,Ib ", // 0xe5
    "outb Ib,AL   ", // 0xe6
    "outw/d Ib,eAX ", // 0xe7
    "call Jv      ", // 0xe8
    "jmp Jv       ", // 0xe9
    "jmp Ap       ", // 0xea
    "jmp Jb       ", // 0xeb
    "inb AL,DX    ", // 0xec
    "inw/d Ib,DX  ", // 0xed
    "outb DX,AL   ", // 0xee
    "outw/d DX,eAX ", // 0xef
    "lock:        ", // 0xf0
    "illegal      ", // 0xf1
    "repnz:       ", // 0xf2
    "repz:        ", // 0xf3
    "hlt          ", // 0xf4
    "cmc          ", // 0xf5
    "group3 Eb,?  ", // 0xf6
    "group3 Ev,?  ", // 0xf7
    "clc          ", // 0xf8
    "stc          ", // 0xf9
    "cli          ", // 0xfa
    "sti          ", // 0xfb
    "cld          ", // 0xfc
    "std          ", // 0xfd
    "group4 Eb    ", // 0xfe
    "group5 Ev    "  // 0xff
};

const PCHAR XmOpcodeNameTable2[] = {
    "group6       ", // 0x00
    "group7       ", // 0x01
    "lar          ", // 0x02
    "lsl          ", // 0x03
    "illegal      ", // 0x04
    "illegal      ", // 0x05
    "clts         ", // 0x06
    "illegal      ", // 0x07
    "illegal      ", // 0x08
    "illegal      ", // 0x09
    "illegal      ", // 0x0a
    "illegal      ", // 0x0b
    "illegal      ", // 0x0c
    "illegal      ", // 0x0d
    "illegal      ", // 0x0e
    "illegal      ", // 0x0f
    "illegal      ", // 0x10
    "illegal      ", // 0x11
    "illegal      ", // 0x12
    "illegal      ", // 0x13
    "illegal      ", // 0x14
    "illegal      ", // 0x15
    "illegal      ", // 0x16
    "illegal      ", // 0x17
    "illegal      ", // 0x18
    "illegal      ", // 0x19
    "illegal      ", // 0x1a
    "illegal      ", // 0x1b
    "illegal      ", // 0x1c
    "illegal      ", // 0x1d
    "illegal      ", // 0x1e
    "illegal      ", // 0x1f
    "mov Cd,Rd    ", // 0x20
    "mov Dd,Rd    ", // 0x21
    "mov Rd,Cd    ", // 0x22
    "mov Rd,Dd    ", // 0x23
    "mov Td,Rd    ", // 0x24
    "illegal      ", // 0x25
    "mov Rd,Td    ", // 0x26
    "illegal      ", // 0x27
    "illegal      ", // 0x28
    "illegal      ", // 0x29
    "illegal      ", // 0x2a
    "illegal      ", // 0x2b
    "illegal      ", // 0x2c
    "illegal      ", // 0x2d
    "illegal      ", // 0x2e
    "illegal      ", // 0x2f
    "illegal      ", // 0x30
    "illegal      ", // 0x31
    "illegal      ", // 0x32
    "illegal      ", // 0x33
    "illegal      ", // 0x34
    "illegal      ", // 0x35
    "illegal      ", // 0x36
    "illegal      ", // 0x37
    "illegal      ", // 0x38
    "illegal      ", // 0x39
    "illegal      ", // 0x3a
    "illegal      ", // 0x3b
    "illegal      ", // 0x3c
    "illegal      ", // 0x3d
    "illegal      ", // 0x3e
    "illegal      ", // 0x3f
    "illegal      ", // 0x40
    "illegal      ", // 0x41
    "illegal      ", // 0x42
    "illegal      ", // 0x43
    "illegal      ", // 0x44
    "illegal      ", // 0x45
    "illegal      ", // 0x46
    "illegal      ", // 0x47
    "illegal      ", // 0x48
    "illegal      ", // 0x49
    "illegal      ", // 0x4a
    "illegal      ", // 0x4b
    "illegal      ", // 0x4c
    "illegal      ", // 0x4d
    "illegal      ", // 0x4e
    "illegal      ", // 0x4f
    "illegal      ", // 0x50
    "illegal      ", // 0x51
    "illegal      ", // 0x52
    "illegal      ", // 0x53
    "illegal      ", // 0x54
    "illegal      ", // 0x55
    "illegal      ", // 0x56
    "illegal      ", // 0x57
    "illegal      ", // 0x58
    "illegal      ", // 0x59
    "illegal      ", // 0x5a
    "illegal      ", // 0x5b
    "illegal      ", // 0x5c
    "illegal      ", // 0x5d
    "illegal      ", // 0x5e
    "illegal      ", // 0x5f
    "illegal      ", // 0x60
    "illegal      ", // 0x61
    "illegal      ", // 0x62
    "illegal      ", // 0x63
    "illegal      ", // 0x64
    "illegal      ", // 0x65
    "illegal      ", // 0x66
    "illegal      ", // 0x67
    "illegal      ", // 0x68
    "illegal      ", // 0x69
    "illegal      ", // 0x6a
    "illegal      ", // 0x6b
    "illegal      ", // 0x6c
    "illegal      ", // 0x6d
    "illegal      ", // 0x6e
    "illegal      ", // 0x6f
    "illegal      ", // 0x70
    "illegal      ", // 0x71
    "illegal      ", // 0x72
    "illegal      ", // 0x73
    "illegal      ", // 0x74
    "illegal      ", // 0x75
    "illegal      ", // 0x76
    "illegal      ", // 0x77
    "illegal      ", // 0x78
    "illegal      ", // 0x79
    "illegal      ", // 0x7a
    "illegal      ", // 0x7b
    "illegal      ", // 0x7c
    "illegal      ", // 0x7d
    "illegal      ", // 0x7e
    "illegal      ", // 0x7f
    "jo Jv        ", // 0x80
    "jno Jv       ", // 0x81
    "jb Jv        ", // 0x82
    "jnb Jv       ", // 0x83
    "jz Jv        ", // 0x84
    "jnz Jv       ", // 0x85
    "jbe Jv       ", // 0x86
    "jnbe Jv      ", // 0x87
    "js Jv        ", // 0x88
    "jns Jv       ", // 0x89
    "jp Jv        ", // 0x8a
    "jnp Jv       ", // 0x8b
    "jl Jv        ", // 0x8c
    "jnl Jv       ", // 0x8d
    "jle Jv       ", // 0x8e
    "jnle Jv      ", // 0x8f
    "seto         ", // 0x90
    "setno        ", // 0x91
    "setb         ", // 0x92
    "setnb        ", // 0x93
    "setz         ", // 0x94
    "setnz        ", // 0x95
    "setbe        ", // 0x96
    "setnbe       ", // 0x97
    "sets         ", // 0x98
    "setns        ", // 0x99
    "setp         ", // 0x9a
    "setnp        ", // 0x9b
    "setl         ", // 0x9c
    "setnl        ", // 0x9d
    "setle        ", // 0x9e
    "setnle       ", // 0x9f
    "push FS      ", // 0xa0
    "pop FS       ", // 0xa1
    "illegal      ", // 0xa2
    "bt Ev,Gv     ", // 0xa3
    "shld Ev,Gv,Ib ", // 0xa4
    "Shld Ev,Gv,vl ", // 0xa5
    "illegal      ", // 0xa6
    "illegal      ", // 0xa7
    "push GS      ", // 0xa8
    "pop GS       ", // 0xa9
    "illegal      ", // 0xaa
    "bts Ev,Gv    ", // 0xab
    "shrd Ev,Gv,Ib ", // 0xac
    "shrd Ev,Gv,cl ", // 0xad
    "illegal      ", // 0xae
    "imul Gv,Ev   ", // 0xaf
    "cmpxchg Eb,Gv ", // 0xb0
    "cmpxchg Ev,Gv ", // 0xb1
    "lss Gv,Mp    ", // 0xb2
    "btr Ev,Gv    ", // 0xb3
    "lfs Gv,Mp    ", // 0xb4
    "lgs Gv,Mp    ", // 0xb5
    "movzb Gv,Eb  ", // 0xb6
    "movzw Gv,Ew  ", // 0xb7
    "illegal      ", // 0xb8
    "illegal      ", // 0xb9
    "group8 Ev,Ib ", // 0xba
    "btc Ev,Gv    ", // 0xbb
    "bsf Gv,Ev    ", // 0xbc
    "bsr Gv,Ev    ", // 0xbd
    "movsb Gv,Eb  ", // 0xbe
    "movsw Gv,Ew  ", // 0xbf
    "xadd Eb,Gb   ", // 0xc0
    "xadd Ev,Gv   ", // 0xc1
    "illegal      ", // 0xc2
    "illegal      ", // 0xc3
    "illegal      ", // 0xc4
    "illegal      ", // 0xc5
    "illegal      ", // 0xc6
    "illegal      ", // 0xc7
    "bswap Gv     ", // 0xc8
    "illegal      ", // 0xc9
    "illegal      ", // 0xca
    "illegal      ", // 0xcb
    "illegal      ", // 0xcc
    "illegal      ", // 0xcd
    "illegal      ", // 0xce
    "illegal      ", // 0xcf
    "illegal      ", // 0xd0
    "illegal      ", // 0xd1
    "illegal      ", // 0xd2
    "illegal      ", // 0xd3
    "illegal      ", // 0xd4
    "illegal      ", // 0xd5
    "illegal      ", // 0xd6
    "illegal      ", // 0xd7
    "illegal      ", // 0xd8
    "illegal      ", // 0xd9
    "illegal      ", // 0xda
    "illegal      ", // 0xdb
    "illegal      ", // 0xdc
    "illegal      ", // 0xdd
    "illegal      ", // 0xde
    "illegal      ", // 0xdf
    "illegal      ", // 0xe0
    "illegal      ", // 0xe1
    "illegal      ", // 0xe2
    "illegal      ", // 0xe3
    "illegal      ", // 0xe4
    "illegal      ", // 0xe5
    "illegal      ", // 0xe6
    "illegal      ", // 0xe7
    "illegal      ", // 0xe8
    "illegal      ", // 0xe9
    "illegal      ", // 0xea
    "illegal      ", // 0xeb
    "illegal      ", // 0xec
    "illegal      ", // 0xed
    "illegal      ", // 0xee
    "illegal      ", // 0xef
    "illegal      ", // 0xf0
    "illegal      ", // 0xf1
    "illegal      ", // 0xf2
    "illegal      ", // 0xf3
    "illegal      ", // 0xf4
    "illegal      ", // 0xf5
    "illegal      ", // 0xf6
    "illegal      ", // 0xf7
    "illegal      ", // 0xf8
    "illegal      ", // 0xf9
    "illegal      ", // 0xfa
    "illegal      ", // 0xfb
    "illegal      ", // 0xfc
    "illegal      ", // 0xfd
    "illegal      ", // 0xfe
    "illegal      "  // 0xff
};

ULONG XmDebugFlags = 0x00; //0x7f;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\x86new\emulate.c ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    emulate.c

Abstract:

    This module implements an instruction level emulator for the execution
    of x86 code. It is a complete 386/486 emulator, but only implements
    real mode execution. Thus 32-bit addressing and operands are supported,
    but paging and protected mode operations are not supported. The code is
    written with the primary goals of being complete and small. Thus speed
    of emulation is not important.

Author:

    David N. Cutler (davec) 2-Sep-1994

Environment:

    Kernel mode only.

Revision History:

--*/

#include "nthal.h"
#include "emulate.h"

VOID
XmInitializeEmulator (
    IN USHORT StackSegment,
    IN USHORT StackOffset,
    IN PXM_READ_IO_SPACE ReadIoSpace,
    IN PXM_WRITE_IO_SPACE WriteIoSpace,
    IN PXM_TRANSLATE_ADDRESS TranslateAddress
    )

/*++

Routine Description:

    This function initializes the state of the x86 emulator.

Arguments:

    StackSegment - Supplies the stack segment value.

    StackOffset - Supplies the stack offset value.

    ReadIoSpace - Supplies a pointer to a the function that reads from
        I/O space given a datatype and port number.

    WriteIoSpace - Supplies a pointer to a function that writes to I/O
        space given a datatype, port number, and value.

    TranslateAddress - Supplies a pointer to the function that translates
        segment/offset address pairs into a pointer to memory or I/O space.

Return Value:

    None.

--*/

{

    LONG Index;
    PRXM_CONTEXT P = &XmContext;
    PULONG Vector;

    //
    // Clear the emulator context.
    //

    memset((PCHAR)P, 0, sizeof(XM_CONTEXT));

    //
    // Initialize the segment registers.
    //

    Index = GS;
    do {
        P->SegmentLimit[Index] = 0xffff;
        Index -= 1;
    } while (Index >= ES);

    //
    // Initialize the stack segment register and offset.
    //

    P->SegmentRegister[SS] = StackSegment;
    P->Gpr[ESP].Exx = StackOffset;

    //
    // Set the address of the read I/O space, write I/O space, and translate
    // functions.
    //

    P->ReadIoSpace = ReadIoSpace;
    P->WriteIoSpace = WriteIoSpace;
    P->TranslateAddress = TranslateAddress;

    //
    // Get address of interrupt vector table and initialize all vector to
    // point to an iret instruction at location 0x500.
    //
    //
    // N.B. It is assumed that the vector table is contiguous in emulated
    //      memory.
    //

    Vector = (PULONG)(P->TranslateAddress)(0, 0);
    Vector[0x500 / 4] = 0x000000cf;
    Index = 0;
    do {
        Vector[Index] = 0x00000500;
        Index += 1;
    } while (Index < 256);


    XmEmulatorInitialized = TRUE;
    return;
}

XM_STATUS
XmEmulateFarCall (
    IN USHORT Segment,
    IN USHORT Offset,
    IN OUT PXM86_CONTEXT Context
    )

/*++

Routine Description:

    This function emulates a far call by pushing a special exit
    sequence on the stack and then starting instruction execution
    at the address specified by the respective segment and offset.

Arguments:

    Segment - Supplies the segment in which to start execution.

    Offset - Supplies the offset within the code segment to start
        execution.

    Context - Supplies a pointer to an x86 context structure.

Return Value:

    The emulation completion status.

--*/

{

    PRXM_CONTEXT P = &XmContext;
    PUSHORT Stack;

    //
    // If the emulator has not been initialized, return an error.
    //

    if (XmEmulatorInitialized == FALSE) {
        return XM_EMULATOR_NOT_INITIALIZED;
    }

    //
    // Get address of current stack pointer, push exit markers, and
    // update stack pointer.
    //
    // N.B. It is assumed that the stack pointer is within range and
    //      contiguous in emulated memory.
    //

    Stack = (PUSHORT)(P->TranslateAddress)(P->SegmentRegister[SS], P->Gpr[SP].Xx);
    *--Stack = 0xffff;
    *--Stack = 0xffff;
    P->Gpr[SP].Xx -= 4;

    //
    // Emulate the specified instruction stream and return the final status.
    //

    return XmEmulateStream(&XmContext, Segment, Offset, Context);
}

XM_STATUS
XmEmulateInterrupt (
    IN UCHAR Interrupt,
    IN OUT PXM86_CONTEXT Context
    )

/*++

Routine Description:

    This function emulates an interrrupt by pushing a special exit
    sequence on the stack and then starting instruction execution
    at the address specified by the respective interrupt vector.

Arguments:

    Interrupt - Supplies the number of the interrupt that is emulated.

    Context - Supplies a pointer to an x86 context structure.

Return Value:

    The emulation completion status.

--*/

{

    PRXM_CONTEXT P = &XmContext;
    USHORT Segment;
    USHORT Offset;
    PUSHORT Stack;
    PULONG Vector;

    //
    // If the emulator has not been initialized, return an error.
    //

    if (XmEmulatorInitialized == FALSE) {
        return XM_EMULATOR_NOT_INITIALIZED;
    }

    //
    // Get address of current stack pointer, push exit markers, and
    // update stack pointer.
    //
    // N.B. It is assumed that the stack pointer is within range and
    //      contiguous in emulated memory.
    //

    Stack = (PUSHORT)(P->TranslateAddress)(P->SegmentRegister[SS], P->Gpr[SP].Xx);
    *--Stack = 0;
    *--Stack = 0xffff;
    *--Stack = 0xffff;
    P->Gpr[SP].Xx -= 6;

    //
    // Get address of interrupt vector table and set code segment and IP
    // values.
    //
    //
    // N.B. It is assumed that the vector table is contiguous in emulated
    //      memory.
    //

    Vector = (PULONG)(P->TranslateAddress)(0, 0);
    Segment = (USHORT)(Vector[Interrupt] >> 16);
    Offset = (USHORT)(Vector[Interrupt] & 0xffff);

    //
    // Emulate the specified instruction stream and return the final status.
    //

    return XmEmulateStream(&XmContext, Segment, Offset, Context);
}

XM_STATUS
XmEmulateStream (
    PRXM_CONTEXT P,
    IN USHORT Segment,
    IN USHORT Offset,
    IN OUT PXM86_CONTEXT Context
    )

/*++

Routine Description:

    This function establishes the specfied context and emulates the
    specified instruction stream until exit conditions are reached..

Arguments:

    Segment - Supplies the segment in which to start execution.

    Offset - Supplies the offset within the code segment to start
        execution.

    Context - Supplies a pointer to an x86 context structure.

Return Value:

    The emulation completion status.

--*/

{

    XM_STATUS Status;

    //
    // Set the x86 emulator registers from the specified context.
    //

    P->Gpr[EAX].Exx = Context->Eax;
    P->Gpr[ECX].Exx = Context->Ecx;
    P->Gpr[EDX].Exx = Context->Edx;
    P->Gpr[EBX].Exx = Context->Ebx;
    P->Gpr[EBP].Exx = Context->Ebp;
    P->Gpr[ESI].Exx = Context->Esi;
    P->Gpr[EDI].Exx = Context->Edi;
    P->SegmentRegister[DS] = Context->SegDs;
    P->SegmentRegister[ES] = Context->SegEs;

    //
    // Set the code segment, offset within segment, and emulate code.
    //

    P->SegmentRegister[CS] = Segment;
    P->Eip = Offset;
    if ((Status = setjmp(&P->JumpBuffer[0])) == 0) {

        //
        // Emulate x86 instruction stream.
        //

        do {

            //
            // Initialize instruction decode variables.
            //

            P->ComputeOffsetAddress = FALSE;
            P->DataSegment = DS;
            P->LockPrefixActive = FALSE;
            P->OpaddrPrefixActive = FALSE;
            P->OpsizePrefixActive = FALSE;
            P->RepeatPrefixActive = FALSE;
            P->SegmentPrefixActive = FALSE;
            P->OpcodeControlTable = &XmOpcodeControlTable1[0];

#if defined(XM_DEBUG)

            P->OpcodeNameTable = &XmOpcodeNameTable1[0];

#endif

            //
            // Get the next byte from the instruction stream and decode
            // operands. If the byte is a prefix or an escape, then the
            // next byte will be decoded. Decoding continues until an
            // opcode byte is reached with a terminal decode condition.
            //
            // N.B. There is no checking for legitimate sequences of prefix
            //      and/or two byte opcode escapes. Redundant or invalid
            //      prefixes or two byte escape opcodes have no effect and
            //      are benign.
            //

            do {
                P->CurrentOpcode = XmGetCodeByte(P);

#if defined(XM_DEBUG)

                if ((XmDebugFlags & TRACE_INSTRUCTIONS) != 0) {
                    DEBUG_PRINT(("\n%04lx %s %02lx ",
                                 P->Eip - 1,
                                 P->OpcodeNameTable[P->CurrentOpcode],
                                 (ULONG)P->CurrentOpcode));
                }

#endif

                P->OpcodeControl = P->OpcodeControlTable[P->CurrentOpcode];
                P->FunctionIndex = P->OpcodeControl.FunctionIndex;
            } while (XmOperandDecodeTable[P->OpcodeControl.FormatType](P) == FALSE);

            //
            // Emulate the instruction.
            //

            XmTraceFlags(P);
            XmOpcodeFunctionTable[P->FunctionIndex](P);
            XmTraceFlags(P);
            XmTraceRegisters(P);

#if defined(XM_DEBUG)

            if ((XmDebugFlags & TRACE_SINGLE_STEP) != 0) {
                DEBUG_PRINT(("\n"));
                DbgBreakPoint();
            }

#endif

        } while (TRUE);
    }

    //
    // Set the x86 return context to the current emulator registers.
    //

    Context->Eax = P->Gpr[EAX].Exx;
    Context->Ecx = P->Gpr[ECX].Exx;
    Context->Edx = P->Gpr[EDX].Exx;
    Context->Ebx = P->Gpr[EBX].Exx;
    Context->Ebp = P->Gpr[EBP].Exx;
    Context->Esi = P->Gpr[ESI].Exx;
    Context->Edi = P->Gpr[EDI].Exx;
    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\x86new\debug.c ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    debug.c

Abstract:

    This module implements utility functions.

Author:

    David N. Cutler (davec) 21-Sep-1994

Environment:

    Kernel mode only.

Revision History:

--*/

#include "nthal.h"
#include "emulate.h"

#if defined(XM_DEBUG)


//
// Define counter used to control flag tracing.
//

ULONG XmTraceCount = 0;

VOID
XmTraceDestination (
    IN PRXM_CONTEXT P,
    IN ULONG Destination
    )

/*++

Routine Description:

    This function traces the destination value if the TRACE_OPERANDS
    flag is set.

Arguments:

    P - Supplies a pointer to an emulator context structure.

    Result - Supplies the destination value to trace.

Return Value:

    None.

--*/

{

    //
    // Trace result of operation.
    //

    if ((XmDebugFlags & TRACE_OPERANDS) != 0) {
        if (P->DataType == BYTE_DATA) {
            DEBUG_PRINT(("\n    Dst - %02lx", Destination));

        } else if (P->DataType == WORD_DATA) {
            DEBUG_PRINT(("\n    Dst - %04lx", Destination));

        } else {
            DEBUG_PRINT(("\n    Dst - %08lx", Destination));
        }
    }

    return;
}

VOID
XmTraceFlags (
    IN PRXM_CONTEXT P
    )

/*++

Routine Description:

    This function traces the condition flags if the TRACE_FLAGS flag
    is set.

Arguments:

    P - Supplies a pointer to an emulator context structure.

Return Value:

    None.

--*/

{

    //
    // Trace flags.
    //

    if ((XmDebugFlags & TRACE_OPERANDS) != 0) {
        DEBUG_PRINT(("\n    OF-%lx, DF-%lx, SF-%lx, ZF-%lx, AF-%lx, PF-%lx, CF-%lx",
                     (ULONG)P->Eflags.EFLAG_OF,
                     (ULONG)P->Eflags.EFLAG_DF,
                     (ULONG)P->Eflags.EFLAG_SF,
                     (ULONG)P->Eflags.EFLAG_ZF,
                     (ULONG)P->Eflags.EFLAG_AF,
                     (ULONG)P->Eflags.EFLAG_PF,
                     (ULONG)P->Eflags.EFLAG_CF));
    }

    //
    // Increment the trace count and if the result is even, then put
    // out a new line.
    //

    XmTraceCount += 1;
    if (((XmTraceCount & 1) == 0) && (XmDebugFlags != 0)) {
        DEBUG_PRINT(("\n"));
    }

    return;
}

VOID
XmTraceJumps (
    IN PRXM_CONTEXT P
    )

/*++

Routine Description:

    This function traces jump operations if the TRACE_JUMPS flag is set.

Arguments:

    P - Supplies a pointer to an emulator context structure.

Return Value:

    None.

--*/

{

    //
    // Trace jumps.
    //

    if ((XmDebugFlags & TRACE_JUMPS) != 0) {
        DEBUG_PRINT(("\n    Jump to %04lx:%04lx",
                     (ULONG)P->SegmentRegister[CS],
                     (ULONG)P->Eip));
    }

    return;
}

VOID
XmTraceInstruction (
    IN XM_OPERATION_DATATYPE DataType,
    IN ULONG Instruction
    )

/*++

Routine Description:

    This function traces instructions if the TRACE_OPERANDS flag is
    set.

Arguments:

    DataType - Supplies the data type of the instruction value.

    Instruction - Supplies the instruction value to trace.

Return Value:

    None.

--*/

{

    //
    // Trace instruction stream of operation.
    //

    if ((XmDebugFlags & TRACE_OPERANDS) != 0) {
        if (DataType == BYTE_DATA) {
            DEBUG_PRINT(("%02lx ", Instruction));

        } else if (DataType == WORD_DATA) {
            DEBUG_PRINT(("%04lx ", Instruction));

        } else {
            DEBUG_PRINT(("%08lx ", Instruction));
        }
    }

    return;
}

VOID
XmTraceOverride (
    IN PRXM_CONTEXT P
    )

/*++

Routine Description:

    This function traces segment override prefixes.

Arguments:

    P - Supplies a pointer to an emulator context structure.

Return Value:

    None.

--*/

{

    PCHAR Name = "ECSDFG";
    ULONG Segment;

    //
    // Trace segment override.
    //

    if ((XmDebugFlags & TRACE_OVERRIDE) != 0) {
        Segment = P->DataSegment;
        DEBUG_PRINT(("\n    %cS:Selector - %04lx, Limit - %04lx",
                     (ULONG)Name[Segment],
                     (ULONG)P->SegmentRegister[Segment],
                     P->SegmentLimit[Segment]));
    }

    return;
}

VOID
XmTraceRegisters (
    IN PRXM_CONTEXT P
    )

/*++

Routine Description:

    This function traces emulator registers.

Arguments:

    P - Supplies a pointer to an emulator context structure.

Return Value:

    None.

--*/

{

    //
    // Trace general register.
    //

    if ((XmDebugFlags & TRACE_GENERAL_REGISTERS) != 0) {
        DEBUG_PRINT(("\n    EAX-%08lx ECX-%08lx EDX-%08lx EBX-%08lx",
                     P->Gpr[EAX].Exx,
                     P->Gpr[ECX].Exx,
                     P->Gpr[EDX].Exx,
                     P->Gpr[EBX].Exx));

        DEBUG_PRINT(("\n    ESP-%08lx EBP-%08lx ESI-%08lx EDI-%08lx",
                     P->Gpr[ESP].Exx,
                     P->Gpr[EBP].Exx,
                     P->Gpr[ESI].Exx,
                     P->Gpr[EDI].Exx));

        DEBUG_PRINT(("\n    ES:%04lx CS:%04lx SS:%04lx DS:%04lx FS:%04lx GS:%04lx",
                     (ULONG)P->SegmentRegister[ES],
                     (ULONG)P->SegmentRegister[CS],
                     (ULONG)P->SegmentRegister[SS],
                     (ULONG)P->SegmentRegister[DS],
                     (ULONG)P->SegmentRegister[FS],
                     (ULONG)P->SegmentRegister[GS]));
    }

    return;
}

VOID
XmTraceResult (
    IN PRXM_CONTEXT P,
    IN ULONG Result
    )

/*++

Routine Description:

    This function traces the result value if the TRACE_OPERANDS
    flag is set.

Arguments:

    P - Supplies a pointer to an emulator context structure.

    Result - Supplies the result value to trace.

Return Value:

    None.

--*/

{

    //
    // Trace result of operation.
    //

    if ((XmDebugFlags & TRACE_OPERANDS) != 0) {
        if (P->DataType == BYTE_DATA) {
            DEBUG_PRINT(("\n    Rsl - %02lx", Result));

        } else if (P->DataType == WORD_DATA) {
            DEBUG_PRINT(("\n    Rsl - %04lx", Result));

        } else {
            DEBUG_PRINT(("\n    Rsl - %08lx", Result));
        }
    }

    return;
}

VOID
XmTraceSpecifier (
    IN UCHAR Specifier
    )

/*++

Routine Description:

    This function traces the specifiern if the TRACE_OPERANDS flag is
    set.

Arguments:

    Specifier - Supplies the specifier value to trace.

Return Value:

    None.

--*/

{

    //
    // Trace instruction stream of operation.
    //

    if ((XmDebugFlags & TRACE_OPERANDS) != 0) {
        DEBUG_PRINT(("%02lx ", Specifier));
        if ((XmDebugFlags & TRACE_SPECIFIERS) != 0) {
            DEBUG_PRINT(("(mod-%01lx reg-%01lx r/m-%01lx) ",
                         (Specifier >> 6) & 0x3,
                         (Specifier >> 3) & 0x7,
                         (Specifier >> 0) & 0x7));
        }
    }

    return;
}

VOID
XmTraceSource (
    IN PRXM_CONTEXT P,
    IN ULONG Source
    )

/*++

Routine Description:

    This function traces the source value if the TRACE_OPERANDS
    flag is set.

Arguments:

    P - Supplies a pointer to an emulator context structure.

    Source - Supplies the source value to trace.

Return Value:

    None.

--*/

{

    //
    // Trace result of operation.
    //

    if ((XmDebugFlags & TRACE_OPERANDS) != 0) {
        if (P->DataType == BYTE_DATA) {
            DEBUG_PRINT(("\n    Src - %02lx", Source));

        } else if (P->DataType == WORD_DATA) {
            DEBUG_PRINT(("\n    Src - %04lx", Source));

        } else {
            DEBUG_PRINT(("\n    Src - %08lx", Source));
        }
    }

    return;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\x86new\ctrlops.c ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    ctrlops.c

Abstract:

    This module implements the code to emulate call, retunr, and various
    control operations.

Author:

    David N. Cutler (davec) 10-Nov-1994

Environment:

    Kernel mode only.

Revision History:

--*/

#include "nthal.h"
#include "emulate.h"

VOID
XmCallOp (
    PRXM_CONTEXT P
    )

/*++

Routine Description:

    This function emulates a call opcode.

Arguments:

    P - Supplies a pointer to an emulator context structure.

Return Value:

    None.

--*/

{

    ULONG Target;
    ULONG Source;

    //
    // Save the target address, push the current segment, if required, and
    // push the current IP, set the destination segment, if required, and
    // set the new IP.
    //

    Target = P->DstValue.Long;
    if (P->OpsizePrefixActive != FALSE) {
        P->DataType = LONG_DATA;

    } else {
        P->DataType = WORD_DATA;
    }

    if ((P->CurrentOpcode == 0x9a) || (P->FunctionIndex != X86_CALL_OP)) {
        XmPushStack(P, P->SegmentRegister[CS]);
        XmPushStack(P, P->Eip);
        P->SegmentRegister[CS] = P->DstSegment;

    } else {
        XmPushStack(P, P->Eip);
    }

    P->Eip = Target;
    XmTraceJumps(P);
    return;
}

VOID
XmEnterOp (
    PRXM_CONTEXT P
    )

/*++

Routine Description:

    This function emulates an enter opcode.

Arguments:

    P - Supplies a pointer to an emulator context structure.

Return Value:

    None.

--*/

{

    ULONG Allocate;
    ULONG Frame;
    ULONG Number;

    //
    // set the number of bytes to allocate on the stack and the number
    // of nesting levels.
    //

    Allocate = P->SrcValue.Long;
    Number = P->DstValue.Long;

    //
    // Set the data type and save the frame pointer on the stack.
    //

    if (P->OpsizePrefixActive != FALSE) {
        P->DataType = LONG_DATA;
        XmPushStack(P, P->Gpr[EBP].Exx);
        Frame = P->Gpr[ESP].Exx;

    } else {
        P->DataType = WORD_DATA;
        XmPushStack(P, P->Gpr[BP].Xx);
        Frame = P->Gpr[SP].Xx;
    }

    //
    // Save the current stack pointer and push parameters on the stack.
    //

    if (Number != 0) {

        //
        // If the level number is not one, then raise an exception.
        //
        // N.B. Level numbers greater than one are not supported.
        //

        if (Number != 1) {
            longjmp(&P->JumpBuffer[0], XM_ILLEGAL_LEVEL_NUMBER);
        }

        XmPushStack(P, Frame);
    }

    //
    // Allocate local storage on stack.
    //

    if (P->OpsizePrefixActive != FALSE) {
        P->Gpr[EBP].Exx = Frame;
        P->Gpr[ESP].Exx = P->Gpr[ESP].Exx - Allocate;

    } else {
        P->Gpr[BP].Xx = (USHORT)Frame;
        P->Gpr[SP].Xx = (USHORT)(P->Gpr[SP].Xx - Allocate);
    }

    return;
}

VOID
XmHltOp (
    PRXM_CONTEXT P
    )

/*++

Routine Description:

    This function emulates a hlt opcode.

Arguments:

    P - Supplies a pointer to an emulator context structure.

Return Value:

    None.

--*/

{

    //
    // Halt instructions are not supported by the emulator.
    //

    longjmp(&P->JumpBuffer[0], XM_HALT_INSTRUCTION);
    return;
}

VOID
XmIntOp (
    PRXM_CONTEXT P
    )

/*++

Routine Description:

    This function emulates an int opcode.

Arguments:

    P - Supplies a pointer to an emulator context structure.

Return Value:

    None.

--*/

{

    ULONG Number;
    PULONG Vector;

    //
    // If the int instruction is an int 3, then set the interrupt vector
    // to 3. Otherwise, if the int instruction is an into, then set the
    // vector to 4 if OF is set. use the source interrupt vector.
    //

    if (P->OpsizePrefixActive != FALSE) {
        P->DataType = LONG_DATA;

    } else {
        P->DataType = WORD_DATA;
    }

    if (P->CurrentOpcode == 0xcc) {
        Number = 3;

    } else if (P->CurrentOpcode == 0xce) {
        if (P->Eflags.EFLAG_OF == 0) {
            return;
        }

        Number = 4;

    } else {
        Number = P->SrcValue.Byte;
    }

    //
    // If the vector number is 0x42, then nop the interrupt. This is the
    // standard EGA video driver entry point in a PC's motherboard BIOS
    // for which there is no code.
    //

#if !defined(_PURE_EMULATION_)

    if (Number == 0x42) {
        return;
    }

#endif

    //
    // If the vector number is 0x1a, then attempt to emulate the PCI BIOS
    // if it is enabled.
    //

#if !defined(_PURE_EMULATION_)

    if ((Number == 0x1a) && (XmExecuteInt1a(P) != FALSE)) {
        return;
    }

#endif

    //
    // Push the current flags, code segment, and EIP on the stack.
    //

    XmPushStack(P, P->AllFlags);
    XmPushStack(P, P->SegmentRegister[CS]);
    XmPushStack(P, P->Eip);

    //
    // Set the new coded segment and IP from the specified interrupt
    // vector.
    //

    Vector = (PULONG)(P->TranslateAddress)(0, 0);
    P->SegmentRegister[CS] = (USHORT)(Vector[Number] >> 16);
    P->Eip = (USHORT)(Vector[Number] & 0xffff);
    XmTraceJumps(P);
    return;
}

VOID
XmIretOp (
    PRXM_CONTEXT P
    )

/*++

Routine Description:

    This function emulates an iret opcode.

Arguments:

    P - Supplies a pointer to an emulator context structure.

Return Value:

    None.

--*/

{

    //
    // Set the data type and restore the return address, code segment,
    // and flags.
    //

    if (P->OpsizePrefixActive != FALSE) {
        P->DataType = LONG_DATA;

    } else {
        P->DataType = WORD_DATA;
    }

    P->Eip = XmPopStack(P);
    P->SegmentRegister[CS] = (USHORT)XmPopStack(P);
    P->AllFlags = XmPopStack(P);
    XmTraceJumps(P);

    //
    // Check for emulator exit conditions.
    //

    if ((P->Eip == 0xffff) && (P->SegmentRegister[CS] == 0xffff)) {
        longjmp(&P->JumpBuffer[0], XM_SUCCESS);
    }

    return;
}

VOID
XmLeaveOp (
    PRXM_CONTEXT P
    )

/*++

Routine Description:

    This function emulates a leave opcode.

Arguments:

    P - Supplies a pointer to an emulator context structure.

Return Value:

    None.

--*/

{

    //
    // Set the data type, restore the stack pointer, and restore the frame
    // pointer.
    //

    if (P->OpsizePrefixActive != FALSE) {
        P->DataType = LONG_DATA;
        P->Gpr[ESP].Exx = P->Gpr[EBP].Exx;
        P->Gpr[EBP].Exx = XmPopStack(P);

    } else {
        P->DataType = WORD_DATA;
        P->Gpr[SP].Xx = P->Gpr[BP].Xx;
        P->Gpr[BP].Xx = (USHORT)XmPopStack(P);
    }

    return;
}

VOID
XmRetOp (
    PRXM_CONTEXT P
    )

/*++

Routine Description:

    This function emulates a ret opcode.

Arguments:

    P - Supplies a pointer to an emulator context structure.

Return Value:

    None.

--*/

{

    ULONG Adjust;

    //
    // Compute the number of bytes that are to be removed from the stack
    // after having removed the return address and optionally the new CS
    // segment value.
    //

    if ((P->CurrentOpcode & 0x1) == 0) {
        Adjust = XmGetWordImmediate(P);

    } else {
        Adjust = 0;
    }

    //
    // Remove the return address from the stack and set the new IP.
    //

    if (P->OpsizePrefixActive != FALSE) {
        P->DataType = LONG_DATA;

    } else {
        P->DataType = WORD_DATA;
    }

    P->Eip = XmPopStack(P);

    //
    // If the current opcode is a far return, then remove the new CS segment
    // value from the stack.
    //

    if ((P->CurrentOpcode & 0x8) != 0) {
        P->SegmentRegister[CS] = (USHORT)XmPopStack(P);
    }

    //
    // Remove the specified number of bytes from the stack.
    //

    P->Gpr[ESP].Exx += Adjust;
    XmTraceJumps(P);

    //
    // Check for emulator exit conditions.
    //

    if ((P->Eip == 0xffff) && (P->SegmentRegister[CS] == 0xffff)) {
        longjmp(&P->JumpBuffer[0], XM_SUCCESS);
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\x86new\emulate.h ===
/*++ BUILD Version: 0000    // Increment this if a change has global effects

Copyright (c) 1994  Microsoft Corporation

Module Name:

    emulate.h

Abstract:

    This module contains the private header file for the x86 bios
    emulation.

Author:

    David N. Cutler (davec) 2-Sep-1994

Revision History:

--*/

#ifndef _EMULATE_
#define _EMULATE_

#include "setjmp.h"
#include "xm86.h"
#include "x86new.h"

//
// Define debug tracing flags.
//

//#define XM_DEBUG 1  // ****** temp ******

#define TRACE_INSTRUCTIONS 0x1
#define TRACE_OPERANDS 0x2
#define TRACE_GENERAL_REGISTERS 0x4
#define TRACE_OVERRIDE 0x8
#define TRACE_JUMPS 0x10
#define TRACE_SPECIFIERS 0x20
#define TRACE_SINGLE_STEP 0x40

//
// Define opcode function table indexes.
//
// N.B. This values must correspond exactly one for one with the function
//      table entries. If the C language had indexed initializers this
//      type would not be necessary.
//

typedef enum _XM_FUNCTION_TABLE_INDEX {

    //
    // ASCII operators.
    //

    X86_AAA_OP,
    X86_AAD_OP,
    X86_AAM_OP,
    X86_AAS_OP,
    X86_DAA_OP,
    X86_DAS_OP,

    //
    // Group 1 operators.
    //

    X86_ADD_OP,
    X86_OR_OP,
    X86_ADC_OP,
    X86_SBB_OP,
    X86_AND_OP,
    X86_SUB_OP,
    X86_XOR_OP,
    X86_CMP_OP,

    //
    // Group 2 operators.
    //

    X86_ROL_OP,
    X86_ROR_OP,
    X86_RCL_OP,
    X86_RCR_OP,
    X86_SHL_OP,
    X86_SHR_OP,
    X86_FILL0_OP,
    X86_SAR_OP,

    //
    // Group 3 operators.
    //

    X86_TEST_OP,
    X86_FILL1_OP,
    X86_NOT_OP,
    X86_NEG_OP,
    X86_MUL_OP,
    X86_IMULX_OP,
    X86_DIV_OP,
    X86_IDIV_OP,

    //
    // Group 4 and 5 operators.
    //

    X86_INC_OP,
    X86_DEC_OP,
    X86_CALL_OP,
    X86_FILL2_OP,
    X86_JMP_OP,
    X86_FILL3_OP,
    X86_PUSH_OP,
    X86_FILL4_OP,

    //
    // Group 8 operators.
    //

    X86_BT_OP,
    X86_BTS_OP,
    X86_BTR_OP,
    X86_BTC_OP,

    //
    // Stack push and pop operators.
    //

    X86_POP_OP,
    X86_PUSHA_OP,
    X86_POPA_OP,

    //
    // Jump operators.
    //

    X86_JXX_OP,
    X86_LOOP_OP,
    X86_JCXZ_OP,

    //
    // Control operators.
    //

    X86_ENTER_OP,
    X86_HLT_OP,
    X86_INT_OP,
    X86_IRET_OP,
    X86_LEAVE_OP,
    X86_RET_OP,

    //
    // Set boolean byte value based on condition.
    //

    X86_SXX_OP,

    //
    // Condition code operators.
    //

    X86_CMC_OP,
    X86_CLC_OP,
    X86_STC_OP,
    X86_CLI_OP,
    X86_STI_OP,
    X86_CLD_OP,
    X86_STD_OP,
    X86_LAHF_OP,
    X86_SAHF_OP,

    //
    // General move operators.
    //

    X86_MOV_OP,
    X86_XCHG_OP,

    //
    // Convert operations.
    //

    X86_CBW_OP,
    X86_CWD_OP,

    //
    // Single multiply operator.
    //

    X86_IMUL_OP,

    //
    // String operators.
    //

    X86_CMPS_OP,
    X86_INS_OP,
    X86_LODS_OP,
    X86_MOVS_OP,
    X86_OUTS_OP,
    X86_SCAS_OP,
    X86_STOS_OP,

    //
    // Effective address operators.
    //

    X86_BOUND_OP,
    X86_LEA_OP,

    //
    // Double shift operators.
    //

    X86_SHLD_OP,
    X86_SHRD_OP,

    //
    // I/O operators.
    //

    X86_IN_OP,
    X86_OUT_OP,

    //
    // Bit scan operators.
    //

    X86_BSF_OP,
    X86_BSR_OP,

    //
    // Byte swap operators.
    //

    X86_BSWAP_OP,

    //
    // Add/compare and exchange operators.
    //

    X86_XADD_OP,
    X86_CMPXCHG_OP,

    //
    // No operation.
    //

    X86_NOP_OP,

    //
    // Illegal opcode.
    //

    X86_ILL_OP,
    X86_MAXIMUM_INDEX
} XM_FUNCTION_TABLE_INDEX;

//
// Define 8-bit register numbers.
//

typedef enum _X86_8BIT_REGISTER {
    AL,
    CL,
    DL,
    BL,
    AH,
    CH,
    DH,
    BH
} X86_8BIT_REGISTER;

//
// Define 16-bit register numbers.
//

typedef enum _X86_16BIT_REGISTER {
    AX,
    CX,
    DX,
    BX,
    SP,
    BP,
    SI,
    DI
} X86_16BIT_REGISTER;

//
// Define 32-bit register numbers.
//

typedef enum _X86_32BIT_REGISTER {
    EAX,
    ECX,
    EDX,
    EBX,
    ESP,
    EBP,
    ESI,
    EDI
} X86_32BIT_REGISTER;

//
// Define general register structure.
//

typedef union _X86_GENERAL_REGISTER {
    ULONG Exx;
    union {
        USHORT Xx;
        struct {
            UCHAR Xl;
            UCHAR Xh;
        };
    };
} X86_GENERAL_REGISTER, *PX86_GENERAL_REGISTER;

//
// Define segment register numbers.
//

typedef enum _X86_SEGMENT_REGISTER {
    ES,
    CS,
    SS,
    DS,
    FS,
    GS
} X86_SEGMENT_REGISTER;

//
// Define instruction format types.
//

typedef enum _XM_FORMAT_TYPE {

    //
    // N.B. These format codes MUST be the first codes and MUST be
    //      exactly in this order since the ordering corresponds to
    //      segment numbers.
    //

    FormatSegmentES,
    FormatSegmentCS,
    FormatSegmentSS,
    FormatSegmentDS,
    FormatSegmentFS,
    FormatSegmentGS,

    //
    // N.B. These format codes MUST be the second codes and MUST be
    //      exactly in this order since the ordering corresponds to
    //      biased segment number. The entry for the code segment is
    //      a dummy entry to make the indexing work right.
    //

    FormatLoadSegmentES,
    FormatLoadSegmentCS,
    FormatLoadSegmentSS,
    FormatLoadSegmentDS,
    FormatLoadSegmentFS,
    FormatLoadSegmentGS,

    //
    // The following codes can be in any order.
    //

    FormatGroup1General,
    FormatGroup1Immediate,
    FormatGroup2By1,
    FormatGroup2ByCL,
    FormatGroup2ByByte,
    FormatGroup3General,
    FormatGroup4General,
    FormatGroup5General,
    FormatGroup8BitOffset,
    FormatOpcodeRegister,
    FormatLongJump,
    FormatShortJump,
    FormatSetccByte,
    FormatAccumImmediate,
    FormatAccumRegister,
    FormatMoveGeneral,
    FormatMoveImmediate,
    FormatMoveRegImmediate,
    FormatSegmentOffset,
    FormatMoveSegment,
    FormatMoveXxGeneral,
    FormatFlagsRegister,
    FormatPushImmediate,
    FormatPopGeneral,
    FormatImulImmediate,
    FormatStringOperands,
    FormatEffectiveOffset,
    FormatImmediateJump,
    FormatImmediateEnter,
    FormatGeneralBitOffset,
    FormatShiftDouble,
    FormatPortImmediate,
    FormatPortDX,
    FormatBitScanGeneral,
    FormatByteImmediate,
    FormatXlatOpcode,
    FormatGeneralRegister,
    FormatNoOperands,
    FormatOpcodeEscape,
    FormatPrefixOpcode
} XM_FORMAT_TYPE;

//
// Defined opcode modifier bit masks.
//

#define WIDTH_BIT 0x1                   // operand size control
#define DIRECTION_BIT 0x2               // direction of operation
#define SIGN_BIT 0x2                    // sign extended byte

//
// Define prefix opcode function index values.
//

typedef enum _XM_PREFIX_FUNCTION_INDEX {
    X86_ES_OP = ES,
    X86_CS_OP = CS,
    X86_SS_OP = SS,
    X86_DS_OP = DS,
    X86_FS_OP = FS,
    X86_GS_OP = GS,
    X86_LOCK_OP,
    X86_ADSZ_OP,
    X86_OPSZ_OP,
    X86_REPZ_OP,
    X86_REPNZ_OP
} XM_PREFIX_FUNCTION_INDEX;

//
// Define two byte opcode escape.
//

#define TWO_BYTE_ESCAPE 0x0f

//
// Define opcode control table structure.
//
// This table controls the decoding of instructions and there operands.
//

typedef struct _OPCODE_CONTROL {
    UCHAR FunctionIndex;
    UCHAR FormatType;
} OPCODE_CONTROL, *POPCODE_CONTROL;

//
// Define emulator context structure.
//
// This structure holds the global emulator state.
//

typedef struct _XM_CONTEXT {

    //
    // Pointers to the opcode control table and the opcode name table.
    //

    const OPCODE_CONTROL *OpcodeControlTable;
    const CHAR **OpcodeNameTable;

    //
    // x86 extended flags register.
    //

    union {
        UCHAR AhFlags;
        USHORT Flags;
        ULONG AllFlags;
        struct {
            ULONG EFLAG_CF : 1;
            ULONG EFLAG_MBO : 1;
            ULONG EFLAG_PF : 1;
            ULONG EFLAG_SBZ0 : 1;
            ULONG EFLAG_AF : 1;
            ULONG EFLAG_SBZ1 : 1;
            ULONG EFLAG_ZF : 1;
            ULONG EFLAG_SF : 1;
            ULONG EFLAG_TF : 1;
            ULONG EFLAG_IF : 1;
            ULONG EFLAG_DF : 1;
            ULONG EFLAG_OF : 1;
            ULONG EFLAG_IOPL : 2;
            ULONG EFLAG_NT : 1;
            ULONG EFLAG_SBZ2 : 1;
            ULONG EFLAG_RF : 1;
            ULONG EFLAG_VM : 1;
            ULONG EFLAG_AC : 1;
            ULONG EFLAG_SBZ3 : 13;
        } Eflags;
    };

    //
    // x86 instruction pointer.
    //

    union {
        USHORT Ip;
        ULONG Eip;
    };

    //
    // x86 general registers.
    //

    X86_GENERAL_REGISTER Gpr[8];

    //
    // x86 segment registers.
    //

    USHORT SegmentRegister[6];

    //
    // Emulator segment descriptors.
    //

    USHORT SegmentLimit[6];

    //
    // Instruction opcode control information read from the opcode
    // control table.
    //

    OPCODE_CONTROL OpcodeControl;

    //
    // Call or jmp destination segment segment.
    //

    USHORT DstSegment;

    //
    // Source and destination address and value.
    //

    union {
        UCHAR UNALIGNED *DstByte;
        USHORT UNALIGNED *DstWord;
        ULONG UNALIGNED *DstLong;
    };

    union {
        UCHAR UNALIGNED *SrcByte;
        USHORT UNALIGNED *SrcWord;
        ULONG UNALIGNED *SrcLong;
    };

    union {
        UCHAR Byte;
        ULONG Long;
        USHORT Word;
    } DstValue;

    union {
        UCHAR Byte;
        ULONG Long;
        USHORT Word;
    } SrcValue;

    //
    // Current opcode, data segment register to be used to access
    // data operands, function index, and operand data type, and
    // effective address offset.
    //

    ULONG CurrentOpcode;
    ULONG DataSegment;
    ULONG DataType;
    ULONG FunctionIndex;
    ULONG Offset;

    //
    // Prefix control information.
    //

    BOOLEAN LockPrefixActive;
    BOOLEAN OpaddrPrefixActive;
    BOOLEAN OpsizePrefixActive;
    BOOLEAN RepeatPrefixActive;
    BOOLEAN SegmentPrefixActive;
    UCHAR RepeatZflag;

    //
    // Effective address computation control.
    //

    BOOLEAN RegisterOffsetAddress;
    BOOLEAN ComputeOffsetAddress;

    //
    // Shift count.
    //

    UCHAR Shift;

    //
    // Jump buffer.
    //

    _JBTYPE JumpBuffer[_JBLEN];

    //
    // Address of read I/O space, write I/O space, and translation address
    // routines.
    //

    PXM_READ_IO_SPACE ReadIoSpace;
    PXM_WRITE_IO_SPACE WriteIoSpace;
    PXM_TRANSLATE_ADDRESS TranslateAddress;
} XM_CONTEXT, *PXM_CONTEXT, *RESTRICTED_POINTER PRXM_CONTEXT;

//
// Define opcode function and decode operand types.
//

typedef
ULONG
(*POPERAND_DECODE) (
    IN PRXM_CONTEXT P
    );

typedef
VOID
(*POPCODE_FUNCTION) (
    IN PRXM_CONTEXT P
    );

//
// Operand decode prototypes.
//

ULONG
XmPushPopSegment (
    IN PRXM_CONTEXT P
    );

ULONG
XmLoadSegment (
    IN PRXM_CONTEXT P
    );

ULONG
XmGroup1General (
    IN PRXM_CONTEXT P
    );

ULONG
XmGroup1Immediate (
    IN PRXM_CONTEXT P
    );

ULONG
XmGroup2By1 (
    IN PRXM_CONTEXT P
    );

ULONG
XmGroup2ByCL (
    IN PRXM_CONTEXT P
    );

ULONG
XmGroup2ByByte (
    IN PRXM_CONTEXT P
    );

ULONG
XmGroup3General (
    IN PRXM_CONTEXT P
    );

ULONG
XmGroup45General (
    IN PRXM_CONTEXT P
    );

ULONG
XmGroup8BitOffset (
    IN PRXM_CONTEXT P
    );

ULONG
XmOpcodeRegister (
    IN PRXM_CONTEXT P
    );

ULONG
XmLongJump (
    IN PRXM_CONTEXT P
    );

ULONG
XmShortJump (
    IN PRXM_CONTEXT P
    );

ULONG
XmSetccByte (
    IN PRXM_CONTEXT P
    );

ULONG
XmAccumImmediate (
    IN PRXM_CONTEXT P
    );

ULONG
XmAccumRegister (
    IN PRXM_CONTEXT P
    );

ULONG
XmMoveGeneral (
    IN PRXM_CONTEXT P
    );

ULONG
XmMoveImmediate (
    IN PRXM_CONTEXT P
    );

ULONG
XmMoveRegImmediate (
    IN PRXM_CONTEXT P
    );

ULONG
XmSegmentOffset (
    IN PRXM_CONTEXT P
    );

ULONG
XmMoveSegment (
    IN PRXM_CONTEXT P
    );

ULONG
XmMoveXxGeneral (
    IN PRXM_CONTEXT P
    );

ULONG
XmFlagsRegister (
    IN PRXM_CONTEXT P
    );

ULONG
XmPushImmediate (
    IN PRXM_CONTEXT P
    );

ULONG
XmPopGeneral (
    IN PRXM_CONTEXT P
    );

ULONG
XmImulImmediate (
    IN PRXM_CONTEXT P
    );

ULONG
XmStringOperands (
    IN PRXM_CONTEXT P
    );

ULONG
XmEffectiveOffset (
    IN PRXM_CONTEXT P
    );

ULONG
XmImmediateJump (
    IN PRXM_CONTEXT P
    );

ULONG
XmImmediateEnter (
    IN PRXM_CONTEXT P
    );

ULONG
XmGeneralBitOffset (
    IN PRXM_CONTEXT P
    );

ULONG
XmShiftDouble (
    IN PRXM_CONTEXT P
    );

ULONG
XmPortImmediate (
    IN PRXM_CONTEXT P
    );

ULONG
XmPortDX (
    IN PRXM_CONTEXT P
    );

ULONG
XmBitScanGeneral (
    IN PRXM_CONTEXT P
    );

ULONG
XmByteImmediate (
    IN PRXM_CONTEXT P
    );

ULONG
XmXlatOpcode (
    IN PRXM_CONTEXT P
    );

ULONG
XmGeneralRegister (
    IN PRXM_CONTEXT P
    );

ULONG
XmOpcodeEscape (
    IN PRXM_CONTEXT P
    );

ULONG
XmPrefixOpcode (
    IN PRXM_CONTEXT P
    );

ULONG
XmNoOperands (
    IN PRXM_CONTEXT P
    );

//
// Define miscellaneous prototypes.
//

ULONG
XmComputeParity (
    IN ULONG Result
    );

XM_STATUS
XmEmulateStream (
    IN PRXM_CONTEXT P,
    USHORT Segment,
    USHORT Offset,
    PXM86_CONTEXT Context
    );

UCHAR
XmGetCodeByte (
    IN PRXM_CONTEXT P
    );

UCHAR
XmGetByteImmediate (
    IN PRXM_CONTEXT P
    );

USHORT
XmGetByteImmediateToWord (
    IN PRXM_CONTEXT P
    );

ULONG
XmGetByteImmediateToLong (
    IN PRXM_CONTEXT P
    );

USHORT
XmGetSignedByteImmediateToWord (
    IN PRXM_CONTEXT P
    );

ULONG
XmGetSignedByteImmediateToLong (
    IN PRXM_CONTEXT P
    );

USHORT
XmGetWordImmediate (
    IN PRXM_CONTEXT P
    );

ULONG
XmGetLongImmediate (
    IN PRXM_CONTEXT P
    );

ULONG
XmPopStack (
    IN PRXM_CONTEXT P
    );

VOID
XmPushStack (
    IN PRXM_CONTEXT P,
    IN ULONG Value
    );

VOID
XmSetDataType (
    IN PRXM_CONTEXT P
    );

VOID
XmStoreResult (
    IN PRXM_CONTEXT P,
    IN ULONG Result
    );

//
// Define operand specifier prototypes.
//

PVOID
XmEvaluateAddressSpecifier (
    IN PRXM_CONTEXT P,
    OUT PLONG Register
    );

PVOID
XmGetOffsetAddress (
    IN PRXM_CONTEXT P,
    IN ULONG Offset
    );

PVOID
XmGetRegisterAddress (
    IN PRXM_CONTEXT P,
    IN ULONG Number
    );

PVOID
XmGetStringAddress (
    IN PRXM_CONTEXT P,
    IN ULONG Segment,
    IN ULONG Register
    );

VOID
XmSetDestinationValue (
    IN PRXM_CONTEXT P,
    IN PVOID Destination
    );

VOID
XmSetSourceValue (
    IN PRXM_CONTEXT P,
    IN PVOID Source
    );

ULONG
XmGetImmediateSourceValue (
    IN PRXM_CONTEXT P,
    IN ULONG ByteFlag
    );

VOID
XmSetImmediateSourceValue (
    IN PRXM_CONTEXT P,
    IN ULONG Source
    );

//
// ASCII operators.
//

VOID
XmAaaOp (
    IN PRXM_CONTEXT P
    );

VOID
XmAadOp (
    IN PRXM_CONTEXT P
    );

VOID
XmAamOp (
    IN PRXM_CONTEXT P
    );

VOID
XmAasOp (
    IN PRXM_CONTEXT P
    );

VOID
XmDaaOp (
    IN PRXM_CONTEXT P
    );

VOID
XmDasOp (
    IN PRXM_CONTEXT P
    );

//
// Group 1 operations.
//

VOID
XmAddOp (
    IN PRXM_CONTEXT P
    );

VOID
XmOrOp (
    IN PRXM_CONTEXT P
    );

VOID
XmAdcOp (
    IN PRXM_CONTEXT P
    );

VOID
XmSbbOp (
    IN PRXM_CONTEXT P
    );

VOID
XmAndOp (
    IN PRXM_CONTEXT P
    );

VOID
XmSubOp (
    IN PRXM_CONTEXT P
    );

VOID
XmXorOp (
    IN PRXM_CONTEXT P
    );

VOID
XmCmpOp (
    IN PRXM_CONTEXT P
    );

//
// Group 2 operations.
//

VOID
XmRolOp (
    IN PRXM_CONTEXT P
    );

VOID
XmRorOp (
    IN PRXM_CONTEXT P
    );

VOID
XmRclOp (
    IN PRXM_CONTEXT P
    );

VOID
XmRcrOp (
    IN PRXM_CONTEXT P
    );

VOID
XmShlOp (
    IN PRXM_CONTEXT P
    );

VOID
XmShrOp (
    IN PRXM_CONTEXT P
    );

VOID
XmSarOp (
    IN PRXM_CONTEXT P
    );

//
// Group 3 operations.
//

VOID
XmTestOp (
    IN PRXM_CONTEXT P
    );

VOID
XmNotOp (
    IN PRXM_CONTEXT P
    );

VOID
XmNegOp (
    IN PRXM_CONTEXT P
    );

VOID
XmDivOp (
    IN PRXM_CONTEXT P
    );

VOID
XmIdivOp (
    IN PRXM_CONTEXT P
    );

VOID
XmImulOp (
    IN PRXM_CONTEXT P
    );

VOID
XmImulxOp (
    IN PRXM_CONTEXT P
    );

VOID
XmMulOp (
    IN PRXM_CONTEXT P
    );

//
// Group 4 and 5 operators.
//

VOID
XmIncOp (
    IN PRXM_CONTEXT P
    );

VOID
XmDecOp (
    IN PRXM_CONTEXT P
    );

VOID
XmCallOp (
    PRXM_CONTEXT P
    );

VOID
XmJmpOp (
    IN PRXM_CONTEXT P
    );

VOID
XmPushOp (
    IN PRXM_CONTEXT P
    );

//
// Group 8 operators.
//

VOID
XmBtOp (
    IN PRXM_CONTEXT P
    );

VOID
XmBtsOp (
    IN PRXM_CONTEXT P
    );

VOID
XmBtrOp (
    IN PRXM_CONTEXT P
    );

VOID
XmBtcOp (
    IN PRXM_CONTEXT P
    );

//
// Stack operations.
//

VOID
XmPopOp (
    IN PRXM_CONTEXT P
    );

VOID
XmPushaOp (
    IN PRXM_CONTEXT P
    );

VOID
XmPopaOp (
    IN PRXM_CONTEXT P
    );

//
// Conditional jump and set conditional operations.
//

VOID
XmJxxOp (
    IN PRXM_CONTEXT P
    );

VOID
XmLoopOp (
    IN PRXM_CONTEXT P
    );

VOID
XmJcxzOp (
    IN PRXM_CONTEXT P
    );

VOID
XmSxxOp (
    IN PRXM_CONTEXT P
    );

//
// Condition code operations.
//

VOID
XmClcOp (
    PRXM_CONTEXT P
    );

VOID
XmCldOp (
    PRXM_CONTEXT P
    );

VOID
XmCliOp (
    PRXM_CONTEXT P
    );

VOID
XmCmcOp (
    PRXM_CONTEXT P
    );

VOID
XmStcOp (
    PRXM_CONTEXT P
    );

VOID
XmStdOp (
    PRXM_CONTEXT P
    );

VOID
XmStiOp (
    PRXM_CONTEXT P
    );

VOID
XmLahfOp (
    PRXM_CONTEXT P
    );

VOID
XmSahfOp (
    PRXM_CONTEXT P
    );

//
// Move operations.
//

VOID
XmMovOp (
    PRXM_CONTEXT P
    );

VOID
XmXchgOp (
    PRXM_CONTEXT P
    );

//
// Convert operations.
//

VOID
XmCbwOp (
    PRXM_CONTEXT P
    );

VOID
XmCwdOp (
    PRXM_CONTEXT P
    );

//
// Control operations.
//

VOID
XmEnterOp (
    PRXM_CONTEXT P
    );

VOID
XmHltOp (
    PRXM_CONTEXT P
    );

VOID
XmIntOp (
    PRXM_CONTEXT P
    );

VOID
XmIretOp (
    PRXM_CONTEXT P
    );

VOID
XmLeaveOp (
    PRXM_CONTEXT P
    );

VOID
XmRetOp (
    PRXM_CONTEXT P
    );

//
// String operations.
//

VOID
XmCmpsOp (
    PRXM_CONTEXT P
    );

VOID
XmInsOp (
    PRXM_CONTEXT P
    );

VOID
XmLodsOp (
    PRXM_CONTEXT P
    );

VOID
XmMovsOp (
    PRXM_CONTEXT P
    );

VOID
XmOutsOp (
    PRXM_CONTEXT P
    );

VOID
XmScasOp (
    PRXM_CONTEXT P
    );

VOID
XmStosOp (
    PRXM_CONTEXT P
    );

//
// Shift double operators.
//

VOID
XmShldOp (
    PRXM_CONTEXT P
    );

VOID
XmShrdOp (
    PRXM_CONTEXT P
    );

//
// I/O operators.
//

VOID
XmInOp (
    PRXM_CONTEXT P
    );

VOID
XmOutOp (
    PRXM_CONTEXT P
    );

//
// Bit scan operators.
//

VOID
XmBsfOp (
    PRXM_CONTEXT P
    );

VOID
XmBsrOp (
    PRXM_CONTEXT P
    );

//
// MIscellaneous operations.
//

VOID
XmXaddOp (
    PRXM_CONTEXT P
    );

VOID
XmBoundOp (
    PRXM_CONTEXT P
    );

VOID
XmBswapOp (
    PRXM_CONTEXT P
    );

VOID
XmCmpxchgOp (
    PRXM_CONTEXT P
    );

VOID
XmIllOp (
    PRXM_CONTEXT P
    );

VOID
XmNopOp (
    PRXM_CONTEXT P
    );

//
// PCI Bios emulation routines.
//

#if !defined(_PURE_EMULATION_)

BOOLEAN
XmExecuteInt1a (
    IN OUT PRXM_CONTEXT Context
    );

VOID
XmInt1aPciBiosPresent(
    IN OUT PRXM_CONTEXT Context
    );

VOID
XmInt1aFindPciClassCode(
    IN OUT PRXM_CONTEXT Context
    );

VOID
XmInt1aFindPciDevice(
    IN OUT PRXM_CONTEXT Context
    );

VOID
XmInt1aGenerateSpecialCycle(
    IN OUT PRXM_CONTEXT Context
    );

VOID
XmInt1aGetRoutingOptions(
    IN OUT PRXM_CONTEXT Context
    );

VOID
XmInt1aSetPciIrq(
    IN OUT PRXM_CONTEXT Context
    );

VOID
XmInt1aReadConfigRegister(
    IN OUT PRXM_CONTEXT Context
    );

VOID
XmInt1aWriteConfigRegister(
    IN OUT PRXM_CONTEXT Context
    );

#endif

//
// Debug routines.
//

#if XM_DEBUG

#include "stdio.h"
//#define DEBUG_PRINT(_X_) DbgPrint _X_
#define DEBUG_PRINT(_X_) printf _X_

VOID
XmTraceDestination (
    IN PRXM_CONTEXT P,
    IN ULONG Destination
    );

VOID
XmTraceFlags (
    IN PRXM_CONTEXT P
    );

VOID
XmTraceInstruction (
    IN XM_OPERATION_DATATYPE DataType,
    IN ULONG Instruction
    );

VOID
XmTraceJumps (
    IN PRXM_CONTEXT P
    );

VOID
XmTraceOverride (
    IN PRXM_CONTEXT P
    );

VOID
XmTraceRegisters (
    IN PRXM_CONTEXT P
    );

VOID
XmTraceResult (
    IN PRXM_CONTEXT P,
    IN ULONG Result
    );

VOID
XmTraceSpecifier (
    IN UCHAR Specifier
    );

VOID
XmTraceSource (
    IN PRXM_CONTEXT P,
    IN ULONG Source
    );

#else

#define XmTraceDestination(P, Destination)
#define XmTraceInstruction(DataType, Instruction)
#define XmTraceFlags(P)
#define XmTraceJumps(P)
#define XmTraceOverride(P)
#define XmTraceRegisters(P)
#define XmTraceResult(P, Result)
#define XmTraceSpecifier(Specifier)
#define XmTraceSource(P, Source)

#endif

//
// Define global data.
//

extern XM_CONTEXT XmContext;
extern BOOLEAN XmEmulatorInitialized;
extern const OPCODE_CONTROL XmOpcodeControlTable1[];
extern const OPCODE_CONTROL XmOpcodeControlTable2[];
extern const POPCODE_FUNCTION XmOpcodeFunctionTable[];
extern const POPERAND_DECODE XmOperandDecodeTable[];

#if !defined(_PURE_EMULATION)

extern UCHAR XmNumberPciBusses;
extern BOOLEAN XmPciBiosPresent;
extern PGETSETPCIBUSDATA XmGetPciData;
extern PGETSETPCIBUSDATA XmSetPciData;

#endif

#if XM_DEBUG

extern ULONG XmDebugFlags;
extern const PCHAR XmOpcodeNameTable1[];
extern const PCHAR XmOpcodeNameTable2[];

#endif

#endif // _EMULATE_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\x86new\inoutops.c ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    inoutops.c

Abstract:

    This module implements the code to emulate the in and out opcodes.

Author:

    David N. Cutler (davec) 7-Nov-1994

Environment:

    Kernel mode only.

Revision History:

--*/

#include "nthal.h"
#include "emulate.h"

VOID
XmInOp (
    IN PRXM_CONTEXT P
    )

/*++

Routine Description:

    This function emulates a inb/w/d opcode.

Arguments:

    P - Supplies a pointer to the emulation context structure.

Return Value:

    None.

--*/

{

    //
    // Check if the I/O port number is valid.
    //

    if ((P->SrcValue.Long + P->DataType) > 0xffff) {
        longjmp(&P->JumpBuffer[0], XM_ILLEGAL_PORT_NUMBER);
    }

    //
    // Set the destination address, input from the specified port, and
    // store the result.
    //

    P->DstLong = (ULONG UNALIGNED *)(&P->Gpr[EAX].Exx);
    XmStoreResult(P, (P->ReadIoSpace)(P->DataType, P->SrcValue.Word));
    return;
}

VOID
XmInsOp (
    IN PRXM_CONTEXT P
    )

/*++

Routine Description:

    This function emulates a insb/w/d opcode.

Arguments:

    P - Supplies a pointer to the emulation context structure.

Return Value:

    None.

--*/

{

    ULONG Count;
    USHORT PortNumber;

    //
    // If a repeat prefix is active, then the loop count is specified
    // by eCX. Otherwise, the loop count is one.
    //

    Count = 1;
    if (P->RepeatPrefixActive != FALSE) {
        if (P->OpaddrPrefixActive != FALSE) {
            Count = P->Gpr[ECX].Exx;
            P->Gpr[ECX].Exx = 0;

        } else {
            Count = P->Gpr[CX].Xx;
            P->Gpr[CX].Xx = 0;
        }
    }

    //
    // Move items from the input port to the destination string.
    //

    PortNumber = P->SrcValue.Word;
    while (Count != 0) {

        //
        // Set the destination address, input from the specified port, and
        // store the result.
        //

        P->DstLong = (ULONG UNALIGNED *)XmGetStringAddress(P, ES, EDI);
        XmStoreResult(P, (P->ReadIoSpace)(P->DataType, PortNumber));
        Count -= 1;
    }

    return;
}

VOID
XmOutOp (
    IN PRXM_CONTEXT P
    )

/*++

Routine Description:

    This function emulates a outb/w/d opcode.

Arguments:

    P - Supplies a pointer to the emulation context structure.

Return Value:

    None.

--*/

{

    USHORT PortNumber;

    //
    // Check if the I/O port number is valid.
    //

    if ((P->SrcValue.Long + P->DataType) > 0xffff) {
        longjmp(&P->JumpBuffer[0], XM_ILLEGAL_PORT_NUMBER);
    }

    //
    // Save the port number, get the source value, and output to the port.
    //

    PortNumber = P->SrcValue.Word;
    XmSetSourceValue(P, &P->Gpr[EAX].Exx);
    (P->WriteIoSpace)(P->DataType, PortNumber, P->SrcValue.Long);
    return;
}

VOID
XmOutsOp (
    IN PRXM_CONTEXT P
    )

/*++

Routine Description:

    This function emulates a outsb/w/d opcode.

Arguments:

    P - Supplies a pointer to the emulation context structure.

Return Value:

    None.

--*/

{

    ULONG Count;
    USHORT PortNumber;

    //
    // If a repeat prefix is active, then the loop count is specified
    // by eCX. Otherwise, the loop count is one.
    //

    Count = 1;
    if (P->RepeatPrefixActive != FALSE) {
        if (P->OpaddrPrefixActive != FALSE) {
            Count = P->Gpr[ECX].Exx;
            P->Gpr[ECX].Exx = 0;

        } else {
            Count = P->Gpr[CX].Xx;
            P->Gpr[CX].Xx = 0;
        }
    }

    //
    // Move items from the source string to the output port.
    //

    PortNumber = P->SrcValue.Word;
    while (Count != 0) {

        //
        // Set the source value and output to the specified port.
        //

        XmSetSourceValue(P, XmGetStringAddress(P, P->DataSegment, ESI));
        (P->WriteIoSpace)(P->DataType, PortNumber, P->SrcValue.Long);
        Count -= 1;
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\x86new\miscops.c ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    miscops.c

Abstract:

    This module implements the code to emulate miscellaneous opcodes.

Author:

    David N. Cutler (davec) 22-Sep-1994

Environment:

    Kernel mode only.

Revision History:

--*/

#include "nthal.h"
#include "emulate.h"

VOID
XmBoundOp (
    PRXM_CONTEXT P
    )

/*++

Routine Description:

    This function emulates a bound opcode.

Arguments:

    P - Supplies a pointer to an emulator context structure.

Return Value:

    None.

--*/

{

    union {
        LONG Long;
        SHORT Word;
    } LowerBound;

    union {
        LONG Long;
        SHORT Word;
    } UpperBound;

    ULONG Offset;

    //
    // Get lower and upper bounds and check index against index value.
    //

    Offset = P->SrcValue.Long;
    XmSetSourceValue(P, XmGetOffsetAddress(P, Offset));
    LowerBound.Long = P->SrcValue.Long;
    XmSetSourceValue(P, XmGetOffsetAddress(P, Offset + P->DataType + 1));
    UpperBound.Long = P->SrcValue.Long;
    if (P->DataType == LONG_DATA) {
        if (((LONG)(*P->DstLong) < LowerBound.Long) ||
            ((LONG)(*P->DstLong) > (UpperBound.Long + (LONG)(P->DataType + 1)))) {
            longjmp(&P->JumpBuffer[0], XM_INDEX_OUT_OF_BOUNDS);
        }

    } else {
        if (((SHORT)(*P->DstWord) < LowerBound.Word) ||
            ((SHORT)(*P->DstWord) > (UpperBound.Word + (SHORT)(P->DataType + 1)))) {
            longjmp(&P->JumpBuffer[0], XM_INDEX_OUT_OF_BOUNDS);
        }
    }

    return;
}

VOID
XmBswapOp (
    PRXM_CONTEXT P
    )

/*++

Routine Description:

    This function emulates a bswap opcode.

Arguments:

    P - Supplies a pointer to an emulator context structure.

Return Value:

    None.

--*/

{

    ULONG Result;

    //
    // Swap bytes and set result value.
    //

    Result = (P->SrcValue.Long << 24) | ((P->SrcValue.Long & 0xff00) << 8) |
             (P->SrcValue.Long >> 24) | ((P->SrcValue.Long >> 8) & 0xff00);

    XmStoreResult(P, Result);
    return;
}

VOID
XmIllOp (
    PRXM_CONTEXT P
    )

/*++

Routine Description:

    This function emulates an illegal opcode.

Arguments:

    P - Supplies a pointer to an emulator context structure.

Return Value:

    None.

--*/

{

    //
    // Raise an illegal opcode exception.
    //

    longjmp(&P->JumpBuffer[0], XM_ILLEGAL_INSTRUCTION_OPCODE);
    return;
}

VOID
XmNopOp (
    PRXM_CONTEXT P
    )

/*++

Routine Description:

    This function emulates a nop opcode.

Arguments:

    P - Supplies a pointer to an emulator context structure.

Return Value:

    None.

--*/

{

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\x86new\main.c ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    x86test.c

Abstract:

    This module implements a series of tests for the x86 ROM Bios emulator.

Author:

    David N. Cutler (davec) 13-Sep-1994

Environment:

    Kernel mode only.

Revision History:

--*/

#include "nthal.h"
#include "stdio.h"
#include "string.h"
#include "memory.h"
#include "emulate.h"

//
// Define global instruction execution data.
//

UCHAR CodeStream[] = {0xeb, 0x07,                   // jmp .+7
                      0xc3,                         // ret (near)
                      0xcb,                         // ret (far)
                      0x66, 0xc3,                   // ret (near)
                      0x66, 0xcb,                   // ret (far)
                      0xcf,                         // iret
                      0xe9, 0x00, 0x00,             // jmp .+1
                      0x66, 0xe9, 0x00, 0x00, 0x00, 0x00, // jmp .+1
                      0xea, 0x17, 0x00, 0x00, 0x20, // jmp 0x0017:0x2000
                      0x66, 0xea, 0x1f, 0x00, 0x00, 0x00, 0x00, 0x20, // jmp 0x0000001f:0x2000
                      0x66, 0xb8, 0x2e, 0x00, 0x00, 0x20, // mov eax, 0x2000002e
                      0x66, 0x89, 0x06, 0x04, 0x00, // mov ds:0x0004, eax
                      0xff, 0x26, 0x04, 0x00,       // jmp ds:0x0004
                      0x66, 0xb8, 0x3d, 0x00, 0x00, 0x20, // mov eax, 0x2000003d
                      0x66, 0x89, 0x06, 0x04, 0x00, // mov ds:0x0004, eax
                      0xff, 0x2e, 0x04, 0x00,       // jmp ds:0x0004
                      0x9b,                         // wait (nop)
/*                      0x00, 0xc0,                   // add al, al
                      0x00, 0xc9,                   // add cl, cl
                      0x00, 0xd2,                   // add dl, dl
                      0x00, 0xdb,                   // add bl, bl
                      0x00, 0xe4,                   // add ah, ah
                      0x00, 0xed,                   // add ch, ch
                      0x00, 0xf6,                   // add dh, dh
                      0x00, 0xff,                   // add bh, bh
                      0x01, 0xc0,                   // add ax, ax
                      0x01, 0xc9,                   // add cx, cx
                      0x01, 0xd2,                   // add dx, dx
                      0x01, 0xdb,                   // add bx, bx
                      0x01, 0xed,                   // add bp, bp
                      0x01, 0xf6,                   // add si, si
                      0x01, 0xff,                   // add di, di
                      0x66, 0x01, 0xc0,             // add eax, eax
                      0x66, 0x01, 0xc9,             // add ecx, ecx
                      0x66, 0x01, 0xd2,             // add edx, edx
                      0x66, 0x01, 0xdb,             // add ebx, ebx
                      0x66, 0x01, 0xed,             // add ebp, ebp
                      0x66, 0x01, 0xf6,             // add esi, esi
                      0x66, 0x01, 0xff,             // add edi, edi
                      0x66, 0x31, 0xc0,             // xor eax, eax
                      0x66, 0x31, 0xc9,             // xor ecx, ecx
                      0x66, 0x31, 0xd2,             // xor edx, edx
                      0x66, 0x31, 0xdb,             // xor ebx, ebx
                      0x66, 0x31, 0xed,             // xor ebp, ebp
                      0x66, 0x31, 0xf6,             // xor esi, esi
                      0x66, 0x31, 0xff,             // xor edi, edi
                      0x04, 0xf0,                   // add al, 0xf0
                      0x41,                         // inc CX
                      0x41,                         // inc CX
                      0xc0, 0xc0, 0x05,             // rol al, 0x05
                      0xd0, 0xc0,                   // rol al, 1
                      0xd2, 0xc0,                   // rol al, CL
                      0x05, 0x0f, 0x00,             // add ax, 0x000f
                      0xc1, 0xc0, 0x0d,             // rol ax, 0x0d
                      0xd1, 0xc0,                   // rol ax, 1
                      0xd3, 0xc0,                   // rol ax, CL
                      0x05, 0x00, 0xff,             // add ax, 0xff00
                      0x66, 0xc1, 0xc0, 0x1d,       // rol eax, 0x1d
                      0x66, 0xd1, 0xc0,             // rol eax, 1
                      0x66, 0xd3, 0xc0,             // rol eax, CL
                      0xf8,                         // clc
                      0xf9,                         // stc
                      0xf8,                         // clc
                      0xf5,                         // cmc
                      0xf5,                         // cmc
                      0xfa,                         // cli
                      0xfb,                         // sti
                      0xfc,                         // cld
                      0xfd,                         // std
                      0xfc,                         // cld
                      0x66, 0x31, 0xc0,             // xor eax, eax
                      0x66, 0x31, 0xc9,             // xor ecx, ecx
                      0x66, 0x31, 0xd2,             // xor edx, edx
                      0x66, 0x31, 0xdb,             // xor ebx, ebx
                      0x66, 0x31, 0xed,             // xor ebp, ebp
                      0x66, 0x31, 0xf6,             // xor esi, esi
                      0x66, 0x31, 0xff,             // xor edi, edi
                      0x66, 0x05, 0xf0, 0x3c, 0x0f, 0x0f, // add eax, 0x0f0f3cf0
                      0x66, 0x89, 0xc2,             // mov edx,eax
                      0x31, 0xd2,                   // xor dx, dx
                      0x88, 0xc3,                   // mov bl, al
                      0x88, 0xe7,                   // mov bh, ah
                      0x89, 0xda,                   // mov dx, bx
                      0x66, 0x89, 0xc6,             // mov esi, eax
                      0x66, 0x31, 0xc0,             // xor eax, eax
                      0x66, 0x8b, 0xc6,             // mov eax, esi
                      0x66, 0x31, 0xc0,             // xor eax, eax
                      0x66, 0x31, 0xc9,             // xor ecx, ecx
                      0x66, 0x31, 0xd2,             // xor edx, edx
                      0x66, 0x31, 0xdb,             // xor ebx, ebx
                      0x66, 0x31, 0xed,             // xor ebp, ebp
                      0x66, 0x31, 0xf6,             // xor esi, esi
                      0x66, 0x31, 0xff,             // xor edi, edi
                      0x66, 0xb8, 0x11, 0x11, 0x11, 0x11, // mov EAX, 0x11111111
                      0x66, 0xb9, 0x22, 0x22, 0x22, 0x22, // mov ECX, 0x22222222
                      0x66, 0xba, 0x33, 0x33, 0x33, 0x33, // mov EDX, 0x33333333
                      0x66, 0xbb, 0x44, 0x44, 0x44, 0x44, // mov EBX, 0x44444444
                      0x66, 0xbd, 0x66, 0x66, 0x66, 0x66, // mov EBP, 0x66666666
                      0x66, 0xbe, 0x77, 0x77, 0x77, 0x77, // mov ESI, 0x77777777
                      0x66, 0xbf, 0x88, 0x88, 0x88, 0x88, // mov EDI, 0x88888888
                      0xb8, 0x08, 0x01,             // mov AX, 0x0108
                      0xb9, 0x09, 0x02,             // mov CX, 0x0209
                      0xba, 0x0a, 0x03,             // mov DX, 0x030a
                      0xbb, 0x0b, 0x04,             // mov BX, 0x040b
                      0xbd, 0x0d, 0x06,             // mov BP, 0x060d
                      0xbe, 0x0e, 0x07,             // mov SI, 0x070e
                      0xbf, 0x0f, 0x08,             // mov DI, 0x080f
                      0xb0, 0x01,                   // mov al, 0x01
                      0xb1, 0x02,                   // mov cl, 0x02
                      0xb2, 0x03,                   // mov dl, 0x03
                      0xb3, 0x04,                   // mov bl, 0x04
                      0xb4, 0x05,                   // mov ah, 0x05
                      0xb5, 0x06,                   // mov ch, 0x06
                      0xb6, 0x07,                   // mov dh, 0x07
                      0xb7, 0x08,                   // mov bh, 0x08
                      0x91,                         // xchg cx, ax
                      0x92,                         // xchg dx, ax
                      0x93,                         // xchg bx, ax
                      0x95,                         // xchg bp, ax
                      0x96,                         // xchg si, ax
                      0x97,                         // xchg di, ax
                      0x66, 0x91,                   // xchg ecx, eax
                      0x66, 0x92,                   // xchg edx, eax
                      0x66, 0x93,                   // xchg ebx, eax
                      0x66, 0x95,                   // xchg ebp, eax
                      0x66, 0x96,                   // xchg esi, eax
                      0x66, 0x97,                   // xchg edi, eax
                      0x86, 0xd9,                   // xchg bl, cl
                      0x87, 0xd9,                   // xchg bx, cx
                      0x66, 0x87, 0xd9,             // xchg ebx, ecx
                      0xb0, 0x7f,                   // mov al, 0x7f
                      0x98,                         // cbw
                      0xb0, 0x83,                   // mov al, 0x83
                      0x98,                         // cbw
                      0xb8, 0x01, 0x08,             // mov AX, 0x0801
                      0x99,                         // cwd
                      0xb8, 0x01, 0x80,             // mov AX, 0x8001
                      0x99,                         // cwd
                      0xb4, 0xfd,                   // mov ah, 0xfd
                      0x9e,                         // sahf
                      0xb4, 0x77,                   // mov ah, 0x77
                      0x9f,                         // lahf
                      0xc6, 0xc0, 0xed,             // mov al, 0xed
                      0xc6, 0xc4, 0xde,             // mov ah, 0xde
                      0xc7, 0xc0, 0xcc, 0xdd,       // mov ax, 0xddcc
                      0x66, 0xc7, 0xc0, 0xdd, 0xcc, 0xbb, 0xaa, // mov eax, 0xaabbccdd
                      0xb0, 0x83,                   // mov al, 0x83
                      0x0f, 0x90, 0xc0,             // seto al
                      0xb0, 0x83,                   // mov al, 0x83
                      0x0f, 0x91, 0xc0,             // setno al
                      0xb0, 0x83,                   // mov al, 0x83
                      0x0f, 0x92, 0xc0,             // setb al
                      0xb0, 0x83,                   // mov al, 0x83
                      0x0f, 0x93, 0xc0,             // setnb al
                      0xb0, 0x83,                   // mov al, 0x83
                      0x0f, 0x94, 0xc0,             // setz al
                      0xb0, 0x83,                   // mov al, 0x83
                      0x0f, 0x95, 0xc0,             // setnz al
                      0xb0, 0x83,                   // mov al, 0x83
                      0x0f, 0x96, 0xc0,             // setbe al
                      0xb0, 0x83,                   // mov al, 0x83
                      0x0f, 0x97, 0xc0,             // setnbe al
                      0xb0, 0x83,                   // mov al, 0x83
                      0x0f, 0x98, 0xc0,             // sets al
                      0xb0, 0x83,                   // mov al, 0x83
                      0x0f, 0x99, 0xc0,             // setns al
                      0xb0, 0x83,                   // mov al, 0x83
                      0x0f, 0x9a, 0xc0,             // setp al
                      0xb0, 0x83,                   // mov al, 0x83
                      0x0f, 0x9b, 0xc0,             // setnp al
                      0xb0, 0x83,                   // mov al, 0x83
                      0x0f, 0x9c, 0xc0,             // setl al
                      0xb0, 0x83,                   // mov al, 0x83
                      0x0f, 0x9d, 0xc0,             // setnl al
                      0xb0, 0x83,                   // mov al, 0x83
                      0x0f, 0x9e, 0xc0,             // setle al
                      0xb0, 0x83,                   // mov al, 0x83
                      0x0f, 0x9f, 0xc0,             // setnle al
                      0x66, 0xb8, 0xfe, 0xff, 0x01, 0x00, // mov eax, 0x0001fffe
                      0x40,                         // inc ax
                      0x66, 0x40,                   // inc eax
                      0x66, 0x48,                   // dec eax
                      0x48,                         // dec ax
                      0x66, 0xb9, 0xfe, 0xff, 0x01, 0x00, // mov ecx, 0x0001fffe
                      0x41,                         // inc cx
                      0x66, 0x41,                   // inc ecx
                      0x66, 0x49,                   // dec ecxx
                      0x49,                         // dec cx
                      0x66, 0xba, 0xfe, 0xff, 0x01, 0x00, // mov edx, 0x0001fffe
                      0x42,                         // inc dx
                      0x66, 0x42,                   // inc edx
                      0x66, 0x4a,                   // dec edx
                      0x4a,                         // dec dx
                      0x66, 0xbb, 0xfe, 0xff, 0x01, 0x00, // mov ebx, 0x0001fffe
                      0x43,                         // inc bx
                      0x66, 0x43,                   // inc ebx
                      0x66, 0x4b,                   // dec ebx
                      0x4b,                         // dec bx
                      0x66, 0xbd, 0xfe, 0xff, 0x01, 0x00, // mov ebp, 0x0001fffe
                      0x45,                         // inc bp
                      0x66, 0x45,                   // inc ebp
                      0x66, 0x4d,                   // dec ebp
                      0x4d,                         // dec bp
                      0x66, 0xbe, 0xfe, 0xff, 0x01, 0x00, // mov esi, 0x0001fffe
                      0x46,                         // inc si
                      0x66, 0x46,                   // inc esi
                      0x66, 0x4e,                   // dec esix
                      0x4e,                         // dec si
                      0x66, 0xbf, 0xfe, 0xff, 0x01, 0x00, // mov edi, 0x0001fffe
                      0x47,                         // inc di
                      0x66, 0x47,                   // inc edi
                      0x66, 0x4f,                   // dec edix
                      0x4f,                         // dec di
                      0x26, 0x90,                   // ES: nop
                      0x2e, 0x90,                   // CS: nop
                      0x36, 0x90,                   // SS: nop
                      0x3e, 0x90,                   // DS: nop
                      0x64, 0x90,                   // FS: nop
                      0x65, 0x90,                   // GS: nop
                      0xb8, 0xb8, 0xb8,             // mov ax, 0xb8b8
                      0xb9, 0xb9, 0xb9,             // mov cx, 0xb9b9
                      0xba, 0xba, 0xba,             // mov dx, 0xbaba
                      0xbb, 0xbb, 0xbb,             // mov bx, 0xbbbb
                      0xbd, 0xbd, 0xbd,             // mov bp, 0xbdbd
                      0xbe, 0xbe, 0xbe,             // mov si, 0xbebe
                      0xbf, 0xbf, 0xbf,             // mov di, 0xbfbf
                      0x66, 0x50,                   // push eax
                      0x66, 0x51,                   // push ecx
                      0x66, 0x52,                   // push edx
                      0x66, 0x53,                   // push ebx
                      0x66, 0x54,                   // push esp
                      0x66, 0x55,                   // push ebp
                      0x66, 0x56,                   // push esi
                      0x66, 0x57,                   // push edi
                      0x50,                         // push ax
                      0x51,                         // push cx
                      0x52,                         // push dx
                      0x53,                         // push bx
                      0x54,                         // push sp
                      0x55,                         // push bp
                      0x56,                         // push si
                      0x57,                         // push di
                      0xb8, 0x00, 0x00,             // mov ax, 0x0000
                      0xb9, 0x00, 0x00,             // mov cx, 0x0000
                      0xba, 0x00, 0x00,             // mov dx, 0x0000
                      0xbb, 0x00, 0x00,             // mov bx, 0x0000
                      0xbd, 0x00, 0x00,             // mov bp, 0x0000
                      0xbe, 0x00, 0x00,             // mov si, 0x0000
                      0xbf, 0x00, 0x00,             // mov di, 0x0000
                      0x5f,                         // pop di
                      0x5e,                         // pop si
                      0x5d,                         // pop bp
                      0x5c,                         // pop sp
                      0x5b,                         // pop bx
                      0x5a,                         // pop dx
                      0x59,                         // pop cx
                      0x58,                         // pop ax
                      0xb8, 0x00, 0x00,             // mov ax, 0x0000
                      0xb9, 0x00, 0x00,             // mov cx, 0x0000
                      0xba, 0x00, 0x00,             // mov dx, 0x0000
                      0xbb, 0x00, 0x00,             // mov bx, 0x0000
                      0xbd, 0x00, 0x00,             // mov bp, 0x0000
                      0xbe, 0x00, 0x00,             // mov si, 0x0000
                      0xbf, 0x00, 0x00,             // mov di, 0x0000
                      0x66, 0x5f,                   // pop edi
                      0x66, 0x5e,                   // pop esi
                      0x66, 0x5d,                   // pop ebp
                      0x66, 0x5c,                   // pop esp
                      0x66, 0x5b,                   // pop ebx
                      0x66, 0x5a,                   // pop edx
                      0x66, 0x59,                   // pop ecx
                      0x66, 0x58,                   // pop eax
                      0x06,                         // push ES
                      0x0e,                         // push CS
                      0x16,                         // push SS
                      0x1e,                         // push DS
                      0x0f, 0xa0,                   // push FS
                      0x0f, 0xa8,                   // push GS
                      0x0f, 0xa9,                   // pop GS
                      0x0f, 0xa1,                   // pop FS
                      0x1f,                         // pop DS
                      0x17,                         // pop SS
                      0x58,                         // pop ax
                      0x07,                         // pop ES
                      0x90,                         // nop
                      0xb0, 0x81,                   // mov al, 0x81
                      0xb1, 0xff,                   // mov cl, 0xff
                      0x20, 0xc1,                   // and cl, al
                      0xb0, 0x55,                   // mov al, 0x55
                      0xb1, 0xff,                   // mov cl, 0xff
                      0x20, 0xc1,                   // and cl, al
                      0xb0, 0x81,                   // mov al, 0x81
                      0xb1, 0x7e,                   // mov cl, 0x7e
                      0x20, 0xc1,                   // and cl, al
                      0xb8, 0x81, 0x81,             // mov ax, 0x8181
                      0xb9, 0xff, 0xff,             // mov cx, 0xffff
                      0x21, 0xc1,                   // and cx, ax
                      0xb8, 0x55, 0x55,             // mov ax, 0x5555
                      0xb9, 0xff, 0xff,             // mov cx, 0xffff
                      0x21, 0xc1,                   // and cx, ax
                      0xb8, 0x81, 0x81,             // mov ax, 0x8181
                      0xb9, 0x7e, 0x7e,             // mov cx, 0x7e7e
                      0x21, 0xc1,                   // and cx, ax
                      0x66, 0xb8, 0x80, 0x81, 0x81, 0x81, // mov eax, 0x81818181
                      0x66, 0xb9, 0xff, 0xff, 0xff, 0xff, // mov ecx, 0xffffffff
                      0x66, 0x21, 0xc1,             // and ecx, eax
                      0x66, 0xb8, 0x55, 0x55, 0x55, 0x55, // mov eax, 0x55555555
                      0x66, 0xb9, 0xff, 0xff, 0xff, 0xff, // mov ecx, 0xffffffff
                      0x66, 0x21, 0xc1,             // and ecx, eax
                      0x66, 0xb8, 0x81, 0x81, 0x81, 0x81, // mov eax, 0x81818181
                      0x66, 0xb9, 0x7e, 0x7e, 0x7e, 0x7e, // mov ecx, 0x7e7e7e7e
                      0x66, 0x21, 0xc1,             // and ecx, eax
                      0xb1, 0x80,                   // mov cl, 0x80
                      0x80, 0xe1, 0xff,             // and cl, 0xff
                      0xb9, 0x55, 0x55,             // mov cx, 0x5555
                      0x81, 0xe1, 0xff, 0xff,       // and cx, 0xffff
                      0x66, 0xb9, 0x80, 0x81, 0x81, 0x81, // mov ecx, 0x81818181
                      0x66, 0x81, 0xe1, 0xff, 0xff, 0xff, 0xff, // and ecx, 0xffffffff
                      0xb9, 0x55, 0x55,             // mov cx, 0x5555
                      0x83, 0xe1, 0x7f,             // and cx, (sign)0xff
                      0x66, 0xb9, 0x80, 0x81, 0x81, 0x81, // mov ecx, 0x81818181
                      0x66, 0x83, 0xe1, 0x7f,       // and ecx, (sign)0xff
                      0xb9, 0x55, 0x55,             // mov cx, 0x5555
                      0x83, 0xe1, 0xf7,             // and cx, (sign)0xff
                      0x66, 0xb9, 0x80, 0x81, 0x81, 0x81, // mov ecx, 0x81818181
                      0x66, 0x83, 0xe1, 0xf7,       // and ecx, (sign)0xff
                      0xb0, 0x81,                   // mov al, 0x81
                      0xb1, 0xff,                   // mov cl, 0xff
                      0x08, 0xc1,                   // or cl, al
                      0xb0, 0x55,                   // mov al, 0x55
                      0xb1, 0xff,                   // mov cl, 0xff
                      0x08, 0xc1,                   // or cl, al
                      0xb0, 0x81,                   // mov al, 0x81
                      0xb1, 0x7e,                   // mov cl, 0x7e
                      0x08, 0xc1,                   // or cl, al
                      0xb8, 0x81, 0x81,             // mov ax, 0x8181
                      0xb9, 0xff, 0xff,             // mov cx, 0xffff
                      0x09, 0xc1,                   // or cx, ax
                      0xb8, 0x55, 0x55,             // mov ax, 0x5555
                      0xb9, 0xff, 0xff,             // mov cx, 0xffff
                      0x09, 0xc1,                   // or cx, ax
                      0xb8, 0x81, 0x81,             // mov ax, 0x8181
                      0xb9, 0x7e, 0x7e,             // mov cx, 0x7e7e
                      0x09, 0xc1,                   // or cx, ax
                      0x66, 0xb8, 0x80, 0x81, 0x81, 0x81, // mov eax, 0x81818181
                      0x66, 0xb9, 0xff, 0xff, 0xff, 0xff, // mov ecx, 0xffffffff
                      0x66, 0x09, 0xc1,             // or ecx, eax
                      0x66, 0xb8, 0x55, 0x55, 0x55, 0x55, // mov eax, 0x55555555
                      0x66, 0xb9, 0xff, 0xff, 0xff, 0xff, // mov ecx, 0xffffffff
                      0x66, 0x09, 0xc1,             // or ecx, eax
                      0x66, 0xb8, 0x81, 0x81, 0x81, 0x81, // mov eax, 0x81818181
                      0x66, 0xb9, 0x7e, 0x7e, 0x7e, 0x7e, // mov ecx, 0x7e7e7e7e
                      0x66, 0x09, 0xc1,             // or ecx, eax
                      0xb1, 0x80,                   // mov cl, 0x80
                      0x80, 0xc9, 0xff,             // or cl, 0xff
                      0xb9, 0x55, 0x55,             // mov cx, 0x5555
                      0x81, 0xc9, 0xff, 0xff,       // or cx, 0xffff
                      0x66, 0xb9, 0x80, 0x81, 0x81, 0x81, // mov ecx, 0x81818181
                      0x66, 0x81, 0xc9, 0xff, 0xff, 0xff, 0xff, // or ecx, 0xffffffff
                      0xb9, 0x55, 0x55,             // mov cx, 0x5555
                      0x83, 0xc9, 0x7f,             // or cx, (sign)0xff
                      0x66, 0xb9, 0x80, 0x81, 0x81, 0x81, // mov ecx, 0x81818181
                      0x66, 0x83, 0xc9, 0x7f,       // or ecx, (sign)0xff
                      0xb9, 0x55, 0x55,             // mov cx, 0x5555
                      0x83, 0xc9, 0xf7,             // or cx, (sign)0xff
                      0x66, 0xb9, 0x80, 0x81, 0x81, 0x81, // mov ecx, 0x81818181
                      0x66, 0x83, 0xc9, 0xf7,       // or ecx, (sign)0xff
                      0xb0, 0x81,                   // mov al, 0x81
                      0xb1, 0xff,                   // mov cl, 0xff
                      0x30, 0xc1,                   // xor cl, al
                      0xb0, 0x55,                   // mov al, 0x55
                      0xb1, 0xff,                   // mov cl, 0xff
                      0x30, 0xc1,                   // xor cl, al
                      0xb0, 0x81,                   // mov al, 0x81
                      0xb1, 0x7e,                   // mov cl, 0x7e
                      0x30, 0xc1,                   // xor cl, al
                      0xb8, 0x81, 0x81,             // mov ax, 0x8181
                      0xb9, 0xff, 0xff,             // mov cx, 0xffff
                      0x31, 0xc1,                   // xor cx, ax
                      0xb8, 0x55, 0x55,             // mov ax, 0x5555
                      0xb9, 0xff, 0xff,             // mov cx, 0xffff
                      0x31, 0xc1,                   // xor cx, ax
                      0xb8, 0x81, 0x81,             // mov ax, 0x8181
                      0xb9, 0x7e, 0x7e,             // mov cx, 0x7e7e
                      0x31, 0xc1,                   // xor cx, ax
                      0x66, 0xb8, 0x80, 0x81, 0x81, 0x81, // mov eax, 0x81818181
                      0x66, 0xb9, 0xff, 0xff, 0xff, 0xff, // mov ecx, 0xffffffff
                      0x66, 0x31, 0xc1,             // xor ecx, eax
                      0x66, 0xb8, 0x55, 0x55, 0x55, 0x55, // mov eax, 0x55555555
                      0x66, 0xb9, 0xff, 0xff, 0xff, 0xff, // mov ecx, 0xffffffff
                      0x66, 0x31, 0xc1,             // xor ecx, eax
                      0x66, 0xb8, 0x81, 0x81, 0x81, 0x81, // mov eax, 0x81818181
                      0x66, 0xb9, 0x7e, 0x7e, 0x7e, 0x7e, // mov ecx, 0x7e7e7e7e
                      0x66, 0x31, 0xc1,             // xor ecx, eax
                      0xb1, 0x80,                   // mov cl, 0x80
                      0x80, 0xf1, 0xff,             // xor cl, 0xff
                      0xb9, 0x55, 0x55,             // mov cx, 0x5555
                      0x81, 0xf1, 0xff, 0xff,       // xor cx, 0xffff
                      0x66, 0xb9, 0x80, 0x81, 0x81, 0x81, // mov ecx, 0x81818181
                      0x66, 0x81, 0xf1, 0xff, 0xff, 0xff, 0xff, // xor ecx, 0xffffffff
                      0xb9, 0x55, 0x55,             // mov cx, 0x5555
                      0x83, 0xf1, 0x7f,             // xor cx, (sign)0xff
                      0x66, 0xb9, 0x80, 0x81, 0x81, 0x81, // mov ecx, 0x81818181
                      0x66, 0x83, 0xf1, 0x7f,       // xor ecx, (sign)0xff
                      0xb9, 0x55, 0x55,             // mov cx, 0x5555
                      0x83, 0xf1, 0xf7,             // xor cx, (sign)0xff
                      0x66, 0xb9, 0x80, 0x81, 0x81, 0x81, // mov ecx, 0x81818181
                      0x66, 0x83, 0xf1, 0xf7,       // xor ecx, (sign)0xff
                      0xb0, 0x81,                   // mov al, 0x81
                      0xa8, 0xff,                   // test al, 0xff
                      0xb0, 0x55,                   // mov al, 0x55
                      0xa8, 0xff,                   // test al, 0xff
                      0xb0, 0x81,                   // mov al, 0x81
                      0xa8, 0x7e,                   // test al, 0x7e
                      0xb8, 0x81, 0x81,             // mov ax, 0x8181
                      0xa9, 0xff, 0xff,             // test ax, 0xffff
                      0xb8, 0x55, 0x55,             // mov ax, 0x5555
                      0xa9, 0xff, 0xff,             // test ax, 0xffff
                      0xb8, 0x81, 0x81,             // mov ax, 0x8181
                      0xa9, 0x7e, 0x7e,             // test ax, 0x7e7e
                      0x66, 0xb8, 0x80, 0x81, 0x81, 0x81, // mov eax, 0x81818181
                      0x66, 0xa9, 0xff, 0xff, 0xff, 0xff, // test ecx, 0xffffffff
                      0x66, 0xb8, 0x55, 0x55, 0x55, 0x55, // mov eax, 0x55555555
                      0x66, 0xa9, 0xff, 0xff, 0xff, 0xff, // test eax, 0xffffffff
                      0x66, 0xb8, 0x81, 0x81, 0x81, 0x81, // mov eax, 0x81818181
                      0x66, 0xa9, 0x7e, 0x7e, 0x7e, 0x7e, // test eax, 0x7e7e7e7e
                      0xb2, 0x81,                    // mov dl, 0x81
                      0xf6, 0xd2,                    // not dl
                      0xba, 0x7e, 0x7e,              // mov dx, 0xfe7e
                      0xf7, 0xd2,                    // not dx
                      0x66, 0xba, 0x5a, 0xa5, 0x5a, 0xa5, // mov edx, 0xa55aa55a
                      0x66, 0xf7, 0xd2,              // not edx
                      0xb1, 0x81,                   // mov cl, 0x81
                      0xf6, 0xc1, 0xff,             // test cl, 0xff
                      0xb1, 0x55,                   // mov cl, 0x55
                      0xf6, 0xc1, 0xff,             // test cl, 0xff
                      0xb1, 0x81,                   // mov cl, 0x81
                      0xf6, 0xc1, 0x7e,             // test cl, 0x7e
                      0xb9, 0x81, 0x81,             // mov cx, 0x8181
                      0xf7, 0xc1, 0xff, 0xff,       // test cx, 0xffff
                      0xb9, 0x55, 0x55,             // mov cx, 0x5555
                      0xf7, 0xc1, 0xff, 0xff,       // test cx, 0xffff
                      0xb9, 0x81, 0x81,             // mov cx, 0x8181
                      0xf7, 0xc1, 0x7e, 0x7e,       // test cx, 0x7e7e
                      0x66, 0xb9, 0x81, 0x81, 0x81, 0x81, // mov ecx, 0x81818181
                      0x66, 0xf7, 0xc1, 0xff, 0xff, 0xff, 0xff, // test ecx, 0xffffffff
                      0x66, 0xb9, 0x55, 0x55, 0x55, 0x55, // mov ecx, 0x55555555
                      0x66, 0xf7, 0xc1, 0xff, 0xff, 0xff, 0xff, // test ecx, 0xffffffff
                      0x66, 0xb9, 0x81, 0x81, 0x81, 0x81, // mov ecx, 0x81818181
                      0x66, 0xf7, 0xc1, 0x7e, 0x7e, 0x7e, 0x7e, // test ecx, 0x7e7e7e7e
                      0xb2, 0x81,                    // mov dl, 0x81
                      0xf6, 0xda,                    // neg dl
                      0xba, 0x7e, 0xfe,              // mov dx, 0xfe7e
                      0xf7, 0xda,                    // neg dx
                      0x66, 0xba, 0x5a, 0xa5, 0x5a, 0xa5, // mov edx, 0xa55aa55a
                      0x66, 0xf7, 0xda,              // neg edx
                      0xb2, 0x7f,                    // mov dl, 0x7f
                      0xf6, 0xda,                    // neg dl
                      0xba, 0x7e, 0x7e,              // mov dx, 0x7e7e
                      0xf7, 0xda,                    // neg dx
                      0x66, 0xba, 0xa5, 0x5a, 0xa5, 0x5a, // mov edx, 0x5aa55aa5
                      0x66, 0xf7, 0xda,              // neg edx
                      0xb0, 0x7f,                   // mov al, 0x7f
                      0x98,                         // cbw
                      0xb0, 0x83,                   // mov al, 0x83
                      0x98,                         // cbw
                      0xb8, 0x01, 0x08,             // mov ax, 0x0801
                      0x99,                         // cwd
                      0xb8, 0x01, 0x80,             // mov ax, 0x8001
                      0x99,                         // cwd
                      0xb8, 0x7f, 0x7f,             // mov ax, 0x7f7f
                      0x66, 0x98,                   // cwde
                      0xb8, 0x83, 0x83,             // mov ax, 0x8383
                      0x66, 0x98,                   // cwde
                      0x66, 0xb8, 0x01, 0x08, 0x01, 0x08, // mov eax, 0x08010801
                      0x66, 0x99,                   // cdq
                      0x66, 0xb8, 0x01, 0x80, 0x01, 0x80, // mov eax, 0x80018001
                      0x66, 0x99,                   // cdq
                      0x66, 0x9c,                   // pushaf
                      0x9c,                         // pushf
                      0x66, 0xb8, 0xd7, 0x0c, 0x06, 0x00, // mov eax, 0x00060cd7
                      0x66, 0x50,                   // push eax
                      0x50,                         // push ax
                      0x9d,                         // popf
                      0x66, 0x9d,                   // popaf
                      0x9d,                         // popf
                      0x66, 0x9d,                   // popaf
                      0x68, 0xef, 0xfe,             // push 0xfeef
                      0x68, 0x11, 0x11,             // push 0x1111
                      0x66, 0x68, 0xef, 0xfe, 0xef, 0xfe, // push 0xfeeffeef
                      0x6a, 0xfe,                   // push 0xfe -> 0xfffe
                      0x6a, 0x7f,                   // push 0x7f -> 0x007f
                      0x66, 0x6a, 0xfe,             // push 0xfe -> 0xfffffffe
                      0x66, 0x6a, 0x7f,             // push 0x7f -> 0x0000007f
                      0x66, 0x9d,                   // popaf
                      0x66, 0x9d,                   // popaf
                      0x9d,                         // popf
                      0x9d,                         // popf
                      0x66, 0x9d,                   // popaf
                      0x9d,                         // popf
                      0x9d,                         // popf
                      0x60,                         // pusha
                      0x66, 0x60,                   // pushad
                      0x66, 0x31, 0xc0,             // xor eax, eax
                      0x66, 0x31, 0xc9,             // xor ecx, ecx
                      0x66, 0x31, 0xd2,             // xor edx, edx
                      0x66, 0x31, 0xdb,             // xor ebx, ebx
                      0x66, 0x31, 0xed,             // xor ebp, ebp
                      0x66, 0x31, 0xf6,             // xor esi, esi
                      0x66, 0x31, 0xff,             // xor edi, edi
                      0x66, 0x61,                   // popad
                      0x66, 0x31, 0xc0,             // xor eax, eax
                      0x66, 0x31, 0xc9,             // xor ecx, ecx
                      0x66, 0x31, 0xd2,             // xor edx, edx
                      0x66, 0x31, 0xdb,             // xor ebx, ebx
                      0x66, 0x31, 0xed,             // xor ebp, ebp
                      0x66, 0x31, 0xf6,             // xor esi, esi
                      0x66, 0x31, 0xff,             // xor edi, edi
                      0x61,                         // popa
                      0xb4, 0x40,                   // mov ah, 0x40 (ZF)
                      0x9e,                         // sahf
                      0x74, 0x00,                   // jz Ib .+1
                      0x75, 0x00,                   // jnz Ib .+1
                      0x0f, 0x84, 0x00, 0x00,       // jz Iv .+1
                      0x0f, 0x85, 0x00, 0x00,       // jnz Iv .+1
                      0x66, 0x0f, 0x84, 0x00, 0x00, 0x00, 0x00,  // jz Iv .+1
                      0x66, 0x0f, 0x85, 0x00, 0x00, 0x00, 0x00,  // jnz Iv .+1
                      0xb4, 0x01,                   // mov ah, 0x01 (CF)
                      0x9e,                         // sahf
                      0x72, 0x00,                   // jb Ib .+1
                      0x73, 0x00,                   // jnb Ib .+1
                      0x0f, 0x82, 0x00, 0x00,       // jb Iv .+1
                      0x0f, 0x83, 0x00, 0x00,       // jnb Iv .+1
                      0x66, 0x0f, 0x82, 0x00, 0x00, 0x00, 0x00,  // jb Iv .+1
                      0x66, 0x0f, 0x83, 0x00, 0x00, 0x00, 0x00,  // jnb Iv .+1
                      0xb4, 0x41,                   // mov ah, 0x41 (ZF-CF)
                      0x9e,                         // sahf
                      0x76, 0x00,                   // jbe Ib .+1
                      0x77, 0x00,                   // jnbe Ib .+1
                      0x0f, 0x86, 0x00, 0x00,       // jbe Iv .+1
                      0x0f, 0x87, 0x00, 0x00,       // jnbe Iv .+1
                      0x66, 0x0f, 0x86, 0x00, 0x00, 0x00, 0x00,  // jbe Iv .+1
                      0x66, 0x0f, 0x87, 0x00, 0x00, 0x00, 0x00,  // jnbe Iv .+1
                      0xb4, 0x80,                   // mov ah, 0x80 (SF)
                      0x9e,                         // sahf
                      0x78, 0x00,                   // js Ib .+1
                      0x79, 0x00,                   // jns Ib .+1
                      0x0f, 0x88, 0x00, 0x00,       // js Iv .+1
                      0x0f, 0x89, 0x00, 0x00,       // jns Iv .+1
                      0x66, 0x0f, 0x88, 0x00, 0x00, 0x00, 0x00,  // js Iv .+1
                      0x66, 0x0f, 0x89, 0x00, 0x00, 0x00, 0x00,  // jns Iv .+1
                      0xb4, 0x04,                   // mov ah, 0x04 (PF)
                      0x9e,                         // sahf
                      0x7a, 0x00,                   // jp Ib .+1
                      0x7b, 0x00,                   // jnp Ib .+1
                      0x0f, 0x8a, 0x00, 0x00,       // jp Iv .+1
                      0x0f, 0x8b, 0x00, 0x00,       // jnp Iv .+1
                      0x66, 0x0f, 0x8a, 0x00, 0x00, 0x00, 0x00,  // jp Iv .+1
                      0x66, 0x0f, 0x8b, 0x00, 0x00, 0x00, 0x00,  // jnp Iv .+1
                      0xb4, 0x80,                   // mov ah, 0x80 (SF)
                      0x9e,                         // sahf
                      0x7c, 0x00,                   // jl Ib .+1
                      0x7d, 0x00,                   // jnl Ib .+1
                      0x0f, 0x8c, 0x00, 0x00,       // jl Iv .+1
                      0x0f, 0x8d, 0x00, 0x00,       // jnl Iv .+1
                      0x66, 0x0f, 0x8c, 0x00, 0x00, 0x00, 0x00,  // jl Iv .+1
                      0x66, 0x0f, 0x8d, 0x00, 0x00, 0x00, 0x00,  // jnl Iv .+1
                      0xb4, 0xc0,                   // mov ah, 0xc0 (SF-ZF)
                      0x9e,                         // sahf
                      0x7e, 0x00,                   // jle Ib .+1
                      0x7f, 0x00,                   // jnle Ib .+1
                      0x0f, 0x8e, 0x00, 0x00,       // jle Iv .+1
                      0x0f, 0x8f, 0x00, 0x00,       // jnle Iv .+1
                      0x66, 0x0f, 0x8e, 0x00, 0x00, 0x00, 0x00,  // jle Iv .+1
                      0x66, 0x0f, 0x8f, 0x00, 0x00, 0x00, 0x00,  // jnle Iv .+1
                      0xb0, 0x80,                   // mov al, 0x80
                      0xd0, 0xc0,                   // rol al, 1
                      0x70, 0x00,                   // jo Ib .+1
                      0x71, 0x00,                   // jno Ib .+1
                      0x0f, 0x80, 0x00, 0x00,       // jo Iv .+1
                      0x0f, 0x81, 0x00, 0x00,       // jno Iv .+1
                      0x66, 0x0f, 0x80, 0x00, 0x00, 0x00, 0x00,  // jo Iv .+1
                      0x66, 0x0f, 0x81, 0x00, 0x00, 0x00, 0x00,  // jno Iv .+1
                      0xb8, 0x00, 0x00,             // mov ax, 0x0000
                      0xb9, 0x02, 0x00,             // mov cx, 0x0002
                      0x40,                         // inc ax
                      0xe2, 0xfd,                   // loop .-3
                      0x66, 0xb8, 0x00, 0x00, 0x00, 0x00, // mov eax, 0x00000000
                      0x66, 0xb9, 0x02, 0x00, 0x00, 0x00, // mov ecx, 0x00000001
                      0x66, 0x40,                   // inc eax
                      0x67, 0xe2, 0xfb,             // loop .-5
                      0xb8, 0x00, 0x00,             // mov ax, 0x0000
                      0xb9, 0x02, 0x00,             // mov cx, 0x0002
                      0x40,                         // inc ax
                      0xe1, 0xfd,                   // loopz .-3
                      0xb8, 0x00, 0x00,             // mov ax, 0x0000
                      0xb9, 0x02, 0x00,             // mov cx, 0x0002
                      0x40,                         // inc ax
                      0xe0, 0xfd,                   // loopnz .-3
                      0x31, 0xc0,                   // xor ax, ax
                      0xb9, 0x02, 0x00,             // mov cx, 0x0002
                      0x40,                         // inc ax
                      0xe0, 0xfd,                   // loopnz .-3
                      0x31, 0xc0,                   // xor ax, ax
                      0xb9, 0x02, 0x00,             // mov cx, 0x0002
                      0x90,                         // nop
                      0xe1, 0xfd,                   // loopz .-3
                      0xeb, 0x00,                   // jmp .+1
                      0xe9, 0x00, 0x00,             // jmp .+1
                      0x66, 0xe9, 0x00, 0x00, 0x00, 0x00, // jmp .+1
                      0xb0, 0x7f,                   // mov al, 0x7f
                      0x0f, 0xb6, 0xc8,             // movzb cx,al
                      0x0f, 0xbe, 0xc8,             // movsb cx,al
                      0xb0, 0x8f,                   // mov al, 0x8f
                      0x0f, 0xb6, 0xc8,             // movzb cx,al
                      0x0f, 0xbe, 0xc8,             // movsb cx,al
                      0xb0, 0x7f,                   // mov al, 0x7f
                      0x66, 0x0f, 0xb6, 0xc8,       // movzb ecx,al
                      0x66, 0x0f, 0xbe, 0xc8,       // movsb ecx,al
                      0xb0, 0x8f,                   // mov al, 0x8f
                      0x66, 0x0f, 0xb6, 0xc8,       // movzb ecx,al
                      0x66, 0x0f, 0xbe, 0xc8,       // movsb ecx,al
                      0xb8, 0x00, 0x7f,             // mov ax, 0x7f00
                      0x0f, 0xb7, 0xc8,             // movzw cx,ax
                      0x0f, 0xbf, 0xc8,             // movsw cx,ax
                      0xb8, 0x00, 0x8f,             // mov ax, 0x8f00
                      0x66, 0x0f, 0xb7, 0xc8,       // movzw ecx,ax
                      0x66, 0x0f, 0xbf, 0xc8,       // movsw ecx,ax
                      0xb8, 0x55, 0xaa,             // mov ax, 0xaa55
                      0x8e, 0xe0,                   // mov fs, ax
                      0x8c, 0xe1,                   // mov cx, fs
                      0x8e, 0xe9,                   // mov gs, cx
                      0x68, 0xef, 0xfe,             // push 0xfeef
                      0x68, 0x11, 0x11,             // push 0x1111
                      0x66, 0x68, 0xef, 0xfe, 0xef, 0xfe, // push 0xfeeffeef
                      0x66, 0x8f, 0xc1,             // pop ecx
                      0x8f, 0xc1,                   // pop cx
                      0x8f, 0xc2,                   // pop dx
                      0xb0, 0x03,                   // mov al, 0x03
                      0xb1, 0x05,                   // mov cl, 0x05
                      0xf6, 0xe1,                   // mul al, cl
                      0xb0, 0xff,                   // mov al, 0xff
                      0xb1, 0x10,                   // mov cl, 0x10
                      0xf6, 0xe1,                   // mul al, cl
                      0xb8, 0x03, 0x00,             // mov ax, 0x03
                      0xb9, 0x05, 0x00,             // mov cx, 0x05
                      0xf7, 0xe1,                   // mul ax, cx
                      0xb8, 0x00, 0xff,             // mov ax, 0xff00
                      0xb9, 0x10, 0x00,             // mov cx, 0x0010
                      0xf7, 0xe1,                   // mul ax, cx
                      0x66, 0xb8, 0x03, 0x00, 0x00, 0x00, // mov eax, 0x00000003
                      0x66, 0xb9, 0x05, 0x00, 0x00, 0x00, // mov ecx, 0x00000005
                      0x66, 0xf7, 0xe1,             // mul eax, ecx
                      0x66, 0xb8, 0x00, 0x00, 0x00, 0xff, // mov eax, 0xff000000
                      0x66, 0xb9, 0x10, 0x00, 0x00, 0x00, // mov ecx, 0x00000010
                      0x66, 0xf7, 0xe1,             // mul eax, ecx
                      0xb0, 0x03,                   // mov al, 0x03
                      0xb1, 0x05,                   // mov cl, 0x05
                      0xf6, 0xe9,                   // imul al, cl
                      0xb0, 0xff,                   // mov al, 0xff
                      0xb1, 0x10,                   // mov cl, 0x10
                      0xf6, 0xe9,                   // imul al, cl
                      0xb8, 0x03, 0x00,             // mov ax, 0x03
                      0xb9, 0x05, 0x00,             // mov cx, 0x05
                      0xf7, 0xe9,                   // imul ax, cx
                      0xb8, 0xff, 0xff,             // mov ax, 0xffff
                      0xb9, 0x10, 0x00,             // mov cx, 0x0010
                      0xf7, 0xe9,                   // imul ax, cx
                      0xb8, 0x00, 0xf0,             // mov ax, 0xf000
                      0xb9, 0x10, 0x00,             // mov cx, 0x0010
                      0xf7, 0xe9,                   // imul ax, cx
                      0x66, 0xb8, 0x03, 0x00, 0x00, 0x00, // mov eax, 0x00000003
                      0x66, 0xb9, 0x05, 0x00, 0x00, 0x00, // mov ecx, 0x00000005
                      0x66, 0xf7, 0xe9,             // imul eax, ecx
                      0x66, 0xb8, 0x00, 0x00, 0x00, 0xf0, // mov eax, 0xf0000000
                      0x66, 0xb9, 0x10, 0x00, 0x00, 0x00, // mov ecx, 0x00000010
                      0x66, 0xf7, 0xe9,             // imul eax, ecx
                      0xb8, 0x03, 0x00,             // mov ax, 0x0003
                      0x6b, 0xc8, 0x05,             // imul cx, ax, 0x05
                      0xb8, 0x00, 0xff,             // mov ax, 0xff00
                      0x6b, 0xc8, 0x10,             // imul cx, ax, 0x10
                      0xb8, 0x00, 0xf0,             // mov ax, 0xf000
                      0x6b, 0xc8, 0x10,             // imul cx, ax, 0x10
                      0xb8, 0x00, 0x10,             // mov ax, 0x1000
                      0x6b, 0xc8, 0xf0,             // imul cx, ax, 0xf0
                      0x66, 0xb8, 0x03, 0x00, 0x00, 0x00, // mov eax, 0x00000003
                      0x66, 0x6b, 0xc8, 0x05,             // imul ecx, eax, 0x05
                      0x66, 0xb8, 0x00, 0x00, 0x00, 0xff, // mov eax, 0xff000000
                      0x66, 0x6b, 0xc8, 0x10,             // imul ecx, eax, 0x10
                      0x66, 0xb8, 0x00, 0x00, 0x00, 0xf0, // mov eax, 0xf0000000
                      0x66, 0x6b, 0xc8, 0x10,             // imul ecx, eax, 0x10
                      0x66, 0xb8, 0x00, 0x00, 0x00, 0x10, // mov eax, 0x1000
                      0x66, 0x6b, 0xc8, 0xf0,             // imul ecx, eax, 0xf0
                      0xb8, 0x03, 0x00,             // mov ax, 0x0003
                      0x69, 0xc8, 0x05, 0x00,       // imul cx, ax, 0x0005
                      0xb8, 0x00, 0xff,             // mov ax, 0xff00
                      0x69, 0xc8, 0x10, 0x00,       // imul cx, ax, 0x0010
                      0xb8, 0x00, 0xf0,             // mov ax, 0xf000
                      0x69, 0xc8, 0x10, 0x00,       // imul cx, ax, 0x0010
                      0xb8, 0x00, 0x10,             // mov ax, 0x1000
                      0x69, 0xc8, 0x00, 0xf0,       // imul cx, ax, 0xf000
                      0x66, 0xb8, 0x03, 0x00, 0x00, 0x00, // mov eax, 0x00000003
                      0x66, 0x69, 0xc8, 0x05, 0x00, 0x00, 0x00, // imul ecx, eax, 0x00000005
                      0x66, 0xb8, 0x00, 0x00, 0x00, 0xff, // mov eax, 0xff000000
                      0x66, 0x69, 0xc8, 0x10, 0x00, 0x00, 0x00, // imul ecx, eax, 0x00000010
                      0x66, 0xb8, 0x00, 0x00, 0x00, 0xf0, // mov eax, 0xf0000000
                      0x66, 0x69, 0xc8, 0x10, 0x00, 0x00, 0x00, // imul ecx, eax, 0x00000010
                      0x66, 0xb8, 0x00, 0x00, 0x00, 0x10, // mov eax, 0x10000000
                      0x66, 0x69, 0xc8, 0xf0, 0xff, 0xff, 0xff, // imul ecx, eax, 0xfffffff0
                      0xb8, 0x03, 0x00,             // mov ax, 0x0003
                      0xb9, 0x05, 0x00,             // mov cx, 0x0005
                      0x0f, 0xaf, 0xc8,             // imul cx, ax
                      0xb8, 0x00, 0xff,             // mov ax, 0xff00
                      0xb9, 0x10, 0x00,             // mov cx, 0x0010
                      0x0f, 0xaf, 0xc8,             // imul cx,ax
                      0xb8, 0x00, 0xf0,             // mov ax, 0xf000
                      0xb9, 0x10, 0x00,             // mov cx, 0x0010
                      0x0f, 0xaf, 0xc8,             // imul cx,ax
                      0xb8, 0x00, 0x10,             // mov ax, 0x1000
                      0xb9, 0x00, 0xf0,             // mov cx, 0xf000
                      0x0f, 0xaf, 0xc8,             // imul cx,ax
                      0x66, 0xb8, 0x03, 0x00, 0x00, 0x00, // mov eax, 0x00000003
                      0x66, 0xb9, 0x05, 0x00, 0x00, 0x00, // mov ecx, 0x00000005
                      0x66, 0x0f, 0xaf, 0xc8,       // imul ecx, eax
                      0x66, 0xb8, 0x00, 0x00, 0x00, 0xff, // mov eax, 0xff000000
                      0x66, 0xb9, 0x10, 0x00, 0x00, 0x00, // mov ecx, 0x00000010
                      0x66, 0x0f, 0xaf, 0xc8,       // imul ecx, eax
                      0x66, 0xb8, 0x00, 0x00, 0x00, 0xf0, // mov eax, 0xf0000000
                      0x66, 0xb9, 0x10, 0x00, 0x00, 0x00, // mov ecx, 0x00000010
                      0x66, 0x0f, 0xaf, 0xc8,       // imul ecx, eax
                      0x66, 0xb8, 0x00, 0x00, 0x00, 0x10, // mov eax, 0x10000000
                      0x66, 0xb9, 0xf0, 0xff, 0xff, 0xff, // mov ecx, 0xfffffff0
                      0x66, 0x0f, 0xaf, 0xc8,       // imul ecx, eax
                      0xb1, 0xfe,                   // mov cl, 0xfe
                      0xfe, 0xc1,                   // inc cl
                      0xfe, 0xc1,                   // inc cl
                      0xfe, 0xc9,                   // dec cl
                      0xfe, 0xc9,                   // dec cl
                      0xb9, 0xfe, 0xff,             // mov cx, 0xfffe
                      0xff, 0xc1,                   // inc cx
                      0xff, 0xc1,                   // inc cx
                      0xff, 0xc9,                   // dec cx
                      0xff, 0xc9,                   // dec cx
                      0x66, 0xb9, 0xfe, 0xff, 0xff, 0xff, // mov ecx, 0xfffffffe
                      0x66, 0xff, 0xc1,             // inc ecx
                      0x66, 0xff, 0xc1,             // inc ecx
                      0x66, 0xff, 0xc9,             // dec ecx
                      0x66, 0xff, 0xc9,             // dec ecx
                      0xff, 0xf2,                   // push dx
                      0x8f, 0xc3,                   // pop bx
                      0x66, 0xff, 0xf5,             // push ebp
                      0x66, 0x8f, 0xc6,             // pop esi
                      0xb8, 0x7f, 0x00,             // mov ax, 0x007f
                      0xb1, 0x04,                   // mov cl, 0x04
                      0xf6, 0xf1,                   // div ah:al, cl
                      0xb8, 0x80, 0x00,             // mov ax, 0x0080
                      0xb1, 0x10,                   // mov cl, 0x10
                      0xf6, 0xf1,                   // div ah:al, cl
                      0xb8, 0x0f, 0x7f,             // mov ax, 0x7f0f
                      0xba, 0x00, 0x00,             // mov dx, 0x0000
                      0xb9, 0x04, 0x00,             // mov cx, 0x04
                      0xf7, 0xf1,                   // div dx:ax, cx
                      0xb8, 0x00, 0x80,             // mov ax, 0x8000
                      0xba, 0x00, 0x00,             // mov dx, 0x0000
                      0xb9, 0x10, 0x00,             // mov cx, 0x10
                      0xf7, 0xf1,                   // div dx:ax, cx
                      0x66, 0xb8, 0x0f, 0x00, 0x00, 0x7f, // mov eax, 0x7f00000f
                      0x66, 0xba, 0x00, 0x00, 0x00, 0x00, // mov edx, 0x00000000
                      0x66, 0xb9, 0x04, 0x00, 0x00, 0x00, // mov ecx, 0x00000004
                      0x66, 0xf7, 0xf1,                   // div edx:eax, ecx
                      0x66, 0xb8, 0x00, 0x00, 0x00, 0x80, // mov eax, 0x80000000
                      0x66, 0xba, 0x00, 0x00, 0x00, 0x00, // mov edx, 0x00000000
                      0x66, 0xb9, 0x10, 0x00, 0x00, 0x00, // mov ecx, 0x00000010
                      0x66, 0xf7, 0xf1,                   // div edx:eax, ecx
                      0xb8, 0x7f, 0x00,             // mov ax, 0x007f
                      0xb1, 0x04,                   // mov cl, 0x04
                      0xf6, 0xf9,                   // idiv ah:al, cl
                      0xb8, 0x81, 0xff,             // mov ax, 0xff81
                      0xb1, 0x10,                   // mov cl, 0x10
                      0xf6, 0xf9,                   // idiv ah:al, cl
                      0xb8, 0x0f, 0x7f,             // mov ax, 0x7f0f
                      0xba, 0x00, 0x00,             // mov dx, 0x0000
                      0xb9, 0x04, 0x00,             // mov cx, 0x04
                      0xf7, 0xf9,                   // idiv dx:ax, cx
                      0xb8, 0x01, 0x80,             // mov ax, 0x8001
                      0xba, 0xff, 0xff,             // mov dx, 0xffff
                      0xb9, 0x10, 0x00,             // mov cx, 0x10
                      0xf7, 0xf9,                   // idiv dx:ax, cx
                      0x66, 0xb8, 0x0f, 0x00, 0x00, 0x7f, // mov eax, 0x7f00000f
                      0x66, 0xba, 0x00, 0x00, 0x00, 0x00, // mov edx, 0x00000000
                      0x66, 0xb9, 0x04, 0x00, 0x00, 0x00, // mov ecx, 0x00000004
                      0x66, 0xf7, 0xf9,                   // idiv edx:eax, ecx
                      0x66, 0xb8, 0x01, 0x00, 0x00, 0x80, // mov eax, 0x80000001
                      0x66, 0xba, 0xff, 0xff, 0xff, 0xff, // mov edx, 0xffffffff
                      0x66, 0xb9, 0x10, 0x00, 0x00, 0x00, // mov ecx, 0x00000010
                      0x66, 0xf7, 0xf9,                   // idiv edx:eax, ecx
                      0x66, 0xb8, 0x05, 0x50, 0x0a, 0xa0, // mov eax, 0xa00a5005
                      0xa2, 0x00, 0x00,             // mov 0x0000, al
                      0x67, 0xa2, 0x04, 0x00, 0x00, 0x00, // mov 0x00000004, al
                      0xa3, 0x08, 0x00,             // mov 0x0008, ax
                      0x67, 0xa3, 0x0c, 0x00, 0x00, 0x00, // mov 0x0000000c, ax
                      0x66, 0xa3, 0x10, 0x00,             // mov 0x0010, eax
                      0x66, 0x67, 0xa3, 0x14, 0x00, 0x00, 0x00, // mov 0x00000014, eax
                      0x66, 0xb8, 0x00, 0x00, 0x00, 0x00, // mov eax, 0x00000000
                      0xa0, 0x00, 0x00,             // mov al, ds:0x0000
                      0xb0, 0x00,                   // mov al, 0x00
                      0x67, 0xa0, 0x04, 0x00, 0x00, 0x00, // al, mov ds:0x00000004
                      0xb0, 0x00,                   // mov al, 0x00
                      0xa1, 0x08, 0x00,             // mov ax, ds:0x0008
                      0xb8, 0x00, 0x00,             // mov ax, 0x0000
                      0x67, 0xa1, 0x0c, 0x00, 0x00, 0x00, // mov ax, ds:0x0000000c
                      0xb8, 0x00, 0x00,             // mov ax, 0x0000
                      0x66, 0xa1, 0x10, 0x00,       // mov eax, ds:0x0010
                      0x66, 0xb8, 0x00, 0x00, 0x00, 0x00, // mov eax, 0x00000000
                      0x66, 0x67, 0xa1, 0x14, 0x00, 0x00, 0x00, // eax, ds:mov 0x00000014
                      0x66, 0xb9, 0x00, 0x00, 0x10, 0x10, // mov ecx, 0x10100000
                      0xe3, 0x00,                   // jcxz .+1
                      0xb9, 0x01, 0x01,             // mov cx, 0x0101
                      0xe3, 0x00,                   // jcxz .+1
                      0x66, 0xe3, 0x00,             // jecxz .+1
                      0x66, 0xb9, 0x00, 0x00, 0x00, 0x00, // mov ecx, 0x00000000
                      0x66, 0xe3, 0x00,             // jecxz .+1
                      0xb8, 0x01, 0x00,             // mov ax, 0x0001
                      0xb9, 0x02, 0x00,             // mov cx, 0x0002
                      0xba, 0x03, 0x00,             // mov dx, 0x0003
                      0xbb, 0x04, 0x00,             // mov bx, 0x0004
                      0xbd, 0x06, 0x00,             // mov bp, 0x0006
                      0xbe, 0x07, 0x00,             // mov si, 0x0007
                      0xbf, 0x08, 0x00,             // mov di, 0x0008
                      0x66, 0x8d, 0x80, 0x10, 0x10, // lea eax,[bx + si + 0x1010]
                      0x66, 0x8d, 0x81, 0x10, 0x10, // lea eax,[bx + di + 0x1010]
                      0x66, 0x8d, 0x82, 0x10, 0x10, // lea eax,[bp + si + 0x1010]
                      0x66, 0x8d, 0x83, 0x10, 0x10, // lea eax,[bp + di + 0x1010]
                      0x66, 0x8d, 0x84, 0x10, 0x10, // lea eax,[si + 0x1010]
                      0x66, 0x8d, 0x85, 0x10, 0x10, // lea eax,[di + 0x1010]
                      0x66, 0x8d, 0x86, 0x10, 0x10, // lea eax,[bp + 0x1010]
                      0x66, 0x8d, 0x87, 0x10, 0x10, // lea eax,[bx + 0x1010]
                      0x66, 0x8d, 0x40, 0x10,       // lea eax,[bx + si + 0x10]
                      0x66, 0x8d, 0x41, 0x10,       // lea eax,[bx + di + 0x10]
                      0x66, 0x8d, 0x42, 0x10,       // lea eax,[bp + si + 0x10]
                      0x66, 0x8d, 0x43, 0x10,       // lea eax,[bp + di + 0x10]
                      0x66, 0x8d, 0x44, 0x10,       // lea eax,[si + 0x10]
                      0x66, 0x8d, 0x45, 0x10,       // lea eax,[di + 0x10]
                      0x66, 0x8d, 0x46, 0x10,       // lea eax,[bp + 0x10]
                      0x66, 0x8d, 0x47, 0x10,       // lea eax,[bx + 0x10]
                      0x66, 0x8d, 0x00,             // lea eax,[bx + si]
                      0x66, 0x8d, 0x01,             // lea eax,[bx + di]
                      0x66, 0x8d, 0x02,             // lea eax,[bp + si]
                      0x66, 0x8d, 0x03,             // lea eax,[bp + di]
                      0x66, 0x8d, 0x04,             // lea eax,[si]
                      0x66, 0x8d, 0x05,             // lea eax,[di]
                      0x66, 0x8d, 0x06, 0xff, 0xee, // lea eax,[0xffee]
                      0x66, 0x8d, 0x07,             // lea eax,[bx]
                      0x8d, 0x80, 0x10, 0x10,       // lea ax,[bx + si + 0x1010]
                      0x8d, 0x81, 0x10, 0x10,       // lea ax,[bx + di + 0x1010]
                      0x8d, 0x82, 0x10, 0x10,       // lea ax,[bp + si + 0x1010]
                      0x8d, 0x83, 0x10, 0x10,       // lea ax,[bp + di + 0x1010]
                      0x8d, 0x84, 0x10, 0x10,       // lea ax,[si + 0x1010]
                      0x8d, 0x85, 0x10, 0x10,       // lea ax,[di + 0x1010]
                      0x8d, 0x86, 0x10, 0x10,       // lea ax,[bp + 0x1010]
                      0x8d, 0x87, 0x10, 0x10,       // lea ax,[bx + 0x1010]
                      0x8d, 0x40, 0x10,             // lea ax,[bx + si + 0x10]
                      0x8d, 0x41, 0x10,             // lea ax,[bx + di + 0x10]
                      0x8d, 0x42, 0x10,             // lea ax,[bp + si + 0x10]
                      0x8d, 0x43, 0x10,             // lea ax,[bp + di + 0x10]
                      0x8d, 0x44, 0x10,             // lea ax,[si + 0x10]
                      0x8d, 0x45, 0x10,             // lea ax,[di + 0x10]
                      0x8d, 0x46, 0x10,             // lea ax,[bp + 0x10]
                      0x8d, 0x47, 0x10,             // lea ax,[bx + 0x10]
                      0x8d, 0x00,                   // lea ax,[bx + si]
                      0x8d, 0x01,                   // lea ax,[bx + di]
                      0x8d, 0x02,                   // lea ax,[bp + si]
                      0x8d, 0x03,                   // lea ax,[bp + di]
                      0x8d, 0x04,                   // lea ax,[si]
                      0x8d, 0x05,                   // lea ax,[di]
                      0x8d, 0x06, 0xff, 0xee,       // lea ax,[0xffee]
                      0x8d, 0x07,                   // lea ax,[bx]
                      0xb8, 0x01, 0x00,             // mov ax, 0x0001
                      0xb9, 0x02, 0x00,             // mov cx, 0x0002
                      0xba, 0x03, 0x00,             // mov dx, 0x0003
                      0xbb, 0x04, 0x00,             // mov bx, 0x0004
                      0xbd, 0x06, 0x00,             // mov bp, 0x0006
                      0xbe, 0x07, 0x00,             // mov si, 0x0007
                      0xbf, 0x08, 0x00,             // mov di, 0x0008
                      0x67, 0x8d, 0x00,             // lea ax,[eax]
                      0x67, 0x8d, 0x01,             // lea ax,[ecx]
                      0x67, 0x8d, 0x02,             // lea ax,[edx]
                      0x67, 0x8d, 0x03,             // lea ax,[ebx]
                      0x67, 0x8d, 0x05, 0xff, 0xee, 0xdd, 0xcc, // lea ax,[0xccddeeff]
                      0x67, 0x8d, 0x06,             // lea ax,[esi]
                      0x67, 0x8d, 0x07,             // lea ax,[edi]
                      0x67, 0x8d, 0x40, 0x10,       // lea ax,[eax + 0x10]
                      0x67, 0x8d, 0x41, 0x10,       // lea ax,[ecx + 0x10]
                      0x67, 0x8d, 0x42, 0x10,       // lea ax,[edx + 0x10]
                      0x67, 0x8d, 0x43, 0x10,       // lea ax,[ebx + 0x10]
                      0x67, 0x8d, 0x45, 0x10,       // lea ax,[ebp + 0x10]
                      0x67, 0x8d, 0x46, 0x10,       // lea ax,[esi + 0x10]
                      0x67, 0x8d, 0x47, 0x10,       // lea ax,[edi + 0x10]
                      0x67, 0x8d, 0x80, 0x10, 0x10, 0x10, 0x10, // lea ax,[eax + 0x10101010]
                      0x67, 0x8d, 0x81, 0x10, 0x10, 0x10, 0x10, // lea ax,[ecx + 0x10101010]
                      0x67, 0x8d, 0x82, 0x10, 0x10, 0x10, 0x10, // lea ax,[edx + 0x10101010]
                      0x67, 0x8d, 0x83, 0x10, 0x10, 0x10, 0x10, // lea ax,[ebx + 0x10101010]
                      0x67, 0x8d, 0x85, 0x10, 0x10, 0x10, 0x10, // lea ax,[ebp + 0x10101010]
                      0x67, 0x8d, 0x86, 0x10, 0x10, 0x10, 0x10, // lea ax,[esi + 0x10101010]
                      0x67, 0x8d, 0x87, 0x10, 0x10, 0x10, 0x10, // lea ax,[edi + 0x10101010]
                      0x66, 0x67, 0x8d, 0x00,       // lea eax,[eax]
                      0x66, 0x67, 0x8d, 0x01,       // lea eax,[ecx]
                      0x66, 0x67, 0x8d, 0x02,       // lea eax,[edx]
                      0x66, 0x67, 0x8d, 0x03,       // lea eax,[ebx]
                      0x66, 0x67, 0x8d, 0x05, 0x10, 0x10, 0x10, 0x10, // lea eax,[0x10101010]
                      0x66, 0x67, 0x8d, 0x06,       // lea eax,[esi]
                      0x66, 0x67, 0x8d, 0x07,       // lea eax,[edi]
                      0x66, 0x67, 0x8d, 0x40, 0x10, // lea eax,[eax + 0x10]
                      0x66, 0x67, 0x8d, 0x41, 0x10, // lea eax,[ecx + 0x10]
                      0x66, 0x67, 0x8d, 0x42, 0x10, // lea eax,[edx + 0x10]
                      0x66, 0x67, 0x8d, 0x43, 0x10, // lea eax,[ebx + 0x10]
                      0x66, 0x67, 0x8d, 0x45, 0x10, // lea eax,[ebp + 0x10]
                      0x66, 0x67, 0x8d, 0x46, 0x10, // lea eax,[esi + 0x10]
                      0x66, 0x67, 0x8d, 0x47, 0x10, // lea eax,[edi + 0x10]
                      0x66, 0x67, 0x8d, 0x80, 0x10, 0x10, 0x10, 0x10, // lea eax,[eax + 0x10101010]
                      0x66, 0x67, 0x8d, 0x81, 0x10, 0x10, 0x10, 0x10, // lea eax,[ecx + 0x10101010]
                      0x66, 0x67, 0x8d, 0x82, 0x10, 0x10, 0x10, 0x10, // lea eax,[edx + 0x10101010]
                      0x66, 0x67, 0x8d, 0x83, 0x10, 0x10, 0x10, 0x10, // lea eax,[ebx + 0x10101010]
                      0x66, 0x67, 0x8d, 0x85, 0x10, 0x10, 0x10, 0x10, // lea eax,[ebp + 0x10101010]
                      0x66, 0x67, 0x8d, 0x86, 0x10, 0x10, 0x10, 0x10, // lea eax,[esi + 0x10101010]
                      0x66, 0x67, 0x8d, 0x87, 0x10, 0x10, 0x10, 0x10, // lea eax,[edi + 0x10101010]
                      0x66, 0xb8, 0x02, 0x00, 0xff, 0x00, // mov eax, 0x00ff0002
                      0x67, 0x8d, 0x04, 0x80,       // lea ax,[eax + eax * 2]
                      0x66, 0xb8, 0x02, 0x00, 0xff, 0x00, // mov eax, 0x00ff0002
                      0x67, 0x8d, 0x04, 0x81,       // lea ax,[ecx + eax * 2]
                      0x66, 0xb8, 0x02, 0x00, 0xff, 0x00, // mov eax, 0x00ff0002
                      0x67, 0x8d, 0x04, 0x82,       // lea ax,[edx + eax * 2]
                      0x66, 0xb8, 0x02, 0x00, 0xff, 0x00, // mov eax, 0x00ff0002
                      0x67, 0x8d, 0x04, 0x83,       // lea ax,[ebx + eax * 2]
                      0x66, 0xb8, 0x02, 0x00, 0xff, 0x00, // mov eax, 0x00ff0002
                      0x67, 0x8d, 0x04, 0x84,       // lea ax,[esp + eax * 2]
                      0x66, 0xb8, 0x02, 0x00, 0xff, 0x00, // mov eax, 0x00ff0002
                      0x67, 0x8d, 0x04, 0x85, 0x10, 0x10, 0x10, 0x10, // lea ax,[0x10101010 + eax * 2]
                      0x66, 0xb8, 0x02, 0x00, 0xff, 0x00, // mov eax, 0x00ff0002
                      0x67, 0x8d, 0x04, 0x86,       // lea ax,[esi + eax * 2]
                      0x66, 0xb8, 0x02, 0x00, 0xff, 0x00, // mov eax, 0x00ff0002
                      0x67, 0x8d, 0x04, 0x87,       // lea ax,[edi + eax * 2]
                      0x66, 0xb8, 0x02, 0x00, 0xff, 0x00, // mov eax, 0x00ff0002
                      0x67, 0x66, 0x8d, 0x04, 0x80,       // lea eax,[eax + eax * 2]
                      0x66, 0xb8, 0x02, 0x00, 0xff, 0x00, // mov eax, 0x00ff0002
                      0x67, 0x66, 0x8d, 0x04, 0x81,       // lea eax,[ecx + eax * 2]
                      0x66, 0xb8, 0x02, 0x00, 0xff, 0x00, // mov eax, 0x00ff0002
                      0x67, 0x66, 0x8d, 0x04, 0x82,       // lea eax,[edx + eax * 2]
                      0x66, 0xb8, 0x02, 0x00, 0xff, 0x00, // mov eax, 0x00ff0002
                      0x67, 0x66, 0x8d, 0x04, 0x83,       // lea eax,[ebx + eax * 2]
                      0x66, 0xb8, 0x02, 0x00, 0xff, 0x00, // mov eax, 0x00ff0002
                      0x67, 0x66, 0x8d, 0x04, 0x84,       // lea eax,[esp + eax * 2]
                      0x66, 0xb8, 0x02, 0x00, 0xff, 0x00, // mov eax, 0x00ff0002
                      0x67, 0x66, 0x8d, 0x04, 0x85, 0x10, 0x10, 0x10, 0x10, // lea eax,[0x10101010 + eax * 2]
                      0x66, 0xb8, 0x02, 0x00, 0xff, 0x00, // mov eax, 0x00ff0002
                      0x67, 0x66, 0x8d, 0x04, 0x86,       // lea eax,[esi + eax * 2]
                      0x66, 0xb8, 0x02, 0x00, 0xff, 0x00, // mov eax, 0x00ff0002
                      0x67, 0x66, 0x8d, 0x04, 0x87,       // lea eax,[edi + eax * 2]
                      0x66, 0xb8, 0x02, 0x00, 0x00, 0x00, // mov eax, 0x00000002
                      0x66, 0x67, 0x8d, 0x44, 0x80, 0x10, // lea eax,[eax + eax * 2 + 0x10]
                      0x66, 0xb8, 0x02, 0x00, 0x00, 0x00, // mov eax, 0x00000002
                      0x66, 0x67, 0x8d, 0x44, 0x81, 0x10, // lea eax,[ecx + eax * 2 + 0x10]
                      0x66, 0xb8, 0x02, 0x00, 0x00, 0x00, // mov eax, 0x00000002
                      0x66, 0x67, 0x8d, 0x44, 0x82, 0x10, // lea eax,[edx + eax * 2 + 0x10]
                      0x66, 0xb8, 0x02, 0x00, 0x00, 0x00, // mov eax, 0x00000002
                      0x66, 0x67, 0x8d, 0x44, 0x83, 0x10, // lea eax,[ebx + eax * 2 + 0x10]
                      0x66, 0xb8, 0x02, 0x00, 0x00, 0x00, // mov eax, 0x00000002
                      0x66, 0x67, 0x8d, 0x44, 0x84, 0x10, // lea eax,[esp + eax * 2 + 0x10]
                      0x66, 0xb8, 0x02, 0x00, 0x00, 0x00, // mov eax, 0x00000002
                      0x66, 0x67, 0x8d, 0x44, 0x85, 0x10, // lea eax,[ebp + eax * 2 + 0x10]
                      0x66, 0xb8, 0x02, 0x00, 0x00, 0x00, // mov eax, 0x00000002
                      0x66, 0x67, 0x8d, 0x44, 0x86, 0x10, // lea eax,[esi + eax * 2 + 0x10]
                      0x66, 0xb8, 0x02, 0x00, 0x00, 0x00, // mov eax, 0x00000002
                      0x66, 0x67, 0x8d, 0x44, 0x87, 0x10, // lea eax,[edi + eax * 2 + 0x10]
                      0x66, 0xb8, 0x02, 0x00, 0x00, 0x00, // mov eax, 0x00000002
                      0x66, 0x67, 0x8d, 0x84, 0x80, 0x10, 0x00, 0x00, 0x10, // lea eax,[eax + eax * 2 + 0x10000010]
                      0x66, 0xb8, 0x02, 0x00, 0x00, 0x00, // mov eax, 0x00000002
                      0x66, 0x67, 0x8d, 0x84, 0x81, 0x10, 0x00, 0x00, 0x10, // lea eax,[ecx + eax * 2 + 0x10000010]
                      0x66, 0xb8, 0x02, 0x00, 0x00, 0x00, // mov eax, 0x00000002
                      0x66, 0x67, 0x8d, 0x84, 0x82, 0x10, 0x00, 0x00, 0x10, // lea eax,[edx + eax * 2 + 0x10000010]
                      0x66, 0xb8, 0x02, 0x00, 0x00, 0x00, // mov eax, 0x00000002
                      0x66, 0x67, 0x8d, 0x84, 0x83, 0x10, 0x00, 0x00, 0x10, // lea eax,[ebx + eax * 2 + 0x10000010]
                      0x66, 0xb8, 0x02, 0x00, 0x00, 0x00, // mov eax, 0x00000002
                      0x66, 0x67, 0x8d, 0x84, 0x84, 0x10, 0x00, 0x00, 0x10, // lea eax,[esp + eax * 2 + 0x10000010]
                      0x66, 0xb8, 0x02, 0x00, 0x00, 0x00, // mov eax, 0x00000002
                      0x66, 0x67, 0x8d, 0x84, 0x85, 0x10, 0x00, 0x00, 0x10, // lea eax,[ebp + eax * 2 + 0x10000010]
                      0x66, 0xb8, 0x02, 0x00, 0x00, 0x00, // mov eax, 0x00000002
                      0x66, 0x67, 0x8d, 0x84, 0x86, 0x10, 0x00, 0x00, 0x10, // lea eax,[esi + eax * 2 + 0x10000010]
                      0x66, 0xb8, 0x02, 0x00, 0x00, 0x00, // mov eax, 0x00000002
                      0x66, 0x67, 0x8d, 0x84, 0x87, 0x10, 0x00, 0x00, 0x10, // lea eax,[edi + eax * 2 + 0x10000010]
                      0x90,                         // nop
                      0xfc,                         // cld
                      0xbe, 0x00, 0x00,             // mov si, 0x0000
                      0xbf, 0x02, 0x00,             // mov di, 0x0002
                      0xa4,                         // movsb
                      0x66, 0xb8, 0xaa, 0x55, 0xf0, 0x0f, // mov eax, 0x0ff055aa
                      0xbf, 0x00, 0x00,             // mov di, 0x0000
                      0xaa,                         // stosb
                      0xaa,                         // stosb
                      0xab,                         // stosw
                      0x66, 0xab,                   // stosd
                      0xb9, 0x04, 0x00,             // mov cx, 0x0004
                      0xf3, 0x66, 0xab,             // rep stosd
                      0x66, 0xb8, 0x5a, 0xa5, 0x00, 0xff, // mov eax, 0x0ff055aa
                      0xb9, 0x06, 0x00,             // mov cx, 0x0006
                      0xbf, 0x2c, 0x00,             // mov di, 0x002c
                      0xfd,                         // std
                      0xf3, 0x66, 0xab,             // rep stosd
                      0xc8, 0x00, 0x02, 0x00,       // enter 0x0200, 0x00
                      0xc9,                         // leave
                      0xc8, 0x00, 0x02, 0x01,       // enter 0x0200, 0x01
                      0xc9,                         // leave
                      0x66, 0xc8, 0x00, 0x02, 0x00, // enter 0x0200, 0x00
                      0x66, 0xc9,                   // leave
                      0x66, 0xc8, 0x00, 0x02, 0x01, // enter 0x0200, 0x01
                      0x66, 0xc9,                   // leave
                      0x66, 0xb8, 0x02, 0x00, 0xfe, 0xfe, // mov eax, 0xfefe0002
                      0x66, 0x89, 0x06, 0x04, 0x00, // mov ds:0x0004, eax
                      0x66, 0x89, 0x06, 0x08, 0x00, // mov ds:0x0008, eax
                      0xc4, 0x06, 0x04, 0x00,       // les ax,d:0x0004
                      0x0f, 0xb4, 0x0e, 0x04, 0x00, // lfs cx,d:0x0004
                      0x0f, 0xb5, 0x16, 0x04, 0x00, // lgs dx,d:0x0004
                      0x66, 0xc4, 0x1e, 0x04, 0x00, // les ebx,d:0x0004
                      0x66, 0x0f, 0xb4, 0x36, 0x04, 0x00, // lfs esi,d:0x0004
                      0x66, 0x0f, 0xb5, 0x3e, 0x04, 0x00, // lgs edi,d:0x0004
                      0xb8, 0x03, 0x00,             // mov ax, 0x0003
                      0x68, 0x10, 0x00,             // push 0x0010
                      0x9d,                         // popf
                      0x37,                         // aaa
                      0xd5, 0x0a,                   // aad
                      0xd4, 0x0a,                   // aam
                      0x27,                         // daa
                      0x2f,                         // das
                      0xb8, 0x03, 0x00,             // mov ax, 0x0003
                      0x68, 0x01, 0x00,             // push 0x0001
                      0x9d,                         // popf
                      0x37,                         // aaa
                      0xb8, 0x03, 0x00,             // mov ax, 0x0003
                      0x68, 0x10, 0x00,             // push 0x0010
                      0x9d,                         // popf
                      0x3f,                         // aas
                      0xd5, 0x0a,                   // aad
                      0xd4, 0x0a,                   // aam
                      0xb8, 0x03, 0x00,             // mov ax, 0x0003
                      0x68, 0x01, 0x00,             // push 0x0001
                      0x9d,                         // popf
                      0x3f,                         // aas
                      0xb8, 0x05, 0x00,             // mov ax, 0x0005
                      0xb9, 0x20, 0x00,             // mov cx, 0x0020
                      0xf8,                         // clc
                      0x0f, 0xa3, 0xc1,             // bt cx, ax
                      0xf8,                         // clc
                      0x0f, 0xb3, 0xc1,             // btr cx, ax
                      0xf9,                         // stc
                      0x0f, 0xab, 0xc1,             // bts cx, ax
                      0xf8,                         // clc
                      0x0f, 0xbb, 0xc1,             // btc cx, ax
                      0x66, 0xb8, 0x15, 0x00, 0x00, 0x00, // mov eax, 0x00000015
                      0x66, 0xb9, 0x00, 0x00, 0x20, 0x00, // mov ecx, 0x00200000
                      0xf8,                         // clc
                      0x66, 0x0f, 0xa3, 0xc1,       // bt ecx, eax
                      0xf8,                         // clc
                      0x66, 0x0f, 0xb3, 0xc1,       // btr ecx, eax
                      0xf9,                         // stc
                      0x66, 0x0f, 0xab, 0xc1,       // bts ecx, eax
                      0xf8,                         // clc
                      0x66, 0x0f, 0xbb, 0xc1,       // btc ecx, eax
                      0xb9, 0x20, 0x00,             // mov cx, 0x0020
                      0xf8,                         // clc
                      0x0f, 0xba, 0xe1, 0x05,       // bt cx, 0x05
                      0xf8,                         // clc
                      0x0f, 0xba, 0xf1, 0x05,       // btr cx, 0x05
                      0xf9,                         // stc
                      0x0f, 0xba, 0xe9, 0x05,       // bts cx, 0x05
                      0xf8,                         // clc
                      0x0f, 0xba, 0xf9, 0x05,       // btc cx, 0x05
                      0x66, 0xb9, 0x00, 0x00, 0x20, 0x00, // mov ecx, 0x00200000
                      0xf8,                         // clc
                      0x66, 0x0f, 0xba, 0xe1, 0x15, // bt ecx, 0x15
                      0xf8,                         // clc
                      0x66, 0x0f, 0xba, 0xf1, 0x15, // btr ecx, 0x15
                      0xf9,                         // stc
                      0x66, 0x0f, 0xba, 0xe9, 0x15, // bts ecx, 0x15
                      0xf8,                         // clc
                      0x66, 0x0f, 0xba, 0xf9, 0x15, // btc ecx, 0x15
                      0x66, 0xb8, 0x20, 0x00, 0x00, 0x00, // mov eax, 0x00000020
                      0x66, 0x89, 0x06, 0x08, 0x00, // mov ds:0x0008, eax
                      0xb8, 0x45, 0x00,             // mov ax, 0x0045
                      0xf8,                         // clc
                      0x0f, 0xa3, 0x06, 0x00, 0x00, // bt ds:0x0000, ax
                      0xf8,                         // clc
                      0x0f, 0xb3, 0x06, 0x00, 0x00, // btr ds:0x0000, ax
                      0xf9,                         // stc
                      0x0f, 0xab, 0x06, 0x00, 0x00, // bts ds:0x0000, ax
                      0xf8,                         // clc
                      0x0f, 0xbb, 0x06, 0x00, 0x00, // btc ds:0x0000, ax
                      0x66, 0xb8, 0x00, 0x00, 0x20, 0x00, // mov eax, 0x00200000
                      0x66, 0x89, 0x06, 0x08, 0x00, // mov ds:0x0008, eax
                      0x66, 0xb8, 0x55, 0x00, 0x00, 0x00, // mov eax, 0x00000055
                      0xf8,                         // clc
                      0x66, 0x0f, 0xa3, 0x06, 0x00, 0x00, // bt ds:0x0000, eax
                      0xf8,                         // clc
                      0x66, 0x0f, 0xb3, 0x06, 0x00, 0x00, // btr ds:0x0000, eax
                      0xf9,                         // stc
                      0x66, 0x0f, 0xab, 0x06, 0x00, 0x00, // bts ds:0x0000, eax
                      0xf8,                         // clc
                      0x66, 0x0f, 0xbb, 0x06, 0x00, 0x00, // btc ds:0x0000, eax
                      0xb8, 0xab, 0xab,             // mov ax, 0xabab
                      0xb9, 0x08, 0x00,             // mov cx, 0x0008
                      0xba, 0xfe, 0xfe,             // mov dx, 0xfefe
                      0x0f, 0xa4, 0xc2, 0x04,       // shld dx, ax, 0x04
                      0x0f, 0xa5, 0xc2,             // shld dx, ax, cl
                      0x66, 0xb8, 0xab, 0xab, 0xa5, 0x5a, // mov eax, 0x5aa5abab
                      0xb9, 0x08, 0x00,             // mov cx, 0x0008
                      0x66, 0xba, 0xfe, 0xfe, 0x12, 0x21, // mov edx, 0x2112fefe
                      0x66, 0x0f, 0xa4, 0xc2, 0x04, // shld edx, eax, 0x04
                      0x66, 0x0f, 0xa5, 0xc2,       // shld edx, eax, cl
                      0xb8, 0xab, 0xab,             // mov ax, 0xabab
                      0xb9, 0x08, 0x00,             // mov cx, 0x0008
                      0xba, 0xfe, 0xfe,             // mov dx, 0xfefe
                      0x0f, 0xac, 0xd0, 0x04,       // shld ax, dx, 0x04
                      0x0f, 0xad, 0xd0,             // shld ax, dx, cl
                      0x66, 0xb8, 0xab, 0xab, 0xa5, 0x5a, // mov eax, 0x5aa5abab
                      0xb9, 0x08, 0x00,             // mov cx, 0x0008
                      0x66, 0xba, 0xfe, 0xfe, 0x12, 0x21, // mov edx, 0x2112fefe
                      0x66, 0x0f, 0xac, 0xd0, 0x04, // shld eax, edx, 0x04
                      0x66, 0x0f, 0xad, 0xd0,       // shld eax, edx, cl
                      0xb0, 0xaa,                   // mov al, 0xaa
                      0xc0, 0xe0, 0x02,             // shl al, 0x02
                      0xb0, 0xaa,                   // mov al, 0xaa
                      0xc0, 0xe8, 0x03,             // shl al, 0x03
                      0xb0, 0xaa,                   // mov al, 0xaa
                      0xc0, 0xf8, 0x04,             // shl al, 0x04
//                      0xe8, 0x02, 0x00,             // call 0x0002
                      0x9a, 0x03, 0x00, 0x00, 0x20, // call 0x0003:0x2000
//                      0x66, 0xe8, 0x04, 0x00, 0x00, 0x00, // call 0x00000004
                      0x66, 0x9a, 0x06, 0x00, 0x00, 0x00, 0x00, 0x20, // call 0x00000006:0x2000
                      0x66, 0xb8, 0x02, 0x00, 0x00, 0x20, // mov eax, 0x20000002
                      0x66, 0x89, 0x06, 0x04, 0x00, // mov ds:0x0004, eax
                      0xff, 0x16, 0x04, 0x00,       // call ds:0x0004
                      0x66, 0xb8, 0x03, 0x00, 0x00, 0x20, // mov eax, 0x20000003
                      0x66, 0x89, 0x06, 0x04, 0x00, // mov ds:0x0004, eax
                      0xff, 0x1e, 0x04, 0x00,       // call ds:0x0004
                      0xb8, 0xaa, 0xaa,             // mov ax, 0xaaaa
                      0xc1, 0xe0, 0x02,             // shl ax, 0x02
                      0xb8, 0xaa, 0xaa,             // mov ax, 0xaaaa
                      0xc1, 0xe8, 0x03,             // shl ax, 0x03
                      0xb8, 0xaa, 0xaa,             // mov ax, 0xaaaa
                      0xc1, 0xf8, 0x04,             // shl ax, 0x04
                      0x66, 0xb8, 0xaa, 0xaa, 0xaa, 0xaa, // mov eax, 0xaaaaaaaa
                      0x66, 0xc1, 0xe0, 0x02,       // shl eax, 0x02
                      0x66, 0xb8, 0xaa, 0xaa, 0xaa, 0xaa, // mov eax, 0xaaaaaaaa
                      0x66, 0xc1, 0xe8, 0x03,       // shl eax, 0x03
                      0x66, 0xb8, 0xaa, 0xaa, 0xaa, 0xaa, // mov eax, 0xaaaaaaaa
                      0x66, 0xc1, 0xf8, 0x04,       // shl eax, 0x04
                      0xf0, 0x90,                   // lock nop
                      0x66, 0xb8, 0x12, 0x34, 0x56, 0x78, // mov eax, 0x78563412
                      0xe6, 0x04,                   // outb 0x04, al
                      0xe7, 0x08,                   // outw 0x09, ax
                      0x66, 0xe7, 0x0c,             // outd 0x0c, eax
                      0xba, 0x40, 0x00,             // mov dx, 0x0040
                      0xee,                         // outb dx, al
                      0x42,                         // inc dx
                      0x42,                         // inc dx
                      0xef,                         // outw dx, ax
                      0x42,                         // inc dx
                      0x42,                         // inc dx
                      0x66, 0xef,                   // outd dx, eax
                      0x66, 0xb8, 0x00, 0x00, 0x00, 0x00, // mov eax, 0x00000000
                      0xe4, 0x04,                   // inb al, 0x04
                      0xe5, 0x08,                   // inw ax, 0x08
                      0x66, 0xe5, 0x0c,             // ind eax, 0x0c
                      0x66, 0xb8, 0x00, 0x00, 0x00, 0x00, // mov eax, 0x00000000
                      0xba, 0x40, 0x00,             // mov dx, 0x0040
                      0xec,                         // inb al, dx
                      0x42,                         // inc dx
                      0x42,                         // inc dx
                      0xed,                         // inw ax, dx
                      0x42,                         // inc dx
                      0x42,                         // inc dx
                      0x66, 0xed,                   // ind eax, dx
//                      0xf4,                         // hlt (nop)
                      0xb8, 0x00, 0x00,              // mov ax, 0x0000
                      0x0f,0xbc, 0xc8,              // bsf cx, ax
                      0xb8, 0x00, 0x10,             // mov ax, 0x1000
                      0x0f,0xbc, 0xc8,              // bsf cx, ax
                      0xb8, 0x00, 0x00,             // mov ax, 0x0000
                      0x0f,0xbd, 0xc8,              // bsr cx, ax
                      0xb8, 0x10, 0x10,             // mov ax, 0x1010
                      0x0f,0xbd, 0xc8,              // bsr cx, ax
                      0x66, 0xb8, 0x00, 0x00, 0x00, 0x00, // mov eax, 0x00000000
                      0x66, 0x0f,0xbc, 0xc8,        // bsf ecx, eax
                      0x66, 0xb8, 0x00, 0x10, 0x00, 0x00, // mov eax, 0x00001000
                      0x66, 0x0f,0xbc, 0xc8,        // bsf ecx, eax
                      0x66, 0xb8, 0x00, 0x00, 0x00, 0x00, // mov eax, 0x00000000
                      0x66, 0x0f,0xbd, 0xc8,        // bsr ecx, eax
                      0x66, 0xb8, 0x10, 0x10, 0x00, 0x00, // mov eax, 0x00001010
                      0x66, 0x0f,0xbd, 0xc8,        // bsr ecx, eax
                      0xcc,                         // int 3
                      0xcd, 0x04,                   // int 0x04
                      0xcd, 0x05,                   // int 0x05
*/                      0x90,                         // nop
                      0x66, 0xb8, 0x11, 0x22, 0x33, 0x44, // mov eax, 0x44332211
                      0x66, 0x89, 0x06, 0x04, 0x00, // mov ds:0x0004, eax
                      0xb0, 0x01,                   // mov al, 0x01
                      0xbb, 0x03, 0x00,             // mov bx, 0x0003
                      0xd7,                         // xlat
                      0xb0, 0x02,                   // mov al, 0x01
                      0x66, 0xbb, 0x04, 0x00, 0x00, 0x00,  // mov ebx, 0x00000004
                      0x67, 0xd7,                   // xlat
                      0x66, 0xb8, 0x04, 0x00, 0x08, 0x00, // mov eax, 0x00080004
                      0x66, 0x89, 0x06, 0x04, 0x00, // mov ds:0x0004, eax
                      0x66, 0xb8, 0x04, 0x00, 0x08, 0x01, // mov eax, 0x01080004
                      0x66, 0x89, 0x06, 0x08, 0x00, // mov ds:0x0008, eax
                      0xb9, 0x04, 0x00,             // mov cx, 0x0004
                      0x62, 0x0e, 0x04, 0x00,       // bound cx, ds:0x0004
                      0x66, 0xb9, 0x04, 0x00, 0x08, 0x01, // mov ecx, 0x01080004
                      0x66, 0x62, 0x0e, 0x04, 0x00, // bound ecx, ds:0x0004
                      0x66, 0xb8, 0x11, 0x22, 0x33, 0x44, // mov eax, 0x44332211
                      0x0f, 0xc8, 0xc0,             // bswap ax
                      0x66, 0xb8, 0x11, 0x22, 0x33, 0x44, // mov eax, 0x44332211
                      0x66, 0x0f, 0xc8, 0xc0,       // bswap eax
                      0xb0, 0x01,                   // mov al, 0x01
                      0xb1, 0x01,                   // mov cl, 0x01
                      0xb2, 0xff,                   // mov dl, 0xff
                      0x0f, 0xb0, 0xd1,             // cmpxchg cl,dl
                      0xb0, 0x01,                   // mov al, 0x01
                      0xb1, 0x02,                   // mov cl, 0x02
                      0xb2, 0xff,                   // mov dl, 0xff
                      0x0f, 0xb0, 0xd1,             // cmpxchg cl,dl
                      0xb8, 0x01, 0x00,             // mov ax, 0x01
                      0xb9, 0x01, 0x00,             // mov cx, 0x01
                      0xba, 0xff, 0x00,             // mov dx, 0xff
                      0x0f, 0xb1, 0xd1,             // cmpxchg cx,dx
                      0xb8, 0x01, 0x00,             // mov ax, 0x01
                      0xb9, 0x02, 0x00,             // mov cx, 0x02
                      0xba, 0xff, 0x00,             // mov dx, 0xff
                      0x0f, 0xb1, 0xd1,             // cmpxchg cx,dx
                      0x66, 0xb8, 0x01, 0x00, 0x00, 0x00, // mov eax, 0x00000001
                      0x66, 0xb9, 0x01, 0x00, 0x00, 0x00, // mov ecx, 0x00000001
                      0x66, 0xba, 0xff, 0x00, 0x00, 0x00, // mov edx, 0x000000ff
                      0x66, 0x0f, 0xb1, 0xd1,             // cmpxchg ecx,edx
                      0x66, 0xb8, 0x01, 0x00, 0x00, 0x00, // mov eax, 0x00000001
                      0x66, 0xb9, 0x02, 0x00, 0x00, 0x00, // mov ecx, 0x00000002
                      0x66, 0xba, 0xff, 0x00, 0x00, 0x00, // mov edx, 0x000000ff
                      0x66, 0x0f, 0xb1, 0xd1,             // cmpxchg ecx,edx
                      0xb0, 0x01,                   // mov al, 0x01
                      0xb1, 0x02,                   // mov cl, 0x02
                      0x0f, 0xc0, 0xc8,             // xadd al,cl
                      0xb8, 0x01, 0x01,             // mov ax, 0x0101
                      0xb9, 0x02, 0x02,             // mov cx, 0x0202
                      0x0f, 0xc1, 0xc8,             // xadd ax,cx
                      0x66, 0xb8, 0x01, 0x01, 0x01, 0x01, // mov eax, 0x01010101
                      0x66, 0xb9, 0x02, 0x02, 0x02, 0x02, // mov ecx, 0x02020202
                      0x66, 0x0f, 0xc1, 0xc8,             // xadd eax,ecx
                      0xb8, 0x03, 0x00,             // mov ax, 0x0003
                      0x68, 0x10, 0x00,             // push 0x0010
                      0x9d,                         // popf
                      0x37,                         // aaa
                      0xd5, 0x0a,                   // aad
                      0xd4, 0x0a,                   // aam
                      0x27,                         // daa
                      0x2f,                         // das
                      0xb8, 0x03, 0x00,             // mov ax, 0x0003
                      0x68, 0x01, 0x00,             // push 0x0001
                      0x9d,                         // popf
                      0x37,                         // aaa
                      0xb8, 0x03, 0x00,             // mov ax, 0x0003
                      0x68, 0x10, 0x00,             // push 0x0010
                      0x9d,                         // popf
                      0x3f,                         // aas
                      0xd5, 0x0a,                   // aad
                      0xd4, 0x0a,                   // aam
                      0xb8, 0x03, 0x00,             // mov ax, 0x0003
                      0x68, 0x01, 0x00,             // push 0x0001
                      0x9d,                         // popf
                      0x3f,                         // aas
                      0xb0, 0x83,                   // mov al, 0x83
                      0x0f, 0x90, 0xc0,             // seto al
                      0xb0, 0x83,                   // mov al, 0x83
                      0x0f, 0x91, 0xc0,             // setno al
                      0x66, 0xb8, 0x00, 0x00, 0x00, 0x80, // mov eax, 0x80000000
                      0x66, 0xb9, 0x00, 0x00, 0x00, 0x80, // mov ecx, 0x80000000
                      0x66, 0x01, 0xc1,             // add ecx, eax
                      0x66, 0xb8, 0x00, 0x00, 0x00, 0x80, // mov eax, 0x80000000
                      0x66, 0xb9, 0x00, 0x00, 0x00, 0x80, // mov ecx, 0x80000000
                      0x66, 0x29, 0xc1,             // sub ecx, eax
                      0x66, 0xb8, 0x00, 0x00, 0x00, 0xb0, // mov eax, 0xb0000000
                      0x66, 0xb9, 0x00, 0x00, 0x00, 0x50, // mov ecx, 0x50000000
                      0x66, 0x01, 0xc1,             // add ecx, eax
                      0x66, 0xb8, 0xac, 0x08, 0x02, 0x08, // mov eax, 0x080208ac
                      0x66, 0xb9, 0x9b, 0x2a, 0xa4, 0xc8, // mov ecx, 0xc8a42a9b
                      0xf9,                         // stc
                      0x66, 0x1b, 0xc1,             // sbb eax, ecx
                      0x66, 0xb8, 0xcf, 0x33, 0xeb, 0xaf, // mov eax, 0xafeb33cf
                      0x66, 0xb9, 0x85, 0xed, 0xa5, 0xd0, // mov ecx, 0xd0a5ed85
                      0x66, 0x09, 0xc1,             // or ecx, eax
                      0xb4, 0xb3,                   // mov ah, 0xb3
                      0xb5, 0x0e,                   // mov ch, 0x0e
                      0x28, 0xe5,                   // sub ch, ah
                      0x66, 0xbf, 0x64, 0x4b, 0x7d, 0xdc, // mov edi, 0xdc7d4b64
                      0x66, 0xd1, 0xc7,             // rol edi, 1
                      0x66, 0xbe, 0xe7, 0x8b, 0x26, 0x34, // mov esi, 0x34268be7
                      0x66, 0xb9, 0x88, 0x00, 0x00, 0x00, // mov ecx, 0x00000088
                      0x66, 0xbf, 0x64, 0x4b, 0x7d, 0x8c, // mov edi, 0x8c7d4b64
                      0x66, 0xd1, 0xc7,             // rol edi, 1
                      0x66, 0x0f, 0xa4, 0xce, 0x1b, // shld esi, ecx, 0x1b
                      0x66, 0xbe, 0x98, 0x07, 0xe1, 0xeb, // mov esi, 0xebe10798
                      0x66, 0xb9, 0xa6, 0x50, 0x9b, 0xee, // mov ecx, 0xee9b50a6
                      0x66, 0xbf, 0x64, 0x4b, 0x7d, 0xdc, // mov edi, 0xdc7d4b64
                      0x66, 0xd1, 0xc7,             // rol edi, 1
                      0x66, 0x0f, 0xac, 0xce, 0x17, // shrd esi, ecx, 0x17
                      0xb0, 0x01,                   // mov al, 0x01
                      0xb7, 0x04,                   // mov bh, 0x04
                      0x0f, 0xb0, 0xc7,             // cmpxchg bh, al
                      0xcf,                         // iret
                      0xff};

//
// Define stack storage space.
//

ULONG StackSpace[4096 / 4];
ULONG DataSpace[4096 / 4];
ULONG IoSpace[4096 / 4];

//
// Define read and write I/O space functions.
//

ULONG
ReadIoSpace (
    IN XM_OPERATION_DATATYPE DataType,
    IN USHORT PortNumber
    )

{
    if (DataType == BYTE_DATA) {
        return *((UCHAR UNALIGNED *)((PUCHAR)(&IoSpace) + PortNumber));

    } else if (DataType == LONG_DATA) {
        return *((ULONG UNALIGNED *)((PUCHAR)(&IoSpace) + PortNumber));

    } else {
        return *((USHORT UNALIGNED *)((PUCHAR)(&IoSpace) + PortNumber));
    }
}

VOID
WriteIoSpace (
    IN XM_OPERATION_DATATYPE DataType,
    IN USHORT PortNumber,
    IN ULONG Value
    )

{

    if (DataType == BYTE_DATA) {
        *((UCHAR UNALIGNED *)((PUCHAR)(&IoSpace) + PortNumber)) = (UCHAR)Value;

    } else if (DataType == LONG_DATA) {
        *((ULONG UNALIGNED *)((PUCHAR)(&IoSpace) + PortNumber)) = Value;

    } else {
        *((USHORT UNALIGNED *)((PUCHAR)(&IoSpace) + PortNumber)) = (USHORT)Value;
    }

    return;
}

//
// Define address translation routine.
//

PVOID
TranslateAddress (
    IN USHORT Segment,
    IN USHORT Offset
    )

{

    ULONG Value;

    //
    // Case on high hex digit of segment.
    //

    Value = Offset + (Segment << 4);
    Offset = (USHORT)Value;
    Value &= 0xf0000;
    switch ((Value >> 16) & 0xf) {

        //
        // Interrupt vector/stack space.
        //

    case 0x0:
        return (PVOID)((PUCHAR)&StackSpace + Offset);

        //
        // Data space.
        //

    case 0x1:
        return (PVOID)((PUCHAR)&DataSpace + Offset);

        //
        // Code space.
        //

    case 0x2:
        return (PVOID)((PUCHAR)&CodeStream + Offset);

        //
        // No valid translation.
        //

    default:
        return NULL;
    }
}

VOID
__cdecl
main(
    int argc,
    char *argv[]
    )

{

    XM86_CONTEXT Context;
    PULONG Vector = &StackSpace[0];

    //
    // Initialize the emulator.
    //

    XmInitializeEmulator(0,
                         0x1000,
                         ReadIoSpace,
                         WriteIoSpace,
                         TranslateAddress);

    //
    // Initialize vector 255 and emulate an interrupt through that
    // vector.
    //

    Vector[3] = (0x2000 << 16) | 0x0008;
    Vector[4] = (0x2000 << 16) | 0x0008;
    Vector[5] = (0x2000 << 16) | 0x0008;
    Vector[255] = (0x2000 << 16) | 0x0000;
    Context.Eax = 0;
    Context.Ecx = 0;
    Context.Edx = 0;
    Context.Ebx = 0;
    Context.Ebp = 0;
    Context.Esi = 0;
    Context.Edi = 0;
    XmContext.SegmentRegister[DS] = 0x1000;
    XmEmulateInterrupt(255, &Context);
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\x86new\jmpops.c ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    jmpops.c

Abstract:

    This module implements the code to emulate jump opcodes.

Author:

    David N. Cutler (davec) 13-Sep-1994

Environment:

    Kernel mode only.

Revision History:

--*/

#include "nthal.h"
#include "emulate.h"

VOID
XmJcxzOp (
    IN PRXM_CONTEXT P
    )

/*++

Routine Description:

    This function emulates a jcxz instruction.

Arguments:

    P - Supplies a pointer to the emulation context structure.

Return Value:

    None.

--*/

{

    ULONG Condition;

    //
    // If eCX is zero, then set the new IP value.
    //

    if (P->OpsizePrefixActive != FALSE) {
        Condition = P->Gpr[ECX].Exx;

    } else {
        Condition = P->Gpr[CX].Xx;
    }

    if (Condition == 0) {
        P->Eip = P->DstValue.Word;
        XmTraceJumps(P);
    }

    return;
}

VOID
XmJmpOp (
    IN PRXM_CONTEXT P
    )

/*++

Routine Description:

    This function emulates a jmp near relative instruction.

Arguments:

    P - Supplies a pointer to the emulation context structure.

Return Value:

    None.

--*/

{

    //
    // Set the destination segment, if required, and set the new IP.
    //

    P->Eip = P->DstValue.Long;
    if ((P->CurrentOpcode == 0xea) || (P->FunctionIndex != X86_JMP_OP)) {
        P->SegmentRegister[CS] = P->DstSegment;
    }

    XmTraceJumps(P);
    return;
}

VOID
XmJxxOp (
    IN PRXM_CONTEXT P
    )

/*++

Routine Description:

    This function emulates conditional jump instructions.

Arguments:

    P - Supplies a pointer to the emulation context structure.

Return Value:

    None.

--*/

{

    ULONG Complement;
    ULONG Condition;

    //
    // Case on the jump control value.
    //

    Complement = P->SrcValue.Long & 1;
    switch (P->SrcValue.Long >> 1) {

        //
        // Jump if overflow/not overflow.
        //

    case 0:
        Condition = P->Eflags.EFLAG_OF;
        break;

        //
        // Jump if below/not below.
        //

    case 1:
        Condition = P->Eflags.EFLAG_CF;
        break;

        //
        // Jump if zero/not zero.
        //

    case 2:
        Condition = P->Eflags.EFLAG_ZF;
        break;

        //
        // Jump if below or equal/not below or equal.
        //

    case 3:
        Condition = P->Eflags.EFLAG_CF | P->Eflags.EFLAG_ZF;
        break;

        //
        // Jump if signed/not signed.
        //

    case 4:
        Condition = P->Eflags.EFLAG_SF;
        break;

        //
        // Jump if parity/not parity.
        //

    case 5:
        Condition = P->Eflags.EFLAG_PF;
        break;

        //
        // Jump if less/not less.
        //

    case 6:
        Condition = (P->Eflags.EFLAG_SF ^ P->Eflags.EFLAG_OF);
        break;

        //
        // Jump if less or equal/not less or equal.
        //

    case 7:
        Condition = (P->Eflags.EFLAG_SF ^ P->Eflags.EFLAG_OF) | P->Eflags.EFLAG_ZF;
        break;
    }

    //
    // If the specified condition is met, then set the new IP value.
    //

    if ((Condition ^ Complement) != 0) {
        P->Eip = P->DstValue.Word;
        XmTraceJumps(P);
    }

    return;
}

VOID
XmLoopOp (
    IN PRXM_CONTEXT P
    )

/*++

Routine Description:

    This function emulates loop, loopz, or a loopnz instructions.

Arguments:

    P - Supplies a pointer to the emulation context structure.

Return Value:

    None.

--*/

{

    ULONG Condition;
    ULONG Result;
    ULONG Type;

    //
    // Set the address of the destination and compute the result value.
    //

    Result = P->Gpr[ECX].Exx - 1;
    P->DstLong = (UNALIGNED ULONG *)(&P->Gpr[ECX].Exx);
    if (P->OpaddrPrefixActive != FALSE) {
        P->DataType = LONG_DATA;

    } else {
        P->DataType = WORD_DATA;
        Result &= 0xffff;
    }

    XmStoreResult(P, Result);

    //
    // Isolate the loop type and test the appropriate condition.
    //
    // Type 0 - loopnz
    //      1 - loopz
    //      2 - loop
    //

    Type = P->CurrentOpcode & 3;
    if (Type == 0) {
        Condition = P->Eflags.EFLAG_ZF ^ 1;

    } else if (Type == 1) {
        Condition = P->Eflags.EFLAG_ZF;

    } else {
        Condition = TRUE;
    }

    //
    // If the loop condition is met, then set the new IP value.
    //

    if ((Condition != FALSE) && (Result != 0)) {
        P->Eip = P->DstValue.Word;
        XmTraceJumps(P);
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\x86new\logops.c ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    logops.c

Abstract:

    This module implements the code to emulate the and, or, test, xor,
    and not opcodes.

Author:

    David N. Cutler (davec) 12-Sep-1994

Environment:

    Kernel mode only.

Revision History:

--*/

#include "nthal.h"
#include "emulate.h"

//
// Define forward referenced prototypes.
//

VOID
XmSetLogicalResult (
    IN PRXM_CONTEXT P,
    IN ULONG Result
    );

VOID
XmAndOp (
    IN PRXM_CONTEXT P
    )

/*++

Routine Description:

    This function emulates an and opcode.

Arguments:

    P - Supplies a pointer to the emulation context structure.

Return Value:

    None.

--*/

{

    //
    // And operands and store result.
    //

    XmSetLogicalResult(P, P->DstValue.Long & P->SrcValue.Long);
    return;
}

VOID
XmOrOp (
    IN PRXM_CONTEXT P
    )

/*++

Routine Description:

    This function emulates an or opcode.

Arguments:

    P - Supplies a pointer to the emulation context structure.

Return Value:

    None.

--*/

{

    //
    // Or operands and store result.
    //

    XmSetLogicalResult(P, P->DstValue.Long | P->SrcValue.Long);
    return;
}

VOID
XmTestOp (
    IN PRXM_CONTEXT P
    )

/*++

Routine Description:

    This function emulates a test opcode.

Arguments:

    P - Supplies a pointer to the emulation context structure.

Return Value:

    None.

--*/

{

    //
    // And operands but don't store result.
    //

    XmSetLogicalResult(P, P->DstValue.Long & P->SrcValue.Long);
    return;
}

VOID
XmXorOp (
    IN PRXM_CONTEXT P
    )

/*++

Routine Description:

    This function emulates a xor opcode.

Arguments:

    P - Supplies a pointer to the emulation context structure.

Return Value:

    None.

--*/

{

    //
    // Xor operands and store result.
    //

    XmSetLogicalResult(P, P->DstValue.Long ^ P->SrcValue.Long);
    return;
}

VOID
XmNotOp (
    IN PRXM_CONTEXT P
    )

/*++

Routine Description:

    This function emulates a not opcode.

Arguments:

    P - Supplies a pointer to the emulation context structure.

Return Value:

    None.

--*/

{

    ULONG Mask;
    ULONG Shift;

    //
    // Complement operand and store result.
    //

    Shift = Shift = ((P->DataType + 1) << 3) - 1;
    Mask = ((1 << Shift) - 1) | (1 << Shift);
    XmStoreResult(P, ~P->DstValue.Long & Mask);
    return;
}

VOID
XmSetLogicalResult (
    IN PRXM_CONTEXT P,
    IN ULONG Result
    )

/*++

Routine Description:

    This function conditionally stores the result of a logical operation
    and computes the resultant condtion codes.

Arguments:

    P - Supplies a pointer to the emulation context structure.

    Result - Supplies the result value (note that the result is always
        zero extended to a long with no carry bits into the zero extended
        part).

Return Value:

    None.

--*/

{

    ULONG Shift;

    //
    // Store the result and compute auxilary carry flag, parity flag, sign
    // and zero flags.
    //

    if (P->FunctionIndex != X86_TEST_OP) {
        XmStoreResult(P, Result);
    }

    Shift = Shift = ((P->DataType + 1) << 3) - 1;
    P->Eflags.EFLAG_CF = 0;
    P->Eflags.EFLAG_PF = XmComputeParity(Result);
    P->Eflags.EFLAG_AF = 0;
    P->Eflags.EFLAG_ZF = (Result == 0);
    P->Eflags.EFLAG_SF = Result >> Shift;
    P->Eflags.EFLAG_OF = 0;
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\x86new\pcibios.c ===
/*++

Module Name:

    pcibios.c

Abstract:

    This module implements the INT 1a functions of the
    PCI BIOS Specification revision 2.1, which makes
    it possible to support video BIOSes that expect
    to be able to read and write PCI configuration
    space.

    In order to read and write to PCI configuration
    space, this code needs to call functions in the
    HAL that know how configuration space is
    implemented in the specific machine.  There are
    standard functions exported by the HAL to do
    this, but they aren't usually available (i.e.
    the bus handler code hasn't been set up yet) by
    the time that the video needs to be initialized.
    So the PCI BIOS functions in the emulator make
    calls to XmGetPciData and XmSetPciData, which
    are pointers to functions passed into the
    emulator by the HAL.  It is the responsibility of
    the calling code to provide functions which match
    these prototypes.

Author:

    Jake Oshins (joshins@vnet.ibm.com) 3-15-96

Environment:

    Kernel mode only.

Revision History:

--*/

#include "nthal.h"
#include "emulate.h"
#include "pci.h"

BOOLEAN
XmExecuteInt1a (
    IN OUT PRXM_CONTEXT Context
    )
/*++

Routine Description:

    The function calls the specific worker functions
    based upon the contents of the registers in Context.

Arguments:

    Context - State of the emulator

Return Value:

    None.

--*/
{
    //
    // If we aren't emulating PCI BIOS,
    // return.
    if (!XmPciBiosPresent) {
        return FALSE;
    }

    //
    // If this is not a call to PCI BIOS,
    // ignore it.
    //
    if (Context->Gpr[EAX].Xh != PCI_FUNCTION_ID) {
        return FALSE;
    }

    //
    // Switch on AL to see which PCI BIOS function
    // has been requested.
    //
    switch (Context->Gpr[EAX].Xl) {
    case PCI_BIOS_PRESENT:

        XmInt1aPciBiosPresent(Context);
        break;

    case PCI_FIND_DEVICE:

        XmInt1aFindPciDevice(Context);
        break;

    case PCI_FIND_CLASS_CODE:

        XmInt1aFindPciClassCode(Context);
        break;

    case PCI_GENERATE_CYCLE:

        XmInt1aGenerateSpecialCycle(Context);
        break;

    case PCI_GET_IRQ_ROUTING:

        XmInt1aGetRoutingOptions(Context);
        break;

    case PCI_SET_IRQ:

        XmInt1aSetPciIrq(Context);
        break;

    case PCI_READ_CONFIG_BYTE:
    case PCI_READ_CONFIG_WORD:
    case PCI_READ_CONFIG_DWORD:

        XmInt1aReadConfigRegister(Context);
        break;

    case PCI_WRITE_CONFIG_BYTE:
    case PCI_WRITE_CONFIG_WORD:
    case PCI_WRITE_CONFIG_DWORD:

        XmInt1aWriteConfigRegister(Context);
        break;

    default:
        return FALSE;
    }

    return TRUE;
}

VOID
XmInt1aPciBiosPresent(
    IN OUT PRXM_CONTEXT Context
    )
/*++

Routine Description:

    This function implements PCI_BIOS_PRESENT.

Arguments:

    Context - State of the emulator

Return Value:

    None.

--*/
{
    Context->Gpr[EDX].Exx = *(PULONG)(&"PCI ");

    // Present status is good:
    Context->Gpr[EAX].Xh = 0x0;

    // Hardware mechanism is:
    // Standard config mechanisms not supported,
    // Special cycles not supported
    // i.e.  We want all accesses to be done through software
    Context->Gpr[EAX].Xl = 0x0;

    // Interface level major version
    Context->Gpr[EBX].Xh = 0x2;

    // Interface level minor version
    Context->Gpr[EBX].Xl = 0x10;

    // Number of last PCI bus in system
    Context->Gpr[ECX].Xl = XmNumberPciBusses;

    // Present status good:
    Context->Eflags.EFLAG_CF = 0x0;
}

VOID
XmInt1aFindPciDevice(
    IN OUT PRXM_CONTEXT Context
    )
/*++

Routine Description:

    This function implements FIND_PCI_DEVICE.

Arguments:

    Context - State of the emulator
        [AH]    PCI_FUNCTION_ID
        [AL]    FIND_PCI_DEVICE
        [CX]    Device ID (0...65535)
        [DX]    Vendor ID (0...65534)
        [SI]    Index (0..N)


Return Value:

        [BH]    Bus Number
        [BL]    Device Number, Function Number
        [AH]    return code
        [CF]    completion status
--*/
{
    UCHAR Bus;
    PCI_SLOT_NUMBER Slot;
    ULONG Device;
    ULONG Function;
    ULONG Index = 0;
    ULONG buffer;

    if (Context->Gpr[EAX].Xx == PCI_ILLEGAL_VENDOR_ID) {
        Context->Gpr[EAX].Xh = PCI_BAD_VENDOR_ID;
        Context->Eflags.EFLAG_CF = 1;
        return;
    }

    Slot.u.AsULONG = 0;

    for (Bus = 0; Bus < XmNumberPciBusses; Bus++) {
        for (Device = 0; Device < 32; Device++) {
            for (Function = 0; Function < 8; Function++) {

                Slot.u.bits.DeviceNumber = Device;
                Slot.u.bits.FunctionNumber = Function;

                if (4 != XmGetPciData(Bus,
                                      Slot.u.AsULONG,
                                      &buffer,
                                      0, //offset of vendor ID
                                      4)) {

                    buffer = 0xffffffff;
                }

                //
                // Did we find the right one?
                //
                if (((buffer & 0xffff) == Context->Gpr[EDX].Xx) &&
                    (((buffer >> 16) & 0xffff) == Context->Gpr[ECX].Xx)) {

                    //
                    // Did we find the right occurrence?
                    //
                    if (Index++ == Context->Gpr[ESI].Xx) {

                    Context->Gpr[EBX].Xh = Bus;
                    Context->Gpr[EBX].Xl = (UCHAR)((Device << 3) | Function);
                    Context->Gpr[EAX].Xh = PCI_SUCCESS;
                    Context->Eflags.EFLAG_CF = 0;

                    return;
                    }
                }
            }
        }
    }

    Context->Gpr[EAX].Xh = PCI_DEVICE_NOT_FOUND;
    Context->Eflags.EFLAG_CF = 1;

}

VOID
XmInt1aFindPciClassCode(
    IN OUT PRXM_CONTEXT Context
    )
/*++

Routine Description:

    This function implements FIND_PCI_CLASS_CODE.

Arguments:

    Context - State of the emulator
        [AH]    PCI_FUNCTION_ID
        [AL]    FIND_PCI_CLASS_CODE
        [ECX]   Class Code (in lower three bytes)
        [SI]    Index (0..N)


Return Value:

        [BH]    Bus Number
        [BL]    Device Number, Function Number
        [AH]    return code
        [CF]    completion status
--*/
{
    UCHAR Bus;
    PCI_SLOT_NUMBER Slot;
    ULONG Index = 0;
    ULONG class_code;
    ULONG Device;
    ULONG Function;

    Slot.u.AsULONG = 0;

    for (Bus = 0; Bus < XmNumberPciBusses; Bus++) {
        for (Device = 0; Device < 32; Device++) {
            for (Function = 0; Function < 8; Function++) {

                Slot.u.bits.DeviceNumber = Device;
                Slot.u.bits.FunctionNumber = Function;

                if (4 != XmGetPciData(Bus,
                                      Slot.u.AsULONG,
                                      &class_code,
                                      8, //offset of vendor ID
                                      4)) {

                    class_code = 0xffffffff;
                }

                class_code >>= 8;

                //
                // Did we find the right one?
                //
                if (class_code == (Context->Gpr[ECX].Exx & 0xFFFFFF)) {

                    //
                    // Did we find the right occurrence?
                    //
                    if (Index++ == Context->Gpr[ESI].Xx) {

                    Context->Gpr[EBX].Xh = Bus;
                    Context->Gpr[EBX].Xl = (UCHAR)((Device << 3) | (Function));
                    Context->Gpr[EAX].Xh = PCI_SUCCESS;
                    Context->Eflags.EFLAG_CF = 0;

                    return;

                    }
                }
            }
        }
    }

    Context->Gpr[EAX].Xh = PCI_DEVICE_NOT_FOUND;
    Context->Eflags.EFLAG_CF = 1;

}

VOID
XmInt1aGenerateSpecialCycle(
    IN OUT PRXM_CONTEXT Context
    )
/*++

Routine Description:

    This function implements GENERATE_SPECIAL_CYCLE.  Since
    there is no uniform way to support special cycles from
    the NT HAL, we won't support this function.

Arguments:

    Context - State of the emulator

Return Value:

    [AH]    PCI_NOT_SUPPORTED

--*/
{
    Context->Gpr[EAX].Xh = PCI_NOT_SUPPORTED;
    Context->Eflags.EFLAG_CF = 1;
}

VOID
XmInt1aGetRoutingOptions(
    IN OUT PRXM_CONTEXT Context
    )
/*++

Routine Description:

    This function implements GET_IRQ_ROUTING_OPTIONS.  We
    won't allow devices to try to specify their own interrupt
    routing, partly because there isn't an easy way to do it,
    partly because this is done later by the HAL, and partly
    because almost no video devices generate interrupts.

Arguments:

    Context - State of the emulator

Return Value:

    [AH]    PCI_NOT_SUPPORTED

--*/
{
    Context->Gpr[EAX].Xh = PCI_NOT_SUPPORTED;
    Context->Eflags.EFLAG_CF = 1;
}

VOID
XmInt1aSetPciIrq(
    IN OUT PRXM_CONTEXT Context
    )
/*++

Routine Description:

    This function implements SET_PCI_IRQ.  We
    won't allow devices to try to specify their own interrupt
    routing, partly because there isn't an easy way to do it,
    partly because this is done later by the HAL, and partly
    because almost no video devices generate interrupts.

Arguments:

    Context - State of the emulator

Return Value:

    [AH]    PCI_NOT_SUPPORTED

--*/
{
    Context->Gpr[EAX].Xh = PCI_NOT_SUPPORTED;
    Context->Eflags.EFLAG_CF = 1;
}



VOID
XmInt1aReadConfigRegister(
    IN OUT PRXM_CONTEXT Context
    )
/*++

Routine Description:

    This function implements READ_CONFIG_BYTE,
    READ_CONFIG_WORD and READ_CONFIG_DWORD.

Arguments:

    Context - State of the emulator
        [AH]    PCI_FUNCTION_ID
        [AL]    function
        [BH]    bus number
        [BL]    device number/function number
        [DI]    Register number


Return Value:

        [ECX]   data read
        [AH]    return code
        [CF]    completion status
--*/
{
    UCHAR length;
    PCI_SLOT_NUMBER Slot;
    ULONG buffer;

    //
    // First, make sure that the register number is valid.
    //
    if (((Context->Gpr[EAX].Xl == PCI_READ_CONFIG_WORD) &&
         (Context->Gpr[EBX].Xl % 2)) ||
        ((Context->Gpr[EAX].Xl == PCI_READ_CONFIG_DWORD) &&
         (Context->Gpr[EBX].Xl % 4))
       )
    {
        Context->Gpr[EAX].Xh = PCI_BAD_REGISTER;
        Context->Eflags.EFLAG_CF = 1;
    }

    switch (Context->Gpr[EAX].Xl) {
    case PCI_READ_CONFIG_BYTE:
        length = 1;
        break;

    case PCI_READ_CONFIG_WORD:
        length = 2;
        break;

    case PCI_READ_CONFIG_DWORD:
        length = 4;
    }

    Slot.u.AsULONG = 0;
    Slot.u.bits.DeviceNumber   = Context->Gpr[EBX].Xl >> 3;
    Slot.u.bits.FunctionNumber = Context->Gpr[EBX].Xl;

    if (XmGetPciData(Context->Gpr[EBX].Xh,
                     Slot.u.AsULONG,
                     &buffer,
                     Context->Gpr[EDI].Xx,
                     length
                     ) == 0)
    {
        // This is the only error code supported by this function
        Context->Gpr[EAX].Xh = PCI_BAD_REGISTER;
        Context->Eflags.EFLAG_CF = 1;
        return;
    }

    switch (Context->Gpr[EAX].Xl) {
    case PCI_READ_CONFIG_BYTE:
        Context->Gpr[ECX].Xl = (UCHAR)(buffer & 0xff);
        break;

    case PCI_READ_CONFIG_WORD:
        Context->Gpr[ECX].Xx = (USHORT)(buffer & 0xffff);
        break;

    case PCI_READ_CONFIG_DWORD:
        Context->Gpr[ECX].Exx = buffer;
    }

    Context->Gpr[EAX].Xh = PCI_SUCCESS;
    Context->Eflags.EFLAG_CF = 0;

}


VOID
XmInt1aWriteConfigRegister(
    IN OUT PRXM_CONTEXT Context
    )
/*++

Routine Description:

    This function implements WRITE_CONFIG_BYTE,
    WRITE_CONFIG_WORD and WRITE_CONFIG_DWORD.

Arguments:

    Context - State of the emulator
        [AH]    PCI_FUNCTION_ID
        [AL]    function
        [BH]    bus number
        [BL]    device number/function number
        [DI]    Register number


Return Value:

        [ECX]   data read
        [AH]    return code
        [CF]    completion status
--*/
{
    UCHAR length;
    PCI_SLOT_NUMBER Slot;
    ULONG buffer;

    //
    // First, make sure that the register number is valid.
    //
    if (((Context->Gpr[EAX].Xl == PCI_WRITE_CONFIG_WORD) &&
         (Context->Gpr[EBX].Xl % 2)) ||
        ((Context->Gpr[EAX].Xl == PCI_WRITE_CONFIG_DWORD) &&
         (Context->Gpr[EBX].Xl % 4))
       )
    {
        Context->Gpr[EAX].Xh = PCI_BAD_REGISTER;
        Context->Eflags.EFLAG_CF = 1;
    }

    //
    // Find out how many bytes to write
    //
    switch (Context->Gpr[EAX].Xl) {
    case PCI_WRITE_CONFIG_BYTE:
        length = 1;
        buffer = Context->Gpr[ECX].Xl;
        break;

    case PCI_WRITE_CONFIG_WORD:
        length = 2;
        buffer = Context->Gpr[ECX].Xx;
        break;

    case PCI_WRITE_CONFIG_DWORD:
        length = 4;
        buffer = Context->Gpr[ECX].Exx;
    }

    //
    // Unpack the Slot/Function information
    //
    Slot.u.AsULONG = 0;
    Slot.u.bits.DeviceNumber   = Context->Gpr[EBX].Xl >> 3;
    Slot.u.bits.FunctionNumber = Context->Gpr[EBX].Xl;

    if (XmSetPciData(Context->Gpr[EBX].Xh,
                     Slot.u.AsULONG,
                     &buffer,
                     Context->Gpr[EDI].Xx,
                     length
                     ) == 0)
    {
        Context->Gpr[EAX].Xh = PCI_SUCCESS;
        Context->Eflags.EFLAG_CF = 0;
    } else {
        // This is the only error code supported by this function
        Context->Gpr[EAX].Xh = PCI_BAD_REGISTER;
        Context->Eflags.EFLAG_CF = 1;
    }


}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\x86new\moveops.c ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    movops.c

Abstract:

    This module implements the code to emulate the move and exchange
    opcodes.

Author:

    David N. Cutler (davec) 22-Sep-1994

Environment:

    Kernel mode only.

Revision History:

--*/

#include "nthal.h"
#include "emulate.h"

VOID
XmCbwOp (
    IN PRXM_CONTEXT P
    )

/*++

Routine Description:

    This function emulates a cbw opcode.

Arguments:

    P - Supplies a pointer to the emulation context structure.

Return Value:

    None.

--*/

{

    //
    // Sign extend byte to word or word to double.
    //

    P->DstLong = (ULONG UNALIGNED *)(&P->Gpr[EAX].Exx);
    if (P->OpsizePrefixActive != FALSE) {
        P->DataType = LONG_DATA;
        XmStoreResult(P, (ULONG)((LONG)((SHORT)P->Gpr[AX].Xx)));

    } else {
        P->DataType = WORD_DATA;
        XmStoreResult(P, (ULONG)((USHORT)((SCHAR)P->Gpr[AL].Xl)));
    }

    return;
}

VOID
XmCwdOp (
    IN PRXM_CONTEXT P
    )

/*++

Routine Description:

    This function emulates a cwd opcode.

Arguments:

    P - Supplies a pointer to the emulation context structure.

Return Value:

    None.

--*/

{

    //
    // Sign extend word to double or double to quad.
    //

    P->DstLong = (ULONG UNALIGNED *)(&P->Gpr[EDX].Exx);
    if (P->OpsizePrefixActive != FALSE) {
        P->DataType = LONG_DATA;
        XmStoreResult(P, (ULONG)((LONG)P->Gpr[EAX].Exx >> 31));

    } else {
        P->DataType = WORD_DATA;
        XmStoreResult(P, (ULONG)((USHORT)((SHORT)P->Gpr[AX].Xx >> 16)));
    }

    return;
}

VOID
XmMovOp (
    IN PRXM_CONTEXT P
    )

/*++

Routine Description:

    This function emulates a move general opcode.

Arguments:

    P - Supplies a pointer to the emulation context structure.

Return Value:

    None.

--*/

{

    //
    // Move source to destination.
    //

    XmStoreResult(P, P->SrcValue.Long);
    return;
}

VOID
XmXchgOp (
    IN PRXM_CONTEXT P
    )

/*++

Routine Description:

    This function emulates a xchg opcode.

Arguments:

    P - Supplies a pointer to the emulation context structure.

Return Value:

    None.

--*/

{

    //
    // Exchange source with destination.
    //

    if (P->DataType == BYTE_DATA) {
        *P->SrcByte = P->DstValue.Byte;

    } else if (P->DataType == LONG_DATA) {
        *P->SrcLong = P->DstValue.Long;

    } else {
        *P->SrcWord = P->DstValue.Word;
    }

    XmStoreResult(P, P->SrcValue.Long);
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\x86new\mulops.c ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    mulops.c

Abstract:

    This module implements the code to emulate the mul and imul opcodes.

Author:

    David N. Cutler (davec) 21-Sep-1994

Environment:

    Kernel mode only.

Revision History:

--*/

#include "nthal.h"
#include "emulate.h"

VOID
XmImulOp (
    IN PRXM_CONTEXT P
    )

/*++

Routine Description:

    This function emulates an imul opcode with a single destination.

Arguments:

    P - Supplies a pointer to the emulation context structure.

Return Value:

    None.

--*/

{

    LARGE_INTEGER Product;
    ULONG UpperEqual;

    //
    // Multiply the signed operands and store result.
    //

    if (P->DataType == BYTE_DATA) {
        Product.QuadPart = Int32x32To64((LONG)((SCHAR)P->DstValue.Byte),
                                        (LONG)((SCHAR)P->SrcValue.Byte));

        XmStoreResult(P, Product.LowPart & 0xff);
        UpperEqual = ((UCHAR)((Product.LowPart >> 8) & 0xff) !=
                      (UCHAR)((SCHAR)Product.LowPart >> 7));

    } else if (P->DataType == LONG_DATA) {
        Product.QuadPart = Int32x32To64((LONG)P->DstValue.Long,
                                        (LONG)P->SrcValue.Long);

        XmStoreResult(P, Product.LowPart);
        UpperEqual = (Product.HighPart != (LONG)Product.LowPart >> 31);

    } else {
        Product.QuadPart = Int32x32To64((LONG)((SHORT)P->DstValue.Word),
                                        (LONG)((SHORT)P->SrcValue.Word));

        XmStoreResult(P, Product.LowPart & 0xffff);
        UpperEqual = ((USHORT)((Product.LowPart >> 16) & 0xffff) !=
                      (USHORT)((SHORT)Product.LowPart >> 15));
    }

    P->Eflags.EFLAG_CF = UpperEqual;
    P->Eflags.EFLAG_OF = UpperEqual;
    return;
}

VOID
XmImulxOp (
    IN PRXM_CONTEXT P
    )

/*++

Routine Description:

    This function emulates an imul opcode with an extended destination.

Arguments:

    P - Supplies a pointer to the emulation context structure.

Return Value:

    None.

--*/

{

    LARGE_INTEGER Product;
    ULONG UpperEqual;

    //
    // Multiply the signed operands and store the result and the extended
    // result.
    //

    if (P->DataType == BYTE_DATA) {
        Product.QuadPart = Int32x32To64((LONG)((SCHAR)P->DstValue.Byte),
                                        (LONG)((SCHAR)P->SrcValue.Byte));

        P->DataType = WORD_DATA;
        XmStoreResult(P, Product.LowPart & 0xffff);
        UpperEqual = (P->Gpr[AX].Xh != (UCHAR)((SCHAR)P->Gpr[AX].Xl >> 7));

    } else if (P->DataType == LONG_DATA) {
        Product.QuadPart = Int32x32To64((LONG)P->DstValue.Long,
                                        (LONG)P->SrcValue.Long);

        XmStoreResult(P, Product.LowPart);
        P->DstLong = (UNALIGNED ULONG *)(&P->Gpr[EDX].Exx);
        XmStoreResult(P, (ULONG)Product.HighPart);
        UpperEqual = (Product.HighPart != (LONG)Product.LowPart >> 31);

    } else {
        Product.QuadPart = Int32x32To64((LONG)((SHORT)P->DstValue.Word),
                                        (LONG)((SHORT)P->SrcValue.Word));

        XmStoreResult(P, Product.LowPart & 0xffff);
        P->DstLong = (UNALIGNED ULONG *)(&P->Gpr[DX].Exx);
        XmStoreResult(P, Product.LowPart >> 16);
        UpperEqual = (P->Gpr[DX].Xx != (USHORT)((SHORT)P->Gpr[AX].Xx >> 15));
    }

    P->Eflags.EFLAG_CF = UpperEqual;
    P->Eflags.EFLAG_OF = UpperEqual;
    return;
}

VOID
XmMulOp (
    IN PRXM_CONTEXT P
    )

/*++

Routine Description:

    This function emulates a mul opcode.

Arguments:

    P - Supplies a pointer to the emulation context structure.

Return Value:

    None.

--*/

{

    ULARGE_INTEGER Product;
    ULONG UpperZero;

    //
    // Multiply the unsigned operands and store result.
    //

    Product.QuadPart = UInt32x32To64(P->DstValue.Long, P->SrcValue.Long);
    if (P->DataType == BYTE_DATA) {
        P->DataType = WORD_DATA;
        XmStoreResult(P, Product.LowPart);
        UpperZero = (P->Gpr[AX].Xh != 0);

    } else if (P->DataType == LONG_DATA) {
        XmStoreResult(P, Product.LowPart);
        P->DstLong = (UNALIGNED ULONG *)(&P->Gpr[EDX].Exx);
        XmStoreResult(P, Product.HighPart);
        UpperZero = (Product.HighPart != 0);

    } else {
        XmStoreResult(P, Product.LowPart & 0xffff);
        P->DstLong = (UNALIGNED ULONG *)(&P->Gpr[DX].Exx);
        XmStoreResult(P, Product.LowPart >> 16);
        UpperZero = (P->Gpr[DX].Xx != 0);
    }

    P->Eflags.EFLAG_CF = UpperZero;
    P->Eflags.EFLAG_OF = UpperZero;
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\x86new\operand.c ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    operand.c

Abstract:

    This module implements the operand functions necessary to decode x86
    instruction operands.

Author:

    David N. Cutler (davec) 3-Sep-1994

Environment:

    Kernel mode only.

Revision History:

--*/

#include "nthal.h"
#include "emulate.h"

ULONG
XmPushPopSegment (
    IN PRXM_CONTEXT P
    )

/*++

Routine Description:

    This function decodes x86 operand specifiers for the following opcodes:

    xxxxxx

Arguments:

    P - Supplies a pointer to an emulator context structure.

Return Value:

    A completion status of TRUE is returned as the function value.

--*/

{

    ULONG Index;

    //
    // Push or pop segment register.
    //

    Index = P->OpcodeControl.FormatType;
    P->DataType = WORD_DATA;
    if (P->FunctionIndex == X86_PUSH_OP) {
        XmSetSourceValue(P, (PVOID)(&P->SegmentRegister[Index]));

    } else {
        XmSetDestinationValue(P, (PVOID)(&P->SegmentRegister[Index]));
    }

    return TRUE;
}

ULONG
XmLoadSegment (
    IN PRXM_CONTEXT P
    )

/*++

Routine Description:

    This function decodes x86 operand specifiers for the following opcodes:

    xxxxxx

Arguments:

    P - Supplies a pointer to an emulator context structure.

Return Value:

    A completion status of TRUE is returned as the function value.

--*/

{

    ULONG Index;
    ULONG DataType;
    PVOID Operand;
    ULONG Number;

    //
    // Load a segment register and a displacement value into register.
    //

    Index = P->OpcodeControl.FormatType;
    if (P->OpsizePrefixActive != FALSE) {
        P->DataType = LONG_DATA;

    } else {
        P->DataType = WORD_DATA;
    }

    Operand = XmEvaluateAddressSpecifier(P, &Number);
    if (!Operand) return FALSE;
    if (P->RegisterOffsetAddress != FALSE) {
        longjmp(&P->JumpBuffer[0], XM_ILLEGAL_REGISTER_SPECIFIER);
    }

    XmSetSourceValue(P, Operand);
    DataType = P->DataType;
    P->DataType = WORD_DATA;
    Operand = XmGetOffsetAddress(P, P->Offset + DataType + 1);
    XmSetDestinationValue(P, Operand);
    P->SegmentRegister[Index - FormatLoadSegmentES] = P->DstValue.Word;
    P->DataType = DataType;
    P->DstLong = (ULONG UNALIGNED *)(&P->Gpr[Number].Exx);
    return TRUE;
}

ULONG
XmGroup1General (
    IN PRXM_CONTEXT P
    )

/*++

Routine Description:

    This function decodes x86 operand specifiers for the following opcodes:

    xxxxxx

Arguments:

    P - Supplies a pointer to an emulator context structure.

Return Value:

    A completion status of TRUE is returned as the function value.

--*/

{

    PVOID Operand;
    ULONG Number;

    //
    // Group 1 opcodes with general operand specifier and a direction
    // bit.
    //

    XmSetDataType(P);
    Operand = XmEvaluateAddressSpecifier(P, &Number);
    if (!Operand) return FALSE;
    if ((P->CurrentOpcode & DIRECTION_BIT) == 0) {
        XmSetDestinationValue(P, Operand);
        XmSetSourceValue(P, XmGetRegisterAddress(P, Number));

    } else {
        XmSetDestinationValue(P, XmGetRegisterAddress(P, Number));
        XmSetSourceValue(P, Operand);
    }

    return TRUE;
}

ULONG
XmGroup1Immediate (
    IN PRXM_CONTEXT P
    )

/*++

Routine Description:

    This function decodes x86 operand specifiers for the following opcodes:

    xxxxxx

Arguments:

    P - Supplies a pointer to an emulator context structure.

Return Value:

    A completion status of TRUE is returned as the function value.

--*/

{

    PVOID Operand;
    ULONG Number;
    ULONG Source;

    //
    // Group 1 opcode with general operand specifier and an immediate
    // operand.
    //

    XmSetDataType(P);
    Operand = XmEvaluateAddressSpecifier(P, &Number);
    Source = XmGetImmediateSourceValue(P, P->CurrentOpcode & SIGN_BIT);
    XmSetDestinationValue(P, Operand);
    XmSetImmediateSourceValue(P, Source);
    P->FunctionIndex += Number;
    return TRUE;
}

ULONG
XmGroup2By1 (
    IN PRXM_CONTEXT P
    )

/*++

Routine Description:

    This function decodes x86 operand specifiers for the following opcodes:

    xxxxxx

Arguments:

    P - Supplies a pointer to an emulator context structure.

Return Value:

    A completion status of TRUE is returned as the function value.

--*/

{

    PVOID Operand;
    ULONG Number;
    ULONG Source;

    //
    // Group 2 shift opcodes with a general operand specifier and a
    // shift count of 1.
    //

    XmSetDataType(P);
    Operand = XmEvaluateAddressSpecifier(P, &Number);
    if (!Operand) return FALSE;
    Source = 1;
    XmSetImmediateSourceValue(P, Source);
    XmSetDestinationValue(P, Operand);
    P->FunctionIndex += Number;
    return TRUE;
}

ULONG
XmGroup2ByCL (
    IN PRXM_CONTEXT P
    )

/*++

Routine Description:

    This function decodes x86 operand specifiers for the following opcodes:

    xxxxxx

Arguments:

    P - Supplies a pointer to an emulator context structure.

Return Value:

    A completion status of TRUE is returned as the function value.

--*/

{

    PVOID Operand;
    ULONG Number;
    ULONG Source;

    //
    // Group 2 shift opcodes with a general operand specifier and a
    // CL shift count.
    //

    XmSetDataType(P);
    Operand = XmEvaluateAddressSpecifier(P, &Number);
    if (!Operand) return FALSE;
    Source = (ULONG)P->Gpr[CL].Xl & 0x1f;
    XmSetImmediateSourceValue(P, Source);
    XmSetDestinationValue(P, Operand);
    P->FunctionIndex += Number;
    return TRUE;
}

ULONG
XmGroup2ByByte (
    IN PRXM_CONTEXT P
    )

/*++

Routine Description:

    This function decodes x86 operand specifiers for the following opcodes:

    xxxxxx

Arguments:

    P - Supplies a pointer to an emulator context structure.

Return Value:

    A completion status of TRUE is returned as the function value.

--*/

{

    PVOID Operand;
    ULONG Number;
    ULONG Source;

    //
    // Group 2 shift opcodes with a general operand specifier and a
    // byte immediate shift count.
    //

    XmSetDataType(P);
    Operand = XmEvaluateAddressSpecifier(P, &Number);
    Source = XmGetByteImmediate(P) & 0x1f;
    XmSetImmediateSourceValue(P, Source);
    XmSetDestinationValue(P, Operand);
    P->FunctionIndex += Number;
    return TRUE;
}

ULONG
XmGroup3General (
    IN PRXM_CONTEXT P
    )

/*++

Routine Description:

    This function decodes x86 operand specifiers for the following opcodes:

    xxxxxx

Arguments:

    P - Supplies a pointer to an emulator context structure.

Return Value:

    A completion status of TRUE is returned as the function value.

--*/

{

    PVOID Operand;
    ULONG Number;
    ULONG Source;

    //
    // Group 3 opcodes with general operand specifier.
    //
    // N.B. The test operator for this group has an immediate operand
    //      and the multiply and divide operators use the accumulator
    //      as a source. The not and neg operators are unary.
    //

    XmSetDataType(P);
    Operand = XmEvaluateAddressSpecifier(P, &Number);
    P->FunctionIndex += Number;
    if (P->FunctionIndex == X86_TEST_OP) {
        Source = XmGetImmediateSourceValue(P, 0);
        XmSetDestinationValue(P, Operand);
        XmSetImmediateSourceValue(P, Source);

    } else {

        //
        // If the operation is a mulitply or divide, then there is an
        // implied operand which is AL, AX, or EAX. If the operation is
        // a divide, then there is an additional implied operand which
        // is AH, DX, or EDX.
        //

        if ((Number & 0x4) != 0) {
            if ((Number & 0x2) == 0) {
                XmSetDestinationValue(P, (PVOID)(&P->Gpr[EAX].Exx));

            } else {
                P->DstLong = (UNALIGNED ULONG *)(&P->Gpr[EAX].Exx);
            }

            XmSetSourceValue(P, Operand);

        } else {
            XmSetDestinationValue(P, Operand);
        }
    }

    return TRUE;
}

ULONG
XmGroup45General (
    IN PRXM_CONTEXT P
    )

/*++

Routine Description:

    This function decodes x86 operand specifiers for the following opcodes:

    xxxxxx

Arguments:

    P - Supplies a pointer to an emulator context structure.

Return Value:

    A completion status of TRUE is returned as the function value.

--*/

{

    ULONG DataType;
    PVOID Operand;
    ULONG Number;

    //
    // Group 4 and group 5 unary opcodes with general operand specifier.
    //

    XmSetDataType(P);
    Operand = XmEvaluateAddressSpecifier(P, &Number);
    if (!Operand) return FALSE;
    if (P->OpcodeControl.FormatType == FormatGroup4General) {
        Number &= 0x1;
    }

    P->FunctionIndex += Number;
    if (P->FunctionIndex == X86_PUSH_OP) {
        XmSetSourceValue(P, Operand);

    } else {

        //
        // If the operation is a call or jump that specifies a segment,
        // then get the segment value.
        //

        XmSetDestinationValue(P, Operand);
        if ((Number == 3) || (Number == 5)) {
            if (P->RegisterOffsetAddress != FALSE) {
                longjmp(&P->JumpBuffer[0], XM_ILLEGAL_REGISTER_SPECIFIER);
            }

            DataType = P->DataType;
            P->DataType = WORD_DATA;
            Operand = XmGetOffsetAddress(P, P->Offset + DataType + 1);
            XmSetSourceValue(P, Operand);
            P->DstSegment = P->SrcValue.Word;
            P->DataType = DataType;
        }
    }

    return TRUE;
}

ULONG
XmGroup8BitOffset (
    IN PRXM_CONTEXT P
    )

/*++

Routine Description:

    This function decodes x86 operand specifiers for the following opcodes:

    xxxxxx

Arguments:

    P - Supplies a pointer to an emulator context structure.

Return Value:

    A completion status of TRUE is returned as the function value.

--*/

{

    PVOID Operand;
    ULONG Offset;
    ULONG Number;

    //
    // Bit test opcodes with an immediate bit offset and a memory or
    // register operand.
    //

    if (P->OpsizePrefixActive != FALSE) {
        P->DataType = LONG_DATA;

    } else {
        P->DataType = WORD_DATA;
    }

    Operand = XmEvaluateAddressSpecifier(P, &Number);
    Offset = XmGetByteImmediate(P);
    XmSetImmediateSourceValue(P, Offset);
    if (P->RegisterOffsetAddress == FALSE) {
        if (P->DataType == LONG_DATA) {
            Offset = (P->SrcValue.Long >> 5) << 2;

        } else {
            Offset = (P->SrcValue.Long >> 4) << 1;
        }

        Operand = XmGetOffsetAddress(P, Offset + P->Offset);
    }

    if (P->DataType == LONG_DATA) {
        P->SrcValue.Long &= 0x1f;

    } else {
        P->SrcValue.Long &= 0xf;
    }

    XmSetDestinationValue(P, Operand);
    P->FunctionIndex += (Number & 0x3);
    return TRUE;
}

ULONG
XmOpcodeRegister (
    IN PRXM_CONTEXT P
    )

/*++

Routine Description:

    This function decodes x86 operand specifiers for the following opcodes:

    xxxxxx

Arguments:

    P - Supplies a pointer to an emulator context structure.

Return Value:

    A completion status of TRUE is returned as the function value.

--*/

{

    ULONG Number;

    //
    // Unary opodes with a general register encoded in the low
    // 3 bits of the opcode value.
    //

    Number = P->CurrentOpcode & 0x7;
    if (P->OpsizePrefixActive != FALSE) {
        P->DataType = LONG_DATA;

    } else {
        P->DataType = WORD_DATA;
    }

    if (P->FunctionIndex == X86_PUSH_OP) {
        XmSetSourceValue(P, (PVOID)(&P->Gpr[Number].Exx));

    } else {
        XmSetDestinationValue(P, (PVOID)(&P->Gpr[Number].Exx));
    }

    return TRUE;
}

ULONG
XmLongJump (
    IN PRXM_CONTEXT P
    )

/*++

Routine Description:

    This function decodes x86 operand specifiers for the following opcodes:

    xxxxxx

Arguments:

    P - Supplies a pointer to an emulator context structure.

Return Value:

    A completion status of TRUE is returned as the function value.

--*/

{

    ULONG Offset;

    //
    // Long jump with opcode containing the control for conditional
    // jumps. The destination of the jump is stored in the destination
    // value and the jump control is stored in the sources value.
    //

    if (P->OpsizePrefixActive != FALSE) {
        Offset = XmGetLongImmediate(P);
        P->DstValue.Long = P->Eip + Offset;

    } else {
        Offset = XmGetWordImmediate(P);
        P->DstValue.Long = (USHORT)(Offset + P->Eip);
    }

    P->SrcValue.Long = P->CurrentOpcode & 0xf;
    return TRUE;
}

ULONG
XmShortJump (
    IN PRXM_CONTEXT P
    )

/*++

Routine Description:

    This function decodes x86 operand specifiers for the following opcodes:

    xxxxxx

Arguments:

    P - Supplies a pointer to an emulator context structure.

Return Value:

    A completion status of TRUE is returned as the function value.

--*/

{

    ULONG Offset;

    //
    // Short jump with opcode containing the control for conditional
    // jumps. The destination of the jump is stored in the destination
    // value and the jump control is stored in the sources value.
    //

    Offset = (ULONG)XmGetSignedByteImmediateToWord(P);
    P->DstValue.Long = (USHORT)(Offset + P->Eip);
    P->SrcValue.Long = P->CurrentOpcode & 0xf;
    return TRUE;
}

ULONG
XmSetccByte (
    IN PRXM_CONTEXT P
    )

/*++

Routine Description:

    This function decodes x86 operand specifiers for the following opcodes:

    xxxxxx

Arguments:

    P - Supplies a pointer to an emulator context structure.

Return Value:

    A completion status of TRUE is returned as the function value.

--*/

{

    ULONG Number;

    //
    // General byte destination with reg field ignored and the opcode
    // containing the condition control.
    //

    P->DataType = BYTE_DATA;
    P->DstByte = (UCHAR UNALIGNED *)XmEvaluateAddressSpecifier(P, &Number);
    P->SrcValue.Long = P->CurrentOpcode & 0xf;
    return TRUE;
}

ULONG
XmAccumImmediate (
    IN PRXM_CONTEXT P
    )

/*++

Routine Description:

    This function decodes x86 operand specifiers for the following opcodes:

    xxxxxx

Arguments:

    P - Supplies a pointer to an emulator context structure.

Return Value:

    A completion status of TRUE is returned as the function value.

--*/

{

    ULONG Source;

    //
    // Accumulator destination and immediate source operands.
    //

    XmSetDataType(P);
    Source = XmGetImmediateSourceValue(P, 0);
    XmSetDestinationValue(P, (PVOID)(&P->Gpr[EAX].Exx));
    XmSetImmediateSourceValue(P, Source);
    return TRUE;
}

ULONG
XmAccumRegister (
    IN PRXM_CONTEXT P
    )

/*++

Routine Description:

    This function decodes x86 operand specifiers for the following opcodes:

    xxxxxx

Arguments:

    P - Supplies a pointer to an emulator context structure.

Return Value:

    A completion status of TRUE is returned as the function value.

--*/

{

    ULONG Number;

    //
    // Accumulator destination and a general register source encoded in
    // the low 3-bits of the opcode value.
    //

    Number = P->CurrentOpcode & 0x7;
    if (P->OpsizePrefixActive != FALSE) {
        P->DataType = LONG_DATA;

    } else {
        P->DataType = WORD_DATA;
    }

    XmSetSourceValue(P, (PVOID)(&P->Gpr[Number].Exx));
    XmSetDestinationValue(P, (PVOID)(&P->Gpr[EAX].Exx));
    return TRUE;
}

ULONG
XmMoveGeneral (
    IN PRXM_CONTEXT P
    )

/*++

Routine Description:

    This function decodes x86 operand specifiers for the following opcodes:

    xxxxxx

Arguments:

    P - Supplies a pointer to an emulator context structure.

Return Value:

    A completion status of TRUE is returned as the function value.

--*/

{

    PVOID Operand;
    ULONG Number;

    //
    // Move opcodes with general operand specifier and a direction bit.
    //

    XmSetDataType(P);
    Operand = XmEvaluateAddressSpecifier(P, &Number);
    if (!Operand) return FALSE;
    if ((P->CurrentOpcode & DIRECTION_BIT) == 0) {
        P->DstLong = (ULONG UNALIGNED *)Operand;
        XmSetSourceValue(P, XmGetRegisterAddress(P, Number));

    } else {
        P->DstLong = (ULONG UNALIGNED *)XmGetRegisterAddress(P, Number);
        XmSetSourceValue(P, Operand);
    }

    return TRUE;
}

ULONG
XmMoveImmediate (
    IN PRXM_CONTEXT P
    )

/*++

Routine Description:

    This function decodes x86 operand specifiers for the following opcodes:

    xxxxxx

Arguments:

    P - Supplies a pointer to an emulator context structure.

Return Value:

    A completion status of TRUE is returned as the function value.

--*/

{

    PVOID Operand;
    ULONG Number;
    ULONG Source;

    //
    // Move opcodes with general operand specifier and an immediate
    // operand.
    //

    XmSetDataType(P);
    Operand = XmEvaluateAddressSpecifier(P, &Number);
    P->DstLong = (ULONG UNALIGNED *)Operand;
    Source = XmGetImmediateSourceValue(P, 0);
    XmSetImmediateSourceValue(P, Source);
    return TRUE;
}

ULONG
XmMoveRegImmediate (
    IN PRXM_CONTEXT P
    )

/*++

Routine Description:

    This function decodes x86 operand specifiers for the following opcodes:

    xxxxxx

Arguments:

    P - Supplies a pointer to an emulator context structure.

Return Value:

    A completion status of TRUE is returned as the function value.

--*/

{

    ULONG Number;

    //
    // Move register immediate opcodes with a general register encoded
    // in the low 3-bits of the opcode value and an immediate operand.
    //

    Number = P->CurrentOpcode & 0x7;
    if ((P->CurrentOpcode & 0x8) == 0) {
        P->DataType = BYTE_DATA;

    } else {
        if (P->OpsizePrefixActive != FALSE) {
            P->DataType = LONG_DATA;

        } else {
            P->DataType = WORD_DATA;
        }
    }

    P->DstLong = (ULONG UNALIGNED *)XmGetRegisterAddress(P, Number);
    XmSetImmediateSourceValue(P, XmGetImmediateSourceValue(P, 0));
    return TRUE;
}

ULONG
XmSegmentOffset (
    IN PRXM_CONTEXT P
    )

/*++

Routine Description:

    This function decodes x86 operand specifiers for the following opcodes:

    xxxxxx

Arguments:

    P - Supplies a pointer to an emulator context structure.

Return Value:

    A completion status of TRUE is returned as the function value.

--*/

{

    PVOID Operand;
    ULONG Offset;

    //
    // Move opcodes with an implied accumlator operand and an immediate
    // segment offset and a direction bit.
    //

    XmSetDataType(P);
    if (P->OpaddrPrefixActive != FALSE) {
        Offset = XmGetLongImmediate(P);

    } else {
        Offset = XmGetWordImmediate(P);
    }

    Operand = XmGetOffsetAddress(P, Offset);
    if ((P->CurrentOpcode & DIRECTION_BIT) == 0) {
        P->DstLong = (ULONG UNALIGNED *)(&P->Gpr[EAX].Exx);
        XmSetSourceValue(P, Operand);

    } else {
        P->DstLong = (ULONG UNALIGNED *)Operand;
        XmSetSourceValue(P, &P->Gpr[EAX].Exx);
    }

    return TRUE;
}

ULONG
XmMoveSegment (
    IN PRXM_CONTEXT P
    )

/*++

Routine Description:

    This function decodes x86 operand specifiers for the following opcodes:

    xxxxxx

Arguments:

    P - Supplies a pointer to an emulator context structure.

Return Value:

    A completion status of TRUE is returned as the function value.

--*/

{

    PVOID Operand;
    ULONG Number;

    //
    // Move segment opcodes with general operand specifier and a direction
    // bit.
    //

    P->DataType = WORD_DATA;
    Operand = XmEvaluateAddressSpecifier(P, &Number);
    if (!Operand) return FALSE;
    if ((P->CurrentOpcode & DIRECTION_BIT) == 0) {
        P->DstLong = (ULONG UNALIGNED *)Operand;
        XmSetSourceValue(P, (PVOID)(&P->SegmentRegister[Number]));

    } else {
        P->DstLong = (ULONG UNALIGNED *)(&P->SegmentRegister[Number]);
        XmSetSourceValue(P, Operand);
    }

    return TRUE;
}

ULONG
XmMoveXxGeneral (
    IN PRXM_CONTEXT P
    )

/*++

Routine Description:

    This function decodes x86 operand specifiers for the following opcodes:

    xxxxxx

Arguments:

    P - Supplies a pointer to an emulator context structure.

Return Value:

    A completion status of TRUE is returned as the function value.

--*/

{

    PVOID Operand;
    ULONG Number;

    //
    // Move zero or sign extended opcodes with general operand specifier.
    //

    if ((P->CurrentOpcode & WIDTH_BIT) == 0) {
        P->DataType = BYTE_DATA;

    } else {
        P->DataType = WORD_DATA;
    }

    Operand = XmEvaluateAddressSpecifier(P, &Number);
    if (!Operand) return FALSE;
    XmSetSourceValue(P, Operand);
    if (P->DataType == BYTE_DATA) {
        if ((P->CurrentOpcode & 0x8) == 0) {
            P->SrcValue.Long = (ULONG)P->SrcValue.Byte;

        } else {
            P->SrcValue.Long = (ULONG)((LONG)((SCHAR)P->SrcValue.Byte));
        }

    } else {
        if ((P->CurrentOpcode & 0x8) == 0) {
            P->SrcValue.Long = (ULONG)P->SrcValue.Word;

        } else {
            P->SrcValue.Long = (ULONG)((LONG)((SHORT)P->SrcValue.Word));
        }
    }

    if (P->OpsizePrefixActive != FALSE) {
        P->DataType = LONG_DATA;

    } else {
        P->DataType = WORD_DATA;
        P->SrcValue.Long &= 0xffff;
    }

    P->DstLong = (UNALIGNED ULONG *)(&P->Gpr[Number].Exx);
    return TRUE;
}

ULONG
XmFlagsRegister (
    IN PRXM_CONTEXT P
    )

/*++

Routine Description:

    This function decodes x86 operand specifiers for the following opcodes:

    xxxxxx

Arguments:

    P - Supplies a pointer to an emulator context structure.

Return Value:

    A completion status of TRUE is returned as the function value.

--*/

{

    //
    // Flags register source or destination with a stack source or
    // destination.
    //

    if (P->OpsizePrefixActive != FALSE) {
        P->DataType = LONG_DATA;

    } else {
        P->DataType = WORD_DATA;
    }

    if (P->FunctionIndex == X86_PUSH_OP) {
        XmSetSourceValue(P, (PVOID)(&P->AllFlags));

    } else {
        XmSetDestinationValue(P, (PVOID)(&P->AllFlags));
    }

    return TRUE;
}

ULONG
XmPushImmediate (
    IN PRXM_CONTEXT P
    )

/*++

Routine Description:

    This function decodes x86 operand specifiers for the following opcodes:

    xxxxxx

Arguments:

    P - Supplies a pointer to an emulator context structure.

Return Value:

    A completion status of TRUE is returned as the function value.

--*/

{

    ULONG Source;

    //
    // Push opcode with an immediate operand.
    //

    if (P->OpsizePrefixActive != FALSE) {
        P->DataType = LONG_DATA;

    } else {
        P->DataType = WORD_DATA;
    }

    Source = XmGetImmediateSourceValue(P, P->CurrentOpcode & SIGN_BIT);
    XmSetImmediateSourceValue(P, Source);
    return TRUE;
}

ULONG
XmPopGeneral (
    IN PRXM_CONTEXT P
    )

/*++

Routine Description:

    This function decodes x86 operand specifiers for the following opcodes:

    xxxxxx

Arguments:

    P - Supplies a pointer to an emulator context structure.

Return Value:

    A completion status of TRUE is returned as the function value.

--*/

{

    PVOID Operand;
    ULONG Number;

    //
    // Pop opcode with a general specifier.
    //

    if (P->OpsizePrefixActive != FALSE) {
        P->DataType = LONG_DATA;

    } else {
        P->DataType = WORD_DATA;
    }

    Operand = XmEvaluateAddressSpecifier(P, &Number);
    if (!Operand) return FALSE;
    XmSetDestinationValue(P, Operand);
    return TRUE;
}

ULONG
XmImulImmediate (
    IN PRXM_CONTEXT P
    )

/*++

Routine Description:

    This function decodes x86 operand specifiers for the following opcodes:

    xxxxxx

Arguments:

    P - Supplies a pointer to an emulator context structure.

Return Value:

    A completion status of TRUE is returned as the function value.

--*/

{

    ULONG Number;
    PVOID Operand;
    ULONG Source;

    //
    // Multiply signed opcode with a general specifier and an immediate
    // operand.
    //

    if (P->OpsizePrefixActive != FALSE) {
        P->DataType = LONG_DATA;

    } else {
        P->DataType = WORD_DATA;
    }

    Operand = XmEvaluateAddressSpecifier(P, &Number);
    Source = XmGetImmediateSourceValue(P, P->CurrentOpcode & SIGN_BIT);
    XmSetImmediateSourceValue(P, Source);
    XmSetDestinationValue(P, Operand);
    P->DstLong = (UNALIGNED ULONG *)(&P->Gpr[Number].Exx);
    return TRUE;
}

ULONG
XmStringOperands (
    IN PRXM_CONTEXT P
    )

/*++

Routine Description:

    This function decodes x86 operand specifiers for the following opcodes:

    xxxxxx

Arguments:

    P - Supplies a pointer to an emulator context structure.

Return Value:

    A completion status of TRUE is returned as the function value.

--*/

{

    //
    // String opcode with implicit operands of eSI and eDI.
    //

    XmSetDataType(P);
    return TRUE;
}

ULONG
XmEffectiveOffset (
    IN PRXM_CONTEXT P
    )

/*++

Routine Description:

    This function decodes x86 operand specifiers for the following opcodes:

    xxxxxx

Arguments:

    P - Supplies a pointer to an emulator context structure.

Return Value:

    A completion status of TRUE is returned as the function value.

--*/

{

    PVOID Operand;
    ULONG Number;

    //
    // Effective offset opcodes with general operand specifier.
    //

    if (P->OpsizePrefixActive != FALSE) {
        P->DataType = LONG_DATA;

    } else {
        P->DataType = WORD_DATA;
    }

    P->ComputeOffsetAddress = TRUE;
    Operand = XmEvaluateAddressSpecifier(P, &Number);
    if (P->RegisterOffsetAddress != FALSE) {
        longjmp(&P->JumpBuffer[0], XM_ILLEGAL_REGISTER_SPECIFIER);
    }

    P->SrcValue.Long = (ULONG)((ULONG_PTR)Operand);
    XmTraceSource(P, P->SrcValue.Long);
    P->DstLong = (ULONG UNALIGNED *)(&P->Gpr[Number].Exx);
    return TRUE;
}

ULONG
XmImmediateJump (
    IN PRXM_CONTEXT P
    )

/*++

Routine Description:

    This function decodes x86 operand specifiers for the following opcodes:

    xxxxxx

Arguments:

    P - Supplies a pointer to an emulator context structure.

Return Value:

    A completion status of TRUE is returned as the function value.

--*/

{

    //
    // Immediate long jump with the destination offset and new CS
    // segment value. The destination of the jump is stored in the
    // destination value and the new CS segment value is stored in
    // destination segment.
    //

    if (P->OpsizePrefixActive != FALSE) {
        P->DstValue.Long = XmGetLongImmediate(P);

    } else {
        P->DstValue.Long = XmGetWordImmediate(P);
    }

    P->DstSegment = XmGetWordImmediate(P);
    return TRUE;
}

ULONG
XmImmediateEnter (
    IN PRXM_CONTEXT P
    )

/*++

Routine Description:

    This function decodes x86 operand specifiers for the following opcodes:

    enter

Arguments:

    P - Supplies a pointer to an emulator context structure.

Return Value:

    A completion status of TRUE is returned as the function value.

--*/

{

    //
    // Enter operands with an allocation size and level number.
    //

    P->SrcValue.Long = XmGetWordImmediate(P);
    P->DstValue.Long = XmGetByteImmediate(P) & 0x1f;
    if (P->OpsizePrefixActive != FALSE) {
        P->DataType = LONG_DATA;

    } else {
        P->DataType = WORD_DATA;
    }

    return TRUE;
}

ULONG
XmGeneralBitOffset (
    IN PRXM_CONTEXT P
    )

/*++

Routine Description:

    This function decodes x86 operand specifiers for the following opcodes:

    xxxxxx

Arguments:

    P - Supplies a pointer to an emulator context structure.

Return Value:

    A completion status of TRUE is returned as the function value.

--*/

{

    PVOID Operand;
    ULONG Offset;
    ULONG Number;

    //
    // Bit test opcodes with a register bit offset and a memory or
    // register operand.
    //

    if (P->OpsizePrefixActive != FALSE) {
        P->DataType = LONG_DATA;

    } else {
        P->DataType = WORD_DATA;
    }

    Operand = XmEvaluateAddressSpecifier(P, &Number);
    XmSetSourceValue(P, (PVOID)(&P->Gpr[Number].Exx));
    if (P->RegisterOffsetAddress == FALSE) {
        if (P->DataType == LONG_DATA) {
            Offset = (P->SrcValue.Long >> 5) << 2;

        } else {
            Offset = (P->SrcValue.Long >> 4) << 1;
        }

        Operand = XmGetOffsetAddress(P, Offset + P->Offset);
    }

    if (P->DataType == LONG_DATA) {
        P->SrcValue.Long &= 0x1f;

    } else {
        P->SrcValue.Long &= 0xf;
    }

    XmSetDestinationValue(P, Operand);
    return TRUE;
}

ULONG
XmShiftDouble (
    IN PRXM_CONTEXT P
    )

/*++

Routine Description:

    This function decodes x86 operand specifiers for the following opcodes:

    shld    shrd

Arguments:

    P - Supplies a pointer to an emulator context structure.

Return Value:

    A completion status of TRUE is returned as the function value.

--*/

{

    PVOID Operand;
    ULONG Number;
    ULONG Source;

    //
    // Shift double operators with an immediate byte or cl shift count.
    //

    if (P->OpsizePrefixActive != FALSE) {
        P->DataType = LONG_DATA;

    } else {
        P->DataType = WORD_DATA;
    }

    Operand = XmEvaluateAddressSpecifier(P, &Number);
    if ((P->CurrentOpcode & 0x1) == 0) {
        Source = XmGetByteImmediate(P);

    } else {
        Source = P->Gpr[CX].Xl;
    }

    if (P->DataType == LONG_DATA) {
        P->Shift = (UCHAR)(Source & 0x1f);

    } else {
        P->Shift = (UCHAR)(Source & 0xf);
    }

    XmSetSourceValue(P, (PVOID)(&P->Gpr[Number].Exx));
    XmSetDestinationValue(P, Operand);
    return TRUE;
}

ULONG
XmPortImmediate (
    IN PRXM_CONTEXT P
    )

/*++

Routine Description:

    This function decodes x86 operand specifiers for the following opcodes:

    xxxxxx

Arguments:

    P - Supplies a pointer to an emulator context structure.

Return Value:

    A completion status of TRUE is returned as the function value.

--*/

{

    ULONG Source;

    //
    // In/out opcodes with an immediate port and all other operands implied.
    //

    Source = (ULONG)XmGetByteImmediate(P);
    P->DataType = WORD_DATA;
    XmSetImmediateSourceValue(P, Source);
    XmSetDataType(P);
    return TRUE;
}

ULONG
XmPortDX (
    IN PRXM_CONTEXT P
    )

/*++

Routine Description:

    This function decodes x86 operand specifiers for the following opcodes:

    xxxxxx

Arguments:

    P - Supplies a pointer to an emulator context structure.

Return Value:

    A completion status of TRUE is returned as the function value.

--*/

{

    ULONG Source;

    //
    // In/out opcodes with a port in DX with all other operands implied.
    //

    Source = P->Gpr[DX].Xx;
    P->DataType = WORD_DATA;
    XmSetImmediateSourceValue(P, Source);
    XmSetDataType(P);
    return TRUE;
}

ULONG
XmBitScanGeneral (
    IN PRXM_CONTEXT P
    )

/*++

Routine Description:

    This function decodes x86 operand specifiers for the following opcodes:

    xxxxxx

Arguments:

    P - Supplies a pointer to an emulator context structure.

Return Value:

    A completion status of TRUE is returned as the function value.

--*/

{

    PVOID Operand;
    ULONG Number;

    //
    // Bit scan general opcodes with general operand specifier.
    // bit.
    //

    if (P->OpsizePrefixActive != FALSE) {
        P->DataType = LONG_DATA;

    } else {
        P->DataType = WORD_DATA;
    }

    Operand = XmEvaluateAddressSpecifier(P, &Number);
    if (!Operand) return FALSE;
    P->DstLong = (ULONG UNALIGNED *)(&P->Gpr[Number].Exx);
    XmSetSourceValue(P, Operand);
    return TRUE;
}

ULONG
XmByteImmediate (
    IN PRXM_CONTEXT P
    )

/*++

Routine Description:

    This function decodes x86 operand specifiers for the following opcodes:

    int     xxxxxx

Arguments:

    P - Supplies a pointer to an emulator context structure.

Return Value:

    A completion status of TRUE is returned as the function value.

--*/

{

    ULONG Source;

    //
    // int opcode with an immediate operand.
    //

    P->DataType = BYTE_DATA;
    Source = XmGetImmediateSourceValue(P, 0);
    XmSetImmediateSourceValue(P, Source);
    return TRUE;
}

ULONG
XmXlatOpcode (
    IN PRXM_CONTEXT P
    )

/*++

Routine Description:

    This function decodes x86 operand specifiers for the following opcodes:

    xlat

Arguments:

    P - Supplies a pointer to an emulator context structure.

Return Value:

    A completion status of TRUE is returned as the function value.

--*/

{

    PVOID Operand;
    ULONG Offset;

    //
    // xlat opcode with zero extended [AL] + [eBX] as the effective
    // address.
    //

    P->DataType = BYTE_DATA;
    if (P->OpaddrPrefixActive != FALSE) {
        Offset = P->Gpr[EBX].Exx + P->Gpr[AL].Xl;

    } else {
        Offset = P->Gpr[BX].Xx + P->Gpr[AL].Xl;
    }

    Operand = XmGetOffsetAddress(P, Offset);
    XmSetSourceValue(P, Operand);
    P->DstByte = (UCHAR UNALIGNED *)(&P->Gpr[AL].Xl);
    return TRUE;
}

ULONG
XmGeneralRegister (
    IN PRXM_CONTEXT P
    )

/*++

Routine Description:

    This function decodes x86 operand specifiers for the following opcodes:

    bswap

Arguments:

    P - Supplies a pointer to an emulator context structure.

Return Value:

    A completion status of TRUE is returned as the function value.

--*/

{

    PVOID Operand;
    ULONG Number;

    //
    // General register source and destination.
    //

    if (P->OpsizePrefixActive != FALSE) {
        P->DataType = LONG_DATA;

    } else {
        P->DataType = WORD_DATA;
    }

    Operand = XmEvaluateAddressSpecifier(P, &Number);
    if (P->RegisterOffsetAddress == FALSE) {
        longjmp(&P->JumpBuffer[0], XM_ILLEGAL_GENERAL_SPECIFIER);
    }

    XmSetSourceValue(P, (PVOID)(&P->Gpr[Number].Exx));
    P->DstLong = (ULONG UNALIGNED *)(&P->Gpr[Number].Exx);
    return TRUE;
}

ULONG
XmOpcodeEscape (
    IN PRXM_CONTEXT P
    )

/*++

Routine Description:

    This function decodes x86 operand specifiers for the following opcodes:

    2-byte escape

Arguments:

    P - Supplies a pointer to an emulator context structure.

Return Value:

    A completion status of xx is returned as the function value.

--*/

{

    //
    // Two byte opcode escape.
    //

    P->OpcodeControlTable = &XmOpcodeControlTable2[0];

#if defined(XM_DEBUG)

    P->OpcodeNameTable = &XmOpcodeNameTable2[0];

#endif

    return FALSE;
}

ULONG
XmPrefixOpcode (
    IN PRXM_CONTEXT P
    )

/*++

Routine Description:

    This function decodes x86 operand specifiers for the following opcodes:

    CS:     DS;     ES:     SS:     FS:     GS:     lock    adrsize
    opsize  repz    repnz

Arguments:

    P - Supplies a pointer to an emulator context structure.

Return Value:

    A completion status of FALSE is returned as the function value.

--*/

{

    //
    // Case on the function index.
    //

    switch (P->FunctionIndex) {

        //
        // Segment override prefix.
        //
        // Set the segment override prefix flags and the data segment
        // number.
        //

    case X86_ES_OP:
    case X86_CS_OP:
    case X86_SS_OP:
    case X86_DS_OP:
    case X86_FS_OP:
    case X86_GS_OP:
        P->SegmentPrefixActive = TRUE;
        P->DataSegment = P->FunctionIndex;
        XmTraceOverride(P);
        break;

        //
        // Lock prefix.
        //
        // Set the lock prefix flags.
        //

    case X86_LOCK_OP:
        P->LockPrefixActive = TRUE;
        break;

        //
        // Address size prefix.
        //
        // Set the address size prefix flag.
        //

    case X86_ADSZ_OP:
        P->OpaddrPrefixActive = TRUE;
        break;

        //
        // Operand size prefix.
        //
        // Set the operand size prefix flag.
        //


    case X86_OPSZ_OP:
        P->OpsizePrefixActive = TRUE;
        break;

        //
        // Repeat until ECX or ZF equals zero
        //
        // Set up repeat until ECX or ZF equals zero prefix flags.
        //

    case X86_REPZ_OP:
        P->RepeatPrefixActive = TRUE;
        P->RepeatZflag = 1;
        break;

        //
        // Repeat until ECX equals zero or ZF equals one.
        //
        // Set up repeat until ECX equals zero or ZF equals one prefix
        // flags.
        //

    case X86_REPNZ_OP:
        P->RepeatPrefixActive = TRUE;
        P->RepeatZflag = 0;
        break;
    }

    return FALSE;
}

ULONG
XmNoOperands (
    IN PRXM_CONTEXT P
    )

/*++

Routine Description:

    This function decodes x86 operand specifiers for the following opcodes:

    xxxxxx

Arguments:

    P - Supplies a pointer to an emulator context structure.

Return Value:

    A completion status of TRUE is returned as the function value.

--*/

{

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\x86new\regmode.c ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    regmode.c

Abstract:

    This module implements the code necessary to decode the address
    mode specifier byte.

    N.B. This routine could be probably be more tightly encoded with a
        loss of clarity.

Author:

    David N. Cutler (davec) 10-Sep-1994

Environment:

    Kernel mode only.

Revision History:

--*/

#include "nthal.h"
#include "emulate.h"

//
// Define forward referenced function prototypes.
//

ULONG
XmEvaluateIndexSpecifier (
    IN PRXM_CONTEXT P,
    IN ULONG Mode
    );

PVOID
XmEvaluateAddressSpecifier (
    IN PRXM_CONTEXT P,
    OUT PLONG Number
    )

/*++

Routine Description:

    This function decodes x86 operand specifiers.

Arguments:

    P - Supplies a pointer to an emulator context structure.

    Number - Supplies a pointer to a variable that receives the register
        number selected by the reg field of the operand specifier.

    Operand - Supplies a pointer to a variable that receives the address
        of the operand specified by the mod-r/m field of the operand
        specifier.

Return Value:

    None.

--*/

{

    ULONG DispatchIndex;
    ULONG Mode;
    ULONG Modifier;
    ULONG Offset;
    ULONG Register;
    UCHAR SpecifierByte;

    PVOID Address;

    //
    // Get the next byte from the instruction stream and isolate
    // the fields. The format of an operand specifier byte is:
    //
    // <7:6> - Mode
    // <5:3> - Operand Register
    // <2:0> - Modifier
    //

    SpecifierByte = XmGetCodeByte(P);
    XmTraceSpecifier(SpecifierByte);
    Mode = (SpecifierByte >> 6) & 0x3;
    Modifier = SpecifierByte & 0x7;
    Register = (SpecifierByte >> 3) & 0x7;
    DispatchIndex = (Mode << 3) | (Modifier);
    P->RegisterOffsetAddress = FALSE;

    //
    // Set the segment base address and select between 16- and 32-bit
    // addressing.
    //

    *Number = Register;
    if (P->OpaddrPrefixActive != FALSE) {

        //
        // 32-bit addressing.
        //
        // Case on dispatch index.
        //

        switch (DispatchIndex) {

            //
            // 00-000 DS:[EAX]
            //

        case 0:
            Offset = P->Gpr[EAX].Exx;
            break;

            //
            // 00-001 DS:[ECX]
            //

        case 1:
            Offset = P->Gpr[ECX].Exx;
            break;

            //
            // 00-010 DS:[EDX]
            //

        case 2:
            Offset = P->Gpr[EDX].Exx;
            break;

            //
            // 00-011 DS:[EBX]
            //

        case 3:
            Offset = P->Gpr[EBX].Exx;
            break;

            //
            // 00-100 - scale index byte
            //

        case 4:
            Offset = XmEvaluateIndexSpecifier(P, Mode);
            break;

            //
            // 00-101 DS:d32
            //

        case 5:
            Offset = XmGetLongImmediate(P);
            break;

            //
            // 00-110 DS:[ESI]
            //

        case 6:
            Offset = P->Gpr[ESI].Exx;
            break;

            //
            // 00-111 DS:[EDI]
            //

        case 7:
            Offset = P->Gpr[EDI].Exx;
            break;

            //
            // 01-000 DS:[EAX + d8]
            //

        case 8:
            Offset = P->Gpr[EAX].Exx + XmGetSignedByteImmediateToLong(P);
            break;

            //
            // 01-001 DS:[ECX + d8]
            //

        case 9:
            Offset = P->Gpr[ECX].Exx + XmGetSignedByteImmediateToLong(P);
            break;

            //
            // 01-010 DS:[EDX + d8]
            //

        case 10:
            Offset = P->Gpr[EDX].Exx + XmGetSignedByteImmediateToLong(P);
            break;

            //
            // 01-011 DS:[EBX + d8]
            //

        case 11:
            Offset = P->Gpr[EBX].Exx + XmGetSignedByteImmediateToLong(P);
            break;

            //
            // 01-100 - scale index byte
            //

        case 12:
            Offset = XmEvaluateIndexSpecifier(P, Mode);
            break;

            //
            // 01-101 DS:[EBP + d8]
            //

        case 13:
            Offset = P->Gpr[EBP].Exx + XmGetSignedByteImmediateToLong(P);
            if (P->SegmentPrefixActive == FALSE) {
                P->DataSegment = SS;
            }

            break;

            //
            // 01-110 DS:[ESI + d8]
            //

        case 14:
            Offset = P->Gpr[ESI].Exx + XmGetSignedByteImmediateToLong(P);
            break;

            //
            // 01-111 DS:[EDI + d8]
            //

        case 15:
            Offset = P->Gpr[EDI].Exx + XmGetSignedByteImmediateToLong(P);
            break;

            //
            // 10-000 DS:[EAX + d32]
            //

        case 16:
            Offset = P->Gpr[EAX].Exx + XmGetLongImmediate(P);
            break;

            //
            // 10-001 DS:[ECX + d32]
            //

        case 17:
            Offset = P->Gpr[ECX].Exx + XmGetLongImmediate(P);
            break;

            //
            // 10-010 DS:[EDX + d32]
            //

        case 18:
            Offset = P->Gpr[EDX].Exx + XmGetLongImmediate(P);
            break;

            //
            // 10-011 DS:[EBX + d32]
            //

        case 19:
            Offset = P->Gpr[EBX].Exx + XmGetLongImmediate(P);
            break;

            //
            // 10-100 - scale index byte
            //

        case 20:
            Offset = XmEvaluateIndexSpecifier(P, Mode);
            break;

            //
            // 10-101 DS:[EBP + d32]
            //

        case 21:
            Offset = P->Gpr[EBP].Exx + XmGetLongImmediate(P);
            if (P->SegmentPrefixActive == FALSE) {
                P->DataSegment = SS;
            }

            break;

            //
            // 10-110 DS:[ESI + d32]
            //

        case 22:
            Offset = P->Gpr[ESI].Exx + XmGetLongImmediate(P);
            break;

            //
            // 10-111 DS:[EDI + d32]
            //

        case 23:
            Offset = P->Gpr[EDI].Exx + XmGetLongImmediate(P);
            break;

            //
            // 11-xxx - Register mode.
            //

        case 24:
        case 25:
        case 26:
        case 27:
        case 28:
        case 29:
        case 30:
        case 31:
            P->RegisterOffsetAddress = TRUE;
            return XmGetRegisterAddress(P, Modifier);
        }

    } else {

        //
        // 16-bit addressing.
        //
        // Case on dispatch index.
        //

        switch (DispatchIndex) {

            //
            // 00-000 DS:[BX + SI]
            //

        case 0:
            Offset = (USHORT)(P->Gpr[BX].Xx + P->Gpr[SI].Xx);
            break;

            //
            // 00-001 DS:[BX + DI]
            //

        case 1:
            Offset = (USHORT)(P->Gpr[BX].Xx + P->Gpr[DI].Xx);
            break;

            //
            // 00-010 SS:[BP + SI]
            //

        case 2:
            Offset = (USHORT)(P->Gpr[BP].Xx + P->Gpr[SI].Xx);
            if (P->SegmentPrefixActive == FALSE) {
                P->DataSegment = SS;
            }

            break;

            //
            // 00-011 SS:[BP + DI]
            //

        case 3:
            Offset = (USHORT)(P->Gpr[BP].Xx + P->Gpr[DI].Xx);
            if (P->SegmentPrefixActive == FALSE) {
                P->DataSegment = SS;
            }

            break;

            //
            // 00-100 DS:[SI]
            //

        case 4:
            Offset = (USHORT)(P->Gpr[SI].Xx);
            break;

            //
            // 00-101 DS:[DI]
            //

        case 5:
            Offset = (USHORT)(P->Gpr[DI].Xx);
            break;

            //
            // 00-110 DS:d16
            //

        case 6:
            Offset = XmGetWordImmediate(P);
            break;

            //
            // 00-111 DS:[BX]
            //

        case 7:
            Offset = (USHORT)(P->Gpr[BX].Xx);
            break;

            //
            // 01-000 DS:[BX + SI + d8]
            //

        case 8:
            Offset = (USHORT)(P->Gpr[BX].Xx + P->Gpr[SI].Xx + XmGetSignedByteImmediateToWord(P));
            break;

            //
            // 01-001 DS:[BX + DI + d8]
            //

        case 9:
            Offset = (USHORT)(P->Gpr[BX].Xx + P->Gpr[DI].Xx + XmGetSignedByteImmediateToWord(P));
            break;

            //
            // 01-010 SS:[BP + SI + d8]
            //

        case 10:
            Offset = (USHORT)(P->Gpr[BP].Xx + P->Gpr[SI].Xx + XmGetSignedByteImmediateToWord(P));
            if (P->SegmentPrefixActive == FALSE) {
                P->DataSegment = SS;
            }

            break;

            //
            // 01-011 SS:[BP + DI + d8]
            //

        case 11:
            Offset = (USHORT)(P->Gpr[BP].Xx + P->Gpr[DI].Xx + XmGetSignedByteImmediateToWord(P));
            if (P->SegmentPrefixActive == FALSE) {
                P->DataSegment = SS;
            }

            break;

            //
            // 01-100 DS:[SI + d8]
            //

        case 12:
            Offset = (USHORT)(P->Gpr[SI].Xx + XmGetSignedByteImmediateToWord(P));
            break;

            //
            // 01-101 DS:[DI + d8]
            //

        case 13:
            Offset = (USHORT)(P->Gpr[DI].Xx + XmGetSignedByteImmediateToWord(P));
            break;

            //
            // 01-110 DS:[BP + d8]
            //

        case 14:
            Offset = (USHORT)(P->Gpr[BP].Xx + XmGetSignedByteImmediateToWord(P));
            if (P->SegmentPrefixActive == FALSE) {
                P->DataSegment = SS;
            }

            break;

            //
            // 01-111 DS:[BX + d8]
            //

        case 15:
            Offset = (USHORT)(P->Gpr[BX].Xx + XmGetSignedByteImmediateToWord(P));
            break;

            //
            // 10-000 DS:[BX + SI + d16]
            //

        case 16:
            Offset = (USHORT)(P->Gpr[BX].Xx + P->Gpr[SI].Xx + XmGetWordImmediate(P));
            break;

            //
            // 10-001 DS:[BX + DI + d16]
            //

        case 17:
            Offset = (USHORT)(P->Gpr[BX].Xx + P->Gpr[DI].Xx + XmGetWordImmediate(P));
            break;

            //
            // 10-010 SS:[BP + SI + d16]
            //

        case 18:
            Offset = (USHORT)(P->Gpr[BP].Xx + P->Gpr[SI].Xx + XmGetWordImmediate(P));
            if (P->SegmentPrefixActive == FALSE) {
                P->DataSegment = SS;
            }

            break;

            //
            // 10-011 SS:[BP + DI + d16]
            //

        case 19:
            Offset = (USHORT)(P->Gpr[BP].Xx + P->Gpr[DI].Xx + XmGetWordImmediate(P));
            if (P->SegmentPrefixActive == FALSE) {
                P->DataSegment = SS;
            }

            break;

            //
            // 10-100 DS:[SI + d16]
            //

        case 20:
            Offset = (USHORT)(P->Gpr[SI].Xx + XmGetWordImmediate(P));
            break;

            //
            // 10-101 DS:[DI + d16]
            //

        case 21:
            Offset = (USHORT)(P->Gpr[DI].Xx + XmGetWordImmediate(P));
            break;

            //
            // 10-110 DS:[BP + d16]
            //

        case 22:
            Offset = (USHORT)(P->Gpr[BP].Xx + XmGetWordImmediate(P));
            if (P->SegmentPrefixActive == FALSE) {
                P->DataSegment = SS;
            }

            break;

            //
            // 10-111 DS:[BX + d16]
            //

        case 23:
            Offset = (USHORT)(P->Gpr[BX].Xx + XmGetWordImmediate(P));
            break;

            //
            // 11-xxx - Register mode.
            //

        case 24:
        case 25:
        case 26:
        case 27:
        case 28:
        case 29:
        case 30:
        case 31:
            P->RegisterOffsetAddress = TRUE;
            return XmGetRegisterAddress(P, Modifier);
        }
    }

    //
    // If an effective offset is being calculated, then return the offset
    // value. Otherwise, If the offset displacement value plus the datum
    // size is not within the segment limits, then raise an exception.
    // Otherwise, compute the operand address.
    //

    if (P->ComputeOffsetAddress != FALSE) {
        if (P->DataType == WORD_DATA) {
            Offset &= 0xffff;
        }

        P->Offset = Offset;
        Address   = UlongToPtr(Offset);
    } else {
        if ((Offset > P->SegmentLimit[P->DataSegment]) ||
            ((Offset + P->DataType) > P->SegmentLimit[P->DataSegment])) {
            longjmp(&P->JumpBuffer[0], XM_SEGMENT_LIMIT_VIOLATION);

        } else {
            P->Offset = Offset;
            Address = (PVOID)(ULONG_PTR)(P->TranslateAddress)(P->SegmentRegister[P->DataSegment],
                                                             (USHORT)Offset);
        }
    }

    return Address;
}

ULONG
XmEvaluateIndexSpecifier (
    IN PRXM_CONTEXT P,
    IN ULONG Mode
    )

/*++

Routine Description:

    This function evaluates a index specifier byte.

Arguments:

    P - Supplies a pointer to an emulator context structure.

    Mode - Supplies the mode of the address specifier.

Return Value:

    The offset value computes from the index specifier.

--*/

{

    ULONG DispatchIndex;
    ULONG Modifier;
    ULONG Offset;
    ULONG Register;
    ULONG Scale;
    UCHAR SpecifierByte;

    //
    // Get the next byte from the instruction stream and isolate the
    // specifier fields. The format of an scale/index byte is:
    //
    // <7:6> - Scale
    // <5:3> - Index register
    // <2:0> - Modifier
    //

    SpecifierByte = XmGetCodeByte(P);
    XmTraceInstruction(BYTE_DATA, (ULONG)SpecifierByte);
    Scale = (SpecifierByte >> 6) & 0x3;
    Modifier = SpecifierByte & 0x7;
    Register = (SpecifierByte >> 3) & 0x7;
    DispatchIndex = (Mode << 3) | (Modifier);

    //
    // Case of dispatch index.
    //

    switch (DispatchIndex) {

        //
        // 00-000 DS:[EAX + scaled index]
        //

    case 0:
        Offset = P->Gpr[EAX].Exx;
        break;

        //
        // 00-001 DS:[ECX + scaled index]
        //

    case 1:
        Offset = P->Gpr[ECX].Exx;
        break;

        //
        // 00-010 DS:[EDX + scaled index]
        //

    case 2:
        Offset = P->Gpr[EDX].Exx;
        break;

        //
        // 00-011 DS:[EBX + scaled index]
        //

    case 3:
        Offset = P->Gpr[EBX].Exx;
        break;

        //
        // 00-100 SS:[ESP + scaled index]
        //

    case 4:
        Offset = P->Gpr[ESP].Exx;
        if (P->SegmentPrefixActive == FALSE) {
            P->DataSegment = SS;
        }

        break;

        //
        // 00-101 DS:[d32 + scaled index]
        //

    case 5:
        Offset = XmGetLongImmediate(P);
        break;

        //
        // 00-110 DS:[ESI + scaled index]
        //

    case 6:
        Offset = P->Gpr[ESI].Exx;
        break;

        //
        // 00-111 DS:[EDI + scaled index]
        //

    case 7:
        Offset = P->Gpr[EDI].Exx;
        break;

        //
        // 01-000 DS:[EAX + scaled index + d8]
        //

    case 8:
        Offset = P->Gpr[EAX].Exx + XmGetSignedByteImmediateToLong(P);
        break;

        //
        // 01-001 DS:[ECX + scaled index + d8]
        //

    case 9:
        Offset = P->Gpr[ECX].Exx + XmGetSignedByteImmediateToLong(P);
        break;

        //
        // 01-010 DS:[EDX + scaled index + d8]
        //

    case 10:
        Offset = P->Gpr[EDX].Exx + XmGetSignedByteImmediateToLong(P);
        break;

        //
        // 01-011 DS:[EBX + scaled index + d8]
        //

    case 11:
        Offset = P->Gpr[EBX].Exx + XmGetSignedByteImmediateToLong(P);
        break;

        //
        // 01-100 SS:[ESP + scaled index + d8]
        //

    case 12:
        Offset = P->Gpr[ESP].Exx + XmGetSignedByteImmediateToLong(P);
        if (P->SegmentPrefixActive == FALSE) {
            P->DataSegment = SS;
        }

        break;

        //
        // 01-101 DS:[EBP + scaled index + d8]
        //

    case 13:
        Offset = P->Gpr[EBP].Exx + XmGetSignedByteImmediateToLong(P);
        if (P->SegmentPrefixActive == FALSE) {
            P->DataSegment = SS;
        }
        break;

        //
        // 01-110 DS:[ESI + scaled index + d8]
        //

    case 14:
        Offset = P->Gpr[ESI].Exx + XmGetSignedByteImmediateToLong(P);
        break;

        //
        // 01-111 DS:[EDI + scaled index + d8]
        //

    case 15:
        Offset = P->Gpr[EDI].Exx + XmGetSignedByteImmediateToLong(P);
        break;

        //
        // 10-000 DS:[EAX + scaled index + d32]
        //

    case 16:
        Offset = P->Gpr[EAX].Exx + XmGetLongImmediate(P);
        break;

        //
        // 10-001 DS:[ECX + scaled index + d32]
        //

    case 17:
        Offset = P->Gpr[ECX].Exx + XmGetLongImmediate(P);
        break;

        //
        // 10-010 DS:[EDX + scaled index + d32]
        //

    case 18:
        Offset = P->Gpr[EDX].Exx + XmGetLongImmediate(P);
        break;

        //
        // 10-011 DS:[EBX + scaled index + d32]
        //

    case 19:
        Offset = P->Gpr[EBX].Exx + XmGetLongImmediate(P);
        break;

        //
        // 10-100 SS:[ESP + scaled index + d32]
        //

    case 20:
        Offset = P->Gpr[ESP].Exx + XmGetLongImmediate(P);
        if (P->SegmentPrefixActive == FALSE) {
            P->DataSegment = SS;
        }

        break;

        //
        // 10-101 DS:[EBP + scaled index + d32]
        //

    case 21:
        Offset = P->Gpr[EBP].Exx + XmGetLongImmediate(P);
        if (P->SegmentPrefixActive == FALSE) {
            P->DataSegment = SS;
        }

        break;

        //
        // 10-110 DS:[ESI + scaled index + d32]
        //

    case 22:
        Offset = P->Gpr[ESI].Exx + XmGetLongImmediate(P);
        break;

        //
        // 10-111 DS:[EDI + scaled index + d32]
        //

    case 23:
        Offset = P->Gpr[EDI].Exx + XmGetLongImmediate(P);
        break;

        //
        // Illegal mode specifier.
        //

    default:
        longjmp(&P->JumpBuffer[0], XM_ILLEGAL_INDEX_SPECIFIER);
    }

    //
    // Compute the total offset value.
    //

    return Offset + (P->Gpr[Register].Exx << Scale);
}

PVOID
XmGetOffsetAddress (
    IN PRXM_CONTEXT P,
    IN ULONG Offset
    )

/*++

Routine Description:

    This function evaluates a data segment address given a specified
    offset.

Arguments:

    P - Supplies a pointer to an emulator context structure.

    Offset - Supplies the offset value.

Return Value:

    A pointer to the operand value.

--*/

{

    //
    // If the offset displacement value plus the datum size is not within
    // the segment limits, then raise an exception. Otherwise, compute the
    // operand address.
    //

    if ((Offset > P->SegmentLimit[P->DataSegment]) ||
        ((Offset + P->DataType) > P->SegmentLimit[P->DataSegment])) {
        longjmp(&P->JumpBuffer[0], XM_SEGMENT_LIMIT_VIOLATION);
    }

    return (P->TranslateAddress)(P->SegmentRegister[P->DataSegment], (USHORT)Offset);
}

PVOID
XmGetRegisterAddress (
    IN PRXM_CONTEXT P,
    IN ULONG Number
    )

/*++

Routine Description:

    This function computes the address of a register value.

Arguments:

    P - Supplies a pointer to an emulator context structure.

    Number  - Supplies the register number.

Return Value:

    A pointer to the register value.

--*/

{

    PVOID Value;

    //
    // If the operand width is a byte, then the register is a
    // byte register. Otherwise, the register is a word register.
    //

    if (P->DataType == BYTE_DATA) {
        if (Number < 4) {
            Value = (PVOID)&P->Gpr[Number].Xl;

        } else {
            Value = (PVOID)&P->Gpr[Number - 4].Xh;
        }

    } else if (P->DataType == WORD_DATA) {
        Value = (PVOID)&P->Gpr[Number].Xx;

    } else {
        Value = (PVOID)&P->Gpr[Number].Exx;
    }

    return Value;
}

PVOID
XmGetStringAddress (
    IN PRXM_CONTEXT P,
    IN ULONG Segment,
    IN ULONG Register
    )

/*++

Routine Description:

    This function evaluates a string address.

Arguments:

    P - Supplies a pointer to an emulator context structure.

    Segment - Supplies the segment number of the string operand.

    Register - Supplies the register number of the string operand.

Return Value:

    A pointer to the string value.

--*/

{

    ULONG Increment;
    ULONG Offset;

    //
    // Get the offset of the specified address and increment the specified
    // register.
    //

    Increment = P->DataType + 1;
    if (P->Eflags.EFLAG_DF != 0) {
        Increment = ~Increment + 1;
    }

    if (P->OpaddrPrefixActive != FALSE) {
        Offset = P->Gpr[Register].Exx;
        P->Gpr[Register].Exx += Increment;

    } else {
        Offset = P->Gpr[Register].Xx;
        P->Gpr[Register].Xx += (USHORT)Increment;
    }

    //
    // If the offset displacement value plus the datum size is not within
    // the segment limits, then raise an exception. Otherwise, compute the
    // operand address.
    //

    if ((Offset > P->SegmentLimit[Segment]) ||
        ((Offset + P->DataType) > P->SegmentLimit[Segment])) {
        longjmp(&P->JumpBuffer[0], XM_SEGMENT_LIMIT_VIOLATION);
    }

    return (P->TranslateAddress)(P->SegmentRegister[Segment], (USHORT)Offset);
}

VOID
XmSetDestinationValue (
    IN PRXM_CONTEXT P,
    IN PVOID Destination
    )

/*++

Routine Description:

    This function stores the destination operand value in the emulator
    context.

Arguments:

    P - Supplies a pointer to an emulator context structure.

    Destination - Supplies a pointer to the destination operand value.

Return Value:

    None.

--*/

{

    //
    // Set address and value of destination.
    //

    P->DstLong = (ULONG UNALIGNED *)Destination;
    if (P->DataType == BYTE_DATA) {
        P->DstValue.Long = *(UCHAR *)Destination;

    } else if (P->DataType == WORD_DATA) {
        if (((ULONG_PTR)Destination & 0x1) == 0) {
            P->DstValue.Long = *(USHORT *)Destination;

        } else {
            P->DstValue.Long = *(USHORT UNALIGNED *)Destination;
        }

    } else {
        if (((ULONG_PTR)Destination & 0x3) == 0) {
            P->DstValue.Long = *(ULONG *)Destination;

        } else {
            P->DstValue.Long = *(ULONG UNALIGNED *)Destination;
        }
    }

    XmTraceDestination(P, P->DstValue.Long);
    return;
}

VOID
XmSetSourceValue (
    IN PRXM_CONTEXT P,
    IN PVOID Source
    )

/*++

Routine Description:

    This function stores the source operand value in the emulator
    context.

Arguments:

    P - Supplies a pointer to an emulator context structure.

    Source - Supplies a pointer to the source operand value.

Return Value:

    None.

--*/

{

    //
    // Set address and value of source.
    //

    P->SrcLong = (ULONG UNALIGNED *)Source;
    if (P->DataType == BYTE_DATA) {
        P->SrcValue.Long = *(UCHAR UNALIGNED *)Source;

    } else if (P->DataType == WORD_DATA) {
        P->SrcValue.Long = *(USHORT UNALIGNED *)Source;

    } else {
        P->SrcValue.Long = *(ULONG UNALIGNED *)Source;
    }

    XmTraceSource(P, P->SrcValue.Long);
    return;
}

ULONG
XmGetImmediateSourceValue (
    IN PRXM_CONTEXT P,
    IN ULONG ByteFlag
    )

/*++

Routine Description:

    This function gets an immediate source from the instruction stream.

Arguments:

    P - Supplies a pointer to an emulator context structure.

    ByteFlag - Supplies a flag value that determines whether the
        immediate value is a sign extended byte.

Return Value:

    None.

--*/

{

    ULONG Value;

    //
    // Get source value.
    //

    if (P->DataType == BYTE_DATA) {
        Value = XmGetByteImmediate(P);

    } else if (P->DataType == WORD_DATA) {
        if (ByteFlag == 0) {
            Value = XmGetWordImmediate(P);

        } else {
            Value = XmGetSignedByteImmediateToWord(P);
        }

    } else {
        if (ByteFlag == 0) {
            Value = XmGetLongImmediate(P);

        } else {
            Value = XmGetSignedByteImmediateToLong(P);
        }
    }

    return Value;
}

VOID
XmSetImmediateSourceValue (
    IN PRXM_CONTEXT P,
    IN ULONG Source
    )

/*++

Routine Description:

    This function stores the immediate source operand value in the
    emulator context.

Arguments:

    P - Supplies a pointer to an emulator context structure.

    Source - Supplies the source value.

Return Value:

    None.

--*/

{

    //
    // Set source value.
    //

    P->SrcValue.Long = Source;
    XmTraceSource(P, Source);
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\x86new\setops.c ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    setops.c

Abstract:

    This module implements the code to emulate set opcodes.

Author:

    David N. Cutler (davec) 13-Sep-1994

Environment:

    Kernel mode only.

Revision History:

--*/

#include "nthal.h"
#include "emulate.h"

VOID
XmSxxOp (
    IN PRXM_CONTEXT P
    )

/*++

Routine Description:

    This function emulates set byte on condition opcodes.

Arguments:

    P - Supplies a pointer to the emulation context structure.

Return Value:

    None.

--*/

{

    ULONG Complement;
    ULONG Condition;

    //
    // Case on the set control value.
    //

    Complement = P->SrcValue.Long & 1;
    switch (P->SrcValue.Long >> 1) {

        //
        // Set if overflow/not overflow.
        //

    case 0:
        Condition = P->Eflags.EFLAG_OF;
        break;

        //
        // Set if below/not below.
        //

    case 1:
        Condition = P->Eflags.EFLAG_CF;
        break;

        //
        // Set if zero/not zero.
        //

    case 2:
        Condition = P->Eflags.EFLAG_ZF;
        break;

        //
        // Set if below or equal/not below or equal.
        //

    case 3:
        Condition = P->Eflags.EFLAG_CF | P->Eflags.EFLAG_ZF;
        break;

        //
        // Set if signed/not signed.
        //

    case 4:
        Condition = P->Eflags.EFLAG_SF;
        break;

        //
        // Set if parity/not parity.
        //

    case 5:
        Condition = P->Eflags.EFLAG_PF;
        break;

        //
        // Set if less/not less.
        //

    case 6:
        Condition = (P->Eflags.EFLAG_SF ^ P->Eflags.EFLAG_OF);
        break;

        //
        // Set if less or equal/not less or equal.
        //

    case 7:
        Condition = (P->Eflags.EFLAG_SF ^ P->Eflags.EFLAG_OF) | P->Eflags.EFLAG_ZF;
        break;
    }

    //
    // If the specified condition is met, then set the byte destination
    // value to one. Otherwise, set the byte destination value to zero.
    //

    XmStoreResult(P, (ULONG)(Condition ^ Complement));
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\x86new\stackops.c ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    stackops.c

Abstract:

    This module implements the code to emulate the push, pop, pushf, popf,
    pusha, popa, pushSeg, and popSeg.

Author:

    David N. Cutler (davec) 6-Sep-1994

Environment:

    Kernel mode only.

Revision History:

--*/

#include "nthal.h"
#include "emulate.h"

VOID
XmPushOp (
    IN PRXM_CONTEXT P
    )

/*++

Routine Description:

    This function emulates a push opcode.

Arguments:

    P - Supplies a pointer to the emulation context structure.

Return Value:

    None.

--*/

{

    //
    // Push source value onto stack.
    //

    XmPushStack(P, P->SrcValue.Long);
    return;
}

VOID
XmPopOp (
    IN PRXM_CONTEXT P
    )

/*++

Routine Description:

    This function emulates a pop opcode.

Arguments:

    P - Supplies a pointer to the emulation context structure.

Return Value:

    None.

--*/

{

    //
    // Pop the stack and store the result value.
    //

    XmStoreResult(P, XmPopStack(P));
    return;
}

VOID
XmPushaOp (
    IN PRXM_CONTEXT P
    )

/*++

Routine Description:

    This function emulates a pusha opcode.

Arguments:

    P - Supplies a pointer to the emulation context structure.

Return Value:

    None.

--*/

{

    ULONG Index;
    ULONG Temp;

    //
    // Push all registers onto the stack.
    //

    if (P->OpsizePrefixActive != FALSE) {
        P->DataType = LONG_DATA;

    } else {
        P->DataType = WORD_DATA;
    }

    Index = EAX;
    Temp = P->Gpr[ESP].Exx;
    do {
        if (Index == ESP) {
            XmSetSourceValue(P, (PVOID)&Temp);

        } else {
            XmSetSourceValue(P, (PVOID)(&P->Gpr[Index].Exx));
        }

        XmPushOp(P);
        Index += 1;
    } while (Index <= EDI);
    return;
}

VOID
XmPopaOp (
    IN PRXM_CONTEXT P
    )

/*++

Routine Description:

    This function emulates a popa opcode.

Arguments:

    P - Supplies a pointer to the emulation context structure.

Return Value:

    None.

--*/

{

    ULONG Index;
    ULONG Temp;

    //
    // Pop all register from the stack, but skip over ESP.
    //

    if (P->OpsizePrefixActive != FALSE) {
        P->DataType = LONG_DATA;

    } else {
        P->DataType = WORD_DATA;
    }

    Index = EDI + 1;
    Temp = P->Gpr[ESP].Exx;
    do {
        Index -= 1;
        if (Index == ESP) {
            XmSetDestinationValue(P, (PVOID)&Temp);

        } else {
            XmSetDestinationValue(P, (PVOID)(&P->Gpr[Index].Exx));
        }

        XmPopOp(P);
    } while (Index > EAX);
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\x86new\stringop.c ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    stringop.c

Abstract:

    This module implements the code to emulate the string opcodes.

Author:

    David N. Cutler (davec) 7-Nov-1994

Environment:

    Kernel mode only.

Revision History:

--*/

#include "nthal.h"
#include "emulate.h"

//
// Define forward referenced prototypes.
//

VOID
XmCompareOperands (
    IN PRXM_CONTEXT P
    );

VOID
XmCmpsOp (
    IN PRXM_CONTEXT P
    )

/*++

Routine Description:

    This function emulates a cmpsb/w/d opcode.

Arguments:

    P - Supplies a pointer to the emulation context structure.

Return Value:

    None.

--*/

{

    ULONG Count;

    //
    // If a repeat prefix is active, then the loop count is specified
    // by eCX. Otherwise, the loop count is one.
    //

    Count = 1;
    if (P->RepeatPrefixActive != FALSE) {
        if (P->OpaddrPrefixActive != FALSE) {
            Count = P->Gpr[ECX].Exx;

        } else {
            Count = P->Gpr[CX].Xx;
        }
    }

    //
    // Compare items from source and destination.
    //

    while (Count != 0) {

        //
        // Set source and destination values.
        //

        XmSetSourceValue(P, XmGetStringAddress(P, P->DataSegment, ESI));
        XmSetDestinationValue(P, XmGetStringAddress(P, ES, EDI));

        //
        // Compare source with destination operand and decrement loop count.
        // If ZF is not equal to the repeat Z flag condition, then terminate
        // the loop.
        //

        XmCompareOperands(P);
        Count -= 1;
        if (P->Eflags.EFLAG_ZF != P->RepeatZflag) {
            break;
        }
    }

    //
    // If a repeat prefix is active, then set the final count value.
    //

    if (P->RepeatPrefixActive != FALSE) {
        if (P->OpaddrPrefixActive != FALSE) {
            P->Gpr[ECX].Exx = Count;

        } else {
            P->Gpr[CX].Xx = (USHORT)Count;
        }
    }

    return;
}

VOID
XmLodsOp (
    IN PRXM_CONTEXT P
    )

/*++

Routine Description:

    This function emulates a lodsb/w/d opcode.

Arguments:

    P - Supplies a pointer to the emulation context structure.

Return Value:

    None.

--*/

{

    ULONG Count;

    //
    // If a repeat prefix is active, then the loop count is specified
    // by eCX. Otherwise, the loop count is one.
    //

    Count = 1;
    if (P->RepeatPrefixActive != FALSE) {
        if (P->OpaddrPrefixActive != FALSE) {
            Count = P->Gpr[ECX].Exx;
            P->Gpr[ECX].Exx = 0;

        } else {
            Count = P->Gpr[CX].Xx;
            P->Gpr[CX].Xx = 0;
        }
    }

    //
    // Set destination address.
    //

    P->DstLong = (ULONG UNALIGNED *)&P->Gpr[EAX].Exx;

    //
    // Move items from source to destination.
    //

    while (Count != 0) {

        //
        // Set source value and store result.
        //

        XmSetSourceValue(P, XmGetStringAddress(P, P->DataSegment, ESI));
        XmStoreResult(P, P->SrcValue.Long);
        Count -= 1;
    }

    return;
}

VOID
XmMovsOp (
    IN PRXM_CONTEXT P
    )

/*++

Routine Description:

    This function emulates a movsb/w/d opcode.

Arguments:

    P - Supplies a pointer to the emulation context structure.

Return Value:

    None.

--*/

{

    ULONG Count;

    //
    // If a repeat prefix is active, then the loop count is specified
    // by eCX. Otherwise, the loop count is one.
    //

    Count = 1;
    if (P->RepeatPrefixActive != FALSE) {
        if (P->OpaddrPrefixActive != FALSE) {
            Count = P->Gpr[ECX].Exx;
            P->Gpr[ECX].Exx = 0;

        } else {
            Count = P->Gpr[CX].Xx;
            P->Gpr[CX].Xx = 0;
        }
    }

    //
    // Move items from source to destination.
    //

    while (Count != 0) {

        //
        // Set source value, set destination address, and store result.
        //

        XmSetSourceValue(P, XmGetStringAddress(P, P->DataSegment, ESI));
        P->DstLong = (ULONG UNALIGNED *)XmGetStringAddress(P, ES, EDI);
        XmStoreResult(P, P->SrcValue.Long);
        Count -= 1;
    }

    return;
}

VOID
XmScasOp (
    IN PRXM_CONTEXT P
    )

/*++

Routine Description:

    This function emula