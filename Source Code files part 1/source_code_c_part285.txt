tError())
        {
            return TRUE;
        }        
        return FALSE;
    }

    return TRUE;
}

//--------------------------------------------------------------------------
// DebugORPCRestoreAuto()
//
// Restores the previous value of the "Auto" value in the AeDebug key.
//--------------------------------------------------------------------------

VOID WINAPI DebugORPCRestoreAuto(VOID)
{
	TCHAR	rgtchAuto[256] = TEXT("");

	// Restore old Auto value (or delete it if it didn't exist before).
	// Very minor bug here: if "Auto" was previously "", then we will
	// now delete it.  That's not a big deal though, as an empty "Auto"
	// and a nonexistent one have the same effect.
	//
	// If GetProfileString failed (for some reason) then we take the
	// default value for rgtchAuto (init above).
	GetProfileString(tszAeDebugName, tszOldAutoName, TEXT(""), 
					 rgtchAuto, sizeof(rgtchAuto) / sizeof(TCHAR));

	WriteProfileString(tszAeDebugName, tszAutoName,
					   rgtchAuto[0] ? rgtchAuto : NULL);

	// Delete OldAuto value
	WriteProfileString(tszAeDebugName, tszOldAutoName, NULL);
}

 // This pragma is necessary in case the compiler chooses not to inline these
// functions (e.g. in a debug build, when optimizations are off).

#pragma code_seg(".orpc")

__inline DWORD WINAPI OrpcBreakpointFilter(
	LPEXCEPTION_POINTERS lpExcptPtr,
	BOOL *lpAeDebugAttached )									\
{
	BOOL fAeDebugAttached = FALSE;
	DWORD dwRet;
																
	if ( lpExcptPtr->ExceptionRecord->ExceptionCode == EXCEPTION_ORPC_DEBUG )	
	{
		if  ( UnhandledExceptionFilter(lpExcptPtr) == EXCEPTION_CONTINUE_SEARCH )
		{
			// It is important that we don't return EXCEPTION_CONTINUE_SEARCH.
			// This is because there might an handler up the stack which could
			// handle this exception. Just set the flag indicating that a
			// debugger is now attached.
			
			fAeDebugAttached = TRUE;
		}
		dwRet = EXCEPTION_EXECUTE_HANDLER;
	}
	else
	{
		// Not one of our exceptions.
		dwRet = EXCEPTION_CONTINUE_SEARCH;
	}

	if ( lpAeDebugAttached != NULL )
		(*lpAeDebugAttached) = fAeDebugAttached;
	
	return dwRet;	
}
							
ULONG WINAPI DebugORPCClientGetBufferSize(
	RPCOLEMESSAGE *		pMessage,
	REFIID				iid,
	void *				reserved,
	IUnknown *			pUnkProxyMgr,
	LPORPC_INIT_ARGS	lpInitArgs,
	BOOL				fHookEnabled)
{
	ULONG	cbBuffer = 0;
	ORPC_DBG_ALL	orpc_all = {0};
	ORPC_DBG_ALL *  lpOrpcAll = &orpc_all;

	if (!fHookEnabled)
		return 0; // We should be able to assert that this never happens.

	orpc_all.pSignature = rgbClientGetBufferSizeSignature;
	orpc_all.pMessage = pMessage;
	orpc_all.reserved = reserved;
	orpc_all.pUnkProxyMgr = pUnkProxyMgr;
	orpc_all.lpcbBuffer = &cbBuffer;
	ASSIGN_REFIID(orpc_all, iid);

	if ( lpInitArgs == NULL || lpInitArgs->lpIntfOrpcDebug == NULL )
	{
		// Do Orpc debug notification using an exception.
		__try
		{
			RaiseException(EXCEPTION_ORPC_DEBUG, 0, 1, (PULONG_PTR)&lpOrpcAll);
		}
		__except(OrpcBreakpointFilter(GetExceptionInformation(), NULL))
		{
			// this just goes down to the  to the return.
		}
	}
	else
	{
		IOrpcDebugNotify __RPC_FAR *lpIntf = lpInitArgs->lpIntfOrpcDebug;

		// call the appropriate method in the registered interface
		// ( this is typically used by in-proc debuggers)
#if defined(__cplusplus) && !defined(CINTERFACE)
		lpIntf->ClientGetBufferSize(lpOrpcAll);
#else
		lpIntf->lpVtbl->ClientGetBufferSize(lpIntf, lpOrpcAll);
#endif
		
	}

	return cbBuffer;
}

//--------------------------------------------------------------------------

void WINAPI DebugORPCClientFillBuffer(
	RPCOLEMESSAGE *		pMessage,
	REFIID				iid,
	void *				reserved,
	IUnknown *			pUnkProxyMgr,
	void *				pvBuffer,
	ULONG				cbBuffer,
	LPORPC_INIT_ARGS	lpInitArgs,
	BOOL				fHookEnabled)
{
	ORPC_DBG_ALL	orpc_all = {0};
	ORPC_DBG_ALL *  lpOrpcAll = &orpc_all;

	if (!fHookEnabled)
		return; // We should be able to assert that this never happens

	orpc_all.pSignature = rgbClientFillBufferSignature;

	orpc_all.pMessage = pMessage;
	orpc_all.reserved = reserved;
	orpc_all.pUnkProxyMgr = pUnkProxyMgr;
	ASSIGN_REFIID(orpc_all, iid);

	orpc_all.pvBuffer = pvBuffer;
	orpc_all.cbBuffer = cbBuffer;

	
	if ( lpInitArgs == NULL || lpInitArgs->lpIntfOrpcDebug == NULL )
	{
		// Do Orpc debug notification using an exception.
		__try
		{
			RaiseException(EXCEPTION_ORPC_DEBUG, 0, 1, (PULONG_PTR)&lpOrpcAll);
		}
		__except(OrpcBreakpointFilter(GetExceptionInformation(), NULL))
		{
			// this just returns.
		}
	}
	else
	{
		IOrpcDebugNotify __RPC_FAR *lpIntf = lpInitArgs->lpIntfOrpcDebug;

		// call the appropriate method in the registered interface
		// ( this is typically used by in-proc debuggers)
#if defined(__cplusplus) && !defined(CINTERFACE)
		lpIntf->ClientFillBuffer(lpOrpcAll);
#else
		lpIntf->lpVtbl->ClientFillBuffer(lpIntf, lpOrpcAll);
#endif	
	}
}

//--------------------------------------------------------------------------

// This special value is to ensure backward compatibility with VC 2.0.
// It is not exposed in the header files. The behavior if this is the value
// in the first four bytes of the debug packet, should be identical to
// ORPC_DEBUG_ALWAYS.

#define ORPC_COMPATIBILITY_CODE		(0x4252414DL)

void WINAPI DebugORPCClientNotify(
	RPCOLEMESSAGE *		pMessage,
	REFIID				iid,
	void *				reserved,
	IUnknown *			pUnkProxyMgr,
	HRESULT				hresult,
	void *				pvBuffer,
	ULONG				cbBuffer,
	LPORPC_INIT_ARGS	lpInitArgs,
	BOOL				fHookEnabled)
{
	ORPC_DBG_ALL orpc_all = {0};
	ORPC_DBG_ALL * lpOrpcAll = &orpc_all;
	BOOL fRethrow = FALSE;

	// First check to see if the debugger on the other side
	// wants us to notify this side if the hook is not enabled.
	if (!fHookEnabled)
	{
		if (cbBuffer >= 4)
		{
			LONG orpcCode = *(LONG *)pvBuffer;
			if ( orpcCode == ORPC_DEBUG_IF_HOOK_ENABLED)
				return;		// No notification in this case.
		}
	}

	orpc_all.pSignature = rgbClientNotifySignature;

	orpc_all.pMessage = pMessage;
	orpc_all.reserved = reserved;
	orpc_all.pUnkProxyMgr = pUnkProxyMgr;
	orpc_all.hresult = hresult;
	ASSIGN_REFIID(orpc_all, iid);

	orpc_all.pvBuffer = pvBuffer;
	orpc_all.cbBuffer = cbBuffer;

	if ( lpInitArgs == NULL || lpInitArgs->lpIntfOrpcDebug == NULL )
	{
		if (DebugORPCSetAuto())
		{
			// Do Orpc debug notification using an exception.
			__try
			{
				RaiseException(EXCEPTION_ORPC_DEBUG, 0, 1, (PULONG_PTR)&lpOrpcAll);
			}
			__except(OrpcBreakpointFilter(GetExceptionInformation(), &fRethrow))
			{
				// Fall through.
			}

			if (fRethrow)
			{
				// At this point we are sure that a debugger is attached
				// so we raise this exception outside of a __try block.
				RaiseException(EXCEPTION_ORPC_DEBUG, 0, 1, (PULONG_PTR)&lpOrpcAll);
			}

			DebugORPCRestoreAuto();
		}
	
	}
	else
	{
		IOrpcDebugNotify __RPC_FAR *lpIntf = lpInitArgs->lpIntfOrpcDebug;

		// call the appropriate method in the registered interface
		// ( this is typically used by in-proc debuggers)
#if defined(__cplusplus) && !defined(CINTERFACE)
		lpIntf->ClientNotify(lpOrpcAll);
#else
		lpIntf->lpVtbl->ClientNotify(lpIntf, lpOrpcAll);
#endif
	}

}

//--------------------------------------------------------------------------

void WINAPI DebugORPCServerNotify(
	RPCOLEMESSAGE *		pMessage,
	REFIID				iid,
	IRpcChannelBuffer *	pChannel,
	void *				pInterface,
	IUnknown *			pUnkObject,
	void *				pvBuffer,
	ULONG				cbBuffer,
	LPORPC_INIT_ARGS	lpInitArgs,
	BOOL				fHookEnabled)

{
	ORPC_DBG_ALL orpc_all = {0};
	ORPC_DBG_ALL * lpOrpcAll = &orpc_all;
	BOOL fRethrow = FALSE;

	// First check to see if the debugger on the other side
	// wants us to notify this side if the hook is not enabled.
	if (!fHookEnabled)
	{
		if (cbBuffer >= 4)
		{
			LONG orpcCode = *(LONG *)pvBuffer;
			if ( orpcCode == ORPC_DEBUG_IF_HOOK_ENABLED)
				return;		// No notification in this case.
		}
	}

	orpc_all.pSignature = rgbServerNotifySignature;

	orpc_all.pMessage = pMessage;
	orpc_all.pChannel = pChannel;
	orpc_all.pInterface = pInterface;
	orpc_all.pUnkObject = pUnkObject;
	ASSIGN_REFIID(orpc_all, iid);
	
	orpc_all.pvBuffer = pvBuffer;
	orpc_all.cbBuffer = cbBuffer;

	if ( lpInitArgs == NULL || lpInitArgs->lpIntfOrpcDebug == NULL )
	{
		if (DebugORPCSetAuto())
		{
			// Do Orpc debug notification using an exception.
			__try
			{
				RaiseException(EXCEPTION_ORPC_DEBUG, 0, 1, (PULONG_PTR)&lpOrpcAll);
			}
			__except(OrpcBreakpointFilter(GetExceptionInformation(), &fRethrow))
			{
				// Fall through
			}

			if (fRethrow)
			{
				// At this point we are sure that a debugger is attached
				// so we raise this exception outside of a __try block.
				RaiseException(EXCEPTION_ORPC_DEBUG, 0, 1, (PULONG_PTR)&lpOrpcAll);
			}

			DebugORPCRestoreAuto();
		}
	
	}
	else
	{
		IOrpcDebugNotify __RPC_FAR *lpIntf = lpInitArgs->lpIntfOrpcDebug;

		// call the appropriate method in the registered interface
		// ( this is typically used by in-proc debuggers)
#if defined(__cplusplus) && !defined(CINTERFACE)
		lpIntf->ServerNotify(lpOrpcAll);
#else
		lpIntf->lpVtbl->ServerNotify(lpIntf, lpOrpcAll);
#endif
	}

}

//--------------------------------------------------------------------------

ULONG WINAPI DebugORPCServerGetBufferSize(
	RPCOLEMESSAGE *		pMessage,
	REFIID				iid,
	IRpcChannelBuffer *	pChannel,
	void *				pInterface,
	IUnknown *			pUnkObject,
	LPORPC_INIT_ARGS	lpInitArgs,
	BOOL				fHookEnabled)

{
	ULONG	cbBuffer = 0;
	ORPC_DBG_ALL orpc_all = {0};
	ORPC_DBG_ALL * lpOrpcAll = &orpc_all;

	if (!fHookEnabled)
		return 0; // We should be able to assert that this never happens.

	orpc_all.pSignature = rgbServerGetBufferSizeSignature;

	orpc_all.pMessage = pMessage;
	orpc_all.pChannel = pChannel;
	orpc_all.pInterface = pInterface;
	orpc_all.pUnkObject = pUnkObject;
	orpc_all.lpcbBuffer = &cbBuffer;
	ASSIGN_REFIID(orpc_all, iid);

	if ( lpInitArgs == NULL || lpInitArgs->lpIntfOrpcDebug == NULL )
	{
		// Do Orpc debug notification using an exception.
		__try
		{
			RaiseException(EXCEPTION_ORPC_DEBUG, 0, 1, (PULONG_PTR)&lpOrpcAll);
		}
		__except(OrpcBreakpointFilter(GetExceptionInformation(), NULL))
		{
			// this just goes down to the return.
		}
	}
	else
	{
		IOrpcDebugNotify __RPC_FAR *lpIntf = lpInitArgs->lpIntfOrpcDebug;

		// call the appropriate method in the registered interface
		// ( this is typically used by in-proc debuggers)
#if defined(__cplusplus) && !defined(CINTERFACE)
		lpIntf->ServerGetBufferSize(lpOrpcAll);
#else
		lpIntf->lpVtbl->ServerGetBufferSize(lpIntf, lpOrpcAll);
#endif
	}

	return cbBuffer;
}

//--------------------------------------------------------------------------

void WINAPI DebugORPCServerFillBuffer(
	RPCOLEMESSAGE *		pMessage,
	REFIID				iid,
	IRpcChannelBuffer *	pChannel,
	void *				pInterface,
	IUnknown *			pUnkObject,
	void *				pvBuffer,
	ULONG				cbBuffer,
	LPORPC_INIT_ARGS	lpInitArgs,
	BOOL				fHookEnabled)
{
	ORPC_DBG_ALL orpc_all = {0};
	ORPC_DBG_ALL * lpOrpcAll = &orpc_all;

	if (!fHookEnabled)
		return;	// We should be able to assert that this never happens.

	orpc_all.pSignature = rgbServerFillBufferSignature;

	orpc_all.pMessage = pMessage;
	orpc_all.pChannel = pChannel;
	orpc_all.pInterface = pInterface;
	orpc_all.pUnkObject = pUnkObject;
	ASSIGN_REFIID(orpc_all, iid);

	orpc_all.pvBuffer = pvBuffer;
	orpc_all.cbBuffer = cbBuffer;

	if ( lpInitArgs == NULL || lpInitArgs->lpIntfOrpcDebug == NULL )
	{
		// Do Orpc debug notification using an exception.
		__try
		{
			RaiseException(EXCEPTION_ORPC_DEBUG, 0, 1, (PULONG_PTR)&lpOrpcAll);
		}
		__except(OrpcBreakpointFilter(GetExceptionInformation(), NULL))
		{
			// this just returns.
		}
	}
	else
	{
		IOrpcDebugNotify __RPC_FAR *lpIntf = lpInitArgs->lpIntfOrpcDebug;

		// call the appropriate method in the registered interface
		// ( this is typically used by in-proc debuggers)
#if defined(__cplusplus) && !defined(CINTERFACE)
		lpIntf->ServerFillBuffer(lpOrpcAll);
#else
		lpIntf->lpVtbl->ServerFillBuffer(lpIntf, lpOrpcAll);
#endif
	}
}

// WARNING: there is no way to "pop" to the previously active code_seg:
// this will revert to what the code seg was when compilation began.
#pragma code_seg()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\com\dcomrem\pstable.cxx ===
//+-------------------------------------------------------------------
//
//  File:       PSTable.cxx
//
//  Contents:   Support for Policy Sets
//
//  Functions:  CPolicySet methods
//              CPSTable methods
//
//  History:    20-Dec-97   Gopalk      Created
//
//--------------------------------------------------------------------
#include <ole2int.h>
#include <chock.hxx>
#include <locks.hxx>
#include <stdid.hxx>
#include <context.hxx>
#include <pstable.hxx>
#include <ctxchnl.hxx>
#include <crossctx.hxx>
#include <rwlock.hxx>

//+-------------------------------------------------------------------
//
// Class globals
//
//+-------------------------------------------------------------------
CPageAllocator CPolicySet::s_PSallocator;   // Allocator for policy sets
CPageAllocator CPolicySet::s_PEallocator;   // Allocator for policy entries
BOOL           CPolicySet::s_fInitialized;  // Relied on being FALSE
DWORD          CPolicySet::s_cObjects;      // Relied on being ZERO

BOOL           CPSTable::s_fInitialized;    // Relied on being FALSE

// Hash Buckets for policy sets
SHashChain CPSTable::s_PSBuckets[NUM_HASH_BUCKETS] = {
    {&s_PSBuckets[0],  &s_PSBuckets[0]},
    {&s_PSBuckets[1],  &s_PSBuckets[1]},
    {&s_PSBuckets[2],  &s_PSBuckets[2]},
    {&s_PSBuckets[3],  &s_PSBuckets[3]},
    {&s_PSBuckets[4],  &s_PSBuckets[4]},
    {&s_PSBuckets[5],  &s_PSBuckets[5]},
    {&s_PSBuckets[6],  &s_PSBuckets[6]},
    {&s_PSBuckets[7],  &s_PSBuckets[7]},
    {&s_PSBuckets[8],  &s_PSBuckets[8]},
    {&s_PSBuckets[9],  &s_PSBuckets[9]},
    {&s_PSBuckets[10], &s_PSBuckets[10]},
    {&s_PSBuckets[11], &s_PSBuckets[11]},
    {&s_PSBuckets[12], &s_PSBuckets[12]},
    {&s_PSBuckets[13], &s_PSBuckets[13]},
    {&s_PSBuckets[14], &s_PSBuckets[14]},
    {&s_PSBuckets[15], &s_PSBuckets[15]},
    {&s_PSBuckets[16], &s_PSBuckets[16]},
    {&s_PSBuckets[17], &s_PSBuckets[17]},
    {&s_PSBuckets[18], &s_PSBuckets[18]},
    {&s_PSBuckets[19], &s_PSBuckets[19]},
    {&s_PSBuckets[20], &s_PSBuckets[20]},
    {&s_PSBuckets[21], &s_PSBuckets[21]},
    {&s_PSBuckets[22], &s_PSBuckets[22]}
};
CPSHashTable CPSTable::s_PSHashTbl;         // Hash table for policy sets
CPSTable gPSTable;                          // Global policy set table
CStaticRWLock gPSRWLock;                    // Reader-Writer lock protecting
                                            // policy sets
COleStaticMutexSem gPSLock;                 // Lock protecting allocators

// Externs used
extern CObjectContext *g_pMTAEmptyCtx;
extern CObjectContext *g_pNTAEmptyCtx;

#define CONTEXT_MAJOR_VERSION    0x00010000
#define CONTEXT_MINOR_VERSION    0x00000000
#define CONTEXT_VERSION          CONTEXT_MAJOR_VERSION | CONTEXT_MINOR_VERSION

// NOTE: Align the following structs on a 8-byte boundary
#define MAINHDRSIG     0x414E554B
typedef struct tagMainHeader
{
    unsigned long Signature;
    unsigned long Version;
    unsigned long cPolicies;
    unsigned long cbBuffer;
    unsigned long cbSize;
    long          hr;
    long          hrServer;
    long         reserved;
} MainHeader;

#define ENTRYHDRSIG   0x494E414E
typedef struct tagEntryHeader
{
    unsigned long Signature;
    unsigned long cbBuffer;
    unsigned long cbSize;
    long reserved;
    GUID policyID;
} EntryHeader;

void *CCtxCall::s_pAllocList[CTXCALL_CACHE_SIZE] = { NULL, NULL, NULL,
                                                     NULL, NULL, NULL,
                                                     NULL, NULL, NULL,
                                                     NULL };
int CCtxCall::s_iAvailable;   // Relied on being zero
COleStaticMutexSem CCtxCall::_mxsCtxCallLock;   // critical section

//+-------------------------------------------------------------------
//
//  Method:     CCtxCall::operator new     public
//
//  Synopsis:   new operator of context call object
//
//  History:    20-Dec-97   Gopalk      Created
//
//+-------------------------------------------------------------------
void *CCtxCall::operator new(size_t size)
{
    void *pv = NULL;

    // Acquire lock
    LOCK(_mxsCtxCallLock);

    // Assert that cache cannot be more than full
    Win4Assert(s_iAvailable <= CTXCALL_CACHE_SIZE);

    // Check for previous process uninit
    if(s_iAvailable < 0)
        s_iAvailable = 0;

    // Check for availability in cache
    if(s_iAvailable > 0)
    {
        --s_iAvailable;
        pv = s_pAllocList[s_iAvailable];
        s_pAllocList[s_iAvailable] = NULL;
    }

    // Release lock
    UNLOCK(_mxsCtxCallLock);

    // Check if context call object was not allocated from the cache
    if(pv == NULL)
        pv = PrivMemAlloc(size);

    return(pv);
}


//+-------------------------------------------------------------------
//
//  Method:     CCtxCall::operator delete     public
//
//  Synopsis:   delete operator of context call object
//
//  History:    20-Dec-97   Gopalk      Created
//
//+-------------------------------------------------------------------
void CCtxCall::operator delete(void *pv)
{
    // Acquire lock
    LOCK(_mxsCtxCallLock);

    // Assert that cache cannot be more than full
    Win4Assert(s_iAvailable <= CTXCALL_CACHE_SIZE);

#if DBG==1
    // Detect double deletion in debug builds
    for(int i = 0;i < s_iAvailable;i++)
        if(s_pAllocList[i] == pv)
            Win4Assert(!"CCtxCall being deleted twice");
#endif

    // Check if the cache is full
    if(s_iAvailable >= 0 && s_iAvailable < CTXCALL_CACHE_SIZE)
    {
        s_pAllocList[s_iAvailable++] = pv;
        pv = NULL;
    }

    // Release lock
    UNLOCK(_mxsCtxCallLock);

    // Check if context call object was not returned to cache
    if(pv)
        PrivMemFree(pv);

    return;
}


//+-------------------------------------------------------------------
//
//  Method:     CCtxCall::Cleanup     public
//
//  Synopsis:   Cleanup allocator of context call objects
//
//  History:    20-Dec-97   Gopalk      Created
//
//+-------------------------------------------------------------------
void CCtxCall::Cleanup()
{
    ASSERT_LOCK_NOT_HELD(_mxsCtxCallLock);
    LOCK(_mxsCtxCallLock);

    // Free cached context call objects
    while(s_iAvailable > 0)
    {
        PrivMemFree(s_pAllocList[--s_iAvailable]);
        s_pAllocList[s_iAvailable] = NULL;
    }

    // Ensure that context call objects of canceled calls
    // are not cached for future use
    s_iAvailable = -1;

    UNLOCK(_mxsCtxCallLock);
    ASSERT_LOCK_NOT_HELD(_mxsCtxCallLock);
    return;
}

//+-------------------------------------------------------------------
//
//  Method:     CCtxCall::QueryInterface
//
//  Synopsis:   ICallFrame::QueryInterface
//
//  History:    30-Sep-98   TarunA      Created
//
//+-------------------------------------------------------------------
STDMETHODIMP CCtxCall::QueryInterface(REFIID iid, LPVOID* ppv)
{
    if (iid == IID_IUnknown || iid == IID_ICallFrameWalker)
        *ppv = (ICallFrameWalker*)this;
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    ((IUnknown*)*ppv)->AddRef();
    return S_OK;
}

//+-------------------------------------------------------------------
//
//  Method:     CCtxCall::AddRef
//
//  Synopsis:   ICallFrame::AddRef
//
//  History:    30-Sep-98   TarunA      Created
//
//+-------------------------------------------------------------------
STDMETHODIMP_(ULONG) CCtxCall::AddRef()
{
    return 1;
}

//+-------------------------------------------------------------------
//
//  Method:     CCtxCall::Release
//
//  Synopsis:   ICallFrame::Release
//
//  History:    30-Sep-98   TarunA      Created
//
//+-------------------------------------------------------------------
STDMETHODIMP_(ULONG) CCtxCall::Release()
{
    return 1;
}

//+-------------------------------------------------------------------
//
//  Method:     CCtxCall::OnWalkInterface
//
//  Synopsis:   ICallFrame::OnWalkInterface
//              This function implements the frame walker functionality
//              There are three types of frame walkers.
//              (1) Error frame walker which cleans up after any errors
//                  during walking of the frame
//              (2) Free frame walker which releases interface pointers
//              (3) Marshaling frame walker which marshals/unmarshals
//                  interface pointers
//
//  History:    30-Sep-98   TarunA      Created
//
//+-------------------------------------------------------------------
STDMETHODIMP CCtxCall::OnWalkInterface(REFIID riid, PVOID *ppvInterface,
                                       BOOL fIn, BOOL fOut)
{
    ASSERT_LOCK_NOT_HELD(gComLock);

    HRESULT hr = S_OK;
    
    // The following section of code is used to keep track of [in, out]
    // interface pointers embedded in the DISPPARAMS argument of 
    // IDispatch::Invoke invoke calls.  In a nutshell, params packaged in
    // DISPPARAMS are implicitly [in, out], so they fall through our
    // check at interceptor creation time.  Therefore, we have to be
    // prepared to handle cases where the invoked method changes one of
    // the interface pointers somewhere in the DISPPARAMS.  The way we
    // do that is: 1) count the [in,out] interface pointers in the frame 
    // 2) allocate space for and copy all of the interface pointers into a 
    // vector 3) following Invoke, walk the frame again to Release any 
    // interface pointers that were changed.
    
    if(STAGE_COUNT & _dwStage)
    {
        // Walk initiator is responsible for resetting _cItfs before
        // counting interface pointers.
        // Count only [in,out] pointers.
        if (fIn && fOut)
        {
            ++_cItfs;
        }
        return hr;
    }
    else if (STAGE_COLLECT & _dwStage)
    {
        // Walk initiator is responsible for resetting _idx before
        // collecting interface pointers.  This stage will only get
        // executed when the _cItfs is non zero.
        // Collect only [in,out] pointers.
        if (fIn && fOut)
        {
            Win4Assert(_cItfs && _ppItfs);
            Win4Assert(_idx < _cItfs);
            _ppItfs[_idx] = *ppvInterface;
            _idx++;
        }
    }
        
    if(NULL == *ppvInterface)
        return hr;

    // If an error has occurred, any memory allocated upto this point
    // has to be released and any extra references have to be released
    if(_fError)
    {
        // Call an error handling function
        hr = ErrorHandler(riid, ppvInterface, fIn, fOut);
        return hr;
    }

    if(STAGE_FREE & _dwStage)
    {
        // This is called during the freeing of the frame and hence
        // the interface parameters need to be released
        ((IUnknown *)*ppvInterface)->Release();
        _cFree++;
    }
    else if ((STAGE_COPY & _dwStage) && FAILED(_hr))
    {
        // The copy process failed midway. We continue anyways,
        // and clean up at the end.
        *ppvInterface = NULL;
    }
    // Marshal
    else if(STAGE_MARSHAL & _dwStage)
        hr = MarshalItfPtrs(riid, ppvInterface, fIn, fOut);
    // Unmarshal
    else if(STAGE_UNMARSHAL & _dwStage)
        hr = UnmarshalItfPtrs(riid, ppvInterface, fIn, fOut);    
    else
    {
        hr = E_UNEXPECTED;
        Win4Assert(FALSE);
    }

    if((STAGE_COPY & _dwStage) && S_OK != hr)
    {
        // Set the failed hr during the copy stage so that
        // we can recover gracefully at the end of the copy stage
        if(SUCCEEDED(_hr))
        {
            // Only the first failure is stored
            _hr = hr;
        }
        // Return a successful hr so that the copy stage continues 
        // and we can free the copied frame entirely at the end of
        // the copy. If we return a failed hr here then the half copied
        // frame is thrown away without giving us a chance to cleanup
        hr = S_OK;
    }

    ASSERT_LOCK_NOT_HELD(gComLock);
    return hr;
}

//+-------------------------------------------------------------------
//
//  Method:     CCtxCall::ErrorHandler
//
//  Synopsis:   Recovers from errors which occurred during walking of frame
//              (1) STAGE_MARSHAL: Error occurred during marshaling
//                  [in] and [out] interface ptrs which are  marshaled
//                  are released. Extra references obtained during marshaling
//                  are released. Memory allocated for the interface data is
//                  released.
//              (2) STAGE_UNMARSHAL: Error occurred during unmarshaling
//                  [in] and [out] interface ptrs which are marshaled
//                  are released. Extra references obtained during
//                  unmarshaling are released.Memory allocated for the
//                  interface data is released.
//              (3) STAGE_FREE [in] interface pointers are released.
//                  There is no free stage for [out] interface pointers
//
//
//  History:    30-Sep-98   TarunA      Created
//
//+-------------------------------------------------------------------
STDMETHODIMP CCtxCall::ErrorHandler(REFIID riid, PVOID *ppvInterface, BOOL fIn,
                                    BOOL fOut)
{
    HRESULT hr = S_OK;

    // The error handling is done based on the stage
    switch(_dwStage)
    {
        case STAGE_MARSHAL:
        if(_cError < _cMarshalItfs)
        {
            InterfaceData* pData = (InterfaceData *)*ppvInterface;
            CXmitRpcStream stream(pData);

            // Release the reference  added while marshaling
            CoReleaseMarshalData(&stream);

            // Release the serialized buffer
            PrivMemFree(pData);
        }

        // NULL the [out] params
        if(fOut)
            *ppvInterface = NULL;

        // Increment the number of interface pointers handled
        _cError++;
        break;

    case STAGE_UNMARSHAL:
        // Sanity check
        Win4Assert(_cError <= _cMarshalItfs);
        Win4Assert(_cUnmarshalItfs <= _cMarshalItfs);

        // For all the interface ptrs that have been successfully
        // unmarshaled we should call a release
        if(_cError < _cUnmarshalItfs)
        {
            ((IUnknown *)*ppvInterface)->Release();
        }
        // For all interface ptrs yet to be unmarshaled
        // release any memory associated with them
        else
        {
            InterfaceData* pData = (InterfaceData *)*ppvInterface;
            CXmitRpcStream stream(pData);

            // Release the reference  added while marshaling
            CoReleaseMarshalData(&stream);

            // Release the serialized buffer
            PrivMemFree(pData);
        }

        // NULL the [out] params
        if(fOut)
            *ppvInterface = NULL;

        // Increment the number of interface pointers handled
        _cError++;
        break;

    case STAGE_FREE:
        if(fIn)
        {
            // For all the interface pointers that have not yet
            // been released, release them.
            if(_cError >= _cFree)
            {
                // Simply release the [in] pointer
                ((IUnknown *)*ppvInterface)->Release();
            }
            _cError++;
        }
        else
        {
            // There is no free stage for [out] pointers
            Win4Assert(FALSE && "Illegal free of [out] interface pointer\n");
        }
        break;

    default:
        hr = E_UNEXPECTED;
        Win4Assert(FALSE);
    }
    return hr;
}


//+-------------------------------------------------------------------
//
//  Method:     CCtxCall::MarshalItfPtrs
//
//  Synopsis:   Marshals Interface Pointers.
//              Determine the max size of the marshaled buffer and
//              call CoMarshalInterface.
//
//  History:    30-Sep-98   TarunA      Created
//
//+-------------------------------------------------------------------
STDMETHODIMP CCtxCall::MarshalItfPtrs(REFIID riid, PVOID *ppvInterface, BOOL fIn,
                                       BOOL fOut)
{
    ASSERT_LOCK_NOT_HELD(gComLock);

    HRESULT hr = S_OK;
    DWORD dwSize = 0;
    void *pvDestCtx = NULL;
    DWORD mshlFlags = MSHLFLAGS_NORMAL;

    if(MSHCTX_UNINITIALIZED == _dwDestCtx) _dwDestCtx = MSHCTX_CROSSCTX;

    // Determine the maximum size of the marshaled buffer
    hr = CoGetMarshalSizeMax(&dwSize, riid, (IUnknown *)*ppvInterface,
                             _dwDestCtx, pvDestCtx, mshlFlags);
    if(SUCCEEDED(hr))
    {
        CXmitRpcStream stream(dwSize);

        // Marshal the interface pointer
        hr = CoMarshalInterface(
                                &stream,
                                riid,
                                (IUnknown *)*ppvInterface,
                                _dwDestCtx,
                                pvDestCtx,
                                mshlFlags
                                );

        if(SUCCEEDED(hr))
        {
            // Extract the buffer out of the stream
            InterfaceData* pData = NULL;
            stream.AssignSerializedInterface(&pData);

            // Point the interface pointer to the
            // marshaled buffer
            *ppvInterface = (LPVOID)pData;
            _cMarshalItfs++;
        }
    }

    ASSERT_LOCK_NOT_HELD(gComLock);
    return hr;
}

//+-------------------------------------------------------------------
//
//  Method:     CCtxCall::UnmarshalItfPtrs
//
//  Synopsis:   Unmarshals Interface Pointers.
//              Create a stream out of the buffer passed in and call
//              CoUnmarshalInterface on it.
//
//  History:    30-Sep-98   TarunA      Created
//
//+-------------------------------------------------------------------
STDMETHODIMP CCtxCall::UnmarshalItfPtrs(REFIID riid, PVOID *ppvInterface, BOOL fIn,
                                       BOOL fOut)
{
    ASSERT_LOCK_NOT_HELD(gComLock);

    // Sanity check
    Win4Assert(_cUnmarshalItfs <= _cMarshalItfs && 0 < _cMarshalItfs);

    HRESULT hr = S_OK;
    InterfaceData *pData = (InterfaceData *)*ppvInterface;

    CXmitRpcStream *pStm = new CXmitRpcStream(pData);
    if(NULL != pStm)
    {
        IUnknown *pUnk = NULL;
        // Unmarshal the interface pointer
        hr = CoUnmarshalInterface(pStm, riid, (void**)&pUnk);
        if(SUCCEEDED(hr))
        {
            // Point to the unmarshaled interface
            *ppvInterface= pUnk;

            // Release the serialized data buffer
            PrivMemFree(pData);

            // Increment the count of ptrs unmarshaled
            _cUnmarshalItfs++;
        }

        // Delete the stream object
        delete pStm;
    }
    else
        hr = E_OUTOFMEMORY;

    ASSERT_LOCK_NOT_HELD(gComLock);
    return hr;
}

//+-------------------------------------------------------------------
//
//  Method:     CPolicySet::Initialize     public
//
//  Synopsis:   Initializes allocators for policy sets
//
//  History:    20-Dec-97   Gopalk      Created
//
//+-------------------------------------------------------------------
void CPolicySet::Initialize()
{
    ContextDebugOut((DEB_POLICYSET, "CPolicySet::Initialize\n"));
    ASSERT_LOCK_NOT_HELD(gPSLock);

    // Acquire lock
    LOCK(gPSLock);

    // Initialize the allocators only if needed
    if(s_cObjects == 0 && !s_fInitialized)
    {
        s_PSallocator.Initialize(sizeof(CPolicySet), PS_PER_PAGE, NULL);
        s_PEallocator.Initialize(sizeof(PolicyEntry), PE_PER_PAGE, NULL);
    }

    // Mark the state as initialized
    s_fInitialized = TRUE;

    // Release lock
    UNLOCK(gPSLock);

    return;
}


//+-------------------------------------------------------------------
//
//  Method:     CPolicySet::operator new     public
//
//  Synopsis:   new operator of policy set
//
//  History:    20-Dec-97   Gopalk      Created
//
//+-------------------------------------------------------------------
void *CPolicySet::operator new(size_t size)
{
    ContextDebugOut((DEB_POLICYSET, "CPolicySet::operator new\n"));

    // Acquire lock
    ASSERT_LOCK_NOT_HELD(gPSLock);
    LOCK(gPSLock);

    void *pv;

    // CPolicySet can be inherited only by those objects
    // with overloaded new and delete operators
    Win4Assert(size == sizeof(CPolicySet) &&
               "CPolicySet improperly inherited");

    // Make sure allocator is initialized
    Win4Assert(s_fInitialized);

    // Allocate memory
    pv = (void *) s_PSallocator.AllocEntry();
    if(pv)
        ++s_cObjects;

    // Release lock
    UNLOCK(gPSLock);

    return(pv);
}


//+-------------------------------------------------------------------
//
//  Method:     CPolicySet::operator delete     public
//
//  Synopsis:   delete operator of policy set
//
//  History:    20-Dec-97   Gopalk      Created
//
//+-------------------------------------------------------------------
void CPolicySet::operator delete(void *pv)
{
    ContextDebugOut((DEB_POLICYSET, "CPolicySet::operator delete  pv:%x\n", pv));

    // Acquire lock
    ASSERT_LOCK_NOT_HELD(gPSLock);
    LOCK(gPSLock);

#if DBG==1
    // Ensure that the pv was allocated by the allocator
    // CPolicySet can be inherited only by those objects
    // with overloaded new and delete operators
    LONG index = s_PSallocator.GetEntryIndex((PageEntry *) pv);
    Win4Assert(index != -1);
#endif

    // Release policy entries
    CPolicySet *pPS = (CPolicySet *) pv;
    if(pPS->_cPolicies > 1)
        s_PEallocator.ReleaseEntryList((PageEntry *) pPS->_pFirstEntry,
                                       (PageEntry *) pPS->_pLastEntry);
    else if(pPS->_cPolicies == 1)
        s_PEallocator.ReleaseEntry((PageEntry *) pPS->_pFirstEntry);

    // Release the pointer
    s_PSallocator.ReleaseEntry((PageEntry *) pv);
    --s_cObjects;
    // Cleanup allocators if needed
    if(s_fInitialized==FALSE && s_cObjects==0)
    {
        s_PSallocator.Cleanup();
        s_PEallocator.Cleanup();
    }

    // Release writer lock
    UNLOCK(gPSLock);

    return;
}


//+-------------------------------------------------------------------
//
//  Method:     CPolicySet::Cleanup     public
//
//  Synopsis:   Cleanup allocator of policy sets
//
//  History:    20-Dec-97   Gopalk      Created
//
//+-------------------------------------------------------------------
void CPolicySet::Cleanup()
{
    ContextDebugOut((DEB_POLICYSET, "CPolicySet::Cleanup\n"));
    ASSERT_LOCK_NOT_HELD(gPSLock);

    // Acquire lock
    LOCK(gPSLock);

    // Check if initialized
    if(s_fInitialized)
    {
        // Ensure that there are no policy sets
        if(s_cObjects == 0)
        {
            // Cleanup allocators
            s_PSallocator.Cleanup();
            s_PEallocator.Cleanup();
        }

        // State is no longer initialized
        s_fInitialized = FALSE;
    }

    // Release lock
    UNLOCK(gPSLock);

    ASSERT_LOCK_NOT_HELD(gPSLock);
    return;
}

//+-------------------------------------------------------------------
//
//  Method:     CPolicySet::CPolicySet     public
//
//  Synopsis:   Constructor of policy set
//
//  History:    20-Dec-97   Gopalk      Created
//
//+-------------------------------------------------------------------
CPolicySet::CPolicySet(DWORD dwFlags)
{
    ContextDebugOut((DEB_POLICYSET, "CPolicySet::CPolicySet this:%x\n", this));
    ASSERT_LOCK_NOT_HELD(gComLock);

    _dwFlags = dwFlags;
#ifdef ASYNC_SUPPORT
    _dwFlags |= PSFLAG_ASYNCSUPPORT;
#endif
    _cRefs = 1;
    _cPolicies = 0;
    _dwAptID = -2;
    _pClientCtx = NULL;
    _pServerCtx = NULL;
    _pFirstEntry = NULL;
    _pLastEntry = NULL;
    _PSCache.clientPSChain.pNext = NULL;
    _PSCache.clientPSChain.pPrev = NULL;
    _PSCache.serverPSChain.pNext = NULL;
    _PSCache.serverPSChain.pPrev = NULL;
}


//+-------------------------------------------------------------------
//
//  Method:     CPolicySet::~CPolicySet     private
//
//  Synopsis:   Destructor of policy set
//
//  History:    20-Dec-97   Gopalk      Created
//
//+-------------------------------------------------------------------
CPolicySet::~CPolicySet()
{
    ContextDebugOut((DEB_POLICYSET, "CPolicySet::~CPolicySet this:%x\n", this));
    ASSERT_LOCK_NOT_HELD(gComLock);
    gPSRWLock.AssertNotHeld();

    // Sanity checks
    Win4Assert(_cRefs == 0);
    Win4Assert(_pClientCtx==NULL);
    Win4Assert((_cPolicies != 0) == (_pFirstEntry != NULL));
    Win4Assert(_PSCache.clientPSChain.pNext == NULL);
    Win4Assert(_PSCache.clientPSChain.pPrev == NULL);
    Win4Assert(_PSCache.serverPSChain.pNext == NULL);
    Win4Assert(_PSCache.serverPSChain.pPrev == NULL);

    // Release any policy entries that might be present
    PolicyEntry *pEntry = _pFirstEntry;
    while(pEntry)
    {
        pEntry->pPolicy->Release();
        pEntry->pPolicy = NULL;

#ifdef ASYNC_SUPPORT
        if(pEntry->pPolicyAsync)
        {
            pEntry->pPolicyAsync->Release();
            pEntry->pPolicyAsync = NULL;
        }
#endif
        pEntry = pEntry->pNext;
    }

    ASSERT_LOCK_NOT_HELD(gComLock);
}


//+-------------------------------------------------------------------
//
//  Method:     CPolicySet::QueryInterface     public
//
//  Synopsis:   QI behavior of policy set
//
//  History:    20-Dec-97   Gopalk      Created
//
//+-------------------------------------------------------------------
STDMETHODIMP CPolicySet::QueryInterface(REFIID riid, LPVOID *ppv)
{
    ContextDebugOut((DEB_POLICYSET, "CPolicySet::QueryInterface this:%x riid:%I\n",
                    this, &riid));

    HRESULT hr = S_OK;

    if(IsEqualIID(riid, IID_IUnknown))
    {
        *ppv = (IUnknown *) this;
    }
    else if(IsEqualIID(riid, IID_IPolicySet))
    {
        *ppv = (IPolicySet *) this;
    }
    else if(IsEqualIID(riid, IID_IStdPolicySet))
    {
        *ppv = this;
    }
    else
    {
        *ppv = NULL;
        hr = E_NOINTERFACE;
    }

    // AddRef the interface before return
    if(*ppv)
        ((IUnknown *) (*ppv))->AddRef();

    ContextDebugOut((DEB_POLICYSET, "CPolicySet::QueryInterface this:%x hr:0x%x\n",
                     this, hr));
    return hr;
}


//+-------------------------------------------------------------------
//
//  Method:     CPolicySet::AddRef     public
//
//  Synopsis:   AddRefs policy set
//
//  History:    20-Dec-97   Gopalk      Created
//
//+-------------------------------------------------------------------
STDMETHODIMP_(ULONG) CPolicySet::AddRef()
{
    ContextDebugOut((DEB_POLICYSET, "CPolicySet::AddRef this:%x cRefs:%x\n",
                    this, _cRefs+1));

    ULONG cRefs;

    // Increment ref count
    cRefs = InterlockedIncrement((LONG *)& _cRefs);

    return(cRefs);
}


//+-------------------------------------------------------------------
//
//  Method:     CPolicySet::Release     public
//
//  Synopsis:   Release policy set. Gaurds against
//              double destruction that can happen if it aggregates
//              another object and gets nested AddRef and Release on
//              the thread invoking the destructor
//
//  History:    20-Dec-97   Gopalk      Created
//
//+-------------------------------------------------------------------
STDMETHODIMP_(ULONG) CPolicySet::Release()
{
    ULONG cRefs;

    // Decrement ref count
    cRefs = InterlockedDecrement((LONG *) &_cRefs);

    if(cRefs == 0)
        delete this;
        
    ContextDebugOut((DEB_POLICYSET, "CPolicySet::Release this:%x cRefs:%x\n",
                     this, cRefs));
    return(cRefs);
}


//+-------------------------------------------------------------------
//
//  Method:     CPolicySet::AddPolicy     public
//
//  Synopsis:   Implements IPolicySet::AddPolicy method
//
//  History:    20-Dec-97   Gopalk      Created
//
//+-------------------------------------------------------------------
STDMETHODIMP CPolicySet::AddPolicy(ContextEvent ctxEvent, REFGUID rguid,
                                   IPolicy *pUnk)
{
    ContextDebugOut((DEB_POLICYSET, "CPolicySet::AddPolicy this:%x pUnk:%x rguid:%I\n",
                    this, pUnk, &rguid));
    ASSERT_LOCK_NOT_HELD(gComLock);

    HRESULT hr = E_INVALIDARG;
    PolicyEntry *pEntry, *pNewEntry;
    IPolicy *pPolicy = NULL;
    BOOL fAdded = FALSE;

    // Validate arguments
    do
    {
        if((_dwFlags & PSFLAG_CLIENTSIDE) || (_dwFlags & PSFLAG_PROXYSIDE))
        {
            if(ctxEvent & SERVER_CTXEVENTS)
                break;
        }
        if((_dwFlags & PSFLAG_SERVERSIDE) && (_dwFlags & PSFLAG_STUBSIDE))
        {
            if(ctxEvent & CLIENT_CTXEVENTS)
                break;
        }

        if(ctxEvent & SERVER_ENTER_CTXEVENTS)
        {
            if(!!(ctxEvent & CONTEXTEVENT_ENTER) ==
               !!(ctxEvent & CONTEXTEVENT_ENTERWITHBUFFER))
                break;
        }
        if(ctxEvent & SERVER_LEAVE_CTXEVENTS)
        {
            if(!!(ctxEvent & CONTEXTEVENT_LEAVE) ==
               !!(ctxEvent & CONTEXTEVENT_LEAVEFILLBUFFER))
                break;
            if(ctxEvent & SERVER_EXCEPTION_CTXEVENTS)
                break;
        }
        else if(ctxEvent & SERVER_EXCEPTION_CTXEVENTS)
        {
            if(!!(ctxEvent & CONTEXTEVENT_LEAVEEXCEPTION) ==
               !!(ctxEvent & CONTEXTEVENT_LEAVEEXCEPTIONFILLBUFFER))
                break;
        }

        if(ctxEvent & CLIENT_CALL_CTXEVENTS)
        {
            if(!!(ctxEvent & CONTEXTEVENT_CALL) ==
               !!(ctxEvent & CONTEXTEVENT_CALLFILLBUFFER))
                break;
        }
        if(ctxEvent & CLIENT_RETURN_CTXEVENTS)
        {
            if(!!(ctxEvent & CONTEXTEVENT_RETURN) ==
               !!(ctxEvent & CONTEXTEVENT_RETURNWITHBUFFER))
                break;
            if(ctxEvent & CLIENT_EXCEPTION_CTXEVENTS)
                break;
        }
        else if(ctxEvent & CLIENT_EXCEPTION_CTXEVENTS)
        {
            if(!!(ctxEvent & CONTEXTEVENT_RETURNEXCEPTION) ==
               !!(ctxEvent & CONTEXTEVENT_RETURNEXCEPTIONWITHBUFFER))
                break;
        }

        if(FAILED(pUnk->QueryInterface(IID_IPolicy, (void **) &pPolicy)))
            break;

        hr = S_OK;
    } while(FALSE);

    if(SUCCEEDED(hr))
    {
        // Check if the operation is allowed
        if(_dwFlags & PSFLAG_FROZEN)
        {
            hr = E_FAIL;
        }
        else
        {
            // Do not allow duplicate entries
            pEntry = _pFirstEntry;
            while(pEntry)
            {
                if((pEntry->policyID == rguid) && (pEntry->ctxEvent & ctxEvent))
                {
                    hr = E_INVALIDARG;
                    break;
                }

                pEntry = pEntry->pNext;
            }

            if(SUCCEEDED(hr))
            {
                // Allocte a new policy entry
                LOCK(gPSLock);
                pNewEntry = (PolicyEntry *) s_PEallocator.AllocEntry();
                UNLOCK(gPSLock);
                if(pNewEntry)
                {
                    pNewEntry->policyID = rguid;
                    pNewEntry->pPolicy = pPolicy;
#ifdef ASYNC_SUPPORT
                    pNewEntry->pPolicyAsync = NULL;
#endif
                    pNewEntry->ctxEvent = ctxEvent;
                    pNewEntry->pPrev = _pLastEntry;
                    pNewEntry->pNext = NULL;
                    if(_pFirstEntry)
                    {
                        Win4Assert(_pLastEntry);
                        _pLastEntry->pNext = pNewEntry;
                    }
                    else
                    {
                        Win4Assert(!_pLastEntry);
                        _pFirstEntry = pNewEntry;
                    }
                    _pLastEntry = pNewEntry;

                    if(ctxEvent & CLIENT_BUFFERCREATION_CTXEVENTS)
                        _dwFlags |= PSFLAG_CALLBUFFERS;
                    if(ctxEvent & CLIENT_CALL_CTXEVENTS)
                        _dwFlags |= PSFLAG_CALLEVENTS;
                    if(ctxEvent & (CLIENT_RETURN_CTXEVENTS | CLIENT_EXCEPTION_CTXEVENTS))
                        _dwFlags |= PSFLAG_RETURNEVENTS;
                    if(ctxEvent & SERVER_BUFFERCREATION_CTXEVENTS)
                        _dwFlags |= PSFLAG_LEAVEBUFFERS;
                    if(ctxEvent & SERVER_ENTER_CTXEVENTS)
                        _dwFlags |= PSFLAG_ENTEREVENTS;
                    if(ctxEvent & (SERVER_LEAVE_CTXEVENTS | SERVER_EXCEPTION_CTXEVENTS))
                        _dwFlags |= PSFLAG_LEAVEEVENTS;
                    ++_cPolicies;
                    fAdded = TRUE;
                }
                else
                    hr = E_OUTOFMEMORY;
            }
        }
    }

    if(fAdded)
    {
        // Check if the policy object implements IPolicyAsync interface
#ifdef ASYNC_SUPPORT
        void *pv;
        HRESULT hr1 = pPolicy->QueryInterface(IID_IPolicyAsync, &pv);
        if(SUCCEEDED(hr1) && pv)
            pNewEntry->pPolicyAsync = (IPolicyAsync *) pv;
        else
            ResetAsyncSupport();
#endif
    }
    else if(pPolicy)
        pPolicy->Release();

    ASSERT_LOCK_NOT_HELD(gComLock);
    ContextDebugOut((DEB_POLICYSET, "CPolicySet::AddPolicy this:%x hr: 0x%x\n",
                     this, hr));
    return(hr);
}


//+-------------------------------------------------------------------
//
//  Method:     CPolicySet::DeliverReleasePolicyEvents  public
//
//  Synopsis:   Called when the policy set is being marked as cached
//
//  History:    20-Dec-97   Gopalk      Created
//
//+-------------------------------------------------------------------
void CPolicySet::DeliverReleasePolicyEvents()
{
    ContextDebugOut((DEB_POLICYSET,
                     "CPolicySet::DeliverReleasePolicyEvents this:%x\n",
                     this));

    // Sanity checks
    gPSRWLock.AssertNotHeld();

#if DBG==1
    ULONG cPolicies = 0;
#endif
    // Deliver ReleasePolicy events if needed
    PolicyEntry *pEntry = _pFirstEntry;
    while(pEntry)
    {
        pEntry->pPolicy->ReleasePolicy();
        pEntry = pEntry->pNext;
#if DBG==1
        cPolicies++;
#endif
    }
    Win4Assert(_cPolicies == cPolicies);

    return;
}


//+-------------------------------------------------------------------
//
//  Method:     CPolicySet::DeliverAddrefPolicyEvents     public
//
//  Synopsis:   Called when the policy set is being removed from the
//              cache
//
//  History:    20-Dec-97   Gopalk      Created
//
//+-------------------------------------------------------------------
void CPolicySet::DeliverAddRefPolicyEvents()
{
    ContextDebugOut((DEB_POLICYSET,
                     "CPolicySet::DeliverAddRefPolicyEvents this:%x\n", this));

    // Sanity check
    gPSRWLock.AssertNotHeld();

#if DBG==1
    ULONG cPolicies = 0;
#endif
    PolicyEntry *pEntry = _pFirstEntry;
    while(pEntry)
    {
        pEntry->pPolicy->AddRefPolicy();
        pEntry = pEntry->pNext;
#if DBG==1
        cPolicies++;
#endif
    }
    Win4Assert(_cPolicies == cPolicies);

    return;
}


//+-------------------------------------------------------------------
//
//  Method:     CPolicySet::GetSize    private
//
//  Synopsis:   This method is called from inside GetBuffer method
//              before calling CXXXRpcChnl::GetBuffer method
//
//              This method obtains the size of buffer that needs to be
//              allocated for polices that exchange buffers with their
//              counterparts. It updates the cbBuffer field inside
//              RPCOLEMESSAGE to reflect the new size
//
//  History:    20-Dec-97   Gopalk      Created
//
//+-------------------------------------------------------------------
HRESULT CPolicySet::GetSize(CRpcCall *pCall, EnumCallType eCallType,
                            CCtxCall *pCtxCall)
{
    ContextDebugOut((DEB_POLICYSET, "CPolicySet::GetSize this:%x\n", this));
    ASSERT_LOCK_NOT_HELD(gComLock);

    HRESULT hrRet, hrCall = E_UNEXPECTED;
    PolicyEntry *pEntry;
    ContextEvent ctxEvent = 0;
    ULONG cPolicies, cbHeader, cbTotal, cb = 0;
    BOOL fClientSide = TRUE;
    BOOL fBuffers;

    // Assert that the policy set is frozen
    Win4Assert(_dwFlags & PSFLAG_FROZEN);

    // Check COM version for downlevel interop
    hrRet = S_OK;

    // Ensure that this is the first invocation for this call
    if(!(pCtxCall->_dwFlags & CTXCALLFLAG_GBINIT))
    {
        // Main header will always be present
        cbHeader = sizeof(MainHeader);
        cPolicies = 0;
        cbTotal = 0;
        fBuffers = FALSE;

        // Check for any policies
        if(_cPolicies || (pCtxCall->_hrServer != S_OK))
        {
            // Initialize
            Win4Assert((_cPolicies) ? TRUE : _pFirstEntry == NULL);
            pEntry = _pFirstEntry;
            switch(eCallType)
            {
#ifdef CONTEXT_ASYNCSUPPORT
            case CALLTYPE_BEGINCALL:
                if(_dwFlags & PSFLAG_CLIENTBUFFERS)
                {
                    fBuffers = TRUE;
                    ctxEvent = CONTEXTEVENT_BEGINCALLFILLBUFFER;
                }
                fClientSide = TRUE;
                break;

            case CALLTYPE_FINISHLEAVE:
                if(_dwFlags & PSFLAG_SERVERBUFFERS)
                {
                    fBuffers = TRUE;
                    ctxEvent = CONTEXTEVENT_FINISHLEAVEFILLBUFFER;
                    if(pCall->GetHResult() == RPC_E_SERVERFAULT)
                        ctxEvent |= CONTEXTEVENT_LEAVEEXCEPTIONFILLBUFFER;
                }
                fClientSide = FALSE;
                break;
#endif
            case CALLTYPE_SYNCCALL:
                if(_dwFlags & PSFLAG_CALLBUFFERS)
                {
                    fBuffers = TRUE;
                    ctxEvent = CONTEXTEVENT_CALLFILLBUFFER;
                }
                fClientSide = TRUE;
                break;

            case CALLTYPE_SYNCLEAVE:
                if(_dwFlags & PSFLAG_LEAVEBUFFERS)
                {
                    fBuffers = TRUE;
                    ctxEvent = CONTEXTEVENT_LEAVEFILLBUFFER;
                    if(pCall->GetHResult() == RPC_E_SERVERFAULT)
                        ctxEvent |= CONTEXTEVENT_LEAVEEXCEPTIONFILLBUFFER;
                }
                fClientSide = FALSE;
                break;

            default:
                Win4Assert(FALSE);
				return E_UNEXPECTED;
            }
            // Assert that current side matches the policy set
            Win4Assert(!(_dwFlags & PSFLAG_PROXYSIDE) || fClientSide || IsThreadInNTA());
            Win4Assert(!(_dwFlags & PSFLAG_STUBSIDE) || !fClientSide || IsThreadInNTA());

            while(pEntry && fBuffers)
            {
                // Check if the policy wishes to participate in
                // buffer creation events
                if(pEntry->ctxEvent & ctxEvent)
                {
                    // Get buffer size from the policy
                    switch(eCallType)
                    {
#ifdef CONTEXT_ASYNCSUPPORT
                    case CALLTYPE_BEGINCALL:
                        hrCall = pEntry->pPolicyAsync->BeginCallGetSize(pCall, &cb);
                        break;

                    case CALLTYPE_FINISHLEAVE:
                        hrCall = pEntry->pPolicyAsync->FinishLeaveGetSize(pCall, &cb);
                        break;
#endif
                    case CALLTYPE_SYNCCALL:
                        hrCall = pEntry->pPolicy->CallGetSize(pCall, &cb);
                        break;

                    case CALLTYPE_SYNCLEAVE:
                        hrCall = pEntry->pPolicy->LeaveGetSize(pCall, &cb);
                        break;
#if DBG==1
                    default:
                        Win4Assert(FALSE);
#endif
                    }

                    if(SUCCEEDED(hrCall))
                    {
                        if(cb > 0)
                        {
                            // Round up the size to a 8-byte boundary
                            cb = (cb + 7) & ~7;

                            // Add to the total
                            cbTotal += cb;
                            ++cPolicies;
                        }
                    }
                    else
                    {
                        ContextDebugOut((DEB_WARN,
                                        "GetSize for policyID:%I returned hr:0x%x\n",
                                        &pEntry->policyID, hrCall));
                        pCall->Nullify(hrCall);
                    }
                }

                // Get the next policy
                pEntry = pEntry->pNext;
            }

            // Allocate space for entry headers
            if(cPolicies)
                cbHeader += cPolicies*sizeof(EntryHeader);
        }

        // Obtain latest call status
        hrCall = pCall->GetHResult();

        // Compute the return status
        // REVIEW: If a serverside policy decides to send buffer 
	// (ie cbTotal!=0) *and* fail the call, then downlevel (NT4 etc)
	// clients will choke. Fortunately, we don't have any such
	// policies yet. But beware.
	
	if(fClientSide || cbTotal==0) 
            hrRet = hrCall;

        // Check for the need to send data.  Since the server's true
        // HRESULT is required by COM+ services, we must always send
        // back at least the main header.
        if(((cbTotal > 0) || (pCtxCall->_hrServer != S_OK)) && SUCCEEDED(hrRet))
        {
            // Assert that cbExtent is 8-byte aligned
            Win4Assert(!(cbHeader & 7) && "Extent size not a multiple of 8");
            // Assert that cbTotal is 8-byte aligned
            Win4Assert(!(cbTotal & 7) && "Request size not a multiple of 8");

            // Update context call object
            pCtxCall->_cPolicies = cPolicies;
            pCtxCall->_cbExtent = cbHeader + cbTotal;
        }

        // Update flags of context call object
        pCtxCall->_dwFlags |= CTXCALLFLAG_GBINIT;
    }

    ASSERT_LOCK_NOT_HELD(gComLock);
    ContextDebugOut((DEB_POLICYSET, "CPolicySet::GetSize this:%x hr:0x%x\n",
                     this, hrRet));
    return(hrRet);
}


//+-------------------------------------------------------------------
//
//  Method:     CPolicySet::FillBuffer    private
//
//  Synopsis:   This method is called from inside SendReceive on the
//              client side before calling CXXXRpcChnl::SendReceive
//              and AppInvoke on the server side after the call
//              returns from the stub
//
//              This method puts the policy headers and obtains buffers
//              from the policies which are delivered to their
//              counterparts on the other side.
//
//  History:    20-Dec-97   Gopalk      Created
//
//+-------------------------------------------------------------------
HRESULT CPolicySet::FillBuffer(CRpcCall *pCall, EnumCallType eCallType,
                               CCtxCall *pCtxCall)
{
    ContextDebugOut((DEB_POLICYSET, "CPolicySet::FillBuffer this:%x\n", this));
    ASSERT_LOCK_NOT_HELD(gComLock);

    HRESULT hrRet, hr1 = E_UNEXPECTED;
    RPCOLEMESSAGE *pMessage;
    PolicyEntry *pEntry;
    ContextEvent ctxEvent = 0, ctxBufEvent = 0;
    ULONG cPolicies, cbHeader, cbData, cbTotal, cb = 0;
    MainHeader *pMainHeader;
    EntryHeader *pEntryHeader;
    void *pvBuffer;
    BOOL fClientSide = FALSE;

    // Assert that the policy set is frozen
    Win4Assert(_dwFlags & PSFLAG_FROZEN);

    // Initialize
    hrRet = S_OK;

    // Check for downlevel interop
    if(pCtxCall->_pvExtent && !(pCtxCall->_dwFlags & CTXCALLFLAG_FBDONE))
    {
        // Get the message
        pMessage = pCall->GetMessage();

        // Compute cbHeader and cbData
        cbHeader = sizeof(MainHeader) +
                   pCtxCall->_cPolicies*sizeof(EntryHeader);
        cbData = pCtxCall->_cbExtent - cbHeader;

        // Initialize Main header
        pMainHeader = (MainHeader *) pCtxCall->_pvExtent;
        pMainHeader->Signature = MAINHDRSIG;
        pMainHeader->Version = CONTEXT_VERSION;
        pMainHeader->cbBuffer = pMessage->cbBuffer;
        pMainHeader->cbSize = cbHeader;
        pMainHeader->hrServer = pCtxCall->_hrServer;
        pMainHeader->reserved = NULL;

        // Initialize entry header
        pEntryHeader = (EntryHeader *) (pMainHeader + 1);

        // Seek past proxy/stub data
        pvBuffer = (BYTE *) pMainHeader + cbHeader;
        Win4Assert(!(((ULONG_PTR) pvBuffer) & 7) &&
                   "Buffer is not 8-byte aligned");

        // Loop through policy entries
        cbTotal = 0;
        cPolicies = 0;
        switch(eCallType)
        {
#ifdef CONTEXT_ASYNCSUPPORT
        case CALLTYPE_BEGINCALL:
            ctxEvent = CONTEXTEVENT_BEGINCALL;
            ctxBufEvent = CONTEXTEVENT_BEGINCALLFILLBUFFER;
            fClientSide = TRUE;
            break;

        case CALLTYPE_FINISHLEAVE:
            ctxEvent = CONTEXTEVENT_FINISHLEAVE;
            ctxBufEvent = CONTEXTEVENT_FINISHLEAVEFILLBUFFER;
            fClientSide = FALSE;
            break;
#endif
        case CALLTYPE_SYNCCALL:
            Win4Assert(_dwFlags & PSFLAG_CALLEVENTS || pCtxCall->_hrServer);
            ctxEvent = CONTEXTEVENT_CALL;
            ctxBufEvent = CONTEXTEVENT_CALLFILLBUFFER;
            fClientSide = TRUE;
            break;

        case CALLTYPE_SYNCLEAVE:
            Win4Assert(_dwFlags & PSFLAG_LEAVEEVENTS || pCtxCall->_hrServer);
            ctxEvent = CONTEXTEVENT_LEAVE;
            ctxBufEvent = CONTEXTEVENT_LEAVEFILLBUFFER;
            if(pCall->GetHResult() == RPC_E_SERVERFAULT)
            {
                ctxEvent |= CONTEXTEVENT_LEAVEEXCEPTION;
                ctxBufEvent |= CONTEXTEVENT_LEAVEEXCEPTIONFILLBUFFER;
            }
            fClientSide = FALSE;
            break;
#if DBG==1
        default:
            Win4Assert(FALSE);
#endif
        }
        if(fClientSide)
        {
            pEntry = _pFirstEntry;
        }
        else
        {
            pEntry = _pLastEntry;
            pCall->SetServerHR(pCtxCall->_hrServer);
        }

        // Assert that current side matches the policy set
        Win4Assert(!(_dwFlags & PSFLAG_PROXYSIDE) || fClientSide || IsThreadInNTA());
        Win4Assert(!(_dwFlags & PSFLAG_STUBSIDE) || !fClientSide || IsThreadInNTA());

        while(pEntry)
        {
            // Check if the policy wishes to participate in
            // buffer creation events
            if(pEntry->ctxEvent & ctxBufEvent)
            {
                // Sanity check
                Win4Assert( pvBuffer != NULL );
                Win4Assert(!(pEntry->ctxEvent & ctxEvent));

                // Get buffer from the policy
                switch(eCallType)
                {
#ifdef CONTEXT_ASYNCSUPPORT
                    case CALLTYPE_BEGINCALL:
                        hr1 = pEntry->pPolicyAsync->BeginCallFillBuffer(pCall,
                                                                        pvBuffer,
                                                                        &cb);
                        break;

                    case CALLTYPE_FINISHLEAVE:
                        hr1 = pEntry->pPolicyAsync->FinishLeaveFillBuffer(pCall,
                                                                          pvBuffer,
                                                                          &cb);
                        break;
#endif
                    case CALLTYPE_SYNCCALL:
                        hr1 = pEntry->pPolicy->CallFillBuffer(pCall,
                                                              pvBuffer,
                                                              &cb);
                        break;

                    case CALLTYPE_SYNCLEAVE:
                        hr1 = pEntry->pPolicy->LeaveFillBuffer(pCall,
                                                               pvBuffer,
                                                               &cb);
                        break;
#if DBG==1
                    default:
                        Win4Assert(FALSE);
#endif
                }

                if(SUCCEEDED(hr1))
                {
                    if(cb > 0)
                    {
                        if(cPolicies < pCtxCall->_cPolicies &&
                           cbTotal+((cb + 7) & ~7) <= cbData)
                        {
                            // Update entry header
                            pEntryHeader->Signature = ENTRYHDRSIG;
                            pEntryHeader->cbBuffer = cb;
                            pEntryHeader->cbSize = (ULONG) ((BYTE *) pvBuffer -
                                                   (BYTE *) pMainHeader);
                            pEntryHeader->reserved = NULL;
                            pEntryHeader->policyID = pEntry->policyID;

                            // Sanity check
                            Win4Assert(!(pEntryHeader->cbSize & 7) &&
                                       "cbSize not a multiple of 8");

                            // Round up the size to a 8-byte boundary
                            cb = (cb + 7) & ~7;

                            // Skip to next entry header
                            ++pEntryHeader;

                            // Update Buffer pointer for next policy
                            pvBuffer = (BYTE *) pvBuffer + cb;
                            Win4Assert(!(((ULONG_PTR) pvBuffer) & 7) &&
                                       "Buffer is not 8-byte aligned");

                            // Add to the total
                            cbTotal += cb;
                            ++cPolicies;
                        }
                        else
                        {
                            Win4Assert(!"FillBuffer events > GetSize events");
                            ContextDebugOut((DEB_WARN,
                                             "Either more Policies "
                                             "participated in FillBuffer "
                                             "events than GetSize events "
                                             "\nOR\n Buffer length requested "
                                             "in GetSize was exceeded\n"));
                            hr1 = pCall->Nullify(E_FAIL);
                            Win4Assert(hr1 == S_OK);
                            break;
                        }
                    }
                }
            }
            else if(pEntry->ctxEvent & ctxEvent)
            {
                switch(eCallType)
                {
#ifdef CONTEXT_ASYNCSUPPORT
                    case CALLTYPE_BEGINCALL:
                        hr1 = pEntry->pPolicyAsync->BeginCall(pCall);
                        break;

                    case CALLTYPE_FINISHLEAVE:
                        hr1 = pEntry->pPolicyAsync->FinishLeave(pCall);
                        break;
#endif
                    case CALLTYPE_SYNCCALL:
                        hr1 = pEntry->pPolicy->Call(pCall);
                        break;

                    case CALLTYPE_SYNCLEAVE:
                        hr1 = pEntry->pPolicy->Leave(pCall);
                        break;
#if DBG==1
                    default:
                        Win4Assert(FALSE);
#endif
                }
            }
            else
                hr1 = S_OK;

            if(FAILED(hr1))
            {
                ContextDebugOut((DEB_WARN,
                                 "FillBuffer for policyID:%I returned hr:0x%x\n",
                                 &pEntry->policyID, hr1));
                hr1 = pCall->Nullify(hr1);
                Win4Assert(hr1 == S_OK);
            }

            // Get the next policy
            if(fClientSide)
                pEntry = pEntry->pNext;
            else
                pEntry = pEntry->pPrev;
        }
        Win4Assert(cPolicies <= pCtxCall->_cPolicies);
        if(cPolicies < pCtxCall->_cPolicies)
            ContextDebugOut((DEB_WARN,
                             "%2d policies participated in FillBuffer events "
                             "as opposed to %2d policies that participated "
                             "in GetSize events\n",
                             cPolicies, pCtxCall->_cPolicies));
        Win4Assert(cbTotal <= cbData);
        if(cbTotal < cbData)
            ContextDebugOut((DEB_WARN,
                             "%3d bytes supplied in FillBuffer events as "
                             "opposed to %3d bytes requested in GetSize events\n",
                             cbTotal, cbData));

        // Update main header
        pMainHeader->cPolicies = cPolicies;
        if(fClientSide)
        {
            pMainHeader->hr = S_OK;
            hrRet = pCall->GetHResult();
        }
        else
        {
            pMainHeader->hr = pCall->GetHResult();
	    
	    // REVIEW: If a serverside policy decides to send buffer 
	    // (ie cbTotal!=0) *and* fail the call, then downlevel (NT4 etc)
	    // clients will choke. Fortunately, we don't have any such
	    // policies yet. But beware.
	    
	    if(cbTotal == 0) 
                hrRet = pMainHeader->hr;
        }

        // Update context call object
        pCtxCall->_dwFlags |= CTXCALLFLAG_FBDONE;

        // Assert that buffer is 8-byte aligned
        Win4Assert(!(((ULONG_PTR) pMessage->Buffer) & 7) &&
                   "Buffer not 8-byte aligned");
    }
    else
    {
        // Downlevel interop or Failed call
        hrRet = DeliverEvents(pCall, eCallType, pCtxCall);
    }

    ASSERT_LOCK_NOT_HELD(gComLock);
    ContextDebugOut((DEB_POLICYSET, "CPolicySet::FillBuffer this:%x hr:0x%x\n",
                     this, hrRet));
    return(hrRet);
}


//+-------------------------------------------------------------------
//
//  Method:     CPolicySet::Notify    private
//
//  Synopsis:   This method is called from inside SendReceive on the
//              client side after the call returns and StubInvoke on the
//              server side before the call is dispatched to the stub
//
//              This method delivers buffers created by polcies on the
//              other side to the polcies on this side
//
//  History:    20-Dec-97   Gopalk      Created
//
//+-------------------------------------------------------------------
HRESULT CPolicySet::Notify(CRpcCall *pCall, EnumCallType eCallType,
                           CCtxCall *pCtxCall)
{
    ContextDebugOut((DEB_POLICYSET, "CPolicySet::Notify this:%x\n", this));
    ASSERT_LOCK_NOT_HELD(gComLock);

    HRESULT hrRet, hr1 = E_UNEXPECTED;
    RPCOLEMESSAGE *pMessage;
    BOOL fDataRep, fClientSide = FALSE, fDeliver;
    ContextEvent ctxEvent = 0, ctxBufEvent = 0;
    PolicyEntry *pEntry;
    MainHeader *pMainHeader;
    EntryHeader *pEntryHeader;
    void *pvBuffer;
    unsigned long cbBuffer;
    unsigned long i;

    // Assert that the policy set is frozen
    Win4Assert(_dwFlags & PSFLAG_FROZEN);

    // Check COM version for downlevel interop
    pMainHeader = NULL;
    hrRet = S_OK;

    // Check for the presence of buffers created by the policies
    // on the other side
    if(pCtxCall->_pvExtent)
    {
        // Initialize
        fDeliver = FALSE;

        // Get the message
        pMessage = pCall->GetMessage();

        // Obtain Main Header pointer
        pMainHeader = (MainHeader *) pCtxCall->_pvExtent;

        if(!(pCtxCall->_dwFlags & CTXCALLFLAG_NBINIT))
        {
            // Check data representation of the incoming buffer
            // NT supports only Little Endianess
            if((pMessage->dataRepresentation & NDR_INT_REP_MASK) != NDR_LOCAL_ENDIAN)
                fDataRep = TRUE;
            else
                fDataRep = FALSE;

            // Catch exceptions raised while examining headers
            _try
            {
                // Check the need to change to local data representation
                if(fDataRep)
                {
                    ByteSwapLong(pMainHeader->Signature);
                    ByteSwapLong(pMainHeader->Version);
                    ByteSwapLong(pMainHeader->cPolicies);
                    ByteSwapLong(pMainHeader->cbBuffer);
                    ByteSwapLong(pMainHeader->cbSize);
                    ByteSwapLong(*((DWORD *) &pMainHeader->hr));
                    ByteSwapLong(*((DWORD *) &pMainHeader->hrServer));
                }

                // Validate the header
                if(pMainHeader->Signature != MAINHDRSIG)
                {
                    ContextDebugOut((DEB_WARN, "Invalid Signature inside "
                                     "Main Header\n"));
                    hrRet = RPC_E_INVALID_HEADER;
                }
                else if((pMainHeader->Version & 0xFFFF0000) != CONTEXT_MAJOR_VERSION ||
                        (pMainHeader->Version & 0x0000FFFF) > CONTEXT_MINOR_VERSION)
                {
                    ContextDebugOut((DEB_WARN, "Invalid version inside "
                                     "Main Header\n"));
                    hrRet = RPC_E_INVALID_HEADER;
                }
                else
                {
                    // Initialize entry header
                    pEntryHeader = (EntryHeader *) (pMainHeader + 1);

                    // Check for existance of buffers created by policies
                    for(i = 0; i < pMainHeader->cPolicies;i++)
                    {
                        // Check the need to change to local data representation
                        if(fDataRep)
                        {
                            ByteSwapLong(pEntryHeader->Signature);
                            ByteSwapLong(pEntryHeader->cbBuffer);
                            ByteSwapLong(pEntryHeader->cbSize);
                            ByteSwapLong(pEntryHeader->policyID.Data1 );
                            ByteSwapShort(pEntryHeader->policyID.Data2 );
                            ByteSwapShort(pEntryHeader->policyID.Data3 );
                        }

                        // Validate the header
                        if(pEntryHeader->Signature != ENTRYHDRSIG)
                        {
                            ContextDebugOut((DEB_WARN, "Invalid Signature "
                                             "inside Entry Header\n"));
                            hrRet = RPC_E_INVALID_HEADER;
                            break;
                        }

                        // Skip to next entry header
                        ++pEntryHeader;
                    }
                }
            }
            _except(EXCEPTION_EXECUTE_HANDLER)
            {
                Win4Assert(!"Improper Header Data");
                hrRet = RPC_E_INVALID_HEADER;
            }
        }

        // Check if header data has been successfuly unmarshaled
        if(SUCCEEDED(hrRet))
        {
            // Header has been converted to local representation
            pCtxCall->_dwFlags |= CTXCALLFLAG_NBINIT;

            // Determine appropriate ctxEvents
            switch(eCallType)
            {
#ifdef CONTEXT_ASYNCSUPPORT
            case CALLTYPE_FINISHRETURN:
                ctxEvent = CONTEXTEVENT_FINISHRETURN;
                ctxBufEvent = CONTEXTEVENT_FINISHRETURNWITHBUFFER;
                fClientSide = TRUE;
                break;

            case CALLTYPE_BEGINENTER:
                ctxEvent = CONTEXTEVENT_BEGINENTER;
                ctxBufEvent = CONTEXTEVENT_BEGINENTERWITHBUFFER;
                fClientSide = FALSE;
                break;
#endif
            case CALLTYPE_SYNCRETURN:
                if(_dwFlags & PSFLAG_RETURNEVENTS)
                {
                    fDeliver = TRUE;
                    ctxEvent = CONTEXTEVENT_RETURN;
                    ctxBufEvent = CONTEXTEVENT_RETURNWITHBUFFER;
                    if(pCall->GetHResult() == RPC_E_SERVERFAULT)
                    {
                        ctxEvent |= CONTEXTEVENT_RETURNEXCEPTION;
                        ctxBufEvent |= CONTEXTEVENT_RETURNEXCEPTIONWITHBUFFER;
                    }
                }
                fClientSide = TRUE;
                break;

            case CALLTYPE_SYNCENTER:
                if(_dwFlags & PSFLAG_ENTEREVENTS)
                {
                    fDeliver = TRUE;
                    ctxEvent = CONTEXTEVENT_ENTER;
                    ctxBufEvent = CONTEXTEVENT_ENTERWITHBUFFER;
                }
                fClientSide = FALSE;
                break;
#if DBG==1
            default:
                Win4Assert(FALSE);
#endif
            }

            // Assert that current side matches the policy set
            Win4Assert(!(_dwFlags & PSFLAG_PROXYSIDE) || fClientSide);
            Win4Assert(!(_dwFlags & PSFLAG_STUBSIDE) || !fClientSide);

            if (fClientSide)
            {
                // On the client side, nullify the call for failed HRESULT
                // inside the main header
                if (FAILED(pMainHeader->hr))
                    pCall->Nullify(pMainHeader->hr);
                    
                // Set the server's HRESULT in the call object
                pCall->SetServerHR(pMainHeader->hrServer);
                
                // On client side, start with the last entry.
                pEntry = _pLastEntry;
            }
            else
            {
                pEntry = _pFirstEntry;
            }

            while(pEntry && fDeliver)
            {
                if(pEntry->ctxEvent & ctxBufEvent)
                {
                    // Sanity check
                    Win4Assert(!(pEntry->ctxEvent & ctxEvent));

                    // Initialize
                    pvBuffer = NULL;
                    cbBuffer = 0;

                    // Initialize entry header
                    pEntryHeader = (EntryHeader *) (pMainHeader + 1);

                    // Check if a buffer is available for the policy
                    for(i = 0; i < pMainHeader->cPolicies;i++)
                    {
                        // Compare GUIDS
                        if(pEntry->policyID == pEntryHeader->policyID)
                        {
                            // Obtain policy buffer
                            cbBuffer = pEntryHeader->cbBuffer;
                            pvBuffer = (BYTE *) pMainHeader + pEntryHeader->cbSize;
                            break;
                        }

                        // Skip to next entry header
                        ++pEntryHeader;
                    }

                    // Deliver event to the policy
                    switch(eCallType)
                    {
#ifdef CONTEXT_ASYNCSUPPORT
                    case CALLTYPE_FINISHRETURN:
                        hr1 = pEntry->pPolicyAsync->FinishReturnWithBuffer(pCall,
                                                                           pvBuffer,
                                                                           cbBuffer);
                        break;

                    case CALLTYPE_BEGINENTER:
                        hr1 = pEntry->pPolicyAsync->BeginEnterWithBuffer(pCall,
                                                                         pvBuffer,
                                                                         cbBuffer);
                        break;
#endif
                    case CALLTYPE_SYNCRETURN:
                        hr1 = pEntry->pPolicy->ReturnWithBuffer(pCall,
                                                                pvBuffer,
                                                                cbBuffer);
                        break;

                    case CALLTYPE_SYNCENTER:
                        hr1 = pEntry->pPolicy->EnterWithBuffer(pCall,
                                                               pvBuffer,
                                                               cbBuffer);
                        break;
#if DBG==1
                    default:
                        Win4Assert(FALSE);
#endif
                    }
                }
                else if(pEntry->ctxEvent & ctxEvent)
                {
                    switch(eCallType)
                    {
#ifdef CONTEXT_ASYNCSUPPORT
                    case CALLTYPE_FINISHRETURN:
                        hr1 = pEntry->pPolicyAsync->FinishReturn(pCall);
                        break;

                    case CALLTYPE_BEGINENTER:
                        hr1 = pEntry->pPolicyAsync->BeginEnter(pCall);
                        break;
#endif
                    case CALLTYPE_SYNCRETURN:
                        hr1 = pEntry->pPolicy->Return(pCall);
                        break;

                    case CALLTYPE_SYNCENTER:
                        hr1 = pEntry->pPolicy->Enter(pCall);
                        break;
#if DBG==1
                    default:
                        Win4Assert(FALSE);
#endif
                    }
                }
                else
                    hr1 = S_OK;

                if(FAILED(hr1))
                {
                    ContextDebugOut((DEB_WARN,
                                     "Notify for policyID:%I failed with hr:0x%x\n",
                                     &pEntry->policyID, hr1));
                    hr1 = pCall->Nullify(hr1);
                    Win4Assert(hr1 == S_OK);
                }

                // Get the next policy
                if(fClientSide)
                    pEntry = pEntry->pPrev;
                else
                    pEntry = pEntry->pNext;
            }

            // Return latest call status
            hrRet = pCall->GetHResult();
        }
    }
    else
    {
        // Downlevel interop or Failed call
        hrRet = DeliverEvents(pCall, eCallType, pCtxCall);
    }

    ASSERT_LOCK_NOT_HELD(gComLock);
    ContextDebugOut((DEB_POLICYSET, "CPolicySet::Notify returning hr:0x%x\n",
                     hrRet));
    return(hrRet);
}


//+-------------------------------------------------------------------
//
//  Method:     CPolicySet::DeliverEvents    private
//
//  Synopsis:   This method is called from inside SendReceive on the
//              client side and StubInvoke on the server side
//
//              This method delivers events to polcies. It is called when
//              there is not any buffer to deliver, and any buffer that
//              we create cannot be delivered. (We still have to honor
//              our contract with the policies to call GetSize first.)
//
//  History:    20-Dec-97   Gopalk      Created
//
//+-------------------------------------------------------------------
HRESULT CPolicySet::DeliverEvents(CRpcCall *pCall, EnumCallType eCallType, CCtxCall *pCtxCall)
{
    ContextDebugOut((DEB_POLICYSET, "CPolicySet::DeliverEvents this:%x\n", this));
    ASSERT_LOCK_NOT_HELD(gComLock);

    HRESULT hrRet, hr1 = E_UNEXPECTED;
    ContextEvent ctxEvent = 0, ctxBufEvent = 0, ctxCurrent;
    BOOL fForward, fDeliver;
    PolicyEntry *pEntry;
    BOOL fClientSide;
    void *pvBuf = NULL;
    ULONG cbBuf = 0;
    ULONG cbNeeded = 0;

    // Assert that the policy set is frozen
    Win4Assert(_dwFlags & PSFLAG_FROZEN);

    // Check for any policies
    if(_cPolicies)
    {
        // Initialize
        fDeliver = FALSE;

        // Determine appropriate ctxEvents
        switch(eCallType)
        {
        case CALLTYPE_SYNCCALL:
            if(_dwFlags & PSFLAG_CALLEVENTS)
            {
                fDeliver = TRUE;
                ctxBufEvent = CONTEXTEVENT_CALLFILLBUFFER;
                ctxEvent = CONTEXTEVENT_CALL;
            }
            fForward = TRUE;
            fClientSide = TRUE;
            break;

        case CALLTYPE_SYNCENTER:
            if(_dwFlags & PSFLAG_ENTEREVENTS)
            {
                fDeliver = TRUE;
                ctxBufEvent = CONTEXTEVENT_ENTERWITHBUFFER;
                ctxEvent = CONTEXTEVENT_ENTER;
            }
            fForward = TRUE;
            fClientSide = FALSE;
            break;

        case CALLTYPE_SYNCLEAVE:
            if(_dwFlags & PSFLAG_LEAVEEVENTS)
            {
                fDeliver = TRUE;
                ctxBufEvent = CONTEXTEVENT_LEAVEFILLBUFFER;
                ctxEvent = CONTEXTEVENT_LEAVE;
                if(pCall->GetHResult() == RPC_E_SERVERFAULT)
                {
                    ctxBufEvent |= CONTEXTEVENT_LEAVEEXCEPTIONFILLBUFFER;
                    ctxEvent |= CONTEXTEVENT_LEAVEEXCEPTION;
                }
            }
            fForward = FALSE;
            fClientSide = FALSE;
            break;

        case CALLTYPE_SYNCRETURN:
            if(_dwFlags & PSFLAG_RETURNEVENTS)
            {
                fDeliver = TRUE;
                ctxBufEvent = CONTEXTEVENT_RETURNWITHBUFFER;
                ctxEvent = CONTEXTEVENT_RETURN;
                if(pCall->GetHResult() == RPC_E_SERVERFAULT)
                {
                    ctxBufEvent |= CONTEXTEVENT_RETURNEXCEPTIONWITHBUFFER;
                    ctxEvent |= CONTEXTEVENT_RETURNEXCEPTION;
                }
            }
            fForward = FALSE;
            fClientSide = TRUE;
            break;

#ifdef CONTEXT_ASYNCSUPPORT
        case CALLTYPE_BEGINCALL:
            ctxBufEvent = CONTEXTEVENT_BEGINCALLFILLBUFFER;
            ctxEvent = CONTEXTEVENT_BEGINCALL;
            fForward = TRUE;
            fClientSide = TRUE;
            break;

        case CALLTYPE_BEGINENTER:
            ctxBufEvent = CONTEXTEVENT_BEGINENTERWITHBUFFER;
            ctxEvent = CONTEXTEVENT_BEGINENTER;
            fForward = TRUE;
            fClientSide = FALSE;
            break;

        case CALLTYPE_BEGINLEAVE:
            ctxBufEvent = CONTEXTEVENT_NONE;
            ctxEvent = CONTEXTEVENT_BEGINLEAVE;
            fForward = FALSE;
            fClientSide = FALSE;
            break;

        case CALLTYPE_BEGINRETURN:
            ctxBufEvent = CONTEXTEVENT_NONE;
            ctxEvent = CONTEXTEVENT_BEGINRETURN;
            fForward = FALSE;
            fClientSide = TRUE;
            break;

        case CALLTYPE_FINISHCALL:
            ctxBufEvent = CONTEXTEVENT_NONE;
            ctxEvent = CONTEXTEVENT_FINISHCALL;
            fForward = TRUE;
            fClientSide = TRUE;
            break;

        case CALLTYPE_FINISHENTER:
            ctxBufEvent = CONTEXTEVENT_NONE;
            ctxEvent = CONTEXTEVENT_FINISHENTER;
            fForward = TRUE;
            fClientSide = FALSE;
            break;

        case CALLTYPE_FINISHLEAVE:
            ctxBufEvent = CONTEXTEVENT_FINISHLEAVEFILLBUFFER;
            ctxEvent = CONTEXTEVENT_FINISHLEAVE;
            fForward = FALSE;
            fClientSide = FALSE;
            break;

        case CALLTYPE_FINISHRETURN:
            ctxBufEvent = CONTEXTEVENT_FINISHRETURNWITHBUFFER;
            ctxEvent = CONTEXTEVENT_FINISHRETURN;
            fForward = FALSE;
            fClientSide = TRUE;
            break;
#endif
        default:
            Win4Assert(FALSE);
			return E_UNEXPECTED;
        }

        // Assert that current side matches the policy set
        Win4Assert(!(_dwFlags & PSFLAG_PROXYSIDE) || fClientSide);
        Win4Assert(!(_dwFlags & PSFLAG_STUBSIDE) || !fClientSide);

        // Loop through policy entries
        if(fForward)
            pEntry = _pFirstEntry;
        else
            pEntry = _pLastEntry;

        BOOL fCallGetSize;
        if (pCtxCall)
        {
            fCallGetSize = !(pCtxCall->_dwFlags & CTXCALLFLAG_GBINIT);
        }
        else
        {
            fCallGetSize = TRUE;
        }

        while(pEntry && fDeliver)
        {
            // Check if the policy wishes to participate in the event
            if(pEntry->ctxEvent & ctxBufEvent)
                ctxCurrent = pEntry->ctxEvent & ctxBufEvent;
            else if(pEntry->ctxEvent & ctxEvent)
                ctxCurrent = pEntry->ctxEvent & ctxEvent;
            else
                ctxCurrent = CONTEXTEVENT_NONE;

            // Deliver event to policy
            switch(ctxCurrent)
            {
            case CONTEXTEVENT_CALL:
                hr1 = pEntry->pPolicy->Call(pCall);
                break;

            case CONTEXTEVENT_CALLFILLBUFFER:
                if (fCallGetSize)
                {
                    hr1 = pEntry->pPolicy->CallGetSize(pCall, &cbNeeded);
                    if(hr1 != S_OK)
                        break;
                }
                else
                {
                    cbNeeded = 0;
                }
                if(cbNeeded > cbBuf)
                {
                    pvBuf = _alloca(cbNeeded);
                    cbBuf = cbNeeded;
                }
                hr1 = pEntry->pPolicy->CallFillBuffer(pCall, pvBuf, &cbNeeded);
                break;

            case CONTEXTEVENT_ENTER:
                hr1 = pEntry->pPolicy->Enter(pCall);
                break;

            case CONTEXTEVENT_ENTERWITHBUFFER:
                hr1 = pEntry->pPolicy->EnterWithBuffer(pCall, NULL, 0);
                break;

            case CONTEXTEVENT_LEAVE:
            case CONTEXTEVENT_LEAVEEXCEPTION:
                hr1 = pEntry->pPolicy->Leave(pCall);
                break;

            case CONTEXTEVENT_LEAVEFILLBUFFER:
            case CONTEXTEVENT_LEAVEEXCEPTIONFILLBUFFER:
                if (fCallGetSize)
                {
                    hr1 = pEntry->pPolicy->LeaveGetSize(pCall, &cbNeeded);
                    if(hr1 != S_OK)
                        break;
                }
                else
                {
                    cbNeeded = 0;
                }
                if(cbNeeded > cbBuf)
                {
                    pvBuf = _alloca(cbNeeded);
                    cbBuf = cbNeeded;
                }
                hr1 = pEntry->pPolicy->LeaveFillBuffer(pCall, pvBuf, &cbNeeded);
                break;

            case CONTEXTEVENT_RETURN:
            case CONTEXTEVENT_RETURNEXCEPTION:
                hr1 = pEntry->pPolicy->Return(pCall);
                break;

            case CONTEXTEVENT_RETURNWITHBUFFER:
            case CONTEXTEVENT_RETURNEXCEPTIONWITHBUFFER:
                hr1 = pEntry->pPolicy->ReturnWithBuffer(pCall, NULL, 0);
                break;

#ifdef CONTEXT_ASYNCSUPPORT
            case CONTEXTEVENT_BEGINCALL:
                hr1 = pEntry->pPolicyAsync->BeginCall(pCall);
                break;

            case CONTEXTEVENT_BEGINCALLFILLBUFFER:
                hr1 = pEntry->pPolicyAsync->BeginCallGetSize(pCall, &cbNeeded);
                if(hr1 != S_OK)
                    break;
                if(cbNeeded > cbBuf)
                {
                    pvBuf = _alloca(cbNeeded);
                    cbBuf = cbNeeded;
                }
                hr1 = pEntry->pPolicyAsync->BeginCallFillBuffer(pCall, pvBuf, &cbNeeded);
                break;

            case CONTEXTEVENT_BEGINENTER:
                hr1 = pEntry->pPolicyAsync->BeginEnter(pCall);
                break;

            case CONTEXTEVENT_BEGINENTERWITHBUFFER:
                hr1 = pEntry->pPolicyAsync->BeginEnterWithBuffer(pCall, NULL, 0);
                break;

            case CONTEXTEVENT_BEGINLEAVE:
                hr1 = pEntry->pPolicyAsync->BeginLeave(pCall);
                break;

            case CONTEXTEVENT_BEGINRETURN:
                hr1 = pEntry->pPolicyAsync->BeginReturn(pCall);
                break;

            case CONTEXTEVENT_FINISHCALL:
                hr1 = pEntry->pPolicyAsync->FinishCall(pCall);
                break;

            case CONTEXTEVENT_FINISHENTER:
                hr1 = pEntry->pPolicyAsync->FinishEnter(pCall);
                break;

            case CONTEXTEVENT_FINISHLEAVE:
                hr1 = pEntry->pPolicyAsync->FinishLeave(pCall);
                break;

            case CONTEXTEVENT_FINISHLEAVEFILLBUFFER:
                hr1 = pEntry->pPolicyAsync->FinishLeaveGetSize(pCall, &cbNeeded);
                if(hr1 != S_OK)
                    break;
                if(cbNeeded > cbBuf)
                {
                    pvBuf = _alloca(cbNeeded);
                    cbBuf = cbNeeded;
                }
                hr1 = pEntry->pPolicyAsync->FinishLeaveFillBuffer(pCall, pvBuf, &cbNeeded);
                break;

            case CONTEXTEVENT_FINISHRETURN:
                hr1 = pEntry->pPolicyAsync->FinishReturn(pCall);
                break;

            case CONTEXTEVENT_FINISHRETURNWITHBUFFER:
                hr1 = pEntry->pPolicyAsync->FinishReturnWithBuffer(pCall, NULL, 0);
                break;
#endif
            case CONTEXTEVENT_NONE:
                hr1 = S_OK;
                break;

            default:
                Win4Assert(!"Improper CtxEvent being delivered");
                hr1 = E_FAIL;
            }

            // Check the return code
            if(FAILED(hr1))
            {
                ContextDebugOut((DEB_WARN,
                                 "Delivery of event %d for policyID:%I "
                                 "failed with hr:0x%x\n",
                                 ctxCurrent, &pEntry->policyID, hr1));
                hr1 = pCall->Nullify(hr1);
                Win4Assert(hr1 == S_OK);
            }

            // Get the next policy
            if(fForward)
                pEntry = pEntry->pNext;
            else
                pEntry = pEntry->pPrev;
        }
    }

    // Obtain the call status
    hrRet = pCall->GetHResult();

    ASSERT_LOCK_NOT_HELD(gComLock);
    ContextDebugOut((DEB_POLICYSET, "CPolicySet::DeliverEvents this:%x hr:0x%x\n",
                     this, hrRet));
    return(hrRet);
}


//---------------------------------------------------------------------------
//
//  Method:     CPSHashTable::HashNode
//
//  Synopsis:   Computes the hash value for a given node
//
//  History:    20-Dec-97   Gopalk      Created
//
//---------------------------------------------------------------------------
DWORD CPSHashTable::HashNode(SHashChain *pNode)
{
    CPolicySet *pPS = CPolicySet::HashChainToPolicySet(pNode);

	Win4Assert(pPS && "Attempting to hash NULL PolicySet!");
	if (pPS)
	{
		return Hash(((CPolicySet *) pPS)->GetClientContext(),
					((CPolicySet *) pPS)->GetServerContext());
	}

	return 0;
}


//---------------------------------------------------------------------------
//
//  Method:     CPSHashTable::Compare
//
//  Synopsis:   Compares a node and a key.
//
//---------------------------------------------------------------------------
BOOL CPSHashTable::Compare(const void *pv, SHashChain *pNode, DWORD dwHash)
{
    CPolicySet *pPS = CPolicySet::HashChainToPolicySet(pNode);
    Contexts *pContexts = (Contexts *) pv;

	Win4Assert (pPS && "Comparing NULL PolicySet!");
	if (pPS)
	{
		if((pPS->GetClientContext() == pContexts->pClientCtx) &&
		   (pPS->GetServerContext() == pContexts->pServerCtx))
			return(TRUE);
	}

    return(FALSE);
}


//---------------------------------------------------------------------------
//
//  Method:     CPSTable::Initialize
//
//  Synopsis:   Initailizes the policy set table
//
//  History:    20-Dec-97   Gopalk      Created
//
//---------------------------------------------------------------------------
void CPSTable::Initialize()
{
    ContextDebugOut((DEB_POLICYTBL, "CPSTable::Initialize\n"));
    ASSERT_LOCK_NOT_HELD(gComLock);
    gPSRWLock.AssertNotHeld();

    // Avoid double init
    if(!s_fInitialized)
    {
        // Initialize Policy Sets
        CPolicySet::Initialize();
        
        // Acquire writer lock
        gPSRWLock.AcquireWriterLock();

        // Initialize hash table
        if(!s_fInitialized)
        {
            s_PSHashTbl.Initialize(s_PSBuckets, &gPSRWLock);
            s_fInitialized = TRUE;
        }

        // Release hash table
        gPSRWLock.ReleaseWriterLock();
    }

    gPSRWLock.AssertNotHeld();
    ASSERT_LOCK_NOT_HELD(gComLock);
    return;
}


//---------------------------------------------------------------------------
//
//  Function:   CleanupPolicySets
//
//  Synopsis:   Should never get called
//
//  History:    20-Dec-97   Gopalk      Created
//
//---------------------------------------------------------------------------
void CleanupPolicySets(SHashChain *pNode)
{
    Win4Assert(!"Leaking contexts");

    if (pNode)
    {
        CPolicySet *pPS = CPolicySet::HashChainToPolicySet(pNode);
        pPS->Release();
    }

    return;
}


//---------------------------------------------------------------------------
//
//  Method:     CPSTable::ThreadCleanup
//
//  Synopsis:   Cleanup the policy set table for the current apartment
//
//  History:    20-Dec-97   Gopalk      Created
//
//---------------------------------------------------------------------------
void CPSTable::ThreadCleanup(BOOL fApartmentUninit)
{
    ContextDebugOut((DEB_POLICYTBL, "CPSTable::ThreadCleanup\n"));
    ASSERT_LOCK_NOT_HELD(gComLock);
    gPSRWLock.AssertNotHeld();

    COleTls Tls;

    Win4Assert(Tls->pCtxCall == NULL);
    Win4Assert(Tls->pCurrentCtx == Tls->pNativeCtx);

    // Destory the policy sets associated with the native context
//    CPolicySet::DestroyPSCache(Tls->pNativeCtx);
    
    // Release the native context of this thread
    Tls->pNativeCtx->InternalRelease();
    Tls->pNativeCtx = NULL;
    Tls->pCurrentCtx = NULL;
    Tls->ContextId = (ULONGLONG)-1;

    gPSRWLock.AssertNotHeld();
    ASSERT_LOCK_NOT_HELD(gComLock);
    return;
}


//---------------------------------------------------------------------------
//
//  Method:     CPSTable::Cleanup
//
//  Synopsis:   Cleanup the policy set table
//
//  History:    20-Dec-97   Gopalk      Created
//
//---------------------------------------------------------------------------
void CPSTable::Cleanup()
{
    ContextDebugOut((DEB_POLICYTBL, "CPSTable::Cleanup\n"));
    gPSRWLock.AssertNotHeld();

    // Check if the table was initialized
    if(s_fInitialized)
    {
        // Acquire writer lock
        gPSRWLock.AcquireWriterLock();

        // Cleanup hash table
        s_PSHashTbl.Cleanup(CleanupPolicySets);

        // State is no longer initialized
        s_fInitialized = FALSE;

        // Release writer lock
        gPSRWLock.ReleaseWriterLock();

        // Cleanup Policy sets
        CPolicySet::Cleanup();
    }

    gPSRWLock.AssertNotHeld();
    return;
}


//---------------------------------------------------------------------------
//
//  Method:     CPSTable::Add
//
//  Synopsis:   Addes a given policy set into the table
//
//  History:    20-Dec-97   Gopalk      Created
//
//---------------------------------------------------------------------------
void CPSTable::Add(CPolicySet *pPS)
{
    ContextDebugOut((DEB_POLICYTBL, "CPSTable::Add pPolicySet:%x\n", pPS));
    ASSERT_LOCK_NOT_HELD(gComLock);
    gPSRWLock.AssertWriterLockHeld();

    // Sanity check
    Win4Assert(pPS);

    // Mark the policy set as belonging to the current apartment
    pPS->SetApartmentID(GetCurrentApartmentId());

    // Obtain contexts
    CObjectContext *pClientCtx = pPS->GetClientContext();
    CObjectContext *pServerCtx = pPS->GetServerContext();
    Win4Assert(pClientCtx || pServerCtx);

    // Obtain Hash value
    DWORD dwHash = s_PSHashTbl.Hash(pClientCtx, pServerCtx);

    // Add Policy Set to the Hash table
    s_PSHashTbl.Add(dwHash, pPS);

    // The table takes a reference.
    pPS->AddRef();

    gPSRWLock.AssertWriterLockHeld();
    ASSERT_LOCK_NOT_HELD(gComLock);
    ContextDebugOut((DEB_POLICYTBL, "CPSTable::Add returning 0x%x\n", pPS));
}


//---------------------------------------------------------------------------
//
//  Method:     CPSTable::Remove
//
//  Synopsis:   Removes the policy set from the policy set table
//
//  History:    20-Dec-97   Gopalk      Created
//
//---------------------------------------------------------------------------
void CPSTable::Remove(CPolicySet *pPS)
{
    ContextDebugOut((DEB_POLICYTBL, "CPSTable::Remove pPolicySet:%x\n", pPS));
    ASSERT_LOCK_NOT_HELD(gComLock);
    gPSRWLock.AssertWriterLockHeld();

    // Sanity check
    Win4Assert(pPS);

#if DBG==1
    // In debug builds, ensure that the node is present in the table
    CPolicySet *pExistingPS;
    DWORD dwHash;

    // Obtain Hash value
    dwHash = s_PSHashTbl.Hash(pPS->GetClientContext(),
                              pPS->GetServerContext());
    pExistingPS = s_PSHashTbl.Lookup(dwHash,
                                     pPS->GetClientContext(),
                                     pPS->GetServerContext());
    Win4Assert(pExistingPS == pPS);
#endif

    s_PSHashTbl.Remove(pPS);

    // The table has a reference.
    pPS->Release();

    gPSRWLock.AssertWriterLockHeld();
    ASSERT_LOCK_NOT_HELD(gComLock);
    ContextDebugOut((DEB_POLICYTBL, "CPSTable::Remove returning\n"));
    return;
}


//---------------------------------------------------------------------------
//
//  Method:     CPSTable::Lookup
//
//  Synopsis:   Looksup the policy set for the given contexts
//
//  History:    20-Dec-97   Gopalk      Created
//
//---------------------------------------------------------------------------
HRESULT CPSTable::Lookup(CObjectContext *pClientCtx, CObjectContext *pServerCtx,
                         CPolicySet **ppPS)
{
    ContextDebugOut((DEB_POLICYTBL, "CPSTable::Lookup pCliCtx:%x pSrvCtx:%x\n",
                    pClientCtx, pServerCtx));
    ASSERT_LOCK_NOT_HELD(gComLock);
    gPSRWLock.AssertReaderOrWriterLockHeld();

    DWORD dwHash;
    HRESULT hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);

    // Sanity check
    Win4Assert(pClientCtx || pServerCtx);

    // Obtain Hash value
    dwHash = s_PSHashTbl.Hash(pClientCtx, pServerCtx);

    // Lookup the policy set between the contexts
    CPolicySet *pPS = s_PSHashTbl.Lookup(dwHash, pClientCtx, pServerCtx);
    if(pPS)
    {
        pPS->AddRef();
        hr = S_OK;
    }

    // Initialize the return value
    *ppPS = pPS;
    Win4Assert(FAILED(hr) == (*ppPS == NULL));

    gPSRWLock.AssertReaderOrWriterLockHeld();
    ASSERT_LOCK_NOT_HELD(gComLock);
    ContextDebugOut((DEB_POLICYTBL, "CPSTable::Lookup returning hr:0x%x, ppPS:0x%x, *ppPS:0x%x\n",
                     hr, ppPS, *ppPS));
    return(hr);
}

//+-------------------------------------------------------------------
//
//  Function:   CoGetObjectContext            public
//
//  Synopsis:   Obtains the current object context
//
//  History:    15-Jan-98   Gopalk      Created
//              12-Nov-98   Johnstra    Modified to hand out user
//                                      context instead of real one.
//
//+-------------------------------------------------------------------
STDAPI CoGetObjectContext(REFIID riid, void **ppv)
{
    ContextDebugOut((DEB_POLICYSET, "CoGetObjectContext\n"));
    ASSERT_LOCK_NOT_HELD(gComLock);

    HRESULT hr;

    // Initialize
    *ppv = NULL;

    // Initalize channel
    hr = InitChannelIfNecessary();
    if(SUCCEEDED(hr))
    {
        CObjectContext *pContext = GetCurrentContext();
        if(pContext)
        {
            // We are returning a reference to a context to user code,
            // so we want them to have a user reference instead of
            // an internal ref, hence QI instead of InternalQI.
            hr = pContext->QueryInterface(riid, ppv);
        }
        else
            hr = CO_E_NOTINITIALIZED;
    }

    ASSERT_LOCK_NOT_HELD(gComLock);
    ContextDebugOut((DEB_POLICYSET, "CoGetObjectContext pv:%x hr:0x%x\n", *ppv, hr));
    return(hr);
}


//+-------------------------------------------------------------------
//
//  Function:   CoSetObjectContext            public
//
//  Synopsis:   Sets the current object context
//
//  History:    04-Oct-99   Gopalk      Created
//
//+-------------------------------------------------------------------
STDAPI CoSetObjectContext(IUnknown *pUnk)
{
    ContextDebugOut((DEB_POLICYSET, "CoSetObjectContext\n"));
    ASSERT_LOCK_NOT_HELD(gComLock);

    // Ensure that the supplied punk is really a context object
    CObjectContext *pContext;
    HRESULT hr = pUnk->QueryInterface(IID_IStdObjectContext, (void **) &pContext);
    if(SUCCEEDED(hr))
    {
        COleTls Tls(hr);
        if(SUCCEEDED(hr))
        {
            Tls->pCurrentCtx = pContext;
            Tls->ContextId = pContext->GetId();
        }
    }

    return(hr);
}


//+-------------------------------------------------------------------
//
//  Function:   DeterminePolicySet      Private
//
//  Synopsis:   Determines the policy set for the given contexts
//
//  History:    15-Jan-98   Gopalk      Created
//
//+-------------------------------------------------------------------
HRESULT DeterminePolicySet(CObjectContext *pClientCtx,
                           CObjectContext *pServerCtx,
                           DWORD dwFlags, CPolicySet **ppCPS)
{
    ContextDebugOut((DEB_POLICYSET, "DeterminePolicySet pCliCtx:%x pSrvCtx:%x\n",
                    pClientCtx, pServerCtx));
    ASSERT_LOCK_NOT_HELD(gComLock);
    gPSRWLock.AssertNotHeld();

    HRESULT hr = S_OK;
    void *pvCltNode, *pvSvrNode;

    // Sanity check
    Win4Assert(pClientCtx || pServerCtx);
    if (!(pClientCtx || pServerCtx))
        return E_UNEXPECTED;

    // Initialize cookies used for enumerating properties in contexts
    // Initialization might fail if object context has not been frozen
    if(pClientCtx)
    {
        hr = pClientCtx->Reset(&pvCltNode);
        Win4Assert(SUCCEEDED(hr));
    }
    if(pServerCtx)
    {
        hr = pServerCtx->Reset(&pvSvrNode);
        Win4Assert(SUCCEEDED(hr));
    }

    // Create a new policy set
    CPolicySet *pCPS = new CPolicySet(dwFlags);
    if(pCPS)
    {
        HRESULT hr2;
        ContextProperty *pCtxProp;
        IPolicyMaker *pPM;

        // Check for server context
        if(pServerCtx && !pServerCtx->IsEmpty())
        {
            // Set policy set to server side
            pCPS->SetServerSide();

            // Enumerate PolicyMakers in the server context
            do
            {
                pCtxProp = pServerCtx->GetNextProperty(&pvSvrNode);
                if(pCtxProp == NULL)
                    break;

                // QI the property object for IPolicyMaker interface
                if(pCtxProp->pUnk)
                {
                    hr2 = pCtxProp->pUnk->QueryInterface(IID_IPolicyMaker,
                                                        (void **) &pPM);
                    if(SUCCEEDED(hr2))
                    {
                        if(pCPS->IsProxySide())
                            hr = pPM->AddEnvoyPoliciesToSet(pCPS, pClientCtx, pServerCtx);
                        else
                            hr = pPM->AddServerPoliciesToSet(pCPS, pClientCtx, pServerCtx);
                        pPM->Release();
                        if(FAILED(hr))
                            break;
                    }
                }
            } while(TRUE);

            // Reset policy set side
            pCPS->ResetServerSide();
        }

        // Check for client context
        if(SUCCEEDED(hr) && pClientCtx && !pClientCtx->IsEmpty())
        {
            // Set policy set to client side
            pCPS->SetClientSide();

            // Enumerate PolicyMakers in the client context
            do
            {
                pCtxProp = pClientCtx->GetNextProperty(&pvCltNode);
                if(pCtxProp == NULL)
                    break;

                // QI the property object for IPolicyMaker interface
                if(pCtxProp->pUnk)
                {
                    hr2 = pCtxProp->pUnk->QueryInterface(IID_IPolicyMaker,
                                                         (void **) &pPM);
                    if(SUCCEEDED(hr2))
                    {
                        hr = pPM->AddClientPoliciesToSet(pCPS, pClientCtx, pServerCtx);
                        pPM->Release();
                        if(FAILED(hr))
                            break;
                    }
                }
            } while(TRUE);

            // Reset policy set side
            pCPS->ResetClientSide();
        }

        // Update the policy set
        if(SUCCEEDED(hr))
        {
            pCPS->Freeze();
            pCPS->DeliverAddRefPolicyEvents();
        }
        else
        {
            pCPS->Release();
            pCPS = NULL;
        }
    }
    else
        hr = E_OUTOFMEMORY;

    // Sanity check
    Win4Assert((SUCCEEDED(hr)) == (pCPS!=NULL));
    *ppCPS = pCPS;

#if DBG==1
    if(FAILED(hr))
    {
        ContextDebugOut((DEB_ERROR,
                         "DeterminePolicySet failed to create a policy set "
                         "for contexts 0x%x-->0x%x with hr:0x%x\n",
                         pClientCtx, pServerCtx, hr));
    }
#endif

    gPSRWLock.AssertNotHeld();
    ASSERT_LOCK_NOT_HELD(gComLock);
    ContextDebugOut((DEB_POLICYSET,
                     "DeterminePolicySet returning 0x%x, pCPS=0x%x\n", hr, pCPS));
    return(hr);
}

//+-------------------------------------------------------------------
//
//  Function:   CPolicySet::SetClientContext    Private
//
//  Synopsis:   Chains the policy set to the list of policy sets
//              maintained by the client context. This method can
//              only be called once during the lifetime of the
//              policy set
//
//  History:    02-Dec-98   Gopalk      Created
//
//+-------------------------------------------------------------------
void CPolicySet::SetClientContext(CObjectContext *pClientCtx)
{
    ContextDebugOut((DEB_POLICYSET,
                     "CPolicySet::SetClientContext this:%x ClientCtx:%x\n",
                     this, pClientCtx));

    // Sanity checks
    gPSRWLock.AssertWriterLockHeld();
    Win4Assert(!_pClientCtx);

    // Save the pointer to client context
    _pClientCtx = pClientCtx;

    // Chain the policy set into the list maintained by the
    // client context
    SPSCache *pPSCache = pClientCtx->GetPSCache();
    _PSCache.clientPSChain.pNext = pPSCache->clientPSChain.pNext;
    _PSCache.clientPSChain.pPrev = &(pPSCache->clientPSChain);
    _PSCache.clientPSChain.pNext->pPrev = &_PSCache.clientPSChain;
    pPSCache->clientPSChain.pNext = &(_PSCache.clientPSChain);
}


//+-------------------------------------------------------------------
//
//  Function:   CPolicySet::SetServerContext    Private
//
//  Synopsis:   Chains the policy set to the list of policy sets
//              maintained by the server context. This method can
//              only be called once during the lifetime of the
//              policy set
//
//  History:    02-Dec-98   Gopalk      Created
//
//+-------------------------------------------------------------------
void CPolicySet::SetServerContext(CObjectContext *pServerCtx)
{
    ContextDebugOut((DEB_POLICYSET,
                     "CPolicySet::SetServerContext this:%x pServerCtx:%x\n",
                     this, pServerCtx));

    // Sanity checks
    gPSRWLock.AssertWriterLockHeld();
    Win4Assert(!_pServerCtx);

    // Save the pointer to server context
    // This is a weak reference.
    _pServerCtx = pServerCtx;

    // Chain the policy set into the list maintained by the
    // server context
    SPSCache *pPSCache = pServerCtx->GetPSCache();
    _PSCache.serverPSChain.pNext = pPSCache->serverPSChain.pNext;
    _PSCache.serverPSChain.pPrev = &(pPSCache->serverPSChain);
    _PSCache.serverPSChain.pNext->pPrev = &_PSCache.serverPSChain;
    pPSCache->serverPSChain.pNext = &(_PSCache.serverPSChain);
}


//+-------------------------------------------------------------------
//
//  Function:   CPolicySet::RemoveFromCacheLists    Private
//
//  Synopsis:   Removes the policy set from lists maintained by the
//              client and server contexts
//
//  History:    02-Dec-98   Gopalk      Created
//
//+-------------------------------------------------------------------
void CPolicySet::RemoveFromCacheLists()
{
    // Sanity checks
    gPSRWLock.AssertWriterLockHeld();
    Win4Assert(_pServerCtx || _pClientCtx);

    // Remove from the list maintained by the client context
    if(_pClientCtx)
    {
        _pClientCtx = NULL;
        _PSCache.clientPSChain.pNext->pPrev = _PSCache.clientPSChain.pPrev;
        _PSCache.clientPSChain.pPrev->pNext = _PSCache.clientPSChain.pNext;
#if DBG==1
        _PSCache.clientPSChain.pNext = NULL;
        _PSCache.clientPSChain.pPrev = NULL;
#endif
    }

    // Remove from the list maintained by the server context
    if(_pServerCtx)
    {
        _PSCache.serverPSChain.pNext->pPrev = _PSCache.serverPSChain.pPrev;
        _PSCache.serverPSChain.pPrev->pNext = _PSCache.serverPSChain.pNext;
#if DBG==1
        _PSCache.serverPSChain.pNext = NULL;
        _PSCache.serverPSChain.pPrev = NULL;
#endif

        _pServerCtx = NULL;
    }
}


//+-------------------------------------------------------------------
//
//  Function:   CPolicySet::PrepareForDestruction    Private
//
//  Synopsis:   Prepares the policy sets for destruction
//
//  History:    02-Dec-98   Gopalk      Created
//
//+-------------------------------------------------------------------
inline void CPolicySet::PrepareForDestruction()
{
    // Sanity checks
    Win4Assert(_pClientCtx || _pServerCtx);
    gPSRWLock.AssertWriterLockHeld();

    // Remove the policy set from the policy set table
    gPSTable.Remove(this);
    RemoveFromCacheLists();
}

//+-------------------------------------------------------------------
//
//  Function:   CPolicySet::PreparePSCache    Private
//
//  Synopsis:   Prepares all the policy sets from lists maintained by the
//              client and server contexts
//
//  History:    02-Dec-98   Gopalk      Created
//
//+-------------------------------------------------------------------
void CPolicySet::DestroyPSCache(CObjectContext *pCtx)
{
    ContextDebugOut((DEB_POLICYSET,
                     "CPolicySet::PreparePSCache pCtx:%x\n", pCtx));

    // Sanity check
    gPSRWLock.AssertNotHeld();

    const int CleanupPSListSize = 25;
    int iNumPS;
    CPolicySet *pPS;
    SPSCache *pPSCache = pCtx->GetPSCache();

    CPolicySet **pCleanupPSList = (CPolicySet **) _alloca(sizeof(CPolicySet *)
                                                          * CleanupPSListSize);

    while((pPSCache->clientPSChain.pNext != &(pPSCache->clientPSChain)) ||
          (pPSCache->serverPSChain.pNext != &(pPSCache->serverPSChain)))
    {
        // Initialize
        iNumPS = 0;

        // Acquire writer lock
        gPSRWLock.AcquireWriterLock();

        // Cleanup policy sets in the client list
        while((iNumPS < CleanupPSListSize) &&
              (pPSCache->clientPSChain.pNext != &(pPSCache->clientPSChain)))
        {
            pPS = ClientChainToPolicySet(pPSCache->clientPSChain.pNext);
            Win4Assert(pCtx == pPS->GetClientContext());

            // Add the policy set and addref it.  This is so that the
            // we actually release the reference held by the table 
            // outside of the policy set lock.  This is important because
            // it may be the last reference.
            pCleanupPSList[iNumPS] = pPS;
            pPS->AddRef();

            pPS->PrepareForDestruction();            
            iNumPS++;
        }

        // Cleanup policy sets in the server list
        while((iNumPS < CleanupPSListSize) &&
              (pPSCache->serverPSChain.pNext != &(pPSCache->serverPSChain)))
        {
            pPS = ServerChainToPolicySet(pPSCache->serverPSChain.pNext);
            Win4Assert(pCtx == pPS->GetServerContext());

            // Add the policy set and addref it.  This is so that the
            // we actually release the reference held by the table 
            // outside of the policy set lock.  This is important because
            // it may be the last reference.
            pCleanupPSList[iNumPS] = pPS;
            pPS->AddRef();

            pPS->PrepareForDestruction();
            iNumPS++;
        }

        // Release writer lock
        gPSRWLock.ReleaseWriterLock();

        for (int i = 0; i < iNumPS; i++)
        {
            // Actually release the policy sets.
            pCleanupPSList[i]->Release();
            pCleanupPSList[i] = NULL;
        }
    }

    gPSRWLock.AssertNotHeld();
    return;
}


//+-------------------------------------------------------------------
//
//  Function:   PrivSetServerHResult    Private
//
//  Synopsis:   Sets the server's HRESULT for a given call.
//
//  History:    29-Mar-99   Johnstra      Created
//
//+-------------------------------------------------------------------
HRESULT PrivSetServerHResult(
    RPCOLEMESSAGE *pMsg,
    VOID          *pReserved,
    HRESULT        appsHr
    )
{
    CAsyncCall asyncCall(0);
    void* vptrAsync = *(void**) &asyncCall;
    CClientCall clientCall(0);
    void* vptrClient = *(void**) &clientCall;

    void* vptrCall = *(void**)pMsg->reserved1;
    
    // Obtain the context call object
    CCtxCall *pCtxCall;
    if (vptrCall == vptrAsync || vptrCall == vptrClient)
        pCtxCall = ((CMessageCall *) pMsg->reserved1)->GetServerCtxCall();
    else
        pCtxCall = (CCtxCall *) pMsg->reserved1;
        
    // Set the server's HRESULT in the call object.
    if (pCtxCall)
        pCtxCall->_hrServer = appsHr;
    
    return S_OK;
}

//+-------------------------------------------------------------------
//
//  Function:   PrivSetServerHRESULTInTLS    Private
//
//  Synopsis:   Sets the server's HRESULT for a given call.  Retrieves
//              the call object from TLS
//
//  History:    21-Feb-01   JSimmons     Created
//
//+-------------------------------------------------------------------
HRESULT PrivSetServerHRESULTInTLS(
    VOID* pvReserved,
    HRESULT appsHR
    )
{
    HRESULT hr;

    if (pvReserved != NULL)
        return E_INVALIDARG;

    // There's no point in remembering the hresult if it is S_OK
    if (S_OK == appsHR)
        return S_OK;
    
    // Note: i'm using the version of the COleTls constructor that 
    // doesn't fault in the TLS data.  If it isn't already there, too bad.
    COleTls tls;
    
    // Check to make sure TLS is there.
    if (tls.IsNULL())
        return CO_E_NOTINITIALIZED;
    
    // Check for call object in tls
    if (!tls->pCallInfo)
        return RPC_E_CALL_COMPLETE;

    // Retrieve the server ctx call obj
    CCtxCall* pCtxCall = tls->pCallInfo->GetServerCtxCall();

    // Dbl-check that one too
    if (!pCtxCall)
        return E_UNEXPECTED;

    // Done
    pCtxCall->_hrServer = appsHR;
    
    return S_OK;
}

//+-------------------------------------------------------------------
//
//  Function:   CNullWalker::QueryInterface
//
//  Synopsis:   Standard QueryInterface Implementation
//
//  History:    03-Jan-01   JohnDoty      Created
//
//+-------------------------------------------------------------------
STDMETHODIMP CNullWalker::QueryInterface(REFIID riid, void **ppv)
{
    HRESULT hr = S_OK;;

    if ((riid == IID_IUnknown) || 
        (riid == IID_ICallFrameWalker))
    {
        *ppv = this;
    }
    else
    {
        hr = E_NOINTERFACE;
        *ppv = NULL;
    }
    
    if (SUCCEEDED(hr))
        AddRef();

    return hr;
}

//+-------------------------------------------------------------------
//
//  Function:   CNullWalker::OnWalkInterface
//
//  Synopsis:   ICallFrameWalker::OnWalkInterface.  Simply NULLs the
//              offending pointer so that nobody Releases it.
//
//  History:    03-Jan-01   JohnDoty      Created
//
//+-------------------------------------------------------------------
STDMETHODIMP CNullWalker::OnWalkInterface(REFIID riid, void **ppv,
                                          BOOL fIn, BOOL fOut)
{
    if (ppv)
        *ppv = NULL;
    return S_OK;    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\com\dcomrem\refcache.cxx ===
//+-------------------------------------------------------------------
//
//  File:       refcache.cxx
//
//  Contents:   class implementing a cache for client side reference
//              counts process wide.
//
//  Classes:    CRefCache
//
//  History:    31-Jul-97 MattSmit  Created
//              10-Nov-98 Rickhi    Merged code from Resolver
//
//--------------------------------------------------------------------
#include    <ole2int.h>
#include    <resolver.hxx>      // gResolver
#include    <refcache.hxx>      // class def's
#include    <smemscm.hxx>

// critical section guarding channel initialization
extern COleStaticMutexSem  gChannelInitLock;


////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
//                                                                        //
//                           CRefCache Implementation                     //
//                                                                        //
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////


//+-------------------------------------------------------------------------
//
// Member:    Constructor
//
// Synopsis:  Initialize members
//
// History:   07-24-97  MattSmit   Created
//
//+-------------------------------------------------------------------------
CRefCache::CRefCache() :
    _cRefs(1),
    _cStrongItfs(0),
    _cWeakItfs(0),
    _cTableStrong(0),
    _cIRCs(0),
    _pIRCList(NULL)
{
    RefCacheDebugOut((DEB_TRACE, "CRefCache created: this = 0x%x\n", this));
}

//+-------------------------------------------------------------------------
//
// Member:    Destructor
//
// Synopsis:  delete list nodes
//
// History:   07-24-97  MattSmit   Created
//
//+-------------------------------------------------------------------------
CRefCache::~CRefCache()
{
    ASSERT_LOCK_HELD(gIPIDLock);
    RefCacheDebugOut((DEB_TRACE, "CRefCache destroyed: this = 0x%x\n", this));
    AssertValid();
    Win4Assert(!_cRefs);
    Win4Assert(!_cStrongItfs);
    Win4Assert(!_cWeakItfs);

    // cleanup the list of IRCEntries chained off this guy.
    while (_pIRCList)
    {
        Win4Assert(!_pIRCList->cStrongUsage &&
                   !_pIRCList->cWeakUsage &&
                   !_pIRCList->cStrongRefs &&
                   !_pIRCList->cWeakRefs);

        IRCEntry *pTemp = _pIRCList;
        _pIRCList = _pIRCList->pNext;
        delete pTemp;
    }
}

//+-------------------------------------------------------------------------
//
// Member:    AssertValid
//
// Synopsis:  assert internal integrity
//
// History:   07-24-97  MattSmit   Created
//
//+-------------------------------------------------------------------------
#if DBG==1
void CRefCache::AssertValid()
{
    ASSERT_LOCK_HELD(gIPIDLock);

    ULONG cStrongCheck = 0;
    ULONG cWeakCheck   = 0;
    ULONG cCountCheck  = 0;

    IRCEntry *pIRCEntry = _pIRCList;
    while (pIRCEntry)
    {
        Win4Assert(_cStrongItfs || _cTableStrong || !pIRCEntry->cStrongRefs);
        Win4Assert(_cWeakItfs || !pIRCEntry->cWeakRefs);

        cStrongCheck += pIRCEntry->cStrongUsage;
        cWeakCheck   += pIRCEntry->cWeakUsage;
        cCountCheck++;
        pIRCEntry     = pIRCEntry->pNext;
    }

    // The sum of the counts in the IRCs should equal
    // the total in the CRefCache object
    Win4Assert(_cIRCs == cCountCheck);
    Win4Assert(cStrongCheck == _cStrongItfs);
    Win4Assert(cWeakCheck == _cWeakItfs);
}
#endif

//+-------------------------------------------------------------------
//
//  Member:     CRefCache::TrackIPIDEntry
//
//  Synopsis:   Inform the cache to keep track of this proxy
//
//  History:    25-Jul-97  MattSmit Created
//
//--------------------------------------------------------------------
void CRefCache::TrackIPIDEntry(IPIDEntry *pIPIDEntry)
{
    RefCacheDebugOut((DEB_TRACE,
      "CRefCache::TrackIPIDEntry this:%x pIPIDEntry:0x%x\n",this,pIPIDEntry));
    ASSERT_LOCK_HELD(gIPIDLock);
    AssertValid();

    // make this routine idempotent since it could get
    // called on another thread when this one yields to
    // call RemoteAddref
    if (!pIPIDEntry->pIRCEntry)
    {
        // find or make an IRCEntry
        IRCEntry *pIRCEntry = ClientFindIRCEntry(pIPIDEntry->ipid);
        if (pIRCEntry)
        {
            pIPIDEntry->pIRCEntry = pIRCEntry;

            // mark IPIDEntry as holding a strong ref in the IRCEntry
            // and increment usage counts.
            Win4Assert(!pIPIDEntry->cWeakRefs);
            pIPIDEntry->dwFlags |= IPIDF_STRONGREFCACHE;
            ++ pIRCEntry->cStrongUsage;
            ++ _cStrongItfs;
        }

        AssertValid();
    }
}

//+-------------------------------------------------------------------
//
//  Member:     CRefCache::ClientFindIRCEntry
//
//  Synopsis:   Returns the IRCEntry for the given IPID
//
//  History:    30-Mar-97   Rickhi      Created.
//
//--------------------------------------------------------------------
IRCEntry *CRefCache::ClientFindIRCEntry(REFIPID ripid)
{
    RefCacheDebugOut((DEB_TRACE,
       "CRefCache::ClientFindIRCEntry this:%x ipid:%I\n", this, &ripid));
    ASSERT_LOCK_HELD(gIPIDLock);
    AssertValid();

    // look for a matching IPID in the IRC list
    IRCEntry *pIRCEntry = _pIRCList;
    while (pIRCEntry)
    {
        if (InlineIsEqualGUID(pIRCEntry->ipid, ripid))
        {
            // found the entry, break
            break;
        }
        pIRCEntry =  pIRCEntry->pNext;
    }

    if (pIRCEntry == NULL)
    {
        // no record found, try to allocate one for this IPID
        pIRCEntry = new IRCEntry;
        if (pIRCEntry)
        {
            // initialize it and chain it to the SOIDReg.
            pIRCEntry->ipid         = ripid;
            pIRCEntry->cStrongRefs  = 0;
            pIRCEntry->cWeakRefs    = 0;
            pIRCEntry->cPrivateRefs = 0;
            pIRCEntry->cStrongUsage = 0;
            pIRCEntry->cWeakUsage   = 0;
            pIRCEntry->pRefCache    = this;

            pIRCEntry->pNext        = _pIRCList;
            _pIRCList               = pIRCEntry;
            _cIRCs                 += 1;
        }
    }

    AssertValid();
    RefCacheDebugOut((DEB_TRACE,
            "CRefCache::ClientFindIRCEntry pIRCEntry: %x\n", pIRCEntry));
    return pIRCEntry;
}

//+-------------------------------------------------------------------
//
//  Member:     CRefCache::ReleaseIPIDEntry
//
//  Synopsis:   Stop tracking a proxy in the reference cache
//
//  History:    25-Jul-97  MattSmit Created
//
//--------------------------------------------------------------------
void  CRefCache::ReleaseIPIDEntry(IPIDEntry            *pIPIDEntry,
                                  REMINTERFACEREF     **ppRifRef,
                                  USHORT               *pcRifRef)
{
    RefCacheDebugOut((DEB_TRACE, "CRefCache::ReleaseIPIDEntry pIPIDEntry:0x%x"
               "ipid:%I ppRifRef = OX%x, pcRifRef = %d\n",
               pIPIDEntry, &pIPIDEntry->ipid, ppRifRef, pcRifRef));
    ASSERT_LOCK_HELD(gIPIDLock);
    Win4Assert(!(pIPIDEntry->dwFlags & IPIDF_NOPING));
    AssertValid();

    // Use references for convenience
    REMINTERFACEREF    *&pRifRef = *ppRifRef;
    USHORT              &cRifRef = *pcRifRef;

    if (!pIPIDEntry->pIRCEntry)
    {
        // no caching, so just release the references
        RefCacheDebugOut((DEB_TRACE,
            "CRefCache::ReleaseIPIDEntry no caching .. releasing reference\n"));

        if (pIPIDEntry->cStrongRefs > 0)
        {
            if (pRifRef)
            {
                pRifRef->cPublicRefs     = pIPIDEntry->cStrongRefs;
                pRifRef->cPrivateRefs    = 0;
                pRifRef->ipid            = pIPIDEntry->ipid;
                pRifRef++;
                cRifRef++;
            }
            pIPIDEntry->cStrongRefs  = 0;
        }
        else if (pIPIDEntry->cWeakRefs > 0)
        {
            if (pRifRef)
            {
                pRifRef->cPublicRefs     = pIPIDEntry->cWeakRefs;
                pRifRef->cPrivateRefs    = 0;
                pRifRef->ipid            = pIPIDEntry->ipid;
                pRifRef->ipid.Data1     |= IPIDFLAG_WEAKREF;
                pRifRef++;
                cRifRef++;
            }
            pIPIDEntry->cWeakRefs    = 0;
        }
    }
    else
    {
        IRCEntry *pIRCEntry = pIPIDEntry->pIRCEntry;

        if (pIPIDEntry->dwFlags & IPIDF_WEAKREFCACHE)
        {
            // give the weak references to the IRCEntry
            Win4Assert(!pIPIDEntry->cPrivateRefs);
            pIRCEntry->cWeakRefs  += pIPIDEntry->cWeakRefs;
            pIPIDEntry->cWeakRefs  = 0;

            // count one less weak reference user
            pIPIDEntry->dwFlags &= ~IPIDF_WEAKREFCACHE;
            --pIRCEntry->cWeakUsage;
            if (--_cWeakItfs == 0)
            {
                // this is the last weak proxy -- cleanup
                CleanupWeak(&pRifRef, &cRifRef);
            }
        }
        else
        {
            Win4Assert(pIPIDEntry->dwFlags & IPIDF_STRONGREFCACHE);

            // give the strong references to the IRCEntry
            pIRCEntry->cStrongRefs  += pIPIDEntry->cStrongRefs;
            pIPIDEntry->cStrongRefs  = 0;

            // count one less strong reference user
            pIPIDEntry->dwFlags &= ~IPIDF_STRONGREFCACHE;
            --pIRCEntry->cStrongUsage;
            if (--_cStrongItfs == 0 && _cTableStrong == 0)
            {
                // this is the last strong proxy -- cleanup
                CleanupStrong(&pRifRef, &cRifRef);
            }
        }

        // don't reference the IRCEntry from this client any more
        pIPIDEntry->pIRCEntry = NULL;
    }

    // we can't cache private references w/o keeping track of the
    // principle of the apartment they came from.  Too much work,
    // so we'll just release them now.
    if (pIPIDEntry->cPrivateRefs > 0)
    {
        if (pRifRef)
        {
            pRifRef->cPrivateRefs    = pIPIDEntry->cPrivateRefs;
            pRifRef->cPublicRefs     = 0;
            pRifRef->ipid            = pIPIDEntry->ipid;
            pRifRef++;
            cRifRef++;
        }
        pIPIDEntry->cPrivateRefs = 0;
    }

    AssertValid();
}

//+-------------------------------------------------------------------
//
//  Member:     CRefCache::GetSharedRefs
//
//  Synopsis:   Gets any available shared references for an interface IPID
//
//  History:    30-Mar-97   Rickhi      Created.
//
//--------------------------------------------------------------------
HRESULT CRefCache::GetSharedRefs(IPIDEntry *pIPIDEntry, ULONG cStrong)
{
    RefCacheDebugOut((DEB_TRACE,
       "CRefCache::GetSharedRefs this:%x pIPIDEntry:%x cStrong = %d\n",
       this, pIPIDEntry, cStrong));
    ASSERT_LOCK_HELD(gIPIDLock);
    AssertValid();

    HRESULT hr = E_FAIL;

    IRCEntry *pIRCEntry = pIPIDEntry->pIRCEntry;
    if (pIRCEntry)
    {
        if (pIRCEntry->cStrongRefs >= cStrong)
        {
            // got all the references we need right here
            pIRCEntry->cStrongRefs -= cStrong;
            hr = S_OK;
        }
    }

    AssertValid();
    RefCacheDebugOut((DEB_TRACE, "CRefCache::GetSharedRefs hr:%x\n", hr));
    return hr;
}

//+-------------------------------------------------------------------
//
//  Member:     CRefCache::GiveUpRefs
//
//  Synopsis:   Takes extra references and stores them in the cache
//
//  History:    01-Aug-97   MattSmit     Created.
//
//--------------------------------------------------------------------
void CRefCache::GiveUpRefs(IPIDEntry *pIPIDEntry)
{
    RefCacheDebugOut((DEB_TRACE,"CRefCache::GiveUpRefs this:%x pIPIDEntry:%x\n",
       this, pIPIDEntry));
    ASSERT_LOCK_HELD(gIPIDLock);
    AssertValid();

    IRCEntry *pIRCEntry = pIPIDEntry->pIRCEntry;
    if (pIRCEntry)
    {
        // store extra references in the cache
        if (pIPIDEntry->cStrongRefs > 0)
        {
            Win4Assert(pIPIDEntry->dwFlags & IPIDF_STRONGREFCACHE);
            pIRCEntry->cStrongRefs += pIPIDEntry->cStrongRefs;
            pIPIDEntry->cStrongRefs = 0;
        }
        else if (pIPIDEntry->cWeakRefs > 1)
        {
            Win4Assert(pIPIDEntry->dwFlags & IPIDF_WEAKREFCACHE);
            pIRCEntry->cWeakRefs += pIPIDEntry->cWeakRefs - 1;
            pIPIDEntry->cWeakRefs = 1;
        }
    }

    AssertValid();
    RefCacheDebugOut((DEB_TRACE, "leaving CRefCache::GiveUpRefs\n"));
}

//+-------------------------------------------------------------------
//
//  Member:     CRefCache::ChangeRef
//
//  Synopsis:   Changes cached references from weak to strong and vice
//              versa
//
//  Parameters: [pIPIDEntry] - ptr to IPIDEntry
//              [fLock] - TRUE:  Convert Weak Refs to Strong Refs
//                        FALSE: Convert Strong Refs to Weak Refs
//              [ppRifRefChange] - references to change
//              [pcRifRefChange] - count of references to change
//              [ppRifRefRelease] - cached references to release
//              [pcRifRefRelease] - count of cached refs to change
//
//  History:    25-Jul-97  MattSmit Created
//
//--------------------------------------------------------------------
void CRefCache::ChangeRef(IPIDEntry           *pIPIDEntry,
                          BOOL                 fLock,
                          REMINTERFACEREF    **ppRifRefChange,
                          USHORT              *pcRifRefChange,
                          REMINTERFACEREF    **ppRifRefRelease,
                          USHORT              *pcRifRefRelease)

{
    RefCacheDebugOut((DEB_TRACE, "CRefCache::ChangeRef pIPIDEntry:0x%x "
               "ppRifRefChange = 0x%x, pcRifRefChange = 0x%x "
               "ppRifRefRelease = OX%X, pcRifRefRelease = %d\n",
               pIPIDEntry, ppRifRefChange, pcRifRefChange,
               ppRifRefRelease, pcRifRefRelease));
    Win4Assert(ppRifRefChange  && pcRifRefChange &&
               ppRifRefRelease && pcRifRefRelease);
    ASSERT_LOCK_HELD(gIPIDLock);
    AssertValid();

    IRCEntry *pIRCEntry = pIPIDEntry->pIRCEntry;
    if (!pIRCEntry)
    {
        RefCacheDebugOut((DEB_TRACE, "CRefCache::ChangeRef No pIRCEntry ... Leaving.\n"));
        return;
    }
    Win4Assert(pIRCEntry->pRefCache == this);
    Win4Assert(pIPIDEntry->cPrivateRefs == 0);

    // use references
    REMINTERFACEREF    *&pRifRefChange = *ppRifRefChange;
    USHORT              &cRifRefChange = *pcRifRefChange;

    if (!fLock && (pIPIDEntry->dwFlags & IPIDF_STRONGREFCACHE))
    {
        Win4Assert(pIRCEntry->cStrongUsage > 0);
        if (-- pIRCEntry->cStrongUsage == 0 && pIRCEntry->cStrongRefs &&
            _cTableStrong == 0)
        {
            // No more strong objects using this IPID
            // Need to change all the refs in the cache so the
            // object will get a call on IExternalConnection.
            pRifRefChange->cPublicRefs  = pIRCEntry->cStrongRefs;
            pRifRefChange->cPrivateRefs = 0;
            pRifRefChange->ipid         = pIPIDEntry->ipid;
            ++ cRifRefChange;
            ++ pRifRefChange;
            pIRCEntry->cWeakRefs       += pIRCEntry->cStrongRefs;
            pIRCEntry->cStrongRefs      = 0;
        }

        // adjust the usage counts to count one more weak and one less
        // strong reference, and mark the IPIDEntry appropriately.
        ++ pIRCEntry->cWeakUsage;
        ++ _cWeakItfs;
        pIPIDEntry->dwFlags |= IPIDF_WEAKREFCACHE;
        pIPIDEntry->dwFlags &= ~IPIDF_STRONGREFCACHE;
        if (-- _cStrongItfs == 0 && _cTableStrong == 0)
        {
            // changing this reference to weak released the last strong
            // count on this identity.  Relase all the strong counts
            // the cache is holding so IExternalConnection wil be called
            CleanupStrong(ppRifRefRelease, pcRifRefRelease);
        }
    }
    else if (fLock && (pIPIDEntry->dwFlags & IPIDF_WEAKREFCACHE))
    {
        // weak -> strong
        Win4Assert(pIRCEntry->cWeakUsage > 0);
        if ((-- pIRCEntry->cWeakUsage == 0) && (pIRCEntry->cWeakRefs))
        {
            // we don't really need to do this, because the
            // cached weak references would get cleaned up when
            // the last strong count goes, but since we are
            // already making the trip, we'll convert these
            // references also so we can use them if we need them
            pRifRefChange->cPublicRefs   = pIRCEntry->cWeakRefs;
            pRifRefChange->cPrivateRefs  = 0;
            pRifRefChange->ipid          = pIPIDEntry->ipid;
            ++ cRifRefChange;
            ++ pRifRefChange;
            pIRCEntry->cStrongRefs      += pIRCEntry->cWeakRefs;
            pIRCEntry->cWeakRefs         = 0;
        }

        // adjust the usage counts to count one more strong and one less
        // weak reference, and mark the IPIDEntry appropriately.
        ++ pIRCEntry->cStrongUsage;
        ++ _cStrongItfs;
        pIPIDEntry->dwFlags |= IPIDF_STRONGREFCACHE;
        pIPIDEntry->dwFlags &= ~IPIDF_WEAKREFCACHE;
        -- _cWeakItfs;
        // No need to call CleanupWeak because it does nothing if
        // there are still strong objects which there are because
        // we just converted one
    }

    AssertValid();
}

//+-------------------------------------------------------------------
//
//  Member:     CRefCache::CleanupStrong
//
//  Synopsis:   Called when the number of strong interfaces goes to
//              zero.  Releases all strong references in the cache.
//              Also releases weak references if there are no weak
//              interfaces left.
//
//  History:    25-Jul-97  MattSmit Created
//
//--------------------------------------------------------------------
void CRefCache::CleanupStrong(REMINTERFACEREF **ppRifRef, USHORT *pcRifRef)
{
    RefCacheDebugOut((DEB_TRACE, "CRefCache::CleanupStrong "
               "this = 0x%x, ppRifRef = OX%x, pcRifRef = %d\n",
               this, ppRifRef, pcRifRef));
    ASSERT_LOCK_HELD(gIPIDLock);

    // use references -- more conveinient
    REMINTERFACEREF    *&pRifRef = *ppRifRef;
    USHORT              &cRifRef = *pcRifRef;

    IRCEntry *pIRCEntry = _pIRCList;

    while (pIRCEntry)
    {
        if (pIRCEntry->cStrongRefs)
        {
            if (pRifRef)
            {            
                pRifRef->cPublicRefs    = pIRCEntry->cStrongRefs;
                pRifRef->cPrivateRefs   = 0;
                pRifRef->ipid           = pIRCEntry->ipid;
                pRifRef++;
                cRifRef++;
            }
            pIRCEntry->cStrongRefs  = 0;
        }
        // clean up any weak reference if there are no more
        // weak proxies.
        if (!_cWeakItfs && (pIRCEntry->cWeakRefs))
        {
            if (pRifRef)
            {
                pRifRef->cPublicRefs    = pIRCEntry->cWeakRefs;
                pRifRef->cPrivateRefs   = 0;
                pRifRef->ipid           = pIRCEntry->ipid;
                pRifRef->ipid.Data1    |= IPIDFLAG_WEAKREF;
                pRifRef++;
                cRifRef++;
            }
            pIRCEntry->cWeakRefs    = 0;
        }

        pIRCEntry = pIRCEntry->pNext;
    }

    AssertValid();
}

//+-------------------------------------------------------------------
//
//  Member:     CRefCache::CleanupWeak
//
//  Synopsis:   Called when the number of weak interfaces goes to
//              zero.  If there are still strong interfaces, this
//              function does nothing and lets the CleanupStrong
//              cleanup the weak counts as well.  If there are no
//              strong proxies left, the weak references are released.
//
//  History:    25-Jul-97  MattSmit Created
//
//--------------------------------------------------------------------
void CRefCache::CleanupWeak(REMINTERFACEREF **ppRifRef, USHORT *pcRifRef)
{
    RefCacheDebugOut((DEB_TRACE, "CRefCache::CleanupWeak "
               "this = 0x%x, ppRifRef = OX%X, pcRifRef = 0x%x\n",
               this, ppRifRef, pcRifRef));
    ASSERT_LOCK_HELD(gIPIDLock);

    if (_cStrongItfs == 0)
    {
        // use references -- more conveinient
        REMINTERFACEREF    *&pRifRef  = *ppRifRef;
        USHORT              &cRifRef  = *pcRifRef;
        IRCEntry           *pIRCEntry = _pIRCList;

        while (pIRCEntry)
        {
            RefCacheDebugOut((DEB_TRACE, "CRefCache::CleanupWeak "
                              "pIRCEntry:0x%x, ipid:%I, cWeakRefs:%d\n",
                              pIRCEntry, &pIRCEntry->ipid, pIRCEntry->cWeakRefs));
            if (pIRCEntry->cWeakRefs)
            {
                if (pRifRef)
                {
                    pRifRef->cPublicRefs    = pIRCEntry->cWeakRefs;
                    pRifRef->cPrivateRefs   = 0;
                    pRifRef->ipid           = pIRCEntry->ipid;
                    pRifRef->ipid.Data1    |= IPIDFLAG_WEAKREF;
                    pRifRef++;
                    cRifRef++;
                }
                pIRCEntry->cWeakRefs    = 0;
            }
            pIRCEntry = pIRCEntry->pNext;
        }
    }

    AssertValid();
}


//+-------------------------------------------------------------------
//
//  Member:     CRefCache::IncTableStrongCnt
//
//  Synopsis:   Called when a client marshals a proxy TABLESTRONG.
//              This keeps the client process pinging the server
//              object even in the absence of a proxy.
//
//  History:    01-Feb-99   Rickhi  Created
//
//+-------------------------------------------------------------------
ULONG CRefCache::IncTableStrongCnt()
{
    RefCacheDebugOut((DEB_TRACE,
        "CRefCache::IncTableStrongCnt this:%x _cTableStrong:%x\n",
        this, _cTableStrong+1));

    ASSERT_LOCK_HELD(gIPIDLock);
    ULONG cRefs = (++_cTableStrong);
    if (cRefs == 1)
    {
        // first TABLESTRONG reference, ensure we keep pinging the object.
        gROIDTbl.IncOIDRefCnt(&_soidReg);
    }

    return cRefs;
}

//+-------------------------------------------------------------------
//
//  Member:     CRefCache::DecTableStrongCnt
//
//  Synopsis:   Called when a client RMD's a proxy TABLESTRONG objref.
//              This stops the client process pinging the server
//              in the absence of an instantiated proxy.
//
//  History:    01-Feb-99   Rickhi  Created
//
//+-------------------------------------------------------------------
ULONG CRefCache::DecTableStrongCnt(BOOL fMarshaled,
                                   REMINTERFACEREF **ppRifRef,
                                   USHORT *pcRifRef)
{
    RefCacheDebugOut((DEB_TRACE,
        "CRefCache::DecTableStrongCnt this:%x _cTableStrong:%x\n",
        this, _cTableStrong-1));
    ASSERT_LOCK_HELD(gIPIDLock);

    // don't allow decrement if the count is already 0. Can happen if a
    // client does CRMD on a TABLESTRONG packet that the client did not
    // marshal TABLESTRONG (ie. they got the packet from the server).
    if (_cTableStrong == 0)
        return 0;

    ULONG cRefs = (--_cTableStrong);
    if (cRefs == 0)
    {
        // last TABLESTRONG reference, count one less usage and,
        // if it is the last usage, stop pinging.
        gROIDTbl.ClientDeRegisterOIDFromPingServer(this, fMarshaled);

        if (_cStrongItfs == 0)
        {
            // no more strong or tablestrong users, remote release the
            // remaining strong references.
            CleanupStrong(ppRifRef, pcRifRef);
        }
    }

    return cRefs;
}


////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
//                                                                        //
//                           CROIDTable Implementation                    //
//                                                                        //
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////

SHashChain OIDBuckets[C_OIDBUCKETS] = {   {&OIDBuckets[0],  &OIDBuckets[0]},
                                          {&OIDBuckets[1],  &OIDBuckets[1]},
                                          {&OIDBuckets[2],  &OIDBuckets[2]},
                                          {&OIDBuckets[3],  &OIDBuckets[3]},
                                          {&OIDBuckets[4],  &OIDBuckets[4]},
                                          {&OIDBuckets[5],  &OIDBuckets[5]},
                                          {&OIDBuckets[6],  &OIDBuckets[6]},
                                          {&OIDBuckets[7],  &OIDBuckets[7]},
                                          {&OIDBuckets[8],  &OIDBuckets[8]},
                                          {&OIDBuckets[9],  &OIDBuckets[9]},
                                          {&OIDBuckets[10], &OIDBuckets[10]},
                                          {&OIDBuckets[11], &OIDBuckets[11]},
                                          {&OIDBuckets[12], &OIDBuckets[12]},
                                          {&OIDBuckets[13], &OIDBuckets[13]},
                                          {&OIDBuckets[14], &OIDBuckets[14]},
                                          {&OIDBuckets[15], &OIDBuckets[15]},
                                          {&OIDBuckets[16], &OIDBuckets[16]},
                                          {&OIDBuckets[17], &OIDBuckets[17]},
                                          {&OIDBuckets[18], &OIDBuckets[18]},
                                          {&OIDBuckets[19], &OIDBuckets[19]},
                                          {&OIDBuckets[20], &OIDBuckets[20]},
                                          {&OIDBuckets[21], &OIDBuckets[21]},
                                          {&OIDBuckets[22], &OIDBuckets[22]}
};


// the global ROID table
CROIDTable  gROIDTbl;

// static data in the ROID table class
#ifndef SHRMEM_OBJEX
// List of OIDs to register/ping/revoke with the resolver used
// for lazy/batch client-side OID processing.
SOIDRegistration CROIDTable::_ClientOIDRegList;
ULONG     CROIDTable::_cOidsToAdd    = 0; // # OIDs to add next call
ULONG     CROIDTable::_cOidsToRemove = 0; // # OIDs to remove next call
DWORD     CROIDTable::_dwSleepPeriod = 0; // worker thread sleep period
BOOL      CROIDTable::_fWorker = FALSE;   // worker thread not present
#endif // SHRMEM_OBJEX
CUUIDHashTable CROIDTable::_ClientRegisteredOIDs;


//+-------------------------------------------------------------------
//
//  Method:     CROIDTable::Initialize, public
//
//  Synopsis:   called to initialize the registered OID table.
//
//  History:    03-Nov-98   Rickhi      Created
//
//+-------------------------------------------------------------------
void CROIDTable::Initialize()
{
    LOCK(gIPIDLock);
    _ClientRegisteredOIDs.Initialize(OIDBuckets, &gIPIDLock);

#ifndef SHRMEM_OBJEX
    // empty the OIDRegList. Any SOIDRegistration records have already
    // been deleted by the gClientRegisteredOIDs list cleanup code.
    _ClientOIDRegList.pPrevList = &_ClientOIDRegList;
    _ClientOIDRegList.pNextList = &_ClientOIDRegList;
    _cOidsToAdd       = 0;
    _cOidsToRemove    = 0;
#endif // SHRMEM_OBJEX

    UNLOCK(gIPIDLock);
}

//+-------------------------------------------------------------------
//
//  Function:   CleanupRegOIDs, public
//
//  Synopsis:   called to delete each node of the registered OID list.
//
//+-------------------------------------------------------------------
void CleanupRegOIDs(SHashChain *pNode)
{
    SOIDRegistration *pOIDReg = (SOIDRegistration *) pNode;
    CRefCache *pRefCache = pOIDReg->pRefCache;
    pOIDReg->pRefCache = NULL;
    ULONG cRefs = pRefCache->DecRefCnt();
    Win4Assert(cRefs == 0);
}

//+-------------------------------------------------------------------
//
//  Method:     CROIDTable::Cleanup, public
//
//  Synopsis:   called to cleanup the registered OID table.
//
//  History:    03-Nov-98   Rickhi      Created
//
//+-------------------------------------------------------------------
void CROIDTable::Cleanup()
{
    LOCK(gIPIDLock);
    _ClientRegisteredOIDs.Cleanup(CleanupRegOIDs);

#ifndef SHRMEM_OBJEX
    // empty the OIDRegList. Any SOIDRegistration records have already
    // been deleted by the gClientRegisteredOIDs list cleanup code.
    _ClientOIDRegList.pPrevList = &_ClientOIDRegList;
    _ClientOIDRegList.pNextList = &_ClientOIDRegList;
    _cOidsToAdd       = 0;
    _cOidsToRemove    = 0;
#endif // SHRMEM_OBJEX

    UNLOCK(gIPIDLock);
}

//+-------------------------------------------------------------------
//
//  Member:     CROIDTable::ClientRegisterOIDWithPingServer
//
//  Synopsis:   registers an OID with the Ping Server if it has
//              not already been registered.
//
//  History:    30-Oct-95   Rickhi      Created.
//
//--------------------------------------------------------------------
HRESULT CROIDTable::ClientRegisterOIDWithPingServer(REFMOID moid,
                                                    REFOXID roxid,
                                                    REFMID  rmid,
                                                    CRefCache **ppRefCache)
{
    ComDebOut((DEB_OXID, "ClientRegisterOIDWithPingServer moid:%I\n", &moid));
    ASSERT_LOCK_HELD(gIPIDLock);
    AssertValid();

    HRESULT hr  = S_OK;
    *ppRefCache = NULL;

    // see if this OID already has a client-side registration
    // record created by another apartment in this process.

    DWORD iHash;
    SOIDRegistration *pOIDReg = LookupSOID(moid, &iHash);

    if (pOIDReg == NULL)
    {
        // not yet registered with resolver, create a new entry and
        // add it to the hash table and to the List of items to register
        // with the Resolver.

#ifndef SHRMEM_OBJEX
        // make sure we have a worker thread ready to do the register
        // at some point in the future.
        hr = EnsureWorkerThread();
#else // SHRMEM_OBJEX
        // we are using shared memory
        // just make sure we have a connection
        hr = gResolver.GetConnection();
#endif // SHRMEM_OBJEX

        if (SUCCEEDED(hr))
        {
            hr = E_OUTOFMEMORY;
            CRefCache *pRefCache = new CRefCache();
            if (pRefCache)
            {
                pOIDReg = pRefCache->GetSOIDPtr();

                pOIDReg->cRefs      = 1;
                pOIDReg->pRefCache  = pRefCache;
                pOIDReg->mid        = rmid;
                pOIDReg->oxid       = roxid;

                // add a refcounted copy of it's pointer to the hash table
                pRefCache->IncRefCnt();
                _ClientRegisteredOIDs.Add(iHash, moid, (SUUIDHashNode *)pOIDReg);

                // return the RefCache ptr to the caller (caller takes ownership
                // of the initial refcnt)
                *ppRefCache = pRefCache;
#ifndef SHRMEM_OBJEX
                // using a worker thread so add it to the list to be registered
                // when the worker thread runs.
                pOIDReg->flags = ROIDF_REGISTER;
                AddToList(pOIDReg, &_ClientOIDRegList);
                _cOidsToAdd++;
                hr = S_OK;
#else // SHRMEM_OBJEX
                // we are using shared memory so add it to the shared memory
                // list immediately.
                pOIDReg->flags = 0;
                OID oid;
                OIDFromMOID(moid, &oid);
                hr = ClientAddOID(_ph, moid, roxid, rmid);
#endif // SHRMEM_OBJEX
            }
        }
    }
    else
    {
        // already have a record for this OID, count one more
        // reference

        // return the RefCache ptr to the caller, AddRef'd.
        *ppRefCache = pOIDReg->pRefCache;
        Win4Assert(*ppRefCache);
        (*ppRefCache)->IncRefCnt();

        // inc the refcnt
        IncOIDRefCnt(pOIDReg);
    }

    AssertValid();
    ASSERT_LOCK_HELD(gIPIDLock);
    ComDebOut((DEB_OXID,
            "ClientRegisterOIDWithPingServer pOIDReg:%x pRefCache:%x hr:%x\n",
            pOIDReg, *ppRefCache, hr));
    return hr;
}


//+-------------------------------------------------------------------
//
//  Member:     CROIDTable::ClientDeRegisterOIDWithPingServer
//
//  Synopsis:   de-registers an OID that has previously been registered
//              with the Ping Server
//
//  History:    30-Oct-95   Rickhi      Created.
//
//--------------------------------------------------------------------
HRESULT CROIDTable::ClientDeRegisterOIDFromPingServer(CRefCache *pRefCache,
                                                      BOOL fMarshaled)
{
    ComDebOut((DEB_OXID,"ClientDeRegisterOIDWithPingServer pRefCache:%x\n",
              pRefCache));
    ASSERT_LOCK_HELD(gIPIDLock);
    AssertValid();

    SOIDRegistration *pOIDReg = pRefCache->GetSOIDPtr();
    Win4Assert(pOIDReg->pRefCache == pRefCache);
    Win4Assert((pOIDReg->flags == ROIDF_REGISTER) ||
               (pOIDReg->flags == (ROIDF_REGISTER | ROIDF_PING)) ||
               (pOIDReg->flags == 0));

#if DBG==1
    // find the OID in the hash table. it better still be there!
    DWORD iHash;
    SOIDRegistration *pOIDReg2 = LookupSOID(pOIDReg->Node.key, &iHash);
    Win4Assert(pOIDReg2 != NULL);
    Win4Assert(pOIDReg2 == pOIDReg);
#endif // DBG

    if (-- pOIDReg->cRefs == 0)
    {
        // this was the last registration of the OID in this process.

#ifndef SHRMEM_OBJEX
        // this never happens with shared memory
        if (pOIDReg->flags & ROIDF_REGISTER)
        {
            // still on the Register list, have not yet told the Ping Server
            // about this OID so dont have to do anything unless it was
            // client-side marshaled.

            if (fMarshaled || pOIDReg->flags & ROIDF_PING)
            {
                // object was marshaled by the client. Still need to tell
                // the Ping Server to ping the OID then forget about it.

                pOIDReg->flags = ROIDF_PING;
                _cOidsToRemove++;

                // make sure we have a worker thread ready to do the deregister
                // at some point in the future.  Not much we can do about an
                // error here. If transient, then a thread will most likely
                // be created later.
                EnsureWorkerThread();
            }
            else
            {
                // dont need this record any longer. remove from chain
                // and delete the record.

                RemoveFromList(pOIDReg);
                _cOidsToAdd--;
                _ClientRegisteredOIDs.Remove((SHashChain *)pOIDReg);
                pRefCache->DecRefCnt(); // release ref that hash table owned
                pOIDReg->pRefCache = NULL;
            }
        }
        else
        {
            // must already be registered with the resolver. now need to
            // deregister it so put it on the Registration list for delete.

            pOIDReg->flags = ROIDF_DEREGISTER;
            AddToList(pOIDReg, &_ClientOIDRegList);
            _cOidsToRemove++;

            // make sure we have a worker thread ready to do the deregister
            // at some point in the future.  Not much we can do about an
            // error here. If transient, then a thread will most likely
            // be created later.
            EnsureWorkerThread();
        }

#else // SHRMEM_OBJEX
        // make sure we have a connection --
        // Do we ever try to deregister something we didn't register?

        gResolver.GetConnection();

        OID Oid;
        OIDFromMOID(pOIDReg->Node.key, &Oid);
        MID Mid = pOIDReg->mid;

        ClientDropOID(_ph,Oid,Mid);
#endif // SHRMEM_OBJEX

    }

    AssertValid();
    ASSERT_LOCK_HELD(gIPIDLock);
    ComDebOut((DEB_OXID,"ClientDeRegisterOIDWithPingServer pOIDReg:%x hr:%x\n",
              pOIDReg, S_OK));
    return S_OK;
}

//+-------------------------------------------------------------------
//
//  Member:     CROIDTable::IncOIDRefCnt
//
//  Synopsis:   Increments the RefCnt on an SOIDRegistration and determines
//              what, if any, effect this has on the state that needs to
//              be updated with the Ping Server.
//
//  History:    30-Oct-95   Rickhi      Created.
//
//--------------------------------------------------------------------
void CROIDTable::IncOIDRefCnt(SOIDRegistration *pOIDReg)
{
    RefCacheDebugOut((DEB_TRACE,
        "CROIDTable::IncOIDRefCnt pOIDReg:%x cRefs:%x\n",
        pOIDReg, pOIDReg->cRefs+1));

    // inc the refcnt
    pOIDReg->cRefs++;
    if (pOIDReg->cRefs == 1)
    {
#ifndef SHRMEM_OBJEX
        // re-using an entry that had a count of zero, so it must have
        // been going to be deregistered or pinged.
        Win4Assert((pOIDReg->flags == ROIDF_PING) ||
                   (pOIDReg->flags == ROIDF_DEREGISTER));

        _cOidsToRemove--;

        if (pOIDReg->flags & ROIDF_PING)
        {
            // was only going to be pinged, now must be added.
            pOIDReg->flags |= ROIDF_REGISTER;
        }
        else
        {
            // was going to be unregistered, already registered so does
            // not need to be on the registration list anymmore

            Win4Assert(pOIDReg->flags & ROIDF_DEREGISTER);
            pOIDReg->flags = 0;
            RemoveFromList(pOIDReg);
        }
#endif // SHRMEM_OBJEX
    }
}


#ifndef SHRMEM_OBJEX
//+-------------------------------------------------------------------
//
//  Member:     CROIDTable::ClientBulkUpdateOIDWithPingServer
//
//  Synopsis:   registers/deregisters/pings any OIDs waiting to be
//              sent to the ping server.
//
//  History:    30-Oct-95   Rickhi      Created.
//              13-Mar-01   Jsimmons    Modified to send soid unpins also
//
//--------------------------------------------------------------------
HRESULT CROIDTable::ClientBulkUpdateOIDWithPingServer(ULONG cOxidsToRemove,
                                                      ULONG cSOidsToUnpin)
{
    ComDebOut((DEB_OXID, "ClientBulkUpdateOIDWithPingServer\n"));
    ASSERT_LOCK_HELD(gIPIDLock);
    ASSERT_HELD_CONTINUOS_START(gIPIDLock);
    AssertValid();

    // Copy the counters so we can reset them before we make the call.
    // Allocate space for the Add, Status, and Remove lists to send to the
    // ping server, and remember the start address so we can free the
    // memory later. Compute the address of the other lists within the
    // one allocated memory block.

    ULONG cOidsToAdd     = _cOidsToAdd;
    ULONG cOidsToRemove  = _cOidsToRemove;
    Win4Assert((_cOidsToAdd + _cOidsToRemove + cOxidsToRemove + cSOidsToUnpin) != 0);

    // We're allocating five arrays of stuff in a single allocation.
    //
    // OXID_OID_PAIR pOidsToAdd[ cOidsToAdd ];
    // OID_MID_PAIR  pOidsToRemove[ cOidsToRemove ];
    // OID           pServerOidsToUnpin[ cSOidsToUnpin ];
    // OXID_REF      pOxidsToRemove[ cOxidsToRemove ];
    // ULONG         pStatusOfAdds[ cOidsToAdd ];
    //
    // pStatusOfAdds[] must appear at the end, otherwise subsequent arrays
    // will be unaligned in the event of an odd-numbered cOidsToAdd.

    ULONG cBytesToAlloc = (cOidsToAdd * sizeof(OXID_OID_PAIR))
                        + (cOidsToRemove * sizeof(OID_MID_PAIR))
                        + (cSOidsToUnpin * sizeof(OID))
                        + (cOxidsToRemove * sizeof(OXID_REF))
                        + (cOidsToAdd * sizeof(ULONG));


    OXID_OID_PAIR *pOidsToAdd;
    PVOID pvBytes;

    if (cBytesToAlloc < 0x7000)
    {
        pvBytes = NULL;
        pOidsToAdd = (OXID_OID_PAIR *)alloca(cBytesToAlloc);
    }
    else
    {
        pvBytes = PrivMemAlloc(cBytesToAlloc);
        pOidsToAdd = (OXID_OID_PAIR *) pvBytes;
    }

    if (pOidsToAdd == NULL)
    {
        // cant allocate memory. Leave the registration lists alone for
        // now, this may be a transient problem and we can handle the
        // registration later (unless of course the problem persists and
        // our object is run down!).

        UNLOCK(gIPIDLock);
        ASSERT_LOCK_NOT_HELD(gIPIDLock);
        ComDebOut((DEB_ERROR, "ClientBulkUpdate OOM\n"));
        return E_OUTOFMEMORY;
    }

    OXID_OID_PAIR *pOidsToAddStart    = pOidsToAdd;
    OID_MID_PAIR  *pOidsToRemove      = (OID_MID_PAIR *)(&pOidsToAddStart[cOidsToAdd]);
    OID           *pSOidsToUnpin      = (OID*)&(pOidsToRemove[cOidsToRemove]);
    OXID_REF      *pOxidsToRemove     = (OXID_REF *) (&pSOidsToUnpin[cSOidsToUnpin]);
    LONG          *pStatusOfAdds      = (LONG *) (&pOxidsToRemove[cOxidsToRemove]);


    // Track the number of entries processed.
    DWORD cOidsAdded      = 0;
    DWORD cOidsRemoved    = 0;

    // loop through each OID registration records in the list filling in
    // the Add and Remove lists. Pinged OIDs are placed in both lists.

    while (_ClientOIDRegList.pNextList != &_ClientOIDRegList &&
           cOidsAdded + cOidsRemoved < cOidsToAdd + cOidsToRemove)
    {
        // get the entry and remove it from the registration list
        SOIDRegistration *pOIDReg = _ClientOIDRegList.pNextList;
        RemoveFromList(pOIDReg);

        // reset the state flags before we begin
        DWORD dwFlags = pOIDReg->flags;
        pOIDReg->flags = 0;

        if (dwFlags & (ROIDF_REGISTER | ROIDF_PING))
        {
            // register the OID with the ping server
            pOidsToAdd->mid  = pOIDReg->mid;
            pOidsToAdd->oxid = pOIDReg->oxid;
            OIDFromMOID  (pOIDReg->Node.key, &pOidsToAdd->oid);
            ComDebOut((DEB_OXID, "\tadd    moid:%I\n", &pOIDReg->Node.key));

            pOidsToAdd++;
            cOidsAdded++;
        }

        if (dwFlags == ROIDF_DEREGISTER || dwFlags == ROIDF_PING)
        {
            // ensure we have not exceeded the count
            Win4Assert(cOidsRemoved != cOidsToRemove);

            // deregister the OID with the ping server
            // Node.key is the OID+MID so extract each part
            pOidsToRemove->mid = pOIDReg->mid;
            OIDFromMOID(pOIDReg->Node.key, &pOidsToRemove->oid);
            ComDebOut((DEB_OXID, "\tremove moid:%I\n", &pOIDReg->Node.key));

            pOidsToRemove++;
            cOidsRemoved++;

            // dont need the entry any more since there are no more
            // users of it.  remove from hash table and release the
            // reference the hash table owned.
            _ClientRegisteredOIDs.Remove((SHashChain *)pOIDReg);
            pOIDReg->pRefCache->DecRefCnt();
        }
    }

    // make sure we got all the entries and that our counters work correctly.
    _cOidsToAdd    -= cOidsAdded;
    _cOidsToRemove -= cOidsRemoved;

    Win4Assert(_cOidsToAdd == 0);
    Win4Assert(_cOidsToRemove == 0);
    AssertValid();

    ASSERT_HELD_CONTINUOS_FINISH(gIPIDLock);
    UNLOCK(gIPIDLock);
    ASSERT_LOCK_NOT_HELD(gIPIDLock);

    // Ask the OXID table to fill in the list of OXIDs to remove.
    // Note: We need to take the gChannelInitLock since that prevents
    // other threads from accessing anything we are about to cleanup
    // in FreeExpireEntries, in particular, the COXIDTable and CIPIDTable.
    ASSERT_LOCK_NOT_HELD(gChannelInitLock);
    LOCK(gChannelInitLock);

    gOXIDTbl.GetOxidsToRemove(pOxidsToRemove, &cOxidsToRemove);

    UNLOCK(gChannelInitLock);
    ASSERT_LOCK_NOT_HELD(gChannelInitLock);
		
    // Ask the server oid table to fill in the list of server oids that
    // need to be unpinned.
    if (cSOidsToUnpin > 0)
    {
        gOIDTable.GetServerOidsToUnpin(pSOidsToUnpin, &cSOidsToUnpin);
    }

    // reset the OidsToRemove and OxidsToRemove list pointers since we mucked with
    // them above.
    pOidsToRemove = (OID_MID_PAIR *)(&pOidsToAddStart[cOidsToAdd]);

    // CODEWORK: We could tell the resolver about OIDs that have been used
    // and freed. This would reduce the working set of the resolver in cases
    // where objects are created/destroyed frequently.

    // call the ping server
    HRESULT
    hr = gResolver.BulkUpdateOIDs(cOidsToAdd,       // #oids to add
                                  pOidsToAddStart,  // ptr to oids to add
                                  pStatusOfAdds,    // status of adds
                                  cOidsToRemove,    // #oids to remove
                                  pOidsToRemove,    // ptr to oids to remove
                                  cSOidsToUnpin,    // #soids to unpin
                                  pSOidsToUnpin,    // ptr to soids to unpin
                                  cOxidsToRemove,   // #oxids to remove
                                  pOxidsToRemove);  // ptr to oxids to remove
    if (cSOidsToUnpin > 0)
    {
        // The success cases we care about here are OR_OK or OR_PARTIAL_UPDATE.
        gOIDTable.NotifyUnpinOutcome(SUCCEEDED(hr));
    }

    // CODEWORK: reset the status flags for any OIDs not successfully added
    // to the resolver.

#if DBG==1
    LOCK(gIPIDLock);
    AssertValid();
    UNLOCK(gIPIDLock);
#endif

    PrivMemFree(pvBytes);  //  NULL if stack allocated

    ASSERT_LOCK_NOT_HELD(gIPIDLock);
    ComDebOut((DEB_OXID, "ClientBulkUpdateOIDWithPingServer hr:%x\n", hr));
    return hr;
}

//+-------------------------------------------------------------------
//
//  Member:     CROIDTable::EnsureWorkerThread
//
//  Synopsis:   Make sure there is a worker thread. Create one if
//              necessary.
//
//  History:    06-Nov-95   Rickhi      Created.
//
//--------------------------------------------------------------------
HRESULT CROIDTable::EnsureWorkerThread(void)
{
    ASSERT_LOCK_HELD(gIPIDLock);
    HRESULT hr = S_OK;

    if (!_fWorker)
    {
        // no worker thread currently exists, try to create one. First, make
        // sure that we have a connection to the resolver.

        hr = gResolver.GetConnection();

        if (SUCCEEDED(hr))
        {
            // compute the sleep period for the registration worker thread
            // (which is 1/6th the ping period). The ping period may differ
            // on debug and retail builds.
            _dwSleepPeriod = BULK_UPDATE_RATE;

            hr = CacheCreateThread( WorkerThreadLoop, 0 );
            _fWorker = SUCCEEDED(hr);
            if (!_fWorker)
                ComDebOut((DEB_ERROR,"Create CROIDTable worker thread hr:%x\n",hr));
        }
    }

    ASSERT_LOCK_HELD(gIPIDLock);
    return hr;
}

//+-------------------------------------------------------------------
//
//  Member:     CROIDTable::WorkerThreadLoop
//
//  Synopsis:   Worker thread for doing lazy/bulk OID registration
//              with the ping server.
//
//  History:    06-Nov-95   Rickhi      Created.
//
//--------------------------------------------------------------------
DWORD _stdcall  CROIDTable::WorkerThreadLoop(void *param)
{
    while (TRUE)
    {
        // sleep for a while to let the OIDs batch up in the registration list
        Sleep(_dwSleepPeriod);

        ASSERT_LOCK_NOT_HELD(gIPIDLock);
        LOCK(gIPIDLock);

        // NumOxids is not protected by the gIPIDLock so save it
        // off in a local variable and pass it in as a parameter
        ULONG cOxidsToRemove = gOXIDTbl.NumOxidsToRemove();
        ULONG cServerOidsToUnpin = gOIDTable.NumServerOidsToUnpin();

        if (_cOidsToAdd == 0 && 
            _cOidsToRemove == 0 &&
            cOxidsToRemove == 0 && 
            cServerOidsToUnpin == 0)
        {
            // There is no work to do. Exit this thread. If we need to
            // register more oids later we will spin up another thread.

            _fWorker = FALSE;
            UNLOCK(gIPIDLock);
            break;
        }

        ASSERT_LOCK_HELD(gIPIDLock);
        ClientBulkUpdateOIDWithPingServer(cOxidsToRemove, cServerOidsToUnpin);
        ASSERT_LOCK_NOT_HELD(gIPIDLock);
    }

    return 0;
}

//+-------------------------------------------------------------------
//
//  Member:     CROIDTable::NotifyWorkWaiting
//
//  Synopsis:   Used by folks who are also depending on our worker 
//              thread to run.   Tries to create a worker thread. 
//
//  History:    13-Mar-01   JSimmons   Created.
//
//--------------------------------------------------------------------
void CROIDTable::NotifyWorkWaiting(void)
{
    ASSERT_LOCK_DONTCARE(gIPIDLock);
    LOCK(gIPIDLock);

    (void)EnsureWorkerThread();

    UNLOCK(gIPIDLock);
    ASSERT_LOCK_DONTCARE(gIPIDLock);

    return;
}

#endif // SHRMEM_OBJEX


#if DBG==1
//+-------------------------------------------------------------------
//
//  Member:     CROIDTable::AssertValid
//
//  Synopsis:   validates the state of this object
//
//  History:    30-Oct-95   Rickhi      Created.
//
//--------------------------------------------------------------------
void CROIDTable::AssertValid()
{
#ifndef SHRMEM_OBJEX

    ASSERT_LOCK_HELD(gIPIDLock);

    Win4Assert((_cOidsToAdd & 0xf0000000) == 0x00000000);
    Win4Assert((_cOidsToRemove & 0xf0000000) == 0x00000000);

    if (_cOidsToAdd == 0 && _cOidsToRemove == 0)
    {
        // make sure the Reg list is empty.
        Win4Assert(_ClientOIDRegList.pPrevList == &_ClientOIDRegList);
        Win4Assert(_ClientOIDRegList.pNextList == &_ClientOIDRegList);
    }
    else
    {
        // make sure we have a worker thread. we cant assert because
        // we could be OOM trying to create the thread.
        if (!_fWorker)
        {
            ComDebOut((DEB_WARN, "No CROIDTable Worked Thread\n"));
        }

        // make sure the Reg list is consistent with the counters
        ULONG cAdd = 0;
        ULONG cRemove = 0;

        SOIDRegistration *pOIDReg = _ClientOIDRegList.pNextList;
        while (pOIDReg != &_ClientOIDRegList)
        {
            // make sure the flags are valid
            Win4Assert(pOIDReg->flags == ROIDF_REGISTER   ||
                       pOIDReg->flags == ROIDF_DEREGISTER ||
                       pOIDReg->flags == ROIDF_PING       ||
                       pOIDReg->flags == (ROIDF_PING | ROIDF_REGISTER));

            if (pOIDReg->flags & (ROIDF_REGISTER | ROIDF_PING))
            {
                // OID is to be registered
                cAdd++;
            }

            if (pOIDReg->flags == ROIDF_DEREGISTER ||
                pOIDReg->flags == ROIDF_PING)
            {
                // OID is to be deregistered
                cRemove++;
            }

            pOIDReg = pOIDReg->pNextList;
        }

        Win4Assert(cAdd == _cOidsToAdd);
        Win4Assert(cRemove == _cOidsToRemove);
    }

    ASSERT_LOCK_HELD(gIPIDLock);
#endif // SHRMEM_OBJEX
}
#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\com\dcomrem\pgalloc.cxx ===
//+-----------------------------------------------------------------------
//
//  File:       pagealloc.cxx
//
//  Contents:   Special fast allocator to allocate fixed-sized entities.
//
//  Classes:    CPageAllocator
//
//  History:    02-Feb-96   Rickhi      Created
//
//  Notes:      All synchronization is the responsibility of the caller.
//
//  CODEWORK:   faster list managment
//              free empty pages
//
//-------------------------------------------------------------------------
#include    <ole2int.h>
#include    <pgalloc.hxx>       // class def'n
#include    <locks.hxx>         // LOCK/UNLOCK


// Page Table constants for Index manipulation.
// The high 16bits of the PageEntry index provides the index to the page
// where the PageEntry is located. The lower 16bits provides the index
// within the page where the PageEntry is located.

#define PAGETBL_PAGESHIFT   16
#define PAGETBL_PAGEMASK    0x0000ffff


#define FREE_PAGE_ENTRY  (0xF1EEF1EE) // FreeEntry
#define ALLOC_PAGE_ENTRY (0xa110cced) // AllocatedEntry

// critical section to guard memory allocation
const BOOL gfInterlocked64 = FALSE;

//+------------------------------------------------------------------------
//
//  Macro:      LOCK/UNLOCK_IF_NECESSARY
//
//  Synopsis:   Standin for LOCK/UNLOCK.
//
//  Notes:      This macro allows us to use the assert only when performing
//              on behalf of COM tables, and avoid it when used for shared
//              memory in the resolver which are protected by a different
//              locking mechanism.
//
//  History:    01-Nov-96   SatishT Created
//
//-------------------------------------------------------------------------
#define LOCK_IF_NECESSARY(lock);                 \
    if (lock != NULL)                           \
    {                                           \
        LOCK((*lock));                           \
    }

#define UNLOCK_IF_NECESSARY(lock);               \
    if (lock != NULL)                           \
    {                                           \
        UNLOCK((*lock));                         \
    }


//-------------------------------------------------------------------------
//
//  Function:   PushSList, public
//
//  Synopsis:   atomically pushes an entry onto a stack list
//
//  Notes:      Uses the InterlockedCompareExchange64 funcion if available
//              otherwise, uses critical section to guard state transitions.
//
//  History:    02-Oct-98   Rickhi      Created
//
//-------------------------------------------------------------------------
void PushSList(PageEntry *pListHead, PageEntry *pEntry, COleStaticMutexSem *pLock)
{
    if (gfInterlocked64)
    {
        // CODEWORK: Interlocked SList not implemented
        Win4Assert(!"This code not implemented yet");
    }
    else
    {
        LOCK_IF_NECESSARY(pLock);
        pEntry->pNext     = pListHead->pNext;
        pListHead->pNext  = pEntry;
        UNLOCK_IF_NECESSARY(pLock);
    }
}

//-------------------------------------------------------------------------
//
//  Function:   PopSList, public
//
//  Synopsis:   atomically pops an entry off a stack list
//
//  Notes:      Uses the InterlockedCompareExchange64 funcion if available
//              otherwise, uses critical section to guard state transitions.
//
//  History:    02-Oct-98   Rickhi      Created
//
//-------------------------------------------------------------------------
PageEntry *PopSList(PageEntry *pListHead, COleStaticMutexSem *pLock)
{
    PageEntry *pEntry;

    if (gfInterlocked64)
    {
        // CODEWORK: Interlocked SList not implemented
        Win4Assert(!"This code not implemented yet");
		pEntry = NULL;
    }
    else
    {
        LOCK_IF_NECESSARY(pLock);
        pEntry = pListHead->pNext;
        if (pEntry)
        {
            pListHead->pNext = pEntry->pNext;
        }
        UNLOCK_IF_NECESSARY(pLock);
    }

    return pEntry;
}

//+------------------------------------------------------------------------
//
//  Member:     CInternalPageAllocator::Initialize, public
//
//  Synopsis:   Initializes the page allocator.
//
//  Notes:      Instances of this class must be static since this
//              function does not init all members to 0.
//
//  History:    02-Feb-95   Rickhi      Created
//              25-Feb-97   SatishT     Added mem alloc/free function
//                                      parameters
//
//-------------------------------------------------------------------------
void CInternalPageAllocator::Initialize(
                            SIZE_T cbPerEntry,
                            USHORT cEntriesPerPage,
                            COleStaticMutexSem *pLock,
                            DWORD dwFlags,
                            MEM_ALLOC_FN pfnAlloc,
                            MEM_FREE_FN  pfnFree
                            )
{
    ComDebOut((DEB_PAGE,
        "CInternalPageAllocator::Initialize cbPerEntry:%x cEntriesPerPage:%x\n",
         cbPerEntry, cEntriesPerPage));

    Win4Assert(cbPerEntry >= sizeof(PageEntry));
    Win4Assert(cEntriesPerPage > 0);

    _cbPerEntry      = cbPerEntry;
    _cEntriesPerPage = cEntriesPerPage;

    _cPages          = 0;
    _cEntries        = 0;
    _dwFlags         = dwFlags;
    _pPageListStart  = NULL;
    _pPageListEnd    = NULL;

    _ListHead.pNext  = NULL;
    _ListHead.dwFlag = 0;

    _pLock           = pLock;
    _pfnMyAlloc      = pfnAlloc;
    _pfnMyFree       = pfnFree;
}

//+------------------------------------------------------------------------
//
//  Member:     CInternalPageAllocator::Cleanup, public
//
//  Synopsis:   Cleanup the page allocator.
//
//  History:    02-Feb-95   Rickhi      Created
//
//-------------------------------------------------------------------------
void CInternalPageAllocator::Cleanup()
{
    ComDebOut((DEB_PAGE, "CInternalPageAllocator::Cleanup _dwFlags = 0x%x\n", _dwFlags));
    LOCK_IF_NECESSARY(_pLock);

    if (_pPageListStart)
    {
        PageEntry **pPagePtr = _pPageListStart;
        while (pPagePtr < _pPageListEnd)
        {
            // release each page of the table
            _pfnMyFree(*pPagePtr);
            pPagePtr++;
        }

        // release the page list
        _pfnMyFree(_pPageListStart);

        // reset the pointers so re-initialization is not needed
        _cPages          = 0;
        _pPageListStart  = NULL;
        _pPageListEnd    = NULL;

        _ListHead.pNext  = NULL;
        _ListHead.dwFlag = 0;
    }

    UNLOCK_IF_NECESSARY(_pLock);
}

//+------------------------------------------------------------------------
//
//  Member:     CInternalPageAllocator::AllocEntry, public
//
//  Synopsis:   Finds the first available entry in the table and returns
//              a ptr to it. Returns NULL if no space is available and it
//              cant grow the list.
//
//  History:    02-Feb-95   Rickhi      Created
//
//-------------------------------------------------------------------------
PageEntry *CInternalPageAllocator::AllocEntry(BOOL fGrow)
{
    ComDebOut((DEB_PAGE, "CInternalPageAllocator::AllocEntry fGrow:%x\n", fGrow));

    // try to pop the first free one off the stack list head
    PageEntry *pEntry = PopSList(&_ListHead, _pLock);

    if (pEntry == NULL)
    {
        // no free entries
        if (fGrow)
        {
            // OK to try to grow the list
            pEntry = Grow();
        }

        if (pEntry == NULL)
        {
            // still unable to allocate more, return NULL
            return NULL;
        }
    }

    // count one more allocation
    InterlockedIncrement(&_cEntries);

    // In debug builds, try to detect two allocations of the
    // same entry. This is not 100% fool proof, but will mostly
    // assert correctly.
    Win4Assert(pEntry->dwFlag == FREE_PAGE_ENTRY);
    pEntry->dwFlag = ALLOC_PAGE_ENTRY;

    ComDebOut((DEB_PAGE, "CInternalPageAllocator::AllocEntry _cEntries:%x pEntry:%x \n",
               _cEntries, pEntry));
    return pEntry;
}

//+------------------------------------------------------------------------
//
//  Member:     CInternalPageAllocator::ReleaseEntry, private
//
//  Synopsis:   returns an entry on the free list.
//
//  History:    02-Feb-95   Rickhi      Created
//
//-------------------------------------------------------------------------
void CInternalPageAllocator::ReleaseEntry(PageEntry *pEntry)
{
    ComDebOut((DEB_PAGE, "CInternalPageAllocator::ReleaseEntry _cEntries:%x pEntry:%x\n",
               _cEntries, pEntry));
    Win4Assert(pEntry);

    // In Debug builds, try to detect second release
    // This is not 100% fool proof, but will mostly assert correctly
    Win4Assert(pEntry->dwFlag != FREE_PAGE_ENTRY);
    pEntry->dwFlag = FREE_PAGE_ENTRY;

    // count 1 less allocation
    InterlockedDecrement(&_cEntries);

    // push it on the free stack list
    PushSList(&_ListHead, pEntry, _pLock);
}

//+------------------------------------------------------------------------
//
//  Member:     CInternalPageAllocator::ReleaseEntryList, private
//
//  Synopsis:   returns a list of entries to the free list.
//
//  History:    02-Feb-95   Rickhi      Created
//
//-------------------------------------------------------------------------
void CInternalPageAllocator::ReleaseEntryList(PageEntry *pFirst, PageEntry *pLast)
{
    ComDebOut((DEB_PAGE, "CInternalPageAllocator::ReleaseEntryList pFirst:%x pLast:%x\n",
         pFirst, pLast));
    Win4Assert(pFirst);
    Win4Assert(pLast);

#if DBG==1
    // In Debug builds, try to detect second released of an entry.
    // This is not 100% fool proof, but will mostly assert correctly
    //
    // We don't need to do this in free builds because this value is only
    // used by the CPageAllocator when system heap allocation is enabled.
    // In that case, this function is never called
    pLast->pNext = NULL;
    PageEntry *pCur = pFirst;
    while (pCur)
    {
        Win4Assert(pCur->dwFlag != FREE_PAGE_ENTRY);
        pCur->dwFlag = FREE_PAGE_ENTRY;
        pCur = pCur->pNext;
    }
#endif

    LOCK_IF_NECESSARY(_pLock);

    // update the free list
    pLast->pNext    = _ListHead.pNext;
    _ListHead.pNext = pFirst;

    UNLOCK_IF_NECESSARY(_pLock);
}

//+------------------------------------------------------------------------
//
//  Member:     CInternalPageAllocator::Grow, private
//
//  Synopsis:   Grows the table to allow for more Entries.
//
//  History:    02-Feb-95   Rickhi      Created
//
//-------------------------------------------------------------------------
PageEntry *CInternalPageAllocator::Grow()
{
    // allocate a new page
    SIZE_T cbPerPage = _cbPerEntry * _cEntriesPerPage;
    PageEntry *pNewPage = (PageEntry *) _pfnMyAlloc(cbPerPage);

    if (pNewPage == NULL)
    {
        return NULL;
    }

#if DBG==1
    // clear the page (only needed in debug)
    memset(pNewPage, 0xbaadbeef, cbPerPage);
#endif

    // link all the new entries together in a linked list and mark
    // them as currently free.
    PageEntry *pNextFreeEntry = pNewPage;
    PageEntry *pLastFreeEntry = (PageEntry *)(((BYTE *)pNewPage) + cbPerPage - _cbPerEntry);

    while (pNextFreeEntry < pLastFreeEntry)
    {
        pNextFreeEntry->pNext  = (PageEntry *)((BYTE *)pNextFreeEntry + _cbPerEntry);
        pNextFreeEntry->dwFlag = FREE_PAGE_ENTRY;
        pNextFreeEntry         = pNextFreeEntry->pNext;
    }

    // last entry has an pNext of NULL (end of list)
    pLastFreeEntry->pNext  = NULL;
    pLastFreeEntry->dwFlag = FREE_PAGE_ENTRY;


    // we may have to free these later if a failure happens below
    PageEntry * pPageToFree     = pNewPage;
    PageEntry **pPageListToFree = NULL;
    PageEntry * pEntryToReturn  = NULL;


    // CODEWORK: we face the potential of several threads growing the same
    // list at the same time. We may want to check the free list again after taking
    // the lock to decide whether to continue growing or not.
    LOCK_IF_NECESSARY(_pLock);

    // compute size of current page list
    LONG cbCurListSize = _cPages * sizeof(PageEntry *);

    // allocate a new page list to hold the new page ptr.
    PageEntry **pNewList = (PageEntry **) _pfnMyAlloc(cbCurListSize +
                                                       sizeof(PageEntry *));
    if (pNewList)
    {
        // copy old page list into the new page list
        memcpy(pNewList, _pPageListStart, cbCurListSize);

        // set the new page ptr entry
        *(pNewList + _cPages) = pNewPage;
        _cPages ++;

        // replace old page list with the new page list
        pPageListToFree = _pPageListStart;
        _pPageListStart = pNewList;
        _pPageListEnd   = pNewList + _cPages;

        // Since some entries may have been freed while we were growing,
        // chain the current free list to the end of the newly allocated chain.
        pLastFreeEntry->pNext  = _ListHead.pNext;

        // update the list head to point to the start of the newly allocated
        // entries (except we take the first entry to return to the caller).
        pEntryToReturn         = pNewPage;
        _ListHead.pNext        = pEntryToReturn->pNext;

        // don't free the allocated page
        pPageToFree            = NULL;
    }

    UNLOCK_IF_NECESSARY(_pLock);

    // free the allocated pages if needed.
    if (pPageToFree)
        _pfnMyFree(pPageToFree);

    if (pPageListToFree)
        _pfnMyFree(pPageListToFree);

    ComDebOut((DEB_PAGE, "CInternalPageAllocator::Grow _pPageListStart:%x _pPageListEnd:%x pEntryToReturn:%x\n",
        _pPageListStart, _pPageListEnd, pEntryToReturn));

    return pEntryToReturn;
}

//+------------------------------------------------------------------------
//
//  Member:     CInternalPageAllocator::GetEntryIndex, public
//
//  Synopsis:   Converts a PageEntry ptr into an index.
//
//  History:    02-Feb-95   Rickhi      Created
//
//-------------------------------------------------------------------------
LONG CInternalPageAllocator::GetEntryIndex(PageEntry *pEntry)
{
    LONG lIndex = -1;
    
    LOCK_IF_NECESSARY(_pLock);
    
    for (LONG index=0; index<_cPages; index++)
    {
        PageEntry *pPage = *(_pPageListStart + index);  // get page ptr
        if (pEntry >= pPage)
        {
            if (pEntry < (PageEntry *) ((BYTE *)pPage + (_cEntriesPerPage * _cbPerEntry)))
            {
                // found the page that the entry lives on, compute the index of
                // the page and the index of the entry within the page.
                lIndex = (index << PAGETBL_PAGESHIFT) +
                       (ULONG) (((BYTE *)pEntry - (BYTE *)pPage) / _cbPerEntry);
                break;
            }
        }
    }

    UNLOCK_IF_NECESSARY(_pLock);

    // not found
    return lIndex;
}

//+------------------------------------------------------------------------
//
//  Member:     CInternalPageAllocator::IsValidIndex, private
//
//  Synopsis:   determines if the given DWORD provides a legal index
//              into the PageTable.
//
//  History:    02-Feb-95   Rickhi      Created
//
//-------------------------------------------------------------------------
BOOL CInternalPageAllocator::IsValidIndex(LONG index)
{
    // make sure the index is not negative, otherwise the shift will do
    // sign extension. check for valid page and valid offset within page
    if ( (index >= 0) &&
         ((index >> PAGETBL_PAGESHIFT) < _cPages) &&
         ((index & PAGETBL_PAGEMASK) < _cEntriesPerPage) )
         return TRUE;

    // Don't print errors during shutdown.
    if (_cPages != 0)
        ComDebOut((DEB_ERROR, "IsValidIndex: Invalid PageTable Index:%x\n", index));
    return FALSE;
}

//+------------------------------------------------------------------------
//
//  Member:     CInternalPageAllocator::GetEntryPtr, public
//
//  Synopsis:   Converts an entry index into an entry pointer
//
//  History:    02-Feb-95   Rickhi      Created
//
//-------------------------------------------------------------------------
PageEntry *CInternalPageAllocator::GetEntryPtr(LONG index)
{
    Win4Assert(index >= 0);
    Win4Assert(_cPages != 0);
    Win4Assert(IsValidIndex(index));

    LOCK_IF_NECESSARY(_pLock);

    PageEntry *pEntry = _pPageListStart[index >> PAGETBL_PAGESHIFT];
    pEntry = (PageEntry *) ((BYTE *)pEntry +
                            ((index & PAGETBL_PAGEMASK) * _cbPerEntry));

    UNLOCK_IF_NECESSARY(_pLock);

    return pEntry;
}

//+------------------------------------------------------------------------
//
//  Member:     CInternalPageAllocator::ValidateEntry, debug
//
//  Synopsis:   Verifies that the specified entry is in the range of
//              memory for this table.
//
//  Note:       The caller must lock the page allocator if necessary.
//
//  History:    15 Apr 98   AlexArm      Created
//
//-------------------------------------------------------------------------
void CInternalPageAllocator::ValidateEntry( void *pEntry )
{
    Win4Assert( GetEntryIndex( (PageEntry *) pEntry ) != -1 );
}


LONG CInternalPageAllocator::GetNextEntry (LONG lIndex)
{
    LONG lPage, lOffset, lNewIndex;

    if (lIndex == PGALLOC_INVALID_INDEX)
    {
        lPage = 0;
        lOffset = 0;
    }
    else
    {
        lPage = lIndex >> PAGETBL_PAGESHIFT;
        lOffset = lIndex & PAGETBL_PAGEMASK;

        lOffset ++;
        if (lOffset >= _cEntriesPerPage)
        {
            lOffset = 0;
            lPage ++;
        }
    }

    if (lPage >= _cPages)
    {
        lNewIndex = PGALLOC_INVALID_INDEX;
    }
    else
    {
        Win4Assert (_cEntriesPerPage > 0);
        
        lNewIndex = (lPage << PAGETBL_PAGESHIFT) + lOffset;
        Win4Assert (IsValidIndex (lNewIndex));
    }

    return lNewIndex;
}


//
// Wrapper class around old page allocator
// Allows user blocks to come from the system heap
//

CPageAllocator::CPageAllocator()
{
    _hHeap = NULL;
    _cbPerEntry = 0;
    _lNumEntries = 0;
    _pLock = NULL;
}

CPageAllocator::~CPageAllocator()
{
    // It would be nice to assert this, but we can't
    //Win4Assert (_hHeap == NULL);
    //Win4Assert (_cbPerEntry == 0);
    //Win4Assert (_lNumEntries == 0);
    //Win4Assert (_pLock == NULL);
}

BOOL CPageAllocator::InitializeHeap()
{
    if (_hHeap == NULL)
    {
        HANDLE hHeap = ComVerifierSettings::PageAllocHeapIsPrivate() ? HeapCreate (_pLock ? 0 : HEAP_NO_SERIALIZE, 1, 0) : GetProcessHeap();
        if (hHeap == NULL)
        {
            return FALSE;
        }

        if (InterlockedCompareExchangePointer (&_hHeap, hHeap, NULL) != NULL && ComVerifierSettings::PageAllocHeapIsPrivate())
        {
            // We lost the race
            HeapDestroy (hHeap);
        }
    }

    return TRUE;
}

// return ptr to first free entry
PageEntry* CPageAllocator::AllocEntry (BOOL fGrow)
{
    // First, get a real page allocator entry
    PageEntry* pEntry = _pgalloc.AllocEntry (fGrow);
    if (!ComVerifierSettings::PageAllocUseSystemHeap() || pEntry == NULL)
    {
        return pEntry;
    }

    // What we got from the internal page allocator was really a SystemPageEntry
    SystemPageEntry* psEntry = (SystemPageEntry*) pEntry;
    psEntry->pHeapBlock = NULL;

    if (!InitializeHeap())
    {
        _pgalloc.ReleaseEntry (psEntry);
        return NULL;
    }

    // Allocate the user block from the real heap
    SystemBlockHeader* pHeader = (SystemBlockHeader*) HeapAlloc (_hHeap, 0, _cbPerEntry);
    if (pHeader == NULL)
    {
        _pgalloc.ReleaseEntry (psEntry);
        return NULL;
    }

    // Mark up the header of the new heap block
    LONG lIndex = _pgalloc.GetEntryIndex (psEntry);
    Win4Assert (IsValidIndex (lIndex));

    pHeader->lIndex = lIndex;
    pHeader->ulSignature = PGALLOC_SIGNATURE;

    // Make the pgalloc entry point to the heap entry
    psEntry->pHeapBlock = pHeader;

#if DBG==1
    SystemPageEntry* pTestEntry = (SystemPageEntry*) _pgalloc.GetEntryPtr (lIndex);
    Win4Assert (pTestEntry == psEntry);
    Win4Assert (pTestEntry->pHeapBlock == pHeader);
#endif

    // Now, both blocks point at each other.  Return the heap block to the user
    pHeader ++;
    Win4Assert ((INT_PTR) pHeader % 8 == 0);

    LONG lEntries = InterlockedIncrement (&_lNumEntries);
    Win4Assert (lEntries > 0);
    
    return (PageEntry*) pHeader;
}


// return an entry to the free list
void CPageAllocator::ReleaseEntry (PageEntry* pEntry)
{
    ValidateEntry (pEntry);

    if (!ComVerifierSettings::PageAllocUseSystemHeap())
    {
        _pgalloc.ReleaseEntry (pEntry);
    }
    else
    {
        SystemBlockHeader* pHeader = (SystemBlockHeader*) pEntry;
        pHeader--;

        // Free the page allocator block
        SystemPageEntry* pRealEntry = (SystemPageEntry*) _pgalloc.GetEntryPtr (pHeader->lIndex);

        pRealEntry->pHeapBlock = NULL;
        _pgalloc.ReleaseEntry (pRealEntry);

        // Free the heap block
        ComDebOut((DEB_PAGE, "CPageAllocator::ReleaseEntry HeapFree:%p pEntry:%p\n", pHeader, pRealEntry));

        HeapFree (_hHeap, 0, pHeader);
        
        LONG lEntries = InterlockedDecrement (&_lNumEntries);
        Win4Assert (lEntries >= 0);
    }
}
        

// return a list of entries to free list
void CPageAllocator::ReleaseEntryList (PageEntry *pFirst, PageEntry *pLast)
{
    ValidateEntry (pFirst);
    ValidateEntry (pLast);
    
    if (!ComVerifierSettings::PageAllocUseSystemHeap())
    {
        _pgalloc.ReleaseEntryList (pFirst, pLast);
    }
    else
    {
        PageEntry* pEntry = pFirst, * pFree = pLast;
        while (pEntry)
        {
            pFree = pEntry;
            pEntry = pEntry->pNext;

            ReleaseEntry (pFree);
        }

        // Last should really be last
        Win4Assert (pFree == pLast);
    }
}

LONG CPageAllocator::GetEntryIndex(PageEntry *pEntry)
{
    ValidateEntry (pEntry);
    
    if (!ComVerifierSettings::PageAllocUseSystemHeap())
    {
        return _pgalloc.GetEntryIndex (pEntry);
    }
    else
    {
        SystemBlockHeader* pHeader = (SystemBlockHeader*) pEntry;
        pHeader--;

        Win4Assert (IsValidIndex (pHeader->lIndex));
        return pHeader->lIndex;
    }
}

// TRUE if index is valid
BOOL CPageAllocator::IsValidIndex(LONG iEntry)
{
    return _pgalloc.IsValidIndex (iEntry);
}

// return ptr based on index
PageEntry* CPageAllocator::GetEntryPtr(LONG iEntry)
{
    PageEntry* pEntry = _pgalloc.GetEntryPtr (iEntry);
    if (!ComVerifierSettings::PageAllocUseSystemHeap())
    {
        return pEntry;
    }

    // It would be nice to assert this, but we can't.
    // The IPID table fetches arbitrary indexes under a lock, and pokes them to see if they're valid
    // Win4Assert (pEntry->dwFlag == ALLOC_PAGE_ENTRY);

    SystemBlockHeader* pHeader = ((SystemPageEntry*) pEntry)->pHeapBlock;
    if (pHeader == NULL)
    {
        return NULL;
    }
    
    pHeader ++;
    pEntry = (PageEntry*) pHeader;
    ValidateEntry (pEntry);

    return pEntry;
}
    

// initialize the table
void CPageAllocator::Initialize(
    SIZE_T cbPerEntry,
    USHORT cEntryPerPage,
    COleStaticMutexSem *pLock,   // NULL implies no locking
    DWORD dwFlags,
    MEM_ALLOC_FN pfnAlloc,
    MEM_FREE_FN  pfnFree)
{
    Win4Assert (_hHeap == NULL);

    if (ComVerifierSettings::PageAllocUseSystemHeap())
    {
        _cbPerEntry = sizeof (SystemBlockHeader) + cbPerEntry;
        cbPerEntry = (LONG) sizeof (SystemPageEntry);

        _pLock = pLock;
        
        InitializeHeap();
    }

    _pgalloc.Initialize (cbPerEntry, cEntryPerPage, pLock, dwFlags, pfnAlloc, pfnFree);
}

// cleanup the table
void CPageAllocator::Cleanup()
{
    if (ComVerifierSettings::PageAllocUseSystemHeap())
    {
        // Enumerate all unfreed page allocator entries, and free the heap blocks associated with them
        LONG lItorIndex = PGALLOC_INVALID_INDEX;

        while ((lItorIndex = _pgalloc.GetNextEntry (lItorIndex)) != PGALLOC_INVALID_INDEX)
        {
            SystemPageEntry* pRealEntry = (SystemPageEntry*) _pgalloc.GetEntryPtr (lItorIndex);
            if (pRealEntry->dwFlag == ALLOC_PAGE_ENTRY)
            {
                SystemBlockHeader* pUserBlock = pRealEntry->pHeapBlock;
                pUserBlock ++;

                ComDebOut((DEB_PAGE, "CPageAllocator::Cleanup releasing leaked entry:%p\n", pUserBlock));
                
                ReleaseEntry ((PageEntry*) pUserBlock);
            }
            else
            {
                Win4Assert (pRealEntry->dwFlag == FREE_PAGE_ENTRY);
            }
        }

        AssertEmpty();
        
        if (ComVerifierSettings::PageAllocHeapIsPrivate() && _hHeap != NULL)
        {
            HeapDestroy (_hHeap);
        }
        
        _hHeap = NULL;
        _cbPerEntry = 0;
        _lNumEntries = 0;
        _pLock = NULL;
    }

    _pgalloc.Cleanup();
}

// Checked builds only
void CPageAllocator::AssertEmpty()
{
    Win4Assert (_lNumEntries == 0);
    _pgalloc.AssertEmpty();
}

void CPageAllocator::ValidateEntry( void *pEntry )
{
    if (!ComVerifierSettings::PageAllocUseSystemHeap())
    {
        _pgalloc.ValidateEntry (pEntry);
    }
    else
    {
#if DBG==1
        SystemBlockHeader* pHeader = (SystemBlockHeader*) pEntry;
        pHeader --;

        Win4Assert (!IsBadReadPtr (pHeader, sizeof (SystemBlockHeader)));
        Win4Assert (pHeader->ulSignature == PGALLOC_SIGNATURE);
        Win4Assert (IsValidIndex (pHeader->lIndex));

        SystemPageEntry* psEntry = (SystemPageEntry*) _pgalloc.GetEntryPtr (pHeader->lIndex);
        Win4Assert (psEntry->dwFlag == ALLOC_PAGE_ENTRY);
        Win4Assert ((INT_PTR) psEntry->pHeapBlock == (INT_PTR) pHeader);
#endif
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\com\dcomrem\resolver.cxx ===
//+-------------------------------------------------------------------
//
//  File:       resolver.cxx
//
//  Contents:   class implementing interface to RPC OXID/PingServer
//              resolver process. Only one instance per process.
//
//  Classes:    CRpcResolver
//
//  History:    20-Feb-95   Rickhi      Created
//
//--------------------------------------------------------------------
#include    <ole2int.h>
#include    <resolver.hxx>      // CRpcResolver
#include    <service.hxx>       // GetStringBindings
#include    <locks.hxx>         // LOCK/UNLOCK etc
#include    <marshal.hxx>       // GetOXIDFromObjRef
#include    <channelb.hxx>      // gfCatchServerExceptions and gfBreakOnSilencedExceptions
#include    <sobjact.hxx>       // CObjServer
#include    <security.hxx>      // Security globals
#include    <events.hxx>        // Event logging functions
#include    <chock.hxx>         // Channel hook globals
#include    <secdes.hxx>        // CWorldSecurityDescriptor
#include    <smemscm.hxx>
#include    <immact.hxx>

// global instance of OXID resolver
CRpcResolver gResolver;

// static members of CRpcResolver
handle_t  CRpcResolver::_hRpc = NULL;       // binding handle to resolver
HANDLE    CRpcResolver::_hResolverWaitEvent = NULL;       
DWORD     CRpcResolver::_dwFlags = 0;       // flags
CDualStringArray* CRpcResolver::_pdsaLocalResolver = NULL;
DWORD64   CRpcResolver::_dwCurrentBindingsID = 0;
CMachineNamesHelper* CRpcResolver::_pMNHelper = NULL;

ULONG      CRpcResolver::_cReservedOidsAvail = 0;
OID        CRpcResolver::_OidsReserved[MAX_RESERVED_OIDS];
LPWSTR    CRpcResolver::_pwszWinstaDesktop = NULL;
LPWSTR    CRpcResolver::_pwszFQDN = NULL;
ULONG64   CRpcResolver::_ProcessSignature = 0;
ISCMLocalActivator *CRpcResolver::_pSCMProxy = NULL;     // scm proxy
COleStaticMutexSem  CRpcResolver::_mxsResolver;
PHPROCESS CRpcResolver::_ph = NULL;         // context handle to resolver process
GUID      CRpcResolver::_GuidRPCSSProcessIdentifier = GUID_NULL;

// MID (machine ID) of local machine
MID gLocalMid;

// Ping period in milliseconds.
DWORD giPingPeriod;

// String arrays for the SCM process. These are used to tell the interface
// marshaling code the protocol and endpoint of the SCM process.
typedef struct tagSCMSA
{
    unsigned short wNumEntries;     // Number of entries in array.
    unsigned short wSecurityOffset; // Offset of security info.
    WCHAR awszStringArray[62];
} SCMSA;

// The last 4 characters in the string define the security bindings.
// \0xA is RPC_C_AUTHN_WINNT
// \0xFFFF is COM_C_AUTHZ_NONE
// \0 is an empty principle name
SCMSA saSCM = {24, 20, L"ncalrpc:[epmapper]\0\0\xA\xFFFF\0\0"};

// string binding to the resolver
const WCHAR *pwszResolverBindString = L"ncalrpc:[epmapper,Security=Impersonation Dynamic False]";

const DWORD ANY_CLOAKING = EOAC_STATIC_CLOAKING | EOAC_DYNAMIC_CLOAKING;

BOOL GetEnvBlock( PRIV_SCM_INFO * pScmInfo );

extern "C" HRESULT GetActivationPropertiesIn(
                                    ActivationPropertiesIn *pActIn,
                                    REFCLSID rclsid,
                                    DWORD dwContext,
                                    COSERVERINFO * pServerInfo,
                                    DWORD cIIDs,
                                    IID *iidArray,
                                    DWORD actvflags,
                                    PVOID notUsed1,
                                    PVOID notUsed2);

extern void UpdateCOMPlusEnabled();

//+-------------------------------------------------------------------
//
//  Member:     CRpcResolver::Cleanup, public
//
//  Synopsis:   cleanup the resolver state. Called by ProcessUninitialze.
//
//  History:    20-Feb-95   Rickhi      Created.
//
//--------------------------------------------------------------------
void CRpcResolver::Cleanup()
{	
    ASSERT_LOCK_NOT_HELD(_mxsResolver);
    LOCK(_mxsResolver);

    // reset the connect bit
    _dwFlags &= ~ORF_CONNECTED;
    
    // if the bulkupdate thread is currently in a call to the resolver
    // wait till it completes the call
    if (IsInBulkupdateCall()) 
    {
       Win4Assert(_hResolverWaitEvent);
       UNLOCK(_mxsResolver);
       DWORD dw = WaitForSingleObject(_hResolverWaitEvent, INFINITE);
       LOCK(_mxsResolver);
       Win4Assert (WAIT_OBJECT_0 == dw);
       Win4Assert (!IsInBulkupdateCall());
    }
    if (_hResolverWaitEvent)
    {
	CloseHandle(_hResolverWaitEvent);
	_hResolverWaitEvent = NULL;
    }
    
    // release our context handle
    Disconnect();

    // release regular handle
    if (_hRpc)
    {
        RpcBindingFree(&_hRpc);
        _hRpc = NULL;
    }

    // Release the string bindings for the local object exporter.
    SetLocalResolverBindings(0, NULL);

    if (_pwszWinstaDesktop != NULL)
    {
        PrivMemFree(_pwszWinstaDesktop);
        _pwszWinstaDesktop = NULL;
    }
    if (_pwszFQDN != NULL)
    {
        PrivMemFree(_pwszFQDN);
        _pwszFQDN = NULL;
    }

    // reset the flags
    _dwFlags = 0;

    UNLOCK(_mxsResolver);
    ASSERT_LOCK_NOT_HELD(_mxsResolver);
}

//+-------------------------------------------------------------------
//
//  Member:     CRpcResolver::Disconnect, private
//
//  Synopsis:   cleanup our context handle by calling RPCSS to 
//              release it.   
//
//  History:    22-Mar-02   JSimmons      Created
//
//--------------------------------------------------------------------
void CRpcResolver::Disconnect()
{
    RPC_STATUS sc = RPC_S_OK;

    if (_ph)
    {
        Win4Assert(_hRpc);

        do
        {
            sc = ::Disconnect(_hRpc, &_ph);
        }
        while (RetryRPC(sc));
    }

    if (_ph)
    {
        // Failed to disconnect it in the normal fashion.  We
        // still need to release the resources though and tell RPC
        // we're done using it.  This should be a relatively rare
        // event, hence the assert.
        Win4Assert(!"Disconnect rpc call failed");
        sc = RpcSmDestroyClientContext(&_ph);
        Win4Assert(sc == RPC_S_OK);
        _ph = NULL;
    }

    return;
}

//+-------------------------------------------------------------------
//
//  Member:     CRpcResolver::ReleaseSCMProxy, public
//
//  Synopsis:   cleanup the resolver state. Called by ProcessUninitialze.
//
//  History:    20-Feb-95   Rickhi      Created.
//
//--------------------------------------------------------------------
void CRpcResolver::ReleaseSCMProxy()
{
    LOCK(_mxsResolver);

    // NULL the ptr in a thread-safe fashion
    ISCMLocalActivator *pSCM = _pSCMProxy;
    _pSCMProxy = NULL;

    UNLOCK(_mxsResolver);

    if (pSCM != NULL)
    {
        // release the proxy to the SCM
        pSCM->Release();
    }

    // CODEWORK: Why are these here and not in the activation
    // cleanup code?
    if (gpMTAObjServer != NULL)
    {
        delete gpMTAObjServer;
        gpMTAObjServer = NULL;
    }

    if (gpNTAObjServer != NULL)
    {
        delete gpNTAObjServer;
        gpNTAObjServer = NULL;
    }
}

//+-------------------------------------------------------------------
//
//  Member:     CRpcResolver::GetSCMProxy, public
//
//  Synopsis:   Gets a proxy to the SCM.
//
//  History:    20-Feb-95   Rickhi      Created.
//
//--------------------------------------------------------------------
HRESULT CRpcResolver::GetSCMProxy(ISCMLocalActivator** ppScmProxy)
{
    HRESULT hr = BindToSCMProxy();

    if (FAILED(hr))
    {
        return hr;
    }

    *ppScmProxy = _pSCMProxy;
    return S_OK;
}

//+-------------------------------------------------------------------
//
//  Member:     CRpcResolver::RetryRPC, private
//
//  Synopsis:   determine if we need to retry the RPC call due to
//              the resolver being too busy.
//
//  History:    20-Feb-95   Rickhi      Created.
//
//--------------------------------------------------------------------
BOOL CRpcResolver::RetryRPC(RPC_STATUS sc)
{
    if (sc != RPC_S_SERVER_TOO_BUSY)
        return FALSE;

    // give the resolver time to run, then try again.
    Sleep(100);

    // CODEWORK: this is currently an infinite loop. Should we limit it?
    return TRUE;
}

//+-------------------------------------------------------------------
//
//  Member:     CRpcResolver::CheckStatus, private
//
//  Synopsis:   Checks the status code of an Rpc call, prints a debug
//              ERROR message if failed, and maps the failed status code
//              into an HRESULT.
//
//  History:    20-Feb-95   Rickhi      Created.
//
//--------------------------------------------------------------------
HRESULT CRpcResolver::CheckStatus(RPC_STATUS sc)
{
    if (sc != RPC_S_OK)
    {
        ComDebOut((DEB_ERROR, "OXID Resolver Failure sc:%x\n", sc));
        sc = HRESULT_FROM_WIN32(sc);
    }

    return sc;
}

//+-------------------------------------------------------------------
//
//  Member:     CRpcResolver::GetFQDN, public
//
//  Synopsis:   Gets the FQDN for this server
//
//  History:    31-Oct-2001   sajia      Created.
//
//--------------------------------------------------------------------

HRESULT CRpcResolver::GetFQDN(WCHAR **ppwszFQDN)
{
   HRESULT hr = S_OK;
   WCHAR* pwszLocal = NULL;
   
   *ppwszFQDN = NULL;
   if (_pwszFQDN) 
   {
      *ppwszFQDN = _pwszFQDN;
      return hr;
   }
   ASSERT_LOCK_NOT_HELD(_mxsResolver);
   LOCK(_mxsResolver);
   if (_pwszFQDN) 
   {
      UNLOCK(_mxsResolver);
      ASSERT_LOCK_NOT_HELD(_mxsResolver);
      *ppwszFQDN = _pwszFQDN;
      return hr;
   }
   DWORD dwBuf = 0;
   BOOL bRet = GetComputerNameEx(ComputerNameDnsFullyQualified, NULL, &dwBuf);
   if ((bRet == FALSE) && (ERROR_MORE_DATA == GetLastError())) 
   {
      pwszLocal = (LPWSTR)PrivMemAlloc(dwBuf*sizeof(WCHAR));
      if (pwszLocal) 
      {
         if (!GetComputerNameEx(ComputerNameDnsFullyQualified, pwszLocal, &dwBuf))
         {
            PrivMemFree(pwszLocal);
            hr = HRESULT_FROM_WIN32(GetLastError());
            ComDebOut((DEB_ERROR, "GetComputerNameEx Failed GLE:0x%x\n", hr));
         }
         else
            _pwszFQDN = pwszLocal;
      }
      else
         hr = E_OUTOFMEMORY;
   }
   else
      hr = HRESULT_FROM_WIN32(GetLastError());
   if (SUCCEEDED(hr) )
   {
      Win4Assert(_pwszFQDN);
      *ppwszFQDN = _pwszFQDN;
   }
   UNLOCK(_mxsResolver);
   ASSERT_LOCK_NOT_HELD(_mxsResolver);
   return hr;
}

//+-------------------------------------------------------------------
//
//  Member:     CRpcResolver::GetConnection, public
//
//  Synopsis:   connects to the resolver process
//
//  History:    20-Feb-95   Rickhi      Created.
//
//--------------------------------------------------------------------

HRESULT CRpcResolver::GetConnection()
{
    ComDebOut((DEB_OXID,"CRpcResolver::GetConnection\n"));

    // ensure TLS is initialized for this thread.
    HRESULT     hr;
    COleTls     tls(hr);
    if (FAILED(hr))
        return(hr);

    // if already initailized, just return
    if (IsConnected())
        return S_OK;

    RPC_STATUS  sc = RPC_S_OK;

    // only 1 thread should do the initialization
    ASSERT_LOCK_NOT_HELD(_mxsResolver);
    LOCK(_mxsResolver);

    if (!IsConnected())
    {
        DWORD   fConnectFlags = 0;
        DUALSTRINGARRAY *psaResolver = NULL;

        ULONG   cOidsReserved = 0;
        OID     aOidsReserved[MAX_RESERVED_OIDS];

        if ( _pwszWinstaDesktop == NULL )
            sc = GetThreadWinstaDesktop();

        if ( sc == RPC_S_OK )
        {
            sc = RpcBindingFromStringBinding((LPWSTR)pwszResolverBindString, &_hRpc);
            ComDebErr(sc != RPC_S_OK, "Resolver Binding Failed.\n");
        }

        if ( sc == RPC_S_OK )
    	{
            Win4Assert(!_hResolverWaitEvent);
            Win4Assert (!IsInBulkupdateCall());
            
            if ( (_hResolverWaitEvent = CreateEvent(NULL, TRUE, FALSE, NULL)) == NULL)
            {
                sc = GetLastError();
                ComDebOut((DEB_ERROR, "CreateEvent Failed GLE:0x%x\n",sc));
            }
    	}
        if (sc == RPC_S_OK)
        {
            HANDLE hImpToken = NULL;

            // We always want RPCSS to see the process token on 
            // initial Connect.
            SuspendImpersonate(&hImpToken);

            do
            {
                // call the resolver to get a context handle
                sc = Connect(_hRpc,
                             _pwszWinstaDesktop,
                             &_ph,
                             &giPingPeriod,
                             &psaResolver,
                             &gLocalMid,
                             MAX_RESERVED_OIDS,
                             aOidsReserved,
                             &cOidsReserved,
                             &fConnectFlags,
                             (WCHAR **) &gLegacySecurity,
                             &gAuthnLevel,
                             &gImpLevel,
                             &gServerSvcListLen,
                             &gServerSvcList,
                             &gClientSvcListLen,
                             &gClientSvcList,
                             &gcChannelHook,
                             &gaChannelHook,
                             &(tls->dwApartmentID),
                             &gdwScmProcessID,
                             &_ProcessSignature,                             
                             &_GuidRPCSSProcessIdentifier);
            }  while (RetryRPC(sc));

            ResumeImpersonate(hImpToken);
			
            if (sc == RPC_S_OK)
            {
                Win4Assert(_pdsaLocalResolver == NULL);
                Win4Assert((psaResolver != NULL) && "out-param NULL on success");

                sc = RPC_S_OUT_OF_MEMORY;
                
                // Can't use psaResolver in our CDualStringArray object, since 
                // RPC uses a different heap.  So make a copy.
                DUALSTRINGARRAY* psaLocalCopy;
                hr = CopyDualStringArray(psaResolver, &psaLocalCopy);
                if (SUCCEEDED(hr))
                {
                    // Allocate initial wrapper object for resolver bindings.
                    CDualStringArray* pdsaResolver = new CDualStringArray(psaLocalCopy);
                    if (pdsaResolver)
                    {
                        _pdsaLocalResolver = pdsaResolver;
                        sc = RPC_S_OK;

                        // We no longer need the RPC-allocated bindings
                        MIDL_user_free( psaResolver );
                        psaResolver = NULL;
                    }
                    else
                        delete psaLocalCopy;
                }
            }

            // If the call fails, some out parameters may be set while others
            // are not.  Make the out parameters consistent.
            if (sc != RPC_S_OK)
            {
                // Leak any principal names stored in gClientSvcList because
                // there is no way to tell how much of the structure was
                // initialized.
                MIDL_user_free( gClientSvcList );
                MIDL_user_free( gServerSvcList );
                MIDL_user_free( gLegacySecurity );
                MIDL_user_free( psaResolver );

                gServerSvcListLen = 0;
                gServerSvcList    = NULL;
                gClientSvcListLen = 0;
                gClientSvcList    = NULL;
                gLegacySecurity   = NULL;
            }
            else
            {
                // Sanity check
                Win4Assert((_ph != 0) && (gdwScmProcessID != 0) &&
                           (_pdsaLocalResolver->DSA() != 0) && (_ProcessSignature != 0));
            }
        }

        if (sc == RPC_S_OK)
        {
            gfCatchServerExceptions = fConnectFlags & CONNECT_CATCH_SERVER_EXCEPTIONS;
            gfBreakOnSilencedExceptions = fConnectFlags & CONNECT_BREAK_ON_SILENCED_SERVER_EXCEPTIONS;
            gDisableDCOM = fConnectFlags & CONNECT_DISABLEDCOM;

            if (fConnectFlags & CONNECT_MUTUALAUTH)
                gCapabilities = EOAC_MUTUAL_AUTH;
            else
                gCapabilities = EOAC_NONE;
            if (fConnectFlags & CONNECT_SECUREREF)
                gCapabilities |= EOAC_SECURE_REFS;
                
            Win4Assert(cOidsReserved <= MAX_RESERVED_OIDS);
            	
            // remember the reserved OID base.
            ZeroMemory(_OidsReserved, sizeof(OID) * MAX_RESERVED_OIDS);
            _cReservedOidsAvail = cOidsReserved;
            CopyMemory(_OidsReserved, aOidsReserved, sizeof(OID) * cOidsReserved);

            // Mark the security data as initialized.
            gGotSecurityData = TRUE;
            if (IsWOWProcess())
            {
                gDisableDCOM = TRUE;
            }
#ifndef SSL
            // Don't use SSL until the bug fixes are checked in.
            DWORD i;
            for (i = 0; i < gServerSvcListLen; i++)
                if (gServerSvcList[i] == RPC_C_AUTHN_GSS_SCHANNEL)
                {
                    // Remove SSL without reordering the list.
                    memcpy( &gServerSvcList[i], &gServerSvcList[i+1],
                            sizeof(gServerSvcList[i]) * (gServerSvcListLen-i-1) );
                    gServerSvcListLen -= 1;
                    break;
                }

            for (i = 0; i < gClientSvcListLen; i++)
                if (gClientSvcList[i].wId == RPC_C_AUTHN_GSS_SCHANNEL)
                {
                    // Remove SSL without reordering the list.
                    MIDL_user_free( gClientSvcList[i].pName );
                    memcpy( &gClientSvcList[i], &gClientSvcList[i+1],
                            sizeof(gClientSvcList[i]) * (gClientSvcListLen-i-1) );
                    gClientSvcListLen -= 1;
                    break;
                }
#endif
            // Convert the ping period from seconds to milliseconds.
            giPingPeriod *= 1000;
            Win4Assert(_pdsaLocalResolver->DSA()->wNumEntries != 0);
	    
            // mark the resolver as connected now
            _dwFlags |= ORF_CONNECTED;
        }
        else
        {
            ComDebOut((DEB_ERROR, "Resolver Connect Failed sc:%x\n", sc));
            if (_hRpc)
            {
                RpcBindingFree(&_hRpc);
                _hRpc = NULL;
            }

            // release our context handle
            if (_ph != NULL)
            {
                RpcSmDestroyClientContext(&_ph);
                _ph = NULL;
            }
            if (_hResolverWaitEvent)
            {
                CloseHandle(_hResolverWaitEvent);
                _hResolverWaitEvent = NULL;
            }
            Win4Assert(_pdsaLocalResolver == NULL);
        }
    }

    UNLOCK(_mxsResolver);
    ASSERT_LOCK_NOT_HELD(_mxsResolver);

    hr = CheckStatus(sc);
#if DBG==1
    if(FAILED(hr))
        ComDebOut((DEB_ERROR, "GetConnection Failed hr:0x%x\n",hr));
#endif
    ComDebOut((DEB_OXID,"CRpcResolver::GetConnection hr:%x\n", hr));
    return hr;
}

//+--------------------------------------------------------------------------
//
//  Member:     CRpcResolver::ServerGetReservedMOID, public
//
//  Synopsis:   Get an OID that does not need to be pinged.
//
//  History:    06-Nov-95   Rickhi      Created.
//
//----------------------------------------------------------------------------
HRESULT CRpcResolver::ServerGetReservedMOID(MOID *pmoid)
{
    ComDebOut((DEB_OXID,"ServerGetReservedMOID\n"));
    ASSERT_LOCK_NOT_HELD(_mxsResolver);

    OID oid;

    HRESULT hr = ServerGetReservedID(&oid);
    if (SUCCEEDED(hr))
    {
        MOIDFromOIDAndMID(oid, gLocalMid, pmoid);
    }

    ASSERT_LOCK_NOT_HELD(_mxsResolver);
    ComDebOut((DEB_OXID,"ServerGetReservedMOID hr:%x moid:%I\n", hr, pmoid));
    return hr;
}

//+--------------------------------------------------------------------------
//
//  Member:     CRpcResolver::ServerGetReservedID, public
//
//  Synopsis:   Get an ID that does not need to be pinged.
//
//  History:    06-Nov-95   Rickhi      Created.
//
//----------------------------------------------------------------------------
HRESULT CRpcResolver::ServerGetReservedID(OID *pid)
{
    ComDebOut((DEB_OXID,"ServerGetReservedID\n"));
    ASSERT_LOCK_NOT_HELD(_mxsResolver);

    HRESULT hr = S_OK;

    ASSERT_LOCK_NOT_HELD(_mxsResolver);
    LOCK(_mxsResolver);

    if ( _cReservedOidsAvail == 0 )
    {
        // go get more reserved OIDs from the ping server
        UNLOCK(_mxsResolver);
        ASSERT_LOCK_NOT_HELD(_mxsResolver);
		
        OID aOidsRequested[MAX_RESERVED_OIDS];
        ULONG cOidsAllocated = 0;

        do
        {
            hr = ::AllocateReservedIds(
                              _hRpc,
                              _ph,
                              MAX_RESERVED_OIDS,
                              aOidsRequested,
                              &cOidsAllocated);
        } while ( RetryRPC(hr) );

        // map Rpc status if necessary
        hr = CheckStatus(hr);

        ASSERT_LOCK_NOT_HELD(_mxsResolver);
        LOCK(_mxsResolver);

        if (SUCCEEDED(hr) && (cOidsAllocated > _cReservedOidsAvail))
        {
            Win4Assert(cOidsAllocated <= MAX_RESERVED_OIDS);
            
            // copy into global state. Dont have to worry about two threads
            // getting more simultaneously, since these OIDs are expendable.
            ZeroMemory(_OidsReserved, sizeof(_OidsReserved));
            _cReservedOidsAvail = cOidsAllocated;
            CopyMemory(_OidsReserved, aOidsRequested, sizeof(OID) * cOidsAllocated);
        }
    }

    if (SUCCEEDED(hr))
    {
        // take the next OID on the list, working backward down the array
        *pid = _OidsReserved[_cReservedOidsAvail - 1];
        _OidsReserved[_cReservedOidsAvail - 1] = 0;
        _cReservedOidsAvail--;
    }

    UNLOCK(_mxsResolver);
    ASSERT_LOCK_NOT_HELD(_mxsResolver);
    ComDebOut((DEB_OXID,"ServerGetReservedID hr:%x id:%08x %08x\n",
              hr, *pid ));
    return hr;
}

//+-------------------------------------------------------------------
//
//  Member:     CRpcResolver::ServerRegisterOXID, public
//
//  Synopsis:   allocate an OXID and Object IDs with the local ping server
//
//  History:    20-Feb-95   Rickhi      Created.
//
//--------------------------------------------------------------------
HRESULT CRpcResolver::ServerRegisterOXID(OXID_INFO &oxidInfo,
                                         OXID      *poxid,
                                         ULONG     *pcOidsToAllocate,
                                         OID        arNewOidList[])
{
    ComDebOut((DEB_OXID, "ServerRegisterOXID TID:%x\n", GetCurrentThreadId()));
    ASSERT_LOCK_NOT_HELD(_mxsResolver);
    Win4Assert(IsConnected());

    // make sure we have the local binding and security strings
    HRESULT hr = StartListen();
    ComDebErr(hr != S_OK, "StartListen Failed.\n");

    DWORD64 dwBindingsID = 0;
    DUALSTRINGARRAY *psaNewORBindings = NULL;
    if (hr == S_OK)
    {
        DUALSTRINGARRAY *psaSB = gpsaCurrentProcess; // string bindings
        DUALSTRINGARRAY *psaSC = gpsaSecurity;       // security bindings

        if (_dwFlags & ORF_STRINGSREGISTERED)
        {
            // already registered these once, dont need to do it again.
            psaSB = NULL;
            psaSC = NULL;
        }

        ComDebOut((DEB_OXID,"ServerRegisterOXID oxidInfo:%x psaSB:%x psaSC:%x\n",
            &oxidInfo, psaSB, psaSC));

        do
        {
            hr = ::ServerAllocateOXIDAndOIDs(
                            _hRpc,              // Rpc binding handle
                            _ph,                // context handle
                            poxid,              // OXID of server
                            IsSTAThread(),      // fApartment Threaded
                            *pcOidsToAllocate,  // count of OIDs requested
                            arNewOidList,       // array of reserved oids
                            pcOidsToAllocate,   // count actually allocated
                            &oxidInfo,          // OXID_INFO to register
                            psaSB,              // string bindings for process
                            psaSC,              // security bindings for process
                            &dwBindingsID,      // bindings id of psaNewORBindings
                            &psaNewORBindings); // current OR bindings, if non-NULLs
        } while (RetryRPC(hr));

        // map Rpc status if necessary
        hr = CheckStatus(hr);
    }
	
    // Save new OR bindings
    if (SUCCEEDED(hr) && psaNewORBindings)
    {
        hr = IUpdateResolverBindings(dwBindingsID, psaNewORBindings, NULL, NULL);
    }

    ASSERT_LOCK_NOT_HELD(_mxsResolver);
    ComDebOut((DEB_OXID, "ServerRegisterOXID hr:%x\n", hr));
    return hr;
}

//+-------------------------------------------------------------------
//
//  Member:     CRpcResolver::ServerAllocOIDs, private
//
//  Synopsis:   allocate Object IDs from the local ping server
//
//  History:    20-Feb-95   Rickhi      Created.
//
//--------------------------------------------------------------------
HRESULT CRpcResolver::ServerAllocOIDs(OXID   &oxid,
                                      ULONG  *pcOidsToAllocate,
                                      OID    *parNewOidList,
                                      ULONG  cOidsToReturn,
                                      OID    *parOidsToReturn)
{
    ASSERT_LOCK_NOT_HELD(_mxsResolver);
    Win4Assert(IsConnected());
    HRESULT hr;

    do
    {
        hr = ::ServerAllocateOIDs(
                          _hRpc,            // Rpc binding handle
                          _ph,              // context handle
                          &oxid,            // OXID of server
                          cOidsToReturn,    // count of OIDs to return
                          parOidsToReturn,  // array of OIDs to return
                         *pcOidsToAllocate, // count of OIDs requested
                          parNewOidList,    // array of reserved oids
                          pcOidsToAllocate  // count actually allocated
                          );
    } while (RetryRPC(hr));

    // map Rpc status if necessary
    hr = CheckStatus(hr);

    ASSERT_LOCK_NOT_HELD(_mxsResolver);
    return hr;
}

//+-------------------------------------------------------------------
//
//  Member:     CRpcResolver::ServerFreeOXIDAndOIDs, public
//
//  Synopsis:   frees an OXID and associated OIDs that were  pre-registered
//              with the local ping server
//
//  History:    20-Jan-96   Rickhi      Created.
//
//--------------------------------------------------------------------
HRESULT CRpcResolver::ServerFreeOXIDAndOIDs(OXID &oxid, ULONG cOids, OID *pOids)
{
    ComDebOut((DEB_OXID, "CRpcResolver::ServerFreeOXID TID:%x\n", GetCurrentThreadId()));
    ASSERT_LOCK_NOT_HELD(_mxsResolver);
    Win4Assert(IsConnected());

    // call the resolver.
    HRESULT hr;

    do
    {
        Win4Assert(_ph != NULL);

        hr = ::ServerFreeOXIDAndOIDs(
                            _hRpc,      // Rpc binding handle
                            _ph,        // context handle
                            oxid,       // OXID of server
                            cOids,      // count of OIDs to de-register
                            pOids);     // ptr to OIDs to de-register

    } while (RetryRPC(hr));

    // map Rpc status if necessary
    hr = CheckStatus(hr);

    ASSERT_LOCK_NOT_HELD(_mxsResolver);
    ComDebOut((DEB_OXID, "CRpcResolver::ServerFreeOXID hr:%x\n", hr));
    return hr;
}


//+-------------------------------------------------------------------
//
//  Member:     CRpcResolver::ClientResolveOXID, public
//
//  Synopsis:   Resolve client-side OXID and returns the oxidInfo
//              structure.
//
//  History:    20-Feb-95   Rickhi      Created.
//
//--------------------------------------------------------------------
HRESULT CRpcResolver::ClientResolveOXID(REFOXID   roxid,
                                        OXID_INFO *poxidInfo,
                                        MID       *pmid,
                                        DUALSTRINGARRAY *psaResolver,
					unsigned long *pulMarshaledTargetInfoLength,
					unsigned char **pucMarshaledTargetInfo,
                                        USHORT    *pusAuthnSvc)
{
    ComDebOut((DEB_OXID,"ClientResolveOXID oxid:%08x %08x psa:%x\n",
               roxid, psaResolver));
    ASSERT_LOCK_NOT_HELD(_mxsResolver);
    Win4Assert(IsConnected());

    RPC_STATUS sc = RPC_S_OK;

    do
    {
        Win4Assert(_ph != NULL);

        sc = ::ClientResolveOXID(
                        _hRpc,              // Rpc binding handle
                        _ph,
                        (OXID *)&roxid,     // OXID of server
                        psaResolver,        // resolver binging strings
                        IsSTAThread(),      // fApartment threaded
                        poxidInfo,          // resolver info returned
                        pmid,               // mid for the machine
                        pulMarshaledTargetInfoLength,
			pucMarshaledTargetInfo, // credman credentials
                        pusAuthnSvc);       // exact authn svc used to talk to server

    } while (RetryRPC(sc));

    // map Rpc status if necessary
    sc = CheckStatus(sc);

    ASSERT_LOCK_NOT_HELD(_mxsResolver);
    ComDebOut((DEB_OXID,"ClientResolveOXID hr:%x poxidInfo:%x\n",
        sc, poxidInfo));
    return sc;
}

//+-------------------------------------------------------------------
//
//  Member:     CRpcResolver::BulkUpdateOIDs
//
//  Synopsis:   registers/deregisters/pings any OIDs waiting to be
//              sent to the ping server.
//
//  History:    30-Oct-95   Rickhi      Created.
//
//--------------------------------------------------------------------
HRESULT CRpcResolver::BulkUpdateOIDs(ULONG          cOidsToAdd,
                                     OXID_OID_PAIR *pOidsToAdd,
                                     LONG          *pStatusOfAdds,
                                     ULONG          cOidsToRemove,
                                     OID_MID_PAIR  *pOidsToRemove,
                                     ULONG          cServerOidsToUnPin,
                                     OID           *aServerOidsToUnPin,
                                     ULONG          cOxidsToRemove,
                                     OXID_REF      *pOxidsToRemove)
{
    ASSERT_LOCK_NOT_HELD(_mxsResolver);

    // it is possible for the bulkupdate thread to call here after the
    // process has been uninitialized. Just return an error.
    RPC_STATUS sc;
    LOCK(_mxsResolver);
    if (IsConnected())
    {
       if (!ResetEvent(_hResolverWaitEvent))
       {
	  sc = GetLastError();
	  ComDebOut((DEB_ERROR, "ResetEvent Failed GLE:0x%x\n",sc));
       }
       else
          sc = RPC_S_OK;
       _dwFlags |= ORF_INBULKUPDATECALL;
    }
    else
    {
      sc = RPC_E_DISCONNECTED;
    }
    UNLOCK(_mxsResolver);
    if (RPC_S_OK == sc) 
    {
        do
        {
            // call the Resolver.
            sc = ::BulkUpdateOIDs(_hRpc,          // Rpc binding handle
                              _ph,                // context handle
                              cOidsToAdd,         // #oids to add
                              pOidsToAdd,         // ptr to oids to add
                              pStatusOfAdds,      // status of adds
                              cOidsToRemove,      // #oids to remove
                              pOidsToRemove,      // ptr to oids to remove
                              0, 0,               // #, ptr to soids to free
                              cServerOidsToUnPin, // # soids to unpin
                              aServerOidsToUnPin, // ptr to soids to unpin
                              cOxidsToRemove,     // #oxids to remove
                              pOxidsToRemove);    // ptr to oxids to remove
        } while (RetryRPC(sc));
	LOCK(_mxsResolver);
	Win4Assert(_hResolverWaitEvent);
	Win4Assert (IsInBulkupdateCall());
	_dwFlags &= ~ORF_INBULKUPDATECALL;
	if (!SetEvent(_hResolverWaitEvent))
	{
	   sc = GetLastError();
	   ComDebOut((DEB_ERROR, "SetEvent Failed GLE:0x%x\n",sc));
	}
	UNLOCK(_mxsResolver);
	
    }

    // map status if necessary
    sc = CheckStatus(sc);

    ASSERT_LOCK_NOT_HELD(_mxsResolver);
    return sc;
}

//+-------------------------------------------------------------------
//
//  Function:   FillLocalOXIDInfo
//
//  Synopsis:   Fills in a OXID_INFO structure for the current apartment.
//              Used by the Drag & Drop code to register with the resolver.
//
//  History:    20-Feb-95   Rickhi      Created.
//
//--------------------------------------------------------------------
HRESULT FillLocalOXIDInfo(OBJREF &objref, OXID_INFO &oxidInfo)
{
    // extract the OXIDEntry from the objref
    OXIDEntry *pOXIDEntry = GetOXIDFromObjRef(objref);
    Win4Assert(pOXIDEntry);

    // fill in the fields of the OXID_INFO structure.
    pOXIDEntry->FillOXID_INFO(&oxidInfo);
    oxidInfo.dwAuthnHint     = gAuthnLevel;

    HRESULT hr = GetStringBindings(&oxidInfo.psa);
    ComDebErr(hr != S_OK, "GetStringBindings Failed.\n");
    return (hr);
}

#if DBG==1
//+-------------------------------------------------------------------
//
//  Member:     CRpcResolver::AssertValid
//
//  Synopsis:   validates the state of this object
//
//  History:    30-Oct-95   Rickhi      Created.
//
//--------------------------------------------------------------------
void CRpcResolver::AssertValid(void)
{
}
#endif // DBG


//+------------------------------------------------------------------------
//
//  Function:   MakeProxyHelper, public
//
//  Synopsis:   Creates a Proxy given bindings, a destination Process ID,
//              a destination MIDEntry, an AuthnLevel, and an IID.
//              Interface.
//
//  History:    14 Apr 95   AlexMit     Created  (as MakeSCMProxy)
//              24 Jun 96   SatishT     Generalized
//
//-------------------------------------------------------------------------
INTERNAL MakeProxyHelper(DUALSTRINGARRAY *psa, REFIID riid, DWORD dwAuthnHint,
                         DWORD ProcessID, void **ppProxy)
{
    ComDebOut((DEB_OXID, "MakeProxyHelper psa:%x ppProxy:%x\n", psa, ppProxy));

    Win4Assert(ProcessID != 0);

    // Init out parameter
    *ppProxy = NULL;

    // Make a fake oxidInfo for the SCM.
    OXID_INFO oxidInfo;
    oxidInfo.dwTid          = 0;
    oxidInfo.dwPid          = ProcessID;
    oxidInfo.version.MajorVersion = COM_MAJOR_VERSION;
    oxidInfo.version.MinorVersion = COM_MINOR_VERSION;
    oxidInfo.ipidRemUnknown = GUID_NULL;
    oxidInfo.dwFlags        = 0;
    oxidInfo.psa            = psa;
    oxidInfo.dwAuthnHint    = dwAuthnHint;

    // Make a fake OXID for the SCM. We can use any ID that the resolver
    // hands out as the OXID for the SCM.

    OXID oxid;
    HRESULT hr = gResolver.ServerGetReservedID(&oxid);

    if (SUCCEEDED(hr))
    {
        // make an entry in the OXID table for the SCM
        OXIDEntry *pOXIDEntry;
        hr = gOXIDTbl.MakeSCMEntry(oxid, &oxidInfo, &pOXIDEntry);

        if (SUCCEEDED(hr))
        {
            // Make an object reference for the SCM. The oid and ipid dont
            // matter, except the OID must be machine-unique.

            OBJREF objref;
            hr = MakeFakeObjRef(objref, pOXIDEntry, GUID_NULL, riid);
            if (SUCCEEDED(hr))
            {
                // now unmarshal the objref to create a proxy to the SCM.
                // use the internal form to reduce initialization time.
                hr = UnmarshalInternalObjRef(objref, ppProxy);
            }

            // release the reference to the OXIDEntry from AddEntry, since
            // UnmarshalInternalObjRef added another one if it was successful.
            pOXIDEntry->DecRefCnt();
        }
    }

    ComDebOut((DEB_OXID, "MakeProxyHelper hr:%x *ppProxy:%x\n", hr, *ppProxy));
    return hr;
}

//+------------------------------------------------------------------------
//
//  Function:   MakeSCMProxy, public
//
//  Synopsis:   Creates an OXIDEntry and a proxy for the SCM Activation
//              Interface.
//
//  History:    14 Apr 95   AlexMit     Created
//              24 Jun 96   SatishT     Modified to use MakeProxyHelper
//
//-------------------------------------------------------------------------
INTERNAL MakeSCMProxy(DUALSTRINGARRAY *psaSCM, REFIID riid, void **ppSCM)
{
    ComDebOut((DEB_OXID, "MakeSCMProxy psaSCM:%x ppSCM:%x\n", psaSCM, ppSCM));

    Win4Assert(gdwScmProcessID != 0);

    // Call MakeProxyHelper to do the real work
    HRESULT hr = MakeProxyHelper(psaSCM,
                         riid,
                         RPC_C_AUTHN_LEVEL_CONNECT,
                         gdwScmProcessID,
                         ppSCM);


    if (SUCCEEDED(hr) && (
           (gImpLevel != RPC_C_IMP_LEVEL_IMPERSONATE) ||
           (gCapabilities & ANY_CLOAKING) ) )
    {
        // Make sure SCM can impersonate us. If the process is using either
        // static or dynamic cloaking, we want the SCM connection to use
        // dynamic cloaking since the user will expect us to do activation
        // using the current thread token in either case.

        hr = CoSetProxyBlanket( (IUnknown *) *ppSCM,
                               RPC_C_AUTHN_WINNT,
                               RPC_C_AUTHZ_NONE, NULL,
                               RPC_C_AUTHN_LEVEL_CONNECT,
                               RPC_C_IMP_LEVEL_IMPERSONATE,
                               NULL,
                               gCapabilities & ANY_CLOAKING ?
                                   EOAC_DYNAMIC_CLOAKING : EOAC_NONE );

        if (FAILED(hr))
        {
            ((IUnknown *) (*ppSCM))->Release();
            *ppSCM = NULL;
        }
    }

    ComDebOut((DEB_OXID, "MakeSCMProxy hr:%x *ppSCM:%x\n", hr, *ppSCM));
    return hr;
}


//+-------------------------------------------------------------------------
//
//  Member:     CRpcResolver::BindToSCMProxy
//
//  Synopsis:   Get a proxy to the SCM Activation interface.
//
//  History:    19-May-95 Rickhi    Created
//
//  Notes:      The SCM activation interface is an ORPC interface so that
//              apartment model apps can receive callbacks and do cancels
//              while activating object servers.
//
//--------------------------------------------------------------------------
HRESULT CRpcResolver::BindToSCMProxy()
{
    ComDebOut((DEB_ACTIVATE, "CRpcResolver::BindToSCMProxy\n"));

    // since we are calling out on this thread, we have to ensure that the
    // call control is set up for this thread.

    HRESULT hr = InitChannelIfNecessary();
    if (SUCCEEDED(hr))
    {
        // ensure we have connected to the resolver
        hr = GetConnection();
        if (SUCCEEDED(hr))
        {
            // single-thread access to this, don't use the _mxsResolver
            // lock since UnmarshalObjRef will assert that it is not
            // taken.
            COleStaticLock lck(g_mxsSingleThreadOle);

            if (_pSCMProxy == NULL)
            {
                // Make a proxy to the SCM
                hr = MakeSCMProxy((DUALSTRINGARRAY *)&saSCM, IID_ISCMLocalActivator, (void **) &_pSCMProxy);
            }
        }
    }

    ComDebOut((SUCCEEDED(hr) ? DEB_SCM : DEB_ERROR,
        "CRpcResolver::BindToSCMProxy for ISCMLocalActivator returns %x.\n", hr));
    return hr;
}

//+-------------------------------------------------------------------------
//
//  Member:     CRpcResolver::NotifySurrogateStarted
//
//  Synopsis:   Notify the SCM that a COM+ surrogate has been started
//
//  Arguments:  [pProcessActivatorToken] - class started
//              [dwFlags] - whether class is multiple use or not.
//
//  History:    02-Apr-98 SatishT    Created
//
//--------------------------------------------------------------------------
HRESULT CRpcResolver::NotifySurrogateStarted(
                        ProcessActivatorToken   *pProcessActivatorToken
                        )
{
    ComDebOut((DEB_ACTIVATE, "CRpcResolver::NotifySurrogateStarted\n"));

    // Bind to the SCM if that hasn't already happened
    HRESULT hr = GetConnection();
    if (FAILED(hr))
        return hr;

    // Tell SCM that we are started
    error_status_t rpcstat;

    do
    {
        hr = ProcessActivatorStarted(
                _hRpc,
                _ph,
                pProcessActivatorToken,
                &rpcstat );

    } while (RetryRPC(rpcstat));

    if (rpcstat != RPC_S_OK)
    {
        hr = HRESULT_FROM_WIN32(rpcstat);
    }

    ComDebOut(( (hr == S_OK) ? DEB_SCM : DEB_ERROR,
              "CRpcResolver::NotifySurrogateStarted returned %x\n", hr));
    return hr;
}

//+-------------------------------------------------------------------------
//
//  Member:     CRpcResolver::NotifySurrogateInitializing
//
//  Synopsis:   Notify the SCM that a class has been started
//
//  Arguments:  [rclsid] - class started
//              [dwFlags] - whether class is multiple use or not.
//
//  History:    02-Apr-98 SatishT    Created
//
//--------------------------------------------------------------------------
HRESULT CRpcResolver::NotifySurrogateInitializing()
{
    ComDebOut((DEB_ACTIVATE, "CRpcResolver::NotifySurrogateInitializing\n"));

    error_status_t rpcstat = RPC_S_OK;
    HRESULT hr = S_OK;

    do
    {
        hr = ProcessActivatorInitializing(_hRpc,_ph,&rpcstat);
    }
    while (RetryRPC(rpcstat));

    if (rpcstat != RPC_S_OK)
    {
        hr = HRESULT_FROM_WIN32(rpcstat);
    }

    ComDebOut(( (hr == S_OK) ? DEB_SCM : DEB_ERROR,
              "CRpcResolver::NotifySurrogateInitializing returned %x\n", hr));
    return hr;
}

//+-------------------------------------------------------------------------
//
//  Member:     CRpcResolver::NotifySurrogateReady
//
//  Synopsis:   Notify the SCM that a class has been started
//
//  Arguments:  [rclsid] - class started
//              [dwFlags] - whether class is multiple use or not.
//
//  History:    02-Apr-98 SatishT    Created
//
//--------------------------------------------------------------------------
HRESULT CRpcResolver::NotifySurrogateReady()
{
    ComDebOut((DEB_ACTIVATE, "CRpcResolver::NotifySurrogateReady\n"));

    error_status_t rpcstat = RPC_S_OK;
    HRESULT hr = S_OK;

    do
    {
        hr = ProcessActivatorReady(_hRpc,_ph,&rpcstat);
    }
    while (RetryRPC(rpcstat));

    if (rpcstat != RPC_S_OK)
    {
        hr = HRESULT_FROM_WIN32(rpcstat);
    }

    ComDebOut(( (hr == S_OK) ? DEB_SCM : DEB_ERROR,
              "CRpcResolver::NotifySurrogateReady returned %x\n", hr));
    return hr;
}

//+-------------------------------------------------------------------------
//
//  Member:     CRpcResolver::NotifySurrogateStopped
//
//  Synopsis:   Notify the SCM that a class has been started
//
//  Arguments:  [rclsid] - class started
//              [dwFlags] - whether class is multiple use or not.
//
//  History:    02-Apr-98 SatishT    Created
//
//--------------------------------------------------------------------------
HRESULT CRpcResolver::NotifySurrogateStopped()
{
    ComDebOut((DEB_ACTIVATE, "CRpcResolver::NotifySurrogateStopped\n"));

    error_status_t rpcstat = RPC_S_OK;
    HRESULT hr = S_OK;

    do
    {
        hr = ProcessActivatorStopped(_hRpc,_ph,&rpcstat);
    }
    while (RetryRPC(rpcstat));

    if (rpcstat != RPC_S_OK)
    {
        hr = HRESULT_FROM_WIN32(rpcstat);
    }

    ComDebOut(( (hr == S_OK) ? DEB_SCM : DEB_ERROR,
              "CRpcResolver::NotifySurrogateStopped returned %x\n", hr));
    return hr;
}

//+-------------------------------------------------------------------------
//
//  Member:     CRpcResolver::NotifySurrogatePaused
//
//  Synopsis:   Notify the SCM that this surrogate process has been paused.
//
//  Arguments:  none
//
//  History:    09-Jan-00 JSimmons  Created
//
//--------------------------------------------------------------------------
HRESULT CRpcResolver::NotifySurrogatePaused()
{
    ComDebOut((DEB_ACTIVATE, "CRpcResolver::NotifySurrogatePaused\n"));

    error_status_t rpcstat = RPC_S_OK;
    HRESULT hr = S_OK;

    do
    {
        hr = ProcessActivatorPaused(_hRpc,_ph,&rpcstat);
    }
    while (RetryRPC(rpcstat));

    if (rpcstat != RPC_S_OK)
    {
        hr = HRESULT_FROM_WIN32(rpcstat);
    }

    ComDebOut(( (hr == S_OK) ? DEB_SCM : DEB_ERROR,
              "CRpcResolver::NotifySurrogatePaused returned %x\n", hr));
    return hr;
}

//+-------------------------------------------------------------------------
//
//  Member:     CRpcResolver::NotifySurrogateResumed
//
//  Synopsis:   Notify the SCM that this surrogate process has been resumed.
//
//  Arguments:  none
//
//  History:    09-Jan-00 JSimmons  Created
//
//--------------------------------------------------------------------------
HRESULT CRpcResolver::NotifySurrogateResumed()
{
    ComDebOut((DEB_ACTIVATE, "CRpcResolver::NotifySurrogateResume\n"));

    error_status_t rpcstat = RPC_S_OK;
    HRESULT hr = S_OK;

    do
    {
        hr = ProcessActivatorResumed(_hRpc,_ph,&rpcstat);
    }
    while (RetryRPC(rpcstat));

    if (rpcstat != RPC_S_OK)
    {
        hr = HRESULT_FROM_WIN32(rpcstat);
    }

    ComDebOut(( (hr == S_OK) ? DEB_SCM : DEB_ERROR,
              "CRpcResolver::NotifySurrogateResume returned %x\n", hr));
    return hr;
}


//+-------------------------------------------------------------------------
//
//  Member:     CRpcResolver::NotifySurrogateUserInitializing
//
//  Synopsis:   Notify the SCM that this surrogate process is entering
//              the initializing state.
//
//  History:    24-May-01 JohnDoty    Created
//
//--------------------------------------------------------------------------
HRESULT CRpcResolver::NotifySurrogateUserInitializing()
{
    ComDebOut((DEB_ACTIVATE, "CRpcResolver::NotifySurrogateInitializing\n"));

    error_status_t rpcstat = RPC_S_OK;
    HRESULT hr = S_OK;

    do
    {
        hr = ProcessActivatorUserInitializing(_hRpc,_ph,&rpcstat);
    }
    while (RetryRPC(rpcstat));

    if (rpcstat != RPC_S_OK)
    {
        hr = HRESULT_FROM_WIN32(rpcstat);
    }

    ComDebOut(( (hr == S_OK) ? DEB_SCM : DEB_ERROR,
              "CRpcResolver::NotifySurrogateInitializing returned %x\n", hr));
    return hr;
}

//+-------------------------------------------------------------------------
//
//  Member:     CRpcResolver::NotifyStarted
//
//  Synopsis:   Notify the SCM that a class has been started
//
//  Arguments:  [rclsid] - class started
//              [dwFlags] - whether class is multiple use or not.
//
//  History:    19-May-92 Ricksa    Created
//
//--------------------------------------------------------------------------
HRESULT CRpcResolver::NotifyStarted(
    RegInput   *pRegIn,
    RegOutput **ppRegOut)
{
    ComDebOut((DEB_ACTIVATE, "CRpcResolver::NotifyStarted\n"));

    // Bind to the SCM if that hasn't already happened
    HRESULT hr = GetConnection();
    if (FAILED(hr))
        return hr;

    // Tell SCM that we are started
    error_status_t rpcstat;

    do
    {
        hr = ServerRegisterClsid(
                _hRpc,
                _ph,
                pRegIn,
                ppRegOut,
                &rpcstat );

    } while (RetryRPC(rpcstat));

    ComDebOut(( (hr == S_OK) ? DEB_SCM : DEB_ERROR,
              "Class Registration returned %x\n", hr));

    if (rpcstat != RPC_S_OK)
    {
        hr = HRESULT_FROM_WIN32(rpcstat);
    }

    if (LogEventIsActive())
    {
        LogEventClassRegistration(hr, pRegIn, *ppRegOut);
    }
    return hr;
}

//+-------------------------------------------------------------------------
//
//  Member:     CRpcResolver::NotifyStopped
//
//  Synopsis:   Notify the SCM that the server is stopped.
//
//  History:    19-May-92 Ricksa    Created
//
//--------------------------------------------------------------------------
void CRpcResolver::NotifyStopped(
    REFCLSID rclsid,
    DWORD dwReg)
{
    ComDebOut((DEB_ACTIVATE, "CRpcResolver::NotifyStopped\n"));
    Win4Assert(IsConnected());

    error_status_t rpcstat;

    RevokeClasses revcls;
    revcls.dwSize = 1;
    revcls.revent[0].clsid = rclsid;
    revcls.revent[0].dwReg = dwReg;

    do
    {
        ServerRevokeClsid(
                        _hRpc,
                        _ph,
                        &revcls,
                        &rpcstat);

    } while (RetryRPC(rpcstat));

    if (LogEventIsActive())
    {
        LogEventClassRevokation(rclsid, dwReg);
    }
}


//+-------------------------------------------------------------------------
//
//  Member:     CRpcResolver::GetClassObject
//
//  Synopsis:   Send a get object request to the SCM
//
//  Arguments:  [rclsid] - class id for class object
//              [dwCtrl] - type of server required
//              [ppIFDClassObj] - marshaled buffer for class object
//              [ppwszDllToLoad] - DLL name to use for server
//
//  Returns:    S_OK
//
//  History:    20-May-93 Ricksa    Created
//
//--------------------------------------------------------------------------
HRESULT CRpcResolver::GetClassObject(
    IActivationPropertiesIn   * pInActivationProperties,
    IActivationPropertiesOut **ppActOut
)
{
    ComDebOut((DEB_ACTIVATE, "CRpcResolver::GetClassObject\n"));

    HRESULT                   hr;
    OXID                      OxidServer;
    DUALSTRINGARRAY         * pssaServerObjectResolverBindings;
    OXID_INFO                 OxidInfo;
    MID                       LocalMidOfRemote;
    OXIDEntry               * pOxidEntry;
    LPWSTR                    pwszWinstaDesktop;
    PRIV_SCM_INFO             PrivateScmInfo;

    IInstantiationInfo         * pInstantiationInfo = NULL;           // input
    ILegacyInfo                * pLegacyInfo = NULL;                  // input
    IActivationPropertiesOut   * pOutActivationProperties = NULL;     // output
    IScmRequestInfo            * pInScmResolverInfo = NULL;
    IScmReplyInfo              * pOutScmResolverInfo = NULL;
    PRIV_RESOLVER_INFO         * pPrivateResolverInfo = NULL;
    ISpecialSystemProperties   * pSpecialSystemProperties = NULL;

    hr = BindToSCMProxy();
    if (FAILED(hr))
        return hr;
	
    hr = SetImpersonatingFlag(pInActivationProperties);
    if (FAILED(hr))
        return hr;

    memset(&PrivateScmInfo, 0, sizeof(PrivateScmInfo));

    PrivateScmInfo.Apartment = IsSTAThread();
    PrivateScmInfo.pwszWinstaDesktop = _pwszWinstaDesktop;    
    PrivateScmInfo.ProcessSignature = _ProcessSignature;

    hr = pInActivationProperties->QueryInterface(
                                        IID_ILegacyInfo,
                                        (LPVOID*)&pLegacyInfo
                                        );
    if (hr != S_OK)
        return hr;

    COSERVERINFO *pServerInfo = NULL;
    pLegacyInfo->GetCOSERVERINFO(&pServerInfo);
    pLegacyInfo->Release();

    if ( ! GetEnvBlock( &PrivateScmInfo ) )
        return E_OUTOFMEMORY;

    hr = pInActivationProperties->QueryInterface(IID_IScmRequestInfo,
                                                 (LPVOID*)&pInScmResolverInfo);
    if (FAILED(hr))
    {
       if ( PrivateScmInfo.pEnvBlock )
           FreeEnvironmentStringsW( PrivateScmInfo.pEnvBlock );
       return hr;
    }

    pInScmResolverInfo->SetScmInfo(&PrivateScmInfo);
    pInScmResolverInfo->Release();

    //
    // Set the default authentication level for remote activations.
    // This needs to be set here, since we can't be sure that security
    // has even been initialized until now.  (Security gets initialzied
    // with the first apartment that starts, at the latest.)
    //
    hr = pInActivationProperties->QueryInterface(IID_ISpecialSystemProperties,
                                                 (LPVOID*)&pSpecialSystemProperties);
    if (FAILED(hr))
    {
       if ( PrivateScmInfo.pEnvBlock )
           FreeEnvironmentStringsW( PrivateScmInfo.pEnvBlock );
       return hr;
    }
    
    pSpecialSystemProperties->SetDefaultAuthenticationLevel(gAuthnLevel);
    pSpecialSystemProperties->Release();

    hr = GetSCM()->GetClassObject(
                        (IActivationPropertiesIn*)pInActivationProperties,
                        (IActivationPropertiesOut**)&pOutActivationProperties
                        );
    *ppActOut = pOutActivationProperties;

    if ( FAILED(hr) )
    {
        ComDebOut((DEB_ACTIVATE, "CRpcResolver::GetClassObject hr:%x\n", hr));
        if ( PrivateScmInfo.pEnvBlock )
            FreeEnvironmentStringsW( PrivateScmInfo.pEnvBlock );
        return hr;
    }
    else
    {
        Win4Assert(pOutActivationProperties &&
            "CRpcResolver::GetClassObject Succeeded but returned NULL pOutActivationProperties");
    }

    hr = pOutActivationProperties->QueryInterface(IID_IScmReplyInfo,
                                                 (LPVOID*)&pOutScmResolverInfo);
    if (FAILED(hr))
    {
       if ( PrivateScmInfo.pEnvBlock )
           FreeEnvironmentStringsW( PrivateScmInfo.pEnvBlock );
       return hr;
    }

    pOutScmResolverInfo->GetResolverInfo(&pPrivateResolverInfo);
    pOutScmResolverInfo->Release();

    if ( PrivateScmInfo.pEnvBlock )
        FreeEnvironmentStringsW( PrivateScmInfo.pEnvBlock );
    
    if (pPrivateResolverInfo == NULL)
        return S_OK;


    // If no resolver info or OXID, then we must have a custom marshalled objref
    if ((!pPrivateResolverInfo) || (pPrivateResolverInfo->OxidServer == 0))
        return S_OK;

    Win4Assert(pPrivateResolverInfo->pServerORBindings != NULL);            

    {
        pOxidEntry = 0;
        hr = gOXIDTbl.FindOrCreateOXIDEntry(
            pPrivateResolverInfo->OxidServer,
            pPrivateResolverInfo->OxidInfo,
            FOCOXID_REF,
            pPrivateResolverInfo->pServerORBindings,
            pPrivateResolverInfo->LocalMidOfRemote,
            NULL,
            0,
            NULL,
            RPC_C_AUTHN_DEFAULT,
            &pOxidEntry );

        //
        // CODEWORK CODEWORK CODEWORK
        //
        // These comments also apply to CreateInstance and GetPersistentInstance
        // methods.
        //
        // Releasing the OXID and reacquiring it makes me a little
        // nervous. The Expired list is fairly short, so if multiple guys are doing
        // this simultaneously, the entries could get lost.  I guess this is not
        // too bad since it should be rare and the local resolver will have it
        // anyway, but I think there is a window where the local resolver could
        // lose it too, forcing a complete roundtrip back to the server.
        //
        // A better mechanism may be to pass the iid and ppunk into this method
        // and do the unmarshal inside it. We could improve performance by calling
        // UnmarshalObjRef instead of putting a stream wrapper around the
        // MInterfacePointer and then calling CoUnmarshalInterface. It would avoid
        // looking up the OXIDEntry twice, and would avoid the race where we could
        // lose the OXIDEntry off the expired list.  It would require a small
        // change in UnmarshalObjRef to deal with the custom marshal case.
        //

        //
        // Decrement our ref.  The interface unmarshall will do a LookupOXID
        // which will increment the count and move the OXIDEntry back to the
        // InUse list.
        //
        if (pOxidEntry)
            pOxidEntry->DecRefCnt();
    }

    ComDebOut((DEB_ACTIVATE, "CRpcResolver::GetClassObject hr:%x\n", hr));
    return hr;
}

//+-------------------------------------------------------------------------
//
//  Member:     CRpcResolver::CreateInstance
//
//  Synopsis:   Legacy interface used by handlers
//
//  Arguments:
//
//  Returns:    S_OK
//
//  History:    20-May-93 Ricksa    Created
//
//--------------------------------------------------------------------------
HRESULT CRpcResolver::CreateInstance(
    COSERVERINFO *pServerInfo,
    CLSID *pClsid,
    DWORD dwClsCtx,
    DWORD dwCount,
    IID *pIIDs,
    DWORD *pdwDllServerModel,
    WCHAR **ppwszDllServer,
    MInterfacePointer **pRetdItfs,
    HRESULT *pRetdHrs
)
{
    ActivationPropertiesIn actIn;
    IActivationPropertiesOut *pActOut=NULL;

    DWORD actvflags = CComActivator::GetActvFlags(dwClsCtx);
    
    actIn.SetNotDelete();
    HRESULT hr = GetActivationPropertiesIn(
                        &actIn,
                        *pClsid,
                        dwClsCtx,
                        pServerInfo,
                        dwCount,
                        pIIDs,
                        actvflags,
                        NULL,
                        NULL);

    if (SUCCEEDED(hr))
    {
        hr = CreateInstance(&actIn, &pActOut);
        actIn.Release();

        if (SUCCEEDED(hr))
        {
            IScmReplyInfo        * pOutScmResolverInfo;

            Win4Assert(pActOut != NULL);

            hr = pActOut->QueryInterface(IID_IScmReplyInfo,(LPVOID*)&pOutScmResolverInfo);
            if (FAILED(hr))
            {
                pActOut->Release();
                return hr;
            }

            PRIV_RESOLVER_INFO      * pPrivateResolverInfo;
            hr = pOutScmResolverInfo->GetResolverInfo(&pPrivateResolverInfo);
            Win4Assert(SUCCEEDED(hr));

            pOutScmResolverInfo->Release();

            if (pPrivateResolverInfo == NULL)
            {
                pActOut->Release();
                return E_UNEXPECTED;
            }

            *pdwDllServerModel = pPrivateResolverInfo->DllServerModel;
            *ppwszDllServer = pPrivateResolverInfo->pwszDllServer;

            IPrivActivationPropertiesOut *pPrivOut;
            hr = pActOut->QueryInterface(IID_IPrivActivationPropertiesOut,
                                                   (LPVOID*)&pPrivOut);
            if (FAILED(hr))
            {
                pActOut->Release();
                return hr;
            }

            DWORD count;
            IID *piids=0;
            hr = pPrivOut->GetMarshalledResults(&count, &piids, &pRetdHrs, &pRetdItfs);

            pPrivOut->Release();

            pActOut->Release();
        }
    }

    return hr;
}

//+-------------------------------------------------------------------------
//
//  Member:     CRpcResolver::CreateInstance
//
//  Synopsis:   Send a create instance request to the SCM
//
//  Arguments:
//
//  Returns:    S_OK
//
//  History:    20-May-93 Ricksa    Created
//
//--------------------------------------------------------------------------
HRESULT CRpcResolver::CreateInstance(
    IActivationPropertiesIn   * pInActivationProperties,
    IActivationPropertiesOut **ppActOut
)
{
    ComDebOut((DEB_ACTIVATE, "CRpcResolver::CreateInstance\n"));

    HRESULT hr = BindToSCMProxy();
    if (FAILED(hr))
        return hr;

    hr = SetImpersonatingFlag(pInActivationProperties);
    if (FAILED(hr))
        return hr;

    OXID_INFO           OxidInfo;
    OXIDEntry         * pOxidEntry;
    DUALSTRINGARRAY   * pssaServerObjectResolverBindings;
    PRIV_SCM_INFO       PrivateScmInfo;
    memset(&PrivateScmInfo, 0, sizeof(PRIV_SCM_INFO));

    IInstantiationInfo         * pInstantiationInfo = NULL;           // input
    ILegacyInfo                * pLegacyInfo = NULL;                  // input
    IActivationPropertiesOut   * pOutActivationProperties = NULL;     // output
    IScmRequestInfo            * pInScmResolverInfo = NULL;
    IScmReplyInfo              * pOutScmResolverInfo = NULL;
    PRIV_RESOLVER_INFO         * pPrivateResolverInfo = NULL;
    ISpecialSystemProperties   * pSpecialSystemProperties = NULL;

    PrivateScmInfo.Apartment = IsSTAThread();
    PrivateScmInfo.pwszWinstaDesktop = _pwszWinstaDesktop;
    PrivateScmInfo.ProcessSignature = _ProcessSignature;

    hr = pInActivationProperties->QueryInterface(
                                        IID_ILegacyInfo,
                                        (LPVOID*)&pLegacyInfo
                                        );
    if (FAILED(hr))
        return hr;

    COSERVERINFO *pServerInfo = NULL;

    pLegacyInfo->GetCOSERVERINFO(&pServerInfo);
    pLegacyInfo->Release();

    if ( ! GetEnvBlock( &PrivateScmInfo ) )
        return E_OUTOFMEMORY;

    hr = pInActivationProperties->QueryInterface(IID_IScmRequestInfo,
                                                 (LPVOID*)&pInScmResolverInfo);
    if (FAILED(hr))
    {
       if ( PrivateScmInfo.pEnvBlock )
           FreeEnvironmentStringsW( PrivateScmInfo.pEnvBlock );
       return hr;
    }

    pInScmResolverInfo->SetScmInfo(&PrivateScmInfo);
    pInScmResolverInfo->Release();

    //
    // Set the default authentication level for remote activations.
    // This needs to be set here, since we can't be sure that security
    // has even been initialized until now.  (Security gets initialzied
    // with the first apartment that starts, at the latest.)
    //
    hr = pInActivationProperties->QueryInterface(IID_ISpecialSystemProperties,
                                                 (LPVOID*)&pSpecialSystemProperties);
    if (FAILED(hr))
    {
       if ( PrivateScmInfo.pEnvBlock )
           FreeEnvironmentStringsW( PrivateScmInfo.pEnvBlock );
       return hr;
    }
    
    pSpecialSystemProperties->SetDefaultAuthenticationLevel(gAuthnLevel);
    pSpecialSystemProperties->Release();

    pssaServerObjectResolverBindings = 0;
    OxidInfo.psa = 0;
    pOxidEntry = 0;

    hr = GetSCM()->CreateInstance(
            NULL,
            (IActivationPropertiesIn*)pInActivationProperties,
            (IActivationPropertiesOut**)&pOutActivationProperties
        );

    *ppActOut = pOutActivationProperties;

    if ( FAILED(hr) )
    {
       if ( PrivateScmInfo.pEnvBlock )
           FreeEnvironmentStringsW( PrivateScmInfo.pEnvBlock );
        ComDebOut((DEB_ACTIVATE, "CRpcResolver::CreateInstance hr:%x\n", hr));
        return hr;
    }
    else
    {
        Win4Assert(pOutActivationProperties &&
            "CRpcResolver::CreateInstance Succeeded but returned NULL pOutActivationProperties");
    }

    if (pOutActivationProperties)
    {
        hr = pOutActivationProperties->QueryInterface(IID_IScmReplyInfo,
                                                 (LPVOID*)&pOutScmResolverInfo);
        if (FAILED(hr))
        {
           if ( PrivateScmInfo.pEnvBlock )
               FreeEnvironmentStringsW( PrivateScmInfo.pEnvBlock );
           return hr;
        }

        pOutScmResolverInfo->GetResolverInfo(&pPrivateResolverInfo);
        pOutScmResolverInfo->Release();

        if ( PrivateScmInfo.pEnvBlock )
            FreeEnvironmentStringsW( PrivateScmInfo.pEnvBlock );
        
        if (pPrivateResolverInfo==NULL)
            return E_UNEXPECTED;


        // If no resolver info, then we must have a custom marshalled objref
        if (pPrivateResolverInfo->OxidServer == 0)
            return S_OK;

        Win4Assert(pPrivateResolverInfo->pServerORBindings != NULL);            

        hr = gOXIDTbl.FindOrCreateOXIDEntry(
            pPrivateResolverInfo->OxidServer,
            pPrivateResolverInfo->OxidInfo,
            FOCOXID_REF,
            pPrivateResolverInfo->pServerORBindings,
            pPrivateResolverInfo->LocalMidOfRemote,
            NULL,
            0,
            NULL,
            RPC_C_AUTHN_DEFAULT,
            &pOxidEntry );

        CoTaskMemFree(OxidInfo.psa);
        CoTaskMemFree(pssaServerObjectResolverBindings);

        //
        // Decrement our ref.  The interface unmarshall will do a LookupOXID
        // which will increment the count and move the OXIDEntry back to the
        // InUse list.
        //

        if (pOxidEntry)
            pOxidEntry->DecRefCnt();
    }
    else
    {
       if ( PrivateScmInfo.pEnvBlock )
           FreeEnvironmentStringsW( PrivateScmInfo.pEnvBlock );
    }

    ComDebOut((DEB_ACTIVATE, "CRpcResolver::CreateInstance hr:%x\n", hr));
    return hr;
}

//+-------------------------------------------------------------------------
//
//  Member:     CRpcResolver::GetPersistentInstance
//
//  Synopsis:   Send a get object request to the SCM
//
//GAJGAJ - fix this comment block
//  Arguments:  [rclsid] - class id for class object
//              [dwCtrl] - type of server required
//              [ppIFDClassObj] - marshaled buffer for class object
//              [ppwszDllToLoad] - DLL name to use for server
//
//  Returns:    S_OK
//
//  History:    20-May-93 Ricksa    Created
//
//--------------------------------------------------------------------------
HRESULT CRpcResolver::GetPersistentInstance(
    IActivationPropertiesIn   * pInActivationProperties,
    IActivationPropertiesOut **ppActOut,
    BOOL *pFoundInROT)
{
    HRESULT hr = CreateInstance(pInActivationProperties,
                                ppActOut);
    IActivationPropertiesOut   * pOutActivationProperties = *ppActOut;
    if (pOutActivationProperties)
    {
        IScmReplyInfo        * pOutScmResolverInfo;
        PRIV_RESOLVER_INFO      * pPrivateResolverInfo;
        hr = pOutActivationProperties->QueryInterface(IID_IScmReplyInfo,
                                            (LPVOID*)&pOutScmResolverInfo);
        if (SUCCEEDED(hr))
        {
            hr = pOutScmResolverInfo->GetResolverInfo(&pPrivateResolverInfo);
            Win4Assert(SUCCEEDED(hr) && (pPrivateResolverInfo != NULL));

            *pFoundInROT = pPrivateResolverInfo->FoundInROT;
            pOutScmResolverInfo->Release();
        }
    }

    return hr;
}

//+-------------------------------------------------------------------------
//
//  Member:     CRpcResolver::IrotRegister
//
//  Synopsis:   Register an object in the ROT
//
//  Arguments:  [pmkeqbuf] - moniker compare buffer
//              [pifdObject] - marshaled interface for object
//              [pifdObjectName] - marshaled moniker
//              [pfiletime] - file time of last change
//              [dwProcessID] -
//              [psrkRegister] - output of registration
//
//  Returns:    S_OK
//
//  History:    28-Jan-95 Ricksa    Created
//
//--------------------------------------------------------------------------
HRESULT CRpcResolver::IrotRegister(
    MNKEQBUF *pmkeqbuf,
    InterfaceData *pifdObject,
    InterfaceData *pifdObjectName,
    FILETIME *pfiletime,
    DWORD dwProcessID,
    WCHAR *pwszServerExe,
    SCMREGKEY *psrkRegister)
{
    // Bind to the SCM if that hasn't already happened
    HRESULT hr = GetConnection();
    if (FAILED(hr))
        return hr;

    error_status_t rpcstat = RPC_S_OK;

    do
    {
        hr = ::IrotRegister(
            _hRpc,
            _ph,
            _pwszWinstaDesktop,
            pmkeqbuf,
            pifdObject,
            pifdObjectName,
            pfiletime,
            dwProcessID,
            pwszServerExe,
            psrkRegister,
            &rpcstat);
    } while (RetryRPC(rpcstat));

    if (rpcstat != RPC_S_OK)
    {
        hr = CO_E_SCM_RPC_FAILURE;
    }

    return hr;
}

//+-------------------------------------------------------------------------
//
//  Member:     CRpcResolver::IrotRevoke
//
//  Synopsis:   Call to SCM to revoke object from the ROT
//
//  Arguments:  [psrkRegister] - moniker compare buffer
//              [fServerRevoke] - whether server for object is revoking
//              [pifdObject] - where to put marshaled object
//              [pifdName] - where to put marshaled moniker
//
//  Returns:    S_OK
//
//  History:    28-Jan-95 Ricksa    Created
//
//--------------------------------------------------------------------------
HRESULT CRpcResolver::IrotRevoke(
    SCMREGKEY *psrkRegister,
    InterfaceData **ppifdObject,
    InterfaceData **ppifdName)
{
    // Bind to the SCM if that hasn't already happened
    HRESULT hr = GetConnection();
    if (FAILED(hr))
        return hr;

    error_status_t rpcstat = RPC_S_OK;

    do
    {
        hr = ::IrotRevoke(
            _hRpc,
            _ph,
            psrkRegister,
            ppifdObject,
            ppifdName,
            &rpcstat);

    } while (RetryRPC(rpcstat));

    if (rpcstat != RPC_S_OK)
    {
        hr = CO_E_SCM_RPC_FAILURE;
    }


    return hr;
}

//+-------------------------------------------------------------------------
//
//  Member:     CRpcResolver::IrotIsRunning
//
//  Synopsis:   Call to SCM to determine if object is in the ROT
//
//  Arguments:  [pmkeqbuf] - moniker compare buffer
//
//  Returns:    S_OK
//
//  History:    28-Jan-95 Ricksa    Created
//
//--------------------------------------------------------------------------
HRESULT CRpcResolver::IrotIsRunning(MNKEQBUF *pmkeqbuf)
{
    // Bind to the SCM if that hasn't already happened
    HRESULT hr = GetConnection();
    if (FAILED(hr))
        return hr;

    error_status_t rpcstat = RPC_S_OK;

    do
    {
        hr = ::IrotIsRunning(
                _hRpc,
                _ph,
                _pwszWinstaDesktop,
                pmkeqbuf,
                &rpcstat);

    } while (RetryRPC(rpcstat));

    if (rpcstat != RPC_S_OK)
    {
        hr = CO_E_SCM_RPC_FAILURE;
    }

    return hr;
}

//+-------------------------------------------------------------------------
//
//  Member:     CRpcResolver::IrotGetObject
//
//  Synopsis:   Call to SCM to determine if object is in the ROT
//
//  Arguments:  [dwProcessID] - process ID for object we want
//              [pmkeqbuf] - moniker compare buffer
//              [psrkRegister] - registration ID in SCM
//              [pifdObject] - marshaled interface for the object
//
//  Returns:    S_OK
//
//  History:    28-Jan-95 Ricksa    Created
//
//--------------------------------------------------------------------------
HRESULT CRpcResolver::IrotGetObject(
    DWORD dwProcessID,
    MNKEQBUF *pmkeqbuf,
    SCMREGKEY *psrkRegister,
    InterfaceData **pifdObject)
{
    // Bind to the SCM if that hasn't already happened
    HRESULT hr = GetConnection();
    if (FAILED(hr))
        return hr;

    error_status_t rpcstat = RPC_S_OK;

    do
    {
        hr = ::IrotGetObject(
                _hRpc,
                _ph,
                _pwszWinstaDesktop,
                dwProcessID,
                pmkeqbuf,
                psrkRegister,
                pifdObject,
                &rpcstat);

    } while (RetryRPC(rpcstat));

    if (rpcstat != RPC_S_OK)
    {
        hr = CO_E_SCM_RPC_FAILURE;
    }

    return hr;
}

//+-------------------------------------------------------------------------
//
//  Member:     CRpcResolver::IrotNoteChangeTime
//
//  Synopsis:   Call to SCM to set time of change for object in the ROT
//
//  Arguments:  [psrkRegister] - SCM registration ID
//              [pfiletime] - time of change
//
//  Returns:    S_OK
//
//  History:    28-Jan-95 Ricksa    Created
//
//--------------------------------------------------------------------------
HRESULT CRpcResolver::IrotNoteChangeTime(
    SCMREGKEY *psrkRegister,
    FILETIME *pfiletime)
{
    // Bind to the SCM if that hasn't already happened
    HRESULT hr = GetConnection();
    if (FAILED(hr))
        return hr;

    error_status_t rpcstat = RPC_S_OK;

    do
    {
        hr = ::IrotNoteChangeTime(
            _hRpc,
            _ph,
            psrkRegister,
            pfiletime,
            &rpcstat);

    } while (RetryRPC(rpcstat));

    if (rpcstat != RPC_S_OK)
    {
        hr = CO_E_SCM_RPC_FAILURE;
    }

    return hr;
}

//+-------------------------------------------------------------------------
//
//  Member:     CRpcResolver::IrotGetTimeOfLastChange
//
//  Synopsis:   Call to SCM to get time changed of object in the ROT
//
//  Arguments:  [pmkeqbuf] - moniker compare buffer
//              [pfiletime] - where to put time of last change
//
//  Returns:    S_OK
//
//  History:    28-Jan-95 Ricksa    Created
//
//--------------------------------------------------------------------------
HRESULT CRpcResolver::IrotGetTimeOfLastChange(
    MNKEQBUF *pmkeqbuf,
    FILETIME *pfiletime)
{
    // Bind to the SCM if that hasn't already happened
    HRESULT hr = GetConnection();
    if (FAILED(hr))
        return hr;

    error_status_t rpcstat = RPC_S_OK;

    do
    {
        hr = ::IrotGetTimeOfLastChange(
                _hRpc,
                _ph,
                _pwszWinstaDesktop,
                pmkeqbuf,
                pfiletime,
                &rpcstat);

    } while (RetryRPC(rpcstat));

    if (rpcstat != RPC_S_OK)
    {
        hr = CO_E_SCM_RPC_FAILURE;
    }

    return hr;
}

//+-------------------------------------------------------------------------
//
//  Member:     CRpcResolver::IrotEnumRunning
//
//  Synopsis:   Call to SCM to enumerate running objects in the ROT
//
//  Arguments:  [ppMkIFList] - output pointer to array of marshaled monikers
//
//  Returns:    S_OK
//
//  History:    28-Jan-95 Ricksa    Created
//
//--------------------------------------------------------------------------
HRESULT CRpcResolver::IrotEnumRunning(MkInterfaceList **ppMkIFList)
{
    // Bind to the SCM if that hasn't already happened
    HRESULT hr = GetConnection();
    if (FAILED(hr))
        return hr;

    error_status_t rpcstat = RPC_S_OK;

    do
    {
        hr = ::IrotEnumRunning(
                _hRpc,
                _ph,
                _pwszWinstaDesktop,
                ppMkIFList,
                &rpcstat);

    } while (RetryRPC(rpcstat));

    if (rpcstat != RPC_S_OK)
    {
        hr = CO_E_SCM_RPC_FAILURE;
    }

    return hr;
}

//+-------------------------------------------------------------------------
//
//  Member:     CRpcResolver::GetThreadID
//
//  Synopsis:   Get unique thread id from SCM.
//
//  Arguments:  [pThreadID] - Pointer to returned thread ID.
//
//  History:    22-Jan-96   Rickhi      Created
//--------------------------------------------------------------------------
void CRpcResolver::GetThreadID( DWORD * pThreadID )
{
    HRESULT hr;

    *pThreadID = 0;

    hr = GetConnection();
    if ( FAILED(hr) )
        return;

    //
    // If GetConnection does the initial connect to the SCM/OR then
    // our apartment thread id, which is aliased by pThreadID, will be set.
    //
    if ( *pThreadID != 0 )
        return;

    error_status_t rpcstat;

    do
    {
        ::GetThreadID( _hRpc, 
                       _ph,
                       pThreadID, 
                       &rpcstat );
    } while (RetryRPC(rpcstat));
}

//+-------------------------------------------------------------------------
//
//  Member:     CRpcResolver::UpdateActivationSettings
//
//  Synopsis:   Tells rpcss to re-read default activation keys/values.
//              Used by OLE test team.
//
//  Arguments:  none
//
//--------------------------------------------------------------------------
void CRpcResolver::UpdateActivationSettings()
{
    HRESULT hr;

    // Refresh the local catalog's COM+ enabled setting
    UpdateCOMPlusEnabled();

    hr = GetConnection();
    if ( FAILED(hr) )
        return;

    error_status_t rpcstat;

    do
    {
        ::UpdateActivationSettings( _hRpc, 
                                    _ph,
                                    &rpcstat );
    } while (RetryRPC(rpcstat));
}

//+-------------------------------------------------------------------------
//
//  Member:     CRpcResolver::RegisterWindowPropInterface
//
//  Synopsis:   Register window property interface with the SCM
//
//  Arguments:
//
//  History:    22-Jan-96   Rickhi      Created
//
//--------------------------------------------------------------------------
HRESULT CRpcResolver::RegisterWindowPropInterface(
    HWND       hWnd,
    STDOBJREF *pStd,
    OXID_INFO *pOxidInfo,
    DWORD_PTR *pdwCookie)
{
    // Bind to the SCM if that hasn't already happened
    HRESULT hr = GetConnection();
    if (FAILED(hr))
        return hr;

    error_status_t rpcstat;

    do
    {
        hr = ::RegisterWindowPropInterface(_hRpc, 
                                           _ph,
                                           (DWORD_PTR)hWnd,
                                           pStd, 
                                           pOxidInfo, 
                                           pdwCookie, 
                                           &rpcstat);
    } while (RetryRPC(rpcstat));

    ComDebOut(( (hr == S_OK) ? DEB_SCM : DEB_ERROR,
            "RegisterWindowPropInterface returned %x\n", hr));

    if (rpcstat != RPC_S_OK)
    {
        return HRESULT_FROM_WIN32(rpcstat);
    }

    return hr;
}

//+-------------------------------------------------------------------------
//
//  Member:     CRpcResolver::RegisterWindowPropInterface
//
//  Synopsis:   Get (and possibly Revoke) window property interface
//              registration with the SCM.
//
//  Arguments:
//
//  History:    22-Jan-96   Rickhi      Created
//
//--------------------------------------------------------------------------
HRESULT CRpcResolver::GetWindowPropInterface(
    HWND       hWnd,
    DWORD_PTR  dwCookie,
    BOOL       fRevoke,
    STDOBJREF *pStd,
    OXID_INFO *pOxidInfo)
{
    // Bind to the SCM if that hasn't already happened
    HRESULT hr = GetConnection();
    if (FAILED(hr))
        return hr;

    error_status_t rpcstat;

    do
    {
        hr = ::GetWindowPropInterface(_hRpc, 
                                      _ph,
                                      (DWORD_PTR)hWnd, 
                                      dwCookie, 
                                      fRevoke,
                                      pStd, 
                                      pOxidInfo, 
                                      &rpcstat);
    } while (RetryRPC(rpcstat));

    ComDebOut(( (hr == S_OK) ? DEB_SCM : DEB_ERROR,
            "GetWindowPropInterface returned %x\n", hr));

    if (rpcstat != RPC_S_OK)
    {
        return HRESULT_FROM_WIN32(rpcstat);
    }

    return hr;
}

//+-------------------------------------------------------------------------
//
//  Member:     CRpcResolver::EnableDisableDynamicIPTracking
//
//  Purpose:    Tells the SCM to start or stop dynamic address change tracking.
//
//  Returns:    hresult
//
//  History:    07-Oct-00 Jsimmons  Created
//
//--------------------------------------------------------------------------
HRESULT CRpcResolver::EnableDisableDynamicIPTracking(BOOL fEnable)
{
    // Bind to the SCM if that hasn't already happened
    HRESULT hr = GetConnection();
    if (FAILED(hr))
        return hr;

    error_status_t rpcstat;

    do
    {
        hr = ::EnableDisableDynamicIPTracking(_hRpc, _ph, fEnable, &rpcstat);
    } while (RetryRPC(rpcstat));

    ComDebOut(( (hr == S_OK) ? DEB_SCM : DEB_ERROR,
            "EnableDisableDynamicIPTracking returned %x\n", hr));

    if (rpcstat != RPC_S_OK)
    {
        return HRESULT_FROM_WIN32(rpcstat);
    }

    return hr;
}


//+-------------------------------------------------------------------------
//
//  Member:     CRpcResolver::GetCurrentAddrExclusionList
//
//  Purpose:    Retrieves the contents of the current IP exclusion list
//
//  Returns:    hresult
//
//  History:    09-Oct-00 Jsimmons  Created
//
//--------------------------------------------------------------------------
HRESULT CRpcResolver::GetCurrentAddrExclusionList(
        DWORD* pdwNumStrings,
        LPWSTR** ppszStrings)
{
    // Bind to the SCM if that hasn't already happened
    HRESULT hr = GetConnection();
    if (FAILED(hr))
        return hr;

    error_status_t rpcstat;

    do
    {
        hr = ::GetCurrentAddrExclusionList(_hRpc, _ph, pdwNumStrings, ppszStrings, &rpcstat);

    } while (RetryRPC(rpcstat));

    ComDebOut(( (hr == S_OK) ? DEB_SCM : DEB_ERROR,
            "GetCurrentAddrExclusionList returned %x\n", hr));

    if (rpcstat != RPC_S_OK)
    {
        return HRESULT_FROM_WIN32(rpcstat);
    }

    return hr;
}

//+-------------------------------------------------------------------------
//
//  Member:     CRpcResolver::SetAddrExclusionList
//
//  Purpose:    Sets the contents of the current IP exclusion list
//
//  Returns:    hresult
//
//  History:    09-Oct-00 Jsimmons  Created
//
//--------------------------------------------------------------------------
HRESULT CRpcResolver::SetAddrExclusionList(
        DWORD dwNumStrings,
        LPWSTR* pszStrings)
{
    // Bind to the SCM if that hasn't already happened
    HRESULT hr = GetConnection();
    if (FAILED(hr))
        return hr;

    error_status_t rpcstat;

    do
    {
        hr = ::SetAddrExclusionList(_hRpc, _ph, dwNumStrings, pszStrings, &rpcstat);
    } while (RetryRPC(rpcstat));

    ComDebOut(( (hr == S_OK) ? DEB_SCM : DEB_ERROR,
            "SetAddrExclusionList returned %x\n", hr));

    if (rpcstat != RPC_S_OK)
    {
        return HRESULT_FROM_WIN32(rpcstat);
    }

    return hr;
}


//+-------------------------------------------------------------------------
//
//  Member:     CRpcResolver::FlushSCMBindings
//
//  Purpose:    Tells the SCM to flush its binding handle cache for the 
//              specified server.
//
//  Returns:    hresult
//
//  History:    21-May-00 Jsimmons  Created
//
//--------------------------------------------------------------------------
HRESULT CRpcResolver::FlushSCMBindings(WCHAR* pszMachineName)
{
    // Bind to the SCM if that hasn't already happened
    HRESULT hr = GetConnection();
    if (FAILED(hr))
        return hr;

    error_status_t rpcstat;

    do
    {
        hr = ::FlushSCMBindings(_hRpc, _ph, pszMachineName, &rpcstat);

    } while (RetryRPC(rpcstat));

    ComDebOut(( (hr == S_OK) ? DEB_SCM : DEB_ERROR,
            "FlushSCMBindings returned %x\n", hr));

    if (rpcstat != RPC_S_OK)
    {
        return HRESULT_FROM_WIN32(rpcstat);
    }

    return hr;
}

//+-------------------------------------------------------------------------
//
//  Member:     CRpcResolver::RetireServer
//
//  Purpose:    Tells the SCM that this process is to be no longer used for
//              any activations whatsoever.
//
//  Returns:    hresult
//
//  History:    21-May-00 Jsimmons  Created
//
//--------------------------------------------------------------------------
HRESULT CRpcResolver::RetireServer(GUID* pguidProcessIdentifier)
{
    // Bind to the SCM if that hasn't already happened
    HRESULT hr = GetConnection();
    if (FAILED(hr))
        return hr;

    error_status_t rpcstat;

    do
    {
        hr = ::RetireServer(_hRpc, _ph, pguidProcessIdentifier, &rpcstat);

    } while (RetryRPC(rpcstat));

    ComDebOut(( (hr == S_OK) ? DEB_SCM : DEB_ERROR,
            "RetireServer returned %x\n", hr));

    if (rpcstat != RPC_S_OK)
    {
        return HRESULT_FROM_WIN32(rpcstat);
    }

    return hr;
}

//+-------------------------------------------------------------------------
//
//  Member:     CRpcResolver::GetThreadWinstaDesktop
//
//  Purpose:    Get the string representing the winsta\desktop for this
//              thread.
//
//  Returns:    String with winsta\desktop name.
//
//  History:    11-Nov-93 Ricksa    Created
//                 Apr-96 DKays     Return winsta\desktop pair
//
//--------------------------------------------------------------------------
DWORD CRpcResolver::GetThreadWinstaDesktop()
{
    HWINSTA hWinsta;
    HDESK   hDesk;
    WCHAR   wszWinsta[32];
    WCHAR   wszDesktop[32];
    LPWSTR  pwszWinsta;
    LPWSTR  pwszDesktop;
    DWORD   WinstaSize;
    DWORD   DesktopSize;
    DWORD   Length;
    BOOL    Status;
    DWORD   Result;

    hWinsta = GetProcessWindowStation();

    if ( ! hWinsta )
        return GetLastError();

    hDesk = GetThreadDesktop(GetCurrentThreadId());

    if ( ! hDesk )
        return GetLastError();

    pwszWinsta = wszWinsta;
    pwszDesktop = wszDesktop;

    Length = sizeof(wszWinsta);

    Status = GetUserObjectInformation(
                hWinsta,
                UOI_NAME,
                pwszWinsta,
                Length,
                &Length );

    if ( ! Status )
    {
        Result = GetLastError();
        if ( Result != ERROR_INSUFFICIENT_BUFFER )
            goto WinstaDesktopExit;

        pwszWinsta = (LPWSTR)PrivMemAlloc( Length );
        if ( ! pwszWinsta )
        {
            Result = ERROR_OUTOFMEMORY;
            goto WinstaDesktopExit;
        }

        Status = GetUserObjectInformation(
                    hWinsta,
                    UOI_NAME,
                    pwszWinsta,
                    Length,
                    &Length );

        if ( ! Status )
        {
            Result = GetLastError();
            goto WinstaDesktopExit;
        }
    }

    Length = sizeof(wszDesktop);

    Status = GetUserObjectInformation(
                hDesk,
                UOI_NAME,
                pwszDesktop,
                Length,
                &Length );

    if ( ! Status )
    {
        Result = GetLastError();
        if ( Result != ERROR_INSUFFICIENT_BUFFER )
            goto WinstaDesktopExit;

        pwszDesktop = (LPWSTR)PrivMemAlloc( Length );
        if ( ! pwszDesktop )
        {
            Result = ERROR_OUTOFMEMORY;
            goto WinstaDesktopExit;
        }

        Status = GetUserObjectInformation(
                    hDesk,
                    UOI_NAME,
                    pwszDesktop,
                    Length,
                    &Length );

        if ( ! Status )
        {
            Result = GetLastError();
            goto WinstaDesktopExit;
        }
    }

    _pwszWinstaDesktop = (WCHAR *)
    PrivMemAlloc( (lstrlenW(pwszWinsta) + 1 + lstrlenW(pwszDesktop) + 1) * sizeof(WCHAR) );

    if ( _pwszWinstaDesktop )
    {
        lstrcpyW( _pwszWinstaDesktop, pwszWinsta );
        lstrcatW( _pwszWinstaDesktop, L"\\" );
        lstrcatW( _pwszWinstaDesktop, pwszDesktop );
        Result = S_OK;
    }
    else
    {
        Result = ERROR_OUTOFMEMORY;
    }

WinstaDesktopExit:

    if ( pwszWinsta != wszWinsta )
        PrivMemFree( pwszWinsta );

    if ( pwszDesktop != wszDesktop )
        PrivMemFree( pwszDesktop );

    // There have been some stress failures where _pwszWinstaDesktop
    // was NULL and result was zero.  Handle that case for now, but try
    // to catch it after NT 5 ships.
    Win4Assert( Result != 0 || _pwszWinstaDesktop != NULL );
    if (Result == 0 && _pwszWinstaDesktop == NULL)
        Result = ERROR_OUTOFMEMORY;
    return Result;
}


// 
// The SCM needs to know if this client thread was impersonating or not.   We 
// store that information here in the outgoing activation blob.
// 
HRESULT CRpcResolver::SetImpersonatingFlag(IActivationPropertiesIn* pIActPropsIn)
{
    HRESULT hr;
    BOOL bResult;
    ISpecialSystemProperties* pISSP = NULL;
    HANDLE hToken = NULL;
    
    bResult = OpenThreadToken(GetCurrentThread(), TOKEN_READ, TRUE, &hToken);
    if (!bResult)
    {
        DWORD dwGLE = GetLastError();
        
        // Okay if it failed due to no token on the thread;  blob data is FALSE
        // by default so no need to set it explicitly to that.
        hr = (dwGLE == ERROR_NO_TOKEN) ?  S_OK : HRESULT_FROM_WIN32(dwGLE);
    }
    else
    {
        // Thread is impersonating
        CloseHandle(hToken);

        hr = pIActPropsIn->QueryInterface(IID_ISpecialSystemProperties, (void**)&pISSP);
        if (SUCCEEDED(hr))
        {
            hr = pISSP->SetClientImpersonating(TRUE);
            pISSP->Release();
        }
    }

    return hr;
}

//+-------------------------------------------------------------------------
//
//  Member:     CRpcResolver::GetLocalResolverBindings
//
//  Purpose:    Gets a refcounted ptr to the current set of bindings for the
//              local resolver.
//
//  Returns:    S_OK -- bindings were returned
//              E_UNEXPECTED -- no bindings were present
//
//  History:    10-Oct-00 JSimmons    Created
//
//--------------------------------------------------------------------------
HRESULT CRpcResolver::GetLocalResolverBindings(CDualStringArray** ppdsaLocalResolver)
{
    LOCK(_mxsResolver);

    Win4Assert(ppdsaLocalResolver);
    Win4Assert(_pdsaLocalResolver);  // until we find a case where this shouldn't happen
    
    if (!_pdsaLocalResolver)
    {
        UNLOCK(_mxsResolver);  
        return E_UNEXPECTED;
    }

    *ppdsaLocalResolver = _pdsaLocalResolver;
    _pdsaLocalResolver->AddRef();

    UNLOCK(_mxsResolver);

    return S_OK;
}

//+-------------------------------------------------------------------------
//
//  Member:     CRpcResolver::SetLocalResolverBindings
//
//  Purpose:    Replaces the currently cached local resolver bindings with 
//              the one passed in.  If NULL is passed, the current bindings
//              are released.
//
//  Returns:    S_OK
//
//  History:    10-Oct-00 JSimmons    Created
//
//--------------------------------------------------------------------------
HRESULT CRpcResolver::SetLocalResolverBindings(DWORD64 dwBindingsID, CDualStringArray* pdsaLocalResolver)
{
    LOCK(_mxsResolver);  // may be a reentrancy of the lock

    if (pdsaLocalResolver && (dwBindingsID < _dwCurrentBindingsID))
    {
        // The specified bindings are older than the ones we
        // already have.  Just reject them.
        UNLOCK(_mxsResolver);  
        return E_FAIL;
    }

    if (_pdsaLocalResolver)
    {
        _pdsaLocalResolver->Release();
        _pdsaLocalResolver = NULL;
        _dwCurrentBindingsID = 0;
    }
    if (_pMNHelper)
    {
    	_pMNHelper->DecRefCount();
    	_pMNHelper = NULL;
    }
    if (pdsaLocalResolver)
    {
        _pdsaLocalResolver = pdsaLocalResolver;
        _pdsaLocalResolver->AddRef();
        _dwCurrentBindingsID = dwBindingsID;
    }    

    UNLOCK(_mxsResolver);  

    return S_OK;
}

//+-------------------------------------------------------------------------
//
//  Member:     CRpcResolver::GetCurrentMachineNames
//
//  Purpose:    Returns a CMachineNamesHelper object that represents the 
//              current set of local machine names.
//
//  Returns:    S_OK - okay
//              other - error occurred
//
//  History:    18-Feb-02 JSimmons    Created
//
//--------------------------------------------------------------------------
HRESULT CRpcResolver::GetCurrentMachineNames(CMachineNamesHelper** ppMNHelper)
{
    HRESULT hr = E_UNEXPECTED;
    
    Win4Assert(ppMNHelper);

    *ppMNHelper = NULL;

    LOCK(_mxsResolver);

    if (_pdsaLocalResolver)
    {
        if (_pMNHelper)
        {
            // already have the names ready to go
            hr = S_OK;
        }
        else
        {
            // need to create them
            hr = CMachineNamesHelper::Create(_pdsaLocalResolver, &_pMNHelper);        
        }

        if (SUCCEEDED(hr))
        {
            Win4Assert(_pMNHelper);

            *ppMNHelper = _pMNHelper;
            _pMNHelper->IncRefCount();
        }
    }
    // else if we don't have any resolver bindings, return an error

    UNLOCK(_mxsResolver);

    return hr;
}

//+-------------------------------------------------------------------------
//
//  Method:     GetEnvBlock
//
//  Purpose:    Attempts to get the environment block for clients running
//              in the interactive windowstation.
//
//  Returns:    Nothing.
//
//  History:    Feb-97 DKays     Created
//
//--------------------------------------------------------------------------
BOOL GetEnvBlock( PRIV_SCM_INFO * pScmInfo )
{
    WCHAR * pwszWinsta;
    WCHAR * pwszWinsta0;
    WCHAR * pwszString;
    DWORD   StringLength;

    pScmInfo->pEnvBlock = 0;
    pScmInfo->EnvBlockLength = 0;

    //
    // First see if this user is running in the interactive windowstation.
    // The winsta desktop field is always in the form "winsta\desktop".
    //
    pwszWinsta = pScmInfo->pwszWinstaDesktop;
    pwszWinsta0 = L"WinSta0";

    for ( ; *pwszWinsta == *pwszWinsta0; pwszWinsta++, pwszWinsta0++ )
        ;

    if ( *pwszWinsta != L'\\' || *pwszWinsta0 != L'\0' )
        return TRUE;

    pScmInfo->pEnvBlock = GetEnvironmentStringsW();

    if ( ! pScmInfo->pEnvBlock )
        return FALSE;

    pwszString = pScmInfo->pEnvBlock;

    for ( ; *pwszString; )
    {
        StringLength = lstrlenW(pwszString);
        pwszString += StringLength + 1;
        pScmInfo->EnvBlockLength += StringLength + 1;
    }

    pScmInfo->EnvBlockLength++;

    return TRUE;
}

//+-------------------------------------------------------------------------
//
//  Method:     ScmGetThreadId
//
//  Purpose:    helper method so gResolver is not used in
//              com\class subdir.
//
//--------------------------------------------------------------------------
void ScmGetThreadId( DWORD * pThreadID )
{
    gResolver.GetThreadID( pThreadID );
}
//+---------------------------------------------------------------------
//
//  Function:   UpdateDCOMSettings
//
//  Synopsis:   Calls rpcss to re-read the default activation keys/values.
//
//----------------------------------------------------------------------
STDAPI_(void) UpdateDCOMSettings(void)
{
    gResolver.UpdateActivationSettings();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\com\dcomrem\rpchelp.cxx ===
//+-------------------------------------------------------------------
//
//  File:       rpchelp.cxx
//
//  Contents:   class for implementing IRpcHelper used by RPC
//              to get information from DCOM.
//
//  Classes:    CRpcHelper
//
//  History:    09-Oct-97   RickHi  Created
//
//--------------------------------------------------------------------
#include <ole2int.h>
#include <locks.hxx>
#include <objsrv.h>         // IRpcHelper


extern HRESULT GetIIDFromObjRef(OBJREF &objref, IID **piid);

//+-------------------------------------------------------------------
//
// Class:       CRpcHelper
//
// Synopsis:    Implements the IRpcHelper interface used by the
//              RPC runtime to get private information from the
//              DCOM version running on this machine.
//
// History:     09-Oct-97   RickHi     Created
//
//--------------------------------------------------------------------
class CRpcHelper : public IRpcHelper
{
public:
    // construction
    CRpcHelper() { _cRefs = 1; }
    friend HRESULT CRpcHelperCF_CreateInstance(IUnknown *pUnkOuter,
                                               REFIID riid,
                                               void** ppv);

    // IUnknown
    STDMETHOD(QueryInterface)(REFIID riid, LPVOID *pv);
    STDMETHOD_(ULONG, AddRef)();
    STDMETHOD_(ULONG, Release)();

    // IRpcHelper
    STDMETHOD(GetDCOMProtocolVersion)(DWORD *pComVersion);
    STDMETHOD(GetIIDFromOBJREF)(void *pObjRef, IID **piid);

private:
    ULONG               _cRefs;     // reference count
};

//+-------------------------------------------------------------------
//
//  Member:     CRpcHelper::QueryInterface
//
//  History:    09-Oct-97   RickHi  Created
//
//--------------------------------------------------------------------
STDMETHODIMP CRpcHelper::QueryInterface(REFIID riid, void **ppv)
{
    if (IsEqualIID(riid, IID_IRpcHelper) ||
        IsEqualIID(riid, IID_IUnknown))
    {
        *ppv = (IRpcHelper *)this;
        AddRef();
        return S_OK;
    }

    *ppv = NULL;
    return E_NOINTERFACE;
}

//+-------------------------------------------------------------------
//
//  Member:     CRpcHelper::AddRef
//
//  History:    09-Oct-97   RickHi  Created
//
//--------------------------------------------------------------------
STDMETHODIMP_(ULONG) CRpcHelper::AddRef()
{
    return InterlockedIncrement((long *)&_cRefs);
}

//+-------------------------------------------------------------------
//
//  Member:     CRpcHelper::Release
//
//  History:    09-Oct-97    RickHi  Created
//
//--------------------------------------------------------------------
STDMETHODIMP_(ULONG) CRpcHelper::Release()
{
    ULONG cRefs = InterlockedDecrement((long *)&_cRefs);
    if (cRefs == 0)
    {
        delete this;
    }
    return cRefs;
}

//+-------------------------------------------------------------------
//
//  Member:     CRpcHelper::GetDCOMProtocolVersion
//
//  Synopsis:   return local processes DCOM protocol version
//
//  History:    09-Oct-97    RickHi  Created
//
//--------------------------------------------------------------------
STDMETHODIMP CRpcHelper::GetDCOMProtocolVersion(DWORD *pComVersion)
{
    ComDebOut((DEB_TRACE, "CRpcHelper::GetDCOMProtocolVersion pComVersion:%x",
               pComVersion));
    ASSERT_LOCK_NOT_HELD(gComLock);

    HRESULT hr = S_OK;
    ((COMVERSION *)pComVersion)->MajorVersion = COM_MAJOR_VERSION;
    ((COMVERSION *)pComVersion)->MinorVersion = COM_MINOR_VERSION;

    ASSERT_LOCK_NOT_HELD(gComLock);
    ComDebOut((DEB_TRACE, "CRpcHelper::GetDCOMProtocolVersion hr:%x ComVersion:%x",
               hr, *pComVersion));
    return hr;
}

//+-------------------------------------------------------------------
//
//  Member:     CRpcHelper::GetIIDFromOBJREF
//
//  Synopsis:   return the IID of the interface that was marshaled
//              in the supplied OBJREF.
//
//  History:    09-Oct-97    RickHi  Created
//
//--------------------------------------------------------------------
STDMETHODIMP CRpcHelper::GetIIDFromOBJREF(void *pObjRef, IID **piid)
{
    ComDebOut((DEB_TRACE,
        "CRpcHelper::GetIIDFromOBJREF pObjRef:%x piid:%x", pObjRef, piid));
    ASSERT_LOCK_NOT_HELD(gComLock);

    HRESULT hr = GetIIDFromObjRef(*(OBJREF *)pObjRef, piid);

    ASSERT_LOCK_NOT_HELD(gComLock);
    ComDebOut((DEB_TRACE, "CRpcHelper::GetIIDFromOBJREF hr:%x iid:%I", hr, *piid));
    return hr;
}

//+-------------------------------------------------------------------
//
//  Function:   CRpcHelperCF_CreateInstance, public
//
//  History:    09-Oct-97   Rickhi  Created
//
//  Notes:      Class Factory CreateInstance function.
//
//--------------------------------------------------------------------
HRESULT CRpcHelperCF_CreateInstance(IUnknown *pUnkOuter,
                                    REFIID riid,
                                    void** ppv)
{
    Win4Assert(pUnkOuter == NULL);

    HRESULT hr = E_OUTOFMEMORY;
    CRpcHelper *pRpcHlp = new CRpcHelper();
    if (pRpcHlp)
    {
        hr = pRpcHlp->QueryInterface(riid, ppv);
        pRpcHlp->Release();
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\com\dcomrem\remoteu.cxx ===
//+-------------------------------------------------------------------
//
//  File:       remoteu.cxx
//
//  Copyright (c) 1996-1996, Microsoft Corp. All rights reserved.
//
//  Contents:   Remote Unknown object implementation
//
//  Classes:    CRemoteUnknown
//
//  History:    23-Feb-95   AlexMit     Created
//
//--------------------------------------------------------------------
#include <ole2int.h>
#include <remoteu.hxx>      // CRemoteUnknown
#include <ipidtbl.hxx>      // COXIDTable, CIPIDTable
#include <stdid.hxx>        // CStdIdentity
#include <ctxchnl.hxx>      // CCtxComChnl
#include <crossctx.hxx>     // SwitchForCallback
#include <resolver.hxx>     // giPingPeriod
#include <security.hxx>     // FromLocalSystem
#include <xmit.hxx>         // CXmitRpcStream

// If you make a cross thread call and the server asks who the client
// is, we return the contents of gLocalName.
const WCHAR *gLocalName = L"\\\\\\Thread to thread";


//+-------------------------------------------------------------------
//
//  Member:     CRemoteUnknown::CRemoteUnknown, public
//
//  Synopsis:   ctor for the CRemoteUnknown
//
//  History:    22-Feb-95   Rickhi      Created
//              12-Feb-98   Johnstra    Made NTA aware
//
//--------------------------------------------------------------------
CRemoteUnknown::CRemoteUnknown(HRESULT &hr, IPID *pipid) :
    _pStdId(NULL)
{
    ASSERT_LOCK_NOT_HELD(gComLock);

    // Marshal the remote unknown and rundown, no pinging needed. Note
    // that we just marshal the IRundown interfaces since it inherits
    // from IRemUnknown.  This lets us use the same IPID for both
    // interfaces. Also, we use the Internal version of MarshalObjRef in
    // order to prevent registering the OID in the OIDTable. This allows
    // us to receive Release calls during IDTableThreadUninitialize since
    // we wont get cleaned up in the middle of that function. It also allows
    // us to lazily create the OIDTable.

    OBJREF objref;
    hr = MarshalInternalObjRef(objref, IID_IRundown, this, MSHLFLAGS_NOPING,
                               (void **)&_pStdId);
    if (SUCCEEDED(hr))
    {
        // return the IPID to the caller, and release any allocated resources
        // since all we wanted was the infrastructure, not the objref itself.

        *pipid = ORSTD(objref).std.ipid;
        FreeObjRef(objref);
    }

    ComDebOut((DEB_MARSHAL,
        "CRemoteUnk::CRemoteUnk this:%x pStdId:%x hr:%x\n", this, _pStdId, hr));
}

//+-------------------------------------------------------------------
//
//  Member:     CRemoteUnknown::~CRemoteUnknown, public
//
//  Synopsis:   dtor for the CRemoteUnknown
//
//  History:    22-Feb-95   Rickhi      Created
//
//--------------------------------------------------------------------
CRemoteUnknown::~CRemoteUnknown()
{
    ASSERT_LOCK_NOT_HELD(gComLock);

    if (_pStdId)
    {
        // Release stub manager
        ((CStdMarshal *) _pStdId)->Disconnect(DISCTYPE_SYSTEM);
        _pStdId->Release();
    }

    ComDebOut((DEB_MARSHAL, "CRemoteUnk::~CRemoteUnk this:%x\n", this));
}

//+-------------------------------------------------------------------
//
//  Member:     CRemoteUnknown::QueryInterface, public
//
//  Synopsis:   returns supported interfaces
//
//  History:    22-Feb-95   AlexMit     Created
//
//--------------------------------------------------------------------
STDMETHODIMP CRemoteUnknown::QueryInterface(REFIID riid, void **ppv)
{
    if (IsEqualIID(riid, IID_IRundown)    ||  // more common than IUnknown
        IsEqualIID(riid, IID_IRemUnknown) ||
        IsEqualIID(riid, IID_IUnknown))
    {
        *ppv = (IRundown *) this;
        // no need to AddRef since we dont refcount this object
        return S_OK;
    }

    *ppv = NULL;
    return E_NOINTERFACE;
}

//+-------------------------------------------------------------------
//
//  Member:     CRemoteUnknown::AddRef, public
//
//  Synopsis:   increment reference count
//
//  History:    23-Feb-95   AlexMit     Created
//
//--------------------------------------------------------------------
STDMETHODIMP_(ULONG) CRemoteUnknown::AddRef(void)
{
    return 1;
}

//+-------------------------------------------------------------------
//
//  Member:     CRemoteUnknown::Release, public
//
//  Synopsis:   decrement reference count
//
//  History:    23-Feb-95   AlexMit     Created
//
//--------------------------------------------------------------------
STDMETHODIMP_(ULONG) CRemoteUnknown::Release(void)
{
    return 1;
}

//+-------------------------------------------------------------------
//
//  Function:   GetIPIDEntry, private
//
//  Synopsis:   find the IPIDEntry given an IPID
//
//  History:    23-Feb-95   Rickhi      Created
//
//--------------------------------------------------------------------
IPIDEntry *GetIPIDEntry(REFIPID ripid)
{
    ASSERT_LOCK_HELD(gIPIDLock);
    IPIDEntry *pEntry= gIPIDTbl.LookupIPID(ripid);

    if (pEntry && !(pEntry->dwFlags & IPIDF_DISCONNECTED))
    {
        return pEntry;
    }

    return NULL;
}

//+-------------------------------------------------------------------
//
//  Function:   GetStdIdFromIPID, private
//
//  Synopsis:   find the stdid from the ipid
//
//  History:    23-Feb-95   Rickhi      Created
//
//--------------------------------------------------------------------
CStdIdentity *GetStdIdFromIPID(REFIPID ripid)
{
    ASSERT_LOCK_HELD(gIPIDLock);
    IPIDEntry *pEntry = GetIPIDEntry(ripid);

    if (pEntry)
    {
        CStdIdentity *pStdId = pEntry->pChnl->GetStdId();
        if (pStdId)
        {
            // keep it alive for the duration of the call
            pStdId->AddRef();
        }
        return pStdId;
    }

    return NULL;
}


//+-------------------------------------------------------------------
//
//  Function:   CrossAptQIFn            Internal
//
//  Synopsis:   This routine delegates CRemUnknown to do the actual QI
//              on the server object and building of IPIDEntries
//
//  History:    20-Jan-98   Gopalk      Created
//
//+-------------------------------------------------------------------
typedef struct tagXAptQIData
{
    const IPID     *pIPID;
    ULONG           cRefs;
    USHORT          cIids;
    IID            *iids;
    REMQIRESULT   **ppQIResults;
    CRemoteUnknown *pRemUnk;
} XAptQIData;

HRESULT __stdcall CrossAptQIFn(void *pv)
{
    ContextDebugOut((DEB_CTXCOMCHNL, "CrossAptQIFn\n"));
    ASSERT_LOCK_NOT_HELD(gIPIDLock);

    HRESULT hr;
    XAptQIData *pXAptQIData = (XAptQIData *) pv;

    // Delegate to CRemoteUnknown
    hr = pXAptQIData->pRemUnk->RemQueryInterface(*pXAptQIData->pIPID,
                                                 pXAptQIData->cRefs,
                                                 pXAptQIData->cIids,
                                                 pXAptQIData->iids,
                                                 pXAptQIData->ppQIResults);

    ASSERT_LOCK_NOT_HELD(gIPIDLock);
    ContextDebugOut((DEB_CTXCOMCHNL, "CrossAptQIFn returning 0x%x\n", hr));
    return(hr);
}


//+-------------------------------------------------------------------
//
//  Member:     CRemoteUnknown::RemQueryInterface, public
//
//  Synopsis:   returns supported interfaces
//
//  History:    22-Feb-95   AlexMit     Created
//              20-Jan-98   GopalK      Context related changes
//              05-Jul-99   a-sergiv    Move security check here
//
//  Notes:      Remote calls to QueryInterface for this OXID arrive here.
//              This routine looks up the object and calls MarshalIPID on
//              it for each interface requested.
//
//--------------------------------------------------------------------
STDMETHODIMP CRemoteUnknown::RemQueryInterface(REFIPID ripid, ULONG cRefs,
                       USHORT cIids, IID *iids, REMQIRESULT **ppQIResults)
{
    ComDebOut((DEB_MARSHAL,
        "CRemUnknown::RemQueryInterface this:%x ipid:%I cRefs:%x cIids:%x iids:%x ppQIResults:%x\n",
        this, &ripid, cRefs, cIids, iids, ppQIResults));

    // init the out parameters
    *ppQIResults = NULL;

    // validate the input parameters
    if (cIids == 0)
    {
        return E_INVALIDARG;
    }

    // Perform access check. It is best to perform it no
    // matter what. This is cheaper than doing PreventDisconnect
    // and fiddling with gIPIDLock farther down in this function.
    BOOL bAccessDenied = (CheckAccess(NULL, NULL) != S_OK);

    // Remember whether the IPID is for a strong or a weak reference,
    // then clear the strong/weak bit so that GetIPIDEntry will find
    // the IPID. It is safe to mask off this bit because we are the
    // server for this IPID and we know it's format.

    DWORD mshlflags = MSHLFLAGS_NORMAL;
    DWORD sorfflags = SORF_NULL;

    if (ripid.Data1 & IPIDFLAG_WEAKREF)
    {
        mshlflags = MSHLFLAGS_WEAK;
        sorfflags = SORF_P_WEAKREF;
        ((IPID &)(ripid)).Data1 &= ~IPIDFLAG_WEAKREF;   // overcome the const
    }

    ASSERT_LOCK_NOT_HELD(gIPIDLock);
    LOCK(gIPIDLock);

    CStdIdentity *pStdId = GetStdIdFromIPID(ripid);
    if (pStdId == NULL)
    {
        UNLOCK(gIPIDLock);
        ASSERT_LOCK_NOT_HELD(gIPIDLock);
        return RPC_E_INVALID_OBJECT;
    }

    // Get server context
    HRESULT hr;
    CPolicySet *pPS = pStdId->GetServerPolicySet();
    CObjectContext *pCurrentCtx = GetCurrentContext();
    CObjectContext *pServerCtx = pPS ? pPS->GetServerContext() : pCurrentCtx;

    if(bAccessDenied && (!pPS || !pServerCtx->IsUnsecure()))
    {
        pStdId->Release();
        UNLOCK(gIPIDLock);
        ASSERT_LOCK_NOT_HELD(gIPIDLock);
        return E_ACCESSDENIED;
    }

    // Compare contexts
    if (pServerCtx == pCurrentCtx)
    {
        // allocate space for the return parameters
        REMQIRESULT *pQIRes = (REMQIRESULT *)CoTaskMemAlloc(cIids *
                                                            sizeof(REMQIRESULT));
        // allocate space on the stack to hold the IPIDEntries
        // for each interface
        IPIDEntry **parIPIDs = (IPIDEntry **)alloca(cIids * sizeof(IPIDEntry *));

        if (pQIRes == NULL)
        {
            UNLOCK(gIPIDLock);
            ASSERT_LOCK_NOT_HELD(gIPIDLock);
            pStdId->Release();
            return E_OUTOFMEMORY;
        }

        hr = pStdId->PreventDisconnect();
        if (SUCCEEDED(hr))
        {
            *ppQIResults = pQIRes;

            // while holding the lock, marshal each interface that was requested
            for (USHORT i=0; i < cIids; i++, pQIRes++)
            {
                pQIRes->hResult = pStdId->MarshalIPID(iids[i], cRefs, mshlflags,
                                                      &parIPIDs[i], 0);
            }

            // we are done with the lock, the IPIDEntries will remain valid
            // as long as Disconnect has been prevented.
            UNLOCK(gIPIDLock);
            ASSERT_LOCK_NOT_HELD(gIPIDLock);

            USHORT cFails = 0;
            if (SUCCEEDED(hr))
            {
                // create a STDOBJREF for each interface from the info in the
                // IPIDEntries.
                pQIRes = *ppQIResults;  // reset the pointer

                for (USHORT i=0; i < cIids; i++, pQIRes++)
                {
                    if (SUCCEEDED(pQIRes->hResult))
                    {
                        // marshal for this interface succeeded, fill the STDOJBREF
                        pStdId->FillSTD(&pQIRes->std, cRefs, mshlflags, parIPIDs[i]);
                        pQIRes->std.flags |= sorfflags;
                    }
                    else
                    {
                        // marshaled failed. on failure, the STDOBJREF must be NULL
                        memset(&pQIRes->std, 0, sizeof(pQIRes->std));
                        cFails++;
                    }
                }
            }
            else
            {
                // free the memory since the call failed.
                CoTaskMemFree(pQIRes);
                pQIRes = NULL;
                Win4Assert(*ppQIResults == NULL);
            }

            if (cFails > 0)
            {
                hr = (cFails == cIids) ? E_NOINTERFACE : S_FALSE;
            }
        }
        else
        {
            UNLOCK(gIPIDLock);
            ASSERT_LOCK_NOT_HELD(gIPIDLock);
        }

        // handle any disconnects that came in while we were marshaling
        // the requested interfaces.
        hr = pStdId->HandlePendingDisconnect(hr);
        pStdId->Release();
    }
    else
    {
        UNLOCK(gIPIDLock);
        ASSERT_LOCK_NOT_HELD(gIPIDLock);
        pStdId->Release();

        XAptQIData xAptQIData;

        // Switch to server context for the QI
        xAptQIData.pIPID = &ripid;
        xAptQIData.cRefs = cRefs;
        xAptQIData.cIids = cIids;
        xAptQIData.iids  = iids;
        xAptQIData.ppQIResults = ppQIResults;
        xAptQIData.pRemUnk = this;

        hr = SwitchForCallback(pPS, CrossAptQIFn, &xAptQIData,
                               IID_IUnknown, 0, NULL);
    }

    ASSERT_LOCK_NOT_HELD(gIPIDLock);
    ComDebOut((DEB_MARSHAL,
        "CRemUnknown::RemQueryInterface this:%x pQIRes:%x hr:%x\n",
        this, *ppQIResults, hr));
    return hr;
}

//+-------------------------------------------------------------------
//
//  Member:     CRemoteUnknown::GetSecBinding
//
//  Synopsis:   Get the security binding of the caller
//
//  History:    21-Feb-96   AlexMit     Created
//
//--------------------------------------------------------------------
HRESULT CRemoteUnknown::GetSecBinding( SECURITYBINDING **pSecBind )
{
    HRESULT       hr;
    DWORD         lAuthnSvc;
    DWORD         lAuthzSvc;
    DWORD         lAuthnLevel;
    const WCHAR  *pPrivs;
    DWORD         lLen;

    hr = CoQueryClientBlanket( &lAuthnSvc, &lAuthzSvc, NULL,
                                &lAuthnLevel, NULL, (void **) &pPrivs, NULL );
    if (FAILED(hr))
        return hr;

    // For thread to thread calls, make up a privilege name.
    if (pPrivs == NULL && LocalCall())
        pPrivs = gLocalName;
    else if (lAuthnLevel == RPC_C_AUTHN_LEVEL_NONE ||
             lAuthnLevel < gAuthnLevel)
        return E_INVALIDARG;

    if (pPrivs != NULL)
        lLen = lstrlenW( pPrivs ) * sizeof(WCHAR);
    else
        lLen = 0;
    *pSecBind = (SECURITYBINDING *) PrivMemAlloc(
                                     sizeof(SECURITYBINDING) + lLen );
    if (*pSecBind != NULL)
    {
        // Sometimes rpc returns authn svc 0.
        if (lAuthnSvc == RPC_C_AUTHN_NONE)
            lAuthnSvc = RPC_C_AUTHN_WINNT;

        (*pSecBind)->wAuthnSvc = (USHORT) lAuthnSvc;
        if (lAuthzSvc == RPC_C_AUTHZ_NONE)
            (*pSecBind)->wAuthzSvc = COM_C_AUTHZ_NONE;
        else
            (*pSecBind)->wAuthzSvc = (USHORT) lAuthzSvc;

        if (pPrivs != NULL)
            memcpy( &(*pSecBind)->aPrincName, pPrivs, lLen+2 );
        else
            (*pSecBind)->aPrincName = 0;

        return S_OK;
    }
    else
        return E_OUTOFMEMORY;
}


//+-------------------------------------------------------------------
//
//  Function:   CrossAptAddRefFn        Internal
//
//  Synopsis:   This routine delegates CRemUnknown to do the actual
//              Addref on the server object
//
//  History:    07-May-98   Gopalk      Created
//
//+-------------------------------------------------------------------
typedef struct tagXAptAddRefData
{
    USHORT           cIfs;
    REMINTERFACEREF *pIfRefs;
    HRESULT         *pResults;
    CRemoteUnknown  *pRemUnk;
} XAptAddRefData;

HRESULT __stdcall CrossAptAddRefFn(void *pv)
{
    ContextDebugOut((DEB_CTXCOMCHNL, "CrossAptAddRefFn\n"));
    ASSERT_LOCK_NOT_HELD(gIPIDLock);

    HRESULT hr;
    XAptAddRefData *pXAptAddRefData = (XAptAddRefData *) pv;

    // Delegate to CRemoteUnknown
    hr = pXAptAddRefData->pRemUnk->RemAddRefWorker(pXAptAddRefData->cIfs,
                                                   pXAptAddRefData->pIfRefs,
                                                   pXAptAddRefData->pResults,
                                                   FALSE);

    ASSERT_LOCK_NOT_HELD(gIPIDLock);
    ContextDebugOut((DEB_CTXCOMCHNL, "CrossAptAddRefFn returning 0x%x\n", hr));
    return(hr);
}


//+-------------------------------------------------------------------
//
//  Member:     CRemoteUnknown::RemAddRef   public
//
//  Synopsis:   Remote calls to AddRef server objects arrive here.
//              This method delegates to RemAddRefWorker to do the
//              actual work
//
//  History:    07-May-98   Gopalk      Created
//
//--------------------------------------------------------------------
STDMETHODIMP CRemoteUnknown::RemAddRef(unsigned short cInterfaceRefs,
                                       REMINTERFACEREF InterfaceRefs[],
                                       HRESULT        *pResults)
{
    return(RemAddRefWorker(cInterfaceRefs, InterfaceRefs, pResults, TRUE));
}


//+-------------------------------------------------------------------
//
//  Member:     CRemoteUnknown::RemAddRefWorker   public
//
//  Synopsis:   increment reference count
//
//  History:    22-Feb-95   AlexMit     Created
//              07-May-98   GopalK      Context related changes
//              05-Jul-99   a-sergiv    Move security check here
//
//  Description: Remote calls to AddRef for this OXID arrive
//               here.  This routine just looks up the correct remote
//               remote handler and asks it to do the work.
//
//--------------------------------------------------------------------
HRESULT CRemoteUnknown::RemAddRefWorker(unsigned short cInterfaceRefs,
                                        REMINTERFACEREF InterfaceRefs[],
                                        HRESULT *pResults,
                                        BOOL fTopLevel)
{
    // Adjust the reference count for each entry.
    HRESULT          hr       = S_OK;
    HRESULT          hr2;
    SECURITYBINDING *pSecBind = NULL;
    REMINTERFACEREF *pNext = InterfaceRefs;
    CStdIdentity    *pStdId, *pPrevStdId = NULL;

    // Get Current context
    CObjectContext *pCurrentCtx = GetCurrentContext();
    CObjectContext *pServerCtx;
    CPolicySet     *pPS;

    // Perform access check
    BOOL            bAccessDenied = (CheckAccess(NULL, NULL) != S_OK);

    ASSERT_LOCK_NOT_HELD(gIPIDLock);
    LOCK(gIPIDLock);

    for(USHORT i=0; i < cInterfaceRefs; i++, pNext++)
    {
        // Get the IPIDEntry for the specified IPID.
        IPIDEntry *pEntry = GetIPIDEntry(pNext->ipid);
        if(!pEntry)
        {
            // Don't assert on failure.  The server can disconnect and go away
            // while clients exist.
            pResults[i] = hr = CO_E_OBJNOTREG;
            continue;
        }

        // Get StdId
        pStdId = pEntry->pChnl->GetStdId();
        if(pStdId)
        {
            // Get server context
            pPS = pStdId->GetServerPolicySet();
            pServerCtx = pPS ? pPS->GetServerContext() : GetEmptyContext();

            // Compare contexts
            if (pServerCtx != pCurrentCtx)
            {
                // Check for top level call to this routine
                if (fTopLevel)
                {
                    UNLOCK(gIPIDLock);
                    ASSERT_LOCK_NOT_HELD(gIPIDLock);

                    if(bAccessDenied && (!pPS || !pServerCtx->IsUnsecure()))
                    {
                        for(i=0;i<cInterfaceRefs;i++)
                            pResults[i] = E_ACCESSDENIED;
                        return E_ACCESSDENIED;
                    }

                    XAptAddRefData xAptAddRefData;

                    // Switch to server context for the AddRef
                    xAptAddRefData.cIfs     = cInterfaceRefs - i;
                    xAptAddRefData.pIfRefs  = pNext;
                    xAptAddRefData.pResults = pResults + i;
                    xAptAddRefData.pRemUnk  = this;

                    hr2 = SwitchForCallback(pPS, CrossAptAddRefFn,
                                            &xAptAddRefData,
                                            IID_IUnknown, 1, NULL);
                    if(FAILED(hr2))
                        hr = hr2;

                    return hr;
                }
                else
                {
                    OutputDebugStringW(L"CRemUnknown::RemAddRef called on objects "
                                      L"living in multiple contexts\n");
                    Win4Assert("CRemUnknown::RemAddRef called on objects living "
                               "in multiple contexts");
                    hr = pResults[i] = E_FAIL;
                    continue;
                }
            }
            else
            {
                ComDebOut((DEB_MARSHAL,
                           "CRemUnknown::RemAddRef pEntry:%x cCur:%x cAdd:%x "
                           "cStdId:%x ipid:%I\n", pEntry, pEntry->cStrongRefs,
                           pNext->cPublicRefs, pStdId->GetRC(), &pNext->ipid));

                Win4Assert(pNext->cPublicRefs > 0 || pNext->cPrivateRefs > 0);

                if(bAccessDenied && (!pPS || !pServerCtx->IsUnsecure()))
                {
                    hr = pResults[i] = E_ACCESSDENIED;
                    continue;
                }

                // Lookup security info the first time an entry asks for
                // secure references.
                if (pNext->cPrivateRefs != 0 && pSecBind == NULL)
                {
                    hr2 = GetSecBinding( &pSecBind );
                    if (FAILED(hr2))
                    {
                        hr = pResults[i] = hr2;
                        continue;
                    }
                }

                hr2 = pStdId->IncSrvIPIDCnt(pEntry, pNext->cPublicRefs,
                                            pNext->cPrivateRefs, pSecBind,
                                            MSHLFLAGS_NORMAL);
                if (FAILED(hr2))
                    hr = pResults[i] = hr2;
                else
                    pResults[i] = S_OK;
            }
        }
        else
            hr = pResults[i] = CO_E_OBJNOTREG;
    }

    UNLOCK(gIPIDLock);
    ASSERT_LOCK_NOT_HELD(gIPIDLock);

    if (pSecBind)
        PrivMemFree(pSecBind);

    return hr;
}


//+-------------------------------------------------------------------
//
//  Function:   CrossAptReleaseFn        Internal
//
//  Synopsis:   This routine delegates CRemUnknown to do the actual
//              Release on the server object
//
//  History:    07-May-98   Gopalk      Created
//
//+-------------------------------------------------------------------
typedef struct tagXAptReleaseData
{
    USHORT            cIfs;
    REMINTERFACEREF  *pIfRefs;
    CRemoteUnknown   *pRemUnk;
} XAptReleaseData;

HRESULT __stdcall CrossAptReleaseFn(void *pv)
{
    ContextDebugOut((DEB_CTXCOMCHNL, "CrossAptReleaseFn\n"));
    ASSERT_LOCK_NOT_HELD(gIPIDLock);

    HRESULT hr;
    XAptReleaseData *pXAptReleaseData = (XAptReleaseData *) pv;

    // Delegate to CRemoteUnknown
    hr = pXAptReleaseData->pRemUnk->RemReleaseWorker(pXAptReleaseData->cIfs,
                                                     pXAptReleaseData->pIfRefs,
                                                     FALSE);

    ASSERT_LOCK_NOT_HELD(gIPIDLock);
    ContextDebugOut((DEB_CTXCOMCHNL, "CrossAptReleaseFn returning 0x%x\n", hr));
    return(hr);
}


//+-------------------------------------------------------------------
//
//  Member:     CRemoteUnknown::RemRelease   public
//
//  Synopsis:   Remote calls to Release server objects arrive here
//              This method delegates to RemReleaseWorker to do the actual work
//
//  History:    07-May-98   Gopalk      Created
//
//--------------------------------------------------------------------
STDMETHODIMP CRemoteUnknown::RemRelease(unsigned short  cInterfaceRefs,
                                        REMINTERFACEREF InterfaceRefs[])
{
    return(RemReleaseWorker(cInterfaceRefs, InterfaceRefs, TRUE));
}

//+-------------------------------------------------------------------
//
//  Member:     CRemoteUnknown::RemReleaseWorker  public
//
//  Synopsis:   decrement reference count
//
//  History:    22-Feb-95   AlexMit     Created
//              07-May-98   GopalK      Context related changes
//              05-Jul-99   a-sergiv    Move security check here
//
//  Description: Remote calls to Release for this OXID arrive
//               here.  This routine just looks up the correct remote
//               remote handler and asks it to do the work.
//
//--------------------------------------------------------------------
HRESULT CRemoteUnknown::RemReleaseWorker(unsigned short  cInterfaceRefs,
                                         REMINTERFACEREF InterfaceRefs[],
                                         BOOL fTopLevel)
{
    ComDebOut((DEB_MARSHAL,"CRemoteUnknown::RemReleaseWorker [in]\n"));
    REMINTERFACEREF *pNext    = InterfaceRefs;
    SECURITYBINDING *pSecBind = NULL;
    CStdIdentity   *pStdId    = NULL;

    // Get Current context
    CObjectContext *pCurrentCtx = GetCurrentContext();
    CObjectContext *pServerCtx;

    // Perform access check
    BOOL            bAccessDenied = (CheckAccess(NULL, NULL) != S_OK);

    ASSERT_LOCK_NOT_HELD(gIPIDLock);
    LOCK(gIPIDLock);

    // Adjust the reference count for each entry.
    for (USHORT i=0; i < cInterfaceRefs; i++, pNext++)
    {
        // Get the entry for the requested IPID. Remember whether this
        // is an IPID for a strong or a weak reference, then clear the
        // strong/weak bit so that GetIPIDEntry will find the IPID.

        DWORD mshlflags = (InterfaceRefs[i].ipid.Data1 & IPIDFLAG_WEAKREF)
                                ? MSHLFLAGS_WEAK : MSHLFLAGS_NORMAL;

        InterfaceRefs[i].ipid.Data1 &= ~IPIDFLAG_WEAKREF;
        IPIDEntry *pIPIDEntry = GetIPIDEntry(InterfaceRefs[i].ipid);

        if (pIPIDEntry)
        {
            // Get the entry for the requested IPID.
            HRESULT hr = S_OK;
            CStdIdentity *pStdIdNew = pIPIDEntry->pChnl->GetStdId();

            if (pStdIdNew == NULL)
            {
                hr = CO_E_OBJNOTCONNECTED;
            }
            else if (pStdIdNew != pStdId)
            {
                // the server object for this IPID differs from
                // the server object of the previous IPID, go figure
                // out what to do...

                // Get server context
                BOOL fSwitchContext = FALSE;
                CPolicySet *pPS = pStdIdNew->GetServerPolicySet();
                pServerCtx = pPS ? pPS->GetServerContext() : GetEmptyContext();

                if (pServerCtx != pCurrentCtx)
                {
                    // this new object lives in a different context than the
                    if (fTopLevel)
                    {
                        // top level call to this routine so OK to switch to
                        // server's context.
                        fSwitchContext = TRUE;
                    }
                    else
                    {
                        Win4Assert(!"CRemUnknown::RemRelease called on objects living "
                                    "in multiple contexts");
                        continue;
                    }
                }
                else
                {
                    // contexts match but the object is different. keep
                    // the new object alive while we do our work on it.
                    pStdIdNew->AddRef();
                    hr = pStdIdNew->PreventDisconnect();
                }

                if (pStdId)
                {
                    // there was a previous object, go cleanup that one.

                    // do the final release of the object while not holding
                    // the lock, since it may call into the server.
                    UNLOCK(gIPIDLock);
                    ASSERT_LOCK_NOT_HELD(gIPIDLock);

                    // This will handle any Disconnect that came in while we were
                    // busy.  Ignore error codes since we are releasing.
                    pStdId->HandlePendingDisconnect(S_OK);
                    pStdId->Release();
                    pStdId = NULL;

                    ASSERT_LOCK_NOT_HELD(gIPIDLock);
                    LOCK(gIPIDLock);
                }

                // the new StdId become the current one.
                pStdId = pStdIdNew;

                if (fSwitchContext)
                {
                    // need to switch to the server's context to do the release.
                    UNLOCK(gIPIDLock);
                    ASSERT_LOCK_NOT_HELD(gIPIDLock);

                    if(bAccessDenied && (!pPS || !pServerCtx->IsUnsecure()))
                        return E_ACCESSDENIED;

                    // AddRef policy set to stabilize it
                    pPS->AddRef();

                    XAptReleaseData xAptReleaseData;

                    // Switch to server context for the AddRef
                    xAptReleaseData.cIfs    = cInterfaceRefs - i;
                    xAptReleaseData.pIfRefs = pNext;
                    xAptReleaseData.pRemUnk = this;

                    SwitchForCallback(pPS, CrossAptReleaseFn,
                                      &xAptReleaseData,
                                      IID_IUnknown, 2, NULL);

                    // Release policy set
                    pPS->Release();

                    return S_OK;
                }
            }

            if (SUCCEEDED(hr))
            {
                CPolicySet *pPS = pStdIdNew->GetServerPolicySet();
                pServerCtx = pPS ? pPS->GetServerContext() : NULL;

                if(bAccessDenied && (!pPS || !pServerCtx->IsUnsecure()))
                    continue;
				
                // Get the client's security binding on the first entry
                // that releases secure references.
                if (pNext->cPrivateRefs > 0 && pSecBind == NULL)
                {
                    GetSecBinding( &pSecBind );
                    if (pSecBind == NULL)
                        continue;
                }

                ComDebOut((DEB_MARSHAL,
                           "CRemUnknown::RemRelease pEntry:%x cCur:%x "
                           "cStdId:%x cRel:%x mshlflags:%x ipid:%I\n",
                           pIPIDEntry, (mshlflags == MSHLFLAGS_WEAK) ?
                           pIPIDEntry->cWeakRefs : pIPIDEntry->cStrongRefs,
                           pStdId->GetRC(), pNext->cPublicRefs,
                           mshlflags, &pNext->ipid));
                Win4Assert(pNext->cPublicRefs > 0 || pNext->cPrivateRefs > 0);

                pStdId->DecSrvIPIDCnt(pIPIDEntry, pNext->cPublicRefs,
                                      pNext->cPrivateRefs, pSecBind,
                                      mshlflags);
            }
        }   // if IPIDEntry
    }   // for

    UNLOCK(gIPIDLock);
    ASSERT_LOCK_NOT_HELD(gIPIDLock);

    if (pStdId)
    {
        // there was a last object, go clean it up.
        // This will handle any Disconnect that came in while we were
        // busy.  Ignore error codes since we are releasing.
        pStdId->HandlePendingDisconnect(S_OK);
        pStdId->Release();
    }

    PrivMemFree( pSecBind );
    ComDebOut((DEB_MARSHAL,"CRemoteUnknown::RemReleaseWorker [out]\n"));
    return S_OK;
}

//+-------------------------------------------------------------------
//
//  Function:   GetDestCtx
//
//  Synopsis:   Since we dont have the channel, get the DestCtx
//              from the CMessageCall in Tls.
//
//  History:    22-Nov-96        Rickhi Created
//
//--------------------------------------------------------------------
DWORD GetDestCtx(void **ppv)
{
    COleTls tls;
    Win4Assert( tls->pCallInfo != NULL );
    *ppv = NULL;
    return tls->pCallInfo->GetDestCtx();
}

//+-------------------------------------------------------------------
//
//  Member:     CRemoteUnknown::RemQueryInterface2, public
//
//  Synopsis:   returns supported interfaces. Special version of
//              RemQI for objects which have handlers and aggregate
//              the standard marshaler. Such objects can add their own
//              data to the marshaled interface stream, so we have to
//              call IMarshal::MarshalInterface rather than shortcutting
//              to MarshalIPID.
//
//  History:    22-Nov-96        Rickhi    Created
//              05-Jul-99        a-sergiv  Move security check here
//
//--------------------------------------------------------------------
STDMETHODIMP CRemoteUnknown::RemQueryInterface2(REFIPID ripid, USHORT cIids,
                         IID *iids, HRESULT *phr, MInterfacePointer **ppMIFs)
{
    ComDebOut((DEB_MARSHAL,
        "CRemUnknown::RemQueryInterface2 this:%x ipid:%I cIids:%x iids:%x ppMIFs:%x\n",
        this, &ripid, cIids, iids, ppMIFs));

    // validate the input parameters
    if (cIids == 0 || phr == NULL || ppMIFs == NULL)
    {
        return E_INVALIDARG;
    }

    // find the StdId
    HRESULT hr = RPC_E_INVALID_OBJECT;

    ASSERT_LOCK_NOT_HELD(gIPIDLock);
    LOCK(gIPIDLock);

    CStdIdentity *pStdId = GetStdIdFromIPID(ripid);
    if (pStdId)
    {
        hr = pStdId->PreventDisconnect();
    }

    UNLOCK(gIPIDLock);
    ASSERT_LOCK_NOT_HELD(gIPIDLock);

    if (SUCCEEDED(hr))
    {
        CPolicySet *pPS = pStdId->GetServerPolicySet();
        CObjectContext *pCurrentCtx = GetCurrentContext();
        CObjectContext *pServerCtx = pPS ? pPS->GetServerContext() : pCurrentCtx;

        if(!pPS || !pServerCtx->IsUnsecure())
        {
            if(CheckAccess(NULL, NULL) != S_OK)
            {
                pStdId->HandlePendingDisconnect(E_ACCESSDENIED);
                pStdId->Release();

                for(USHORT i=0;i<cIids;i++)
                    phr[i] = E_ACCESSDENIED;

                return E_ACCESSDENIED;
            }
        }

        USHORT  cFails = 0;

        // find outer IMarshal
        IMarshal *pIM = NULL;
        hr = pStdId->QueryInterface(IID_IMarshal, (void **)&pIM);

        if (SUCCEEDED(hr))
        {
            // get an IUnknown and DestCtx to pass to MarshalInterface
            IUnknown *pUnk = pStdId->GetServer();   // not AddRef'd
            void *pvDestCtx;
            DWORD dwDestCtx = GetDestCtx(&pvDestCtx);

            // loop on the cIIDs marshaling each requested interface
            for (USHORT i=0; i < cIids; i++)
            {
                // make a stream on memory.
                CXmitRpcStream Stm;

                // marshal the requested interface
                phr[i] = pIM->MarshalInterface(&Stm,
                                            iids[i], pUnk,
                                            dwDestCtx, pvDestCtx,
                                            MSHLFLAGS_NORMAL);

                if (SUCCEEDED(phr[i]))
                {
                    // extract the data ptr and cbData from the stream
                    Stm.AssignSerializedInterface((InterfaceData **)&ppMIFs[i]);
                }
                else
                {
                    // call failed, increment count of fails
                    cFails++;
                }
            }

            // release the IMarshal interface pointer
            pIM->Release();
        }

        if (cFails > 0)
        {
            hr = (cFails == cIids) ? E_NOINTERFACE : S_FALSE;
        }

        // handle any disconnects that came in while we were marshaling
        // the requested interfaces.
        hr = pStdId->HandlePendingDisconnect(hr);
    }

    if (pStdId)
        pStdId->Release();

    ComDebOut((DEB_MARSHAL,
        "CRemUnknown::RemQueryInterface2 this:%x phr:%x pMIF:%x hr:%x\n",
        this, phr[0], ppMIFs[0], hr));
    return hr;
}

//+-------------------------------------------------------------------------
//
//  Member:     CRemoteUnknown::RemChangeRefs, public
//
//  Synopsis:   Change an interface reference from strong/weak or vice versa.
//
//  History:    08-Nov-95   Rickhi      Created
//
//  Note:       It is safe for this routine to ignore private refcounts
//              becuase it is only called locally hence we own the client
//              implementation and can guarantee they are zero.
//
//--------------------------------------------------------------------------
STDMETHODIMP CRemoteUnknown::RemChangeRef(ULONG flags, USHORT cInterfaceRefs,
                                          REMINTERFACEREF InterfaceRefs[])
{
    // figure out the flags to pass to the Inc/DecSrvIPIDCnt
    BOOL  fMakeStrong = flags & IRUF_CONVERTTOSTRONG;
    DWORD IncFlags    = fMakeStrong ? MSHLFLAGS_NORMAL : MSHLFLAGS_WEAK;
    DWORD DecFlags    = fMakeStrong ? MSHLFLAGS_WEAK : MSHLFLAGS_NORMAL;
    DecFlags |= (flags & IRUF_DISCONNECTIFLASTSTRONG) ? 0 : MSHLFLAGS_KEEPALIVE;

    CStdIdentity *pStdId = NULL;

    ASSERT_LOCK_NOT_HELD(gIPIDLock);
    LOCK(gIPIDLock);

    for (USHORT i=0; i < cInterfaceRefs; i++)
    {
        // Get the entry for the specified IPID.
        IPIDEntry *pEntry = GetIPIDEntry(InterfaceRefs[i].ipid);

        if (pEntry)
        {
            // find the StdId for this IPID. We assume that the client
            // only gives us IPIDs for the same object, so first time
            // we find a StdId we remember it and AddRef it. This is a safe
            // assumption cause the client is local to this machine (ie
            // we wrote the client).

            CStdIdentity *pStdIdTmp = pEntry->pChnl->GetStdId();

            if (pStdIdTmp != NULL)
            {
                if (pStdId == NULL)
                {
                    pStdId = pStdIdTmp;
                    pStdId->AddRef();
                }

                // We assume that all IPIDs are for the same object. We
                // just verify that here.

                if (pStdId == pStdIdTmp)
                {
                    // tweak the reference counts
                    pStdId->IncSrvIPIDCnt(
                        pEntry, InterfaceRefs[i].cPublicRefs,
                        fMakeStrong ? InterfaceRefs[i].cPrivateRefs : 0,
                        NULL, IncFlags);
                    pStdId->DecSrvIPIDCnt(
                        pEntry, InterfaceRefs[i].cPublicRefs,
                        fMakeStrong ? 0 : InterfaceRefs[i].cPrivateRefs,
                        NULL, DecFlags);
                }
            }
        }
    }

    UNLOCK(gIPIDLock);
    ASSERT_LOCK_NOT_HELD(gIPIDLock);

    if (pStdId)
    {
        // release the AddRef (if any) we did above
        pStdId->Release();
    }

    return S_OK;
}

//+-------------------------------------------------------------------
//
//  Member:     CRemoteUnknown::RundownOid, public
//
//  Synopsis:   Tell the server that no clients are using an object
//
//  History:    25 May 95   AlexMit     Created
//              19 Jun 98   GopalK      Context changes
//              19 Dec 2000 DickD       COM+ Prefix bug 22887
//
//  Description: Lookup each OID in the IDTable.  If found and not
//               recently marshaled, call DisconnectObject on it.
//
//--------------------------------------------------------------------
STDMETHODIMP CRemoteUnknown::RundownOid(ULONG cOid, OID aOid[],
                                        BYTE aRundownStatus[])
{
    ComDebOut((DEB_MARSHAL,
        "CRemUnknown::RundownOid this:%x cOid:%x aOid:%x afOkToRundown:%x\n",
        this, cOid, aOid, aRundownStatus));

    //
    // We cannot directly use an RPC security callback function, since most
    // of the inherited methods of IRundown (eg, IRemUnknownN, etc) must be
    // able to receive calls from many places.  However, we should always 
    // be in the middle of a call so we can reuse the security callback fn
    // by calling it directly with the call handle of the current call.
    //
    HRESULT hr = S_OK;
    COleTls tls(hr);
    if (FAILED(hr))
        return hr;

    if (!tls->pCallInfo)
    {
        Win4Assert(!"Inside of RundownOid without a call object");
        return E_ACCESSDENIED;
    }
    else
    {
        RPC_STATUS status = RPCSStoOLE32SecurityCallback(0, tls->pCallInfo->_hRpc);
        if (status != RPC_S_OK)
        {
            ComDebOut((DEB_ERROR, "Invalid user called CRemoteUnknown::RundownOid" ));

            // Lie to caller & tell him we ran everything down
            for (ULONG i = 0; i < cOid; i++)
                aRundownStatus[i] = ORS_OK_TO_RUNDOWN;

            return S_OK;
        }
    }

    // allocate space for a bunch of results and OIDs. Control the
    // size of the allocation so we don't have to worry about
    // overflowing the stack.

#if DBG==1
    const int cMAX_OID_ALLOC = 2;
    MOID arMOID[cMAX_OID_ALLOC];
#else
    const int cMAX_OID_ALLOC = 100;
#endif

    ULONG cAlloc = min(cOid, cMAX_OID_ALLOC);
    RUNDOWN_RESULT *arResult = (RUNDOWN_RESULT *)
                                _alloca(sizeof(RUNDOWN_RESULT) * cAlloc);
    CStdIdentity  **arpStdId = (CStdIdentity **)
                                _alloca(sizeof(CStdIdentity *) * cAlloc);


    // now loop over the results, filling in the response
    DWORD iNow    = GetCurrentTime();
    DWORD dwAptId = GetCurrentApartmentId();

    CComApartment *pComApt;

    hr = GetCurrentComApartment(&pComApt);
    if (FAILED(hr))	// COM+ 22887 GetCurrentComApartment can fail
    {
        return hr;
    }

    ULONG i = 0;
    while (i < cOid)
    {
        // first, ask the apartment object if it knows about these oids.
        // For each OID it knows about, it will tell us which ones can be
        // rundown now and which cannot. For the ones it does not know
        // about, we will have to look in the OID table.

        pComApt->CanRundownOIDs(min(cAlloc, cOid - i), &aOid[i], arResult);

        // lookup a bunch while we hold the lock. This saves a lot of
        // LOCK/UNLOCK activity which causes contention in a busy server.
        ASSERT_LOCK_NOT_HELD(gComLock);
        LOCK(gComLock);

        for (ULONG j=0; i+j<cOid && j<cAlloc; j++)
        {
            arpStdId[j] = NULL;

            if (arResult[j] == RUNDWN_RUNDOWN)
            {
                // OK to rundown the OID
                aRundownStatus[i+j] = ORS_OK_TO_RUNDOWN;
            }
            else if (arResult[j] == RUNDWN_KEEP)
            {
                // not OK to rundown the OID
                aRundownStatus[i+j] = ORS_DONTRUNDOWN;
            }
            else
            {
                // don't know about this OID, look it up
                Win4Assert(arResult[j] == RUNDWN_UNKNOWN);

                MOID moid;
                MOIDFromOIDAndMID(aOid[i+j], gLocalMid, &moid);
#if DBG==1
                arMOID[j] = moid;
#endif
                hr = ObtainStdIDFromOID(moid, dwAptId, TRUE, &arpStdId[j]);
                if (SUCCEEDED(hr))
                {
                    // found it, ask the stdid if it can be run down.
                    Win4Assert(arpStdId[j] != NULL);
                    aRundownStatus[i+j] = arpStdId[j]->CanRunDown(iNow);

                    // assert stdid returned valid status
                    Win4Assert(aRundownStatus[i+j] == ORS_DONTRUNDOWN ||
                               aRundownStatus[i+j] == ORS_OK_TO_RUNDOWN ||
                               aRundownStatus[i+j] == ORS_OID_PINNED);
                }
                else 
                {
                    // if we did not find it, could be because the OID is in an
                    // intermediate stage (not in the list, but not yet registered
                    // either, default to FALSE).
                    Win4Assert(arpStdId[j] == NULL);
                    aRundownStatus[i+j] = ORS_DONTRUNDOWN;
                }
            }
        }

        UNLOCK(gComLock);
        ASSERT_LOCK_NOT_HELD(gComLock);

        for (j=0; i+j<cOid && j<cAlloc; j++)
        {
            Win4Assert(i<cOid);
            CStdIdentity *pStdId = arpStdId[j];
            if (pStdId)
            {
                if (aRundownStatus[i+j] == ORS_OK_TO_RUNDOWN)
                {
                    ComDebOut((DEB_MARSHAL,
                       "Running Down Object: pStdId:%x pCtrlUnk:%x moid:%I\n",
                        pStdId, pStdId->GetCtrlUnk(), &arMOID[j]));
                    pStdId->DisconnectAndRelease(DISCTYPE_RUNDOWN);
                }
                else
                {
                    pStdId->Release();
                }
            }
        }

        // increment the counter
        i += j;
    }

    pComApt->Release();

#if DBG==1
    // print out the results
    ULONG *ptr = (ULONG *)aOid;
    for (ULONG k=0; k<cOid; k++, ptr+=2)
    {
        ComDebOut((DEB_MARSHAL, "OID: %x %x  Result:%s\n", *ptr, *(ptr+1),
                  (aRundownStatus[k] == ORS_OK_TO_RUNDOWN) ? "RUNDOWN" : "KEEP"));
    }
#endif // DBG==1

    ASSERT_LOCK_NOT_HELD(gComLock);
    return S_OK;
}


//+-------------------------------------------------------------------
//
//  Method:     DoCallback                Internal
//
//  Synopsis:   This method is used for the apartment switching part
//              of the context callback implementation
//
//  History:    19-Apr-98   Johnstra      Created
//              30-Jun-98   GopalK        Rewritten
//
//+-------------------------------------------------------------------
STDMETHODIMP CRemoteUnknown::DoCallback(XAptCallback *pCallbackData)
{
    ContextDebugOut((DEB_WRAPPER, "CRemoteUnknown::DoCallback\n"));
    ASSERT_LOCK_NOT_HELD(gComLock);

    HRESULT hr;
    hr = gProcessSecret.VerifyMatchingSecret(pCallbackData->guidProcessSecret);
    if (FAILED(hr))
    {
       Win4Assert(!"CRemoteUnknown::DoCallback called from out of process!");
       return hr;
    }
    CObjectContext *pServerCtx = (CObjectContext *) pCallbackData->pServerCtx;

    // Check for the need to switch
    if (pServerCtx != GetCurrentContext())
    {
        BOOL fCreate = TRUE;
        CPolicySet *pPS;

        // Obtain policy set
        hr = ObtainPolicySet(NULL, pServerCtx, PSFLAG_STUBSIDE,
                             &fCreate, &pPS);
        if(SUCCEEDED(hr))
        {
            // Execute callback
            hr = SwitchForCallback(pPS,
                                   (PFNCTXCALLBACK) pCallbackData->pfnCallback,
                                   (void *) pCallbackData->pParam,
                                   pCallbackData->iid,
                                   pCallbackData->iMethod,
                                   (IUnknown *) pCallbackData->pUnk);

            // Release policy set
            pPS->Release();
        }
    }
    else
    {
        // Execute the callback
        hr = ((PFNCTXCALLBACK) pCallbackData->pfnCallback)((void *) pCallbackData->pParam);
    }

    ASSERT_LOCK_NOT_HELD(gComLock);
    ContextDebugOut((DEB_WRAPPER,
                     "CRemoteUnknown::DoCallback returning hr:0x%x\n", hr));
    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\com\dcomrem\sources.inc ===
!IF 0

Copyright (c) 1998  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.

!ENDIF

TARGETNAME=   remote
TARGETPATH=   obj
TARGETTYPE=   LIBRARY

INCLUDES    = \
    ..\..\..\common\$(DEST_TREE);\
    ..\..\..\ih;\
    ..;..\..\inc;\
    ..\..\class;\
    ..\..\objact;\
    ..\..\..\idl\public\$(DEST_TREE)\$(O);\
    ..\..\..\idl\internal\$(DEST_TREE)\$(O);\
    ..\..\..\idl\private\$(DEST_TREE)\$(O);\
    ..\..\..\actprops;\
    $(BASE_INC_PATH);\
    $(DS_INC_PATH)

MIDL_UUIDDIR=$(O)
PASS0_SOURCEDIR=$(O)
PASS0_HEADERDIR=$(O)
MIDL_TLBDIR=$(O)

C_DEFINES=    \
              $(C_DEFINES) -DMSWMSG

SOURCES=      $(SOURCES)      \
              ..\stub_rawprivact_c.c  \
              ..\aggid.cxx    \
              ..\aprtmnt.cxx  \
              ..\callctrl.cxx \
              ..\call.cxx     \
              ..\callmgr.cxx  \
              ..\chancont.cxx \
              ..\channelb.cxx \
              ..\chock.cxx    \
              ..\coapi.cxx    \
              ..\context.cxx  \
              ..\crossctx.cxx \
              ..\ctxchnl.cxx  \
              ..\destobj.cxx  \
              ..\events.cxx   \
              ..\excepn.cxx   \
              ..\giptbl.cxx   \
              ..\hash.cxx     \
              ..\idobj.cxx    \
              ..\ipaddr.cxx   \
              ..\ipidtbl.cxx  \
              ..\ipmrshl.cxx  \
              ..\locks.cxx    \
              ..\marshal.cxx  \
              ..\orpc_dbg.c   \
              ..\pgalloc.cxx  \
              ..\pstable.cxx  \
              ..\rpchelp.cxx  \
              ..\refcache.cxx \
              ..\remoteu.cxx  \
              ..\resolver.cxx \
              ..\riftbl.cxx   \
              ..\rpcopt.cxx   \
              ..\security.cxx \
              ..\service.cxx  \
              ..\stdid.cxx    \
              ..\stream.cxx   \
              ..\sync.cxx     \
              ..\surract.cxx  \
              ..\threads.cxx  \
              ..\svcdomain.cxx \
              ..\machname.cxx \
              ..\globalopt.cxx \

UMTYPE=       windows

!include ..\..\precomp2.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\com\dcomrem\rpcopt.cxx ===
//+-------------------------------------------------------------------
//
//  File:       rpcopt.cxx
//
//  Contents:   class for implementing IRpcOptions
//
//  Classes:    CRpcOptions
//
//  History:    09-Jan-97    MattSmit       Created
//
//--------------------------------------------------------------------

#include <ole2int.h>
#include <locks.hxx>

#if (_WIN32_WINNT >= 0x500)
#include <ctxchnl.hxx>
#else
#include <channelb.hxx>
#endif

#include <ipidtbl.hxx>
#include "rpcopt.hxx"

//+-------------------------------------------------------------------
//
// Section:   IUnknown Methods for CRpcOptions
//
//--------------------------------------------------------------------

STDMETHODIMP CRpcOptions::QueryInterface(REFIID riid, LPVOID *pv)
{
    return _pUnkOuter->QueryInterface(riid, pv);
}

STDMETHODIMP_(ULONG) CRpcOptions::AddRef()
{
    return _pUnkOuter->AddRef();
}

STDMETHODIMP_(ULONG) CRpcOptions::Release()
{
    return _pUnkOuter->Release();
}


//+-------------------------------------------------------------------
//
// Section:   IRpcOptions Methods for CRpcOptions
//
//--------------------------------------------------------------------


CRpcOptions::CRpcOptions(CStdIdentity *pStdId, IUnknown *pUnkOuter)
    : _pStdId(pStdId), _pUnkOuter(pUnkOuter)
{
//    Win4Assert(_pStdId);
//    Win4Assert(_pUnkOuter);
}




//+-------------------------------------------------------------------
//
// Member:     Set
//
// Synopsis:   Set message queue specific properties on a proxy
//
// Arguments:
//   pPrx -       [in] Indicates the proxy to set.
//   dwProperty - [in] A single DWORD value from the COMBND_xxxx enumeration
//   dwValue -    [in] A single DWORD specifying the value for the
//                property being set.
//
// Returns:    S_OK, E_INVALIDARG
//
// Algorithm:  Use the IPID table to find the corresponding channel
//             object.  Query the channel object for the binding
//             handle and set the option on the handle
//
// History:    09-Jan-96    MattSmit  Created
//
//--------------------------------------------------------------------


STDMETHODIMP CRpcOptions::Set( IUnknown * pPrx,
                               DWORD      dwProperty,
                               ULONG_PTR  dwValue)
{
    ComDebOut((DEB_TRACE, "CRpcOptions::Set pPrx = 0x%p, dwProperty = 0x%x, dwValue = 0x%p\n",
               pPrx, dwProperty, dwValue));



#if (_WIN32_WINNT >= 0x500)
    ASSERT_LOCK_NOT_HELD(gIPIDLock);

    CChannelHandle *pRpc;
#else
    ASSERT_LOCK_RELEASED

    handle_t       hRpc;
#endif

    CRpcChannelBuffer *pChannel;
    HRESULT hr = S_OK;

    // parameter checking

    if (!IsValidInterface(pPrx) ||
        (dwProperty != COMBND_RPCTIMEOUT))
    {
        hr = E_INVALIDARG;
    }
    else
    {
        // Implements COMBND_RPCTIMEOUT

        // get the binding handle
#if (_WIN32_WINNT >= 0x500)
        hr = ProxyToBindingHandle(pPrx, &pRpc, TRUE);
#else
        hr = ProxyToBindingHandle(pPrx, &hRpc);
#endif
        if (SUCCEEDED(hr))
        {
            // set the properties.
#if (_WIN32_WINNT >= 0x500)
            RPC_STATUS sc = RpcMgmtSetComTimeout(pRpc->_hRpc, PtrToUint((void *)dwValue));
#else
            RPC_STATUS sc = RpcMgmtSetComTimeout(hRpc, dwValue);
#endif
            if (sc != RPC_S_OK)
            {
                hr = MAKE_SCODE(SEVERITY_ERROR, FACILITY_RPC, sc);
            }
#if (_WIN32_WINNT >= 0x500)
            pRpc->Release();
#endif
        }

    }

#if (_WIN32_WINNT >= 0x500)
    ASSERT_LOCK_NOT_HELD(gIPIDLock);
#else
    ASSERT_LOCK_RELEASED
#endif

    return hr;
}

//+-------------------------------------------------------------------
//
// Member:     Query
//
// Synopsis:   Query message queue specific properties on a proxy
//
// Arguments:
//   pPrx -        [in] Indicates the proxy to query.
//   pdwProperty - [in] A single DWORD value from the COMBND_xxxx enumeration
//   dwValue -     [in] A single DWORD pointer specifying where to place
//                 the result of the query
//
// Returns:    S_OK, E_INVALIDARG
//
// Algorithm:  Use the IPID table to find the corresponding channel
//             object.  Query the channel object for the binding
//             handle and query the binding handle for the property
//             status.
//
// History:    09-Jan-96    MattSmit  Created
//
//--------------------------------------------------------------------


STDMETHODIMP CRpcOptions::Query( IUnknown * pPrx,
                                 DWORD dwProperty,
                                 ULONG_PTR * pdwValue)
{
    ComDebOut((DEB_TRACE, "CRpcOptions::Query pPrx = 0x%p, dwProperty = 0x%x, pdwValue = 0x%p\n",
               pPrx, dwProperty, pdwValue));



#if (_WIN32_WINNT >= 0x500)
    ASSERT_LOCK_NOT_HELD(gIPIDLock);

    CChannelHandle *pHandle;
#else
    ASSERT_LOCK_RELEASED

    handle_t       pHandle;
#endif

    HRESULT hr = S_OK;

    // parameter checking

    if (!IsValidInterface(pPrx) ||
       !IsValidPtrOut(pdwValue, sizeof(ULONG_PTR)) ||
        ((dwProperty != COMBND_RPCTIMEOUT) && (dwProperty != COMBND_SERVER_LOCALITY)))
    {
        hr = E_INVALIDARG;
    }
    else
    {
        // For COMBND_RPCTIMEOUT

        // Query the binding handle
#if (_WIN32_WINNT >= 0x500)
        hr = ProxyToBindingHandle(pPrx, &pHandle, FALSE);
#else
        hr = ProxyToBindingHandle(pPrx, &pHandle);
#endif

        // set the property
        if (SUCCEEDED(hr))
        {
            if (COMBND_RPCTIMEOUT == dwProperty) 
            {
               RPC_STATUS sc;
   
   #if (_WIN32_WINNT >= 0x500)
               UINT dwTimeout = 0;
               sc = RpcMgmtInqComTimeout(pHandle->_hRpc, &dwTimeout);
               *pdwValue = dwTimeout;      //Allow Compiler to widen it on Win64
   #else
               sc = RpcMgmtInqComTimeout(pHandle, (UINT*)pdwValue);
   #endif
   
               if (sc != RPC_S_OK)
               {
                   hr = MAKE_SCODE(SEVERITY_ERROR, FACILITY_WIN32, sc);
               }
            }
            else if (COMBND_SERVER_LOCALITY == dwProperty) 
            {
               (pHandle->_eState & process_local_hs) ? *pdwValue = SERVER_LOCALITY_PROCESS_LOCAL:
               (pHandle->_eState & machine_local_hs) ? *pdwValue = SERVER_LOCALITY_MACHINE_LOCAL:
               *pdwValue = SERVER_LOCALITY_REMOTE;
            }
            else
               Win4Assert( !"IRpcOptions::Query: Incorrect option" );
               
#if (_WIN32_WINNT >= 0x500)
            pHandle->Release();
#endif
        }

#if (_WIN32_WINNT >= 0x500)
        ASSERT_LOCK_NOT_HELD(gIPIDLock);
#else
        ASSERT_LOCK_RELEASED
#endif

    }
    return hr;

}


//+-------------------------------------------------------------------
//
// Member:     ProxyToBindingHandle
//
// Synopsis:   Use internal DCOM data structure to get the corr-
//             esponding binding handle for the specified proxy.
//
// Arguments:
//   pPrx          [in]  proxy
//   pHandle       [out] Channel handle
//   fSave         [in]  {W2K}Whether the binding handle, if created, is saved in the channel
//
// Returns:    S_OK, E_INVALIDARG
//
// Algorithm:  Verify the parameters. Use the proxy manager to get
//             the proxy's IPID entry.  Get the handle from the
//             channel object in the IPID entry.
//
// History:    09-Jan-96    MattSmit  Created
//
//--------------------------------------------------------------------



#if (_WIN32_WINNT >= 0x500)
HRESULT CRpcOptions::ProxyToBindingHandle(void *pPrx, CChannelHandle **pHandle, BOOL fSave )
#else
HRESULT CRpcOptions::ProxyToBindingHandle(void *pPrx, handle_t *pHandle )
#endif
{
    ComDebOut((DEB_TRACE,
              "CRpcOptions::ProxyToBindingHandle pPrx = 0x%p, pHandle = 0x%p\n",
              pPrx, pHandle));

#if (_WIN32_WINNT >= 0x500)
    ASSERT_LOCK_NOT_HELD(gIPIDLock);
    LOCK(gIPIDLock);
#else
    ASSERT_LOCK_RELEASED
    LOCK(gComLock);
#endif

    IPIDEntry *pIPID;
    HRESULT hr = _pStdId->FindIPIDEntryByInterface(pPrx, &pIPID);

    if (SUCCEEDED(hr))
    {
        // disallow server entries
        if (pIPID->dwFlags & IPIDF_SERVERENTRY)
        {
            hr = E_INVALIDARG;
        }
        // No rpc options for disconnected proxies.
        else if (pIPID->dwFlags & IPIDF_DISCONNECTED)
        {
            hr = RPC_E_DISCONNECTED;
        }
        // No rpc options for process local proxies.
        else if (pIPID->pChnl->ProcessLocal())
        {
            hr = E_INVALIDARG;
        }
        else
        {
#if (_WIN32_WINNT >= 0x500)
            hr = pIPID->pChnl->GetHandle(pHandle, fSave);
#else
            hr = pIPID->pChnl->GetHandle(pHandle);
#endif

        }
    }

#if (_WIN32_WINNT >= 0x500)
    UNLOCK(gIPIDLock);
#else
    UNLOCK(gComLock);
#endif

    return hr;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\com\dcomrem\service.cxx ===
//+-------------------------------------------------------------------
//
//  File:       service.cxx
//
//  Contents:   APIs to simplify RPC setup
//
//  Functions:
//
//  History:    23-Nov-92   Rickhi
//              20-Feb-95   Rickhi  Major Simplification for DCOM
//              20-Jan-97   Ronans  Merged predefined  endpoint changes
//
//--------------------------------------------------------------------
#include    <ole2int.h>
#include    <service.hxx>           // CRpcService
#include    <orcb.h>                // IOrCallback
#include    <malloc.hxx>            // MIDL_user_allocate
#include    <locks.hxx>             // LOCK/UNLOCK etc
#include    <security.hxx>          // gpsaSecurity
#include    <riftbl.hxx>            // gRemUnknownIf. gRemUnknownIf2
#include    <TCHAR.H>               // portability macros
#include    <netevent.h>            // EVENT_DCOM_INVALID_ENDPOINT_DATA
#include    <secdes.hxx>            // Security descriptor utilities
#include    <resolver.hxx>          // CRpcResolver 
#include    <ipidtbl.hxx>           // CMIDTable
#include    <reghelp.hxx>

BOOL             gSpeedOverMem      = FALSE;    // Trade memory for speed.
BOOL             gfListening        = FALSE;    // Server is/isn't listening
BOOL             gfDefaultStrings   = FALSE;    // Using precomputed string bindings
BOOL             gfLrpc             = FALSE;    // Registered for ncalrpc
DWORD            gdwPsaMaxSize      = 0;
DUALSTRINGARRAY *gpsaCurrentProcess = NULL;
const DWORD      MAX_LOCAL_SB       = 23 + GUIDSTR_MAX +3;
extern GUID      g_AppId;
WCHAR            gwszLRPCEndPoint[GUIDSTR_MAX];

CWorldSecurityDescriptor* pLrpcSecurityDescriptor = NULL;
BOOL                      fLrpcSDInitialized = FALSE;

// ronans - flags for endpoint processing
#define POLICY_PROTSEQ_DISALLOWED 3

// flag to indicate endpoints have been added programmatically
// in this case no endpoints will be read from registry
static BOOL sfProgrammaticEndpoints = FALSE;

// flag to indicate if endpoints have already been processed for server
// if so disallow any more endpoints
static BOOL sfEndpointsProcessed = FALSE;

// forward declarations for predefined endpoint processing
static HRESULT wGetFinalEndpointTable();

// global endpoint table per process
CEndpointsTable gEndpointsTable;

// ronans DCOMHTTTP
// CODEWORK - add this to common header
#ifndef ID_DCOMHTTP
#define ID_DCOMHTTP (0x1f)
#endif

// Private Interface Registration. We need to register interfaces such as
// IOrCallback and IRemUnknown, and IRemUnknown2 because these never get
// marshaled by CoMarshalInterface.
typedef struct tagRegIf
{
    RPC_IF_HANDLE       hServerIf;      // interface handle
    DWORD               dwRegFlags;     // registration flags
    RPC_IF_CALLBACK_FN* pfnSecurityCB;  // RPC security callback function
} RegIf;

RegIf   arDcomInterfaces[] =
        {
            {_IOrCallback_ServerIfHandle, RPC_IF_AUTOLISTEN, RPCSStoOLE32SecurityCallback },          
            {(RPC_IF_HANDLE) &gRemUnknownIf,  RPC_IF_AUTOLISTEN | RPC_IF_OLE, NULL },
            {(RPC_IF_HANDLE) &gRemUnknownIf2, RPC_IF_AUTOLISTEN | RPC_IF_OLE, NULL },
        };
const ULONG cDcomInterfaces = sizeof(arDcomInterfaces)/sizeof(RegIf);

#if DBG==1
//+-------------------------------------------------------------------
//
//  Function:   DisplayAllStringBindings, private
//
//  Synopsis:   prints the stringbindings to the debugger
//
//  Notes:      This function requires the caller to hold gComLock.
//
//  History:    23-Nov-93   Rickhi       Created
//
//--------------------------------------------------------------------
void DisplayAllStringBindings(void)
{
    ASSERT_LOCK_HELD(gComLock);

    if (gpsaCurrentProcess)
    {
        LPWSTR pwszNext = gpsaCurrentProcess->aStringArray;
        LPWSTR pwszEnd = pwszNext + gpsaCurrentProcess->wSecurityOffset;

        while (pwszNext < pwszEnd)
        {
            ComDebOut((DEB_CHANNEL, "pSEp=%x %ws\n", pwszNext, pwszNext));
            pwszNext += lstrlenW(pwszNext) + 1;
        }
    }
}
#endif // DBG == 1


//+-------------------------------------------------------------------
//
//  Function:   InitializeLrpcSecurity, private
//
//  Synopsis:   Create a DACL allowing all access to NCALRPC endpoints.
//
//--------------------------------------------------------------------
void InitializeLrpcSecurity()
{
    if (!fLrpcSDInitialized)
    {
        //
        // This function may be called by multiple threads
        // simultaneously and we don't want to allocate more than
        // one object. Hence the InterlockedCompareExchange trick.
        //

        CWorldSecurityDescriptor *pWSD = new CWorldSecurityDescriptor;
        if(!pWSD) return;

        if(InterlockedCompareExchangePointer((PVOID*) &pLrpcSecurityDescriptor,
                                             pWSD,
                                             NULL) != NULL)
        {            
            delete pWSD;  // Someone beat us.
        }
        else
        {
            fLrpcSDInitialized = TRUE;
        }

    }
}

//+-------------------------------------------------------------------
//
//  Function:   RegisterLrpc, private
//
//  Synopsis:   Register the ncalrpc transport.
//
//--------------------------------------------------------------------
RPC_STATUS RegisterLrpc()
{
    RPC_STATUS sc;
    WCHAR      pwszEndPoint[GUIDSTR_MAX+3+1];
    HANDLE     hThread;
    BOOL       fRet;

    InitializeLrpcSecurity();
    if(!pLrpcSecurityDescriptor)
        return RPC_S_OUT_OF_MEMORY;

    lstrcpyW( pwszEndPoint, L"OLE" );
    lstrcatW( pwszEndPoint, gwszLRPCEndPoint);

    // Make sure RPC doesn't create any threads while impersonating.
    SuspendImpersonate( &hThread );

    // The second parameter is a hint that tells lrpc whether or not it
    // can preallocate additional resources (threads).

    ComDebOut((DEB_CHANNEL, "->RpcServerUseProtseqEp(protseq=ncalrpc, maxcalls= %lu, endpt=%ws, xxx)\n",
              gSpeedOverMem ? RPC_C_PROTSEQ_MAX_REQS_DEFAULT + 1 : RPC_C_PROTSEQ_MAX_REQS_DEFAULT,
              pwszEndPoint));
    sc = RpcServerUseProtseqEp(L"ncalrpc",
                               RPC_C_PROTSEQ_MAX_REQS_DEFAULT + 1,
                               pwszEndPoint,
                               pLrpcSecurityDescriptor);
    ComDebOut((DEB_CHANNEL, "<-RpcServerUseProtseqEp(status=0x%x)\n",sc));

    // Put the impersonation token back.
    ResumeImpersonate( hThread );

    // Duplicate endpoint can mean that somebody is squatting on our endpoint, bail.
    if (sc == RPC_S_DUPLICATE_ENDPOINT)
    {
       ComDebOut((DEB_CHANNEL, "COM:ncalrpc EndPoint %s already in use!", pwszEndPoint));
       Win4Assert(!"ncalrpc EndPoint already in use!");
    }
    else if (sc == RPC_S_OK)
    {
        gfLrpc = TRUE;
    }
    return sc;
}

//+-------------------------------------------------------------------
//
//  Function:   CheckLrpc, private
//
//  Synopsis:   Register the ncalrpc transport if not already registered.
//
//--------------------------------------------------------------------
HRESULT CheckLrpc()
{
    RPC_STATUS sc = S_OK;
    WCHAR wszLRPCEndPoint[GUIDSTR_MAX];

    ASSERT_LOCK_DONTCARE(gComLock);
    LOCK(gComLock);

    if (!gfLrpc)
    {
       GUID guidLRPCEndPoint;
       sc = UuidCreate(&guidLRPCEndPoint);
       Win4Assert(SUCCEEDED(sc));
       if (RPC_S_OK == sc) 
       {
          //RPC has a limit of 32 WCHARs for portnames. We have a 3 WCHAR prefix
	  
	  // Also get rid of fluff like the opening/closing braces and 
	  // the hyphens, which do not contribute to randomness
          
	  // returns string with no braces
	  wStringFromUUID(guidLRPCEndPoint,wszLRPCEndPoint); 
	  
          lstrcpynW(gwszLRPCEndPoint, wszLRPCEndPoint, 9);
          lstrcpynW(gwszLRPCEndPoint+8, wszLRPCEndPoint+9, 5);
          lstrcpynW(gwszLRPCEndPoint+12, wszLRPCEndPoint+14, 5);
          lstrcpynW(gwszLRPCEndPoint+16, wszLRPCEndPoint+19, 5);
          lstrcpynW(gwszLRPCEndPoint+20, wszLRPCEndPoint+24, 9);
          // Register LRPC.
          sc = RegisterLrpc();
          
       }
       if (sc != RPC_S_OK)
          sc = HRESULT_FROM_WIN32(sc);
    }

    UNLOCK(gComLock);
    ASSERT_LOCK_DONTCARE(gComLock);
    return sc;
}



//+-------------------------------------------------------------------
//
//  Function:   DefaultStringBindings, private
//
//  Synopsis:   Create a string binding with an entry for just ncalrpc.
//
//  Notes:      This function requires the caller to hold gComLock.
//
//--------------------------------------------------------------------
RPC_STATUS DefaultStringBindings()
{
    ULONG cChar;
    BOOL fRet;

    ASSERT_LOCK_HELD(gComLock);

    // Reserve space for the string
    // ncalrpc:[OLE{GUID}]
    Win4Assert(gfLrpc);

    // Allocate memory.  Reserve space for an empty security binding.
    gpsaCurrentProcess = (DUALSTRINGARRAY *) PrivMemAlloc( SASIZE(27+GUIDSTR_MAX+3) );

    // Give up if the allocation failed.
    if (gpsaCurrentProcess == NULL)
        return RPC_S_OUT_OF_RESOURCES;

    // Build a string binding for ncalrpc.
    lstrcpyW( gpsaCurrentProcess->aStringArray, L"ncalrpc:[OLE" );
    lstrcatW(gpsaCurrentProcess->aStringArray, gwszLRPCEndPoint);

    cChar = lstrlenW( gpsaCurrentProcess->aStringArray );
    gpsaCurrentProcess->aStringArray[cChar++] = L']';
    gpsaCurrentProcess->aStringArray[cChar++] = 0;

    // Stick on an empty security binding.
    gpsaCurrentProcess->aStringArray[cChar++] = 0;
    gpsaCurrentProcess->wSecurityOffset       = (USHORT) cChar;
    gpsaCurrentProcess->aStringArray[cChar++] = 0;
    gpsaCurrentProcess->aStringArray[cChar++] = 0;
    gpsaCurrentProcess->wNumEntries           = (USHORT) cChar;
    gfDefaultStrings                          = TRUE;
    return RPC_S_OK;
}


//+-------------------------------------------------------------------
//
//  Function:   InquireStringBindings, private
//
//  Synopsis:   Get and server binding handles from RPC and convert them
//              into a string array.
//
//  Notes:      This function requires the caller to hold gComLock.
//
//  History:    23 May 95 AlexMit       Created
//
//--------------------------------------------------------------------
BOOL InquireStringBindings( WCHAR *pProtseq)
{
    ASSERT_LOCK_HELD(gComLock);

    BOOL                fFound    = FALSE;
    DWORD               cbProtseq;
    RPC_BINDING_VECTOR *pBindVect = NULL;
    RPC_STATUS sc = RpcServerInqBindings(&pBindVect);


    if (sc == S_OK)
    {
        LPWSTR *apwszFullStringBinding;
        ULONG  *aulStrLen;
        ULONG   ulTotalStrLen = MAX_LOCAL_SB; // Total string lengths
        ULONG   j             = 0;            // BindString we're using

        if (pProtseq != NULL)
            cbProtseq = lstrlenW( pProtseq ) * sizeof(WCHAR);
        else
            cbProtseq = 0;
        apwszFullStringBinding = (LPWSTR *) PrivMemAlloc( pBindVect->Count *
                                                          sizeof(LPWSTR) );
        aulStrLen              = (ULONG *)  PrivMemAlloc( pBindVect->Count *
                                                          sizeof(ULONG) );
        if (apwszFullStringBinding != NULL &&
            aulStrLen              != NULL)
        {
            //  iterate over the handles to get the string bindings
            //  and dynamic endpoints for all available protocols.

            for (ULONG i=0; i<pBindVect->Count; i++)
            {
                LPWSTR  pwszStringBinding = NULL;
                LPWSTR  pwszProtseq       = NULL;
                LPWSTR  pwszEndpoint      = NULL;
                LPWSTR  pwszNetworkAddr   = NULL;

                apwszFullStringBinding[j] = NULL;
                aulStrLen[j]              = 0;

                sc = RpcBindingToStringBinding(pBindVect->BindingH[i],
                                               &pwszStringBinding);
                if (sc == RPC_S_OK)
                {

                    sc = RpcStringBindingParse(pwszStringBinding,
                                               0,
                                               &pwszProtseq,
                                               &pwszNetworkAddr,
                                               &pwszEndpoint,
                                               0);



                    ComDebOut((DEB_MARSHAL, "InquireStringBindings processing binding %ws\n", pwszStringBinding));


                    if (sc == RPC_S_OK)
                    {
                        // Determine is this is the protseq we are looking for.
                        if (memcmp( pProtseq, pwszStringBinding, cbProtseq ) == 0)
                            fFound = TRUE;

                        // Skip OLE ncalrpc endpoints -- added back in below
                        if ( (lstrcmpW( L"ncalrpc", pwszProtseq)  != 0) ||
                             (lstrlenW(pwszEndpoint) < 3) ||
                             (lstrcmpW( L"OLE", pwszEndpoint) != 0))
                        {
                            // Ignore TCP bindings with localhost adress...
                            if ((lstrcmpW( L"ncacn_ip_tcp", pwszProtseq)  == 0) && (lstrcmpW( L"127.0.0.1", pwszNetworkAddr)  == 0)) 
                            {
                               RpcStringFree( &pwszStringBinding );
                            }
                            else
                            {
                               //  record the string lengths for later. include room
                               //  for the NULL terminator.
                               apwszFullStringBinding[j] = pwszStringBinding;
                               aulStrLen[j]              = lstrlenW(apwszFullStringBinding[j])+1;
                               ulTotalStrLen            += aulStrLen[j];
                               j++;
                            }

                        }
                        else
                        {
                            RpcStringFree( &pwszStringBinding );
                        }
                        RpcStringFree(&pwszNetworkAddr);
                        RpcStringFree(&pwszProtseq);
                        RpcStringFree(&pwszEndpoint);
                    }
                }
            }   //  for


            //  now that all the string bindings and endpoints have been
            //  accquired, allocate a DUALSTRINGARRAY large enough to hold them
            //  all and copy them into the structure.

            if (ulTotalStrLen > 0)
            {
                void *pNew = PrivMemAlloc( sizeof(DUALSTRINGARRAY) +
                                           (ulTotalStrLen+1)*sizeof(WCHAR) );
                if (pNew)
                {
                    PrivMemFree( gpsaCurrentProcess );
                    gpsaCurrentProcess = (DUALSTRINGARRAY *) pNew;
                    LPWSTR pwszNext    = gpsaCurrentProcess->aStringArray;

                    // Copy in ncalrpc:[OLE{GUID}]
                    if (gfLrpc)
                    {	
                        BOOL fRet;
                        lstrcpyW( pwszNext, L"ncalrpc:[OLE" );
                        lstrcatW( pwszNext, gwszLRPCEndPoint);
                        lstrcatW( pwszNext, L"]" );
                        pwszNext += lstrlenW(pwszNext) + 1;
                    }

                    // copy in the strings
                    for (i=0; i<j; i++)
                    {
                        lstrcpyW(pwszNext, apwszFullStringBinding[i]);
                        pwszNext += aulStrLen[i];
                    }

                    // Add a second null to terminate the string binding
                    // set.  Add a third and fourth null to create an empty
                    // security binding set.

                    pwszNext[0] = 0;
                    pwszNext[1] = 0;
                    pwszNext[2] = 0;

                    // Fill in the size fields.
                    gpsaCurrentProcess->wSecurityOffset = (USHORT) (pwszNext -
                                       gpsaCurrentProcess->aStringArray + 1);
                    gpsaCurrentProcess->wNumEntries =
                                       gpsaCurrentProcess->wSecurityOffset + 2;
                }
                else
                {
                    sc = RPC_S_OUT_OF_RESOURCES;
                }
            }
            else
            {
                //  no binding strings. this is an error.
                ComDebOut((DEB_ERROR, "No Rpc ProtSeq/EndPoints Generated\n"));
                sc = RPC_S_NO_PROTSEQS;
            }

            // free the full string bindings we allocated above
            for (i=0; i<j; i++)
            {
                //  free the old strings
                RpcStringFree(&apwszFullStringBinding[i]);
            }
        }
        else
        {
            sc = RPC_S_OUT_OF_RESOURCES;
        }

        //  free the binding vector allocated above
        RpcBindingVectorFree(&pBindVect);
        PrivMemFree( apwszFullStringBinding );
        PrivMemFree( aulStrLen );
    }

#if DBG==1
    //  display our binding strings on the debugger
    DisplayAllStringBindings();
#endif

    return fFound;
}

//+-------------------------------------------------------------------
//
//  Function:   StartListen, public
//
//  Synopsis:   this starts the Rpc service listening. this is required
//              in order to marshal interfaces.  it is executed lazily,
//              that is, we dont start listening until someone tries to
//              marshal a local object interface. this is done so we dont
//              spawn a thread unnecessarily.
//
//  Notes:      This function takes gComLock.
//
//  History:    23-Nov-93   Rickhi       Created
//
//--------------------------------------------------------------------
HRESULT StartListen(void)
{
    if (gfListening)
    {
        //already listening
        return S_OK;
    }

    ComDebOut((DEB_MARSHAL,"[IN] StartListen.\n"));
    RPC_STATUS sc = S_OK;

    ASSERT_LOCK_NOT_HELD(gComLock);
    LOCK(gComLock);

    if (!gfListening)
    {
        // Register ncalrpc.
        sc = CheckLrpc();
        if (sc == S_OK)
        {
            // register the private DCOM interfaces that dont get registered
            // during CoMarshalInterface.
            sc = RegisterDcomInterfaces();

            if (sc == RPC_S_OK)
            {
                sc = DefaultStringBindings();
            }
            if (sc != RPC_S_OK)
            {
                sc = HRESULT_FROM_WIN32(sc);
            }
        }

        if (sc == RPC_S_OK)
        {
            gfListening = TRUE;
            sc = S_OK;
        }
    }

    UNLOCK(gComLock);
    ASSERT_LOCK_NOT_HELD(gComLock);

    // If something failed, make sure everything gets cleaned up.
    if (FAILED(sc))
    {
        UnregisterDcomInterfaces();
    }

    ComDebOut(((sc == S_OK) ? DEB_MARSHAL : DEB_ERROR,
               "[OUT] StartListen hr: 0x%x\n", sc));
    return sc;
}

//+-------------------------------------------------------------------
//
//  Function:   GetStringBindings, public
//
//  Synopsis:   Return an array of strings bindings for this process
//
//  Notes:      This function takes gComLock.
//
//  History:    23-Nov-93   Rickhi       Created
//
//--------------------------------------------------------------------
HRESULT GetStringBindings( DUALSTRINGARRAY **psaStrings )
{
    ComDebOut((DEB_CHANNEL, "[IN]  GetStringBindings\n"));

    *psaStrings = NULL;

    HRESULT hr = StartListen();
    if (SUCCEEDED(hr))
    {
        LOCK(gComLock);
        hr = CopyStringArray(gpsaCurrentProcess, gpsaSecurity, psaStrings);
        UNLOCK(gComLock);
    }

    ComDebOut((DEB_CHANNEL, "[OUT] GetStringBindings hr:%x\n", hr));
    return hr;
}


//+-------------------------------------------------------------------
//
//  Function:   CopyStringArray, public
//
//  Synopsis:   Combines the string bindings from the first DUALSTRINGARRAY
//              with the security bindings from the second DUALSTRINGARRAY
//              (if present) into a new DUALSTRINGARRAY.
//
//  History:    23-Nov-93   Rickhi       Created
//
//--------------------------------------------------------------------
HRESULT CopyStringArray(DUALSTRINGARRAY *psaStringBinding,
                        DUALSTRINGARRAY *psaSecurity,
                        DUALSTRINGARRAY **ppsaNew)
{
    // compute size of string bindings
    USHORT lSizeSB = SASIZE(psaStringBinding->wNumEntries);

    // compute size of additional security strings
    USHORT lSizeSC = (USHORT) (psaSecurity == NULL ? 0 :
      psaSecurity->wNumEntries - psaSecurity->wSecurityOffset);

    *ppsaNew = (DUALSTRINGARRAY *) PrivMemAlloc( lSizeSB +
                                                 lSizeSC * sizeof(USHORT));

    if (*ppsaNew != NULL)
    {
        // copy in the string bindings
        memcpy(*ppsaNew, psaStringBinding, lSizeSB);

        if (psaSecurity != NULL)
        {
            // copy in the security strings, and adjust the overall length.
            memcpy(&(*ppsaNew)->aStringArray[psaStringBinding->wSecurityOffset],
                   &psaSecurity->aStringArray[psaSecurity->wSecurityOffset],
                   lSizeSC*sizeof(USHORT));

            (*ppsaNew)->wNumEntries = psaStringBinding->wSecurityOffset +
                                      lSizeSC;
        }
        return S_OK;
    }

    return E_OUTOFMEMORY;
}

//+-------------------------------------------------------------------
//
//  Function:   RegisterDcomInterfaces
//
//  Synopsis:   Register the private DCOM interfaces.
//
//  History:    23-Nov-93   Rickhi       Created
//
//--------------------------------------------------------------------
SCODE RegisterDcomInterfaces(void)
{
    ComDebOut((DEB_CHANNEL, "[IN] RegisterDcomInterfaces\n"));
    ASSERT_LOCK_HELD(gComLock);

    RPC_STATUS sc = RPC_S_OK;

    for (int i=0; i<cDcomInterfaces; i++)
    {
        ComDebOut((DEB_CHANNEL,
            "->RpcServerRegisterIfEx(iface=0x%x, flags:%x RPC_IF_AUTOLISTEN, 0xffff, xxx)\n",
            arDcomInterfaces[i].hServerIf, arDcomInterfaces[i].dwRegFlags));

        // The MaxRpcSize for this set of interfaces is the system default size
        sc = RpcServerRegisterIfEx(arDcomInterfaces[i].hServerIf,
                                   NULL, 
                                   NULL,
                                   arDcomInterfaces[i].dwRegFlags,
                                   RPC_C_LISTEN_MAX_CALLS_DEFAULT,
                                   arDcomInterfaces[i].pfnSecurityCB);

        ComDebOut((DEB_CHANNEL, "->RpcServerRegisterIfEx(status=0x%x)\n", sc));

        if (sc != RPC_S_OK && sc != RPC_S_TYPE_ALREADY_REGISTERED)
        {
            ComDebOut((DEB_ERROR, "RegisterDcomInterfaces sc:%x\n", sc));
            break;
        }

        sc = RPC_S_OK;
    }

    if (sc != RPC_S_OK)
        sc = HRESULT_FROM_WIN32(sc);

    ASSERT_LOCK_HELD(gComLock);
    ComDebOut((DEB_CHANNEL, "[OUT] RegisterDcomInterfaces hr:%x\n", sc));
    return sc;
}

//+-------------------------------------------------------------------
//
//  Function:   UnregisterDcomInterfaces
//
//  Synopsis:   Unregister the private DCOM interfaces and mark
//              DCOM as no longer accepting remote calls.
//
//  Notes:      This function requires that the caller guarantee
//              serialization without taking gComLock.
//
//  History:    23-Nov-93   Rickhi       Created
//
//--------------------------------------------------------------------
SCODE UnregisterDcomInterfaces(void)
{
    ComDebOut((DEB_CHANNEL, "[IN] UnregisterDcomInterfaces\n"));
    ASSERT_LOCK_NOT_HELD(gComLock);

    RPC_STATUS sc = RPC_S_OK;

    if (gfListening)
    {
        for (int i=0; i<cDcomInterfaces; i++)
        {
            // Unregister the interface. This can result in calls being
            // dispatched.  Do not hold the lock around this call.

            ComDebOut((DEB_CHANNEL,
                "->RpcServerUnregisterIf(iface=0x%x, 0, 1)\n",
                arDcomInterfaces[i].hServerIf));

            sc = RpcServerUnregisterIf(arDcomInterfaces[i].hServerIf, 0, 1 );

            ComDebOut((DEB_CHANNEL,
                "->RpcServerUnregisterIf(status=0x%x)\n", sc));
        }

        gfListening = FALSE;
    }
    gSpeedOverMem = FALSE;

    if (sc != RPC_S_OK)
        sc = HRESULT_FROM_WIN32(sc);

    ComDebOut((DEB_CHANNEL, "[OUT] UnregisterDcomInterfaces hr:%x\n", sc));
    return sc;
}


static void LogEndpointFailure(WCHAR *pszProtseq,
                               WCHAR *pszEndpoint,
                               DWORD  dwFlags)
{
    HANDLE  LogHandle;
    WCHAR const *  Strings[3]; // array of message strings.
    WCHAR szFlags[20];
    wsprintf(szFlags, L"0x%x", dwFlags);

    Strings[0] = pszProtseq;
    Strings[1] = pszEndpoint;
    Strings[2] = szFlags;

    // Get the log handle, then report the event.
    LogHandle = RegisterEventSource( NULL, L"DCOM" );

    if ( LogHandle )
    {
        ReportEventW( LogHandle,
                      EVENTLOG_ERROR_TYPE,
                      0,             // event category
                      EVENT_DCOM_INVALID_ENDPOINT_DATA,
                      NULL,
                      3,             // 3 strings passed
                      0,             // 0 bytes of binary
                      Strings,       // array of strings
                      NULL );        // no raw data

        // clean up the event log handle
        DeregisterEventSource(LogHandle);
    }
}


//+-------------------------------------------------------------------
//
//  Function:   UseProtseq
//
//  Synopsis:   Use the specified protseq and return a list of all string
//              bindings.
//
//  History:    25 May 95 AlexMit       Created
//              01 Feb 97 Ronans        modified to use towerIds and custom endpoints
//              14 Jul 00 Sergei        Added IsCallerLocalSystem check
//
//--------------------------------------------------------------------


error_status_t _UseProtseq( handle_t hRpc,
                            unsigned short wTowerId,
                            DUALSTRINGARRAY **ppsaNewBindings,
                            DUALSTRINGARRAY **ppsaSecurity )
{
    // Note: security checks are performed automatically by the
    // RPC security callback function.

    BOOL fInUse = FALSE;
    RPC_STATUS sc = RPC_S_OK;
    wchar_t *pwstrProtseq = (wchar_t*)utGetProtseqFromTowerId(wTowerId);

    // Parameter validation:  the caller must pass in a valid tower
    // id, as well as valid out ptrs for the string\sec bindings.
    if (!pwstrProtseq || !ppsaNewBindings || !ppsaSecurity)
        return E_INVALIDARG;

    ASSERT_LOCK_NOT_HELD(gComLock);
    LOCK(gComLock);

    // Make sure security is initialized.
    sc = DefaultAuthnServices();

    // If we have never inquired string bindings, inquire them before doing
    // anything else.
    if (sc == RPC_S_OK && gfDefaultStrings)
    {
        fInUse = InquireStringBindings( pwstrProtseq );
        gfDefaultStrings = FALSE;
    }

    if (sc == RPC_S_OK && !fInUse)
    {
        Win4Assert( lstrcmpW( pwstrProtseq, L"ncalrpc" ) != 0 );
        ComDebOut((DEB_CHANNEL, "->RpcServerUseProtseq(protseq=%ws, maxcalls= RPC_C_PROTSEQ_MAX_REQS_DEFAULT, NULL)\n",
                   pwstrProtseq));

        // ronans - added code to process custom endpoint entries
        CEndpointEntry *pCustomEntry;

        ComDebOut((DEB_CHANNEL, "_UseProtseq - searching custom endpoints table\n"));

        if ((gEndpointsTable.GetCount()) &&
            (pCustomEntry = gEndpointsTable.FindEntry(wTowerId)))
        {
            // setup custom entry
            RPC_POLICY rpcPolicy;
            rpcPolicy.Length = sizeof(RPC_POLICY);
            rpcPolicy.EndpointFlags = pCustomEntry -> m_dwFlags;
            rpcPolicy.NICFlags = 0;

            if (rpcPolicy.EndpointFlags != POLICY_PROTSEQ_DISALLOWED)
            {
                // call extended versions providing policy
                if (!pCustomEntry -> m_pszEndpoint)
                {
                    ComDebOut((DEB_CHANNEL,
                        "->RpcServerUseProtseqEx(protseq=%ws, maxcalls= RPC_C_PROTSEQ_MAX_REQS_DEFAULT, NULL)\n",
                           pwstrProtseq));

                    sc = RpcServerUseProtseqExW(pwstrProtseq,
                            RPC_C_PROTSEQ_MAX_REQS_DEFAULT,
                            NULL,
                            &rpcPolicy);

                    if (sc != RPC_S_OK)
                    {
                        LogEndpointFailure(pwstrProtseq,
                                           L"(not specified)",
                                           pCustomEntry -> m_dwFlags);
                    }
                }
                else
                {
                    ComDebOut((DEB_CHANNEL,
                        "->RpcServerUseProtseqEpEx(protseq=%ws, maxcalls= RPC_C_PROTSEQ_MAX_REQS_DEFAULT, endpoint=%ws, NULL)\n",
                           pwstrProtseq, pCustomEntry -> m_pszEndpoint));

                    sc = RpcServerUseProtseqEpExW(pwstrProtseq,
                            RPC_C_PROTSEQ_MAX_REQS_DEFAULT,
                            pCustomEntry -> m_pszEndpoint,
                            NULL,
                            &rpcPolicy);

                    if (sc != RPC_S_OK)
                    {
                        LogEndpointFailure(pwstrProtseq,
                                           pCustomEntry -> m_pszEndpoint,
                                           pCustomEntry -> m_dwFlags);
                    }
                }

                ComDebOut((DEB_CHANNEL, "<-RpcServerUseProtseqEpEx(status=0x%x)\n",sc));
            }
            else
            {
                sc = RPC_E_ACCESS_DENIED;
                ComDebOut((DEB_CHANNEL, "<-_UseProtoseq - protocol sequence disabled\n",sc));
            }
        }
        else
        {
            // ronans - DCOMHTTP - if we're using DCOMHTTP - use the internet range of ports
            if (wTowerId == ID_DCOMHTTP)
            {
                // setup custom entry
                RPC_POLICY rpcPolicy;
                rpcPolicy.Length = sizeof(RPC_POLICY);
                rpcPolicy.EndpointFlags = RPC_C_USE_INTERNET_PORT;
                rpcPolicy.NICFlags = 0;

                // call extended versions providing policy
                ComDebOut((DEB_CHANNEL,
                    "->RpcServerUseProtseqEx(protseq=%ws, maxcalls= RPC_C_PROTSEQ_MAX_REQS_DEFAULT, NULL)\n",
                   pwstrProtseq));

                sc = RpcServerUseProtseqExW(pwstrProtseq,
                        RPC_C_PROTSEQ_MAX_REQS_DEFAULT,
                        NULL,
                        &rpcPolicy);

                ComDebOut((DEB_CHANNEL, "<-RpcServerUseProtseqEx(status=0x%x)\n",sc));
            }
            else
            {
                ComDebOut((DEB_CHANNEL,
                            "->RpcServerUseProtseq(protseq=%ws, maxcalls= RPC_C_PROTSEQ_MAX_REQS_DEFAULT, NULL)\n",
                            pwstrProtseq));
                sc = RpcServerUseProtseq(pwstrProtseq,
                                        RPC_C_PROTSEQ_MAX_REQS_DEFAULT,
                                        NULL);
                ComDebOut((DEB_CHANNEL, "<-RpcServerUseProtseq(status=0x%x)\n",sc));
            }

        }

        if (sc != RPC_S_OK)
        ComDebOut((DEB_CHANNEL, "Could not register protseq %ws: 0x%x\n",
                  pwstrProtseq, sc ));

        // Return the latest string bindings. Ignore failures.
        InquireStringBindings( NULL );
    }

    // Generate a copy to return.
    sc = CopyStringArray( gpsaCurrentProcess, NULL, ppsaNewBindings );
    if (SUCCEEDED(sc))
    {
        sc = CopyStringArray( gpsaSecurity, NULL, ppsaSecurity );
    }

    UNLOCK(gComLock);
    ASSERT_LOCK_NOT_HELD(gComLock);
    return sc;
}



// static page allocator for endpoints table
CPageAllocator  CEndpointsTable ::_palloc;


//+------------------------------------------------------------------------
//
//  Member:     CEndpointsTable::Initialize, public
//
//  Synopsis:   Initializes the endpoints table static info.
//
//  Notes:      This function requires the caller to hold gComLock.
//
//  History:    20-Jan-97       Ronans  created
//
//-------------------------------------------------------------------------
void CEndpointsTable::Initialize()
{
    ComDebOut((DEB_CHANNEL, "CEndpointsTable Initialize \n"));
    LOCK(gComLock);

    m_pHead = NULL;
    m_nCount = 0;

    // note no locking will be used for page allocator
    _palloc.Initialize(sizeof(CEndpointEntry),ENDPOINTS_PER_PAGE,
                       (COleStaticMutexSem *)NULL);

    UNLOCK(gComLock);
}

//+-------------------------------------------------------------------
//
//  Function:   CEndpointsTable::Cleanup
//
//  Synopsis:   removes all endpoints from table
//
//  Notes:      This function requires the caller to hold gComLock.
//
//  History:    20-Jan-1997     Ronans  Created
//
//--------------------------------------------------------------------
void CEndpointsTable::Cleanup()
{
    ComDebOut((DEB_CHANNEL, "CEndpointsTable Cleanup \n"));
    LOCK(gComLock);

    // delete all entries
    while (m_pHead)
    {
        CEndpointEntry* ptmp = m_pHead ;
        m_pHead = m_pHead -> m_pNext;
        delete ptmp;
    }

    m_nCount = 0;
    _palloc.Cleanup();

    UNLOCK(gComLock);
}

//+-------------------------------------------------------------------
//
//  Function:   CEndpointsTable::GetIterator
//
//  Synopsis:   iterator to iterate through endpoints in table
//
//  Notes:
//
//  History:    20-Jan-1997     Ronans  Created
//
//--------------------------------------------------------------------
ULONG_PTR CEndpointsTable::GetIterator()
{
    ASSERT_LOCK_HELD(gComLock);

    return (ULONG_PTR)m_pHead;
}

//+-------------------------------------------------------------------
//
//  Function:   CEndpointsTable::GetNextEntry
//
//  Synopsis:   get next entry and update iterator
//
//  Notes:
//
//  History:    20-Jan-1997     Ronans  Created
//
//--------------------------------------------------------------------
CEndpointEntry * CEndpointsTable::GetNextEntry(ULONG_PTR &rIterator)
{
    ASSERT_LOCK_HELD(gComLock);

    ASSERT(rIterator != 0);
    CEndpointEntry * pEntry = (CEndpointEntry *)rIterator;

    rIterator = pEntry ? (ULONG_PTR) (pEntry -> m_pNext) : 0;
    return pEntry;
}

//+-------------------------------------------------------------------
//
//  Function:   CEndpointsTable::RemoveEntry
//
//  Synopsis:   removes specific endpoint from table
//
//  Notes:
//
//  History:    20-Jan-1997     Ronans  Created
//
//--------------------------------------------------------------------
void CEndpointsTable::RemoveEntry(CEndpointEntry *pEntry)
{
    ASSERT_LOCK_HELD(gComLock);

    ASSERT(GetCount() != 0);

    CEndpointEntry *pTmp = NULL;
    CEndpointEntry *pNextTmp = m_pHead;

    while (pNextTmp  )
    {
        if (pNextTmp == pEntry)
        {
            if (pTmp)
                    pTmp -> m_pNext = pNextTmp -> m_pNext;
            else
                    m_pHead = pNextTmp -> m_pNext;
            delete pNextTmp;
            pNextTmp = NULL;
            m_nCount--;
        }
        else
        {
            pTmp = pNextTmp;
            pNextTmp = pNextTmp -> m_pNext;
        }
    }
}

//+-------------------------------------------------------------------
//
//  Function:   CEndpointsTable::AddEntry
//
//  Synopsis:   adds new endpoint to table
//
//  Notes:      this method requires that gComLock is held before calling
//
//  History:    20-Jan-1997     Ronans  Created
//
//--------------------------------------------------------------------
CEndpointEntry * CEndpointsTable::AddEntry(USHORT wTowerId, WCHAR* pszProtSeqEP, DWORD dwFlags)
{
    ComDebOut((DEB_CHANNEL, "CEndpointsTable AddEntry %d, %ws\n", wTowerId, pszProtSeqEP));

    ASSERT_LOCK_HELD(gComLock);

    CEndpointEntry *pNewEntry = new CEndpointEntry(wTowerId, pszProtSeqEP, dwFlags);
    if (pNewEntry && (pNewEntry -> IsValid()))
    {
        pNewEntry -> m_pNext = m_pHead;
        m_pHead = pNewEntry;
        m_nCount++;
    }
    else
    {
        if (pNewEntry)
        {
            delete pNewEntry;
            ComDebOut((DEB_ERROR, "CEndpointsTable - endpoint entry is invalid\n"));
            pNewEntry = NULL;
        }
        else
        {
            ComDebOut((DEB_ERROR, "CEndpointsTable - couldn't allocate entry\n"));
        }
    }

    return pNewEntry;
}

//+-------------------------------------------------------------------
//
//  Function:   CEndpointEntry constructor
//
//  Synopsis:   represents endpoint in table
//
//  Notes:
//
//  History:    20-Jan-1997     Ronans  Created
//
//--------------------------------------------------------------------
CEndpointEntry::CEndpointEntry( USHORT wTowerId, WCHAR* pszEndpoint, DWORD dwFlags)
{
    m_dwFlags  = dwFlags;
    m_wTowerId = wTowerId;
    m_pszEndpoint = NULL;
    m_pNext = NULL;

    if (pszEndpoint)
    {
        if (m_pszEndpoint = new WCHAR[lstrlenW(pszEndpoint)+1])
            lstrcpyW(m_pszEndpoint, pszEndpoint);
        else
        {
            // reset towerid to 0 to indicate invalid state
            m_wTowerId = 0;

            // send error message to debugger
            ComDebOut((DEB_ERROR, "CEndpointEntry ::contructor - couldn't allocate memory for string copy\n"));
        }
    }

    ComDebOut((DEB_CHANNEL, "CEndpointEntry:: constructor structure [0x%p] %d, %ws %ld \n", this, m_wTowerId, m_pszEndpoint, m_dwFlags));
}

//+-------------------------------------------------------------------
//
//  Function:   CEndpointEntry destructor
//
//  Synopsis:   represents endpoint in table
//
//  Notes:
//
//  History:    20-Jan-1997     Ronans  Created
//
//--------------------------------------------------------------------
CEndpointEntry::~CEndpointEntry()
{
    ComDebOut((DEB_CHANNEL, "CENdpointEntry:: destructor\n"));

    if (m_pszEndpoint)
        delete m_pszEndpoint;
}


//+-------------------------------------------------------------------
//
//  Function:   CEndpointEntry ::new operator
//
//  Synopsis:   custom allocator for endpoint entry
//
//  Notes:      requires holding gComLock before calling
//
//  History:    20-Jan-1997     Ronans  Created
//
//--------------------------------------------------------------------
void* CEndpointEntry::operator new(size_t t)
{
    ComDebOut((DEB_CHANNEL, "CENdpointEntry:: new operator\n"));

    ASSERT_LOCK_HELD(gComLock);

    return (void*)(CEndpointsTable::_palloc.AllocEntry());
}

//+-------------------------------------------------------------------
//
//  Function:   CEndpointEntry ::delete operator
//
//  Synopsis:   custom allocator support for endpoint entry
//
//  Notes:      requires holding gComLock before calling
//
//  History:    20-Jan-1997     Ronans  Created
//
//--------------------------------------------------------------------
void CEndpointEntry::operator delete(void *p)
{
    ComDebOut((DEB_CHANNEL, "CENdpointEntry:: delete operator\n"));

    ASSERT_LOCK_HELD(gComLock);

    CEndpointsTable::_palloc.ReleaseEntry((PageEntry*)p);
}

//+-------------------------------------------------------------------
//
//  Function:   CEndpointsTable::FindEntry
//
//  Synopsis:   finds endpoint in table if present
//
//  Notes:      requires gComLock to be held before calling
//
//  History:    20-Jan-1997     Ronans  Created
//
//--------------------------------------------------------------------
CEndpointEntry * CEndpointsTable::FindEntry(unsigned short wTowerId)
{
    ComDebOut((DEB_CHANNEL, "CEndpointsTable:: find entry\n"));

    ASSERT_LOCK_HELD(gComLock);

    if (!wTowerId)
        return NULL;

    // iterate through list looking for entry
    ULONG_PTR nIterator  = gEndpointsTable.GetIterator();

    // search table looking for endpoint
    while (nIterator)
    {
        CEndpointEntry *pEntry = gEndpointsTable.GetNextEntry(nIterator);
        if (pEntry && (pEntry -> m_wTowerId == wTowerId))
            return pEntry;
    }
    return NULL;
}

//+-------------------------------------------------------------------
//
//  Function:   wCoRegisterComBinding
//
//  Synopsis:   worker function to register an endpoint in the endpoint table.
//
//  Notes:              When registering endpoints via this API, COM will ignore
//                              AppID registry specified endpoints.
//
//              requires gComLock held
//
//  History:    20-Feb-1997     Ronans  Created
//
//--------------------------------------------------------------------
HRESULT wCoRegisterComBinding(WCHAR * pszProtseqEP, WCHAR* pszEndpoint, DWORD dwFlags)
{
    HRESULT hr = S_OK;
    USHORT wTmpTowerId;

    ComDebOut((DEB_CHANNEL, "wCoRegisterProtSeqEp([%ws],[%ws],[%ld]\n", pszProtseqEP, pszEndpoint,dwFlags));

    wTmpTowerId = utGetTowerId(pszProtseqEP );

    // check if its a valid tower id
    if (!wTmpTowerId )
    {
        ComDebOut((DEB_ERROR, "wCoRegisterProtSeqEp - can't find tower id for (%ws)\n", pszProtseqEP));
        return E_INVALIDARG;
    }

    // check lock before accessing global table
    ASSERT_LOCK_HELD(gComLock);

        // check if we can still register endpoints
    if (!sfEndpointsProcessed)
    {
        CEndpointEntry *pEntry = gEndpointsTable.AddEntry(wTmpTowerId, pszEndpoint, dwFlags);

        // check that entry was allocated
        if (!pEntry)
        {
            ComDebOut((DEB_ERROR, "CoRegisterProtSeqEp - out of memory allocating entry\n"));
            hr = E_OUTOFMEMORY;
        }

        // set flag to indicate endpoints have been added
        sfProgrammaticEndpoints = TRUE;
    }
    else
    {
        ComDebOut((DEB_ERROR, "CoRegisterProtSeqEp - function called after DCOM resolver initialized\n"));
        hr = E_UNEXPECTED;
    }

    return hr;
}

static HRESULT wReadProtseqsForAppid(HKEY hkAppID);


//+-------------------------------------------------------------------
//
//  Function:   wGetEndpointsForApp, internal
//
//  Synopsis:   Get the endpoints for the current app.  First,
//              look under the app id for the current exe name.  If that
//              fails return default endpoints  .
//
//  Notes:              requires gComLock to be held before calling
//
//  History:    20-Jan-1997     Ronans  Created
//
//--------------------------------------------------------------------
HRESULT wGetEndpointsForApp( GUID* pAppID)
{
    // Holds either Appid\{guid} or Appid\module_name.
    WCHAR   aKeyName[MAX_PATH+7];
    HRESULT hr = S_OK;
    LONG lErr;
    HKEY    hKey  = NULL;

    ASSERT_LOCK_HELD(gComLock);

    // ensure its not too late to process endpoints
    Win4Assert(!sfEndpointsProcessed);

    if (sfEndpointsProcessed)
    {
        ComDebOut((DEB_ERROR, "wGetEndpointsForApp - shouldn't be called twice"));
        return E_UNEXPECTED;
    }

    lstrcpyW( aKeyName, L"AppID\\" );
    int nOffset = lstrlenW(aKeyName);

    // If pAppId is not null - it contains a pointer to the AppId GUID
    if (pAppID != NULL)
    {
        if (StringFromIID2( *pAppID, &aKeyName[nOffset], sizeof(aKeyName) - nOffset ) != 0)
            hr = S_OK;
        else
        {
            ComDebOut((DEB_ERROR, "wGetEndpointsForApp - error converting IID to string\n"));
            return E_UNEXPECTED;
        }
    }
    else
    {
        // Look up the app id from the exe name.
        hr = utGetAppIdForModule(&aKeyName[nOffset], (MAX_PATH + 7) - nOffset);
    }


    if (SUCCEEDED(hr))
    {
        lErr = OpenClassesRootKeyEx( aKeyName, KEY_READ, &hKey );

        // Get the endpoints from the registry.
        if (lErr == ERROR_SUCCESS)
        {
            ComDebOut((DEB_CHANNEL, "wGetEndpointsForApp - opened appid [%ws]\n", aKeyName));
            hr = wReadProtseqsForAppid( hKey);
            RegCloseKey(hKey);
        }
        else
        {
            ComDebOut((DEB_ERROR, "wGetEndpointsForApp - can't open AppID key for %ws\n", aKeyName));
            hr = E_FAIL;    // indicate normal failure
        }
    }

    return hr;
}



const WCHAR szEndpointText[] = L"Endpoint";
const int lenEndpoint = (sizeof(szEndpointText) / sizeof(TCHAR)) -1;

//+-------------------------------------------------------------------
//
//  Function:   wStrtok
//
//  Synopsis:   local implementation of wcstok - needed as wcstok is not in
//              libraries for standard build
//
//  Notes:              not threadsafe
//
//  History:    20-Feb-1997     Ronans  Created
//
//--------------------------------------------------------------------
static WCHAR * wStrtok(WCHAR * lpszStr, WCHAR * lpszDelim)
{
    static WCHAR *lpszLastStr = NULL;
    WCHAR * lpszRetval = NULL;

    int nLenDelim = lstrlenW(lpszDelim);
    int index;

    // save string to search if necessary
    if (lpszStr)
        lpszLastStr = lpszStr;

    // return NULL string if necessary
    if (!lpszLastStr || !*lpszLastStr)
    {
        return NULL;
    }

    // skip initial delimiters
    while (*lpszLastStr)
    {
        for (index = 0; (index < nLenDelim) && (*lpszLastStr != lpszDelim[index]); index++);
            // do nothing

        if (index < nLenDelim)
             lpszLastStr++;
        else
            break;
    }

    // skip non-delimiter characters
    if (*lpszLastStr)
    {
        lpszRetval = lpszLastStr;

        while (*lpszLastStr)
        {
            for (index = 0;
                (index < nLenDelim) && (*lpszLastStr != lpszDelim[index]);
                index++);
                // do nothing

            if (index == nLenDelim)
                 lpszLastStr++;
            else
            {
                *lpszLastStr++ = NULL;
                break;
            }
        }
    }
    else
        lpszLastStr = NULL;

    return lpszRetval;
}

//+-------------------------------------------------------------------
//
//  Function:   wReadProtseqForAppID
//
//  Synopsis:   read endpoints from registry for particular appid
//                              and add them to the endpoint table
//
//  Notes:              requires gComLock to be held before calling
//
//  History:    20-Jan-1997     Ronans  Created
//
//--------------------------------------------------------------------
static HRESULT wReadProtseqsForAppid(HKEY hkAppID)
{
    HRESULT hr = S_OK;
    DWORD dwType = REG_MULTI_SZ;
    DWORD dwcbBuffer = 1024;
    WCHAR* pszBuffer;

    ComDebOut((DEB_CHANNEL,
                "wReadProtseqsForApp -  reading endpoints from the registry\n"));

    ASSERT_LOCK_HELD(gComLock);

    // read DCOM endpoint data from the registry
    Win4Assert(hkAppID != 0);


    if (!(pszBuffer = new WCHAR[1024]))
    {
        ComDebOut((DEB_ERROR,
                    "wReadProtseqsForApp -  could'nt allocate buffer for endpoints\n"));
        return E_OUTOFMEMORY;
    }

    // try to read values into default sized buffer
    LONG lErr = RegQueryValueExW(hkAppID,
                        L"Endpoints",
                        0,
                        &dwType,
                        (LPBYTE)pszBuffer,
                        &dwcbBuffer);

    // if buffer is not big enough, extend it and reread
    if (lErr == ERROR_MORE_DATA)
    {
        delete  pszBuffer;
        DWORD dwNewSize = (dwcbBuffer + 1 / sizeof(TCHAR));
        pszBuffer = new WCHAR[dwNewSize];
        if (pszBuffer)
            dwcbBuffer = dwNewSize;
        else
        {
            ComDebOut((DEB_ERROR,
                        "wReadProtseqsForApp -  could'nt allocate buffer for endpoints\n"));
            return E_OUTOFMEMORY;
        }


        lErr = RegQueryValueExW(hkAppID,
                        L"Endpoints",
                        0,
                        &dwType,
                        (LPBYTE)pszBuffer,
                        &dwcbBuffer);
    }

    // if we have read the Endpoints value successfully
    if ((lErr == ERROR_SUCCESS) &&
        (dwcbBuffer > 0) &&
        (dwType == REG_MULTI_SZ))
    {
        // parse each string
        WCHAR * lpszRegEntry = pszBuffer;

        while(*lpszRegEntry)
        {
            // caclulate length of entry
            int nLenEntry = lstrlenW(lpszRegEntry);

            // ok its a valid endpoint so parse it
            WCHAR* pszProtseq = NULL;
            WCHAR* pszEndpointData = NULL;
            WCHAR* pszTmpDynamic = NULL;
            DWORD dwFlags;

            pszProtseq = wStrtok(lpszRegEntry, L", ");

            pszTmpDynamic = wStrtok(NULL, L", ");
            if (pszTmpDynamic == NULL)
                dwFlags = 0;
            else
                dwFlags = (DWORD) _wtol(pszTmpDynamic);

            pszEndpointData = wStrtok(NULL, L", ");

            // at this point we should have the protseq, endpoint and flags
            // .. so add the entry

            // ignore result as we will continue even if one fails
            wCoRegisterComBinding(pszProtseq, pszEndpointData, dwFlags);
            lpszRegEntry += nLenEntry + 1;
        }
    }
    else if ((lErr != ERROR_SUCCESS) && (lErr != ERROR_FILE_NOT_FOUND))
    {
        ComDebOut((DEB_ERROR, "wReadProtseqsForApp -  invalid registry entry\n" ));
    }

    delete pszBuffer;

    return S_OK;
}

//+-------------------------------------------------------------------
//
//  Function:   wGetFinalEndpointTable
//
//  Synopsis:   checks if endpoints have been added programmatically
//              if not read them from the registry. This will be called by
//              the COM server when it needs to determine whether to negotiate
//              specific endpoints for the application or use the COM default
//              endpoints.
//
//  Notes:      Requires gComLock to be held before calling
//
//  History:    20-Jan-97       Ronans       Created
//
//--------------------------------------------------------------------
static HRESULT wGetFinalEndpointTable()
{
    ComDebOut((DEB_CHANNEL, "wGetFinalEndpointTable\n"));
    ASSERT_LOCK_HELD(gComLock);

    HRESULT hr = S_OK;

    // if endpoints have not been added programmatically
    if (!sfProgrammaticEndpoints)
    {
        // ... then get them
        GUID * pAppID = NULL;
        if ( g_AppId != GUID_NULL )
           pAppID = &g_AppId;

        // locate AppID
        hr = wGetEndpointsForApp(pAppID);

        // E_FAIL indicates no endpoints so mark the endpoints as processed in this
        // case also.
        if (SUCCEEDED(hr) || (hr == E_FAIL))
            sfEndpointsProcessed = TRUE;
    }
    else
        sfEndpointsProcessed = TRUE;

    return ((SUCCEEDED(hr) || (hr == E_FAIL)) ? S_OK : hr);
}

//+-------------------------------------------------------------------
//
//  Function:   IsAllowableProtseq
//
//  Synopsis:   Check a towerId against the list of machine protseqs
//
//  History:    20-Jan-97       Ronans       Created
//
//--------------------------------------------------------------------
BOOL IsAllowableProtseq(unsigned short wTowerId, unsigned short cMyProtseqs,
                        unsigned short aMyProtseqs[])
{
    for (int i = 0; i < cMyProtseqs; i++)
    {
        if (wTowerId == aMyProtseqs[i])
            return TRUE;
    }

    return FALSE;
}

//+-------------------------------------------------------------------
//
//  Function:   GetCustomProtseqInfo
//
//  Synopsis:   Get a list of the custom specified protocol sequences and
//              return them in a DUALSTRINGARRAY.
//
//  Notes:      Exported as part of RPC interface to be called by
//              DCOMSS during ResolveOXID
//              Takes gComLock during processing
//
//  History:    20-Jan-97       Ronans       Created
//
//--------------------------------------------------------------------
error_status_t _GetCustomProtseqInfo( handle_t hRpc,
                            unsigned short cMachineProtseqs,
                            unsigned short aMachineProtseqs[  ],
                            DUALSTRINGARRAY **pdsaCustomProtseqs)
{
    // Note: security checks are performed automatically by the
    // RPC security callback function.
	
    ComDebOut((DEB_CHANNEL, "_GetCustomProtseqInfo ==> \n"));

    ASSERT_LOCK_NOT_HELD(gComLock);
    LOCK(gComLock);
    ASSERT_LOCK_HELD(gComLock);

    HRESULT hr = S_OK;

    // It's now possible that RPCSS may call this method more than
    // once.  The only place where we might get into trouble is 
    // during initial creation of the endpoints table, but we're
    // under gComLock so that's taken care of.

    // Parse endpoints if necessary
    if (!sfEndpointsProcessed)
    {
        hr = wGetFinalEndpointTable();
        if (FAILED(hr))
            return RPC_S_OUT_OF_RESOURCES;
    }

    int nItems = 0;

    // build up custom protseqinfo as compressed dual string array
    // process table.
    DUALSTRINGARRAY* pdsaResults = NULL;
    unsigned short nSize = 3; // entries for nulls
    ULONG_PTR nIterator  = gEndpointsTable.GetIterator();

    // calculate length needed for overall DUALSTRINGARRAY string
    while (nIterator)
    {
        // for each entry - check if its available in the machine protseqs
        CEndpointEntry *pData = gEndpointsTable.GetNextEntry(nIterator);

        if (pData && IsAllowableProtseq(pData -> m_wTowerId, cMachineProtseqs, aMachineProtseqs))
        {
            nItems ++;
            nSize += 2; // size of wTowerid and sizeof null

            // add size of endpoint data also
            if (pData -> m_pszEndpoint)
                nSize = nSize + (USHORT) lstrlenW(pData -> m_pszEndpoint);
        }
    }

    // build DSA from results
    if (nItems)
    {
        pdsaResults = (DUALSTRINGARRAY*)
                        MIDL_user_allocate( sizeof(DUALSTRINGARRAY) +
                                            nSize*sizeof(WCHAR) );
        nIterator   = gEndpointsTable.GetIterator();

        ASSERT(nIterator != NULL);

        if (pdsaResults)
        {
            // copy strings
            LPWSTR pszNext = pdsaResults -> aStringArray;

            while (nIterator)
            {
                CEndpointEntry *pData = gEndpointsTable.GetNextEntry(nIterator);

                    if (pData &&
                    IsAllowableProtseq(pData -> m_wTowerId, cMachineProtseqs, aMachineProtseqs))
                {
                    // first part of string is tower id for compressed strings
                    *pszNext++ = (WCHAR) pData -> m_wTowerId;
                    if (pData -> m_pszEndpoint)
                    {
                        lstrcpyW( pszNext, pData -> m_pszEndpoint);
                        pszNext += lstrlenW(pszNext) + 1;
                    }
                    else
                        *pszNext++ = (WCHAR)0;
                    }
            }

            // Add a second null to terminate the string binding
            // set.

            pszNext[0] = 0;

            // set blank security info
            pszNext[1] = 0;
            pszNext[2] = 0;

            // Fill in the size fields.
            pdsaResults->wSecurityOffset = nSize - 2;
            pdsaResults->wNumEntries = nSize;
            *pdsaCustomProtseqs = pdsaResults;
        }
        else
        {
            ComDebOut(( DEB_ERROR, "Failed to allocate memory for compressed string array\n"));
            hr = E_OUTOFMEMORY;
        }
    }
    else
        *pdsaCustomProtseqs = NULL;

    ASSERT_LOCK_HELD(gComLock);
    UNLOCK(gComLock);
    ASSERT_LOCK_NOT_HELD(gComLock);

    ComDebOut((DEB_CHANNEL, "_GetCustomProtseqInfo <== [0x%lx] returning S_OK\n", hr));

    // always return S_OK as any errors will not be fixed by retrying (except for E_OUTOFMEMORY)
    return ((hr == E_OUTOFMEMORY) ? E_OUTOFMEMORY : S_OK);
}

//+-------------------------------------------------------------------
//
//  Function:   _UpdateResolverBindings
//
//  Synopsis:   Updates the process-wide resolver bindings.
//
//  Notes:      Exported as part of RPC interface to be called by
//              RPCSS when resolver bindings change and someone has
//              requested dynamic updates of same to running processes.
//
//  History:    09-Oct-00       Jsimmons    Created
//
//--------------------------------------------------------------------
error_status_t _UpdateResolverBindings( 
                    RPC_ASYNC_STATE* pAsync,
                    handle_t hRpc,
                    DUALSTRINGARRAY* pdsaResolverBindings,
                    DWORD64* pdwBindingsID,
                    DUALSTRINGARRAY **ppdsaNewBindings,
                    DUALSTRINGARRAY **ppdsaNewSecurity)     
{
    // Note: security checks are performed automatically by the
    // RPC security callback function.

    ComDebOut((DEB_CHANNEL, "_UpdateResolverBindings ==> \n"));

    HRESULT hr = RPC_E_ACCESS_DENIED;
    RPC_STATUS status = RPC_E_ACCESS_DENIED;

    // Parameter validation
    if (!pAsync ||
        !hRpc ||
        !pdsaResolverBindings ||
        !pdwBindingsID ||
        !ppdsaNewBindings ||
        !ppdsaNewSecurity)
    {
        // just fall thru
    }
    else
    {
        hr = IUpdateResolverBindings(*pdwBindingsID,
                        pdsaResolverBindings,
                        ppdsaNewBindings,
                        ppdsaNewSecurity);          
    }

    // Need to complete the call regardless of outcome
    status = RpcAsyncCompleteCall(pAsync, &hr);

    ComDebOut((DEB_CHANNEL, "_UpdateResolverBindings <== returning 0x%8x\n", hr));

    return status;
}

//+-------------------------------------------------------------------
//
//  Function:   IUpdateResolverBindings
//
//  Synopsis:   Updates the process-wide resolver bindings.
//
//  Notes:      Helper function for updating the process-wide resolver
//              bindings.
//
//              Right now I am holding gComLock across this function; not
//              sure if it is needed, but this is not a high-perf code
//              path so I don't think it can hurt.
//
//  History:    09-Oct-00       Jsimmons    Created
//
//--------------------------------------------------------------------
HRESULT IUpdateResolverBindings(
                    DWORD64 dwBindingsID,   
                    DUALSTRINGARRAY* pdsaResolverBindings,
                    DUALSTRINGARRAY **ppdsaNewBindings,
                    DUALSTRINGARRAY **ppdsaNewSecurity
                    )
{
    HRESULT hr;

    // Check apcompat info
    if (DisallowDynamicORBindingChanges())
    {
        // this process does not want to recognize dynamic changes
        // in the resolver bindings.   So don't do it.
        hr = S_OK;

        // We can get called directly from the resolver after a call to
        // ServerAllocateOxidAndOids, when this occurs ppdsaNewBindings
        // and ppdsaNewSecurity will be null.
        if (ppdsaNewBindings && ppdsaNewSecurity)
        {
            hr = CopyStringArray(gpsaCurrentProcess, NULL, ppdsaNewBindings);
            if (SUCCEEDED(hr))
            {
                hr = CopyStringArray(gpsaSecurity, NULL, ppdsaNewSecurity);
            }
        }
        return hr;
    }

    ASSERT_LOCK_NOT_HELD(gComLock);
    LOCK(gComLock);
    ASSERT_LOCK_HELD(gComLock);

    DUALSTRINGARRAY* pdsaLocalCopyResolverBindings = NULL;

    // Make copy of incoming bindings.   
    hr = CopyDualStringArray(pdsaResolverBindings, &pdsaLocalCopyResolverBindings);
    if (SUCCEEDED(hr))
    {        
        CDualStringArray* pdsaResolver = new CDualStringArray(pdsaLocalCopyResolverBindings);
        if (pdsaResolver)
        {
            // Change cached resolver bindings.  The pdsaResolver object now owns
            // the pdsaResolver bindings.  SetLocalResolverBindings may fail if
            // we are trying update using older bindings
            hr = gResolver.SetLocalResolverBindings(dwBindingsID, pdsaResolver);
            if (SUCCEEDED(hr))
            {
                // Change cached local midentry
                hr = gMIDTbl.ReplaceLocalEntry(pdsaResolverBindings);
                if (SUCCEEDED(hr))
                {
                    ASSERT_LOCK_NOT_HELD(gOXIDLock);
                    hr = gOXIDTbl.UpdateCachedLocalMIDEntries();
                    ASSERT_LOCK_NOT_HELD(gOXIDLock);

                    if (SUCCEEDED(hr) &&
                        ppdsaNewBindings && 
                        ppdsaNewSecurity)
                    {
                        // Generate binding copies to return.
                        hr = CopyStringArray(gpsaCurrentProcess, NULL, ppdsaNewBindings);
                        if (SUCCEEDED(hr))
                        {
                            hr = CopyStringArray(gpsaSecurity, NULL, ppdsaNewSecurity);
                        }
                    }
                }
            }
            pdsaResolver->Release();
        }
        else
        {
            hr = E_OUTOFMEMORY;
            // free the copy made above
            delete pdsaLocalCopyResolverBindings;
        }
    }

    ASSERT_LOCK_HELD(gComLock);
    UNLOCK(gComLock);
    ASSERT_LOCK_NOT_HELD(gComLock);

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\com\dcomrem\riftbl.cxx ===
//+------------------------------------------------------------------------
//
//  File:       riftbl.cxx
//
//  Contents:   RIF (Registered Interfaces) Table.
//
//  Classes:    CRIFTable
//
//  History:    12-Feb-96   Rickhi      Created
//
//-------------------------------------------------------------------------
#include <ole2int.h>
#include <riftbl.hxx>       // class definition
#include <locks.hxx>        // LOCK/UNLOCK
#include <channelb.hxx>     // ThreadInvoke
#include <objsrv.h>
#include <sxstypes.h>


// number of Registered Interface Entries per allocator page
#define RIFS_PER_PAGE   32


// Table of system interfaces used to prefill the RIFTable with known IIDs.
// We dont want anyone to try to override our implementations of these.

extern "C" const IID IID_IDLLHost;
extern "C" const IID IID_ILocalSystemActivator;
extern "C" const IID IID_ISystemActivator;
extern "C" const IID IID_IISCMLocalActivator;
extern "C" const IID IID_IInterfaceFromWindowProp;
extern "C" const IID IID_IRemoteQI;

const IID *gKnownSystemIIDs[] = {
                           &IID_IDLLHost,
                           &IID_ILocalSystemActivator,
                           &IID_ISystemActivator,
                           &IID_ISCMLocalActivator,
#ifdef SERVER_HANDLER
                           &IID_IServerHandler,
                           &IID_IClientSiteHandler,
#endif // SERVER_HANDLER
                           &IID_IClassFactory,
                           &IID_IInterfaceFromWindowProp,
                           &IID_IRemoteQI,
                           NULL};

const CLSID *gKnownSystemCLSIDs[] = {
                           &CLSID_PSOlePrx32,
                           &CLSID_PSOlePrx32,
                           &CLSID_PSOlePrx32,
                           &CLSID_PSOlePrx32,
#ifdef SERVER_HANDLER
                           &CLSID_PSOlePrx32,
                           &CLSID_PSOlePrx32,
#endif // SERVER_HANDLER
                           &CLSID_PSOlePrx32,
                           &CLSID_PSOlePrx32,
                           &CLSID_PSOlePrx32,
                           NULL};



// global RIF table
CRIFTable gRIFTbl;
BOOL               CRIFTable::_fPreFilled = FALSE; // table not pre-filled
CUUIDHashTable     CRIFTable::_HashTbl;      // interface lookup hash table
CPageAllocator     CRIFTable::_palloc;       // page allocator
COleStaticMutexSem CRIFTable::_mxs;          // critical section


//+------------------------------------------------------------------------
//
//  Vector Table: All calls on registered interfaces are dispatched through
//  this table to ThreadInvoke, which subsequently dispatches to the
//  appropriate interface stub. All calls on COM interfaces are dispatched
//  on method #0 so the table only needs to be 1 entry long.
//
//+------------------------------------------------------------------------
const RPC_DISPATCH_FUNCTION vector[] =
{
    (void (_stdcall *) (struct  ::_RPC_MESSAGE *)) ThreadInvoke,
};

const RPC_DISPATCH_TABLE gDispatchTable =
{
    sizeof(vector)/sizeof(RPC_DISPATCH_FUNCTION),
    (RPC_DISPATCH_FUNCTION *)&vector, 0
};


//+------------------------------------------------------------------------
//
//  Interface Templates. When we register an interface with the RPC runtime,
//  we allocate an structure, copy one of these templates in (depending on
//  whether we want client side or server side) and then set the interface
//  IID to the interface being registered.
//
//  We hand-register the RemUnknown interface because we normally marshal its
//  derived verion (IRundown), yet expect calls on IRemUnknown.
//
//+------------------------------------------------------------------------

// NOTE: For 64-bit COM, we support non-NDR transfer syntaxes. In this
// case, we get RPC_SERVER_INERFACE directly from the RPC NDR engine
// and will not use the fake gServerIf struct below on the server 
// side - Sajia

// NOTE - Updating RPC_SERVER_INTERFACE to reflect the current 
// version of the struct-Sajia

extern const RPC_SERVER_INTERFACE gServerIf =
{
   sizeof(RPC_SERVER_INTERFACE),
   {0x69C09EA0, 0x4A09, 0x101B, 0xAE, 0x4B, 0x08, 0x00, 0x2B, 0x34, 0x9A, 0x02,
    {0, 0}},
   {0x8A885D04, 0x1CEB, 0x11C9, 0x9F, 0xE8, 0x08, 0x00, 0x2B, 0x10, 0x48, 0x60,
    {2, 0}},
   (RPC_DISPATCH_TABLE *)&gDispatchTable, 0, 0, 0, 0, 0
};

// NOTE: For 64-bit COM, we support non-NDR transfer syntaxes. In this
// case, we get RPC_CLIENT_INERFACE directly from the RPC NDR engine
// and will not use the fake gClientIf struct below on the client 
// side - Sajia

// NOTE - Updating RPC_CLIENT_INTERFACE to reflect the current 
// version of the struct-Sajia

const RPC_CLIENT_INTERFACE gClientIf =
{
   sizeof(RPC_CLIENT_INTERFACE),
   {0x69C09EA0, 0x4A09, 0x101B, 0xAE, 0x4B, 0x08, 0x00, 0x2B, 0x34, 0x9A, 0x02,
    {0, 0}},
   {0x8A885D04, 0x1CEB, 0x11C9, 0x9F, 0xE8, 0x08, 0x00, 0x2B, 0x10, 0x48, 0x60,
    {2, 0}},
   0, 0, 0, 0, 0, 0
};

const RPC_SERVER_INTERFACE gRemUnknownIf =
{
   sizeof(RPC_SERVER_INTERFACE),
   {0x00000131, 0x0000, 0x0000, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x46,
    {0, 0}},
   {0x8A885D04, 0x1CEB, 0x11C9, 0x9F, 0xE8, 0x08, 0x00, 0x2B, 0x10, 0x48, 0x60,
    {2, 0}},
   (RPC_DISPATCH_TABLE *)&gDispatchTable, 0, 0, 0
};

const RPC_SERVER_INTERFACE gRemUnknownIf2 =
{
   sizeof(RPC_SERVER_INTERFACE),
   {0x00000143, 0x0000, 0x0000, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x46,
    {0, 0}},
   {0x8A885D04, 0x1CEB, 0x11C9, 0x9F, 0xE8, 0x08, 0x00, 0x2B, 0x10, 0x48, 0x60,
    {2, 0}},
   (RPC_DISPATCH_TABLE *)&gDispatchTable, 0, 0, 0
};


//+------------------------------------------------------------------------
//
//  Registered Interface hash table buckets. This is defined as a global
//  so that we dont have to run any code to initialize the hash table.
//
//+------------------------------------------------------------------------
SHashChain RIFBuckets[23] =
{
    {&RIFBuckets[0],  &RIFBuckets[0]},
    {&RIFBuckets[1],  &RIFBuckets[1]},
    {&RIFBuckets[2],  &RIFBuckets[2]},
    {&RIFBuckets[3],  &RIFBuckets[3]},
    {&RIFBuckets[4],  &RIFBuckets[4]},
    {&RIFBuckets[5],  &RIFBuckets[5]},
    {&RIFBuckets[6],  &RIFBuckets[6]},
    {&RIFBuckets[7],  &RIFBuckets[7]},
    {&RIFBuckets[8],  &RIFBuckets[8]},
    {&RIFBuckets[9],  &RIFBuckets[9]},
    {&RIFBuckets[10], &RIFBuckets[10]},
    {&RIFBuckets[11], &RIFBuckets[11]},
    {&RIFBuckets[12], &RIFBuckets[12]},
    {&RIFBuckets[13], &RIFBuckets[13]},
    {&RIFBuckets[14], &RIFBuckets[14]},
    {&RIFBuckets[15], &RIFBuckets[15]},
    {&RIFBuckets[16], &RIFBuckets[16]},
    {&RIFBuckets[17], &RIFBuckets[17]},
    {&RIFBuckets[18], &RIFBuckets[18]},
    {&RIFBuckets[19], &RIFBuckets[19]},
    {&RIFBuckets[20], &RIFBuckets[20]},
    {&RIFBuckets[21], &RIFBuckets[21]},
    {&RIFBuckets[22], &RIFBuckets[22]}
};


//+-------------------------------------------------------------------
//
//  Function:   CleanupRIFEntry
//
//  Synopsis:   Call the RIFTable to cleanup an entry. This is called
//              by the hash table cleanup code.
//
//  History:    12-Feb-96   Rickhi  Created
//
//--------------------------------------------------------------------
void CleanupRIFEntry(SHashChain *pNode)
{
    gRIFTbl.UnRegisterInterface((RIFEntry *)pNode, TRUE);
}


//+-------------------------------------------------------------------
//
//  Function:   UnregisterUnusedInterfaces
//
//  Synopsis:   Call the RIFTable to cleanup all unused interface 
//              entries.  This is called by the class cache when 
//              unloading DLLs.
//
//  History:    22-Apr-02   JohnDoty  Created
//
//--------------------------------------------------------------------
void UnregisterUnusedInterfaces()
{
    gRIFTbl.UnregisterUnused();
}


//+------------------------------------------------------------------------
//
//  Member:     CRIFTable::Initialize, public
//
//  Synopsis:   Initialize the Registered Interface Table
//
//  History:    12-Feb-96   Rickhi      Created
//
//-------------------------------------------------------------------------
void CRIFTable::Initialize()
{
    ComDebOut((DEB_CHANNEL, "CRIFTable::Initialize\n"));
    ASSERT_LOCK_NOT_HELD(_mxs);
    LOCK(_mxs);
    ASSERT_LOCK_HELD(_mxs);
    _fPreFilled = FALSE;
    _HashTbl.Initialize(RIFBuckets, &_mxs);
    _palloc.Initialize(sizeof(RIFEntry), RIFS_PER_PAGE, NULL);
    UNLOCK(_mxs);
    ASSERT_LOCK_NOT_HELD(_mxs);
}

//+------------------------------------------------------------------------
//
//  Member:     CRIFTable::Cleanup, public
//
//  Synopsis:   Cleanup the Registered Interface Table.
//
//  History:    12-Feb-96   Rickhi      Created
//
//-------------------------------------------------------------------------
void CRIFTable::Cleanup()
{
    ComDebOut((DEB_CHANNEL, "CRIFTable::Cleanup\n"));
    ASSERT_LOCK_NOT_HELD(_mxs);
    LOCK(_mxs);
    ASSERT_LOCK_HELD(_mxs);
    _HashTbl.Cleanup(CleanupRIFEntry);
    _palloc.Cleanup();
    _fPreFilled = FALSE;
    UNLOCK(_mxs);
    ASSERT_LOCK_NOT_HELD(_mxs);
}

//+-------------------------------------------------------------------
//
//  Member:     CRIFTable::GetClientInterfaceInfo, public
//
//  Synopsis:   returns the interface info for a given interface
//
//  History:    12-Feb-96   Rickhi  Created
//
//--------------------------------------------------------------------
RPC_CLIENT_INTERFACE *CRIFTable::GetClientInterfaceInfo(REFIID riid)
{
	RPC_CLIENT_INTERFACE *ret = NULL;

    DWORD iHash = _HashTbl.Hash(riid);
    ASSERT_LOCK_NOT_HELD(_mxs);
    LOCK(_mxs);
    ASSERT_LOCK_HELD(_mxs);
    RIFEntry *pRIFEntry = (RIFEntry *) _HashTbl.Lookup(iHash, riid);
    Win4Assert(pRIFEntry);      // must already be registered
	if (pRIFEntry)
	{
		Win4Assert(pRIFEntry->pCliInterface);
		ret = pRIFEntry->pCliInterface;
	}
    UNLOCK(_mxs);
    ASSERT_LOCK_NOT_HELD(_mxs);

    return ret;
}
//+-------------------------------------------------------------------
//
//  Member:     CRIFTable::GetServerInterfaceInfo, public
//
//  Synopsis:   returns the interface info for a given interface
//
//  History:    27-Apr-97    MattSmit  Created
//
//--------------------------------------------------------------------
RPC_SERVER_INTERFACE *CRIFTable::GetServerInterfaceInfo(REFIID riid)
{
	RPC_SERVER_INTERFACE *ret = NULL;
    DWORD iHash;

    ASSERT_LOCK_NOT_HELD(_mxs);
    LOCK(_mxs);
    ASSERT_LOCK_HELD(_mxs);
    
	iHash = _HashTbl.Hash(riid);
	
    RIFEntry *pRIFEntry = (RIFEntry *) _HashTbl.Lookup(iHash, riid);
    Win4Assert(pRIFEntry);      // must already be registered
	if (pRIFEntry)
	{
		Win4Assert(pRIFEntry->pSrvInterface);
		ret = pRIFEntry->pSrvInterface;
	}
    UNLOCK(_mxs);
    ASSERT_LOCK_NOT_HELD(_mxs);

    return ret;
}

//+-------------------------------------------------------------------
//
//  Member:     CRIFTable::RegisterInterface, public
//
//  Synopsis:   returns the proxy stub clsid of the specified interface,
//              and adds an entry to the registered interface hash table
//              if needed.
//
//  History:    12-Feb-96   Rickhi      Created
//              10-Jan-2000 Sajia       Modifications for NDR64
//--------------------------------------------------------------------
HRESULT CRIFTable::RegisterInterface(
    REFIID riid, 
    BOOL fServer, 
    IRpcStubBuffer *pStub, 
    RIFEntry *pRIFEntry)
{
    Win4Assert ((!fServer && !pStub) || (fServer && pStub));
    Win4Assert(pRIFEntry);

    ComDebOut((DEB_CHANNEL, "CRIFTable::RegisterInterface riid:%I\n", &riid));
    ASSERT_LOCK_NOT_HELD(_mxs);
    
    if (pRIFEntry == NULL)
        return E_INVALIDARG;

    LOCK(_mxs);
    ASSERT_LOCK_HELD(_mxs);   

    HRESULT hr = S_OK;

    // Look to ensure either server or client side is registered.
    if (fServer)
    {
        if (pRIFEntry->pSrvInterface == NULL)
        {
            // server side not yet registered, go register it
            hr = RegisterServerInterface(pRIFEntry, riid, pStub);
        }
    }
    else if (pRIFEntry->pCliInterface == NULL)
    {
        // client side not yet registered, go register it
        hr = RegisterClientInterface(pRIFEntry, riid);
    }

    // Increment the number of registrations for this entry.
    if (SUCCEEDED(hr))
    {
        pRIFEntry->cRefs++;
    }

    UNLOCK(_mxs);
    ASSERT_LOCK_NOT_HELD(_mxs);

    return hr;
}

//+-------------------------------------------------------------------
//
//  Member:     CRIFTable::RegisterClientInterface, private
//
//  Synopsis:   Register with the RPC runtime a client RPC interface
//              structure for the given IID. The IID must not already
//              be registered.
//
//  History:    12-Feb-96   Rickhi      Created
//
//--------------------------------------------------------------------
HRESULT CRIFTable::RegisterClientInterface(RIFEntry *pRIFEntry, REFIID riid)
{
    ComDebOut((DEB_CHANNEL,
        "CRIFTable::RegisterClientInterface pRIFEntry:%x\n", pRIFEntry));
    Win4Assert(pRIFEntry->pCliInterface == NULL);
    ASSERT_LOCK_HELD(_mxs);

    HRESULT hr = E_OUTOFMEMORY;
    pRIFEntry->pCliInterface = (RPC_CLIENT_INTERFACE *)
                             PrivMemAlloc(sizeof(RPC_CLIENT_INTERFACE));

    if (pRIFEntry->pCliInterface != NULL)
    {
        memcpy(pRIFEntry->pCliInterface, &gClientIf, sizeof(gClientIf));
        pRIFEntry->pCliInterface->InterfaceId.SyntaxGUID = riid;
        hr = S_OK;
    }

    return hr;
}


//+-------------------------------------------------------------------
//
//  Member:     CRIFTable::RegisterServerInterface, private
//
//  Synopsis:   Register with the RPC runtime a server RPC interface
//              structure for the given IID. The IID must not already
//              be registered
//
//  History:    12-Feb-96   Rickhi      Created
//              10-Jan-2000 Sajia       Modifications for NDR64
//
//--------------------------------------------------------------------
HRESULT CRIFTable::RegisterServerInterface(RIFEntry *pRIFEntry, REFIID riid, IRpcStubBuffer *pStub)
{
    RPC_STATUS sc;
    ComDebOut((DEB_CHANNEL,
               "CRIFTable::RegisterServerInterface pRIFEntry:%x\n", pRIFEntry));
    Win4Assert(pRIFEntry->pSrvInterface == NULL);
    ASSERT_LOCK_HELD(_mxs);

    HRESULT hr = E_OUTOFMEMORY;
    pRIFEntry->pSrvInterface = (RPC_SERVER_INTERFACE *)
                               PrivMemAlloc(sizeof(RPC_SERVER_INTERFACE));

    if (pRIFEntry->pSrvInterface != NULL)
    {
        hr = S_OK;
        memcpy(pRIFEntry->pSrvInterface, &gServerIf, sizeof(gServerIf));
        pRIFEntry->pSrvInterface->InterfaceId.SyntaxGUID = riid;

        sc = NdrCreateServerInterfaceFromStub (pStub, pRIFEntry->pSrvInterface);
        if (sc != RPC_S_OK)
        {
            ComDebOut((DEB_ERROR,
                       "NdrCreateServerInterfaceFromStub %I failed:0x%x.\n", &riid, sc));

            PrivMemFree(pRIFEntry->pSrvInterface);
            pRIFEntry->pSrvInterface = NULL;
            hr = HRESULT_FROM_WIN32(sc);
            return hr;
        }
        pRIFEntry->pSrvInterface->DispatchTable = (RPC_DISPATCH_TABLE *)&gDispatchTable;

        sc = RpcServerRegisterIf2(pRIFEntry->pSrvInterface, NULL,
                                              NULL,
                                              RPC_IF_AUTOLISTEN | RPC_IF_OLE,
                                              RPC_C_LISTEN_MAX_CALLS_DEFAULT, 
                                              (unsigned int)-1,
                                              NULL);
        if (sc != RPC_S_OK)
        {
            ComDebOut((DEB_ERROR,
                       "RegisterServerInterface %I failed:0x%x.\n", &riid, sc));

            PrivMemFree(pRIFEntry->pSrvInterface);
            pRIFEntry->pSrvInterface = NULL;
            hr = HRESULT_FROM_WIN32(sc);
        }
    }

    return hr;
}

//+-------------------------------------------------------------------
//
//  Member:     CRIFTable::ReleaseInterface, public
//
//  Synopsis:   Release a registration count on the registered iface.
//
//  History:    22-Apr-02  JohnDoty  Created
//
//--------------------------------------------------------------------
void CRIFTable::ReleaseInterface(REFIID riid)
{
    DWORD iHash = _HashTbl.Hash(riid);

    ASSERT_LOCK_NOT_HELD(_mxs);
    LOCK(_mxs);

    RIFEntry *pRIFEntry = (RIFEntry *) _HashTbl.Lookup(iHash, riid);
    if (pRIFEntry)
    {
        Win4Assert(pRIFEntry->cRefs > 0);
        pRIFEntry->cRefs--;

        // RIF Entries with 0 references will be cleaned
        // up later.
    }
    
    UNLOCK(_mxs);
    ASSERT_LOCK_NOT_HELD(_mxs);   
}


//+-------------------------------------------------------------------
//
//  Member:     CRIFTable::UnregisterUnusedHelper, static
//
//  Synopsis:   Helper function for CHashTable::EnumAndRemove.
//
//  History:    22-Apr-02  JohnDoty  Created
//
//--------------------------------------------------------------------
BOOL CRIFTable::UnregisterUnusedHelper(SHashChain *pNode, void *pvData)
{
    RIFEntry *pEntry = (RIFEntry *)pNode;
    CRIFTable *pThis = (CRIFTable *)pvData;

    if (pEntry->cRefs == 0)
    {
        // Remove this entry, it isn't being used.
        pThis->UnRegisterInterface(pEntry, FALSE);
    }
    
    // Don't take it out of the table.
    return FALSE;
}

//+-------------------------------------------------------------------
//
//  Member:     CRIFTable::UnregisterUnused, public
//
//  Synopsis:   Unregister all of the RIF entries that are not being
//              used any more.
//
//  History:    22-Apr-02  JohnDoty  Created
//
//--------------------------------------------------------------------
void CRIFTable::UnregisterUnused()
{    
    ASSERT_LOCK_NOT_HELD(_mxs);
    LOCK(_mxs);

    // If not pre-filled, then we haven't added anything to the table
    // yet, or the table has been cleaned up already.
    if (_fPreFilled)
    {
        _HashTbl.EnumAndRemove(UnregisterUnusedHelper, this, NULL, NULL);
    }

    UNLOCK(_mxs);
    ASSERT_LOCK_NOT_HELD(_mxs);
}

//+-------------------------------------------------------------------
//
//  Member:     CRIFTable::UnRegisterInterface
//
//  Synopsis:   UnRegister with the RPC runtime a server RPC interface
//              structure for the given IID. This is called by
//              CUUIDHashTable::Cleanup during CoUninitialize. Also
//              delete the interface structures.
//
//  History:    12-Feb-96   Rickhi  Created
//
//--------------------------------------------------------------------
void CRIFTable::UnRegisterInterface(RIFEntry *pRIFEntry, BOOL fFree)
{
    PrivMemFree(pRIFEntry->pCliInterface);
    pRIFEntry->pCliInterface = NULL;
    if (pRIFEntry->pSrvInterface)
    {
        // server side entry exists, unregister the interface with RPC.
        // Note that this can result in calls being dispatched so we
        // have to release the lock around the call.
        RPC_SERVER_INTERFACE *pSrvInterface = pRIFEntry->pSrvInterface;
        pRIFEntry->pSrvInterface = NULL;
        
        ASSERT_LOCK_HELD(_mxs);
        UNLOCK(_mxs);
        ASSERT_LOCK_NOT_HELD(_mxs);
        // Get the status, but we don't really care.
        RPC_STATUS st = RpcServerUnregisterIf(pSrvInterface, 0, 1);
        PrivMemFree(pSrvInterface);
        ASSERT_LOCK_NOT_HELD(_mxs);
        LOCK(_mxs);
        ASSERT_LOCK_HELD(_mxs);
    }
    if (fFree)
    {
        _palloc.ReleaseEntry((PageEntry *)pRIFEntry);
    }
}

//+-------------------------------------------------------------------
//
//  Member:     CRIFTable::GetPSClsidHelper, internal
//
//  Synopsis:   Finds the RIFEntry in the table for the given riid, and
//              adds an entry if one is not found. Called by CoGetPSClsid
//              and by CRIFTable::RegisterInterface.
//
//  Notes:      This takes the critical section and calls a common helper
//              function.
//
//  History:    12-Feb-96   Rickhi      Created
//
//--------------------------------------------------------------------
HRESULT CRIFTable::GetPSClsid(REFIID riid, CLSID *pclsid, RIFEntry **ppEntry)
{
    ComDebOut((DEB_CHANNEL,
        "CRIFTable::GetPSClsid riid:%I pclsid:%x\n", &riid, pclsid));

    ASSERT_LOCK_NOT_HELD(_mxs);
    LOCK(_mxs);
    ASSERT_LOCK_HELD(_mxs);

    HRESULT hr = GetPSClsidHelper(riid, pclsid, ppEntry);

    ASSERT_LOCK_HELD(_mxs);
    UNLOCK(_mxs);
    ASSERT_LOCK_NOT_HELD(_mxs);

    return hr;
}

//+-------------------------------------------------------------------
//
//  Member:     CRIFTable::GetPSClsidHelper, internal
//
//  Synopsis:   Finds the RIFEntry in the table for the given riid, and
//              adds an entry if one is not found. Called by CoGetPSClsid
//              and by CRIFTable::RegisterInterface.
//
//  Notes:      This assumes the caller is holding the critical section
//
//  History:    12-Feb-96   Rickhi      Created
//
//--------------------------------------------------------------------
HRESULT CRIFTable::GetPSClsidHelper(REFIID riid, CLSID *pclsid, RIFEntry **ppEntry)
{
    ComDebOut((DEB_CHANNEL,
        "CRIFTable::GetPSClsid riid:%I pclsid:%x\n", &riid, pclsid));
    ASSERT_LOCK_HELD(_mxs);
    HRESULT hr = S_OK;
    ACTCTX_SECTION_KEYED_DATA askd;
    GUID *pSxsProxyStubClsid32 = NULL;

    // look for the interface in the table.
    DWORD iHash = _HashTbl.Hash(riid);
    RIFEntry *pRIFEntry = (RIFEntry *) _HashTbl.Lookup(iHash, riid);

    if (pRIFEntry == NULL)
    {
        // make sure the known IIDs are prefilled in the cache. We've
        // delayed adding them until this point in order to avoid
        // touching the pages until a request is actually issued.
        pRIFEntry = PreFillKnownIIDs(riid);
    }

    if (pRIFEntry == NULL || !(pRIFEntry->dwFlags & RIFFLG_HASCLSID))
    {
        // still no entry exists for this interface, add one. Dont
        // hold the lock over a call to the registry

        UNLOCK(_mxs);
        ASSERT_LOCK_NOT_HELD(_mxs);

        askd.cbSize = sizeof(askd);

        if (!::FindActCtxSectionGuid(
                    0,              // dwFlags
                    NULL,           // lpExtensionGuid
                    ACTIVATION_CONTEXT_SECTION_COM_INTERFACE_REDIRECTION,
                    &riid,
                    &askd))
        {
            const DWORD dwLastError = ::GetLastError();
            if ((dwLastError != ERROR_SXS_KEY_NOT_FOUND) &&
                (dwLastError != ERROR_SXS_SECTION_NOT_FOUND))
            {
                LOCK(_mxs);
                ASSERT_LOCK_HELD(_mxs);
                return HRESULT_FROM_WIN32(dwLastError);
            }
        }
        else
        {
            // Add additional cases here to deal with other data formats in the future.
            if (askd.ulDataFormatVersion == ACTIVATION_CONTEXT_DATA_COM_INTERFACE_REDIRECTION_FORMAT_WHISTLER)
            {
                pSxsProxyStubClsid32 = &((PACTIVATION_CONTEXT_DATA_COM_INTERFACE_REDIRECTION) askd.lpData)->ProxyStubClsid32;
            }
        }

        hr = wRegQueryPSClsid(riid, pclsid);

        if (SUCCEEDED(hr))
        {
            if (pSxsProxyStubClsid32 != NULL)
            {
                // Verify that they match; otherwise something very broken is going on.
                if ((*pclsid) != (*pSxsProxyStubClsid32))
                {
                    ComDebOut((DEB_CHANNEL, "OLE/SXS: ProxyStubClsid32 in manifest does not match interface's registered ProxyStubClsid32\n"));

                    LOCK(_mxs);
                    ASSERT_LOCK_HELD(_mxs);
                    return REGDB_E_INVALIDVALUE;
                }
            }
        }
        else if (hr == REGDB_E_IIDNOTREG)
        {
            if (pSxsProxyStubClsid32 != NULL)
            {
                *pclsid = *pSxsProxyStubClsid32;
                hr = NOERROR;
            }
        }

        ASSERT_LOCK_NOT_HELD(_mxs);
        LOCK(_mxs);
        ASSERT_LOCK_HELD(_mxs);

        // now that we are holding the lock again, do another lookup incase
        // some other thread came it while the lock was released.

        pRIFEntry = (RIFEntry *) _HashTbl.Lookup(iHash, riid);
        if (pRIFEntry == NULL && SUCCEEDED(hr)) // <--- NOTE: do not change w/o 
        {                                       //      changing else if condition
            hr = AddEntry(*pclsid, riid, iHash, &pRIFEntry);
        }
        else if (SUCCEEDED(hr) && !(pRIFEntry->dwFlags & RIFFLG_HASCLSID))
        {
            // an entry was created, but the clsid has not
            // been filled in.
            pRIFEntry->psclsid = *pclsid;
            pRIFEntry->dwFlags |= RIFFLG_HASCLSID;
        }

    }
    else
    {
        // found an entry, return the clsid
        *pclsid = pRIFEntry->psclsid;
    }

    *ppEntry = pRIFEntry;

    ASSERT_LOCK_HELD(_mxs);
    ComDebOut((DEB_CHANNEL, "CRIFTable::RegisterPSClsid pRIFEntry:%x\n", pRIFEntry));
    return hr;
}

//+-------------------------------------------------------------------
//
//  Member:     CRIFTable::PreFillKnownIIDs, public
//
//  Synopsis:   PreFills the RIFTable with the known IID->PSCLSID mappings.
//              The known mappings are the ones that COM uses internally.
//              This saves registry lookups and prevents tampering with
//              the system interface stubs.
//
//  History:    22-Oct-96   Rickhi      Created
//
//--------------------------------------------------------------------
RIFEntry *CRIFTable::PreFillKnownIIDs(REFIID riid)
{
    if (_fPreFilled)
    {
        return NULL;
    }

    RIFEntry *pRIFEntry = NULL;
    const IID *piid;
    int i=0;

    while ((piid = gKnownSystemIIDs[i++]) != NULL)
    {
        // add each mapping to the table
        RIFEntry *pRIFTmp;
        DWORD iHash = _HashTbl.Hash(*piid);
        if (SUCCEEDED(AddEntry(*gKnownSystemCLSIDs[i-1], *piid, iHash, &pRIFTmp)))
        {
            if (InlineIsEqualGUID(riid, *piid))
            {
                pRIFEntry = pRIFTmp;
            }
        }
    }

    // mark the table as pre-filled
    _fPreFilled = TRUE;
    return pRIFEntry;
}

//+-------------------------------------------------------------------
//
//  Member:     CRIFTable::RegisterPSClsid, public
//
//  Synopsis:   Adds an entry to the table. Used by CoRegisterPSClsid
//              so that applications can add a temporary entry that only
//              affects the local process without having to muck with
//              the system registry.
//
//  History:    12-Feb-96   Rickhi      Created
//
//--------------------------------------------------------------------
HRESULT CRIFTable::RegisterPSClsid(REFIID riid, REFCLSID rclsid)
{
    ComDebOut((DEB_CHANNEL,
        "CRIFTable::RegisterPSClsid rclsid:%I riid:%I\n", &rclsid, &riid));

    HRESULT hr = S_OK;
    ASSERT_LOCK_NOT_HELD(_mxs);
    LOCK(_mxs);
    ASSERT_LOCK_HELD(_mxs);

    // look for the interface in the table.
    DWORD iHash = _HashTbl.Hash(riid);
    RIFEntry *pRIFEntry = (RIFEntry *) _HashTbl.Lookup(iHash, riid);

    if (pRIFEntry == NULL)
    {
        // no entry exists for this interface, add one.
        hr = AddEntry(rclsid, riid, iHash, &pRIFEntry);
    }
    else
    {
        // found an entry, update the clsid
        pRIFEntry->psclsid = rclsid;
    }

    UNLOCK(_mxs);
    ASSERT_LOCK_NOT_HELD(_mxs);
    ComDebOut((DEB_CHANNEL, "CRIFTable::RegisterPSClsid hr:%x\n", hr));
    return hr;
}

//+-------------------------------------------------------------------
//
//  Member:     CRIFTable::AddEntry, private
//
//  Synopsis:   allocates and entry, fills in the values, and adds it
//              to the hash table.
//
//  History:    12-Feb-96   Rickhi      Created
//
//--------------------------------------------------------------------
HRESULT CRIFTable::AddEntry(REFCLSID rclsid, REFIID riid,
                            DWORD iHash, RIFEntry **ppRIFEntry)
{
    ASSERT_LOCK_HELD(_mxs);
    RIFEntry *pRIFEntry = (RIFEntry *) _palloc.AllocEntry();

    if (pRIFEntry)
    {
        pRIFEntry->psclsid = rclsid;
        pRIFEntry->dwFlags = RIFFLG_HASCLSID;
        pRIFEntry->cRefs   = 0;
        pRIFEntry->pSrvInterface = NULL;
        pRIFEntry->pCliInterface = NULL;
        *ppRIFEntry = pRIFEntry;

        // add to the hash table
        _HashTbl.Add(iHash, riid, &pRIFEntry->HashNode);

        ComDebOut((DEB_CHANNEL,
            "Added RIFEntry riid:%I pRIFEntry\n", &riid, pRIFEntry));
        return S_OK;
    }

    ASSERT_LOCK_HELD(_mxs);
    return E_OUTOFMEMORY;
}
//+-------------------------------------------------------------------
//
//  Member:     CRIFTable::SyncFromAsync public
//
//  Synopsis:   gets mapping from asynchronous IID to synchronous IID
//
//  History:    03-May-99   MattSmit  Created
//
//--------------------------------------------------------------------
HRESULT CRIFTable::SyncFromAsync(const IID &async, IID *psync)
{
    return InterfaceMapHelper(async, psync, FALSE);
}

//+-------------------------------------------------------------------
//
//  Member:     CRIFTable::AsyncFromSync public
//
//  Synopsis:   gets mapping from synchronous IID to asynchronous IID
//
//  History:    03-May-99   MattSmit  Created
//
//--------------------------------------------------------------------
HRESULT CRIFTable::AsyncFromSync(const IID &sync, IID *pasync)
{
    return InterfaceMapHelper(sync, pasync, TRUE);
}

//+-------------------------------------------------------------------
//
//  Member:     CRIFTable::InterfaceMapHelper private
//
//  Synopsis:   does the work of getting the mapping.
//
//  History:    03-May-99   MattSmit  Created
//
//--------------------------------------------------------------------
HRESULT CRIFTable::InterfaceMapHelper(const IID &riid1, IID *piid2, BOOL fAsyncFromSync)
{

    ASSERT_LOCK_NOT_HELD(_mxs);
    LOCK(_mxs);
    ASSERT_LOCK_HELD(_mxs);
    
    DWORD dwHash = _HashTbl.Hash(riid1);
    HRESULT hr;
    RIFEntry *pRifEntry = (RIFEntry *) _HashTbl.Lookup(dwHash, riid1);
    if (!pRifEntry || !(pRifEntry->dwFlags & RIFFLG_HASCOUNTERPART))
    {
        UNLOCK(_mxs);
        ASSERT_LOCK_NOT_HELD(_mxs);
        
        if (fAsyncFromSync)
            hr = wRegQueryAsyncIIDFromSyncIID(riid1, piid2);
        else
            hr = wRegQuerySyncIIDFromAsyncIID(riid1, piid2);

        LOCK(_mxs);
        ASSERT_LOCK_HELD(_mxs);

        if (SUCCEEDED(hr))
        {
            hr = RegisterInterfaceMapping(riid1, *piid2, dwHash, pRifEntry);
        }
    }
    else
    {
        *piid2 = pRifEntry->iidCounterpart;
        hr = S_OK;
    }
    UNLOCK(_mxs);
    ASSERT_LOCK_NOT_HELD(_mxs);
    return hr;
}

//+-------------------------------------------------------------------
//
//  Member:     CRIFTable::RegisterInterfaceMapping private
//
//  Synopsis:   creates a mapping between two interfaces
//
//  History:    03-May-99   MattSmit  Created
//
//--------------------------------------------------------------------
HRESULT CRIFTable::RegisterInterfaceMapping(const IID &iid1, const IID &iid2, 
                                            DWORD dwHash, RIFEntry *pRifEntry)
{
    ASSERT_LOCK_HELD(_mxs);
    if (!pRifEntry)
    {
        pRifEntry = (RIFEntry *) _HashTbl.Lookup(dwHash, iid1);
    }

    if (!pRifEntry)
    {
        // no RifEntry in the table, so allocate one.

        pRifEntry = (RIFEntry *) _palloc.AllocEntry();
        if (pRifEntry)
        {
            memset(pRifEntry, 0, sizeof(RIFEntry));
            // add to the hash table
            _HashTbl.Add(dwHash, iid1, &pRifEntry->HashNode);
        }
    }

    if (pRifEntry)
    {
        // fill in counterpart member

        Win4Assert(pRifEntry->HashNode.key == iid1);
        pRifEntry->iidCounterpart = iid2;
        pRifEntry->dwFlags |= RIFFLG_HASCOUNTERPART;
        return S_OK;
    }
    else
    {
        return E_OUTOFMEMORY;
    }
}

//+-------------------------------------------------------------------
//
//  Function:   CoRegisterPSClsid, public
//
//  Synopsis:   registers a IID->PSCLSID mapping that applies only within
//              the current process. Can be used by code downloaded over
//              a network to do custom interface marshaling without having
//              to muck with the system registry.
//
//  Algorithm:  validate the parameters then add an entry to the RIFTable.
//
//  History:    15-Apr-96   Rickhi      Created
//
//--------------------------------------------------------------------
STDAPI CoRegisterPSClsid(REFIID riid, REFCLSID rclsid)
{
    ComDebOut((DEB_MARSHAL,
        "CoRegisterPSClsid riid:%I rclsid:%I\n", &riid, &rclsid));

    HRESULT hr = InitChannelIfNecessary();
    if (FAILED(hr))
        return hr;

    hr = E_INVALIDARG;

    if ((&riid != NULL) && (&rclsid != NULL) &&
        IsValidPtrIn(&riid, sizeof(riid)) &&
        IsValidPtrIn(&rclsid, sizeof(rclsid)))
    {
        hr = gRIFTbl.RegisterPSClsid(riid, rclsid);
    }

    return hr;
}

//+-------------------------------------------------------------------------
//
//  Function:   CoGetPSClsid,    public
//
//  Synopsis:   returns the proxystub clsid associated with the specified
//              interface IID.
//
//  Arguments:  [riid]      - the interface iid to lookup
//              [lpclsid]   - where to return the clsid
//
//  Returns:    S_OK if successfull
//              REGDB_E_IIDNOTREG if interface is not registered.
//              REGDB_E_READREGDB if any other error
//
//  Algorithm:  First it looks in the local RIFTable for a matching IID. If
//              no entry is found, the RIFTable looks in the shared memory
//              table (NT only), and if not found and the table is FULL, it
//              will look in the registry itself.
//
//  History:    07-Apr-94   Rickhi      rewrite
//
//--------------------------------------------------------------------------
STDAPI CoGetPSClsid(REFIID riid, CLSID *pclsid)
{
    ComDebOut((DEB_MARSHAL, "CoGetPSClsid riid:%I pclsid:%x\n", &riid, pclsid));

    HRESULT hr = InitChannelIfNecessary();
    if (FAILED(hr))
        return hr;

    hr = E_INVALIDARG;

    if ((&riid != NULL) &&
        IsValidPtrIn(&riid, sizeof(riid)) &&
        IsValidPtrOut(pclsid, sizeof(*pclsid)))
    {
        RIFEntry *pRIFEntry;
        hr = gRIFTbl.GetPSClsid(riid, pclsid, &pRIFEntry);
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\com\dcomrem\stub_rawprivact_c.c ===
/* Stub for generated file rawprivact_c.c */
#include <rawprivact_c.c>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\com\dcomrem\security.cxx ===
//+-------------------------------------------------------------------
//
//  File:       security.cxx
//
//  Copyright (c) 1996-1996, Microsoft Corp. All rights reserved.
//
//  Contents:   Classes for channel security
//
//  Classes:    CClientSecurity, CServerSecurity
//
//  History:    11 Oct 95       AlexMit Created
//
//--------------------------------------------------------------------

#include <ole2int.h>
#include <locks.hxx>
#include <security.hxx>
#include <ctxchnl.hxx>
#include <ipidtbl.hxx>
#include <resolver.hxx>
#include <service.hxx>
#include <iaccess.h>
#include <stream.hxx>
#include <secdes.hxx>
#include <reghelp.hxx>

C2Security gC2Security;

extern "C"
{
#define SECURITY_WIN32 // Used by security.h
#include <security.h>
}

#include <ntsecapi.h>
#include <capi.h>      // Crypto API
#include <rpcssl.h>
#include <wincrypt.h>

#define SAFEALLOCA_ASSERT Win4Assert
#include <alloca.h>

#ifdef DCOM_SECURITY
/**********************************************************************/
// Definitions.

// SSL prinicpal name prefixes.
const WCHAR FULL_SUBJECT_ISSUER_CHAIN[]    = L"fullsic:";
const WCHAR MICROSOFT_STANDARD[]           = L"MSStd:";

// Versions of the permissions in the registry.
const WORD COM_PERMISSION_SECDESC = 1;
const WORD COM_PERMISSION_ACCCTRL = 2;

// Guess length of user name.
const DWORD SIZEOF_NAME         = 80;

// This leaves space for 8 sub authorities.  Currently NT only uses 6 and
// Cairo uses 7.
const DWORD SIZEOF_SID          = 44;

// This leaves space for 2 access allowed ACEs in the ACL.
const DWORD SIZEOF_ACL          = sizeof(ACL) + 2 * sizeof(ACCESS_ALLOWED_ACE) +
                                  2 * SIZEOF_SID;

const DWORD SIZEOF_TOKEN_USER   = sizeof(TOKEN_USER) + SIZEOF_SID;

const SID   LOCAL_SYSTEM_SID    = {SID_REVISION, 1, {0,0,0,0,0,5},
                                   SECURITY_LOCAL_SYSTEM_RID };

const SID   NETWORKSERVICE_SID   = {SID_REVISION, 1, {0,0,0,0,0,5},
                                   SECURITY_NETWORK_SERVICE_RID };
const DWORD NUM_SEC_PKG         = 8;

const DWORD ACCESS_CACHE_LEN    = 5;

const DWORD VALID_BLANKET_FLAGS = EOAC_MUTUAL_AUTH | EOAC_STATIC_CLOAKING |
                                  EOAC_DYNAMIC_CLOAKING | EOAC_MAKE_FULLSIC |
                                  EOAC_DEFAULT
#if MANUAL_CERT_CHECK // in concert with RPC codebase
                                  | EOAC_ANY_AUTHORITY
#endif // MANUAL_CERT_CHECK
                                  ;  // this terminates const statement

const DWORD VALID_INIT_FLAGS    = (VALID_BLANKET_FLAGS & ~EOAC_DEFAULT) |
                                  EOAC_SECURE_REFS |
                                  EOAC_ACCESS_CONTROL | EOAC_APPID |
                                  EOAC_DYNAMIC | EOAC_REQUIRE_FULLSIC |
                                  EOAC_DISABLE_AAA | EOAC_NO_CUSTOM_MARSHAL;

const DWORD ANY_CLOAKING        = EOAC_STATIC_CLOAKING | EOAC_DYNAMIC_CLOAKING;

// Remove this for NT 5.0 when we link to oleext.lib
const IID IID_IAccessControl = {0xEEDD23E0,0x8410,0x11CE,{0xA1,0xC3,0x08,0x00,0x2B,0x2B,0x8D,0x8F}};

// Map impersonation level to flags for APIs
const SECURITY_IMPERSONATION_LEVEL ImpLevelToSecLevel[5] =
  { SecurityAnonymous, SecurityAnonymous, SecurityIdentification,
    SecurityImpersonation, SecurityDelegation };
const DWORD ImpLevelToAccess[5]   = { 0, TOKEN_QUERY, TOKEN_QUERY,
                                      TOKEN_IMPERSONATE | TOKEN_QUERY,
                                      TOKEN_IMPERSONATE | TOKEN_QUERY };

// Stores results of AccessCheck.
typedef struct
{
    BOOL  fAccess;
    LUID  lClient;
} SAccessCache;

// Header in access permission key.
typedef struct
{
    WORD  wVersion;
    WORD  wPad;
    GUID  gClass;
} SPermissionHeader;

// Stores SSL certificate information.
typedef struct tagSCertificate
{
    struct tagSCertificate *pNext;
    WCHAR                   aSubject[1];
} SCertificate;

/**********************************************************************/
// Classes.

//+----------------------------------------------------------------
//
//  Class:       CAuthInfo
//
//  Purpose:     Maintains a list of default client authentication
//               information.
//
//  Description: This is a static class just to make it easy to find
//               all accesses to the data.
//
//-----------------------------------------------------------------
class CAuthInfo
{
  public:
    static void    Cleanup();
    static HRESULT Copy   ( SOLE_AUTHENTICATION_LIST *pAuthInfo,
                            SOLE_AUTHENTICATION_LIST **pCopyAuthInfo,
                            DWORD dwCapabilities );
    static void   *Find   ( SECURITYBINDING *pSecBind );
    static void    Set    ( SOLE_AUTHENTICATION_LIST *pAuthInfo );

  private:
    static SOLE_AUTHENTICATION_LIST *_sList;
    static BOOL                      _fNeedSSL;
};

//+----------------------------------------------------------------
//
//  Class:       CSSL
//
//  Purpose:     Save the handles associated with the default SSL
//               identity.
//
//  Description: This is a static class just to make it easy to find
//               all accesses to the data.
//
//-----------------------------------------------------------------
class CSSL
{
  public:
    static void    Cleanup      ();
    static HRESULT DefaultCert  ( PCCERT_CONTEXT *pCert );
    static HRESULT PrincipalName( const CERT_CONTEXT *pCert, WCHAR **pSSL );

  private:
    static HCRYPTPROV                     _hProvider;
    static HCERTSTORE                     _hMyStore;
    static HCERTSTORE                     _hRootStore;
    static const CERT_CONTEXT            *_pCert;
    static HRESULT                        _hr;
};

/**********************************************************************/
// Externals.

EXTERN_C const IID IID_ILocalSystemActivator;


/**********************************************************************/
// Prototypes.
WCHAR  *AuthnName              ( DWORD lAuthnService );
void    CacheAccess            ( LUID lClient, BOOL fAccess );
BOOL    CacheAccessCheck       ( LUID lClient, BOOL *pAccess );
HRESULT CheckAccessControl     ();
HRESULT CheckAcl               ( void );
HRESULT CopySecDesc            ( SECURITY_DESCRIPTOR *pOrig,
                                 SECURITY_DESCRIPTOR **pCopy );
HRESULT FixupAccessControl     ( SECURITY_DESCRIPTOR **pSD, DWORD cbSD );
HRESULT FixupSecurityDescriptor( SECURITY_DESCRIPTOR **pSD, DWORD cbSD );
HRESULT GetLegacyBlanket       ( SECURITY_DESCRIPTOR **, DWORD *, DWORD * );
void    GetRegistryAuthnLevel  ( HKEY hKey, DWORD *pAuthnLevel );
HRESULT GetRegistrySecDesc     ( HKEY, WCHAR *pAccessName,
                                 SECURITY_DESCRIPTOR **pSD, DWORD *, BOOL * );
DWORD   HashSid                ( SID * );
DWORD   LocalAuthnService      ( USHORT wAuthnService );
HRESULT LookupPrincName        ( USHORT, WCHAR ** );
HRESULT MakeSecDesc            ( SECURITY_DESCRIPTOR **, DWORD * );
HRESULT RegisterAuthnServices  ( DWORD cbSvc, SOLE_AUTHENTICATION_SERVICE * );
DWORD   RemoteAuthnService     ( USHORT wAuthnService, DUALSTRINGARRAY * );
DWORD   StrEscByteCnt          ( WCHAR * );
WCHAR  *StrEscCopy             ( WCHAR *, WCHAR * );
WCHAR  *StrQual                ( WCHAR *, BOOL * );


/**********************************************************************/
// Globals.

// These variables hold the default authentication information.
DWORD                            gAuthnLevel       = RPC_C_AUTHN_LEVEL_NONE;
DWORD                            gImpLevel         = RPC_C_IMP_LEVEL_IDENTIFY;
DWORD                            gCapabilities     = EOAC_NONE;
SECURITYBINDING                 *gLegacySecurity   = NULL;

// Initial values for CAuthInfo class.
SOLE_AUTHENTICATION_LIST *CAuthInfo::_sList    = NULL;
BOOL                      CAuthInfo::_fNeedSSL = TRUE;

// Initial values for the CSSL class.
HCRYPTPROV                    CSSL::_hProvider                    = NULL;
HCERTSTORE                    CSSL::_hMyStore                     = NULL;
HCERTSTORE                    CSSL::_hRootStore                   = NULL;
const CERT_CONTEXT           *CSSL::_pCert                        = NULL;
HRESULT                       CSSL::_hr                           = S_FALSE;
SCHANNEL_CRED                 gSchannelCred;
PCCERT_CONTEXT                gSchannelContext                    = NULL;

// These variables define a list of security providers OLE clients can
// use and a list OLE servers can use.
SECPKG              *gClientSvcList      = NULL;
DWORD                gClientSvcListLen   = 0;
USHORT              *gServerSvcList      = NULL;
DWORD                gServerSvcListLen   = 0;

// gDisableDCOM is read from the registry by CRpcResolver::GetConnection.
// If TRUE, all machine remote calls will be failed.  It is set TRUE in WOW.
BOOL                 gDisableDCOM        = FALSE;

// Set TRUE when CRpcResolver::GetConnection initializes the previous globals.
BOOL                 gGotSecurityData    = FALSE;

// The security descriptor to check when new connections are established.
// gAccessControl and gSecDesc will not both be nonNULL at the same time.
IAccessControl      *gAccessControl      = NULL;
SECURITY_DESCRIPTOR *gSecDesc            = NULL;

// The security string array.  If gDefaultService is TRUE, compute the
// security string array the first time a remote protocol sequence is
// registered.
DUALSTRINGARRAY     *gpsaSecurity        = NULL;
BOOL                 gDefaultService     = FALSE;

// Don't map any of the generic bits to COM_RIGHTS_EXECUTE or any other bit.
GENERIC_MAPPING      gMap  = { 0, 0, 0, 0 };
PRIVILEGE_SET        gPriv = { 1, 0 };

// Cache of results of calls to AccessCheck.
SAccessCache         gAccessCache[ACCESS_CACHE_LEN] =
{ {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}};
DWORD                gMostRecentAccess = 0;
COleStaticMutexSem   gSecurityLock;

// Cache of CServerSecurity objects.
const ULONG          SS_PER_PAGE = 10;  // server security objects per page
CPageAllocator       CServerSecurity::_palloc;
COleStaticMutexSem   CServerSecurity::_mxs;


//+-------------------------------------------------------------------
//
//  Function:   AuthnName
//
//  Synopsis:   Return the string name for the authentication service.
//
//  Note:       The name must be present because the id and the name
//              are both stored in gClientSvcList.
//
//--------------------------------------------------------------------
WCHAR *AuthnName( DWORD lAuthnService )
{
    DWORD i;

    for (i = 0; i < gClientSvcListLen; i++)
        if (gClientSvcList[i].wId == lAuthnService)
            return gClientSvcList[i].pName;
    return NULL;
}

//+-------------------------------------------------------------------
//
//  Function:   CacheAccess
//
//  Synopsis:   Store the results of the access check in the cache.
//
//--------------------------------------------------------------------
void CacheAccess( LUID lClient, BOOL fAccess )
{
    SAccessCache *pNew;
    DWORD         cbSid;

    ASSERT_LOCK_NOT_HELD(gSecurityLock);
    LOCK(gSecurityLock);

    // Find the next record.
    gMostRecentAccess += 1;
    if (gMostRecentAccess >= ACCESS_CACHE_LEN)
        gMostRecentAccess = 0;

    // Save the access results.
    gAccessCache[gMostRecentAccess].fAccess = fAccess;
    gAccessCache[gMostRecentAccess].lClient = lClient;

    UNLOCK(gSecurityLock);
    ASSERT_LOCK_NOT_HELD(gSecurityLock);
}

//+-------------------------------------------------------------------
//
//  Function:   CacheAccessCheck
//
//  Synopsis:   Look for the specified LUID in the cache.  If found,
//              return the results of the cached access check.
//
//--------------------------------------------------------------------
BOOL CacheAccessCheck( LUID lClient, BOOL *pAccess )
{
    DWORD         i;
    DWORD         j;
    BOOL          fFound = FALSE;
    SAccessCache  sSwap;

    ASSERT_LOCK_NOT_HELD(gSecurityLock);
    LOCK(gSecurityLock);

    // Look for the SID.
    j = gMostRecentAccess;
    for (i = 0; i < ACCESS_CACHE_LEN; i++)
    {
        if (gAccessCache[j].lClient.LowPart == lClient.LowPart &&
            gAccessCache[j].lClient.HighPart == lClient.HighPart)
        {
            // Move this entry to the head.
            fFound                          = TRUE;
            *pAccess                        = gAccessCache[j].fAccess;
            sSwap                           = gAccessCache[gMostRecentAccess];
            gAccessCache[gMostRecentAccess] = gAccessCache[j];
            gAccessCache[j]                 = sSwap;
            break;
        }
        if (j == 0)
            j = ACCESS_CACHE_LEN - 1;
        else
            j -= 1;
    }

    UNLOCK(gSecurityLock);
    ASSERT_LOCK_NOT_HELD(gSecurityLock);
    return fFound;
}

//+-------------------------------------------------------------------
//
//  Function:   CAuthInfo::Cleanup
//
//  Synopsis:   Cleanup the authentication list.
//
//--------------------------------------------------------------------
void CAuthInfo::Cleanup()
{
    PrivMemFree( _sList );
    _sList = NULL;
}

//+-------------------------------------------------------------------
//
//  Function:   CAuthInfo::Copy
//
//  Synopsis:   Copy an authentication information graph.
//
//  Note: This function needs to be updated as we support new
//        authentication services and as they support new
//        authentication information types.
//
//--------------------------------------------------------------------
HRESULT CAuthInfo::Copy( SOLE_AUTHENTICATION_LIST  *pAuthInfo,
                         SOLE_AUTHENTICATION_LIST **pCopyAuthInfo,
                         DWORD                      dwCapabilities )
{
    DWORD                      i;
    DWORD                      cbCopy;
    DWORD                      cAuthInfo = 0;
    DWORD                      dwAuthnSvc;
    SOLE_AUTHENTICATION_INFO  *aAuthInfo;
    char                      *pData;
    SEC_WINNT_AUTH_IDENTITY_W *pNtlm;
    SEC_WINNT_AUTH_IDENTITY_W *pNtlmCopy;
    BOOL                       fSSL      = FALSE;

    // Do nothing if there is no list.
    *pCopyAuthInfo = NULL;
    if (pAuthInfo == NULL)
        return S_OK;
    if (pAuthInfo == COLE_DEFAULT_AUTHINFO)
        return E_INVALIDARG;

    // Compute the size of the graph.
    cbCopy = sizeof(SOLE_AUTHENTICATION_LIST);
    for (i = 0; i < pAuthInfo->cAuthInfo; i++)
    {
        // Validate the parameters.
        dwAuthnSvc = pAuthInfo->aAuthInfo[i].dwAuthnSvc;
        pNtlm      = (SEC_WINNT_AUTH_IDENTITY_W *)
                         pAuthInfo->aAuthInfo[i].pAuthInfo;
        if (pNtlm == COLE_DEFAULT_AUTHINFO    ||
            dwAuthnSvc == RPC_C_AUTHN_DEFAULT ||
            pAuthInfo->aAuthInfo[i].dwAuthzSvc == RPC_C_AUTHZ_DEFAULT)
            return E_INVALIDARG;

        // Check the allowed structures for NTLM and Kerberos.
        else if (dwAuthnSvc == RPC_C_AUTHN_WINNT ||
                 dwAuthnSvc == RPC_C_AUTHN_GSS_KERBEROS)
        {
            if (pNtlm != NULL)
                if (pNtlm->Flags & SEC_WINNT_AUTH_IDENTITY_UNICODE)
                {
                    cbCopy += (pNtlm->UserLength + 1)*sizeof(WCHAR);
                    cbCopy += (pNtlm->DomainLength + 1)*sizeof(WCHAR);
                    cbCopy += (pNtlm->PasswordLength + 1)*sizeof(WCHAR);
                    cbCopy    += sizeof(SEC_WINNT_AUTH_IDENTITY_W);
                    cAuthInfo += 1;
                }
                else
                    return E_INVALIDARG;
        }

        // Check the allowed structure for SSL.
        else if (dwAuthnSvc == RPC_C_AUTHN_GSS_SCHANNEL)
        {
            if (dwCapabilities & ANY_CLOAKING)
                return E_INVALIDARG;
            cAuthInfo += 1;
            fSSL       = TRUE;
        }

        // All other authentication services can only have NULL auth info.
        else if (pNtlm != NULL)
            return E_INVALIDARG;
    }

    // Leave space for SSL credentials to be added later if not already
    // present.
    if (!fSSL)
        cAuthInfo += 1;

    // Add space for the SOLE_AUTHENTICATION_INFO structures.  Nothing
    // needs to be done if no authentication services had credentials.
    if (cAuthInfo == 0)
        return S_OK;
    cbCopy += cAuthInfo * sizeof(SOLE_AUTHENTICATION_INFO);

    // Allocate memory.
    *pCopyAuthInfo = (SOLE_AUTHENTICATION_LIST *) PrivMemAlloc( cbCopy );
    if (*pCopyAuthInfo == NULL)
        return E_OUTOFMEMORY;

    // Copy the graph.
    aAuthInfo = (SOLE_AUTHENTICATION_INFO *) ((*pCopyAuthInfo) + 1);
    pData     = (char *) (aAuthInfo + cAuthInfo);
    if (fSSL)
        (*pCopyAuthInfo)->cAuthInfo = cAuthInfo;
    else
        (*pCopyAuthInfo)->cAuthInfo = cAuthInfo - 1;
    (*pCopyAuthInfo)->aAuthInfo = aAuthInfo;
    for (i = 0; i < pAuthInfo->cAuthInfo; i++)
    {
        // Copy the structure for NTLM and Kerberos
        dwAuthnSvc = pAuthInfo->aAuthInfo[i].dwAuthnSvc;
        pNtlm      = (SEC_WINNT_AUTH_IDENTITY_W *)
                         pAuthInfo->aAuthInfo[i].pAuthInfo;
        if (dwAuthnSvc == RPC_C_AUTHN_WINNT ||
            dwAuthnSvc == RPC_C_AUTHN_GSS_KERBEROS)
        {
            // Copy the auth info.
            aAuthInfo->dwAuthnSvc = dwAuthnSvc;
            if (pNtlm == NULL)
                aAuthInfo->pAuthInfo = NULL;
            else
            {
                aAuthInfo->pAuthInfo  = pData;
                pNtlmCopy             = (SEC_WINNT_AUTH_IDENTITY_W *) pData;
                pData                 = (char *) (pNtlmCopy + 1);
                *pNtlmCopy            = *pNtlm;
                if (pAuthInfo->aAuthInfo[i].dwAuthzSvc == RPC_C_AUTHZ_NONE)
                    aAuthInfo->dwAuthzSvc = 0xffff;
                else
                    aAuthInfo->dwAuthzSvc = pAuthInfo->aAuthInfo[i].dwAuthzSvc;

                // Copy the strings.
                if (pNtlm->UserLength != 0)
                {
                    pNtlmCopy->User = (WCHAR *) pData;
                    memcpy( pNtlmCopy->User, pNtlm->User,
                            (pNtlm->UserLength + 1)*sizeof(WCHAR) );
                    pData += (pNtlm->UserLength + 1)*sizeof(WCHAR);
                }
                else
                    pNtlmCopy->User = NULL;
                if (pNtlm->DomainLength != 0)
                {
                    pNtlmCopy->Domain = (WCHAR *) pData;
                    memcpy( pNtlmCopy->Domain, pNtlm->Domain,
                            (pNtlm->DomainLength + 1)*sizeof(WCHAR) );
                    pData += (pNtlm->DomainLength + 1)*sizeof(WCHAR);
                }
                else
                    pNtlmCopy->Domain = NULL;
                if (pNtlm->PasswordLength != 0)
                {
                    pNtlmCopy->Password = (WCHAR *) pData;
                    memcpy( pNtlmCopy->Password, pNtlm->Password,
                            (pNtlm->PasswordLength + 1)*sizeof(WCHAR) );
                    pData += (pNtlm->PasswordLength + 1)*sizeof(WCHAR);
                }
                else
                    pNtlmCopy->Password = NULL;
            }

            // Advance the auth info.
            aAuthInfo += 1;
        }

        // Copy the structure for SSL.
        else if (dwAuthnSvc == RPC_C_AUTHN_GSS_SCHANNEL)
        {
            // Copy the auth info.
            aAuthInfo->dwAuthnSvc = dwAuthnSvc;
            aAuthInfo->pAuthInfo  = pAuthInfo->aAuthInfo[i].pAuthInfo;
            if (pAuthInfo->aAuthInfo[i].dwAuthzSvc == RPC_C_AUTHZ_NONE)
                aAuthInfo->dwAuthzSvc = 0xffff;
            else
                aAuthInfo->dwAuthzSvc = pAuthInfo->aAuthInfo[i].dwAuthzSvc;

            // Advance the auth info.
            aAuthInfo += 1;
        }
    }
    return S_OK;
}

//+-------------------------------------------------------------------
//
//  Function:   CAuthInfo::Find
//
//  Synopsis:   Scan the global authentication information array for
//              authentication information for the specified
//              authentication/authorization service pair.
//
//--------------------------------------------------------------------
void *CAuthInfo::Find( SECURITYBINDING *pSecBind )
{
    DWORD                i;
    DWORD                cAuthInfo;
    const CERT_CONTEXT  *pCert;
    HRESULT              hr;

    // Determine the list length.
    if (_sList == NULL)
        cAuthInfo = 0;
    else
        cAuthInfo = _sList->cAuthInfo;

    // Scan the list.
    for (i = 0; i < cAuthInfo; i++)
        if (_sList->aAuthInfo[i].dwAuthnSvc == pSecBind->wAuthnSvc &&
            _sList->aAuthInfo[i].dwAuthzSvc == pSecBind->wAuthzSvc)
            return _sList->aAuthInfo[i].pAuthInfo;

    // If the requested authentication service is SSL, try to find some
    // default SSL credentials.
    if (pSecBind->wAuthnSvc == RPC_C_AUTHN_GSS_SCHANNEL &&
        pSecBind->wAuthzSvc == RPC_C_AUTHZ_NONE         &&
        _fNeedSSL)
    {
        // Don't try again.
        _fNeedSSL = FALSE;

        // Try to get a certificate.
        hr = CSSL::DefaultCert( &pCert );

        // Save the authentication information and return it.
        if (SUCCEEDED(hr))
        {
            _sList->aAuthInfo[_sList->cAuthInfo].dwAuthnSvc = RPC_C_AUTHN_GSS_SCHANNEL;
            _sList->aAuthInfo[_sList->cAuthInfo].dwAuthzSvc = RPC_C_AUTHZ_NONE;
            _sList->aAuthInfo[_sList->cAuthInfo].pAuthInfo  = (void *) pCert;
            _sList->cAuthInfo += 1;
            return (void *) pCert;
        }
    }
    return NULL;
}

//+-------------------------------------------------------------------
//
//  Function:   CAuthInfo::Set
//
//  Synopsis:   Save the specified authentication information list.
//
//--------------------------------------------------------------------
void CAuthInfo::Set( SOLE_AUTHENTICATION_LIST *pAuthList )
{
    _sList    = pAuthList;
    _fNeedSSL = TRUE;
}

//+-------------------------------------------------------------------
//
//  Member:     CClientSecurity::CopyProxy, public
//
//  Synopsis:   Create a new IPID entry for the specified IID.
//
//--------------------------------------------------------------------
STDMETHODIMP CClientSecurity::CopyProxy( IUnknown *pProxy, IUnknown **ppCopy )
{
   // Make sure TLS is initialized on this thread.
   HRESULT          hr;
   COleTls          tls(hr);
   if (FAILED(hr))
       return hr;

    // Ask the marshaller to copy the proxy.
    return _pStdId->PrivateCopyProxy( pProxy, ppCopy );
}

//+-------------------------------------------------------------------
//
//  Member:     CClientSecurity::QueryBlanket, public
//
//  Synopsis:   Get the binding handle for a proxy.  Query RPC for the
//              authentication information for that handle.
//
//--------------------------------------------------------------------
STDMETHODIMP CClientSecurity::QueryBlanket(
                                IUnknown                *pProxy,
                                DWORD                   *pAuthnSvc,
                                DWORD                   *pAuthzSvc,
                                OLECHAR                **pServerPrincName,
                                DWORD                   *pAuthnLevel,
                                DWORD                   *pImpLevel,
                                void                   **pAuthInfo,
                                DWORD                   *pCapabilities )
{
    HRESULT           hr;
    IPIDEntry        *pIpid;
    IRemUnknown      *pRemUnk = NULL;

    // Initialize all out parameters to default values.
    if (pServerPrincName != NULL)
        *pServerPrincName = NULL;
    if (pAuthnLevel != NULL)
        *pAuthnLevel = RPC_C_AUTHN_LEVEL_PKT_PRIVACY;
    if (pImpLevel != NULL)
        *pImpLevel = RPC_C_IMP_LEVEL_IMPERSONATE;
    if (pAuthnSvc != NULL)
        *pAuthnSvc = RPC_C_AUTHN_WINNT;
    if (pAuthInfo != NULL)
        *pAuthInfo = NULL;
    if (pAuthzSvc != NULL)
        *pAuthzSvc = RPC_C_AUTHZ_NONE;
    if (pCapabilities != NULL)
        *pCapabilities = EOAC_NONE;

    ASSERT_LOCK_NOT_HELD(gIPIDLock);
    LOCK(gIPIDLock);

    // For IUnknown just call QueryBlanket on the IRemUnknown of
    // the IPID or the OXID.
    if (_pStdId->GetCtrlUnk() == pProxy)
    {
        pIpid = _pStdId->GetConnectedIPID();
        UNLOCK(gIPIDLock);
        ASSERT_LOCK_NOT_HELD(gIPIDLock);

        hr = _pStdId->GetSecureRemUnk( &pRemUnk, pIpid->pOXIDEntry );
        if (pRemUnk != NULL)
        {
            hr = CoQueryProxyBlanket( pRemUnk, pAuthnSvc, pAuthzSvc,
                                      pServerPrincName, pAuthnLevel,
                                      pImpLevel, pAuthInfo, pCapabilities );
        }
    }

    // Find the right IPID entry.
    else
    {
        hr = _pStdId->FindIPIDEntryByInterface( pProxy, &pIpid );
        UNLOCK(gIPIDLock);

        if (SUCCEEDED(hr))
        {
            // Disallow server entries.
            if (pIpid->dwFlags & IPIDF_SERVERENTRY)
                hr = E_INVALIDARG;

            // No security for disconnected proxies.
            else if (pIpid->dwFlags & IPIDF_DISCONNECTED)
                hr = RPC_E_DISCONNECTED;

            else
            {
                LOCK(gComLock);
                hr = QueryBlanketFromChannel(pIpid->pChnl, pAuthnSvc, pAuthzSvc,
                                              pServerPrincName, pAuthnLevel,
                                              pImpLevel, pAuthInfo, pCapabilities);
                UNLOCK(gComLock);
            }
        }

    }

    ASSERT_LOCK_NOT_HELD(gIPIDLock);
    return hr;
}
//+----------------------------------------------------------------------------
//
//  Function:      QueryBlanketFromChannel
//
//  Synopsis:      Helper function fills in security blanket given a channel
//                 object.
//
//  History:       6-Mar-98  MattSmit  Created
//
//-----------------------------------------------------------------------------

HRESULT QueryBlanketFromChannel(CRpcChannelBuffer       *pChnl,
                                DWORD                   *pAuthnSvc,
                                DWORD                   *pAuthzSvc,
                                OLECHAR                **pServerPrincName,
                                DWORD                   *pAuthnLevel,
                                DWORD                   *pImpLevel,
                                void                   **pAuthInfo,
                                DWORD                   *pCapabilities )
{
    ComDebOut((DEB_CHANNEL, "QueryBlanketFromChannel IN pChnl:0x%x, pAuthnSvc:0x%x, "
               "pAuthzSvc:0x%x, pServerPrincName:0x%x, pAuthnLevel:0x%x, pImpLevel:0x%x, "
               "pAuthInfo:0x%x, pCapabilities:0x%x\n", pChnl, pAuthnSvc, pAuthzSvc,
               pServerPrincName, pAuthnLevel, pImpLevel, pAuthInfo, pCapabilities));


    ASSERT_LOCK_HELD(gComLock);

    HRESULT hr;
    RPC_STATUS        sc;
    CChannelHandle   *pHandle;
    RPC_SECURITY_QOS  sQos;
    DWORD             iLen;
    OLECHAR          *pCopy;


    // If it is local, use the default values for everything but the
    // impersonation level.
    if (pChnl->ProcessLocal())
    {
        if (pImpLevel != NULL)
            *pImpLevel = pChnl->GetImpLevel();
          hr = S_OK;
    }

    // Otherwise ask RPC.
    else
    {
        // Get the binding handle to query.
        hr = pChnl->GetHandle( &pHandle, FALSE );

        if (SUCCEEDED(hr))
        {
            sc = RpcBindingInqAuthInfoExW( pHandle->_hRpc,
                                           pServerPrincName, pAuthnLevel,
                                           pAuthnSvc, pAuthInfo,
                                           pAuthzSvc,
                                           RPC_C_SECURITY_QOS_VERSION,
                                           &sQos );

            // It is not an error for a handle to have default
            // security.
            if (sc == RPC_S_BINDING_HAS_NO_AUTH)
            {
                // By default remote handles are unsecure
                if (!(pChnl->GetOXIDEntry()->IsOnLocalMachine()))
                {
                    if (pAuthnLevel != NULL)
                        *pAuthnLevel = RPC_C_AUTHN_LEVEL_NONE;
                    if (pAuthnSvc != NULL)
                        *pAuthnSvc = RPC_C_AUTHN_NONE;
                }
                if (pServerPrincName != NULL)
                    *pServerPrincName = NULL;
            }

            // RPC sometimes sets out parameters on error.
            else if (sc != RPC_S_OK)
            {
                if (pServerPrincName != NULL)
                    *pServerPrincName = NULL;
                hr = MAKE_SCODE( SEVERITY_ERROR, FACILITY_WIN32, sc );
            }
            else
            {
                // Return the impersonation level and capabilities.
                if (pImpLevel != NULL)
                    *pImpLevel = sQos.ImpersonationType;
                if (pCapabilities != NULL)
                {
                    if (sQos.Capabilities & RPC_C_QOS_CAPABILITIES_MUTUAL_AUTH)
                        *pCapabilities = EOAC_MUTUAL_AUTH;
                    if (sQos.IdentityTracking == RPC_C_QOS_IDENTITY_DYNAMIC)
                        *pCapabilities |= EOAC_DYNAMIC_CLOAKING;
                    if (pHandle->_eState & static_cloaking_hs)
                        *pCapabilities |= EOAC_STATIC_CLOAKING;
#if MANUAL_CERT_CHECK
                    if (sQos.Capabilities & RPC_C_QOS_CAPABILITIES_ANY_AUTHORITY)
                        *pCapabilities |= EOAC_ANY_AUTHORITY;
#endif // MANUAL_CERT_CHECK
                }

                // Reallocate the principal name using the OLE memory allocator.
                if (pServerPrincName != NULL && *pServerPrincName != NULL)
                {
                    iLen = lstrlenW( *pServerPrincName ) + 1;
                    pCopy = (OLECHAR *) CoTaskMemAlloc( iLen * sizeof(OLECHAR) );
                    if (pCopy != NULL)
                        memcpy( pCopy, *pServerPrincName, iLen*sizeof(USHORT) );
                    else
                        hr = E_OUTOFMEMORY;
                    RpcStringFree( pServerPrincName );
                    *pServerPrincName = pCopy;
                }

                // [Sergei O. Ivanov (sergei), 7/19/2000]
                // Retrieve certificate out of SChannel credential
                if ((pAuthnSvc) && (*pAuthnSvc == RPC_C_AUTHN_GSS_SCHANNEL))
                {
                    SCHANNEL_CRED *pCred = ((SCHANNEL_CRED*) *pAuthInfo);
                    *pAuthInfo = (void*) *(pCred->paCred);
                }
            }
            pHandle->Release();
        }
    }

    ASSERT_LOCK_HELD(gComLock);
    ComDebOut((DEB_CHANNEL, "QueryBlanketFromChannel OUT hr:0x%x\n", hr));
    return hr;
}




//+-------------------------------------------------------------------
//
//  Member:     CClientSecurity::SetBlanket, public
//
//  Synopsis:   Get the binding handle for a proxy.  Call RPC to set the
//              authentication information for that handle.
//
//--------------------------------------------------------------------
STDMETHODIMP CClientSecurity::SetBlanket(
                                IUnknown *pProxy,
                                DWORD     AuthnSvc,
                                DWORD     AuthzSvc,
                                OLECHAR  *pServerPrincName,
                                DWORD     AuthnLevel,
                                DWORD     ImpLevel,
                                void     *pAuthInfo,
                                DWORD     Capabilities )
{
    HRESULT           hr;
    IPIDEntry        *pIpid;
    IRemUnknown      *pRemUnk;
    IRemUnknown      *pSecureRemUnk = NULL;

    ASSERT_LOCK_NOT_HELD(gComLock);

    // IUnknown is special.  Set the security on IRemUnknown instead.
    if (_pStdId->GetCtrlUnk() == pProxy)
    {
        // Make sure the identity has its own copy of the OXID's
        // IRemUnknown.
        if (!_pStdId->CheckSecureRemUnk())
        {
            // This will get the remote unknown from the OXID.
            LOCK(gIPIDLock);
            pIpid = _pStdId->GetConnectedIPID();
            UNLOCK(gIPIDLock);
            hr = _pStdId->GetSecureRemUnk( &pRemUnk, pIpid->pOXIDEntry );

            if (SUCCEEDED(hr))
            {
                hr = CoCopyProxy( pRemUnk, (IUnknown **) &pSecureRemUnk );
                if (SUCCEEDED(hr))
                {
                    // Remote Unknown proxies are not supposed to ref count
                    // the OXID.

                    ULONG cRefs = pIpid->pOXIDEntry->DecRefCnt();
                    Win4Assert(cRefs != 0);

                    // Only keep the proxies if no one else made a copy
                    // while this thread was making a copy.

                    // CODEWORK: Make this an atomic operation on the stdid
                    // using interlockedcompare etc. to avod taking the lock.
                    LOCK(gComLock);
                    if (!_pStdId->CheckSecureRemUnk())
                    {
                        _pStdId->SetSecureRemUnk( pSecureRemUnk );
                        pSecureRemUnk = NULL;
                    }
                    UNLOCK(gComLock);

                    // Discard the newly created remunk if someone else
                    // created on.
                    if (pSecureRemUnk != NULL)
                    {
                        pSecureRemUnk->Release();
                    }
                    hr = _pStdId->GetSecureRemUnk( &pSecureRemUnk, NULL );
                }
            }
        }
        else
            hr = _pStdId->GetSecureRemUnk( &pSecureRemUnk, NULL );

        // Call SetBlanket on the copy of IRemUnknown.
        if (pSecureRemUnk != NULL)
            hr = CoSetProxyBlanket( pSecureRemUnk, AuthnSvc, AuthzSvc,
                                    pServerPrincName, AuthnLevel,
                                    ImpLevel, pAuthInfo, Capabilities );
    }

    else
    {
        // Find the right IPID entry.
        LOCK(gIPIDLock);
        hr = _pStdId->FindIPIDEntryByInterface( pProxy, &pIpid );
        UNLOCK(gIPIDLock);

        if (SUCCEEDED(hr))
        {
            // Disallow server entries.
            if (pIpid->dwFlags & IPIDF_SERVERENTRY)
                hr = E_INVALIDARG;

            // No security for disconnected proxies.
            else if (pIpid->dwFlags & IPIDF_DISCONNECTED)
                hr = RPC_E_DISCONNECTED;

            // Compute the real values for any default parameters.
            else
            {
                LOCK(gComLock);
                hr = SetBlanketOnChannel(pIpid->pChnl, AuthnSvc, AuthzSvc,
                                          pServerPrincName, AuthnLevel,
                                          ImpLevel, pAuthInfo, Capabilities);
                UNLOCK(gComLock);
            }
        }
    }

    ASSERT_LOCK_NOT_HELD(gComLock);
    return hr;
}


//+----------------------------------------------------------------------------
//
//  Function:      SetBlanketOnChannel
//
//  Synopsis:      Helper function to set the security blanket on a channel
//                 object.
//
//  History:       6-Mar-98  MattSmit  Created
//
//-----------------------------------------------------------------------------
HRESULT SetBlanketOnChannel(CRpcChannelBuffer *pChnl,
                             DWORD     AuthnSvc,
                             DWORD     AuthzSvc,
                             OLECHAR  *pServerPrincName,
                             DWORD     AuthnLevel,
                             DWORD     ImpLevel,
                             void     *pAuthInfo,
                             DWORD     Capabilities )
{
    ComDebOut((DEB_CHANNEL, "SetBlanketOnChannel IN pChnl:0x%x, AuthnSvc:0x%x, "
               "AuthzSvc:0x%x, pServerPrincName:0x%x, AuthnLevel:0x%x, ImpLevel:0x%x, "
               "pAuthInfo:0x%x, Capabilities:0x%x\n", pChnl, AuthnSvc, AuthzSvc,
               pServerPrincName, AuthnLevel, ImpLevel, pAuthInfo, Capabilities));
    ASSERT_LOCK_HELD(gComLock);

    SBlanket          sBlanket;
    HRESULT           hr;
    CChannelHandle   *pRpc          = NULL;
    RPC_STATUS        sc = RPC_S_OK;
    BOOL              fResume;
    HANDLE            hThread;
    DWORD             lSvcIndex;
    unsigned long     ulMarshaledTargetInfoLength = 0;
    unsigned char*    pMarshaledTargetInfo = NULL;
    WCHAR             *pTargetName = NULL;
#ifndef SSL
    // Don't allow SSL until the fixes are checked in.
    if (AuthnSvc == RPC_C_AUTHN_GSS_SCHANNEL)
        return MAKE_SCODE( SEVERITY_ERROR, FACILITY_WIN32, RPC_S_UNKNOWN_AUTHN_SERVICE );
#endif

#ifdef SSL
    // Sergei O. Ivanov (a-sergiv)  9/14/99  NTBUG #402305 and #402311
    // Validate authn/imp levels for SSL

    if(AuthnSvc == RPC_C_AUTHN_GSS_SCHANNEL)
    {
        if(AuthnLevel == RPC_C_AUTHN_LEVEL_NONE
           || ImpLevel == RPC_C_IMP_LEVEL_IDENTIFY
           || ImpLevel == RPC_C_IMP_LEVEL_DELEGATE
           || (ImpLevel == RPC_C_IMP_LEVEL_ANONYMOUS && pAuthInfo != NULL)
           )
        {
            // SSL does not support these authn/imp levels.
            return E_INVALIDARG;
        }
    }
#endif // SSL

    // Check the authentication service.
    if (AuthnSvc == RPC_C_AUTHN_DEFAULT)
        lSvcIndex = DefaultAuthnSvc( pChnl->GetOXIDEntry() );
    else
        lSvcIndex = GetAuthnSvcIndexForBinding( AuthnSvc, pChnl->GetOXIDEntry()->GetBinding() );
    // Compute all the other defaults.
    sBlanket._lAuthnLevel = AuthnLevel;
    hr = DefaultBlanket( lSvcIndex, pChnl->GetOXIDEntry(), &sBlanket );
    if(FAILED(hr)) return hr;

    if (AuthzSvc != RPC_C_AUTHZ_DEFAULT)
        sBlanket._lAuthzSvc = AuthzSvc;
    if (AuthnLevel != RPC_C_AUTHN_LEVEL_DEFAULT)
        sBlanket._lAuthnLevel = AuthnLevel;
    if (AuthnSvc != RPC_C_AUTHN_DEFAULT)
        sBlanket._lAuthnSvc = AuthnSvc;
    else if (sBlanket._lAuthnLevel != RPC_C_AUTHN_LEVEL_NONE &&
             sBlanket._lAuthnSvc == RPC_C_AUTHN_NONE)
        sBlanket._lAuthnSvc = RPC_C_AUTHN_WINNT;
    if (ImpLevel != RPC_C_IMP_LEVEL_DEFAULT)
        sBlanket._sQos.ImpersonationType = ImpLevel;
    else
    {
        // Verify that default imp level works with SSL.
        // Sergei O. Ivanov (a-sergiv)  9/21/99  NTBUG #403493

        if(sBlanket._lAuthnSvc == RPC_C_AUTHN_GSS_SCHANNEL
           && sBlanket._sQos.ImpersonationType != RPC_C_IMP_LEVEL_IMPERSONATE)
            return SEC_E_UNSUPPORTED_FUNCTION; // BUGBUG: CO_E_DEF_IMP_LEVEL_INCOMPAT (define this!)
    }
    if (pServerPrincName != COLE_DEFAULT_PRINCIPAL)
        sBlanket._pPrincipal = pServerPrincName;
    
    if (pAuthInfo != COLE_DEFAULT_AUTHINFO)
    {
        // Pass the certificate for SSL in a SCHANNEL_CRED structure which was
        // initialized by DefaultBlanket.
        if (sBlanket._lAuthnSvc == RPC_C_AUTHN_GSS_SCHANNEL)
        {
            sBlanket._pAuthId = (void *) &sBlanket._sCred;
            sBlanket._pCert = (PCCERT_CONTEXT) pAuthInfo;
        }
        else
            sBlanket._pAuthId = pAuthInfo;
    }
    else // pAuthInfo == COLE_DEFAULT_AUTHINFO
    {
        // When COLE_DEFAULT_AUTHINFO is specified with SSL user wants to use the default certificate
        if (sBlanket._lAuthnSvc == RPC_C_AUTHN_GSS_SCHANNEL)
        {
            sBlanket._pAuthId = (void *) &sBlanket._sCred;
            CSSL::DefaultCert(&sBlanket._pCert);
        }
    }
    
    if (Capabilities != EOAC_DEFAULT)
        sBlanket._lCapabilities = Capabilities;

    // Don't allow both cloaking and auth info.
    if (sBlanket._pAuthId != NULL &&
        (sBlanket._lCapabilities & ANY_CLOAKING) &&
        sBlanket._lAuthnSvc != RPC_C_AUTHN_GSS_NEGOTIATE)
        hr = E_INVALIDARG;

    // Don't allow both cloaking flags.
    else if ((sBlanket._lCapabilities & ANY_CLOAKING) == ANY_CLOAKING)
        hr = E_INVALIDARG;

    else if (pChnl->ProcessLocal())
    {
        // Local calls can use no authn service or winnt.
        if (sBlanket._lAuthnSvc != RPC_C_AUTHN_NONE &&
            sBlanket._lAuthnSvc != RPC_C_AUTHN_WINNT &&
            sBlanket._lAuthnSvc != RPC_C_AUTHN_DCE_PRIVATE)
            hr = E_INVALIDARG;

        // Make sure the authentication level is not invalid.
        else if ((sBlanket._lAuthnSvc == RPC_C_AUTHN_NONE &&
                  sBlanket._lAuthnLevel != RPC_C_AUTHN_LEVEL_NONE) ||
                 (sBlanket._lAuthnSvc == RPC_C_AUTHN_WINNT &&
                  sBlanket._lAuthnLevel > RPC_C_AUTHN_LEVEL_PKT_PRIVACY))
            hr = E_INVALIDARG;

        // No authorization services are supported locally.
        else if (sBlanket._lAuthzSvc != RPC_C_AUTHZ_NONE)
            hr = E_INVALIDARG;

        // You cannot supply credentials locally.
        else if (sBlanket._pAuthId != NULL)
            hr = E_INVALIDARG;

        // Range check the impersonation level.
        else if (sBlanket._sQos.ImpersonationType < RPC_C_IMP_LEVEL_ANONYMOUS ||
                 sBlanket._sQos.ImpersonationType > RPC_C_IMP_LEVEL_DELEGATE)
            hr = E_INVALIDARG;

                    // No capabilities are supported yet.
        else if (sBlanket._lCapabilities & ~VALID_BLANKET_FLAGS)
            hr = E_INVALIDARG;

        // Create a new handle object and discard the old one.
        else
        {
            // Create a new handle.
            pRpc = new CChannelHandle( sBlanket._lAuthnLevel,
                                       sBlanket._sQos.ImpersonationType,
                                       sBlanket._lCapabilities,
                                       pChnl->GetOXIDEntry(),
                                       pChnl->GetState() | app_security_cs,
                                       &hr );
            if (pRpc == NULL)
                hr = E_OUTOFMEMORY;
            else
            {
                // Replace the old one.
                if (SUCCEEDED(hr))
                    pChnl->ReplaceHandle( pRpc );
                pRpc->Release();
            }
        }
    }

    // If it is remote, tell RPC.
    else
    {
        // Validate the capabilities.
        if (sBlanket._lCapabilities & ~VALID_BLANKET_FLAGS)
            hr = E_INVALIDARG;
        else if ((sBlanket._lCapabilities & ANY_CLOAKING) &&
                 sBlanket._lAuthnSvc == RPC_C_AUTHN_GSS_SCHANNEL)
            hr = E_INVALIDARG;
        else
        {
            // Create a new handle.
            pRpc = new CChannelHandle( sBlanket._lAuthnLevel,
                                       sBlanket._sQos.ImpersonationType,
                                       sBlanket._lCapabilities,
                                       pChnl->GetOXIDEntry(),
                                       pChnl->GetState() | app_security_cs,
                                       &hr );
            if (pRpc == NULL)
                hr = E_OUTOFMEMORY;
            else if (FAILED(hr))
            {
                pRpc->Release();
                pRpc = NULL;
            }
        }

        if (SUCCEEDED(hr))
        {
            // Adjust the thread token to the one RPC needs to see.
            pRpc->AdjustToken( SET_BLANKET_AT, &fResume, &hThread );

            // Initialize the QOS structure.
            if (sBlanket._pPrincipal != NULL)
                sBlanket._sQos.Capabilities = RPC_C_QOS_CAPABILITIES_MUTUAL_AUTH;
            else
                sBlanket._sQos.Capabilities = RPC_C_QOS_CAPABILITIES_DEFAULT;
#ifdef MANUAL_CERT_CHECK
            if (sBlanket._lCapabilities & EOAC_ANY_AUTHORITY)
                sBlanket._sQos.Capabilities |= RPC_C_QOS_CAPABILITIES_ANY_AUTHORITY;
#endif
            if (sBlanket._lCapabilities & EOAC_DYNAMIC_CLOAKING)
                sBlanket._sQos.IdentityTracking   = RPC_C_QOS_IDENTITY_DYNAMIC;
            else
                sBlanket._sQos.IdentityTracking   = RPC_C_QOS_IDENTITY_STATIC;

            // RPC wants authentication service winnt for
            // unsecure same machine calls.
            if (sBlanket._lAuthnLevel == RPC_C_AUTHN_LEVEL_NONE &&
                sBlanket._lAuthnSvc   == RPC_C_AUTHN_NONE       &&
                (pRpc->_eState & machine_local_hs))
                sBlanket._lAuthnSvc = RPC_C_AUTHN_WINNT;

            // [Sergei O. Ivanov (sergei), 7/19/2000]
            // Store the credential inside CChannelHandle for SSL
            if(sBlanket._lAuthnSvc == RPC_C_AUTHN_GSS_SCHANNEL)
            {
                pRpc->_pCert = sBlanket._pCert;
                pRpc->_sCred = sBlanket._sCred;
                pRpc->_sCred.paCred = &pRpc->_pCert;

                if(pRpc->_pCert)
                {
                    pRpc->_sCred.cCreds = 1;  // there is a cert
                    sBlanket._pAuthId = (void *) &pRpc->_sCred;
                }
                else
                {
                    pRpc->_sCred.cCreds = 0;  // there is no cert
                    sBlanket._pAuthId = RPC_C_NO_CREDENTIALS;
                }

                
            }

            if (SUCCEEDED(hr))
            {
               pChnl->GetOXIDEntry()->GetMarshaledTargetInfo(&ulMarshaledTargetInfoLength, &pMarshaledTargetInfo);
               if (ulMarshaledTargetInfoLength && pMarshaledTargetInfo && sBlanket._pPrincipal)
               {
                  DWORD dwLen = lstrlenW(sBlanket._pPrincipal)*sizeof(WCHAR)+ ulMarshaledTargetInfoLength + sizeof(WCHAR);
                  pTargetName = (WCHAR *)MIDL_user_allocate(dwLen);
                  if (pTargetName) 
                  {
                     memset(pTargetName,0,dwLen);
                     memcpy(pTargetName,sBlanket._pPrincipal,lstrlenW(sBlanket._pPrincipal)*sizeof(WCHAR));
                     memcpy(pTargetName+lstrlenW(sBlanket._pPrincipal), pMarshaledTargetInfo, ulMarshaledTargetInfoLength);
                     sBlanket._pPrincipal = pTargetName;
                  }
                  else
                     hr = E_OUTOFMEMORY;
               }
               if (SUCCEEDED(hr))
               {
                  // Set the level on the handle.
                  sc = RpcBindingSetAuthInfoExW( pRpc->_hRpc,
                                              sBlanket._pPrincipal,
                                              sBlanket._lAuthnLevel,
                                              sBlanket._lAuthnSvc,
                                              sBlanket._pAuthId,
                                              sBlanket._lAuthzSvc,
                                              &sBlanket._sQos );
                  if (pTargetName) 
                  {
                     MIDL_user_free(pTargetName);
                  }
               }
               // Restore the thread token.
               pRpc->RestoreToken( fResume, hThread );
               
               if (SUCCEEDED(hr))
               {
                  if (sc != RPC_S_OK)
                     hr = MAKE_SCODE( SEVERITY_ERROR, FACILITY_WIN32, sc );
                  else
                     pChnl->ReplaceHandle( pRpc );
               }
            }
            pRpc->Release();
        }
    }

    ASSERT_LOCK_HELD(gComLock);
    ComDebOut((DEB_CHANNEL, "SetBlanketOnChannel OUT hr:0x%x\n", hr));
    return hr;

}
//+-------------------------------------------------------------------
//
//  Function:   CheckAccess
//
//  Synopsis:   Determine if the caller has permission to make a call.
//              If this function returns a result other then S_OK,
//              access will be denied.
//
//  Notes:      Convert all error codes to E_ACCESSDENIED since activation
//              tests, and applications expect security failures to return
//              it.
//
//--------------------------------------------------------------------
HRESULT CheckAccess( IPIDEntry *pIpid, CMessageCall *pCall )
{
    HRESULT result;
    DWORD   lAuthnLevel;
    BOOL    fAccess;
    IServerSecurity *pISS = NULL;

    ASSERT_LOCK_NOT_HELD(gComLock);

    // If process local always succeed (until we have real security
    // boundaries in COM Base). We short-circuit the inproc case as
    // quickly as possible.
    if (pCall && pCall->ProcessLocal())
        return S_OK;

    if(pIpid)
    {
        // Unsecure Callbacks feature requires us to bypass access check
        // for calls on CRemUnknown. CRemUnknown will perform its own
        // access check just before calling into the user object.
        //
        // REVIEW: Does it suffice to check for IRundown only?
        if(pIpid->iid == IID_IRundown)
            return S_OK;

        // Check the target context to see if it wants to allow unsecure calls.
        CPolicySet *pPS = pIpid->pChnl->GetStdId()->GetServerPolicySet();
        if (pPS && pPS->GetServerContext()->IsUnsecure())
            return S_OK;            // unsecure calls are allowed
    }

    result = CoGetCallContext(IID_IServerSecurity, (void**) &pISS);
    if(FAILED(result))
        return E_ACCESSDENIED;
    else
        result = S_OK;

    // Check authentication level.
    if (gAuthnLevel > RPC_C_AUTHN_LEVEL_NONE)
    {
        result = pISS->QueryBlanket( NULL, NULL, NULL, &lAuthnLevel, NULL,
                                     NULL, NULL );

        if (result != RPC_S_OK || lAuthnLevel < gAuthnLevel)
        {
            pISS->Release();
            return E_ACCESSDENIED;  // normal failure path for secure app
        }
    }

    pISS->Release();

    // If there is no ACL, allow access.
    if (gSecDesc == NULL && gAccessControl == NULL)
        return S_OK;

    // Check the ACL or IAccessControl.
    if (gSecDesc != NULL)
       result = CheckAcl();
    else
       result = CheckAccessControl();


    ASSERT_LOCK_NOT_HELD(gComLock);

    // Convert all error codes to E_ACCESSDENIED since activation
    // tests, and applications expect security failures to return
    // it.
    if (result != S_OK)
        return E_ACCESSDENIED;
    else
        return S_OK;
}
//+-------------------------------------------------------------------
//
//  Function:   CheckAccessControl
//
//  Synopsis:   Call the access control and ask it to check access.
//
//--------------------------------------------------------------------
HRESULT CheckAccessControl()
{
    HRESULT          hr;
    TRUSTEE_W        sTrustee;
    BOOL             fAccess = FALSE;
    COleTls          tls(hr);
#if DBG == 1
    char            *pFailure = "";
#endif

    sTrustee.ptstrName = NULL;
    if (FAILED(hr))
    {
#if DBG == 1
         pFailure = "Bad TLS: 0x%x\n";
#endif
    }

    else
    {
        if (SUCCEEDED(hr))
        {
            // Get the trustee name.
            hr = CoQueryClientBlanket( NULL, NULL, NULL, NULL, NULL,
                                       (void **) &sTrustee.ptstrName, NULL );

            if (hr == S_OK)
            {
                // Check access.
                sTrustee.pMultipleTrustee         = NULL;
                sTrustee.MultipleTrusteeOperation = NO_MULTIPLE_TRUSTEE;
                sTrustee.TrusteeForm              = TRUSTEE_IS_NAME;
                sTrustee.TrusteeType              = TRUSTEE_IS_USER;
                hr = gAccessControl->IsAccessAllowed( &sTrustee, NULL,
                                              COM_RIGHTS_EXECUTE, &fAccess );
#if DBG==1
                if (FAILED(hr))
                    pFailure = "IsAccessAllowed failed: 0x%x\n";
#endif
                if (SUCCEEDED(hr) && !fAccess)
                {
                    hr = E_ACCESSDENIED;
#if DBG==1
                    pFailure = "IAccessControl does not allow user access.\n";
#endif
                }
            }
#if DBG == 1
            else
                pFailure = "RpcBindingInqAuthClientW failed: 0x%x\n";
#endif
        }
    }

#if DBG==1
    if (hr != S_OK)
    {
        ComDebOut(( DEB_WARN, "***** ACCESS DENIED *****\n" ));
        ComDebOut(( DEB_WARN, pFailure, hr ));

        // Print the user name.
        if (sTrustee.ptstrName != NULL)
            ComDebOut(( DEB_WARN, "User: %ws\n", sTrustee.ptstrName ));
    }
#endif
    return hr;
}

//+-------------------------------------------------------------------
//
//  Function:   CheckAcl
//
//  Synopsis:   Impersonate and do an AccessCheck against the global ACL.
//
//--------------------------------------------------------------------
HRESULT CheckAcl()
{
    HRESULT          hr;
    BOOL             fAccess = FALSE;
    BOOL             fSuccess;
    DWORD            lGrantedAccess;
    DWORD            lSetLen = sizeof(gPriv);
    HANDLE           hToken;
    DWORD            i;
    TOKEN_STATISTICS sTokenStatistics;
    DWORD            lSize      = sizeof(sTokenStatistics);
#if DBG==1
    char            *pFailure   = "";
#endif

    hr = CoImpersonateClient();

    if (hr == S_OK)
    {
        // Open the thread token.
        fSuccess = OpenThreadToken( GetCurrentThread(), TOKEN_READ,
                                    TRUE, &hToken );

        // Remove the thread token so the GetTokenInformation succeeds.
        Verify( SetThreadToken( NULL, NULL ) );

        if (fSuccess)
        {
            // Get the SID and see if its cached.
            fSuccess = GetTokenInformation( hToken, TokenStatistics,
                                            &sTokenStatistics, lSize, &lSize );

            // Lookup the cached access results.
            if (fSuccess)
                fSuccess = CacheAccessCheck( sTokenStatistics.ModifiedId,
                                             &fAccess );

            // If there are any cached access results, use them.
            if (fSuccess)
            {
                if (!fAccess)
                {
                    hr = E_ACCESSDENIED;
#if DBG==1
                    pFailure = "Security descriptor does not allow user access.\n";
#endif
                }
            }

            // Access check.
            else
            {
                fSuccess = AccessCheck( gSecDesc, hToken, COM_RIGHTS_EXECUTE,
                                        &gMap, &gPriv, &lSetLen, &lGrantedAccess,
                                        &fAccess );
                if (fSuccess)
                    CacheAccess( sTokenStatistics.ModifiedId, fAccess );

                if (!fAccess)
                {
                    hr = E_ACCESSDENIED;
#if DBG==1
                    pFailure = "Security descriptor does not allow user access.\n";
#endif
                }
#if DBG==1
                if (!fSuccess)
                    pFailure = "Bad security descriptor\n";
#endif
            }
            CloseHandle( hToken );
        }
        else
        {
            hr = GetLastError();
#if DBG==1
            pFailure = "Could not open thread token: 0x%x\n";
#endif
        }

        // Revert.
        CoRevertToSelf();

    }
#if DBG==1
    else
        pFailure = "Could not impersonate client: 0x%x\n";
#endif

#if DBG==1
    if (hr != S_OK)
    {
        ComDebOut(( DEB_WARN, "***** ACCESS DENIED *****\n" ));
        ComDebOut(( DEB_WARN, pFailure, hr ));

        // Print the user name.
        WCHAR *pClient = NULL;
        CoQueryClientBlanket( NULL, NULL, NULL, NULL, NULL,
                              (void **) &pClient, NULL );
        if (pClient != NULL)
            ComDebOut(( DEB_WARN, "User: %ws\n", pClient ));
        ComDebOut(( DEB_WARN, "Security Descriptor 0x%x\n", gSecDesc ));
    }
#endif
    return hr;
}

//+-------------------------------------------------------------------
//
//  Function:   CheckObjactAccess, private
//
//  Synopsis:   Determine whether caller has permission to make call.
//
//  Notes: This function was created to special case security on
//         activation calls using dynamic delegation on NT 4.  In NT 5
//         security on dynamic delegation calls is handled automaticly
//         so the function does nothing.
//
//  Old Notes: Since ILocalSystemActivator uses dynamic delegation, we have to allow
//  all calls to ILocalSystemActivator through the normal security (which only
//  checks access on connect) and check them manually.
//
//--------------------------------------------------------------------
BOOL CheckObjactAccess()
{
    return TRUE;
}

//+-------------------------------------------------------------------
//
//  Function:   CoCopyProxy, public
//
//  Synopsis:   Copy a proxy.
//
//--------------------------------------------------------------------
WINOLEAPI CoCopyProxy(
    IUnknown    *pProxy,
    IUnknown   **ppCopy )
{
    HRESULT          hr;
    IClientSecurity *pickle;

    // Check the parameters.
    if (pProxy == NULL || ppCopy == NULL)
        return E_INVALIDARG;

    // Ask the proxy for IClientSecurity.
    hr = ((IUnknown *) pProxy)->QueryInterface( IID_IClientSecurity,
                                                (void **) &pickle );
    if (FAILED(hr))
        return hr;
    else if (pickle == NULL)
        return E_NOINTERFACE;

    // Ask IClientSecurity to do the copy.
    hr = pickle->CopyProxy( pProxy, ppCopy );
    pickle->Release();
    return hr;
}

//+-------------------------------------------------------------------
//
//  Function:   CoGetCallContext
//
//  Synopsis:   Get an interface that supplies contextual information
//              about the call.  Currently only IServerSecurity.
//
//--------------------------------------------------------------------
WINOLEAPI CoGetCallContext( REFIID riid, void **ppInterface )
{
    HRESULT hr;
    COleTls tls(hr);

    if (SUCCEEDED(hr))
    {
        if (ppInterface == NULL)
            return E_INVALIDARG;
        if (tls->pCallContext != NULL)
        {
            // Look up the requested interface.
            hr = tls->pCallContext->QueryInterface( riid, ppInterface );
        }
        else
        {
            // Fail if there is no call context.
            hr = RPC_E_CALL_COMPLETE;
        }

        // Only delegate to COM Services if COM Base failed the request and the
        // caller requested an interface unknown to us.
        if (FAILED(hr) && riid != IID_IServerSecurity)
        {
            // See if this is a request for the COM+ security call context
            static HRESULT (STDAPICALLTYPE *pfnCosGetCallContext)(REFIID, void**) = NULL;
            static HMODULE s_hComsvcsDll = NULL;
            if(pfnCosGetCallContext == NULL)
            {
                HMODULE hModule = GetModuleHandleW(L"comsvcs.dll");

                // Fail if the COM+ DLL isn't already loaded.
                if (hModule == NULL)
                    return hr;

                // Protect ourselves against comsvcs.dll going away out from 
                // underneath us.  We won't do this until we see it's already
                // loaded into the process (via GetModuleHandle above), but after
                // that we keep our own reference on the dll, for safety's sake.
                s_hComsvcsDll = LoadLibraryW(L"comsvcs.dll");
                if (s_hComsvcsDll == NULL)
                    return hr;
                
                pfnCosGetCallContext = (HRESULT (STDAPICALLTYPE *)(REFIID, void**))
                                       GetProcAddress(s_hComsvcsDll, "CosGetCallContext");

                // If the entry point isn't there, just return the original error.
                if (pfnCosGetCallContext == NULL)
                    return hr;
            }

            // Delegate the request to COM+ Services
            hr = (*pfnCosGetCallContext)(riid, ppInterface);
        }
    }
    return hr;
}

//+-------------------------------------------------------------------
//
//  Function:   CoImpersonateClient
//
//  Synopsis:   Get the server security for the current call and ask it
//              to do an impersonation.
//
//--------------------------------------------------------------------
WINOLEAPI CoImpersonateClient()
{
    HRESULT          hr;
    IServerSecurity *pSS;

    // Get the IServerSecurity.
    hr = CoGetCallContext( IID_IServerSecurity, (void **) &pSS );
    if (FAILED(hr))
        return hr;

    // Ask IServerSecurity to do the impersonate.
    hr = pSS->ImpersonateClient();
    pSS->Release();
    return hr;
}

//+-------------------------------------------------------------------
//
//  Function:   CoInitializeSecurity, public
//
//  Synopsis:   Set the values to use for automatic security.  This API
//              can only be called once so it does not need to be thread
//              safe.
//
//--------------------------------------------------------------------
WINOLEAPI CoInitializeSecurity(
                    PSECURITY_DESCRIPTOR              pVoid,
                    LONG                              cAuthSvc,
                    SOLE_AUTHENTICATION_SERVICE      *asAuthSvc,
                    void                             *pReserved1,
                    DWORD                             dwAuthnLevel,
                    DWORD                             dwImpLevel,
                    void                             *pReserved2,
                    DWORD                             dwCapabilities,
                    void                             *pReserved3 )
{
    HRESULT                      hr             = S_OK;
    DWORD                        i;
    SECURITY_DESCRIPTOR         *pSecDesc       = (SECURITY_DESCRIPTOR *) pVoid;
    SECURITY_DESCRIPTOR         *pCopySecDesc   = NULL;
    IAccessControl              *pAccessControl = NULL;
    BOOL                         fFreeSecDesc   = FALSE;
    SOLE_AUTHENTICATION_SERVICE  sAuthSvc;
    SOLE_AUTHENTICATION_LIST    *pAuthInfo      = (SOLE_AUTHENTICATION_LIST *) pReserved2;
    SOLE_AUTHENTICATION_LIST    *pCopyAuthInfo  = NULL;
    WCHAR                       *pPrincName     = NULL;
    DWORD                        lNameLen       = 1;
    SECURITYBINDING             *pSecBind;

    // Fail if OLE is not initialized or TLS cannot be allocated.
    if (!IsApartmentInitialized())
        return CO_E_NOTINITIALIZED;

    // Make sure the security data is available.
    if (!gGotSecurityData)
    {
        hr = gResolver.GetConnection();
        if (FAILED(hr))
            return hr;
        Win4Assert(gGotSecurityData);
    }

    // Make sure only one of the flags defining the pVoid parameter is set.
    if ((dwCapabilities & (EOAC_APPID | EOAC_ACCESS_CONTROL)) ==
        (EOAC_APPID | EOAC_ACCESS_CONTROL))
        return E_INVALIDARG;

    // Convert the default authentication level to connect.
    if (dwAuthnLevel == RPC_C_AUTHN_LEVEL_DEFAULT)
        dwAuthnLevel = RPC_C_AUTHN_LEVEL_CONNECT;

    // If the appid flag is set, read the registry security.
    if (dwCapabilities & EOAC_APPID)
    {
        if (pSecDesc != NULL && !IsValidPtrIn( pSecDesc, sizeof(UUID) ))
            return E_INVALIDARG;

        // Get a security blanket from the registry.
        hr = GetLegacyBlanket( &pSecDesc, &dwCapabilities, &dwAuthnLevel );
        if (FAILED(hr))
            return hr;
        fFreeSecDesc = TRUE;

        // Fix up the security binding.
        if (gLegacySecurity != NULL)
        {
            // Ignore errors since the principal name may not be used anyway.
            LookupPrincName( gLegacySecurity->wAuthnSvc, &pPrincName );
            cAuthSvc                = 1;
            asAuthSvc               = &sAuthSvc;
            sAuthSvc.dwAuthnSvc     = gLegacySecurity->wAuthnSvc;
            sAuthSvc.dwAuthzSvc     = gLegacySecurity->wAuthzSvc;
            sAuthSvc.pPrincipalName = pPrincName;
            if (sAuthSvc.dwAuthzSvc == COM_C_AUTHZ_NONE)
                sAuthSvc.dwAuthzSvc = RPC_C_AUTHZ_NONE;
        }
        else
            cAuthSvc = 0xFFFFFFFF;

        // Initialize remaining parameters.
        pReserved1      = NULL;
        dwImpLevel      = gImpLevel;
        pAuthInfo       = NULL;
        pReserved3      = NULL;
        dwCapabilities |= gCapabilities;
    }

    // Fail if called too late, recalled, or called with bad parameters.
    if (dwImpLevel > RPC_C_IMP_LEVEL_DELEGATE        ||
        dwImpLevel < RPC_C_IMP_LEVEL_ANONYMOUS       ||
        dwAuthnLevel > RPC_C_AUTHN_LEVEL_PKT_PRIVACY ||
        pReserved1 != NULL                           ||
        pReserved3 != NULL                           ||
        (dwCapabilities & ~VALID_INIT_FLAGS)         ||
        (dwCapabilities & ANY_CLOAKING) == ANY_CLOAKING
        )
    {
        hr = E_INVALIDARG;
        goto Error;
    }
    if (dwAuthnLevel == RPC_C_AUTHN_LEVEL_NONE)
    {
        if (dwCapabilities & EOAC_SECURE_REFS)
        {
            hr = E_INVALIDARG;
            goto Error;
        }
    }
    else if (cAuthSvc == 0)
    {
        hr = E_INVALIDARG;
        goto Error;
    }

    // Validate the pointers.
    if (pSecDesc != NULL)
        if (dwCapabilities & EOAC_ACCESS_CONTROL)
        {
            if (!IsValidPtrIn( pSecDesc, 4 ))
            {
                hr = E_INVALIDARG;
                goto Error;
            }
        }
        else if (!IsValidPtrIn( pSecDesc, sizeof(SECURITY_DESCRIPTOR) ))
        {
            hr = E_INVALIDARG;
            goto Error;
        }
    if (cAuthSvc != 0 && cAuthSvc != -1 &&
        !IsValidPtrOut( asAuthSvc, sizeof(SOLE_AUTHENTICATION_SERVICE) * cAuthSvc ))
    {
        hr = E_INVALIDARG;
        goto Error;
    }

    // Copy and validate the auth info.
    hr = CAuthInfo::Copy( pAuthInfo, &pCopyAuthInfo, dwCapabilities );
    if (FAILED(hr))
        goto Error;

#ifdef SSL
    // Sergei O. Ivanov, 8/16/99  We will lookup SSL certificate
    // only when RPC_C_AUTHN_GSS_SCHANNEL is explicitly specified.

    if(asAuthSvc)
    {
        for(LONG i=0;i<cAuthSvc;i++)
        {
            if(asAuthSvc[i].dwAuthnSvc == RPC_C_AUTHN_GSS_SCHANNEL)
            {
                // [Sergei O. Ivanov (sergei) 8/8/2000]
                // SSL does not support cloaking so we shall fail if cloaking is requested

                if(dwCapabilities & ANY_CLOAKING)
                {
                    hr = E_INVALIDARG;
                    goto Error;
                }

                // Just compute the default cert before taking the lock for now.
                // If SSL ends up working, fix this later.  This is not thread
                // safe and a waste of work if SSL isn't used.

                const CERT_CONTEXT *pCert;
                CSSL::DefaultCert( &pCert ); // ignore hr for now

                break;
            }
        }
    }
#endif

    LOCK(gComLock);

    if (gpsaSecurity != NULL)
        hr = RPC_E_TOO_LATE;

    if (SUCCEEDED(hr))
    {
        // If the app doesn't want security, don't set up a security
        // descriptor.
        if (dwAuthnLevel == RPC_C_AUTHN_LEVEL_NONE)
        {
            // Check for some more invalid parameters.
            if (pSecDesc != NULL && (dwCapabilities & EOAC_APPID) == 0)
                hr = E_INVALIDARG;
        }

        // Check whether security is done with ACLs or IAccessControl.
        else if (dwCapabilities & EOAC_ACCESS_CONTROL)
        {
            if (pSecDesc == NULL)
                hr = E_INVALIDARG;
            else
                hr = ((IUnknown *) pSecDesc)->QueryInterface(
                            IID_IAccessControl, (void **) &pAccessControl );
        }

        else
        {
            // If specified, copy the security descriptor.
            if (pSecDesc != NULL)
                hr = CopySecDesc( pSecDesc, &pCopySecDesc );
        }
    }

    if (SUCCEEDED(hr))
    {
        // Delay the registration of authentication services if the caller
        // isn't picky.
        if (cAuthSvc == -1)
        {
            hr = LookupPrincName( RPC_C_AUTHN_WINNT, &pPrincName );
            if (SUCCEEDED(hr))
            {
                lNameLen = lstrlenW( pPrincName );

                gpsaSecurity = (DUALSTRINGARRAY *)
                               PrivMemAlloc( SASIZE(lNameLen + 6) );
                if (gpsaSecurity != NULL)
                {
                    gpsaSecurity->wNumEntries     = (USHORT) lNameLen + 6;
                    gpsaSecurity->wSecurityOffset = 2;
                    gpsaSecurity->aStringArray[0] = 0;
                    gpsaSecurity->aStringArray[1] = 0;
                    pSecBind = (SECURITYBINDING *) &gpsaSecurity->aStringArray[2];
                    pSecBind->wAuthnSvc = RPC_C_AUTHN_WINNT;
                    pSecBind->wAuthzSvc = COM_C_AUTHZ_NONE;
                    memcpy( &pSecBind->aPrincName, pPrincName,
                            (lNameLen+1) * sizeof(WCHAR) );
                    gpsaSecurity->aStringArray[lNameLen+5] = 0;
                    gDefaultService                        = TRUE;
                }
                else
                    hr = E_OUTOFMEMORY;
            }
            else
            {
                gpsaSecurity = (DUALSTRINGARRAY *) PrivMemAlloc( SASIZE(4) );
                if (gpsaSecurity != NULL)
                {
                    gpsaSecurity->wNumEntries     = 4;
                    gpsaSecurity->wSecurityOffset = 2;
                    memset( gpsaSecurity->aStringArray, 0, 4*sizeof(WCHAR) );
                    gDefaultService               = TRUE;
                    hr = S_OK;
                }
                else
                    hr = E_OUTOFMEMORY;
            }
        }

        // Create an empty security binding if the caller wants no
        // security.
        else if (cAuthSvc == 0)
        {
            gpsaSecurity = (DUALSTRINGARRAY *) PrivMemAlloc( SASIZE(4) );
            if (gpsaSecurity != NULL)
            {
                gpsaSecurity->wNumEntries     = 4;
                gpsaSecurity->wSecurityOffset = 2;
                memset( gpsaSecurity->aStringArray, 0, 4*sizeof(WCHAR) );
            }
            else
                hr = E_OUTOFMEMORY;
        }

        // Otherwise, register the ones the caller specified.
        else
        {
            // Sergei O. Ivanov (a-sergiv)  10/07/99
            // RegisterAuthnServices may need to look at dwCapabilities
            // when registering authentication services. It does for SSL.
            //
            // It is quite OK to do this since we're holding gComLock.

            DWORD dwSavedCapabilities = gCapabilities;
            gCapabilities = dwCapabilities;

            hr = RegisterAuthnServices( cAuthSvc, asAuthSvc );

            gCapabilities = dwSavedCapabilities;
        }
    }

    // If everything succeeded, change the globals.
    if (SUCCEEDED(hr))
    {
        // Save the defaults.
        gAuthnLevel    = dwAuthnLevel;
        gImpLevel      = dwImpLevel;
        gCapabilities  = dwCapabilities;
        gSecDesc       = pCopySecDesc;
        gAccessControl = pAccessControl;
        CAuthInfo::Set( pCopyAuthInfo );

        // If cloaking was specified, remove SSL from the client service list.
        if (dwCapabilities & ANY_CLOAKING)
        {
            for (i = 0; i < gClientSvcListLen; i++)
                if (gClientSvcList[i].wId == RPC_C_AUTHN_GSS_SCHANNEL)
                {
                    gClientSvcListLen -= 1;
                    if (i < gClientSvcListLen)
                        memcpy( &gClientSvcList[i], &gClientSvcList[i+1],
                                (gClientSvcListLen - i)*sizeof(SECPKG) );
                    break;
                }
        }

        CoVrfCheckSecuritySettings();
    }
    UNLOCK(gComLock);

    // If anything was allocated for app id security, free it.
Error:
    if (fFreeSecDesc && pSecDesc != NULL)
        if (dwCapabilities & EOAC_ACCESS_CONTROL)
            ((IAccessControl *) pSecDesc)->Release();
        else
            PrivMemFree( pSecDesc );

    PrivMemFree( pPrincName );

    // If there was an error, free any memory allocated.
    if (FAILED(hr))
    {
        PrivMemFree( pCopySecDesc );
        PrivMemFree( pCopyAuthInfo );
    }
    return hr;
}

//+-------------------------------------------------------------------
//
//  Function:   CopySecDesc
//
//  Synopsis:   Copy a security descriptor.
//
//  Notes: The function does not copy the SACL because we do not do
//  auditing.
//
//--------------------------------------------------------------------
HRESULT CopySecDesc( SECURITY_DESCRIPTOR *pOrig, SECURITY_DESCRIPTOR **pCopy )
{
    SID   *pOwner;
    SID   *pGroup;
    ACL   *pDacl;
    ULONG  cSize;
    ULONG  cOwner;
    ULONG  cGroup;
    ULONG  cDacl;

    // Assert if there is a new revision for the security descriptor or
    // ACL.
#if DBG== 1
    if (pOrig->Revision != SECURITY_DESCRIPTOR_REVISION)
        ComDebOut(( DEB_ERROR, "Someone made a new security descriptor revision without telling me." ));
    if (!(pOrig->Control & SE_SELF_RELATIVE) && pOrig->Dacl != NULL)
        Win4Assert( pOrig->Dacl->AclRevision <= ACL_REVISION4 ||
                    !"Someone made a new acl revision without telling me." );
#endif

    // Validate the security descriptor and ACL.
    if (pOrig->Revision != SECURITY_DESCRIPTOR_REVISION ||
        (pOrig->Control & SE_SELF_RELATIVE) != 0        ||
        pOrig->Owner == NULL                            ||
        pOrig->Group == NULL                            ||
        pOrig->Sacl != NULL                             ||
        (pOrig->Dacl != NULL && pOrig->Dacl->AclRevision > ACL_REVISION4))
        return E_INVALIDARG;

    // Figure out how much memory to allocate for the copy and allocate it.
    cOwner = GetLengthSid( pOrig->Owner );
    cGroup = GetLengthSid( pOrig->Group );
    cDacl  = pOrig->Dacl == NULL ? 0 : pOrig->Dacl->AclSize;
    cSize = sizeof(SECURITY_DESCRIPTOR) + cOwner + cGroup + cDacl;
    *pCopy = (SECURITY_DESCRIPTOR *) PrivMemAlloc( cSize );
    if (*pCopy == NULL)
        return E_OUTOFMEMORY;

    // Get pointers to each of the parts of the security descriptor.
    pOwner = (SID *) (*pCopy + 1);
    pGroup = (SID *) (((char *) pOwner) + cOwner);
    if (pOrig->Dacl != NULL)
        pDacl = (ACL *) (((char *) pGroup) + cGroup);
    else
        pDacl = NULL;

    // Copy each piece.
   **pCopy = *pOrig;
   memcpy( pOwner, pOrig->Owner, cOwner );
   memcpy( pGroup, pOrig->Group, cGroup );
   if (pDacl != NULL)
       memcpy( pDacl, pOrig->Dacl, pOrig->Dacl->AclSize );
   (*pCopy)->Owner = pOwner;
   (*pCopy)->Group = pGroup;
   (*pCopy)->Dacl  = pDacl;
   (*pCopy)->Sacl  = NULL;

    // Check the security descriptor.
#if DBG==1
    if (!IsValidSecurityDescriptor( *pCopy ))
    {
        Win4Assert( !"COM Created invalid security descriptor." );
        return GetLastError();
    }
#endif
   return S_OK;
}

//+-------------------------------------------------------------------
//
//  Function:   CoQueryAuthenticationServices, public
//
//  Synopsis:   Return a list of the registered authentication services.
//
//--------------------------------------------------------------------
WINOLEAPI CoQueryAuthenticationServices( DWORD *pcAuthSvc,
                                      SOLE_AUTHENTICATION_SERVICE **asAuthSvc )
{
    DWORD      i;
    DWORD      lNum = 0;
    WCHAR     *pNext;
    HRESULT    hr   = S_OK;

    // Validate the parameters.
    if (asAuthSvc == NULL)
        return E_INVALIDARG;

    ASSERT_LOCK_NOT_HELD(gComLock);
    LOCK(gComLock);

    // Count the number of services in the security string array.
    if (gpsaSecurity != NULL)
    {
        pNext = (PWCHAR)&gpsaSecurity->aStringArray[gpsaSecurity->wSecurityOffset];
        while (*pNext != 0)
        {
            lNum++;
            pNext += lstrlenW(pNext)+1;
        }
    }

    // Return nothing if there are no authentication services.
    *pcAuthSvc = lNum;
    if (lNum == 0)
    {
        *asAuthSvc  = NULL;
        goto exit;
    }

    // Allocate a list of pointers.
    *asAuthSvc = (SOLE_AUTHENTICATION_SERVICE *)
                   CoTaskMemAlloc( lNum * sizeof(SOLE_AUTHENTICATION_SERVICE) );
    if (*asAuthSvc == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }

    // Initialize it.
    for (i = 0; i < lNum; i++)
        (*asAuthSvc)[i].pPrincipalName = NULL;

    // Fill in one SOLE_AUTHENTICATION_SERVICE record per service
    pNext = (PWCHAR)&gpsaSecurity->aStringArray[gpsaSecurity->wSecurityOffset];
    for (i = 0; i < lNum; i++)
    {
        (*asAuthSvc)[i].dwAuthnSvc = *(pNext++);
        (*asAuthSvc)[i].hr         = S_OK;
        if (*pNext == COM_C_AUTHZ_NONE)
        {
            (*asAuthSvc)[i].dwAuthzSvc = RPC_C_AUTHZ_NONE;
            pNext += 1;
        }
        else
            (*asAuthSvc)[i].dwAuthzSvc = *(pNext++);

        // Allocate memory for the principal name string.
        (*asAuthSvc)[i].pPrincipalName = (OLECHAR *)
          CoTaskMemAlloc( (lstrlenW(pNext)+1)*sizeof(OLECHAR) );
        if ((*asAuthSvc)[i].pPrincipalName == NULL)
        {
            hr = E_OUTOFMEMORY;
            break;
        }

        lstrcpyW( (*asAuthSvc)[i].pPrincipalName, pNext );
        pNext += lstrlenW(pNext) + 1;
    }

    // Clean up if there wasn't enough memory.
    if (FAILED(hr))
    {
        for (i = 0; i < lNum; i++)
            CoTaskMemFree( (*asAuthSvc)[i].pPrincipalName );
        CoTaskMemFree( *asAuthSvc );
        *asAuthSvc  = NULL;
        *pcAuthSvc = 0;
    }

exit:
    UNLOCK(gComLock);
    ASSERT_LOCK_NOT_HELD(gComLock);
    return hr;
}

//+-------------------------------------------------------------------
//
//  Function:   CoQueryClientBlanket
//
//  Synopsis:   Get the authentication settings the client used to call
//              the server.
//
//--------------------------------------------------------------------
WINOLEAPI CoQueryClientBlanket(
    DWORD             *pAuthnSvc,
    DWORD             *pAuthzSvc,
    OLECHAR          **pServerPrincName,
    DWORD             *pAuthnLevel,
    DWORD             *pImpLevel,
    RPC_AUTHZ_HANDLE  *pPrivs,
    DWORD             *pCapabilities )
{
    HRESULT          hr;
    IServerSecurity *pSS;

    // Get the IServerSecurity.
    hr = CoGetCallContext( IID_IServerSecurity, (void **) &pSS );
    if (FAILED(hr))
        return hr;

    // Ask IServerSecurity to do the query.
    hr = pSS->QueryBlanket( pAuthnSvc, pAuthzSvc, pServerPrincName,
                            pAuthnLevel, pImpLevel, pPrivs, pCapabilities );

    pSS->Release();
    return hr;
}

//+-------------------------------------------------------------------
//
//  Function:   CoQueryProxyBlanket, public
//
//  Synopsis:   Get the authentication settings from a proxy.
//
//--------------------------------------------------------------------
WINOLEAPI CoQueryProxyBlanket(
    IUnknown                  *pProxy,
    DWORD                     *pAuthnSvc,
    DWORD                     *pAuthzSvc,
    OLECHAR                  **pServerPrincName,
    DWORD                     *pAuthnLevel,
    DWORD                     *pImpLevel,
    RPC_AUTH_IDENTITY_HANDLE  *pAuthInfo,
    DWORD                     *pCapabilities )
{
    HRESULT          hr;
    IClientSecurity *pickle;

    // Ask the proxy for IClientSecurity.
    if (pProxy == NULL)
        return E_INVALIDARG;
    hr = ((IUnknown *) pProxy)->QueryInterface( IID_IClientSecurity,
                                                (void **) &pickle );
    if (FAILED(hr))
        return hr;
    else if (pickle == NULL)
        return E_NOINTERFACE;

    // Ask IClientSecurity to do the query.
    hr = pickle->QueryBlanket( pProxy, pAuthnSvc, pAuthzSvc, pServerPrincName,
                               pAuthnLevel, pImpLevel, pAuthInfo,
                               pCapabilities );
    pickle->Release();
    return hr;
}

//+-------------------------------------------------------------------
//
//  Function:   CoRevertToSelf
//
//  Synopsis:   Get the server security for the current call and ask it
//              to revert.
//
//--------------------------------------------------------------------
WINOLEAPI CoRevertToSelf()
{
    HRESULT          hr;
    IServerSecurity *pSS;

    // Get the IServerSecurity.
    hr = CoGetCallContext( IID_IServerSecurity, (void **) &pSS );
    if (FAILED(hr))
        return hr;

    // Ask IServerSecurity to do the revert.
    hr = pSS->RevertToSelf();
    pSS->Release();
    return hr;
}

//+-------------------------------------------------------------------
//
//  Function:   CoSetProxyBlanket, public
//
//  Synopsis:   Set the authentication settings for a proxy.
//
//--------------------------------------------------------------------
WINOLEAPI CoSetProxyBlanket(
    IUnknown                 *pProxy,
    DWORD                     dwAuthnSvc,
    DWORD                     dwAuthzSvc,
    OLECHAR                  *pServerPrincName,
    DWORD                     dwAuthnLevel,
    DWORD                     dwImpLevel,
    RPC_AUTH_IDENTITY_HANDLE  pAuthInfo,
    DWORD                     dwCapabilities )
{
    HRESULT          hr;
    IClientSecurity *pickle;

    // Ask the proxy for IClientSecurity.
    if (pProxy == NULL)
        return E_INVALIDARG;
    hr = ((IUnknown *) pProxy)->QueryInterface( IID_IClientSecurity,
                                                (void **) &pickle );
    if (FAILED(hr))
        return hr;
    else if (pickle == NULL)
        return E_NOINTERFACE;

    // Ask IClientSecurity to do the set.
    hr = pickle->SetBlanket( pProxy, dwAuthnSvc, dwAuthzSvc, pServerPrincName,
                             dwAuthnLevel, dwImpLevel, pAuthInfo,
                             dwCapabilities );
    pickle->Release();
    return hr;
}

//+-------------------------------------------------------------------
//
//  Function:   CoSwitchCallContext
//
//  Synopsis:   Replace the call context object in TLS.  Return the old
//              context object.  This API is used by custom marshallers
//              to support security.
//
//--------------------------------------------------------------------
WINOLEAPI CoSwitchCallContext( IUnknown *pNewObject, IUnknown **ppOldObject )
{
    HRESULT hr;
    COleTls tls(hr);

    if (SUCCEEDED(hr))
    {
        *ppOldObject      = tls->pCallContext;
        tls->pCallContext = pNewObject;
    }
    return hr;
}

//+-------------------------------------------------------------------
//
//  Member:     CServerSecurity::AddRef, public
//
//  Synopsis:   Adds a reference to an interface
//
//--------------------------------------------------------------------
STDMETHODIMP_(ULONG) CServerSecurity::AddRef()
{
    return InterlockedIncrement( (long *) &_iRefCount );
}

//+-------------------------------------------------------------------
//
//  Function:   CServerSecurity::Initialize
//
//  Synopsis:   Initialize the authentication list.
//
//--------------------------------------------------------------------
/* static */
void CServerSecurity::Initialize()
{
    ASSERT_LOCK_NOT_HELD(_mxs);
    LOCK(_mxs);

    _palloc.Initialize(sizeof(CServerSecurity), SS_PER_PAGE, &_mxs);

    UNLOCK(_mxs);
    ASSERT_LOCK_NOT_HELD(_mxs);
}

//---------------------------------------------------------------------------
//
//  Method:     CServerSecurity::Cleanup
//
//  Synopsis:   Free all elements in the cache.
//
//---------------------------------------------------------------------------
/* static */
void CServerSecurity::Cleanup()
{
    ASSERT_LOCK_NOT_HELD(_mxs);
    LOCK(_mxs);

    _palloc.Cleanup();

    UNLOCK(_mxs);
    ASSERT_LOCK_NOT_HELD(_mxs);
}

//+-------------------------------------------------------------------
//
//  Member:     CServerSecurity::CServerSecurity, public
//
//  Synopsis:   Construct a server security for a call.
//
//--------------------------------------------------------------------
CServerSecurity::CServerSecurity( CMessageCall *call, handle_t hRpc,
                                  HRESULT *hr )
{
    *hr        = S_OK;
    _iRefCount = 1;
    _pHandle   = call->_pHandle;
    _hRpc      = hRpc;

    if (call->ProcessLocal())
    {
        _iFlags      = SS_PROCESS_LOCAL;
        _pClientCall = call;
    }
    else
    {
        _iFlags      = 0;
        _pClientCall = NULL;
    }

    // Handle impersonation.
    *hr = SetupSecurity();
}

//+-------------------------------------------------------------------
//
//  Member:     CServerSecurity::SetupSecurity, public
//
//  Synopsis:   Auto impersonates if necessary
//
//--------------------------------------------------------------------
HRESULT CServerSecurity::SetupSecurity()
{
    COleTls         tls;

    // Save the impersonation data for the previous call on this thread.
    if (tls->dwFlags & OLETLS_IMPERSONATING)
    {
        _iFlags      |= SS_WAS_IMPERSONATING;
        _hSaved       = tls->hRevert;
        tls->hRevert  = NULL;
        tls->dwFlags &= ~OLETLS_IMPERSONATING;
    }
    else
        _hSaved = NULL;

    return S_OK;
}

//+-------------------------------------------------------------------
//
//  Member:     CServerSecurity::RestoreSecurity, public
//
//  Synopsis:   Clears the stored binding handle because the call
//              this object represents is over.
//
//  Note:       When async finish completes, RPC destroys the binding
//              handle _hRpc even if async begin has not completed.
//
//--------------------------------------------------------------------
void CServerSecurity::RestoreSecurity( BOOL fCallDone )
{
    // Revert if the app forgot to.
    RevertToSelf();
    if (fCallDone)
    {
        _iFlags |= SS_CALL_DONE;
        _pHandle = NULL;
        _hRpc    = NULL;
    }

    // Restore the impersonation data for the previous call on this thread.
    if (_iFlags & SS_WAS_IMPERSONATING)
    {
        COleTls tls;
        tls->dwFlags |= OLETLS_IMPERSONATING;
        Win4Assert( tls->hRevert == NULL );
        tls->hRevert  = _hSaved;
        _hSaved       = NULL;
        _iFlags      &= ~SS_WAS_IMPERSONATING;
    }
}

//+-------------------------------------------------------------------
//
//  Member:     CServerSecurity::ImpersonateClient, public
//
//  Synopsis:   Calls RPC to impersonate for the stored binding handle.
//
//--------------------------------------------------------------------
STDMETHODIMP CServerSecurity::ImpersonateClient()
{
    HRESULT    hr;
    RPC_STATUS sc;
    BOOL       fSuccess;
    HANDLE     hProcess;
    HANDLE     hToken;
    HANDLE     hThread;
    SECURITY_IMPERSONATION_LEVEL eDuplicate;
    COleTls    tls(hr);

    // If TLS could not be created, fail.
    if (FAILED(hr))
        return hr;

    // If the call is over, fail this request.
    if (_iFlags & SS_CALL_DONE)
        return RPC_E_CALL_COMPLETE;

    // If this is the first impersonation on this thread, save the
    // current thread token.  Ignore errors.
    if ((tls->dwFlags & OLETLS_IMPERSONATING) == 0)
        OpenThreadToken( GetCurrentThread(), TOKEN_IMPERSONATE, TRUE,
                         &tls->hRevert );

    // For process local calls, ask the channel to impersonate.
    if (_iFlags & SS_PROCESS_LOCAL)
    {

        // A NULL token means the client wasn't cloaking, use the process
        // token.
        if (_pHandle->_hToken == NULL)
        {
            // Determine what rights to duplicate the token with.
            eDuplicate = ImpLevelToSecLevel[_pHandle->_lImp];

            // If there is a thread token it can cause the Open or Duplicate
            // to fail or create a bad token.
            SuspendImpersonate( &hThread );

            // If the channel doesn't have a token, use the process token.
            if (OpenProcessToken( GetCurrentProcess(),
                                  TOKEN_DUPLICATE,
                                  &hProcess ))
            {
                if (DuplicateToken( hProcess, eDuplicate, &hToken ))
                {
                    if (!SetThreadToken( NULL, hToken ))
                        hr = MAKE_SCODE( SEVERITY_ERROR, FACILITY_WIN32, GetLastError() );

                    // If the channel still doesn't have a token, save this one.
                    LOCK(gComLock);
                    if (_pHandle->_hToken == NULL)
                        _pHandle->_hToken = hToken;
                    else
                        CloseHandle( hToken );
                    UNLOCK(gComLock);
                }
                else
                    hr = MAKE_SCODE( SEVERITY_ERROR, FACILITY_WIN32, GetLastError() );
                CloseHandle( hProcess );
            }
            else
                hr = MAKE_SCODE( SEVERITY_ERROR, FACILITY_WIN32, GetLastError() );

            // Restore the thread token.
            if (hThread != NULL)
            {
                if (FAILED(hr))
                    Verify( SetThreadToken( NULL, hThread ) );
                CloseHandle( hThread );
            }
        }
        else
        {
            fSuccess = SetThreadToken( NULL, _pHandle->_hToken );
            if (!fSuccess)
                hr = MAKE_SCODE( SEVERITY_ERROR, FACILITY_WIN32, GetLastError() );
        }
    }

    // For process remote calls, ask RPC to impersonate.
    else
    {
        sc = RpcImpersonateClient( _hRpc );
        if (sc != RPC_S_OK)
            hr = MAKE_SCODE( SEVERITY_ERROR, FACILITY_WIN32, sc );
    }

    // If successful, set the impersonating flag in TLS.
    if (SUCCEEDED(hr))
        tls->dwFlags |= OLETLS_IMPERSONATING;

    // If the impersonate failed and the start of this function saved a
    // token, release it.
    else if ((tls->dwFlags & OLETLS_IMPERSONATING) == 0 && tls->hRevert != NULL)
    {
        CloseHandle( tls->hRevert );
        tls->hRevert = NULL;
    }
    return hr;
}

//+-------------------------------------------------------------------
//
//  Member:     CServerSecurity::IsImpersonating, public
//
//  Synopsis:   Return TRUE if ImpersonateClient has been called.
//
//--------------------------------------------------------------------
STDMETHODIMP_(BOOL) CServerSecurity::IsImpersonating()
{
    HRESULT hr;
    COleTls tls(hr);
    if (SUCCEEDED(hr))
        return (tls->dwFlags & OLETLS_IMPERSONATING) ? TRUE : FALSE;
    else
        return FALSE;
}

//---------------------------------------------------------------------------
//
//  Method:     CServerSecurity::operator delete
//
//  Synopsis:   Cache or actually free a server security object.
//
//---------------------------------------------------------------------------
void CServerSecurity::operator delete( void *pSS )
{
    _palloc.ReleaseEntry((PageEntry *)pSS);
}

//---------------------------------------------------------------------------
//
//  Method:     CServerSecurity::operator new
//
//  Synopsis:   Keep a cache of CServerSecuritys.
//
//---------------------------------------------------------------------------
void *CServerSecurity::operator new( size_t size )
{
    Win4Assert(size == sizeof(CServerSecurity));
    return _palloc.AllocEntry();
}

//+-------------------------------------------------------------------
//
//  Member:     CServerSecurity::QueryBlanket, public
//
//  Synopsis:   Calls RPC to return the authentication information
//              for the stored binding handle.
//
//--------------------------------------------------------------------
STDMETHODIMP CServerSecurity::QueryBlanket(
                                            DWORD    *pAuthnSvc,
                                            DWORD    *pAuthzSvc,
                                            OLECHAR **pServerPrincName,
                                            DWORD    *pAuthnLevel,
                                            DWORD    *pImpLevel,
                                            void    **pPrivs,
                                            DWORD    *pCapabilities )
{
    HRESULT    hr = S_OK;
    RPC_STATUS sc;
    DWORD      iLen;
    OLECHAR   *pCopy;

    // Initialize the out parameters.  Currently the impersonation level
    // and capabilities can not be determined.
    if (pPrivs != NULL)
        *((void **) pPrivs) = NULL;
    if (pServerPrincName != NULL)
        *pServerPrincName = NULL;
    if (pAuthnSvc != NULL)
        *pAuthnSvc = RPC_C_AUTHN_WINNT;
    if (pAuthnLevel != NULL)
        *pAuthnLevel = RPC_C_AUTHN_LEVEL_PKT_PRIVACY;
    if (pImpLevel != NULL)
        *pImpLevel = RPC_C_IMP_LEVEL_ANONYMOUS;
    if (pAuthzSvc != NULL)
        *pAuthzSvc = RPC_C_AUTHZ_NONE;
    if (pCapabilities != NULL)
        *pCapabilities = EOAC_NONE;

    // If the call is over, fail this request.
    if (_iFlags & SS_CALL_DONE)
        hr = RPC_E_CALL_COMPLETE;

    // For process local calls, use the defaults. Otherwise ask RPC.
    else if ((_iFlags & SS_PROCESS_LOCAL) == 0)
    {
        sc = RpcBindingInqAuthClientW( _hRpc, pPrivs, pServerPrincName,
                                      pAuthnLevel, pAuthnSvc, pAuthzSvc );

        // Sometimes RPC sets out parameters in error cases.
        if (sc != RPC_S_OK)
        {
            if (pServerPrincName != NULL)
                *pServerPrincName = NULL;
            hr = MAKE_SCODE( SEVERITY_ERROR, FACILITY_WIN32, sc );
        }
        else if (pServerPrincName != NULL && *pServerPrincName != NULL)
        {
            // Reallocate the principle name using the OLE memory allocator.
            iLen = lstrlenW( *pServerPrincName );
            pCopy = (OLECHAR *) CoTaskMemAlloc( (iLen+1) * sizeof(OLECHAR) );
            if (pCopy != NULL)
                lstrcpyW( pCopy, *pServerPrincName );
            else
                hr = E_OUTOFMEMORY;
            RpcStringFree( pServerPrincName );
            *pServerPrincName = pCopy;
        }
    }
    return hr;
}

//+-------------------------------------------------------------------
//
//  Member:     CServerSecurity::QueryInterface, public
//
//  Synopsis:   Returns a pointer to the requested interface.
//
//--------------------------------------------------------------------
STDMETHODIMP CServerSecurity::QueryInterface( REFIID riid, LPVOID FAR* ppvObj)
{
  if (IsEqualIID(riid, IID_IUnknown) ||
      IsEqualIID(riid, IID_IServerSecurity))
  {
    *ppvObj = (IServerSecurity *) this;
  }
  else if(IsEqualIID(riid, IID_ICancelMethodCalls))
  {
    *ppvObj = (ICancelMethodCalls *) this;
  }
  else if(IsEqualIID(riid, IID_IComDispatchInfo))
  {
    *ppvObj = (IComDispatchInfo *) this;
  }
  else
  {
    *ppvObj = NULL;
    return E_NOINTERFACE;
  }

  AddRef();
  return S_OK;
}

//+-------------------------------------------------------------------
//
//  Member:     CServerSecurity::Release, public
//
//  Synopsis:   Releases an interface
//
//--------------------------------------------------------------------
STDMETHODIMP_(ULONG) CServerSecurity::Release()
{
    ULONG lRef = InterlockedDecrement( (long*) &_iRefCount );

    if (lRef == 0)
    {
        // Don't let anyone call release too many times.
        Win4Assert( _iFlags & SS_CALL_DONE );
        if ((_iFlags & SS_CALL_DONE) == 0)
            DebugBreak();
        else
            delete this;
    }

    return lRef;
}

//+-------------------------------------------------------------------
//
//  Member:     CServerSecurity::RevertToSelf, public
//
//  Synopsis:   If ImpersonateClient was called, then either ask RPC to
//              revert or restore the thread token ourself.
//
//--------------------------------------------------------------------
HRESULT CServerSecurity::RevertToSelf()
{
    HRESULT    hr;
    RPC_STATUS sc;
    BOOL       fSuccess;
    COleTls    tls(hr);

    // If TLS doesn't initialize, we can't be impersonating.
    if (FAILED(hr))
        return S_OK;

    // Don't do anything if this security object isn't impersonating.
    if (tls->dwFlags & OLETLS_IMPERSONATING)
    {
        // Ask RPC to revert for process remote calls.
        tls->dwFlags &= ~OLETLS_IMPERSONATING;
        if ((_iFlags & SS_PROCESS_LOCAL) == 0)
        {
            sc = RpcRevertToSelfEx( _hRpc );
            if (sc != RPC_S_OK)
                hr = MAKE_SCODE( SEVERITY_ERROR, FACILITY_WIN32, sc );
        }

        // If there was no token before impersonating, NULL the thread token.
        // Note that if we set the token on this thread after impersonating
        // RpcRevertToSelfEx won't remove it, but we have to call
        // RpcRevertToSelfEx to prevent RPC from automaticly reverting later
        // so set the thread token NULL even after calling RpcRevertToSelfEx.
        if (tls->hRevert == NULL)
        {
            fSuccess = SetThreadToken( NULL, NULL );
            if (!fSuccess)
                hr = MAKE_SCODE( SEVERITY_ERROR, FACILITY_WIN32, GetLastError() );
        }

        // If there was a token before impersonating, put it back.
        // Ignore errors.
        else if (tls->hRevert != NULL)
        {
            Verify( SetThreadToken( NULL, tls->hRevert ) );
            CloseHandle( tls->hRevert );
            tls->hRevert = NULL;
        }
    }
    return hr;
}

//+-------------------------------------------------------------------
//
//  Method:     CServerSecurity::Cancel     public
//
//  Synopsis:   Not valid on the server side
//
//  History:    July 26, 97     GopalK      Created
//
//+-------------------------------------------------------------------
STDMETHODIMP CServerSecurity::Cancel(ULONG ulSeconds)
{
    CairoleDebugOut((DEB_WARN, "Cancel on CServerSecurity:0x%x\n", this));
    return(E_NOTIMPL);
}

//+-------------------------------------------------------------------
//
//  Method:     CServerSecurity::TestCancel     public
//
//  Synopsis:   Answers whether the current call has been canceled
//
//  History:    July 26, 97     GopalK      Created
//
//+-------------------------------------------------------------------
STDMETHODIMP CServerSecurity::TestCancel()
{
    RPC_STATUS hr;

    // Check for local case
    if(_pClientCall)
        return(_pClientCall->TestCancel());

    // Non local case
    hr = RpcServerTestCancel(_hRpc);
    if(hr == RPC_S_OK)
        return(RPC_E_CALL_CANCELED);

    return(RPC_S_CALLPENDING);
}

//+-------------------------------------------------------------------
//
//  Method:     CServerSecurity::EnableComInits   public
//
//  Synopsis:   This method allows future STA inits on dispatch threads
//              to succeed
//
//  History:    June 26, 98     GopalK      Created
//
//+-------------------------------------------------------------------
STDMETHODIMP CServerSecurity::EnableComInits(void **ppvCookie)
{
    COleTls Tls(TRUE);
    HRESULT hr;

    if(((SOleTlsData *) Tls != NULL) &&
       (Tls->cCalls == 1) &&
       (Tls->dwFlags & OLETLS_DISPATCHTHREAD))
    {
        *ppvCookie = (SOleTlsData *) Tls;
        Tls->dwFlags &= ~OLETLS_DISPATCHTHREAD;
        hr = S_OK;
    }
    else
    {
        *ppvCookie = NULL;
        hr = CO_E_NOT_SUPPORTED;
    }

    return(hr);
}

//+-------------------------------------------------------------------
//
//  Method:     CServerSecurity::DisableComInits   public
//
//  Synopsis:   This method disables future STA inits
//
//  History:    June 26, 98     GopalK      Created
//
//+-------------------------------------------------------------------
STDMETHODIMP CServerSecurity::DisableComInits(void *pvCookie)
{
    COleTls Tls(TRUE);
    HRESULT hr;

    if((pvCookie != NULL) &&
       ((SOleTlsData *) Tls == pvCookie))
    {
        Tls->dwFlags |= OLETLS_DISPATCHTHREAD;
        hr = S_OK;
    }
    else
    {
        hr = E_INVALIDARG;
    }

    return(hr);
}

//+-------------------------------------------------------------------
//
//  Method:     CSSL::Cleanup
//
//  Synopsis:   Free the handles.
//
//+-------------------------------------------------------------------
void CSSL::Cleanup()
{
    DWORD status;
    BOOL fRet = FALSE;
    
    _hr = S_FALSE;
    
    if (_pCert != NULL)
    {
        CERT_CONTEXT* pCert = (CERT_CONTEXT*)_pCert;
        _pCert = NULL;
        fRet = CertFreeCertificateContext(pCert);
        Win4Assert(fRet);
    }
        
    if (_hMyStore != NULL)
    {
        HCERTSTORE hMyStore = _hMyStore;
        _hMyStore = NULL;
        fRet = CertCloseStore(hMyStore, 0);
        Win4Assert(fRet);
    }
    
    if (_hRootStore != NULL)
    {
        HCERTSTORE hRootStore = _hRootStore;
        _hRootStore = NULL;
        fRet = CertCloseStore(hRootStore, 0);                
        Win4Assert(fRet);
    }
    
    if (_hProvider != NULL)
    {
        HCRYPTPROV hProvider = _hProvider;
        _hProvider = NULL;
        fRet = CryptReleaseContext(hProvider, 0);
        Win4Assert(fRet);
    }

    return;
}

//+-------------------------------------------------------------------
//
//  Method:      CSSL::DefaultCert
//
//  Synopsis:    Try to get a default certificate.
//
//  Description: Only try once.
//
//+-------------------------------------------------------------------
HRESULT CSSL::DefaultCert( PCCERT_CONTEXT *pCert )
{
    BOOL    fSuccess;
    HRESULT hr;
    DWORD   status;

    // Codework - Currently CryptAcquireContext calls CoInitialize which
    // causes a deadlock.  Find a solution when testing SSL.
#ifndef SSL
    return E_NOTIMPL;
#else
    // If this function has already been called, return the previous
    // results.
    if (_hr != S_FALSE)
        if (_pCert != NULL)
        {
            *pCert = _pCert;
            return S_OK;
        }
        else
            return _hr;

    // Open the CSP provider.
    fSuccess = CryptAcquireContext(&_hProvider, NULL, NULL, PROV_RSA_FULL,
                                    CRYPT_VERIFYCONTEXT);
    if (!fSuccess)
    {
        _hr = MAKE_SCODE( SEVERITY_ERROR, FACILITY_WIN32, GetLastError() );
        return _hr;
    }

    _hMyStore = CertOpenSystemStore(_hProvider, L"my");
    if (_hMyStore != NULL)
    {
        // Get a certificate.
        _pCert = CertEnumCertificatesInStore(_hMyStore, NULL );
        if (_pCert != NULL)
            hr = S_OK;
        else
            hr = MAKE_SCODE( SEVERITY_ERROR, FACILITY_WIN32, GetLastError());
    }
    else
		hr = MAKE_SCODE( SEVERITY_ERROR, FACILITY_WIN32, GetLastError());

    // If something failed, clean up.
    if (FAILED(hr))
        Cleanup();
    *pCert = _pCert;
    _hr    = hr;
    return hr;
#endif
}


//+-------------------------------------------------------------------
//
//  Method:      CSSL::PrincipalName
//
//  Synopsis:    Get a principal name from a certificate.
//
//  Description: Generate a standard or full principal name depending
//               on the capabilities flags.  However, if the standard
//               form fails, try the full form.
//
//  Note:        The string returned must be freed with RpcStringFree.
//
//+-------------------------------------------------------------------
HRESULT CSSL::PrincipalName( const CERT_CONTEXT *pApp, WCHAR **pSSL )
{
    RPC_STATUS status = RPC_S_INTERNAL_ERROR;

    //  If the EOAC_MAKE_FULLSIC flag is not set, try the standard form.
    if ((gCapabilities & EOAC_MAKE_FULLSIC) == 0)
        status = RpcCertGeneratePrincipalName( pApp, 0, pSSL );

    // If the EOAC_MAKE_FULLSIC flag is set or the standard function failed,
    // try the full form.
    if (status != RPC_S_OK)
        status = RpcCertGeneratePrincipalName( pApp, RPC_C_FULL_CERT_CHAIN, pSSL );

    if (status == RPC_S_OK)
        return S_OK;
    else
        return MAKE_SCODE( SEVERITY_ERROR, FACILITY_WIN32, status );
}

//+-------------------------------------------------------------------
//
//  Function:   DefaultAuthnServices, private
//
//  Synopsis:   Register authentication services with RPC and build
//              a string array of authentication services and principal
//              names that were successfully registered.
//
//              Build the best security bindings possible and ignore
//              errors since the user may not need security.
//
//--------------------------------------------------------------------
HRESULT DefaultAuthnServices()
{
    HRESULT                hr;
    DWORD                  i;
    SECURITYBINDING       *pSecBind   = (SECURITYBINDING *)
                  &gpsaSecurity->aStringArray[gpsaSecurity->wSecurityOffset];
    WCHAR                 *pPrincName = NULL;
    DWORD                  lNameLen   = gpsaSecurity->wNumEntries - 5;
    USHORT                *pNextString;
    DUALSTRINGARRAY       *pOld;
    DWORD                  cwBinding  = 0;
    BOOL                  *aSuccess   = (BOOL *) _alloca( sizeof(BOOL) *
                                                          gServerSvcListLen );
    WCHAR                 *pKerberos  = NULL;
    WCHAR                 *pSnego     = NULL;
    WCHAR                 *pSSL       = NULL;
    const CERT_CONTEXT    *pCert;

    ASSERT_LOCK_HELD(gComLock);
    Win4Assert( gGotSecurityData );

    if (gpsaSecurity->aStringArray[gpsaSecurity->wSecurityOffset] != 0)
		pPrincName = &pSecBind->aPrincName;
	
    // Return if the security bindings are already computed.
    if (!gDefaultService)
        return S_OK;

    // Make sure NTLM is first in the list because some NT 4 and Windows
    // 95 machines try to use Kerberos or Snego even thought they don't
    // support then.
    if (gServerSvcList[0] != RPC_C_AUTHN_WINNT)
        for (i = 1; i < gServerSvcListLen; i++)
            if (gServerSvcList[i] == RPC_C_AUTHN_WINNT)
            {
                gServerSvcList[i] = gServerSvcList[0];
                gServerSvcList[0] = RPC_C_AUTHN_WINNT;
                break;
            }

    // Loop over the server service list.
    for (i = 0; i < gServerSvcListLen; i++)
    {
        // Compute the certificate and principal name for SSL.
        // Register SSL.
        if (gServerSvcList[i] == RPC_C_AUTHN_GSS_SCHANNEL)
        {
            aSuccess[i] = FALSE;
            
            hr = CSSL::DefaultCert( &pCert );
            if (SUCCEEDED(hr))
            {
                // Initialize the schannel credential structure.
                memset( &gSchannelCred, 0, sizeof(gSchannelCred) );
                gSchannelContext        = pCert;
                gSchannelCred.dwVersion = SCHANNEL_CRED_VERSION;
                gSchannelCred.cCreds    = 1;
                gSchannelCred.paCred    = &gSchannelContext;

                // Register SSL.
                hr = RpcServerRegisterAuthInfoW( NULL, RPC_C_AUTHN_GSS_SCHANNEL,
                                                 NULL, (WCHAR *) &gSchannelCred );

                // Figure out how much space to save.
                if (SUCCEEDED(hr))
                {
                    hr = CSSL::PrincipalName( pCert, &pSSL );
                    if (SUCCEEDED(hr))
                    {
                        cwBinding += lstrlenW( pSSL ) + 3;
                        aSuccess[i] = TRUE;
                    }
                }
            }
        }

        else if (gServerSvcList[i] == RPC_C_AUTHN_GSS_KERBEROS)
        {
            aSuccess[i] = FALSE;
            hr = LookupPrincName( RPC_C_AUTHN_GSS_KERBEROS, &pKerberos );
            if (SUCCEEDED(hr))
            {
                hr = RpcServerRegisterAuthInfoW( pKerberos,
                                                 RPC_C_AUTHN_GSS_KERBEROS,
                                                 NULL, NULL );

                // Figure out how much space to save.
                if (SUCCEEDED(hr))
                {
                    cwBinding += lstrlenW( pKerberos ) + 3;
                    aSuccess[i] = TRUE;
                }
            }

        }

        else if (gServerSvcList[i] == RPC_C_AUTHN_GSS_NEGOTIATE)
        {
            aSuccess[i] = FALSE;
            hr = LookupPrincName( RPC_C_AUTHN_GSS_NEGOTIATE, &pSnego );
            if (SUCCEEDED(hr))
            {
                hr = RpcServerRegisterAuthInfoW( pSnego,
                                                 RPC_C_AUTHN_GSS_NEGOTIATE,
                                                 NULL, NULL );

                // Figure out how much space to save.
                if (SUCCEEDED(hr))
                {
                    cwBinding += lstrlenW( pSnego ) + 3;
                    aSuccess[i] = TRUE;
                }
            }

        }

        // Register other authentication services.
        else
        {
            hr = RpcServerRegisterAuthInfoW( pPrincName, gServerSvcList[i],
                                             NULL, NULL );

            // Figure out how much space to save.
            if (SUCCEEDED(hr))
            {
                aSuccess[i] = TRUE;
                cwBinding += lNameLen + 3;
            }
            else
                aSuccess[i] = FALSE;
        }
    }

    // Allocate memory for the string array.  Include space for the header,
    // each security binding, 2 nulls to say there are no protocol sequences,
    // and two nulls if the list is empty (one of them is included in the
    // size of the header).
    pOld = gpsaSecurity;
    gpsaSecurity = (DUALSTRINGARRAY *) PrivMemAlloc( sizeof(DUALSTRINGARRAY) +
                                             (cwBinding + 3) * sizeof(WCHAR) );
    if (gpsaSecurity != NULL)
    {
        // Fill in the array of security information. First two characters
        // are NULLs to signal empty binding strings.
        gDefaultService               = FALSE;
        gpsaSecurity->wSecurityOffset = 2;
        gpsaSecurity->aStringArray[0] = 0;
        gpsaSecurity->aStringArray[1] = 0;
        pNextString                   = &gpsaSecurity->aStringArray[2];

        for (i = 0; i < gServerSvcListLen; i++)
        {
            // Fill in the security bindings for authentication services
            // that registered successfully.
            if (aSuccess[i])
            {
                // Fill in authentication service and authorization service.
                *(pNextString++) = gServerSvcList[i];
                *(pNextString++) = COM_C_AUTHZ_NONE;

                // For SSL, use the generated principal name.
                if (gServerSvcList[i] == RPC_C_AUTHN_GSS_SCHANNEL)
                {
                    lstrcpyW( (LPWSTR)pNextString, pSSL );
                    pNextString += lstrlenW(pSSL)+1;
                }

                // For Kerberos, use the appropriate principal name.
                else if (gServerSvcList[i] == RPC_C_AUTHN_GSS_KERBEROS)
                {
                    lstrcpyW( (LPWSTR)pNextString, pKerberos );
                    pNextString += lstrlenW(pKerberos)+1;
                }

                // Same goes for SNEGO.
                else if (gServerSvcList[i] == RPC_C_AUTHN_GSS_NEGOTIATE)
                {
                    lstrcpyW( (LPWSTR)pNextString, pSnego );
                    pNextString += lstrlenW(pSnego)+1;
                }

                // Otherwise use the principal name from the process token.
                else
                {
                    if (pPrincName == NULL)
                        *pNextString = 0;
                    else
                        memcpy( pNextString, pPrincName, lNameLen*sizeof(USHORT) );
                    pNextString += lNameLen;
                }
            }
        }

        // Add a final NULL.  Special case an empty list which requires
        // two NULLs.
        *(pNextString++) = 0;
        if (pNextString == &gpsaSecurity->aStringArray[3])
            *(pNextString++) = 0;
        gpsaSecurity->wNumEntries = (USHORT)
                                  (pNextString-gpsaSecurity->aStringArray);
        hr = S_OK;
        PrivMemFree( pOld );
    }

    // If the memory allocation failed, don't change the string bindings.
    else
    {
        hr           = E_OUTOFMEMORY;
        gpsaSecurity = pOld;
    }

    // Cleanup interm memory allocations.
    RpcStringFree( &pSSL );
    PrivMemFree( pKerberos );
    PrivMemFree( pSnego );
    return hr;
}

//+-------------------------------------------------------------------
//
//  Function:   DefaultAuthnSvc
//
//  Synopsis:   Return the index in the security binding of the
//              default authentication service.  If the server is
//              machine local, find NTLM.  Otherwise, find a security
//              provider available on both the client and server.
//              If there are several matches, select the first one
//              from the client's authentication service list.  If
//              there are no matches return an index past the end of
//              the security binding.
//
//--------------------------------------------------------------------

DWORD DefaultAuthnSvc( OXIDEntry *pOxid )
{
    USHORT                       wNext;
    USHORT                       wFirst;
    USHORT                       wServer;
    DWORD                        i;
    DWORD                        lIndex;

    ASSERT_LOCK_HELD(gComLock);
    DUALSTRINGARRAY *pBinding = pOxid->GetBinding();

    // For machine local servers, always pick NTLM
    if (pOxid->IsOnLocalMachine())
        return GetAuthnSvcIndexForBinding ( RPC_C_AUTHN_WINNT, pBinding );

    // For machine remote servers, find a match.
    else
    {
        // Look through all the authentication services in the interface
        // till we find one that works on this machine.

        wNext  = pBinding->wSecurityOffset;
        wFirst = 0xffff;
        lIndex = 0xffffffff;
        while (wNext < pBinding->wNumEntries &&
               pBinding->aStringArray[wNext] != 0)
        {
            // Don't use Kerberos or Snego to talk to old builds because they
            // register those ids even thought they don't support them.
            wServer = pBinding->aStringArray[wNext];
            if (pOxid->GetComVersion().MinorVersion > 3 ||
                (wServer != RPC_C_AUTHN_GSS_KERBEROS &&
                 wServer != RPC_C_AUTHN_GSS_NEGOTIATE))
            {
                i = LocalAuthnService( wServer );
                if (i != -1)
                {
                    if (i < lIndex)
                    {
                        lIndex = i;
                        wFirst = wNext;
                    }
                }
            }

            // Skip to the next authentication service.
            wNext += (USHORT) lstrlenW( (LPCWSTR)&pBinding->aStringArray[wNext] ) + 1;
        }

        // If there was a match, return its index.
        if (wFirst != 0xffff)
            return wFirst;

        // Otherwise return a bad index.
        else
            return pBinding->wNumEntries;
    }
}

//+-------------------------------------------------------------------
//
//  Function:   DefaultBlanket
//
//  Synopsis:   Compute the default security blanket for the specified
//              authentication service.
//              The authentication level is the higher of the process
//              default and the level in the interface.  The
//              impersonation level is the process default.
//
//--------------------------------------------------------------------

HRESULT DefaultBlanket( DWORD lAuthnSvc, OXIDEntry *pOxid, SBlanket *pBlanket )
{
    USHORT                       wAuthnSvc;
    USHORT                       wNext;
    WCHAR                       *pEnd;
    DWORD                        cbAuthId;
    DWORD                        i;
    DWORD                        lIndex;
    SECURITYBINDING             *pSecBind;

    ASSERT_LOCK_HELD(gComLock);

    // Pick the highest authentication level between the process default
    // and the interface hint.
    if (pBlanket->_lAuthnLevel == RPC_C_AUTHN_LEVEL_DEFAULT)
        if (gAuthnLevel > pOxid->GetAuthnHint())
            pBlanket->_lAuthnLevel = gAuthnLevel;
        else
            pBlanket->_lAuthnLevel = pOxid->GetAuthnHint();

    // Compute the quality of service parameter.
    pBlanket->_lCapabilities           = gCapabilities & VALID_BLANKET_FLAGS;
    pBlanket->_sQos.Version            = RPC_C_SECURITY_QOS_VERSION;
    pBlanket->_sQos.ImpersonationType  = gImpLevel;
    pBlanket->_sQos.Capabilities       = RPC_C_QOS_CAPABILITIES_DEFAULT;
    if (gCapabilities & EOAC_DYNAMIC_CLOAKING)
        pBlanket->_sQos.IdentityTracking   = RPC_C_QOS_IDENTITY_DYNAMIC;
    else
        pBlanket->_sQos.IdentityTracking   = RPC_C_QOS_IDENTITY_STATIC;

    // [Sergei O. Ivanov (sergei), 7/20/2000]
    // This fixes a number of bugs that surface when cAuthSvc
    // is -1 in an earlier user call to CoInitalizeSecurity.

    // Fill in the schannel cred structure.
    memset( &pBlanket->_sCred, 0, sizeof(pBlanket->_sCred) );
    pBlanket->_sCred.dwVersion = SCHANNEL_CRED_VERSION;
    pBlanket->_sCred.cCreds    = 1;
    pBlanket->_sCred.paCred    = &pBlanket->_pCert;
    pBlanket->_pCert           = NULL;

    // If the index is bad or the default authentication level is none,
    // make up return values.
    DUALSTRINGARRAY *pBinding = pOxid->GetBinding();
    if (pBinding == NULL                   ||
        lAuthnSvc >= pBinding->wNumEntries ||
        pBlanket->_lAuthnLevel == RPC_C_AUTHN_LEVEL_NONE)
    {
        if (pBlanket->_lAuthnLevel == RPC_C_AUTHN_LEVEL_NONE)
            pBlanket->_lAuthnSvc     = RPC_C_AUTHN_NONE;
        else
            pBlanket->_lAuthnSvc     = RPC_C_AUTHN_WINNT;
        pBlanket->_pPrincipal    = NULL;
        pBlanket->_pAuthId       = NULL;
        pBlanket->_lAuthzSvc     = RPC_C_AUTHZ_NONE;

        return S_OK;
    }

    // Get the principal name.
    pSecBind = (SECURITYBINDING *) &pBinding->aStringArray[lAuthnSvc];
    pBlanket->_pPrincipal = (WCHAR *)&pSecBind->aPrincName;
    if (pBlanket->_pPrincipal[0] == 0)
        pBlanket->_pPrincipal = NULL;

    // For SChannel, work around the case when server certificate
    // has no email and MSSTD format name is sent from the server
    if (pSecBind->wAuthnSvc == RPC_C_AUTHN_GSS_SCHANNEL
        && pBlanket->_pPrincipal != NULL
        && lstrcmpi(pBlanket->_pPrincipal, L"msstd:") == 0)
        return CO_E_MALFORMED_SPN;

    // Fix up the authorization service.
    pBlanket->_lAuthnSvc = pSecBind->wAuthnSvc;
    pBlanket->_lAuthzSvc = pSecBind->wAuthzSvc;
    if (pBlanket->_lAuthzSvc == COM_C_AUTHZ_NONE)
        pBlanket->_lAuthzSvc = RPC_C_AUTHZ_NONE;

    //look up the authid parameter.
    // Find the authentication information only for remote machines.
    if (!(pOxid->IsOnLocalMachine()))
       pBlanket->_pAuthId = CAuthInfo::Find( pSecBind );
    else
       pBlanket->_pAuthId = NULL;

    if (pSecBind->wAuthnSvc == RPC_C_AUTHN_GSS_SCHANNEL)
    {
       // Verify that the principal name for SSL is in the correct form.
       if ((gCapabilities & EOAC_REQUIRE_FULLSIC) &&
           (pBlanket->_pPrincipal == NULL ||
            wcsncmp( pBlanket->_pPrincipal, FULL_SUBJECT_ISSUER_CHAIN,
                     sizeof(FULL_SUBJECT_ISSUER_CHAIN) / sizeof(*FULL_SUBJECT_ISSUER_CHAIN) - 1 ) != 0))
          return RPC_E_FULLSIC_REQUIRED;
       
       // Fill in the schannel cred structure.
       pBlanket->_pCert = (PCCERT_CONTEXT) pBlanket->_pAuthId;
       
       if (pBlanket->_pCert)
          pBlanket->_pAuthId = (void *) &pBlanket->_sCred;
    }
    return S_OK;
}

//+-------------------------------------------------------------------
//
//  Function:   FixupAccessControl, internal
//
//  Synopsis:   Get the access control class id.  Instantiate the access
//              control class and load the data.
//
//  Notes:      The caller has already insured that the structure is
//              at least as big as a SPermissionHeader structure.
//
//--------------------------------------------------------------------
HRESULT FixupAccessControl( SECURITY_DESCRIPTOR **pSD, DWORD cbSD )
{
    SPermissionHeader *pHeader;
    IAccessControl    *pControl = NULL;
    IPersistStream    *pPersist = NULL;
    CNdrStream         cStream( ((unsigned char *) *pSD) + sizeof(SPermissionHeader),
                                cbSD - sizeof(SPermissionHeader) );
    HRESULT            hr;

    // Get the class id.
    pHeader = (SPermissionHeader *) *pSD;

    // Instantiate the class.
    hr = CoCreateInstance( pHeader->gClass, NULL, CLSCTX_INPROC_SERVER | CLSCTX_NO_CODE_DOWNLOAD,
                           IID_IAccessControl, (void **) &pControl );

    // Get IPeristStream
    if (SUCCEEDED(hr))
    {
        hr = pControl->QueryInterface( IID_IPersistStream, (void **) &pPersist );

        // Load the stream.
        if (SUCCEEDED(hr))
            hr = pPersist->Load( &cStream );
    }

    // Release resources.
    if (pPersist != NULL)
        pPersist->Release();
    if (SUCCEEDED(hr))
    {
        PrivMemFree( *pSD );
        *pSD = (SECURITY_DESCRIPTOR *) pControl;
    }
    else if (pControl != NULL)
        pControl->Release();
    return hr;
}



//+-------------------------------------------------------------------
//
//  Function:   FixupSecurityDescriptor, internal
//
//  Synopsis:   Convert the security descriptor from self relative to
//              absolute form and check for errors.
//
//--------------------------------------------------------------------
HRESULT FixupSecurityDescriptor( SECURITY_DESCRIPTOR **pSD, DWORD cbSD )
{

#ifdef _WIN64

    DWORD local_cbSD = cbSD;
    if ( MakeAbsoluteSD2( *pSD, &local_cbSD ) == FALSE )
    {
        // Failed to convert the self-relative SD to absolute.  Let's see if
        // we can figure out why and if we can do something about it.

        HRESULT hr = REGDB_E_INVALIDVALUE;

        if (local_cbSD > cbSD)
        {
            // The buffer containing the self-relative security descriptor is
            // not big enough to convert to absolute form.  To correct this:
            // allocate a new buffer, copy the contents of the existing buffer
            // into it, release the original buffer, and try to convert again.

            hr = E_OUTOFMEMORY;
            SECURITY_DESCRIPTOR *pASD = (SECURITY_DESCRIPTOR *) PrivMemAlloc(local_cbSD);
            if (pASD)
            {
                CopyMemory(pASD, *pSD, cbSD);

                SECURITY_DESCRIPTOR *pTemp = *pSD;
                *pSD = pASD;
                PrivMemFree(pTemp);

                if ( MakeAbsoluteSD2( *pSD, &local_cbSD ) == FALSE )
                    hr = REGDB_E_INVALIDVALUE;
            }
        }
    }
#else  // !_WIN64

    // Fix up the security descriptor.
    (*pSD)->Control &= ~SE_SELF_RELATIVE;
    if ((*pSD)->Dacl != NULL)
    {
        if (cbSD < (sizeof(ACL) + sizeof(SECURITY_DESCRIPTOR)) ||
            (ULONG) (*pSD)->Dacl > cbSD - sizeof(ACL))
            return REGDB_E_INVALIDVALUE;
        (*pSD)->Dacl = (ACL *) (((char *) *pSD) + ((ULONG) (*pSD)->Dacl));
        if ((*pSD)->Dacl->AclSize + sizeof(SECURITY_DESCRIPTOR) > cbSD)
            return REGDB_E_INVALIDVALUE;
    }

    // Set up the owner and group SIDs.
    if ((*pSD)->Group == 0 || ((ULONG) (*pSD)->Group) + sizeof(SID) > cbSD ||
        (*pSD)->Owner == 0 || ((ULONG) (*pSD)->Owner) + sizeof(SID) > cbSD)
        return REGDB_E_INVALIDVALUE;
    (*pSD)->Group = (SID *) (((BYTE *) *pSD) + (ULONG) (*pSD)->Group);
    (*pSD)->Owner = (SID *) (((BYTE *) *pSD) + (ULONG) (*pSD)->Owner);

#endif // !_WIN64
    (*pSD)->Sacl     = NULL;

    // Check the security descriptor.
#if DBG==1
    if (!IsValidSecurityDescriptor( *pSD ))
        return REGDB_E_INVALIDVALUE;
#endif

    return S_OK;
}

//+-------------------------------------------------------------------
//
//  Function:   GetLegacyBlanket, internal
//
//  Synopsis:   Get a security blanket for the current app.  First,
//              look under the app id for the current exe name.  If that
//              fails look up the default descriptor.  If that fails,
//              create one.
//
//  Note: It is possible that the security descriptor size could change
//  during the size computation.  Add code to retry.
//
//--------------------------------------------------------------------
HRESULT GetLegacyBlanket( SECURITY_DESCRIPTOR **pSD, DWORD *pCapabilities,
                          DWORD *pAuthnLevel)
{
    extern GUID g_AppId;

    // Holds either Appid\{guid} or Appid\module_name.
    WCHAR   aKeyName[MAX_PATH+7] = L"";
 // But first it holds nothing.
    HRESULT hr;
    HKEY    hKey   = NULL;
    DWORD   lSize;
    WCHAR   aModule[MAX_PATH];
    DWORD   cModule;
    DWORD   i;
    WCHAR   aAppid[40];         // Hold a registry GUID.
    DWORD   lType;
    BOOL    fContinue = TRUE;

    // If the flag EOAC_APPID is set, the security descriptor contains the
    // app id.
    if ((*pCapabilities & EOAC_APPID) && *pSD != NULL)
    {
        if (StringFromIID2( *((GUID *) *pSD), aAppid, sizeof(aAppid) / sizeof(WCHAR) ) == 0)
            return RPC_E_UNEXPECTED;

        // Open the application id key.  A GUID in the registry is stored.
        // as a 38 character string.
        lstrcpyW( aKeyName, L"AppID\\" );
        memcpy( &aKeyName[6], aAppid, 39*sizeof(WCHAR) );
        hr = OpenClassesRootKeyEx( aKeyName, KEY_READ, &hKey );
        Win4Assert( hr == ERROR_SUCCESS || hKey == NULL );

        g_AppId = *((GUID *) (*pSD));
    }

    // Look up the app id from the exe name.
    else
    {
        // Get the executable's name.  Find the start of the file name.
        cModule = GetModuleFileName( NULL, aModule, MAX_PATH );
        if (cModule >= MAX_PATH)
        {
            Win4Assert( !"Module name too long." );
            return RPC_E_UNEXPECTED;
        }
        for (i = cModule-1; i > 0; i--)
            if (aModule[i] == '/' ||
                aModule[i] == '\\' ||
                aModule[i] == ':')
                break;
        if (i != 0)
            i += 1;

        // Open the key for the EXE's module name.
        lstrcpyW( aKeyName, L"AppID\\" );
        memcpy( &aKeyName[6], &aModule[i], (cModule - i + 1) * sizeof(WCHAR) );
        hr = OpenClassesRootKeyEx(aKeyName, KEY_READ, &hKey );
        Win4Assert( hr == ERROR_SUCCESS || hKey == NULL );

        // Look for an application id.
        if (hr == ERROR_SUCCESS)
        {
            lSize = sizeof(aAppid);
            hr = RegQueryValueEx( hKey, L"AppID", NULL, &lType,
                                  (unsigned char *) &aAppid, &lSize );
            RegCloseKey( hKey );
            hKey = NULL;

            // Open the application id key.  A GUID in the registry is stored.
            // as a 38 character string.
            if (hr == ERROR_SUCCESS && lType == REG_SZ &&
                lSize == 39*sizeof(WCHAR))
            {
                memcpy( &aKeyName[6], aAppid, 39*sizeof(WCHAR) );
                hr = OpenClassesRootKeyEx( aKeyName, KEY_READ, &hKey );
                Win4Assert( hr == ERROR_SUCCESS || hKey == NULL );
            }
        }
    }

    // Get the authentication level.
    *pSD = NULL;
    hr   = S_OK;
    GetRegistryAuthnLevel( hKey, pAuthnLevel );

    // If the authentication level is not none, get a security descriptor.
    if (*pAuthnLevel != RPC_C_AUTHN_LEVEL_NONE)
    {

        // Use the appid key to open access permissions.
        if (hKey != NULL)
        {
            hr = GetRegistrySecDesc( hKey, L"AccessPermission",
                                     pSD, pCapabilities, &fContinue );
            RegCloseKey( hKey );
            hKey = NULL;
        }

        // If the appid access permission does not exist, try the default
        // access permission.
        if (fContinue)
        {
            // Open the default key.
            hr = RegOpenKeyEx( HKEY_LOCAL_MACHINE, L"SOFTWARE\\Microsoft\\OLE",
                               NULL, KEY_READ, &hKey );
            Win4Assert( hr == ERROR_SUCCESS || hKey == NULL );

            // Get the security descriptor from the registry.
            if (hr == ERROR_SUCCESS)
            {
                hr = GetRegistrySecDesc( hKey, L"DefaultAccessPermission",
                                         pSD, pCapabilities, &fContinue );

                // If that failed, make one.
                if (fContinue)
                    hr = MakeSecDesc( pSD, pCapabilities );
            }
            else
                hr = MAKE_SCODE( SEVERITY_ERROR, FACILITY_WIN32, hr );
        }
    }

    // Free the security descriptor memory if anything failed.
    if (FAILED(hr))
    {
        PrivMemFree( *pSD );
        *pSD = NULL;
    }

    // Close the registry keys.
    if (hKey != NULL)
        RegCloseKey( hKey );
    return hr;
}

//+-------------------------------------------------------------------
//
//  Function:   GetRegistryAuthnLevel, internal
//
//  Synopsis:   Look for the authentication level under the appid.
//              If not found, use the default.
//
//--------------------------------------------------------------------
void GetRegistryAuthnLevel( HKEY hKey, DWORD *pAuthnLevel )

{
    DWORD   lType;
    HRESULT hr;
    DWORD   cbDword = sizeof(DWORD);

    // If there is no key, use the default.
    if (hKey == NULL)
        *pAuthnLevel = gAuthnLevel;

    // Get the authentication level
    else
    {
        hr = RegQueryValueEx( hKey, L"AuthenticationLevel", NULL, &lType,
                             (unsigned char *) pAuthnLevel, &cbDword );

        // If it wasn't present use the default.
        if (hr != ERROR_SUCCESS)
            *pAuthnLevel = gAuthnLevel;

        // If the type was wrong, use a bad value.
        else if (lType != REG_DWORD || cbDword != sizeof(DWORD))
            *pAuthnLevel = 0xffffffff;
    }
}

//+-------------------------------------------------------------------
//
//  Function:   GetRegistrySecDesc, internal
//
//  Synopsis:   Read a security descriptor from the registry.
//              Convert it from self relative to
//              absolute form.  Stuff in an owner and a group.
//
//  Notes:      pContinue indicates whether or not the security
//              descriptor exists in the registry.  TRUE means it does not.
//
//              pContinue is assumed to be TRUE on entry.  If the
//              security descriptor is read correctly, or it exists but
//              is bad, or it may exist, set pContinue FALSE.
//
//              The caller must free the security descriptor in both the
//              success and failure cases.
//
//--------------------------------------------------------------------
HRESULT GetRegistrySecDesc( HKEY hKey, WCHAR *pAccessName,
                            SECURITY_DESCRIPTOR **pSD, DWORD *pCapabilities,
                            BOOL *pContinue )

{
    SID    *pGroup;
    SID    *pOwner;
    DWORD   cbSD = 256, cbAlloc = cbSD;
    DWORD   lType;
    HRESULT hr;
    WORD    wVersion;

    // Guess how much memory to allocate for the security descriptor.
    size_t stDeltaSize = 0;

#ifdef _WIN64

    // Make sure that the initially allocated buffer has space for the size difference between the
    // disk representation and the memory representation of security descriptors
    stDeltaSize = sizeof( SECURITY_DESCRIPTOR ) - sizeof( SECURITY_DESCRIPTOR_RELATIVE );

    Win4Assert (stDeltaSize < sizeof( SECURITY_DESCRIPTOR ));

    stDeltaSize = OLE2INT_ROUND_UP( stDeltaSize, sizeof(PVOID) );
    cbAlloc += (DWORD) stDeltaSize;

#endif // _WIN64


    *pContinue = FALSE;
    *pSD = (SECURITY_DESCRIPTOR *) PrivMemAlloc( cbAlloc );
    if (*pSD == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto cleanup;
    }

    // Find put how much memory to allocate for the security
    // descriptor.
    hr = RegQueryValueEx( hKey, pAccessName, NULL, &lType,
                         (unsigned char *) *pSD, &cbSD );
    if (hr != ERROR_SUCCESS && hr != ERROR_MORE_DATA)
    {
        hr = MAKE_SCODE( SEVERITY_ERROR, FACILITY_WIN32, hr );
        *pContinue = TRUE;
        goto cleanup;
    }
    if (lType != REG_BINARY || cbSD < sizeof(SECURITY_DESCRIPTOR_RELATIVE))
    {
        hr = REGDB_E_INVALIDVALUE;
        goto cleanup;
    }

    // If the first guess wasn't large enough, reallocate the memory.
    if (hr == ERROR_MORE_DATA)
    {
        PrivMemFree( *pSD );

        cbAlloc = (DWORD) (cbSD + stDeltaSize);
        *pSD = (SECURITY_DESCRIPTOR *) PrivMemAlloc( cbAlloc );
        if (*pSD == NULL)
        {
            hr = E_OUTOFMEMORY;
            goto cleanup;
        }

        // Read the security descriptor.
        hr = RegQueryValueEx( hKey, pAccessName, NULL, &lType,
                              (unsigned char *) *pSD, &cbSD );
        if (hr != ERROR_SUCCESS)
        {
            hr = MAKE_SCODE( SEVERITY_ERROR, FACILITY_WIN32, hr );
            *pContinue = TRUE;
            goto cleanup;
        }
        if (lType != REG_BINARY || cbSD < sizeof(SECURITY_DESCRIPTOR_RELATIVE))
        {
            hr = REGDB_E_INVALIDVALUE;
            goto cleanup;
        }
    }

    // Check the first DWORD to determine what type of data is in the
    // registry value.
    wVersion = *((WORD *) *pSD);
    if (wVersion == COM_PERMISSION_SECDESC)
        hr = FixupSecurityDescriptor( pSD, cbAlloc);
    else
    {
        if (wVersion == COM_PERMISSION_ACCCTRL)
        {
            hr = FixupAccessControl( pSD, cbSD );
            if (SUCCEEDED(hr))
                *pCapabilities |= EOAC_ACCESS_CONTROL;
        }
        else
            hr = REGDB_E_INVALIDVALUE;
    }

cleanup:
    if (FAILED(hr))
    {
        PrivMemFree( *pSD );
        *pSD = NULL;
    }
    return hr;
}

//+-------------------------------------------------------------------
//
//  Function:   HashSid
//
//  Synopsis:   Create a 32 bit hash of a SID.
//
//--------------------------------------------------------------------
DWORD HashSid( SID *pSid )
{
    DWORD          lHash = 0;
    DWORD          cbSid = GetLengthSid( pSid );
    DWORD          i;
    unsigned char *pData = (unsigned char *) pSid;

    for (i = 0; i < cbSid; i++)
        lHash = (lHash << 1) + *pData++;
    return lHash;
}

//+-------------------------------------------------------------------
//
//  Function:   InitializeSecurity, internal
//
//  Synopsis:   Called the first time the channel is used.  If the app
//              has not initialized security yet, this function sets
//              up legacy security.
//
//--------------------------------------------------------------------
HRESULT InitializeSecurity()
{
    HRESULT  hr = S_OK;

    ASSERT_LOCK_NOT_HELD(gComLock);
    LOCK(gComLock);

    // skip if already initialized.
    if (gpsaSecurity == NULL)
    {
        // Initialize.  All parameters are ignored except the security descriptor
        // since the capability is set to app id.
        hr = CoInitializeSecurity( NULL, -1, NULL, NULL, RPC_C_AUTHN_LEVEL_NONE,
                                   RPC_C_IMP_LEVEL_IDENTIFY, NULL, EOAC_APPID,
                                   NULL );

        // Convert confusing error codes.
        if (hr == E_INVALIDARG)
            hr = REGDB_E_INVALIDVALUE;
    }

    UNLOCK(gComLock);
    ASSERT_LOCK_NOT_HELD(gComLock);

    return hr;
}


//+-------------------------------------------------------------------
//
//  Function:   VerifyCallerIsUs
//
//  Synopsis:   Debug only function used to verify that calls by RPCSS 
//    made to a process are made using the process' identity, instead
//    of RPCSS' identity.  Also verifies that caller called at an
//    IDENTIFY level of impersonation.
//
//  Arguments:  
//
//     hRpc -- RPC call handle.  Pass NULL if a COM call.
//
//  Returns:
//     TRUE  -- the caller's identity matches this process' identity and caller
//        used IDENTIFY level impersonation.
//
//     FALSE -- not
//
//  History:  03-Apr-02   JSimmons    Created 
//
//--------------------------------------------------------------------
#ifdef DBG
BOOL VerifyCallerIsUs(handle_t hRpc)
{
    HRESULT     hr = S_OK;
    HANDLE      hThreadToken = NULL;
    HANDLE      hProcessToken = NULL;
    BOOL        fRet = FALSE;
    BOOL        fIsCallerUs = TRUE;
    BOOL        fCallerUsedIDENTIFY = FALSE;
    DWORD       dwBufSize = 0;
    TOKEN_USER* ptuCaller = NULL;
    TOKEN_USER* ptuUs = NULL;
    SECURITY_IMPERSONATION_LEVEL implevel;

    // Impersonate.
    if(!hRpc)
        fRet = (S_OK == CoImpersonateClient());
    else
        fRet = (RPC_S_OK == RpcImpersonateClient(hRpc));

    // Get the thread token.
    if (fRet)
    {
        fRet = OpenThreadToken(GetCurrentThread(),
                               TOKEN_READ,
                               TRUE, 
                               &hThreadToken );
        
        // Revert
        if(!hRpc)
            (void)CoRevertToSelf();
        else
            (void)RpcRevertToSelfEx(hRpc);
    }

    if (fRet)
    {
        // Open process token
        fRet = OpenProcessToken(GetCurrentProcess(), TOKEN_READ, &hProcessToken);
    }

    // Get sid for caller
    if (fRet)
    {
        fRet = GetTokenInformation(hThreadToken,
                                   TokenUser,
                                   NULL,
                                   0,
                                   &dwBufSize);
        if (!fRet && (GetLastError() == ERROR_INSUFFICIENT_BUFFER))
        {
            SafeAllocaAllocate(ptuCaller, dwBufSize);
            if (ptuCaller)
            {
                fRet = GetTokenInformation(hThreadToken,
                                           TokenUser,
                                           ptuCaller,
                                           dwBufSize,
                                           &dwBufSize);
            }
            // else fRet is already FALSE
        }
        else
            fRet = FALSE;
    }

    // Get sid for us
    if (fRet)
    {
        fRet = GetTokenInformation(hProcessToken,
                                   TokenUser,
                                   NULL,
                                   0,
                                   &dwBufSize);
        if (!fRet && (GetLastError() == ERROR_INSUFFICIENT_BUFFER))
        {
            SafeAllocaAllocate(ptuUs, dwBufSize);
            if (ptuUs)
            {
                fRet = GetTokenInformation(hProcessToken,
                                           TokenUser,
                                           ptuUs,
                                           dwBufSize,
                                           &dwBufSize);
            }
            // else fRet is already FALSE
        }
        else
            fRet = FALSE;
    }          

    // Compare sids
    if (fRet)
    {
        fIsCallerUs = EqualSid(ptuCaller->User.Sid, ptuUs->User.Sid);
    }

    // Cleanup
    if (hProcessToken) 
        CloseHandle(hProcessToken);
    if (hThreadToken) 
        CloseHandle(hThreadToken);
    SafeAllocaFree(ptuCaller);
    SafeAllocaFree(ptuUs);

    // Done.  Return TRUE if an error occurred.
    return fRet ? fIsCallerUs : TRUE;
}


//+-------------------------------------------------------------------
//
//  Function:   VerifyCallerIsLocalSystem
//
//  Synopsis:   Debug only function used to verify that calls by RPCSS 
//    made to a process are made using the SYSTEM identity.
//
//  Arguments:  
//
//     hRpc -- RPC call handle.  Pass NULL if a COM call.
//
//  Returns:
//     TRUE  -- the sid of the caller's identity is SYSTEM
//
//     FALSE -- not
//
//  History:  03-Apr-02   JSimmons    Created 
//
//--------------------------------------------------------------------
BOOL VerifyCallerIsLocalSystem(handle_t hRpc)
{
    HRESULT     hr = S_OK;
    HANDLE      hThreadToken = NULL;
    BOOL        fRet = FALSE;
    BOOL        fIsCallerLocalSystem = FALSE;
    DWORD       dwBufSize = 0;
    TOKEN_USER* ptuCaller = NULL;

    // Impersonate.
    if(!hRpc)
        fRet = (S_OK == CoImpersonateClient());
    else
        fRet = (RPC_S_OK == RpcImpersonateClient(hRpc));

    // Get the thread token.
    if (fRet)
    {
        fRet = OpenThreadToken(GetCurrentThread(),
                               TOKEN_READ,
                               TRUE, 
                               &hThreadToken );
        
        // Revert
        if(!hRpc)
            (void)CoRevertToSelf();
        else
            (void)RpcRevertToSelfEx(hRpc);
    }

    // Get caller's sid
    if (fRet)
    {
        fRet = GetTokenInformation(hThreadToken,
                                   TokenUser,
                                   NULL,
                                   0,
                                   &dwBufSize);
        if (!fRet && (GetLastError() == ERROR_INSUFFICIENT_BUFFER))
        {
            SafeAllocaAllocate(ptuCaller, dwBufSize);
            if (ptuCaller)
            {
                fRet = GetTokenInformation(hThreadToken,
                                           TokenUser,
                                           ptuCaller,
                                           dwBufSize,
                                           &dwBufSize);
            }
            // else fRet is already FALSE
        }
        else
            fRet = FALSE;
    }

    // Compare caller sid to localsystem sid
    if (fRet)
    {
        fIsCallerLocalSystem = EqualSid(ptuCaller->User.Sid, (PSID)&LOCAL_SYSTEM_SID);
    }
    
    // Cleanup
    if (hThreadToken) 
        CloseHandle(hThreadToken);
    SafeAllocaFree(ptuCaller);

    // Done.  Return TRUE if an error occurred.
    return fRet ? fIsCallerLocalSystem : TRUE;
}

//+-------------------------------------------------------------------
//
//  Function:   VerifyCallersImpLevel
//
//  Synopsis:   Debug only function used to verify that a caller called
//     us at a specified impersonation level.
//
//  Arguments:  
//
//     hRpc -- RPC call handle.  Pass NULL if a COM call.
//
//  Returns:
//     TRUE  -- The caller used the specified impersonation level.
//     FALSE -- The caller didn't
//
//  History:  03-Apr-02   JSimmons    Created 
//
//--------------------------------------------------------------------
BOOL VerifyCallersImpLevel(handle_t hRpc, DWORD dwExpectedImpLevel)
{
    BOOL   fRet = FALSE;
    BOOL   fImpLevelOkay = FALSE;
    HANDLE hThreadToken = NULL;
    DWORD  dwImpLevel = 0;
    DWORD  dwBufSize = 0;

    // Impersonate.
    if(!hRpc)
        fRet = (S_OK == CoImpersonateClient());
    else
        fRet = (RPC_S_OK == RpcImpersonateClient(hRpc));

    // Get the thread token.
    if (fRet)
    {
        fRet = OpenThreadToken(GetCurrentThread(),
                               TOKEN_READ,
                               TRUE,
                               &hThreadToken );

        // Revert
        if(!hRpc)
            (void)CoRevertToSelf();
        else
            (void)RpcRevertToSelfEx(hRpc);
    }

    // Query token for it's impersonation level
    if (fRet)
    {
        dwBufSize = sizeof(dwImpLevel);
        fRet = GetTokenInformation(hThreadToken,
                                   TokenImpersonationLevel,
                                   &dwImpLevel,
                                   dwBufSize,
                                   &dwBufSize);
        if (fRet)
        {
            fImpLevelOkay = (dwImpLevel == dwExpectedImpLevel);
        }
        CloseHandle(hThreadToken);
    }

    // Return TRUE if an error occurred to avoid spurious asserts
    // during stress.
    return fRet ? fImpLevelOkay : TRUE;
}


#endif // DBG

//+-------------------------------------------------------------------
//
//  Function:   LocalAuthnService
//
//  Synopsis:   Returns the index of the specified authentication
//              service in gClientSvcListLen or -1.
//
//--------------------------------------------------------------------
DWORD LocalAuthnService( USHORT wAuthnService )
{
    DWORD l;

    for (l = 0; l < gClientSvcListLen; l++)
        if (gClientSvcList[l].wId == wAuthnService)
            return l;
    return -1;
}

//+-------------------------------------------------------------------
//
//  Function:   LookupPrincName, private
//
//  Synopsis:   Open the process token and find the user's name.
//
//  Notes:      NTLM includes a special case for LocalSystem - in this case
//              we want need to construct "NT Authority\System" as the
//              principal name.  This is the default returned by SID
//              lookup.  For all other authentication services we need
//              to use LsaQueryInformationPolicy.
//
//--------------------------------------------------------------------
HRESULT LookupPrincName( USHORT wAuthnSvc, WCHAR **pPrincName )
{
    HRESULT            hr          = S_OK;
    BYTE               aMemory[SIZEOF_TOKEN_USER];
    TOKEN_USER        *pTokenUser  = (TOKEN_USER *) &aMemory;
    HANDLE             hToken      = NULL;
    DWORD              lSize;
    DWORD              lNameLen    = 80;
    DWORD              lDomainLen  = 80;
    WCHAR             *pUserName   = NULL;
    SID_NAME_USE       sIgnore;
    BOOL               fSuccess;
    HANDLE             hThread;
    BOOL               bUseFQDN = FALSE;
     
    // Suspend the thread token.
    SuspendImpersonate( &hThread );

    // Open the process's token.
    *pPrincName = NULL;
    if (OpenProcessToken( GetCurrentProcess(), TOKEN_QUERY, &hToken ))
    {
        // Lookup SID of process token.
        if (GetTokenInformation( hToken, TokenUser, pTokenUser, sizeof(aMemory),
                                 &lSize ))
        {
           if (wAuthnSvc != RPC_C_AUTHN_WINNT &&
               ( EqualSid( (PVOID) &LOCAL_SYSTEM_SID, pTokenUser->User.Sid ) ||
                 EqualSid( (PVOID) &NETWORKSERVICE_SID, pTokenUser->User.Sid ))) 
           {
              
              WCHAR*             pwszSPNPrefix = L"host/";
              WCHAR*             pwszFQDN = NULL;
              hr = gResolver.GetFQDN(&pwszFQDN);
              if (SUCCEEDED(hr)) 
              {
                 Win4Assert(pwszFQDN);
                 *pPrincName = (WCHAR *) PrivMemAlloc( (lstrlenW(pwszSPNPrefix)+lstrlenW(pwszFQDN)+1)*sizeof(WCHAR) );
                 if (*pPrincName != NULL)
                 {
                    lstrcpyW(*pPrincName, pwszSPNPrefix);
                    lstrcatW(*pPrincName, pwszFQDN);
                    bUseFQDN = TRUE;
                 }
                 else
                    hr = E_OUTOFMEMORY;
              }
           }
           else
           {
              // Preallocate some memory;
              lSize       = lNameLen+lDomainLen+2;
              *pPrincName = (WCHAR *) PrivMemAlloc( lSize*sizeof(WCHAR) );
              pUserName   = (WCHAR *) _alloca( lNameLen*sizeof(WCHAR) );
              if (*pPrincName != NULL && pUserName != NULL)
              {
                 // Find the user's name.
                 fSuccess = LookupAccountSidW( NULL, pTokenUser->User.Sid,
                                                     pUserName, &lNameLen,
                                                     *pPrincName, &lDomainLen,
                                                     &sIgnore );
   
                 // If the call failed, try allocating more memory.
                 if (!fSuccess)
                 {
   
                    // Allocate memory for the user's name.
                    PrivMemFree( *pPrincName );
                    *pPrincName = (WCHAR *) PrivMemAlloc(
                                           (lNameLen+lDomainLen+1)*sizeof(WCHAR) );
                    pUserName   = (WCHAR *) _alloca(
                                           lNameLen*sizeof(WCHAR) );
                    if (*pPrincName != NULL && pUserName != NULL)
                    {
                       
                       // Find the user's name.
                       if (!LookupAccountSidW( NULL, pTokenUser->User.Sid,
                                               pUserName, &lNameLen,
                                               *pPrincName, &lDomainLen,
                                               &sIgnore ))
                          hr = MAKE_SCODE( SEVERITY_ERROR, FACILITY_WIN32, GetLastError() );
                    }
                    else
                       hr = E_OUTOFMEMORY;
                 }
              }
              else
                 hr = E_OUTOFMEMORY;
           }
        }
        else
            hr = MAKE_SCODE( SEVERITY_ERROR, FACILITY_WIN32, GetLastError() );
        CloseHandle( hToken );
    }
    else
        hr = MAKE_SCODE( SEVERITY_ERROR, FACILITY_WIN32, GetLastError() );

    // Restore the thread token.
    ResumeImpersonate( hThread );

    if (hr != S_OK)
    {
        PrivMemFree( *pPrincName );
        *pPrincName = NULL;
    }
    else if (!bUseFQDN) 
    {
        lstrcatW( *pPrincName, L"\\" );
        lstrcatW( *pPrincName, pUserName );
    }

    return hr;
}

//+-------------------------------------------------------------------
//
//  Function:   MakeSecDesc, private
//
//  Synopsis:   Make a security descriptor that allows the current user
//              and local system access.
//
//  NOTE: Compute the length of the sids used rather then using constants.
//
//--------------------------------------------------------------------
HRESULT MakeSecDesc( SECURITY_DESCRIPTOR **pSD, DWORD *pCapabilities )
{
    HRESULT            hr         = S_OK;
    ACL               *pAcl;
    DWORD              lSidLen;
    SID               *pGroup;
    SID               *pOwner;
    BYTE               aMemory[SIZEOF_TOKEN_USER];
    TOKEN_USER        *pTokenUser  = (TOKEN_USER *) &aMemory;
    HANDLE             hToken      = NULL;
    DWORD              lIgnore;
    HANDLE             hThread;

    Win4Assert( *pSD == NULL );

    // Open the process's token.
    if (!OpenProcessToken( GetCurrentProcess(), TOKEN_QUERY, &hToken ))
    {
        // If the thread has a token, remove it and try again.
        if (!OpenThreadToken( GetCurrentThread(), TOKEN_IMPERSONATE, TRUE,
                              &hThread ))
            return MAKE_SCODE( SEVERITY_ERROR, FACILITY_WIN32, GetLastError() );
        if (!SetThreadToken( NULL, NULL ))
        {
            hr = MAKE_SCODE( SEVERITY_ERROR, FACILITY_WIN32, GetLastError() );
            CloseHandle( hThread );
            return hr;
        }
        if (!OpenProcessToken( GetCurrentProcess(), TOKEN_QUERY, &hToken ))
            hr = MAKE_SCODE( SEVERITY_ERROR, FACILITY_WIN32, GetLastError() );
        Verify( SetThreadToken( NULL, hThread ) );
        CloseHandle( hThread );
        if (FAILED(hr))
            return hr;
    }

    // Lookup SID of process token.
    if (!GetTokenInformation( hToken, TokenUser, pTokenUser, sizeof(aMemory),
                                 &lIgnore ))
        goto last_error;

    // Compute the length of the SID.
    lSidLen = GetLengthSid( pTokenUser->User.Sid );
    Win4Assert( lSidLen <= SIZEOF_SID );

    // Allocate the security descriptor.
    *pSD = (SECURITY_DESCRIPTOR *) PrivMemAlloc(
                  sizeof(SECURITY_DESCRIPTOR) + 2*lSidLen + SIZEOF_ACL );
    if (*pSD == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto cleanup;
    }
    pGroup = (SID *) (*pSD + 1);
    pOwner = (SID *) (((BYTE *) pGroup) + lSidLen);
    pAcl   = (ACL *) (((BYTE *) pOwner) + lSidLen);

    // Initialize a new security descriptor.
    if (!InitializeSecurityDescriptor(*pSD, SECURITY_DESCRIPTOR_REVISION))
        goto last_error;

    // Initialize a new ACL.
    if (!InitializeAcl(pAcl, SIZEOF_ACL, ACL_REVISION2))
        goto last_error;

    // Allow the current user access.
    if (!AddAccessAllowedAce( pAcl, ACL_REVISION2, COM_RIGHTS_EXECUTE,
                              pTokenUser->User.Sid))
        goto last_error;

    // Allow local system access.
    if (!AddAccessAllowedAce( pAcl, ACL_REVISION2, COM_RIGHTS_EXECUTE,
                              (void *) &LOCAL_SYSTEM_SID ))
        goto last_error;

    // Add a new ACL to the security descriptor.
    if (!SetSecurityDescriptorDacl( *pSD, TRUE, pAcl, FALSE ))
        goto last_error;

    // Set the group.
    memcpy( pGroup, pTokenUser->User.Sid, lSidLen );
    if (!SetSecurityDescriptorGroup( *pSD, pGroup, FALSE ))
        goto last_error;

    // Set the owner.
    memcpy( pOwner, pTokenUser->User.Sid, lSidLen );
    if (!SetSecurityDescriptorOwner( *pSD, pOwner, FALSE ))
        goto last_error;

    // Check the security descriptor.
#if DBG==1
    if (!IsValidSecurityDescriptor( *pSD ))
    {
        Win4Assert( !"COM Created invalid security descriptor." );
        goto last_error;
    }
#endif

    goto cleanup;
last_error:
    hr = MAKE_SCODE( SEVERITY_ERROR, FACILITY_WIN32, GetLastError() );

cleanup:
    if (hToken != NULL)
        CloseHandle( hToken );
    if (FAILED(hr))
    {
        PrivMemFree( *pSD );
        *pSD = NULL;
    }
    return hr;
}

//+-------------------------------------------------------------------
//
//  Function:   OpenThreadTokenAtLevel
//
//  Synopsis:   Open the thread token and duplicate it to the specified
//              impersonation level.  If there is no thread token
//              return success and NULL.  If there is an identify
//              level token, return an error.
//
//--------------------------------------------------------------------
HRESULT OpenThreadTokenAtLevel( DWORD lImpReq, HANDLE *pToken )
{
    BOOL                         fSuccess;
    DWORD                        status     = S_OK;

    // COM+ 22868: This used to be like this. But this looks wrong,
    // since we need TOKEN_IMPERSONATE right to restore thread token.
    // Further, access to a token object is not the same as token
    // imp level. Access mask is property of a handle whereas imp level
    // is a property of a token object itself.
    //
    //DWORD                        dwOpen     = ImpLevelToAccess[lImpReq];

    DWORD                        dwOpen = TOKEN_QUERY | TOKEN_IMPERSONATE;
    DWORD                        dwOpenWithDup;
    SECURITY_IMPERSONATION_LEVEL eDuplicate = ImpLevelToSecLevel[lImpReq];
    HANDLE                       hThread;
    DWORD                        lImpTok;
    DWORD                        lIgnore;
    BOOL                         fClose;


    // Open the thread token, first with TOKEN_DUPLICATE since some code paths
    // require that we dup the token:
    *pToken = NULL;
    dwOpenWithDup = dwOpen | TOKEN_DUPLICATE;
    fSuccess= OpenThreadToken( GetCurrentThread(), dwOpenWithDup, TRUE, &hThread );
    if (!fSuccess)
    {
      // Hmm.  For some reason we failed to get the thread token with
      // TOKEN_DUPLICATE.    Well, for some cases this will not be fatal.  Try
      // again without it, and maybe things will work:
      fSuccess= OpenThreadToken( GetCurrentThread(), dwOpen, TRUE, &hThread );
    }

    if (fSuccess)
    {
        // Remove the thread token.  Ignore errors.
        fClose = TRUE;
        Verify( SetThreadToken( NULL, NULL ) );

        // Check the impersonation level.
        fSuccess = GetTokenInformation( hThread, TokenImpersonationLevel,
                                        &lImpTok, sizeof(lImpTok), &lIgnore );

        if (fSuccess)
        {
            // Don't allow identify level tokens.
            if (lImpTok < SecurityImpersonation)
                status = RPC_E_ACCESS_DENIED;

            else
            {
                // If the impersonation level is correct, return the
                // current token.
                if (lImpTok+1 <= lImpReq)
                {
                    *pToken = hThread;
                    fClose  = FALSE;
                }

                // Duplication the token to the correct level.
                else
                    fSuccess = DuplicateToken( hThread, eDuplicate, pToken );
            }
        }

        // Restore the thread token.  Ignore errors.
        Verify( SetThreadToken( NULL, hThread ) );

        // Close the thread token.  Ignore errors.
        if (fClose)
            CloseHandle( hThread );
    }

    // Convert a status code to a HRESULT and convert ERROR_NO_TOKEN to
    // success.
    if (!fSuccess)
    {
        status = GetLastError();
        if (status != ERROR_NO_TOKEN)
            return MAKE_WIN32( status );
        else
            return S_OK;
    }
    return status;
}

//+-------------------------------------------------------------------
//
//  Function:   RegisterAuthnServices, public
//
//  Synopsis:   Register the specified services.  Build a security
//              binding.
//
//--------------------------------------------------------------------
HRESULT RegisterAuthnServices(  DWORD                        cAuthSvc,
                                SOLE_AUTHENTICATION_SERVICE *asAuthSvc )
{
    DWORD                        i;
    RPC_STATUS                   sc;
    USHORT                       wNumEntries = 0;
    USHORT                      *pNext;
    HRESULT                      hr;
    DWORD                        lNameLen;
    WCHAR                       *pSSL        = NULL;
    WCHAR                       *pPrincipal;
    const CERT_CONTEXT           *pCert;
    SOLE_AUTHENTICATION_SERVICE *pService    = asAuthSvc;
    WCHAR                       *pArg        = NULL;

    ASSERT_LOCK_HELD(gComLock);

    // Register all the authentication services specified.
    for (i = 0; i < cAuthSvc; i++)
    {
        // Validate the parameters.
        pPrincipal = pService->pPrincipalName;
        if (pPrincipal == COLE_DEFAULT_PRINCIPAL        ||
            pService->dwAuthnSvc == RPC_C_AUTHN_DEFAULT ||
            pService->dwAuthzSvc == RPC_C_AUTHZ_DEFAULT)
            hr = E_INVALIDARG;

        // Determine a principal name for SSL.
        else if (pService->dwAuthnSvc == RPC_C_AUTHN_GSS_SCHANNEL)
        {
#ifndef SSL
            // Don't allow SSL until bug fixes are checked in.
            hr = MAKE_SCODE( SEVERITY_ERROR, FACILITY_WIN32, RPC_S_UNKNOWN_AUTHN_SERVICE );
#else
            // If no certificate is specified, try to find a default.
            if (pPrincipal == NULL)
                hr = CSSL::DefaultCert( &pCert );
            else
            {
                pCert = (PCCERT_CONTEXT) pPrincipal;
                if (pCert == NULL)
                    hr = E_INVALIDARG;
                else
                    hr = S_OK;
            }

            // For SSL we need to pass a NULL principal name to RPC
            pPrincipal = NULL;
            
            // Initialize the schannel credential structure.
            memset( &gSchannelCred, 0, sizeof(gSchannelCred) );
            gSchannelContext        = pCert;
            gSchannelCred.dwVersion = SCHANNEL_CRED_VERSION;
            gSchannelCred.cCreds    = 1;
            gSchannelCred.paCred    = &gSchannelContext;
            pArg                    = (WCHAR *) &gSchannelCred;

            // Compute the principal name from the certificate.
            if (SUCCEEDED(hr))
            {
                hr = CSSL::PrincipalName( pCert, &pSSL );  
            }
#endif
        }
        else
        {
            pArg = NULL;
            hr = S_OK;
        }

        // Register the authentication service.
        if (SUCCEEDED(hr))
        {
            sc = RpcServerRegisterAuthInfoW( pPrincipal, pService->dwAuthnSvc,
                                             NULL, pArg );

            // If the registration failed, store the failure code.
            if (sc != RPC_S_OK)
                hr = MAKE_SCODE( SEVERITY_ERROR, FACILITY_WIN32, sc );
        }

        // If everything is ok for this entry, determine how much space to
        // reserve.
        if (SUCCEEDED(hr))
        {
            // For SSL we registered the cert, not the principal name.
            if (pService->dwAuthnSvc == RPC_C_AUTHN_GSS_SCHANNEL)
                pPrincipal = pSSL;
            
            // Find the length of the security binding with or without a
            // principal name.
            pService->hr = S_OK;
            if (pPrincipal != NULL)
                wNumEntries += (USHORT) lstrlenW( pPrincipal ) + 3;
            else
                wNumEntries += 3;
        }

        // Save any failure codes.
        else
            pService->hr = hr;

        pService += 1;
    }

    // It is an error for all registrations to fail.
    if (wNumEntries == 0)
        hr = RPC_E_NO_GOOD_SECURITY_PACKAGES;

    // If some services were registered, build a string array.
    else
    {
        // Make room for the two NULLs that placehold for the empty
        // string binding and the trailing NULL.
        wNumEntries += 3;
        gpsaSecurity = (DUALSTRINGARRAY *) PrivMemAlloc(
                     wNumEntries*sizeof(USHORT) + sizeof(DUALSTRINGARRAY) );
        if (gpsaSecurity == NULL)
            hr = E_OUTOFMEMORY;
        else
        {
            gpsaSecurity->wNumEntries     = wNumEntries;
            gpsaSecurity->wSecurityOffset = 2;
            gpsaSecurity->aStringArray[0] = 0;
            gpsaSecurity->aStringArray[1] = 0;
            pNext                         = &gpsaSecurity->aStringArray[2];
            pService                      = asAuthSvc;

            for (i = 0; i < cAuthSvc; i++)
            {
                if (pService->hr == S_OK)
                {
                    // Fill in authentication service, authorization service,
                    // and principal name.
                    *(pNext++) = (USHORT) pService->dwAuthnSvc;
                    *(pNext++) = (USHORT) (pService->dwAuthzSvc == 0 ?
                                                  COM_C_AUTHZ_NONE :
                                                  pService->dwAuthzSvc);

                    // For SLL principal name is from the certificate
                    if (pService->dwAuthnSvc != RPC_C_AUTHN_GSS_SCHANNEL)
                    {
                        pPrincipal = pService->pPrincipalName;
                    }
                    else
                    {
                        pPrincipal = pSSL;
                    }
            
            
                    if (pPrincipal != NULL)
                    {
                        lNameLen = lstrlenW( pPrincipal ) + 1;
                        memcpy( pNext, pPrincipal, lNameLen*sizeof(USHORT) );
                        pNext += lNameLen;
                        
                    }
                    else
                        *(pNext++) = 0;
                }
                pService += 1;
            }
            *pNext = 0;

            hr = S_OK;
        }
    }

    // Free interm strings.
    RpcStringFree( &pSSL );
    ASSERT_LOCK_HELD(gComLock);
    return hr;
}

//+-------------------------------------------------------------------
//
//  Function:   RemoteAuthnService
//
//  Synopsis:   Returns the index of the specified authentication
//              service in the specified dual string array or -1.
//
//--------------------------------------------------------------------
DWORD RemoteAuthnService( USHORT wAuthnService, DUALSTRINGARRAY *pRemote )
{
    DWORD l;

    // Loop over all the security elements.
    l = pRemote->wSecurityOffset;
    while (pRemote->aStringArray[l] != 0)
        if (pRemote->aStringArray[l] == wAuthnService)
            return l;
        else
            l += lstrlenW( (LPCWSTR)&pRemote->aStringArray[l] ) + 1;
    return -1;
}



//+-------------------------------------------------------------------
//
//  Function:   StrEscByteCnt
//
//  Synopsis:   Return the number of bytes of memory needed to hold
//              the specified string including the null terminator
//              and add space so StrEscCopy can replace all slashes
//              with double slashes
//
//--------------------------------------------------------------------
DWORD StrEscByteCnt( WCHAR *pStr )
{
    DWORD cLen = 2;

    while (*pStr != 0)
    {
        if (*pStr == '\\')
            cLen += 4;
        else
            cLen += 2;
        pStr += 1;
    }
    return cLen;
}

//+-------------------------------------------------------------------
//
//  Function:   StrEscCopy
//
//  Synopsis:   Return the number of bytes of memory needed to hold
//              the specified string including the null terminator
//              and replacing all slashes with double slashes.  Return
//              a pointer to the null terminator in the destinition
//              string.
//
//--------------------------------------------------------------------
WCHAR *StrEscCopy( WCHAR *pDest, WCHAR *pSrc )
{
    WCHAR c;

    // Copy the source and escape any slashes.
    while ((c = *pSrc++) != 0)
        if (c == '\\')
        {
            *pDest++ = '\\';
            *pDest++ = '\\';
        }
        else
            *pDest++ = c;

    // Add the final null terminiation.
    *pDest = 0;
    return pDest;
}

//+-------------------------------------------------------------------
//
//  Function:   StrQual
//
//  Synopsis:   Find a CN= or E= prefix in the specified string.
//              Return a pointer to the string after the prefix.
//              Replace the next comma with a NULL.
//
//--------------------------------------------------------------------
WCHAR *StrQual( WCHAR *pSubject, BOOL *pEmail )
{
    WCHAR *pComma;
    WCHAR *pEqual = &pSubject[1];

    // Fail if the string is empty.
    if (pSubject == NULL || pSubject[0] == '\0')
        return NULL;

    // Check each equal sign.
    while (pEqual != NULL)
    {
        // Find the next equal sign.
        pEqual = wcschr( pEqual, L'=' );

        if (pEqual != NULL)
        {
            if (pEqual[-1] == L'e' || pEqual[-1] == L'E')
            {
                *pEmail = TRUE;
                break;
            }
            if ((pEqual[-1] == L'n' || pEqual[-1] == L'N') &&
                pEqual - pSubject > 1)
                if (pEqual[-2] == 'c' || pEqual[-2] == 'C')
                {
                    *pEmail = FALSE;
                    break;
                }

            // Skip past the equal sign.
            pEqual += 1;
        }
    }

    // If a match was found, null terminate it.
    if (pEqual != NULL)
    {
        pComma = wcschr( pEqual, L',' );
        if (pComma != NULL)
            *pComma = 0;
        return pEqual + 1;
    }
    return NULL;
}

//+-------------------------------------------------------------------
//
//  Function:   GetAuthnSvcIndexForBinding
//
//  Synopsis:   Find the index of the specified authentication service
//              in the specified security binding.
//
//--------------------------------------------------------------------
DWORD GetAuthnSvcIndexForBinding ( DWORD lAuthnSvc, DUALSTRINGARRAY *pBinding )
{
    USHORT wNext;

    // Return zero for process local bindings.
    if (pBinding == NULL)
        return 0;

    // Loop over the security binding.
    wNext = pBinding->wSecurityOffset;
    while (wNext < pBinding->wNumEntries &&
           pBinding->aStringArray[wNext] != 0)
    {
        // Return the index of the authentication service.
        if (pBinding->aStringArray[wNext] == lAuthnSvc)
            return wNext;

        // Skip to the next authentication service.
        wNext += (USHORT) lstrlenW( (LPCWSTR)&pBinding->aStringArray[wNext] ) + 1;
    }

    // The authentication service isn't in the list.  Return a bad index.
    return pBinding->wNumEntries;
}
//+----------------------------------------------------------------------------
//
//  Function:      GetFirstAuthnSvcIndex
//
//  Synopsis:      Helper function to get the offset of the first authn svc
//                 in the binding.
//
//-----------------------------------------------------------------------------

DWORD GetFirstAuthnSvcIndex (DUALSTRINGARRAY *pBinding )
{
   USHORT wNext = 0;
   if (pBinding != NULL)
      wNext = pBinding->wSecurityOffset;
   return wNext;
}

//+-------------------------------------------------------------------
//
//  Function:   UninitializeSecurity, internal
//
//  Synopsis:   Free resources allocated while initializing security.
//
//--------------------------------------------------------------------
void UninitializeSecurity()
{
    DWORD i;

    ASSERT_LOCK_NOT_HELD(gComLock);
    LOCK(gComLock);

    PrivMemFree(gSecDesc);
    PrivMemFree(gpsaSecurity);
#ifndef SHRMEM_OBJEX
    for (i = 0; i < gClientSvcListLen; i++)
        MIDL_user_free( gClientSvcList[i].pName );
    MIDL_user_free( gClientSvcList );
    MIDL_user_free( gServerSvcList );
    MIDL_user_free( gLegacySecurity );
#else // SHRMEM_OBJEX
    delete [] gClientSvcList;
    delete [] gServerSvcList;
    delete [] gLegacySecurity;
#endif // SHRMEM_OBJEX
    for (i = 0; i < ACCESS_CACHE_LEN; i++)
    {
        gAccessCache[i].lClient.LowPart  = 0;
        gAccessCache[i].lClient.HighPart = 0;
    }
    if (gAccessControl != NULL)
        gAccessControl->Release();

    CAuthInfo::Cleanup();
    CSSL::Cleanup();
    gAccessControl         = NULL;
    gSecDesc               = NULL;
    gAuthnLevel            = RPC_C_AUTHN_LEVEL_NONE;
    gImpLevel              = RPC_C_IMP_LEVEL_IDENTIFY;
    gCapabilities          = EOAC_NONE;
    gLegacySecurity        = NULL;
    gpsaSecurity           = NULL;
    gClientSvcList         = NULL;
    gServerSvcList         = NULL;
    gClientSvcListLen      = 0;
    gGotSecurityData       = FALSE;
    gDefaultService        = FALSE;
    gMostRecentAccess      = 0;

    UNLOCK(gComLock);
    ASSERT_LOCK_NOT_HELD(gComLock);
}

//+-------------------------------------------------------------------
//
//  Function:   RPCSStoOLE32SecurityCallback
//
//  Synopsis:   RPC security callback function for non RPC_IF_OLE 
//              interfaces.
//
//  Notes:      Use this callback function on all private RPCSS->OLE32
//              RPC interfaces.  This allows us to centralize the 
//              checking logic rather than having it scattered across
//              each individual method.
//
//  History:    12-Mar-02       Jsimmons    Created
//
//--------------------------------------------------------------------
RPC_STATUS RPC_ENTRY RPCSStoOLE32SecurityCallback(
                                IN RPC_IF_HANDLE Interface,
                                IN void *Context
                                ) 
{
    RPC_STATUS status = 0;
    DWORD dwCallerPID = 0;
    UINT type = 0;

    Win4Assert(Context);

    // Call should always be coming from a local client
    status = I_RpcBindingInqTransportType(Context, &type);
    if ((status != RPC_S_OK) || (type != TRANSPORT_TYPE_LPC))
        return RPC_S_ACCESS_DENIED;

    // Make sure that the pid of the caller matches what we got
    // back when we first connected to RPCSS.
    status = I_RpcBindingInqLocalClientPID(Context, &dwCallerPID);
    if (status != RPC_S_OK)
        return RPC_S_ACCESS_DENIED;

    if (dwCallerPID != gdwScmProcessID)
        return RPC_S_ACCESS_DENIED;

    // RPCSS is always supposed to call us back using the SYSTEM
    // identity, at an IDENTIFY level of impersonation.  These asserts
    // are meant to catch any flaws in the implementation of that policy.
    Win4Assert(VerifyCallerIsLocalSystem(Context));
    Win4Assert(VerifyCallersImpLevel(Context, SecurityIdentification));

    // okay
    return RPC_S_OK;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\com\dcomrem\stream.cxx ===
/*++

Microsoft Windows
Copyright (c) 1994 Microsoft Corporation.  All rights reserved.

Module Name:
    stream.cxx

Abstract:
    Implements the IStream interface on a memory buffer.

Author:
    ShannonC    09-Mar-1994

Environment:
    Windows NT and Windows 95.  We do not support DOS and Win16.

Revision History:
    12-Oct-94   ShannonC    Reformat for code review.

--*/

#include <ole2int.h>
#include <stream.hxx>

CNdrStream::CNdrStream(
    IN  unsigned char * pData,
    IN  unsigned long   cbMax)
    : pBuffer(pData), cbBufferLength(cbMax)
/*++

Routine Description:
    This function creates a stream on the specified memory buffer.

Arguments:
    pData - Supplies pointer to memory buffer.
    cbMax - Supplies size of memory buffer.

Return Value:
    None.

--*/
{
    RefCount = 1;
    position = 0;
}


ULONG STDMETHODCALLTYPE
CNdrStream::AddRef()
/*++

Routine Description:
    Increment the reference count.

Arguments:

Return Value:
    Reference count.

--*/
{
    InterlockedIncrement(&RefCount);
    return (ULONG) RefCount;
}

HRESULT STDMETHODCALLTYPE
CNdrStream::Clone(
    OUT IStream **ppstm)
/*++

Routine Description:
    Create a new IStream object.  The new IStream gets an
    independent seek pointer but it shares the underlying
    data buffer with the original IStream object.

Arguments:
    ppstm - Pointer to the new stream.

Return Value:
    S_OK            - The stream was successfully copied.
    E_OUTOFMEMORY   - The stream could not be copied due to lack of memory.

--*/
{
    HRESULT     hr;
    CNdrStream *pStream = new CNdrStream(pBuffer, cbBufferLength);

    if(pStream != 0)
    {
        pStream->position = position;
        hr = S_OK;
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    *ppstm = (IStream *) pStream;

    return hr;
}

HRESULT STDMETHODCALLTYPE
CNdrStream::Commit(
    IN DWORD grfCommitFlags)
/*++

Routine Description:
    This stream does not support transacted mode.  This function does nothing.

Arguments:
    grfCommitFlags

Return Value:
    S_OK

--*/
{
  return S_OK;
}

HRESULT STDMETHODCALLTYPE
CNdrStream::CopyTo(
    IN  IStream *       pstm,
    IN  ULARGE_INTEGER  cb,
    OUT ULARGE_INTEGER *pcbRead,
    OUT ULARGE_INTEGER *pcbWritten)
/*++

Routine Description:
    Copies data from one stream to another stream.

Arguments:
    pstm        - Specifies the destination stream.
    cb          - Specifies the number of bytes to be copied to the destination stream.
    pcbRead     - Returns the number of bytes read from the source stream.
    pcbWritten  - Returns the number of bytes written to the destination stream.

Return Value:
    S_OK        - The data was successfully copied.
    Other errors from IStream::Write.

--*/
{
    HRESULT         hr;
    unsigned char * pSource;
    unsigned long   cbRead;
    unsigned long   cbWritten;
    unsigned long   cbRemaining;

    //Check if we are going off the end of the buffer.
    if(position < cbBufferLength)
        cbRemaining = cbBufferLength - position;
    else
        cbRemaining = 0;

    if((cb.HighPart == 0) && (cb.LowPart <= cbRemaining))
        cbRead = cb.LowPart;
    else
        cbRead = cbRemaining;

    pSource = pBuffer + position;

    //copy the data
    hr = pstm->Write(pSource, cbRead, &cbWritten);

    //advance the current position
    position += cbRead;

    if (pcbRead != 0)
    {
        pcbRead->LowPart = cbRead;
        pcbRead->HighPart = 0;
    }
    if (pcbWritten != 0)
    {
        pcbWritten->LowPart = cbWritten;
        pcbWritten->HighPart = 0;
    }

    return hr;
}

HRESULT STDMETHODCALLTYPE
CNdrStream::LockRegion(
    IN ULARGE_INTEGER   libOffset,
    IN ULARGE_INTEGER   cb,
    IN DWORD            dwLockType)
/*++

Routine Description:
    Range locking is not supported by this stream.

Return Value:
    STG_E_INVALIDFUNCTION.

--*/
{
    return STG_E_INVALIDFUNCTION;
}

HRESULT STDMETHODCALLTYPE
CNdrStream::QueryInterface(
    REFIID riid,
    void **ppvObj)
/*++

Routine Description:
    Query for an interface on the stream.  The stream supports
    the IUnknown and IStream interfaces.

Arguments:
    riid        - Supplies the IID of the interface being requested.
    ppvObject   - Returns a pointer to the requested interface.

Return Value:
    S_OK
    E_NOINTERFACE

--*/
{
    HRESULT hr;

    if ((memcmp(&riid, &IID_IUnknown, sizeof(IID)) == 0) ||
       (memcmp(&riid, &IID_IStream, sizeof(IID)) == 0))
    {
        this->AddRef();
        *ppvObj = (IStream *) this;
        hr = S_OK;
    }
    else
    {
        *ppvObj = 0;
        hr = E_NOINTERFACE;
    }

    return hr;
}

HRESULT STDMETHODCALLTYPE
CNdrStream::Read(
    OUT void * pv,
    IN  ULONG  cb,
    OUT ULONG *pcbRead)
/*++

Routine Description:
    Reads data from the stream starting at the current seek pointer.

Arguments:
    pv      - Returns the data read from the stream.
    cb      - Supplies the number of bytes to read from the stream.
    pcbRead - Returns the number of bytes actually read from the stream.

Return Value:
    S_OK    - The data was successfully read from the stream.
    S_FALSE - The number of bytes read was smaller than the number requested.

--*/
{
    HRESULT         hr;
    unsigned long   cbRead;
    unsigned long   cbRemaining;

    //Check if we are reading past the end of the buffer.
    if(position < cbBufferLength)
        cbRemaining = cbBufferLength - position;
    else
        cbRemaining = 0;

    if(cb <= cbRemaining)
    {
        cbRead = cb;
        hr = S_OK;
    }
    else
    {
        cbRead = cbRemaining;
        hr = S_FALSE;
    }

    //copy the data
    memcpy(pv, pBuffer + position, cbRead);

    //advance the current position
    position += cbRead;

    if(pcbRead != 0)
        *pcbRead = cbRead;

    return hr;
}

ULONG STDMETHODCALLTYPE
CNdrStream::Release()
/*++

Routine Description:
    Decrement the reference count.  When the reference count
    reaches zero, the stream is deleted.

Arguments:

Return Value:
    Reference count.

--*/
{
    ULONG count = InterlockedDecrement(&RefCount);

    if(count == 0)
    {
        delete this;
    }

    return count;
}


HRESULT STDMETHODCALLTYPE
CNdrStream::Revert()
/*++

Routine Description:
    This stream does not support transacted mode.  This function does nothing.

Arguments:
    None.

Return Value:
    S_OK.

--*/
{
  return S_OK;
}

HRESULT STDMETHODCALLTYPE
CNdrStream::Seek(
    IN  LARGE_INTEGER   dlibMove,
    IN  DWORD           dwOrigin,
    OUT ULARGE_INTEGER *plibNewPosition)
/*++

Routine Description:
    Sets the position of the seek pointer.  It is an error to seek
    before the beginning of the stream or past the end of the stream.

Arguments:
    dlibMove        - Supplies the offset from the position specified in dwOrigin.
    dwOrigin        - Supplies the seek mode.
    plibNewPosition - Returns the new position of the seek pointer.

Return Value:
    S_OK                    - The seek pointer was successfully adjusted.
    STG_E_INVALIDFUNCTION   - dwOrigin contains invalid value.
    STG_E_SEEKERROR         - The seek pointer cannot be positioned before the
                              beginning of the stream or past the
                              end of the stream.

--*/
{
    HRESULT         hr;
    long            high;
    long            low;
    unsigned long   offset;
    unsigned long   cbRemaining;

    switch (dwOrigin)
    {
    case STREAM_SEEK_SET:
        //Set the seek position relative to the beginning of the stream.
        if((dlibMove.HighPart == 0) && (dlibMove.LowPart <= cbBufferLength))
        {
            position = dlibMove.LowPart;
            hr = S_OK;
        }
        else
        {
            //It is an error to seek past the end of the stream.
            hr = STG_E_SEEKERROR;
        }
        break;

    case STREAM_SEEK_CUR:
        //Set the seek position relative to the current position of the stream.
        high = (long) dlibMove.HighPart;
        if(high < 0)
        {
            //Negative offset
            low = (long) dlibMove.LowPart;
            offset = -low;

            if((high == -1) && (offset <= position))
            {
                position -= offset;
                hr = S_OK;
            }
            else
            {
                //It is an error to seek before the beginning of the stream.
                hr = STG_E_SEEKERROR;
            }
        }
        else
        {
            //Positive offset
            if(position < cbBufferLength)
                cbRemaining = cbBufferLength - position;
            else
                cbRemaining = 0;

            if((dlibMove.HighPart == 0) && (dlibMove.LowPart <= cbRemaining))
            {
                position += dlibMove.LowPart;
                hr = S_OK;
            }
            else
            {
                //It is an error to seek past the end of the stream.
                hr = STG_E_SEEKERROR;
            }
        }
        break;

    case STREAM_SEEK_END:
    //Set the seek position relative to the end of the stream.
        high = (long) dlibMove.HighPart;
        if(high < 0)
        {
            //Negative offset
            low = (long) dlibMove.LowPart;
            offset = -low;

            if((high == -1) && (offset <= cbBufferLength))
            {
                position = cbBufferLength - offset;
                hr = S_OK;
            }
            else
            {
                //It is an error to seek before the beginning of the stream.
                hr = STG_E_SEEKERROR;
            }
        }
        else if(dlibMove.QuadPart == 0)
        {
            position = cbBufferLength;
            hr = S_OK;
        }
        else
        {
            //Positive offset
            //It is an error to seek past the end of the stream.
            hr = STG_E_SEEKERROR;
        }
        break;

    default:
        //dwOrigin contains an invalid value.
        hr = STG_E_INVALIDFUNCTION;
    }

    if (plibNewPosition != 0)
    {
        plibNewPosition->LowPart = position;
        plibNewPosition->HighPart = 0;
    }

    return hr;
}

HRESULT STDMETHODCALLTYPE
CNdrStream::SetSize(
    IN ULARGE_INTEGER libNewSize)
/*++

Routine Description:
    Changes the size of the stream.

Arguments:
    libNewSize - Supplies the new size of the stream.

Return Value:
    S_OK                - The stream size was successfully changed.
    STG_E_MEDIUMFULL    - The stream size could not be changed.

--*/
{
    HRESULT hr;

    if((libNewSize.HighPart == 0) && (libNewSize.LowPart <= cbBufferLength))
    {
        cbBufferLength = libNewSize.LowPart;
        hr = S_OK;
    }
    else
    {
        hr = STG_E_MEDIUMFULL;
    }

    return hr;
}

HRESULT STDMETHODCALLTYPE
CNdrStream::Stat(
    OUT STATSTG *   pstatstg,
    IN  DWORD       grfStatFlag)
/*++

Routine Description:
    This function gets information about this stream.

Arguments:
    pstatstg    - Returns information about this stream.
    grfStatFlg  - Specifies the information to be returned in pstatstg.

Return Value:
    S_OK.

--*/
{
    memset(pstatstg, 0, sizeof(STATSTG));
    pstatstg->type = STGTY_STREAM;
    pstatstg->cbSize.LowPart = cbBufferLength;
    pstatstg->cbSize.HighPart = 0;

    return S_OK;
}

HRESULT STDMETHODCALLTYPE
CNdrStream::UnlockRegion(
    IN ULARGE_INTEGER   libOffset,
    IN ULARGE_INTEGER   cb,
    IN DWORD            dwLockType)
/*++

Routine Description:
    Range locking is not supported by this stream.

Return Value:
    STG_E_INVALIDFUNCTION.

--*/
{
    return STG_E_INVALIDFUNCTION;
}

HRESULT STDMETHODCALLTYPE
CNdrStream::Write(
    IN  void const *pv,
    IN  ULONG       cb,
    OUT ULONG *     pcbWritten)
/*++

Routine Description:
    Write data to the stream starting at the current seek pointer.

Arguments:
    pv          - Supplies the data to be written to the stream.
    cb          - Specifies the number of bytes to be written to the stream.
    pcbWritten  - Returns the number of bytes actually written to the stream.

Return Value:
    S_OK                - The data was successfully written to the stream.
    STG_E_MEDIUMFULL    - Data cannot be written past the end of the stream.

--*/
{
    HRESULT         hr;
    unsigned long   cbRemaining;
    unsigned long   cbWritten;

    //Check if we are writing past the end of the buffer.
    if(position < cbBufferLength)
        cbRemaining = cbBufferLength - position;
    else
        cbRemaining = 0;

    if(cb <= cbRemaining)
    {
        cbWritten = cb;
        hr = S_OK;
    }
    else
    {
        cbWritten = cbRemaining;
        hr = STG_E_MEDIUMFULL;
    }

    // Write the data.
    memcpy(pBuffer + position, pv, cbWritten);

    //Advance the current position
    position += cbWritten;

    //update pcbWritten
    if (pcbWritten != 0)
        *pcbWritten = cbWritten;

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\com\dcomrem\stdid.cxx ===
//+-------------------------------------------------------------------
//
//  File:       stdid.cxx
//
//  Contents:   identity object and creation function
//
//  History:     1-Dec-93   CraigWi     Created
//              13-Sep-95   Rickhi      Simplified
//
//--------------------------------------------------------------------
#include <ole2int.h>

#include <stdid.hxx>        // CStdIdentity
#include <marshal.hxx>      // CStdMarshal
#include <ctxchnl.hxx>      // Context channel
#include "callmgr.hxx"
#include <excepn.hxx>       // Exception filter routines

#include "..\objact\objact.hxx"  // used in IProxyManager::CreateServer
#include "crossctx.hxx"     // ObtainPolicySet


#if DBG==1
// head of linked list of identities for debug tracking purposes
CStdIdentity gDbgIDHead;
#endif  // DBG


//+----------------------------------------------------------------
//
//  Class:      CStdIdentity (stdid)
//
//  Purpose:    To be the representative of the identity of the object.
//
//  History:    11-Dec-93   CraigWi     Created.
//              21-Apr-94   CraigWi     Stubmgr addref's object; move strong cnt
//              10-May-94   CraigWi     IEC called for strong connections
//              17-May-94   CraigWi     Container weak connections
//              31-May-94   CraigWi     Tell object of weak pointers
//
//  Details:
//
//  The identity is determined on creation of the identity object. On the
//  server side a new OID is created, on the client side, the OID contained
//  in the OBJREF is used.
//
//  The identity pointer is typically stored in the OIDTable, NOT AddRef'd.
//  SetOID adds the identity to the table, and can be called from ctor or
//  from Unmarshal. RevokeOID removes the identity from the table, and can
//  be called from Disconnect, or final Release.
//
//--------------------------------------------------------------------

//+-------------------------------------------------------------------
//
//  Member:     CStdIdentity::CStdIdentity, private
//
//  Synopsis:   ctor for identity object
//
//  Arguments:  for all but the last param, see CreateIdentityHandler.
//              [ppUnkInternal] --
//                  when aggregated, this the internal unknown;
//                  when not aggregated, this is the controlling unknown
//
//  History:    15-Dec-93   CraigWi     Created.
//              12-Dec-96   Gopalk      Initialize connection status
//              22-Apr-98   SatishT     Control QI for IExternalConnection
//--------------------------------------------------------------------
CStdIdentity::CStdIdentity(DWORD flags, DWORD dwAptId, IUnknown *pUnkOuter,
                IUnknown *pUnkControl, IUnknown **ppUnkInternal, BOOL *pfSuccess) :
    m_refs(1),
    m_cStrongRefs(0),
    m_cWeakRefs(0),
    m_flags(flags),
    m_pIEC(NULL),
    m_moid(GUID_NULL),
    m_ConnStatus(S_OK),
    m_dwAptId(dwAptId),
    m_pUnkOuter((pUnkOuter) ? pUnkOuter : (IMultiQI *)&m_InternalUnk),
    m_pUnkControl((pUnkControl) ? pUnkControl : m_pUnkOuter),
    CClientSecurity( this ),
    CRpcOptions(this, m_pUnkOuter)
{
    ComDebOut((DEB_MARSHAL, "CStdIdentity %s Created this:%x\n",
                IsClient() ? "CLIENT" : "SERVER", this));
    Win4Assert(!!IsClient() == (pUnkControl == NULL));
    Win4Assert(pfSuccess != NULL);

    *pfSuccess = TRUE;

#if DBG==1
    // Chain this identity onto the global list of instantiated identities
    // so we can track even the ones that are not placed in the ID table.
    LOCK(gComLock);
    m_pNext            = gDbgIDHead.m_pNext;
    m_pPrev            = &gDbgIDHead;
    gDbgIDHead.m_pNext = this;
    m_pNext->m_pPrev   = this;
    UNLOCK(gComLock);
#endif

    if (pUnkOuter)
    {
        m_flags |= STDID_AGGREGATED;
    }

    CLSID clsidHandler;
    DWORD dwSMFlags = SMFLAGS_CLIENT_SIDE;  // assume client side

    if (!IsClient())
    {
#if DBG == 1
        // the caller should have a strong reference and so these tests
        // should not disturb the object. These just check the sanity of
        // the object we are attempting to marshal.

        // addref/release pUnkControl; shouldn't go away (i.e.,
        // should be other ref to it).
        {
            pUnkControl->AddRef();
            if (pUnkControl->Release() == 0  &&
                !IsTaskName(L"EXCEL.EXE")    &&
                !IsTaskName(L"EXPLORER.EXE") &&
                !IsTaskName(L"IEXPLORE.EXE") &&
                !IsTaskName(L"DLLHOST.EXE"))
            {
                // Do this only if it is not Excel or Explorer as they always
                // return 0 which will trigger the assert on debug builds
                // unnecessarily!

                Win4Assert(!"pUnkControl incorrect refcnt");
            }

            // verify that pUnkControl is in fact the controlling unknown
            IUnknown *pUnkT;
            Verify(pUnkControl->QueryInterface(IID_IUnknown,(void **)&pUnkT)==NOERROR);
            Win4Assert(pUnkControl == pUnkT);
            if (pUnkT->Release() == 0        &&
                !IsTaskName(L"EXCEL.EXE")    &&
                !IsTaskName(L"EXPLORER.EXE") &&
                !IsTaskName(L"IEXPLORE.EXE") &&
                !IsTaskName(L"DLLHOST.EXE"))
            {
                // Do this only if it is not Excel or Explorer as they always
                // return 0 which will trigger the assert on debug builds
                // unnecessarily!

                Win4Assert(!"pUnkT incorrect refcnt");
            }
        }
#endif

        dwSMFlags = 0;      // server side
        if(!IsAggregated())
        {
            // If aggregated the aggregation rules dictate that we
            // don't need to AddRef.
            m_pUnkControl->AddRef();
        }

        // determine if we will write a standard or handler objref. we write
        // standard unless the object implements IStdMarshalInfo and overrides
        // the standard class. we ignore all errors from this point onward in
        // order to maintain backward compatibility.

        ASSERT_LOCK_NOT_HELD(gComLock);

        IStdMarshalInfo *pSMI;
        HRESULT hr = m_pUnkControl->QueryInterface(IID_IStdMarshalInfo,
                                                   (void **)&pSMI);
        if (SUCCEEDED(hr))
        {
            hr = pSMI->GetClassForHandler(NULL, NULL, &clsidHandler);
            if (SUCCEEDED(hr) && !IsEqualCLSID(clsidHandler, CLSID_NULL))
            {
                dwSMFlags |= SMFLAGS_HANDLER;

                if (IsAggregated())
                {
                    // server side aggregated StdMarshal & outer unk
                    // provides a handler, so use CLSID_AggStdMarshal
                    dwSMFlags |= SMFLAGS_USEAGGSTDMARSHAL;
                }
            }
            else
            {
                clsidHandler = GUID_NULL;
            }
            pSMI->Release();
        }

        // look for the IExternalConnection interface. The StdId will use
        // this for Inc/DecStrongCnt. We do the QI here while we are not
        // holding the LOCK.

        if (!(flags & STDID_NOIEC))
        {
            hr = m_pUnkControl->QueryInterface(IID_IExternalConnection,
                                               (void **)&m_pIEC);
            if(SUCCEEDED(hr))
            {
                if(IsAggregated())
                {
                    // Follow aggregation rules and don't hold a
                    // reference to the server.
                    m_pUnkControl->Release();
                }
            }
            else
            {
                // make sure it is NULL
                m_pIEC = NULL;
            }
        }
        else
        {
            // make sure it is NULL
            m_pIEC = NULL;
        }

        if (!(m_flags & STDID_IGNOREID))
        {
            // Look for the IMarshalOptions interface, and if supported query
            // for any marshal options specified by the client.  This is a 
            // private mechanism used by COM+ only.
            IMarshalOptions* pIMrshlOpts = NULL;
            hr = m_pUnkControl->QueryInterface(IID_IMarshalOptions, (void**)&pIMrshlOpts);
            if (SUCCEEDED(hr))
            {
                DWORD dwMarshalFlags = 0;
                Win4Assert(pIMrshlOpts);
                pIMrshlOpts->GetStubMarshalFlags(&dwMarshalFlags);
                pIMrshlOpts->Release();
            
                // Translate user flags to internal flags
                if (dwMarshalFlags & MARSHOPT_NO_OID_REGISTER)
                    m_flags |= STDID_IGNOREID;
            }
        }

        ASSERT_LOCK_NOT_HELD(gComLock);
    }
    else
    {
        m_cStrongRefs = 1;
    }

    if (m_flags & STDID_STCMRSHL)
    {
        dwSMFlags |= SMFLAGS_CSTATICMARSHAL;
    }
    if (m_flags & STDID_SYSTEM)
    {
        dwSMFlags |= SMFLAGS_SYSTEM;
    }

    if (m_flags & STDID_FTM)
        dwSMFlags |= SMFLAGS_FTM;

    // now intialize the standard marshaler
    if (CStdMarshal::Init(m_pUnkControl, this, clsidHandler, dwSMFlags) == FALSE)
    {
        // construction failed. Release any resources held.
    	*pfSuccess = FALSE;
    	if (!IsClient() && !IsAggregated())
    	{
    	    m_pUnkControl->Release(); // construction failed; release ref count
    	    m_pUnkControl = NULL;
    	}
    	if (m_pIEC)
    	{
    	    m_pIEC->Release();
    	    m_pIEC = NULL;
    	}
    	// if initialization fails, set refcount to zero. User then deletes object instead of
    	// calling Release (too many different refcounts and I don't see a straightforward
    	// way to call Release and have this object cleaned up).
    	m_refs = 0;
    }
    else
    {
        *ppUnkInternal = (IMultiQI *)&m_InternalUnk; // this is what the m_refs=1 is for
        AssertValid();
    }
}

#if DBG==1
//+-------------------------------------------------------------------
//
//  Member:     CStdIdentity::CStdIdentity, public
//
//  Synopsis:   Special Identity ctor for the debug list head.
//
//+-------------------------------------------------------------------
CStdIdentity::CStdIdentity() : CClientSecurity(this), CRpcOptions(this, NULL)
{
    Win4Assert(this == &gDbgIDHead);
    m_pNext = this;
    m_pPrev = this;
}
#endif  // DBG

//+-------------------------------------------------------------------
//
//  Member:     CStdIdentity::~CStdIdentity, private
//
//  Synopsis:   Final destruction of the identity object.  ID has been
//              revoked by now (in internal ::Release).  Here we disconnect
//              on server.
//
//  History:    15-Dec-93   CraigWi     Created.
//                          Rickhi      Simplified
//
//--------------------------------------------------------------------
CStdIdentity::~CStdIdentity()
{
#if DBG==1
    if (this != &gDbgIDHead)
    {
#endif  // DBG

        ComDebOut((DEB_MARSHAL, "CStdIdentity %s Deleted this:%x\n",
                    IsClient() ? "CLIENT" : "SERVER", this));

        Win4Assert(m_refs == 0 || m_refs == CINDESTRUCTOR);
        m_refs++;               // simple guard against reentry of dtor
        SetNowInDestructor();   // debug flag which enables asserts to detect

        // find out if this is an AsyncRelease
        HRESULT hr;
        COleTls tls(hr);
        if (SUCCEEDED(hr))
        {
            SetAsyncRelease(tls->pAsyncRelease);
        }

        // make sure we have disconnected
        CStdMarshal::Disconnect(DISCTYPE_RELEASE);

        if (SUCCEEDED(hr))
        {
            // propogate async release status
            tls->pAsyncRelease = GetAsyncRelease();
        }

#if DBG==1
        // UnChain this identity from the global list of instantiated identities
        // so we can track even the ones that are not placed in the ID table.
        LOCK(gComLock);
        m_pPrev->m_pNext = m_pNext;
        m_pNext->m_pPrev = m_pPrev;
        UNLOCK(gComLock);
    }
#endif  // DBG
}

//+-------------------------------------------------------------------
//
//  Member:     CStdIdentity::CInternalUnk::QueryInterface, private
//
//  Synopsis:   Queries for an interface. Just delegates to the common
//              code in QueryMultipleInterfaces.
//
//  History:    26-Feb-96   Rickhi      Created
//
//--------------------------------------------------------------------
STDMETHODIMP CStdIdentity::CInternalUnk::QueryInterface(REFIID riid, VOID **ppv)
{
    if (ppv == NULL)
    {
        return E_INVALIDARG;
    }

    MULTI_QI mqi;
    mqi.pIID = &riid;
    mqi.pItf = NULL;

    HRESULT hr = QueryMultipleInterfaces(1, &mqi);

    *ppv = (void *)mqi.pItf;
    // carefull what gets returned here.
    return (hr == E_NOINTERFACE || hr == S_FALSE) ? mqi.hr : hr;
}

//+-------------------------------------------------------------------
//
//  Member:     CStdIdentity::CInternalUnk::QueryMultipleInterfacesLocal, public
//
//  Synopsis:   loop over the interfaces looking for locally supported interfaces,
//              instantiated proxies, and unsupported interfaces.
//
//  History:    06-Jan-98    MattSmit  Created -- factored out of QueryMultipleInterfaces
//
//--------------------------------------------------------------------
USHORT CStdIdentity::CInternalUnk::QueryMultipleInterfacesLocal(ULONG       cMQIs,
                                                                 MULTI_QI   *pMQIs,
                                                                 MULTI_QI  **ppMQIPending,
                                                                 IID        *pIIDPending,
                                                                 ULONG      *pcAcquired)
{
    ComDebOut((DEB_CHANNEL, "CStdIdentity::CInternalUnk::QueryMultipleInterfacesLocal IN cMQIs:0x%d, "
               "pMQIs:0x%x, ppMQIPending:0x%x, pIIDPending:%I, pcAcquired:0x%x\n",
               cMQIs, pMQIs, ppMQIPending, pIIDPending, pcAcquired));

    // loop over the interfaces looking for locally supported interfaces,
    // instantiated proxies, and unsupported interfaces. Gather up all the
    // interfaces that dont fall into the above categories, and issue a
    // remote query to the server.
    CStdIdentity *pStdID = GETPPARENT(this, CStdIdentity, m_InternalUnk);
    USHORT cPending  = 0;
    ULONG &cAcquired = *pcAcquired;
    cAcquired = 0;
    MULTI_QI *pMQI   = pMQIs;

    for (ULONG i=0; i<cMQIs; i++, pMQI++)
    {
        if (pMQI->pItf != NULL)
        {
            // skip any entries that are not set to NULL. This allows
            // progressive layers of handlers to optionally fill in the
            // interfaces that they know about and pass the whole array
            // on to the next level.
            cAcquired++;
            continue;
        }

        pMQI->hr   = S_OK;

        // always allow - IUnknown, IMarshal, IStdIdentity, IProxyManager,
        // and Instantiated proxies.
        if (InlineIsEqualGUID(*(pMQI->pIID), IID_IUnknown))
        {
            pMQI->pItf = (IMultiQI *)this;
        }
        else if (InlineIsEqualGUID(*(pMQI->pIID), IID_IMarshal))
        {
            pMQI->pItf = (IMarshal *)pStdID;
        }
        else if (InlineIsEqualGUID(*(pMQI->pIID), IID_IMarshal2))
        {
            pMQI->pItf = (IMarshal2 *)pStdID;
        }
        else if (InlineIsEqualGUID(*(pMQI->pIID), IID_IStdIdentity))
        {
            pMQI->pItf = (IUnknown *)(void*)pStdID;
        }
        else if (InlineIsEqualGUID(*(pMQI->pIID), IID_IProxyManager))
        {
            // old code exposed this IID and things now depend on it.
            pMQI->pItf = (IProxyManager *)pStdID;
        }
        else if (InlineIsEqualGUID(*(pMQI->pIID), IID_IRemUnknown) &&
                 pStdID->InstantiatedProxy(IID_IRundown,(void **)&pMQI->pItf,
                                           &pMQI->hr))
        {
            ;
        }
        else if (pStdID->InstantiatedProxy(*(pMQI->pIID),(void **)&pMQI->pItf,
                                            &pMQI->hr))
        {
            // a proxy for this interface already exists
            //
            // NOTE: this call also set pMQI->hr = E_NOINTERFACE if the
            // StId has never been connected, and to CO_E_OBJNOTCONNECTED if
            // it has been connected but is not currently connected. This is
            // required for backwards compatibility, and will cause us to skip
            // the QueryRemoteInterface.
            ;
        }
        else if (pStdID->IsAggregated())
        {
            // aggregate case
            // allow - IInternalUnknown
            // dissallow - IMultiQI, IClientSecurity, IServerSecurity,
            // IRpcOptions, ICallFactory, IForegroundTranfer

            if (InlineIsEqualGUID(*(pMQI->pIID), IID_IInternalUnknown))
            {
                pMQI->pItf = (IInternalUnknown *)this;
                pMQI->hr   = S_OK;
            }
            else if (InlineIsEqualGUID(*(pMQI->pIID), IID_IMultiQI)           ||
                     InlineIsEqualGUID(*(pMQI->pIID), IID_IRpcOptions)        ||
                     InlineIsEqualGUID(*(pMQI->pIID), IID_IClientSecurity)    ||
                     InlineIsEqualGUID(*(pMQI->pIID), IID_IServerSecurity)    ||
                     InlineIsEqualGUID(*(pMQI->pIID), IID_IForegroundTransfer)||
                     InlineIsEqualGUID(*(pMQI->pIID), IID_ICallFactory))
            {
                pMQI->hr = E_NOINTERFACE;
            }
        }

        if ((pMQI->pItf == NULL) && (!pStdID->IsAggregated() || pStdID->IsCStaticMarshal()))
        {
            // non-aggregate case
            // allow - IClientSecurity, IMultiQI, IRpcOptions
            // dissallow - IInternalUnknown, IServerSecurity

            if (InlineIsEqualGUID(*(pMQI->pIID), IID_IClientSecurity))
            {
                pMQI->pItf = (IClientSecurity *)pStdID;
                pMQI->hr   = S_OK;
            }
            else if (InlineIsEqualGUID(*(pMQI->pIID), IID_IRpcOptions))
            {
                pMQI->pItf = (IRpcOptions *)pStdID;
                pMQI->hr   = S_OK;
            }
            else if (InlineIsEqualGUID(*(pMQI->pIID), IID_ICallFactory) &&
                     pStdID->GetClientPolicySet()==NULL)
            {
                pMQI->pItf = (ICallFactory *)pStdID;
                pMQI->hr   = S_OK;
            }

            else if (InlineIsEqualGUID(*(pMQI->pIID), IID_IMultiQI))
            {
                pMQI->pItf = (IMultiQI *)this;
                pMQI->hr   = S_OK;
            }
            else if (InlineIsEqualGUID(*(pMQI->pIID), IID_IForegroundTransfer))
            {
                pMQI->pItf = (IForegroundTransfer *)pStdID;
                pMQI->hr   = S_OK;
            }
            else if (InlineIsEqualGUID(*(pMQI->pIID), IID_IInternalUnknown) ||
                     InlineIsEqualGUID(*(pMQI->pIID), IID_IServerSecurity))
            {
                pMQI->hr = E_NOINTERFACE;
            }
        }


        // never said we had this interface, never said we didn't
        // so, we'll call out to the object.

        if ((pMQI->pItf == NULL) && (pMQI->hr == S_OK))
        {
            pMQI->hr = RPC_S_CALLPENDING;
        }


        if (pMQI->hr == S_OK)
        {
            // got an interface to return, AddRef it and count one more
            // interface acquired.

            pMQI->pItf->AddRef();
            cAcquired++;
        }
        else if (pMQI->hr == RPC_S_CALLPENDING)
        {
            // fill in a remote QI structure and count one more
            // pending interface

            *pIIDPending    = *(pMQI->pIID);
            *ppMQIPending   = pMQI;

            pIIDPending++;
            ppMQIPending++;
            cPending++;
        }
    }

    ComDebOut((DEB_CHANNEL, "CStdIdentity::CInternalUnk::QueryMultipleInterfacesLocal OUT\n"));
    return cPending;
}

//+-------------------------------------------------------------------
//
//  Member:     CStdIdentity::CInternalUnk::QueryMultipleInterfaces, public
//
//  Synopsis:   QI for >1 interface
//
//  History:    26-Feb-96   Rickhi      Created
//
//--------------------------------------------------------------------
STDMETHODIMP CStdIdentity::CInternalUnk::QueryMultipleInterfaces(ULONG cMQIs,
                                        MULTI_QI *pMQIs)
{
    // Make sure TLS is initialized.
    HRESULT hr;
    COleTls tls(hr);
    if (FAILED(hr))
        return hr;


    // ensure it is callable in the current apartment
    CStdIdentity *pStdID = GETPPARENT(this, CStdIdentity, m_InternalUnk);
        
    if (!pStdID->IsCallableFromCurrentApartment(FALSE))
    {
        CoVrfNotifySmuggledProxy(IID_IUnknown, 0, pStdID->GetAptId());
        return RPC_E_WRONG_THREAD;
    }

    pStdID->AssertValid();

    // allocate some space on the stack for the intermediate results. declare
    // working pointers and remember the start address of the allocations.

    MULTI_QI  **ppMQIAlloc = (MULTI_QI **)_alloca(sizeof(MULTI_QI *) * cMQIs);
    IID       *pIIDAlloc   = (IID *)      _alloca(sizeof(IID) * cMQIs);
    SQIResult *pSQIAlloc   = (SQIResult *)_alloca(sizeof(SQIResult) * cMQIs);

    MULTI_QI  **ppMQIPending = ppMQIAlloc;
    IID       *pIIDPending   = pIIDAlloc;
    ULONG     cAcquired;

    USHORT cPending = QueryMultipleInterfacesLocal(cMQIs, pMQIs, ppMQIPending, pIIDPending, &cAcquired);


    if (cPending > 0)
    {
        memset(pSQIAlloc, 0, sizeof(SQIResult) * cPending);
        // there are some interfaces which we dont yet know about, so
        // go ask the remoting layer to Query the server and build proxies
        // where possible. The results are returned in the individual
        // SQIResults, so the overall return code is ignored.

        pStdID->QueryRemoteInterfaces(cPending, pIIDAlloc, pSQIAlloc);

        CopyToMQI(cPending, pSQIAlloc, ppMQIAlloc, &cAcquired);
    }



    // if we got all the interfaces, return S_OK. If we got none of the
    // interfaces, return E_NOINTERFACE. If we got some, but not all, of
    // the interfaces, return S_FALSE;

    if (cAcquired == cMQIs)
        return S_OK;
    else if (cAcquired > 0)
        return S_FALSE;
    else
        return E_NOINTERFACE;
}

//+-------------------------------------------------------------------
//
//  Member:     CStdIdentity::CInternalUnk::QueryInternalInterface, public
//
//  Synopsis:   return interfaces that are internal to the aggregated
//              proxy manager.
//
//  History:    26-Feb-96   Rickhi      Created
//
//--------------------------------------------------------------------
STDMETHODIMP CStdIdentity::CInternalUnk::QueryInternalInterface(REFIID riid,
                                                                VOID **ppv)
{
    CStdIdentity *pStdID = GETPPARENT(this, CStdIdentity, m_InternalUnk);
    if (!pStdID->IsCallableFromCurrentApartment(FALSE))
    {
        CoVrfNotifySmuggledProxy(IID_IUnknown, 0, pStdID->GetAptId());
        return RPC_E_WRONG_THREAD;
    }

    pStdID->AssertValid();

    if (!pStdID->IsAggregated())
    {
        // this method is only valid when we are part of a client-side
        // aggregate.
        return E_NOTIMPL;
    }

    if (InlineIsEqualGUID(riid, IID_IUnknown) ||
        InlineIsEqualGUID(riid, IID_IInternalUnknown))
    {
        *ppv = (IInternalUnknown *)this;
    }
    else if (InlineIsEqualGUID(riid, IID_IMultiQI))
    {
        *ppv = (IMultiQI *)this;
    }
    else if (InlineIsEqualGUID(riid, IID_IStdIdentity))
    {
        *ppv = pStdID;
    }
    else if (InlineIsEqualGUID(riid, IID_IClientSecurity))
    {
        *ppv = (IClientSecurity *)pStdID;
    }
    else if (InlineIsEqualGUID(riid, IID_ICallFactory))
    {
        *ppv = (ICallFactory *)pStdID;
    }
    else if (InlineIsEqualGUID(riid, IID_IRpcOptions) &&
             pStdID->IsCStaticMarshal())
    {
        *ppv = (IRpcOptions *)pStdID;
    }
    else if (InlineIsEqualGUID(riid, IID_IProxyManager))
    {
        *ppv = (IProxyManager *)pStdID;
    }
    else if (InlineIsEqualGUID(riid, IID_IForegroundTransfer))
    {
        *ppv = (IForegroundTransfer *)pStdID;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    ((IUnknown *)*ppv)->AddRef();
    return S_OK;
}


//+-------------------------------------------------------------------
//
//  Member:     CStdIdentity::CInternalUnk::AddRef, public
//
//  Synopsis:   Nothing special.
//
//  History:    15-Dec-93   CraigWi     Created.
//
//--------------------------------------------------------------------
STDMETHODIMP_(ULONG) CStdIdentity::CInternalUnk::AddRef(void)
{
    CStdIdentity *pStdID = GETPPARENT(this, CStdIdentity, m_InternalUnk);
    pStdID->AssertValid();

    if (!pStdID->IsCallableFromCurrentApartment(TRUE))
    {
        CoVrfNotifySmuggledProxy(IID_IUnknown, 1, pStdID->GetAptId());
    }

    DWORD cRefs = InterlockedIncrement((long *)&pStdID->m_refs);

    // ComDebOut((DEB_MARSHAL, "StdId:CtrlUnk::AddRef this:%x m_refs:%x\n", pStdID, cRefs));
    return cRefs;
}

//+-------------------------------------------------------------------
//
//  Member:     CStdIdentity::CInternalUnk::Release, public
//
//  Synopsis:   Releases the identity object.  When the ref count goes
//              to zero, revokes the id and destroys the object.
//
//  History:    15-Dec-93   CraigWi     Created.
//              18-Apr-95   Rickhi      Rewrote much faster/simpler
//
//--------------------------------------------------------------------
STDMETHODIMP_(ULONG) CStdIdentity::CInternalUnk::Release(void)
{
    CStdIdentity *pStdID = GETPPARENT(this, CStdIdentity, m_InternalUnk);
    pStdID->AssertValid();

    if (!pStdID->IsCallableFromCurrentApartment(TRUE))
    {
        CoVrfNotifySmuggledProxy(IID_IUnknown, 2, pStdID->GetAptId());
    }

    // decrement the refcnt. if the refcnt went to zero it will be marked
    // as being in the dtor, and fTryToDelete will be true.
    ULONG cNewRefs;
    BOOL fTryToDelete = InterlockedDecRefCnt(&pStdID->m_refs, &cNewRefs);
    // ComDebOut((DEB_MARSHAL, "StdId:CtrlUnk::Release this:%x m_refs:%x\n", pStdID, cNewRefs));

    while (fTryToDelete)
    {
        // refcnt went to zero, try to delete this entry

        if (pStdID->IsCStaticMarshal())
        {
            // If the aggregator is the AGGID, we stay around until
            // it gets deleted
            break;
        }

        if (IsOKToDeleteClientObject(pStdID, &pStdID->m_refs))
        {
            // the refcnt did not change while we acquired the lock
            // (i.e. the idtable did not just hand out a reference).
            // OK to delete the identity object.
            delete pStdID;
            break;  // all done. the entry has been deleted.
        }

        // the entry was not deleted because some other thread changed
        // the refcnt while we acquired the lock. Try to restore the refcnt
        // to turn off the CINDESTRUCTOR bit. Note that this may race with
        // another thread changing the refcnt, in which case we may decide to
        // try to loop around and delete the object once again.
        fTryToDelete = InterlockedRestoreRefCnt(&pStdID->m_refs, &cNewRefs);
    }

    return (cNewRefs & ~CINDESTRUCTOR);
}


//+-------------------------------------------------------------------
//
//  Function:   IsOKToDeleteClientObject, private
//
//  Synopsis:   Called when a client side object reference count hits
//              zero. Takes a lock and re-checks the reference count to
//              ensure the OID table did not just hand out a reference,
//              removes the OID from the OID table.
//
//  Returns:    TRUE - safe to delete object
//              FALSE - unsafe to delete object
//
//  History:    31-Oct-96   Rickhi      Created
//
//--------------------------------------------------------------------
INTERNAL_(BOOL) IsOKToDeleteClientObject(CStdIdentity *pStdID, ULONG *pcRefs)
{
    BOOL fDelete = FALSE;
    ASSERT_LOCK_NOT_HELD(gComLock);
    LOCK(gComLock);

    // check if we are already in the dtor and skip a second destruction
    // if so. The reason we need this is that some crusty old apps do
    // CoMarshalInterface followed by CoLockObjectExternal(FALSE,TRUE),
    // expecting this to accomplish a Disconnect. It subtracts from the
    // references, but it takes away the ones that the IPIDEntry put on,
    // without telling the IPIDEntry, so when we release the IPIDEntry,
    // our count goes negative!!!

    // the LockedInMemory flag is for the gpStdMarshal instance that we
    // may hand out to clients, but which we never want to go away,
    // regardless of how many times they call Release.

    if (*pcRefs == CINDESTRUCTOR)
    {
        // refcnt is still zero, so the idtable did not just hand
        // out a reference behind our back.

        if (!pStdID->IsLockedOrInDestructor())
        {
            // remove from the OID table and delete the identity
            // We dont delete while holding the table mutex.
            CIDObject *pID = pStdID->GetIDObject();
            if((pID==NULL) || pID->IsOkToDisconnect())
            {
                pStdID->RevokeOID();
                if(pID)
                    pID->RemoveStdID();
                fDelete = TRUE;
            }
        }
        else
        {
            // this object is locked in memory and we should never
            // get here, but some broken test app was doing this in
            // stress.

            *pcRefs = CINDESTRUCTOR | 0x100;
        }
    }

    UNLOCK(gComLock);
    ASSERT_LOCK_NOT_HELD(gComLock);
    return fDelete;
}

//+-------------------------------------------------------------------
//
//  Member:     CStdIdentity::IUnknown methods, public
//
//  Synopsis:   External IUnknown methods; delegates to m_pUnkOuter.
//
//  History:    15-Dec-93   CraigWi     Created.
//
//--------------------------------------------------------------------
STDMETHODIMP CStdIdentity::QueryInterface(REFIID riid, VOID **ppvObj)
{
    AssertValid();

    // It is necessary to switch to the NA if this is an FTM object
    // because our internal unk QI uses QueryMultipleInterfaces which
    // verifies that the call is occuring in the correct apt.

    ENTER_NA_IF_NECESSARY()
    HRESULT hr = m_pUnkOuter->QueryInterface(riid, ppvObj);
    LEAVE_NA_IF_NECESSARY()
    return hr;
}

STDMETHODIMP_(ULONG) CStdIdentity::AddRef(void)
{
    AssertValid();
    return m_pUnkOuter->AddRef();
}

STDMETHODIMP_(ULONG) CStdIdentity::Release(void)
{
    AssertValid();
    return m_pUnkOuter->Release();
}

//+-------------------------------------------------------------------
//
//  Member:     CStdIdentity::UnlockAndRelease, public
//
//  Synopsis:   Version of Release used for gpStdMarshal, that is
//              currently locked in memory so nobody but us can
//              release it, regardless of refcnt.
//
//  History:    19-Apr-96   Rickhi      Created
//
//--------------------------------------------------------------------
ULONG CStdIdentity::UnlockAndRelease(void)
{
    m_flags &= ~STDID_LOCKEDINMEM;
    m_refs = 1;
    return m_pUnkOuter->Release();
}

//+-------------------------------------------------------------------
//
//  Member:     CStdIdentity::IncStrongCnt, public
//
//  Synopsis:   Increments the strong reference count on the identity.
//
//  History:    15-Dec-93   Rickhi      Created.
//
//--------------------------------------------------------------------
void CStdIdentity::IncStrongCnt()
{
    Win4Assert(!IsClient());

    // we might be holding the lock here if this is called from
    // ObtainStdID, since we have to be holding the lock while
    // doing the lookup. We cant release it or we could go away.

    ASSERT_LOCK_DONTCARE(gComLock);

    ComDebOut((DEB_MARSHAL,
        "CStdIdentity::IncStrongCnt this:%x cStrong:%x\n",
        this, m_cStrongRefs+1));

    AddRef();
    InterlockedIncrement(&m_cStrongRefs);

    if (m_pIEC)
    {
        m_pIEC->AddConnection(EXTCONN_STRONG, 0);
    }

    ASSERT_LOCK_DONTCARE(gComLock);
}

//+-------------------------------------------------------------------
//
//  Member:     CStdIdentity::DecStrongCnt, public
//
//  Synopsis:   Decrements the strong reference count on the identity,
//              and releases the object if that was the last strong
//              reference.
//
//  History:    15-Dec-93   Rickhi      Created.
//
//--------------------------------------------------------------------
void CStdIdentity::DecStrongCnt(BOOL fKeepAlive)
{
    Win4Assert(!IsClient());
    ASSERT_LOCK_NOT_HELD(gComLock);

    ComDebOut((DEB_MARSHAL,
        "CStdIdentity::DecStrongCnt this:%x cStrong:%x fKeepAlive:%x\n",
        this, m_cStrongRefs-1, fKeepAlive));

    LONG cStrongRefs = InterlockedDecrement(&m_cStrongRefs);

    if (m_pIEC)
    {
        m_pIEC->ReleaseConnection(EXTCONN_STRONG, 0, !fKeepAlive);
    }

    // If aggregated on the server side, then the last strong reference
    // should cause a Disconnect, otherwise the stubs will hold the object
    // alive when unmarshaling in the server apartment.
    fKeepAlive = IsAggregated() ? FALSE : fKeepAlive;

    if (cStrongRefs == 0 && !fKeepAlive && (m_pIEC == NULL || IsWOWThread()))
    {
        // strong count has gone to zero, disconnect.
        CStdMarshal::Disconnect(DISCTYPE_NORMAL);
	if (m_cStrongRefs <0 ) 
	   m_cStrongRefs = 0;  // make sure a negative count is corrected
                            // see comment below
    }

    if (cStrongRefs >= 0)
    {
        // some apps call CoMarshalInterface + CoLockObjectExternal(F,T)
        // and expect the object to go away. Doing that causes Release to
        // be called too many times (once for each IPID, once for CLOE, and
        // once for the original Lookup).
        Release();
    }

    ASSERT_LOCK_NOT_HELD(gComLock);
}

//+-------------------------------------------------------------------
//
//  Member:     CStdIdentity::IncWeakCnt, public
//
//  Synopsis:   Increments the weak reference count on the identity.
//
//  History:    15-Dec-93   Rickhi      Created.
//
//--------------------------------------------------------------------
void CStdIdentity::IncWeakCnt()
{
    Win4Assert(!IsClient());

    // we might be holding the lock here if this is called from
    // ObtainStdID, since we have to be holding the lock while
    // doing the lookup. We cant release it or we could go away.

    ASSERT_LOCK_DONTCARE(gComLock);

    ComDebOut((DEB_MARSHAL,
        "CStdIdentity::IncWeakCnt this:%x cWeak:%x\n",
        this, m_cWeakRefs+1));

    AddRef();
    InterlockedIncrement(&m_cWeakRefs);

    ASSERT_LOCK_DONTCARE(gComLock);
}

//+-------------------------------------------------------------------
//
//  Member:     CStdIdentity::DecWeakCnt, public
//
//  Synopsis:   Decrements the weak reference count on the identity,
//              and releases the object if that was the last strong
//              and weak reference.
//
//  History:    15-Dec-93   Rickhi      Created.
//
//--------------------------------------------------------------------
void CStdIdentity::DecWeakCnt(BOOL fKeepAlive)
{
    Win4Assert(!IsClient());
    ComDebOut((DEB_MARSHAL,
        "CStdIdentity::DecWeakCnt this:%x cWeak:%x fKeepAlive:%x\n",
        this, m_cWeakRefs-1, fKeepAlive));

    LONG cWeakRefs = InterlockedDecrement(&m_cWeakRefs);

    // If aggregated on the server side, then the last strong or weak reference
    // should cause a Disconnect, otherwise the stubs will hold the object
    // alive when unmarshaling in the server apartment.
    fKeepAlive = IsAggregated() ? FALSE : fKeepAlive;

    if (cWeakRefs == 0 && !fKeepAlive && m_cStrongRefs == 0)
    {
        // strong and weak count have gone to zero, disconnect.
        DisconnectObject(0);
    }

    Release();
}

//+-------------------------------------------------------------------
//
//  Member:     CStdIdentity::LockObjectExternal, public
//
//  Synopsis:   locks (or unlocks) the object so the remoting layer does
//              not (or does) go away.
//
//  History:    09-Oct-96   Rickhi      Moved from CoLockObjectExternal.
//
//--------------------------------------------------------------------
HRESULT CStdIdentity::LockObjectExternal(BOOL fLock, BOOL fLastUR)
{
    HRESULT hr = S_OK;

    if (GetServer() == NULL)
    {
        // attempt to lock handler, return error!
        hr = E_UNEXPECTED;
    }
    else if (fLock)
    {
        // lock (and ignore rundowns) so it does not go away
        IncStrongCnt();
        LOCK(gIPIDLock);
        IncTableCnt();
        UNLOCK(gIPIDLock);
    }
    else
    {
        // unlock so that it can go away
        LOCK(gIPIDLock);
        DecTableCnt();
        UNLOCK(gIPIDLock);
        DecStrongCnt(!fLastUR);
    }

    return hr;
}

//+-------------------------------------------------------------------
//
//  Member:     CStdIdentity::GetServer, public
//
//  Synopsis:   Returns a pUnk for the identified object; NULL on client side
//              The pointer is optionally addrefed depending upon fAddRef
//
//  Returns:    The pUnk on the object.
//
//  History:    15-Dec-93   CraigWi     Created.
//
//--------------------------------------------------------------------
IUnknown * CStdIdentity::GetServer()
{
    if (IsClient() || m_pUnkControl == NULL)
        return NULL;

    // Verify validity
    Win4Assert(IsValidInterface(m_pUnkControl));
    return m_pUnkControl;
}

//+-------------------------------------------------------------------
//
//  Member:     CStdIdentity::ReleaseCtrlUnk, public
//
//  Synopsis:   Releases the server side controlling unknown
//              This code is safe for reentrant calls.
//
//  History:    11-Jun-95   Rickhi  Created
//
//--------------------------------------------------------------------
void CStdIdentity::ReleaseCtrlUnk(void)
{
    AssertValid();
    Win4Assert(!IsClient());
    IUnknown *pUnkControl = m_pUnkControl;
    __try
    {
        if (m_pUnkControl)
        {
            // release the real object's m_pUnkControl

            AssertSz(IsValidInterface(m_pUnkControl),
                     "Invalid IUnknown during disconnect");
            m_pUnkControl = NULL;

            if (m_pIEC)
            {
                AssertSz(IsValidInterface(m_pIEC),
                         "Invalid IExternalConnection during disconnect");
                m_pIEC->Release();
                m_pIEC = NULL;
            }

            if(!IsAggregated())
                pUnkControl->Release();
        }
    }
    __except(AppInvokeExceptionFilter(GetExceptionInformation(), pUnkControl, IID_IUnknown, 2))
    {
    }
}

//+-------------------------------------------------------------------
//
//  Member:     CStdIdentity::SetOID, public
//
//  Synopsis:   Associates the OID and the object (handler or server).
//
//  History:    20-Feb-95   Rickhi      Simplified
//
//--------------------------------------------------------------------
HRESULT CStdIdentity::SetOID(REFMOID rmoid)
{
    Win4Assert(rmoid != GUID_NULL);
    ASSERT_LOCK_HELD(gComLock);

    HRESULT hr = S_OK;

    if (!(m_flags & STDID_HAVEID))
    {
        if (!(m_flags & STDID_IGNOREID))
        {
            GetIDObject()->SetOID(rmoid);
            gOIDTable.Add(GetIDObject());
        }

        if (SUCCEEDED(hr))
        {
            m_flags |= STDID_HAVEID;
            m_moid = rmoid;
        }
    }

    ComDebErr(hr != S_OK, "SetOID Failed. Probably OOM.\n");
    return hr;
}

//+-------------------------------------------------------------------
//
//  Member:     CStdIdentity::RevokeOID, public
//
//  Synopsis:   Disassociates the OID and the object (handler or server).
//              Various other methods will fail (e.g., MarshalInterface).
//
//  History:    15-Dec-93   CraigWi     Created.
//              20-Feb-95   Rickhi      Simplified
//
//--------------------------------------------------------------------
void CStdIdentity::RevokeOID(void)
{
    AssertValid();
    ASSERT_LOCK_HELD(gComLock);

    if (m_flags & STDID_HAVEID)
    {
        m_flags &= ~STDID_HAVEID;

        if (!(m_flags & STDID_IGNOREID))
            gOIDTable.Remove(GetIDObject());
    }
}

//+-------------------------------------------------------------------
//
//  Member:     CStdIdentity::IsCallableFromCurrentApartment, public
//
//  Synopsis:   Determines if the object is callable from the current
//              apartment or not.
//
//  History:    08-Mar-97   Rickhi      Created
//
//--------------------------------------------------------------------
BOOL CStdIdentity::IsCallableFromCurrentApartment(BOOL fAllowFTM)
{
    if (m_dwAptId == GetCurrentApartmentId() || IsFreeThreaded())
    {
        return TRUE;
    }

    if (fAllowFTM)
    {
        // Allow calls on FTM proxies that live in the NA.
        if ((m_dwAptId == NTATID) && IsFTM())
        {
            return TRUE;
        }

        // LightNA has it's own edge cases where it can be called.
        if (LightNA())
        {
            return TRUE;
        }
    }

    return FALSE;
}

//+-------------------------------------------------------------------
//
//  Member:     CStdIdentity::IsConnected, public
//
//  Synopsis:   Indicates if the client is connected to the server.
//              Only the negative answer is definitive because we
//              might not be able to tell if the server is connected
//              and even if we could, the answer might be wrong by
//              the time the caller acted on it.
//
//  Returns:    TRUE if the server might be connected; FALSE if
//              definitely not.
//
//  History:    16-Dec-93   CraigWi     Created.
//
//--------------------------------------------------------------------
STDMETHODIMP_(BOOL) CStdIdentity::IsConnected(void)
{
    Win4Assert(IsClient());             // must be client side
    AssertValid();

    return RemIsConnected();
}

//+-------------------------------------------------------------------
//
//  Member:     CStdIdentity::Disconnect, public
//
//  Synopsis:   IProxyManager::Disconnect implementation, just forwards
//              to the standard marshaller, which may call us back to
//              revoke our OID and release our CtrlUnk.
//
//              May also be called by the IDTable cleanup code.
//
//  History:    11-Jun-95   Rickhi  Created.
//
//--------------------------------------------------------------------
STDMETHODIMP_(void) CStdIdentity::Disconnect()
{
    AssertValid();
    CStdMarshal::Disconnect(DISCTYPE_APPLICATION);
}

//+-------------------------------------------------------------------
//
//  Member:     CStdIdentity::LockConnection, public
//
//  Synopsis:   IProxyManager::LockConnection implementation. Changes
//              all interfaces to weak from strong, or strong from weak.
//
//  History:    11-Jun-95   Rickhi  Created.
//
//--------------------------------------------------------------------
STDMETHODIMP CStdIdentity::LockConnection(BOOL fLock, BOOL fLastUnlockReleases)
{
    if (!IsCallableFromCurrentApartment(FALSE))
    {
        CoVrfNotifySmuggledProxy(IID_IProxyManager, 5, GetAptId());
        return RPC_E_WRONG_THREAD;
    }
    AssertValid();

    if (!IsClient() || !(m_flags & STDID_DEFHANDLER))
    {
        // this operation does not make sense on the server side,
        // and is not allowed except by the OLE default handler
        return E_NOTIMPL;
    }

    if (IsMTAThread())
    {
        // this call is not allowed if we are FreeThreaded. Report
        // success, even though we did not do anything.
        return S_OK;
    }


    if (( fLock && (++m_cStrongRefs == 1)) ||
        (!fLock && (--m_cStrongRefs == 0)))
    {
        // the strong count transitioned from 0 to 1 or 1 to 0, so
        // call the server to change our references.

        return RemoteChangeRef(fLock, fLastUnlockReleases);
    }

    return S_OK;
}

//+-------------------------------------------------------------------
//
//  Member:     CStdIdentity::CreateServer, public
//
//  Synopsis:   Creates the server clsid in the given context and
//              attaches it to this handler.
//
//  History:    16-Dec-93   CraigWi     Created.
//
// CODEWORK:    this code is not thread safe in the freethreading case. We
//              need to decide if the thread safety is the responsibility
//              of the caller, or us. In the latter case, we would check
//              if we are already connected before doing UnmarshalObjRef, and
//              instead do a ::ReleaseMarshalObjRef.
//
//--------------------------------------------------------------------
STDMETHODIMP CStdIdentity::CreateServer(REFCLSID rclsid, DWORD clsctx, void *pv)
{
    ComDebOut((DEB_ACTIVATE, "ScmCreateObjectInstance this:%x clsctx:%x pv:%x\n",
                this, clsctx, pv));
    AssertValid();
    Win4Assert(IsClient());                         // must be client side
    Win4Assert(IsValidInterface(m_pUnkControl));    // must be valid
    //Win4Assert(!IsConnected());
    ASSERT_LOCK_NOT_HELD(gComLock);

    if (!(m_flags & STDID_DEFHANDLER))
    {
        // this operation is not allowed except by the OLE default handler
        return E_NOTIMPL;
    }

    // Loop trying to get object from the server. Because the server can be
    // in the process of shutting down and respond with a marshaled interface,
    // we will retry this call if unmarshaling fails assuming that the above
    // is true.

    if (!IsCallableFromCurrentApartment(FALSE))
    {
        CoVrfNotifySmuggledProxy(IID_IProxyManager, 3, GetAptId());
        return RPC_E_WRONG_THREAD;
    }

    HRESULT hr = InitChannelIfNecessary();
    if (FAILED(hr))
        return hr;

    const int MAX_SERVER_TRIES = 3;

    for (int i = 0; i < MAX_SERVER_TRIES; i++)
    {
        // create object and get back marshaled interface pointer
        InterfaceData *pIFD = NULL;

        // Dll ignored here since we are just doing this to get
        // the remote handler.
        DWORD dwServerModel;
        WCHAR *pwszServerDll = NULL;

        HRESULT hrinterface;
        hr = gResolver.CreateInstance(
                NULL, (CLSID *)&rclsid, clsctx, 1,
                (IID *)&IID_IUnknown, &dwServerModel, &pwszServerDll,
                (MInterfacePointer **)&pIFD, &hrinterface );

        if (pwszServerDll != NULL)
        {
            CoTaskMemFree(pwszServerDll);
        }

        if (FAILED(hr))
        {
            // If an error occurred, return that otherwise convert a wierd
            // success into E_FAIL. The point here is to return an error that
            // the caller can figure out what happened.
            hr = FAILED(hr) ? hr : E_FAIL;
            break;
        }


        // make a stream out of the interface data returned, then read the
        // objref from the stream. No need to find another instance of
        // CStdMarshal because we already know it is for us!

        CXmitRpcStream Stm(pIFD);
        OBJREF  objref;
        hr = ReadObjRef(&Stm, objref);

        if (SUCCEEDED(hr))
        {
            // become this identity by unmarshaling the objref into this
            // object. Note the objref must use standard marshaling.
            Win4Assert(objref.flags & (OBJREF_HANDLER  | OBJREF_STANDARD |
                                       OBJREF_EXTENDED));
            Win4Assert(IsEqualIID(objref.iid, IID_IUnknown));

            // Server should be in a non-default context
            if (!(objref.flags & OBJREF_EXTENDED))
            {
                IUnknown *pUnk = NULL;
                hr = UnmarshalObjRef(objref, (void **)&pUnk);
                if (SUCCEEDED(hr))
                {
                    // release the AddRef done by unmarshaling
                    pUnk->Release();

                    // Reconnect the interface proxies
                    CStdMarshal::ReconnectProxies();
                }
            }
            else
            {
                hr = RPC_E_INVALID_OBJREF;
            }

            // free the objref we read above.
            FreeObjRef(objref);
        }

        CoTaskMemFree(pIFD);


        // If either this worked or we got a packet we couldn't unmarshal
        // at all we give up. Otherwise, we will hope that recontacting the
        // SCM will fix things.

        if (SUCCEEDED(hr) || (hr == E_FAIL))
        {
            break;
        }
    }

    ASSERT_LOCK_NOT_HELD(gComLock);
    ComDebOut((DEB_ACTIVATE, "ScmCreateObjectInstance this:%x hr:%x\n",
                this, hr));
    return hr;
}

//+-------------------------------------------------------------------
//
//  Member:     CStdIdentity::CreateServerWithHandler, public
//
//  Synopsis:   Creates the server clsid in the given context and
//              attaches it to this handler.
//
//  History:    10-Oct-95   JohannP     Created
//              30-Oct-96   rogerg      Altered for New ServerHandler.
//
// CODEWORK:    this code is not thread safe in the freethreading case. We
//              need to decide if the thread safety is the responsibility
//              of the caller, or us. In the latter case, we would check
//              if we are already connected before doing UnmarshalObjRef, and
//              instead do a ::ReleaseMarshalObjRef.
//
//--------------------------------------------------------------------
#ifdef SERVER_HANDLER
STDMETHODIMP CStdIdentity::CreateServerWithEmbHandler(REFCLSID rclsid, DWORD clsctx,
                                        REFIID riidEmbedSrvHandler,void **ppEmbedSrvHandler, void *pv)
{
    ComDebOut((DEB_ACTIVATE, "ScmCreateObjectInstance this:%x clsctx:%x pv:%x\n",
                this, clsctx, pv));
    AssertValid();
    Win4Assert(IsClient());                         // must be client side
    Win4Assert(IsValidInterface(m_pUnkControl));    // must be valid
    //Win4Assert(!IsConnected());
    ASSERT_LOCK_NOT_HELD(gComLock);

    if (!(m_flags & STDID_DEFHANDLER))
    {
        // this operation is not allowed except by the OLE default handler
        return E_NOTIMPL;
    }

    // Loop trying to get object from the server. Because the server can be
    // in the process of shutting down and respond with a marshaled interface,
    // we will retry this call if unmarshaling fails assuming that the above
    // is true.

    *ppEmbedSrvHandler = NULL;

    if (!IsCallableFromCurrentApartment(FALSE))
    {
        CoVrfNotifySmuggledProxy(IID_IProxyManager, 8, pStdID->GetAptId());
        return RPC_E_WRONG_THREAD;
    }

    HRESULT hr = InitChannelIfNecessary();
    if (FAILED(hr))
        return hr;

    const int MAX_SERVER_TRIES = 3;

    for (int i = 0; i < MAX_SERVER_TRIES; i++)
    {
        // create object and get back marshaled interface pointer
        InterfaceData *pIFD = NULL;

        // Dll ignored here since we are just doing this to get
        // the remote handler.
        DWORD dwServerModel;
        WCHAR *pwszServerDll = NULL;

        // Need to ask for both IUnknown and IServerHandler so if Server Handler
        // fails or is disabled can still return the object pointer.

        HRESULT hrinterface[2];
        IID iidArray[2];
        InterfaceData *pIFDHandler[2] = { NULL, NULL };

        iidArray[0] = IID_IUnknown;
        iidArray[1] = riidEmbedSrvHandler;

        hr = gResolver.CreateInstance( NULL, (CLSID *)&rclsid, clsctx, 2,
                (IID *) iidArray, &dwServerModel, &pwszServerDll,
                (MInterfacePointer **)&pIFDHandler, &hrinterface[0] );

        if (pwszServerDll != NULL)
        {
            CoTaskMemFree(pwszServerDll);
        }

        // if failed to create object or couldn't Object IUknown interface return an error.
        if (FAILED(hr) || FAILED(hrinterface[0]) )
        {
            // If an error occurred, return that otherwise convert a wierd
            // success into E_FAIL. The point here is to return an error that
            // the caller can figure out what happened.
            hr = FAILED(hr) ? hr : E_FAIL;
            break;
        }

        // make a stream out of the Object interface data returned, then read the
        // objref from the stream. No need to find another instance of
        // CStdMarshal because we already know it is for us!

        pIFD = pIFDHandler[0];

        CXmitRpcStream Stm(pIFD);
        OBJREF  objref;
        hr = ReadObjRef(&Stm, objref);

        if (SUCCEEDED(hr))
        {
            // become this identity by unmarshaling the objref into this
            // object. Note the objref must use standard marshaling.
            Win4Assert(objref.flags & (OBJREF_HANDLER  | OBJREF_STANDARD));
            Win4Assert(IsEqualIID(objref.iid, IID_IUnknown));

            IUnknown *pUnk = NULL;
            hr = UnmarshalObjRef(objref, (void **)&pUnk);
            if (SUCCEEDED(hr))
            {
                // release the AddRef done by unmarshaling

                pUnk->Release();

                // Reconnect the interface proxies
                CStdMarshal::ReconnectProxies();
            }

            // free the objref we read above.
            FreeObjRef(objref);
        }

        CoTaskMemFree(pIFD);

        // Unmarshal the Server Handler Interface.
        // even if fail to get Server Handler continue

        if (NOERROR == hrinterface[1])
        {
            // Embedded Server handler was returned UnMarshal and get real Server Object.
            *ppEmbedSrvHandler = NULL;
            UnMarshalHelper( (MInterfacePointer *) pIFDHandler[1],riidEmbedSrvHandler,(void **) ppEmbedSrvHandler);
            CoTaskMemFree(pIFDHandler[1]);
        }


        // If either this worked or we got a packet we couldn't unmarshal
        // at all we give up. Otherwise, we will hope that recontacting the
        // SCM will fix things.

        if (SUCCEEDED(hr) || (hr == E_FAIL))
        {
            break;
        }
    }

    ASSERT_LOCK_NOT_HELD(gComLock);
    ComDebOut((DEB_ACTIVATE, "ScmCreateObjectInstance this:%x hr:%x\n",
                this, hr));

    if ( FAILED(hr) &&  (NULL != *ppEmbedSrvHandler) )
    {
        ( (IUnknown *) *ppEmbedSrvHandler)->Release();
        *ppEmbedSrvHandler = NULL;
    }

    return hr;
}
#endif // SERVER_HANDLER

//+-------------------------------------------------------------------
//
//  Member:     CStdIdentity::AllowForegroundTransfer, public
//
//  Synopsis:   Implements IForegroundTransfer::AllowForegroundTransfer
//              Forwards to the standard marshaller.
//
//  History:    02-Feb-99   MPrabhu Created.
//
//--------------------------------------------------------------------
STDMETHODIMP CStdIdentity::AllowForegroundTransfer(void *lpvReserved)
{
    AssertValid();
    return CStdMarshal::AllowForegroundTransfer(lpvReserved);
}

#if DBG == 1
//+-------------------------------------------------------------------
//
//  Member:     CStdIdentity::AssertValid
//
//  Synopsis:   Validates that the state of the object is consistent.
//
//  History:    26-Jan-94   CraigWi     Created.
//
//--------------------------------------------------------------------
void CStdIdentity::AssertValid()
{
    LOCK(gComLock);

    if ((m_refs & ~CINDESTRUCTOR) >= 0x7fff)
        ComDebOut((DEB_WARN, "Identity ref count unreasonable this:%p m_refs:%x\n", this, m_refs & ~CINDESTRUCTOR));
//    AssertSz((m_refs & ~CINDESTRUCTOR) < 0x7fff, "Identity ref count unreasonable");

    if ((STDID_AGGID & m_flags) || (STDID_STCMRSHL & m_flags))
    {
        // The vtbl for the CAggId and CStdMarshal  haven't been
        // constructed yet so we can't assert the interface valid
        Win4Assert(NULL != m_pUnkOuter);
    }
    else
    {
        // ensure we have the controlling unknown
        Win4Assert(IsValidInterface(m_pUnkOuter));  // must be valid
    }

    // NOTE: don't carelessly AddRef/Release because of weak references

    // make sure only valid flags are set
    Win4Assert((m_flags & ~STDID_ALL) == 0);

    // these flags have to match up, the former is defined in olerem.h
    Win4Assert(STDID_CLIENT_DEFHANDLER == (STDID_CLIENT | STDID_DEFHANDLER));

	// if you've got the LightNA flag set, you'd better be a stub.
	if (LightNA())
		Win4Assert(!(m_flags & STDID_CLIENT) && "LightNA but not server!");

    if ((m_flags & STDID_HAVEID) &&
        !(m_flags & (STDID_FREETHREADED | STDID_IGNOREID | STDID_FTM)))
    {
        CStdIdentity *pStdID;
        Verify(ObtainStdIDFromOID(m_moid, m_dwAptId,
                                  FALSE /*fAddRef*/, &pStdID) == NOERROR);
        Win4Assert(pStdID == this);
        // pStdID not addref'd
    }

    if (IsClient())
    {
        if (!IsCStaticMarshal())
        {
            Win4Assert(m_pUnkControl == m_pUnkOuter);
        }
    }

    // Same problem as above.
    if ((STDID_AGGID & m_flags) || (STDID_STCMRSHL & m_flags))
    {
        Win4Assert(NULL != m_pUnkControl);
    }
    else
    {
        // must have RH tell identity when object goes away so we can NULL this
        if (m_pUnkControl != NULL)
            Win4Assert(IsValidInterface(m_pUnkControl));    // must be valid
    }

    if (m_pIEC != NULL)
        Win4Assert(IsValidInterface(m_pIEC));   // must be valid

    UNLOCK(gComLock);
}
#endif // DBG == 1



//+-------------------------------------------------------------------
//
//  Function:   CreateIdentityHandler, private
//
//  Synopsis:   Creates a client side identity object (one which is
//              initialized by the first unmarshal).
//
//  Arguments:  [pUnkOuter] - controlling unknown if aggregated
//              [StdIDFlags]- flags (indicates free-threaded or not)
//              [pServerCtx]- server context
//              [dwAptId]   - client apartment ID
//              [riid]      - interface requested
//              [ppv]       - place for pointer to that interface.
//
//  History:    16-Dec-93   CraigWi     Created.
//              20-Feb-95   Rickhi      Simplified
//
//--------------------------------------------------------------------
INTERNAL CreateIdentityHandler(IUnknown *pUnkOuter, DWORD StdIdFlags,
                               CObjectContext *pServerCtx, DWORD dwAptId,
                               REFIID riid, void **ppv)
{
#if DBG == 1
	ASSERT_LOCK_NOT_HELD(gComLock);
	Win4Assert(IsApartmentInitialized());

    // if aggregating, it must ask for IUnknown.
    Win4Assert(pUnkOuter == NULL ||
               IsEqualGUID(riid, IID_IUnknown) ||
               (StdIdFlags & STDID_AGGID));

    if (pUnkOuter != NULL)
    {
        // addref/release pUnkOuter; shouldn't go away (i.e.,
        // should be other ref to it).
        // Except Excel which always returns 0 on Release!
        if (!IsTaskName(L"EXCEL.EXE"))
        {
            pUnkOuter->AddRef();
            Verify(pUnkOuter->Release() != 0);

            // verify that pUnkOuter is in fact the controlling unknown
            IUnknown *pUnkT;
            Verify(pUnkOuter->QueryInterface(IID_IUnknown,(void**)&pUnkT)==NOERROR);
            Win4Assert(pUnkOuter == pUnkT);
            Verify(pUnkT->Release() != 0);
        }
    }
#endif

    *ppv = NULL;
    IUnknown *pUnkID = NULL;
    BOOL fSuccess = FALSE;
    HRESULT hr = E_OUTOFMEMORY;

    CStdIdentity *pStdID = new CStdIdentity(StdIdFlags, dwAptId, pUnkOuter,
                                            NULL, &pUnkID, &fSuccess);

    if (pStdID && fSuccess == FALSE)
    {
        delete pStdID;
        pStdID = NULL;        
    }
    
    if (pStdID)
    {
        // get the interface the caller asked for.
        if (StdIdFlags & STDID_AGGID)
        {
            Win4Assert(IsEqualIID(riid, IID_IStdIdentity));
            *ppv = pStdID;
            hr = S_OK;
        }
        else
        {
            hr = pUnkID->QueryInterface(riid, ppv);
            pUnkID->Release();
        }

        if (SUCCEEDED(hr) && !(StdIdFlags & STDID_SYSTEM))
        {
            hr = E_OUTOFMEMORY; // assume OOM

            // Aquire lock
            LOCK(gComLock);

            // Create object identity representing the client
            CIDObject *pID = new CIDObject(pUnkOuter, pServerCtx, dwAptId,
                                           IDFLAG_CLIENT);
            // Establish object identity
            if (pID)
            {
                // Set object identity inside StdID. This will
                // AddRef the IDObject.
                pStdID->SetIDObject(pID);

                // Set the StdID inside object identity
                pID->SetStdID(pStdID);
                pID->Release();
                hr = S_OK;
				// Release lock
				UNLOCK(gComLock);
            }
            else
            {
               // Release lock
               UNLOCK(gComLock);
               *ppv = NULL;
               // release the inner object
               pUnkID->Release();
            }
        }
    }

    CALLHOOKOBJECTCREATE(hr,CLSID_NULL,riid,(IUnknown **)ppv);
    return hr;
}

//+-------------------------------------------------------------------
//
//  Member:     CStdIdentity::CreateCall, public
//
//  Synopsis:   Create an async call object.
//
//  History:    15-Jul-98   Gopalk    Aggregation changes
//
//--------------------------------------------------------------------
STDMETHODIMP CStdIdentity::CreateCall(REFIID asyncIID, LPUNKNOWN pCtrlUnk,
                                      REFIID objIID, LPUNKNOWN *ppUnk)
{
    ComDebOut((DEB_CHANNEL,
               "CStdIdentity::CreateCall  asyncIID:%I pCtrlUnk:%x "
               "objIID:%I ppUnk:%x\n", &asyncIID, pCtrlUnk, &objIID, ppUnk));
    ASSERT_LOCK_NOT_HELD(gComLock);


    HRESULT hr;

    // Ensure that caller asks for IUnknown when aggregating the call object
    if(pCtrlUnk && (objIID != IID_IUnknown))
    {
        hr = E_INVALIDARG;
    }
    else
    {
        IID syncIID;

        // Obatin the sync IID corresponding to the requested async IID
        hr = GetSyncIIDFromAsyncIID(asyncIID, &syncIID);
        if(SUCCEEDED(hr))
        {
            // Ensure that proxy for the sync IID is available
            if ((syncIID != IID_IUnknown) && (syncIID != IID_IMultiQI))
            {
                IUnknown *pUnkTest;
                hr =  QueryInterface(syncIID, (void **) &pUnkTest);
                if(SUCCEEDED(hr))
                    pUnkTest->Release();
            }

            // Create the call object
            if(SUCCEEDED(hr))
            {
                IUnknown *pInnerUnk = NULL;
                PVOID pCallMgr;
                if ((syncIID == IID_IUnknown) || (syncIID == IID_IMultiQI))
                {
                    pCallMgr = new CAsyncUnknownMgr(pCtrlUnk, syncIID, asyncIID,
                                                    this, 0, hr, &pInnerUnk);
                }
                else
                {
                    pCallMgr = new CClientCallMgr(pCtrlUnk, syncIID, asyncIID,
                                                  this, 0, hr, &pInnerUnk);
                }
                if(pCallMgr)
                {
                    if(SUCCEEDED(hr))
                    {
                        // Obtain the requested interface on the call object
                        if(pCtrlUnk == NULL)
                        {
                            hr = pInnerUnk->QueryInterface(objIID, (void **)ppUnk);

                            // Fix up the refcount. This could be the last release
                            // if the above call failed
                            pInnerUnk->Release();
                        }
                        else
                            *ppUnk = pInnerUnk;
                    }
                    else
                    {
                        // failure in the ctor, release the call object.
                        pInnerUnk->Release();
                    }
                }
                else
                {
                    hr = E_OUTOFMEMORY;
                }
            }
        }
    }

    ASSERT_LOCK_NOT_HELD(gComLock);
    ComDebOut((DEB_CHANNEL, "CStdIdentity::CreateCall hr:%x\n", hr));
    return hr;
}

//+-------------------------------------------------------------------
//
//  Member:     CStdIdentity::GetWrapperForContext
//
//  Synopsis:   Finds or creates a valid wrapper for our server object
//              in the requested context.
//
//  Arguments:  pCtx- The client context for the wrapper
//              riid- The IID of the returned wrapper
//              ppv-  Pointer to the return location
//
//  History:    29-Sep-00   JohnDoty      Created
//
//+-------------------------------------------------------------------
STDMETHODIMP CStdIdentity::GetWrapperForContext(CObjectContext *pCtx,
                                                REFIID riid,
                                                void **ppv)
{
    HRESULT hr = E_UNEXPECTED;

    // Get or create the wrapper for this object.
    CIDObject *pID = GetIDObject();
    if (pID)
    {
        // If we don't have a server, we cannot create a wrapper.
        // REVIEW: Can we change this?  Should we change this?
        BOOL fCreate = GetCtrlUnk() ? TRUE : FALSE;
        CStdWrapper *pStdWrapper = NULL;

        // Make sure to hold the lock across GetOrCreateWrapper()
        LOCK(gComLock);
        hr = pID->GetOrCreateWrapper(fCreate, 0, &pStdWrapper);
        UNLOCK(gComLock);

        if (SUCCEEDED(hr))
        {            
            // Now that we have the wrapper, get the proxy for the server
            // on it.
            hr = pStdWrapper->WrapInterfaceForContext(pCtx, NULL, riid, ppv);

            // Since WrapInterfaceForContext does not give us a new reference,
            // we'll re-use the one from GetOrCreateWrapper if it succeeded.
            if (FAILED(hr))
            {
                pStdWrapper->InternalRelease(NULL);
            }
        }
    }

    return hr;
}

//+-------------------------------------------------------------------
//
//  Function:   ObtainStdIDFromUnk      Private
//
//  Synopsis:   Obtains the StdID representing the server object
//              Modified version of LookupIDFromUnk
//
//  History:    10-Mar-98   Gopalk      Created
//
//+-------------------------------------------------------------------
HRESULT ObtainStdIDFromUnk(IUnknown *pUnk, DWORD dwAptId, CObjectContext *pServerCtx,
                           DWORD dwFlags, CStdIdentity **ppStdID)
{
    // QI for IStdID; if ok, return that
    if (SUCCEEDED(pUnk->QueryInterface(IID_IStdIdentity, (void **) ppStdID)))
        return S_OK;

    // Obtain pointer id
    IUnknown *pServer;
    if (FAILED(pUnk->QueryInterface(IID_IUnknown, (void **) &pServer)))
        return E_UNEXPECTED;

    BOOL fCreate = (dwFlags & IDLF_CREATE) ? TRUE : FALSE;

    // Acquire lock
    ASSERT_LOCK_NOT_HELD(gComLock);
    LOCK(gComLock);

    // Lookup StdID for the server object
    CIDObject *pID = NULL;
    HRESULT hr = gPIDTable.FindOrCreateIDObject(pServer, pServerCtx, fCreate,
                                                dwAptId, &pID);

    if (SUCCEEDED(hr))
    {
        hr = pID->GetOrCreateStdID(fCreate, dwFlags, ppStdID);
    }

    UNLOCK(gComLock);
    ASSERT_LOCK_NOT_HELD(gComLock);

    if (pID) {

        if (FAILED (hr))
        {
            // The call to GetOrCreateStdID failed for some reason.
            // If pID doesn't have an StdID here, then it wasn't Addref'd
            // and may be released below without having been marked as a 'zombie',
            // causing an Assert to be fired during debug builds (COM+ BUG 14310)
            //
            // Calling StdIDRelease will ensure that if pID has no StdID (either via
            // the call made above or through another thread's intervention), 
            // the object will marked as a 'zombie' when it is released
            
            ComDebOut((DEB_CHANNEL, "GetOrCreateStdID failed, calling StdIDRelease hr:%x\n", hr));
            pID->StdIDRelease();
        }
        
        pID->Release();
    }
    
    pServer->Release();
    return hr;
}

//+-------------------------------------------------------------------
//
//  Function:   GetStdId, private
//
//  Synopsis:   Creates a std id.
//
//  Arguments:  [punkOuter] - controlling unknown
//              [ppv] - The coresponding identity object if successfull
//
//  Returns:    S_OK - have the identity object
//
//  History:    16-Nov-96   Rickhi  Created
//              12-Mar-98   Gopalk  Modified for new ID Tables
//
//--------------------------------------------------------------------
INTERNAL GetStdId(IUnknown *punkOuter, IUnknown **ppUnkInner)
{
    HRESULT hr = E_OUTOFMEMORY;

    DWORD dwAptId = GetCurrentApartmentId();
    BOOL fSuccess = FALSE;
    
    CStdIdentity *pStdID = new CStdIdentity(STDID_SERVER, dwAptId,
                                            punkOuter, punkOuter,
                                            ppUnkInner, &fSuccess);

    if (pStdID && fSuccess == FALSE)
    {
    	delete pStdID;
    	pStdID = NULL;
    }
    
    if (pStdID)
    {
        Win4Assert(pStdID->IsAggregated());

        // Obtain an OID for the server object
        MOID moid;
        hr = GetPreRegMOID(&moid);

        if (SUCCEEDED(hr))
        {
            ASSERT_LOCK_NOT_HELD(gComLock);
            LOCK(gComLock);

            // Ensure the StdID has not already been created
            // for the server object
            CIDObject *pID = NULL;
            hr = gPIDTable.FindOrCreateIDObject(punkOuter, GetCurrentContext(),
                                                TRUE /*fCreate*/, dwAptId,
                                                &pID);
            if (SUCCEEDED(hr))
            {
                if (pID->GetStdID() == NULL)
                {
                    // Set object identity inside StdID. This
                    // will AddRef the IDObject.
                    pStdID->SetIDObject(pID);

                    // Set the StdID inside object identity
                    pID->SetStdID(pStdID);

                    // Establish OID for the object. This registers it
                    // with the gOIDTable.
                    pStdID->SetOID(moid);
                }
                else
                {
                    hr = RPC_E_TOO_LATE;
                }
            }

            UNLOCK(gComLock);
            ASSERT_LOCK_NOT_HELD(gComLock);

            if (pID)
            {
                // release the reference to the IDObject
                pID->Release();
            }
        }

        if (FAILED(hr))
        {
            (*ppUnkInner)->Release();
            *ppUnkInner = NULL;
        }
    }

    return hr;
}

//+-------------------------------------------------------------------
//
//  Function:   ObtainStdIDFromOID      Private
//
//  Synopsis:   Obtains the StdID representing the server object
//              Modified version of LookupIDFromID
//
//  History:    10-Mar-98   Gopalk      Created
//
//+-------------------------------------------------------------------
HRESULT ObtainStdIDFromOID(REFMOID moid, DWORD dwAptId, BOOL fAddRef,
                           CStdIdentity **ppStdID)
{
    ASSERT_LOCK_HELD(gComLock);

    CStdIdentity *pStdID = NULL;

    // Lookup the OID in OID table
    CIDObject *pID = gOIDTable.Lookup(moid, dwAptId);
    if(pID)
    {
        // Obtain the StdID
        pStdID = pID->GetStdID();
        if(fAddRef && pStdID)
           pStdID->AddRef();

        // This cannot be the last release
        pID->Release();
    }

    // Initialize
    *ppStdID = pStdID;

    return (pStdID == NULL) ? CO_E_OBJNOTREG : NOERROR;
}

#if DBG == 1
//+-------------------------------------------------------------------
//
//  Function:   Dbg_FindRemoteHdlr
//
//  Synopsis:   finds a remote object handler for the specified object,
//              and returns an instance of IMarshal on it. This is debug
//              code for assert that reference counts are as expected and
//              is used by tmarshal.exe.
//
//  History:    23-Nov-93   Rickhi       Created
//              23-Dec-93   CraigWi      Changed to identity object
//
//--------------------------------------------------------------------
extern "C" IMarshal * _stdcall Dbg_FindRemoteHdlr(IUnknown *punkObj)
{
    //  validate input parms
    Win4Assert(punkObj);

    IMarshal *pIM = NULL;
    CStdIdentity *pStdID = NULL;

    // Try to obtain the StdID from the current apartment/context.
    //
    HRESULT hr = ObtainStdIDFromUnk(punkObj,
                                    GetCurrentApartmentId(),
                                    GetCurrentContext(),
                                    0,
                                    &pStdID);

    // If no StdID in this apartment/context, switch to the NA and
    // try again.
    //
    if (FAILED(hr))
    {
        // Switch thread to the NA.
        CObjectContext *pSavedCtx = EnterNTA(g_pNTAEmptyCtx);

        hr = ObtainStdIDFromUnk(punkObj,
                                GetCurrentApartmentId(),
                                GetCurrentContext(),
                                0,
                                &pStdID);

        // Pop back to the apartment the thread was in on entry.
        //
        pSavedCtx = LeaveNTA(pSavedCtx);
        Win4Assert(pSavedCtx == g_pNTAEmptyCtx);
    }

    if (hr == NOERROR)
    {
        pIM = (IMarshal *)pStdID;
    }

    return pIM;
}
#endif  //  DBG==1
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\com\dcomrem\surract.cxx ===
//+-------------------------------------------------------------------
//
//  File:       surract.cxx
//
//  Contents:   Implementation of surrogate process activator
//
//  Classes:    CSurrogateProcessActivator
//
//  History:    08-Apr-98   SteveSw      Created
//
//--------------------------------------------------------------------

#include <ole2int.h>
#include <activate.h>
#include <catalog.h>
#include <resolver.hxx>
#include <stdid.hxx>
#include <comsrgt.hxx>
#include <srgtprot.h>
#include <unisrgt.h>
#include <surract.hxx>
#include <netevent.h>

HRESULT CheckMemoryGate(IUnknown *punk, ResourceGateId id);

//=========================================================================
//
//  CSurrogateProcessActivator Class Definition
//
//  This class is not intended to be used in inheritance. It's not intended
//  that more than one of these exist in a particular process. In
//  particular, some of the resolver tools used to communicate with the SCM
//  won't work if you create several of these.
//
//-------------------------------------------------------------------------

class CSurrogateProcessActivator :
public CSurrogateActivator,
public ISurrogate,
public IPAControl,
public IProcessInitControl
{
    // Constructors and destructors.

public:
    CSurrogateProcessActivator();
    ~CSurrogateProcessActivator();
	
    HRESULT Initialize();

    inline void SetProcessGUID(REFGUID processGuid)
    {
        extern GUID g_AppId;

        g_AppId = processGuid;
        m_processGuid = processGuid;
    }

    // Our IUnknown implementation

public:
    STDMETHOD(QueryInterface)(REFIID riid, void** ppv);
    STDMETHOD_(ULONG, AddRef)(void);
    STDMETHOD_(ULONG, Release)(void);

private:
    LONG m_lRC;


    // Methods and members that handle the dialog between Surrogate and SCM.

public:
    STDMETHOD(TellSCMWeAreStarted)(REFGUID rguidProcessID);
    STDMETHOD(TellSCMWeAreReady)(void);
    STDMETHOD(TellSCMWeAreDone)(void);
    STDMETHOD(TellSCMWeAreInitializing)(void);

private:
    static DWORD WINAPI StartNTService(LPVOID ptr);
    static DWORD WINAPI PingSCM(LPVOID ptr);
    STDMETHOD(StartSendingSCMPings)(void);
    STDMETHOD(StopSendingSCMPings)(void);

    HANDLE m_hInitThread;

public:
    HANDLE m_hStopPingingSCM;

    static const PING_INTERVAL;

    // Methods and members that open the catalog, read from it, stash
    // away data found there, and/or act on the data while it's available.
    // Several of these methods feed later groups of functions, in that they
    // stash away data used by them.

public:
    STDMETHOD(OpenCatalog)(REFGUID rguidProcessID);
    STDMETHOD(StartNTServiceIfNecessary)(void);
    STDMETHOD(WaitForNTServiceIfNecessary)(void);
    STDMETHOD(SetupSecurity)(void);
    STDMETHOD(SetupSurrogateTimeout)(void);
    STDMETHOD(AreServicesRequired)(void);
    STDMETHOD(SetupFusionContext)(void);
    STDMETHOD(CloseCatalog)(void);

private:
    IComProcessInfo* m_pIComProcessInfo;
    IProcessServerInfo* m_pIProcessServerInfo;
    CStdIdentity *m_pStdID;


    // These members are about ISurrogate interfaces. An ISurrogate interface
    // is passed down to us from the Surrogate host program; we store it,
    // and pass along an ISurrogate interface implemeneted by this class to
    // the COM infrastructure. The infrastructure calls our FreeSurrogate()
    // method when the process becomes inactive; we pass the call along to
    // the Surrogate host program when timeouts and locks are all right.
public:
    STDMETHOD(StoreISurrogate)(ISurrogate* pISurrogate);
    STDMETHOD(RemoveISurrogate)(void);
    STDMETHOD(LoadDllServer)(REFCLSID rclsid);
    STDMETHOD(FreeSurrogate)(void);

private:
    ISurrogate* m_pISurrogate;


    // These methods initialize the COMSvcs modules as requested in the
    // catalog, and then delete them later.  The HINSTANCE is for the COMSVCS.DLL.
    // IPAControl methods follow

public:
    STDMETHOD(InitializeServices)(REFGUID rguidProcessID);
    STDMETHOD(CleanupServices)(void);
    STDMETHOD(WaitForInitCompleted)(ULONG ulStartingCount, ULONG ulMaxWaits);

private:
    HINSTANCE      m_hCOMSVCS;
    IServicesSink* m_pServices;
    HANDLE         m_hInitCompleted;
    HANDLE         m_hFusionContext;
    ULONG          m_ulServicesPing;
    ULONG          m_ulInitTimeout;

    static const TIMEOUT_SERVICES;

public:
    STDMETHOD_(ULONG, AddRefOnProcess)(void);
    STDMETHOD_(ULONG, ReleaseRefOnProcess)(void);
    STDMETHOD_(void, PendingInit)(void);
    STDMETHOD_(void, ServicesReady)(void);
    STDMETHOD(SuspendApplication)( REFGUID rguidApplID );
    STDMETHOD(PendingApplication)( REFGUID rguidApplID );
    STDMETHOD(ResumeApplication)( REFGUID rguidApplID );
    STDMETHOD(SuspendAll)(void);
    STDMETHOD(ResumeAll)(void);
    STDMETHOD(ForcedShutdown)(void);
	STDMETHOD(SetIdleTimeoutToZero)(void);
	STDMETHOD(SetObjectCountAtIdleTime)(DWORD dwObjectCount);
	        
private:
    LONG m_lProcessRefCount;

    // These methods and members implement the surrogate timeout logic. They're
    // fed by StoreISurrogate() and SetupSurrogateTimeout(), above. Check out
    // the description of the state transitions in the timeout logic, below.
private:
    CRITICAL_SECTION m_timeoutLock;
    BOOL m_bLockValid;
    HANDLE m_hTimeoutEvent;
    static DWORD WINAPI SurrogateTimeout(LPVOID ptr);
    STDMETHOD(BeginSurrogateTimeout)(void);
    STDMETHOD(ActivationBegins)(void);
    STDMETHOD(ActivationSucceeds)(void);
    STDMETHOD(ActivationFails)(void);

public:
    STDMETHOD(WaitForSurrogateTimeout)(void);

private:
    void LockTimeoutState()
    {
        EnterCriticalSection(&m_timeoutLock);
    }
    void UnlockTimeoutState()
    {
        LeaveCriticalSection(&m_timeoutLock);
    }

    enum
    {
        TIMEOUT_INACTIVE,
        TIMEOUT_PENDING,
        TIMEOUT_SUSPENDED,
        TIMEOUT_HAPPENING,
        TIMEOUT_FORCED_SHUTDOWN
    } m_timeoutState;
	
	// We had problems with VB objects Av'ing when we shutdown immediately upon
	// idle.    To avoid this we remain idle for this minimum # of milliseconds
    #define MINIMUM_IDLE_SHUTDOWN_PERIOD_MSEC    5000      

    ULONG m_cActivations;
    ULONG m_cMillisecondsTilDeath;
    DWORD m_cTimeoutPeriod;
    BOOL  m_bPaused;

    static const TIMEOUT_SPINLOCK;

public:
    // These methods implement the IProcessInitControl interface, used by COM+
    // user process-initialization to ping us (so that we don't think they are
    // wedged).
    STDMETHOD(ResetInitializerTimeout)(DWORD dwSecondsRemaining);

private:
    BOOL  m_bInitNotified;


    // The SPA provides the SCM an ILocalSystemActivator interface. This is
    // the portal through which all out-of-process activations arrive in
    // the process from the SCM. In some sense this is our raison-d'etre.
public:
    STDMETHOD(GetClassObject)(IActivationPropertiesIn *pActPropsIn,
                              IActivationPropertiesOut **ppActPropsOut);

    STDMETHOD(CreateInstance)(IUnknown *pUnkOuter,
                              IActivationPropertiesIn *pActPropsIn,
                              IActivationPropertiesOut **ppActPropsOut);
    STDMETHOD(ObjectServerLoadDll)(GUID* pclsid, STATUSTYPE* pStatus);


    // These methods are to support running as an NT Service
public:
    static void NTServiceMain        (DWORD argc, LPWSTR *argv);
    static void NTServiceCtrlHandler (DWORD code);

private:
    static const int      MAX_SRV_NAME_LEN = 255;
    
    HANDLE                m_hNTServiceThread;
    HANDLE                m_hServiceStarted;
    SERVICE_STATUS_HANDLE m_hNTServiceHandle;
    SERVICE_STATUS        m_NTServiceStatus;
    CRITICAL_SECTION      m_serviceStatusLock;
    BOOL                  m_fServiceStatusLockValid;
    WCHAR                 m_NTServiceName[MAX_SRV_NAME_LEN+1];
};


//=========================================================================
//
//  TIMEOUT_SPINLOCK controls the spinlock behavior of the critical section
//  used to guard the state of the activity timeout mechanism.
//
//      TIMEOUT_SERVICES is the duration within which COMSVCS must ping us or
//      we will fail initialization assuming it is hung or otherwise confused.
//
//  s_pCSPA is the static pointer to the single CSurrogateProcessActivator
//  object we create here. It's an object because, hey, we're object
//  oriented folks here, right? And I guess there's the namespace issues.
//
//-------------------------------------------------------------------------

const CSurrogateProcessActivator::TIMEOUT_SPINLOCK = 1000;
const CSurrogateProcessActivator::TIMEOUT_SERVICES = 20000;
const CSurrogateProcessActivator::PING_INTERVAL    = 30000;

CSurrogateProcessActivator* s_pCSPA = NULL;
CSurrogateActivator* CSurrogateActivator::s_pCSA = NULL;

// these are typical values for the WaitForInitCompleted() routine
#define INIT_STARTING   1
#define MAX_WAITS       6


//============================================================================
//
//  Function:   CoRegisterSurrogateEx (public)
//
//  Synopsis:   Called by a surrogate host process to register itself with
//                              COM.
//
//  History:    08-Apr-98   SteveSw      Created
//              13-Dec-99   JohnDoty     Modified to support running as
//                                       an NT Service
//
//----------------------------------------------------------------------------

STDAPI CoRegisterSurrogateEx (REFGUID rguidProcessID, ISurrogate* pSrgt)
{
    HRESULT hr = E_FAIL;
    BOOL    fLoadServices = FALSE;

    //  Error checking
    if ( s_pCSPA != NULL )
    {
        return CO_E_ALREADYINITIALIZED;
    }
    if ( !IsApartmentInitialized() )
    {
        return CO_E_NOTINITIALIZED;
    }


    //  Create the controlling CSurrogateProcessActivator object. Notify the
    //  SCM that we're beginning our initialization.
    s_pCSPA = new CSurrogateProcessActivator;
    if ( s_pCSPA == NULL )
    {
        return E_OUTOFMEMORY;
    }

    hr = s_pCSPA->Initialize();
    if (FAILED(hr))
    {       
        s_pCSPA->Release();
        s_pCSPA = NULL;
        return hr;
    }

    //  Open up the catalog, and pull out all the data we need to remember
    //  in order to make everything else work. The error logic here is,
    //  we bail if we had problems with the catalog. The only cleanup we
    //  have to do is with the SCM.

    hr = s_pCSPA->OpenCatalog(rguidProcessID);
    if ( SUCCEEDED(hr) )
    {
        hr = s_pCSPA->StartNTServiceIfNecessary();
    }
    if ( SUCCEEDED(hr) )
    {
        hr = s_pCSPA->SetupFusionContext();
    }
    if ( SUCCEEDED(hr) )
    {
        hr = s_pCSPA->SetupSecurity();
    }
    if ( SUCCEEDED(hr) )
    {
        hr = s_pCSPA->SetupSurrogateTimeout();
    }
    if ( SUCCEEDED(hr) )
    {
        fLoadServices = ( s_pCSPA->AreServicesRequired() == S_OK );
    }

    HRESULT hr2 = s_pCSPA->CloseCatalog();
    if ( FAILED(hr2) || FAILED(hr) )
    {
        goto cleanup;
    }

    //  Ensure there is a main threaded apartment by ensuring there is a DLLHost
    //  AT thread.  This ensures that none of the STA Pool threads become the
    //  main thread, which can produce unpredictable results

    IUnknown *pHostAct;
    hr = CoCreateInstance(CLSID_ATHostActivator,
                          NULL,
                          CLSCTX_ALL,
                          IID_IUnknown,
                          (void **) &pHostAct);

    if ( FAILED(hr) )
    {
        if (hr != REGDB_E_CLASSNOTREG)
        {
            goto cleanup;
        }
    }
    else
    {
        // release this object. we only wanted the side effect.
        pHostAct->Release();
    }

    //  If we're an NT service, wait until our NT service thread has told the
    //  NT SCM that we've started.  Otherwise, calling TellSCMWeAreStarted won't
    //  work very well.
    hr = s_pCSPA->WaitForNTServiceIfNecessary();
    if ( FAILED(hr) )
    {
        goto cleanup;
    }
    
    //  Now we tell the SCM we're starting up in earnest. The "bad thing"
    //  here would be if the total time between when DLLHOST is started and
    //  now was more than 90 seconds.
    hr = s_pCSPA->TellSCMWeAreStarted(rguidProcessID);
    if ( FAILED(hr) )
    {
        goto cleanup;
    }

    // Save process Guid
    s_pCSPA->SetProcessGUID(rguidProcessID);

    //  Do our real startup. We start up the services living undreneath us
    //  first, then we tell COM that we're running, and finally we tell the
    //  SCM that we're ready to accept activations. This order should avoid
    //  race conditions where one part of our infrastructure.
    if ( fLoadServices )
    {
        hr = s_pCSPA->InitializeServices(rguidProcessID);
        if ( FAILED(hr) )
        {
            hr = RPC_S_SERVER_TOO_BUSY;
            goto cleanup;
        }
    }

    hr = s_pCSPA->StoreISurrogate(pSrgt);
    if ( FAILED(hr) )
    {
        goto cleanup;
    }
    hr = s_pCSPA->TellSCMWeAreReady();
    if ( FAILED(hr) )
    {
        goto cleanup;
    }

    //  Now wait for the end

    hr = s_pCSPA->WaitForSurrogateTimeout();

    cleanup:
    (void) s_pCSPA->RemoveISurrogate();
    // Tell SCM we are done before cleaning up services to avoid deadlocks in 
    // the NT SCM.  (CleanupServices might try to start the System App service,
    // and if it does, then we need to be out of the 'starting' state.)
    (void) s_pCSPA->TellSCMWeAreDone();
    (void) s_pCSPA->CleanupServices();
    (void) s_pCSPA->Release();
    s_pCSPA = NULL;

    return hr;
}


//============================================================================
//
//  Constructors and destructors for CSurrogateProcessActivator
//
//----------------------------------------------------------------------------

//----------------------------------------------------------------------------
//
//  Member:     CSurrogateProcessActivator::CSurrogateProcessActivator
//
//  Synopsis:   Constructor for CSurrogateProcessActivator object. Does nothing
//                              but initializations
//
//  History:    08-Apr-98   SteveSw      Created
//
//----------------------------------------------------------------------------
CSurrogateProcessActivator::CSurrogateProcessActivator() :
m_cActivations(0),
m_cMillisecondsTilDeath(0),
m_cTimeoutPeriod(INFINITE),
m_pStdID(NULL),
m_hInitThread(NULL),
m_hNTServiceThread(NULL),
m_hServiceStarted(NULL),
m_fServiceStatusLockValid(FALSE),
m_hStopPingingSCM(NULL),
m_hTimeoutEvent(NULL),
m_hFusionContext(INVALID_HANDLE_VALUE),
m_lRC(0),
m_hCOMSVCS(NULL),
m_pServices(NULL),
m_hInitCompleted(NULL),
m_ulServicesPing(0),
m_pIComProcessInfo(NULL),
m_pIProcessServerInfo(NULL),
m_pISurrogate(NULL),
m_timeoutState(TIMEOUT_INACTIVE),
m_lProcessRefCount(0),
m_bPaused(FALSE),
m_bInitNotified(FALSE),
m_hNTServiceHandle(NULL),
m_bLockValid(FALSE),
m_ulInitTimeout(TIMEOUT_SERVICES)
{
    AddRef();
    s_pCSA = (CSurrogateActivator *) this;
    m_fServicesConfigured = FALSE;

    m_NTServiceStatus.dwServiceType      = SERVICE_WIN32;
    m_NTServiceStatus.dwCurrentState     = SERVICE_START_PENDING;
    m_NTServiceStatus.dwControlsAccepted = SERVICE_ACCEPT_STOP | SERVICE_ACCEPT_PAUSE_CONTINUE;
    m_NTServiceStatus.dwWin32ExitCode    = 0;
    m_NTServiceStatus.dwServiceSpecificExitCode = 0;
    m_NTServiceStatus.dwCheckPoint       = 0;
    m_NTServiceStatus.dwWaitHint         = PING_INTERVAL * 2;
}

//----------------------------------------------------------------------------
//
//  Member:     CSurrogateProcessActivator::Initialize
//
//  Synopsis:   Small init function to break out non-trivial init work from
//              the constructor.
//
//  History:    13-Apr-00   JSimmons   Created
//
//----------------------------------------------------------------------------
HRESULT CSurrogateProcessActivator::Initialize()
{
    m_hStopPingingSCM = CreateEvent(NULL, FALSE, FALSE, NULL);
    if (NULL == m_hStopPingingSCM)
        goto failed_win32;
    
    m_hTimeoutEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
    if (NULL == m_hTimeoutEvent)
        goto failed_win32;
        
    m_hInitCompleted = CreateEvent(NULL, FALSE, FALSE, NULL);
    if (NULL == m_hInitCompleted)
        goto failed_win32;

    m_hServiceStarted = CreateEvent(NULL, FALSE, FALSE, NULL);
    if (NULL == m_hServiceStarted)
        goto failed_win32;

    m_bLockValid = InitializeCriticalSectionAndSpinCount(&m_timeoutLock, TIMEOUT_SPINLOCK);
    if (!m_bLockValid)
        goto failed_win32;

    m_fServiceStatusLockValid = InitializeCriticalSectionAndSpinCount(&m_serviceStatusLock,
                                                                      TIMEOUT_SPINLOCK);
    if (!m_fServiceStatusLockValid)
        goto failed_win32;
        
	return S_OK;
    
failed_win32:

    return HRESULT_FROM_WIN32(GetLastError());
}

//----------------------------------------------------------------------------
//
//  Member:     CSurrogateProcessActivator::~CSurrogateProcessActivator
//
//  Synopsis:   Constructor for CSurrogateProcessActivator object. Should be
//                              able to cleanup from any state. Relies on the idempotency of
//                              each independent initialization/cleanup routine
//
//  History:    08-Apr-98   SteveSw      Created
//
//----------------------------------------------------------------------------

CSurrogateProcessActivator::~CSurrogateProcessActivator()
{
    s_pCSA = NULL;

    if (m_hStopPingingSCM != NULL)
    {
        CloseHandle (m_hStopPingingSCM);
    }

    if (m_hTimeoutEvent != NULL)
    {
        CloseHandle (m_hTimeoutEvent);
    }

    if (m_hInitCompleted != NULL)
    {
        CloseHandle (m_hInitCompleted);
    }

    if (m_hServiceStarted)
    {
        CloseHandle (m_hServiceStarted);
    }
    
    if (m_bLockValid)
    {
        DeleteCriticalSection (&m_timeoutLock);
    }

    if (m_fServiceStatusLockValid)
    {
        DeleteCriticalSection (&m_serviceStatusLock);
    }

    // check that the services DLL (if any) has been released and free'd
    if ( m_pServices )
    {
        m_pServices->Release();
    }

    if( m_hFusionContext != INVALID_HANDLE_VALUE)
    {
        ReleaseActCtx(m_hFusionContext);
    }

    if ( m_hCOMSVCS )
    {
        FreeLibrary( m_hCOMSVCS );
    }
}


//============================================================================
//
//  IUnknown implementation for CSurrogateProcessActivator
//
//----------------------------------------------------------------------------

//----------------------------------------------------------------------------
//
//  Member:     CSurrogateProcessActivator::QueryInterface
//
//  Synopsis:   Garden-variety QI() implementation for object
//
//  History:    08-Apr-98   SteveSw      Created
//
//----------------------------------------------------------------------------

STDMETHODIMP CSurrogateProcessActivator::QueryInterface(REFIID riid, void** ppv)
{
    if ( ppv == NULL )
    {
        return E_POINTER;
    }

    if ( riid == IID_ILocalSystemActivator || riid == IID_IUnknown )
    {
        *ppv = (ILocalSystemActivator*)(this);
    }
    else if ( riid == IID_ISurrogate )
    {
        *ppv = static_cast<ISurrogate*>(this);
    }
    else if ( riid == IID_IPAControl )
    {
        *ppv = static_cast<IPAControl*>(this);
    }
    else if ( riid == IID_IProcessInitControl )
    {
        *ppv = static_cast<IProcessInitControl*>(this);
    }
    else
    {
        return E_NOINTERFACE;
    }

    reinterpret_cast<IUnknown*>(*ppv)->AddRef();
    return S_OK;
}

//----------------------------------------------------------------------------
//
//  Member:     CSurrogateProcessActivator::AddRef
//
//  Synopsis:   Garden-variety AddRef() implementation for object
//
//  History:    08-Apr-98   SteveSw      Created
//
//----------------------------------------------------------------------------

STDMETHODIMP_(ULONG) CSurrogateProcessActivator::AddRef(void)
{
    LONG lRC = 0xcdcdcdcd;

    lRC = InterlockedIncrement(&m_lRC);
    return lRC;
}

//----------------------------------------------------------------------------
//
//  Member:     CSurrogateProcessActivator::Release
//
//  Synopsis:   Garden-variety Release() implementation for object
//
//  History:    08-Apr-98   SteveSw      Created
//
//----------------------------------------------------------------------------

STDMETHODIMP_(ULONG) CSurrogateProcessActivator::Release(void)
{
    LONG lRC = 0xcdcdcdcd;

    lRC = InterlockedDecrement(&m_lRC);
    if ( lRC == 0 )
    {
        delete this;
    }
    return lRC;
}


//============================================================================
//
//  Methods that communicate with the SCM. These rely heavily on the gResolver
//  methods to abstract from the grotty details of communicating with the SCM.
//  They add is the logic to go fetch the IPID for this's ILocalSystemActivator
//  interface, and to deal with the periodic ping's we need to send them SCM
//  if it's taking us a long time to come up.
//
//  The SCM expects four different messages from us. "Started" means we have
//  started to come up. "Initializing" means, don't worry, we're still coming
//  up. "Ready" means we're ready for activations. "Stopped" means we're no
//  longer capable of handling activations.
//
//  These routines need not be thread-safe. We can count on them being called
//  during CoRegisterSurrogateEx(), and then from the Timeout worker thread
//  (there should only ever be one of those, and it won't appear until
//  after CoRegisterSurrogateEx() returns -- if it does, go ahead and grab
//  the TimeoutState lock in that routine, which will block all activations
//  and timeout activity while it's held).
//
//  The Initializing methods are sent to the SCM every thirty seconds, between
//  the times we say "Started" and "Ready". This is done by spinning up a
//  thread that just loops over a 30-second sleep and a call to the resolver
//  to send the ping. To stop these messages, we just hammer the thread.
//
//----------------------------------------------------------------------------

//----------------------------------------------------------------------------
//
//  Member:     CSurrogateProcessActivator::TellSCMWeAreStarted
//
//  Synopsis:   Using gResolver, tell the SCM that we're beginning to
//                              initialize ourselves for this ProcessID
//
//  History:    08-Apr-98   SteveSw      Created
//              15-Jun-98   GopalK       Simplified marshaling
//
//----------------------------------------------------------------------------

STDMETHODIMP CSurrogateProcessActivator::TellSCMWeAreStarted(REFGUID rguidProcessID)
{
    HRESULT hr = E_FAIL;
    ProcessActivatorToken       procActToken;

    // This routine is called to register the interface with the bowels of
    // COM, so that we can get the IPID back we need in order to let the SCM
    // know how to pass activation requests for this processID back to the
    // surrogate.
    OBJREF objref;
    hr = MarshalInternalObjRef(objref,
                               IID_ILocalSystemActivator,
                               (ILocalSystemActivator*)(this),
                               MSHLFLAGS_NORMAL | MSHLFLAGS_NOPING, (void **) &m_pStdID);

    // gResolver's NotifySurrogateStarted() method needs this special
    // token to identify our ILocalSystemActivator interface to the SCM. We
    // build it and pass it to gResolver
    if ( SUCCEEDED(hr) )
    {
        procActToken.ProcessGUID = rguidProcessID;
        procActToken.ActivatorIPID = objref.u_objref.u_standard.std.ipid;
        procActToken.dwFlags = 0;  // flags field not currently being used

        hr = gResolver.NotifySurrogateStarted(&procActToken);
        FreeObjRef(objref);
    }
    else
        m_pStdID = NULL;

    // Once we've told the SCM we're starting, we kick off a process that
    // will periodically remind it that we're still here.
    if ( SUCCEEDED(hr) )
    {
        hr = StartSendingSCMPings();
    } 
    else 
    {
        if (m_pStdID)
        {
            ((CStdMarshal *) m_pStdID)->Disconnect(DISCTYPE_SYSTEM);
            m_pStdID->Release();
            m_pStdID = NULL;
        }
    }

    // Report....
    return hr;
}

//----------------------------------------------------------------------------
//
//  Member:     CSurrogateProcessActivator::TellSCMWeAreReady
//
//  Synopsis:   Using gResolver, tell the SCM that we're ready for activations
//                              for objects with this ProcessID. First, turn off those pings!
//
//  History:    08-Apr-98   SteveSw      Created
//
//----------------------------------------------------------------------------

STDMETHODIMP CSurrogateProcessActivator::TellSCMWeAreReady()
{
    HRESULT hr = E_FAIL;

    hr = StopSendingSCMPings();
    if ( SUCCEEDED(hr) )
    {
        // Hold the lock whenever we are changing the dwCurrentState.
        EnterCriticalSection(&m_serviceStatusLock);
        m_NTServiceStatus.dwCurrentState = SERVICE_RUNNING;
        m_NTServiceStatus.dwCheckPoint   = 0;
        m_NTServiceStatus.dwWaitHint     = 0;
        LeaveCriticalSection(&m_serviceStatusLock);

        if (m_hNTServiceHandle)
        {
            if (!SetServiceStatus (m_hNTServiceHandle, &(m_NTServiceStatus)))
            {
                DWORD err = GetLastError();
                hr = HRESULT_FROM_WIN32(err);
            }
        }

        if ( SUCCEEDED(hr) )
            hr = gResolver.NotifySurrogateReady();
    }
    
    return hr;
}

//----------------------------------------------------------------------------
//
//  Member:     CSurrogateProcessActivator::TellSCMWeAreDone
//
//  Synopsis:   The role of this routine is to be ready, regardless of the
//                              state of things, to clean up after the SCM connection tools.
//
//  History:    08-Apr-98   SteveSw      Created
//              15-Jun-98   GopalK       Simplified destruction
//
//----------------------------------------------------------------------------

STDMETHODIMP CSurrogateProcessActivator::TellSCMWeAreDone()
{
    HRESULT                     hr                      = S_OK;
    ILocalSystemActivator*      pILocalSystemActivator  = NULL;

    // If we call this while we're pinging, we stop that first. Then, if we
    // have a valid objref to ourselves (we created it when we told the SCM
    // we were starting), we tell the SCM we're stopping, release the objref,
    // and then free it. This undoes all the stuff we did to the infrastructure
    // when we first created the marshaled internal objref.
    (void) StopSendingSCMPings();

    if (m_hNTServiceHandle)
    {
        // Hold the lock whenever changing the service state.  Here we change
        // it to SERVICE_STOPPED, which means nobody else will set the state
        // ever again.
        EnterCriticalSection(&m_serviceStatusLock);        
        m_NTServiceStatus.dwCurrentState = SERVICE_STOPPED;
        m_NTServiceStatus.dwCheckPoint   = 0;
        m_NTServiceStatus.dwWaitHint     = 0;
        LeaveCriticalSection(&m_serviceStatusLock);

        if (!SetServiceStatus (m_hNTServiceHandle, &(m_NTServiceStatus)))
        {
            DWORD err = GetLastError();
            hr = HRESULT_FROM_WIN32(err);
        }
    }

    if ( m_pStdID )
    {
        (void) gResolver.NotifySurrogateStopped();
        ((CStdMarshal *) m_pStdID)->Disconnect(DISCTYPE_SYSTEM);
        m_pStdID->Release();
        m_pStdID = NULL;
    }

    return hr;
}

//----------------------------------------------------------------------------
//
//  Member:     CSurrogateProcessActivator::TellSCMWeAreInitializing
//
//  Synopsis:   This routine tells the SCM that we're transitioning into the
//              "running user initializer" state.  This state is used by COM+
//              to allow for potentially very long-running initializations.
//
//  History:    24-May-01   JohnDoty     Created
//
//----------------------------------------------------------------------------

STDMETHODIMP CSurrogateProcessActivator::TellSCMWeAreInitializing()
{
    HRESULT hr = S_OK;

    if (!m_bInitNotified)
    {
        // Make sure we only tell the SCM once (since this can be called from
        // wherever).
        BOOL fOrig = (BOOL)InterlockedCompareExchange((LONG *)&m_bInitNotified, TRUE, FALSE);
        if (!fOrig)
        {
            hr = gResolver.NotifySurrogateUserInitializing();
            if (FAILED(hr))
                m_bInitNotified = FALSE; // Oops.
        }
    }

    return hr;
}

//----------------------------------------------------------------------------
//
//  Member:     CSurrogateProcessActivator::PingSCM
//
//  Synopsis:   This thread just loops, sending an Initialize() message to the
//                              SCM every thirty seconds. To stop the messages, kill the
//                              thread.
//
//  History:    08-Apr-98   SteveSw      Created
//
//----------------------------------------------------------------------------

DWORD WINAPI CSurrogateProcessActivator::PingSCM(LPVOID ptr)
{
    HRESULT hr = E_FAIL;
    CSurrogateProcessActivator* pSCPA = static_cast<CSurrogateProcessActivator*>(ptr);

    while ( WaitForSingleObject( pSCPA->m_hStopPingingSCM, PING_INTERVAL ) == WAIT_TIMEOUT )
    {
        if (pSCPA->m_hNTServiceHandle)
        {
            pSCPA->m_NTServiceStatus.dwCheckPoint++;
            SetServiceStatus(pSCPA->m_hNTServiceHandle, &(pSCPA->m_NTServiceStatus));
        }
        hr = gResolver.NotifySurrogateInitializing();
    }

    return 0;
}

//----------------------------------------------------------------------------
//
//  Member:     CSurrogateProcessActivator::StartSendingSCMPings
//
//  Synopsis:   Create the thread that will loop and send pings to the SCM
//                              every thirty seconds while we are starting up....
//
//  History:    08-Apr-98   SteveSw      Created
//
//----------------------------------------------------------------------------

STDMETHODIMP CSurrogateProcessActivator::StartSendingSCMPings(void)
{
    DWORD                       threadID            = 0xcdcdcdcd;

    if ( m_hInitThread == NULL )
    {
        m_hInitThread = CreateThread (NULL, 0,
                                      CSurrogateProcessActivator::PingSCM,
                                      (PVOID) this, 0, &threadID);
        if ( m_hInitThread == NULL )
        {
            return E_OUTOFMEMORY;
        }
    }
    return S_OK;
}

//----------------------------------------------------------------------------
//
//  Member:     CSurrogateProcessActivator::StopSendingSCMPings
//
//  Synopsis:   Undo whatever StartSendingSCMPings() did. In this case, kill
//                              the thread. Close its handle. Return.
//
//  History:    08-Apr-98   SteveSw      Created
//
//----------------------------------------------------------------------------

STDMETHODIMP CSurrogateProcessActivator::StopSendingSCMPings(void)
{
    DWORD dwRet = 0;

    if ( m_hInitThread != NULL )
    {
        SetEvent(m_hStopPingingSCM);
        dwRet = WaitForSingleObject(m_hInitThread, 20000);  // 20 second wait
        CloseHandle(m_hInitThread);
        m_hInitThread = NULL;
        return ( ( dwRet == WAIT_OBJECT_0 ) ? S_OK : RPC_S_SERVER_TOO_BUSY ) ;
    }
    return S_FALSE;
}


//============================================================================
//
//  Methods that communicate with the catalog. Basically, what we have here
//  is an OpenCatalog(), a CloseCatalog(), and a bunch of SetupXXX() routines,
//  once for each component of the system. Basically, OpenCatalog() caches
//  interface pointers to the Catalog objects required by the SetupXXX()
//  routines. CloseCatalog() is responsible for cleaning up this cache if
//  there are any interfaces lying about. The SetupXXX() methods fill
//  variables, but it is the responsibility of whatever routine cleans up
//  the XXX tools to clean up the variables read in from the catalog
//  (if such cleanup is needed).
//
//  Other than that, no rocket science.
//
//----------------------------------------------------------------------------

//----------------------------------------------------------------------------
//
//  Member:     CSurrogateProcessActivator::OpenCatalog
//
//  Synopsis:   Open up all the catalog interfaces we need to self-configure.
//
//  History:    08-Apr-98   SteveSw      Created
//
//----------------------------------------------------------------------------

STDMETHODIMP CSurrogateProcessActivator::OpenCatalog(REFGUID rguidProcessID)
{
    HRESULT hr = E_FAIL;

    // Failures are sent back to caller. We use the OLE global catalog pointer.
    // We hope to leave one or more of the other interfaces non-null. We only
    // get the interfaces if the pointers have NULL values. Otherwise, this
    // has probably been called twice.

    hr = InitializeCatalogIfNecessary();
    if ( FAILED(hr) )
    {
        return hr;
    }

    if ( m_pIComProcessInfo == NULL )
    {
        hr = gpCatalog->GetProcessInfo(rguidProcessID,
                                       IID_IComProcessInfo,
                                       (void**) &m_pIComProcessInfo);
    }
    if ( SUCCEEDED(hr) && m_pIProcessServerInfo == NULL )
    {
        hr = m_pIComProcessInfo->QueryInterface(IID_IProcessServerInfo,
                                                (void**) &m_pIProcessServerInfo);
    }

    return hr;
}

//----------------------------------------------------------------------------
//
//  Member:     CSurrogateProcessActivator::StartNTServiceIfNecessary()
//
//  Synopsis:   Register ourselves with the NT Service Control Manager if
//              we've been marked for activation as an NT service.
//
//  History:    13-Dec-99   JohnDoty      Created
//
//----------------------------------------------------------------------------

static const GUID APPID_SystemApp = 
{0x02D4B3F1,0xFD88,0x11D1,{0x96,0x0D,0x00,0x80,0x5F,0xC7,0x92,0x35}};

STDMETHODIMP CSurrogateProcessActivator::StartNTServiceIfNecessary (void)
{
    HRESULT hr = S_OK;
    WCHAR  *pServiceName = NULL;

    // Get the service name associated with this application...
    hr = m_pIComProcessInfo->GetServiceName (&pServiceName);
    if (hr == E_FAIL)
    {
        // E_FAIL is an OK thing to return, it just means "you aren't a service"
        hr = S_OK;
    } 
    else if (SUCCEEDED(hr) && pServiceName && (pServiceName[0]))
    {
        GUID *appid;
        hr = m_pIComProcessInfo->GetProcessId(&appid);

        // Special for the system application... it can't be paused or stopped
        if (SUCCEEDED(hr))
        {
            if (memcmp(appid, &APPID_SystemApp, sizeof(APPID_SystemApp)) == 0)
			{
                m_NTServiceStatus.dwControlsAccepted &= ~SERVICE_ACCEPT_PAUSE_CONTINUE;
			}

            // Fire up the thread that's going to register us with the SCM
            if ( m_hNTServiceThread == NULL )
            {
                if (lstrlenW (pServiceName) > MAX_SRV_NAME_LEN)
                {
                    hr = HRESULT_FROM_WIN32(ERROR_INVALID_SERVICENAME);
                }
                else
                {
                    lstrcpyW (m_NTServiceName, pServiceName);
                
                    m_hNTServiceThread = CreateThread (NULL, 0,
                                                   CSurrogateProcessActivator::StartNTService,
                                                   (PVOID) this, 0, NULL);
                    if ( m_hNTServiceThread == NULL )
                    {
                        hr = E_OUTOFMEMORY;
                    }
                }
            }
        }
    }

    return hr;
}

//----------------------------------------------------------------------------
//
//  Member:     CSurrogateProcessActivator::WaitForNTServiceIfNecessary()
//
//  Synopsis:   If we're an NT service, wait until we've told the NT SCM that
//              we're starting.
//
//  History:    15-Apr-02   JohnDoty      Created
//
//----------------------------------------------------------------------------

STDMETHODIMP CSurrogateProcessActivator::WaitForNTServiceIfNecessary (void)
{
    HRESULT hr = S_OK;

    if (m_hNTServiceThread != NULL)
    {
        HANDLE rgaWaitHandle[2] = { m_hServiceStarted, m_hNTServiceThread };

        // Arbitrary wait time here.  If something goes very wrong, then RPCSS
        // ought to kill us.  (In the common case.)
        DWORD dwRet = WaitForMultipleObjects(2, rgaWaitHandle, FALSE, PING_INTERVAL * 5);
        if (dwRet == WAIT_OBJECT_0 + 1)
        {
            // Wow.  The NT service thread died without telling us.
            hr = E_UNEXPECTED;
        }
        else if (dwRet == WAIT_FAILED)
        {
            // Something messed up.
            hr = HRESULT_FROM_WIN32(GetLastError());
        }
        else if (dwRet == WAIT_TIMEOUT)
        {
            // We must be wedged somehow.
            hr = E_FAIL;
        }
        // else the event was signaled, and we may continue.
    }

    return hr;
}


//----------------------------------------------------------------------------
//
//  Member:     CSurrogateProcessActivator::SetupSecurity
//
//  Synopsis:   Dreaded security setup....
//
//  History:    08-Apr-98   SteveSw      Created
//              25-Sep-98   A-Sergiv     Add process identity to process DACL
//              16-Nov-98   TAndrews     Undo DACL hacks - activation bug fixed
//
//----------------------------------------------------------------------------

STDMETHODIMP CSurrogateProcessActivator::SetupSecurity(void)
{
    DWORD                       dwAuthnLevel        = 0xcdcdcdcd;
    DWORD                       dwCapabilities      = 0xcdcdcdcd;
    DWORD                       dwImpLevel          = 0xcdcdcdcd;
    HRESULT                     hr                  = E_FAIL;
    PSECURITY_DESCRIPTOR        pSecDesc            = NULL;
    DWORD                       cbSecDesc;

    //  Get the security descriptor from the catalog. It turns out that this
    //  is a self-relative SD
    hr = m_pIComProcessInfo->GetAccessPermission((void**) &pSecDesc, &cbSecDesc );

    if ( FAILED(hr) )
        return hr;

    //  Get all the other security bits from the catalog
    if ( SUCCEEDED(hr) )
    {
        hr = m_pIComProcessInfo->GetAuthenticationLevel(&dwAuthnLevel);
    }
    if ( SUCCEEDED(hr) )
    {
        hr = m_pIComProcessInfo->GetAuthenticationCapabilities(&dwCapabilities);
    }
    if ( SUCCEEDED(hr) )
    {
        hr = m_pIComProcessInfo->GetImpersonationLevel(&dwImpLevel);
    }

    // Having read values from the catalog, we initialize security for our
    // surrogate....
    if ( SUCCEEDED(hr) )
    {
        hr = CoInitializeSecurity(pSecDesc, -1, NULL, NULL,
                                  dwAuthnLevel, dwImpLevel, NULL,
                                  dwCapabilities, NULL);
    }

    // Who knows which failed, and why? Who cares?
    return hr;
}


//----------------------------------------------------------------------------
//
//  Member:     CSurrogateProcessActivator::SetupSurrogateTimeout
//
//  Synopsis:   Read in the timeout interval used in SurrogateTimeout code
//              The value in the registry is in minutes; we use milliseconds.
//
//  History:    08-Apr-98   SteveSw      Created
//
//----------------------------------------------------------------------------

STDMETHODIMP CSurrogateProcessActivator::SetupSurrogateTimeout(void)
{
    HRESULT hr = E_FAIL;

    hr = m_pIProcessServerInfo->GetShutdownIdleTime(&m_cMillisecondsTilDeath);

    //
    // REVIEW:  Setting shutdown to at least 1 seconds because VB objects are
    // access violating otherwise.  Should find out real reason for access violation
    // to resolve this.
    //

    m_cMillisecondsTilDeath = max ((m_cMillisecondsTilDeath * 60 * 1000), MINIMUM_IDLE_SHUTDOWN_PERIOD_MSEC);


    return hr;
}


//----------------------------------------------------------------------------
//
//  Member:     CSurrogateProcessActivator::AreServicesRequired
//
//  Synopsis:   Returns S_OK if COMSVCS needs to be initialized; S_FALSE otherwise
//
//  History:    08-Apr-98   SteveSw      Created
//
//----------------------------------------------------------------------------

STDMETHODIMP CSurrogateProcessActivator::AreServicesRequired(void)
{
    HRESULT hr = S_FALSE;
    IComServices* pServices = NULL;

    // simply QI and release, setting hr to S_OK if the interface exists

    if ( m_pIComProcessInfo->QueryInterface(IID_IComServices, (void**) &pServices) == S_OK )
    {
        hr = S_OK;
        pServices->Release();
        m_fServicesConfigured = TRUE;
    }


    return hr;
}

//----------------------------------------------------------------------------
//
//  Member:     CSurrogateProcessActivator::SetupFusionContext
//
//  Synopsis:   Sets fusion to the logical application root, if not initialized.
//
//  History:    26-Aug-00   ddriver      Created
//
//----------------------------------------------------------------------------

HRESULT CSurrogateProcessActivator::SetupFusionContext(void)
{
    HRESULT hr = S_FALSE;
    HRESULT hrApp = S_OK;
    IComProcessInfo2* pProcInfo = NULL;
    WCHAR* wszManifest = NULL;
    WCHAR* wszName     = NULL;

    hr = m_pIComProcessInfo->QueryInterface(IID_IComProcessInfo2, (void**)&pProcInfo);
    if(SUCCEEDED(hr))
    {
        hr = pProcInfo->GetManifestLocation(&wszManifest);
        if(SUCCEEDED(hr))
        {
            hrApp = pProcInfo->GetProcessName(&wszName);
        }
        pProcInfo->Release();

        if(SUCCEEDED(hr) && wszManifest != NULL && wszManifest[0] != 0)
        {
            // Create an activation context for this guy:
            ACTCTXW actctx = {0};

            actctx.cbSize              = sizeof (ACTCTXW);
            actctx.dwFlags             = ACTCTX_FLAG_ASSEMBLY_DIRECTORY_VALID | ACTCTX_FLAG_LANGID_VALID;
            actctx.lpSource            = NULL; 
            actctx.wLangId             = LANG_USER_DEFAULT; 
            actctx.lpAssemblyDirectory = wszManifest;
            
            actctx.dwFlags |= ACTCTX_FLAG_SET_PROCESS_DEFAULT;
            
            if(SUCCEEDED(hrApp) && wszName != NULL && wszName[0] != 0) 
            {
                actctx.lpApplicationName = wszName;
                actctx.dwFlags |= ACTCTX_FLAG_APPLICATION_NAME_VALID;
            }

            m_hFusionContext = CreateActCtxW (&actctx); 
            if(m_hFusionContext == INVALID_HANDLE_VALUE)
            {
                DWORD gle = GetLastError();
                if (gle != ERROR_FILE_NOT_FOUND && gle != ERROR_PATH_NOT_FOUND)
                {
                    return HRESULT_FROM_WIN32 (gle);
                }
            }
        }
    }

    return(S_OK);
}

//----------------------------------------------------------------------------
//
//  Member:     CSurrogateProcessActivator::CloseCatalog
//
//  Synopsis:   Cleanup after OpenCatalog() by closing all interfaces
//
//  History:    08-Apr-98   SteveSw      Created
//
//----------------------------------------------------------------------------

STDMETHODIMP CSurrogateProcessActivator::CloseCatalog(void)
{
    if ( m_pIComProcessInfo != NULL )
    {
        m_pIComProcessInfo->Release();
        m_pIComProcessInfo = NULL;
    }
    if ( m_pIProcessServerInfo != NULL )
    {
        m_pIProcessServerInfo->Release();
        m_pIProcessServerInfo = NULL;
    }

    return S_OK;
}


//============================================================================
//
//  Methods to handle communication down into COM and up back to the HOSTPLUS
//  process by means of calls to ISurrogate. This object implements an
//  ISurrogate interface with methods here. This interface is passed down
//  to COM, who only uses the FreeSurrogate() method, and that only when
//  COM deams the process to be idle (no cross-apartment or cross-process
//  activity). We implement a timer facility, which only passes on the call
//  to HOSTPLUS after a specified interval.
//
//  So, what these methods do is hold a counted reference to HOSTPLUS's
//  ISurrogate, and pass a pointer to ours down to COM. Our ISurrogate kicks
//  of the SurrogateTimer when FreeSurrogate() is called -- that code is
//  responsible for all the rest of the work of deciding when to communicate
//  with HOSTPLUS. When it decides it's time, it calls RemoveISurrogate(),
//  which tells HOSTPLUS we're done, releases HOSTPLUS's interface, and tells
//  COM that we don't care to hear any more about idleness, ourselves. This
//  in preparation for shutdown.
//
//  The LoadDllServer() is a vestigal remaint, left here so we don't have to
//  create an ISurrogate2(). If the fact that I return E_NOTIMPL here is a
//  problem, then I'll change it to some other "NO".
//
//----------------------------------------------------------------------------

//----------------------------------------------------------------------------
//
//  Member:     CSurrogateProcessActivator::StoreISurrogate
//
//  Synopsis:   Save HOSTPLUS's ISurrogate; give COM ours
//
//  History:    08-Apr-98   SteveSw      Created
//
//----------------------------------------------------------------------------

STDMETHODIMP CSurrogateProcessActivator::StoreISurrogate(ISurrogate* pISurrogate)
{
    HRESULT hr = E_FAIL;

    m_pISurrogate = pISurrogate;
    if ( m_pISurrogate != NULL )
    {
        m_pISurrogate->AddRef();
    }
    hr = CCOMSurrogate::IsNewStyleSurrogate();
    hr = CCOMSurrogate::InitializeISurrogate ((LPSURROGATE) this);
    return hr;
}

//----------------------------------------------------------------------------
//
//  Member:     CSurrogateProcessActivator::RemoveISurrogate
//
//  Synopsis:   Fire HOSTPLUS's ISurrogate; take ours back from COM
//
//  History:    08-Apr-98   SteveSw      Created
//
//----------------------------------------------------------------------------

STDMETHODIMP CSurrogateProcessActivator::RemoveISurrogate(void)
{
    if ( m_pISurrogate != NULL )
    {
        m_pISurrogate->FreeSurrogate();
        m_pISurrogate->Release();
        m_pISurrogate = NULL;
        return S_OK;
    }
    return S_FALSE;
}

//----------------------------------------------------------------------------
//
//  Member:     CSurrogateProcessActivator::LoadDllServer
//
//  Synopsis:   In CoRegisterServerEx() world, obsolete member of ISurrogate
//
//  History:    08-Apr-98   SteveSw      Created
//
//----------------------------------------------------------------------------

STDMETHODIMP CSurrogateProcessActivator::LoadDllServer(REFCLSID rclsid)
{
    return E_NOTIMPL;
}

//----------------------------------------------------------------------------
//
//  Member:     CSurrogateProcessActivator::FreeSurrogate
//
//  Synopsis:   ISurrogate method called by COM when process quiets; used here
//              to trigger SurrogateTimer mechanisms.
//
//  Note:       Returning S_FALSE tells COM that we want to remain alive to
//              it's notifications after this call....
//
//  History:    08-Apr-98   SteveSw      Created
//
//----------------------------------------------------------------------------

STDMETHODIMP CSurrogateProcessActivator::FreeSurrogate()
{
    HRESULT hr = BeginSurrogateTimeout();

    return S_OK;
}


//============================================================================
//
//  Methods that mess around with Services. We've already read in all the
//  data that the services need to be initialized. Here we have a method that
//  initializes services (and returns the data their initialization required),
//  and a method that cleans up the services.
//
//  Right now these are both no-ops. When they get implemented, their grubbly
//  little hands will be all over the place....
//
//----------------------------------------------------------------------------

//----------------------------------------------------------------------------
//
//  Member:     CSurrogateProcessActivator::InitializeServices
//
//  Synopsis:   Initialize services in surrogate dll, below. And then,
//                              clean up the resources used to hold configuration data.
//
//  History:    08-Apr-98   SteveSw      Created
//              25-Jun-98   WilfR        Added COMSVCS load and init
//
//----------------------------------------------------------------------------

STDMETHODIMP CSurrogateProcessActivator::InitializeServices(REFGUID rguidProcessID)
{
    HRESULT hr = E_FAIL;
    FN_CoLoadServices pfnCoLoadServices = NULL;

    // load COMSVCS.DLL and get the CoLoadServices() entry point
    // The other way we load COMSVCS is with CoCI -- this results in the same LoadLibraryEx call

    if ( ( m_hCOMSVCS = LoadLibraryEx(L"COMSVCS.DLL", NULL,
                                      LOAD_WITH_ALTERED_SEARCH_PATH) ) == NULL )
    {
        return HRESULT_FROM_WIN32(GetLastError());
    }

    if ( ( pfnCoLoadServices = (FN_CoLoadServices) GetProcAddress(m_hCOMSVCS,
                                                                  "CoLoadServices") ) == NULL )
    {
        return HRESULT_FROM_WIN32(GetLastError());
    }

    // call the entry point passing in a reference to ourselves. Since this call will return
    // immediately, we need to block waiting for an acknowledgement from the services DLL that
    // it is ready to roll.

    // the counter is used to recognize that we are being pinged by the services DLL and
    // we should continue to wait.
    m_ulServicesPing = INIT_STARTING;

    // call to startup COMSVCS
    // NT #331848: Don't throw assert when comsvcs says "out of memory"
    if ( ( hr = pfnCoLoadServices(rguidProcessID,
                                  static_cast<IPAControl*>(this),
                                  IID_IServicesSink,
                                  (void**) &m_pServices ) ) != S_OK )
    {
        return hr;
    }

    if ( m_pServices == NULL)
    {
        return E_OUTOFMEMORY;
    }

    // we now wait for the startup to complete (which will be set in our callback)
    if ( ( hr = WaitForInitCompleted( INIT_STARTING, MAX_WAITS ) ) != S_OK )
    {
        return hr;
    }

    m_ulServicesPing = INIT_STARTING;

    // fire the first application launch event -- for this release process GUID == appl GUID
    m_pServices->ApplicationLaunch(rguidProcessID, ServerApplication);

    // we now wait for the application launch to complete (which will be set in our callback)
    // TODO: with > 1 application these events will need to be separate if we allow concurrency
    // in this activator.  This logic should also be in the activation chain instead of here.
    //
    // We set 0 for the MAX_WAITS, because this could take a very long time to complete.
    if ( ( hr = WaitForInitCompleted( INIT_STARTING, 0 ) ) != S_OK )
    {
        return hr;
    }

    return hr;
}



//----------------------------------------------------------------------------
//
//  Member:     CSurrogateProcessActivator::WaitForInitCompleted
//
//  Synopsis:   Monitors the pings from COMSVCS and returns S_OK if completed;
//                              otherwise E_FAIL;
//
//  History:    23-Jun-98   WilfR      Created
//              22-May-01   JohnDoty   Changed to support process initialzers
//
//----------------------------------------------------------------------------

STDMETHODIMP CSurrogateProcessActivator::WaitForInitCompleted( ULONG ulStartingCount,
                                                               ULONG ulMaxWaits )
{
    ULONG ulWaits = 0;

    while ( WaitForSingleObject(m_hInitCompleted, m_ulInitTimeout) == WAIT_TIMEOUT )
    {
        // If this particular piece cares...
        if (ulMaxWaits)
        {
            // ...check if we have exhausted our waits
            if ( ++ulWaits == ulMaxWaits )
            {
                return E_FAIL;
            }
        }

        // read the current value (increments done using Interlocked instructions)
        ULONG ulNewCount = m_ulServicesPing;

        // the ping should increment this value.. if not then we assume COMSVCS is hung
        if ( ulStartingCount == ulNewCount )
        {
            return E_FAIL;
        }
        else
            ulStartingCount = ulNewCount;
    }

    return S_OK;
}

//----------------------------------------------------------------------------
//
//  Member:     CSurrogateProcessActivator::CleanupServices
//
//  Synopsis:   Cleanup all services, as part of shutdown.
//
//  History:    08-Apr-98   SteveSw      Created
//
//----------------------------------------------------------------------------

STDMETHODIMP CSurrogateProcessActivator::CleanupServices(void)
{
    // this will only happen if COMSVCS has been loaded during our operation
    if ( m_pServices )
    {
        m_pServices->ProcessFree();
    }

    return S_OK;
}


//============================================================================
//
//  Methods that implement the Surrogate Timeout mechanism. Once COM tells us
//  the world has shut down, we promise to wait a configurable number of
//  seconds, and then bring down the infrastructure maintained by this object.
//
//  The rub is, during this time we're waiting we may get object activation
//  requests in. If these requests succeed, then our server is no longer
//  dormant, and we cancel the timeout. Heck, we might get two or five
//  activations in; if any one of them succeeds, we cancel the timeout. And
//  we don't want to timeout while an activation is in process, even if it
//  takes a long time and our timeout interval expires.
//
//  It turns out we have three states, and five verbs. The states are
//  INACTIVE, PENDING, and SUSPENDED. The verbs are BEGIN,
//  STARTS, FAILS, SUCCEEDS, and TIMEOUT. The first four verbs happen in
//  routines of the same name; the last one happens in the thread we grab
//  from CoRegisterSurrogate's caller. We know that BEGIN can happen at any time (and
//  at unexpected times). STARTS happens when an activation comes in. It must
//  be matched by either a SUCCEEDS or a FAILS, which happen at the end of
//  an activation, announcing that the activation has completed.
//
//      Once the BEGIN comes in, the event is reset from INFINITE to the application-
//  specific timeout. When it timesout, it is either reset, or it leads to
//  the DLLHOST shutdown.
//
//  So, here's an ASCII kind of state table. Timeout states to the left.
//  Verbs across the top
//
//
//              BEGIN      Activation    Activation    Activation    TIMEOUT
//                           Starts        Fails        Succeeds
//
//  INACTIVE  to PENDING    Ignore         cSusp--       cSusp--      clear
//            set Timeout                                            timeout
//
//                        to SUSPENDED
//  PENDING     NO-OP       cSusp++        cSusp--       cSusp--     shutdown
//
//                                         cSusp--
//  SUSPENDED   NO-OP       cSusp++       cSusp==0 ?   to INACTIVE     set
//                                        to PENDING      clear      timeout
//                                       set timeout     timeout      to '1'
//
//----------------------------------------------------------------------------

//----------------------------------------------------------------------------
//
//  Member:     CSurrogateProcessActivator::BeginSurrogateTimeout
//
//  Synopsis:   Begins the countdown to SurrogateTimeout. Triggered by COM's
//              call to the ISurrogate we implement in this object
//
//  History:    08-Apr-98   SteveSw      Created
//              04-May-98   SteveSw      Fixed races, simplified
//              29-May-98   Gopalk       Fixed races
//              28-Sep-98   SteveSw      Forced shutdown
//
//----------------------------------------------------------------------------

STDMETHODIMP CSurrogateProcessActivator::BeginSurrogateTimeout(void)
{
    BOOL fSetEventWorked = FALSE;
    HRESULT hr = S_OK;
    LockTimeoutState();

    switch ( m_timeoutState )
    {
    //  If BEGIN comes in when the Timeout stuff is inactive, we reset the
    //  timer so that it'll go off in "m_cMillisecondsTilDeath" milliseconds.
    case TIMEOUT_INACTIVE:
        // Check for pending activations
        if ( m_cActivations > 0 )
            m_timeoutState = TIMEOUT_SUSPENDED;
        else
            m_timeoutState = TIMEOUT_PENDING;

        // Wake up the main thread
        m_cTimeoutPeriod = m_cMillisecondsTilDeath;
        fSetEventWorked = SetEvent(m_hTimeoutEvent);
        hr = E_UNEXPECTED;
        break;

    // We can get a superfluous BeginSurrogateTimeout if we are instructed to
    // reset the idle timeout to zero, and we were already in the idle state.    
    // If this happens, and the idle timeout changed, and we are in the pending
    // state, we need to wake up the the timeout thread so that he can take 
    // note of the new idle period.   
    case TIMEOUT_PENDING:
        if (m_cTimeoutPeriod != m_cMillisecondsTilDeath)
        {
			m_cTimeoutPeriod = m_cMillisecondsTilDeath;
			fSetEventWorked = SetEvent(m_hTimeoutEvent);
			hr = fSetEventWorked ? S_OK : HRESULT_FROM_WIN32(GetLastError());
        }
		// else no need to do anything
        break;

    // If an activation is on-going, we can ignore this BeginTimeout request
    case TIMEOUT_SUSPENDED:
        break;

    //  These cases mean we're about to die soon, so no need to do anything
    case TIMEOUT_HAPPENING:
    case TIMEOUT_FORCED_SHUTDOWN:
        break;
    }

    UnlockTimeoutState();

    return hr;
}

//----------------------------------------------------------------------------
//
//  Member:     CSurrogateProcessActivator::ActivationBegins
//
//  Synopsis:   Temporarily suspends the timeout logic. Called when an
//                              activation comes in
//
//  History:    08-Apr-98   SteveSw      Created
//              04-May-98   SteveSw      Fixed races, simplified
//              29-May-98   Gopalk       Fixed races
//              28-Sep-98   SteveSw      Forced shutdown
//
//----------------------------------------------------------------------------

STDMETHODIMP CSurrogateProcessActivator::ActivationBegins(void)
{
    HRESULT hr = S_OK;

    LockTimeoutState();

    m_cActivations += 1;
    switch ( m_timeoutState )
    {
    case TIMEOUT_INACTIVE:
        //  Just keeping track of activations most of the time.
        break;

    case TIMEOUT_PENDING:
        //  Activations that come in when we're in a PENDING state push us
        //  into the SUSPENDED state
        m_timeoutState = TIMEOUT_SUSPENDED;
        break;

    case TIMEOUT_SUSPENDED:
        //  If we're suspended, we accept new activations
        break;

    case TIMEOUT_HAPPENING:
    case TIMEOUT_FORCED_SHUTDOWN:
        //  If we're shutting down, we turn away new activations
        m_cActivations -= 1;  // undo previous increment
        hr = CO_E_SERVER_STOPPING;
        break;
    }

    UnlockTimeoutState();

    return  hr ;
}

//----------------------------------------------------------------------------
//
//  Member:     CSurrogateProcessActivator::ActivationFails
//
//  Synopsis:   Resumes the timeout logic after an unsuccessful activation
//                              call.
//
//  History:    08-Apr-98   SteveSw      Created
//              04-May-98   SteveSw      Fixed races, simplified
//              29-May-98   Gopalk       Fixed races
//              28-Sep-98   SteveSw      Forced shutdown
//
//----------------------------------------------------------------------------

STDMETHODIMP CSurrogateProcessActivator::ActivationFails(void)
{
    Win4Assert (m_cActivations > 0);

    LockTimeoutState();

    m_cActivations -= 1;
    switch ( m_timeoutState )
    {
    case TIMEOUT_FORCED_SHUTDOWN:
        // If we're shutting down, we ignore this failure....
        break;

    case TIMEOUT_INACTIVE:
        //  These cases are about failures that arrive after we're back in a new
        //  cycle.
        break;

    case TIMEOUT_PENDING:
        // Assert that we never land here
        Win4Assert(!"Timeout pending during activation");
        break;

    case TIMEOUT_SUSPENDED:
        //  We again decrement our suspension count. But, if we hit 0, we
        //  transition back into PENDING state.
        if ( m_cActivations == 0 )
            m_timeoutState = TIMEOUT_PENDING;
        break;

    case TIMEOUT_HAPPENING:
        // Assert the we never land here
        Win4Assert(!"Timeout happening during activation");
        break;
    }

    UnlockTimeoutState();

    return  S_OK ;
}

//----------------------------------------------------------------------------
//
//  Member:     CSurrogateProcessActivator::ActivationSucceeds
//
//  Synopsis:   Cancels the timeout logic after a successful activation
//                              call.
//
//  History:    08-Apr-98   SteveSw      Created
//              04-May-98   SteveSw              Fixed races, simplified
//              28-Sep-98   SteveSw      Forced shutdown
//
//----------------------------------------------------------------------------

STDMETHODIMP CSurrogateProcessActivator::ActivationSucceeds(void)
{
    Win4Assert (m_cActivations > 0);

    LockTimeoutState();

    m_cActivations -= 1;
    switch ( m_timeoutState )
    {
    case TIMEOUT_FORCED_SHUTDOWN:
        //  If we're shutting down, this "success" is worthless shortly
        break;

    case TIMEOUT_INACTIVE:
        //  These are about successes that return after we've moved into a new world.
        break;

    case TIMEOUT_PENDING:
        // Assert that we never land here
        Win4Assert(!"Timeout pending during activation");
        break;

    case TIMEOUT_SUSPENDED:
        //  Otherwise, a win means drop the waiting and go back to the inactive
        //  state
        m_timeoutState = TIMEOUT_INACTIVE;
        m_cTimeoutPeriod = INFINITE;
        break;

    case TIMEOUT_HAPPENING:
        break;
    }

    UnlockTimeoutState();
    return S_OK;
}


//----------------------------------------------------------------------------
//
//  Member:     CSurrogateProcessActivator::WaitForSurrogateTimeout
//
//  Synopsis:   Waits until the surrogate times out, then returns
//
//  History:    04-May-98   SteveSw              Created
//              28-Sep-98   SteveSw      Forced shutdown & process refcounts
//
//----------------------------------------------------------------------------


STDMETHODIMP CSurrogateProcessActivator::WaitForSurrogateTimeout(void)
{
    DWORD dwWaitStatus;
    HRESULT hr = S_FALSE;

    if ( m_hTimeoutEvent == NULL )
    {
        hr = E_OUTOFMEMORY;
    }

    LockTimeoutState();
    while ( hr == S_FALSE )
    {
        UnlockTimeoutState();
        dwWaitStatus = WaitForSingleObject (m_hTimeoutEvent, (m_lProcessRefCount > 0) ? INFINITE : m_cTimeoutPeriod);
        LockTimeoutState();

        if ( m_timeoutState == TIMEOUT_FORCED_SHUTDOWN )
        {
            //  If we're shutting down, we just bail....
            hr = S_OK;
        }
        else if ( dwWaitStatus == WAIT_OBJECT_0 || m_lProcessRefCount > 0 )
        {
            //  The event signals a change in the timeout period
            //  m_lProcessRefCount signals externally held references on the process
            //  In either case, we just want to return to the wait
            continue;
        }
        else if ( dwWaitStatus == WAIT_TIMEOUT )
        {
            if ( m_timeoutState == TIMEOUT_PENDING )
            {
                //  Here we're done
                hr = S_OK;
            }
            else if ( m_timeoutState == TIMEOUT_SUSPENDED )
            {
                //  Here we're done, but we still have outstanding activations
                m_cTimeoutPeriod = 1000; // wait one second
                continue;
            }
            else if ( m_timeoutState == TIMEOUT_INACTIVE )
            {
                //  Here we're back to our normal state, go to sleep
                m_cTimeoutPeriod = INFINITE;
                continue;
            }
        }
        else
        {
            hr =  E_UNEXPECTED;
        }
    }

    m_timeoutState = TIMEOUT_HAPPENING;
    UnlockTimeoutState();
    return hr;
}


//============================================================================
//
//  Methods that implement the IProcessInitControl interface.  This interface
//  is handed to COM+ process initializers.
//
//----------------------------------------------------------------------------

//----------------------------------------------------------------------------
//
//  Member:     CSurrogateProcessActivator::ResetInitializerTimeout
//
//  Synopsis:   Reset the timeout used in WaitForInitCompleted, and bump the 
//              ping count so WaitForInitCompleted doesn't think we're stuck.
//
//  History:    22-May-01   JohnDoty      Created
//
//----------------------------------------------------------------------------

STDMETHODIMP CSurrogateProcessActivator::ResetInitializerTimeout(DWORD dwSecondsRemaining)  
{
    const DWORD dwMaxSeconds = (0xFFFFFFFF / 1000); // Max number of seconds without overflow

    if (dwSecondsRemaining > dwMaxSeconds)
        return E_INVALIDARG;

    // Notify the SCM that we are in the initializing state.
    HRESULT hr = TellSCMWeAreInitializing();

    if (SUCCEEDED(hr))
    {
        // Reset the timeout, and then increment the ping.  There are all kinds of 
        // timing issues, but if you update them in this order, you will at least
        // get the specified amount of time before you die.  (You might get twice
        // that.  Is it necessary to be picky?)
        m_ulInitTimeout = dwSecondsRemaining * 1000; // (Convert to ms)
        
        InterlockedIncrement( (PLONG) &m_ulServicesPing );
    }
   
    return hr;
}


//============================================================================
//
//  Methods that implement the ILocalSystemActivator interface. We do this
//  instead of your garden-variety ISystemActivator because we're talking
//  to the SCM, and the SCM needs this kind of interface. Since we're building
//  an unRAW ILocalSystemActivator, it's just the same old ISystemActivator
//  with an extra method there at the bottom that we ignore.
//
//  This activator sits at the very beginning of the local activation
//  chain. It's only job is to "set the stage", so to speak, and then
//  delegate on to the other activators at the Server Process Stage.
//
//  The wrinkle is, activation is intertwined with the whole SurrogateTimeout
//  mechanism. When COM sees that the process has quiesced, it notifies us
//  with a callback. Each ProcessID is associated with a timeout value, a
//  number of seconds to wait after quiescence before we actually bail out
//  and shut down the server. During that time, if an activation succeeds,
//  then we're back in the saddle again, all thoughts of timing out gone.
//  If the activation fails, we just resume the timeout process as though
//  it hadn't happened. This logic is also in these methods.
//
//----------------------------------------------------------------------------

//----------------------------------------------------------------------------
//
//  Member:     CSurrogateProcessActivator::GetClassObject
//
//  Synopsis:   The part of the GetClassObject activation chain that lives
//                              between the SCM and the list of Process Activators
//
//  History:    08-Apr-98   SteveSw      Created
//
//----------------------------------------------------------------------------

STDMETHODIMP CSurrogateProcessActivator::GetClassObject(IActivationPropertiesIn *pActPropsIn,
                                                        IActivationPropertiesOut **ppActPropsOut)
{
    HRESULT hr = E_FAIL;
    IActivationStageInfo*       pActStageInfo       = NULL;
    InstantiationInfo*         pInstantiationInfo  = NULL;
    int nRetries = 0;

    // Check CreateObjectMemoryGate
    ActivationPropertiesIn* pActIn = NULL;
    // Don't need to release pActIn!!
    hr = pActPropsIn->QueryInterface(CLSID_ActivationPropertiesIn, (void**) &pActIn);
    if(SUCCEEDED(hr) && pActIn)
        hr = CheckMemoryGate(pActIn->GetComClassInfo(), CreateObjectMemoryGate);
    if ( FAILED(hr) )
        return hr;

    //  Notify the timeout mechanism that a timeout has begun. This guy will return
    //  failure if we need to abandon the activation here....
    hr = ActivationBegins();
    if ( FAILED(hr) )
    {
        return hr;
    }

    // The activation work proper. First, change the CLSCTX to INPROC.
    hr = pActPropsIn->QueryInterface(IID_IInstantiationInfo, (void**) &pInstantiationInfo);
    if ( SUCCEEDED(hr) && pInstantiationInfo != NULL )
    {
        hr = pInstantiationInfo->SetClsctx(CLSCTX_INPROC_SERVER);
        pInstantiationInfo->Release();
        pInstantiationInfo = NULL;
    }
    if ( FAILED(hr) )
    {
        return hr;
    }

    // NOTE: We can't remove the below code, because it has the side effect
    // of unmarshalling the client context.  This prevents a leak if the client
    // context has marshal-by-ref user properties.
    {
        IActivationContextInfo* pContextInfo = NULL;
        IContext* pContext = NULL;

        hr = pActPropsIn->QueryInterface(IID_IActivationContextInfo, (void**)&pContextInfo);
        if(SUCCEEDED(hr) && pContextInfo != NULL)
        {
            hr = pContextInfo->GetClientContext(&pContext);
            if(SUCCEEDED(hr) && pContext != NULL)
            {
                pContext->Release();
            }
            pContextInfo->Release();
        }
    }

     //Check that activations in our server are not paused
    if(TRUE == m_bPaused)
    {
    	ActivationFails();
    	return CO_E_SERVER_PAUSED;
    }

RETRY_ACTIVATION:
    // Set the Stage. Release the interface. Delegate.
    hr = pActPropsIn->QueryInterface(IID_IActivationStageInfo, (void**) &pActStageInfo);
    if ( SUCCEEDED(hr) && pActStageInfo != NULL )
    {
        hr = pActStageInfo->SetStageAndIndex (SERVER_PROCESS_STAGE, 0);
        pActStageInfo->Release();
        pActStageInfo = NULL;
    }
    if ( FAILED(hr) )
    {
        return hr;
    }

    // Send the activation on down the path
    hr = pActPropsIn->DelegateGetClassObject(ppActPropsOut);
    // Sajia-support for partitions
    // If the delegated activation returns ERROR_RETRY,
    // we walk the chain again, but AT MOST ONCE.
    if (HRESULT_FROM_WIN32(ERROR_RETRY) == hr) {
       Win4Assert(!nRetries);
       if (!nRetries)
       {
	        nRetries++;
	        goto RETRY_ACTIVATION;
       }
    }
    
    // Keeping track of the status of our creates, for the timeout mechanism
    if ( FAILED(hr) )
    {
        ActivationFails();
    }
    else
    {
        ActivationSucceeds();
    }

    // This return passed upstream to them what delegated to us....
    return hr;
}

//----------------------------------------------------------------------------
//
//  Member:     CSurrogateProcessActivator::CreateInstance
//
//  Synopsis:   The part of the CreateInstance activation chain that lives
//                              between the SCM and the list of Process Activators
//
//  History:    08-Apr-98   SteveSw      Created
//
//----------------------------------------------------------------------------

STDMETHODIMP CSurrogateProcessActivator::CreateInstance(IUnknown *pUnkOuter,
                                                        IActivationPropertiesIn *pActPropsIn,
                                                        IActivationPropertiesOut **ppActPropsOut)
{
    HRESULT                     hr                  = E_FAIL;
    IActivationStageInfo*       pActStageInfo       = NULL;
    InstantiationInfo*          pInstantiationInfo  = NULL;
    int nRetries = 0;

    // Check CreateObjectMemoryGate
    ActivationPropertiesIn* pActIn = NULL;
    // Don't need to release pActIn!!
    hr = pActPropsIn->QueryInterface(CLSID_ActivationPropertiesIn, (void**) &pActIn);
    if(SUCCEEDED(hr) && pActIn)
        hr = CheckMemoryGate(pActIn->GetComClassInfo(), CreateObjectMemoryGate);
    if ( FAILED(hr) )
        return hr;

    //  Notify the timeout mechanism that a timeout has begun. This guy will return
    //  failure if we need to abandon the activation here....
    hr = ActivationBegins();
    if ( FAILED(hr) )
    {
        return hr;
    }

    // The activation work proper. First, change the CLSCTX to INPROC.
    hr = pActPropsIn->QueryInterface(IID_IInstantiationInfo, (void**) &pInstantiationInfo);
    if ( SUCCEEDED(hr) && pInstantiationInfo != NULL )
    {
        hr = pInstantiationInfo->SetClsctx(CLSCTX_INPROC_SERVER);
        pInstantiationInfo->Release();
        pInstantiationInfo = NULL;
    }
    if ( FAILED(hr) )
    {
        return hr;
    }

    //Check that activations in our server are not paused
    if(TRUE == m_bPaused)
    {
    	ActivationFails();
    	return CO_E_SERVER_PAUSED;
    }


RETRY_ACTIVATION:
    // Set the Stage. Release the interface. Delegate.
    hr = pActPropsIn->QueryInterface(IID_IActivationStageInfo, (void**) &pActStageInfo);
    if ( SUCCEEDED(hr) && pActStageInfo != NULL )
    {
        hr = pActStageInfo->SetStageAndIndex (SERVER_PROCESS_STAGE, 0);
        pActStageInfo->Release();
        pActStageInfo = NULL;
    }
    if ( FAILED(hr) )
    {
        return hr;
    }

    // Send the work downstream
    hr = pActPropsIn->DelegateCreateInstance(pUnkOuter, ppActPropsOut);
    // Sajia-support for partitions
    // If the delegated activation returns ERROR_RETRY,
    // we walk the chain again, but AT MOST ONCE.
    if (HRESULT_FROM_WIN32(ERROR_RETRY) == hr) {
       Win4Assert(!nRetries);
       if (!nRetries)
       {
	       nRetries++;
	       goto RETRY_ACTIVATION;
       }
    }
    // If the Suspend really suspended, then we need to either RESUME or CANCEL,
    // depending on the outcome of the delegation.
    // Keeping track of the status of our creates, for the timeout mechanism
    if ( FAILED(hr) )
    {
        ActivationFails();
    }
    else
    {
        ActivationSucceeds();
    }

    // This return passed upstream to them what delegated to us....
    return hr;
}

//----------------------------------------------------------------------------
//
//  Member:     CSurrogateProcessActivator::ObjectServerLoadDll
//
//  Synopsis:   Member of ILocalSystemActivator. Other than its name, I have
//                              no idea what it does. It's unimplemented here.
//
//  History:    08-Apr-98   SteveSw      Created
//
//----------------------------------------------------------------------------

STDMETHODIMP CSurrogateProcessActivator::ObjectServerLoadDll(GUID* pclsid, STATUSTYPE* pStatus)
{
    Win4Assert(! "Surrogate's ObjectServerLoadDll not implemented");
    if ( pStatus != NULL )
    {
        *pStatus = E_NOTIMPL;
    }
    return E_NOTIMPL;
}

//----------------------------------------------------------------------------
//
//  Member:     CSurrogateProcessActivator::AddRefOnProcess
//
//  Synopsis:   Member of IPAControl. While process lock > 0, surrogate timeouts
//                              are disabled.
//
//  History:    23-Jun-98   WilfR      Created
//              28-Sep-98   SteveSw    Implemented
//
//----------------------------------------------------------------------------

ULONG CSurrogateProcessActivator::AddRefOnProcess()
{
    BOOL fSetEventWorked;
    ULONG refCount;

    LockTimeoutState();
    if ( m_lProcessRefCount == 0 )
    {
        fSetEventWorked = SetEvent(m_hTimeoutEvent);
    }
    refCount = ++m_lProcessRefCount;
    UnlockTimeoutState();

    return refCount;
}

//----------------------------------------------------------------------------
//
//  Member:     CSurrogateProcessActivator::ReleaseRefOnProcess
//
//  Synopsis:   Member of IPAControl. When process lock goes from 1->0, surrogate timeout
//                              may be initiated if there are no activations.
//
//  History:    23-Jun-98   WilfR      Created
//              28-Sep-98   SteveSw    Implemented
//
//----------------------------------------------------------------------------

ULONG CSurrogateProcessActivator::ReleaseRefOnProcess()
{
    BOOL fSetEventWorked;
    ULONG refCount;

    LockTimeoutState();

    if ( m_lProcessRefCount > 0 )
    {
        m_lProcessRefCount--;
    }
    refCount = m_lProcessRefCount;

    if ( m_lProcessRefCount == 0 )
    {
        fSetEventWorked = SetEvent(m_hTimeoutEvent);
    }

    UnlockTimeoutState();

    return refCount;
}


//----------------------------------------------------------------------------
//
//  Member:     CSurrogateProcessActivator::PendingInit
//
//  Synopsis:   Member of IPAControl. Services DLL uses this to ping the activator.
//
//  History:    23-Jun-98   WilfR      Created
//
//----------------------------------------------------------------------------

void CSurrogateProcessActivator::PendingInit()
{
    InterlockedIncrement( (PLONG) &m_ulServicesPing );
}

//----------------------------------------------------------------------------
//
//  Member:     CSurrogateProcessActivator::ServicesReady
//
//  Synopsis:   Member of IPAControl. Services DLL uses this to acknowledge it
//                              has completed initialization
//
//  History:    23-Jun-98   WilfR      Created
//
//----------------------------------------------------------------------------

void CSurrogateProcessActivator::ServicesReady()
{
    if (m_hInitCompleted != NULL)
    {
        SetEvent( m_hInitCompleted );
    }
}


//----------------------------------------------------------------------------
//
//  Member:     CSurrogateProcessActivator::SuspendApplication
//
//  Synopsis:   Member of IPAControl. Disables application activations.
//                              Not currently implemented
//
//  History:    23-Jun-98   WilfR      Created
//
//----------------------------------------------------------------------------
HRESULT CSurrogateProcessActivator::SuspendApplication( REFGUID rguidApplID )
{
    return E_NOTIMPL;
}

//----------------------------------------------------------------------------
//
//  Member:     CSurrogateProcessActivator::PendingApplication
//
//  Synopsis:   Member of IPAControl. Indicates an application startup is still
//                              pending.  Note that multiple applications where applid != processID
//                              is NOT currently implemented
//
//  History:    23-Jun-98   WilfR      Created
//
//----------------------------------------------------------------------------
HRESULT CSurrogateProcessActivator::PendingApplication( REFGUID rguidApplID )
{
    InterlockedIncrement( (PLONG) &m_ulServicesPing );
    return S_OK;
}

//----------------------------------------------------------------------------
//
//  Member:     CSurrogateProcessActivator::ResumeApplication
//
//  Synopsis:   Member of IPAControl. Indicates an application startup has completed
//                              Note that multiple applications where applid != processID
//                              is NOT currently implemented
//
//  History:    23-Jun-98   WilfR      Created
//
//----------------------------------------------------------------------------
HRESULT CSurrogateProcessActivator::ResumeApplication( REFGUID rguidApplID )
{
    if (m_hInitCompleted != NULL)
    {
        SetEvent( m_hInitCompleted );
        return S_OK;
    }
    else
    {
        return E_UNEXPECTED;
    }
}

//----------------------------------------------------------------------------
//
//  Member:     CSurrogateProcessActivator::SuspendAll
//
//  Synopsis:   Member of IPAControl. Indicates all activations should be suspended
//
//  History:    23-Jun-98   WilfR      Created
//              17-Aug-99   JamesAn    Implemented
//
//----------------------------------------------------------------------------
HRESULT CSurrogateProcessActivator::SuspendAll(void)
{
	HRESULT hr = S_OK;

	LockTimeoutState();

	if(m_bPaused)
		hr = CO_E_SERVER_PAUSED;
	else
	{
            //If we are in the middle of a shutdown we don't suspend and leave the timeout alone
            if(m_timeoutState == TIMEOUT_HAPPENING ||
               m_timeoutState == TIMEOUT_FORCED_SHUTDOWN)
                hr = CO_E_SERVER_STOPPING;
            else
            {
                // Ordering here is important;  first we tell the SCM that we're paused, and 
                // only then do we mark our own state as paused. 
                hr = gResolver.NotifySurrogatePaused();
                if (SUCCEEDED(hr))
                {
                    m_bPaused = TRUE;
                    m_timeoutState = TIMEOUT_INACTIVE;
                }
            }
	}
		
	UnlockTimeoutState();
	return hr;
}

//----------------------------------------------------------------------------
//
//  Member:     CSurrogateProcessActivator::ResumeAll
//
//  Synopsis:   Member of IPAControl. Indicates all activations can be resumed
//
//
//  History:    23-Jun-98   WilfR      Created
//              17-Aug-99   JamesAn    Implemented
//
//----------------------------------------------------------------------------
HRESULT CSurrogateProcessActivator::ResumeAll(void)
{
    HRESULT hr = S_OK;
    
    LockTimeoutState();
    
    if(!m_bPaused)
        hr = CO_E_SERVER_NOT_PAUSED;
    else
    {
        
        //If we are in the middle of a shutdown we don't suspend and leave the timeout alone
        if(m_timeoutState == TIMEOUT_HAPPENING ||
           m_timeoutState == TIMEOUT_FORCED_SHUTDOWN)
            hr = CO_E_SERVER_STOPPING;
        else
        {
            // Here we reverse the order that we did things in SuspendAll.  This is because 
            // once the SCM thinks we're not paused, it might start sending us activations
            // immediately, but before the notifyresumed call returns to us here.  We would
            // then reject those calls, which would be strange to the user.
            
            m_bPaused = FALSE;
            
            //If we have activations we are suspended, otherwise pending.
            m_timeoutState = (m_cActivations > 0) ? TIMEOUT_SUSPENDED : TIMEOUT_PENDING;
            m_cTimeoutPeriod = m_cMillisecondsTilDeath;
            
            hr = gResolver.NotifySurrogateResumed();
            if (FAILED(hr))
            {
                // Reset ourselves back to the paused state
                m_bPaused = TRUE;
                m_timeoutState = TIMEOUT_INACTIVE;
            }
        }
    }
    
    UnlockTimeoutState();
    return hr;
}

//----------------------------------------------------------------------------
//
//  Member:     CSurrogateProcessActivator::ForcedShutdown
//
//  Synopsis:   Member of IPAControl. Indicates that a shutdown request has been
//              received and process termination should be commenced.
//
//  History:    23-Jun-98   WilfR      Created
//              28-Sep-98   SteveSw    Forced shutdown implemented
//
//----------------------------------------------------------------------------
HRESULT CSurrogateProcessActivator::ForcedShutdown(void)
{
    BOOL fSetEventWorked;

    LockTimeoutState();

    m_timeoutState = TIMEOUT_FORCED_SHUTDOWN;
    m_cTimeoutPeriod = 0;
    fSetEventWorked = SetEvent(m_hTimeoutEvent);

    UnlockTimeoutState();

    return fSetEventWorked ? S_OK : E_UNEXPECTED;
}

//----------------------------------------------------------------------------
//
//  Member:     CSurrogateProcessActivator::SetIdleTimeoutToZero
//
//  Synopsis:   Member of IPAControl. Indicates that somebody (ie, com+) wants
//              us to re-set the idle timeout of this process to zero, no matter
//              what it was before.
//
//  History:    27-May-00   JSimmons   Created
//
//----------------------------------------------------------------------------
STDMETHODIMP CSurrogateProcessActivator::SetIdleTimeoutToZero(void)
{
	BOOL fSetEventWorked;

    LockTimeoutState();
    
    // Reset m_cMillisecondsTilDeath;  we never set this to zero due to 
    // av shutdown probs seen with VB objects.   We do this no matter
    // what state we are currently in.
    m_cMillisecondsTilDeath = MINIMUM_IDLE_SHUTDOWN_PERIOD_MSEC;  

    UnlockTimeoutState();   

	FreeSurrogateIfNecessary();

    return S_OK;
}

STDMETHODIMP CSurrogateProcessActivator::SetObjectCountAtIdleTime(DWORD dwObjectCount)
    
{
    // Let's use m_timeoutLock for multi thread safety
    LockTimeoutState();

    m_dwObjectCountAtIdleTime = dwObjectCount;

    UnlockTimeoutState();

    return S_OK;
}


//============================================================================
//
//  Methods that communicate with the NT Service Control Manager.  We need
//  to keep the NT SCM informed of our starting progress along with the normal
//  SCM.  The NT SCM also provides another way that the surrogate may get
//  shut down, so that is taken care of as well.
//
//----------------------------------------------------------------------------

//----------------------------------------------------------------------------
//
//  Member:     CSurrogateProcessActivator::StartNTService
//
//  Synopsis:   This thread hands control off to the NT SCM to let it start
//              our NT Service.
//
//  History:    13-Dec-99   JohnDoty      Created
//
//----------------------------------------------------------------------------
DWORD WINAPI CSurrogateProcessActivator::StartNTService(LPVOID ptr)
{
    CSurrogateProcessActivator* pSCPA = static_cast<CSurrogateProcessActivator*>(ptr);
    HRESULT hr = S_OK;

    if (SUCCEEDED(hr))
    {
        SERVICE_TABLE_ENTRYW  DispatchTable[] = 
        { 
            { pSCPA->m_NTServiceName, CSurrogateProcessActivator::NTServiceMain }, 
            { NULL,                   NULL          } 
        };
        
        if (!StartServiceCtrlDispatcher(DispatchTable))
        { 
            //TODO: Log the error somehow...
            hr = E_FAIL;
        }
    }
    
    return hr;
}

//----------------------------------------------------------------------------
//
//  Member:     CSurrogateProcessActivator::NTServiceMain
//
//  Synopsis:   The ServiceMain for the NT Service.  Register our service
//              control handler and get back a handle that we're going to
//              use for our status updates.
//
//              This is yet another piece of code that relies on there being
//              only one CSurrogateProcessActivator.
//
//  History:    13-Dec-99   JohnDoty      Created
//
//----------------------------------------------------------------------------
void CSurrogateProcessActivator::NTServiceMain(DWORD argc, LPWSTR *argv)
{
    SERVICE_STATUS_HANDLE hSS = RegisterServiceCtrlHandlerW( argv[0], NTServiceCtrlHandler );
    
    if (hSS != (SERVICE_STATUS_HANDLE)0)
    { 
        SetServiceStatus (hSS, &(s_pCSPA->m_NTServiceStatus));
        s_pCSPA->m_hNTServiceHandle = hSS;

        // Let the main thread know we've got this far.
        SetEvent(s_pCSPA->m_hServiceStarted);
    }
    else
    {
        // TODO: Log error somehow.
    }
}

//----------------------------------------------------------------------------
//
//  Member:     CSurrogateProcessActivator::NTServiceCtrlHandler
//
//  Synopsis:   The function that the NT SCM calls when somebody wants to
//              start, stop, pause, continue, or just plain question this
//              service.
//
//              This is yet another piece of code that relies on there being
//              only one CSurrogateProcessActivator.
//
//  History:    13-Dec-99   JohnDoty      Created
//
//----------------------------------------------------------------------------
void CSurrogateProcessActivator::NTServiceCtrlHandler (DWORD code)
{
    HRESULT          hr   = S_OK;

    EnterCriticalSection(&(s_pCSPA->m_serviceStatusLock));

    if (s_pCSPA->m_NTServiceStatus.dwCurrentState != SERVICE_STOPPED)
    {
        switch (code)
        {
        case SERVICE_CONTROL_PAUSE:      
            hr = s_pCSPA->m_pServices->PauseApplication();
            
            if (SUCCEEDED(hr))
            {
                s_pCSPA->m_NTServiceStatus.dwCurrentState = SERVICE_PAUSED;
                s_pCSPA->m_NTServiceStatus.dwWaitHint     = 0;
                s_pCSPA->m_NTServiceStatus.dwCheckPoint   = 0;
            }
            break;
            
        case SERVICE_CONTROL_CONTINUE:
            hr = s_pCSPA->m_pServices->ResumeApplication();
            
            if (SUCCEEDED(hr))
            {
                s_pCSPA->m_NTServiceStatus.dwCurrentState = SERVICE_RUNNING;
                s_pCSPA->m_NTServiceStatus.dwWaitHint     = 0;
                s_pCSPA->m_NTServiceStatus.dwCheckPoint   = 0;
            }
            break;
            
        case SERVICE_CONTROL_STOP:
            hr = s_pCSPA->ForcedShutdown ();
            
            if (SUCCEEDED(hr))
            {
                s_pCSPA->m_NTServiceStatus.dwCurrentState = SERVICE_STOP_PENDING;
                s_pCSPA->m_NTServiceStatus.dwWaitHint     = 0; // Do I need to give a hint?
                s_pCSPA->m_NTServiceStatus.dwCheckPoint   = 0;
            }
            break;
            
        case SERVICE_CONTROL_INTERROGATE:
            // Ok boss.
            break;
        }
        
        SetServiceStatus (s_pCSPA->m_hNTServiceHandle, &(s_pCSPA->m_NTServiceStatus));
    }

    LeaveCriticalSection(&(s_pCSPA->m_serviceStatusLock));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\com\dcomrem\sync.cxx ===
//+--------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997 - 1997.
//
//  File:       sync.cxx
//
//  Contents:   This module contains classes implementing ISynchronize
//
//  Classes:    CStdEvent
//              CManualResetEvent
//              CSynchronizeContainer
//
//----------------------------------------------------------------------

#include <ole2int.h>
#include <chancont.hxx>
#include <callctrl.hxx>
#include <sync.hxx>

//------------------------------------------------------------------------------
//
// CoWaitForMultipleHandles
//
// Description: Waits on the set of Win32 handles passed in.
//
// Return: S_OK
//         E_INVALIDARG
//         RPC_E_NO_SYNC
//         RPC_S_CALLPENDING
//
// Notes:
//
//------------------------------------------------------------------------------

WINOLEAPI CoWaitForMultipleHandles (DWORD dwFlags,
                                    DWORD dwTimeout,
                                    ULONG cHandles,
                                    LPHANDLE pHandles,
                                    LPDWORD  lpdwindex)
{
    DWORD         hr = S_OK;
    DWORD         dwSignaled = 0;


    if ((pHandles == NULL) || (lpdwindex == NULL))
    {
        if (lpdwindex) *lpdwindex = 0;
        return E_INVALIDARG;
    }

    if ((dwFlags & ~(COWAIT_WAITALL | COWAIT_ALERTABLE | COWAIT_INPUTAVAILABLE)) != 0)
    {
        *lpdwindex = 0;
        return E_INVALIDARG;
    }

    // If nothing to do, return
    if (cHandles == 0)
    {
        *lpdwindex = 0;
        return RPC_E_NO_SYNC;
    }

    // On MTA threads, just wait
    HRESULT hrTls;
    COleTls Tls(hrTls);

    if (FAILED(hrTls) || ((Tls->dwFlags & OLETLS_APARTMENTTHREADED) == FALSE))
    {
        dwSignaled = WaitForMultipleObjectsEx(cHandles,
                                              pHandles,
                                              dwFlags & COWAIT_WAITALL,
                                              dwTimeout,
                                              dwFlags & COWAIT_ALERTABLE);

        // Fix up the error code if the wait timed out.
        if (dwSignaled == WAIT_TIMEOUT)
            hr = RPC_S_CALLPENDING;
        else if ((LONG) dwSignaled < WAIT_OBJECT_0 ||
                 dwSignaled >= WAIT_OBJECT_0 + cHandles)
            hr = MAKE_WIN32(GetLastError());
        else
            dwSignaled -= WAIT_OBJECT_0;
    }

    // On STA threads, use the modal loop
    else
    {        
        // Tell the modal loop how long to wait.
        hr = InitChannelIfNecessary();
        if (SUCCEEDED(hr))
        {
            CCliModalLoop CML( 0,
                               QS_ALLINPUT | QS_TRANSFER | QS_ALLPOSTMESSAGE,
                               dwFlags);
            CML.StartTimer( dwTimeout );

            // Enter a modal loop.
            hr = RPC_S_CALLPENDING;
            while (hr == RPC_S_CALLPENDING || hr == RPC_S_WAITONTIMER)
                hr = CML.BlockFn( pHandles, cHandles, &dwSignaled );

            // Fix up the error code if the wait timed out.
            if (hr == RPC_E_SERVERCALL_RETRYLATER)
                //hr = RPC_E_TIMEOUT;
                hr = RPC_S_CALLPENDING;
        }
    }
    *lpdwindex = dwSignaled;
    return hr;
}




//+-------------------------------------------------------------------
//
//  Function:   CStdEvent_CreateInstance, public
//
//  Synopsis:   Create an instance of the requested class
//
//--------------------------------------------------------------------
HRESULT CStdEventCF_CreateInstance( IUnknown *pUnkOuter,
                                    REFIID riid, void **ppv )
{
    Win4Assert(*ppv == NULL);
    HRESULT hr = E_OUTOFMEMORY;
    CStdEvent *pAC = new CStdEvent( pUnkOuter );
    if (pAC != NULL)
    {
        IUnknown *pUnk = NULL;
        hr = pAC->_cInner.QueryInterface( riid, (void **) &pUnk );
        pAC->_cInner.Release();
        if (FAILED(hr))
        {
            return hr;
        }
        *ppv = pUnk;
    }

    return hr;
}


//+-------------------------------------------------------------------
//
//  Function:   CManualResetEvent_CreateInstance, public
//
//  Synopsis:   Create an instance of the requested class
//
//--------------------------------------------------------------------
HRESULT CManualResetEventCF_CreateInstance( IUnknown *pUnkOuter,
                                            REFIID riid, void **ppv )
{
    Win4Assert(*ppv == NULL);
    HRESULT hr = E_OUTOFMEMORY;
    CManualResetEvent *pMRE = new CManualResetEvent( pUnkOuter, &hr );
    if (SUCCEEDED(hr))
    {
        IUnknown *pUnk = NULL;
        hr = pMRE->_cInner.QueryInterface( riid, (void **) &pUnk );
        pMRE->_cInner.Release();
        if (FAILED(hr))
        {
            return hr;
        }
        *ppv = pUnk;
    } else
    {
        delete pMRE;
    }

    return hr;

}

//+-------------------------------------------------------------------
//
//  Function:   CSynchronizeContainer_CreateInstance, public
//
//  Synopsis:   Create an instance of the requested class
//
//--------------------------------------------------------------------
HRESULT CSynchronizeContainerCF_CreateInstance( IUnknown *pUnkOuter,
                                                REFIID riid, void **ppv )
{
    Win4Assert(*ppv == NULL);
    HRESULT hr = E_OUTOFMEMORY;
    CSynchronizeContainer *pAC = new CSynchronizeContainer( pUnkOuter );
    if (pAC != NULL)
    {
        IUnknown *pUnk = NULL;
        hr = pAC->_cInner.QueryInterface( riid, (void **) &pUnk );
        pAC->_cInner.Release();
        if (FAILED(hr))
        {
            return hr;
        }
        *ppv = pUnk;
    }

    return hr;
}


// CStdEvent Methods
//+-------------------------------------------------------------------
//
//  Member:     CSTInnerUnknown::AddRef, public
//
//  Synopsis:   Adds a reference to an interface
//
//--------------------------------------------------------------------
STDMETHODIMP_(ULONG) CSTInnerUnknown::AddRef()
{
    return InterlockedIncrement( (long *) &_iRefCount );
}

//+-------------------------------------------------------------------
//
//  Member:     CSTInnerUnknown::CSTInnerUnknown
//
//  Synopsis:   Constructor
//
//--------------------------------------------------------------------
CSTInnerUnknown::CSTInnerUnknown( CStdEvent *pParent )
{
    _iRefCount = 1;
    _pParent   = pParent;
}

//+-------------------------------------------------------------------
//
//  Member:     CSTInnerUnknown::QueryInterface, public
//
//  Synopsis:   Returns a pointer to the requested interface.
//
//--------------------------------------------------------------------
STDMETHODIMP CSTInnerUnknown::QueryInterface( REFIID riid, LPVOID FAR* ppvObj)
{
    IUnknown *pUnk;

    if (IsEqualIID(riid, IID_IUnknown))
        pUnk = (IUnknown *) this;
    else if (IsEqualIID(riid, IID_ISynchronize))
        pUnk = (ISynchronize *) _pParent;
    else if (IsEqualIID(riid, IID_ISynchronizeEvent))
        pUnk = (ISynchronizeEvent *) _pParent;
    else if (IsEqualIID(riid, IID_ISynchronizeHandle))
        pUnk = (ISynchronizeHandle *) _pParent;
    else
    {
        *ppvObj = NULL;
        return E_NOINTERFACE;
    }

    pUnk->AddRef();
    *ppvObj = pUnk;
    return S_OK;
}

//+-------------------------------------------------------------------
//
//  Member:     CSTInnerUnknown::Release, public
//
//  Synopsis:   Releases an interface
//
//--------------------------------------------------------------------
STDMETHODIMP_(ULONG) CSTInnerUnknown::Release()
{
    ULONG lRef = InterlockedDecrement( (long*) &_iRefCount );

    if (lRef == 0)
    {
        delete _pParent;
    }

    return lRef;
}

//+-------------------------------------------------------------------
//
//  Member:     CStdEvent::AddRef, public
//
//  Synopsis:   Forwards AddRef to the controlling unknown
//
//--------------------------------------------------------------------
STDMETHODIMP_(ULONG) CStdEvent::AddRef()
{
    return _pControl->AddRef();
}

//+-------------------------------------------------------------------
//
//  Member:     CStdEvent::CStdEvent
//
//  Synopsis:   Constructor
//
//--------------------------------------------------------------------
CStdEvent::CStdEvent( IUnknown *pControl ) :
_cInner( this ),
m_hEvent(NULL)
{
    if (pControl != NULL)
        _pControl = pControl;
    else
        _pControl = &_cInner;
}

//+-------------------------------------------------------------------
//
//  Member:     CStdEvent::~CStdEvent
//
//  Synopsis:   Destructor
//
//--------------------------------------------------------------------
CStdEvent::~CStdEvent()
{
    if (m_hEvent != NULL)
        CloseHandle(m_hEvent);
}

//+-------------------------------------------------------------------
//
//  Member:     CStdEvent::QueryInterface, public
//
//  Synopsis:   Forwards QueryInterface to the controlling unknown
//
//--------------------------------------------------------------------
STDMETHODIMP CStdEvent::QueryInterface( REFIID riid, LPVOID FAR* ppvObj)
{
    return _pControl->QueryInterface( riid, ppvObj );
}

//+-------------------------------------------------------------------
//
//  Member:     CStdEvent::Release, public
//
//  Synopsis:   Forwards Release to the controlling unknown
//
//--------------------------------------------------------------------
STDMETHODIMP_(ULONG) CStdEvent::Release()
{
    return _pControl->Release();

}


//+-------------------------------------------------------------------
//
//  Member:     CStdEvent::Wait, public
//
//  Synopsis:   Waits for call to complete.
//
//--------------------------------------------------------------------
STDMETHODIMP CStdEvent::Wait(DWORD dwFlags, DWORD dwTimeout)
{
    HANDLE _aEvent[1];
    DWORD index = 0;
    if (m_hEvent == NULL)
        return RPC_E_NO_SYNC;

    _aEvent[0] = m_hEvent;
    return CoWaitForMultipleHandles(dwFlags,
                                    dwTimeout,
                                    1,
                                    _aEvent,
                                    &index);
}

//+-------------------------------------------------------------------
//
//  Member:     CStdEvent::Signal, public
//
//  Synopsis:   Signal Event
//
//--------------------------------------------------------------------
STDMETHODIMP CStdEvent::Signal()
{
    if (m_hEvent)
    {
        if (SetEvent(m_hEvent))
           return S_OK;

        return MAKE_WIN32(GetLastError());
    }

    return RPC_E_NO_SYNC;
}


//+-------------------------------------------------------------------
//
//  Member:     CStdEvent::Reset, public
//
//  Synopsis:   Resets ISynchronize state.
//
//--------------------------------------------------------------------
STDMETHODIMP CStdEvent::Reset()
{
    if (m_hEvent)
    {
        if (ResetEvent(m_hEvent))
            return S_OK;

        return MAKE_WIN32(GetLastError());
    }

    return RPC_E_NO_SYNC;
}


//+-------------------------------------------------------------------
//
//  Member:     CStdEvent::GetHandle, public
//
//  Synopsis:   Returns pointer to event
//
//--------------------------------------------------------------------
STDMETHODIMP CStdEvent::GetHandle(HANDLE *ph)
{
    *ph = m_hEvent;
    return S_OK;
}


//+-------------------------------------------------------------------
//
//  Member:     CStdEvent::SetEventHandle, public
//
//  Synopsis:   Sets an event handle
//
//--------------------------------------------------------------------
STDMETHODIMP CStdEvent::SetEventHandle(HANDLE *ph)
{
    if (m_hEvent == NULL)
    {
        m_hEvent = *ph;
        return S_OK;
    }

    return E_FAIL;
}


// Manual Reset Methods
//+-------------------------------------------------------------------
//
//  Member:     CMREInnerUnknown::AddRef, public
//
//  Synopsis:   Adds a reference to an interface
//
//--------------------------------------------------------------------
STDMETHODIMP_(ULONG) CMREInnerUnknown::AddRef()
{
    return InterlockedIncrement( (long *) &_iRefCount );
}

//+-------------------------------------------------------------------
//
//  Member:     CMREInnerUnknown::CMREInnerUnknown
//
//  Synopsis:   Constructor
//
//--------------------------------------------------------------------
CMREInnerUnknown::CMREInnerUnknown( CManualResetEvent *pParent )
{
    _iRefCount = 1;
    _pParent   = pParent;
}

//+-------------------------------------------------------------------
//
//  Member:     CMREInnerUnknown::QueryInterface, public
//
//  Synopsis:   Returns a pointer to the requested interface.
//
//--------------------------------------------------------------------
STDMETHODIMP CMREInnerUnknown::QueryInterface( REFIID riid, LPVOID FAR* ppvObj)
{
    IUnknown *pUnk;

    if (IsEqualIID(riid, IID_IUnknown))
        pUnk = (IUnknown *) this;
    else if (IsEqualIID(riid, IID_ISynchronize))
        pUnk = (ISynchronize *) _pParent;
    else if (IsEqualIID(riid, IID_ISynchronizeHandle))
        pUnk = (ISynchronizeHandle *) _pParent;
    else
    {
        *ppvObj = NULL;
        return E_NOINTERFACE;
    }

    pUnk->AddRef();
    *ppvObj = pUnk;
    return S_OK;
}

//+-------------------------------------------------------------------
//
//  Member:     CMREInnerUnknown::Release, public
//
//  Synopsis:   Releases an interface
//
//--------------------------------------------------------------------
STDMETHODIMP_(ULONG) CMREInnerUnknown::Release()
{
    ULONG lRef = InterlockedDecrement( (long*) &_iRefCount );

    if (lRef == 0)
    {
        delete _pParent;
    }

    return lRef;
}

//+-------------------------------------------------------------------
//
//  Member:     CManualResetEvent::AddRef, public
//
//  Synopsis:   Forwards AddRef to the controlling unknown
//
//--------------------------------------------------------------------
STDMETHODIMP_(ULONG) CManualResetEvent::AddRef()
{
    return _pControl->AddRef();
}

//+-------------------------------------------------------------------
//
//  Member:     CManualResetEvent::CManualResetEvent
//
//  Synopsis:   Constructor
//
//--------------------------------------------------------------------
CManualResetEvent::CManualResetEvent( IUnknown *pControl, HRESULT *phr ) :
_cInner( this )
{
    // CManualResetEvent creates a CStdEvent containing a
    // ManualResetEvent, and delegates its methods to
    // CStdEvent

    if (pControl != NULL)
        _pControl = pControl;
    else
        _pControl = &_cInner;

    m_cStdEvent = new CStdEvent(NULL);

    if (m_cStdEvent == NULL)
    {
        *phr = E_OUTOFMEMORY;
        return;
    }

    // Create an unnamed manual reset event
    HANDLE hEvent = CreateEvent(NULL,TRUE,FALSE,NULL);
    if (hEvent == NULL)
    {
        *phr = E_FAIL;
        return;
    }

    *phr = m_cStdEvent->SetEventHandle(&hEvent);
    if (FAILED(*phr))
    {
        return;
    }
    *phr = S_OK;
}

//+-------------------------------------------------------------------
//
//  Member:     CManualResetEvent::~CManualResetEvent
//
//  Synopsis:   Destructor
//
//--------------------------------------------------------------------
CManualResetEvent::~CManualResetEvent( )
{
    if (m_cStdEvent != NULL)
        m_cStdEvent->Release();
}

//+-------------------------------------------------------------------
//
//  Member:     CManualResetEvent::QueryInterface, public
//
//  Synopsis:   Forwards QueryInterface to the controlling unknown
//
//-------------------------------------------------------------------
STDMETHODIMP CManualResetEvent::QueryInterface( REFIID riid, LPVOID FAR* ppvObj)
{
    return _pControl->QueryInterface( riid, ppvObj );
}

//+-------------------------------------------------------------------
//
//  Member:     CManualResetEvent::Release, public
//
//  Synopsis:   Forwards Release to the controlling unknown
//
//--------------------------------------------------------------------
STDMETHODIMP_(ULONG) CManualResetEvent::Release()
{
    return _pControl->Release();
}


//+-------------------------------------------------------------------
//
//  Member:     CManualResetEvent::Wait, public
//
//  Synopsis:   Waits for call to complete.  For MTA it just blocks.
//              For STA it enters a message loop.
//
//--------------------------------------------------------------------
STDMETHODIMP CManualResetEvent::Wait(DWORD dwFlags, DWORD dwTimeout )
{
    return m_cStdEvent->Wait(dwFlags, dwTimeout);
}


//+-------------------------------------------------------------------
//
//  Member:     CManualResetEvent::Signal, public
//
//  Synopsis:   Invoked when the call is done.  Sets event.
//
//--------------------------------------------------------------------
STDMETHODIMP CManualResetEvent::Signal()
{
    return m_cStdEvent->Signal();
}


//+-------------------------------------------------------------------
//
//  Member:     CManualResetEvent::Reset, public
//
//  Synopsis:   Resets ISynchronize state.
//
//--------------------------------------------------------------------
STDMETHODIMP CManualResetEvent::Reset()
{
    return m_cStdEvent->Reset();
}


//+-------------------------------------------------------------------
//
//  Member:     CManualResetEvent::GetHandle, public
//
//  Synopsis:   Gets Event handle.
//
//--------------------------------------------------------------------
STDMETHODIMP CManualResetEvent::GetHandle(HANDLE *ph)
{
    return m_cStdEvent->GetHandle(ph);
}


// ISynchronizeContainer Methods
//+-------------------------------------------------------------------
//
//  Member:     CSCInnerUnknown::AddRef, public
//
//  Synopsis:   Adds a reference to an interface
//
//--------------------------------------------------------------------
STDMETHODIMP_(ULONG) CSCInnerUnknown::AddRef()
{
    return InterlockedIncrement( (long *) &_iRefCount );
}

//+-------------------------------------------------------------------
//
//  Member:     CSCInnerUnknown::CSCInnerUnknown
//
//  Synopsis:   Constructor
//
//--------------------------------------------------------------------
CSCInnerUnknown::CSCInnerUnknown( CSynchronizeContainer *pParent )
{
    _iRefCount = 1;
    _pParent   = pParent;
}

//+-------------------------------------------------------------------
//
//  Member:     CSCInnerUnknown::QueryInterface, public
//
//  Synopsis:   Returns a pointer to the requested interface.
//
//--------------------------------------------------------------------
STDMETHODIMP CSCInnerUnknown::QueryInterface( REFIID riid, LPVOID FAR* ppvObj)
{
    IUnknown *pUnk;

    if (IsEqualIID(riid, IID_IUnknown))
        pUnk = (IUnknown *) this;
    else if (IsEqualIID(riid, IID_ISynchronizeContainer))
        pUnk = (ISynchronizeContainer *) _pParent;
    else
    {
        *ppvObj = NULL;
        return E_NOINTERFACE;
    }

    pUnk->AddRef();
    *ppvObj = pUnk;
    return S_OK;
}

//+-------------------------------------------------------------------
//
//  Member:     CSCInnerUnknown::Release, public
//
//  Synopsis:   Releases an interface
//
//--------------------------------------------------------------------
STDMETHODIMP_(ULONG) CSCInnerUnknown::Release()
{
    ULONG lRef = InterlockedDecrement( (long*) &_iRefCount );

    if (lRef == 0)
    {
        delete _pParent;
    }

    return lRef;
}

//+-------------------------------------------------------------------
//
//  Member:     CSynchronizeContainer::AddRef, public
//
//  Synopsis:   Forwards AddRef to the controlling unknown
//
//--------------------------------------------------------------------
STDMETHODIMP_(ULONG) CSynchronizeContainer::AddRef()
{
    return _pControl->AddRef();
}

//+-------------------------------------------------------------------
//
//  Member:     CSynchronizeContainer::CSynchronizeContainer
//
//  Synopsis:   Constructor
//
//--------------------------------------------------------------------
CSynchronizeContainer::CSynchronizeContainer( IUnknown *pControl) :
_cInner( this ),
_lLast(0)
{
    if (pControl != NULL)
        _pControl = pControl;
    else
        _pControl = &_cInner;
}

//+-------------------------------------------------------------------
//
//  Member:     CSynchronizeContainer::~CSynchronizeContainer
//
//  Synopsis:   Destructor
//
//--------------------------------------------------------------------
CSynchronizeContainer::~CSynchronizeContainer( )
{
    DWORD i;
    // Free any remaining synchronizes.
    for (i = 0; i < _lLast; i++)
        _aSync[i]->Release();
}

//+-------------------------------------------------------------------
//
//  Member:     CSynchronizeContainer::QueryInterface, public
//
//  Synopsis:   Forwards QueryInterface to the controlling unknown
//
//--------------------------------------------------------------------
STDMETHODIMP CSynchronizeContainer::QueryInterface( REFIID riid, LPVOID FAR* ppvObj)
{
    return _pControl->QueryInterface( riid, ppvObj );
}

//+-------------------------------------------------------------------
//
//  Member:     CSynchronizeContainer::Release, public
//
//  Synopsis:   Forwards Release to the controlling unknown
//
//--------------------------------------------------------------------
STDMETHODIMP_(ULONG) CSynchronizeContainer::Release()
{
    return _pControl->Release();
}


//+-------------------------------------------------------------------
//
//  Member:     CSynchronizeContainer::AddSynchronize, public
//
//  Synopsis:   Adds an ISynchronize Object to the list of objects
//              to wait on.
//
//--------------------------------------------------------------------
STDMETHODIMP CSynchronizeContainer::AddSynchronize(ISynchronize *pSync)
{

    HRESULT            hr;
    HANDLE             hEvent;
    ISynchronizeHandle *pEvent;

    if (pSync == NULL)
    {
        return E_INVALIDARG;
    }


    // Get the synchronize's event.
    hr = pSync->QueryInterface( IID_ISynchronizeHandle, (void **) &pEvent );
    if (FAILED(hr))
        return hr;

    hr = pEvent->GetHandle( &hEvent );
    pEvent->Release();
    if (FAILED(hr))
        return hr;

    // Add the synchronize at the end of the array (if its not full).
    ASSERT_LOCK_NOT_HELD(gComLock);
    LOCK(gComLock);
    if (_lLast < MAX_SYNC)
    {
        _aEvent[_lLast] = hEvent;
        _aSync[_lLast]  = pSync;
        _lLast         += 1;
    } else
        hr = RPC_E_OUT_OF_RESOURCES;
    UNLOCK(gComLock);

    // If we kept the ISynchronize, AddRef it.
    if (SUCCEEDED(hr))
        pSync->AddRef();
    return hr;

}


//+-------------------------------------------------------------------
//
//  Member:     CSynchronizeContainer::WaitMultiple, public
//
//  Synopsis:   Waits for objects to be signaled.
//
//--------------------------------------------------------------------
//  CODEWORK: There are race conditions that can occur if multiple threads
//    are executing WaitMultiple on the same container. The underlying
//    Win32 APIs use an array of handles. To meet the spec, the signaled
//    synchronize object is to be removed from the container when signaled.
//    This causes the array of events to be modified. It is unpredictable
//    what will happen if another thread is in WaitMultiple when this occurs.
//    Should this be detected (and an error returned) to enforce only a
//    single thread can be in WaitMultiple at a time?
//
STDMETHODIMP CSynchronizeContainer::WaitMultiple(DWORD dwFlags,
                                                 DWORD dwTimeout,
                                                 ISynchronize **ppSync)
{
    DWORD index = 0;
    if (dwFlags&COWAIT_WAITALL)
    {
        // Wait all not supported
        return E_INVALIDARG;
    }

    if (_lLast == 0)
    {
        // Nothing to Synchronize
        return RPC_E_NO_SYNC;
    }

    if (ppSync == NULL)
    {
        return E_INVALIDARG;
    }

    HRESULT hr = CoWaitForMultipleHandles(dwFlags,
                                          dwTimeout,
                                          _lLast,
                                          _aEvent,
                                          &index);
    if (FAILED(hr))
    {
        *ppSync = NULL;
    } else
    {
        // Have interface that signaled, remove
        // From list and return it to caller
        ASSERT_LOCK_NOT_HELD(gComLock);
        LOCK(gComLock);

        *ppSync = _aSync[index];

        Win4Assert((_lLast>0) && (index<_lLast));

        _lLast--;
        for(; index<_lLast ; index++)
        {
          _aEvent[index] = _aEvent[index+1];
          _aSync[index] = _aSync[index+1];
        }

        UNLOCK(gComLock);
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\com\dcomrem\threads.cxx ===
//+-------------------------------------------------------------------
//
//  File:       threads.cxx
//
//  Contents:   Rpc thread cache
//
//  Classes:    CRpcThread       - single thread
//              CRpcThreadCache  - cache of threads
//
//  Notes:      This code represents the cache of Rpc threads used to
//              make outgoing calls in the SINGLETHREADED object Rpc
//              model.
//
//  History:                Rickhi  Created
//              07-31-95    Rickhi  Fix event handle leak
//
//+-------------------------------------------------------------------
#include    <ole2int.h>
#include    <olerem.h>
#include    <threads.hxx>
#include    <security.hxx>   // SuspendImpersonate

// Rpc worker thread cache.
CRpcThreadCache     gRpcThreadCache;

// static members of ThreadCache class
CRpcThread * CRpcThreadCache::_pFreeList = NULL;// list of free threads
COleStaticMutexSem    CRpcThreadCache::_mxs;    // for list manipulation


//+-------------------------------------------------------------------
//
//  Member:     CRpcThreadCache::RpcWorkerThreadEntry
//
//  Purpose:    Entry point for an Rpc worker thread.
//
//  Returns:    nothing, it never returns.
//
//  Callers:    Called ONLY by a worker thread.
//
//+-------------------------------------------------------------------
DWORD _stdcall CRpcThreadCache::RpcWorkerThreadEntry(void *param)
{    
    // First thing we need to do is LoadLibrary ourselves in order to
    // prevent our code from going away while this worker thread exists.
    // The library will be freed when this thread exits.

    HINSTANCE hInst = LoadLibrary(L"OLE32.DLL");

    // Now reset ourselves to implicit MTA, and mark us as a dispatch
    // thread, so people can't take us OUT of the MTA.  (It's really 
    // bad if one of these threads goes back into the cache as an
    // STA.)
    ResetTLS();

    // Call the worker loop for the thread object parameter and delete it
    // when its done.
    CRpcThread *pThrd = (CRpcThread *) param;
    pThrd->WorkerLoop();
    delete pThrd;

    // Simultaneously free our Dll and exit our thread. This allows us to
    // keep our Dll around incase a remote call was cancelled and the
    // worker thread is still blocked on the call, and allows us to cleanup
    // properly when all threads are done with the code.

    FreeLibraryAndExitThread(hInst, 0);

    // compiler wants a return value
    return 0;
}

//+-------------------------------------------------------------------
//
//  Function:   CRpcThreadCache::ResetTLS
//
//  Purpose:    Reset TLS to being an implicit MTA thread, and marks
//              the thread as a dispatch thread.  This is to prevent
//              corruption by stupid code.
//
//  Callers:    Called ONLY by worker thread.
//
//+-------------------------------------------------------------------
void CRpcThreadCache::ResetTLS()
{
    HRESULT hr;
    COleTls Tls(hr);
    if (FAILED(hr))
    {
        // Must not have had a TLS, and we couldn't allocate one. Um.
        // Just bail.
        return;
    }

    // First, uninitialize.  
    //
    // I'm making the assumption that, if this is an MTA thread, then it
    // is not the only remaining MTA thread.  We explicitly want this 
    // thread to be in the IMPLICIT MTA.  
    //
    // Get rid of OleInitialize calls first...
    while (Tls->cOleInits > 0)
    {        
        DWORD dwOldInits = Tls->cOleInits;

        OleUninitialize();

        // Make sure we're actually doing something here...
        Win4Assert(dwOldInits > Tls->cOleInits);
    }
    // Then get rid of CoInitialize calls...
    while (Tls->cComInits > 0)
    {
        DWORD dwOldInits = Tls->cComInits;

        CoUninitialize();

        // Make sure we're actually doing something here...
        Win4Assert(dwOldInits > Tls->cOleInits);
    }

    // Now we should be implicit MTA (if anything).  
    Win4Assert(!(Tls->dwFlags & OLETLS_APARTMENTTHREADED) &&
               !(Tls->dwFlags & OLETLS_MULTITHREADED));

    // Mark as dispatch thread, so we don't have to do this again.
    Tls->dwFlags |= OLETLS_DISPATCHTHREAD;

    return;
}

//+-------------------------------------------------------------------
//
//  Member:     CRpcThread::CRpcThread
//
//  Purpose:    Constructor for a thread object.
//
//  Notes:      Allocates a wakeup event.
//
//  Callers:    Called ONLY by CacheCreateThread.
//
//+-------------------------------------------------------------------
CRpcThread::CRpcThread(LPTHREAD_START_ROUTINE fn, void *param) :
    _fn(fn),
    _param(param),
    _pNext(NULL),
    _fDone(FALSE)
{
    //  create the Wakeup event. Do NOT use the event cache, as there are
    //  some exit paths that leave this event in the signalled state!
    _hWakeup = CreateEvent(NULL, FALSE, FALSE, NULL);

    ComDebOut((DEB_CHANNEL,
        "CRpcThread::CRpcThread pThrd:%x _hWakeup:%x\n", this, _hWakeup));
}


//+-------------------------------------------------------------------
//
//  Member:     CRpcThread::~CRpcThread
//
//  Purpose:    Destructor for an Rpc thread object.
//
//  Notes:      When threads are exiting, they place the CRpcThread
//              object on the delete list. The main thread then later
//              pulls it from the delete list and calls this destructor.
//
//  Callers:    Called ONLY by a worker thread.
//
//+-------------------------------------------------------------------
CRpcThread::~CRpcThread()
{
    // close the event handle. Do NOT use the event cache, since not all
    // exit paths leave this event in the non-signalled state. Also, do
    // not close NULL handle.

    if (_hWakeup)
    {
        CloseHandle(_hWakeup);
    }

    ComDebOut((DEB_CHANNEL,
        "CRpcThread::~CRpcThread pThrd:%x _hWakeup:%x\n", this, _hWakeup));
}


//---------------------------------------------------------------------------
//
//  Method:     CRpcThread::operator delete
//
//  Synopsis:   Use the process heap rather then the COM debug heap.
//              See operator new.
//
//---------------------------------------------------------------------------
void CRpcThread::operator delete( void *thread )
{
    HeapFree( GetProcessHeap(), 0, thread );
}

//---------------------------------------------------------------------------
//
//  Method:     CRpcThread::operator new
//
//  Synopsis:   Allocate memory for this class directly out of the process
//              heap so the debug memory allocator doesn't track this
//              memory.  Threads frequently don't have a chance to clean up
//              before the process exits (CRpcResolver::WorkerThreadLoop)
//
//---------------------------------------------------------------------------
void *CRpcThread::operator new( size_t size )
{
    return HeapAlloc( GetProcessHeap(), 0, size );
}

//+-------------------------------------------------------------------
//
//  Function:   CRpcThread::WorkerLoop
//
//  Purpose:    Entry point for a new Rpc call thread.
//
//  Notes:      Dispatch to the specified function.  When it returns wait
//              if possible.  If we wake up with more work, do it.
//
//              When there is no more work after some timeout period, we
//              pull it from the free list and exit.
//
//  Callers:    Called ONLY by worker thread.
//
//+-------------------------------------------------------------------
void CRpcThread::WorkerLoop()
{
    // Main worker loop where we do some work then wait for more.
    // When the thread has been inactive for some period of time
    // it will exit the loop.

    while (!_fDone)
    {
    	Win4Assert( _fn != NULL );
    	
        // Dispatch the call.
        _fn(_param);

        // Leverage appverifier.   Do this before null'ing params, so
        // we know what code we just called into.
        RtlCheckForOrphanedCriticalSections(GetCurrentThread());

        _fn    = NULL;
        _param = NULL;

        if (!_hWakeup)
        {
            // we failed to create an event in the ctor so we cant
            // get put on the freelist to be re-awoken later with more
            // work. Just exit.
            break;
        }

        // put the thread object on the free list
        gRpcThreadCache.AddToFreeList(this);

        // Wait for more work or for a timeout.
        DWORD dwRet;
        ULONG i;
        
        i = 0;
        while (TRUE)
        {
            dwRet = WaitForSingleObjectEx(_hWakeup, THREAD_INACTIVE_TIMEOUT, 0);
            if (dwRet == WAIT_OBJECT_0)
            {
                // just break out, we have new work to do
                break;
            }
            else
            {
                // This assert might be overactive during stress?
                Win4Assert(dwRet == WAIT_TIMEOUT);
				
                //
                // Either we haven't gotten any new work in the last timeout period, or
                // WFSOEx is blowing chunks.  In either case try to remove ourself from 
                // the free thread list.  If _fDone is still FALSE, it means someone is 
                // about to give us more work to do (so go wait for that to happen).
                //
                // Note there is a possibility that WFSOEx might be so broken on an over-
                // stressed machine that it keeps failing, and we keep looping.  However
                // eventually we will either get new work to do, or we will manage to
                // get off of the free list and die.
                //
                gRpcThreadCache.RemoveFromFreeList(this);
                if(_fDone)
                {
                    // OK to exit and let this thread die.
                    break;
                }
            }

            i++; // for debugging if we ever get stuck in a loop
        }
    }

    // Assert that we are not exiting with work 
    // assigned to us.
    Win4Assert(_fn == NULL);
}


//+-------------------------------------------------------------------
//
//  Function:   CacheCreateThread
//
//  Purpose:    Finds the first free thread, and dispatches the request
//              to that thread, or creates a new thread if none are
//              available.
//
//  Notes:      This function is just like CreateThread except
//              - It doesn't return a thread handle
//              - It's faster when it uses a cached thread
//              - It handles shutdown when ole32.dll is unloaded
//              - It sets the security descriptor so you don't get
//                a random one if called when impersonating.
//
//  Returns:    S_OK if dispatched OK
//              HRESULT if it can't create a thread.
//
//+-------------------------------------------------------------------
HRESULT CacheCreateThread( LPTHREAD_START_ROUTINE fn, void *param )
{
    Win4Assert( fn != NULL );
    if( fn == NULL )
        return E_INVALIDARG;
		
    HRESULT hr = S_OK;

    LOCK (CRpcThreadCache::_mxs);

    // grab the first thread from the list
    CRpcThread *pThrd = CRpcThreadCache::_pFreeList;

    if (pThrd)
    {
        // update the free list pointer
        CRpcThreadCache::_pFreeList = pThrd->GetNext();
        UNLOCK (CRpcThreadCache::_mxs);

        // dispatch the call
        pThrd->Dispatch(fn, param);
    }
    else
    {
        // Remove the thread token.
        UNLOCK (CRpcThreadCache::_mxs);
        HANDLE hThread;
        SuspendImpersonate( &hThread );

        // no free threads, spin up a new one and dispatch directly to it.
        pThrd = new CRpcThread( fn, param );
        if (pThrd != NULL)
        {
            DWORD  dwThrdId;
            HANDLE hThrd = CreateThread(
                                        NULL,
                                        0,
                                        CRpcThreadCache::RpcWorkerThreadEntry,
                                        pThrd, 0,
                                        &dwThrdId);

            if (hThrd)
            {
                // close the thread handle since we dont need it for anything.
                CloseHandle(hThrd);
            }
            else
            {
                hr = HRESULT_FROM_WIN32(GetLastError());
                delete pThrd;
                ComDebOut((DEB_ERROR,"CreatThread failed:%x\n", hr));
            }
        }
        else
            hr = E_OUTOFMEMORY;

        // Restore the thread token.
        ResumeImpersonate( hThread );
    }

    return hr;
}


//+-------------------------------------------------------------------
//
//  Member:     CRpcThreadCache::RemoveFromFreeList
//
//  Purpose:    Tries to pull a thread from the free list.
//
//  Returns:    pThrd->_fDone TRUE if it was successfull and thread can exit.
//              pThrd->_fDone FALSE otherwise.
//
//  Callers:    Called ONLY by a worker thread.
//
//+-------------------------------------------------------------------
void CRpcThreadCache::RemoveFromFreeList(CRpcThread *pThrd)
{
    ComDebOut((DEB_CHANNEL,
        "CRpcThreadCache::RemoveFromFreeList pThrd:%x\n", pThrd));

    COleStaticLock lck(_mxs);

    //  pull pThrd from the free list. if it is not on the free list
    //  then either it has just been dispatched OR ClearFreeList has
    //  just removed it, set _fDone to TRUE, and kicked the wakeup event.

    CRpcThread *pPrev = NULL;
    CRpcThread *pCurr = _pFreeList;

    while (pCurr && pCurr != pThrd)
    {
        pPrev = pCurr;
        pCurr = pCurr->GetNext();
    }

    if (pCurr == pThrd)
    {
        // remove it from the free list.
        if (pPrev)
            pPrev->SetNext(pThrd->GetNext());
        else
            _pFreeList = pThrd->GetNext();

        // tell the thread to wakeup and exit
        pThrd->WakeAndExit();
    }
}


//+-------------------------------------------------------------------
//
//  Member:     CRpcThreadCache::ClearFreeList
//
//  Purpose:    Cleans up all threads on the free list.
//
//  Notes:      For any threads still on the free list, it pulls them
//              off the freelist, sets their _fDone flag to TRUE, and
//              kicks their event to wake them up. When the threads
//              wakeup, they will exit.
//
//              We do not free active threads. The only way for a thread
//              to still be active at this time is if it was making an Rpc
//              call and was cancelled by the message filter and the thread has
//              still not returned to us.  We cant do much about that until
//              Rpc supports cancel for all protocols.  If the thread ever
//              does return to us, it will eventually idle-out and delete
//              itself. This is safe because the threads LoadLibrary OLE32.
//
//  Callers:    Called ONLY by the last COM thread during
//              ProcessUninitialize.
//
//+-------------------------------------------------------------------
void CRpcThreadCache::ClearFreeList(void)
{
    ComDebOut((DEB_CHANNEL, "CRpcThreadCache::ClearFreeList\n"));

    {
        COleStaticLock lck(_mxs);

        CRpcThread *pThrd = _pFreeList;
        while (pThrd)
        {
            // use temp variable incase thread exits before we call GetNext
            CRpcThread *pThrdNext = pThrd->GetNext();
            pThrd->WakeAndExit();
            pThrd = pThrdNext;
        }

        _pFreeList = NULL;

        // the lock goes out of scope at this point. we dont want to hold
        // it while we sleep.
    }

    // yield to let the other threads run if necessary.
    Sleep(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\com\dcomrem\svcdomain.cxx ===
//+-------------------------------------------------------------------
//
//  File:       svcdomain.cxx
//
//  Contents:   Services Without Components APIs
//
//  Functions:  CoPushServiceDomain
//              CoPopServiceDomain
//
//  Notes:      This code represents the APIs provided to COM+ by
//              ole32.dll in order to enable services without components
//
//  History:    02-08-2001  mfeingol created
//
//+-------------------------------------------------------------------

#include "ole2int.h"
#include "crossctx.hxx"

STDAPI CoPushServiceDomain (IObjContext* pObjContext)
{
    if (!pObjContext || !IsValidInterface (pObjContext))
    {
        return E_INVALIDARG;
    }
    
    if (!IsApartmentInitialized())
    {
        return CO_E_NOTINITIALIZED;
    }

    return EnterServiceDomain (pObjContext);
}

STDAPI CoPopServiceDomain (IObjContext** ppObjContext)
{   
    if (!ppObjContext)
    {
        return E_INVALIDARG;
    }

    return LeaveServiceDomain (ppObjContext);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\com\dcomrem\vsevfire.h ===
//+-------------------------------------------------------------------
//
//  File:       vsevfile.h
//
//  Contents:   Vista events and related functions
//
//  History:    26-Sep-97  RongC  Created
//
//  Note:       This file was generated from vsevfire.idl in the Vista land.
//              Since we only use a very small and stable subset part of
//              the original file, we don't want to build the IDL file
//              everytime.  We may, however, consider building vsevfire.idl
//              when it ships with NT 5.0 SDK.
//
//--------------------------------------------------------------------

typedef enum VSAParameterType {
    cVSAParameterKeyMask            = 0x80000000,
    cVSAParameterKeyString          = 0x80000000,
    cVSAParameterValueMask          = 0x7ffff,
    cVSAParameterValueTypeMask      = 0x70000,
    cVSAParameterValueUnicodeString = 0,
    cVSAParameterValueANSIString    = 0x10000,
    cVSAParameterValueGUID          = 0x20000,
    cVSAParameterValueDWORD         = 0x30000,
    cVSAParameterValueBYTEArray     = 0x40000,
    cVSAParameterValueLengthMask    = 0xffff
} VSAParameterFlags;

typedef enum VSAStandardParameter {
    cVSAStandardParameterSourceMachine      = 0,
    cVSAStandardParameterSourceProcess      = 1,
    cVSAStandardParameterSourceThread       = 2,
    cVSAStandardParameterSourceComponent    = 3,
    cVSAStandardParameterSourceSession      = 4,
    cVSAStandardParameterTargetMachine      = 5,
    cVSAStandardParameterTargetProcess      = 6,
    cVSAStandardParameterTargetThread       = 7,
    cVSAStandardParameterTargetComponent    = 8,
    cVSAStandardParameterTargetSession      = 9,
    cVSAStandardParameterSecurityIdentity   = 10,
    cVSAStandardParameterCausalityID        = 11,
    cVSAStandardParameterNoDefault          = 0x4000,
    cVSAStandardParameterSourceHandle       = 0x4000,
    cVSAStandardParameterTargetHandle       = 0x4001,
    cVSAStandardParameterArguments          = 0x4002,
    cVSAStandardParameterReturnValue        = 0x4003,
    cVSAStandardParameterException          = 0x4004,
    cVSAStandardParameterCorrelationID      = 0x4005
} VSAStandardParameters;

typedef enum eVSAEventFlags {
    cVSAEventStandard       = 0,
    cVSAEventDefaultSource  = 1,
    cVSAEventDefaultTarget  = 2,
    cVSAEventCanBreak       = 4
} VSAEventFlags;


const IID IID_ISystemDebugEventFire =
    {0x6C736DC1,0xAB0D,0x11D0,{0xA2,0xAD,0x00,0xA0,0xC9,0x0F,0x27,0xE8}};

interface ISystemDebugEventFire : public IUnknown
{
public:
    virtual HRESULT STDMETHODCALLTYPE BeginSession( 
        /* [in] */ REFGUID guidSourceID,
        /* [in] */ LPCOLESTR strSessionName) = 0;
    
    virtual HRESULT STDMETHODCALLTYPE EndSession( void) = 0;
    
    virtual HRESULT STDMETHODCALLTYPE IsActive( void) = 0;
    
    virtual HRESULT STDMETHODCALLTYPE FireEvent( 
        /* [in] */ REFGUID guidEvent,
        /* [in] */ int nEntries,
        /* [size_is][in] */ PULONG_PTR rgKeys,
        /* [size_is][in] */ PULONG_PTR rgValues,
        /* [size_is][in] */ LPDWORD rgTypes,
        /* [in] */ DWORD dwTimeLow,
        /* [in] */ LONG dwTimeHigh,
        /* [in] */ VSAEventFlags dwFlags) = 0;
};


const IID IID_ISystemDebugEventShutdown =
    {0x6C736DCF,0xAB0D,0x11D0,{0xA2,0xAD,0x00,0xA0,0xC9,0x0F,0x27,0xE8}};

interface ISystemDebugEventShutdown : public IUnknown
{
public:
    virtual HRESULT STDMETHODCALLTYPE Shutdown( void) = 0;
};


extern const CLSID CLSID_VSA_IEC =
    {0x6C736DB1,0xBD94,0x11D0,{0x8A,0x23,0x00,0xAA,0x00,0xB5,0x8E,0x10}};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\com\dde\client\cnct_tbl.cxx ===
// cnct_tbl.cpp
//
// class CConnectionTable
//
// CConnectionTable maps connection numbers (as returned by ::Advise())
// to clipformat's for DDE advise connections.

#include "ddeproxy.h"
#include "cnct_tbl.h"

ASSERTDATA

#define grfMemFlags (GMEM_MOVEABLE | GMEM_ZEROINIT)

// number of INFO entries to grow by
#define cinfoBlock 10

typedef struct INFO
{
    BOOL       fUsed;         // is this table entry used?
    DWORD      dwConnection;  // search key
    CLIPFORMAT cf;            // corresponding cf, for use in DDE_(UN)ADVISE
    DWORD      grfAdvf;       // ON_CHANGE or ON_SAVE or ON_CLOSE
} INFO, FAR* PINFO;



CDdeConnectionTable::CDdeConnectionTable ()
{
    m_h = GlobalAlloc (grfMemFlags, cinfoBlock * sizeof(INFO));
    Assert (m_h);
    m_cinfo=cinfoBlock;
}


CDdeConnectionTable::~CDdeConnectionTable ()
{
    Assert(m_h);
    m_h =GlobalFree (m_h);
    Assert (m_h==NULL);
    m_cinfo=0;
}




INTERNAL CDdeConnectionTable::Add
    (DWORD      dwConnection,
     CLIPFORMAT cf,
     DWORD      grfAdvf)
{
  Start:
    PINFO rginfo;

    if (NULL==(rginfo = (PINFO) GlobalLock(m_h)))
    {
        Puts ("ERROR: CDdeConnectionTable::Add out of memory\n");
        return ReportResult(0, E_OUTOFMEMORY, 0, 0);
    }
    // Look for an empty table entry
    for (DWORD i=0; i<m_cinfo; i++)
    {
        if (!rginfo[i].fUsed)
        {
            rginfo[i].fUsed        = TRUE;
            rginfo[i].dwConnection = dwConnection;
            rginfo[i].cf           = cf;
            rginfo[i].grfAdvf      = grfAdvf;
            break;
        }
        else
        {
            Assert (rginfo[i].dwConnection != dwConnection);
        }
    }
    GlobalUnlock (m_h);
    if (i==m_cinfo) // if no empty entry found
    {
        Puts ("Growing the connection table\n");
        // Note: GlobalReAlloc returns NULL if failure. Don't lose
        // the orignial handle value if failure.
        HANDLE hTmp = GlobalReAlloc(m_h,(m_cinfo += cinfoBlock) * sizeof(INFO),
                             grfMemFlags);
        if (hTmp==NULL)
            return ReportResult(0, E_OUTOFMEMORY, 0, 0);
        m_h = hTmp;
        goto Start;
    }
    else
    {
        return NOERROR;
    }
}




INTERNAL CDdeConnectionTable::Subtract
    (DWORD           dwConnection,
     CLIPFORMAT FAR* pcf,          // out parm
     DWORD FAR* pgrfAdvf)          // out parm
{
    PINFO rginfo;
    if (dwConnection==0)
    {
        Puts ("CDdeConnectionTable::Subtract called with dwConnection==0\n");
        return ReportResult(0, E_INVALIDARG, 0, 0);
    }

    if (NULL==(rginfo = (PINFO) GlobalLock(m_h)))
    {
        Assert (0);
        Puts ("ERROR: CDdeConnectionTable::Subtract out of memory\n");
        return ReportResult(0, E_OUTOFMEMORY, 0, 0);
    }

    for (DWORD i=0; i<m_cinfo; i++)
    {
        if (rginfo[i].fUsed && rginfo[i].dwConnection == dwConnection)
        {
            Assert (pcf);
            *pcf = rginfo[i].cf;
            Assert (pgrfAdvf);
            *pgrfAdvf = rginfo[i].grfAdvf;
            rginfo[i].fUsed = FALSE;  // remove this connection
            GlobalUnlock (m_h);
            return NOERROR;
        }
    }
    GlobalUnlock (m_h);
    return ReportResult(0, S_FALSE, 0, 0); // not found
}




INTERNAL CDdeConnectionTable::Lookup
    (CLIPFORMAT cf,             // search key
    LPDWORD pdwConnection)      // out parm.  May be NULL on input
{
    PINFO rginfo;

    if (NULL==(rginfo = (PINFO) GlobalLock(m_h)))
    {
        Puts ("ERROR: CDdeConnectionTable::Lookup out of memory\n");
        return ReportResult(0, E_OUTOFMEMORY, 0, 0);
    }

    for (DWORD i=0; i<m_cinfo; i++)
    {
        if (rginfo[i].fUsed &&
            rginfo[i].cf == cf)
        {
            if (pdwConnection)
                *pdwConnection = rginfo[i].dwConnection;
            GlobalUnlock (m_h);
            return NOERROR;
        }
    }
    GlobalUnlock (m_h);
    return ReportResult(0, S_FALSE, 0, 0); // not found
}



INTERNAL CDdeConnectionTable::Erase
    (void)
{
    PINFO rginfo;
    Assert (wIsValidHandle(m_h, NULL));
    if (NULL==(rginfo = (PINFO) GlobalLock(m_h)))
    {
        Puts ("ERROR: CDdeConnectionTable::Lookup out of memory\n");
        Assert (0);
        return ReportResult(0, E_OUTOFMEMORY, 0, 0);
    }

    for (DWORD i=0; i<m_cinfo; i++)
    {
        rginfo[i].fUsed = FALSE;
    }
    GlobalUnlock (m_h);
    return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\com\dde\client\ddechc.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       DdeChC.cxx
//
//  Contents:   CDdeChannelControl implementation for DDE. This
//		implementation requires no instance data, therefore it is
//		intended to be static.
//
//  Functions:
//
//  History:    08-May-94 Johann Posch (johannp)    Created
//  		10-May-94 KevinRo  Made simpler
//		29-May-94 KevinRo  Added DDE Server support
//
//--------------------------------------------------------------------------
#include "ddeproxy.h"

//+---------------------------------------------------------------------------
//
//  Function:	DispatchCall
//
//  Synopsis:   DispatchCall is called to handle incoming calls.
//
//  Effects:    Dispatches a call to the specified in the DispatchData.
//		This function is the result of a call in OnData(), which
//		processes incoming calls from the OLE 1.0 server.
//
//  Arguments:  [pDispData] -- Points to the dispatch data structure
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:
//
//  History:    5-16-94   JohannP Created
//
//  Notes:
//
//----------------------------------------------------------------------------
INTERNAL DispatchCall( PDISPATCHDATA pDispData )
{
    intrDebugOut((DEB_ITRACE,
		  "DispatchCall(pDispData=%x)\n",
		  pDispData));

    intrAssert(pDispData != NULL);
    POLE1DISPATCHDATA pData = (POLE1DISPATCHDATA)pDispData->pData;
    intrAssert(pData != NULL);

    switch (pData->wDispFunc)
    {
    case DDE_DISP_SENDONDATACHANGE: // OnDataChange
	{
	    PDDEDISPATCHDATA pDData = (PDDEDISPATCHDATA)pDispData->pData;
	    return pDData->pCDdeObject->SendOnDataChange(pDData->iArg);
	}

    case DDE_DISP_OLECALLBACK: // OleCallBack
	{
	    PDDEDISPATCHDATA pDData = (PDDEDISPATCHDATA)pDispData->pData;
	    return  pDData->pCDdeObject->OleCallBack(pDData->iArg,NULL);
	}

    //
    // The server window has an incoming call. Look in dde\server\srvr.cxx
    //
    case DDE_DISP_SRVRWNDPROC:
	return(SrvrDispatchIncomingCall((PSRVRDISPATCHDATA)pDispData->pData));
    //
    // This dispatches to a Document window
    //
    case DDE_DISP_DOCWNDPROC:
	return(DocDispatchIncomingCall((PDOCDISPATCHDATA)pDispData->pData));

    default:
	intrAssert(!"Unknown wDispFunc");
    }
    return E_FAIL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\com\dde\client\cnct_tbl.h ===
// cnct_tbl.h

// CConnectionTable maps connection numbers (as returned by ::Advise())
// to clipformat's for DDE advise connections.

#ifndef fCnct_tbl_h
#define fCnct_tbl_h

class FAR CDdeConnectionTable : public CPrivAlloc
{
  public:
	CDdeConnectionTable();
	~CDdeConnectionTable();

	INTERNAL Add 		(DWORD dwConnection, CLIPFORMAT cf, DWORD grfAdvf);
	INTERNAL Subtract (DWORD dwConnection, CLIPFORMAT FAR* pcf, DWORD FAR* pgrfAdvf);
	INTERNAL Lookup	(CLIPFORMAT cf, LPDWORD pdwConnection);
	INTERNAL Erase		(void);

  private:
	HANDLE 	m_h;		  // handle to the table
	DWORD 	m_cinfo;	  // total number of INFO entries
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\com\dde\client\ddedo.cxx ===
/*
ddedo.cpp
DDE Data Object

copyright (c) 1992  Microsoft Corporation

Abstract:

    This module contains the methods for DdeObject::DataObject

Author:

    Jason Fuller    (jasonful)  24-July-1992

*/

#include "ddeproxy.h"
#include <stddef.h>
#include "trgt_dev.h"


#define f10UserModel
// Should we ignore a request by a 2.0 client to get advise-on-change,
// so that the user must do an explicit File/Update or File/Close?
// Probably yes, because:
// 1) Advise-on-change can be expensive for apps like PaintBrush.
// 2) It is confusing if the container asks for change updates
//    ONLY on presentation and not on native because when the user
//    closes the server and is asked "Do you want to update?" he'll say no
//    because the picture LOOKS correct even though the container does not
//    have the native data.
// 3) Excel: if A1 is the first cell you create, changes to other cells
//    will not be sent to the client until you change A1 again.
//    If advises are only sent explicitly, then all the cells extant at that
//    time will be considered part of the object.


ASSERTDATA


//
// DataObject methods
//

STDUNKIMPL_FORDERIVED(DdeObject, DataObjectImpl)


static inline INTERNAL_(BOOL) NotEqual
    (DVTARGETDEVICE FAR* ptd1,
    DVTARGETDEVICE FAR* ptd2)
{
    if (NULL==ptd1 && NULL==ptd2)
        return FALSE;
    else if ((ptd1 && !ptd2)
            || (ptd2 && !ptd1)
            || (ptd1->tdSize != ptd2->tdSize))
    {
        return TRUE;
    }
    else
#ifdef WIN32
        return 0 != memcmp(ptd1, ptd2, (size_t)ptd1->tdSize);
#else
        return 0 != _fmemcmp(ptd1, ptd2, (size_t)ptd1->tdSize);
#endif
}



// GetData
//
// The data is copied out of a private cache consisting of
// DdeObject::m_hNative, DdeObject::m_hPict, and DdeObject::m_hExtra.
// If the cache is empty, data is requested using WM_DDE_REQUEST.
// The cache should only be empty before the first DDE_DATA message
// is received.
// See DdeObject::KeepData()
//
STDMETHODIMP NC(CDdeObject,CDataObjectImpl)::GetData
    (LPFORMATETC pformatetcIn,
     LPSTGMEDIUM pmedium)
{
    intrDebugOut((DEB_ITRACE,
		  "CDdeObject::GetData(%x,pformatetcIn=%x)\n",
		  this,pformatetcIn));

lStart:
    intrDebugOut((DEB_ITRACE,"::GetData(%x)lStart\n",this));

    LPSTR lpGlobal=NULL;
    HRESULT hres;
    VDATEPTROUT (pmedium, STGMEDIUM);
    pmedium->tymed = TYMED_NULL;
    pmedium->pUnkForRelease = NULL;

    if ((hres = wVerifyFormatEtc (pformatetcIn)) != NOERROR)
    {
	goto exitRtn;
    }

    hres = E_UNEXPECTED; // assume error unless a clipboard format is found.

    if (DVASPECT_ICON & pformatetcIn->dwAspect)
    {
        hres = GetDefaultIcon(m_pDdeObject->m_clsid, NULL, &pmedium->hGlobal);
	if (hres != NOERROR)
	{
	    goto exitRtn;
	}
        hres = NOERROR;
        goto lDone;
    }
    if (m_pDdeObject->m_fGotCloseData)
    {
        // If we already got DDE_DATA on close, don't try requesting more
        // data. (MSDraw will give a bogus metafile.)
        hres=OLE_E_NOTRUNNING;
	goto exitRtn;
    }

    if (NotEqual (pformatetcIn->ptd, m_pDdeObject->m_ptd))
    {
        // If caller is asking for a different target device
        // (We assume a different pointer points to a different target device)

        if (NOERROR!=m_pDdeObject->SetTargetDevice (pformatetcIn->ptd))
        {
            // 1.0 server did not accept target device
	    hres=DATA_E_FORMATETC;
	    goto exitRtn;
        }

        Assert (hres!=NOERROR); // Must do RequestData with new target device
    }
    else
    {
        // Pick a member handle (H) to return, based on clipboard format CF.
        // If caller did not pass in its own medium, we must allocate a new
        // handle.


        #define macro(CF,H)                                                     \
        if (pformatetcIn->cfFormat == CF) {                             \
            if (m_pDdeObject->H) {                                      \
                if (pmedium->tymed == TYMED_NULL) {                     \
		intrDebugOut((DEB_ITRACE,"::GetData giving cf==%x hData=%x\n",CF,m_pDdeObject->H)); \
                    pmedium->hGlobal = m_pDdeObject->H;                 \
                    m_pDdeObject->H = NULL;                             \
                }                                                       \
                hres = NOERROR; /* found data in right format */        \
            }                                                           \
        }

             macro (g_cfNative,               m_hNative)
        else macro (m_pDdeObject->m_cfPict, m_hPict  )
        else macro (m_pDdeObject->m_cfExtra,m_hExtra )

        // If we gave away our picture, we must forget its format.
        if (pformatetcIn->cfFormat == m_pDdeObject->m_cfPict)
            m_pDdeObject->m_cfPict = 0;
        #undef macro
    }

    if (hres!=NOERROR)
    {
	intrDebugOut((DEB_ITRACE,
		      "::GetData(%x) posting DDE_REQUEST for cf==%x\n",
		      this,
		      (ULONG)pformatetcIn->cfFormat));

        // Didn't find a handle for the requested format,
        // or handle was NULL, so request it.
        // The sequence should be:
        // GetData -> DDE_REQUEST -> DDE_DATA -> OnData -> return to GetData

        if ((hres=m_pDdeObject->RequestData (pformatetcIn->cfFormat)) != NOERROR)
	{
	    intrDebugOut((DEB_ITRACE,
			  "::GetData(%x) RequestData returns error %x\n",
			  this,hres));

	    hres = DV_E_CLIPFORMAT;
	    goto exitRtn;
	}

        // By now, a KeepData() should have been done with the right cf,
        // so try again.
	intrDebugOut((DEB_ITRACE,
		      "::GetData(%x) KeepData should have been called. Go again\n",
			  this));

        Puts ("KeepData should have been called. Trying GetData again.\n");
        goto lStart;
    }
  lDone:
    Puts ("pmedium->hGlobal =="); Puth(pmedium->hGlobal); Putn();
    pmedium->pUnkForRelease = NULL;   // Let caller release medium
    // Must set tymed _after_ the goto loop.
    // Otherwise it'll be changed the second time around.

    // tell caller what we're returning
    pmedium->tymed = UtFormatToTymed (pformatetcIn->cfFormat);


    intrDebugOut((DEB_ITRACE,
		  "::GetData(%x)tymed=%x cfFormat=%x hGlobal=%x\n",
		  this,
		  pmedium->tymed,
		  (USHORT)pformatetcIn->cfFormat,
		  pmedium->hGlobal));
exitRtn:
    intrDebugOut((DEB_ITRACE,
		  "::GetData(%x)hres=%x\n",
		  this,
		  hres));
    return hres;
}



STDMETHODIMP NC(CDdeObject,CDataObjectImpl)::GetDataHere
    (LPFORMATETC pformatetcIn,
     LPSTGMEDIUM pmedium)
{
    intrDebugOut((DEB_ITRACE,
		  "CDdeObject::GetDataHere(%x,pformatetcIn=%x)\n",
		  this,
		  pformatetcIn));

    HRESULT hresult = NOERROR;
    STGMEDIUM medium;
    if (!(pformatetcIn->tymed & TYMED_HGLOBAL))
    {
	intrDebugOut((DEB_ITRACE,
		      "::GetDataHere(%x)DV_E_TYMED(%x)\n",
		      this,DV_E_TYMED));
        // Cannot GetDataHere for GDI objects
        hresult = DV_E_TYMED;
	goto exitRtn;
    }
    RetErr (GetData (pformatetcIn, &medium));
    if (medium.tymed != TYMED_HGLOBAL)
    {
	intrDebugOut((DEB_ITRACE,
		      "::GetDataHere(%x)medium.tymed != TYMED_HGLOBAL\n",
		      this));
        hresult = ResultFromScode (DV_E_TYMED);
        goto errRtn;
    }
    pmedium->tymed         = medium.tymed;
    pmedium->pUnkForRelease = medium.pUnkForRelease;
    ErrRtnH (wHandleCopy (pmedium->hGlobal, medium.hGlobal));

  errRtn:
    ReleaseStgMedium (&medium);

  exitRtn:
    intrDebugOut((DEB_ITRACE,
		  "CDdeObject::GetDataHere(%x) returning %x\n",
		  this,hresult));
    return hresult;
}



STDMETHODIMP NC(CDdeObject,CDataObjectImpl)::QueryGetData
    (LPFORMATETC pformatetcIn)
{
    HRESULT hr;
    intrDebugOut((DEB_ITRACE,
		  "%x _IN CDdeObject::QueryGetData(pformatetcIn=%x)\n",
		  this,
		  pformatetcIn));

    hr = wVerifyFormatEtc (pformatetcIn);

    if (hr != NOERROR)
    {
	goto exitRtn;
    }
    if (pformatetcIn->cfFormat == g_cfEmbeddedObject
            || pformatetcIn->cfFormat == g_cfEmbedSource
            || pformatetcIn->cfFormat == g_cfLinkSource
            || pformatetcIn->cfFormat == g_cfFileName
            || pformatetcIn->cfFormat == g_cfCustomLinkSource
            || pformatetcIn->cfFormat == g_cfObjectDescriptor
            || pformatetcIn->cfFormat == g_cfLinkSrcDescriptor)
    {
	hr = S_FALSE;
    }

    hr = m_pDdeObject->IsFormatAvailable (pformatetcIn);

exitRtn:
    intrDebugOut((DEB_ITRACE,
		  "%x _OUT CDdeObject::QueryGetData returning %x\n",
		  this,hr));
    return(hr);

}


STDMETHODIMP NC(CDdeObject,CDataObjectImpl)::SetData
    (LPFORMATETC    pformatetc,
     STGMEDIUM FAR* pmedium,
     BOOL           fRelease)
{
    HANDLE hDdePoke;
    HRESULT hresult;

    intrDebugOut((DEB_ITRACE,
		  "%x _IN CDdeObject::SetData(pformatetc=%x)\n",
		  this,
		  pformatetc));

    hresult = wVerifyFormatEtc (pformatetc);

    if (hresult != NOERROR)
    {
	goto exitRtn;
    }
    intrDebugOut((DEB_ITRACE,
		  "%x ::SetData(pformatetc->cfFormat=%x)\n",
		  this,
		  (ULONG)pformatetc->cfFormat));

    if (pformatetc->dwAspect & DVASPECT_ICON)
    {
	intrDebugOut((DEB_ITRACE,
		      "%x ::SetData dwAspect & DVASPECT_ICON\n",
		      this));
	hresult = DV_E_DVASPECT;
	goto exitRtn;
    }


    if (pformatetc->ptd != m_pDdeObject->m_ptd)
    {
        // If caller is setting with a different target device
        // (We assume a different pointer points to a different target device)

        if (NOERROR != m_pDdeObject->SetTargetDevice (pformatetc->ptd))
        {
	    intrDebugOut((DEB_IERROR,
			  "%x ::SetData server did not accept target device\n",
			  this));
	    hresult = DV_E_DVTARGETDEVICE;
	    goto exitRtn;
        }
    }

    if (hDdePoke = wPreparePokeBlock (pmedium->hGlobal,
                                      pformatetc->cfFormat,
                                      m_pDdeObject->m_aClass,
                                      m_pDdeObject->m_bOldSvr))
    {
        hresult = m_pDdeObject->Poke (m_pDdeObject->m_aItem, hDdePoke);
        if (fRelease)
            ReleaseStgMedium (pmedium);
        goto exitRtn;
    }
    else
    {
        hresult = E_OUTOFMEMORY;
    }
exitRtn:

    intrDebugOut((DEB_ITRACE,"%x _OUT ::SetData returns %x\n",this,hresult));
    return(hresult);

}





STDMETHODIMP NC(CDdeObject,CDataObjectImpl)::DAdvise
    (FORMATETC FAR*   pformatetc,
     DWORD            grfAdvf,
     IAdviseSink FAR* pAdvSink,
     DWORD FAR*       pdwConnection)
{
    HRESULT hresult;
    HRESULT hresLookup;
    FORMATETC formatetc;

    intrDebugOut((DEB_ITRACE,
		  "%x _IN CDdeObject::DAdvise(pformatetc=%x,grfAdvf=%x,pAdvSink=%x)\n",
		  this,
		  pformatetc,
		  grfAdvf,
		  pAdvSink));

    VDATEPTROUT (pdwConnection, DWORD);
    *pdwConnection = 0;

    wNormalize (pformatetc, &formatetc);

    hresult =wVerifyFormatEtc (&formatetc);

    if ( hresult  != NOERROR)
    {
	goto errRtn;
    }

    intrDebugOut((DEB_ITRACE,
		  "%x ::DAdvise pformatetc->cfFormat=%x\n",
		  this,
                  pformatetc->cfFormat));

    if (NotEqual (formatetc.ptd, m_pDdeObject->m_ptd))
    {
        if (NOERROR != m_pDdeObject->SetTargetDevice (formatetc.ptd))
	{
            hresult= DV_E_DVTARGETDEVICE;
	    goto errRtn;
	}
    }

    hresLookup = m_pDdeObject->m_ConnectionTable.Lookup (formatetc.cfFormat, NULL);
    if (hresLookup != NOERROR)
    {
        // We have not already done a DDE advise for this format

        Puts (" m_iAdvChange = "); Puti (m_pDdeObject->m_iAdvChange); Puts("\n");

        if (m_pDdeObject->m_ulObjType == OT_LINK)
        {
            ErrRtnH (m_pDdeObject->AdviseOn (formatetc.cfFormat, ON_CHANGE));
            ErrRtnH (m_pDdeObject->AdviseOn (formatetc.cfFormat, ON_SAVE));
        }
        else
        {
            ErrRtnH (m_pDdeObject->AdviseOn (formatetc.cfFormat, ON_SAVE));
            ErrRtnH (m_pDdeObject->AdviseOn (formatetc.cfFormat, ON_CLOSE));
        }
    }

    ErrZS (m_pDdeObject->m_pDataAdvHolder, E_OUTOFMEMORY);
    hresult = m_pDdeObject->m_pDataAdvHolder->Advise (this, pformatetc, grfAdvf,
                                                     pAdvSink, pdwConnection);

    m_pDdeObject->m_ConnectionTable.Add (*pdwConnection, formatetc.cfFormat,
                                             grfAdvf);

  errRtn:
    intrDebugOut((DEB_ITRACE,
		  "%x _OUT CDdeObject::DAdvise hresult=%x\n",
		  this,
		  hresult));
    return hresult;
}




STDMETHODIMP NC(CDdeObject,CDataObjectImpl)::DUnadvise
    (DWORD dwConnection)
{
    intrDebugOut((DEB_ITRACE,
		  "CDdeObject::DUnadvise(%x,dwConnection=%x)\n",
		  this,
		  dwConnection));

    CLIPFORMAT  cf;
    HRESULT     hres;
    DWORD       grfAdvf;

    // Remove connection from table.  Lookup the cf for this connection.
    if (m_pDdeObject->m_ConnectionTable.Subtract (dwConnection, &cf, &grfAdvf)
        == NOERROR)
    {
        // If there is not another connection that needs this format
        if (m_pDdeObject->m_ConnectionTable.Lookup (cf, NULL) != NOERROR)
        {
            // We did a DDE advise for this connection, so undo it.
            if (m_pDdeObject->m_ulObjType == OT_LINK)
            {
                if (NOERROR != (hres=m_pDdeObject->UnAdviseOn (cf, ON_CHANGE)))
                {
		    intrDebugOut((DEB_IWARN,
				  "::DUnadvise(%x,dwConnection=%x) ON_CHANGE failed\n",
				  this,
				  dwConnection));
                }
                if (NOERROR != (hres=m_pDdeObject->UnAdviseOn (cf, ON_SAVE)))
                {
		    intrDebugOut((DEB_IWARN,
				  "::DUnadvise(%x,dwConnection=%x) ON_SAVE failed\n",
				  this,
				  dwConnection));
                }
            }
            else
            {
                if (NOERROR != (hres=m_pDdeObject->UnAdviseOn (cf, ON_SAVE)))
                {
		    intrDebugOut((DEB_IWARN,
				  "::DUnadvise(%x,dwConnection=%x) ON_SAVE failed\n",
				  this,
				  dwConnection));
                }
                if (NOERROR != (hres=m_pDdeObject->UnAdviseOn (cf, ON_CLOSE)))
                {
		    intrDebugOut((DEB_IWARN,
				  "::DUnadvise(%x,dwConnection=%x) ON_CLOSE failed\n",
				  this,
				  dwConnection));
                }
            }
        }
    }

    // Delegate rest of the work to the DataAdviseHolder
    RetZS (m_pDdeObject->m_pDataAdvHolder, E_OUTOFMEMORY);
    return m_pDdeObject->m_pDataAdvHolder->Unadvise (dwConnection);
}

STDMETHODIMP NC(CDdeObject,CDataObjectImpl)::EnumDAdvise
    (THIS_ LPENUMSTATDATA FAR* ppenumAdvise)
{
    RetZS (m_pDdeObject->m_pDataAdvHolder, E_OUTOFMEMORY);
    return m_pDdeObject->m_pDataAdvHolder->EnumAdvise(ppenumAdvise);
}

STDMETHODIMP NC(CDdeObject,CDataObjectImpl)::EnumFormatEtc
    (DWORD dwDirection, LPENUMFORMATETC FAR* ppenumFormatEtc)
{
    return OleRegEnumFormatEtc (m_pDdeObject->m_clsid, dwDirection,
                                ppenumFormatEtc);
}




STDMETHODIMP NC(CDdeObject,CDataObjectImpl)::GetCanonicalFormatEtc
(LPFORMATETC pformatetc, LPFORMATETC pformatetcOut)
{
    VDATEPTROUT (pformatetcOut, FORMATETC);
    memcpy (pformatetcOut, pformatetc, sizeof (FORMATETC));
    return ReportResult(0, DATA_S_SAMEFORMATETC, 0, 0);
    // We must be very conservative and assume data will be different for
    // every formatetc
}



INTERNAL CDdeObject::RequestData
    (CLIPFORMAT cf)
{
    intrDebugOut((DEB_ITRACE,
		  "CDdeObject::RequestData(%x,cf=%x)\n",
		  this,cf));

    LPARAM lparam;
    RetZ (m_pDocChannel);
    intrAssert(wIsValidAtom(m_aItem));
    ATOM aItem = wDupAtom (m_aItem);
    intrAssert(wIsValidAtom(aItem));

    lparam = MAKE_DDE_LPARAM (WM_DDE_REQUEST,cf, aItem);

    HRESULT hr = SendMsgAndWaitForReply (m_pDocChannel,
					 AA_REQUEST,
					 WM_DDE_REQUEST,
					 lparam,
					 TRUE);
    if ( aItem && FAILED(hr) )
    {
	GlobalDeleteAtom (aItem);
    }
    return hr;
}


// special name
const char achSpecialName[] = "DISPLAY";

//
// Return a 1.0 target device for the screen
//

static INTERNAL DefaultTargetDevice (HANDLE FAR* ph)
{
    intrDebugOut((DEB_ITRACE,
		  "DefaultTargetDevice(ph=%x)\n",ph));

    VDATEPTROUT ((LPVOID) ph, HANDLE);
    LPOLETARGETDEVICE p1=NULL;
    *ph = GlobalAlloc (GMEM_DDESHARE | GMEM_MOVEABLE, sizeof (*p1) + 10);
    RetZS (*ph, E_OUTOFMEMORY);
    p1 = (LPOLETARGETDEVICE) GlobalLock (*ph);
    RetZS (p1, E_OUTOFMEMORY);
    p1->otdDeviceNameOffset = 8;
    p1->otdDriverNameOffset = 0;	// The driver name is at otdData
    p1->otdPortNameOffset   = 9;
    p1->otdExtDevmodeOffset = 0;
    p1->otdExtDevmodeSize   = 0;
    p1->otdEnvironmentOffset= 0;
    p1->otdEnvironmentSize  = 0;

    //
    // Note that memcpy is moving a constant string. Therefore, sizeof()
    // will include the NULL terminator
    //
    //
    memcpy((LPSTR)p1->otdData, achSpecialName,sizeof(achSpecialName));
    p1->otdData[8] = 0;			// NULL the otdDeviceName
    p1->otdData[9] = 0;			// NULL the PortNameOffset
    GlobalUnlock (*ph);
    return NOERROR;
}



//+---------------------------------------------------------------------------
//
//  Function:   Convert20TargetDevice
//
//  Synopsis:   Converts a 2.0 TargetDevice into a 1.0 OLETARGETDEVICE
//
//  Effects:	First converts the 2.0 UNICODE target device into ANSI,
//		then converts that into a 1.0 OLETARGETDEVICE. The astute
//		reader would say: Why not just 2.0 UNICODE to OLETARGETDEVICE?
//
//		Two reasons: time before we ship vs time needed elsewhere.
//
//		If you can spare some time, please change this to go
//		directly from one to the other.
//
//  Arguments:  [ptd] --
//		[phTD1] --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    5-03-94   kevinro   Created
//
//  Notes:
//
//  the NT version of the OLE 1.0 used UINT as the size of the
//  structures members. This was baaaad, since we really need them to be
//  a fixed size. I am currently in the works of changing the NT 1.0 header
//  file to reflect what we really need it to be, which is USHORT's
//
//
// We have a DVTARGETDEVICE, but we want a OLETARGETDEVICE, which looks like
//
// typedef struct _OLETARGETDEVICE {
//    USHORT otdDeviceNameOffset;
//    USHORT otdDriverNameOffset;
//    USHORT otdPortNameOffset;
//    USHORT otdExtDevmodeOffset;
//    USHORT otdExtDevmodeSize;
//    USHORT otdEnvironmentOffset;
//    USHORT otdEnvironmentSize;
//    BYTE otdData[1];
// } OLETARGETDEVICE;
//
// A couple things to note:
//
// 1) The Names in the OLETARGETDEVICE need to be Ansi
// 2) The Environment member doens't exist in the DVTARGETDEVICE, and will
//    be created in this conversion
// 3) The ExtDevmode also needs to be ANSI
//
//----------------------------------------------------------------------------
INTERNAL Convert20TargetDevice
    (const DVTARGETDEVICE FAR* ptd,     // in parm
    HANDLE FAR* phTD1)                  // out parm
{
    const size_t cbHeader = SIZEOF_DVTARGETDEVICE_HEADER;
    HRESULT hr;
    LPOLETARGETDEVICE ptd1 = NULL;
    size_t cbTD1;
    size_t cbDevmode;
    size_t cbOffset;
    LPDEVMODEA pdevmode;

    intrDebugOut((DEB_ITRACE,
		  "Convert20TargetDevice(ptd=%x)\n",ptd));

    VDATEPTROUT ((LPVOID) phTD1, HANDLE);
    *phTD1 = NULL;

    //
    // If no device specified, then return the default
    //

    if (NULL==ptd)
    {
        return DefaultTargetDevice (phTD1);
    }

    //
    // Compute information for doing conversion using routines in utils.cpp
    // The following structure will get the sizes
    //

    DVTDINFO dvtdInfo;

    hr = UtGetDvtd32Info(ptd,&dvtdInfo);

    if (hr != NOERROR)
    {
        return DV_E_DVTARGETDEVICE;
    }

    //
    // The conversion routines require us to allocate memory to pass in.
    //

    DVTARGETDEVICE *pdvtdAnsi = (DVTARGETDEVICE *) PrivMemAlloc(dvtdInfo.cbConvertSize);

    if (pdvtdAnsi == NULL)
    {
	return(E_OUTOFMEMORY);
    }

    //
    // Convert the UNICODE target device into an ANSI target device
    //

    hr = UtConvertDvtd32toDvtd16(ptd,&dvtdInfo,pdvtdAnsi);

    if (hr != NOERROR)
    {
	goto errRtn;
    }

    //
    // pdvtdAnsi now holds an ANSI version of the DVTARGETDEVICE. Turns
    // out the structure we really want is the DVTARGETDEVICE, plus a
    // couple of extra header bytes. Therefore, we can just do a block
    // copy of the DVTARGETDEVICE's data, and fix up our OLETARGETDEVICE
    // header to have the correct offsets in the data.
    //
    // offset of data block from beginning of 2.0 target device
    //
    cbOffset = offsetof (DVTARGETDEVICE, tdData);

    //
    // Calculate a pointer to the DEVMODEA
    //
    pdevmode = pdvtdAnsi->tdExtDevmodeOffset ?
                    (LPDEVMODEA)((LPBYTE)pdvtdAnsi + pdvtdAnsi->tdExtDevmodeOffset)
                    : NULL;

    //
    // Quick sanity check on the resulting pointer.
    //
    if (pdevmode && !IsValidReadPtrIn (pdevmode, sizeof(DEVMODEA)))
    {
	hr = DV_E_DVTARGETDEVICE;
	goto errRtn;
    }

    //
    // Calculate the size of the devmode part.
    //

    cbDevmode = (pdevmode ? pdevmode->dmSize + pdevmode->dmDriverExtra:0);

    //
    // Calculate the total size needed. The DVTARGETDEVICE header has 12 bytes,
    // and the OLETARGETDEVICE has 14 bytes. We also need to make an extra copy
    // of the cbDevmode structure to fill in the environment. Therefore, there is
    // an extra cbDevmode, and a sizeof(USHORT) added to the size. The size includes
    // the size of the DVTARGETHEADER
    //

    cbTD1 = (size_t) pdvtdAnsi->tdSize +
		     cbDevmode +	  // For extra Environment data
		     sizeof (USHORT); // for Environment Size field

    *phTD1 = GlobalAlloc (GMEM_DDESHARE | GMEM_MOVEABLE, cbTD1);
    if (NULL== *phTD1)
    {
        intrAssert (!"GlobalAlloc Failed");
	hr = E_OUTOFMEMORY;
	goto errRtn;
    }

    ptd1 = (LPOLETARGETDEVICE) GlobalLock (*phTD1);
    if (NULL== ptd1)
    {
        intrAssert (!"GlobalLock Failed");
	hr = E_OUTOFMEMORY;
	goto errRtn;
    }

    // Set x1 (1.0 offset) based on x2 (2.0 offset)
    //
    // Note that the OLETARGETDEVICE offsets are relative to the array of bytes,
    // where the DVTARGETDEVICE is relative to the start of the structure. Thats
    // why cbOffset is subtracted
    //

    #define ConvertOffset(x1, x2) (x1 = (USHORT) (x2 ? x2 - cbOffset : 0))

    //
    // Using the above macro, and assuming
    //

    ConvertOffset (ptd1->otdDeviceNameOffset, pdvtdAnsi->tdDeviceNameOffset);
    ConvertOffset (ptd1->otdDriverNameOffset, pdvtdAnsi->tdDriverNameOffset);
    ConvertOffset (ptd1->otdPortNameOffset, pdvtdAnsi->tdPortNameOffset);
    ConvertOffset (ptd1->otdExtDevmodeOffset, pdvtdAnsi->tdExtDevmodeOffset);
    ptd1->otdExtDevmodeSize = (USHORT) cbDevmode;

    //
    // I found this in the OLE 2 information on OLETARGETDEVICE:
    //
    // The otdDeviceNameOffset, otdDriverNameOffset, and otdPortNameOffset
    // members should be null-terminated.  In Windows 3.1, the ability to
    // connect multiple printers to one port has made the environment
    // obsolete.  The environment information retrieved by the
    // GetEnvironment function can occasionally be incorrect.  To ensure that the
    // OLETARGETDEVICE structure is initialized correctly, the application
    // should copy information from the DEVMODEA structure retrieved by a
    // call to the ExtDeviceMode function to the environment position of
    // the OLETARGETDEVICE structure.
    //
    //

    //
    // Adjust the environment offset to the end of the converted structure, and
    // set the size. the sizeof(USHORT) accounts for the addition of the
    // otdEnvironmentSize field. The offsetof accounts for the fact that the
    // OLETARGETDEVICE offsets are based from the otdData array.
    //
    ptd1->otdEnvironmentOffset = (USHORT) pdvtdAnsi->tdSize +
					  sizeof(USHORT) -
					  offsetof(OLETARGETDEVICE,otdData);

    ptd1->otdEnvironmentSize  = (USHORT) cbDevmode;

    // Copy data block
    if(!IsValidPtrOut (ptd1->otdData,  (size_t) pdvtdAnsi->tdSize - cbHeader))
    {
	hr = E_UNEXPECTED;
	goto errRtn;
    }
    memcpy (ptd1->otdData, pdvtdAnsi->tdData, (size_t) pdvtdAnsi->tdSize - cbHeader);

    if (cbDevmode != 0)
    {
        if(!IsValidPtrOut (ptd1->otdData, sizeof (DEVMODEA)))
	{
	    hr = E_UNEXPECTED;
	    goto errRtn;
	}

        // Copy 2.0 Devmode into 1.0 environment

        memcpy (ptd1->otdData + ptd1->otdEnvironmentOffset,
		pdvtdAnsi->tdData   + pdvtdAnsi->tdExtDevmodeOffset,
		cbDevmode);
    }

    hr = NOERROR;

errRtn:

    if (ptd1 != NULL)
    {
        GlobalUnlock(*phTD1);
    }

    if (pdvtdAnsi != NULL)
    {
	PrivMemFree(pdvtdAnsi);
    }
    intrDebugOut((DEB_ITRACE,
		  "Convert20TargetDevice(ptd=%x) returns %x\n",ptd,hr));
    return(hr);
}



static INTERNAL CopyTargetDevice
    (const DVTARGETDEVICE FAR* ptd,
    DVTARGETDEVICE FAR* FAR* pptd)
{
    intrDebugOut((DEB_ITRACE,
		  "CopyTargetDevice(ptd=%x)\n",ptd));

    if (*pptd)
    {
        delete *pptd; // delete old target device
    }
    if (NULL==ptd)
    {
        *pptd = NULL;
    }
    else
    {
        *pptd = (DVTARGETDEVICE FAR*) operator new ((size_t) (ptd->tdSize));
        if (NULL==*pptd)
        {
            return ReportResult(0, E_OUTOFMEMORY, 0, 0);
        }
        _fmemcpy (*pptd, ptd, (size_t) ptd->tdSize);
    }
    return NOERROR;
}



INTERNAL CDdeObject::SetTargetDevice
    (const DVTARGETDEVICE FAR* ptd)
{
    intrDebugOut((DEB_ITRACE,
		  "CDdeObject::SetTargetDevice(%x,ptd=%x)\n",
		  this,
		  ptd));

    HANDLE hTD1 = NULL;
    HANDLE hDdePoke=NULL;

    RetErr (Convert20TargetDevice (ptd, &hTD1));

    Assert (hTD1);
    Verify (hDdePoke = wPreparePokeBlock (hTD1, g_cfBinary, m_aClass, m_bOldSvr));
    if (hTD1)
    {
        GlobalFree (hTD1);
    }
    // Poke new target device to 1.0 server
    aStdTargetDevice = GlobalAddAtom (L"StdTargetDevice");
    intrAssert(wIsValidAtom(aStdTargetDevice));
    RetErr (Poke (aStdTargetDevice, hDdePoke));

    // Remember current target device
    RetErr (CopyTargetDevice (ptd, &m_ptd));
    // Flush the cache because it contains a picture for the wrong
    // target device.
    if (m_hPict)
        wFreeData (m_hPict, m_cfPict);
    m_cfPict = (CLIPFORMAT)0;
    m_hPict = NULL;

    return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\com\dde\client\ddecnvrt.cxx ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    ddecnvrt.cpp

Abstract:

    This module contains the code to read/write PBrush, MSDraw native data
    formats. This module also contains PBrush native format <->DIbFile stream,
    and MSDraw native format <-> placeable metafile stream conversion routines.

Author:

    Srini Koppolu (srinik)  06/29/1993

Revision History:

--*/

#ifndef _MAC


/************************   FILE FORMATS   **********************************


Normal Metafile (memory or disk based):

     ------------ ---------------
    | METAHEADER | Metafile bits |
     ------------ ---------------

Placeable Metafile:

     --------------------- -----------------
    | PLACEABLEMETAHEADER | Normal metafile |
     --------------------- -----------------

Memory Based DIB:

     ------------------ --------------- ----------
    | BITMAPINFOHEADER | RGBQUAD array | DIB bits |
     ------------------ --------------- ----------

DIB file format:

     ------------------ ------------------
    | BITMAPFILEHEADER | Memory based DIB |
     ------------------ ------------------

Ole10NativeStream Format:

     -------- ----------------------
    | dwSize | Object's Native data |
     -------- ----------------------

PBrush Native data format:

     -----------------
    | Dib File format |
     -----------------

MSDraw Native data format:

     --------------------- ------------- ------------- -----------------
    | mapping mode (WORD) | xExt (WORD) | yExt (WORD) | Normal metafile |
     --------------------- ------------- ------------- -----------------


*****************************************************************************/

#include <ole2int.h>

INTERNAL    UtGetHMFPICTFromMSDrawNativeStm
    (LPSTREAM pstm, DWORD dwSize, HANDLE FAR* lphdata)
{
    HRESULT     error;
    WORD        mfp[3]; // mm, xExt, yExt
    HMETAFILE   hMF = NULL;

    *lphdata = NULL;

    if (error = pstm->Read(mfp, sizeof(mfp), NULL))
        return error;

    dwSize -= sizeof(mfp);

    if (error = UtGetHMFFromMFStm(pstm, dwSize, FALSE, (void **)&hMF))
        return error;

    AssertSz(mfp[0] == MM_ANISOTROPIC, "invalid map mode in MsDraw native data");

    if (*lphdata = UtGetHMFPICT(hMF, TRUE, (int) mfp[1], (int) mfp[2]))
        return NOERROR;

    return ResultFromScode(E_OUTOFMEMORY);
}


INTERNAL UtPlaceableMFStmToMSDrawNativeStm
    (LPSTREAM pstmPMF, LPSTREAM pstmMSDraw)
{
    DWORD   dwSize; // size of metafile bits excluding the placeable MF header
    LONG    xExt;
    LONG    yExt;
    WORD    wBuf[5]; // dwSize(DWORD), mm(int), xExt(int), yExt(int)
    HRESULT error;

    if (error = UtGetSizeAndExtentsFromPlaceableMFStm(pstmPMF, &dwSize,
            &xExt, &yExt))
        return error;

    *((DWORD FAR*) wBuf) = dwSize + 3*sizeof(WORD);
    wBuf[2] = MM_ANISOTROPIC;
    wBuf[3] = (int) xExt;
    wBuf[4] = (int) yExt;

    if (error = pstmMSDraw->Write(wBuf, sizeof(wBuf), 0))
        return error;

    ULARGE_INTEGER ularge_int;
    ULISet32(ularge_int, dwSize);
    if ((error = pstmPMF->CopyTo(pstmMSDraw, ularge_int,
            NULL, NULL)) == NOERROR)
        StSetSize(pstmMSDraw);

    return error;

}


INTERNAL UtDIBFileStmToPBrushNativeStm
    (LPSTREAM pstmDIBFile, LPSTREAM pstmPBrush)
{
    BITMAPFILEHEADER bfh;
    HRESULT error;

    if (error = pstmDIBFile->Read(&bfh, sizeof(bfh), 0))
        return error;

    // seek to the begining of the stream
    LARGE_INTEGER large_int;
    LISet32( large_int, 0);
    if (error = pstmDIBFile->Seek(large_int, STREAM_SEEK_SET, 0))
        return error;

    if (error = pstmPBrush->Write(&(bfh.bfSize), sizeof(DWORD), 0))
        return error;

    ULARGE_INTEGER ularge_int;
    ULISet32(ularge_int, bfh.bfSize);

    if ((error = pstmDIBFile->CopyTo(pstmPBrush, ularge_int,
            NULL, NULL)) == NOERROR)
        StSetSize(pstmPBrush);

    return error;
}



INTERNAL UtContentsStmTo10NativeStm
    (LPSTORAGE pstg, REFCLSID rclsid, BOOL fDeleteSrcStm, UINT FAR* puiStatus)
{
    CLIPFORMAT  cf;
    LPOLESTR        lpszUserType = NULL;
    HRESULT     error;
    LPSTREAM    pstmSrc = NULL;
    LPSTREAM    pstmDst = NULL;

    *puiStatus = NULL;

    if (error = ReadFmtUserTypeStg(pstg, &cf, &lpszUserType))
        return error;


    if (! ((cf == CF_DIB  && rclsid == CLSID_PBrush)
            || (cf == CF_METAFILEPICT && rclsid == CLSID_MSDraw))) {
        error = ResultFromScode(DV_E_CLIPFORMAT);
        goto errRtn;
    }

    if (error = pstg->OpenStream(CONTENTS_STREAM, NULL,
                        (STGM_READ|STGM_SHARE_EXCLUSIVE),
                        0, &pstmSrc)) {
        *puiStatus |= CONVERT_NOSOURCE;

        // check whether OLE10_NATIVE_STREAM exists
        if (pstg->OpenStream(OLE10_NATIVE_STREAM, NULL,
                (STGM_READ|STGM_SHARE_EXCLUSIVE), 0, &pstmDst))
            *puiStatus |= CONVERT_NODESTINATION;
        else {
            pstmDst->Release();
            pstmDst = NULL;
        }

        goto errRtn;
    }

    if (error = OpenOrCreateStream(pstg, OLE10_NATIVE_STREAM, &pstmDst)) {
        *puiStatus |= CONVERT_NODESTINATION;
        goto errRtn;
    }

    if (cf == CF_METAFILEPICT)
        error = UtPlaceableMFStmToMSDrawNativeStm(pstmSrc, pstmDst);
    else
        error = UtDIBFileStmToPBrushNativeStm(pstmSrc, pstmDst);

errRtn:
    if (pstmDst)
        pstmDst->Release();

    if (pstmSrc)
        pstmSrc->Release();

    if (error == NOERROR) {
        LPOLESTR lpszProgId = NULL;
        ProgIDFromCLSID(rclsid, &lpszProgId);

        error = WriteFmtUserTypeStg(pstg,
                        RegisterClipboardFormat(lpszProgId),
                        lpszUserType);

        if (lpszProgId)
            delete lpszProgId;
    }

    if (error == NOERROR) {
        if (fDeleteSrcStm)
            pstg->DestroyElement(CONTENTS_STREAM);
    } else {
        pstg->DestroyElement(OLE10_NATIVE_STREAM);
    }

    if (lpszUserType)
        delete lpszUserType;

    return error;
}



INTERNAL Ut10NativeStmToContentsStm
    (LPSTORAGE pstg, REFCLSID rclsid, BOOL fDeleteSrcStm)
{
    extern CLIPFORMAT   cfPBrush;
    extern CLIPFORMAT   cfMSDraw;

    CLIPFORMAT  cfOld;
    CLIPFORMAT  cfNew;
    LPOLESTR        lpszUserType = NULL;
    HRESULT     error;
    LPSTREAM    pstmSrc = NULL;
    LPSTREAM    pstmDst = NULL;


    if (error = ReadFmtUserTypeStg(pstg, &cfOld, &lpszUserType))
        return error;

    if (rclsid == CLSID_StaticDib)
        cfNew = CF_DIB;
    else if (rclsid == CLSID_StaticMetafile)
        cfNew = CF_METAFILEPICT;
    else {
        AssertSz(FALSE, "Internal Error: this routine shouldn't have been called for this class");
        return ResultFromScode(E_FAIL);
    }

    if (cfOld == cfPBrush) {
        if (cfNew != CF_DIB) {
            error = ResultFromScode(DV_E_CLIPFORMAT);
            goto errRtn;
        }
    } else if (cfOld == cfMSDraw) {
        if (cfNew != CF_METAFILEPICT) {
            error = ResultFromScode(DV_E_CLIPFORMAT);
            goto errRtn;
        }
    } else {
        // Converted to static object from some class other than PBrush or
        // MSDraw. The data must be in a proper format in the CONTENTS
        // stream.
        return NOERROR;
    }

    if (error = pstg->OpenStream(OLE10_NATIVE_STREAM, NULL,
                        (STGM_READ|STGM_SHARE_EXCLUSIVE),
                        0, &pstmSrc))
        goto errRtn;

    if (error = OpenOrCreateStream(pstg, CONTENTS_STREAM, &pstmDst))
        goto errRtn;

    DWORD dwSize;
    if (error = pstmSrc->Read(&dwSize, sizeof(DWORD), NULL))
        goto errRtn;

    if (cfOld == cfMSDraw) {
        WORD mfp[3]; // mm, xExt, yExt

        if (error = pstmSrc->Read(mfp, sizeof(mfp), NULL))
            goto errRtn;

        dwSize -= sizeof(mfp);

        error = UtMFStmToPlaceableMFStm(pstmSrc, dwSize,
                    (LONG) mfp[1], (LONG) mfp[2], pstmDst);

    } else {
        // The PBrush native data format is DIB File format. So all we got to
        // do is CopyTo.

        ULARGE_INTEGER ularge_int;
        ULISet32(ularge_int, dwSize);
        if ((error = pstmSrc->CopyTo(pstmDst, ularge_int, NULL,
                NULL)) == NOERROR)
            StSetSize(pstmDst);
    }

errRtn:
    if (pstmDst)
        pstmDst->Release();

    if (pstmSrc)
        pstmSrc->Release();

    if (error == NOERROR) {
        error = WriteFmtUserTypeStg(pstg, cfNew, lpszUserType);

        if (fDeleteSrcStm)
            pstg->DestroyElement(OLE10_NATIVE_STREAM);

    } else {
        pstg->DestroyElement(CONTENTS_STREAM);
    }

    if (lpszUserType)
        delete lpszUserType;

    return error;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\com\dde\client\ddeioc.cxx ===
/*

copyright (c) 1992  Microsoft Corporation

Module Name:

    ddeLink.cpp

Abstract:

    This module contains the DdeObject::OleItemContainer methods
    and other Link-related code

Author:

    Jason Fuller    (jasonful)  19-October-1992

*/

#include "ddeproxy.h"
// #include <limits.h>
// #include <utils.h>
// #include <moniker.h>


ASSERTDATA



STDUNKIMPL_FORDERIVED (DdeObject, OleItemContainerImpl)


static INTERNAL_(void) wSkipDelimiter
    (LPOLESTR * psz)
{
    if (wcschr (L"!\"'*+,./:;<=>?@[\\]`|" , **psz))
        (*psz)++;
}



STDMETHODIMP NC(CDdeObject, COleItemContainerImpl)::ParseDisplayName
    (LPBC pbc,
    LPOLESTR lpszDisplayName,
    ULONG * pchEaten,
    LPMONIKER * ppmkOut)
{
    intrDebugOut((DEB_ITRACE,
		  "CDdeObject::ParseDisplayName(%x,lpsz=%ws)\n",
		  this,
		  lpszDisplayName));

    LPUNKNOWN pUnk = NULL;
    VDATEPTROUT(ppmkOut,LPMONIKER);
    *ppmkOut = NULL;
    VDATEIFACE(pbc);
    VDATEPTRIN(lpszDisplayName, char);
    VDATEPTROUT(pchEaten,ULONG);

    *pchEaten = lstrlenW(lpszDisplayName);
    wSkipDelimiter (&lpszDisplayName);
    // Validate the item name
    RetErr (GetObject (lpszDisplayName, BINDSPEED_INDEFINITE, pbc,
                        IID_IUnknown, (LPLPVOID) &pUnk));
    if (pUnk)
        pUnk->Release();
    return CreateItemMoniker (L"!", lpszDisplayName, ppmkOut);
}



STDMETHODIMP NC(CDdeObject, COleItemContainerImpl)::EnumObjects
    (DWORD grfFlags,
     LPENUMUNKNOWN FAR* ppenumUnk)

{
    // OLE 1.0 provides no way to enumerate all the items in a document.
    // This method is unlikely to be called since our implementation of
    // file and item monikers does not call it.
    Puts ("OleItemContainer::EnumObjects\r\n");
    if (ppenumUnk)
    {
        *ppenumUnk = NULL;
        return E_NOTIMPL;
    }

    return E_INVALIDARG;
}



STDMETHODIMP NC(CDdeObject, COleItemContainerImpl)::LockContainer
    (BOOL fLock)
{
    intrDebugOut((DEB_ITRACE,
		  "CDdeObject::LockContainer(%x,fLock=%x)\n",
		  this,
		  fLock));

    return NOERROR;
}



STDMETHODIMP NC(CDdeObject, COleItemContainerImpl)::GetObject
    (LPOLESTR lpszItem,
    DWORD  dwSpeedNeeded,
    LPBINDCTX pbc,
    REFIID riid,
    LPVOID * ppvObject)
{
    intrDebugOut((DEB_ITRACE,
		  "CDdeObject::GetObject(%x,szItem=%ws)\n",
		  this,
		  lpszItem));


    HRESULT hresult = NOERROR;
    VDATEPTROUT (ppvObject, LPVOID);
    *ppvObject=NULL;
    LPUNKNOWN pUnk = NULL;       //  These refer to the
    CDdeObject FAR* pdde = NULL; //  same object

    RetZS (pUnk =CDdeObject::Create (NULL,m_pDdeObject->m_clsid,OT_LINK,
                     m_pDdeObject->m_aTopic,lpszItem,&pdde),
                     E_OUTOFMEMORY);

    // For handling invisible updates--propagate information from document
    // to item.
    pdde->DeclareVisibility (m_pDdeObject->m_fVisible);
    pdde->m_fDidLaunchApp = m_pDdeObject->m_fDidLaunchApp;
    pdde->m_fDidStdOpenDoc   = m_pDdeObject->m_fDidStdOpenDoc;

    intrAssert(wIsValidAtom(pdde->m_aItem));
    LPOLESTR pszAtomName = wAtomName(pdde->m_aItem);

    ErrZ (pszAtomName && 0==lstrcmpW(lpszItem, pszAtomName));

    // OPTIMIZATION: Could use a mini Running Object Table to map lpszItem to
    // LPUNKNOWN and avoiding the Connect() and DDE_REQUEST.

    // Open a DocChannel
    ErrRtnH (pdde->m_ProxyMgr.Connect (IID_NULL, CLSID_NULL));

    // Request Native data in order to see if the item name is valid
    Assert (pdde->m_pDocChannel);
    LPARAM lp;
    lp=MAKE_DDE_LPARAM (WM_DDE_REQUEST,g_cfNative, wDupAtom(pdde->m_aItem));
    hresult = pdde->SendMsgAndWaitForReply (pdde->m_pDocChannel,
    					    AA_REQUESTAVAILABLE,
			                    WM_DDE_REQUEST,
                       			    lp,
                       			    TRUE);
    if ( FAILED( hresult ) )
    {
        // Try metafile.  Excel can't render large metafiles
        // but it can render native.
        lp=MAKE_DDE_LPARAM (WM_DDE_REQUEST,CF_METAFILEPICT, wDupAtom(pdde->m_aItem));
        hresult = pdde->SendMsgAndWaitForReply (pdde->m_pDocChannel,
						AA_REQUESTAVAILABLE,
                                    		WM_DDE_REQUEST,
                                    		lp,
                                    		TRUE);
        if ( FAILED( hresult ) )
        {
            Assert (pdde->m_refs==1);
            hresult = ResultFromScode (MK_E_NOOBJECT);
            goto errRtn;
        }
    }

    // Item name is valid
    hresult = pdde->m_pUnkOuter->QueryInterface (riid, (LPLPVOID) ppvObject);
    if (NOERROR==hresult)
    {
        m_pDdeObject->m_fDidGetObject = TRUE;
    }
  errRtn:
    if (pUnk)
        pUnk->Release();
    return hresult;
}



STDMETHODIMP NC(CDdeObject, COleItemContainerImpl)::GetObjectStorage
    (LPOLESTR lpszItem,
    LPBINDCTX ptc,
    REFIID riid,
    LPVOID * ppvStorage)
{
    intrDebugOut((DEB_ITRACE,
		  "CDdeObject::GetObjectStorage(%x,szItem=%ws)\n",
		  this,
		  lpszItem));
    return MK_E_NOSTORAGE;
}



STDMETHODIMP NC(CDdeObject, COleItemContainerImpl)::IsRunning
    (LPOLESTR szItem)
{
    intrDebugOut((DEB_ITRACE,
		  "CDdeObject::IsRunning(%x,szItem=%ws)\n",
		  this,
		  szItem));

    // By definition, all items are running
    return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\com\dde\client\ddemnker.cxx ===
/*

copyright (c) 1992  Microsoft Corporation

Module Name:

    ddeLink.cpp

Abstract:

    This module implements:
    DdeBindToObject
    DdeIsRunning

Author:

    Jason Fuller    (jasonful)  19-October-1992

*/
#include "ddeproxy.h"
#include "strsafe.h"

INTERNAL DdeBindToObject
    (LPCOLESTR  szFileIn,
    REFCLSID clsid,
    BOOL     fPackageLink,
    REFIID   iid,
    LPLPVOID ppv)
{
    intrDebugOut((DEB_ITRACE,
		  "DdeBindToObject szFileIn(%ws) fPackageLink(%x)\n",
		  szFileIn,
		  fPackageLink));


    LPUNKNOWN punk;
    *ppv = NULL;
    CDdeObject FAR* pdde=NULL;
    HRESULT hresult = E_UNEXPECTED;
    BOOL fSysConnection = FALSE;
    WCHAR wszTmpFile [MAX_STR+5];

    COleTls Tls;
    if( Tls->dwFlags & OLETLS_DISABLE_OLE1DDE )
    {
        // If DDE use is disabled we shouldn't have gotten here.
        //
        Assert(!"Executing DdeBindToObject when DDE is disabled");
        hresult = CO_E_OLE1DDE_DISABLED;
        goto exitRtn;
    }

    //
    // This protocol doesn't handle the fact that there are two names for
    // every file. This is a bit of a problem. So, we are going to choose
    // the short name as the one to look for. This means that DDE objects
    // using the long filename will not work very well.
    //
    WCHAR szFile[MAX_PATH];
    szFile[0] = L'\0';
    if ((lstrlenW(szFileIn) == 0) || (GetShortPathName(szFileIn,szFile,MAX_PATH) == 0))
    {
	//
	// Unable to determine a short path for this object. Use whatever we were
	// handed.
	//
	intrDebugOut((DEB_ITRACE,"No conversion for short path. Copy szFileIn\n"));
	StringCbCopyW(szFile, sizeof(szFile), szFileIn);
    }
    intrDebugOut((DEB_ITRACE,"Short file szFile(%ws)\n",szFile));

    RetZS (punk=CDdeObject::Create (NULL,clsid,OT_LINK,wGlobalAddAtom(szFile),
                    NULL,&pdde),E_OUTOFMEMORY);
    RetZ (pdde);

    // Document already running?

    if (NOERROR != (hresult = pdde->DocumentLevelConnect (NULL) ))
    {
        if (GetScode (hresult) != S_FALSE)
	{
	    intrDebugOut((DEB_ITRACE,
			  "DdeBindToObject szFile(%ws) DLC returns %x \n",
			  szFile,hresult));
	    goto exitRtn;
	}


        // If not already running, try to make a sys level connection

        if (!pdde->m_pSysChannel) {
	    if (!pdde->AllocDdeChannel (&pdde->m_pSysChannel, TRUE))
            {
                intrAssert( !"Out of memory");
		hresult = E_OUTOFMEMORY;
		goto exitRtn;
            }
        }

        hresult = ReportResult (0, E_UNEXPECTED, 0, 0);

        if (fPackageLink) {
            StringCbCopyW(wszTmpFile, sizeof(wszTmpFile), szFile);
            StringCbCatW(wszTmpFile, sizeof(wszTmpFile), L"/Link");
            pdde->SetTopic (wGlobalAddAtom(wszTmpFile));
        }

        if (pdde->InitSysConv())
        {
            fSysConnection = TRUE;

            // Try to make the server open the document
            ErrRtnH (pdde->PostSysCommand (pdde->m_pSysChannel, (LPSTR)&achStdOpenDocument,FALSE));
            pdde->m_fDidStdOpenDoc = TRUE;

        }
        else
        {
            // launch the server
	    if (!pdde->LaunchApp())
	    {
		hresult = CO_E_APPNOTFOUND;
		goto errRtn;
	    }
        }

        if (fPackageLink)
            pdde->SetTopic (wGlobalAddAtom(szFile));

        // Connect to document
        hresult = pdde->m_ProxyMgr.Connect (IID_NULL, CLSID_NULL);
        if (hresult != NOERROR)
        {
            // Excel does not register its document in time if it loads
            // startup macros.  So we force it to open the document.
            if (pdde->InitSysConv())
            {
                fSysConnection = TRUE;
                // Try to make the server open the document.
                ErrRtnH (pdde->PostSysCommand (pdde->m_pSysChannel,
				               (LPSTR)&achStdOpenDocument,
					       FALSE));
                pdde->m_fDidStdOpenDoc = TRUE;
            }
            else
            {
                ErrRtnH (ResultFromScode (CO_E_APPDIDNTREG));
            }
            // Try connecting to document again.  Should succeed.
            hresult = pdde->m_ProxyMgr.Connect (IID_NULL, CLSID_NULL);
        }
    }
    else
    {
        // Already running, so assume visible
        pdde->DeclareVisibility (TRUE);
    }

errRtn:
    if (pdde->m_pSysChannel) {
        if (fSysConnection)
            pdde->TermConv (pdde->m_pSysChannel);
        else
            pdde->DeleteChannel (pdde->m_pSysChannel);
    }

    if (hresult == NOERROR) {
        hresult = punk->QueryInterface (iid, ppv);
    }
    pdde->m_pUnkOuter->Release();
    if (hresult!=NOERROR)
    {
        Warn ("DdeBindToObject failed");
    }

exitRtn:
    intrDebugOut((DEB_ITRACE,
		  "DdeBindToObject szFile(%ws) returns %x \n",
		  szFile,hresult));

    return hresult;
}


//
// This won't work in a multi-threaded world. But this is not
// a danger to DDE since it is very single threaded.
//
static LPOLESTR szOriginalUNCName;
static WCHAR cOriginalDrive;

static INTERNAL InitializeIterator
    (LPCOLESTR wszFile)
{
    WCHAR wszDrive[] = L"A:\\";

    if ((wszFile == NULL) || (wszFile[1] != ':'))
    {
        return(S_FALSE);
    }

    wszDrive[0] = (WCHAR)CharUpperW((LPWSTR)wszFile[0]);

    if (GetDriveType(wszDrive) == DRIVE_REMOTE)
    {

        DWORD cb = MAX_STR;
        wszDrive[2] = '\0';
        if (NULL==szOriginalUNCName)
        {
        szOriginalUNCName = new WCHAR [MAX_STR];
        }


	if (WN_SUCCESS == WNetGetConnection (wszDrive, szOriginalUNCName, &cb))
        {
        cOriginalDrive = (WCHAR)CharUpperW((LPWSTR)wszFile[0]);
        return NOERROR;
        }
    }
    // szFile is not a network file
    return ReportResult (0, S_FALSE, 0, 0);
}



// NextEquivalentNetDrive
//
// Change the drive letter of szFile to the next (modulo 'Z') drive letter
// that is connected to the same net drive
// Return S_FALSE when there are no more equivalent drives
//
// NOTE NOTE NOTE
//
// This routine is playing fast and furious with the relationship between
// the first 128 Unicode characters and the ASCII character set.
//
static INTERNAL NextEquivalentNetDrive
    (LPOLESTR szFile)
{
    #define incr(c) (c=='Z' ? c='A' : ++c)
    WCHAR wszDrive[3]= L"A:";
    Assert (szFile && szFile[1]==':');

    char cDrive = (char)CharUpperA((LPSTR)szFile[0]);

    while (cOriginalDrive != incr(cDrive))
    {

        DWORD cb = MAX_PATH;
        WCHAR szUNCName [MAX_PATH];
        wszDrive[0] = cDrive;

        Assert (cDrive >= 'A' && cDrive <= 'Z');
        Assert (szOriginalUNCName);

	if(cDrive >= 'A' && cDrive <= 'Z' && szOriginalUNCName)
	{
		if (WN_SUCCESS == WNetGetConnection (wszDrive,szUNCName, &cb) &&
        	(0 == lstrcmpW (szUNCName, szOriginalUNCName)))
	        {
        	    szFile[0] = cDrive;
	            return NOERROR;
	        }
	}
    }
    // We've gone through all the drives
    return ReportResult (0, S_FALSE, 0, 0);
}



// Dde_IsRunning
//
// Attempt to open a document-level conversation using the
// filename as a topic.  If the conversation is established we
// know the file is running and terminate the conversation.
// Otherwise it is not running.
//
INTERNAL DdeIsRunning
    (CLSID clsid,
    LPCOLESTR szFileIn,
    LPBC pbc,
    LPMONIKER pmkToLeft,
    LPMONIKER pmkNewlyRunning)
{
    intrDebugOut((DEB_ITRACE,
		  "DdeIsRunning szFileIn(%ws)\n",szFileIn));

    ATOM aTopic;
    CDdeObject FAR* pdde=NULL;
    HRESULT hres = ReportResult(0, S_FALSE, 0, 0);

    if (NULL==szFileIn || '\0'==szFileIn[0])
    {
        // A NULL filename is invalid for our purposes.
        // But if we did a DDE_INITIATE, NULL would mean "any topic",
        // and if we were called by RunningMoniker() with CLSID_NULL,
        // then we would be INITIATEing on "any app, any topic" and
        // SHELL (if not others) would respond.
	intrDebugOut((DEB_ITRACE,
		      "DdeIsRunning NULL szFileIn\n"));

        hres = S_FALSE;
	goto exitRtn;
    }
    //
    // This protocol doesn't handle the fact that there are two names for
    // every file. This is a bit of a problem. So, we are going to choose
    // the short name as the one to look for. This means that DDE objects
    // using the long filename will not work very well.
    //
    WCHAR szFile[MAX_PATH];
    szFile[0] = L'\0';
    if ((lstrlenW(szFileIn) == 0) || (GetShortPathName(szFileIn,szFile,MAX_PATH) == 0))
    {
	//
	// Unable to determine a short path for this object. Use whatever we were
	// handed.
	//
	intrDebugOut((DEB_ITRACE,"No conversion for short path. Copy szFileIn\n"));
	StringCbCopyW(szFile, sizeof(szFile), szFileIn);
    }
    intrDebugOut((DEB_ITRACE,"Short file szFile(%ws)\n",szFile));

    aTopic = wGlobalAddAtom (szFile);
    intrAssert(wIsValidAtom(aTopic));

    ErrZ (CDdeObject::Create (NULL, clsid, OT_LINK, aTopic, NULL, &pdde));

    if (NOERROR == pdde->DocumentLevelConnect (pbc))
    {
        // It is running!
        // Immediately terminate conversation.  We just wanted to know
        // if it was running.
        hres = NOERROR;
    }
    else
    {
        // Not running
        hres = ReportResult(0, S_FALSE, 0, 0);
    }

  errRtn:

    if (aTopic)
    {
        intrAssert(wIsValidAtom(aTopic));
        GlobalDeleteAtom (aTopic);
    }
    if (pdde)
    {
        Assert (pdde->m_refs==1);
        pdde->m_pUnkOuter->Release();
    }

exitRtn:
    intrDebugOut((DEB_ITRACE,
		  "DdeIsRunning szFile(%ws) returns %x\n",szFile,hres));
    return hres;
}


#if 0
INTERNAL DdeIsRunning
    (CLSID clsid,
    LPCSTR cszFile,
    LPBC pbc,
    LPMONIKER pmkToLeft,
    LPMONIKER pmkNewlyRunning)
{
    HRESULT hresult = NOERROR;
    LPSTR szFile = NULL;

    // Normal case
    if (NOERROR == Dde_IsRunning (clsid, cszFile, pbc, pmkToLeft,
                                    pmkNewlyRunning))
    {
        return NOERROR;
    }

    if (cszFile[0]=='\\' && cszFile[1]=='\\')
    {
        RetErr (SzFixNet (pbc, (LPSTR)cszFile, &szFile));
        // Try with a drive letter instead of a UNC name
        if (NOERROR==Dde_IsRunning (clsid, szFile, pbc, pmkToLeft,
                                    pmkNewlyRunning))
        {
            hresult = NOERROR;
            goto errRtn;
        }
    }
    else
    {
        szFile = UtDupString (cszFile);  // so it can be deleted
    }

    // If failure, see if the file is running under a different net
    // drive letter that is mapped to the same drive.

    if (InitializeIterator (szFile) != NOERROR)
    {
        // file is probably not on a network drive
        hresult = ResultFromScode (S_FALSE);
        goto errRtn;
    }

    while (NOERROR==NextEquivalentNetDrive (szFile))
    {
        if (NOERROR == Dde_IsRunning (clsid, szFile, pbc, pmkToLeft,
                                    pmkNewlyRunning))
        {
            hresult = NOERROR;
            goto errRtn;
        }
    }
    // not running
    hresult = ResultFromScode (S_FALSE);

  errRtn:
    delete szFile;
    return hresult;
}
#endif



// CDdeObject::DocumentLevelConnect
//
// Try to connect to document (m_aTopic) even if the document is running
// under a different drive letter that is mapped to the same network drive.
//
INTERNAL CDdeObject::DocumentLevelConnect
    (LPBINDCTX pbc)
{
    ATOM aOriginal;
    ATOM aTopic;

    intrDebugOut((DEB_ITRACE,
		  "CDdeObject::DocumentLevelConnect(%x)\n",this));
    HRESULT hresult = NOERROR;

    // Normal case
    if (NOERROR==m_ProxyMgr.Connect (IID_NULL, CLSID_NULL))
    {
	goto exitRtn;
    }


    WCHAR szFile[MAX_STR];
    WCHAR szUNCFile[MAX_STR];

    Assert (wIsValidAtom (m_aTopic));
    if (GlobalGetAtomName (m_aTopic, szFile, MAX_STR) == 0)
    {
	hresult = E_UNEXPECTED;
	goto exitRtn;
    }
    aOriginal = wDupAtom (m_aTopic);
    intrAssert(wIsValidAtom(aOriginal));

    intrDebugOut((DEB_ITRACE,
		  "::DocumentLevelConnect(szFile=%ws)\n",this,szFile));
    if (NOERROR != InitializeIterator (szFile))
    {
        // szFile probably not a network file
        hresult = ResultFromScode (S_FALSE);
        goto errRtn;
    }

    while (NOERROR == NextEquivalentNetDrive (szFile))
    {
        SetTopic (aTopic = wGlobalAddAtom (szFile));
        if (NOERROR==m_ProxyMgr.Connect (IID_NULL, CLSID_NULL))
        {
            // Inform client of new drive letter
            ChangeTopic (wAtomNameA(aTopic));
            hresult = NOERROR;
            goto errRtn;
        }
        else
        {
            SetTopic ((ATOM)0);
        }
    }

    // Try with full UNC name
    StringCbCopyW(szUNCFile, sizeof(szUNCFile), szOriginalUNCName);
    StringCbCatW(szUNCFile, sizeof(szUNCFile), szFile+2);  // skip X:
    SetTopic (aTopic = wGlobalAddAtom (szUNCFile));
    if (NOERROR==m_ProxyMgr.Connect (IID_NULL, CLSID_NULL))
    {
        // Inform client of new name
        ChangeTopic (wAtomNameA(aTopic));
        hresult = NOERROR;
        goto errRtn;
    }
    else
    {
        SetTopic ((ATOM)0);
    }

    // Not running
    hresult = S_FALSE;

errRtn:
    if (NOERROR != hresult)
        SetTopic (aOriginal);
    delete szOriginalUNCName;
    szOriginalUNCName = NULL;

exitRtn:
    intrDebugOut((DEB_ITRACE,
		  "CDdeObject::DocumentLevelConnect(%x) returns %x\n",
		  this,hresult));

    return hresult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\com\dde\client\ddeoo.cxx ===
/*
ddeoo.cpp
DDE Ole Object

copyright (c) 1992  Microsoft Corporation

Module Name:

    ddeoo.cpp

Abstract:

    This module contains the methods for DdeObject::OleObject

Author:

    Jason Fuller    (jasonful)  24-July-1992

*/

#include "ddeproxy.h"
#include "strsafe.h"
#include <limits.h>

ASSERTDATA

//
// OleObject methods
//

STDUNKIMPL_FORDERIVED(DdeObject, OleObjectImpl)



STDMETHODIMP NC(CDdeObject,COleObjectImpl)::SetClientSite
    (IOleClientSite FAR* pClientSite)
{
    intrDebugOut((DEB_ITRACE,
          "CDdeObject::SetClientSite(%x,pClientSite=%x)\n",
          this,
          pClientSite));

    ChkD (m_pDdeObject);

    if (m_pDdeObject->m_pOleClientSite)
        m_pDdeObject->m_pOleClientSite->Release();

    // we've decided to keep the pointer that's been passed to us. So we
    // must AddRef()
    if (m_pDdeObject->m_pOleClientSite = pClientSite)
        pClientSite->AddRef();

    // this pointer need not be sent to the server, because we will always
    // send our &m_MyDataSite as the client site
    return NOERROR;
}



STDMETHODIMP NC(CDdeObject,COleObjectImpl)::GetClientSite
    (IOleClientSite FAR* FAR* ppClientSite)
{
    intrDebugOut((DEB_ITRACE,
          "CDdeObject::GetClientSite(%x)\n",
          this));

    ChkD (m_pDdeObject);
    // we've been asked to give the pointer so we should AddRef()
    if (*ppClientSite = m_pDdeObject->m_pOleClientSite)
        m_pDdeObject->m_pOleClientSite->AddRef();
    return NOERROR;
}



STDMETHODIMP NC(CDdeObject,COleObjectImpl)::EnumVerbs
    (IEnumOLEVERB FAR* FAR* ppenumOleVerb)
{
    intrDebugOut((DEB_ITRACE,
          "CDdeObject::EnumVerbs(%x)\n",
          this));

    ChkD (m_pDdeObject);
    return ReportResult(0, OLE_S_USEREG, 0, 0);
}


STDMETHODIMP NC(CDdeObject,COleObjectImpl)::Update
( void )
{
    HRESULT hr;

    intrDebugOut((DEB_ITRACE,
          "CDdeObject::Update(%x)\n",
          this));

    ChkD (m_pDdeObject);

    hr = m_pDdeObject->Update(TRUE);
    if (hr == NOERROR)
    {
        hr = m_pDdeObject->Save(m_pDdeObject->m_pstg);
    }

    return hr;
}


STDMETHODIMP NC(CDdeObject,COleObjectImpl)::IsUpToDate
( void )
{
    intrDebugOut((DEB_ITRACE,
          "CDdeObject::IsUpToDate(%x)\n",
          this));

    ChkD (m_pDdeObject);
    // There is no way to know if a 1.0 server has edited its embedded
    // object, so we assume it has, to be on the safe side.
    return ResultFromScode (m_pDdeObject->m_ulObjType==OT_EMBEDDED
                            ? S_FALSE : S_OK);
}


STDMETHODIMP NC(CDdeObject,COleObjectImpl)::GetUserClassID
    (CLSID FAR* pClsid)
{
    intrDebugOut((DEB_ITRACE,
          "CDdeObject::GetUserClassID(%x)\n",
          this));

    *pClsid = m_pDdeObject->m_clsid;
    return NOERROR;
}

STDMETHODIMP NC(CDdeObject,COleObjectImpl)::GetUserType
    (DWORD dwFormOfType,
    LPOLESTR * pszUserType)
{
    intrDebugOut((DEB_ITRACE,
          "CDdeObject::GetUserType(%x)\n",
          this));

    return ReportResult (0, OLE_S_USEREG, 0, 0);
}


STDMETHODIMP NC(CDdeObject,COleObjectImpl)::SetExtent
( DWORD dwAspect, LPSIZEL lpsizel)
{
    intrDebugOut((DEB_ITRACE,
          "CDdeObject::SetExtent(%x)\n",
          this));

    HANDLE        hDdePoke = NULL;
    LPRECT16      lprc;

    ChkD (m_pDdeObject);
    Puts ("OleObject::SetExtent\n");
    if (!(dwAspect                              // at least one bit
          && !(dwAspect & (dwAspect-1))         // exactly one bit
          && (dwAspect & DVASPECT_CONTENT)))    // a bit we support
    {
        return ResultFromScode (DV_E_DVASPECT);
    }

#ifdef OLD
    m_pDdeObject->m_cxContentExtent = lpsizel->cx;
    m_pDdeObject->m_cyContentExtent = lpsizel->cy;
#endif

    if (!m_pDdeObject->m_pDocChannel)
    {
            return OLE_E_NOTRUNNING;
    }

    lprc = (LPRECT16) wAllocDdePokeBlock (sizeof(RECT16), g_cfBinary, &hDdePoke);

    if(lprc)
    {
        lprc->left = lprc->right = (SHORT) min(INT_MAX,lpsizel->cx);
        lprc->top  = lprc->bottom= (SHORT) min(INT_MAX,lpsizel->cy);
    }

    aStdDocDimensions = GlobalAddAtom (OLESTR("StdDocDimensions"));
    intrAssert(wIsValidAtom(aStdDocDimensions));

    if(hDdePoke)
        GlobalUnlock (hDdePoke);

    return m_pDdeObject->Poke(aStdDocDimensions, hDdePoke);
}


STDMETHODIMP NC(CDdeObject,COleObjectImpl)::GetExtent
( DWORD dwAspect, LPSIZEL lpsizel)
{
    intrDebugOut((DEB_ITRACE,
          "CDdeObject::GetExtent(%x)\n",
          this));

    ChkD (m_pDdeObject);


#ifdef OLD
    VDATEPTROUT (lpsizel, SIZEL);
    if (!(dwAspect                              // at least one bit
          && !(dwAspect & (dwAspect-1))         // exactly one bit
          && !(dwAspect & (DVASPECT_CONTENT | DVASPECT_ICON)))) // a bit we support
    {
        return ResultFromScode (DV_E_DVASPECT);
    }

    if (dwAspect & DVASPECT_CONTENT)
    {
        lpsizel->cx = m_pDdeObject->m_cxContentExtent;
        lpsizel->cy = m_pDdeObject->m_cyContentExtent;
    }

    return NOERROR;
#endif
    return ResultFromScode(E_NOTIMPL);

}

//+---------------------------------------------------------------------------
//
//  Method:     CDdeObject::DoVerb
//
//  Synopsis:   Send the server a message asking it to do a verb.
//
//  Effects:    OLE1.0 servers only know how to do a couple of
//      verbs. Specifically, it will respond to PRIMARY,
//      HIDE, OPEN, and SHOW. All others return error
//
//
//  Arguments:  [iVerb] -- Verb number
//      [lpmsg] -- Window message (ignored)
//      [pActiveSite] -- ActiveSite (ignored)
//      [lindex] -- Index (ignored)
//      [hwndParent] -- (ignored)
//      [lprcPosRect] -- (ignored)
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:
//
//  History:    5-12-94   kevinro   Created
//
//  Notes:
//
//  ANSI ALERT!
//
//  The server is going to accept a command string from us. This string
//  needs to be done in ANSI, since we are going to pass it to old
//  servers. Therefore, the following code generates an ANSI string
//  The following are the supported verb strings
//
//  [StdShowItem("aItem",FALSE)]
//  [StdDoVerbItem("aItem",verb,FALSE,FALSE)]
//
//----------------------------------------------------------------------------
STDMETHODIMP NC(CDdeObject,COleObjectImpl)::DoVerb
    (LONG iVerb, LPMSG lpmsg, LPOLECLIENTSITE pActiveSite,
     LONG lindex, HWND hwndParent, const RECT FAR* lprcPosRect)
{
    WORD    len, len2 = 0;
    UINT     cch;
    ULONG     size;
    LPSTR   lpdata = NULL;
    LPSTR   lpdataStart = NULL;
    HANDLE  hdata = NULL;
    BOOL    bShow;
    HRESULT hresult;

    ChkD (m_pDdeObject);

    intrDebugOut((DEB_ITRACE,
          "CDdeObject::DoVerb(%x,iVerb=%x,lindex=%x)\n",
          this,iVerb,lindex));

    if (iVerb < OLEIVERB_HIDE)
    {
    intrDebugOut((DEB_ITRACE,
              "CDdeObject::DoVerb(%x)Returning invalid verb\n",
              this));
    return OLEOBJ_E_INVALIDVERB;
    }


    if (iVerb == OLEIVERB_HIDE)
    {
    intrDebugOut((DEB_ITRACE,"::DoVerb(%x) OLEIVERB_HIDE\n",this));

        if (m_pDdeObject->m_fVisible || OT_LINK==m_pDdeObject->m_ulObjType)
    {
        intrDebugOut((DEB_ITRACE,
              "::DoVerb(%x) CANNOT_DOVERB_NOW\n",this));
            return OLEOBJ_S_CANNOT_DOVERB_NOW;
    }

    intrDebugOut((DEB_ITRACE,"::DoVerb(%x) returns NOERROR\n",this));
    return NOERROR;
    }

    //
    // Calculate the number of bytes needed to pass the
    // execute command to the server.
    //
    if (bShow = (iVerb == OLEIVERB_SHOW
                 || iVerb == OLEIVERB_OPEN
                 || m_pDdeObject->m_bOldSvr))
    {
    //
        // [StdShowItem("aItem",FALSE)]
    //

        len = (WORD) (23 + wAtomLenA (m_pDdeObject->m_aItem) + 1);
    }
    else
    {
        // [StdDoVerbItem("aItem",verb,FALSE,FALSE)]
        len = (WORD) (32 + 10 /* for verb */ + wAtomLenA (m_pDdeObject->m_aItem) + 1);
    }

    if (!(hdata = GlobalAlloc (GMEM_DDESHARE, size = len)))
    {
    intrDebugOut((DEB_ITRACE,
              "::DoVerb(%x) cannot alloc %x bytes\n",
              this,size));
        return ReportResult(0, E_OUTOFMEMORY, 0, 0);
    }

    if (!(lpdata = (LPSTR)GlobalLock (hdata)))
    {
    intrDebugOut((DEB_ITRACE,
              "::DoVerb(%x) cannot lock\n",
              this));
        GlobalFree (hdata);
        return ReportResult(0, E_OUTOFMEMORY, 0, 0);
    }

    lpdataStart = lpdata;

    StringCbCopyA(lpdata, size, bShow ? "[StdShowItem(\"" : "[StdDoVerbItem(\"");
    len = (WORD)strlen (lpdata);
    lpdata += len;

    // For links
    if (m_pDdeObject->m_aItem)
    {
        len2 = (WORD)GlobalGetAtomNameA (m_pDdeObject->m_aItem, lpdata, size - len);
    }

    if (size - len - len2 <= 1)
    {
        hresult = E_OUTOFMEMORY;
        goto fail;
    }
    else 
    {
        lpdata += len2;
        len2 = (WORD)(size - len - len2);
    }
        
    if (!bShow) {
        if (FAILED(StringCbPrintfA(lpdata, len2, "\",%lu,TRUE,FALSE)]", iVerb)))
        {
            hresult = E_OUTOFMEMORY;
            goto fail;
        }
    } else {
        if (FAILED(StringCbCopyA(lpdata, len2, "\")]")))
        {
            hresult = E_OUTOFMEMORY;
            goto fail;
        }
        // apps like excel and wingraph do not support activate at item level.
    }

    intrDebugOut((DEB_ITRACE,"::DoVerb(%x)lpdata(%s)\n",this,lpdataStart));

    Assert (strlen(lpdata) < size);

    GlobalUnlock (hdata);

    hresult = m_pDdeObject->Execute (m_pDdeObject->m_pDocChannel, hdata);

    if (NOERROR==hresult)
    {
        // Assume doing a verb makes the server visible.
        // This is not strictly true.
        m_pDdeObject->DeclareVisibility (TRUE);
    }
    else
    {
    intrDebugOut((DEB_ITRACE,
              "::DoVerb(%x)Execute returned %x\n",
              this,
              hresult));
    }
    
    return hresult;

fail:
    GlobalUnlock(hdata);
    return hresult;
}





//+---------------------------------------------------------------------------
//
//  Method:     CDdeObject::SetHostNames
//
//  Synopsis:   Sets the host names
//
//  Effects:
//
//  Arguments:  [szContainerApp] -- Name of container app
//      [szContainerObj] -- Name of contained object
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:
//
//  History:    5-12-94   kevinro   Created
//
//  Notes:
//  ANSI ALERT!
//
//  The server is going to accept a command string from us. This string
//  needs to be done in ANSI, since we are going to pass it to old
//  servers. Therefore, the following code generates an ANSI string
//
//----------------------------------------------------------------------------
STDMETHODIMP NC(CDdeObject,COleObjectImpl)::SetHostNames
(LPCOLESTR szContainerApp, LPCOLESTR szContainerObj)
{
    intrDebugOut((DEB_ITRACE,
          "CDdeObject::SetHostNames(%x,App=%ws,Obj=%ws)\n",
          this,szContainerApp,szContainerObj));

    WORD        cbName;
    WORD        wSize;
    LPSTR       lpBuf;
    HANDLE      hDdePoke = NULL;

    ChkD (m_pDdeObject);

    VDATEPTRIN (szContainerApp, char);

    if (!m_pDdeObject->m_pDocChannel)
        return NOERROR;
    if (szContainerObj==NULL)
        szContainerObj=OLESTR("");

    if (szContainerApp[0]=='\0')
        szContainerApp = OLESTR("Container Application");

    //
    // The OLE 1.0 server is going to want ANSI strings.
    // convert the two that we have
    //

    char pszContainerApp[MAX_STR];
    char pszContainerObj[MAX_STR];

    if (WideCharToMultiByte(CP_ACP,
                0,
                szContainerApp,
                -1,
                pszContainerApp,
                MAX_STR,
                NULL,
                NULL) == FALSE)
    {
    intrDebugOut((DEB_ERROR,
              "::SetHostNames(%x) can't convert szContainerApp(%ws) err=%x\n",
              this,szContainerApp,GetLastError()));

    //
    // Couldn't convert string
    //
    return(E_UNEXPECTED);
    }
    if (WideCharToMultiByte(CP_ACP,
                0,
                szContainerObj,
                -1,
                pszContainerObj,
                MAX_STR,
                NULL,
                NULL) == FALSE)
    {
    intrDebugOut((DEB_ERROR,
              "::SetHostNames(%x) can't convert szContainerObj(%ws) err=%x\n",
              this,szContainerObj,GetLastError));

    //
    // Couldn't convert string
    //
    return(E_UNEXPECTED);
    }


    //
    // We have found through experience that some OLE applications, like
    // Clipart, use a fixed size buffer for these names. Therefore, we
    // are going to limit the sizes of the strings, in case they are
    // too long to send. We do this by always sticking a NULL at offset
    // 80 in the file.
    //
    pszContainerApp[80]=0;
    pszContainerObj[80]=0;

    WORD cbObj;

    wSize = (WORD)((cbName = (WORD) strlen(pszContainerApp)+1)
            + (cbObj = (WORD) strlen(pszContainerObj)+1)
            + 2 * sizeof(WORD));  // for the two offsets

    lpBuf = wAllocDdePokeBlock ((DWORD)wSize, g_cfBinary, &hDdePoke);

    if(lpBuf)
    {
        ((WORD FAR*)lpBuf)[0] = 0;
        ((WORD FAR*)lpBuf)[1] = cbName;
        lpBuf += 2*sizeof(WORD);
        memcpy (lpBuf,pszContainerApp,cbName);
        memcpy (lpBuf+cbName, pszContainerObj,cbObj);
    }

    if(hDdePoke)
        GlobalUnlock (hDdePoke);

    aStdHostNames = GlobalAddAtom (OLESTR("StdHostNames"));
    intrAssert(wIsValidAtom(aStdHostNames));
    m_pDdeObject->Poke(aStdHostNames, hDdePoke);
    return NOERROR;
}



STDMETHODIMP NC(CDdeObject,COleObjectImpl)::Close
    (DWORD dwSaveOption)
{
    intrDebugOut((DEB_ITRACE,
          "CDdeObject::Close(%x,dwSaveOption=%x)\n",
          this,dwSaveOption));


    ChkDR (m_pDdeObject);

    HRESULT hresult;
    if (m_pDdeObject->m_fDidSendOnClose)
        return ResultFromScode (RPC_E_CANTCALLOUT_INASYNCCALL);

    if (((OLECLOSE_SAVEIFDIRTY  == dwSaveOption) ||
         (OLECLOSE_PROMPTSAVE==dwSaveOption)) &&
         (m_pDdeObject->m_clsid != CLSID_Package))
    {
        // Packager gives truncated native data (header info with no
        // actual embedded file) if you DDE_REQUEST it. Bug 3103
        Update(); // IOleObject::Update
        m_pDdeObject->OleCallBack (ON_SAVE,NULL);
    }
    RetZ (m_pDdeObject->m_pDocChannel);

    HANDLE h = wNewHandle ((LPSTR)&achStdCloseDocument,sizeof(achStdCloseDocument));

    if(h)
    {
        hresult=m_pDdeObject->Execute (m_pDdeObject->m_pDocChannel,
                           h,
                           TRUE);
    }
    else
    {
        hresult=E_OUTOFMEMORY;
    }

    if (NOERROR==hresult)
        m_pDdeObject->m_fDidStdCloseDoc = TRUE;

    // Client sends StdCloseDocument. Srvr sends ACK. Srvr may or may not
    // send Terminate.  We may interpret the TERMINATE the server sends
    // as the reply to ours even if he posted first. But since some servers
    // post first and others wait for the client, this is what we need to do.

    BOOL fVisible = m_pDdeObject->m_fWasEverVisible; // TermConv clears this flag
    m_pDdeObject->TermConv (m_pDdeObject->m_pDocChannel);
    if (!fVisible)
        m_pDdeObject->MaybeUnlaunchApp();

    return hresult;
}


STDMETHODIMP NC(CDdeObject,COleObjectImpl)::SetMoniker
    (DWORD dwWhichMoniker, LPMONIKER pmk)
{
    intrDebugOut((DEB_ITRACE,
          "CDdeObject::SetMoniker(%x,dwWhichMoniker=%x)\n",
          this,dwWhichMoniker));

    ChkD (m_pDdeObject);
    Puts ("OleObject::SetMoniker\r\n");
    // we ignore this always
    return NOERROR;
}


STDMETHODIMP NC(CDdeObject,COleObjectImpl)::GetMoniker
    (DWORD dwAssign, DWORD dwWhichMoniker, LPMONIKER FAR* ppmk)
{
    intrDebugOut((DEB_ITRACE,
          "CDdeObject::GetMoniker(%x,dwWhichMoniker=%x)\n",
          this,dwWhichMoniker));

    ChkD (m_pDdeObject);
    if (m_pDdeObject->m_pOleClientSite)
        return m_pDdeObject->m_pOleClientSite->GetMoniker(dwAssign,
                dwWhichMoniker, ppmk);
    else {
        // no client site
        *ppmk = NULL;
        return ReportResult(0, E_UNSPEC, 0, 0);
    }
}


STDMETHODIMP NC(CDdeObject,COleObjectImpl)::InitFromData
    (LPDATAOBJECT pDataObject, BOOL fCreation, DWORD dwReserved)
{
    intrDebugOut((DEB_ITRACE,
          "CDdeObject::InitFromData(%x)\n",
          this));

    Puts ("OleObject::InitFromData\r\n");
    return ReportResult(0, E_NOTIMPL, 0, 0);
}


STDMETHODIMP NC(CDdeObject,COleObjectImpl)::GetClipboardData
    (DWORD dwReserved, LPDATAOBJECT FAR* ppDataObject)
{
    intrDebugOut((DEB_ITRACE,
          "CDdeObject::GetClipboardData(%x)\n",
          this));

    Puts ("OleObject::GetClipboardData\r\n");
    return ReportResult(0, E_NOTIMPL, 0, 0);
}



STDMETHODIMP NC(CDdeObject,COleObjectImpl)::Advise
    (IAdviseSink FAR* pAdvSink,
     DWORD FAR*       pdwConnection)
{
    HRESULT hres;
    intrDebugOut((DEB_ITRACE,
          "CDdeObject::Advise(%x)\n",
          this));

    ChkD (m_pDdeObject);
    Puts ("OleObject::Advise\n");
    // Esstablish a DDE advise connection.
    if (m_pDdeObject->m_ulObjType == OT_EMBEDDED
        && !m_pDdeObject->m_fDidAdvNative)
    {
        // Embedded case.
        // Always advise on Save and Close.
        if (hres = m_pDdeObject->AdviseOn (g_cfNative, ON_SAVE))
            return hres;
        if (hres = m_pDdeObject->AdviseOn (g_cfNative, ON_CLOSE))
            return hres;
        if (m_pDdeObject->m_clsid == CLSID_MSDraw)
        {
            // MSDraw has (another) bug.  If you do not do an Advise on
            // presentation, then File.Update does not work, and you
            // cannot close the app unless you answer "no" to the update
            // dialog.  This would happen when you "Display As Icon"
            // because ordinarily there is no need to advise on presentation.
            // The following "unnecessary" advise fixes this problem.
            if (hres = m_pDdeObject->AdviseOn (CF_METAFILEPICT, ON_SAVE))
                return hres;
            if (hres = m_pDdeObject->AdviseOn (CF_METAFILEPICT, ON_CLOSE))
                return hres;
        }
    }
    else {
        /* Linked case */
        if (hres = m_pDdeObject->AdviseOn (g_cfBinary, ON_RENAME))
            return hres;
    }
    RetZS (m_pDdeObject->m_pOleAdvHolder, E_OUTOFMEMORY);
    return m_pDdeObject->m_pOleAdvHolder->Advise (pAdvSink, pdwConnection);
}




STDMETHODIMP NC(CDdeObject,COleObjectImpl)::Unadvise
    (DWORD dwConnection)
{
    intrDebugOut((DEB_ITRACE,
          "CDdeObject::Unadvise(%x,dwConnection=%x)\n",
          this,dwConnection));

    HRESULT hres;
    ChkD (m_pDdeObject);

    // Terminate the DDE advise connection
    if (m_pDdeObject->m_ulObjType == OT_EMBEDDED)
    {
        // Embedded case.
        if (hres = m_pDdeObject->UnAdviseOn (g_cfNative, ON_SAVE))
            return hres;
        if (hres = m_pDdeObject->UnAdviseOn (g_cfNative, ON_CLOSE))
            return hres;
    }
    else
    {
        /* Linked case */
        if (hres = m_pDdeObject->UnAdviseOn (g_cfBinary, ON_RENAME))
            return hres;
    }
    RetZS (m_pDdeObject->m_pOleAdvHolder, E_OUTOFMEMORY);
    return m_pDdeObject->m_pOleAdvHolder->Unadvise (dwConnection);
}




STDMETHODIMP NC(CDdeObject,COleObjectImpl)::EnumAdvise
    (THIS_ LPENUMSTATDATA FAR* ppenumAdvise)
{
    ChkD (m_pDdeObject);
    RetZS (m_pDdeObject->m_pOleAdvHolder, E_OUTOFMEMORY);
    return m_pDdeObject->m_pOleAdvHolder->EnumAdvise(ppenumAdvise);
}



STDMETHODIMP NC(CDdeObject,COleObjectImpl)::GetMiscStatus
    (DWORD dwAspect,
    DWORD FAR* pdwStatus)
{
    intrDebugOut((DEB_ITRACE,
          "CDdeObject::GetMiscStatus(%x)\n",
          this));

    VDATEPTRIN (pdwStatus, DWORD);
    *pdwStatus = 0L;
    return ResultFromScode (OLE_S_USEREG);
}



STDMETHODIMP NC(CDdeObject,COleObjectImpl)::SetColorScheme
    (LPLOGPALETTE lpLogpal)
{
    HANDLE          hDdePoke    = NULL;
    LPLOGPALETTE    lptmpLogpal = NULL;

    intrDebugOut((DEB_ITRACE,
          "CDdeObject::SetColorScheme(%x)\n",
          this));

    ChkD (m_pDdeObject);

    if (!m_pDdeObject->m_pDocChannel)
        return NOERROR;

    aStdColorScheme = GlobalAddAtom (OLESTR("StdColorScheme"));
    intrAssert(wIsValidAtom(aStdColorScheme));

    DWORD dwSize = (max(lpLogpal->palNumEntries, 1) - 1) * sizeof(PALETTEENTRY)
                        + sizeof(LOGPALETTE);
    lptmpLogpal = (LPLOGPALETTE) wAllocDdePokeBlock (dwSize, g_cfBinary, &hDdePoke);

    if(!lptmpLogpal || !hDdePoke) return E_OUTOFMEMORY;

    memcpy(lptmpLogpal, lpLogpal, dwSize);

    GlobalUnlock(hDdePoke);
    return m_pDdeObject->Poke(aStdColorScheme, hDdePoke);
}



#ifdef _DEBUG
STDMETHODIMP_(void) NC(CDdeObject,CDebug)::Dump( IDebugStream FAR * pdbstm)
{
}

STDMETHODIMP_(BOOL) NC(CDdeObject,CDebug)::IsValid( BOOL fSuspicious )
{
    if( m_pDdeObject->m_refs > 0 && m_pDdeObject->m_chk == chkDdeObj )
        return TRUE;
    else
        return FALSE;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\com\dde\client\ddeproxy.cxx ===
/*
copyright (c) 1992  Microsoft Corporation

Module Name:

    ddeproxy.cpp

Abstract:

    This module contains the code for the dde proxy (wrapper)

Author:

    Srini  Koppolu   (srinik)    22-June-1992
    Jason  Fuller   (jasonful)  24-July-1992
*/
#include "ddeproxy.h"
#include <tls.h>

#define STRSAFE_NO_DEPRECATE
#include "strsafe.h"

DebugOnly (static UINT v_cDdeObjects=0;)
/*
 *  IMPLEMENTATION of CDdeObject
 *
 */

#ifdef OLD
#define UpdateExtent(old,new) do { if ((long)new!=old) {old=(long)new; } } while (0)
#endif

//+---------------------------------------------------------------------------
//
//  Function:   CreateDdeClientHwnd
//
//  Synopsis:   Creates a per thread ClientDde window.
//
//  Effects:    This window is created so we can keep a list of windows that
//              need to be cleaned up in the event the thread dies or OLE32 is
//              unloaded. In the case of DLL unload, we will fault if we don't
//              cleanup this window, since user will dispatch messages to
//              non-existant code. The easy way to track these windows is to
//              make them children of a common per thread window.
//
//              This routine is called by the TLSGetDdeClient() routine to
//              create a window per thread. This window doesn't need to respond
//              to DDE Initiates.
//
//  Arguments:  [void] --
//
//  Returns:    HWND to DdeClientWindow.
//
//  History:    12-10-94   kevinro   Created
//
//----------------------------------------------------------------------------

HWND CreateDdeClientHwnd(void)
{
    return SSCreateWindowExA(0,"STATIC","DdeClientHwnd",WS_DISABLED,
                         0,0,0,0,NULL,NULL,hinstSO,NULL);
}

// CreateDdeProxy
//
// This corresponds to ProxyManager::Create in 2.0
//


INTERNAL_ (LPUNKNOWN) CreateDdeProxy
    (IUnknown * pUnkOuter,
    REFCLSID clsid)
{
    LPUNKNOWN punk;
    intrDebugOut((DEB_ITRACE,"CreateDdeProxy(pUnkOuter=%x)\n",pUnkOuter));

    COleTls Tls;
    if (Tls->dwFlags & OLETLS_DISABLE_OLE1DDE)
    {
        // If DDE use is disabled we shouldn't have gotten here.
        // This is a bad place to error because we can't return an
        // HResult.
        //
        Assert(!"Executing CreateDdeProxy when DDE is disabled");
        return NULL;
    }

    punk = CDdeObject::Create (pUnkOuter, clsid);
    intrDebugOut((DEB_ITRACE,
                  "CreateDdeProxy(pUnkOuter=%x) returns %x\n",
                  pUnkOuter,
                  punk));
    return punk;
}

//+---------------------------------------------------------------------------
//
//  Method:     CDdeObject::Create
//
//  Synopsis:   Creates a CDdeObject
//
//  Effects:
//
//  Arguments:  [pUnkOuter] --  Controlling IUnknown
//      [clsid] --      OLE1 ClassID
//      [ulObjType] --  Object type. Optional: def to OT_EMBEDDED
//      [aTopic] --     Atom of link. Optional: def to NULL
//      [szItem] --     String for link object (def to NULL)
//      [ppdde] --      Output pointer to CDdeObject (def to NULL)
//      [fAllowNullClsid] -- Is NULL clsid OK? Default: false
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:
//
//  History:
//
//  Notes:
//
//----------------------------------------------------------------------------
INTERNAL_(LPUNKNOWN) CDdeObject::Create
    (IUnknown *     pUnkOuter,
    REFCLSID        clsid,
    ULONG           ulObjType,// optional, default OT_EMBEDDED
    ATOM            aTopic,   // optional, only relevant if ulObjType==OT_LINK
    LPOLESTR            szItem,   // optional, only relevant if ulObjType==OT_LINK
    CDdeObject * * ppdde,       // optional, thing created
    BOOL            fAllowNullClsid) // default FALSE
{
    COleTls Tls;
    if(Tls->dwFlags & OLETLS_DISABLE_OLE1DDE)
    {
        //
        // If the DDE implementation of OLE1 is disabled
        // we shouldn't get this far.   This is also a bad place
        // to fail because we this routine is defined to not return
        // an HResult.
        //
        Assert(!"Executing CDdeObject::Create but DDE is Disabled");
        return NULL;
    }
    intrDebugOut((DEB_ITRACE,"CDdeObject::Create(%x,ulObjType=%x)\n",
          pUnkOuter,
          ulObjType));

    CDdeObject * pDdeObject;
    static int iTopic=1;  // used to make topic names unique
    WCHAR szTopic[30];
    Assert (ulObjType==OT_LINK || ulObjType==OT_EMBEDDED);

    Assert (ulObjType != OT_LINK || wIsValidAtom(aTopic));
    if (ppdde)
        *ppdde = NULL;

    if (NULL==(pDdeObject = new CDdeObject (pUnkOuter))
        || NULL == pDdeObject->m_pDataAdvHolder
        || NULL == pDdeObject->m_pOleAdvHolder)
    {
        Assert (!"new CDdeObject failed");
        return NULL;
    }

    pDdeObject->m_refs      = 1;
    pDdeObject->m_clsid     = clsid;
    pDdeObject->m_aClass    = wAtomFromCLSID(clsid);

#ifdef OLE1INTEROP

    pDdeObject->m_fOle1interop = TRUE;

#endif

    if (ulObjType==OT_LINK)
    {

        pDdeObject->m_aTopic = wDupAtom (aTopic);
        pDdeObject->m_aItem  = wGlobalAddAtom (szItem);
        // Never close a linked document
        pDdeObject->m_fNoStdCloseDoc = TRUE;
    }
    else
    {
        // This string may actually be visible in the Window Title Bar for a sec.
        InterlockedIncrement((long *)&iTopic);
        wsprintf (szTopic,OLESTR("Embedded Object #%u"), iTopic);
        Assert (lstrlenW(szTopic) < 30);
        pDdeObject->m_aItem = NULL;
        pDdeObject->m_aTopic = wGlobalAddAtom (szTopic);
    }
    pDdeObject->m_bOldSvr   = wIsOldServer (pDdeObject->m_aClass);
    pDdeObject->m_ulObjType = ulObjType;

    // we can only run if we have a MFI
    pDdeObject->m_aExeName = wGetExeNameAtom(clsid);

    intrDebugOut((DEB_ITRACE,
          "::Create(%x,aTopic=%x,aItem=%x,szItem=%ws,aExeName=%x)\n",
          pDdeObject,
          pDdeObject->m_aTopic,
          pDdeObject->m_aItem,
          szItem?szItem:L"<NULL>",
          pDdeObject->m_aExeName));

    if (ppdde)
        *ppdde = pDdeObject;
    return &pDdeObject->m_Unknown;
}



// Constructor
CDdeObject::CDdeObject (IUnknown * pUnkOuter) :
    m_Unknown(this),
    CONSTRUCT_DEBUG
    m_Data(this),
    m_Ole(this),
    m_PersistStg(this),
    m_ProxyMgr(this),
    m_OleItemContainer(this),
    m_RpcStubBuffer(this)
{
    intrDebugOut((DEB_ITRACE,"CDdeObject::CDdeObject(%x)\n",this));
    if (!pUnkOuter)
        pUnkOuter = &m_Unknown;

    m_pUnkOuter = pUnkOuter;
    m_bRunning  = FALSE;
    m_pOleClientSite = NULL;
    m_pstg = NULL;
    m_pSysChannel = NULL;
    m_pDocChannel = NULL;
    m_bInitNew = NULL;
    m_hNative = NULL;
    m_hPict   = NULL;
    m_hExtra  = NULL;
    m_cfExtra = NULL;
    m_cfPict = 0;
    m_aItem = NULL;
    m_iAdvSave = 0;
    m_iAdvClose = 0;
    m_iAdvChange = 0;
    m_fDidAdvNative = FALSE;
    m_pOleAdvHolder = NULL;
    m_pDataAdvHolder = NULL;
    m_fDidSendOnClose = FALSE;
    m_fNoStdCloseDoc = FALSE;
    m_fDidStdCloseDoc = FALSE;
    m_fDidStdOpenDoc = FALSE;
    m_fDidGetObject = FALSE;
    m_fDidLaunchApp = FALSE;
    m_fUpdateOnSave = TRUE;
    m_fVisible = FALSE;
    m_fWasEverVisible = FALSE;
    m_fCalledOnShow = FALSE;
    m_fGotCloseData = FALSE;
    m_cLocks = 1;               // connections are initially locked
    m_chk = chkDdeObj;
    m_ptd = NULL;
    m_fDoingSendOnDataChange = FALSE;

    CreateOleAdviseHolder (&m_pOleAdvHolder);
    Assert (m_pOleAdvHolder);
    CreateDataAdviseHolder (&m_pDataAdvHolder);
    Assert (m_pDataAdvHolder);

#ifdef OLD
    m_cxContentExtent = 2000;  // 2 centimeters , totally random default
    m_cyContentExtent = 2000;
#endif

    m_wTerminate = Terminate_None;

    DebugOnly (v_cDdeObjects++;)
    Putsi (v_cDdeObjects);
}



CDdeObject::~CDdeObject
    (void)
{
    intrDebugOut((DEB_ITRACE,"CDdeObject::~CDdeObject(%x)\n",this));

    if (m_pDocChannel)
    {
        intrDebugOut((DEB_IWARN , "Abnormal situation: Doc Channel not deleted. Server died?"));
        delete m_pDocChannel;
    }
    if (m_pSysChannel)
    {
        Warn ("Abnormal situation: Sys Channel not deleted. Server died?");
        delete m_pSysChannel;
    }
    if (m_hNative)
    {
        GlobalFree(m_hNative);
    }

    if (m_hPict)
    {
        wFreeData (m_hPict, m_cfPict, TRUE);
    }

    if (m_hExtra)
    {
        wFreeData (m_hExtra, m_cfExtra, TRUE);
    }

    // release all the pointers that we remember

    if (m_pOleClientSite)
    {
        DeclareVisibility (FALSE);
        m_pOleClientSite->Release();
    }

    if (m_pDataAdvHolder)
        m_pDataAdvHolder->Release();

    if (m_pOleAdvHolder)
        m_pOleAdvHolder->Release();

    if (m_pstg)
        m_pstg->Release();

    if (m_aExeName)
        GlobalDeleteAtom (m_aExeName);

    if (m_aClass)
        GlobalDeleteAtom (m_aClass);

    if (m_aTopic)
        GlobalDeleteAtom (m_aTopic);

    if (m_aItem)
        GlobalDeleteAtom (m_aItem);

    if (m_ptd)
        delete m_ptd;

    m_chk = 0;
    DebugOnly (v_cDdeObjects--;)
    Putsi (v_cDdeObjects);
}




//  Handles WM_DDE_ACKs received while in initiate state. If this is the first
//  reply, save its window handle. If multiple replies are received, take the
//  one with the prefered instance, if there is one. Keep a count of
//  WM_DDE_TERMINATEs we send so that we don't shut the window until we get
//  all of the responses for  WM_DDE_TERMINATEs.


INTERNAL_(void) CDdeObject::OnInitAck (LPDDE_CHANNEL pChannel, HWND hwndSvr)
{
    intrDebugOut((DEB_ITRACE,"CDdeObject::OnInitAck(%x,hwndSvr=%x)\n",this,hwndSvr));
#ifdef _MAC
#else
    if (!IsWindow (hwndSvr))
    {
        Assert (0);
        return;
    }
    if (pChannel->hwndSvr) { // if we already have a handle
        intrDebugOut((DEB_ITRACE,
                      "CDdeObject::OnInitAck(%x,hwndSvr=%x) Already have hwndSvr=%x\n",
                      this,
                      hwndSvr,
                      pChannel->hwndSvr));
        // just take the very first one. Direct post is OK
        MPostWM_DDE_TERMINATE(hwndSvr,pChannel->hwndCli);
        // Expect an extra WM_DDE_TERMINATE
        ++pChannel->iExtraTerms;
    } else {
        // this is the server we want
        pChannel->hwndSvr = hwndSvr;
        pChannel->iExtraTerms = NULL;

        intrDebugOut((DEB_ITRACE,
                      "CDdeObject::OnInitAck(%x,hwndSvr=%x) Established Connection\n",
                      this,
                      hwndSvr,
                      pChannel->hwndSvr));
    }
#endif _MAC
}

INTERNAL_(BOOL) CDdeObject::OnAck (LPDDE_CHANNEL pChannel, LPARAM lParam)
{
    intrDebugOut((DEB_ITRACE,"CDdeObject::OnAck(%x,lParam=%x)\n",this,lParam));

    BOOL    retval = TRUE;
    ATOM    aItem = 0;
    WORD    wStatus;
    HANDLE  hData = NULL;

    if( pChannel->iAwaitAck == AA_EXECUTE)
    {
       wStatus = GET_WM_DDE_EXECACK_STATUS( NULL, lParam );
       hData = GET_WM_DDE_EXECACK_HDATA( NULL, lParam );
    }
    else
    {
       wStatus = GET_WM_DDE_ACK_STATUS( NULL, lParam );
       aItem = GET_WM_DDE_ACK_ITEM( NULL, lParam );
    }


    // check for busy bit
    if (wStatus & 0x4000)
    {
        // we got busy from the server.
        pChannel->fRejected = TRUE;
        // tell the wait loop that we got a busy ack
        //CoSetAckState(pChannel->pCI , FALSE,TRUE, SERVERCALLEX_RETRYLATER);
        intrDebugOut((DEB_ITRACE,"::OnAck(%x) Busy SetCallState(SERVERCALLEX_RETRYLATER)\n",this));
        pChannel->SetCallState(SERVERCALLEX_RETRYLATER);
        return TRUE;
    }

    // just reset the flag always
    m_wTerminate = Terminate_None;

    if (pChannel->iAwaitAck != AA_EXECUTE)
    {
        intrDebugOut((DEB_ITRACE,
                      "::OnAck(%x)aItem=%x(%ws) wStatus=\n",
                      this,
                      aItem,
                      wAtomName(aItem),
                      wStatus));
    }

    if (pChannel->iAwaitAck == AA_EXECUTE)
    {
        if(hData) GlobalFree (hData);
        pChannel->hCommands = NULL;
    }
    else
    {
        if (hData)
            GlobalDeleteAtom ((ATOM)hData);
    }


    // even if the client got terminate we have to go thru this path.

    if (pChannel->wTimer) {
        KillTimer (pChannel->hwndCli, 1);
        pChannel->wTimer = 0;
    }


    if (pChannel->iAwaitAck == AA_POKE)
        // We have to free the data first. OnAck can trigger
        // another Poke (like pokehostnames)
        wFreePokeData (pChannel, (m_bOldSvr && m_aClass==aMSDraw));


    if (!(wStatus & POSITIVE_ACK))
    {
        intrDebugOut((DEB_ITRACE,"::OnAck(%x) OnAck got an ack with fAck==FALSE.\n",this));

        // A negative ack is OK when doing a temporary advise from
        // IsFormatAvailable().   Also, apps don't seem to positively
        // ack all unadvises.

        // review: johannp : this is the case were have to inform the reply rejected call

        retval = FALSE;
        // we got the ack and can leave the wait loop
        //CoSetAckState(pChannel->pCI, FALSE);

        intrDebugOut((DEB_ITRACE,
                      "::OnAck(%x) ***_ NACK _*** SetCallState(ISHANDLED,RPC_E_DDE_NACK)\n",
                      this));

        pChannel->SetCallState(SERVERCALLEX_ISHANDLED, RPC_E_DDE_NACK);

        // MSDraw frees hOptions even on a NACK, despite official DDE rules.
        if (pChannel->iAwaitAck == AA_ADVISE && m_clsid != CLSID_MSDraw)
        {
           GlobalFree (pChannel->hopt);
           pChannel->bFreedhopt = TRUE;
        }
    }
    else
    {
        // we got the ack and can leave the wait loop
        // CoSetAckState(pChannel->pCI, FALSE);
        intrDebugOut((DEB_ITRACE,
                      "::OnAck(%x) POSITIVE_ACK SetCallState(SERVERCALLEX_ISHANDLED)\n",
                      this));
        pChannel->SetCallState(SERVERCALLEX_ISHANDLED);
    }

    pChannel->hopt = NULL;
    pChannel->iAwaitAck = NULL;
    return retval;

}





INTERNAL_(void) CDdeObject::OnTimer (LPDDE_CHANNEL pChannel)
{
    intrDebugOut((DEB_ITRACE,"CDdeObject::OnTimer(%x)\n",this));
    // Since there is only one timer for each client, just
    // repost the message and delete the timer.
#ifdef _MAC
#else
    KillTimer (pChannel->hwndCli, 1);
    pChannel->wTimer = 0;

    if (wPostMessageToServer(pChannel, pChannel->wMsg, pChannel->lParam,FALSE))
        return ;

    // Postmessage failed. We need to getback to the main stream of
    // commands for the object.
    OnAck (pChannel, pChannel->lParam);
#endif _MAC
}



// Called when we get a WM_DDE_DATA message in reponse to
// a DDE_REQUEST we sent to check if a format is available.
//
INTERNAL CDdeObject::OnDataAvailable
    (LPDDE_CHANNEL  pChannel,
    HANDLE          hDdeData,
    ATOM            aItem)
{
    intrDebugOut((DEB_ITRACE,"CDdeObject::OnDataAvailable(%x)\n",this));
    CLIPFORMAT cf;
    Assert (AA_REQUESTAVAILABLE == pChannel->iAwaitAck);
    intrAssert( wIsValidAtom(aItem));

    DDEDATA * pDdeData = (DDEDATA *) GlobalLock (hDdeData);
    RetZS (pDdeData, E_OUTOFMEMORY);
    if (!pDdeData->fAckReq && aItem)
    {
            GlobalDeleteAtom (aItem);
    }
    cf = pDdeData->cfFormat;
    GlobalUnlock (hDdeData);

    void* pv = wHandleFromDdeData (hDdeData);
    if(pv) wFreeData (pv, cf);

    return NOERROR;
}



// Called for WM_DDE_DATA message. If data is from an ADVISE-ON-CLOSE and this
// is there are no more outstanding ADVISE-ON-CLOSE requests, close the
// document and end the conversation.


//+---------------------------------------------------------------------------
//
//  Method:     CDdeObject::OnData
//
//  Synopsis:   Called when a WM_DDE_DATA message is recieved. If the data
//              is from an ADVISE_ON_CLOSE, and there are no more
//              outstanding ADVISE_ON_CLOSE request, close the document
//              and end the conversation.
//
//  Effects:    The effects of this routine are complex.
//
//  Wow! What else can be said. This routine does alot of stuff in response
//  to an incoming WM_DDE_DATA message. There are basically two flavors of
//  response here. First is when we were expecting to get this result,
//  in which case we know what we wanted to do with the data. Second is
//  when the data just arrives, but we didn't expect it. These cases could
//  indicate that the server is shutting down.
//
//
//  Arguments:  [pChannel] -- The DDE channel recieving the message
//              [hDdeData] -- Handle to the data
//              [aItem] -- Atom to the item
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:
//
//  History:    5-16-94   kevinro   Restructured and commented
//
//  Notes:
//
//
//      Be extra careful you change this routine.
//      This is especially neccesary if you are going to exit early. The
//      way that hDdeData is free'd or kept should be understood before
//      changing.
//
//
//----------------------------------------------------------------------------
INTERNAL CDdeObject::OnData
    (LPDDE_CHANNEL  pChannel,
    HANDLE          hDdeData,
    ATOM            aItem)
{
    intrDebugOut((DEB_ITRACE,
          "CDdeObject::OnData(%x,pChannel=%x,hDdeData=%x,aItem=%x(%s)iAwaitAck=%x\n",
          this,
          pChannel,
          hDdeData,
          aItem,
          wAtomNameA(aItem),
          pChannel->iAwaitAck));
#ifdef _MAC
#else
    DDEDATA * lpDdeData = NULL;
    BOOL         fAck = TRUE;
    int          iAdvOpt;
    BOOL         fCallBack = FALSE;
    HRESULT      hresult = NOERROR;
    BOOL fRequested = FALSE;

    intrAssert(wIsValidAtom(aItem));

    int iAwaitAck = pChannel->iAwaitAck;

    //
    // If we were waiting for this data, then we are sitting in the
    // modal loop. Set the call state on the call control interface
    // to indicate that a response was recieved. Pass NOERROR to indicate
    // that there was success. If an error is determined later, then
    // the state will be set a second time.
    //

    if ((AA_REQUEST == iAwaitAck) || (AA_REQUESTAVAILABLE == iAwaitAck))
    {
        intrDebugOut((DEB_ITRACE,
                      "::OnData(%x) AA_REQUEST/AVAILABLE \n",
                      this));

        //
        // Regardless of the outcome of this call, we have recieved a
        // response. Set the Awaiting Ack state to nothing.
        //
        pChannel->iAwaitAck = AA_NONE;

        //
        // Determine if this channels call data is valid
        //

        if (pChannel->pCD )
        {
            //CoSetAckState(pChannel->pCI, FALSE); // clear waiting flag
            intrDebugOut((DEB_ITRACE,"::OnData(%x) SetCallState(SERVERCALLEX_ISHANDLED)\n",this));
            pChannel->SetCallState(SERVERCALLEX_ISHANDLED);
        }
    }


    //
    // Check the string for aItem, looking for advise options. The variable
    // iAdvOpt will be set to indicate what type of data we just got, such
    // as ON_CHANGE, etc. If the option is invalid, then we won't know
    // what to do with it.
    //

    if ((hresult=wScanItemOptions (aItem, (int *) &iAdvOpt)) != NOERROR)
    {
        intrAssert(!"Item found with unknown advise option\n");
        LPARAM lp;
        if(!wPostMessageToServer (pChannel,
                          WM_DDE_ACK,
                          lp = MAKE_DDE_LPARAM (WM_DDE_ACK,NEGATIVE_ACK, aItem),TRUE))
        {
            hresult = RPC_E_SERVER_DIED;

        }

        //
        // Did we need to free hDdeData here? No, according to the DDE spec, if the
        // receiever responds with a NACK, then the sender is responsible for
        // freeing the data.
        //
        return hresult;
    }

    //
    // If the server sent no data, there ain't much we can do about it.
    //

    if (hDdeData == NULL)
    {
        intrDebugOut((DEB_IERROR,
                      "::OnData(%x)hDdeData is NULL!\n",
                      this));

        return(RPC_E_INVALID_PARAMETER);
    }

    //
    // Lock the data into memory so we can use it. Be careful, the way
    // this routine was written originally, there are places that free
    // and realloc hDdeData. Specifically, the call to KeepData. Carefully
    // evaluate each place where you are returning, to insure the memory
    // isn't leaked. (if you have time, please restructure this routine
    // so it is easier to understand.
    //
    if (!(lpDdeData = (DDEDATA FAR *) GlobalLock(hDdeData)))
    {
        intrDebugOut((DEB_IERROR,
                      "::OnData(%x)GlobalLock on lpDdeData failed\n",
                      this));
        //
        // (KevinRo)Did we need to free hDdeData here? I think
        // we should have if the fRelease flag was set. The old code
        // didn't. Need to research this further (ie you figure it out!)
        // [Probably not - we haven't seen significant leaks in a long time]
        //
        return ResultFromScode (E_OUTOFMEMORY);
    }

    intrDebugOut((INTR_DDE,
              "::OnData(%x) lpDdeData->cfFormat=%x\n",
              this,
              (UINT)lpDdeData->cfFormat));

    //
    // The server will set fAckReq if it wants a response.
    // don't call HIC for call where not acknoewledge is requested
    //
    fAck = lpDdeData->fAckReq;

    if (pChannel->bTerminating) {
        intrDebugOut((INTR_DDE,"::OnData(%x) Got DDE_DATA in terminate sequence\n",this));
        //
        //      this is very dangerous since the pointer on the
        //      hDocWnd does not get deleted and a further will
        //      DDE message will GPF - we need to fix this!!!
        //
        GlobalUnlock (hDdeData);
        GlobalFree (hDdeData);
        goto exitRtn;
    }

    //
    // (KevinRo) Found this comment:
    //
    //  important that we post the acknowledge first. Otherwise the
    //  messages are not in sync.
    //
    // The above comment might be intended to mean that the acknowledge needs to be
    // send now, because we may call one of the advise functions below, which in
    // turn may send another message to the OLE 1.0 server. Therefore, we ACK now,
    // so the messages to the OLE 1.0 server are in the correct order.
    //
    if (fAck)
    {
        LPARAM lp;
        if(!wPostMessageToServer (pChannel,
                          WM_DDE_ACK,
                          lp=MAKE_DDE_LPARAM(WM_DDE_ACK,POSITIVE_ACK, aItem),TRUE))
        {
            return(RPC_E_SERVER_DIED);
        }
    }

    //
    // this call is now an async call and can not be rejected be HandleIncomingMessage
    //

    if ((AA_REQUESTAVAILABLE == pChannel->iAwaitAck) && (lpDdeData->fResponse))
    {
        //
        // For some reasons, OnDataAvailable will be the one to delete this data.
        // I don't understand it, but lets roll with it. (KevinRo)
        //
        GlobalUnlock (hDdeData);
        return OnDataAvailable (pChannel, hDdeData, aItem);
    }

    //
    // If the clipboard format is binary, and the topic is aStdDocName, then this
    // OnData is a RENAME
    //
    if (lpDdeData->cfFormat == (short)g_cfBinary && aItem== aStdDocName)
    {
        // ON_RENAME
        //
        // The data should be the new name, in ANSI.
        //
        ChangeTopic ((LPSTR)lpDdeData->Value);
        GlobalUnlock (hDdeData);
        GlobalFree (hDdeData);
        return(NOERROR);
    }

    //
    // Based on iAdvOpt, determine if we can callback. This one is a little
    // hard to understand. I don't either. CanCallBack appears to return
    // true if the count is 0,1, or 3, but returns FALSE if its 2 or
    // greater than 3. There are no comments in the old code as to why
    // this is. I am leaving it, since it must have been put there for
    // a reason. See CanCallBack in ddeworker.cxx for futher (ie no) details
    //
    switch (iAdvOpt)
    {
        case ON_SAVE:
            fCallBack = CanCallBack(&m_iAdvSave);
                intrDebugOut((INTR_DDE,
                              "::OnData(%x)ON_SAVE m_iAdvSave=%x\n",
                              this,
                              m_iAdvSave));

            break;
        case ON_CLOSE:
            fCallBack = CanCallBack(&m_iAdvClose);
                intrDebugOut((INTR_DDE,
                              "::OnData(%x)ON_CLOSE m_iAdvClose=%x\n",
                              this,
                              m_iAdvClose));
            break;
        case ON_CHANGE:
            fCallBack = TRUE;
                intrDebugOut((INTR_DDE,
                              "::OnData(%x)ON_CHANGE m_iAdvClose=%x\n",
                              this,
                              m_iAdvClose));
            break;
        default:
            intrAssert( !"Unknown iAdvOpt: Somethings really broke");
    }

    // Keep the data in a cache for a future GetData call
    // which may be triggered a few lines later by the
    // SendOnDataChange().

    fRequested = lpDdeData->fResponse;


    // The call  to KeepData will change hDdeData and
    // invalidate lpDdeData. Check out KeepData for details. The net
    // result is that hDdeData is no longer valid

    GlobalUnlock (hDdeData);
    lpDdeData=NULL;

    hresult = KeepData (pChannel, hDdeData);

    //
    // This is unpleasant, but if KeepData fails, we need to
    // call SetCallState again, resetting the error code. This
    // code is such a mess that rearranging it to do
    // it in a rational way is going to be too much work given
    // the amount of time I have until shipping.
    //
    // If you have time, please simplify this code. Thanks
    //
    if (hresult != NOERROR)
    {
        //
        // At this point, hDdeData has been unlocked, and deleted by
        // the KeepData routine. Therefore, the return here doesn't
        // need to be concerned with cleaning up after hDdeData
        //
        intrDebugOut((DEB_ITRACE,
                      "::OnData(%x) KeepData failed %x\n",
                      this,
                      hresult));
        //
        // Reset the error code on the call control
        //
        if ((AA_REQUEST == iAwaitAck) || (AA_REQUESTAVAILABLE == iAwaitAck))
        {
            if (pChannel->pCD )
            {
                pChannel->SetCallState(SERVERCALLEX_ISHANDLED, hresult);
            }
        }
        goto exitRtn;
    }

    if (fRequested)
    {
        // We REQUESTed the data. So, we are no longer waiting.
        // Do NOT call SendOnDataChange because the data hasn't
        // really changed again, we just requested it to satisfy
        // a call to GetData, which was probably called by the
        // real SendOnDataChange.
        intrDebugOut((INTR_DDE,
                      "::OnData(%x) fRequested DATA\n",
                      this));

        iAwaitAck = NULL;
        hresult = NOERROR;
        goto exitRtn;

    }

    //
    // Now we have decided this is data we had not asked for. This makes
    // it a change/close/saved notificiation.
    //
    intrDebugOut((INTR_DDE,"::OnData(%x) Non requested DATA\n",this));
    pChannel->AddReference();
    if (fCallBack && iAdvOpt != ON_CHANGE)
    {
        // ON_CHANGE will be handled by OleCallback, below

        intrDebugOut((INTR_DDE,
                      "::OnData(%x)Dispatching SendOnDataChange\n",
                      this));


        //
        // There are a couple of things to note about the following. First,
        // the iid of the call doesn't matter. Since OLE 1.0 servers don't
        // do nested calls, the original LID (Logical ID) can be any random
        // value. Therefore, we don't initalize it.
        //
        // According to JohannP, the calltype of these calls is supposed
        // to be CALLTYPE_SYNC. I don't fully understand why they are.
        // I am taking is decision on faith.
        //
        // Using the new call control interfaces, we do the following.
        //

        DDEDISPATCHDATA ddedispdata;
        DISPATCHDATA    dispatchdata;
        DWORD           dwFault;

        IUnknown *pUnk = m_pDataAdvHolder;

        //
        // We are about to call method #6 in the IDataAdviseHolder interface,
        // which is SendOnDataChange
        //

        RPCOLEMESSAGE   rpcMsg = {0};
        RPC_SERVER_INTERFACE RpcInterfaceInfo;
        rpcMsg.reserved2[1] = &RpcInterfaceInfo;

        *MSG_TO_IIDPTR(&rpcMsg) = IID_IDataAdviseHolder;


        rpcMsg.Buffer = &dispatchdata;
        rpcMsg.cbBuffer = sizeof(dispatchdata);
        rpcMsg.iMethod = 6;

        dispatchdata.scode = S_OK;
        dispatchdata.pData = (LPVOID) &ddedispdata;

        ddedispdata.pCDdeObject = this;
        ddedispdata.wDispFunc = DDE_DISP_SENDONDATACHANGE;
        ddedispdata.iArg = iAdvOpt;

        // package as RPCMESSAGE and call STAInvoke
        IRpcStubBuffer * pStub = &m_RpcStubBuffer;
        hresult = STAInvoke(&rpcMsg, CALLCAT_SYNCHRONOUS, pStub,
                            pChannel, NULL, NULL, &dwFault );
    }
    if (fCallBack )
    {
        // in 1.0 ON_CLOSE comes with data
        if (iAdvOpt==ON_CLOSE)
        {

            intrDebugOut((INTR_DDE,
                          "::OnData(%x) iAdvOpt == ON_CLOSE, send ON_SAVE\n",
                          this));

            m_fGotCloseData = TRUE;

            hresult = OleCallBack(ON_SAVE,pChannel);
            if (hresult != NOERROR)
            {
                goto errRel;
            }

            //ErrRtnH (DdeHandleIncomingCall(pChannel->hwndSvr, CALLTYPE_TOPLEVEL) );
            //ErrRtnH (OleCallBack (ON_SAVE));
        }

        // check if app can handle this call
        // we do not need to call HIC for SendOnClose

        hresult = OleCallBack (iAdvOpt,pChannel);
    }

errRel:
    // Don't use pChannel after this. It can get deleted. (srinik)
    if (pChannel->ReleaseReference() == 0)
    {
        m_pDocChannel = NULL;
    }

exitRtn:
    if (!fAck && aItem)
    {
        GlobalDeleteAtom (aItem);
    }
  return hresult;
#endif _MAC
}

//+---------------------------------------------------------------------------
//
//  Method:     CDdeObject::OleCallBack
//
//  Synopsis:   Send all the right notifications whan a Save or Close happens.
//
//  Effects:    OleCallBack is a double duty function. It is called in two
//              different cases.
//
//              First, is to setup the callback, and call HandleIncomingCall.
//              Second is from DispatchCall() in the CDdeChannelControl.
//
//              The reason for doing it this way is we localize the setup
//              and processing of these calls to one routine. Therefore,
//              we can go to one spot in the code to find all of the call
//              back information.
//
//  Arguments:  [iAdvOpt] -- Which Advise operation to perform
//              [pChannel] -- Which channel is being called back
//
//  Requires:   pChannel == NULL, and the AdviseHolders are called.
//              pChannel != NULL, and the call is setup, and HandleIncomingCall
//                          is setup.
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:
//
//  History:    5-23-94   kevinro   Created
//
//  Notes:
//
//  WARNING: this is poor code.  One of the major problems you need
//  to know about is that the CDdeObject may go away as part of the normal
//  processing of some of the below. Be very careful about any processing
//  that might occur after an ON_CLOSE
//
//----------------------------------------------------------------------------
INTERNAL CDdeObject::OleCallBack (int iAdvOpt, LPDDE_CHANNEL pChannel)
{
    HRESULT hresult = NOERROR;
    DDEDISPATCHDATA ddedispdata;
    DISPATCHDATA    dispatchdata;
    RPCOLEMESSAGE   rpcMsg = {0};
    IUnknown        *pUnk;

    RPC_SERVER_INTERFACE RpcInterfaceInfo;
    rpcMsg.reserved2[1] = &RpcInterfaceInfo;

    //
    // If the channel isn't NULL, then setup the data structures for calling
    // off to the call control.
    //
    if (pChannel != NULL)
    {
        //
        // Only do this work if we really have to
        //

        dispatchdata.scode = S_OK;
        dispatchdata.pData = (LPVOID) &ddedispdata;

        ddedispdata.pCDdeObject = this;
        ddedispdata.wDispFunc = DDE_DISP_OLECALLBACK;
        ddedispdata.iArg = iAdvOpt;
    }

    intrDebugOut((DEB_ITRACE,
                  "CDdeObject::OleCallBack(%x,iAdvOpt=%x,pChannel=%x)\n",
                  this,
                  iAdvOpt,
                  pChannel));

    //
    // Determine what needs to be done, based on the iAdvOpt. This should be
    // one of the handled cases below, otherwise its an error.
    //
    switch (iAdvOpt)
    {
    case ON_CLOSE:
        if (pChannel != NULL)
        {
            intrDebugOut((DEB_ITRACE,
                          "::OleCallBack(%x) setup for ON_CLOSE\n",
                          this));

            pUnk = m_pOleAdvHolder;

            *MSG_TO_IIDPTR(&rpcMsg) = IID_IOleAdviseHolder;
            // IOleAdviseHolder::SendOnClose is method 8
            rpcMsg.iMethod = 8;
        }
        else
        {
            intrDebugOut((DEB_ITRACE,"::OleCallBack(%x) ON_CLOSE\n",this));
            DeclareVisibility (FALSE);
            RetZ (!m_fDidSendOnClose); // This SendOnClose should happen 1st
                                      // Don't let OnTerminate() do it too
            hresult = SendOnClose();

            //
            // WARNING WARNING WARNING: SendOnClose() may have caused the
            // destruction of this CDdeObject. Touch nothing on the way
            // out. Actually, if you have time, which I currently don't,
            // see what you can do with reference counting tricks to
            // insure this object doesn't die during this callback.
            // Its a tricky problem, and we are shipping in 2 weeks.
            // (KevinRo 8/6/94)
            //
        }
        break;

    case ON_SAVE:
        if (pChannel != NULL)
        {
            intrDebugOut((DEB_ITRACE,
                          "::OleCallBack(%x) setup for ON_SAVE\n",
                          this));

            if (m_pOleClientSite == NULL)
            {
                pUnk = m_pOleClientSite;
                *MSG_TO_IIDPTR(&rpcMsg) = IID_IOleClientSite;
                // IOleClientSite::SaveObject method 7
                rpcMsg.iMethod = 7;
            }
            else
            {
                // Going to call the IOleAdviseHolder

                pUnk = m_pOleAdvHolder;
                *MSG_TO_IIDPTR(&rpcMsg) = IID_IOleAdviseHolder;
                // IOleAdviseHolder::SendOnSave method 7
                // (Yes, same ordinal as above, I double checked)
                rpcMsg.iMethod = 7;
            }
        }
        else
        {

            intrDebugOut((DEB_ITRACE,"::OleCallBack(%x) ON_SAVE\n",this));
            if (m_pOleClientSite)
            {
                // We just got data from the server, so we don't want to
                // ask him for it again when the container does a save.
                m_fUpdateOnSave = FALSE;

                // Harvard Graphics Access Violates if SaveObject is called on the ClientSite from
                // within OleCreateFromData.
                __try
                {
                    m_pOleClientSite->SaveObject();
                }
                __except (EXCEPTION_EXECUTE_HANDLER)
                {
                    intrDebugOut((DEB_IWARN ,"Warning: Exception in SaveObject\n"));
                }

                // SendOnSave is called in PS::SaveCompleted
                m_fUpdateOnSave = TRUE;
            }
            else
            {
                // Link case
                RetZS (m_pOleAdvHolder, E_OUTOFMEMORY);
                m_pOleAdvHolder->SendOnSave();
            }
        }
        break;

    case ON_CHANGE:
        if (pChannel != NULL)
        {
                // Going to call the IDataAdviseHolder

                pUnk = m_pDataAdvHolder;
                *MSG_TO_IIDPTR(&rpcMsg) = IID_IDataAdviseHolder;
                // IDataAdviseHolder::SendOnDataChange method 6
                rpcMsg.iMethod = 6;

        }
        else
        {
            RetZS (m_pDataAdvHolder, E_OUTOFMEMORY);
            intrDebugOut((DEB_ITRACE,"::OleCallBack(%x) ON_CHANGE\n",this));
            hresult = SendOnDataChange (ON_CHANGE);
        }
        break;

    default:


        intrDebugOut((DEB_ITRACE,
                      "CDdeObject::OleCallBack(%x,iAdvOpt=%x) UNKNOWN iAdvOpt\n",
                      this,
                      iAdvOpt));
        intrAssert(!"Unexpected iAdvOpt");
        return(E_UNEXPECTED);
        break;
    }

    //
    // There are a couple of things to note about the following. First,
    // the iid of the call doesn't matter. Since OLE 1.0 servers don't
    // do nested calls, the original LID (Logical ID) can be any random
    // value. Therefore, we don't initalize it.
    //
    // According to JohannP, the calltype of these calls is supposed
    // to be CALLTYPE_SYNCHRONOUS. I don't fully understand why they are.
    // I am taking is decision on faith.
    //
    //
    // Its possible that during the handling of this call that this object
    // will get deleted. This is a pain in the butt. This means that anything
    // used after this call MUST be protected. lpCallCont happens to be one of
    // these. We have been having problems with lpCallCont being released as
    // part of the object cleanup. The call control code will access member
    // variables on its way out of the HandleDispatch. We need to bracket
    // the call below so this doesn't happen.
    //
    if (pChannel != NULL)
    {
        // dont have to worry about call control going away.
        // package as RPCMESSAGE and call STAInvoke

        DWORD           dwFault;

        rpcMsg.Buffer = &dispatchdata;
        rpcMsg.cbBuffer = sizeof(dispatchdata);

        IRpcStubBuffer * pStub = &m_RpcStubBuffer;
        hresult = STAInvoke(&rpcMsg, CALLCAT_SYNCHRONOUS, pStub,
                            pChannel, NULL, NULL, &dwFault);
    }

    return hresult;
}


INTERNAL CDdeObject::SendOnDataChange
    (int iAdvOpt)
{
    intrDebugOut((DEB_ITRACE,"CDdeObject::SendOnDataChange(%x)\n",this));
    HRESULT hresult;
    RetZS (m_pDataAdvHolder, E_OUTOFMEMORY);
    m_fDoingSendOnDataChange = TRUE;
    hresult = m_pDataAdvHolder->SendOnDataChange (&m_Data,
                                                  DVASPECT_CONTENT,
                                                  0);
    if (ON_CLOSE==iAdvOpt)
    {
        hresult = m_pDataAdvHolder->SendOnDataChange (&m_Data,
                                                      DVASPECT_CONTENT,
                                                      ADVF_DATAONSTOP);
    }
    m_fDoingSendOnDataChange = FALSE;
    return hresult;
}




INTERNAL CDdeObject::SendOnClose
    (void)
{
    intrDebugOut((DEB_ITRACE,"CDdeObject::SendOnClose(%x)\n",this));
    RetZS (m_pOleAdvHolder, E_OUTOFMEMORY);
    m_fDidSendOnClose = TRUE;
    RetErr (m_pOleAdvHolder->SendOnClose() );
    return NOERROR;
}




INTERNAL CDdeObject::OnTerminate
    (LPDDE_CHANNEL pChannel,
    HWND hwndPost)
{
    intrDebugOut((DEB_ITRACE,
                  "CDdeObject::OnTerminate(%x,pChannel=%x,hwndPost=%x)\n",
                  this,
                  pChannel,
                  hwndPost));

    //
    // If the hwndPost and hwndSvr are different, then it is one of two
    // cases. We could have recieved more than one Acknowlege during our
    // initiate, in which case the count iExtraTerms would have been
    // incremented, and this terminate is accounted for iExtraTerms.
    //
    // The other case is that we were terminated by a window that was
    // NOT the window we were conversing with.
    //
    if (pChannel->hwndSvr != hwndPost)
    {
        intrDebugOut((DEB_ITRACE,
                      "::OnTerminate(%x) Extra terms is 0x%x \n",
                      this,
                      pChannel->iExtraTerms));

        //
        // iExtraTerms shouldn't go below zero. If it does, something
        // has gone wrong. We have been seeing some problems with the
        // HWND mapping layer in the past. If the following condition
        // ever trips, then it is possible that another mapping
        // problem has been seen.
        //
#if DBG == 1
        if((pChannel->iExtraTerms == 0 ) &&
           ((PtrToUlong (pChannel->hwndSvr)) & (0xffff)) == (PtrToUlong (hwndPost) & (0xffff)))
        {
            intrDebugOut((DEB_ERROR,
                          "*** OnTerminate expected hwnd=%x got hwnd=%x ***\n",
                          pChannel->hwndSvr,hwndPost));

            intrDebugOut((DEB_ERROR,
                          "\n*** Call KevinRo or SanfordS ***\n\n",
                          pChannel->hwndSvr,hwndPost));

        }
#endif
        --pChannel->iExtraTerms;

        intrAssert((pChannel->iExtraTerms >= 0) && "Call KevinRo or SanfordS");
        return NOERROR;
    }
    if (m_wTerminate == Terminate_Detect) {
        // we should only detect the call but not execute the code
        // set the state to Received
        m_wTerminate = Terminate_Received;
        pChannel->iAwaitAck = NULL;
        // Since Excel incorrectly did not send an ACK, we need to
        // delete the handle in the DDE message ourselves.
        if (pChannel->hCommands)
        {
            GlobalFree (pChannel->hCommands);
            pChannel->hCommands = NULL;
        }
        //CoSetAckState(pChannel->pCI, FALSE);
        intrDebugOut((DEB_ITRACE,
                      "::OnTerminate(%x) Terminate_Detect SERVERCALLEX_ISHANDLED\n",
                      this));
        pChannel->SetCallState(SERVERCALLEX_ISHANDLED, RPC_E_SERVER_DIED);
        return NOERROR;
    }

    RetZ (pChannel);
    ChkDR (this);

    if (!pChannel->bTerminating)
    {
        // Got unprompted terminate
        BOOL    bBusy;

        // Necessary safety bracket
        m_pUnkOuter->AddRef();

        bBusy = wClearWaitState (pChannel);

        if (pChannel->iAwaitAck || bBusy)
        {
            pChannel->iAwaitAck = NULL;
            //CoSetAckState(pChannel->pCI, FALSE);
            intrDebugOut((DEB_ITRACE,"::OnTerminate(%x) !bTerminating SERVERCALLEX_ISHANDLED,RPC_E_DDE_UNEXP_MSG\n",this));
            pChannel->SetCallState(SERVERCALLEX_ISHANDLED, RPC_E_DDE_UNEXP_MSG);
        }

        if (!m_fDidSendOnClose)
        {
        intrDebugOut((DEB_ITRACE,
                      "::OnTerminate(%x) SendOnClose from terminate\n",
                      this));

            BOOL f= m_fNoStdCloseDoc;
            m_fNoStdCloseDoc = TRUE;

            DeclareVisibility (FALSE);
            SendOnClose();

            m_fNoStdCloseDoc = f;
        }
        else
        {
        intrDebugOut((DEB_ITRACE,
                      "::OnTerminate(%x) Already did SendOnClose\n",
                      this));
            Puts ("Already did SendOnClose\n");
        }
        intrDebugOut((DEB_ITRACE,
                      "::OnTerminate(%x) Posting DDE_TERMINATE as reply\n",
                      this));

        wPostMessageToServer (pChannel, WM_DDE_TERMINATE, NULL,FALSE);

        // The terminate that we are sending itself is a reply, so we don't
        // need to do WaitForReply.
        DeleteChannel (pChannel);

        // Necessary safety bracket
        m_pUnkOuter->Release();
    }
    else
    {
        intrDebugOut((DEB_ITRACE,
                      "::OnTerminate(%x) Received DDE_TERMINATE in reply\n",
                      this));

        // We sent the WM_DDE_TERMINATE and we got the acknowledge for it
        pChannel->hwndSvr = NULL;
        pChannel->iExtraTerms = NULL;
        pChannel->iAwaitAck = NULL;
        //CoSetAckState(pChannel->pCI, FALSE);
        intrDebugOut((DEB_ITRACE,"::OnTerminate(%x) bTerminating SERVERCALLEX_ISHANDLED\n",this));
        pChannel->SetCallState(SERVERCALLEX_ISHANDLED);
    }
    Puts ("OnTerminate() done.\n");
    return NOERROR;
}




INTERNAL_(BOOL) CDdeObject::AllocDdeChannel
    (LPDDE_CHANNEL * lplpChannel, BOOL fSysWndProc)
{
    intrDebugOut((DEB_ITRACE,
          "CDdeObject::AllocDdeChannel(%x,fSysWndClass=%x)\n",
          this,
          fSysWndProc));

    // Initialize DDE window class if not already done.
    if (!DDELibMain(NULL, 0, 0, NULL))
    {
        intrAssert(!"CDdeObject::AllocDdeChannel DDELibMain failed");
        return FALSE;
    }

    //
    // Now try to allocate a channel
    //

    if (!(*lplpChannel =  (LPDDE_CHANNEL) new DDE_CHANNEL ))
    {
        //
        // This failed
        //
        intrAssert(*lplpChannel != NULL);
        return FALSE;
    }

    (*lplpChannel)->m_cRefs = 1;
    (*lplpChannel)->hwndSvr         = NULL;
    (*lplpChannel)->bTerminating    = FALSE;
    (*lplpChannel)->wTimer          = NULL;
    (*lplpChannel)->hDdePoke        = NULL;
    (*lplpChannel)->hCommands       = NULL;
    (*lplpChannel)->hopt            = NULL;
    (*lplpChannel)->bFreedhopt      = FALSE;
    (*lplpChannel)->dwStartTickCount= 0;
    (*lplpChannel)->msgFirst        = 0;
    (*lplpChannel)->msgLast         = 0;
    (*lplpChannel)->fRejected       = FALSE;
    (*lplpChannel)->wChannelDeleted = 0;
    //(*lplpChannel)->pCI             = NULL;
    (*lplpChannel)->pCD             = NULL;

    if (!((*lplpChannel)->hwndCli = DdeCreateWindowEx(0,
                                                      gOleDdeWindowClass,
                                                      TEXT("DDE Channel"),
                                                      WS_CHILD,
                                                      0,0,0,0,
                                                      (HWND)TLSGetDdeClientWindow(),
                                                      NULL,
                                                      hinstSO,
                                                      NULL)))
    {
        intrAssert (!"Could not create AllocDdeChannel window");

        //
        // DeleteChannel will give back the CallControl
        //

        DeleteChannel(*lplpChannel);
        *lplpChannel = NULL;
        return FALSE;
    }

    // set the appropriate window procedure
    if (fSysWndProc)
    {
        SetWindowLongPtr ((*lplpChannel)->hwndCli, GWLP_WNDPROC, (LONG_PTR)SysWndProc);
    }
    else
    {
        SetWindowLongPtr ((*lplpChannel)->hwndCli, GWLP_WNDPROC, (LONG_PTR)ClientDocWndProc);
    }

    SetWindowLongPtr ((*lplpChannel)->hwndCli, 0, (LONG_PTR) this);
    return TRUE;
}



INTERNAL_(BOOL) CDdeObject::InitSysConv()
{
    DWORD dwResult;
    intrDebugOut((DEB_ITRACE,"CDdeObject::InitSysConv(%x)\n",this));

    dwResult = wInitiate (m_pSysChannel, m_aClass, aOLE);
    if (!dwResult)
    {
       intrDebugOut((DEB_ITRACE,"\t::InitSysConv(%x) Try aSysTopic\n",this));
       dwResult = wInitiate (m_pSysChannel, m_aClass, aSysTopic);
    }

    if (!dwResult)
    {
       intrDebugOut((DEB_ITRACE,"\t::InitSysConv(%x) is failing\n",this));
    }
    return(dwResult);
}



INTERNAL_(void) CDdeObject::SetTopic(ATOM aTopic)
{
    intrDebugOut((DEB_ITRACE,"CDdeObject::SetTopic(%x)\n",this));
    intrAssert(wIsValidAtom(aTopic));
    if (m_aTopic)
        GlobalDeleteAtom (m_aTopic);

    m_aTopic = aTopic;
}



INTERNAL CDdeObject::TermConv
    (LPDDE_CHANNEL pChannel,
    BOOL fWait)     // Default==TRUE.  FALSE only in ProxyManager::Disconnect
{
    intrDebugOut((DEB_ITRACE,
                  "CDdeObject::TermConv(%x,pChannel=%x)\n",
                  this,
                  pChannel));

    HRESULT hres;
    if (!pChannel)
    {
        return NOERROR;
    }

    pChannel->bTerminating = TRUE;

    hres = SendMsgAndWaitForReply(pChannel,
                                 AA_TERMINATE,
                                 WM_DDE_TERMINATE,
                                 0,
                                 FALSE,
                                 /*fStdCloseDoc*/FALSE,
                                 /*fDetectTerminate*/ FALSE,
                                 fWait);
    if (pChannel==m_pDocChannel)
    {
        DeclareVisibility (FALSE);
        if (!m_fDidSendOnClose)
        {
            SendOnClose();
        }
    }

    DeleteChannel (pChannel);
    intrDebugOut((DEB_ITRACE,"::TermConv(%x) returns %x\n",this,hres));
    return hres;
}




INTERNAL_(void) CDdeObject::DeleteChannel (LPDDE_CHANNEL pChannel)
{
    BOOL fDocChannel = FALSE;
    intrDebugOut((DEB_ITRACE,
                  "CDdeObject::DeleteChannel(%x,pChannel=%x)\n",
                  this,
                  pChannel));

    if (pChannel == NULL)
    {
        return;
    }

    if (pChannel == m_pDocChannel)
        fDocChannel = TRUE;



    // delete any data if we were in busy mode.
    wClearWaitState (pChannel);

    if (pChannel == m_pDocChannel)
    {
        intrDebugOut((DEB_ITRACE,
                      "::DeleteChannel(%x)Clean up pDocChannel\n",
                      this));

        // Cleanup per-conversation information
        m_fDidSendOnClose = FALSE;
        m_fDidStdCloseDoc = FALSE;
        m_ConnectionTable.Erase();
        m_iAdvSave = 0;
        m_iAdvClose= 0;
        m_fWasEverVisible = FALSE;
        m_fGotCloseData = FALSE;
        if (m_ptd)
        {
            delete m_ptd;
            m_ptd = NULL;
        }
        if (m_pstg)
        {
            m_pstg->Release();
            m_pstg = NULL;
        }
        if (m_pDataAdvHolder)
        {
            Verify (0==m_pDataAdvHolder->Release());
        }
        CreateDataAdviseHolder (&m_pDataAdvHolder);
        if (m_pOleAdvHolder)
        {
            m_pOleAdvHolder->Release(); // may not return 0 if we are
                                        // in a SendOnClose
        }
        CreateOleAdviseHolder (&m_pOleAdvHolder);
    }

    if (pChannel->hwndCli)
    {
        intrDebugOut((DEB_ITRACE,
                      "::DeleteChannel(%x)Destroy hwndCli(%x)\n",
                      this,
                      pChannel->hwndCli));

        Assert (IsWindow (pChannel->hwndCli));
        Assert (this==(CDdeObject *)GetWindowLongPtr (pChannel->hwndCli, 0));
        Verify (SSDestroyWindow (pChannel->hwndCli));
    }

    if (pChannel == m_pDocChannel)
    {
        m_pDocChannel = NULL;
    }
    else
    {
        intrAssert(pChannel == m_pSysChannel);
        m_pSysChannel = NULL;
    }


    // Channel will be deleted in the modallp.cpp
    // if flag is on.

    if (pChannel->wChannelDeleted == Channel_InModalloop)
    {
        intrDebugOut((DEB_ITRACE,
                      "::DeleteChannel(%x) Channel(%x) in Modal Loop\n",
                      this,pChannel));

        pChannel->wChannelDeleted = Channel_DeleteNow;
    }
    else
    {
        if (pChannel->ReleaseReference() == 0)
            pChannel = NULL;
    }

    if (fDocChannel)
        m_pDocChannel = pChannel;
}

const WCHAR  EMB_STR[]= OLESTR(" -Embedding ") ;

INTERNAL_(BOOL) CDdeObject::LaunchApp (void)
{
    intrDebugOut((DEB_ITRACE,"CDdeObject::LaunchApp(%x)\n",this));

    STARTUPINFO startInfo;
    PROCESS_INFORMATION procInfo;
    BOOL        fProcStarted;
    WCHAR       cmdline[MAX_PATH + sizeof(EMB_STR)];
    WCHAR       exeName[MAX_PATH + sizeof(cmdline)] = {0};
    //
    // Init all fields of startInfo to zero
    //
    memset((void *)&startInfo,0,sizeof(startInfo));
    startInfo.cb = sizeof(STARTUPINFO);

    //
    // The normal startup is set here.
    //
    startInfo.wShowWindow = SW_NORMAL;
    startInfo.dwFlags = STARTF_USESHOWWINDOW;

    m_fDidLaunchApp = FALSE;


    DWORD dw;

    //
    // Do our best to find the path
    //
    intrAssert(wIsValidAtom(m_aExeName));

    if (m_aExeName == 0)
    {
        //
        // There is no exe name to execute. Can't start it.
        //
        return(FALSE);
    }

    dw = SearchPath(NULL,wAtomName(m_aExeName),NULL,MAX_PATH,exeName, NULL);

    if ((dw == 0) || (dw > MAX_PATH))
    {
        intrDebugOut((DEB_ITRACE,
                      "::LaunchApp(%x) SearchPath failed. Do Default",this));
        //
        // SearchPath failed. Use the default
        //
        GlobalGetAtomName (m_aExeName, exeName, MAX_PATH);
    }

    memcpy(cmdline, EMB_STR,sizeof(EMB_STR));

    if (m_ulObjType == OT_LINK)
    {
        intrAssert(wIsValidAtom(m_aTopic));
       // File name
       Assert (wAtomName (m_aTopic));

       lstrcatW (cmdline, wAtomName (m_aTopic));
    }

    if (m_clsid == CLSID_ExcelWorksheet  // apps that show themselves
        || m_clsid == CLSID_ExcelMacrosheet // when they're not supposed to
        || m_clsid == CLSID_ExcelChart
        || m_clsid == CLSID_PBrush)
    {
       startInfo.wShowWindow = SW_SHOWMINNOACTIVE;
    }

    //
    // According to the spec, the most robust way to start the app is to
    // only use a cmdline that consists of the exe name, followed by the
    // command line arguments.
    //

    lstrcatW(exeName,cmdline);

    Assert((lstrlenW(exeName)+1) < sizeof(exeName));

    intrDebugOut((DEB_ITRACE,
                  "CDdeObject::LaunchApp(%x) Starting '%ws' \n",
                  this,
                  exeName));

    if (IsWOWThread() && IsWOWThreadCallable())
    {
        HRESULT hr;

        hr = g_pOleThunkWOW->WinExec16(exeName, startInfo.wShowWindow);

        fProcStarted = SUCCEEDED(hr);

#if DBG==1
        if (!fProcStarted)
        {
            intrDebugOut((DEB_ITRACE,
                        "::LaunchApp(%x) in Wow FAILED(%x) TO START %ws \n",
                        this,
                        hr,
                        exeName));
        }
#endif
    }
    else
    {
        fProcStarted = CreateProcess(NULL,
                                     exeName,
                                     NULL,
                                     NULL,
                                     FALSE,
                                     0,
                                     NULL,
                                     NULL,
                                     &startInfo,
                                     &procInfo);
        if (fProcStarted)
        {
           //
           // Let's give the server a chance to register itself. On NT,
           // CreateProcess gets the other process going, but returns
           // to let it run asynchronously. This isn't good, since we
           // need some way of knowing when it has started, so we can
           // send the DDE_INITIATES 'after' they create their DDE
           // window.
           //
           // Maximum timeout we want here shall be set at 30 seconds.
           // This should give enough time for even a 16bit WOW app to
           // start. This number was picked by trial and error. Normal
           // apps that go into an InputIdle state will return as soon
           // as they are ready. Therefore, we normally won't wait
           // the full duration.
           //

           ULONG ulTimeoutDuration = 30000L;

           //
           // Now modify this start time to handle classes
           // that have known problems. This list includes:
           //

           switch(WaitForInputIdle(procInfo.hProcess, ulTimeoutDuration))
           {
           case 0:
               intrDebugOut((DEB_ITRACE,
                      "::LaunchApp, %ws started\n",
                      exeName));
                break;
           case WAIT_TIMEOUT:
               intrDebugOut((DEB_ITRACE,
                      "::LaunchApp, %ws wait timeout at %u (dec) ms. Go Anyway\n",
                      exeName,
                  ulTimeoutDuration));
               break;
           default:
               intrDebugOut((DEB_ITRACE,
                      "::LaunchApp, %ws unknown condition (%x)\n",
                      exeName,
                      GetLastError()));
           }
           //
           // We are already done with the Process and Thread handles
           //
           CloseHandle(procInfo.hProcess);
           CloseHandle(procInfo.hThread);
        }
        else
        {
            intrDebugOut((DEB_ITRACE,
                        "::LaunchApp(%x) FAILED(%x) TO START %ws \n",
                        this,
                        GetLastError(),
                        exeName));
        }
    }

    if (fProcStarted)
    {
        // If we ran the server, it should not be visible yet.
        DeclareVisibility (FALSE);
        m_fDidLaunchApp = TRUE;
    }

    return fProcStarted;
}


INTERNAL CDdeObject::MaybeUnlaunchApp (void)
{
    intrDebugOut((DEB_ITRACE,"CDdeObject::MaybeUnlaunchApp(%x)\n",this));
    if (m_fDidLaunchApp
        && !m_fDidGetObject
        && (m_clsid == CLSID_ExcelWorksheet
            || m_clsid == CLSID_ExcelMacrosheet
            || m_clsid == CLSID_ExcelChart))
    {
        return UnlaunchApp();
    }
    return NOERROR;
}




INTERNAL CDdeObject::UnlaunchApp (void)
{
    intrDebugOut((DEB_ITRACE,"CDdeObject::UnlaunchApp(%x)\n",this));
    HANDLE hCommands;
    HRESULT hresult = NOERROR;
    RetZS (AllocDdeChannel (&m_pSysChannel, TRUE), E_OUTOFMEMORY);
    ErrZS (InitSysConv(), E_UNEXPECTED);
    ErrRtnH (PostSysCommand (m_pSysChannel,(LPSTR) &achStdExit, /*bStdNew*/FALSE,
                             /*fWait*/FALSE));
    hCommands = m_pSysChannel->hCommands;
    hresult = TermConv (m_pSysChannel);

    // Since Excel incorrectly did not send an ACK, we need to
    // delete the handle ("[StdExit]") in the DDE message ourselves.
    if (hCommands)
        GlobalFree (hCommands);

    return hresult;

  errRtn:
    DeleteChannel (m_pSysChannel);
    return hresult;
}




INTERNAL CDdeObject::Execute
    (LPDDE_CHANNEL pChannel,
    HANDLE hdata,
    BOOL fStdCloseDoc,
    BOOL fWait,
    BOOL fDetectTerminate)
{
    intrDebugOut((DEB_ITRACE,"CDdeObject::Execute(%x,hdata=%x)\n",this,hdata));

    LPARAM lp=MAKE_DDE_LPARAM(WM_DDE_EXECUTE,0, hdata);

    HRESULT hr = SendMsgAndWaitForReply (pChannel,
                                         AA_EXECUTE,
                                         WM_DDE_EXECUTE,
                                         lp,
                                         TRUE,
                                         fStdCloseDoc,
                                         fDetectTerminate,
                                         fWait);
    if (hr == DDE_CHANNEL_DELETED)
    {
        // the channel was deleted already so dont access it!
        return S_OK;
    }

    if (SUCCEEDED(hr))
    {
        if (fStdCloseDoc)
        {
            // Prepare to free the handle if Excel does not send an Ack
            pChannel->hCommands = hdata;
        }
        return hr;
    }

    GlobalFree (hdata);
    return ReportResult(0, RPC_E_DDE_POST, 0, 0);
}




INTERNAL_(HRESULT) CDdeObject::AdviseOn (CLIPFORMAT cfFormat, int iAdvOn)
{
    intrDebugOut((DEB_ITRACE,
                  "CDdeObject::AdviseOn(%x,cfFormat=%x,iAdvOn=%x)\n",
                  this,
                  cfFormat,
                  iAdvOn));

    HANDLE          hopt=NULL;
    DDEADVISE *  lpopt=NULL;
    ATOM            aItem=(ATOM)0;
    HRESULT         hresult = ReportResult(0, E_UNEXPECTED, 0, 0);

    RetZ (m_pDocChannel);

    if (NOERROR == m_ConnectionTable.Lookup (cfFormat, NULL))
    {
        // We already got a call to DataObject::Advise on this format.
        intrDebugOut((DEB_ITRACE,
                      "::AdviseOn(%x) Advise had been done on cfFormat=%x\n",
                      this,
                      cfFormat));
        return NOERROR;
    }

    UpdateAdviseCounts (cfFormat, iAdvOn, +1);

    if (m_fDidSendOnClose)
    {
        intrDebugOut((DEB_ITRACE,"::AdviseOn(%x)Ignoring Advise because we are closing\n",this));
        return NOERROR;
    }

    if (!(hopt = GlobalAlloc (GMEM_DDESHARE | GMEM_ZEROINIT, sizeof(DDEADVISE))))
    {
        intrDebugOut((DEB_ITRACE,"::AdviseOn(%x)GlobalAlloc returned NULL\n",this));
        return ReportResult(0, E_OUTOFMEMORY, 0, 0);
    }


    if (!(lpopt = (DDEADVISE FAR *) GlobalLock (hopt)))
    {
        intrDebugOut((DEB_ITRACE,"::AdviseOn(%x)GlobalLock returned NULL\n",this));
        GlobalFree (hopt);
        return ReportResult(0, E_OUTOFMEMORY, 0, 0);
    }

    lpopt->fAckReq = TRUE;
    lpopt->fDeferUpd = FALSE;
    lpopt->cfFormat = cfFormat;
    m_pDocChannel->hopt = hopt;

    if (iAdvOn == ON_RENAME)
    {
        aItem = wDupAtom (aStdDocName);
        intrAssert(wIsValidAtom(aItem));
    }
    else
    {
        intrAssert(wIsValidAtom(m_aItem));
        aItem = wExtendAtom (m_aItem, iAdvOn);
        intrAssert(wIsValidAtom(aItem));
    }

    intrDebugOut((DEB_ITRACE,
                  "::AdviseOn(%x) lpopt->cfFormat = %x, aItem=%x (%ws)\n",
                  this,
                  lpopt->cfFormat,
                  aItem,
                  wAtomName(aItem)));

    GlobalUnlock (hopt);

    LPARAM lp=MAKE_DDE_LPARAM(WM_DDE_ADVISE,hopt,aItem);
    hresult =SendMsgAndWaitForReply (m_pDocChannel,
                                     AA_ADVISE,
                                     WM_DDE_ADVISE,
                                     lp,
                                     TRUE);
    if ( FAILED(hresult) )
    {
        intrDebugOut((DEB_ITRACE,"::AdviseOn(%x)wPostMessageToServer failed\n",this));
        if (aItem)
            GlobalDeleteAtom (aItem);
        
        if (hopt && !m_pDocChannel->bFreedhopt)
            GlobalFree (hopt);
    
        hresult = (RPC_E_DDE_NACK == hresult) ? DV_E_CLIPFORMAT : hresult;
        intrDebugOut((DEB_ITRACE,
                      "::AdviseOn(%x) errRet, AdviseRejected, returning %x\n",
                      this,hresult));
    }

    return hresult;
}

INTERNAL CDdeObject::UpdateAdviseCounts
    (CLIPFORMAT cf,
    int         iAdvOn,
    signed int  cDelta)
{
    intrDebugOut((DEB_ITRACE,"CDdeObject::UpdateAdviseCounts(%x)\n",this));
    if (cf==g_cfBinary)
        return NOERROR;

    // Update m_iAdv* flags
    #define macro(Notif, NOTIF) \
    if (iAdvOn == ON_##NOTIF)   \
       m_iAdv##Notif += cDelta; \
    if (m_iAdv##Notif < 0)      \
        m_iAdv##Notif = 0;      \
    else if (m_iAdv##Notif > 2) \
        m_iAdv##Notif = 2;

    macro (Close, CLOSE)
    macro (Save,  SAVE)
    macro (Change,CHANGE)
    #undef macro

    Assert (m_iAdvClose < 3 && m_iAdvSave < 3 && m_iAdvChange < 3);
    Assert (m_iAdvClose >= 0 && m_iAdvSave >= 0 && m_iAdvChange >= 0);

    if (cf == g_cfNative)
    {
        if (iAdvOn != ON_CHANGE)
            m_fDidAdvNative = (cDelta > 0);
        else
            intrDebugOut((DEB_ITRACE,
                          "::UpdateAdviseCounts(%x)Asked advise on cfNative\n",
                          this));
    }

    return NOERROR;
}




INTERNAL CDdeObject::UnAdviseOn (CLIPFORMAT cfFormat, int iAdvOn)
{
    intrDebugOut((DEB_ITRACE,
                  "CDdeObject::UnAdviseOn(%x,cfFormat=%x,iAdvOn=%x)\n",
                  this,cfFormat,iAdvOn));
    HRESULT hr;
    ATOM aItem= (ATOM)0;

    RetZ (m_pDocChannel);
    UpdateAdviseCounts (cfFormat, iAdvOn, -1);
    if (m_fDidSendOnClose)
    {
        intrDebugOut((DEB_ITRACE,
                      "CDdeObject::UnAdviseOn(%x) Ignored because closing\n",
                      this));
        return NOERROR;
    }
    if (wTerminateIsComing (m_pDocChannel))
    {
        // We already did a StdCloseDocument, so the server is not willing
        // to do an unadvise even though the default hanlder asked us to.
        intrDebugOut((DEB_ITRACE,
                      "CDdeObject::UnAdviseOn(%x) Terminate coming\n",
                      this));
        return NOERROR;
    }

    if (iAdvOn == ON_RENAME)
    {
        aItem = wDupAtom (aStdDocName);
        intrAssert(wIsValidAtom(aItem));
    }
    else
    {
        intrAssert(wIsValidAtom(m_aItem));
        aItem = wExtendAtom (m_aItem, iAdvOn);
        intrAssert(wIsValidAtom(aItem));
    }


    // Wait For Reply
    hr = SendMsgAndWaitForReply (m_pDocChannel,
                                 AA_UNADVISE,
                                 WM_DDE_UNADVISE,
                                 MAKE_DDE_LPARAM (WM_DDE_UNADVISE,cfFormat,aItem),
                                 FALSE,
                                 FALSE);
    if (hr != NOERROR && hr != RPC_E_DDE_NACK)
    {
        if (aItem)
            GlobalDeleteAtom (aItem);
        intrDebugOut((DEB_ITRACE,
                      "::UnAdviseOn(%x)WaitForReply returns %x\n",
                      this));
        return hr;
    }


    if (cfFormat==m_cfPict)
    {
        if (m_hPict)
        {
            // Invalidate the cache so when someone explicitly asks for
            // the data, they will get fresh data.
            wFreeData (m_hPict, m_cfPict, TRUE);
            m_hPict = (HANDLE)0;
            m_cfPict = 0;
        }
    }

    // Due to a bug in the OLE1 libraries, unadvising on a presentation
    // format effectively unadvises on native.
    if (cfFormat != g_cfNative && m_fDidAdvNative)
    {
        if (iAdvOn == ON_SAVE)
        {
            // to reflect the fact that the native advise connection was lost
            m_iAdvSave--;
            m_fDidAdvNative = FALSE;
            RetErr (AdviseOn (g_cfNative, ON_SAVE));  // re-establish
        }
        else if (iAdvOn == ON_CLOSE)
        {
            // to reflect the fact that the native advise connection was lost
            m_iAdvClose--;
            m_fDidAdvNative = FALSE;
            RetErr (AdviseOn (g_cfNative, ON_CLOSE));
        }
    }

    return NOERROR;
}


//
// Post a message to a 1.0 server (callee) and wait for the acknowledge
//


INTERNAL CDdeObject::Poke
    (ATOM aItem, HANDLE hDdePoke)
{
    HRESULT hr;

    intrDebugOut((DEB_ITRACE,"CDdeObject::Poke(%x)\n",this));

    ATOM aTmpItem;

    intrAssert(wIsValidAtom(aItem));

    aTmpItem = wDupAtom (aItem);

    intrAssert(wIsValidAtom(aTmpItem));

    m_pDocChannel->hDdePoke = hDdePoke;

    LPARAM lp = MAKE_DDE_LPARAM(WM_DDE_POKE,hDdePoke,aTmpItem);
    hr = SendMsgAndWaitForReply (m_pDocChannel,
                                 AA_POKE,
                                 WM_DDE_POKE,
                                 lp,
                                 TRUE);
    if (S_OK == hr)
    {
        intrDebugOut((DEB_ITRACE,"::Poke(%x) returning %x\n",this,hr));
        return hr;
    }

    intrDebugOut((DEB_ITRACE,"::Poke(%x)wPostMessage failed %x\n",this,hr));
    // Error case
    if (aTmpItem)
        GlobalDeleteAtom (aTmpItem);
    wFreePokeData (m_pDocChannel, m_bOldSvr && m_aClass==aMSDraw);
    hr = RPC_E_DDE_POST;
    intrDebugOut((DEB_ITRACE,"::Poke(%x)wPostMessage returns %x\n",this,hr));
    return hr;

}

INTERNAL CDdeObject::PostSysCommand
    (LPDDE_CHANNEL pChannel,
    LPCSTR szCmd,
    BOOL fStdNew,
    BOOL fWait)
{
    intrDebugOut((DEB_ITRACE,
                  "CDdeObject::PostSysCommand(%x,szCmd=%s,fStdNew=%x,fWait=%x)\n",
                  this,
                  szCmd,
                  fStdNew,
                  fWait));

    ULONG    size;
    WORD   len;
    LPSTR  lpdata= NULL;
    HANDLE hdata = NULL;
    HRESULT hresult;


    #define LN_FUDGE        16     // [],(), 3 * 3 (2 double quotes and comma)

    len =  (WORD)strlen (szCmd);

    // for StdNewDocument command add class name
    if (fStdNew)
        len = len + (WORD) wAtomLenA (m_aClass);

    // Now add the document length.
    len = len + (WORD) wAtomLenA (m_aTopic);

    // now add the fudge factor for the Quotes etc.
    len += LN_FUDGE;

    // allocate the buffer and set the command.
    if (!(hdata = GlobalAlloc (GMEM_DDESHARE, size = len)))
        return ReportResult(0, E_OUTOFMEMORY, 0, 0);

    if (!(lpdata = (LPSTR)GlobalLock (hdata))) {
        Assert (0);
        GlobalFree (hdata);
        return ReportResult(0, E_OUTOFMEMORY, 0, 0);
    }

    StringCbCopyA(lpdata, size, (LPSTR)"["); // [
    StringCbCatA(lpdata, size, szCmd);      // [StdCmd
    if (strcmp (szCmd, "StdExit"))
    {
        StringCbCatA(lpdata, size, "(\"");      // [StdCmd("

        if (fStdNew)
        {
            len = (WORD)strlen (lpdata);
            GlobalGetAtomNameA (m_aClass, (LPSTR)lpdata + len, size-len);
                                                // [StdCmd("class
            StringCbCatA(lpdata, size, "\",\"");          // [StdCmd("class","
        }

        len = (WORD)strlen (lpdata);
        // now get the topic name.
        GlobalGetAtomNameA (m_aTopic, lpdata + len, (WORD)size - len);
                                                // [StdCmd("class","topic
        StringCbCatA(lpdata, size, "\")");                // [StdCmd("class","topic")
    }
    StringCbCatA(lpdata, size, "]");
    Assert (strlen(lpdata) < size);
    intrDebugOut((DEB_ITRACE,"::PostSysCommand(%x) hData(%s)\n",this,lpdata));
    GlobalUnlock (hdata);

    // return Execute (m_pSysChannel, hdata, /*fStdClose*/FALSE, fWait);
    // REVIEW: this fixed bug 1856 (johannp)
    // JasonFul - does it break something else?

    hresult = Execute (m_pSysChannel,
                       hdata,
                       /*fStdClose*/FALSE,
                       fWait,
                       /*fDetectTerminate*/ TRUE);

    intrDebugOut((DEB_ITRACE,"::PostSysCommand(%x) returns:%x\n",this,hresult));
    return hresult;

}

//+---------------------------------------------------------------------------
//
//  Method:     CDdeObject::KeepData
//
//  Synopsis: Given the DDEDATA structure from a WM_DDE_DATA message, extract
//              the real data and keep it till GetData or Save is done.
//
//
//  Effects:
//
//  Arguments:  [pChannel] --
//              [hDdeData] --
//
//  Requires:
//
//  Returns:    E_OUTOFMEMORY or E_HANDLE if failure, NOERROR if success
//
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:
//
//  History:    5-14-94   kevinro   Commented
//
//  Notes:
//
//----------------------------------------------------------------------------
INTERNAL CDdeObject::KeepData
    (LPDDE_CHANNEL pChannel, HANDLE hDdeData)
{
    intrDebugOut((DEB_ITRACE,"CDdeObject::KeepData(%x)\n",this));

    DDEDATA *       lpDdeData = NULL;
    HANDLE          hData     = NULL;
    CLIPFORMAT      cfFormat;



    if (!(lpDdeData = (DDEDATA *) (GlobalLock (hDdeData))))
    {
        return E_OUTOFMEMORY;;
    }


    cfFormat = lpDdeData->cfFormat;
    intrDebugOut((DEB_ITRACE,
                  "::KeepData(%x) Keeping cfFormat=%x\n",
                  this,
                  cfFormat));

    GlobalUnlock (hDdeData);

    // Possible Side effect of wHandleFromDdeData() is the freeing of hDdeData
    if (!(hData = wHandleFromDdeData (hDdeData))
        || !wIsValidHandle (hData, cfFormat) )
    {
        Assert(0);
        return ReportResult(0, E_OUTOFMEMORY, 0, 0);
    }

    if (cfFormat == g_cfNative) {
        if (m_hNative)
            GlobalFree (m_hNative);
        // Keep the native data
        RetErr (wTransferHandle (&m_hNative, &hData, cfFormat));
    }
    else if (cfFormat == CF_METAFILEPICT ||
             cfFormat == CF_BITMAP       ||
             cfFormat == CF_DIB)
    {
        if (m_hPict)
            wFreeData (m_hPict, m_cfPict, TRUE);
        m_cfPict = cfFormat;
        // Keep the presentation data
        RetErr (wTransferHandle (&m_hPict, &hData, cfFormat));

#ifdef OLD
        // Remember size of picture so we can return
        // a reasonable answer for GetExtent
        if (cfFormat == CF_METAFILEPICT)
        {
            LPMETAFILEPICT  lpMfp = (LPMETAFILEPICT) GlobalLock (m_hPict);
            if (NULL==lpMfp)
                return E_HANDLE;
            UpdateExtent (m_cxContentExtent, lpMfp->xExt);
            UpdateExtent (m_cyContentExtent, lpMfp->yExt);
            GlobalUnlock (m_hPict);
        }
        else if (cfFormat==CF_BITMAP)
        {
            BITMAP bm;
            if (0==GetObject (m_hPict, sizeof(BITMAP), (LPVOID) &bm))
                return E_HANDLE;
            UpdateExtent (m_cxContentExtent,
                            wPixelsToHiMetric (bm.bmWidth, giPpliX));
            UpdateExtent (m_cyContentExtent,
                            wPixelsToHiMetric (bm.bmHeight,giPpliY));
        }
        else if (cfFormat==CF_DIB)
        {
            BITMAPINFOHEADER * pbminfohdr;
            pbminfohdr = (BITMAPINFOHEADER *) GlobalLock (m_hPict);
            if (NULL==pbminfohdr)
                return E_HANDLE;
            UpdateExtent (m_cxContentExtent,
                            wPixelsToHiMetric (pbminfohdr->biWidth, giPpliX));
            UpdateExtent (m_cyContentExtent,
                             wPixelsToHiMetric (pbminfohdr->biHeight,giPpliY));
            GlobalUnlock (m_hPict);
        }
#endif

    }
    else
    {
        if (m_hExtra)
            wFreeData (m_hExtra, m_cfExtra, TRUE);
        m_cfExtra = cfFormat;
        wTransferHandle (&m_hExtra, &hData, cfFormat);
    }

    return NOERROR;
}


// IsFormatAvailable
//
// Does a temporary DDE_REQUEST to see if server supports a format
// Returns NOERROR if format is available.
//


INTERNAL CDdeObject::IsFormatAvailable
    (LPFORMATETC pformatetc)
{
    intrDebugOut((DEB_ITRACE,"CDdeObject::IsFormatAvailable(%x)\n",this));
    ATOM    aItem=(ATOM)0;
    HRESULT hresult;
    LPARAM lp = 0;

    Puts ("DdeObject::IsFormatAvailable\n");

    if (!HasValidLINDEX(pformatetc))
    {
        intrDebugOut((DEB_IERROR, "\t!HasValidLINDEX(pformatetc)\n"));
        return(DV_E_LINDEX);
    }

    if (0==pformatetc->cfFormat)
        return ResultFromScode (E_INVALIDARG);

    if (pformatetc->dwAspect & DVASPECT_ICON)
    {
        if (pformatetc->cfFormat==CF_METAFILEPICT)
        {
            // This is always available. we get it from the exe.
            return NOERROR;
        }
        // an icon must be a metafile
        return ResultFromScode (S_FALSE);
    }
    if (!(pformatetc->dwAspect & (DVASPECT_CONTENT | DVASPECT_DOCPRINT)))
    {
        // 1.0 does not support Thumb.
        return ReportResult(0, S_FALSE, 0, 0);
    }

    if (NOERROR == (hresult=m_ConnectionTable.Lookup (pformatetc->cfFormat, NULL)))
    {
        // We already got a call to DataObject::Advise on this format,
        // so it must be available.
        Puts ("DataObject::Advise had been done on this format.\n");
        return NOERROR;
    }
    else
    {
        // Lookup () didn't find this format.
        ErrZ (GetScode(hresult)==S_FALSE);
    }

    intrAssert(wIsValidAtom(m_aItem));
    aItem = wDupAtom (m_aItem);
    intrAssert(wIsValidAtom(aItem));

    lp = MAKE_DDE_LPARAM (WM_DDE_REQUEST,pformatetc->cfFormat,aItem);
    if(NOERROR==SendMsgAndWaitForReply (m_pDocChannel,
                                        AA_REQUESTAVAILABLE,
                                        WM_DDE_REQUEST,
                                        lp,
                                        TRUE))
        return NOERROR;

    // Last ditch effort: Advise
    if (NOERROR== AdviseOn (pformatetc->cfFormat, ON_SAVE))
    {
        // We cannot Unadvise because an OLE 1.0 bug
        // terminates DDE advise connections for ALL formats.
        //// UnAdviseOn (pformatetc->cfFormat, ON_SAVE);
        // Instead, just remember we did this advise.
        m_ConnectionTable.Add (0, pformatetc->cfFormat, ADVFDDE_ONSAVE);
        return NOERROR;
    }
    return ResultFromScode (S_FALSE);

errRtn:
    AssertSz (0, "Error in CDdeObject::IsFormatAvailable");
    Puth (hresult); Putn();
    if (aItem)
        GlobalDeleteAtom (aItem);

    return hresult;
}




INTERNAL CDdeObject::ChangeTopic
    (LPSTR lpszTopic)
{
    intrDebugOut((DEB_ITRACE,"CDdeObject::ChangeTopic(%x,lpszTopic=%s)\n",this,lpszTopic));
    HRESULT hresult;
    LPMONIKER pmkFile=NULL;
    LPMONIKER pmkItem=NULL;
    LPMONIKER pmkComp=NULL;
    LPMONIKER pmkNewName=NULL;
    ATOM aTopic = wGlobalAddAtomA (lpszTopic);
    intrAssert(wIsValidAtom(aTopic));

    // Yet-Another-Excel-Hack
    // Excel 4.0 sends StdDocumentName every time it saves,
    // whether or not the file name has actually changed. Bug 2957
    if (aTopic != m_aTopic)
    {
        ErrRtnH (CreateOle1FileMoniker (wAtomName(aTopic), m_clsid, &pmkFile));
        if (m_aItem)
        {
            intrAssert (wIsValidAtom (m_aItem));
            ErrRtnH (CreateItemMoniker (OLESTR("!"), wAtomName (m_aItem), &pmkItem));
            ErrRtnH (CreateGenericComposite (pmkFile, pmkItem, &pmkComp));
            (pmkNewName = pmkComp)->AddRef();
        }
        else
        {
            (pmkNewName = pmkFile)->AddRef();
        }
        RetZS (m_pOleAdvHolder, E_OUTOFMEMORY);
        RetZ (pmkNewName);
        ErrRtnH (m_pOleAdvHolder->SendOnRename (pmkNewName));
    }
    SetTopic (aTopic);
    hresult = NOERROR;

  errRtn:
    if (pmkFile)
        pmkFile->Release();
    if (pmkItem)
        pmkItem->Release();
    if (pmkComp)
        pmkComp->Release();
    if (pmkNewName)
        pmkNewName->Release();
    return hresult;
}


//+---------------------------------------------------------------------------
//
//  Method:     CDdeObject::ChangeItem
//
//  Synopsis:   Changes the m_aItem atom, using an Ansi string
//
//  Effects:
//
//  Arguments:  [szItem] -- Ansi string for the new item
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:
//
//  History:    5-12-94   kevinro   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
INTERNAL_(void) CDdeObject::ChangeItem
    (LPSTR szItem)
{
    intrDebugOut((DEB_ITRACE,"CDdeObject::ChangeItem(%x,szItem=%s)\n",this,szItem));
    intrAssert(wIsValidAtom(m_aItem));
    if (m_aItem)
        GlobalDeleteAtom (m_aItem);
    m_aItem = wGlobalAddAtomA (szItem);
    intrAssert(wIsValidAtom(m_aItem));
}




INTERNAL CDdeObject::DeclareVisibility
    (BOOL f,
    BOOL fCallOnShowIfNec)
{
    intrDebugOut((DEB_ITRACE,"CDdeObject::DelcareVisibility(%x)\n",this));
    if (f)
        m_fWasEverVisible = TRUE;
    if ((f && (!m_fVisible || !m_fCalledOnShow)) ||
        (!f && m_fVisible))
    {
        if (m_pOleClientSite && fCallOnShowIfNec && m_clsid != CLSID_Package)
        {
            m_pOleClientSite->OnShowWindow (f);
            m_fCalledOnShow = f;
        }
        m_fVisible = f;
    }
    return NOERROR;
}



INTERNAL CDdeObject::Update
    (BOOL fRequirePresentation)
{
    intrDebugOut((DEB_ITRACE,
                  "CDdeObject::Update(%x,fRequiredPresentation=%x)\n",
                  this,
                  fRequirePresentation));
    // Get latest data
    // OLE 1.0 spec says servers must supply metafile format.
    HRESULT hresult = RequestData ((CLIPFORMAT) (m_cfPict ? m_cfPict : CF_METAFILEPICT));
    if (fRequirePresentation && hresult!=NOERROR)
        return hresult;
    RetErr (RequestData (g_cfNative));
    SendOnDataChange (ON_CHANGE);
    return NOERROR;
}



INTERNAL CDdeObject::Save
    (LPSTORAGE pstg)
{
    intrDebugOut((DEB_ITRACE,"CDdeObject::Save(%x)\n",this));
    VDATEIFACE (pstg);
#ifdef OLE1INTEROP
    RetErr (StSave10NativeData (pstg, m_hNative, m_fOle1interop));
#else
    RetErr (StSave10NativeData (pstg, m_hNative, FALSE));
#endif
    if (m_aItem)
    {
        intrAssert(wIsValidAtom(m_aItem));
        RetErr (StSave10ItemName (pstg, wAtomNameA (m_aItem)));
    }
    RetErr (wWriteFmtUserType (pstg, m_clsid));
    return NOERROR;
}

/*
 *  IMPLEMENTATION of CUnknownImpl
 *
 */



STDMETHODIMP_(ULONG) NC(CDdeObject,CUnknownImpl)::AddRef()
{
    ChkD(m_pDdeObject);

    return InterlockedAddRef(&(m_pDdeObject->m_refs));
}


STDMETHODIMP_(ULONG) NC(CDdeObject,CUnknownImpl)::Release()
{
    ChkD(m_pDdeObject);
    Assert (m_pDdeObject->m_refs != 0);
    ULONG ul;

    if ((ul=InterlockedRelease(&(m_pDdeObject->m_refs))) == 0) {
        m_pDdeObject->m_ProxyMgr.Disconnect();

        delete m_pDdeObject;
        return 0;
    }
    return ul;
}




STDMETHODIMP NC(CDdeObject,CUnknownImpl)::QueryInterface(REFIID iid, LPLPVOID ppv)
{
    ChkD(m_pDdeObject);
    if (iid == IID_IUnknown) {
        *ppv = (void FAR *)&m_pDdeObject->m_Unknown;
        AddRef();
        return NOERROR;
    }
    else if (iid ==  IID_IOleObject)
        *ppv = (void FAR *) &(m_pDdeObject->m_Ole);
    else if (iid ==  IID_IDataObject)
        *ppv = (void FAR *) &(m_pDdeObject->m_Data);
    else if (iid ==  IID_IPersist || iid == IID_IPersistStorage)
        *ppv = (void FAR *) &(m_pDdeObject->m_PersistStg);
    else if (iid == IID_IProxyManager)
        *ppv = (void FAR *) &(m_pDdeObject->m_ProxyMgr);
    else if (iid == IID_IOleItemContainer
             || iid == IID_IOleContainer
             || iid == IID_IParseDisplayName)
        *ppv = (void FAR *) &(m_pDdeObject->m_OleItemContainer);
    else {
        Puts ("INTERFACE NOT FOUND \r\n");
        *ppv = NULL;
        return ReportResult(0, E_NOINTERFACE, 0, 0);
    }

    m_pDdeObject->m_pUnkOuter->AddRef();
    return NOERROR;
}


// implementations of IRpcStubBuffer methods
STDUNKIMPL_FORDERIVED(DdeObject, RpcStubBufferImpl)



STDMETHODIMP NC(CDdeObject,CRpcStubBufferImpl)::Connect
    (IUnknown * pUnkServer )
{
    // do nothing
    return S_OK;
}

STDMETHODIMP_(void) NC(CDdeObject,CRpcStubBufferImpl)::Disconnect
    ()
{
    // do nothing
}

STDMETHODIMP_(IRpcStubBuffer*) NC(CDdeObject,CRpcStubBufferImpl)::IsIIDSupported
    (REFIID riid)
{
    // do nothing
    return NULL;
}


STDMETHODIMP_(ULONG) NC(CDdeObject,CRpcStubBufferImpl)::CountRefs
    ()
{
    // do nothing
    return 1;
}

STDMETHODIMP NC(CDdeObject,CRpcStubBufferImpl)::DebugServerQueryInterface
    (void ** ppv )
{
    // do nothing
    *ppv = NULL;
    return S_OK;
}


STDMETHODIMP_(void) NC(CDdeObject,CRpcStubBufferImpl)::DebugServerRelease
    (void * pv)
{
    // do nothing
}

STDMETHODIMP NC(CDdeObject,CRpcStubBufferImpl)::Invoke
    (RPCOLEMESSAGE *_prpcmsg, IRpcChannelBuffer *_pRpcChannelBuffer)
{
    PDISPATCHDATA pdispdata = (PDISPATCHDATA) _prpcmsg->Buffer;
    return DispatchCall( pdispdata );
}


// implementation of IRpcChannelBuffer methods for DDE_CHANNEL
//

STDMETHODIMP DDE_CHANNEL::QueryInterface ( REFIID riid, LPVOID * ppvObj)
{
    *ppvObj = this;
    return S_OK;
}
STDMETHODIMP_(ULONG) DDE_CHANNEL::AddRef ()
{
    return 1;
}
STDMETHODIMP_(ULONG) DDE_CHANNEL::Release ()
{
    return 1;
}

// Provided IRpcChannelBuffer methods (for callback methods side)
HRESULT  DDE_CHANNEL::GetBuffer(
/* [in] */ RPCOLEMESSAGE __RPC_FAR *pMessage,
/* [in] */ REFIID riid)
{
    return S_OK;
}

HRESULT  DDE_CHANNEL::SendReceive(
/* [out][in] */ RPCOLEMESSAGE __RPC_FAR *pMessage,
/* [out] */ ULONG __RPC_FAR *pStatus)
{
    return S_OK;
}

HRESULT  DDE_CHANNEL::FreeBuffer(
/* [in] */ RPCOLEMESSAGE __RPC_FAR *pMessage)
{
    return S_OK;
}

HRESULT  DDE_CHANNEL::GetDestCtx(
/* [out] */ DWORD __RPC_FAR *pdwDestContext,
/* [out] */ void __RPC_FAR *__RPC_FAR *ppvDestContext)
{
    *pdwDestContext = MSHCTX_LOCAL;
    return S_OK;
}

HRESULT  DDE_CHANNEL::IsConnected( void)
{
    return S_OK;
}

// Provided IRpcChannelBuffer2 methods
HRESULT  DDE_CHANNEL::GetProtocolVersion(DWORD *pdwVersion)
{
    return S_OK;
}

STDMETHODIMP DDE_CHANNEL::ContextInvoke(
/* [out][in] */ RPCOLEMESSAGE *pMessage,
/* [in] */ IRpcStubBuffer *pStub,
/* [in] */ IPIDEntry *pIPIDEntry,
/* [out] */ DWORD *pdwFault)
{
    intrDebugOut((DEB_ITRACE,
                  "%p _IN DDE_CHANNEL::ContextInvoke(pMessage=%x,pStub=%x,pdwFault=%x)\n",
                  this,
                  pMessage,
                  pStub,
                  pdwFault));

    HRESULT hr = StubInvoke(pMessage, NULL, pStub, (IRpcChannelBuffer3 *)this, pIPIDEntry, pdwFault);

    intrDebugOut((DEB_ITRACE,
                  "%p _OUT DDE_CHANNEL::ContextInvoke returning hr=0x%x\n",
                  this,
                  hr));
    return(hr);
}

HRESULT  DDE_CHANNEL::GetBuffer2(
/* [in] */ RPCOLEMESSAGE __RPC_FAR *pMessage,
/* [in] */ REFIID riid)
{
    return GetBuffer(pMessage, riid);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\com\dde\client\ddeproxy.h ===
// ddeproxy.h
//
//   Used by ddeproxy.cpp ddeDO.cpp ddeOO.cpp
//
//   Author:  Jason Fuller    jasonful        24-July-1992
//
//   Modified:
//   Brian Chapman  bchapman    Nov 1995
//      - Removed declarations of wAllocDdeChannel() and wGetRequestResponse()
//       because they were not used or even defined anywhere.
//      - Fixed the indention of the declarations of the "worker" routines
//       section.
//   RichN                      Aug 1996
//      - Added Send and Receive to CRpcChannelBuffer implementation
//
#ifndef fDdeProxy_h
#define fDdeProxy_h

//
// One of the oleint.h routines redefines GlobalAlloc and friends
// to perform some memory tracking functions.
//
// This doesn't work in these files, since the tracking functions
// add tail checking, and size to the data structures. GlobalSize
// is a common function to use to determine how much data to
// serialize, plus it turns out that the other side of a DDE
// connection will often be the caller to free the memory.
//
// Therefore, OLE_DDE_NO_GLOBAL_TRACKING is used to disable this in the
// global header file ih\memapi.hxx. Check to insure this
// flag is set on the compile line
//
#if !defined(OLE_DDE_NO_GLOBAL_TRACKING)
error OLE_DDE_OLE_DDE_NO_GLOBAL_TRACKING must be defined to build this directory
#endif


#include <ole2int.h>
#include <callctrl.hxx>
#include <ddeint.h>
#include <dde.h>
#include <olerem.h>
#include <ole1cls.h>
#include <limits.h>
// For fDdeCodeInOle2Dll flag
#include <ddeatoms.h>
#include <ddepack.h>
#include <ddedebug.h>

#ifdef OLE_DEBUG_EXT
#include <ntsdexts.h>
#endif OLE_DEBUG_EXT

#include "ddechc.hxx"
#define LPCALLINFO LPVOID
#include "ddeerr.h"
#include "cnct_tbl.h"

#define MAX_STR         256

// number of .01 mm per inch
#define HIMETRIC_PER_INCH 2540

//#define fDebugOutput

// callback notifications
#define ON_CHANGE       0
#define ON_SAVE         1
#define ON_CLOSE        2
#define ON_RENAME       3

// AwaitAck values
#define AA_NONE         0
#define AA_REQUEST      1
#define AA_ADVISE       2
#define AA_POKE         3
#define AA_EXECUTE      4
#define AA_UNADVISE     5
#define AA_INITIATE     6
#define AA_TERMINATE 7
// A DDE_REQUEST to see if a format is available, not to keep the data.
#define AA_REQUESTAVAILABLE     8

// Bits for Positive WM_DDE_ACK
//#define POSITIVE_ACK 0x8000
//#define NEGATIVE_ACK 0x0000

#define DDE_CHANNEL_DELETED     0xffffffff

typedef DWORD CHK;
const DWORD     chkDdeObj = 0xab01;  // magic cookie


class DDE_CHANNEL : public CPrivAlloc, public IInternalChannelBuffer
{
public:
       // *** IUnknown methods ***
       STDMETHOD(QueryInterface) ( REFIID riid, LPVOID * ppvObj);
       STDMETHOD_(ULONG,AddRef) ();
       STDMETHOD_(ULONG,Release) ();

        // Provided IRpcChannelBuffer methods (for server side)
        STDMETHOD(GetBuffer)(
            /* [in] */ RPCOLEMESSAGE __RPC_FAR *pMessage,
            /* [in] */ REFIID riid);

        STDMETHOD(SendReceive)(
            /* [out][in] */ RPCOLEMESSAGE __RPC_FAR *pMessage,
            /* [out] */ ULONG __RPC_FAR *pStatus);

        STDMETHOD(FreeBuffer)(
            /* [in] */ RPCOLEMESSAGE __RPC_FAR *pMessage);

        STDMETHOD(GetDestCtx)(
            /* [out] */ DWORD __RPC_FAR *pdwDestContext,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvDestContext);

        STDMETHOD(IsConnected)( void);
        STDMETHOD(GetProtocolVersion)( DWORD *pdwVersion );

        // Provided IRpcChannelBuffer2 methods (not implemented)
        STDMETHODIMP Send(RPCOLEMESSAGE *pMsg, ULONG *pulStatus)
        {
          Win4Assert(FALSE);
          return E_NOTIMPL;
        }
        STDMETHODIMP Receive(RPCOLEMESSAGE *pMsg, ULONG uSize, ULONG *pulStatus)
        {
          Win4Assert(FALSE);
          return E_NOTIMPL;
        }

        // Provided IRpcChannelBuffer3 methods (for client side)
        STDMETHOD(SendReceive2)(
            /* [out][in] */ RPCOLEMESSAGE __RPC_FAR *pMessage,
            /* [out] */ ULONG __RPC_FAR *pStatus);

        STDMETHOD(ContextInvoke)(
            /* [out][in] */ RPCOLEMESSAGE *pMessage,
            /* [in] */ IRpcStubBuffer *pStub,
            /* [in] */ IPIDEntry *pIPIDEntry,
            /* [out] */ DWORD *pdwFault);

        STDMETHOD(GetBuffer2)(
            /* [in] */ RPCOLEMESSAGE __RPC_FAR *pMessage,
            /* [in] */ REFIID riid);
            
        // Provided IRpcChannelBuffer3 methods (not implemented)
        STDMETHODIMP Send2(RPCOLEMESSAGE *pMsg, ULONG *pulStatus)
        {
          Win4Assert(FALSE);
          return E_NOTIMPL;
        }
        STDMETHODIMP Receive2(RPCOLEMESSAGE *pMsg, ULONG uSize, ULONG *pulStatus)
        {
          Win4Assert(FALSE);
          return E_NOTIMPL;
        }

        STDMETHODIMP Cancel        ( RPCOLEMESSAGE *pMsg )
                                                      { return E_NOTIMPL; }
        STDMETHODIMP GetCallContext( RPCOLEMESSAGE *pMsg,
                                     REFIID riid,
                                     void **pInterface )
                                                      { return E_NOTIMPL; }
        STDMETHODIMP GetDestCtxEx  ( RPCOLEMESSAGE *pMsg,
                                     DWORD *pdwDestContext,
                                     void **ppvDestContext )
                                                      { return E_NOTIMPL; }
        STDMETHODIMP GetState      ( RPCOLEMESSAGE *pMsg,
                                     DWORD *pState )
                                                      { return E_NOTIMPL; }
        STDMETHODIMP RegisterAsync ( RPCOLEMESSAGE *pMsg,
                                     IAsyncManager *pComplete )
                                                      { return E_NOTIMPL; }

        void SetCallState(SERVERCALLEX ServerCall, HRESULT hr = S_OK);

        // Provided IAsyncRpcChannelBuffer method (not implemented)
        STDMETHODIMP Send(RPCOLEMESSAGE *pMsg, ISynchronize*, ULONG *pulStatus)
        {
          Win4Assert(FALSE);
          return E_NOTIMPL;
        }
        STDMETHOD(Receive)  (RPCOLEMESSAGE *pMsg, ULONG *pulStatus)
        {
            Win4Assert(FALSE);
            return E_NOTIMPL;
        }



    

       ULONG   AddReference()
       {
           return ++m_cRefs;
       }
       ULONG   ReleaseReference()
       {
           if (--m_cRefs == 0)
           {
               delete this;
               return(0);
           }
           return(m_cRefs);
       }

       ULONG    m_cRefs;
       HWND     hwndCli;
       HWND     hwndSvr;
       BOOL     bTerminating;
       int      iExtraTerms;
       WORD     wTimer;
       DWORD    dwStartTickCount;
       WORD     msgFirst;
       WORD     msgLast;
       HWND     msghwnd;        //
       BOOL     fRejected;      // because fBusy flag set in DDE_ACK
       WORD     wMsg;
       LPARAM   lParam;
       int      iAwaitAck;
       HRESULT  hres;
       HANDLE   hopt;           // Memory blocks I may have to free for DDE_ADVISE
       HANDLE   hDdePoke;       // for DDE_POKE
       HANDLE   hCommands;      // for DDE_EXECUTE
       WORD     wChannelDeleted;
       PDDECALLDATA  pCD;
       SERVERCALLEX      CallState;
       BOOL		bFreedhopt;
} ;


#define Channel_InModalloop 1
#define Channel_DeleteNow   2


typedef DDE_CHANNEL * LPDDE_CHANNEL;
extern BOOL               bWndClassesRegistered;

#define hinstSO g_hmodOLE2
extern HMODULE g_hmodOLE2;

extern INTERNAL_(BOOL) wRegisterClasses (void);

#ifndef _MAC
extern CLIPFORMAT g_cfNative;
extern CLIPFORMAT g_cfBinary;
#endif

/*
 *     Definition of CDdeObject
 *
 */
class CMsgFilterInfo;
class  CDdeObject;

class CDdeObject : public CPrivAlloc
{
public:

       static INTERNAL_(LPUNKNOWN) Create (IUnknown * pUnkOuter,
                                    REFCLSID clsidClass,
                                    ULONG ulObjType = OT_EMBEDDED,
                                    ATOM aTopic = NULL,
                                    LPOLESTR szItem = NULL,
                                    CDdeObject * * ppdde = NULL,
                                    BOOL fAllowNullClsid = FALSE);

       INTERNAL_(void)  OnInitAck (LPDDE_CHANNEL pChannel, HWND hwndSvr);
       INTERNAL_(BOOL)  OnAck (LPDDE_CHANNEL pChannel, LPARAM lParam);
       INTERNAL_(void)  OnTimer (LPDDE_CHANNEL pChannel);
       INTERNAL                 OnData (LPDDE_CHANNEL pChannel, HANDLE hData,ATOM aItem);
       INTERNAL                 OnDataAvailable (LPDDE_CHANNEL pChannel, HANDLE hData,ATOM aItem);
       INTERNAL         OnTerminate (LPDDE_CHANNEL pChannel, HWND hwndPost);

       INTERNAL_(LPDDE_CHANNEL) GetSysChannel(void)
       { return m_pSysChannel; }

       INTERNAL_(LPDDE_CHANNEL) GetDocChannel(void)
       { return m_pDocChannel; }

       INTERNAL_(BOOL)  AllocDdeChannel(LPDDE_CHANNEL * lpChannel, BOOL fSysWndProc);
       INTERNAL_(BOOL)  InitSysConv (void);
       INTERNAL_(void)  SetTopic (ATOM aTopic);

       INTERNAL         SendOnDataChange (int iAdvOpt);
       INTERNAL         OleCallBack (int iAdvOpt,LPDDE_CHANNEL pChannel);

       BOOL                     m_fDoingSendOnDataChange;
       ULONG                    m_cRefCount;

private:

                                CDdeObject (IUnknown * pUnkOuter);
                                ~CDdeObject (void);
       INTERNAL                 TermConv (LPDDE_CHANNEL pChannel,
                                          BOOL fWait=TRUE);
       INTERNAL_(void)          DeleteChannel (LPDDE_CHANNEL pChannel);
       INTERNAL_(BOOL)          LaunchApp (void);
       INTERNAL                         MaybeUnlaunchApp (void);
       INTERNAL                         UnlaunchApp (void);
       INTERNAL                 Execute (LPDDE_CHANNEL pChannel,
                                         HANDLE hdata,
                                         BOOL fStdCloseDoc=FALSE,
                                         BOOL fWait=TRUE,
                                         BOOL fDetectTerminate = TRUE);
       INTERNAL                 Advise (void);
       INTERNAL                 AdviseOn (CLIPFORMAT cfFormat,
                                          int iAdvOn);
       INTERNAL                 UnAdviseOn (CLIPFORMAT cfFormat,
                                            int iAdvOn);
       INTERNAL                 Poke (ATOM aItem, HANDLE hDdePoke);
       INTERNAL                 PostSysCommand (LPDDE_CHANNEL pChannel,
                                                LPCSTR szCmd,
                                                BOOL bStdNew=FALSE,
                                                BOOL fWait=TRUE);

       INTERNAL                SendMsgAndWaitForReply (LPDDE_CHANNEL pChannel,
                                              int iAwaitAck,
                                              WORD wMsg,
                                              LPARAM lparam,
                                              BOOL fFreeOnError,
                                              BOOL fStdCloseDoc = FALSE,
                                              BOOL fDetectTerminate = TRUE,
                                              BOOL fWait = TRUE);
       INTERNAL                 KeepData (LPDDE_CHANNEL pChannel, HANDLE hDdeData);
       INTERNAL                 ChangeTopic (LPSTR lpszTopic);
       INTERNAL_(void)          ChangeItem (LPSTR lpszItem);
       INTERNAL                 IsFormatAvailable (LPFORMATETC);
       INTERNAL_(BOOL)          CanCallBack(LPINT);
       INTERNAL                 RequestData (CLIPFORMAT);
       INTERNAL                 SetTargetDevice (const DVTARGETDEVICE *);
       INTERNAL                 DocumentLevelConnect (LPBINDCTX pbc);
       INTERNAL                 SendOnClose (void);
       INTERNAL                 UpdateAdviseCounts (CLIPFORMAT cf,
                                                    int iAdvOn,
                                                    signed int cDelta);
       INTERNAL                 DeclareVisibility (BOOL fVisible,
                                                   BOOL fCallOnShowIfNec=TRUE);
       INTERNAL                 Save (LPSTORAGE);
       INTERNAL                 Update (BOOL fRequirePresentation);

implementations:

       STDUNKDECL(CDdeObject,DdeObject)
       STDDEBDECL(CDdeObject,DdeObject)


    implement COleObjectImpl : IOleObject
    {
    public:
       COleObjectImpl (CDdeObject * pDdeObject)
        { m_pDdeObject = pDdeObject; }

       // *** IUnknown methods ***
       STDMETHOD(QueryInterface) ( REFIID riid, LPVOID * ppvObj);
       STDMETHOD_(ULONG,AddRef) ();
       STDMETHOD_(ULONG,Release) ();

       // *** IOleObject methods ***
       STDMETHOD(SetClientSite) ( LPOLECLIENTSITE pClientSite);
       STDMETHOD(GetClientSite) ( LPOLECLIENTSITE * ppClientSite);
       STDMETHOD(SetHostNames) ( LPCOLESTR szContainerApp, LPCOLESTR szContainerObj);
       STDMETHOD(Close) ( DWORD reserved);
       STDMETHOD(SetMoniker) ( DWORD dwWhichMoniker, LPMONIKER pmk);
       STDMETHOD(GetMoniker) ( DWORD dwAssign, DWORD dwWhichMoniker,LPMONIKER * ppmk);
       STDMETHOD(InitFromData) ( LPDATAOBJECT pDataObject,BOOL fCreation,DWORD dwReserved);
       STDMETHOD(GetClipboardData) ( DWORD dwReserved,LPDATAOBJECT * ppDataObject);

       STDMETHOD(DoVerb) ( LONG iVerb,
                    LPMSG lpmsg,
                    LPOLECLIENTSITE pActiveSite,
                    LONG lindex,
                    HWND hwndParent,
                    const RECT * lprcPosRect);

       STDMETHOD(EnumVerbs) ( IEnumOLEVERB * * ppenumOleVerb);
       STDMETHOD(Update) ();
       STDMETHOD(IsUpToDate) ();
       STDMETHOD(GetUserClassID) ( CLSID * pClsid);
       STDMETHOD(GetUserType) ( DWORD dwFormOfType, LPOLESTR * pszUserType);
       STDMETHOD(SetExtent) ( DWORD dwDrawAspect, LPSIZEL lpsizel);
       STDMETHOD(GetExtent) ( DWORD dwDrawAspect, LPSIZEL lpsizel);
       STDMETHOD(Advise)( IAdviseSink * pAdvSink, DWORD * pdwConnection) ;
       STDMETHOD(Unadvise) ( DWORD dwConnection);
       STDMETHOD(EnumAdvise) ( LPENUMSTATDATA * ppenumAdvise);
       STDMETHOD(GetMiscStatus) ( DWORD dwAspect, DWORD * pdwStatus);
       STDMETHOD(SetColorScheme) ( LPLOGPALETTE lpLogpal);

    private:
       CDdeObject * m_pDdeObject;
    };


    implement CDataObjectImpl :  IDataObject
    {
    public:
       CDataObjectImpl (CDdeObject * pDdeObject)
        { m_pDdeObject = pDdeObject; }
       // *** IUnknown methods ***
       STDMETHOD(QueryInterface) ( REFIID riid, LPVOID * ppvObj);
       STDMETHOD_(ULONG,AddRef) () ;
       STDMETHOD_(ULONG,Release) ();

       STDMETHOD(GetData) ( LPFORMATETC pformatetcIn,LPSTGMEDIUM pmedium );
       STDMETHOD(GetDataHere) ( LPFORMATETC pformatetc,LPSTGMEDIUM pmedium );
       STDMETHOD(QueryGetData) ( LPFORMATETC pformatetc );
       STDMETHOD(GetCanonicalFormatEtc) ( LPFORMATETC pformatetc,LPFORMATETC pformatetcOut);
       STDMETHOD(SetData) ( LPFORMATETC pformatetc, STGMEDIUM * pmedium, BOOL fRelease);
       STDMETHOD(EnumFormatEtc) ( DWORD dwDirection, LPENUMFORMATETC * ppenumFormatEtc);
       STDMETHOD(DAdvise) ( FORMATETC * pFormatetc, DWORD advf, LPADVISESINK pAdvSink, DWORD * pdwConnection) ;
       STDMETHOD(DUnadvise) ( DWORD dwConnection) ;
       STDMETHOD(EnumDAdvise) ( LPENUMSTATDATA * ppenumAdvise) ;

    private:
       CDdeObject * m_pDdeObject;
    };


   implement CPersistStgImpl : IPersistStorage
   {
   public:
        CPersistStgImpl (CDdeObject * pDdeObject)
        { m_pDdeObject  = pDdeObject; }

       STDMETHOD(QueryInterface) ( REFIID iid, LPVOID * ppvObj);
       STDMETHOD_(ULONG,AddRef) ();
       STDMETHOD_(ULONG,Release) ();
       STDMETHOD(GetClassID) ( LPCLSID pClassID);
       STDMETHOD(IsDirty) (void);
       STDMETHOD(InitNew) ( LPSTORAGE pstg);
       STDMETHOD(Load) ( LPSTORAGE pstg);
       STDMETHOD(Save) ( LPSTORAGE pstgSave, BOOL fSameAsLoad);
       STDMETHOD(SaveCompleted) ( LPSTORAGE pstgNew);
       STDMETHOD(HandsOffStorage) (void);

    private:
       CDdeObject * m_pDdeObject;
    };


   implement CProxyManagerImpl : IProxyManager
   {
   public:
       CProxyManagerImpl (CDdeObject * pDdeObject)
        { m_pDdeObject  = pDdeObject; }

       STDMETHOD(QueryInterface) ( REFIID iid, LPVOID * ppvObj);
       STDMETHOD_(ULONG,AddRef) ();
       STDMETHOD_(ULONG,Release) ();

       STDMETHOD(CreateServer)(REFCLSID rclsid, DWORD clsctx, void *pv);
       STDMETHOD_(BOOL, IsConnected)(void);
       STDMETHOD(LockConnection)(BOOL fLock, BOOL fLastUnlockReleases);
       STDMETHOD_(void, Disconnect)();

#ifdef SERVER_HANDLER
       STDMETHOD(CreateServerWithEmbHandler)(REFCLSID rclsid, DWORD clsctx, 
                                             REFIID riidEmbedSrvHandler, 
                                             void **ppEmbedSrvHandler, void *pv);
#endif // SERVER_HANDLER

       STDMETHOD(GetConnectionStatus)(void)               { return(S_OK); }
       STDMETHOD_(void,SetMapping)(void *pv)              { return; }
       STDMETHOD_(void *,GetMapping)()                    { return(NULL); }
       STDMETHOD_(IObjContext *,GetServerObjectContext)() { return(NULL); }

       STDMETHOD(Connect)(GUID oid, REFCLSID rclsid);
       STDMETHOD(EstablishIID)(REFIID iid, LPVOID FAR* ppv);

       private:
        CDdeObject * m_pDdeObject;
       };


   implement COleItemContainerImpl : IOleItemContainer
   {
   public:
       COleItemContainerImpl (CDdeObject * pDdeObject)
           { m_pDdeObject       = pDdeObject; }

        STDMETHOD(QueryInterface) ( REFIID iid, LPVOID * ppvObj);
       STDMETHOD_(ULONG,AddRef) ();
       STDMETHOD_(ULONG,Release) ();

       //  IParseDisplayName method
       STDMETHOD(ParseDisplayName) ( LPBC pbc,
                              LPOLESTR lpszDisplayName,
                              ULONG * pchEaten,
                              LPMONIKER * ppmkOut) ;

       //  IOleContainer methods
       STDMETHOD(EnumObjects) ( DWORD grfFlags,LPENUMUNKNOWN * ppenumUnk);

       STDMETHOD(LockContainer) (BOOL fLock);

       //  IOleItemContainer methods
       STDMETHOD(GetObject) ( LPOLESTR lpszItem,
                       DWORD dwSpeedNeeded,
                       LPBINDCTX pbc,
                       REFIID riid,
                       LPVOID * ppvObject) ;
       STDMETHOD(GetObjectStorage) ( LPOLESTR lpszItem,
                              LPBINDCTX pbc,
                              REFIID riid,
                              LPVOID * ppvStorage) ;

       STDMETHOD(IsRunning) ( LPOLESTR lpszItem) ;

    private:
       CDdeObject * m_pDdeObject;
    };


   implement CRpcStubBufferImpl : public IRpcStubBuffer
   {
   public:
       CRpcStubBufferImpl (CDdeObject * pDdeObject)
           { m_pDdeObject       = pDdeObject; }

       STDMETHOD(QueryInterface) ( REFIID iid, LPVOID * ppvObj);
       STDMETHOD_(ULONG,AddRef) ();
       STDMETHOD_(ULONG,Release) ();
       STDMETHOD(Connect)(
            /* [in] */ IUnknown *pUnkServer);

        STDMETHOD_(void,Disconnect)( void);

        STDMETHOD(Invoke)(
            /* [in] */ RPCOLEMESSAGE *_prpcmsg,
            /* [in] */ IRpcChannelBuffer *_pRpcChannelBuffer);

        STDMETHOD_(IRpcStubBuffer *,IsIIDSupported)(
            /* [in] */ REFIID riid);

       STDMETHOD_(ULONG,CountRefs)( void);

        STDMETHOD(DebugServerQueryInterface)(
            void * *ppv);

        STDMETHOD_(void,DebugServerRelease)(
            void  *pv);

    private:
       CDdeObject * m_pDdeObject;
    };

       DECLARE_NC(CDdeObject, COleObjectImpl)
       DECLARE_NC(CDdeObject, CDataObjectImpl)
       DECLARE_NC(CDdeObject, CPersistStgImpl)
       DECLARE_NC(CDdeObject, CProxyManagerImpl)
       DECLARE_NC(CDdeObject, COleItemContainerImpl)
       DECLARE_NC(CDdeObject, CRpcStubBufferImpl)

       COleObjectImpl           m_Ole;
       CDataObjectImpl          m_Data;
       CPersistStgImpl          m_PersistStg;
       CProxyManagerImpl        m_ProxyMgr;
       COleItemContainerImpl    m_OleItemContainer;
       CRpcStubBufferImpl       m_RpcStubBuffer;

shared_state:
       ULONG                            m_refs;
       ULONG                            m_ulObjType;
       CLSID                            m_clsid;
       ATOM                             m_aClass;
       ATOM                             m_aExeName;
       ATOM                             m_aTopic;
       ATOM                             m_aItem;
       BOOL                             m_bRunning;
       IUnknown *               m_pUnkOuter;
       IOleClientSite * m_pOleClientSite;
       LPSTORAGE                m_pstg;
       BOOL                     m_bInitNew;
       BOOL                     m_bOldSvr;
       HANDLE                   m_hNative;
       HANDLE                   m_hPict;
       HANDLE                   m_hExtra;
       CLIPFORMAT               m_cfPict;
       CLIPFORMAT               m_cfExtra;

       BOOL                             m_fDidSendOnClose;
       BOOL                             m_fNoStdCloseDoc;
       BOOL                             m_fDidStdCloseDoc;
       BOOL                             m_fDidStdOpenDoc;
       BOOL                             m_fDidGetObject;
       BOOL                             m_fDidLaunchApp;
       BOOL                             m_fUpdateOnSave;
       BOOL                             m_fGotCloseData;

#ifdef OLE1INTEROP
   BOOL           m_fOle1interop;
#endif

       // Invisible update stuff
       ULONG                            m_cLocks;   // PM::LockConnection lock count (init 1)
       BOOL                             m_fVisible; // is server visible (as best we know)?
       BOOL                             m_fWasEverVisible;
       BOOL                             m_fCalledOnShow; // Did we call IOleClientSite::OnShow

       CHK                                      m_chk;
       DVTARGETDEVICE * m_ptd;

       // m_iAdvClose and m_iAdvSave are counts (1 or 2) of the number of formats
       // that have advise connections of a given type (Save or Close)
       int                                      m_iAdvClose;
       int                                      m_iAdvSave;
       int                                      m_iAdvChange;

       BOOL                             m_fDidAdvNative;

       // Extent info
#ifdef OLD
       long                             m_cxContentExtent;
       long                             m_cyContentExtent;
#endif

       // terminate info - only used to detect a premature WM_DDE_TERMINATE
       WORD m_wTerminate;

       IDataAdviseHolder *      m_pDataAdvHolder;
       IOleAdviseHolder  *      m_pOleAdvHolder;
       CDdeConnectionTable      m_ConnectionTable;


       // DDE window related stuff
       LPDDE_CHANNEL            m_pSysChannel;
       LPDDE_CHANNEL            m_pDocChannel;

       friend INTERNAL DdeBindToObject
        (LPCOLESTR  szFile,
        REFCLSID clsid,
        BOOL       fPackageLink,
        REFIID   iid,
        LPLPVOID ppv);

       friend INTERNAL DdeIsRunning
        (CLSID clsid,
        LPCOLESTR szFile,
        LPBC pbc,
        LPMONIKER pmkToLeft,
        LPMONIKER pmkNewlyRunning);
#ifdef OLE_DEBUG_EXT

#endif OLE_DEBUG_EXT
};
//
// Note: WM_DDE_TERMINATE
//  A state machine is used to delay the executing of a premature WM_DDE_TERMINTE
//     message, which is send by some apps instead of WM_DDE_ACK (or alike).
//  The code is in WaitForReply() and in OnTerminate()
typedef enum {
       Terminate_None      = 0, // default state - terminate code is executed
       Terminate_Detect    = 1, // window proc will NOT execute terminate code
       Terminate_Received  = 2  // wait loop does not need to run, execute terminate code now
} TERMINATE_DOCUMENT;



INTERNAL_(BOOL)   wPostMessageToServer(LPDDE_CHANNEL pChannel,
                                       WORD wMsg,
                                       LPARAM lParam,
                                       BOOL fFreeOnError);

INTERNAL_(ATOM)   wAtomFromCLSID(REFCLSID rclsid);
INTERNAL_(ATOM)   wGetExeNameAtom (REFCLSID rclsid);
INTERNAL_(BOOL)   wIsWindowValid (HWND hwnd);
INTERNAL_(void)   wFreeData (HANDLE hData, CLIPFORMAT cfFormat,
                             BOOL fFreeNonGdiHandle=TRUE);
INTERNAL_(BOOL)   wInitiate (LPDDE_CHANNEL pChannel, ATOM aLow, ATOM aHigh);
INTERNAL          wScanItemOptions (ATOM aItem, int * lpoptions);
INTERNAL_(BOOL)   wClearWaitState (LPDDE_CHANNEL pChannel);
INTERNAL_(HANDLE) wStdCloseDocumentHandle (void);
INTERNAL_(ATOM)   wExtendAtom (ATOM aIitem, int iAdvOn);
INTERNAL_(int)    wAtomLen (ATOM atom);
INTERNAL_(int)    wAtomLenA (ATOM atom);
INTERNAL_(HANDLE) wHandleFromDdeData(HANDLE hDdeData);
INTERNAL_(BOOL)   wIsOldServer (ATOM aClass);
INTERNAL_(LPSTR)  wAllocDdePokeBlock (DWORD dwSize,
                                      CLIPFORMAT cfFormat,
                                      LPHANDLE phDdePoke);
INTERNAL_(void)   wFreePokeData (LPDDE_CHANNEL pChannel, BOOL fMSDrawBug);
INTERNAL_(HANDLE) wPreparePokeBlock (HANDLE hData,
                                     CLIPFORMAT cfFormat,
                                     ATOM aClass,
                                     BOOL bOldSvr);
INTERNAL_(HANDLE) wNewHandle (LPSTR lpstr, DWORD cb);
INTERNAL          wDupData (LPHANDLE ph, HANDLE h, CLIPFORMAT cf);
INTERNAL          wHandleCopy (HANDLE hDst, HANDLE hSrc);
INTERNAL          wGetItemFromClipboard (ATOM * paItem);
INTERNAL          GetDefaultIcon (REFCLSID clsidIn,
                                  LPCOLESTR szFile,
                                  HANDLE * phmfp);
INTERNAL_(BOOL)   wTerminateIsComing (LPDDE_CHANNEL);
INTERNAL          wTimedGetMessage (LPMSG pmsg,
                                    HWND hwnd,
                                    WORD wFirst,
                                    WORD wLast);

INTERNAL_(ATOM)   wGlobalAddAtom(LPCOLESTR sz);
INTERNAL_(ATOM)   wGlobalAddAtomA(LPCSTR sz);

INTERNAL          wVerifyFormatEtc (LPFORMATETC pformatetc);
INTERNAL          wNormalize (LPFORMATETC pfetc, LPFORMATETC pfetcOut);
INTERNAL          wTransferHandle (LPHANDLE phDst,
                                   LPHANDLE phSrc,
                                   CLIPFORMAT cf);
INTERNAL          wClassesMatch (REFCLSID clsidIn, LPOLESTR szFile);

#if DBG == 1
INTERNAL_(BOOL)   wIsValidHandle (HANDLE h, CLIPFORMAT cf);
INTERNAL_(BOOL)   wIsValidAtom (ATOM a);
#endif

const char achStdCloseDocument[]="[StdCloseDocument]";
const char achStdOpenDocument[]="StdOpenDocument";
const char achStdExit[]="StdExit";
const char achStdNewDocument[]="StdNewDocument";
const char achStdEditDocument[]="StdEditDocument";

HWND CreateDdeClientHwnd(void);

//+---------------------------------------------------------------------------
//
//  Function:   TLSGetDdeClientWindow()
//
//  Synopsis:   Returns a pointer to the per thread DdeClient window. If one
//              has not been created, it will create it and return
//
//  Returns:    Pointer to the DdeClientWindow. This window is used for per
//              thread cleanup
//
//  History:    12-12-94   kevinro   Created
//----------------------------------------------------------------------------
inline void * TLSGetDdeClientWindow()
{
    HRESULT hr;
    COleTls tls(hr);

    if (SUCCEEDED(hr))
    {
        if (tls->hwndDdeClient == NULL)
        {
            tls->hwndDdeClient = CreateDdeClientHwnd();
        }
        return tls->hwndDdeClient;
    }

    return NULL;
}


#endif // ddeproxy.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\com\dde\client\modallp.cxx ===
/*

copyright (c) 1992  Microsoft Corporation

Module Name:

    modallp.cpp

Abstract:

    This module contains the code to wait for reply on a remote call.

Author:
    Johann Posch    (johannp)   01-March-1993 modified to use CoRunModalLoop

*/

#include "ddeproxy.h"


#define DebWarn(x)
#define DebError(x)
#define DebAction(x)
#if DBG==1
static unsigned iCounter=0;
#endif
//
// Called after posting a message (call) to a server
//
#pragma SEG(CDdeObject_WaitForReply)



INTERNAL CDdeObject::SendMsgAndWaitForReply
    (LPDDE_CHANNEL pChannel,
     int iAwaitAck,
     WORD wMsg,
     LPARAM lparam,
     BOOL fFreeOnError,
     BOOL fStdCloseDoc,
     BOOL fDetectTerminate,
     BOOL fWait )
{
#ifdef _MAC
#else
    DDECALLDATA DdeCD;
    BOOL    fPending;
    HRESULT hres;
    ULONG status = 0;



#if DBG == 1
    unsigned iAutoCounter;
    intrDebugOut((INTR_DDE,
		  "DdeObject::WaitForReply(%x) Call#(%x) awaiting %x\n",
		  this,
		  iAutoCounter=++iCounter,
		  iAwaitAck));
#endif

    // make sure we have a call control. if OLE2 stuff has never been run,
    // then we might not yet have a call control (since
    // ChannelThreadInitialize may not have been be called).

    COleTls tls;
    CAptCallCtrl *pCallCtrl = tls->pCallCtrl;

    if (pCallCtrl == NULL)
    {
	// OLE2 stuff has never been run and we dont yet have a CallCtrl
	// for this thread. Go create one now. ctor adds it to the tls.

	pCallCtrl = new CAptCallCtrl;
	if (pCallCtrl == NULL)
	{
	    intrDebugOut((DEB_ERROR,"SendRecieve2 couldn't alloc CallCtrl\n"));
	    return RPC_E_OUT_OF_RESOURCES;
	}
    }

    // see if we can send the message, and then send it...

    CALLCATEGORY  CallCat = fWait ? CALLCAT_SYNCHRONOUS : CALLCAT_ASYNC;

    if (pChannel->pCD != NULL)
    {
	// a DDE call is already in progress, dont let another DDE call out.
	hres =	E_UNEXPECTED;
    }
    else
    {
	// we dont know what interface is being called on, but we do
	// know it is NOT IRemUnknown (IRundown) so it does not matter
	// what we pass here as long as it is not IRemUnknown (IRundown).
	hres = CanMakeOutCall(CallCat, IID_IUnknown, NULL);
    }

    if ( FAILED(hres) )
    {
	intrDebugOut((INTR_DDE, "CanMakeOutCall failed:%x\n", hres));
	return hres;
    }

    // Note:  this is to detect a premature DDE_TERMINATE
    // here we care about if we receive a WM_DDE_TERMINATE instead ACK
    // the next call to WaitForReply will detect this state and return
    // since the terminate was send prematurly (Excel is one)
    //
    if ( fDetectTerminate ) {
        Assert(m_wTerminate == Terminate_None);
        // if this flag is on terminate should not execute the default code
        // in the window procedure
        m_wTerminate = Terminate_Detect;
    }


    pChannel->iAwaitAck = iAwaitAck;
    pChannel->dwStartTickCount = GetTickCount();

    // start looking only for dde messages first
    pChannel->msgFirst = WM_DDE_FIRST;
    pChannel->msgLast  = WM_DDE_LAST;
    pChannel->msghwnd  = pChannel->hwndCli;

    pChannel->fRejected = FALSE;
    // see if there is a thread window for lrpc communication
    // if so we have to dispatch this messages as well
    fPending = FALSE;

    intrDebugOut((DEB_ITRACE,
		  "+++ Waiting for reply: server: %x, client %x Call#(%x) +++\n",
		  pChannel->hwndSvr,
		  pChannel->hwndCli,
		  iAutoCounter));

    // prepare and enter the modal loop
    DdeCD.hwndSvr = pChannel->hwndSvr;
    DdeCD.hwndCli = pChannel->hwndCli;
    DdeCD.wMsg = wMsg;
    DdeCD.wParam = (WPARAM) pChannel->hwndCli,
    DdeCD.lParam = lparam;
    DdeCD.fDone = FALSE;
    DdeCD.fFreeOnError = fFreeOnError;
    DdeCD.pChannel = pChannel;

    pChannel->pCD = &DdeCD;

    //
    // Setting this value tells DeleteChannel NOT to delete itself.
    // If the value changes to Channel_DeleteNow while we are in
    // the modal loop, this routine will delete the channel
    //
    pChannel->wChannelDeleted = Channel_InModalloop;

    //
    // hres will be the return code from the message
    // handlers, or from the channel itself. The return
    // code comes from calls to SetCallState. Most of the
    // time, it will be things like RPC_E_DDE_NACK. However,
    // it may also return OUTOFMEMORY, or other ModalLoop
    // problems.
    //

    RPCOLEMESSAGE	 RpcOleMsg;
    RpcOleMsg.Buffer = &DdeCD;

    // Figure out the call category of this call by looking at the bit
    // values in the rpc message flags.

    DWORD dwMsgQInputFlag = gMsgQInputFlagTbl[CallCat];

    // Now construct a modal loop object for the call that is about to
    // be made. It maintains the call state and exits when the call has
    // been completed, cancelled, or rejected.

    CCliModalLoop CML(0, dwMsgQInputFlag, 0);

    do
    {
	hres = CML.SendReceive(&RpcOleMsg, &status, pChannel);

    }  while (hres == RPC_E_SERVERCALL_RETRYLATER);


    if (hres != NOERROR)
    {
	intrDebugOut((DEB_ITRACE,
		      "**************** CallRunModalLoop returns %x ***\n",
		      hres));
    }

    if (m_wTerminate == Terminate_Received) {
        intrAssert(fDetectTerminate);
	//
	// There really wasn't an error, its just that the server decided
	// to terminate. If we return an error here, the app may decide
	// that things have gone awry. Excel, for example, will decide
	// that the object could not be activated, even though it has
	// already updated its cache information.
	//
	hres = NOERROR;
	intrDebugOut((DEB_ITRACE,
	    	      "::WaitForReply setting hres=%x\n",
		      hres));
	intrDebugOut((DEB_ITRACE,
	    	      "::WaitForReply posting TERMINATE to self hwnd=%x\n",
		      DdeCD.hwndCli));
        // set state to normal and repost message
        Verify (PostMessage (DdeCD.hwndCli, WM_DDE_TERMINATE,
                             (WPARAM)DdeCD.hwndSvr, (LPARAM)0));
    }
    m_wTerminate = Terminate_None;

    //
    // If the channel is to be deleted, then do it now. This flag would
    // have been set in the DeleteChannel routine.
    //
    if (pChannel->wChannelDeleted == Channel_DeleteNow)
    {
	intrDebugOut((INTR_DDE,
		  "::WaitForReply(%x) Channel_DeleteNow pChannel(%x)\n",
		  pChannel));

        // If the channel is closed then its pointer in the DdeChannel must
        // be NULL.  This assumes that the passed in "pChannel" is always
        // equal to either the "Doc" or "Sys" member channels.
        // This code fragment is patterned after a code fragment
        // found in CDdechannel::DeleteChannel().

        if(0 == pChannel->ReleaseReference())
        {
            if(pChannel == m_pDocChannel)
            {
                m_pDocChannel = NULL;
            }
            else
            {
                Assert(pChannel == m_pSysChannel);
                m_pSysChannel = NULL;
            }
        }

        // Excel will send TERMINATE before sending an ACK to StdCloseDoc
	return ResultFromScode (fStdCloseDoc ? DDE_CHANNEL_DELETED : RPC_E_DDE_POST);
    }
    pChannel->wChannelDeleted = 0;

    pChannel->iAwaitAck = 0;
    pChannel->pCD = NULL;

    intrDebugOut((DEB_ITRACE,
		  "### Waiting for reply done: server: %x, client %x hres(%x)###\n",
		  pChannel->hwndSvr,
		  pChannel->hwndCli,
		  hres));

    return hres;
#endif _MAC
}

// Provided IRpcChannelBuffer2 methods
HRESULT DDE_CHANNEL::SendReceive2(
	           /* [out][in] */ RPCOLEMESSAGE __RPC_FAR *pMessage,
	           /* [out] */ ULONG __RPC_FAR *pStatus)
{
    pCD = (DDECALLDATA *) pMessage->Buffer;

    if(!wPostMessageToServer(pCD->pChannel,
                             pCD->wMsg,
                             pCD->lParam,
                             pCD->fFreeOnError))
    {
	intrDebugOut((DEB_ITRACE, "SendRecieve2(%x)wPostMessageToServer failed", this));
        return RPC_E_SERVER_DIED;
    }


    CAptCallCtrl *pCallCtrl = GetAptCallCtrl();

    CCliModalLoop *pCML = pCallCtrl->GetTopCML();

    hres = S_OK;
    BOOL fWait = !pCD->fDone;

    while (fWait)
    {
	HRESULT hr = OleModalLoopBlockFn(NULL, pCML, NULL);

	if (pCD->fDone)
	{
	    fWait = FALSE;
	}
	else if (hr != RPC_S_CALLPENDING)
	{
	    fWait = FALSE;
	    hres = hr;		// return result from OleModalLoopBlockFn()
	}
    }

    if (FAILED(hres))
    {
	intrDebugOut((DEB_ITRACE, "**** CallRunModalLoop returns %x ***\n", hres));
    }
    return hres;
}


void DDE_CHANNEL::SetCallState(SERVERCALLEX ServerCall, HRESULT hr)
{
    CallState = ServerCall;
    hres = hr;
    Win4Assert(pCD);
    pCD->fDone = TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\com\dde\client\packmnkr.cxx ===
/*
    PackMnkr.cpp
    PackageMoniker

    This module implements the CPackagerMoniker class and
    CreatePackagerMoniker()

    Author:
    Jason Fuller    jasonful    Nov-2-1992

    Copyright (c) 1992  Microsoft Corporation
*/

#include <ole2int.h>
#include "packmnkr.h"
#include "..\server\ddedebug.h"
#include <ole1cls.h>
#include <winerror.h>

ASSERTDATA


STDMETHODIMP CPackagerMoniker::QueryInterface
    (REFIID riid, LPVOID * ppvObj)
{
    M_PROLOG(this);
    VDATEIID (riid);
    VDATEPTROUT (ppvObj, LPVOID);

    if ((riid == IID_IMoniker)       || (riid == IID_IUnknown) ||
        (riid == IID_IPersistStream) || (riid == IID_IInternalMoniker))
    {
        *ppvObj = this;
        AddRef();
        return NOERROR;
    }
    AssertSz (0, "Could not find interface\r\n");
    *ppvObj = NULL;
    return ReportResult(0, E_NOINTERFACE, 0, 0);
}

STDMETHODIMP_(ULONG) CPackagerMoniker::AddRef()
{
    M_PROLOG(this);
    return InterlockedIncrement((LONG *)&m_refs);
}

STDMETHODIMP_(ULONG) CPackagerMoniker::Release()
{
    M_PROLOG(this);
    Assert (m_refs > 0);
    ULONG cRefs = InterlockedDecrement((LONG *)&m_refs);
    if (0 == cRefs)
    {
        if (m_pmk)
        {
            m_pmk->Release();
        }

        if (m_szFile)
        {
            delete m_szFile;
        }

        delete this;
        return 0;
    }
    return cRefs;
}

STDMETHODIMP CPackagerMoniker::GetClassID (THIS_ LPCLSID lpClassID)
{
    M_PROLOG(this);
    *lpClassID = CLSID_PackagerMoniker;
    return NOERROR;
}

const CLSID CLSID_Ole2Package = {0xF20DA720, 0xC02F, 0x11CE, {0x92, 0x7B, 0x08, 0x00, 0x09, 0x5A, 0xE3, 0x40}};


STDMETHODIMP CPackagerMoniker::BindToObject (THIS_ LPBC pbc, LPMONIKER pmkToLeft,
        REFIID riidResult, LPVOID * ppvResult)
{
    M_PROLOG(this);
    WIN32_FIND_DATA fd;
    HRESULT hr;

    COleTls Tls;
    if( Tls->dwFlags & OLETLS_DISABLE_OLE1DDE )
    {
        // If this app doesn't want or can tolerate having a DDE
        // window then currently it can't use OLE1 classes because
        // they are implemented using DDE windows.
        //
        return CO_E_OLE1DDE_DISABLED;
    }

    // The following code ensures that the file exists before we try to bind it.
    HANDLE hFind = FindFirstFile(m_szFile, &fd);
    if (hFind != INVALID_HANDLE_VALUE)
    {
    
        hr = CoCreateInstance(CLSID_Ole2Package, NULL, CLSCTX_INPROC_SERVER, riidResult, ppvResult);
        
        if (SUCCEEDED(hr))        
        {   
            IPersistFile *pPersistFile;

            hr = ((IUnknown *)*ppvResult)->QueryInterface(IID_IPersistFile, (void **)&pPersistFile);
            
            if (SUCCEEDED(hr))            
            {
                hr = pPersistFile->Load(m_szFile, 0);             
                pPersistFile->Release();
            }
            else
                ((IUnknown *)*ppvResult)->Release();                
        }
	
        if (FAILED(hr))
            hr = DdeBindToObject (m_szFile, CLSID_Package, m_fLink, riidResult, ppvResult);        

        FindClose(hFind);
    }
    else
        hr = MK_E_CANTOPENFILE;
    return hr;
}

STDMETHODIMP CPackagerMoniker::IsRunning (THIS_ LPBC pbc, LPMONIKER pmkToLeft,
                      LPMONIKER pmkNewlyRunning)
{
  M_PROLOG(this);
  VDATEIFACE (pbc);

  if (pmkToLeft)
    VDATEIFACE (pmkToLeft);
  if (pmkNewlyRunning)
    VDATEIFACE (pmkNewlyRunning);

  // There is no way to tell if a packaged object is running
  return ReportResult (0, S_FALSE, 0, 0);
}



STDAPI CreatePackagerMoniker(LPOLESTR szFile,LPMONIKER *ppmk,BOOL fLink)
{
    return CPackagerMoniker::Create (szFile,NULL,fLink,ppmk);
}

STDAPI CreatePackagerMonikerEx(LPOLESTR szFile,LPMONIKER lpFileMoniker,BOOL fLink,LPMONIKER * ppmk)
{
    return CPackagerMoniker::Create (szFile,lpFileMoniker,fLink,ppmk);
}

HRESULT CPackagerMonikerCF_CreateInstance(IUnknown *pUnkOuter, REFIID riid, void** ppv)
{
    Win4Assert(pUnkOuter == NULL);
    Win4Assert(*ppv == NULL);

    IMoniker *pmk = NULL;
    HRESULT hr = CreatePackagerMoniker (OLESTR(""), &pmk, FALSE);
    if (SUCCEEDED(hr))
    {
        *ppv = (void *)pmk;
    }
    return hr;
}

HRESULT CPackagerMoniker::Create(LPOLESTR szFile,LPMONIKER lpFileMoniker, BOOL fLink, LPMONIKER * ppmk)
{
HRESULT hresult = E_OUTOFMEMORY;
CPackagerMoniker *pmkPack = NULL;

    VDATEPTROUT (ppmk, LPMONIKER);
    *ppmk = NULL;

    if (NULL == szFile)
    {
        return MK_E_SYNTAX;
    }

    pmkPack = new CPackagerMoniker;
    if (NULL != pmkPack)
    {
        pmkPack->m_fLink = fLink;
        pmkPack->m_refs  = 1;

        // an exception could be caused by szFile being bogus
        __try
        {
            pmkPack->m_szFile = new  WCHAR [lstrlenW(szFile)+1];
            if (NULL != pmkPack->m_szFile)
            {
                lstrcpyW (pmkPack->m_szFile, szFile);

                // If we weren't given a FileMoniker try to create one now, else just hold on to the one given.
                if (NULL == lpFileMoniker)
                {
                    if (NOERROR == (hresult = CreateFileMoniker (szFile, &(pmkPack->m_pmk))))
                    {
                        *ppmk = pmkPack;
                    }
                }
                else
                {
                    pmkPack->m_pmk = lpFileMoniker;
                    pmkPack->m_pmk->AddRef();
                    *ppmk = pmkPack;
                    hresult = NOERROR;
                }
            }
        }
        __except (EXCEPTION_EXECUTE_HANDLER)
        {
            hresult = MK_E_SYNTAX;
        }

    }

    if ((NOERROR != hresult) && pmkPack)
    {
        Assert(0);
        pmkPack->Release();
    }

    return hresult;
}



/////////////////////////////////////////////////////////////////////
// The rest of these methods just delegate to m_pmk
// or return some error code.


STDMETHODIMP CPackagerMoniker::IsDirty (THIS)
{
    M_PROLOG(this);
    return ReportResult(0, S_FALSE, 0, 0);
    //  monikers are immutable so they are either always dirty or never dirty.
    //
}

STDMETHODIMP CPackagerMoniker::Load (THIS_ LPSTREAM pStm)
{
    M_PROLOG(this);
    return m_pmk->Load(pStm);
}


STDMETHODIMP CPackagerMoniker::Save (THIS_ LPSTREAM pStm,
                    BOOL fClearDirty)
{
    M_PROLOG(this);
    return m_pmk->Save(pStm, fClearDirty);
}


STDMETHODIMP CPackagerMoniker::GetSizeMax (THIS_ ULARGE_INTEGER  * pcbSize)
{
    M_PROLOG(this);
    return m_pmk->GetSizeMax (pcbSize);
}

    // *** IMoniker methods ***
STDMETHODIMP CPackagerMoniker::BindToStorage (THIS_ LPBC pbc, LPMONIKER pmkToLeft,
        REFIID riid, LPVOID * ppvObj)
{
    M_PROLOG(this);
    *ppvObj = NULL;
    return ReportResult(0, E_NOTIMPL, 0, 0);
}

STDMETHODIMP CPackagerMoniker::Reduce (THIS_ LPBC pbc, DWORD dwReduceHowFar, LPMONIKER *
        ppmkToLeft, LPMONIKER  * ppmkReduced)
{
    M_PROLOG(this);
    return m_pmk->Reduce (pbc, dwReduceHowFar, ppmkToLeft, ppmkReduced);
}

STDMETHODIMP CPackagerMoniker::ComposeWith (THIS_ LPMONIKER pmkRight, BOOL fOnlyIfNotGeneric,
        LPMONIKER * ppmkComposite)
{
    M_PROLOG(this);
    return m_pmk->ComposeWith (pmkRight, fOnlyIfNotGeneric, ppmkComposite);
}

STDMETHODIMP CPackagerMoniker::Enum (THIS_ BOOL fForward, LPENUMMONIKER * ppenumMoniker)
{
    M_PROLOG(this);
    return m_pmk->Enum (fForward, ppenumMoniker);
}

STDMETHODIMP CPackagerMoniker::IsEqual (THIS_ LPMONIKER pmkOtherMoniker)
{
    M_PROLOG(this);
    return m_pmk->IsEqual (pmkOtherMoniker);
}

STDMETHODIMP CPackagerMoniker::Hash (THIS_ LPDWORD pdwHash)
{
    M_PROLOG(this);
    return m_pmk->Hash (pdwHash);
}

STDMETHODIMP CPackagerMoniker::GetTimeOfLastChange (THIS_ LPBC pbc, LPMONIKER pmkToLeft,
        FILETIME * pfiletime)
{
    M_PROLOG(this);
    return m_pmk->GetTimeOfLastChange (pbc, pmkToLeft, pfiletime);
}

STDMETHODIMP CPackagerMoniker::Inverse (THIS_ LPMONIKER * ppmk)
{
    M_PROLOG(this);
    return m_pmk->Inverse (ppmk);
}

STDMETHODIMP CPackagerMoniker::CommonPrefixWith (LPMONIKER pmkOther, LPMONIKER *
        ppmkPrefix)
{
    M_PROLOG(this);
    return m_pmk->CommonPrefixWith (pmkOther, ppmkPrefix);
}

STDMETHODIMP CPackagerMoniker::RelativePathTo (THIS_ LPMONIKER pmkOther, LPMONIKER *
        ppmkRelPath)
{
    M_PROLOG(this);
    return m_pmk->RelativePathTo (pmkOther, ppmkRelPath);
}

STDMETHODIMP CPackagerMoniker::GetDisplayName (THIS_ LPBC pbc, LPMONIKER pmkToLeft,
        LPOLESTR * lplpszDisplayName)
{
    M_PROLOG(this);
    return m_pmk->GetDisplayName (pbc, pmkToLeft, lplpszDisplayName);
}

STDMETHODIMP CPackagerMoniker::ParseDisplayName (THIS_ LPBC pbc, LPMONIKER pmkToLeft,
        LPOLESTR lpszDisplayName, ULONG * pchEaten,
        LPMONIKER * ppmkOut)
{
    M_PROLOG(this);
    return m_pmk->ParseDisplayName (pbc, pmkToLeft, lpszDisplayName, pchEaten,
                                     ppmkOut);
}


STDMETHODIMP CPackagerMoniker::IsSystemMoniker (THIS_ LPDWORD pdwMksys)
{
  M_PROLOG(this);
  VDATEPTROUT (pdwMksys, DWORD);

  *pdwMksys = MKSYS_NONE;
  return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\com\dde\client\sources.inc ===
!IF 0

Copyright (c) 1998  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.

!ENDIF

TARGETNAME=   ddecli
TARGETPATH=   obj
TARGETTYPE=   LIBRARY

INCLUDES = ..\..\server;..\..\..\..\common\$(DEST_TREE);..\..\..\..\ih
INCLUDES = $(INCLUDES);..\..\..\dcomrem;..\..\..\inc
INCLUDES = $(INCLUDES);..\..\..\class;..\..\..\objact
INCLUDES = $(INCLUDES);..\..\..\..\ole232\inc
INCLUDES = $(INCLUDES);..\..\..\..\idl\public\$(DEST_TREE)\$(O)
INCLUDES = $(INCLUDES);..\..\..\..\idl\internal\$(DEST_TREE)\$(O)
INCLUDES = $(INCLUDES);..\..\..\..\idl\private\$(DEST_TREE)\$(O)
INCLUDES = $(INCLUDES);$(BASE_INC_PATH)

C_DEFINES= -DOLE_DDE_NO_GLOBAL_TRACKING=1\
           $(C_DEFINES)

SOURCES=      \
    ..\cnct_tbl.cxx \
    ..\ddedo.cxx    \
    ..\ddeioc.cxx   \
    ..\ddemnker.cxx \
    ..\ddeoo.cxx    \
    ..\ddeproxy.cxx \
    ..\ddechc.cxx   \
    ..\ddestg.cxx   \
    ..\ddewnd.cxx   \
    ..\ddeworkr.cxx \
    ..\modallp.cxx  \
    ..\packmnkr.cxx
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\com\dde\client\ddestg.cxx ===
/*

copyright (c) 1992-1997  Microsoft Corporation

Module Name:

    ddeStg.cpp

Abstract:

    This module contains the DdeObject::PersistStg and
    DdeObject::ProxyManager methods

Author:

    Srini Koppolu   (srinik)    22-June-1992
    Jason Fuller    (jasonful)  24-July-1992

*/

#include "ddeproxy.h"
ASSERTDATA


/*
 *  IMPLEMENTATION of CPersistStgImpl methods
 *
 */


STDUNKIMPL_FORDERIVED(DdeObject, PersistStgImpl)


#pragma SEG(CDdeObject_CPersistStgImpl_GetClassID)
STDMETHODIMP NC(CDdeObject,CPersistStgImpl)::GetClassID (CLSID FAR* pClassID)
{
    *pClassID = m_pDdeObject->m_clsid;
    return NOERROR;
}


#pragma SEG(CDdeObject_CPersistStgImpl_IsDirty)
STDMETHODIMP NC(CDdeObject,CPersistStgImpl)::IsDirty ()
{
    return NOERROR;
}



#pragma SEG(CDdeObject_CPersistStgImpl_InitNew)
STDMETHODIMP NC(CDdeObject,CPersistStgImpl)::InitNew
    (IStorage FAR* pstg)
{
    HRESULT hres;
    intrDebugOut((DEB_ITRACE,
                  "DdeObejct::InitNew(%x,pstg=%x)\n",
                  this,
                  pstg));

    if (hres = m_pDdeObject->PostSysCommand (m_pDdeObject->m_pSysChannel,
                                             (LPSTR)&achStdNewDocument,
                                             TRUE))
        return hres;

    if (hres = m_pDdeObject->m_ProxyMgr.Connect (IID_NULL, CLSID_NULL))
        return hres;

    RetErr (m_pDdeObject->TermConv (m_pDdeObject->m_pSysChannel));
    if (m_pDdeObject->m_pstg)
    {
        m_pDdeObject->m_pstg->Release();
    }
    m_pDdeObject->m_pstg = pstg;
    pstg->AddRef();
    return hres;
}



#pragma SEG(CDdeObject_CPersistStgImpl_Load)
STDMETHODIMP NC(CDdeObject,CPersistStgImpl)::Load (IStorage FAR* pstg)
{
    LPSTR        lpBuf=NULL;
    HANDLE      hDdePoke = NULL;
    DWORD       dwSize;
    CStmBufRead StmRead;
    CStmBufRead StmReadItem;
    HRESULT     hresult;

    intrDebugOut((DEB_ITRACE,"CDdeObject::Load(%x,pstg=%x)\n",this,pstg));

    {

        if (hresult = StmRead.OpenStream(pstg, OLE10_NATIVE_STREAM))
        {
            intrDebugOut((DEB_ITRACE,
                          "::Load(%x) OpenStream failed(%x)\n",
                          this,
                          hresult));
            return hresult;
        }


        if (hresult = StmRead.Read(&dwSize, sizeof(DWORD)))
        {
            intrDebugOut((DEB_ITRACE,
                          "::Load(%x) StRead failed(%x)\n",
                          this,
                          hresult));

            goto errRtn;
        }


        lpBuf = wAllocDdePokeBlock (dwSize, g_cfNative, &hDdePoke);

        if (lpBuf == NULL)
        {
            intrDebugOut((DEB_ITRACE,
                          "::Load(%x) wAllocDdePokeBlock failed(%x)\n",
                          this,
                          hresult));

            hresult = E_OUTOFMEMORY;
            goto errRtn;
        }

        if (hresult = StmRead.Read(lpBuf, dwSize))
        {
            intrDebugOut((DEB_ITRACE,
                          "::Load(%x) StRead of cfNative failed(%x)\n",
                          this,
                          hresult));
            goto errRtn;
        }

        if (m_pDdeObject->m_hNative)
        {
            GlobalFree (m_pDdeObject->m_hNative);
        }
        m_pDdeObject->m_hNative = wNewHandle (lpBuf, dwSize);

        if (m_pDdeObject->m_hNative == NULL)
        {
            intrDebugOut((DEB_ITRACE,
                          "::Load(%x) m_hNative NULL\n",
                          this));
        }
    }

    GlobalUnlock (hDdePoke); // done with lpBuf

    if (hresult = m_pDdeObject->PostSysCommand (m_pDdeObject->m_pSysChannel,
                                                (LPSTR)&achStdEditDocument,
                                                FALSE))
    {
            intrDebugOut((DEB_ITRACE,
                          "::Load(%x) PostSysCommand %s failed (%x)\n",
                          this,
                          &achStdEditDocument,
                          hresult));
        goto errRtn;
    }


    // Read Item Name, if there is one
    if (NOERROR == StmReadItem.OpenStream(pstg, OLE10_ITEMNAME_STREAM))
    {
        LPSTR szItemName = NULL;

        ErrRtnH (ReadStringStreamA (StmReadItem, &szItemName));
        m_pDdeObject->ChangeItem (szItemName);
        PubMemFree(szItemName);
    }

    if (hresult = m_pDdeObject->m_ProxyMgr.Connect (IID_NULL, CLSID_NULL))
    {
        intrDebugOut((DEB_ITRACE,
                      "::Load(%x) ProxyMgr.Connect failed(%x)\n",
                      this,
                      hresult));
        goto errRtn;
    }


    if ((hresult = m_pDdeObject->Poke(m_pDdeObject->m_aItem, hDdePoke))
         != NOERROR)
    {
        intrDebugOut((DEB_ITRACE,
                      "::Load(%x) Poke failed(%x)\n",
                      this,
                      hresult));

        // the Poke calls frees the Poke data even in case of failure.
#ifdef LATER

        if (hresult = m_pDdeObject->Execute (m_pDdeObject->m_pDocChannel,
                                    wNewHandle ((LPSTR)achStdCloseDocument,sizeof(achStdCloseDocument)));
        goto errDoc;
#elseif
        goto errDoc;
#endif
    }

    hresult = m_pDdeObject->TermConv (m_pDdeObject->m_pSysChannel);
    if (hresult != NOERROR)
    {
        intrDebugOut((DEB_ITRACE,
                      "::Load(%x) TermConv on SysChannel failed(%x)\n",
                      this,
                      hresult));
        goto errRtn;
    }


    if (m_pDdeObject->m_pstg)
    {
        m_pDdeObject->m_pstg->Release();
    }

    m_pDdeObject->m_pstg = pstg;
    pstg->AddRef();
    goto LExit;

errRtn:
    if (hDdePoke)
        GlobalFree (hDdePoke);
    if (m_pDdeObject->m_pDocChannel)
        m_pDdeObject->TermConv (m_pDdeObject->m_pDocChannel);
LExit:
    StmReadItem.Release();
    StmRead.Release();

    intrDebugOut((DEB_ITRACE,"::Load(%x) returning (%x)\n",this,hresult));
    return hresult;
}


#pragma SEG(CDdeObject_CPersistStgImpl_Save)
STDMETHODIMP NC(CDdeObject,CPersistStgImpl)::Save
    (IStorage FAR* pstgSave, BOOL fSameAsLoad)
{
    intrDebugOut((DEB_ITRACE,
                  "DdeObject::Save(%x,pstgSave=%x)\n",
                  this,
                  pstgSave));


    HRESULT hresult=NOERROR;

    if (m_pDdeObject->m_fUpdateOnSave
        && (m_pDdeObject->m_clsid != CLSID_Package
            || m_pDdeObject->m_hNative == NULL))
    {
        // Get latest data from server, if it is not shutting down
        // or telling us to Save, in which case it just gave us data.
        // (If it is shutting down, it probably won't respond.
        // Draw does respond, but gives bad data.)
        // Packager gives truncated native data (header info with no
        // actual embedded file) if you DDE_REQUEST it. Bug 3103
        m_pDdeObject->Update (FALSE);
    }

    if (m_pDdeObject->m_hNative == NULL)
    {
        // we still have nothing to save
        return ResultFromScode (E_BLANK);
    }

    hresult = m_pDdeObject->Save (pstgSave);

    Puts ("PersistStg::Save done\n");
    return hresult;
}


#pragma SEG(CDdeObject_CPersistStgImpl_SaveCompleted)
STDMETHODIMP NC(CDdeObject,CPersistStgImpl)::SaveCompleted
    (IStorage FAR* pstgNew)
{
    intrDebugOut((DEB_ITRACE,
                  "DdeObejct::SaveCompleted(%x,pstgNew=%x)\n",
                  this,
                  pstgNew));

    RetZ (m_pDdeObject->m_pOleAdvHolder);
    m_pDdeObject->m_pOleAdvHolder->SendOnSave();
    if (pstgNew)
    {
        if (m_pDdeObject->m_pstg)
            m_pDdeObject->m_pstg->Release();
        m_pDdeObject->m_pstg = pstgNew;
        pstgNew->AddRef();
    }
    return NOERROR;
}


#pragma SEG(CDdeObject_CPersistStgImpl_HandsOffStorage)
STDMETHODIMP NC(CDdeObject,CPersistStgImpl)::HandsOffStorage(void)
{
    intrDebugOut((DEB_ITRACE,"DdeObejct::HandsOffStorage(%x)\n",this));
    if (m_pDdeObject->m_pstg)
    {
        m_pDdeObject->m_pstg->Release();
        m_pDdeObject->m_pstg = NULL;
    }
    return NOERROR;
}


/*
 *  IMPLEMENTATION of CProxyManagerImpl methods
 *
 */


STDUNKIMPL_FORDERIVED(DdeObject, ProxyManagerImpl)



#pragma SEG(CDdeObject_CProxyManagerImpl_CreateServer)
STDMETHODIMP NC(CDdeObject, CProxyManagerImpl)::CreateServer(REFCLSID rclsid,
                                 DWORD clsctx,
                                 void *pv)
{
    intrDebugOut((DEB_ITRACE,"DdeObejct::CreateServer(%x)\n",this));
    HRESULT hresult = NOERROR;

    if (m_pDdeObject->m_pSysChannel)
    {
        intrDebugOut((DEB_ITRACE,
                      "::CreateServer(%x)m_pSysChannel exists\n",
                      this));
        return NOERROR;
    }

    if (m_pDdeObject->m_aExeName == NULL)
    {
        intrDebugOut((DEB_ITRACE,
                      "::CreateServer(%x) Class Not Registered\n",
                      this));
        return(REGDB_E_CLASSNOTREG);
    }


    if (!m_pDdeObject->AllocDdeChannel(&m_pDdeObject->m_pSysChannel,TRUE))
    {
        intrDebugOut((DEB_ITRACE,
                      "::CreateServer(%x)AllocDdeChannel is failing\n",
                      this));
        return ReportResult(0, E_OUTOFMEMORY,0,0);
    }

    if (!m_pDdeObject->InitSysConv())
    {
        if (!(m_pDdeObject->LaunchApp()))
        {
            intrDebugOut((DEB_IERROR,"::CreateServer Could not launch app\n"));
            hresult = ResultFromScode (CO_E_APPNOTFOUND);
            goto errRtn;
        }

        if (!m_pDdeObject->InitSysConv())
        {
            intrDebugOut((DEB_IERROR,"::CreateServer Second init failed\n"));
            hresult = ResultFromScode (CO_E_APPDIDNTREG);
            goto errRtn;
        }
    }

    return NOERROR;

errRtn:
    intrDebugOut((DEB_ITRACE,"DdeObejct::CreateServer(%x) is failing(%x)\n",this,hresult));
    m_pDdeObject->DeleteChannel (m_pDdeObject->m_pSysChannel);
    Assert (hresult != NOERROR); // This is an error path
    return hresult;

}


#pragma SEG(CDdeObject_CProxyManagerImpl_Connect)
STDMETHODIMP NC(CDdeObject, CProxyManagerImpl)::Connect(GUID oid, REFCLSID rclsid)
{
    intrDebugOut((DEB_ITRACE,"DdeObject::Connect(%x)\n",this));

    if (m_pDdeObject->m_pDocChannel)
        return NOERROR;

    if (!m_pDdeObject->AllocDdeChannel (&m_pDdeObject->m_pDocChannel,FALSE))
    {
        intrDebugOut((DEB_ITRACE,
                      "::Connect(%x) AllocDdeChannel failed, return E_OUTOFMEMORY\n",
                      this));
        return ReportResult(0, E_OUTOFMEMORY,0,0);
    }

    // Bug 3701
    m_pDdeObject->m_fDidSendOnClose = FALSE;
    if (wInitiate (m_pDdeObject->m_pDocChannel, m_pDdeObject->m_aClass,
                m_pDdeObject->m_aTopic))
    {
        return NOERROR;
    }

    intrDebugOut((DEB_ITRACE,"::Connect(%x) wInitiate failed\n",this));
    m_pDdeObject->DeleteChannel (m_pDdeObject->m_pDocChannel);
    return ResultFromScode (E_FAIL);
}


#pragma SEG(CDdeObject_CProxyManagerImpl_LockConnection)
STDMETHODIMP NC(CDdeObject, CProxyManagerImpl)::LockConnection(BOOL fLock, BOOL fLastUnlockReleases)
{
    intrDebugOut((DEB_ITRACE,
          "DdeObject::LockConnection(%x,fLock=%x,fLastUnlockReleases=%x)\n",
                  this,
                  fLock,
                  fLastUnlockReleases));

    if (fLock)
        m_pDdeObject->m_cLocks++;
    else
    {
        if (m_pDdeObject->m_cLocks!=0 && 0 == --m_pDdeObject->m_cLocks &&
            fLastUnlockReleases && !m_pDdeObject->m_fVisible)
            (void)m_pDdeObject->m_Ole.Close (OLECLOSE_SAVEIFDIRTY);
    }
    return NOERROR;
}


#ifdef NOTNEEDED
#pragma SEG(CDdeObject_CProxyManagerImpl_GetClassID)
STDMETHODIMP_(void) NC(CDdeObject, CProxyManagerImpl)::GetClassID(CLSID FAR* pClsid)
{
    *pClsid = m_pDdeObject->m_clsid;
}


#pragma SEG(CDdeObject_CProxyManagerImpl_GetOID)
STDMETHODIMP_(OID) NC(CDdeObject, CProxyManagerImpl)::GetOID()
{
    if (m_pDdeObject->m_pSysChannel)
        return (OID) m_pDdeObject->m_pSysChannel;

    if (m_pDdeObject->m_pDocChannel)
        return (OID) m_pDdeObject->m_pDocChannel;

    return NULL;
}
#endif

#pragma SEG(CDdeObject_CProxyManagerImpl_IsConnected)
STDMETHODIMP_(BOOL) NC(CDdeObject, CProxyManagerImpl)::IsConnected(void)
{
    return m_pDdeObject->m_pDocChannel != NULL;
}


#pragma SEG(CDdeObject_CProxyManagerImpl_EstablishIID)
STDMETHODIMP NC(CDdeObject, CProxyManagerImpl)::EstablishIID(REFIID iid, LPVOID FAR* ppv)
{
    // REVIEW: this is correct, but can we be smarter like in the real PM?
    return QueryInterface(iid, ppv);
}


#pragma SEG(wTerminateIsComing)
INTERNAL_(BOOL) wTerminateIsComing (LPDDE_CHANNEL pChannel)
{
    MSG msg;
    return SSPeekMessage (&msg, pChannel->hwndCli, 0, 0, PM_NOREMOVE)
            && msg.message == WM_DDE_TERMINATE
            && (HWND)msg.wParam==pChannel->hwndSvr;
}


#pragma SEG(CDdeObject_CProxyManagerImpl_Disconnect)
STDMETHODIMP_(void) NC(CDdeObject, CProxyManagerImpl)::Disconnect()
{
    intrDebugOut((DEB_ITRACE,"DdeObject::Disonnect(%x)\n",this));

    if (m_pDdeObject->m_pDocChannel)
    {
        BOOL fTermComing = wTerminateIsComing (m_pDdeObject->m_pDocChannel);
        if ((!m_pDdeObject->m_fNoStdCloseDoc
             || (!m_pDdeObject->m_fWasEverVisible      // invisible update or
                 && !m_pDdeObject->m_fDidGetObject     // link from file case.
                 && m_pDdeObject->m_fDidStdOpenDoc))   // only do StdClose if did StdOpen
            && !m_pDdeObject->m_fDidStdCloseDoc
            && !fTermComing)
        {
            HANDLE h = wNewHandle ((LPSTR)&achStdCloseDocument,sizeof(achStdCloseDocument));

            if(h)
            {
                m_pDdeObject->Execute (m_pDdeObject->m_pDocChannel,
                                       h,
                                       /*fStdClose*/TRUE,
                                       /*fWait*/TRUE,
                                       /*fDetectTerminate*/TRUE);
            }

            m_pDdeObject->m_fDidStdCloseDoc = TRUE;
        }
        if (!m_pDdeObject->m_fDidSendOnClose /*|| fTermComing*/)
        {
            // if we did not call SendOnClose() then Disconnect() was called
            // by a Release method, not by SendOnClose().
            // This happens when user deletes object in container.
            BOOL fVisible = m_pDdeObject->m_fWasEverVisible; // TermConv clears this flag
            m_pDdeObject->TermConv (m_pDdeObject->m_pDocChannel);
            if (!fVisible)
                m_pDdeObject->MaybeUnlaunchApp();
        }
    }

    if (m_pDdeObject->m_pSysChannel)
    {
        intrDebugOut((DEB_IWARN,"Terminating system conversation in Disconnect()\n"));
        // This should never happen, I think.
        m_pDdeObject->TermConv (m_pDdeObject->m_pSysChannel);
    }
}

#ifdef SERVER_HANDLER
STDMETHODIMP NC(CDdeObject, CProxyManagerImpl)::CreateServerWithEmbHandler(REFCLSID rclsid, DWORD clsctx, 
			                            REFIID riidEmbedSrvHandler,void **ppEmbedSrvHandler, void *pv)
{
    // No Embedded Server Handler for DDE. Set ppEmbedSrvHandler to NULL and Call ::CreateServer.
    clsctx &= ~CLSCTX_ESERVER_HANDLER;
    *ppEmbedSrvHandler = NULL;

    return CreateServer(rclsid,clsctx,pv);
}
#endif // SERVER_HANDLER
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\com\dde\client\packmnkr.h ===
/*
	packmnkr.h
*/

class  CPackagerMoniker : public IMoniker
{
  public:
	// *** IUnknown methods ***
	STDMETHOD(QueryInterface) ( REFIID riid, LPVOID * ppvObj) ;
	STDMETHOD_(ULONG,AddRef) ()  ;
	STDMETHOD_(ULONG,Release) () ;

	// *** IPersist methods ***
	STDMETHOD(GetClassID) ( LPCLSID lpClassID) ;

	// *** IPersistStream methods ***
	STDMETHOD(IsDirty) () ;
	STDMETHOD(Load) ( LPSTREAM pStm) ;
	STDMETHOD(Save) ( LPSTREAM pStm,
					BOOL fClearDirty) ;
	STDMETHOD(GetSizeMax) ( ULARGE_INTEGER  * pcbSize) ;

	// *** IMoniker methods ***
	STDMETHOD(BindToObject) ( LPBC pbc, LPMONIKER pmkToLeft,
		REFIID riidResult, LPVOID * ppvResult) ;
	STDMETHOD(BindToStorage) ( LPBC pbc, LPMONIKER pmkToLeft,
		REFIID riid, LPVOID * ppvObj) ;
	STDMETHOD(Reduce) ( LPBC pbc, DWORD dwReduceHowFar, LPMONIKER *
		ppmkToLeft, LPMONIKER  * ppmkReduced) ;
	STDMETHOD(ComposeWith) ( LPMONIKER pmkRight, BOOL fOnlyIfNotGeneric,
		LPMONIKER * ppmkComposite) ;
	STDMETHOD(Enum) ( BOOL fForward, LPENUMMONIKER * ppenumMoniker)
		;
	STDMETHOD(IsEqual) ( LPMONIKER pmkOtherMoniker) ;
	STDMETHOD(Hash) ( LPDWORD pdwHash) ;
	STDMETHOD(IsRunning) ( LPBC pbc, LPMONIKER pmkToLeft, LPMONIKER
		pmkNewlyRunning) ;
	STDMETHOD(GetTimeOfLastChange) ( LPBC pbc, LPMONIKER pmkToLeft,
		FILETIME * pfiletime) ;
	STDMETHOD(Inverse) ( LPMONIKER * ppmk) ;
	STDMETHOD(CommonPrefixWith) ( LPMONIKER pmkOther, LPMONIKER *
		ppmkPrefix) ;
	STDMETHOD(RelativePathTo) ( LPMONIKER pmkOther, LPMONIKER *
		ppmkRelPath) ;
	STDMETHOD(GetDisplayName) ( LPBC pbc, LPMONIKER pmkToLeft,
		LPOLESTR * lplpszDisplayName) ;
	STDMETHOD(ParseDisplayName) ( LPBC pbc, LPMONIKER pmkToLeft,
		LPOLESTR lpszDisplayName, ULONG * pchEaten,
		LPMONIKER * ppmkOut) ;
	STDMETHOD(IsSystemMoniker) ( LPDWORD pdwMksys) ;

	static HRESULT Create ( LPOLESTR szFile,LPMONIKER lpFileMoniker,BOOL fLink,LPMONIKER * ppmk) ;

  private:

	ULONG 	 		m_refs;
	LPOLESTR		m_szFile;
	LPMONIKER 		m_pmk;
	BOOL		 	m_fLink;


};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\com\dde\client\ddewnd.cxx ===
/*++

copyright (c) 1992  Microsoft Corporation

Module Name:

    ddewnd.cpp

Abstract:

    This module contains the code for the dde window procs

Author:

    Srini Koppolu   (srinik)    20-June-1992

Revision History:

--*/
#include "ddeproxy.h"



#define SYS_MSG 0
#define DOC_MSG 1

// SysWndProc: Window Procedure for System Topic DDE conversations
// wndproc for system topic


STDAPI_(LRESULT) SysWndProc (
    HWND        hwnd,
    UINT        message,
    WPARAM      wParam,
    LPARAM      lParam
)
{
    StackAssert(SSOnSmallStack());
    CDdeObject FAR* pDdeObj = NULL;
    LPDDE_CHANNEL   pChannel = NULL;

    if (message>=WM_DDE_FIRST && message <= WM_DDE_LAST)
    {
        if (pDdeObj = (CDdeObject FAR*) GetWindowLongPtr (hwnd, 0))
		{
            pChannel = pDdeObj->GetSysChannel();
		}

		if (pChannel == NULL)
		{
			intrAssert(pChannel != NULL);
			return SSDefWindowProc (hwnd, message, wParam, lParam);
		}
    }

    if (pChannel
        && (pChannel->iAwaitAck == AA_EXECUTE
	        || pChannel->iAwaitAck == AA_INITIATE) )
    {
		MSG msg;
		BOOL fDisp = FALSE;
		while (SSPeekMessage(&msg, hwnd, WM_DDE_ACK, WM_DDE_ACK, PM_REMOVE | PM_NOYIELD) )
		{
			intrDebugOut((DEB_WARN, "DDE SysWndProc: dispatching WM_DDE_ACK message (%x)\n",pChannel));
				SSDispatchMessage(&msg);
			fDisp = TRUE;
		}
        if (fDisp && (pDdeObj = (CDdeObject FAR*) GetWindowLongPtr (hwnd, 0)))
		{
            pChannel = pDdeObj->GetSysChannel();
            intrAssert(pChannel != NULL);
		}
    }

	if (pChannel == NULL)
	{
		//intrAssert(pChannel != NULL);
		return SSDefWindowProc (hwnd, message, wParam, lParam);
	}

    switch (message){
    case WM_DDE_ACK:
		intrDebugOut((DEB_ITRACE,
		      "SWP: WM_DDE_ACK pChannel(%x)\n",pChannel));
		if (pChannel->bTerminating)
		{
			intrDebugOut((DEB_ITRACE,
		      "SWP: pChannel->bTerminating: no action\n"));
            break;
        }

        switch (pChannel->iAwaitAck) {
        case AA_INITIATE:
            pDdeObj->OnInitAck (pChannel, (HWND)wParam);
            if (LOWORD(lParam))
                GlobalDeleteAtom (LOWORD(lParam));
            if (HIWORD(lParam))
                GlobalDeleteAtom (HIWORD(lParam));
            break;

        case AA_EXECUTE:
            pDdeObj->OnAck (pChannel, lParam);
            break;

        default:
            intrDebugOut((DEB_ITRACE,
		      "SWP: WM_DDE_ACK UnhandledpChannel(%x)\n",pChannel));
            break;
        }
        break;

    case WM_TIMER:
        pDdeObj->OnTimer (pChannel);
        break;

    case WM_DDE_TERMINATE:
		intrDebugOut((DEB_ITRACE,
		      "SWP: WM_DDE_TERMINATE pChannel(%x)\n",pChannel));
        pDdeObj->OnTerminate (pChannel, (HWND)wParam);
        break;

    default:
        return SSDefWindowProc (hwnd, message, wParam, lParam);
    }

    return 0L;
}


// ClientDocWndProc: Window procedure used to document DDE conversations
STDAPI_(LRESULT) ClientDocWndProc (
    HWND        hwnd,
    UINT        message,
    WPARAM      wParam,
    LPARAM      lParam
)
{
    StackAssert(SSOnSmallStack());
    CDdeObject FAR* pDdeObj = NULL;
    LPDDE_CHANNEL   pChannel = NULL;
    HANDLE hData;
    ATOM aItem;

    if (message>=WM_DDE_FIRST && message <= WM_DDE_LAST)
    {

        if (pDdeObj = (CDdeObject FAR*) GetWindowLongPtr (hwnd, 0))
	    pChannel = pDdeObj->GetDocChannel();

	if (pChannel == NULL)
	{
	    //
	    // pChannel == NULL. Something is very wrong! But, lets
	    // not fault on it.
	    //
	    //intrAssert(pChannel != NULL);
	    return SSDefWindowProc (hwnd, message, wParam, lParam);
	}

    }
    if (   pChannel
	&& (   pChannel->iAwaitAck == AA_EXECUTE
	    || pChannel->iAwaitAck == AA_INITIATE
	    || pChannel->iAwaitAck == AA_REQUESTAVAILABLE
	    || pChannel->iAwaitAck == AA_REQUEST
	    || pChannel->iAwaitAck == AA_UNADVISE
	    || pChannel->iAwaitAck == AA_EXECUTE
	    || pChannel->iAwaitAck == AA_ADVISE
	    || pChannel->iAwaitAck == AA_POKE)	)
    {
	MSG msg;
	BOOL fDisp = FALSE;
	while (SSPeekMessage(&msg, hwnd, WM_DDE_ACK, WM_DDE_ACK, PM_REMOVE | PM_NOYIELD) )
	{
	    intrDebugOut((DEB_WARN, "DDE DocWndProc: dispatching WM_DDE_ACK message (%x)\n",pChannel));
	    SSDispatchMessage(&msg);
	    fDisp = TRUE;
	}

	if (fDisp && (pDdeObj = (CDdeObject FAR*) GetWindowLongPtr (hwnd, 0)))
	{
	    pChannel = pDdeObj->GetDocChannel();
	}

	if (pChannel == NULL)
	{
	    intrAssert(pChannel != NULL);
	    return SSDefWindowProc (hwnd, message, wParam, lParam);
	}
    }

    switch (message)
    {
    case WM_DDE_ACK:

	intrDebugOut((DEB_ITRACE,
		      "ClientWndProc: WM_DDE_ACK pChannel(%x)\n",
		      pChannel));
	if (pChannel->bTerminating){
	    // ### this error recovery may not be correct.
	    DEBUG_OUT ("No action due to termination process",0)
	    break;
	 }

	 switch(pChannel->iAwaitAck){
	     case AA_INITIATE:
		 pDdeObj->OnInitAck (pChannel, (HWND)wParam);
		 if (LOWORD(lParam))
		     GlobalDeleteAtom (LOWORD(lParam));
		 if (HIWORD(lParam))
		     GlobalDeleteAtom (HIWORD(lParam));
		 break;

	     case AA_REQUESTAVAILABLE:
	     case AA_REQUEST:
	     case AA_UNADVISE:
	     case AA_EXECUTE:
	     case AA_ADVISE:
		 pDdeObj->OnAck (pChannel, lParam);
		 break;

	     case AA_POKE:
		 // freeing pokedata is done in handleack
		 pDdeObj->OnAck (pChannel, lParam);
		 break;

	     default:
		 intrDebugOut((DEB_IERROR,
		      "ClientWndProc: WM_DDE_ACK unhandled\n"));
		 break;

	} // end of switch
	break;

    case WM_DDE_DATA:
	hData = GET_WM_DDE_DATA_HDATA(wParam,lParam);
	aItem = GET_WM_DDE_DATA_ITEM(wParam,lParam);
	intrDebugOut((DEB_ITRACE,
		      "CWP: WM_DDE_DATA pChannel(%x) hData(%x) aItem(%x)\n",
		      pChannel,hData,aItem));
	pDdeObj->OnData (pChannel, hData, aItem);

	break;

    case WM_DDE_TERMINATE:
	intrDebugOut((DEB_ITRACE,
		      "CWP: WM_DDE_TERMINATE pChannel(%x)\n",pChannel));


	if (pDdeObj->m_fDoingSendOnDataChange)
	{
	    //
	    // Cheese alert! This protocol is very bad. The original
	    // 16 bit code something even more worse, so we are stuck
	    // to do something roughly compatible.
	    //
	    // If fDoingSendOnDataChange, the client may be asking for
	    // additional information from the server. The way the code
	    // is structured, it doesn't handle OnTerminate gracefully
	    // in this case.
	    //
	    // To fix this, we first tell the call control that
	    // the server has died. Then we repost the terminate
	    // message so we can handle it later.
	    //
	    // The old code did a
	    // pDdeObj->QueueMsg (hwnd, message, wParam, lParam);
	    //
	    // and the old SendOnDataChange removed the message.
	    // This probably didn't work either, but was never
	    // actually encountered.
	    //

	    intrDebugOut((DEB_ITRACE,
			  "CWP: term doing SendOnDataChange \n"));
	    //
	    // If we got here, there should be a CallData assigned
	    // to the channel.
	    //
	    if (pChannel->pCD)
	    {
		intrDebugOut((DEB_ITRACE,"CWP: Setting call state\n"));

		pChannel->SetCallState(SERVERCALLEX_ISHANDLED, RPC_E_SERVER_DIED);

	    }
	    else
	    {
		//
		// If there is no call data, then we aren't waiting in
		// the channel. Terminate the conversation.
		//

		intrDebugOut((DEB_ERROR,"CWP: No call state exists\n"));
		pDdeObj->OnTerminate (pChannel, (HWND)wParam);
        break;
	    }

		//
		// Repost the message and try again.
		//
		intrDebugOut((DEB_ITRACE,"CWP: Reposting WM_DDE_TERMINATE\n"));
		PostMessage(hwnd,message,wParam,lParam);
	    break;
	}
	else
	{
	    pDdeObj->OnTerminate (pChannel, (HWND)wParam);
	}
	break;

    default:
        return SSDefWindowProc (hwnd, message, wParam, lParam);

    }

    return 0L;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\com\dde\client\ddeworkr.cxx ===
/*++

copyright (c) 1992  Microsoft Corporation

Module Name:

    ddeworkr.cpp

Abstract:

    This module contains the code for the worker routines

Author:

    Srini Koppolu   (srinik)    22-June-1992
    Jason Fuller    (jasonful)  24-July-1992

Revision History:
    Kevin Ross	    (KevinRo)   10-May-1994
    	Mostly added comments, and attempted to clean
	it up.

--*/
#include "ddeproxy.h"
#include "strsafe.h"

ASSERTDATA

/*
 *  WORKER ROUTINES
 *
 */


INTERNAL_(BOOL) wPostMessageToServer(LPDDE_CHANNEL pChannel,
				     WORD wMsg,
				     LPARAM lParam,
				     BOOL fFreeOnError)
{
    int c=0;
    intrDebugOut((DEB_ITRACE,
		  "wPostMessageToServer(pChannel=%x,wMsg=%x,lParam=%x,fFreeOnError=%x\n",
		  pChannel,
		  wMsg,
		  lParam,
		  fFreeOnError));
    if (NULL==pChannel)
    {
        AssertSz (0, "Channel missing");
        return FALSE;
    }
    pChannel->wMsg   = wMsg;
    pChannel->lParam = lParam;
    pChannel->hres   = NOERROR;

    while (TRUE && c<10 )
    {
        if (!IsWindow (pChannel->hwndSvr))
        {
       intrDebugOut((DEB_IWARN,
                  "wPostMessageToServer: invalid window %x\n",
                  pChannel->hwndSvr));
            goto errRet;
        }
        if (wTerminateIsComing (pChannel)
            && wMsg != WM_DDE_ACK
            && wMsg != WM_DDE_TERMINATE)
        {
	    intrDebugOut((DEB_IWARN,"Server sent terminate, cannot post\n"));
	    goto errRet;
        }
        if (!PostMessage (pChannel->hwndSvr, wMsg, (WPARAM) pChannel->hwndCli, lParam))
        {
	    intrDebugOut((DEB_IWARN,
                  "wPostMessageToServer: PostMessageFailed, yielding\n"));
            Yield ();
            c++;
        }
        else
            return TRUE;
    }
    AssertSz (0, "PostMessage failed");

errRet:
    intrDebugOut((DEB_IWARN,"wPostMessageToServer returns FALSE\n"));
    if (fFreeOnError)
    {
	DDEFREE(wMsg,lParam);
    }

    return FALSE;
}


// call Ole1ClassFromCLSID then global add atom; returns NULL if error.
INTERNAL_(ATOM) wAtomFromCLSID(REFCLSID rclsid)
{
    WCHAR szClass[MAX_STR];
    ATOM aCls;

	szClass[0] = 0;

    if (Ole1ClassFromCLSID2(rclsid, szClass, sizeof(szClass)) == 0)
        return NULL;
    aCls = wGlobalAddAtom(szClass);
    intrAssert(wIsValidAtom(aCls));
    return aCls;
}

INTERNAL_(ATOM) wGlobalAddAtom(LPCOLESTR sz)
{
    if (sz==NULL || sz[0] == '\0')
    {
        return NULL;
    }

    ATOM a = GlobalAddAtom(sz);
    intrAssert(wIsValidAtom(a));
    return a;
}

INTERNAL_(ATOM) wGlobalAddAtomA(LPCSTR sz)
{
    if (sz==NULL || sz[0] == '\0')
        return NULL;
    ATOM a = GlobalAddAtomA(sz);
    intrAssert(wIsValidAtom(a));
    return a;
}


INTERNAL_(ATOM) wGetExeNameAtom (REFCLSID rclsid)
{
    LONG    cb = MAX_STR;
    WCHAR    key[MAX_STR];
    ATOM    a;

	key[0] = 0;

    if (Ole1ClassFromCLSID2(rclsid, key, sizeof(key)) == 0)
        return NULL;

    StringCbCatW(key, sizeof(key), OLESTR("\\protocol\\StdFileEditing\\server"));

    if (QueryClassesRootValue (key, key, &cb))
    {
        Puts ("ERROR: wGetExeNameAtom failed\n");
        return NULL;
    }
    a = wGlobalAddAtom (key);
    intrAssert(wIsValidAtom(a));
    return a;
}

INTERNAL_(void) wFreeData (HANDLE hData, CLIPFORMAT cfFormat,
                           BOOL fFreeNonGdiHandle)
{
    intrDebugOut((DEB_ITRACE,
		  "wFreeData(hData=%x,cfFormat=%x,FreeNonGDIHandle=%x\n",
		  hData,
		  (USHORT)cfFormat,
		  fFreeNonGdiHandle));

    AssertSz (hData != NULL, "Trying to free NULL handle");
    AssertSz (hData != (HANDLE) LongToHandle(0xcccccccc), "Trying to free handle from a deleted object");

    switch (cfFormat) {
    case CF_METAFILEPICT:
        LPMETAFILEPICT  lpMfp;

        if (lpMfp = (LPMETAFILEPICT) GlobalLock (hData))
	{
	    intrDebugOut((DEB_ITRACE,
		          "wFreeData freeing metafile %x\n",
			  lpMfp->hMF));

	    OleDdeDeleteMetaFile(lpMfp->hMF);
            GlobalUnlock (hData);
        }
        GlobalFree (hData);
        break;

    case CF_BITMAP:
    case CF_PALETTE:
        Verify(DeleteObject (hData));
        break;

    case CF_DIB:
        GlobalFree (hData);
        break;

    default:
        if (fFreeNonGdiHandle)
            GlobalFree (hData);
        break;
    }
}



INTERNAL_(BOOL) wInitiate (LPDDE_CHANNEL pChannel, ATOM aLow, ATOM aHigh)
{
    intrDebugOut((DEB_ITRACE,"wInitiate(pChannel=%x,aLow=%x,aHigh=%x)\n",
          pChannel, aLow, aHigh));

    intrAssert(wIsValidAtom(aLow));
    if (aLow == (ATOM)0)
    {
	intrDebugOut((DEB_IERROR,"wInitiate Failed, aLow == 0\n"));
	return FALSE;
    }

    pChannel->iAwaitAck = AA_INITIATE;

    SSSendMessage ((HWND)-1, WM_DDE_INITIATE, (WPARAM) pChannel->hwndCli,
		  MAKE_DDE_LPARAM (WM_DDE_INITIATE, aLow, aHigh));

    pChannel->iAwaitAck = NULL;

    intrDebugOut((DEB_ITRACE,
		  "wInitiate pChannel->hwndSrvr = %x\n",
		  pChannel->hwndSvr));

    return (pChannel->hwndSvr != NULL);
}



INTERNAL_(HRESULT) wScanItemOptions (ATOM aItem, int FAR* lpoptions)
{
    ATOM    aModifier;
    LPOLESTR   lpbuf;
    WCHAR    buf[MAX_STR];

    *lpoptions = ON_CHANGE; // default

    if (!aItem) {
        // NULL item with no modifier means ON_CHANGE for NULL item
        return NOERROR;
    }

    intrAssert(wIsValidAtom(aItem));
    if (!GlobalGetAtomName (aItem, buf, MAX_STR))
    {
        goto errRtn;
    }
    lpbuf = buf;

    while ( *lpbuf && *lpbuf != '/')
           IncLpch (lpbuf);

    // no modifier same as /change

    if (*lpbuf == NULL)
        return NOERROR;

    *lpbuf++ = NULL;        // seperate out the item string
                            // We are using this in the caller.

    if (!(aModifier = GlobalFindAtom (lpbuf)))
    {
        Puts ("ERROR: wScanItemOptions found non-atom modifier\n");
        return ReportResult(0, RPC_E_DDE_SYNTAX_ITEM, 0, 0);
    }

    intrAssert(wIsValidAtom(aModifier));

    if (aModifier == aChange)
        return NOERROR;

    // Is it a save?
    if (aModifier == aSave){
        *lpoptions = ON_SAVE;
        return  NOERROR;
    }
    // Is it a Close?
    if (aModifier == aClose){
        *lpoptions = ON_CLOSE;
        return NOERROR;
    }

errRtn:
    // unknown modifier
    Puts ("ERROR: wScanItemOptions found bad modifier\n");
    return ReportResult(0, RPC_E_DDE_SYNTAX_ITEM, 0, 0);
}


INTERNAL_(BOOL) wClearWaitState (LPDDE_CHANNEL pChannel)
{
    Assert (pChannel);
    // kill if any timer active.
    if (pChannel->wTimer) {
        KillTimer (pChannel->hwndCli, 1);
        pChannel->wTimer = 0;

        if (pChannel->hDdePoke) {
            GlobalFree (pChannel->hDdePoke);
            pChannel->hDdePoke = NULL;
        }

        if (pChannel->hopt) {
            GlobalFree (pChannel->hopt);
            pChannel->hopt = NULL;
        }

	//
	// If the channel is waiting on an Ack, and there is an
	// lParam, then we may need to cleanup the data.

        if (pChannel->iAwaitAck && (pChannel->lParam)) {
            if (pChannel->iAwaitAck == AA_EXECUTE)
	    {
		//
		// KevinRo: Found the following comment in the code.
		// ; // get hData from GET_WM_DDE_EXECUTE_HADATA ??
		// It appears, by looking at what the 16-bit code does,
		// that the goal is to free the handle that was passed as
		// part of the EXECUTE message. Judging by what the 16-bit
		// code did, I have determined that this is correct.
		//
		// The macro used below wanted two parameters. The first was
		// the WPARAM, the second the LPARAM. We don't have the WPARAM.
		// However, it isn't actually used by the macro, so I have
		// cheated and provided 0 as a default
		//
		GlobalFree(GET_WM_DDE_EXECUTE_HDATA(0,pChannel->lParam));

#ifdef KEVINRO_HERE_IS_THE_16_BIT_CODE
                GlobalFree (HIWORD (pChannel->lParam));
#endif
	    }
            else
	    {
		//
		// All of the other DDE messages pass an Atom in the high word.
		// Therefore, we should delete the atom.
		//
		//
		ATOM aTmp;

		aTmp = (ATOM) MGetDDElParamHi(pChannel->wMsg,pChannel->lParam);

		intrAssert(wIsValidAtom(aTmp));
                if (aTmp)
		{
                    GlobalDeleteAtom (aTmp);
		}
            }
	    DDEFREE(pChannel->wMsg,pChannel->lParam);

            // we want to wipe out the lParam
            pChannel->lParam = 0x0;
        }

        return TRUE;
    }

    return FALSE;
}



// wNewHandle (LPSTR, DWORD)
//
// Copy cb bytes from lpstr into a new memory block and return a handle to it.
// If lpstr is an ASCIIZ string, cb must include 1 for the null terminator.
//

INTERNAL_(HANDLE) wNewHandle (LPSTR lpstr, DWORD cb)
{

    HANDLE  hdata  = NULL;
    LPSTR   lpdata = NULL;

    hdata = GlobalAlloc (GMEM_DDESHARE | GMEM_MOVEABLE, cb);
    if (hdata == NULL || (lpdata = (LPSTR) GlobalLock (hdata)) == NULL)
        goto errRtn;

    memcpy (lpdata, lpstr, cb);
    GlobalUnlock (hdata);
    return hdata;

errRtn:
    Puts ("ERROR: wNewHandle\n");
    Assert (0);
    if (lpdata)
        GlobalUnlock (hdata);

    if (hdata)
        GlobalFree (hdata);
    return NULL;
}



// wDupData
//
// Copy data from handle h into a new handle which is returned as *ph.
//

INTERNAL wDupData (LPHANDLE ph, HANDLE h, CLIPFORMAT cf)
{
    Assert (ph);
    RetZ (wIsValidHandle(h, cf));
    *ph = OleDuplicateData (h, cf, GMEM_DDESHARE | GMEM_MOVEABLE);
    RetZ (wIsValidHandle (*ph, cf));
    return NOERROR;
}


// wTransferHandle
//
//
INTERNAL wTransferHandle
    (LPHANDLE phDst,
    LPHANDLE phSrc,
    CLIPFORMAT cf)
{
    RetErr (wDupData (phDst, *phSrc, cf));
    wFreeData (*phSrc, cf, TRUE);
    *phSrc = (HANDLE)0;
    return NOERROR;
}


// wHandleCopy
//
// copy data from hSrc to hDst.
// Both handles must already have memory allocated to them.
//

INTERNAL wHandleCopy (HANDLE hDst, HANDLE hSrc)
{
    LPSTR lpDst, lpSrc;
    DWORD dwSrc;

    if (NULL==hDst || NULL==hSrc)
        return ResultFromScode (E_INVALIDARG);
    if (GlobalSize(hDst) < (dwSrc= (DWORD) GlobalSize(hSrc)))
    {
        HANDLE hDstNew = GlobalReAlloc (hDst, dwSrc, GMEM_DDESHARE | GMEM_MOVEABLE);
        if (hDstNew != hDst)
            return ResultFromScode (E_OUTOFMEMORY);
    }
    if (!(lpDst = (LPSTR) GlobalLock(hDst)))
    {
        intrAssert(!"ERROR: wHandleCopy hDst");
        return ReportResult(0, E_OUTOFMEMORY, 0, 0);
    }
    if (!(lpSrc = (LPSTR) GlobalLock(hSrc)))
    {
   GlobalUnlock(hDst);
        intrAssert (!"ERROR: wHandleCopy hSrc");
        return ReportResult(0, E_OUTOFMEMORY, 0, 0);
    }
    memcpy (lpDst, lpSrc, dwSrc);
    GlobalUnlock(hDst);
    GlobalUnlock(hSrc);
    return NOERROR;
}


// ExtendAtom: Create a new atom, which is the old one plus extension

INTERNAL_(ATOM) wExtendAtom (ATOM aItem, int iAdvOn)
{
    LPOLESTR   lpext = OLESTR("");

    switch (iAdvOn) {
        case ON_CHANGE:
            lpext = OLESTR("");
            break;

        case ON_SAVE:
            lpext = OLESTR("/Save");
            break;

        case ON_CLOSE:
            lpext = OLESTR("/Close");
            break;

        default:
            AssertSz (FALSE, "Unknown Advise option");
            break;

    }

    // Find the orignal atom name and append the extension, 
    // but don't allow buffer overrun.
    
    // compute length of extension to add
    int extLen = (int) wcslen(lpext);
    
    WCHAR  buffer[MAX_STR+1];
    buffer[0] = 0;

    // aItem==NULL for embedded objects.
    // If so, there is no item name before the slash.
    if (aItem)
        GlobalGetAtomName (aItem, buffer, MAX_STR-extLen);
   
    StringCbCatW(buffer, sizeof(buffer), lpext);
    
    if (buffer[0])
        return wGlobalAddAtom (buffer);
    else
        return NULL;
        // not an error. For embedded object on-change, aItem==NULL
}




INTERNAL_(ATOM) wDupAtom (ATOM a)
{
    WCHAR sz[MAX_STR] = {0};

    if (!a)
        return NULL;

    Assert (wIsValidAtom (a));
    GlobalGetAtomName (a, sz, MAX_STR);
    return wGlobalAddAtom (sz);
}



//+---------------------------------------------------------------------------
//
//  Function:   wAtomLen
//
//  Synopsis:   Return the length, in characters, of the atom name.
//      The length includes the NULL. This function returns the
//      length of the UNICODE version of the atom.
//
//  Effects:
//
//  Arguments:  [atom] --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    5-12-94   kevinro   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
INTERNAL_(int) wAtomLen (ATOM atom)
{
    WCHAR    buf[MAX_STR];

    if (!atom)
        return NULL;

    return (GlobalGetAtomName (atom, buf, MAX_STR));
}

//+---------------------------------------------------------------------------
//
//  Function:   wAtomLenA
//
//  Synopsis:   Return the length, in characters, of the atom name.
//      The length includes the NULL This function returns the
//      length of the ANSI version of the atom,
//
//  Effects:
//
//  Arguments:  [atom] --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    5-12-94   kevinro   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
INTERNAL_(int) wAtomLenA (ATOM atom)
{
    char    buf[MAX_STR];

    if (!atom)
        return NULL;

    return (GlobalGetAtomNameA (atom, (LPSTR)buf, MAX_STR));
}



// NOTE: returns address of static buffer.  Use return value immediately.
//


//+---------------------------------------------------------------------------
//
//  Function:   wAtomName
//
//  Synopsis:   Returns a STATIC BUFFER that holds the string name of the
//      atom.
//
//  Effects:
//
//  Arguments:  [atom] --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    5-12-94   kevinro   Commented
//
//  Notes:
//
//  WARNING:    This uses a static buffer, so don't depend on the pointer for
//      very long.
//
//----------------------------------------------------------------------------
INTERNAL_(LPOLESTR) wAtomName (ATOM atom)
{
    static WCHAR buf[MAX_STR];

    if (!atom)
        return NULL;

    if (0==GlobalGetAtomName (atom, buf, MAX_STR))
        return NULL;

    return buf;
}

//+---------------------------------------------------------------------------
//
//  Function:   wAtomName
//
//  Synopsis:   Returns a STATIC BUFFER that holds the string name of the
//      atom.
//
//  Effects:
//
//  Arguments:  [atom] --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    5-12-94   kevinro   Commented
//
//  Notes:
//
//  WARNING:    This uses a static buffer, so don't depend on the pointer for
//      very long.
//
//----------------------------------------------------------------------------
INTERNAL_(LPSTR) wAtomNameA (ATOM atom)
{
    static char buf[MAX_STR];

    if (!atom)
        return NULL;

    if (0==GlobalGetAtomNameA (atom, (LPSTR)buf, MAX_STR))
        return NULL;

    return buf;
}




//+---------------------------------------------------------------------------
//
//  Function:   wHandleFromDdeData
//
//  Synopsis:   Return a handle from the DDEDATA passed in.
//
//  Effects:    This function will return the correct data from the
//		DDEDATA that is referenced by the handle passed in.
//
//		DDEDATA is a small structure that is used in DDE to
//		specify the data type of the buffer, its release
//		semantics, and the actual data.
//
//		In the case of a known format, the handle to the
//		data is extracted from the DDEDATA structure, and
//		the hDdeData is released.
//
//		If its a Native format, the data is either moved
//		within the memory block allocated, or is copied to
//		another block, depending on the fRelease flag in
//		the hDdeData.
//
//  Arguments:  [hDdeData] -- Handle to DDEDATA
//
//  Requires:
//
//  Returns:	A handle to the data. hDdeData will be invalidated
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    5-13-94   kevinro   Commented
//
//  Notes:
//
// 	hDdeData is invalid after calling this function
//
//----------------------------------------------------------------------------


INTERNAL_(HANDLE) wHandleFromDdeData
    (HANDLE hDdeData)
{
    intrDebugOut((DEB_ITRACE,"wHandleFromDdeData(%x)\n",hDdeData));
    BOOL fRelease;
    HGLOBAL h = NULL; // return value

    DDEDATA FAR* lpDdeData = (DDEDATA FAR *) GlobalLock (hDdeData);

    //
    // If the handle is invalid, then the lpDdeData will be NULL
    //
    if (!lpDdeData)
    {
   intrDebugOut((DEB_ITRACE,
              "\twHandleFromDdeData(%x) invalid handle\n",
              hDdeData));
        return NULL;
    }


    //
    // The header section of a DDEDATA consists of 2 shorts.
    // That makes it 4 bytes. Due to the new packing values,
    // it turns out that doing a sizeof(DDEDATA) won't work,
    // because the size gets rounded up to a multple of 2
    //
    // We will just hard code the 4 here, since it cannot change
    // for all time anyway.
    //
    #define cbHeader 4
    Assert (cbHeader==4);

    //
    // If the cfFormat is BITMAP or METAFILEPICT, then the
    // handle will be retrieved from the first DWORD of the
    // buffer
    //
    if (lpDdeData->cfFormat == CF_BITMAP ||
        lpDdeData->cfFormat == CF_METAFILEPICT)
    {
       //
       // The alignment here should be fine, since the Value
       // field is DWORD aligned. So, we trust this cast
       //
#ifdef _WIN64
        if (lpDdeData->cfFormat == CF_METAFILEPICT)
            h = *(void* UNALIGNED*)lpDdeData->Value;
    	else
#endif
           h = LongToHandle(*(LONG*)lpDdeData->Value);

       Assert (GlobalFlags(h) != GMEM_INVALID_HANDLE);
       fRelease = lpDdeData->fRelease;
       GlobalUnlock (hDdeData);
       if (fRelease)
       {
	   GlobalFree (hDdeData);
       }

       return h;
    }
    else if (lpDdeData->cfFormat == CF_DIB)
    {
       //
       // The alignment here should be fine, since the Value
       // field is DWORD aligned.
       //
       // This changes the memory from fixed to moveable.
       //
        h = GlobalReAlloc (*(LPHANDLE)lpDdeData->Value, 0L,
                              GMEM_MODIFY|GMEM_MOVEABLE);
        Assert (GlobalFlags(h) != GMEM_INVALID_HANDLE);
        fRelease = lpDdeData->fRelease;
        GlobalUnlock (hDdeData);
        if (fRelease)
            GlobalFree (hDdeData);
        return h;
    }


    // Native and other data case
    // dwSize = size of Value array, ie, size of the data itself
    const DWORD dwSize = (DWORD) (GlobalSize (hDdeData) - cbHeader);

    if (lpDdeData->fRelease)
    {
        // Move the Value data up over the DDE_DATA header flags.
        memcpy ((LPSTR)lpDdeData, ((LPSTR)lpDdeData)+cbHeader, dwSize);
        GlobalUnlock (hDdeData);
   h = GlobalReAlloc (hDdeData, dwSize, GMEM_MOVEABLE);
        Assert (GlobalFlags(h) != GMEM_INVALID_HANDLE);
        return h;
    }
    else
    {
        // Duplicate the data because the server will free the original.
        h = wNewHandle (((LPSTR)lpDdeData)+cbHeader, dwSize);
        Assert (GlobalFlags(h) != GMEM_INVALID_HANDLE);
        GlobalUnlock (hDdeData);
        return h;
    }
}





//+---------------------------------------------------------------------------
//
//  Method:     CDdeObject::CanCallBack
//
//  Synopsis:   This routine apparently was supposed to determine if a
// 		call back could be made. However, the PeekMessage stuff
//		was commented out.
//
//		So, it returns TRUE if 0 or 1, FALSE but increments lpCount
//		if 2, returns true but decrements lpCount if > 3. Why?
//		Dunno. Need to ask JasonFul
//
//  Effects:
//
//  Arguments:  [lpCount] --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:
//
//  History:    5-16-94   kevinro   Commented, confused, and disgusted
//
//  Notes:
//
//----------------------------------------------------------------------------
INTERNAL_(BOOL) CDdeObject::CanCallBack (LPINT lpCount)
{
    switch (*lpCount) {
        case 0:
        case 1:
            return TRUE;

        case 2:
        {
//     MSG msg;
            if (0)
                //!PeekMessage (&msg, m_pDocChannel->hwndCli,0,0, PM_NOREMOVE) ||
               //   msg.message != WM_DDE_DATA)
            {
                Puts ("Server only sent one format (hopefully presentation)\n");
                return TRUE;
            }
            else
            {
                ++(*lpCount);
                return FALSE;
            }
        }

        case 3:
            --(*lpCount);
            return TRUE;

        default:
            AssertSz (FALSE, "012345" + *lpCount);
            return FALSE;
    }
}


INTERNAL_(BOOL) wIsOldServer (ATOM aClass)
{
    LONG    cb = MAX_STR;
    WCHAR    key[MAX_STR];
    int     len;

    if (aClass==(ATOM)0)
        return FALSE;

    if (!GlobalGetAtomName (aClass, key, (sizeof(key)) / sizeof(WCHAR)))
        return TRUE;

    StringCbCatW(key, sizeof(key), OLESTR("\\protocol\\StdFileEditing\\verb\\"));
    len = lstrlenW (key);
    if (len < MAX_STR-1)
    {
        key [len++] = (char) ('0');
        key [len++] = 0;
    }

    if (QueryClassesRootValue (key, key, &cb))
        return TRUE; // no verbs registered

    return FALSE;
}




INTERNAL_(void) wFreePokeData
    (LPDDE_CHANNEL pChannel,
     BOOL fMSDrawBug)
{
    DDEPOKE FAR * lpdde;

    if (!pChannel )
        return;

    if (!pChannel->hDdePoke)
        return;

    if (lpdde = (DDEPOKE FAR *) GlobalLock (pChannel->hDdePoke)) {

        // The old version of MSDraw expects the _contents_ of METAFILEPICT
        // structure, rather than the handle to it, to be part of DDEPOKE.

        if (fMSDrawBug && lpdde->cfFormat==CF_METAFILEPICT) {
	    intrDebugOut((DEB_ITRACE,
			  "wFreePokeData is accomodating MSDraw bug\n"));
            //
	    // This meta file was created in 32-bits, and was not passed
	    // into us by DDE. Therefore, this metafile should not need to
	    // call WOW to be free'd.
	    //
	    
	    LPMETAFILEPICT lpmfp = (LPMETAFILEPICT)*(void* UNALIGNED*)&lpdde->Value;
#ifdef _WIN64
            DeleteMetaFile(lpmfp->hMF);
#else
            DeleteMetaFile(lpmfp->hMF);
#endif
        }
        // If there is a normal metafile handle in the Value field,
        // it will be freed (if necessary) by the ReleaseStgMedium()
        // in DO::SetData
        GlobalUnlock (pChannel->hDdePoke);
    }
    GlobalFree (pChannel->hDdePoke);
    pChannel->hDdePoke = NULL;
}




INTERNAL_(HANDLE) wPreparePokeBlock
    (HANDLE hData, CLIPFORMAT cfFormat, ATOM aClass, BOOL bOldSvr)
{
    HANDLE  hDdePoke = NULL;
    LPSTR   lpBuf;

    if (!hData)
        return NULL;

    // The old version of MSDraw expects the contents of METAFILEPICT
    // structure to be part of DDEPOKE, rather than the handle to it.
    if ((cfFormat==CF_METAFILEPICT && !(aClass==aMSDraw && bOldSvr))
        || (cfFormat == CF_DIB)
        || (cfFormat == CF_BITMAP)) {

        Verify (lpBuf = wAllocDdePokeBlock (4, cfFormat, &hDdePoke));
		if (!lpBuf)
			return NULL;
        *((HANDLE FAR*)lpBuf) = hData;

    }
    else {
        // Handle the non-metafile case and the MS-Draw bug
        DWORD dwSize = (DWORD) GlobalSize (hData);

	if ((aClass == aMSDraw) && bOldSvr)
	{
	    intrDebugOut((DEB_ITRACE,
			  "wPreparePokeBlock is accomodating MSDraw bug\n"));
	}

        if (lpBuf = wAllocDdePokeBlock (dwSize, cfFormat, &hDdePoke)) {
            memcpy (lpBuf, GlobalLock(hData), dwSize);
            GlobalUnlock (hData);
        }
    }

    if (hDdePoke)
        GlobalUnlock (hDdePoke);
    return hDdePoke;
}


// wAllocDdePokeBlock
// The caller must unlock *phDdePoke when it is done using the return value
// of this function but before a DDe message is sent using *phDdePoke.
//

INTERNAL_(LPSTR) wAllocDdePokeBlock
    (DWORD dwSize, CLIPFORMAT cfFormat, LPHANDLE phDdePoke)
{
    HANDLE      hdde = NULL;
    DDEPOKE FAR * lpdde = NULL;

    if (!(hdde = GlobalAlloc (GMEM_DDESHARE | GMEM_ZEROINIT,
                 (dwSize + sizeof(DDEPOKE) - sizeof(BYTE) ))))
        return NULL;

    if (!(lpdde = (DDEPOKE FAR*)GlobalLock (hdde))) {
        GlobalFree (hdde);
        return NULL;
    }
    // hdde will be UnLock'ed in wPreparePokeBlock and Free'd in wFreePokeData
    lpdde->fRelease = FALSE;
    lpdde->cfFormat = cfFormat;
    *phDdePoke = hdde;
    return (LPSTR) &(lpdde->Value);
}


#ifdef OLD
INTERNAL_(ULONG) wPixelsToHiMetric
    (ULONG cPixels,
    ULONG cPixelsPerInch)
{
    return cPixels * HIMETRIC_PER_INCH / cPixelsPerInch;
}
#endif

// Can ask for icon based on either CLSID or filename
//

INTERNAL GetDefaultIcon (REFCLSID clsidIn, LPCOLESTR szFile, HANDLE FAR* phmfp)
{
    if (!(*phmfp = OleGetIconOfClass(clsidIn, NULL, TRUE)))
        return ResultFromScode(E_OUTOFMEMORY);

    return NOERROR;
}

#define DWTIMEOUT 1000L

INTERNAL wTimedGetMessage
    (LPMSG pmsg,
    HWND hwnd,
    WORD wFirst,
    WORD wLast)
{
    DWORD dwStartTickCount = GetTickCount();
    while (!SSPeekMessage (pmsg, hwnd, wFirst, wLast, PM_REMOVE))
    {
        if (GetTickCount() - dwStartTickCount > DWTIMEOUT)
        {
            if (!IsWindow (hwnd))
                return ResultFromScode (RPC_E_CONNECTION_LOST);
            else
                return ResultFromScode (RPC_E_SERVER_DIED);
        }
    }
    return NOERROR;
}


INTERNAL wNormalize
    (LPFORMATETC pformatetcIn,
    LPFORMATETC  pformatetcOut)
{
    if (pformatetcIn->cfFormat == 0
        && pformatetcIn->ptd == NULL            // Is WildCard
        && pformatetcIn->dwAspect == -1L
        && pformatetcIn->lindex == -1L
        && pformatetcIn->tymed == -1L)
    {
        pformatetcOut->cfFormat = CF_METAFILEPICT;
        pformatetcOut->ptd      = NULL;
        pformatetcOut->dwAspect = DVASPECT_CONTENT;
        pformatetcOut->lindex = DEF_LINDEX;
        pformatetcOut->tymed = TYMED_MFPICT;
    }
    else
    {
        memcpy (pformatetcOut, pformatetcIn, sizeof(FORMATETC));
    }
    return NOERROR;
}



INTERNAL wVerifyFormatEtc
    (LPFORMATETC pformatetc)
{
    intrDebugOut((DEB_ITRACE,
          "wVerifyFormatEtc(pformatetc=%x)\n",
          pformatetc));

    VDATEPTRIN  (pformatetc, FORMATETC);
    if (!HasValidLINDEX(pformatetc))
    {
        intrDebugOut((DEB_IERROR, "\t!HasValidLINDEX(pformatetc)\n"));
        return(DV_E_LINDEX);
    }

    if (0==(pformatetc->tymed & (TYMED_HGLOBAL | TYMED_MFPICT | TYMED_GDI)))
    {
   intrDebugOut((DEB_IERROR,
              "\t0==(pformatetc->tymed & (TYMED_HGLOBAL | TYMED_MFPICT | TYMED_GDI))\n"));
   return ResultFromScode (DV_E_TYMED);
    }
    if (0==(UtFormatToTymed (pformatetc->cfFormat) & pformatetc->tymed))
    {
   intrDebugOut((DEB_IERROR,
              "\t0==(UtFormatToTymed (pformatetc->cfFormat) & pformatetc->tymed)\n"));
        return ResultFromScode (DV_E_TYMED);
    }
    if (0==(pformatetc->dwAspect & (DVASPECT_CONTENT | DVASPECT_ICON)))
    {
   intrDebugOut((DEB_IERROR,
              "\t0==(pformatetc->dwAspect & (DVASPECT_CONTENT | DVASPECT_ICON))\n"));

        return ResultFromScode (DV_E_DVASPECT);
    }
    if (pformatetc->dwAspect & DVASPECT_ICON)
    {
        if (CF_METAFILEPICT != pformatetc->cfFormat)
   {
   intrDebugOut((DEB_IERROR,
              "\tCF_METAFILEPICT != pformatetc->cfFormat\n"));
            return ResultFromScode (DV_E_CLIPFORMAT);
   }

        if (0==(pformatetc->tymed & TYMED_MFPICT))
   {
   intrDebugOut((DEB_IERROR,
              "\t0==(pformatetc->tymed & TYMED_MFPICT)\n"));
            return ResultFromScode (DV_E_TYMED);
   }
    }
    if (pformatetc->ptd)
    {
        if (!IsValidReadPtrIn (pformatetc->ptd, sizeof (DWORD))
            || !IsValidReadPtrIn (pformatetc->ptd, (size_t)pformatetc->ptd->tdSize))
        {
       intrDebugOut((DEB_IERROR,"\tDV_E_DVTARGETDEVICE\n"));

            return ResultFromScode (DV_E_DVTARGETDEVICE);
        }
    }
    return NOERROR;
}



INTERNAL wClassesMatch
    (REFCLSID clsidIn,
    LPOLESTR szFile)
{
    CLSID clsid;
    if (NOERROR==GetClassFile (szFile, &clsid))
    {
        return clsid==clsidIn ? NOERROR : ResultFromScode (S_FALSE);
    }
    else
    {
        // If we can't determine the class of the file (because it's
        // not a real file) then OK.  Bug 3937.
        return NOERROR;
    }
}

#if DBG == 1

INTERNAL_(BOOL) wIsValidHandle
    (HANDLE h,
    CLIPFORMAT cf)    // cf==NULL means normal memory
{
    LPVOID p;
    if (CF_BITMAP == cf)
    {
        BITMAP bm;
        return (0 != GetObject (h, sizeof(BITMAP), (LPVOID) &bm));
    }
    if (CF_PALETTE == cf)
    {
        WORD w;
        return (0 != GetObject (h, sizeof(w), (LPVOID) &w));
    }
    if (!(p=GlobalLock(h)))
    {
        Puts ("Invalid handle");
        Puth (h);
        Putn();
        return FALSE;
    }
    if (!IsValidReadPtrIn (p, (UINT) min (UINT_MAX, GlobalSize(h))))
    {
        GlobalUnlock (h);
        return FALSE;
    }
    GlobalUnlock (h);
    return TRUE;
}
INTERNAL_(BOOL) wIsValidAtom (ATOM a)
{
    WCHAR sz[MAX_STR];
    if (a==0)
        return TRUE;
    if (a < 0xC000)
        return FALSE;
    if (0==GlobalGetAtomName (a, sz, MAX_STR))
        return FALSE;
    if ('\0'==sz[0])
        return FALSE;
    return TRUE;
}


// A "gentle" assert used in reterr.h
//


INTERNAL_(void) wWarn
    (LPSTR sz,
    LPSTR szFile,
    int iLine)
{
    intrDebugOut((DEB_WARN,
		  "Warning: %s:%u %s\n",
		  szFile,iLine,sz));
}

#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\com\dde\client\trgt_dev.h ===
// trgt_dev.h

// OLE 1.0 Target Device

typedef struct _OLETARGETDEVICE
{
    USHORT otdDeviceNameOffset;
    USHORT otdDriverNameOffset;
    USHORT otdPortNameOffset;
    USHORT otdExtDevmodeOffset;
    USHORT otdExtDevmodeSize;
    USHORT otdEnvironmentOffset;
    USHORT otdEnvironmentSize;
    BYTE otdData[1];
} OLETARGETDEVICE;

typedef OLETARGETDEVICE const FAR* LPCOLETARGETDEVICE;
typedef OLETARGETDEVICE FAR* LPOLETARGETDEVICE;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\com\dde\server\ddeatoms.h ===
/* ddeatoms.h */

//This is here because the file is #included by both client and server files
#define fDdeCodeInOle2Dll 1

// These atoms are defined in srvrmain.cpp 
extern ATOM aEditItems;
extern ATOM aFormats;
extern ATOM aOLE;
extern ATOM aProtocols;
extern ATOM aStatus;
extern ATOM aStdClose;
extern ATOM aStdCreate;
extern ATOM aStdCreateFromTemplate;
extern ATOM aStdEdit;
extern ATOM aStdExit;
extern ATOM aStdOpen;
extern ATOM aStdShowItem;
extern ATOM aSysTopic;
extern ATOM aTopics;

// defined in ddewnd.cpp
extern ATOM aChange;
extern ATOM aClose;
extern ATOM	aMSDraw;
extern ATOM aNullArg;
extern ATOM aOle;
extern ATOM	aSave;
extern ATOM aStdColorScheme;
extern ATOM aStdDocDimensions;
extern ATOM aStdDocName;
extern ATOM	aStdHostNames;
extern ATOM aStdTargetDevice ;
extern ATOM aSystem;

// defined in ddewnd.cpp
extern CLIPFORMAT cfBinary;             // "Binary format"
extern CLIPFORMAT cfNative;             // "NativeFormat"

// defined in srvrmain.cpp
extern CLIPFORMAT cfLink;               // "ObjectLink"
extern CLIPFORMAT cfOwnerLink;          // "Ownerlink"

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\com\dde\server\ddeadv.cxx ===
// ddeadv.cpp
//
// Mapping from DDE advise to/from OLE 2.0 advises
//
// Author:
//      Jason Fuller    jasonful    8-16-92
//
// Copyright (c) 1992  Microsoft Corporation

#include "ole2int.h"
#include "srvr.h"
#include "ddedebug.h"
ASSERTDATA


INTERNAL CDefClient::DoOle20Advise
    (OLE_NOTIFICATION   options,
    CLIPFORMAT  	cf)
{
    HRESULT hresult = NOERROR;
    FORMATETC formatetc;
    formatetc.cfFormat  = cf;
    formatetc.ptd       = m_ptd;
    formatetc.lindex    = DEF_LINDEX;
    formatetc.dwAspect  = DVASPECT_CONTENT;
			  // only types 1.0 client wants
    formatetc.tymed     = TYMED_HGLOBAL | TYMED_MFPICT | TYMED_GDI;

    intrDebugOut((DEB_ITRACE,
		  "%x _IN CDefClient::DoOle20Advise(options=%x,cf=%x)\n",
		  this,
		  options,
		  (ULONG)cf));
    ChkC(this);
    switch (options)
    {
	case OLE_CHANGED:
#ifdef UPDATE
	case OLE_SAVED:
#endif
	    if (0 == m_dwConnectionDataObj)
	    {
		Assert (m_lpdataObj);
		RetErr (m_lpdataObj->DAdvise  (&formatetc,0/* ADVF_PRIMEFIRST*/,
					    &m_AdviseSink,
					    &m_dwConnectionDataObj));
		Assert (m_dwConnectionDataObj != 0);
	    }
	    // Fall through:
	    // Even for OLE_CHANGED do an Ole Advise so we get OnClose
	    // notifications for linked objects.

#ifndef UPDATE
	case OLE_SAVED:
#endif
	case OLE_RENAMED: // Link case
	case OLE_CLOSED:
	    Assert (m_lpoleObj);
	    // Only do one OleObject::Advise even if 1.0 client asks
	    // for two advises for two different formats and two events,
	    // i.e., native and metafile, save and close.
	    if (m_lpoleObj && 0==m_dwConnectionOleObj)
	    {
		Puts ("Calling OleObject::Advise\r\n");
		Assert (m_dwConnectionOleObj == 0L);
		hresult = m_lpoleObj->Advise (&m_AdviseSink, &m_dwConnectionOleObj);
		if (hresult != NOERROR)
		{
		    goto errRtn;
		}
	    }
	    Assert (m_dwConnectionOleObj != 0);
	    break;

	default:
	    Assert(0);
	    break;
    }

errRtn:
    intrDebugOut((DEB_ITRACE,
		  "%x _OUT CDefClient::DoOle20Advise hresult=%x\n",
		  this,hresult));


    return NOERROR;
}




INTERNAL CDefClient::DoOle20UnAdviseAll
    (void)
{
    HRESULT hr;
    intrDebugOut((DEB_ITRACE,
		  "%x _IN CDefClient::DoOle20UnAdviseAll\n",
		  this));

    ChkC(this);
    if (m_dwConnectionOleObj != 0L)
    {
	if (m_lpoleObj)
	{
	    intrDebugOut((DEB_ITRACE,
			  "%x ::DoOle20UnAdviseAll unadvise OLE obj\n",
			  this));
	    Puts ("Unadvising ole obj\r\n");
	    hr = m_lpoleObj->Unadvise (m_dwConnectionOleObj);
	    intrAssert(hr == NOERROR);
	    m_dwConnectionOleObj = 0L;
	}
    }
    if (m_dwConnectionDataObj != 0L)
    {
	if (m_lpdataObj)
	{
	    intrDebugOut((DEB_ITRACE,
			  "%x ::DoOle20UnAdviseAll unadvise DATA obj\n",
			  this));
	    Puts ("Unadvising data obj\r\n");
	    hr = m_lpdataObj->DUnadvise (m_dwConnectionDataObj);
	    intrAssert(hr == NOERROR);
	    m_dwConnectionDataObj = 0L;
	}
    }
    intrDebugOut((DEB_ITRACE,
		  "%x _OUT CDefClient::DoOle20UnAdviseAll\n",
		  this));

    return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\com\dde\server\ddepack.h ===
#ifdef WIN32
extern "C"
{
#include <port1632.h>
}

#define MAKE_DDE_LPARAM(msg,lo,hi) PackDDElParam(msg,(UINT_PTR)lo,(UINT_PTR)hi)

#else

#define GET_WM_DDE_EXECUTE_HDATA(wParam,lParam) ((HANDLE) HIWORD(lParam))
#define GET_WM_DDE_DATA_HDATA(wParam,lParam) ((HANDLE) LOWORD(lParam))
#define GET_WM_DDE_REQUEST_ITEM(wParam,lParam) ((ATOM) HIWORD(lParam))
#define GET_WM_DDE_DATA_ITEM(wParam,lParam) ((ATOM) HIWORD(lParam))
#define MAKE_DDE_LPARAM(msg,lo,hi) MAKELONG(lo,hi)
#define DDEFREE(msg,lParam)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\com\dde\server\ddedebug.h ===
// ddeDebug.h
//
// Generic debug routines
//
// Author:
//		Jason Fuller	jasonful	8-16-92
//

#ifndef fDdedebug_h
#define fDdedebug_h

#define INTR_DDE 	0x00010000
#define INTR_CHNL 	0x00020000
#define INTR_PARAM 	0x00040000

//#define fDebugOutput
#define WIDECHECK(x) (x?x:L"<NULL>")
#define ANSICHECK(x) (x?x:"<NULL>")

#if DBG == 1
#define DEBUG_GUIDSTR(name,guid) WCHAR name [48]; StringFromGUID2( *guid , name , sizeof( name ) / sizeof(WCHAR));
#else
#define DEBUG_GUIDSTR(name,guid)
#endif
#ifdef _DEBUG

	// defined in clientddeworkr.cpp
	BOOL wIsValidHandle (HANDLE, CLIPFORMAT);
	BOOL wIsValidAtom (ATOM);

	#define DebugOnly(x) x
	#define ChkC(p) 			Assert (p && p->m_chk==chkDefClient)
	#define ChkS(p) 			Assert (p && p->m_chk==chkDdeSrvr)
	#define ChkD(p) 			Assert ((p) && (p)->m_chk==chkDdeObj)
	#define AssertIsDoc(p) 	Assert ((p) && (p)->m_pdoc==(p) && (p)->m_bContainer)
	
	#define ChkCR(p) 			RetZ (p && p->m_chk==chkDefClient)
	#define ChkSR(p) 			RetZ (p && p->m_chk==chkDdeSrvr)
	#define ChkDR(p) 			RetZ ((p) && (p)->m_chk==chkDdeObj)
	#define AssertIsDocR(p)	RetZ ((p) && (p)->m_pdoc==(p) && (p)->m_bContainer)

	#ifdef fDebugOutput
	
		#define Puti(i) do {char sz[50]; wsprintf(sz, " %lu ", (unsigned long) (i)); Puts(sz);} while(0)
		#define Puth(i) do {char sz[50]; wsprintf(sz, " 0x%lx ", (unsigned long) (i)); Puts(sz);} while(0)
		#define Puta(a) do {char sz[50]="NULL"; if (a) GlobalGetAtomName(a,sz,50); \
									Puth(a); Puts("\""); Puts(sz); Puts("\" "); } while(0)
		#define Putsi(i) do { Puts(#i " = "); Puti(i); Puts("\n");} while (0)
		#define Putn() Puts("\r\n")
	
	#else
	
		#undef  Puts
		#define Puts(i)  ((void)0)
		#define Puti(i)  ((void)0)
		#define Puth(i)  ((void)0)
		#define Puta(a)  ((void)0)
		#define Putsi(i) ((void)0)
		#define Putn()   ((void)0)
		
	#endif // fDebugOutput
	#define DEBUG_OUT(a,b) OutputDebugStringA(a);
#else
	#define DEBUG_OUT(a,b)
	#define Puti(i)  ((void)0)
	#define Puth(i)  ((void)0)
	#define Puta(a)  ((void)0)
	#define Putsi(i) ((void)0)
	#define Putn()   ((void)0)
	#define wIsValidHandle(h,cf) (TRUE)
	#define wIsValidAtom(a) (TRUE)
	#define DebugOnly(x)
	#define ChkC(p)
	#define ChkS(p)
	#define ChkD(p)
	#define AssertIsDoc(p)
	#define ChkCR(p)
	#define ChkSR(p)
	#define ChkDR(p)
	#define AssertIsDocR(p)
	
#endif // _DEBUG


// Stuff common to both client and server directories
	
#define POSITIVE_ACK (0x8000)
#define NEGATIVE_ACK (0x0000)

#include <reterr.h>

INTERNAL_(LPOLESTR) wAtomName (ATOM atom);
INTERNAL_(LPSTR) wAtomNameA (ATOM atom);
INTERNAL_(ATOM)	wDupAtom (ATOM aSrc);

INTERNAL wClassesMatch (REFCLSID clsid, LPOLESTR szFile);
INTERNAL wWriteFmtUserType (LPSTORAGE, REFCLSID);

#endif // fDdedebug_h
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\com\dde\server\ddesink.cxx ===
// ddesink.cpp
//
// Methods for CDefClient::CAdviseSinkImpl
//
// Author:
//      Jason Fuller    jasonful    8-16-92
//
// Copyright (c) 1990, 1991  Microsoft Corporation


#include <ole2int.h>
#include "srvr.h"
#include "ddedebug.h"


ASSERTDATA

STDUNKIMPL_FORDERIVED (DefClient, AdviseSinkImpl)

 BOOL PeekOneMessage
	(MSG FAR* pmsg,
	HWND hwnd,
	UINT message)
{
	// We have to verify pmsg->message because PeekMessage will return
	// WM_QUIT even if you didn't ask for it.

	if (SSPeekMessage (pmsg, hwnd, message, message, PM_REMOVE))
	{
		if (pmsg->message==message)
			return TRUE;
		else
		{
			AssertSz (pmsg->message == WM_QUIT, "Unexpected message");
			if (WM_QUIT==pmsg->message)
			{
				// Put message back
				PostQuitMessage ((int) pmsg->wParam);
			}
			return FALSE;
		}
	}
	else
		return FALSE;
}
		
	




STDMETHODIMP_(void) NC(CDefClient,CAdviseSinkImpl)::OnClose
    (void)
{
	MSG			msg;
	intrDebugOut((DEB_ITRACE,
		      "%x _IN CDefClient::OnClose\n",
		      this));

	ChkC(m_pDefClient);

	m_pDefClient->m_fInOnClose = TRUE;
	// AddRef/Release safety bracket.  Do not remove.
	m_pDefClient->m_pUnkOuter->AddRef();

	#ifdef _DEBUG
	if (m_pDefClient->m_bContainer)
	{
		if (NOERROR != m_pDefClient->NoItemConnections())
			Warn ("OnClose called on document before item");
	}
	#endif

	if (m_pDefClient->m_ExecuteAck.f)
	{
		// in case the server closes in the middle of a DoVerb, send the ACK
		// for the EXECUTE now to keep the messages in order.
		m_pDefClient->SendExecuteAck (NOERROR);
	}

	if (!m_pDefClient->m_fGotStdCloseDoc)
	{
		// if client sent us StdCloseDocument, then he certainly
		// is not in a state to receive callbacks
	    m_pDefClient->ItemCallBack (OLE_CLOSED);
	}

	// We have to check the message field because PeekMessage will return
	// WM_QUIT even if you didn't ask for it.
	if (PeekOneMessage (&msg, m_pDefClient->m_hwnd, WM_DDE_EXECUTE))
	{
	    LPARAM lp = MAKE_DDE_LPARAM(WM_DDE_ACK,POSITIVE_ACK,
			  GET_WM_DDE_EXECUTE_HDATA(msg.wParam,msg.lParam));

            intrDebugOut((DEB_ITRACE,
		          "0x%p ::OnClose found StdCloseDocument in queue\n",
			  this));

	    if(!PostMessageToClient ((HWND)msg.wParam,
				     WM_DDE_ACK,
				     (WPARAM) m_pDefClient->m_hwnd,
				     lp))
	    {
		DDEFREE(WM_DDE_ACK,lp);
	    }

	}


	ChkC (m_pDefClient);

	if (m_pDefClient->m_bContainer)
	{
		// If the document (container) is closing, then we
		// should send a TERMINATE to the client windows.
		// We don't do this for items because a client window
		// may still be connected to another item.
		// Items within one document share one window.

		m_pDefClient->SendTerminateMsg ();
		ChkC (m_pDefClient);
		AssertIsDoc (m_pDefClient);
		m_pDefClient->ReleaseAllItems();
	}
	else
	{
		m_pDefClient->RemoveItemFromItemList ();
	}

	// If item was deleted in client app, m_lpoleObj could be NULL
  	m_pDefClient->ReleaseObjPtrs ();

	// If "this" is an item, get the doc that contains this item
	LPCLIENT pdoc = m_pDefClient->m_pdoc;
	Assert (pdoc);
	
	Assert (pdoc->m_chk==chkDefClient);
	if (pdoc->m_chk==chkDefClient && pdoc->m_fRunningInSDI)
	if (pdoc->m_fRunningInSDI)
	{
		Puts ("Running in SDI\r\n");
		// The server app never registered a class factory, so no
		// RevokeClassFactory will trigger the destruction of the
		// CDdeServer, so we do it here if there are no other clients
		// connected to that CDdeServer
		if (pdoc->m_psrvrParent->QueryRevokeClassFactory())
		{
			// Assert (No sibling documents)
			Verify (NOERROR==pdoc->m_psrvrParent->Revoke());	
			pdoc->m_psrvrParent = NULL;
		}
	}
	m_pDefClient->m_fInOnClose = FALSE;

	// AddRef/Release safety bracket.  Do not remove.
	// Do not use m_pDefClient after this Release.
	m_pDefClient->m_pUnkOuter->Release();

	intrDebugOut((DEB_ITRACE,
		      "%x _OUT CDefClient::OnClose\n",
		      this));
}




STDMETHODIMP_(void) NC(CDefClient,CAdviseSinkImpl)::OnSave
    (THIS)
{
    intrDebugOut((DEB_ITRACE,
		  "%x _IN CDefClient::OnSave\n",
		  this));

    ChkC(m_pDefClient);
    if (!m_pDefClient->m_fInOleSave)
    {
	// If we called OleSave to get the native data, then of course
	// we will get an OnSave notification.
	m_pDefClient->ItemCallBack (OLE_SAVED);
    }
    intrDebugOut((DEB_ITRACE,
		  "%x _OUT CDefClient::OnSave\n",
		  this));
}



STDMETHODIMP_(void) NC(CDefClient,CAdviseSinkImpl)::OnDataChange
    (THIS_ FORMATETC FAR* pFormatetc,
    STGMEDIUM FAR* pStgmed)
{
    intrDebugOut((DEB_ITRACE,
		  "%x _IN CDefClient::OnDataChange pFormatetc=%x\n",
		  this,
		  pFormatetc));
    // note we are ignoring both the pformatetc and the pStgMed.
    // ItemCallBack will ask (using GetData) for the data the client wants.
    // We are treating a call to this function as a simple Ping.

    ChkC(m_pDefClient);
    m_pDefClient->ItemCallBack (OLE_CHANGED);
    intrDebugOut((DEB_ITRACE,
		  "%x _OUT CDefClient::OnDataChange\n",
		  this));
}



STDMETHODIMP_(void) NC(CDefClient,CAdviseSinkImpl)::OnRename
    (THIS_ LPMONIKER pmk)
{
    intrDebugOut((DEB_ITRACE,
		  "%x _IN CDefClient::OnRename pmk=%x\n",
		  this,pmk));

    LPOLESTR szFile=NULL;

    ChkC(m_pDefClient);
    if (Ole10_ParseMoniker (pmk, &szFile, NULL) != NOERROR)
    {
	// Wrong type of moniker
	intrDebugOut((DEB_IERROR,
		      "%x ::OnRename pmk=%x wrong moniker\n",
		      this,pmk));
    }
    else
    {
	intrDebugOut((DEB_ITRACE,
		      "%x ::OnRename pmk=%x pmk.Name=(%ws)\n",
		      this,
		      pmk,
		      WIDECHECK(szFile)));
	// Notify client
	m_pDefClient->ItemCallBack (OLE_RENAMED, szFile);
	CoTaskMemFree(szFile);
    }

    intrDebugOut((DEB_ITRACE,
		  "%x _OUT CDefClient::OnRename\n",
		  this));
}



STDMETHODIMP_(void) NC(CDefClient,CAdviseSinkImpl)::OnViewChange
    (THIS_ DWORD aspects, LONG lindex)
{
    // Response to IViewObjectAdvise::Advise, which we do not do
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\com\dde\server\ddeint.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       ddeint.h
//
//  Contents:   This file contains shared macros/state between the server
//		and client directories
//  Classes:
//
//  Functions:
//
//  History:    5-04-94   kevinro Commented/cleaned
//
//----------------------------------------------------------------------------

#define DEB_DDE_INIT	(DEB_ITRACE|DEB_USER1)

// global DDE class used to create windows in DDE.
extern LPTSTR  gOleDdeWindowClass;
extern HINSTANCE g_hinst;

// names of the DDE window classes
#define OLE_CLASS	   L"Ole2WndClass"
#define OLE_CLASSA	    "Ole2WndClass"

#define SRVR_CLASS	    (OLESTR("SrvrWndClass"))
#define SRVR_CLASSA         ("SrvrWndClass")

#define DDEWNDCLASS  WNDCLASS
#define DdeRegisterClass RegisterClass
#define DdeUnregisterClass UnregisterClass
#define DdeCreateWindowEx CreateWindowEx

STDAPI_(LRESULT) DocWndProc (HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);
STDAPI_(LRESULT) SrvrWndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);
STDAPI_(LRESULT) SysWndProc (HWND hwnd, UINT  message, WPARAM wParam, LPARAM lParam);
STDAPI_(LRESULT) ClientDocWndProc (HWND hwnd,   UINT  message, WPARAM wParam, LPARAM lParam);
STDAPI_(LRESULT) DdeCommonWndProc (HWND hwnd,   UINT  message, WPARAM wParam, LPARAM lParam);

BOOL SendMsgToChildren (HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);


#define SIZEOF_DVTARGETDEVICE_HEADER (sizeof(DWORD) + (sizeof(WORD) * 4))

// forward declarations
class       CDefClient;
typedef     CDefClient FAR *LPCLIENT;

class       CDDEServer;
typedef     CDDEServer FAR   *LPSRVR;
typedef     CDDEServer FAR   *HDDE;  // used by ClassFactory table


typedef struct tagDISPATCHDATA
{
    SCODE       scode;                  // might be no necessary
    LPVOID      pData;                  // pointer to channel data
} DISPATCHDATA, *PDISPATCHDATA;


// SERVERCALLEX is an extension of SERVERCALL and represents the set of
// valid responses from IMessageFilter::HandleIncoming Call.

typedef enum tagSERVERCALLEX
{
    SERVERCALLEX_ISHANDLED      = 0,    // server can handle the call now
    SERVERCALLEX_REJECTED       = 1,    // server can not handle the call
    SERVERCALLEX_RETRYLATER     = 2,    // server suggests trying again later
    SERVERCALLEX_ERROR          = 3,    // error?
    SERVERCALLEX_CANCELED       = 5     // client suggests canceling
} SERVERCALLEX;




//
// The wire representation of STDDOCDIMENSIONS is a 16-bit
// format. This means instead of 4 longs, there are
// 4 shorts. This structure is used below to pick the data
// from the wire representation.
// backward compatible is the name of the game.
//
typedef struct tagRECT16
{
  SHORT left;
  SHORT top;
  SHORT right;
  SHORT bottom;

} RECT16, *LPRECT16;

//+---------------------------------------------------------------------------
//
//  Function:   ConvertToFullHWND
//
//  Synopsis:	This function is used to convert a 16-bit HWND into a 32-bit
//		hwnd
//
//  Effects:	When running in a VDM, depending on who dispatches the message
//		we can end up with either a 16 or 32 bit window message. This
//		routine is used to make sure we always deal with a 32bit
//		HWND. Otherwise, some of our comparisions are incorrect.
//
//  Arguments:  [hwnd] -- HWND to convert. 16 or 32 bit is fine
//
//  Returns:	Always returns a 32 bit HWND
//
//  History:    8-03-94   kevinro   Created
//
//  Notes:
//	This routine calls a private function given to use by OLETHK32
//
//----------------------------------------------------------------------------
inline
HWND ConvertToFullHWND(HWND hwnd)
{
    if (IsWOWThreadCallable() &&
       ((((UINT_PTR)hwnd & (UINT_PTR)~0xFFFF) == 0) ||
        (((UINT_PTR)hwnd & (UINT_PTR)~0xFFFF) == (UINT_PTR)~0xFFFF)))
    {
	return(g_pOleThunkWOW->ConvertHwndToFullHwnd(hwnd));
    }
    return(hwnd);
}

inline
void OleDdeDeleteMetaFile(HANDLE hmf)
{
    intrDebugOut((DEB_ITRACE,
		  "OleDdeDeleteMetaFile(%x)\n",
		  hmf));
    if (IsWOWThreadCallable())
    {
	intrDebugOut((DEB_ITRACE,
	    	      "InWow: calling WOWFreeMetafile(%x)\n",
		      hmf));

        if (!g_pOleThunkWOW->FreeMetaFile(hmf))
	{
	    return;
	}
	intrDebugOut((DEB_ITRACE,
	    	      "WOWFreeMetafile(%x) FAILED\n",
		      hmf));
    }
    intrDebugOut((DEB_ITRACE,
		  "Calling DeleteMetaFile(%x)\n",
		  hmf));

    DeleteMetaFile((HMETAFILE)hmf);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\com\dde\server\ddeerr.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       ddeerr.h
//
//  Contents:   Error codes from the previous release
//
//  Classes:
//
//  Functions:
//
//  History:    4-26-94   kevinro Commented/cleaned
//
// This is actually the contents from ole2anac.h, with some parts removed.
// Specifically, including ole2anac.h renamed DAdvise and friends, which
// is bad.
//----------------------------------------------------------------------------
#if !defined( _OLE2ANAC_H_ )
#define _OLE2ANAC_H_

typedef enum tagSTGSTATE
{
    STGSTATE_DOC         = 1,
    STGSTATE_CONVERT     = 2,
    STGSTATE_FILESTGSAME = 4
} STGSTATE;


#define MK_E_EXCEEDED_DEADLINE      MK_E_EXCEEDEDDEADLINE
#define MK_E_NEED_GENERIC           MK_E_NEEDGENERIC
#define MK_E_INVALID_EXTENSION      MK_E_INVALIDEXTENSION
#define MK_E_INTERMEDIATE_INTERFACE_NOT_SUPPORTED \
    MK_E_INTERMEDIATEINTERFACENONOT_SUPPORTED
#define MK_E_NOT_BINDABLE           MK_E_NOTBINDABLE
#define S_TRUE                      S_OK

#define E_BLANK             OLE_E_BLANK
#define E_STATIC            OLE_E_STATIC
#define E_NOTRUNNING        OLE_E_NOTRUNNING
#define E_FORMAT            DV_E_CLIPFORMAT
#define OLE_E_CLSID         REGDB_E_CLASSNOTREG
#define OLE_E_NOTSUPPORTED  E_NOTIMPL
#define OLE_E_REGDB_KEY     REGDB_E_KEYMISSING
#define OLE_E_REGDB_FMT     REGDB_E_INVALIDVALUE


#define OLEVERB_PRIMARY     OLEIVERB_PRIMARY
#define OLEVERB_SHOW        OLEIVERB_SHOW

// these DDE error codes are not returned anymore; these definitions are
// here just to make existing code compile without changes.
#define RPC_E_FIRST    MAKE_SCODE(SEVERITY_ERROR, FACILITY_RPC,  0x000)
#define RPC_E_DDE_FIRST    MAKE_SCODE(SEVERITY_ERROR, FACILITY_RPC,  0x100)

#define RPC_E_DDE_BUSY              (RPC_E_DDE_FIRST + 0x0)
#define RPC_E_DDE_CANT_UPDATE       (RPC_E_DDE_FIRST + 0x1)
#define RPC_E_DDE_INIT              (RPC_E_DDE_FIRST + 0x2)
#define RPC_E_DDE_NACK              E_FAIL
#define RPC_E_DDE_LAUNCH            CO_E_APPNOTFOUND
#define RPC_E_DDE_POST              RPC_E_SERVER_DIED
#define RPC_E_DDE_PROTOCOL          (RPC_E_DDE_FIRST + 0x6)
#define RPC_E_DDE_REVOKE            (RPC_E_DDE_FIRST + 0x7)
#define RPC_E_DDE_SYNTAX_EXECUTE    RPC_E_INVALID_PARAMETER
#define RPC_E_DDE_SYNTAX_ITEM       RPC_E_INVALID_PARAMETER
#define RPC_E_DDE_UNEXP_MSG     	(RPC_E_DDE_FIRST + 0xa)
#define RPC_E_DDE_DATA              RPC_E_INVALID_PARAMETER


#define RPC_E_CONNECTION_LOST           (RPC_E_FIRST + 0x6)
#define RPC_E_BUSY                      (RPC_E_FIRST + 0x0)
#define RPC_E_MSG_REJECTED              (RPC_E_FIRST + 0x1)
#define RPC_E_CANCELLED                 (RPC_E_FIRST + 0x2)
#define RPC_E_DISPATCH_ASYNCCALL        (RPC_E_FIRST + 0x4)


#endif // _OLE2ANAC_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\com\dde\server\ddesrvr.h ===
/*
	ddesrvr.h
	Header file for ddesrvr.cpp
	
	Author:
		Jason Fuller	jasonful		8-11-92
*/

#ifndef fDdesrvr_h
#define fDdesrvr_h

// Defined in cftable.cpp
STDAPI RemGetInfoForCid
	(REFCLSID 				clsid,
	LPDWORD 					pgrf,
	LPCLASSFACTORY FAR* 	ppCF,
	LPHANDLE FAR* 			pphwndDde,
	BOOL FAR* FAR* 		ppfAvail,
	BOOL						fEvenIfHidden=FALSE);

INTERNAL DestroyDdeSrvrWindow	(HWND hwnd,	ATOM aClass);
INTERNAL CreateCommonDdeWindow (void);
INTERNAL DestroyCommonDdeWindow (void);

INTERNAL IsRunningInThisTask	(LPOLESTR szFile, BOOL FAR* pf);
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\com\dde\server\ddesite.cxx ===
// ddesite.cpp
//
// Methods for CDefClient::COleClientSiteImpl
//
// Author:
//      Jason Fuller    jasonful    8-16-92
//
// Copyright (c) 1990, 1991  Microsoft Corporation


#include <ole2int.h>
#include "srvr.h"
#include "ddedebug.h"

ASSERTDATA

STDUNKIMPL_FORDERIVED (DefClient, OleClientSiteImpl)


STDMETHODIMP NC(CDefClient,COleClientSiteImpl)::SaveObject
    (void)
{
    intrDebugOut((DEB_ITRACE,
		  "%x _IN CDefClient::SaveObject\n",
		  this));

    ChkC(m_pDefClient);

    if (!m_pDefClient->m_fGotStdCloseDoc)
	m_pDefClient->ItemCallBack (OLE_SAVED);

    intrDebugOut((DEB_ITRACE,
		  "%x _OUT CDefClient::SaveObject\n",
		  this));
    return NOERROR;
}



STDMETHODIMP  NC(CDefClient,COleClientSiteImpl)::GetContainer
    (LPOLECONTAINER  FAR * lplpContainer)
{
    VDATEPTROUT( lplpContainer, LPOLECONTAINER);
    *lplpContainer = NULL;

    ChkC(m_pDefClient);
    return ResultFromScode (E_NOTIMPL);
}



STDMETHODIMP NC(CDefClient,COleClientSiteImpl)::GetMoniker
    (DWORD dwAssign, DWORD dwWhichMoniker, LPMONIKER FAR* ppmk)
{
    VDATEPTROUT( ppmk, LPMONIKER);
    *ppmk = NULL;

    ChkC(m_pDefClient);
    // OLE 1.0 does not support linking to embeddings
    return ReportResult(0, E_NOTIMPL, 0, 0);
}

STDMETHODIMP NC(CDefClient,COleClientSiteImpl)::ShowObject
    (void)
{
    ChkC(m_pDefClient);
    Puts ("OleClientSite::ShowObject\r\n");
    // REVIEW:  what are we supposed do?
    return ResultFromScode (E_NOTIMPL);
}

STDMETHODIMP NC(CDefClient,COleClientSiteImpl)::OnShowWindow
    (BOOL fShow)
{
    ChkC(m_pDefClient);
    Puts ("OleClientSite::OnShowWindow\r\n");
    // REVIEW: what are we supposed do?
    return NOERROR;
}

STDMETHODIMP NC(CDefClient,COleClientSiteImpl)::RequestNewObjectLayout(void)
{
    ChkC(m_pDefClient);
    Puts ("OleClientSite::RequestNewObjectLayout\r\n");
    return ReportResult(0, S_FALSE, 0, 0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\com\dde\server\item.cxx ===
/****************************** Module Header ******************************\
* Module Name: Item.c Object(item) main module
*
* Purpose: Includes All the object releated routiens.
*
* Created: Oct 1990.
*
* Copyright (c) 1990, 1991  Microsoft Corporation
*
* History:
*    Raor (../10/1990)    Designed, coded
*
*
\***************************************************************************/


#include "ole2int.h"
//#include "cmacs.h"
#include <dde.h>
#include "ddeatoms.h"
#include "ddedebug.h"
#include "srvr.h"
#include "itemutil.h"

ASSERTDATA


// !!!change child enumeration.
// !!!No consistency in errors (Sometimes Bools and sometimes HRESULT).


//SearchItem: Searches for a given item in a document tree.
//If found, returns the corresponding client ptr.

INTERNAL_(LPCLIENT)   CDefClient::SearchItem
(
LPOLESTR        lpitemname
)

{
    ATOM    aItem;
    LPCLIENT    lpclient;

    ChkC(this);
    Assert (m_pdoc==this);
    Assert (m_bContainer);

    Puts ("DefClient::SearchItem\r\n");
    // If the item passed is an atom, get its name.
    if (!HIWORD(lpitemname))
    aItem = (ATOM) (LOWORD(PtrToUlong (lpitemname)));
    else if (!lpitemname[0])
    aItem = NULL;
    else
    aItem = GlobalFindAtom (lpitemname);

    // walk thru the items list and mtach for the itemname.
    lpclient = this;

    while (lpclient) {
    ChkC(lpclient);
    if (lpclient->m_aItem == aItem)
        return lpclient;
    // The NULL item is the client that is a container (the whole doc).
    // REVIEW: jasonful
    if (lpclient->m_bContainer && aItem==NULL)
        return lpclient;
    lpclient = lpclient->m_lpNextItem;
    }

    Puts ("SearchItem failed\r\n");
    return NULL;

}



// FindItem: Given the itemname and the doc obj ptr,
// searches for the the item (object) in the document tree.
// Items are lonked to the doc obj.

INTERNAL_(HRESULT)  CDefClient::FindItem
(
LPOLESTR        lpitemname,
LPCLIENT FAR *      lplpclient
)
{
    LPCLIENT    lpclient;
    WCHAR   buf[MAX_STR] = {0};

    Puts ("DefClient::FindItem "); Puts (lpitemname); Putn();
    ChkC(this);

    if (lpclient = SearchItem (lpitemname)) {
    // we found the item window

        ChkC(lpclient);
        *lplpclient = lpclient;
        return NOERROR;

    }

    if (!HIWORD(lpitemname)){
    if (LOWORD(lpitemname))
        GlobalGetAtomName ((ATOM)LOWORD(PtrToUlong (lpitemname)),
                   buf, MAX_STR);
    else
        buf[0] = NULL;
    
    lpitemname = buf;
    }

    // Item (object)window is not created yet. Let us create one.
    return RegisterItem (lpitemname, lplpclient, TRUE);
}



//RegisterItem: Given the document handle and the item string
//creates item with the given name in the doc obj list..

INTERNAL  CDefClient::RegisterItem
    (LPOLESTR          lpitemname,
    LPCLIENT FAR *  lplpclient,
    BOOL        bSrvr)
{
    LPCLIENT        pitemNew = NULL;
    HRESULT         hresult   = ReportResult(0, E_UNEXPECTED, 0, 0);
    LPOLEOBJECT     lpoleObj = NULL;
    LPOLEITEMCONTAINER  lpcontainer;

    intrDebugOut((DEB_ITRACE,
          "%x _IN CDefClient::RegisterItem(%ws)\n",
          this,WIDECHECK(lpitemname)));
    ChkC(this);
    AssertIsDoc(this);
    *lplpclient  = NULL;

    ErrZS (pitemNew = new CDefClient(NULL), E_OUTOFMEMORY);

    pitemNew->m_bTerminate = FALSE;
    pitemNew->m_bContainer = FALSE;       // not a container, i.e.,document


    // Set containing document
    pitemNew->m_pdoc = this;
    m_pUnkOuter->AddRef(); // item keeps its document alive
            // Corresponding Release is in CDefClient::~CDefClient

    if (!HIWORD(lpitemname)) {
    AssertSz (!bSrvr, "invalid lpitemname in RegisterItem\r\n");
    pitemNew->m_aItem = LOWORD(PtrToUlong (lpitemname));
    }
    else if (!lpitemname[0])
    pitemNew->m_aItem = NULL;
    else
    pitemNew->m_aItem = wGlobalAddAtom (lpitemname);

    lpoleObj = m_lpoleObj;

    // Call the server if the item is not one of the standard items.
    if (bSrvr) {

    // Call the server app for container interface
    hresult = lpoleObj->QueryInterface (IID_IOleItemContainer, (LPVOID FAR *)&lpcontainer);

    if (hresult != NOERROR)
    {
        intrDebugOut((DEB_IERROR,
              "%x ::RegisterItem(%ws) No IOleContainer intr\n",
              this,WIDECHECK(lpitemname)));
        goto errRtn;
    }

    hresult = lpcontainer->GetObject(lpitemname, BINDSPEED_INDEFINITE, 0,
        IID_IOleObject, (LPLPVOID)&pitemNew->m_lpoleObj);

        if (hresult != NOERROR)
    {
        intrDebugOut((DEB_ERROR,
              "IOleItemContainer::GetObject(%ws,...) failed (hr=%x)\n",
              lpitemname,
              hresult));
    }

    lpcontainer->Release ();
    if (hresult != NOERROR)
        goto errRtn;

    hresult = pitemNew->m_lpoleObj->QueryInterface (IID_IDataObject, (LPLPVOID)
                           &pitemNew->m_lpdataObj);

        if (hresult != NOERROR)
    {
        intrDebugOut((DEB_ERROR,
              "::QueryInterface(IID_IDataObject) failed (hr=%x)\n",
              hresult));
        pitemNew->m_lpoleObj->Release();
            goto errRtn;
    }


    // This is for Packager, in particular.  If client does not advise
    // on any data, we still need to do an OLE advise so we can get
    // OnClose notifications.
    pitemNew->DoOle20Advise (OLE_CLOSED, (CLIPFORMAT)0);
    }



    // This keeps the CDefClient alive until _we_ are done with it
    // The corresponding Release is in CDefClient::Revoke
    pitemNew->m_pUnkOuter->AddRef();

    pitemNew->m_lpNextItem    = m_lpNextItem;
    pitemNew->m_hwnd          = m_hwnd; // set the window handle to
                    // same as the doc level window

    m_lpNextItem = pitemNew;
    *lplpclient  = pitemNew;

    hresult = NOERROR;
    goto exitRtn;

errRtn:
    if (pitemNew) {
    delete pitemNew;
    }

exitRtn:
    intrDebugOut((DEB_ITRACE,
          "%x CDefClient::RegisterItem(%ws) hresult=%x\n",
          this,WIDECHECK(lpitemname),hresult));


    return(hresult);
}



// Return NOERROR if "this" document has no items which have connections
// (client windows).
//
INTERNAL CDefClient::NoItemConnections (void)
{
    PCLINFO       pclinfo = NULL;
    HANDLE        hcliPrev = NULL;
    HANDLE        hcli;
    PCLILIST      pcli;
    HANDLE        *phandle;

    ChkCR (this);
    AssertIsDoc (this);
    LPCLIENT pitem;
    for (pitem = m_lpNextItem;
     pitem;
     pitem = pitem->m_lpNextItem)
    {
    ChkCR (pitem);
    if (pitem->m_aItem == aStdDocName)
        continue;
    hcli = pitem->m_hcliInfo;
    while (hcli)
    {
        if ((pcli = (PCLILIST) LocalLock (hcli)) == NULL)
        return ResultFromScode (S_FALSE);

        phandle = (HANDLE *) (pcli->info);
        while (phandle < (HANDLE *)(pcli + 1))
        {
        if (*phandle)
        {
            LocalUnlock (hcli);
            return ResultFromScode (S_FALSE);
        }
        else
        {
            phandle++;
            phandle++;
        }
        }

        hcliPrev = hcli;
        hcli = pcli->hcliNext;
        LocalUnlock (hcliPrev);
    }
    }
    return NOERROR;
}
    


INTERNAL_(void) CDefClient::DeleteAdviseInfo (void)
{


    PCLINFO       pclinfo = NULL;
    HANDLE        hcliPrev = NULL;
    PCLILIST      pcli;
    HANDLE        *phandle;
    HANDLE        hcli;
    HANDLE        hcliInfo;

    Puts ("DefClient::DeleteAdviseInfo\r\n");
    ChkC(this);
    hcli = m_hcliInfo;
    while (hcli) {
    if ((pcli = (PCLILIST) LocalLock (hcli)) == NULL)
        return;

    phandle = (HANDLE *) (pcli->info);
    while (phandle < (HANDLE *)(pcli + 1)) {
        if (*phandle) {
        *phandle++ = 0;

        // delete the printer dev info block
        if(pclinfo = (PCLINFO)LocalLock ((hcliInfo = *phandle++))){
            if(pclinfo->hdevInfo)
            GlobalFree (pclinfo->hdevInfo);

            LocalUnlock (hcliInfo);
            // no free if lock failed
            LocalFree (hcliInfo);
        }
        } else {
        phandle++;
        phandle++;

        }
    }

    hcliPrev = hcli;
    hcli = pcli->hcliNext;
    LocalUnlock (hcliPrev);
    LocalFree (hcliPrev);       // free the block;
    }
    m_hcliInfo = NULL;
}



//DeleteFromItemsList: Deletes a client from the object lists of
//all the objects of a given  document. Thie client possibly
//is terminating the conversation with our doc window.
//
INTERNAL_(void) CDefClient::DeleteFromItemsList
    (HWND hwndClient)
{
    HANDLE          hclinfo;
    PCLINFO         pclinfo;
    LPCLIENT        lpclient;
    LPCLIENT FAR*   ppitemLast = NULL;
    BOOL        fRevokedDoc = FALSE;
    static int staticcounter;
    int counter = ++staticcounter;

    Puts ("DefClient::DeleteFromItemsList "); Puti(counter); Putn();
    AssertIsDoc(this);
    lpclient = this;
    ppitemLast = &m_lpNextItem;
    while (lpclient)
    {
    ChkC(lpclient);
    BOOL fDoc = (lpclient==this);
    if (fDoc)
    {
        AssertIsDoc (lpclient);
        // Remove window from doc's master list
        HWND hwnd = (HWND) FindClient (lpclient->m_hcli, hwndClient, /*fDelete*/TRUE);
        Assert (hwnd==hwndClient);
    }

    hclinfo = FindClient (lpclient->m_hcliInfo, hwndClient, /*fDelete*/TRUE);
    LPCLIENT pitemNext = lpclient->m_lpNextItem;

    // We must make sure no other client is connected (linked)
    // to this item before deleting.
    if (!fDoc && AreNoClients (lpclient->m_hcliInfo))
    {
        Assert (ppitemLast);
        if (ppitemLast && !fDoc)
        {
        // Remove from linked list
        *ppitemLast = lpclient->m_lpNextItem;
        }
        fRevokedDoc |= fDoc;
        lpclient->Revoke ();
    }
    else
    {
        ppitemLast = &(lpclient->m_lpNextItem);
    }
    if (hclinfo)
    {
        if(pclinfo = (PCLINFO)LocalLock (hclinfo))
        {
        if(pclinfo->hdevInfo)
            GlobalFree (pclinfo->hdevInfo);
        LocalUnlock (hclinfo);
        }
        LocalFree (hclinfo);
    }
    lpclient = pitemNext;
    }

    // Handle invisible update
    if (!fRevokedDoc && !m_fEmbed //&& !m_fGotDdeAdvise
    && NOERROR ==NoItemConnections()
    && AreNoClients (m_hcliInfo)
    && AreNoClients (m_hcli) )
    {
    ChkC (this);
    Assert (m_lpoleObj);
    Assert (m_lpdataObj);
    ReleaseObjPtrs();
    }
    
    Puts ("DefClient::DeleteFromItemsList Done "); Puti(counter); Putn();
}


INTERNAL_(void) CDefClient::RemoveItemFromItemList
    (void)
{
    // Make sure it's an item
    Assert (m_pdoc != this && !m_bContainer);

    LPCLIENT lpclient = m_pdoc;
    ChkC (lpclient);
    LPCLIENT FAR* ppitemLast = &(m_pdoc->m_lpNextItem);

    while (lpclient)
    {
        ChkC(lpclient);
        if (lpclient==this)
        {
            // Remove from linked list
            *ppitemLast = lpclient->m_lpNextItem;
            break;
        }       
        ppitemLast = &(lpclient->m_lpNextItem);
        lpclient = lpclient->m_lpNextItem;
    }
    Revoke();
}




INTERNAL_(void) CDefClient::ReleaseAllItems ()
{
    LPCLIENT        lpclient;

    Puts ("DefClient::ReleaseAllItems\r\n");
    AssertIsDoc(this);

    // leave the doc level object.
    lpclient = m_lpNextItem;

    while (lpclient)
    {
    ChkC(this);
    LPCLIENT pitemNext = lpclient->m_lpNextItem;
    lpclient->Revoke();
    lpclient = pitemNext;
    }
    // After revoking all the items, we can't keep any refernces to them.
    m_lpNextItem = NULL;
}



INTERNAL_(void)   CDefClient::DeleteAllItems ()
{
    LPCLIENT    lpclient;

    Puts ("DefClient::DeleteAllItems\r\n");
    AssertIsDoc(this);

    // leave the doc level object.
    lpclient = m_lpNextItem;

    while (lpclient)
    {
    ChkC(lpclient);
    if (ISATOM(lpclient->m_aItem))
        GlobalDeleteAtom (lpclient->m_aItem);
    // Delete client advise info
    lpclient->DeleteAdviseInfo ();

    lpclient = lpclient->m_lpNextItem;
    }
}




// PokeData: Prepares and gives the data to the server app thru
// the SetData object method.

INTERNAL CDefClient::PokeData(HWND hwndClient,ATOM aItem,HANDLE hPoke)
{
    HRESULT         hresult = ReportResult(0, E_UNEXPECTED, 0, 0);
    DDEPOKE FAR *   lpPoke = NULL;
    int         format;
    BOOL        fRelease       = FALSE;
    LPPERSISTSTORAGE pPersistStg=NULL;
    FORMATETC       formatetc;
    STGMEDIUM       medium;

    // Due to a C7 bug, do not use a structure initialization for STGMEDIUM
    medium.tymed = TYMED_HGLOBAL;
    medium.hGlobal = NULL; // invalid
    medium.pUnkForRelease= NULL;

    intrDebugOut((DEB_ITRACE,
          "%p CDefClient::PokeData(hwndClient=%x,aItem=%x,hPoke=%x)\n",
          this,hwndClient,aItem,hPoke));

    ChkC(this);
    AssertIsDoc (this);


    // Until now, m_aItem had been the client-generated (ugly) document name.
    // Now it becomes the actual item name, which will almost always be NULL.
    // Only in the TreatAs/ConvertTo case will it be non-NULL.
    m_aItem = aItem;

    formatetc.cfFormat = 0; /* invalid */
    formatetc.ptd = m_ptd;
    formatetc.lindex = DEF_LINDEX;
    formatetc.dwAspect = DVASPECT_CONTENT;
    formatetc.tymed = TYMED_HGLOBAL;

    ErrZS (hPoke && (lpPoke = (DDEPOKE FAR *) GlobalLock (hPoke)),
       E_OUTOFMEMORY);

    format = formatetc.cfFormat = lpPoke->cfFormat;
    Assert (format);
    fRelease = lpPoke->fRelease;

    // We found the item. Now prepare the data to be given to the object
    // MakeItemData returns a newly allocated handle.
    if (!(medium.hGlobal = MakeItemData (lpPoke, hPoke, (CLIPFORMAT) format)))
    goto errRtn;

    // Change type acording to format (not that default has been set above)
    if (format == CF_METAFILEPICT)
    formatetc.tymed = medium.tymed = TYMED_MFPICT;
    else
    if (format == CF_BITMAP)
    formatetc.tymed = medium.tymed = TYMED_GDI;

    // Now send the data to the object
    

    if (formatetc.cfFormat==g_cfNative)
    {
        m_fGotEditNoPokeNativeYet = FALSE;

        // Cannot do SetData.  Must do PersisStg::Load on an IStorage
        // made from the native data, i.e., medium.hGlobal.

        Assert (m_plkbytNative==NULL);
        hresult = CreateILockBytesOnHGlobal (medium.hGlobal,
                            /*fDeleteOnRelease*/TRUE,
                            &m_plkbytNative);

        if (hresult != NOERROR)
        {
            if(medium.hGlobal) ReleaseStgMedium(&medium);
            medium.hGlobal = NULL;
            ErrRtnH(hresult);
        }


        Assert (m_pstgNative==NULL);

        if (NOERROR==StgIsStorageILockBytes(m_plkbytNative))
        {
            // This is a flattened 2.0 storage
            ErrRtnH (StgOpenStorageOnILockBytes (m_plkbytNative,
                            (LPSTORAGE)NULL,
                STGM_READWRITE| STGM_SHARE_EXCLUSIVE| STGM_DIRECT,
                            (SNB)NULL,
                            0,
                            &m_pstgNative));
        }
        else
        {
            // It is a raw 1.0 Native handle.
            // This is the TreatAs/ ConvertTo case.
            LPLOCKBYTES plkbyt = NULL;
            Assert (m_psrvrParent->m_aOriginalClass);

            ErrRtnH (wCreateStgAroundNative (medium.hGlobal,
                             m_psrvrParent->m_aOriginalClass,
                             m_psrvrParent->m_aClass,
                             m_psrvrParent->m_cnvtyp,
                             m_aItem,
                             &m_pstgNative,
                             &plkbyt));


            Assert (m_plkbytNative);
            if (m_plkbytNative)
            {
            // This should free the original native hGlobal also.
            m_plkbytNative->Release();
            medium.hGlobal = NULL;
            }
            m_plkbytNative = plkbyt;

        }

        RetZ (m_pstgNative);
        Assert (m_lpoleObj);
        ErrRtnH (m_lpoleObj->QueryInterface (IID_IPersistStorage,
                            (LPLPVOID) &pPersistStg));
        hresult = pPersistStg->Load (m_pstgNative);
        pPersistStg->Release();
        pPersistStg=NULL;
        ErrRtnH (hresult);

        // Now that we have initialized the object, we can call SetClientSite
        ErrRtnH (SetClientSite() );

        // This is for Packager, in particular.  If client does not advise
        // on any data, we still need to do an OLE advise so we can get
        // OnClose notifications.
        ErrRtnH (DoOle20Advise (OLE_CLOSED, (CLIPFORMAT)0));
    }
    else
    {
        if (m_fGotEditNoPokeNativeYet)
        {
            // We got StdEdit, but instead of getting Poke for native data,
            // we got poke for someother format. So we want to generate
            // InitNew() call for the object.

            hresult = DoInitNew();
            if (hresult != NOERROR)
            {
                if(medium.hGlobal) ReleaseStgMedium(&medium);
                medium.hGlobal = NULL;
                ErrRtnH(hresult);
            }
        }
            
        // Not native format, do SetData
        // Callee frees medium, i.e., the hglobal returned by MakeItemData
        Assert (m_lpdataObj);
        hresult = m_lpdataObj->SetData (&formatetc, &medium, TRUE);

#ifdef _DEBUG
        if (hresult != NOERROR)
        {
            Puts ("****WARNING: SetData failed. cfFormat==");
            WCHAR sz[100];
            GetClipboardFormatName (formatetc.cfFormat, sz, 100);
            Puts (sz);
            Putn();
        }
#endif
        // We free the data if server deos not return NOERROR.
        // Otherwise server must've deleted it.
        if (hresult == NOERROR)
            medium.hGlobal = NULL;
        else if(medium.hGlobal)
            ReleaseStgMedium(&medium);
    }


errRtn:
    GlobalUnlock (hPoke);

    if (fRelease && hPoke)
        GlobalFree (hPoke);

// Do NOT free medium.hGlobal, because it becomes the hGlobal on which
// m_plkbytNative (and therefore m_pstgNative) is based.
// It will be freed when m_plkbytNative is Release().
//    if (medium.hGlobal)
//        ReleaseStgMedium(&medium);
    

    if (pPersistStg)
        pPersistStg->Release();

    return hresult;
}



INTERNAL_(HRESULT)   CDefClient::UnAdviseData
    (HWND            hwndClient,
     ATOM        aItem)
{
    WCHAR       buf[MAX_STR] = {0};
    int         options;
    LPCLIENT        lpclient;
    HRESULT         hresult  = ReportResult(0, E_UNEXPECTED, 0, 0);
    HANDLE          hclinfo = NULL;
    PCLINFO         pclinfo = NULL;

    Puts ("DefClient::UnadviseData\r\n");
    ChkC(this);

    if (aItem == NULL)
    {
    buf[0] = NULL;
    }
    else
    {
    GlobalGetAtomName (aItem, buf, MAX_STR);
    }

    // Scan for the advise options like "Close", "Save" etc
    // at the end of the item.

    ErrRtnH (ScanItemOptions (buf, (int far *)&options));

    // Now get the corresponding object.
    ErrRtnH (FindItem (buf, (LPCLIENT FAR *)&lpclient));

    // Find the client structure to be attached to the object.
    if ((hclinfo = FindClient (lpclient->m_hcliInfo, hwndClient, FALSE)) == NULL ||
    (pclinfo = (PCLINFO) LocalLock (hclinfo)) == NULL )
    {
        hresult = ReportResult(0, E_OUTOFMEMORY, 0, 0);
        goto errRtn;
    }

    pclinfo->options &= (~(0x0001 << options));

errRtn:
    if (pclinfo)
    LocalUnlock (hclinfo);
    return hresult;

}



// AdviseStdItems: This routine takes care of the DDEADVISE for a
//particular object in given document. Creates a client strutcure
//and attaches to the property list of the object window.

INTERNAL_(HRESULT)   CDefClient::AdviseStdItems
(

HWND        hwndClient,
ATOM        aItem,
HANDLE      hopt,
BOOL FAR *  lpfack
)
{

    DDEADVISE FAR       *lpopt;
    HRESULT         hresult = ReportResult(0, E_UNEXPECTED, 0, 0);


    intrDebugOut((DEB_ITRACE,
          "%x _IN CDefClient::AdviseStdItems(hwndClient=%x,aItem=%x(%ws),hopt=%x)\n",
          this,
          hwndClient,
          aItem,
          wAtomName(aItem),
          hopt));

    ChkC(this);
    ErrZS (lpopt = (DDEADVISE FAR *) GlobalLock (hopt), E_OUTOFMEMORY);

    AssertSz (aItem == aStdDocName, "AdviseStdItem is not Documentname");

    *lpfack = lpopt->fAckReq;
    hresult = (HRESULT)SetStdInfo (hwndClient, OLESTR("StdDocumentName"),  NULL);


    if (lpopt)
    GlobalUnlock (hopt);

errRtn:

    if (hresult == NOERROR)
    {
    // Rules say to free handle if ACK will be positive
    GlobalFree (hopt);
    }
    Assert (hresult==NOERROR);
    intrDebugOut((DEB_ITRACE,
          "%x _OUT CDefClient::AdviseStdItems hresult=%x\n",
          this,
          hresult));

    return hresult;
}



//AdviseData: This routine takes care of the DDE_ADVISE for a
//particular object in given document. Creates a client strutcure
//and attaches to the property list of the object window.

INTERNAL CDefClient::AdviseData
(
HWND        hwndClient,
ATOM        aItem,
HANDLE      hopt,
BOOL FAR *  lpfack
)
{
    DDEADVISE FAR   *lpopt = NULL;
    int         format = NULL;
    WCHAR       buf[MAX_STR] = {0};
    OLE_NOTIFICATION  options;
    LPCLIENT        lpclient;
    HRESULT         hresult  = ReportResult(0, E_UNEXPECTED, 0, 0);
    HANDLE          hclinfo = NULL;
    PCLINFO         pclinfo = NULL;
    BOOL            fAllocatedClInfo = FALSE;

    intrDebugOut((DEB_ITRACE,
          "%x _IN CDefClient::AdviseData(hwndClient=%x,aItem=%x(%ws),hopt=%x)\n",
          this,
          hwndClient,
          aItem,
          wAtomName(aItem),
          hopt));
    ChkC(this);
    if (m_fGotEditNoPokeNativeYet) {
        // We got StdEdit, but instead of getting Poke for native data,
        // we got advise. So we want to generate InitNew() call for
        // the object.

        DoInitNew();    // the function clears the flag
    }

    m_fGotDdeAdvise = TRUE;

    ErrZS (lpopt = (DDEADVISE FAR *) GlobalLock (hopt), E_OUTOFMEMORY);

    if (!aItem)
    buf[0] = NULL;
    else
    GlobalGetAtomName (aItem, buf, MAX_STR);

    // Scan for the advise options like "Close", "Save" etc
    // at the end of the item.

    // ack flag should be set before the error return. Otherwise the
    // the atom is getting deleted.

    *lpfack = lpopt->fAckReq;
    ErrRtnH (ScanItemOptions (buf, (int far *)&options));

    // Now get the corresponding item.
    ErrRtnH (FindItem (buf, (LPCLIENT FAR *)&lpclient));

    if (!IsFormatAvailable ((CLIPFORMAT)(unsigned short)lpopt->cfFormat)){
    hresult = ReportResult(0, DV_E_CLIPFORMAT, 0, 0);       // this format is not supported;
    goto errRtn;
    }

    lpclient->DoOle20Advise (options, (CLIPFORMAT)(unsigned short)lpopt->cfFormat);


    // Create the client structure to be attcahed to the object.
    if (!(hclinfo = FindClient (lpclient->m_hcliInfo, hwndClient, FALSE)))
    {
    hclinfo = LocalAlloc (LMEM_MOVEABLE | LMEM_ZEROINIT, sizeof (CLINFO));
    fAllocatedClInfo = TRUE;
    }


    if (hclinfo == NULL || (pclinfo = (PCLINFO) LocalLock (hclinfo)) == NULL){
    hresult = ReportResult(0, E_OUTOFMEMORY, 0, 0);
    goto errRtn;
    }

    // Remember the client window (Needed for sending DATA later on
    // when the data change message comes from the server)

    pclinfo->hwnd = hwndClient;
    if ((CLIPFORMAT)(unsigned short)lpopt->cfFormat == g_cfNative)
    pclinfo->bnative = TRUE;
    else
    pclinfo->format = (CLIPFORMAT)(unsigned short)lpopt->cfFormat;

    // Remeber the data transfer options
    pclinfo->options |= (1 << options) ;

    pclinfo->bdata = !lpopt->fDeferUpd;
    LocalUnlock (hclinfo);
    pclinfo = NULL;

    // if the entry exists already, delete it.
    FindClient (lpclient->m_hcliInfo, hwndClient, /*fDelete*/TRUE);

    // Now add this client to item client list
    // !!! This error recovery is not correct.
    if(!AddClient ((LPHANDLE)&lpclient->m_hcliInfo, hwndClient, hclinfo))
    goto errRtn;


errRtn:
    if (lpopt)
    GlobalUnlock (hopt);

    if (pclinfo)
    LocalUnlock (hclinfo);

    if (hresult==NOERROR)
    {
    // hresult==NOERROR iff we will send a postive ACK, so we must
    // free the hOptions handle.
    GlobalFree (hopt);
    }
    else
    {
    intrDebugOut((DEB_IERROR,
              "%x ::AdviseData() failing.\n",this));
    // We free hclinfo because it was not stored in the item's
    // client list via the AddClient just before the errRtn label.
        if (hclinfo && fAllocatedClInfo)
            LocalFree (hclinfo);

    }

    intrDebugOut((DEB_ITRACE,
          "%x _OUT CDefClient::AdviseData() returns hresult = %x\n",
          this, hresult));

    return hresult;

}





INTERNAL_(BOOL)  CDefClient::IsFormatAvailable
    (CLIPFORMAT cfFormat)
{
    intrDebugOut((DEB_ITRACE,
          "%x _IN CDefClient::IsFormatAvailable(cfFormat=%x)\n",
          this, cfFormat));

    ChkC(this);

    BOOL f = ((cfFormat==g_cfNative) || UtIsFormatSupported (m_lpdataObj, DATADIR_GET, cfFormat));

    intrDebugOut((DEB_ITRACE,
          "%x _OUT CDefClient::IsFormatAvailable(cfFormat=%x) returning %x\n",
          this, cfFormat,f));

    return f;
}


//RequestData: Sends data in response to a DDE Request message.
// for  agiven doc and an object.

INTERNAL_(HRESULT)   CDefClient::RequestData
(
HWND        hwndClient,
ATOM        aItem,
USHORT      cfFormat,
LPHANDLE    lphdde
)
{

    HRESULT       hresult = NOERROR;
    LPCLIENT    lpclient;
    FORMATETC   formatetc;
    STGMEDIUM   medium;
    // Due to a C7 bug, do not use a structure initialization for STGMEDIUM
    medium.tymed = TYMED_NULL;
    medium.hGlobal = 0;
    medium.pUnkForRelease= NULL;

    intrDebugOut((DEB_ITRACE,
          "%x _IN CDefClient::RequestData(hwndClient=%x,aItem=%x(%ws),cfFormat=%x,lphdde=%x)\n",
          this,
          hwndClient,
          aItem,
          wAtomName(aItem),
          cfFormat,
          lphdde));
    ChkC(this);

    // If edit environment Send data if we can
    if (aItem == aEditItems)
    {
    hresult = RequestDataStd (aItem, lphdde);
    goto exitRtn;
    }

    hresult = FindItem ((LPOLESTR) MAKEINTATOM(aItem),(LPCLIENT FAR *)&lpclient);
    if (hresult != NOERROR)
    {
    goto errRtn;
    }

    ChkC (lpclient);

    formatetc.cfFormat  = cfFormat;
    formatetc.ptd       = lpclient->m_ptd;
    formatetc.lindex    = DEF_LINDEX;
    formatetc.dwAspect  = DVASPECT_CONTENT;
    formatetc.tymed     = TYMED_HGLOBAL;


    hresult = ReportResult(0, DV_E_FORMATETC, 0, 0);
    if (!lpclient->IsFormatAvailable (formatetc.cfFormat))
    {
    goto errRtn;
    }


    // Now ask the item for the given format  data
    
    SendDevInfo (hwndClient);

    wSetTymed (&formatetc);
    hresult = lpclient->GetData (&formatetc, &medium);
    if (hresult != NOERROR)
    {
    intrDebugOut((DEB_IERROR,
              "GetData returns hresult=%x\n",
              hresult));
    goto errRtn;
    }
    if (medium.tymed & ~(TYMED_HGLOBAL | TYMED_MFPICT | TYMED_GDI))
    {
    AssertSz (0, "Got a storage medium of type other than hGlobal");
    goto errRtn;
    }
    if (cfFormat == CF_METAFILEPICT)
    {
    ChangeOwner (medium.hGlobal);
    }


    // Duplicate the DDE data
    // medium.hGlobal is freed by MakeDdeData or by the client once the
    // DDE_DATA is posted with *lphdde.
    if (MakeDDEData (medium.hGlobal, cfFormat, lphdde, TRUE)){
    // !!! Why do we have to duplicate the atom
    DuplicateAtom (aItem);
    hresult = NOERROR;
    }
    else
    hresult = E_OUTOFMEMORY;

errRtn:
exitRtn:
    intrDebugOut((DEB_ITRACE,
          "%x _OUT CDefClient::RequestData() returning %x\n",
          this, hresult));

    return hresult;
}



// REVIEW: needs review. Item callvback has to be split

// ItemCallback: Calback routine for the server to inform the
// data changes. When the change message is received, DDE data
// message is sent to each of the clients depending on the
// options.

INTERNAL_(HRESULT)  CDefClient::ItemCallBack
(
    int msg,         // notification message
    LPOLESTR szNewName  // for OLE_RENAMED notification
)
{
    intrDebugOut((DEB_ITRACE,
          "%x _IN CDefClient::ItemCallBack(msg=%x,szNewName=%x)\n",
          this,
          szNewName));

    HRESULT       hresult = NOERROR;
    BOOL    bSaved;
    LPCLIENT    lpclientRename;
    LPCLIENT    lpclient;

    ChkC(this);

    if (msg == OLE_RENAMED) {
    
    Assert (szNewName);
    intrDebugOut((DEB_ITRACE,
             "%x ::ItemCallBack(szNewName=(%ws))\n",
             WIDECHECK(szNewName)));


    if (!m_bContainer)
    {
        lpclient = (LPCLIENT)GetWindowLongPtr (m_hwnd, 0);
        Assert (lpclient==m_pdoc);
    }
    else
        lpclient = this;

    Assert (lpclient->m_chk==chkDefClient);

    // Replace the internally-stored name
    if (lpclient->m_aItem)
    {
        GlobalDeleteAtom (lpclient->m_aItem);
        lpclient->m_aItem = wGlobalAddAtom (szNewName);
    }
    

    // find if any StdDocName item is present at all
    if (lpclientRename =
         lpclient->SearchItem ((LPOLESTR) MAKEINTATOM(aStdDocName)))
    {
        HANDLE hDdeData=NULL;

        //
        // We have a new name in UNICODE. Need to create a new
        // name in ANSI.
        //
        LPSTR lpName = CreateAnsiFromUnicode(szNewName);
        if (!lpName)
        {
        hresult = ReportResult(0, E_OUTOFMEMORY, 0, 0);
        goto errrtn;
        }

        HANDLE hNewName = wNewHandle (lpName, (DWORD) strlen(lpName) + 1);

        PrivMemFree(lpName);

        // hNewName is freed by MakeDDEData

        if (!MakeDDEData (hNewName, (int)g_cfBinary, &hDdeData, FALSE))
        {
        hresult = ReportResult(0, E_OUTOFMEMORY, 0, 0);
        goto errrtn;
        }

        Assert (hDdeData);
        lpclientRename->SendRenameMsgs (hDdeData);
        GlobalFree (hDdeData);

        // Post termination for each of the doc clients that did not
        // advise on rename
        lpclient->TerminateNonRenameClients (lpclientRename);
    }


    Assert (FALSE == lpclient->m_fEmbed);

    // REVIEW: what is this?
    //lpclient->m_fEmbed = FALSE;

    hresult = NOERROR;

     errrtn:
    Assert (hresult == NOERROR);
    goto exitRtn;

    } else {

    // Enumerate all the clients and send DDE_DATA if necessary.
    bSaved =  SendDataMsg ((WORD)msg);

    // REVIEW: Hack from 1.0 for old pre-OLE-library apps
    if ((msg == OLE_SAVED) && m_fEmbed && !bSaved)
        return ReportResult(0, RPC_E_DDE_CANT_UPDATE, 0, 0);

    hresult = NOERROR;
    }

exitRtn:
    intrDebugOut((DEB_ITRACE,
          "%x _OUT CDefClient::ItemCallBack() returning hresult=%x\n",
          this,hresult));

    return(hresult);
}


// This func should definitely be replaced by use of MFC map. (IsEmpty)
INTERNAL_(BOOL) AreNoClients (HANDLE hcli)
{
    HANDLE        hcliPrev = NULL;
    PCLILIST      pcli;
    HANDLE        *phandle;

    while (hcli) {
    if ((pcli = (PCLILIST) LocalLock (hcli)) == NULL)
    {
        Puth (hcli);
        Putn();
        Assert(0);
        return TRUE;
    }

    phandle = (HANDLE *) pcli->info;
    while (phandle < (HANDLE *)(pcli + 1))
    {
        if (*phandle)
        {
        LocalUnlock (hcli);
        return FALSE;
        }
        phandle++;
        phandle++;
    }
    hcliPrev = hcli;
    hcli = pcli->hcliNext;
    LocalUnlock (hcliPrev);
    }
    return TRUE;
}


#ifdef _DEBUG
// For use in CodeView
// NOTE: Returns a static string
INTERNAL_(LPOLESTR)  a2s (ATOM a)
{
    static WCHAR sz[256];
    GlobalGetAtomName (a, sz, 256);
    return sz;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\com\dde\server\item2.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       item2.cxx
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    6-07-94   kevinro   Converted to NT and commented
//
//----------------------------------------------------------------------------

#include "ole2int.h"
#include <dde.h>
#include "ddeatoms.h"
#include "ddedebug.h"
#include "srvr.h"
#include "itemutil.h"
#include "trgt_dev.h"
#include <stddef.h>
#include <limits.h>
#ifndef WIN32
// #include <print.h>
#endif

ASSERTDATA


INTERNAL_(void)    CDefClient::TerminateNonRenameClients
(
LPCLIENT    lprenameClient
)
{

    HANDLE          hcliPrev = NULL;
    PCLILIST        pcli;
    HANDLE          *phandle;
    HANDLE          hcli;
    HWND	    hwndClient;
    LPCLIENT       lpdocClient;

    intrDebugOut((DEB_ITRACE,
		  "%x _IN CDefClient::TerminateNonRenameClients(lprenClient=%x)\n",
		  this,
		  lprenameClient));

    // items also keep the parents window handle.
    hwndClient  =  m_hwnd;
    lpdocClient = (LPCLIENT)GetWindowLongPtr (m_hwnd, 0);


    hcli = m_hcliInfo;
    while (hcli)
    {
	if ((pcli = (PCLILIST) LocalLock (hcli)) == NULL)
	{
	    break;
	}

	phandle = (HANDLE *) (pcli->info);
	while (phandle < (HANDLE *)(pcli + 1))
	{
	    if (*phandle)
	    {
		// This client is in the rename list. So, no termination
		if(!FindClient (lprenameClient->m_hcliInfo, *phandle, FALSE))
		{
		    //
		    // Terminate will send a WM_DDE_TERMINATE at the client
		    //
		    Terminate((HWND)*phandle,hwndClient);

		    // delete this client from all the items lists.
		    lpdocClient->DeleteFromItemsList ((HWND)*phandle);
		}
	    }
	    phandle++;
	    phandle++;
	}

	hcliPrev = hcli;
	hcli = pcli->hcliNext;
	LocalUnlock (hcliPrev);
    }
    intrDebugOut((DEB_ITRACE,
		  "%x _OUT CDefClient::TerminateNonRenameClients\n",
		  this));

}



INTERNAL CDefClient::Terminate
	(HWND hwndTo,
	HWND hwndFrom)
{
    intrDebugOut((DEB_ITRACE,
		  "%x _IN CDefClient::Terminate hwndTo=%x hwndFrom=%x\n",
		  this,
		  hwndTo,
		  hwndFrom));

    DDECALLDATA DdeCD;
    HRESULT hresult;

    DdeCD.hwndSvr = hwndTo;
    DdeCD.hwndCli = hwndFrom;
    DdeCD.wMsg = WM_DDE_TERMINATE;
    DdeCD.wParam = (WPARAM)hwndFrom,
    DdeCD.lParam = 0;

    //
    // Setting the fCallData variable effects the way that the
    // DocWndProc handles WM_DDE_TERMINATE. If it is set, then this
    // object initiated the terminate, and will not reply to the
    // TERMINATE. It will allow us to leave the CallRunModalLoop
    //
    m_fCallData = TRUE;

    RPCOLEMESSAGE RpcOleMsg;
    RpcOleMsg.Buffer = &DdeCD;

    // Figure out the MsgQ input flags based on the callcat of the call.
    DWORD dwMsgQInputFlag = gMsgQInputFlagTbl[CALLCAT_SYNCHRONOUS];

    // Now construct a modal loop object for the call that is about to
    // be made. It maintains the call state and exits when the call has
    // been completed, cancelled, or rejected.

    CCliModalLoop CML(0, dwMsgQInputFlag,0);

    do
    {
	DWORD status = 0;
	hresult = CML.SendReceive(&RpcOleMsg, &status, &m_pCallMgr);

    }  while (hresult == RPC_E_SERVERCALL_RETRYLATER);


    m_fCallData = FALSE;

    intrDebugOut((DEB_ITRACE,
		  "%x _OUT CDefClient::Terminate hresult = %x\n",
		  this,hresult));

    return(hresult);
}


INTERNAL_(void)   CDefClient::SendTerminateMsg ()
{

    HANDLE          hcliPrev = NULL;
    PCLILIST        pcli;
    HANDLE          *phandle;
    HANDLE          hcli;
    HWND	    hwnd;
    LPCLIENT        lpdocClient;
    static int staticcounter;
    int counter = ++staticcounter;

    intrDebugOut((DEB_ITRACE,
		  "%x _IN CDefClient::SendTerminateMsg\n",
		  this));

    // items also keep the document's window handle

    Assert (IsWindow (m_hwnd));

    if (!IsWindow (m_hwnd))
    {
	goto exitRtn;
    }

    hwnd = m_hwnd;

    lpdocClient = (LPCLIENT)GetWindowLongPtr (m_hwnd, 0);

    Assert (lpdocClient);

    if (NULL==lpdocClient)
    {
	goto exitRtn;
    }

    Assert (lpdocClient==m_pdoc);
    AssertIsDoc (lpdocClient);
    // If "this" is a document (container) then iterate through
    // and terminate all its client windows.  If "this" is an item
    // just terminate that item's client windows.
    hcli = m_bContainer ? lpdocClient->m_hcli : m_hcliInfo;
    while (hcli)
    {
	if ((pcli = (PCLILIST) LocalLock (hcli)) == NULL)
	{
	    goto exitRtn;
	}
	phandle = (HANDLE *) (pcli->info);
	while (phandle < (HANDLE *)(pcli + 1))
	{
	    if ((HWND)*phandle)
	    {
		intrDebugOut((DEB_ITRACE,
		              "%x ::SendTerminateMsg on hwnd=%x\n",
			      this,
			      (HWND)*phandle));

		Terminate ((HWND)*phandle, hwnd);

		Assert (lpdocClient->m_cClients > 0);

		lpdocClient->m_cClients--;

		HWND hwndClient = *(HWND *)phandle;
		// This window is no longer a client.

		// Remove window from document's master list
		// and its item's list.
		lpdocClient->DeleteFromItemsList (hwndClient);
	    }
	    //
	    // (KevinRo): Don't understand why the phandle is
	    // incremented twice. This is the same as the original
	    // code. Leaving it for now, since I don't have enough
	    // information.
	    //
	    phandle++;
	    phandle++;
	}

	hcliPrev = hcli;
	hcli = pcli->hcliNext;
	LocalUnlock (hcliPrev);
    }

exitRtn:
    intrDebugOut((DEB_ITRACE,
		  "%x _OUT CDefClient::SendTerminateMsg\n",
		  this));

}



// SendRenameMsg: enumerates the clients for the rename item
// and sends rename message for all the clients.

INTERNAL_(void)    CDefClient::SendRenameMsgs
(
HANDLE      hddeRename
)
{
    ATOM	    aData    = NULL;
    HANDLE          hdde     = NULL;
    PCLINFO         pclinfo = NULL;
    HWND	    hwndClient;

    HANDLE          hcliPrev = NULL;
    PCLILIST        pcli;
    HANDLE          *phandle;
    HANDLE          hcli;
    HANDLE          hcliInfo;

    intrDebugOut((DEB_ITRACE,
		  "%x _IN CDefClient::SendRenameMsgs(hddeRename=%x)\n",
		  this,
		  hddeRename));

    hcli = m_hcliInfo;
    LPARAM lp;
    while (hcli)
    {
	if ((pcli = (PCLILIST) LocalLock (hcli)) == NULL)
	{
    	    goto exitRtn;
	}


	phandle = (HANDLE *) (pcli->info);
	while (phandle < (HANDLE *)(pcli + 1))
	{
	    if (*phandle++)
	    {
		hdde = NULL;
		aData = NULL;

		if (!(pclinfo = (PCLINFO) LocalLock (hcliInfo = *phandle++)))
		{
		    goto exitRtn;
		}


		// Make the item atom with the options.
		aData = DuplicateAtom (aStdDocName);
		hdde  = UtDupGlobal (hddeRename,GMEM_MOVEABLE);

		hwndClient  = pclinfo->hwnd;
		LocalUnlock (hcliInfo);

		// Post the message

		lp = MAKE_DDE_LPARAM(WM_DDE_DATA,hdde,aData);

		if (!PostMessageToClient (hwndClient,
					  WM_DDE_DATA,
					  (WPARAM) m_hwnd,
					  lp))
                {
		    DDEFREE(WM_DDE_DATA,lp);
		    if (hdde)
			GlobalFree (hdde);
		    if (aData)
			GlobalDeleteAtom (aData);
		}
	    }
	    else
	    {
		phandle++;
	    }

	}

	hcliPrev = hcli;
	hcli = pcli->hcliNext;
	LocalUnlock (hcliPrev);
    }

exitRtn:
    intrDebugOut((DEB_ITRACE,
		  "%x _OUT CDefClient::SendRenameMsgs void return\n",
		  this));

}



INTERNAL_(BOOL)   CDefClient::SendDataMsg
(
WORD    		msg        // notification message
)
{

    HANDLE          hcliPrev = NULL;
    PCLILIST        pcli;
    HANDLE          *phandle;
    HANDLE          hcli;
    BOOL	    bSaved = FALSE;

    intrDebugOut((DEB_ITRACE,
		  "%x _IN CDefClient::SendDataMsg(msg=%x)\n",
		  this,
		  msg));

    hcli = m_hcliInfo;
    while (hcli)
    {
	if ((pcli = (PCLILIST) LocalLock (hcli)) == NULL)
	{
	    break;
	}
	phandle = (HANDLE *) (pcli->info);
	while (phandle < (HANDLE *)(pcli + 1)) {
	    if (*phandle++)
		bSaved = SendDataMsg1 (*phandle++, msg);
	    else
		phandle++;
	}

	hcliPrev = hcli;
	hcli = pcli->hcliNext;
	LocalUnlock (hcliPrev);
    }

    intrDebugOut((DEB_ITRACE,
		  "%x _OUT CDefClient::SendDataMsg() returns %x)\n",
		  this,bSaved));

    return bSaved;
}



//SendDataMsg: Send data to the clients, if the data change options
//match the data advise options.

INTERNAL_(BOOL)   CDefClient::SendDataMsg1
(
HANDLE  		hclinfo,    // handle of the client info
WORD    		msg         // notification message
)
{
    intrDebugOut((DEB_ITRACE,
		  "%x _IN CDefClient::SendDataMsg1(hclinfo=%x,msg=%x)\n",
		  this,
		  hclinfo,
		  msg));

    PCLINFO     pclinfo = NULL;
    HANDLE      hdde    = NULL;
    ATOM	aData   = NULL;
    HRESULT       retval;
    BOOL	bSaved = FALSE;


    ChkC (this);
    if (m_lpdataObj == NULL) goto errRtn;

    // LATER: Allow server to give us other tymed's beside HGLOBAL and do
    // the conversion ourselves, e.g., IStorageToHGlobal()

    FORMATETC formatetc;// = {0, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};
    STGMEDIUM medium;// = {TYMED_NULL, NULL, NULL};
    formatetc.ptd = m_ptd;
    formatetc.dwAspect = DVASPECT_CONTENT;
    formatetc.lindex = DEF_LINDEX;
    formatetc.tymed = TYMED_HGLOBAL;
    medium.tymed = TYMED_NULL;
    medium.hGlobal=0; // not really necessary
    medium.pUnkForRelease = NULL;

    if (!(pclinfo = (PCLINFO) LocalLock (hclinfo)))
    {
	goto errRtn;
    }

    // if the client dead, then no message
    if (!IsWindowValid(pclinfo->hwnd))
    {
	goto errRtn;
    }


    //
    // (KevinRo) UPDATE was not defined in the OLE 2.01 code base
    //
#ifdef UPDATE
	// OLE_SAVED is what 1.0 clients expect to get for embedded objects.
	if (msg==OLE_CHANGED && m_fEmbed)
		msg=OLE_SAVED;
#endif

    if (pclinfo->options & (0x0001 << msg))
    {
	bSaved = TRUE;  		
	SendDevInfo (pclinfo->hwnd);

	// send message if the client needs data for every change or
	// only for the selective ones he wants.

	// now look for the data option.
	if (pclinfo->bnative){
	    // prepare native data
	    if (pclinfo->bdata){

		// Wants the data with DDE_DATA message
		// Get native data from the server.
	
		// GetData
		formatetc.cfFormat = g_cfNative;
		wSetTymed (&formatetc);
		retval = GetData (&formatetc, &medium);

		if (retval != NOERROR)
		{
		    Assert(0);
		    goto errRtn;
		}
		Assert (medium.tymed==TYMED_HGLOBAL);
		Assert (medium.hGlobal);

		// Prepare the DDE data block.
		// REVIEW: MakeDDEData frees medium.hGlobal manually, but should
		// really call ReleaseStgMedium.
		if(!MakeDDEData (medium.hGlobal, (int)g_cfNative, (LPHANDLE)&hdde, FALSE))
		{
		    goto errRtn;
		}
	    }


	    // Make the item atom with the options.
	    aData =  MakeDataAtom (m_aItem, msg);

	    intrDebugOut((DEB_ITRACE,
		          "%x ::SendDataMsg1 send NativeData to hwnd=%x"
			  "format %x\n",
			  this,
			  pclinfo->hwnd,
			  pclinfo->format));

            LPARAM lp = MAKE_DDE_LPARAM(WM_DDE_DATA,hdde,aData);
            if (!PostMessageToClient(pclinfo->hwnd,
				     WM_DDE_DATA,
				     (WPARAM) m_hwnd,
				     lp))


	    {
		DDEFREE(WM_DDE_DATA,lp);
		//
		// The two data items will be free'd on exit
		//
		goto errRtn;
	    }
	    hdde = NULL;
	    aData = NULL;
	}


	// Now post the data for the display format

	if (pclinfo->format)
	{
	    if (pclinfo->bdata)
	    {
		intrDebugOut((DEB_ITRACE,
	    		      "%x ::SendDataMsg1 GetData on cf = %x\n",
			      pclinfo->format));
		// Must reset because previous call to GetData set it.
		medium.tymed = TYMED_NULL;

		// GetData
		formatetc.cfFormat = (USHORT) pclinfo->format;
		wSetTymed (&formatetc);
		Assert (IsValidInterface (m_lpdataObj));
		retval = m_lpdataObj->GetData (&formatetc, &medium);

		if (retval != NOERROR)
		{
		    intrDebugOut((DEB_IERROR,
	    			  "m_lpdataObj->GetData returns %x\n",
				  retval));
		    goto errRtn;
		}


		if (pclinfo->format == CF_METAFILEPICT)
		    ChangeOwner (medium.hGlobal);
		
		if(!MakeDDEData (medium.hGlobal, pclinfo->format, (LPHANDLE)&hdde, FALSE))
		    goto errRtn;

	    }

	    // atom is deleted. So, we need to duplicate for every post
	    aData =  MakeDataAtom (m_aItem,  msg);
	    // now post the message to the client;
	    intrDebugOut((DEB_ITRACE,
		          "%x ::SendDataMsg1 send PresentationData to hwnd=%x"
			  " cf=%x\n",
			  this,
			  pclinfo->hwnd,
			  pclinfo->format));

            LPARAM lp = MAKE_DDE_LPARAM(WM_DDE_DATA,hdde,aData);

            if (!PostMessageToClient(pclinfo->hwnd,
				     WM_DDE_DATA,
				     (WPARAM) m_hwnd,
				     lp))
	    {
		DDEFREE(WM_DDE_DATA,lp);
		goto errRtn;
	    }

	    hdde = NULL;
	    aData = NULL;
	}

    }


errRtn:
    if (pclinfo)
	LocalUnlock (hclinfo);

    if (hdde)
	GlobalFree (hdde);

    if (aData)
	GlobalDeleteAtom (aData);

    intrDebugOut((DEB_ITRACE,
		  "%x _OUT CDefClient::SendDataMsg1() returns %x\n",
		  this,bSaved));


    return bSaved;

}



// FixWriteBug
//
// `Write' gives a target device that is missing a NULL between
// the device name and the driver name.  This function creates
// a fixed 1.0 target device.
//
// REVIEW: There is another Write bug we should work around.
// Write does not send the "extra bytes" that are supposed to follow
// the DEVMODE.  It puts the Environment immediately after the DEVMODE.
// So the driver will read the Environment thinking it is the extra bytes.
// To fix this, FixWriteBug() should zero out the Environment bytes; the
// 2.0 target device does not use them anyway.
//
 INTERNAL FixWriteBug
    (HANDLE hTD,
    LPHANDLE ph)
{
    HRESULT hresult;
    LPBYTE pChunk2;
    LPBYTE pNewChunk2;
    HANDLE hNew = NULL;
    LPBYTE pNew = NULL;
    const LPCOLETARGETDEVICE ptd1 = (LPCOLETARGETDEVICE) GlobalLock (hTD);
    RetZS (ptd1, E_OUTOFMEMORY);

    hNew = GlobalAlloc (GMEM_DDESHARE | GMEM_MOVEABLE,
				GlobalSize (hTD) + 1);
    RetZS (hNew, E_OUTOFMEMORY);
    pNew = (LPBYTE) GlobalLock (hNew);
    RetZS (pNew, E_OUTOFMEMORY);
    ULONG cbChunk1 = 7 * sizeof(UINT) + ptd1->otdDriverNameOffset;
    ULONG cbChunk2 = (ULONG)(GlobalSize (hTD) - cbChunk1);
    ErrZS (IsValidPtrOut (pNew, (UINT)cbChunk1), E_OUTOFMEMORY);
    memcpy (pNew, ptd1, cbChunk1);
    pNew[cbChunk1] = '\0';       // insert the missing NULL

    pNewChunk2 = pNew + cbChunk1 + 1;
    pChunk2 = (LPBYTE)ptd1 + cbChunk1;
    ErrZS (IsValidPtrOut (pNewChunk2, (UINT)cbChunk2), E_OUTOFMEMORY);
    Assert (IsValidReadPtrIn (pChunk2, (UINT)cbChunk2));
    memcpy (pNewChunk2, pChunk2, cbChunk2);

    // Fix up the offsets to accomodate the added NULL
    #define macro(x) if (ptd1->otd##x##Offset > ptd1->otdDeviceNameOffset)\
			((LPOLETARGETDEVICE)pNew)->otd##x##Offset++;
    macro (DriverName)
    macro (PortName)
    macro (ExtDevmode)
    macro (Environment)
    #undef macro

    GlobalUnlock (hNew);
    GlobalUnlock (hTD);
    *ph = hNew;
    return NOERROR;

  errRtn:
    if (pNew)
	GlobalUnlock (hNew);
    if (ptd1)
	GlobalUnlock (hTD);
    if (hNew)
	GlobalFree (hNew);
    return hresult;
}






// Convert10TargetDevice
//
INTERNAL Convert10TargetDevice
    (HANDLE     	     hTD,       // 1.0 Target Device
    DVTARGETDEVICE FAR* FAR* pptd2)     // Out parm, corresponding 2.0 TD
{
    intrDebugOut((DEB_ITRACE,
		  "0 _IN Convert10TargetDevice hTD=%x\n",hTD));

    ULONG cbData1, cbData2;

    if (NULL==hTD)
    {
	Assert(0);
	return ReportResult(0, E_INVALIDARG, 0, 0);
    }

    if (*pptd2)
    {
	// delete old target device
	PrivMemFree(*pptd2);
	*pptd2 = NULL;
    }

    LPOLETARGETDEVICE ptd1 = (LPOLETARGETDEVICE) GlobalLock (hTD);

    RetZS (ptd1, E_OUTOFMEMORY);

    if ((ptd1->otdDeviceNameOffset < ptd1->otdDriverNameOffset)
	&& (ptd1->otdDeviceNameOffset
	    + strlen (LPSTR(((BYTE *)ptd1->otdData) +
		ptd1->otdDeviceNameOffset)) + 1 > ptd1->otdDriverNameOffset))
    {
	// No NULL between device and driver name
	HANDLE hNew;
	GlobalUnlock (hTD);
	RetErr (FixWriteBug (hTD, &hNew));
	HRESULT hresult = Convert10TargetDevice (hNew, pptd2);
	Verify (0==GlobalFree (hNew));
	return hresult;
    }
	// Word Bug
	DEVMODEA UNALIGNED *pdevmode = (DEVMODEA UNALIGNED *)
	    (((BYTE *)ptd1->otdData)+ ptd1->otdExtDevmodeOffset);

	if (   HIBYTE(pdevmode->dmSpecVersion) < 3
		|| HIBYTE(pdevmode->dmSpecVersion) > 6
		|| pdevmode->dmDriverExtra > 0x1000)
	{
		if (0==ptd1->otdEnvironmentSize)
		{
			// Sometimes Word does not give an environment.
			ptd1->otdExtDevmodeOffset = 0;
			ptd1->otdExtDevmodeSize   = 0;
		}
		else
		{
			// DevMode is garbage, use environment instead.
			ptd1->otdExtDevmodeOffset = ptd1->otdEnvironmentOffset;
			ptd1->otdExtDevmodeSize   = ptd1->otdEnvironmentSize;
		}
	}

    // These next  assert does not HAVE to be true,
    // but it's a sanity check.
    Assert (ptd1->otdDeviceNameOffset
	    + strlen (LPSTR(((BYTE *)ptd1->otdData) +
		ptd1->otdDeviceNameOffset)) + 1
	    == ptd1->otdDriverNameOffset);


    // Excel has zeroes for DevMode and Environment offsets and sizes

    // Calculate size of Data block.  Many 1.0 clients don't make their
    // target device data block big enough for the DEVMODE.dmDriverExtra
    // bytes (and they don't copy those bytes either).  We can't reconstruct
    // the bytes out of thin air, but we can at least make sure there's not
    // a GP fault when the printer driver tries to access those bytes in
    // a call to CreateDC.  Any extra bytes are zeroed.
    cbData2 = ptd1->otdExtDevmodeOffset + ptd1->otdExtDevmodeSize;

    if (ptd1->otdExtDevmodeOffset != 0)
    {
	cbData2 += ((DEVMODEA UNALIGNED *)((LPBYTE)ptd1->otdData +
	    ptd1->otdExtDevmodeOffset))->dmDriverExtra;
    }

    cbData2 = max (cbData2,
		   ptd1->otdPortNameOffset + (ULONG) strlen (LPCSTR(
		    ((BYTE *)ptd1->otdData) + ptd1->otdPortNameOffset)) + 1);

    // Calculate size of OLE2 Target Device
    //
    // Its the size of the DVTARGETDEVICE header, plus the cbData2
    // The definition of DVTARGETDEVICE currently uses an unsized array
    // of bytes at the end, therefore we can not just do a sizeof().
    //

    ULONG cbTD2 = SIZEOF_DVTARGETDEVICE_HEADER + cbData2;

    // Allocate OLE2 Target Device
    *pptd2 = (DVTARGETDEVICE FAR*) PrivMemAlloc(cbTD2);
    if (!IsValidPtrOut (*pptd2, cbTD2)
	|| !IsValidPtrOut ((*pptd2)->tdData, cbData2))
    {
	AssertSz (0, "out of memory");
	GlobalUnlock (hTD);
	return ResultFromScode (E_OUTOFMEMORY);
    }
    _fmemset (*pptd2, '\0', cbTD2);

    // OLE2 offsets are from the beginning of the DVTARGETDEVICE
    const ULONG cbOffset = offsetof (DVTARGETDEVICE, tdData);

    // Fill in new Target Device

    (*pptd2)->tdSize = cbTD2;

    #define Convert(a) \
	((*pptd2)->td##a##Offset = (USHORT)(ptd1->otd##a##Offset + cbOffset))

    Convert (DeviceName);
    Convert (DriverName);
    Convert (PortName);
    if (ptd1->otdExtDevmodeOffset != 0)
	Convert (ExtDevmode);
    else				// Excel uses 0
       (*pptd2)->tdExtDevmodeOffset = 0;

    // Calculate size of 1.0 data block in case the 1.0 target
    // device is incorrectly not big enough.
    cbData1 = (ULONG) (GlobalSize(hTD) - offsetof (OLETARGETDEVICE, otdData));

    #undef Convert
    _fmemcpy ((*pptd2)->tdData, ptd1->otdData, min(cbData1, cbData2));

    GlobalUnlock (hTD);

    //
    // At this point, pptd2 holds an ANSI version of a DVTARGET device
    //
    // Now, we need to convert it to a UNICODE version. There are routines
    // for doing this in the UTILS.H file.
    //

    DVTDINFO dvtdInfo;
    DVTARGETDEVICE * pdvtd32 = NULL;
    HRESULT hr;

    hr = UtGetDvtd16Info(*pptd2, &dvtdInfo);
    if (hr != NOERROR)
    {
	goto errRtn;
    }

    pdvtd32 = (DVTARGETDEVICE *) PrivMemAlloc(dvtdInfo.cbConvertSize);

    if (pdvtd32 == NULL)
    {
	goto errRtn;
    }

    hr = UtConvertDvtd16toDvtd32(*pptd2, &dvtdInfo, pdvtd32);

    if (hr != NOERROR)
    {
	PrivMemFree(pdvtd32);
	pdvtd32=NULL;
    }

errRtn:

    PrivMemFree(*pptd2);
    *pptd2 = pdvtd32;

    return hr;
}
//+---------------------------------------------------------------------------
//
//  Method:     CDefClient::PokeStdItems
//
//  Synopsis:   Pokes the data for the standard items.
//
//  Effects:
//
// For StdHostnames, StdDocDimensions and SetColorScheme the data is
// sent immediately and for the the StdTargetDeviceinfo the
// data is set in each client block and the data is sent just
// before the GetData call for rendering the right data.
//
//  Arguments:  [hwndClient] --
//		[aItem] --
//		[hdata] --
//		[index] --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:
//
//  History:    6-07-94   kevinro   Commented
//
//  Notes:
//
//----------------------------------------------------------------------------
INTERNAL CDefClient::PokeStdItems(HWND hwndClient,
				  ATOM aItem,
				  HANDLE hdata,
				  int index)
{
    DDEDATA FAR *   lpdata = NULL;
    HANDLE          hnew   = NULL;
    LPHOSTNAMES     lphostnames;
    HRESULT         retval = E_OUTOFMEMORY;
    WORD 	    format;
    BOOL	    fRelease = FALSE;

    intrDebugOut((DEB_ITRACE,
		  "%p _IN CDefClient::PokeStdItems(hwndClient=%x,aItem=%x(%ws)hdata=%x,index=%x)\n",
		  this,
		  hwndClient,
		  aItem,
		  wAtomName(aItem),
		  hdata,
		  index));

    if (m_fGotEditNoPokeNativeYet)
    {
	// We got StdEdit, but instead of getting Poke for native data,
	// we got poke for some std items. So we want to generate InitNew()
	// call for the object.

	DoInitNew(); 	// the function clears the flag
    }

    if(!(hdata && (lpdata = (DDEDATA FAR *)GlobalLock (hdata))))
    {
	    goto errRtn;
    }

    format = lpdata->cfFormat;
    fRelease = lpdata->fRelease;

    AssertSz (format == (int)g_cfBinary, "Format is not binary");

    // we have extracted the data successfully.
    m_lpoleObj = m_lpoleObj;

    if (index == STDHOSTNAMES)
    {
	lphostnames = (LPHOSTNAMES)lpdata->Value;
	//
	// The client should have sent the HOSTNAMES in ANSI. This
	// means we need to convert them to UNICODE before we can
	// use them.
	//
	LPOLESTR lpstrClient = CreateUnicodeFromAnsi((LPSTR)(lphostnames->data) + lphostnames->clientNameOffset);
	LPOLESTR lpstrDoc = CreateUnicodeFromAnsi((LPSTR)(lphostnames->data) + lphostnames->documentNameOffset);

	intrDebugOut((DEB_ITRACE,
		      "%p ::PokeStdItems setting hostnames Client(%ws) Doc(%ws)  \n",
		      this,
		      lpstrClient,
		      lpstrDoc));

	retval = (HRESULT)m_lpoleObj->SetHostNames(lpstrClient,lpstrDoc);

	if (retval==NOERROR)
	{
	    m_fDidRealSetHostNames = TRUE;
	}

	PrivMemFree(lpstrClient);
	PrivMemFree(lpstrDoc);

	goto end;
    }


    if (index == STDDOCDIMENSIONS)
    {

	SIZEL size;
	size.cy = ((LPRECT16)(lpdata->Value))->top;
	size.cx = ((LPRECT16)(lpdata->Value))->left;
	intrDebugOut((DEB_ITRACE,
		      "%p ::PokeStdItems STDDOCDIMENSIONS cy=%x cx=%x\n",
		      this,
		      size.cy,
		      size.cx));
	retval = m_lpoleObj->SetExtent (DVASPECT_CONTENT, &size);

	goto end;

    }


    if (index == STDCOLORSCHEME) {
	intrDebugOut((DEB_ITRACE,
		      "%p ::PokeStdItems setting STDCOLORSCHEME\n",this));

	retval = m_lpoleObj->SetColorScheme((LPLOGPALETTE)(lpdata->Value));

	goto end;
    }

    // Target Device
    if (index == STDTARGETDEVICE)
    {
	intrDebugOut((DEB_ITRACE,
		      "%p ::PokeStdItems setting STDTARGETDEVICE\n",this));

	if (!(hnew = MakeItemData ((DDEPOKE FAR *)lpdata, hdata, format)))
	    goto errRtn;

	retval = Convert10TargetDevice (hnew, &m_ptd);
	goto end;

    }
    retval = E_UNEXPECTED;

    intrAssert(!"::PokeStdItems - Unknown index\n");

    //
    // (KevinRo) Found the following line already commented out.
    //
    //(HRESULT)SetStdInfo (hwndClient, (LPOLESTR) (MAKELONG(STDTARGETDEVICE,0)),hnew);

end:
errRtn:
    
    if (hnew)
    	// can only be global memory block
    	GlobalFree (hnew);

    if (lpdata) {
    	GlobalUnlock (hdata);
    	if (retval == NOERROR && fRelease)
    	    GlobalFree (hdata);
    }

    intrDebugOut((DEB_ITRACE,
		  "%p _OUT CDefClient::PokeStdItems() hresult = %x\n",
		  this,
		  retval));

    return retval;
}






// SetStdInfo: Sets the targetdevice info. Creates a client
// for "StdTargetDevice". This item is created only within the
// lib and it is never visible in server app. When the change
// message comes from the server app, before we ask for
// the data, we send the targetdevice info if there is
// info for the client whom we are trying to send the data
// on advise.


INTERNAL_(HRESULT)    CDefClient::SetStdInfo
(
HWND        hwndClient,
LPOLESTR       lpitemname,
HANDLE      hdata
)
{
    HANDLE      hclinfo  = NULL;
    PCLINFO     pclinfo = NULL;
    LPCLIENT    lpclient;
    HRESULT   retval   = NOERROR;

    intrDebugOut((DEB_ITRACE,
		  "%x _IN CDefClient::SetStdInfo(hwndClient=%x,ItemName=(%ws),hdata=%x)\n",
		  this,
		  hwndClient,
		  lpitemname,
		  hdata));
    //
    // first create/find the StdTargetDeviceItem.
    //

    if ((lpclient = SearchItem (lpitemname)) == NULL)
    {
	 retval = (HRESULT)RegisterItem (lpitemname,(LPCLIENT FAR *)&lpclient, FALSE);
	 if (retval != NOERROR)
	 {
	    goto errRtn;
	 }
    }

    if(hclinfo = FindClient (lpclient->m_hcliInfo, hwndClient, FALSE))
    {
	if (pclinfo = (PCLINFO) LocalLock (hclinfo))
	{
	    if (pclinfo->hdevInfo)
		GlobalFree (pclinfo->hdevInfo);
	    pclinfo->bnewDevInfo = TRUE;
	    if (hdata)
		pclinfo->hdevInfo = UtDupGlobal (hdata,GMEM_MOVEABLE);
	    else
		pclinfo->hdevInfo = NULL;
	    pclinfo->hwnd = hwndClient;
	    LocalUnlock (hclinfo);

	    // We do not have to reset the client because we did not
	    // change the handle it self.
	}
    }
    else
    {
	// Create the client structure to be attcahed to the object.
	hclinfo = LocalAlloc (LMEM_MOVEABLE | LMEM_ZEROINIT, sizeof (CLINFO));
	if (hclinfo == NULL || (pclinfo = (PCLINFO) LocalLock (hclinfo)) == NULL)
	    goto errRtn;

	pclinfo->bnewDevInfo = TRUE;
	if (hdata)
	    pclinfo->hdevInfo = UtDupGlobal (hdata,GMEM_MOVEABLE);
	else
	    pclinfo->hdevInfo = NULL;

	pclinfo->hwnd = hwndClient;
	LocalUnlock (hclinfo);


	// Now add this client to item client list
	// !!! This error recovery is not correct.
	if (!AddClient ((LPHANDLE)&lpclient->m_hcliInfo, hwndClient, hclinfo))
	    goto errRtn;
    }

exitRtn:
    intrDebugOut((DEB_ITRACE,
		  "%x _OUT CDefClient::SetStdInfo() hresult=%x\n",
		  this,retval));

    return retval;
errRtn:
    Assert(0);
    if (pclinfo)
	LocalUnlock (hclinfo);

    if (hclinfo)
	LocalFree (hclinfo);

    retval = E_OUTOFMEMORY;
    goto exitRtn;
}


// SendDevInfo: Sends targetdevice info to the  the object.
// Caches the last targetdevice info sent to the object.
// If the targetdevice block is same as the one in the
// cache, then no targetdevice info is sent.
// (!!! There might be some problem here getting back
// the same global handle).

INTERNAL_(void)     CDefClient::SendDevInfo
(
HWND        hWndCli
)
{

    HANDLE      hclinfo  = NULL;
    PCLINFO     pclinfo = NULL;
    HANDLE      hdata;
    LPCLIENT    lpdocClient;

    intrDebugOut((DEB_ITRACE,
		  "%x _IN CDefClient::SendDevInfo(hwndCli=%x)\n",
		  this,
		  hWndCli));
#if 0
    if (!m_bContainer)
	lpdocClient = (LPCLIENT)GetWindowLong (m_hwnd, 0);
    else
	lpdocClient = this;
#endif

    // find if any StdTargetDeviceInfo item is present at all
    AssertIsDoc(m_pdoc);
    lpdocClient = m_pdoc->SearchItem ((LPOLESTR) LongToPtr((MAKELONG(STDTARGETDEVICE, 0))));
    if (lpdocClient == NULL)
    {
	goto exitRtn;
    }

    hclinfo     = FindClient (lpdocClient->m_hcliInfo, hWndCli, FALSE);

    // This client has not set any target device info. no need to send
    // any stdtargetdevice info
    if (hclinfo != NULL) {
	if (!(pclinfo = (PCLINFO)LocalLock (hclinfo)))
	    goto end;

	// if we cached it, do not send it again.
	if ((!pclinfo->bnewDevInfo) && pclinfo->hdevInfo == m_hdevInfo)
	    goto end;

	pclinfo->bnewDevInfo = FALSE;
	if(!(hdata = UtDupGlobal (pclinfo->hdevInfo,GMEM_MOVEABLE)))
	    goto end;
    } else {

	// already screen
	if (!m_hdevInfo)
	    goto end;

	//for screen send NULL.
	hdata = NULL;
    }



    if (pclinfo)
    {
	m_hdevInfo = pclinfo->hdevInfo;
    }
    else
    {
	m_hdevInfo = NULL;
    }



    // !!! error case who frees the data?'

end:
    if (pclinfo)
	LocalUnlock (hclinfo);

exitRtn:
    intrDebugOut((DEB_ITRACE,
		  "%x _OUT CDefClient::SendDevInfo(hwndCli=%x)\n",
		  this,
		  hWndCli));
    return;
}




// Constructor
CDefClient::CDefClient (LPUNKNOWN pUnkOuter):   m_Unknown (this),
						m_OleClientSite (this),
						m_AdviseSink (this),
						m_pCallMgr (this)
{
    intrDebugOut((DEB_ITRACE,
		  "%x _IN CDefClient::CDefClient(pUnkOuter=%x)\n",
		  this,
		  pUnkOuter));

    m_pUnkOuter = pUnkOuter ? pUnkOuter : &m_Unknown;
    m_bContainer      = TRUE;
    m_lpoleObj        = NULL;
    m_lpdataObj       = NULL;
    m_bCreateInst     = FALSE;
    m_bTerminate      = FALSE;
    m_termNo          = 0;
    m_hcli            = NULL;
    m_lpNextItem      = NULL;
    m_cRef            = 0;
    m_hwnd            = (HWND)0;
    m_hdevInfo        = NULL;
    m_hcliInfo        = NULL;
    m_fDidRealSetHostNames= FALSE;
    m_fDidSetClientSite   = FALSE;
    m_fGotDdeAdvise   = FALSE;
    m_fCreatedNotConnected	  = FALSE;
    m_fInOnClose	  = FALSE;
    m_fInOleSave	  = FALSE;
    m_dwConnectionOleObj  = 0L;
    m_dwConnectionDataObj = 0L;
    m_fGotStdCloseDoc = FALSE;
    m_fEmbed          = FALSE;
    m_cClients        = 0;
    m_plkbytNative    = NULL;
    m_pstgNative      = NULL;
    m_fRunningInSDI   = FALSE;
    m_psrvrParent     = NULL;
    m_ptd             = NULL;
    m_pdoc            = NULL;
    m_chk             = chkDefClient;
    m_ExecuteAck.f    = FALSE;
    m_fGotEditNoPokeNativeYet = FALSE;
    m_fLocked = FALSE;
    m_fCallData	 = FALSE;
    // CDefClient::Create does all the real work.
    intrDebugOut((DEB_ITRACE,
		  "%x _OUT CDefClient::CDefClient(pUnkOuter=%x)\n",
		  this,
		  pUnkOuter));

}


CDefClient::~CDefClient (void)
{
    // This should be more object-oriented.
    // But right now, this BOOL tells us what kind of obj
    // (doc or item) "this" is
    intrDebugOut((DEB_ITRACE,
		  "%x _IN CDefClient::~CDefClient\n",
		  this));

    Puts ("~CDefClient "); Puta(m_aItem); Putn();
    BOOL fDoc = (m_pdoc==this);

    Assert (m_chk==chkDefClient);

    ReleaseObjPtrs ();

    if (m_pdoc && !fDoc)
    {
	Assert (m_pdoc->m_chk==chkDefClient);
	m_pdoc->m_pUnkOuter->Release();
    }
    if (fDoc)
    {
	// delete all the items(objects) for this doc
	DeleteAllItems ();
	if (m_fRunningInSDI && m_psrvrParent
	    && m_psrvrParent->QueryRevokeClassFactory())
	{
	    m_psrvrParent->Revoke();
	}

    }

    if (ISATOM(m_aItem))
	GlobalDeleteAtom (m_aItem);
    if (m_plkbytNative)
    {
	m_plkbytNative->Release();
	Assert (m_pstgNative);
	// They always go together
    }
    if (m_pstgNative)
	m_pstgNative->Release();
    if (m_ptd)
	PrivMemFree(m_ptd);

    // Delete client advise info
    DeleteAdviseInfo ();
    if (fDoc && IsWindow(m_hwnd))
    {
        SSDestroyWindow (m_hwnd);
    }
    intrDebugOut((DEB_ITRACE,
		  "%x _OUT CDefClient::~CDefClient\n",
		  this));

}


//
// Unknown Implementation
//

STDMETHODIMP NC(CDefClient,CUnknownImpl)::QueryInterface
    (REFIID     iid,
    LPVOID FAR* ppv)
{
    intrDebugOut((DEB_ITRACE,"%p CDefClient::QueryInterface()\n",this));

    if (iid == IID_IUnknown)
    {
	*ppv = (LPVOID) &m_pDefClient->m_Unknown;
	AddRef();
	return NOERROR;
    }
    else if (iid==IID_IAdviseSink)
	*ppv = (LPVOID) &m_pDefClient->m_AdviseSink;
    else if (iid==IID_IOleClientSite)
	*ppv = (LPVOID) &m_pDefClient->m_OleClientSite;
    else
    {
	*ppv = NULL;
	return ReportResult(0, E_NOINTERFACE, 0, 0);
    }
    m_pDefClient->m_pUnkOuter->AddRef();

    return NOERROR;
}


STDMETHODIMP_(ULONG) NC(CDefClient,CUnknownImpl)::AddRef()
{
    intrDebugOut((DEB_ITRACE,
		  "%p CDefClient::AddRef() returns %x\n",
		  this,
		  m_pDefClient->m_cRef+1));

    return ++m_pDefClient->m_cRef;
}


STDMETHODIMP_(ULONG) NC(CDefClient,CUnknownImpl)::Release()
{
    AssertSz (m_pDefClient->m_cRef, "Release is being called on ref count of zero");
    if (--m_pDefClient->m_cRef == 0)
    {
	delete m_pDefClient;
	intrDebugOut((DEB_ITRACE,
		      "%p CDefClient::Release() returns 0\n",
		      this));
	return 0;
    }
    intrDebugOut((DEB_ITRACE,
		  "%p CDefClient::Release() returns %x\n",
		  this,
		  m_pDefClient->m_cRef));

    return m_pDefClient->m_cRef;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\com\dde\server\ddesrvr.cxx ===
/*
    ddesrvr.cpp

    Author:
    Jason Fuller    jasonful    8-11-92
*/

#include <ole2int.h>
#include <dde.h>
#include <olerem.h>
#include "srvr.h"
#include "ddeatoms.h"
#include "ddesrvr.h"
#include "ddedebug.h"
#include "map_up.h"

#include "map_dwp.h"
#include "strsafe.h"

ASSERTDATA

// Dde Common Window stuff

UINT         cCommonWindows = 0;

const LPOLESTR szDdeServerWindow = OLESTR("DDE Server Window");
const LPOLESTR szDdeCommonWindowClass = OLESTR("DdeCommonWindowClass");

//+---------------------------------------------------------------------------
//
//  Function:   CreateDdeSrvrWindow
//
//  Synopsis:   When CoRegisterClassObject is called, this function
//              is called to create a DDE window to listen for DDE messages
//              from a 1.0 client.
//
//  Effects:
//
//  Arguments:  [clsid] --
//              [aClass] --
//              [phwnd] --
//              [fIsRunning] --
//              [aOriginalClass] --
//              [cnvtyp] --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    5-27-94   kevinro Commented/cleaned
//             13-Jul-94  BruceMa   Make register/unregister dde window class
//                                    thread safe
//
//  Notes:
//
//----------------------------------------------------------------------------
INTERNAL CreateDdeSrvrWindow
    (REFCLSID clsid,
    ATOM      aClass,
    HWND FAR* phwnd,        // optional out parm: created window
    BOOL      fIsRunning,   // Is the item atom a file in the ROT?
    ATOM      aOriginalClass,   // for TreatAs/ConvertTo case
    CNVTYP    cnvtyp)
{
    intrDebugOut((DEB_DDE_INIT,"0 _IN CreateDdeSrvrWindow\n"));

    VDATEHEAP();
    HWND                hwnd    = NULL;

    HRESULT             hresult = NOERROR;

    DdeClassInfo        ddeClassInfo;

    ddeClassInfo.dwContextMask = CLSCTX_LOCAL_SERVER | CLSCTX_INPROC_SERVER;
    ddeClassInfo.fClaimFactory = FALSE;

    // Null out parameter in case of error
    if (phwnd)
    {
        *phwnd = NULL;
    }

    intrAssert (wIsValidAtom (aClass));

    //
    // See if this process is registered as a class server for
    // the requested class. If it isn't, then check for a running
    // object.
    //
    if (CCGetClassInformationForDde(clsid,&ddeClassInfo) == FALSE)
    {
        intrDebugOut((DEB_DDE_INIT,
                      "CreateDdeSrvrWindow No class information available\n"));

        //
        // The ClassObject was not found in the table.
        //

        if (fIsRunning)
        {
            // Link case.
            // An SDI app was launched by the user (without "-Embedding").
            // It did not register its class factory. (It never does.)
            // Meanwhile, a DDE_INIT with a filename as an item atom was
            // broadcasted.
            // We are in the task of the SDI app that loaded that filename,
            // so this function was called.
            // So we need to create the window even though no class factory
            // was registered.
            // Call CDDEServer::Create with a lot of NULLs.
            // Once the DDE_INIT is passed along to the server window, it
            // should immediately cause a doc window to be created.
            // Must be SDI or we wouldn't have this problem.
            //
            // This works because we are going to attempt to 'bind' to the
            // object which is the subject of the link. If the link object
            // was registered as running, we will find it. Otherwise, the
            // attempt to create via the class factory will fail, since the
            // class factory doesn't exist.
            //

            intrDebugOut((DEB_DDE_INIT,
                      "::CreateDdeServerWindow fIsRunning - override dwFlags\n"));

            //
            // NULL out the entire structure, then set only the flags
            //
            memset(&ddeClassInfo,0,sizeof(ddeClassInfo));
            ddeClassInfo.dwFlags = REGCLS_SINGLEUSE;


        }
        else
        {
            intrDebugOut((DEB_DDE_INIT,
                          "CreateDdeServerWindow Returning FALSE\n"));

            hresult = S_FALSE;
            goto errRtn;
        }
    }
    intrDebugOut((DEB_DDE_INIT,
                  "::CreateDdeServerWindow found class\n"));
    // Create() does the real work: creates a CDDEServer and the window.
    WCHAR szClass[MAX_STR];
    StringCbCopyW(szClass, sizeof(szClass), wAtomName (aClass));
    Assert (szClass[0]);

    hresult = CDDEServer::Create(szClass,
                                 clsid,
                                 &ddeClassInfo,
                                 &hwnd,
                                 aOriginalClass,
                                 cnvtyp);
    if (hresult != NOERROR)
    {
        intrDebugOut((DEB_IERROR,
                      "CreateDdeServerWindow CDDEServer::Create returns %x\n",
                      hresult));
        goto errRtn;
    }

    Assert (IsWindowValid(hwnd));

    // Fill in out parameter
    if (phwnd)
    {
        *phwnd = hwnd;
    }


errRtn:
    VDATEHEAP();
    intrDebugOut((DEB_DDE_INIT,
                  "0 _OUT CreateDdeSrvrWindow %x\n",
                  hresult));
    return hresult;

}



//+---------------------------------------------------------------------------
//
//  Function:   DestroyDdeSrvrWindow
//
//  Synopsis:   Destroy a DDE server window
//
//  Effects:
//
//  Arguments:  [hwnd] -- Window to destroy
//              [aClass] -- Class for server
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    6-24-94   kevinro   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
INTERNAL DestroyDdeSrvrWindow
    (HWND hwnd,
    ATOM aClass)
{
    intrDebugOut((DEB_ITRACE,
                  "0 _IN DestroyDdeSrvrWindow\n"));
    VDATEHEAP();
    Assert (IsAtom (aClass));

    // Make sure it is a server window
    RetZ (IsWindowValid (hwnd));
    RetZ (GetWindowWord (hwnd, WW_LE) == WC_LE);


    // Get the Common window for this task.

    HWND hwndCommonServer = (HWND)TLSGetDdeServer();

    if (hwndCommonServer == NULL)
    {
        intrDebugOut((DEB_IERROR,"hwndCommonServer != NULL\n"));
        return(E_UNEXPECTED);
    }
    if (!IsWindow(hwndCommonServer))
    {
        intrAssert(IsWindow(hwndCommonServer));
        return(E_UNEXPECTED);
    }

    // Get the map from the common window
    CMapUintPtr FAR *pmapClassToHwnd;
    Assert (sizeof (CMapUintPtr FAR *)==sizeof(LONG));
    pmapClassToHwnd = (CMapUintPtr FAR *) GetWindowLongPtr (hwndCommonServer, 0);
    Assert (pmapClassToHwnd);

    // Make sure the window we're deleting is the server window for this class
    void *hwndSrvr = NULL;    // COM+ 22885
    RetZ (pmapClassToHwnd->Lookup (aClass,hwndSrvr) && hwndSrvr == hwnd);

    RetZ (SSDestroyWindow (hwnd));

    // Remove this window from the map
    pmapClassToHwnd->RemoveKey (aClass);

    VDATEHEAP();
    intrDebugOut((DEB_ITRACE,
                  "0 _OUT DestroyDdeSrvrWindow\n"));

    return NOERROR;
}

//+---------------------------------------------------------------------------
//
//  Function:   DdeCommonWndProc
//
//  Synopsis:   Window proc for the common dde server window that
//              listens for all WM_DDE_INITIATEs
//
//  Effects:    When a DDE_INITIATE comes in, this routine will determine
//              the class of the object being requested. If the class is
//              served by this thread, then it will create a window to
//              converse with the server.
//
//  Arguments:  [hWnd] --  hWnd of Common DDE
//              [wMsg] --  msg
//              [wParam] --  Return Window to converse with
//              [lParam] --  HIWORD(aItem) LOWORD(aClass)
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    5-27-94   kevinro Commented/cleaned
//
//  Notes:
//
//  When running in a VDM, it is possible that this window was dispatched
//  without having a full window handle. This happens when the getmessage
//  was dispatched from 16-bit. Therefore, we need to convert the hwnd to
//  a full hwnd before doing any comparision functions.
//
//----------------------------------------------------------------------------
STDAPI_(LRESULT)
DdeCommonWndProc(HWND hwndIn, UINT wMsg, WPARAM wParam, LPARAM lParam)
{

    switch (wMsg)
    {
    case WM_DDE_INITIATE:
    {
        VDATEHEAP();
        ATOM aClass = LOWORD(lParam);
        ATOM aItem  = HIWORD(lParam);
        HWND hwnd;

        CNVTYP cnvtyp = cnvtypNone;

        BOOL fIsFile= FALSE;       // Must initialize
        BOOL fIsRunning= FALSE;    // Must initialize
        BOOL fUnsavedDoc = FALSE;  // Is the "file" really an unsaved doc
        HWND hwndServer;
        HRESULT hresult;


        //
        // From this point forward, we need to insure we are using a
        // FULL hwnd.
        //
        hwnd = ConvertToFullHWND(hwndIn);

        //
        // The following should already be initialized
        //
        intrAssert (aOLE != NULL);
        intrAssert (aSysTopic != NULL);

        if (aItem==aOLE || aItem==aSysTopic
            || (fIsFile=IsFile (aItem, &fUnsavedDoc)))
        {


            intrDebugOut((DEB_DDE_INIT,
                          "DdeCommonWndProc:hWnd(%x) DDE_INITIATE cls(%ws)\n",
                          hwnd,
                          wAtomName(aClass)));

            //
            // Get the ClassToHwnd map for this thread
            //
            CMapUintPtr FAR *pmapClassToHwnd;
            
            pmapClassToHwnd = (CMapUintPtr FAR *) GetWindowLongPtr (hwnd, 0);
            Assert (pmapClassToHwnd);


            // Convert atom to CLSID, taking into account
            // TreatAs and AutoConvert.
            CLSID clsid;
            ATOM aOriginalClass = aClass;

            if (CLSIDFromAtomWithTreatAs (&aClass, &clsid, &cnvtyp) != NOERROR)
            {
                intrDebugOut((DEB_IERROR,"Could not get clsid for this class\n"));
                return 0L;
            }

            void *pServerTmp;
            if (TRUE == pmapClassToHwnd->Lookup (aClass, pServerTmp))
            {
                //
                // Since a server window for this class already exists, but is a child window
                // of ours, we will send it this message directly.
                //

                intrDebugOut((DEB_DDE_INIT,
                              "DdeCommonWndProc Server cls exists. Forwarding to %x\n",
                              pServerTmp));

                return SSSendMessage ((HWND)pServerTmp, WM_DDE_INITIATE, wParam,lParam);

            }

            if (CoIsOle1Class (clsid))
            {
                // We have no business intercepting Initiates sent
                // to 1.0 servers
                intrDebugOut((DEB_DDE_INIT,
                              "DdeCommonWndProc: Its a OLE 1.0 class\n"));
                return 0L;
            }

            if (fIsFile)
            {
                // Link case
                WCHAR szFile[MAX_STR] = {0};

                WORD cb= (WORD) GlobalGetAtomName (aItem, szFile, MAX_STR);
                Assert (cb>0 && cb < MAX_STR-1);
                intrDebugOut((DEB_DDE_INIT,
                              "Looking for file %ws\n",szFile));

                IsRunningInThisTask (szFile, &fIsRunning);
            }

            // If it's not a file, it can't be running, obviously.
            intrAssert (fIsFile || !fIsRunning);

            if (NOERROR == (hresult=(CreateDdeSrvrWindow (clsid,
                                                          aClass,
                                                          &hwndServer,
                                                          fIsRunning,
                                                          aOriginalClass,
                                                          cnvtyp))))
            {

                    // Indicate that we have created a server window
                    // for this class.  We could have used any value in
                    // place of hwndServer_.  It's just a flag.
                    // REVIEW jasonful: how to handle OOM?

                    pmapClassToHwnd->SetAt (wDupAtom(aClass), hwndServer);

#if DBG == 1
                            // Verify the SetAt we just did.
                            void FAR* pv;
                            Verify (pmapClassToHwnd->Lookup(aClass, pv));
                            Assert (pv == hwndServer);
#endif
                    // Pass the INITIATE along to the real,
                    // newly-created server window and forge
                    // the sender's hwnd to be whoever called
                    // the common server window.
                    // SendMessage should return 1L is doc is running,
                    // indicating an ACK was sent.
                    Assert (IsWindowValid (hwndServer));
                    SSSendMessage (hwndServer, WM_DDE_INITIATE, wParam,lParam);
                    intrDebugOut((DEB_DDE_INIT,
                                  "DdeCommonWndProc:hWnd(%x) DDE_INITIATE complete(%ws)\n",
                                  hwnd,
                                  wAtomName(aClass)));
                    VDATEHEAP();
            }
            else
            {
                if (S_FALSE!=GetScode(hresult))
                {
                    intrDebugOut((DEB_IERROR,
                                  "DCWP: CreateDdeSrvrWindow failed %x\n",
                                  hresult));
                }
            }
        }
        else
        {
            //
            // We have a DDE_INITIATE message that needs to be forwarded to our
            // child window.
            //
            return SendMsgToChildren(hwnd,wMsg,wParam,lParam);
        }
    return 0L;
    }
    break;

    case WM_DESTROY:
    {
        //
        // When this window is destroyed, we cleanup the
        // windows attached data.
        //

        CMapUintPtr FAR *pmapClassToHwnd;
        pmapClassToHwnd = (CMapUintPtr FAR *) GetWindowLongPtr (hwndIn, 0);

        //
        // Make sure there are no server windows
        // created by this common window still extant. If there are, print out
        // a message on a debug build. Otherwise, there really isn't much we
        // can do about it. We are already closing down. The DDE emulation layer
        // will send appropriate terminate messages.
        //

    #if DBG == 1
        if (pmapClassToHwnd && !pmapClassToHwnd->IsEmpty())
        {
            intrDebugOut((DEB_ERROR,
                          "DCDW Leaking active OLE 1.0 clients\n"));
            intrDebugOut((DEB_ERROR,
                          "There were active OLE 1.0 connections at shutdown\n"));
        }
    #endif
        delete pmapClassToHwnd;
        return(0);
    }



    default:
        return SSDefWindowProc (hwndIn, wMsg, wParam, lParam);
    }
}




//+---------------------------------------------------------------------------
//
//  Function:   CreateCommonDdeWindow
//
//  Synopsis:   Creates a DDE window for initiating conversations with this
//              threads objects.
//
//  Effects:    Creates a window that responds to DDE_INITIATE messages, and
//              determines if it needs to respond to the INITIATE. This
//              routine is called by OleInitializeEx()
//
//              The handle to the created window is placed in the TLS
//              structure.
//
//  Arguments:  [void] --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    5-27-94   kevinro   Converted to OLE32
//
//  Notes:
//
//----------------------------------------------------------------------------
INTERNAL CreateCommonDdeWindow
    (void)
{
    intrDebugOut((DEB_ITRACE,"%p _IN CreateCommonDdeWindow\n",0));

    HRESULT hr = NOERROR;
    HWND hwndDdeServer;
    COleTls tls;

#if DBG==1
    if (tls->dwFlags & OLETLS_DISABLE_OLE1DDE)
    {
        // If DDE use is disabled we shouldn't have gotten here.
        Assert(!"Executing CreateCommonDdeWindow when DDE is disabled");
    }

    if (tls->hwndDdeServer != NULL || tls->cOleInits == 0)
    {
        // A DdeServer window better not already exist and OLE better
        // already be initialized.
        Assert(!"Executing CreateCommonDdeWindow when window already exists or OLE not initialized");
    }
#endif

    if (!(hwndDdeServer = DdeCreateWindowEx(0, gOleDdeWindowClass,
                                        szDdeServerWindow,
                                        WS_POPUP,0,0,0,0,
                                        NULL,NULL,
                                        g_hmodOLE2, NULL)))
    {
        intrDebugOut((DEB_IERROR,
                      "CreateCommonDocWindow() has failed %x\n",
                      GetLastError()));

        hr =  E_OUTOFMEMORY;
        goto exitRtn;
    }

    intrDebugOut((DEB_ITRACE,
                  "CreateCommonDocWindow() hwndDdeServer=%x\n",
                  hwndDdeServer));

    // Give the common window a map from classes to server windows

    CMapUintPtr FAR *pmapClassToHwnd;

    if ((pmapClassToHwnd = new CMapUintPtr) == NULL)
    {
        intrDebugOut((DEB_ERROR,"pmapClassToHwnd != NULL\n"));
        hr =  E_OUTOFMEMORY;
        goto errRtn;
    }

    SetWindowLongPtr (hwndDdeServer, 0, (LONG_PTR)pmapClassToHwnd);
    //
    // Set the pointer to the server in the TLS data
    //

    tls->hwndDdeServer = hwndDdeServer;

exitRtn:

    intrDebugOut((DEB_ITRACE,"%p _OUT CreateCommonDocWindow (%x)\n",0,hr));

    return(hr);

    //
    // In the error case, if the hwnDdeServer != NULL, then destroy it
    //
errRtn:
    if (hwndDdeServer != NULL)
    {
        SSDestroyWindow(hwndDdeServer);
    }

    goto exitRtn;
}





//+---------------------------------------------------------------------------
//
//  Function:   DestroyCommonDdeWindow
//
//  Synopsis:   Destroys the common DDE Server window
//
//  Effects:
//
//  Arguments:  [void] --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    5-27-94   kevinro Commented/cleaned
//
//  Notes:
//
//----------------------------------------------------------------------------
INTERNAL DestroyCommonDdeWindow
    (void)
{
    intrDebugOut((DEB_ITRACE,"%p _IN DestroyCommonDdeWindow\n",0));

    HRESULT hr = S_OK;
    COleTls tls;

    HWND hwndDdeServer = tls->hwndDdeServer;

    if (hwndDdeServer == NULL)
    {
        goto errRtn;
    }


    //
    // The map from the common window got deleted in DdeCommonWndProc
    //

    //
    // If destroying this window fails, there isn't much we can
    // do about it.
    //
    if(!SSDestroyWindow (hwndDdeServer))
    {
        hr = E_UNEXPECTED;
    }

    // NULL out the TLS
    tls->hwndDdeServer = NULL;

errRtn:
    intrDebugOut((DEB_ITRACE,"%p _OUT DestroyCommonDdeWindow %x\n",0,hr));
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   IsRunningInThisTask
//
//  Synopsis:   Determine if the given file is running in the current task
//
//  Effects:    Calls a special function in the ROT to determine if the
//              file szFile is loaded as a moniker in the current task
//
//  Arguments:  [szFile] -- Filename
//              [pf] -- Points to a BOOL. Returned TRUE if running
//
//  History:    6-29-94   kevinro   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
INTERNAL IsRunningInThisTask(LPOLESTR szFileIn,BOOL FAR* pf)  // out parm
{
    HRESULT hresult;

    intrDebugOut((DEB_DDE_INIT,
                  "IsRunninginThisTask szFileIn=%ws\n",
                  WIDECHECK(szFileIn)));

    //
    // The RunningObjectTable always stores LONG filenames, therefore we
    // need to convert this name to the long name for the lookup.
    //

    WCHAR szFile[MAX_PATH];
    if ((lstrlenW(szFileIn) == 0) || (GetLongPathNameW(szFileIn,szFile,MAX_PATH) == 0))
    {
        //
        // Unable to determine a long path for this object. Use whatever we were
        // handed.
        //
        intrDebugOut((DEB_DDE_INIT,"No conversion to long path. Copy szFileIn\n"));
        StringCbCopyW(szFile, sizeof(szFile), szFileIn);
    }

    intrDebugOut((DEB_DDE_INIT,"Long file szFile(%ws)\n",szFile));

    hresult = GetLocalRunningObjectForDde(szFile,NULL);

    *pf = (hresult == S_OK);

    intrDebugOut((DEB_DDE_INIT,
                  "IsRunninginThisTask szFile=%ws returns %s\n",
                  WIDECHECK(szFile),
                  *pf?"TRUE":"FALSE"));
    return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\com\dde\server\itemutil.h ===
// itemutil.h
//
// Corresponds to itemutil.cpp

void ChangeOwner (HANDLE hmfp);
INTERNAL ScanItemOptions (LPSTR   lpbuf, int far *lpoptions);
INTERNAL_(BOOL) MakeDDEData (HANDLE hdata, int format, LPHANDLE lph, BOOL fResponse);
INTERNAL_(BOOL)     IsAdviseStdItems (ATOM aItem);
INTERNAL_(int)  GetStdItemIndex (ATOM aItem);
void ChangeOwner (HANDLE hmfp);
INTERNAL_(HANDLE)  MakeItemData (DDEPOKE FAR *lpPoke, HANDLE hPoke, CLIPFORMAT cfFormat);
INTERNAL_(HANDLE)  DuplicateMetaFile (HANDLE hSrcData);
INTERNAL_(HBITMAP)  DuplicateBitmap (HBITMAP hold);
INTERNAL wSetTymed (LPFORMATETC pformatetc);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\com\dde\server\itemutil.cxx ===
// itemutil.h//
// routines used by item.cpp
// They used to be in item.cpp but it got too big.


#include "ole2int.h"
#include "srvr.h"
#include "itemutil.h"
#include "ddedebug.h"

ASSERTDATA


//ScanItemOptions: Scan for the item options like Close/Save etc.

INTERNAL_(HRESULT) ScanItemOptions
(
LPOLESTR   lpbuf,
int far *lpoptions
)
{

    ATOM    aModifier;

    *lpoptions = OLE_CHANGED;
    while ( *lpbuf && *lpbuf != '/') lpbuf++;

    // no modifier same as /change

    if (*lpbuf == NULL)
	return NOERROR;

    *lpbuf++ = NULL;        // seperate out the item string
			    // We are using this in the caller.

    if (!(aModifier = GlobalFindAtom (lpbuf)))
	return ReportResult(0, RPC_E_DDE_SYNTAX_ITEM, 0, 0);

    if (aModifier == aChange)
	return NOERROR;

    // Is it a save?
    if (aModifier == aSave){
	*lpoptions = OLE_SAVED;
	return  NOERROR;
    }
    // Is it a Close?
    if (aModifier == aClose){
	*lpoptions = OLE_CLOSED;
	return NOERROR;
    }

    // unknow modifier
    return ReportResult(0, RPC_E_DDE_SYNTAX_ITEM, 0, 0);

}




//MakeDDEData: Create a Global DDE data handle from the server
// app data handle.

INTERNAL_(BOOL) MakeDDEData
(
HANDLE      hdata,
int         format,
LPHANDLE    lph,
BOOL        fResponse
)
{
    DWORD       size;
    HANDLE      hdde   = NULL;
    DDEDATA FAR *lpdata= NULL;
    BOOL	bnative;
    LPSTR       lpdst;
    LPSTR       lpsrc;

    Puts ("MakeDDEData\r\n");

    if (!hdata) {
	*lph = NULL;
	return TRUE;
    }

	
    if (bnative = !(format == CF_METAFILEPICT
            || format == CF_ENHMETAFILE
            || format == CF_DIB
            || format == CF_BITMAP))
    {
	// g_cfNative, CF_TEXT, g_cfBinary
       size = (ULONG) GlobalSize (hdata) + sizeof (DDEDATA);
    }
    else
       size = sizeof (HANDLE_PTR) + sizeof (DDEDATA);


    hdde = (HANDLE) GlobalAlloc (GMEM_DDESHARE | GMEM_ZEROINIT, size);
    if (hdde == NULL || (lpdata = (DDEDATA FAR *) GlobalLock (hdde)) == NULL)
	goto errRtn;

    // set the data otions. Ask the client to delete
    // it always.

    lpdata->fAckReq  = FALSE;
    lpdata->fRelease = TRUE;  // release the data
    lpdata->cfFormat = (CLIPFORMAT) format;
    lpdata->fResponse = fResponse;

    if (!bnative) {

	// If not native, stick in the handle what the server gave us.
#ifdef _WIN64
        if (format == CF_METAFILEPICT)
            *(void* __unaligned*)lpdata->Value = hdata;
        else
#endif
            *(LONG*)lpdata->Value = HandleToLong(hdata);
    }
    else {
	// copy the native data junk here.
	lpdst = (LPSTR)lpdata->Value;
	if(!(lpsrc = (LPSTR)GlobalLock (hdata)))
	    goto errRtn;

	 size -= sizeof (DDEDATA);
	 memcpy (lpdst, lpsrc, size);
	 GlobalUnlock (hdata);
	 GlobalFree (hdata);

    }

    GlobalUnlock (hdde);
    *lph = hdde;
    return TRUE;

errRtn:
    if (lpdata)
	GlobalUnlock (hdde);

    if (hdde)
	GlobalFree (hdde);

    if (bnative)
	 GlobalFree (hdata);

    return FALSE;
}



// IsAdviseStdItems: returns true if the item is one of the standard items
// StdDocName;
INTERNAL_(BOOL)     IsAdviseStdItems (
ATOM   aItem
)
{

    if ( aItem == aStdDocName)
	return TRUE;
    else
	return FALSE;
}



// GetStdItemIndex: returns index to Stditems in the "stdStrTable" if the item
// is one of the standard items StdHostNames, StdTargetDevice,
// StdDocDimensions, StdColorScheme
WCHAR * stdStrTable[STDHOSTNAMES+1] = {NULL,
				       OLESTR("StdTargetDevice"),
				       OLESTR("StdDocDimensions"),
				       OLESTR("StdColorScheme"),
				       OLESTR("StdHostNames")};

INTERNAL_(int)  GetStdItemIndex (
ATOM   aItem
)
{

    WCHAR    str[MAX_STR];

    if (!aItem)
	return NULL;

    if (!GlobalGetAtomName (aItem, str, MAX_STR))
	return NULL;

    if (!lstrcmpiW (str, stdStrTable[STDTARGETDEVICE]))
	return STDTARGETDEVICE;
    else if (!lstrcmpiW (str, stdStrTable[STDHOSTNAMES]))
	return STDHOSTNAMES;
    else if (!lstrcmpiW (str, stdStrTable[STDDOCDIMENSIONS]))
	return STDDOCDIMENSIONS;
    else if (!lstrcmpiW (str, stdStrTable[STDCOLORSCHEME]))
	return STDCOLORSCHEME;

    return NULL;
}




void ChangeOwner
    (HANDLE hmfp)
{

#ifndef WIN32
    LPMETAFILEPICT  lpmfp;
    if (lpmfp = (LPMETAFILEPICT) GlobalLock (hmfp))
    {
	SetMetaFileBitsBetter (lpmfp->hMF);
	GlobalUnlock (hmfp);
    }
#endif
}


INTERNAL_(HANDLE)  MakeItemData
(
DDEPOKE FAR *   lpPoke,
HANDLE  	hPoke,
CLIPFORMAT      cfFormat
)
{
    HANDLE  hnew;
    LPBYTE   lpnew;
    DWORD   dwSize;

    Puts ("MakeItemData\r\n");

    if (cfFormat == CF_METAFILEPICT) {
#ifdef _WIN64
        return DuplicateMetaFile(*(void* __unaligned*)lpPoke->Value);
#else
	return DuplicateMetaFile (*(LPHANDLE)lpPoke->Value);
#endif
    }
    
    if (cfFormat == CF_BITMAP)
	return (HANDLE)DuplicateBitmap ((HBITMAP)LongToHandle(*(LONG*)lpPoke->Value));

    if (cfFormat == CF_DIB)
	return UtDupGlobal (LongToHandle(*(LONG*)lpPoke->Value), GMEM_MOVEABLE);

    // Now we are dealing with normal case
    if (!(dwSize = (DWORD) GlobalSize (hPoke)))
	return NULL;

    dwSize -= sizeof (DDEPOKE) - sizeof(BYTE);

    // Use GMEM_ZEROINIT so there is no garbage after the data in field Value.
    // This may be important when making an IStorage from native data,
    // but I'm not sure.
    // Note that the Value field itself could have garbage
    // at the end if the hData of the DDE_POKE message is bigger than
    // necessary, i.e.,
    // GlobalSize(hData) > sizeof(DDEPOKE) - sizeof(Value) + realsize(Value)

    // A DocFile is of size 512n
    DebugOnly (
    if (cfFormat==g_cfNative && dwSize%512 != 0)
    {
	Putsi(dwSize);
	Puts ("DDE_POKE.Value not of size 512n\r\n");
    }
    )

    if (hnew = GlobalAlloc (GMEM_MOVEABLE|GMEM_ZEROINIT, dwSize)) {
	if (lpnew = (LPBYTE) GlobalLock (hnew)) {
	    memcpy (lpnew, lpPoke->Value, dwSize);
	    GlobalUnlock (hnew);
	}
	else {
	    GlobalFree (hnew);
	    hnew = NULL;
	}
    }

    return hnew;
}



INTERNAL_(HANDLE)  DuplicateMetaFile
(
HANDLE hSrcData
)
{
    LPMETAFILEPICT  lpSrcMfp;
    LPMETAFILEPICT  lpDstMfp = NULL;
    HANDLE          hMF = NULL;
    HANDLE          hDstMfp = NULL;

    Puts ("DuplicateMetaFile\r\n");
	
    if (!(lpSrcMfp = (LPMETAFILEPICT) GlobalLock(hSrcData)))
	return NULL;
	
    GlobalUnlock (hSrcData);
	
    if (!(hMF = CopyMetaFile (lpSrcMfp->hMF, NULL)))
	return NULL;
	
    if (!(hDstMfp = GlobalAlloc (GMEM_MOVEABLE, sizeof(METAFILEPICT))))
	goto errMfp;

    if (!(lpDstMfp = (LPMETAFILEPICT) GlobalLock (hDstMfp)))
	goto errMfp;
	
    GlobalUnlock (hDstMfp);
	
    *lpDstMfp = *lpSrcMfp;
    lpDstMfp->hMF = (HMETAFILE)hMF;
    return hDstMfp;
errMfp:
    //
    // The following Metafile was created in this
    // process. Therefore, the delete shouldn't need to
    // call the DDE functions for deleting the DDE pair
    //
    if (hMF)
	DeleteMetaFile ((HMETAFILE)hMF);
	
    if (hDstMfp)
	GlobalFree (hDstMfp);
	
     return NULL;
}



INTERNAL_(HBITMAP)  DuplicateBitmap
(
HBITMAP     hold
)
{
    HBITMAP     hnew;
    HANDLE      hMem;
    LPBYTE      lpMem;
    LONG	retVal = TRUE;
    DWORD       dwSize;
    BITMAP      bm;

     // !!! another way to duplicate the bitmap

    Puts ("DuplicateBitmap\r\n");

    GetObject (hold, sizeof(BITMAP), (LPSTR) &bm);
    dwSize = ((DWORD) bm.bmHeight) * ((DWORD) bm.bmWidthBytes) *
	     ((DWORD) bm.bmPlanes) * ((DWORD) bm.bmBitsPixel);

    if (!(hMem = GlobalAlloc (GMEM_MOVEABLE | GMEM_ZEROINIT, dwSize)))
	return NULL;

    if (!(lpMem = (LPBYTE) GlobalLock (hMem))){
	GlobalFree (hMem);
	return NULL;
    }

    GetBitmapBits (hold, dwSize, lpMem);
    if (hnew = CreateBitmap (bm.bmWidth, bm.bmHeight,
		    bm.bmPlanes, bm.bmBitsPixel, NULL))
	retVal = SetBitmapBits (hnew, dwSize, lpMem);

    GlobalUnlock (hMem);
    GlobalFree (hMem);

    if (hnew && (!retVal)) {
	DeleteObject (hnew);
	hnew = NULL;
    }

    return hnew;
}




// CDefClient::GetData
//
// Perform a normal GetData on m_lpdataObj, but if g_cfNative is requested,
// do an OleSave onto our IStorage implemented
// on top of an ILockBytes, then convert the ILockBytes to an hGlobal.
// This flattened IStorage will be used as the native data.
//
INTERNAL CDefClient::GetData
    (LPFORMATETC    pformatetc,
    LPSTGMEDIUM     pmedium)
{
    LPPERSISTSTORAGE pPersistStg=NULL;
    HANDLE           hNative    =NULL;
    HANDLE           hNativeDup =NULL;
    HRESULT          hresult    =NOERROR;
    BOOL	     fFreeHNative = FALSE;
    CLSID	     clsid;

    intrDebugOut((DEB_ITRACE,
		  "%x _IN CDefClient::GetData(%x,%x)\n",
		  this,
		  pformatetc,
		  pmedium));

    intrDebugOut((DEB_ITRACE,
		  " ::GetData format=%x\n",
		  pformatetc->cfFormat));

    if (pformatetc->cfFormat==g_cfNative)
    {
	ErrRtnH (m_lpdataObj->QueryInterface (IID_IPersistStorage,
					  (LPLPVOID) &pPersistStg));
	ErrZ (pPersistStg);
	if (NULL==m_pstgNative)
	{
	    // Embed from file case
	    Assert (NULL==m_plkbytNative);
	    ErrRtnH (CreateILockBytesOnHGlobal (NULL,
					       /*fDeleteOnRelease*/TRUE,
					       &m_plkbytNative));

	    Assert (m_plkbytNative);

	    ErrRtnH (StgCreateDocfileOnILockBytes (m_plkbytNative,
					    grfCreateStg, 0, &m_pstgNative));

	    ErrZ (m_pstgNative);
	    Assert (NOERROR==StgIsStorageILockBytes(m_plkbytNative));

	    m_fInOleSave = TRUE;
	    hresult = OleSave (pPersistStg, m_pstgNative, FALSE);
	    pPersistStg->SaveCompleted(NULL);
	    m_fInOleSave = FALSE;
	    ErrRtnH (hresult);
	}
	else
	{
	    // Get the native data by calling OleSave
	    m_fInOleSave = TRUE;
	    hresult = OleSave (pPersistStg, m_pstgNative, TRUE);
	    pPersistStg->SaveCompleted(NULL);
	    m_fInOleSave = FALSE;
	    ErrRtnH (hresult);
	}

	ErrRtnH (ReadClassStg (m_pstgNative, &clsid));

	if (CoIsOle1Class (clsid))
	{
	    // TreatAs case:
	    // Get Native data from "\1Ole10Native" stream
	    fFreeHNative = TRUE;
	    ErrRtnH (StRead10NativeData (m_pstgNative, &hNative));

	    pmedium->hGlobal = hNative;
	}
	else
	{

	    Assert (NOERROR==StgIsStorageILockBytes (m_plkbytNative));
	    ErrRtnH (GetHGlobalFromILockBytes (m_plkbytNative, &hNative));


	    // Must duplicate because we let the client free the handle,
	    // so it can't be the one our ILockBytes depends on.
	    hNativeDup = UtDupGlobal (hNative, GMEM_DDESHARE | GMEM_MOVEABLE);
	    ErrZ (wIsValidHandle (hNativeDup, g_cfNative));

	    if (hNativeDup && (GlobalSize(hNativeDup) % 512 != 0))
	    {
		Puts ("WARNING:\r\n\t");
		Putsi (GlobalSize(hNativeDup));
	    }


	    pmedium->hGlobal = hNativeDup;
	}

	ErrZ (wIsValidHandle (pmedium->hGlobal,g_cfNative));

	pmedium->tymed  	= TYMED_HGLOBAL;
	pmedium->pUnkForRelease = NULL;

	pPersistStg->Release();
	hresult = NOERROR;
	goto exitRtn;
    }
    else
    {
	// Anything but native
	hresult = m_lpdataObj->GetData (pformatetc, pmedium);
//	AssertOutStgmedium(hresult, pmedium);
	goto exitRtn;
    }


errRtn:
    if (hNative && fFreeHNative)
	GlobalFree (hNative);
    if (pPersistStg)
	pPersistStg->Release();

    pmedium->tymed = TYMED_NULL;
    pmedium->pUnkForRelease = NULL;

exitRtn:
    intrDebugOut((DEB_ITRACE,
		  "%x OUT CDefClient::GetData() return %x\n",
		  this,
		  hresult));
    return hresult;
}


// Set pformatetc->tymed based on pformatetc->cfFormat
//
INTERNAL wSetTymed
    (LPFORMATETC pformatetc)
{
    if (pformatetc->cfFormat == CF_METAFILEPICT)
    {
	    pformatetc->tymed = TYMED_MFPICT;
    }
    else if (pformatetc->cfFormat == CF_ENHMETAFILE)
    {
	    pformatetc->tymed = TYMED_ENHMF;
    }
    else if (pformatetc->cfFormat == CF_PALETTE ||
	     pformatetc->cfFormat == CF_BITMAP)
    {
	pformatetc->tymed = TYMED_GDI;
    }
    else
    {
	pformatetc->tymed = TYMED_HGLOBAL;
    }
    return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\com\dde\server\doc.cxx ===
/***************************************************************************\
* Module Name: Doc.c Document Main module
*
* Purpose: Includes All the document level object communication related.
*
* Created: Oct 1990.
*
* Copyright (c) 1990, 1991  Microsoft Corporation
*
* History:
*    Raor (../10/1990)    Designed, coded (modified for 2.0)
*
\***************************************************************************/

#include "ole2int.h"
//#include "cmacs.h"
#include <dde.h>

#include "srvr.h"
#include "ddedebug.h"
#include "valid.h"
ASSERTDATA

extern  ATOM     aStdClose;
extern  ATOM     aStdShowItem;
extern  ATOM     aStdDoVerbItem;
extern  ATOM     aStdDocName;
extern  ATOM     aTrue;
extern  ATOM     aFalse;

extern  HANDLE   hddeRename;
extern  HWND     hwndRename;

#define szDDEViewObj L"DDE ViewObj"


// HRESULT DdeHandleIncomingCall(HWND hwndCli, WORD wCallType);

//
// Call CoHandleIncomingCall which will call the message filter
// Note: only call this functions with:
//  -  CALLTYPE_TOPLEVEL  ... for synchranous calls
//  -  CALLTYPE_ASYNC     ... for async calls
//
HRESULT DdeHandleIncomingCall(HWND hwndCli, WORD wCallType)
{

    Assert(!"DdeHandleIncomingCall not implemented");

    return(RPC_E_CALL_REJECTED);

    // Review: bug: get the correcr hwnd
    switch ( /* CoHandleIncomingCall(hwndCli, wCallType, NULL) */ wCallType) {
    default:
    case SERVERCALL_ISHANDLED:  // call can be proccesed
        return NOERROR;

    case SERVERCALL_REJECTED:       // call rejected
        return  ResultFromScode(RPC_E_CALL_REJECTED);

    case SERVERCALL_RETRYLATER: // call should be retried later
        return  ResultFromScode(RPC_E_DDE_BUSY);
    }
}


INTERNAL CDefClient::Create
(
    LPSRVR      lhOLESERVER,
    LPUNKNOWN   lpunkObj,
    LPOLESTR       lpdocName,
    const BOOL  fSetClientSite,
    const BOOL  fDoAdvise,
    const BOOL  fRunningInSDI,  // optional
    HWND FAR*   phwnd           // optional
)
{
    LPSRVR      lpsrvr   = NULL;
    LPCLIENT    lpclient = NULL;
    HANDLE      hclient  = NULL;
    HRESULT     hresult  = NOERROR;

    intrDebugOut((DEB_ITRACE,
                  "0 _IN CDefClient::Create(lpsrvr=%x,lpdocName=%ws)\n",
                  lhOLESERVER,WIDECHECK(lpdocName)));

    // REVIEW: server's termination has already started. Are
    // we going to see this condition in the synchronous mode.
    lpsrvr = (LPSRVR)lhOLESERVER;
    if (lpsrvr && lpsrvr->m_bTerminate)
    {
        Assert(0);
        return ReportResult(0, RPC_E_DDE_REVOKE, 0, 0);
    }

#ifdef FIREWALLS
    PROBE_READ(lpunkObj);
    PROBE_READ(lpmkObj);
    PROBE_WRITE(lplhobj);
#endif

    lpclient = new CDefClient (/*pUnkOuter==*/NULL);;

    Assert(lpclient->m_pUnkOuter);

    lpclient->m_aItem         = wGlobalAddAtom (/*lpszObjName*/lpdocName);
    lpclient->m_fRunningInSDI = fRunningInSDI;
    lpclient->m_psrvrParent   = lpsrvr;
    // A doc has itself as its containing document
    lpclient->m_pdoc          = lpclient;

    ErrRtnH (lpunkObj->QueryInterface (IID_IOleObject,
                                        (LPLPVOID) &lpclient->m_lpoleObj));

    ErrRtnH (lpunkObj->QueryInterface (IID_IDataObject,
                                        (LPLPVOID) &lpclient->m_lpdataObj));

    // Lock object; do after the QI so that ReleaseObjPtrs will unlock correctly
    lpclient->m_fLocked =
                (NOERROR==CoLockObjectExternal (lpunkObj, TRUE, /*dont care*/ FALSE));

    if (!(lpclient->m_hwnd = DdeCreateWindowEx(0, gOleDdeWindowClass,szDDEViewObj,
          WS_CHILD,0,0,0,0,lpsrvr->m_hwnd,NULL, g_hinst, NULL)))
    {
        intrDebugOut((DEB_ITRACE,"CDefClient::Create() couldn't create window\n"));
        goto errRtn;
    }

    // fix up the WindowProc entry point.
    SetWindowLongPtr(lpclient->m_hwnd, GWLP_WNDPROC, (LONG_PTR)DocWndProc);

    if (fDoAdvise)
    {
        // This is for Packager, in particular, and manual links.
        // If client does not advise on any data, we still need
        // to do an OLE advise so we can get OnClose notifications.
        ErrRtnH (lpclient->DoOle20Advise (OLE_CLOSED, (CLIPFORMAT)0));
    }

    intrDebugOut((DEB_ITRACE,"  Doc window %x created\n",lpclient->m_hwnd));

    // Set out parm (window)
    if (phwnd != NULL)
    {
        *phwnd = lpclient->m_hwnd;
    }

    if (fSetClientSite)
    {
        // Should not set the client site if the object has not been
        // initialized yet, by BindMoniker (i.e. PersistFile::Load)
        // or PersistStorage::Load
        if (lpclient->SetClientSite() != NOERROR)
        {
            goto errRtn;
        }
    }

    Putsi(lpclient->m_cRef);

    SetWindowLongPtr (lpclient->m_hwnd, 0, (LONG_PTR)lpclient);
    SetWindowLongPtr (lpclient->m_hwnd, WW_LE, WC_LE);
    SetWindowLongPtr (lpclient->m_hwnd,WW_HANDLE,
                   (GetWindowLongPtr (lpsrvr->m_hwnd, WW_HANDLE)));

    hresult = NOERROR;

exitRtn:

    intrDebugOut((DEB_ITRACE,
                  "0 _OUT CDefClient::Create(lpsrvr=%x,lpdocName=%ws) hr=%x\n",
                  lhOLESERVER,
                  WIDECHECK(lpdocName),
                  hresult));


    return(hresult);
errRtn:
    intrDebugOut((DEB_ITRACE,"CDefClient::Create() in error handling routine\n"));
    if (lpclient)
    {
        if (lpclient->m_hwnd)
            SSDestroyWindow (lpclient->m_hwnd);

        if (lpclient->m_aItem)
            GlobalDeleteAtom (lpclient->m_aItem);
        delete lpclient;
    }
    hresult = E_OUTOFMEMORY;
    goto exitRtn;
}



INTERNAL CDefClient::Revoke (BOOL fRelease)
{
    Puts ("DefClient::Revoke "); Puth(this); Puta(m_aItem); Putn();

    ChkC(this);


    ReleaseObjPtrs();

    // We are done with this CDefClient but someone may still have a reference
    // to an instance of one of our nested classes.  In particular, an advise
    // holder may be holding on to our sink, or an item may have a pointer
    // to us if we are its parent document.  So we cannot actually do a
    // "delete this".
    // The corresponding AddRef is in CDefClient::Create
    // or CDefClient::RegisterItem

    m_pUnkOuter->Release();

    Puts ("DefClient::Revoke done\r\n");
    return NOERROR;
}



INTERNAL CDefClient::ReleaseObjPtrs
    (void)
{
    intrDebugOut((DEB_ITRACE,
                  "%p _IN CDefClient::ReleaseObjPtrs\n",
                  this));

    ULONG ulResult = 0;

    if (m_lpoleObj && m_fLocked)
    {
        // Unlock object.  Set m_fLocked to FALSE first to prevent reentrant
        // problems (unlock causes close which causes this routine to be called)

                m_fLocked = FALSE;
                CoLockObjectExternal(m_lpoleObj, FALSE, TRUE);
    }
    if (m_lpoleObj)
    {
        if (m_fDidSetClientSite)
            m_lpoleObj->SetClientSite(NULL);
        DoOle20UnAdviseAll();
        Assert (m_lpoleObj);
        if (m_lpoleObj)
        {
            ulResult = m_lpoleObj->Release();
            m_lpoleObj = NULL;
        }
        intrDebugOut((DEB_ITRACE,
                      "%p _OUT ::ReleaseObjPtrs lpoleObj ulResult=%x\n",
                              this,ulResult));
    }
    if (m_lpdataObj)
    {
        // Must do it this way because the Release can cause recursion
        LPDATAOBJECT pdata = m_lpdataObj;
        m_lpdataObj = NULL;
        ulResult = pdata->Release();
        intrDebugOut((DEB_ITRACE,
                      "%p _OUT ::ReleaseObjPtrs pdata ulResult=%x\n",
                      this,ulResult));
    }

    intrDebugOut((DEB_ITRACE,
                  "%p _OUT CDefClient::ReleaseObjPtrs\n",
                  this));
    return NOERROR;
}
#if 000
//RevokeAllDocs : revokes all the doc objects attached to a given
//server.

INTERNAL_(HRESULT) CDDEServer::RevokeAllDocObjs ()
{

    HWND    hwnd;
    HWND    hwndnext;
    LPCLIENT    lpclient;
    Puts ("RevokeAllDocObjs\r\n");
    ChkS(this);

    hwnd = GetWindow (m_hwnd, GW_CHILD);

    // Go thru each of the child windows and revoke the corresponding
    // document. Doc windows are child windows for the server window.

    while (hwnd){
        // sequence is important
        hwndnext = GetWindow (hwnd, GW_HWNDNEXT);
        lpclient = ((LPCLIENT)GetWindowLongPtr (hwnd, 0));
        lpclient->Revoke();
        hwnd =  hwndnext;
    }
    return NOERROR;
}
#endif

// FindDoc: Given a doc obj, searches for the doc obj
// in the given class factory tree. returns true if the
// doc obj is available.


INTERNAL_(LPCLIENT)  CDDEServer::FindDocObj
(
LPSTR   lpdocname
)
{
    ATOM        aItem;
    HWND        hwnd;
    LPCLIENT    lpclient;

    ChkS(this);
    aItem = (ATOM)GlobalFindAtomA (lpdocname);
    Assert (IsWindowValid (m_hwnd));
    hwnd = GetWindow (m_hwnd, GW_CHILD);
    Assert (NULL==hwnd || IsWindowValid (hwnd));

    while (hwnd)
    {
        lpclient = (LPCLIENT)GetWindowLongPtr (hwnd, 0);
        if (lpclient->m_aItem == aItem)
        {
            intrDebugOut((DEB_ITRACE,
                          "FindDocObj found %s lpclient=%x\n",
                          lpdocname,
                          lpclient));
            return lpclient;
        }
        hwnd = GetWindow (hwnd, GW_HWNDNEXT);
    }
    return NULL;
}

BOOL PostAckToClient(HWND hwndClient,HWND hwndServer,ATOM aItem,DWORD retval)
{
    BOOL fResult = TRUE;
    intrDebugOut((DEB_ITRACE,
                  "0 _IN PostAckToClient(hwndClient=%x,hwndServer=%x,aItem=%x(%ws)\n",
                  hwndClient,
                  hwndServer,
                  aItem,
                  wAtomName(aItem)));

    DWORD status = 0;
    SET_MSG_STATUS (retval, status);

    LPARAM lp = MAKE_DDE_LPARAM(WM_DDE_ACK,status,aItem);

    if (!PostMessageToClient (hwndClient,
                              WM_DDE_ACK,
                              (WPARAM)hwndServer,
                              lp))
    {
                DDEFREE(WM_DDE_ACK,lp);
                fResult = FALSE;
    }
    intrDebugOut((DEB_ITRACE,
                  "0 _OUT PostAckToClient returns %x\n",
                  fResult));

    return fResult;
}

//+---------------------------------------------------------------------------
//
//  Function:   DocHandleIncomingCall
//
//  Synopsis:   Setup and call the CallControl to dispatch a call to the doc
//
//  Effects:    A call has been made from the client that requires us to call
//              into our server. This must be routed through the call control.
//              This routine sets up the appropriate data structures, and
//              calls into the CallControl. The CallControl will in turn
//              call DocDispatchIncomingCall to actually process the call.
//
//              This routine should only be called by the DocWndProc
//
//
//  Arguments:  [pDocData] -- Points to DOCDISPATCHDATA for this call
//                            This contains all required information for
//                            handling the message.
//
//  Requires:
//
//  Returns:    If an error is returned, it is assumed that the Dispatch
//              routine was not reached. DocDispatchIncomingCall() should
//              not be returning an error.
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    6-05-94   kevinro Commented/cleaned
//
//  Notes:
//
//  This is a co-routine with DocDispatchIncomingCall. See that routine
//  for more details
//
//----------------------------------------------------------------------------
INTERNAL DocHandleIncomingCall(PDOCDISPATCHDATA pDocData)
{
    HRESULT hresult = NOERROR;
    DISPATCHDATA dispatchdata;
    DWORD callcat;

    intrAssert(pDocData != NULL);

    intrDebugOut((DEB_ITRACE,
                  "0 _IN DocHandleIncomingCall lpclient=%x pDocData=%x\n",
                  pDocData->lpclient,
                  pDocData));

    //
    // TERMINATE messages must always be handled ASYNC, and cannot
    // be rejected.
    //
    if (pDocData->msg == WM_DDE_TERMINATE)
    {
        callcat = CALLCAT_ASYNC;
    }
    else
    {
        callcat = CALLCAT_SYNCHRONOUS;
    }

    dispatchdata.pData = (LPVOID) pDocData;
    pDocData->wDispFunc = DDE_DISP_DOCWNDPROC;

    RPCOLEMESSAGE        rpcMsg = {0};
    RPC_SERVER_INTERFACE RpcInterfaceInfo;
    DWORD                dwFault;

    rpcMsg.iMethod = 0;
    rpcMsg.Buffer = &dispatchdata;
    rpcMsg.cbBuffer = sizeof(dispatchdata);
    rpcMsg.reserved2[1] = &RpcInterfaceInfo;
    *MSG_TO_IIDPTR(&rpcMsg) = GUID_NULL;


    IRpcStubBuffer * pStub = &(pDocData->lpclient->m_pCallMgr);
    IInternalChannelBuffer * pChannel = &(pDocData->lpclient->m_pCallMgr);
    hresult = STAInvoke(&rpcMsg, callcat, pStub, pChannel, NULL, NULL, &dwFault);

    intrDebugOut((DEB_ITRACE,
                  "0 _OUT DocHandleIncomingCall hresult=%x\n",
                  hresult));

    return(hresult);
}

//+---------------------------------------------------------------------------
//
//  Function:   DocDispatchIncomingCall
//
//  Synopsis:   Dispatch a call into the client.
//
//  Effects:    This is a co-routine to DocHandleIncomingCall. This routine
//              is called to implement functions that call into the CDefClient
//              object. It is dispatched by the call control stuff, and helps
//              to insure the server is ready to accept these calls.
//
//              This routine is coded as a continuation of the DocWndProc.
//              There is a switch on the message. Each message does slightly
//              different things. The code to handle each message was snatched
//              from the original DocWndProc, before it was converted to the
//              new call control mechanism.
//
//
//  Arguments:  [pDocData] --   Points to Doc Dispatch Data, which are the
//                              parameters to DocWndProc which need processing
//
//  Requires:
//              pDocData cannot be NULL
//
//  Returns:
//              This routine will always return NOERROR. There are no useful
//              error returns to be made from here. If you decide to return
//              an error, check the DocHandleIncomingCall and DocWndProc to be
//              sure the error paths are correctly handled. Some of the
//              cases do additional error processing in the DocWndProc on
//              error.
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    6-05-94   kevinro Commented/cleaned
//
//  Notes:
//
//----------------------------------------------------------------------------
INTERNAL DocDispatchIncomingCall(PDOCDISPATCHDATA pDocData)
{
    LPCLIENT            lpclient = pDocData->lpclient;
    BOOL                fack;
    HANDLE              hdata =  pDocData->hdata;
    ATOM                aItem =  pDocData->aItem;
    WPARAM              wParam = pDocData->wParam;
    HWND                hwnd =   pDocData->hwnd;
    HRESULT             retval;



    intrDebugOut((DEB_ITRACE,
                  "0 _IN DocDispatchIncomingCall pDocData(%x)\n",
                  pDocData));

    intrAssert(pDocData);

    //
    // This switch statement is intended to continue the functionality found
    // in the DocWndProc. These routines are directly interrelated to the
    // same cases in DocWndProc, and need special care before changing.
    //
    switch (pDocData->msg)
    {
    case WM_DDE_TERMINATE:
        {
            intrDebugOut((DEB_ITRACE,
                          "DDIC: WM_DDE_TERMINATE hwnd=%x \n",
                          pDocData->hwnd));

            //
            // Here is a fine hack for you. 32-bit applications appear to shut
            // down slightly differently than 16-bit applications. There is a
            // problem with Lotus Notes interacting with 32-bit OFFICE apps.
            // When notes has done an OleCreateFromFile, it starts the
            // 32-bit hidden, and does a normal DDE conversation. However,
            // on termination, the 32-bit Doc Window was going away during
            // this routine. Since the world is now multi-tasking, Lotus
            // Notes was seeing its server window die because we get
            // pre-empted during DeleteItemsFromList giving the 16-bit app a
            // chance to run. Since Lotus is in the
            // standard OleQueryReleaseStatus() loop, it will detect that the
            // server has shutdown BEFORE it gets the terminate message.
            // Go figure. So, insure that we post the reply DDE_TERMINATE
            // before destroying our window, or the 16-bit applications
            // won't like us.
            //
            PostMessageToClient ((HWND)wParam, WM_DDE_TERMINATE,
                            (WPARAM) hwnd, NULL);

            // Client initiated the termination. So, we should remove
            // his window from any of our doc or items' lists.
            lpclient->DeleteFromItemsList ((HWND)wParam
                                            /*, lpclient->m_fEmbed*/);

            ChkC (lpclient);


            // REVIEW: If the termination is sent from the client side,
            // lpoleObj will not be NULL.
            if (lpclient->m_cClients == 0 && lpclient->m_fEmbed)
            {
                Assert (lpclient->m_chk==chkDefClient);
                lpclient->ReleaseAllItems ();
                Assert (lpclient->m_chk==chkDefClient);
                Assert (NULL==lpclient->m_lpoleObj &&
                        NULL==lpclient->m_lpdataObj) ;

            }
            break;
        }

    case WM_DDE_EXECUTE:
        {

            intrDebugOut((DEB_ITRACE,
                          "DDIC: WM_DDE_EXECUTE hwnd=%x hdata=%x\n",
                          pDocData->hwnd,
                          pDocData->hdata));

            //
            // The following state variables appear to be used by
            // the execute code.
            //
            lpclient->m_ExecuteAck.f        = TRUE;  // assume we will need to
            lpclient->m_ExecuteAck.hdata    = hdata;
            lpclient->m_ExecuteAck.hwndFrom = (HWND)wParam;
            lpclient->m_ExecuteAck.hwndTo   = hwnd;

            //
            // In the event that the command is a StdClose, we need
            // to force the client to stay around for the duration of
            // the call.
            //
            lpclient->m_pUnkOuter->AddRef();

            retval = lpclient->DocExecute (hdata);

            if (lpclient->m_ExecuteAck.f)
            {
                lpclient->SendExecuteAck (retval);
            }

            lpclient->m_pUnkOuter->Release();
            break;

        }
    case WM_DDE_POKE:
        {
            int iStdItem;
            intrDebugOut((DEB_ITRACE,
                          "DDIC: WM_DDE_POKE hwnd=%x aItem=%x(%ws) hdata=%x\n",
                          hwnd,
                          aItem,
                          wAtomName(aItem),
                          hdata));

            if (iStdItem = GetStdItemIndex (aItem))
            {
                retval = lpclient->PokeStdItems ((HWND)wParam,
                                                 aItem,
                                                 hdata,
                                                 iStdItem);
            }
            else
            {
                retval = lpclient->PokeData ((HWND)wParam,
                                             aItem,
                                             hdata);
                    // This is allowed to fail.  PowerPoint tries to poke
                    // data with cfFormat=="StdSave" and "StdFont"
            }

            if (!PostAckToClient((HWND)wParam,hwnd,aItem,retval))
            {
                goto errRtn;
            }
            break;
        }
    case WM_DDE_ADVISE:
        {
            intrDebugOut((DEB_ITRACE,
                          "DDIC: WM_DDE_ADVISE hwnd=%x aItem=%x(%ws) hdata=%x\n",
                          hwnd,
                          aItem,
                          wAtomName(aItem),
                          hdata));

            if (IsAdviseStdItems (aItem))
            {
                retval = lpclient->AdviseStdItems ((HWND)wParam,
                                                   aItem,
                                                   hdata,
                                                   (BOOL FAR *)&fack);
            }
            else
            {
                retval = lpclient->AdviseData ((HWND)wParam,
                                               aItem,
                                               hdata,
                                               (BOOL FAR *)&fack);
            }

            if (fack)
            {
                if (!PostAckToClient((HWND)wParam,hwnd,aItem,retval))
                {
                    GlobalFree(hdata);
                }
            }
            else if (aItem != NULL)
            {
                GlobalDeleteAtom (aItem);
            }
            break;
        }
    case WM_DDE_UNADVISE:
        {
            intrDebugOut((DEB_ITRACE,
                          "DDIC: WM_DDE_UNADVISE hwnd=%x aItem=%x(%ws)\n",
                          hwnd,
                          aItem,
                          wAtomName(aItem)));

            retval = lpclient->UnAdviseData ((HWND)wParam, aItem);

            if (!PostAckToClient((HWND)wParam,hwnd,aItem,retval))
            {
                goto errRtn;
            }
            break;
        }
    case WM_DDE_REQUEST:
        {
            intrDebugOut((DEB_ITRACE,
                          "DDIC: WM_DDE_REQUEST hwnd=%x aItem=%x(%ws) cfFormat=%x\n",
                          hwnd,
                          aItem,
                          wAtomName(aItem),
                          (USHORT)LOWORD(pDocData->lParam)));

            retval = lpclient->RequestData ((HWND)wParam,
                                            aItem,
                                            LOWORD(pDocData->lParam),
                                            (HANDLE FAR *)&hdata);

            if (retval == NOERROR)
            {
                // post the data message and we are not asking for any
                // acknowledge.

                intrDebugOut((DEB_ITRACE,
                              "DDIC: posting WM_DDE_DATA\n"));

                LPARAM lp = MAKE_DDE_LPARAM(WM_DDE_DATA,hdata,aItem);
                if (!PostMessageToClient ((HWND)wParam, WM_DDE_DATA, (WPARAM) hwnd,lp))
                {
                    // hdata will be freed by the client because fRelease
                    // was set to true by MakeDdeData (called by RequestData)

                    DDEFREE(WM_DDE_DATA,lp);
                    goto errRtn;
                }
            }
            else
            {
                if (!PostAckToClient((HWND)wParam,hwnd,aItem,retval))
                {
                    goto errRtn;
                }
            }
            break;
        }
    default:
        //
        // Whoops, this is very bad. We should never get here.
        //
        intrAssert(!"Unknown MSG in DocWndProc: Very Bad indeed");


    }

exitRtn:
    intrDebugOut((DEB_ITRACE,
                  "0 _OUT DocDispatchIncomingCall pDocData(%x) hr = 0\n",
                  pDocData));

    return(NOERROR);
errRtn:
    intrDebugOut((DEB_IERROR,
                  "***** ERROR DDIC pDocData(%x) Post ACK failed. \n",
                  pDocData));

    if (aItem != NULL)
    {
        GlobalDeleteAtom (aItem);
    }
    goto exitRtn;
}


//+---------------------------------------------------------------------------
//
//  Function:   DocWndProc
//
//  Synopsis:   Document Window Procedure
//
//  Effects:    Processes DDE messages for a document window.
//
//  Arguments:  [hwnd] --
//              [msg] --
//              [wParam] --
//              [lParam] --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    6-05-94   kevinro Commented/cleaned
//
//  Notes:
//
//  When running in a VDM, it is possible that this window was dispatched
//  without having a full window handle. This happens when the getmessage
//  was dispatched from 16-bit. Therefore, we need to convert the hwnd to
//  a full hwnd before doing any comparision functions.
//
//----------------------------------------------------------------------------
STDAPI_(LRESULT) DocWndProc (
HWND        hwndIn,
UINT        msg,
WPARAM      wParam,
LPARAM      lParam
)
{

    //
    // Since this is the DocWndProc, we aren't going to initialize
    // any of the local variables. This function is called as a WNDPROC,
    // which is pretty often.
    //

    DOCDISPATCHDATA     docData;
    LPCLIENT            lpclient;
    WORD                status=0;
    HANDLE              hdata;
    ATOM                aItem;
    HRESULT             retval;
    LPOLEOBJECT         lpoleObj;
    HWND                hwnd;
    DebugOnly (HWND     hwndClient;)

    // REVIEW: We need to take care of the bug, related to
    // Excel. Excel does the sys level connection and sends
    // terminates immediately before making the connection
    // to the doc level. If we send release to classfactory
    // app may revoke the classfactory.


    // REVIEW: It may not be necessary to do the blocking.
    // ReVIEW: For fixing the ref count right way for
    // CreateInstance Vs. WM_DDE_INIT

#ifdef  LATER
    if (AddMessage (hwnd, msg, wParam, lParam, WT_DOC))
        return 0L;
#endif

    switch (msg){

    case WM_CREATE:
        intrDebugOut((DEB_ITRACE,
                      "DocWndProc: CreateWindow hwndIn=%x\n",
                      hwndIn));
            break;


    case WM_DDE_INITIATE:
        hwnd = ConvertToFullHWND(hwndIn);
        intrAssert(IsWindowValid(hwnd));
        lpclient = (LPCLIENT)GetWindowLongPtr (hwnd, 0);

        intrDebugOut((DEB_ITRACE,
                      "DocWndProc: WM_DDE_INITIATE hwnd=%x\n",
                      hwnd));

        ChkC(lpclient);


        // REVIEW: We may not allow  initiates to get thru
        // while we are waiting for terminates. So, this case
        // may not arise

        // Need to verify that m_pCI is not NULL during incoming
        // calls from the client.
        //
        if (lpclient->m_fCallData)
        {
            intrDebugOut((DEB_ITRACE,
                "DocWndProc: No initiates while waiting on terminate\n"));

                break;
        }
        // if we are the document then respond.

        if (! (lpclient->m_aItem == (ATOM)(HIWORD(lParam))))
        {
                break;
        }

        // We can enterain this client. Put this window in the client list
        // and acknowledge the initiate.

        if (!AddClient ((LPHANDLE)&lpclient->m_hcli, (HWND)wParam, (HWND)wParam))
        {
                break;
        }


        // post the acknowledge
        DuplicateAtom (LOWORD(lParam));
        DuplicateAtom (HIWORD(lParam));
        SSSendMessage ((HWND)wParam, WM_DDE_ACK, (WPARAM)hwnd, lParam);

        lpclient->m_cClients++;
        lpclient->m_fCreatedNotConnected = FALSE;
        lpoleObj = lpclient->m_lpoleObj;

        // we have added an addref because of createinstance.

        if (lpclient->m_bCreateInst)
        {
            lpclient->m_bCreateInst = FALSE;
        }

        return 1L; // fAckSent
        break;


    case WM_DDE_EXECUTE:
       {
            hwnd = ConvertToFullHWND(hwndIn);
            intrAssert(IsWindowValid(hwnd));
            lpclient = (LPCLIENT)GetWindowLongPtr (hwnd, 0);

            hdata = GET_WM_DDE_EXECUTE_HDATA(wParam,lParam);
            intrDebugOut((DEB_ITRACE,
                          "DocWndProc: WM_DDE_EXECUTE hwnd=%x hdata=%x\n",
                          hwnd,
                          hdata));

            ChkC(lpclient);

#ifdef  FIREWALLS
            // find the client in the client list.
            hwndClient = FindClient (lpclient->m_hcli, (HWND)wParam, FALSE);
            AssertSz (hwndClient, "Client is missing from the server");
#endif
            if (!IsWindowValid  ((HWND)wParam) || lpclient->m_fCallData)
            {
                if (lpclient->m_fCallData)
                {
                    // This means the terminate has already been sent
                    // to this window (from AdviseSink::OnClose) so
                    // we can ignore the StdCloseDocument.
                }
                else
                {
                    intrAssert(!"Execute received from dead sending window");
                }
                // Since we are not sending an ACK, the sender will not
                // have the chance to free the hCommands handle.
                DDEFREE(WM_DDE_ACK,lParam);
                // GlobalFree (hdata);
                break;
            }

            //
            // Fill in the used items in DocData
            //
            docData.hwnd = hwnd;
            docData.msg = msg;
            docData.wParam = wParam;
            docData.hdata = hdata;
            docData.lpclient = lpclient;

            retval = DocHandleIncomingCall(&docData);

            //
            // If error return, then we didn't call DocDispatchIncomingCall
            // and therefore need to send a NACK
            //
            if (retval != NOERROR)
            {
                lpclient->SendExecuteAck (retval);
            }
            break;
       }
       case WM_DDE_TERMINATE:
            hwnd = ConvertToFullHWND(hwndIn);
            intrAssert(IsWindowValid(hwnd));
            lpclient = (LPCLIENT)GetWindowLongPtr (hwnd, 0);

            intrDebugOut((DEB_ITRACE,
                          "DocWndProc: WM_DDE_TERMINATE hwnd=%x\n",
                          hwnd));

            ChkC(lpclient);

            //
            // If m_fCallData, then we are are waiting for a terminate, which
            // means we generated the original terminate message. If
            // this is so, then we are waiting for a reply to the
            // terminate. Set the AckState and break;
            //
            if (lpclient->m_fCallData)
            {
                lpclient->SetCallState(SERVERCALLEX_ISHANDLED);
                break;
            }


#ifdef _DEBUG
            // find the client in the client list.
            hwndClient = (HWND)FindClient (lpclient->m_hcli,(HWND)wParam, FALSE);
            AssertSz(hwndClient, "Client is missing from the server");
#endif
            AssertIsDoc (lpclient);
            Assert (lpclient->m_cClients > 0);
            lpclient->m_cClients--;

            // Necessary safety bracket
            lpclient->m_pUnkOuter->AddRef();

            // terminate has to be handled always
            // The DocHandleIncomingCall() routine will set the
            // calltype to be CALLTYPE_ASYNC
            // async calls are never rejected

            docData.hwnd = hwnd;
            docData.msg = msg;
            docData.wParam = wParam;
            docData.lpclient = lpclient;

            retval = DocHandleIncomingCall(&docData);

            intrAssert(retval == NOERROR);

            // Necessary safety bracket
            lpclient->m_pUnkOuter->Release();
            break;

       case WM_DESTROY:

            intrDebugOut((DEB_ITRACE,
                          "DocWndProc: WM_DESTROY\n"));
            break;

       case WM_DDE_POKE:
            {
                hwnd = ConvertToFullHWND(hwndIn);
                intrAssert(IsWindowValid(hwnd));
                lpclient = (LPCLIENT)GetWindowLongPtr (hwnd, 0);
                hdata = GET_WM_DDE_POKE_HDATA(wParam,lParam);
                aItem = GET_WM_DDE_POKE_ITEM(wParam,lParam);
                ChkC(lpclient);

                if (!IsWindowValid  ((HWND) wParam) || lpclient->m_fCallData)
                {
                    // The sending window is invalid or we have already sent a
                    // TERMINATE to it (as indicated by m_pCI != NULL).
                    // We cannot ACK the message, so we must free any
                    // handles or atoms.
                    Warn ("Ignoring message");

                    FreePokeData (hdata);
LDeleteAtom:

                if (aItem != NULL)
                {
                    GlobalDeleteAtom (aItem);
                }
                break;
            }

            docData.hwnd = hwnd;
            docData.msg = msg;
            docData.wParam = wParam;
            docData.hdata = hdata;
            docData.aItem = aItem;
            docData.lpclient = lpclient;

            retval = DocHandleIncomingCall(&docData);
            if (retval != NOERROR)
            {
                SET_MSG_STATUS (retval, status);

                // !!! If the fRelease is false and the post fails
                // then we are not freeing the hdata. Are we supposed to

                // REVIEW: The assumption is
                LPARAM lp = MAKE_DDE_LPARAM(WM_DDE_ACK,status,aItem);
                if (!PostMessageToClient ((HWND)wParam, WM_DDE_ACK, (WPARAM) hwnd,lp))
                {
                    DDEFREE(WM_DDE_ACK,lp);
                    goto LDeleteAtom;
                }
            }
                        // johannp: set the busy bit here in the status word
            break;
       }


    case WM_DDE_ADVISE:
        {
            hwnd = ConvertToFullHWND(hwndIn);
            intrAssert(IsWindowValid(hwnd));
            lpclient = (LPCLIENT)GetWindowLongPtr (hwnd, 0);
            HANDLE hOptions = GET_WM_DDE_ADVISE_HOPTIONS(wParam,lParam);
            aItem = GET_WM_DDE_ADVISE_ITEM(wParam,lParam);

            ChkC(lpclient);
            if (!IsWindowValid  ((HWND)wParam) || lpclient->m_fCallData)
            {
AdviseErr:
                Warn ("Ignoring advise message");
                //
                // GlobalFree wants a handle, we are giving it a DWORD.
                //
                if(hOptions) GlobalFree (hOptions);
                break;
            }
            docData.hwnd = hwnd;
            docData.msg = msg;
            docData.wParam = wParam;
            docData.hdata = hOptions;
            docData.aItem = aItem;
            docData.lpclient = lpclient;

            retval = DocHandleIncomingCall(&docData);

            if (retval != NOERROR)
            {
                SET_MSG_STATUS (retval, status);

                LPARAM lp = MAKE_DDE_LPARAM(WM_DDE_ACK,status,aItem);

                if (!PostMessageToClient ((HWND)wParam, WM_DDE_ACK, (WPARAM) hwnd,lp))
                {
                    DDEFREE(WM_DDE_ACK,lp);
                    goto AdviseErr;
                }
            }
            break;
        }
    case WM_DDE_UNADVISE:
     {
        hwnd = ConvertToFullHWND(hwndIn);
        intrAssert(IsWindowValid(hwnd));
        lpclient = (LPCLIENT)GetWindowLongPtr (hwnd, 0);

        aItem = HIWORD(lParam);
        ChkC(lpclient);
        if (!IsWindowValid  ((HWND)wParam) || lpclient->m_fCallData)
        {
                goto LDeleteAtom;
        }
        docData.hwnd = hwnd;
        docData.msg = msg;
        docData.wParam = wParam;
        docData.aItem = aItem;
        docData.lpclient = lpclient;

        retval = DocHandleIncomingCall(&docData);

        if (retval != NOERROR)
        {
            SET_MSG_STATUS (retval, status);
            LPARAM lp = MAKE_DDE_LPARAM(WM_DDE_ACK,status,aItem);

            if (!PostMessageToClient ((HWND)wParam, WM_DDE_ACK, (WPARAM) hwnd,lp))
            {
                DDEFREE(WM_DDE_ACK,lp);
                goto LDeleteAtom;
            }
        }

        break;
     }
    case WM_DDE_REQUEST:
     {
        hwnd = ConvertToFullHWND(hwndIn);
        intrAssert(IsWindowValid(hwnd));
        lpclient = (LPCLIENT)GetWindowLongPtr (hwnd, 0);

        aItem = HIWORD(lParam);

        ChkC(lpclient);
        if (!IsWindowValid  ((HWND) wParam) || lpclient->m_fCallData)
        {
                goto LDeleteAtom;
        }
        docData.hwnd = hwnd;
        docData.msg = msg;
        docData.wParam = wParam;
        docData.lParam = lParam;
        docData.aItem = aItem;
        docData.lpclient = lpclient;

        retval = DocHandleIncomingCall(&docData);
        if (retval != NOERROR)
        {
            if (retval == RPC_E_DDE_BUSY)
            {
                    status = 0x4000;
            }
            else
            {
                    status = 0; // negative acknowledge
            }

            LPARAM lp = MAKE_DDE_LPARAM(WM_DDE_ACK,status,aItem);
            // if request failed, then acknowledge with error.
            if (!PostMessageToClient ((HWND)wParam, WM_DDE_ACK, (WPARAM) hwnd,lp))
            {
                DDEFREE(WM_DDE_ACK,lp);
                goto LDeleteAtom;
            }
        }
        break;
     }
    default:
            return SSDefWindowProc (hwndIn, msg, wParam, lParam);

    }

    return 0L;

}




INTERNAL_(void) CDefClient::SendExecuteAck
    (HRESULT hresult)
{
    AssertIsDoc (this);
    WORD  status = NULL;
    SET_MSG_STATUS (hresult, status);

    m_ExecuteAck.f = FALSE;

    LPARAM lParam = MAKE_DDE_LPARAM (WM_DDE_ACK,status,
                                     m_ExecuteAck.hdata);
    // Post the acknowledge to the client
    if (!PostMessageToClient (m_ExecuteAck.hwndFrom, WM_DDE_ACK,
                              (WPARAM) m_ExecuteAck.hwndTo, lParam))
    {
        Assert (0);
        // the window either died or post failed, delete the data
        DDEFREE (WM_DDE_ACK,lParam);
        GlobalFree (m_ExecuteAck.hdata);
    }
}



//DocExecute: Interprets the execute command for the
//document conversation.


INTERNAL CDefClient::DocExecute
    (HANDLE      hdata)
{

    ATOM            acmd;
    BOOL            fShow;
    BOOL            fActivate;

    HANDLE          hdup   = NULL;
    HRESULT           retval = ReportResult(0, S_OOM, 0, 0);

    LPSTR           lpitemname;
    LPSTR           lpopt;
    LPSTR           lpnextarg;
    LPSTR           lpdata = NULL;
    LPSTR           lpverb = NULL;
    INT         verb;
    WORD            wCmdType;

    ChkC(this);

    intrDebugOut((DEB_ITRACE,
                  "%p _IN CDefClient::DocExecute(hdata=%x)\n",
                  this,
                  hdata));

    // !!!Can we modify the string which has been passed to us
    // rather than duplicating the data. This will get some speed
    // and save some space.

    if(!(hdup = UtDupGlobal(hdata,GMEM_MOVEABLE)))
        goto    errRtn;

    if (!(lpdata  = (LPSTR)GlobalLock (hdup)))
        goto    errRtn;

    retval = ReportResult(0, RPC_E_DDE_SYNTAX_EXECUTE, 0, 0);

    intrDebugOut((DEB_ITRACE,
                  "%p _IN CDefClient::DocExecute command=(%s)\n",
                  this,
                  lpdata));

    if(*lpdata++ != '[') // commands start with the left sqaure bracket
        goto  errRtn;

    // scan the command and scan upto the first arg.
    if (!(wCmdType = ScanCommand(lpdata, WT_DOC, &lpnextarg, &acmd)))
        goto errRtn;

    if (wCmdType == NON_OLE_COMMAND) {

#ifdef  LATER
        if (lpsrvr =  (LPSRVR) GetWindowLongPtr (GetParent (hwnd), 0)) {
            if (!UtilQueryProtocol (lpsrvr->aClass, PROTOCOL_EXECUTE))
                retval = OLE_ERROR_PROTOCOL;
            else {
#ifdef FIREWALLS
                if (!CheckPointer (lpoledoc, WRITE_ACCESS))
                    AssertSz (0, "Invalid LPOLESERVERDOC");
                else if (!CheckPointer (lpoledoc->lpvtbl, WRITE_ACCESS))
                    AssertSz (0, "Invalid LPOLESERVERDOCVTBL");
                else
                    AssertSz (lpoledoc->lpvtbl->Execute,
                        "Invalid pointer to Execute method");
#endif

                retval = (*lpoledoc->lpvtbl->Execute) (lpoledoc, hdata);
            }

        }
#endif
        AssertSz(0, "Doc level execute is being called");

        goto errRtn;
    }


    //////////////////////////////////////////////////////////////////////////
    //
    // [StdCloseDocument]
    //
    //////////////////////////////////////////////////////////////////////////
    if (acmd == aStdClose){

        LPCLIENT lpclient=NULL;
        // if not terminated by NULL error
        if (*lpnextarg)
            goto errRtn;

        if ((retval = FindItem (NULL, (LPCLIENT FAR *)&lpclient)) != NOERROR)
        {
            goto errRtn;
        }


        lpclient->m_fGotStdCloseDoc = TRUE;
        retval = lpclient->m_lpoleObj->Close (OLECLOSE_SAVEIFDIRTY);
        goto end;
    }

    //////////////////////////////////////////////////////////////////////////
    //
    // [StdDoVerbItem("itemname", verb, BOOL, BOOL]
    //
    //////////////////////////////////////////////////////////////////////////
    if (acmd == aStdDoVerbItem){
        lpitemname = lpnextarg;

        if(!(lpverb = ScanArg(lpnextarg)))
            goto errRtn;


    if(!(lpnextarg = ScanNumArg(lpverb, &verb)))
            goto errRtn;

#ifdef  FIREWALLS
        AssertSz (verb < 9 , "Unexpected verb number");
#endif

        // now scan the show BOOL

        if (!(lpnextarg = ScanBoolArg (lpnextarg, (BOOL FAR *)&fShow)))
            goto errRtn;

        fActivate = FALSE;

        // if activate BOOL is present, scan it.

        if (*lpnextarg) {
            if (!(lpnextarg = ScanBoolArg (lpnextarg, (BOOL FAR *)&fActivate)))
                goto errRtn;
        }

        if (*lpnextarg)
            goto errRtn;

        if (m_fEmbed)
        {
            // This is a totally bogus call to SetHostNames whose only
            // purpose is to notify the server that this is an embedded
            // (not linked) object.
            if (!m_fDidRealSetHostNames)
            {
                Puts ("Bogus call to SetHostNames before DoVerb\r\n");
                m_lpoleObj->SetHostNames (OLESTR("Container"), OLESTR("Object"));
            }
        }
        // REVIEW: We are assuming that calling the Docdoverb method
        // will not post any more DDE messahes.

        retval = DocDoVerbItem (lpitemname, (WORD) verb, fShow, !fActivate);
        goto end;
    }





    //////////////////////////////////////////////////////////////////////////
    //
    // [StdShowItem("itemname"[, "true"])]
    //
    //////////////////////////////////////////////////////////////////////////
    if (acmd != aStdShowItem)
        goto errRtn;

    lpitemname = lpnextarg;

    if(!(lpopt = ScanArg(lpitemname)))
        goto errRtn;

    // Now scan for optional parameter.

    fActivate = FALSE;

    if (*lpopt) {

        if(!(lpnextarg = ScanBoolArg (lpopt, (BOOL FAR *)&fActivate)))
            goto errRtn;

        if (*lpnextarg)
            goto errRtn;


    }

    if (m_fEmbed)
    {
        // This is a totally bogus call to SetHostNames whose only
        // purpose is to notify the server that this is an embedded
        // (not linked) object.
        // REVIEW LINK
        if (!m_fDidRealSetHostNames)
        {
            Puts ("Bogus call to SetHostNames before ShowItem\r\n");
            m_lpoleObj->SetHostNames (OLESTR("Container"), OLESTR("Object"));
        }
    }

    retval = DocShowItem (lpitemname, !fActivate);

end:
errRtn:
   if (lpdata)
        GlobalUnlock (hdup);

   if (hdup)
        GlobalFree (hdup);

    intrDebugOut((DEB_ITRACE,
                  "%p _OUT CDefClient::DocExecute(hdata=%x) hresult=%x\n",
                  this,
                  hdata,
                  retval));

   return (HRESULT)retval;
}



INTERNAL_(HRESULT)   CDefClient::DocShowItem
(
LPSTR       lpAnsiitemname,
BOOL        fAct
)
{
    LPCLIENT        lpclient;
    HRESULT             retval;
    LPOLEOBJECT lpoleObj;

    ChkC(this);
    WCHAR       lpitemname[MAX_STR];

    if (MultiByteToWideChar(CP_ACP,0,lpAnsiitemname,-1,lpitemname,MAX_STR) == FALSE)
    {
        Assert(!"Unable to convert characters");
        return(E_UNEXPECTED);
    }

    if ((retval = FindItem (lpitemname, (LPCLIENT FAR *)&lpclient))
           != NOERROR)
       return retval;

    ChkC(lpclient);

    lpoleObj = lpclient->m_lpoleObj;


#ifdef FIREWALLS1
        if (!CheckPointer (lpoleObj->lpvtbl, WRITE_ACCESS))
            AssertSz (0, "Invalid LPOLEOBJECTVTBL");
        else
            AssertSz (lpoleObj->lpvtbl->DoVerb,
                "Invalid pointer to DoVerb method");
#endif

    // protocol sends false for activating and TRUE for not activating.
    // for api send TRUE for avtivating and FALSE for not activating.
    return lpclient->m_lpoleObj->DoVerb(OLEVERB_SHOW, NULL, NULL, NULL, NULL, NULL);
}



INTERNAL_(HRESULT)   CDefClient::DocDoVerbItem
(
LPSTR       lpAnsiitemname,
WORD        verb,
BOOL        fShow,
BOOL        fAct
)
{
    LPCLIENT    lpclient;
    HRESULT     retval;

    WCHAR       lpitemname[MAX_STR];

    if (MultiByteToWideChar(CP_ACP,0,lpAnsiitemname,-1,lpitemname,MAX_STR) == FALSE)
    {
        Assert(!"Unable to convert characters");
        return(E_UNEXPECTED);
    }

    ChkC(this);
    Puts ("DefClient::DocDoVerbItem\r\n");
    if ((retval = FindItem (lpitemname, (LPCLIENT FAR *)&lpclient))
           != NOERROR)
       return retval;
    ChkC(lpclient);

#ifdef FIREWALLS1
        if (!CheckPointer (lpclient->lpoleObj->lpvtbl, WRITE_ACCESS))
            AssertSz (0, "Invalid LPOLEOBJECTVTBL");
        else
            AssertSz (lpclient->lpoleObj->lpvtbl->DoVerb,
                "Invalid pointer to DoVerb method");
#endif

    // pass TRUE to activate and False not to activate. Differnt from
    // protocol.

    retval = lpclient->m_lpoleObj->DoVerb(verb, NULL, &m_OleClientSite, NULL, NULL, NULL);
    // Apparently an obsolete version of Lotus Notes is the only
    // container (other than Cltest) that sets fShow=FALSE
    if (!fShow && lpclient->m_lpoleObj && lpclient->m_fEmbed)
        lpclient->m_lpoleObj->DoVerb(OLEIVERB_HIDE, NULL, &m_OleClientSite, NULL, NULL, NULL);
    return retval;
}

INTERNAL CDefClient::DoInitNew()
{
        HRESULT hresult;
        ATOM aClass;
        LPPERSISTSTORAGE pPersistStg=NULL;

        hresult = m_lpoleObj->QueryInterface(IID_IPersistStorage,
                                                                (LPLPVOID)&pPersistStg);
        if (hresult == NOERROR)
        {
                CLSID clsid;
                RetZ (pPersistStg);
                ErrRtnH (CreateILockBytesOnHGlobal ((HGLOBAL)NULL,
                                                           /*fDeleteOnRelease*/ TRUE,
                                                           &m_plkbytNative));
            ErrZS (m_plkbytNative, E_OUTOFMEMORY);

        ErrRtnH (StgCreateDocfileOnILockBytes
                                                (m_plkbytNative,
                                                 grfCreateStg, 0,
                                                 &m_pstgNative));

            ErrZS (m_pstgNative, E_OUTOFMEMORY);

                aClass = m_psrvrParent->m_cnvtyp == cnvtypTreatAs ? m_psrvrParent->m_aOriginalClass
                                                                : m_psrvrParent->m_aClass;
                // Write appropriate class tag
                ErrZS (CLSIDFromAtom (aClass,(LPCLSID)&clsid),
                                       REGDB_E_CLASSNOTREG);
                ErrRtnH (WriteClassStg (m_pstgNative, clsid));

                // Provide server with a storage to use for its persistent
                // storage, i.e., native data.  We remember this IStorage and the
                // ILockBytes it is built on.
        ErrRtnH (pPersistStg->InitNew(m_pstgNative));
                m_fGotEditNoPokeNativeYet = FALSE;

                // Now that we have initialized the object, we are allowed to
                // set the client site, and advise.
                ErrRtnH (SetClientSite());

                // This is for Packager, in particular.  If client does not advise
                // on any data, we still need to do an OLE advise so we can get
                // OnClose notifications.
                DoOle20Advise (OLE_CLOSED, (CLIPFORMAT)0);
        }
        else
        {
                AssertSz (0, "Can't get IPersistStorage from OleObj\r\n");
        }

        m_fEmbed = TRUE;

errRtn:
   if (pPersistStg)
                pPersistStg->Release();
        return hresult;
}


// FreePokeData: Frees the poked dats.
INTERNAL_(void) FreePokeData
(
HANDLE  hdde
)
{
    DDEPOKE FAR * lpdde;
    Puts ("FreePokeData\r\n");

    if (hdde) {
        if (lpdde = (DDEPOKE FAR *) GlobalLock (hdde)) {
            GlobalUnlock (hdde);
#ifdef _WIN64
            if (lpdde->cfFormat == CF_METAFILEPICT)
            	FreeGDIdata(*(void* _unaligned*)lpdde->Value, lpdde->cfFormat);
            else
#endif            	
                FreeGDIdata (LongToHandle(*(LONG*)lpdde->Value), lpdde->cfFormat);
        }

        GlobalFree (hdde);
    }
}



// Returns TRUE if GDI format else returns FALSE

INTERNAL_(BOOL) FreeGDIdata
(
HANDLE          hData,
CLIPFORMAT      cfFormat
)
{
    Puts ("FreeGDIData\r\n");
    if (cfFormat == CF_METAFILEPICT) {
        LPMETAFILEPICT  lpMfp;

        if (lpMfp = (LPMETAFILEPICT) GlobalLock (hData)) {
            GlobalUnlock (hData);
            DeleteMetaFile (lpMfp->hMF);
        }

        GlobalFree (hData);
    }
    else if (cfFormat == CF_BITMAP)
        DeleteObject (hData);
    else if (cfFormat == CF_DIB)
        GlobalFree (hData);
    else
        return FALSE;

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\com\dde\server\ddeutils.cxx ===
/****************************** Module Header ******************************\
* Module Name: ddeutils.c
*
* Purpose: Conatains all the utility routines
*
* Created: 1990
*
* Copyright (c) 1990, 1991  Microsoft Corporation
*
* History:
*   Raor, Srinik (../../1990)    Designed and coded
*
\***************************************************************************/
#include "ole2int.h"
#include <dde.h>
#include "srvr.h"
#include "ddesrvr.h"
#include "ddedebug.h"
#include "strsafe.h"
ASSERTDATA


#define WM_NCMOUSEFIRST WM_NCMOUSEMOVE
#define WM_NCMOUSELAST WM_NCMBUTTONDBLCLK



#define KB_64   65536

extern ATOM    aTrue;
extern ATOM    aFalse;

extern ATOM    aStdCreateFromTemplate;
extern ATOM    aStdCreate;
extern ATOM    aStdOpen;
extern ATOM    aStdEdit;
extern ATOM    aStdShowItem;
extern ATOM    aStdClose;
extern ATOM    aStdExit;
extern ATOM    aStdDoVerbItem;


//ScanBoolArg: scans the argument which is not included in
//the quotes. These args could be only TRUE or FALSE for
//the time being. !!!The scanning routines should be
//merged and it should be generalized.

INTERNAL_(LPSTR)     ScanBoolArg
(
LPSTR   lpstr,
BOOL    FAR *lpflag
)
{


    LPSTR   lpbool;
    ATOM    aShow;
    char    ch;

    lpbool = lpstr;

    // !!! These routines does not take care of quoted quotes.

    while((ch = *lpstr) && (!(ch == ')' || ch == ',')))
	lpstr++;

    if(ch == NULL)
       return NULL;

    *lpstr++ = NULL;       // terminate the arg by null

    // if terminated by paren, then check for end of command
    // syntax.

    // Check for the end of the command string.
    if (ch == ')') {
	if (*lpstr++ != ']')
	    return NULL;

	if(*lpstr != NULL)
	    return NULL;	     //finally should be terminated by null.

    }

    aShow = GlobalFindAtomA (lpbool);
    if (aShow == aTrue)
	*lpflag = TRUE;

    else {
	if (aShow ==aFalse)
	    *lpflag = FALSE;
	else
	    return NULL;;
    }
    return lpstr;
}


//+---------------------------------------------------------------------------
//
//  Function:   CreateUnicodeFromAnsi
//
//  Synopsis:   Creates a UNICODE string from an ANSI string
//
//  Effects:    Makes a new UNICODE string from the given ANSI string.
//		The new UNICODE string is returned. Memory is allocated
//		using PrivMemAlloc
//
//  Arguments:  [lpAnsi] -- Ansi version of string
//
//  Requires:
//
//  Returns:	NULL if cannot create new string.
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    6-07-94   kevinro Commented/cleaned
//
//  Notes:
//
//----------------------------------------------------------------------------
LPOLESTR CreateUnicodeFromAnsi( LPCSTR lpAnsi)
{
    WCHAR buf[MAX_PATH];
    ULONG ccbuf;
    LPOLESTR lpWideStr;

    if ((ccbuf=MultiByteToWideChar(CP_ACP,0,lpAnsi,-1,buf,MAX_PATH))
	 == FALSE)
    {
	intrAssert(!"Unable to convert characters");
	return NULL;
    }

    lpWideStr = (LPOLESTR) PrivMemAlloc(ccbuf * sizeof(WCHAR));

    if (lpWideStr != NULL)
    {
	memcpy(lpWideStr,buf,ccbuf*sizeof(WCHAR));
    }
    return(lpWideStr);
}
//+---------------------------------------------------------------------------
//
//  Function:   CreateAnsiFromUnicode
//
//  Synopsis:   Creates an Ansi string from a UNICODE string
//
//  Effects:    Makes a new ANSI string from the given UNICODE string.
//		The new string is returned. Memory is allocated
//		using PrivMemAlloc
//
//  Arguments:  [lpUnicode] -- Unicode version of string
//
//  Requires:
//
//  Returns:	NULL if cannot create new string.
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    6-07-94   kevinro Commented/cleaned
//
//  Notes:
//
//----------------------------------------------------------------------------
LPSTR CreateAnsiFromUnicode( LPCOLESTR lpUnicode)
{
    char buf[MAX_PATH];
    ULONG ccbuf;
    LPSTR lpAnsiStr;

    ccbuf = WideCharToMultiByte(CP_ACP,
			    	0,
				lpUnicode,
				-1,
				buf,
				MAX_PATH,
				NULL,
				NULL);


    if (ccbuf == FALSE)
    {
	intrAssert(!"Unable to convert characters");
	return NULL;
    }

    lpAnsiStr = (LPSTR) PrivMemAlloc(ccbuf * sizeof(char));

    if (lpAnsiStr != NULL)
    {
	memcpy(lpAnsiStr,buf,ccbuf);
    }
    return(lpAnsiStr);
}

//ScannumArg: Checks for the syntax of num arg in Execute and if
//the arg is syntactically correct, returns the ptr to the
//beginning of the next arg and also, returns the number
//Does not take care of the last num arg in the list.

INTERNAL_(LPSTR)       ScanNumArg
(
LPSTR   lpstr,
LPINT   lpnum
)
{

    WORD    val = 0;
    char    ch;

    while((ch = *lpstr++) && (ch != ',')) {
	if (ch < '0' || ch >'9')
	    return NULL;
	val += val * 10 + (ch - '0');

    }

    if(!ch)
       return NULL;

    *lpnum = val;
    return lpstr;
}




//ScanArg: Checks for the syntax of arg in Execute and if
//the arg is syntactically correct, returns the ptr to the
//beginning of the next arg or to the end of the excute string.

INTERNAL_(LPSTR)      ScanArg
(
LPSTR   lpstr
)
{


    // !!! These routines does not take care of quoted quotes.

    // first char should be quote.

    if (*(lpstr-1) != '\"')
	return NULL;

    while(*lpstr && *lpstr != '\"')
	lpstr++;

    if(*lpstr == NULL)
       return NULL;

    *lpstr++ = NULL;       // terminate the arg by null

    if(!(*lpstr == ',' || *lpstr == ')'))
	return NULL;


    if(*lpstr++ == ','){

	if(*lpstr == '\"')
	    return ++lpstr;
	// If it is not quote, leave the ptr on the first char
	return lpstr;
    }

    // terminated by paren
    // already skiped right paren

    // Check for the end of the command string.
    if (*lpstr++ != ']')
	return NULL;

    if(*lpstr != NULL)
	return NULL;    	 //finally should be terminated by null.

    return lpstr;
}

// ScanCommand: scanns the command string for the syntax
// correctness. If syntactically correct, returns the ptr
// to the first arg or to the end of the string.

INTERNAL_(WORD)   ScanCommand
(
LPSTR       lpstr,
WORD        wType,
LPSTR FAR * lplpnextcmd,
ATOM FAR *  lpAtom
)
{
    // !!! These routines does not take care of quoted quotes.
    // and not taking care of blanks arround the operators

    // !!! We are not allowing blanks after operators.
    // Should be allright! since this is arestricted syntax.

    char    ch;
    LPSTR   lptemp = lpstr;


    while(*lpstr && (!(*lpstr == '(' || *lpstr == ']')))
	lpstr++;

    if(*lpstr == NULL)
       return NULL;

    ch = *lpstr;
    *lpstr++ = NULL;       // set the end of command

    *lpAtom = GlobalFindAtomA (lptemp);

    if (!IsOleCommand (*lpAtom, wType))
	return NON_OLE_COMMAND;

    if (ch == '(') {
	ch = *lpstr++;

	if (ch == ')') {
	     if (*lpstr++ != ']')
		return NULL;
	}
	else {
	    if (ch != '\"')
		return NULL;
	}

	*lplpnextcmd = lpstr;
	return OLE_COMMAND;
    }

    // terminated by ']'

    if (*(*lplpnextcmd = lpstr)) // if no nul termination, then it is error.
	return NULL;

    return OLE_COMMAND;
}


//MakeDataAtom: Creates a data atom from the item string
//and the item data otions.

INTERNAL_(ATOM)  MakeDataAtom
(
ATOM    aItem,
int     options
)
{
    WCHAR    buf[MAX_STR];

    if (options == OLE_CHANGED)
	return DuplicateAtom (aItem);

    if (!aItem)
	buf[0] = NULL;
    else
	if (!GlobalGetAtomName (aItem, buf, MAX_STR))
	    return NULL;

    if (options == OLE_CLOSED)
	StringCbCat(buf, sizeof(buf), OLESTR("/Close"));
    else {
	if (options == OLE_SAVED)
	   StringCbCat(buf, sizeof(buf), OLESTR("/Save"));
	else
	    AssertSz (0, "Bad option\n");
    }

    Puts ("MakeDataAtom "); Puts(buf); Putn();
    if (buf[0])
	return wGlobalAddAtom (buf);
    else
	return NULL;
}

//DuplicateAtom: Duplicates an atom
INTERNAL_(ATOM)  DuplicateAtom
(
ATOM    atom
)
{
    WCHAR buf[MAX_STR];

    if (!atom)
	return NULL;

    if (!GlobalGetAtomName (atom, buf, MAX_STR))
        return NULL;
    else
        return wGlobalAddAtom (buf);
}

// MakeGlobal: makes global out of strings.
// works only for << 64k

INTERNAL_(HANDLE)   MakeGlobal
(
LPSTR   lpstr
)
{
    size_t  len = 0;
    HANDLE  hdata  = NULL;
    LPSTR   lpdata = NULL;

    len = strlen (lpstr) + 1;

    hdata = GlobalAlloc (GMEM_MOVEABLE | GMEM_DDESHARE, len);

    if (hdata == NULL || (lpdata = (LPSTR) GlobalLock (hdata)) == NULL)
	goto errRtn;


    memcpy(lpdata, lpstr, (DWORD)len);
    GlobalUnlock (hdata);
    return hdata;

errRtn:
    Assert (0);
    if (lpdata)
	GlobalUnlock (hdata);


    if (hdata)
	GlobalFree (hdata);

     return NULL;

}


INTERNAL_(BOOL) CLSIDFromAtom(ATOM aClass, LPCLSID lpclsid)
{
    WCHAR szProgID[MAX_STR] = {0};
    if (!ISATOM (aClass))
	return FALSE;
    WORD cb= (WORD) GlobalGetAtomName (aClass, szProgID, MAX_STR);
    Assert (cb>0 && cb < (MAX_STR - 1));

    return CLSIDFromProgID(szProgID, lpclsid) == S_OK;
}

// CLSIDFromAtomWithTreatAs
//
// Input: *paClass
// Output: *pclsid == corresponding CLSID, taking into account TreatAs and
//                     AutoConvert
//		   *paClass == atom correpsonding to *pclsid
//
#pragma SEG(CLSIDFromAtomWithTreatAs)
INTERNAL CLSIDFromAtomWithTreatAs
	(ATOM FAR* 	paClass,
	LPCLSID 	pclsid,
	CNVTYP FAR* pcnvtyp)
{
    HRESULT hr;


    intrDebugOut((DEB_ITRACE,
		  "%p _IN CLSIDFromAtomWithTreatAs(paClass=%x,"
		  "pclsid=%x,pcnvtyp=%x)\n",0,
		  paClass,pclsid,pcnvtyp));

    LPOLESTR szProgID = NULL;
    CLSID clsidNew;

    if (!CLSIDFromAtom (*paClass, pclsid))
    {
	hr = S_FALSE;
	goto exitRtn;
    }

    DEBUG_GUIDSTR(clsidStr,pclsid);

    intrDebugOut((DEB_ITRACE,"Guid %ws",clsidStr));
    if (CoGetTreatAsClass (*pclsid, &clsidNew) == NOERROR)
    {
	DEBUG_GUIDSTR(newStr,pclsid);

	intrDebugOut((DEB_ITRACE," cnvtypTreatAs %ws\n",newStr));
    	if (pcnvtyp)
    		*pcnvtyp = cnvtypTreatAs;
    }
    else if (OleGetAutoConvert (*pclsid, &clsidNew) == NOERROR)
    {
	DEBUG_GUIDSTR(newStr,pclsid);
	intrDebugOut((DEB_ITRACE," cnvtypConvertTo %ws\n",newStr));
    	if (pcnvtyp)
    		*pcnvtyp = cnvtypConvertTo;
    }
    else	
    {
	intrDebugOut((DEB_ITRACE," no conversion\n"));
    	if (pcnvtyp)
    		*pcnvtyp = cnvtypNone;
    	clsidNew = *pclsid; // no translation
    }

    hr = ProgIDFromCLSID(clsidNew, &szProgID);
    if (FAILED(hr))
    {
	intrDebugOut((DEB_ITRACE,"  ProgIDFromCLSID failed\n"));
	goto exitRtn;
    }

    intrDebugOut((DEB_ITRACE,"ProgIDFromCLSID returns %ws\n",szProgID));
    *paClass = GlobalAddAtom (szProgID);
    *pclsid  = clsidNew;
    CoTaskMemFree(szProgID);

exitRtn:
    intrDebugOut((DEB_ITRACE,
		  "%p OUT CLSIDFromAtomWithTreatAs returns %x\n",
		  0,hr));

    return hr;
}


INTERNAL_(BOOL)  PostMessageToClientWithReply
(
HWND    hWnd,
UINT    wMsg,
WPARAM  wParam,  // posting window
LPARAM  lParam,
UINT    wReplyMsg
)
{
    MSG 		msg;

    if (!IsWindowValid (hWnd))
    {
	AssertSz(FALSE, "Client's window is missing");
	return FALSE;
    }

    if (!IsWindowValid ((HWND)wParam))
    {
	AssertSz (0, "Posting window is invalid");
	return FALSE;
    }

    // Post message to client failed. Treat it as if we got the reply.
    if (!PostMessageToClient (hWnd, wMsg, wParam, lParam))
	return FALSE;

    return NOERROR == wTimedGetMessage (&msg, (HWND)wParam, WM_DDE_TERMINATE,
					WM_DDE_TERMINATE);
}



INTERNAL_(BOOL)  PostMessageToClient
(
    HWND    hWnd,
    UINT    wMsg,
    WPARAM  wParam,
    LPARAM  lParam
)
{
	UINT c=0;

	while (c < 10)
	{
	    if (!IsWindowValid (hWnd)) {
    	    Warn ("Client's window is missing");
        	return FALSE;
	    }
		Puts ("Posting"); Puth(wMsg); Puts("to"); Puth(hWnd); Putn();
    	if (PostMessage (hWnd, wMsg, wParam, lParam))
			return TRUE; // success
		else
		{
			Yield();
			c++; // try again
		}
	}
	return FALSE;
}


INTERNAL_(BOOL)     IsWindowValid
    (HWND    hwnd)
{
    HTASK   htask;

    if (!IsWindow (hwnd))
	return FALSE;

    htask  = GetWindowThreadProcessId(hwnd, NULL);

#ifndef WIN32
    if (IsTask(htask))
#endif
	return TRUE;

    return FALSE;
}



INTERNAL_(BOOL)  UtilQueryProtocol
(
ATOM    aClass,
LPOLESTR   lpprotocol
)
{
    HKEY    hKey;
    WCHAR    key[MAX_STR];
    WCHAR    cclass[MAX_STR];

    if (!aClass)
	return FALSE;

    if (!GlobalGetAtomName (aClass, cclass, MAX_STR))
	return FALSE;

    if (FAILED(StringCbCopy(key, sizeof(key), cclass)))
        return FALSE;
    if (StringCbCat(key, sizeof(key), OLESTR("\\protocol\\")))
        return FALSE;
    if (StringCbCat(key, sizeof(key), lpprotocol))
        return FALSE;
    if (StringCbCat(key, sizeof(key), OLESTR("\\server")))
        return FALSE;
    if (OpenClassesRootKey (key, &hKey) != ERROR_SUCCESS)
	return FALSE;
    RegCloseKey (hKey);
    return TRUE;
}



INTERNAL_(BOOL)  IsOleCommand
(
ATOM    aCmd,
WORD    wType
)
{
    if (wType == WT_SRVR) {
	if ((aCmd == aStdCreateFromTemplate)
		|| (aCmd == aStdCreate)
		|| (aCmd == aStdOpen)
		|| (aCmd == aStdEdit)
		|| (aCmd == aStdShowItem)
		|| (aCmd == aStdClose)
		|| (aCmd == aStdExit))
	    return TRUE;
    }
    else {
	if ((aCmd == aStdClose)
		|| (aCmd == aStdDoVerbItem)
		|| (aCmd == aStdShowItem))
	    return TRUE;
    }

    return FALSE;
}
INTERNAL wFileBind
	(LPOLESTR szFile,
	LPUNKNOWN FAR* ppUnk)
{
	HRESULT hresult = NOERROR;
	LPBC pbc = NULL;
	LPMONIKER pmk = NULL;
	*ppUnk = NULL;
	ErrRtnH (CreateBindCtx (0, &pbc));
	ErrRtnH (CreateFileMoniker (szFile, &pmk));
	ErrRtnH (pmk->BindToObject (pbc, NULL, IID_IUnknown, (LPLPVOID) ppUnk));
  errRtn:
//	AssertOutPtrIface(hresult, *ppUnk);
	if (pbc)
		pbc->Release();
	if (pmk)
		pmk->Release();
	return hresult;
}

// SynchronousPostMessage
//
// Post a message and wait for the ack.
// (jasonful)
//
INTERNAL SynchronousPostMessage
    (HWND   hWndTo,  // also who you expect the reply from
    UINT    wMsg,
    WPARAM  wParam,
    LPARAM  lParam)
{
#ifdef _MAC
#else

    HRESULT hresult = NOERROR;

    static unsigned iCounter;


    HWND hWndFrom = (HWND) wParam;



    RetZ (IsWindowValid(hWndFrom));
    RetZ (IsWindowValid(hWndTo));

    Assert (wMsg != WM_DDE_INITIATE);  // can't check for positive ack.

    RetZS (PostMessage (hWndTo, wMsg, wParam, lParam), RPC_E_SERVER_DIED);

    MSG msg;
    RetErr (wTimedGetMessage (&msg, hWndFrom, WM_DDE_ACK, WM_DDE_ACK));
    Assert (msg.message == WM_DDE_ACK);
    if (!( GET_WM_DDE_ACK_STATUS(msg.wParam,msg.lParam) & POSITIVE_ACK))
	hresult = ResultFromScode (RPC_E_DDE_NACK);
    if (msg.hwnd != hWndFrom)
	hresult = ResultFromScode (RPC_E_DDE_UNEXP_MSG);



    return hresult;
#endif _MAC
}


INTERNAL wFileIsRunning
    (LPOLESTR szFile)
{
    LPMONIKER pmk = NULL;
    LPBINDCTX pbc=NULL;
    HRESULT hresult;

    RetErr (CreateBindCtx (0, &pbc));
    ErrRtnH (CreateFileMoniker (szFile, &pmk));
    hresult = pmk->IsRunning (pbc, NULL, NULL);
  errRtn:
    if (pbc)
	pbc->Release();
    if (pmk)
	pmk->Release();
    return hresult;
}




//+---------------------------------------------------------------------------
//
//  Function:   IsFile
//
//  Synopsis:   Given a handle to an atom, determine if it is a file
//
//  Effects:    Attempts to get the files attributes. If there are no
//		attributes, then the file doesn't exist.
//
//  Arguments:  [a] -- Atom for filename
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    5-03-94   kevinro Commented/cleaned
//
//  Notes:
//
//----------------------------------------------------------------------------
INTERNAL_ (BOOL) IsFile
    (ATOM a,	BOOL FAR* pfUnsavedDoc)
{
	LPMONIKER pmk = NULL;
	LPBC pbc = NULL;
	LPRUNNINGOBJECTTABLE pROT=NULL;

	WCHAR szFile [MAX_STR];
	if (0==GlobalGetAtomName (a, szFile, MAX_STR))
	    return FALSE;

	DWORD dwAttribs = GetFileAttributes(szFile);

	 /* flags prevent sharing violation*/
	if (dwAttribs != 0xFFFFFFFF)
	{
		if (pfUnsavedDoc)
			*pfUnsavedDoc = FALSE;
		return TRUE;
	}
	// This will deal with unsaved documents in the ROT.
	// We do NOT want to call pmk->IsRunning because if a 2.0 client called
	// DdeIsRunning, we do not want call it here, because then we get stuck
	// in an infinite loop.  We only care about true 2.0 running objects.


	BOOL f= NOERROR==CreateBindCtx (0, &pbc) &&
			NOERROR==CreateFileMoniker (szFile, &pmk) &&
			NOERROR==pbc->GetRunningObjectTable (&pROT) &&
			NOERROR==pROT->IsRunning (pmk) ;
	if (pROT)
		pROT->Release();
	if (pmk)
		pmk->Release();
	if (pbc)
		pbc->Release();
	if (pfUnsavedDoc)
		*pfUnsavedDoc = TRUE;
	return f;


}

// wCompatibleClasses
//
// Determine if class "aClient" is Auto-Converted to class "aSrvr" or
// Treated-As class "aSrvr".
// (Does not check if aClient==aSrvr)
//
#pragma SEG(wCompatibleClasses)
INTERNAL wCompatibleClasses
	(ATOM aClient,
	ATOM aSrvr)
{
	CLSID clsidClient, clsidSrvr, clsidTo;
	HRESULT hresult;
	RetZS (CLSIDFromAtom (aClient, &clsidClient), S_FALSE);
	RetZS (CLSIDFromAtom (aSrvr,   &clsidSrvr  ), S_FALSE);
	if (NOERROR==OleGetAutoConvert (clsidClient, &clsidTo)
		&& clsidTo == clsidSrvr)
	{
		// aClient is Auto-Converted to aSrvr
		return NOERROR;
	}
	hresult = CoGetTreatAsClass(clsidClient, &clsidTo);

    // Used to be:
    //   if (hresult != NOERROR)
    // But CoGetTreatAsClass return S_FALSE if you don't have
    // a TreatAs class....
	if (FAILED(hresult))
	{
	    intrDebugOut((DEB_IERROR,
	    		  "wCompatibleClasses CoGetTreatAs returns %x\n",
			  hresult));
	    return(hresult);
	}

	if (clsidTo == clsidSrvr)
	{
		// aClient is Treated-As aSrvr
		return NOERROR;
	}
	return ResultFromScode (S_FALSE); // not compatible
}



// wCreateStgAroundNative
//
// Build an OLE2 storage around 1.0 native data by putting it in
// stream "\1Ole10Native" and creating valid CompObj and OLE streams.
// Return the IStorage and the ILockBytes it is built on.
//
INTERNAL wCreateStgAroundNative
	(HANDLE hNative,
	ATOM	aClassOld,
	ATOM	aClassNew,
	CNVTYP	cnvtyp,
	ATOM	aItem,
	LPSTORAGE FAR* ppstg,
	LPLOCKBYTES FAR* pplkbyt)
{
	HRESULT   hresult;
	LPSTORAGE pstg = NULL;
	LPLOCKBYTES plkbyt = NULL;
	LPOLESTR szUserType = NULL;
	WCHAR szClassOld [256];
	CLSID     clsid;
	ATOM	aClass;
	*ppstg = NULL;

	intrDebugOut((DEB_ITRACE,
	    	      "%p wCreateStgAroundNative(hNative=%x,aClassOld=%x"
		      ",aClassNew=%x cnvtyp=%x,aItem=%x)\n",
		      0,hNative,aClassOld,aClassNew,cnvtyp,aItem));

	// Create temporary docfile on our ILockBytes
	ErrRtnH (CreateILockBytesOnHGlobal (NULL,/*fDeleteOnRelease*/TRUE,&plkbyt));

	Assert (plkbyt);

	ErrRtnH (StgCreateDocfileOnILockBytes (plkbyt, grfCreateStg, 0, &pstg));

	RetZ (pstg);
	Assert (NOERROR==StgIsStorageILockBytes(plkbyt));

	aClass = (cnvtyp == cnvtypConvertTo)?aClassNew:aClassOld;

	if (CLSIDFromAtom (aClass,(LPCLSID)&clsid) == FALSE)
	{
	    hresult = REGDB_E_CLASSNOTREG;
	    goto errRtn;
	}

	ErrRtnH (WriteClassStg (pstg, clsid));

	// The UserType always corresponds to the clsid.
	ErrRtnH (OleRegGetUserType (clsid, USERCLASSTYPE_FULL, &szUserType));

	// The format is always the 1.0 format (classname/progid)
	ErrZS (GlobalGetAtomName (aClassOld, szClassOld, 256), E_UNEXPECTED);

	ErrRtnH (WriteFmtUserTypeStg (pstg, (CLIPFORMAT) RegisterClipboardFormat(szClassOld),
						 			szUserType));


	if (cnvtyp == cnvtypConvertTo)
	{
		// SetConvertStg also writes a complete default Ole Stream
		ErrRtnH (SetConvertStg (pstg, TRUE));
	}
	else
	{
		ErrRtnH (WriteOleStg (pstg, NULL, (CLIPFORMAT)0, NULL));
	}
	ErrRtnH (StSave10NativeData (pstg, hNative, FALSE));
	if (aItem)
	{
		ErrRtnH (StSave10ItemName (pstg, wAtomNameA (aItem)));
	}
	*ppstg = pstg;
	*pplkbyt = plkbyt;
	return NOERROR;

  errRtn:
	if (pstg)
		pstg->Release();
	if (plkbyt)
		plkbyt->Release();
	CoTaskMemFree(szUserType);
	return hresult;
}


#ifdef _DEBUG


INTERNAL_ (BOOL) IsAtom (ATOM a)
{
    WCHAR sz[256]= {0};
    if (a < 0xc000)
	return FALSE;
    WORD cb= (WORD) GlobalGetAtomName (a, sz, 256);
    Assert (lstrlenW(sz) == (int) cb);
    return cb>0 && cb < MAX_STR;
}


#include <limits.h>
#undef GlobalFree




INTERNAL_(HANDLE) wGlobalFree (HANDLE h)
{
    LPVOID p;
    Assert ((GlobalFlags(h) & GMEM_LOCKCOUNT)==0);
    if (!(p=GlobalLock(h)))
    {
	Puts ("Cannot free handle");
	Puth (h);
	Putn();
	AssertSz(0, "Invalid Handle\r\n");
    }
    Assert (IsValidReadPtrIn (p, (UINT) min (UINT_MAX, GlobalSize(h))));
    Assert (GlobalUnlock(h)==0);
    Verify (!GlobalFree (h));
    Puts ("FREEING ");
    Puth (h);
    Putn ();
    return NULL; // success
}



#undef GlobalDeleteAtom

INTERNAL_(ATOM) wGlobalDeleteAtom (ATOM a)
{
    WCHAR sz[256];
    Assert (0 != GlobalGetAtomName (a, sz, 256));
    Assert (0==GlobalDeleteAtom (a));
    return (ATOM)0;
}

INTERNAL_(int) wCountChildren
    (HWND h)
{
    int c = 0;
    HWND hwndChild = GetWindow (h, GW_CHILD);
    while (hwndChild)
    {
	c++;
	hwndChild = GetWindow (hwndChild, GW_HWNDNEXT);
    }
    return c;
}


#endif // _DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\com\dde\server\sources.inc ===
!IF 0

Copyright (c) 1998  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.

!ENDIF

TARGETNAME=   ddesvr
TARGETPATH=   obj
TARGETTYPE=   LIBRARY

INCLUDES = ..\.;..\..\client;..\..\..\..\common\$(DEST_TREE);..\..\..\..\ih
INCLUDES = $(INCLUDES);..\..\..\dcomrem;..\..\..\inc
INCLUDES = $(INCLUDES);..\..\..\class;..\..\..\objact
INCLUDES = $(INCLUDES);..\..\..\..\ole232\inc
INCLUDES = $(INCLUDES);..\..\..\..\idl\public\$(DEST_TREE)\$(O)
INCLUDES = $(INCLUDES);..\..\..\..\idl\internal\$(DEST_TREE)\$(O)
INCLUDES = $(INCLUDES);..\..\..\..\idl\private\$(DEST_TREE)\$(O)
INCLUDES = $(INCLUDES);$(BASE_INC_PATH)

C_DEFINES= -DOLE_DDE_NO_GLOBAL_TRACKING=1\
           $(C_DEFINES)


SOURCES=      \
    ..\ddeadv.cxx   \
    ..\ddesink.cxx  \
    ..\ddesite.cxx  \
    ..\ddesrvr.cxx  \
    ..\ddeutils.cxx \
    ..\doc.cxx      \
    ..\item.cxx     \
    ..\item2.cxx    \
    ..\itemutil.cxx \
    ..\srvr.cxx     \
    ..\srvrmain.cxx
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\com\dde\server\srvrmain.cxx ===
/****************************** Module Header ******************************\
* Module Name: Srvrmain.c Server Main module
*
* Purpose: Includes server intialization and termination code.
*
* Created: Oct 1990.
*
* Copyright (c) 1990, 1991  Microsoft Corporation
*
* History:
*    Raor (../10/1990)    Designed, coded
*    Raor (03/../1992)    Modified for OLE 2.0
*
\***************************************************************************/

#include "ole2int.h"
#include <dde.h>
#include <ddesrvr.h>
// #include "cmacs.h"
#include "srvr.h"
#include "ddeatoms.h"
#include "ddedebug.h"
ASSERTDATA

ATOM    aStdExit = NULL;              // "StdExit"
ATOM    aStdCreate = NULL;            // "StdNewDicument"
ATOM    aStdOpen = NULL;              // "StdOpenDocument"
ATOM    aStdEdit = NULL;              // "StdOpenDocument"
ATOM    aStdCreateFromTemplate = NULL;// "StdNewFromTemplate"
ATOM    aStdClose = NULL;             // "StdCloseDocument"
ATOM    aStdShowItem = NULL;          // "StdShowItem"
ATOM    aStdDoVerbItem = NULL;        // "StddoVerbItem"
ATOM    aSysTopic = NULL;             // "System"
ATOM    aOLE = NULL;                  // "OLE"
ATOM    aProtocols = NULL;            // "Protocols"
ATOM    aTopics = NULL;               // "Topics"
ATOM    aFormats = NULL;              // "Formats"
ATOM    aStatus = NULL;               // "Status"
ATOM    aEditItems = NULL;            // "Edit items
ATOM    aTrue = NULL;                 // "True"
ATOM    aFalse = NULL;                // "False"


ATOM    aStdHostNames;
ATOM    aStdTargetDevice ;
ATOM    aStdDocDimensions;
ATOM    aStdColorScheme;
ATOM    aChange;
ATOM    aSave;
ATOM    aClose;
ATOM    aStdDocName;
ATOM    aMSDraw;

LPTSTR  gOleDdeWindowClass = NULL;         // class used to create DDE windows
BOOL    gfDdeInitialized   = FALSE;        // flag if process-wide DDE initialized

const WCHAR *ptszOleDdeWndClass = L"OleDdeWndClass";


INTERNAL CheckInitDde(BOOL fRegisteringServerObject)
{
    HRESULT hr;
    COleTls tls(hr);
    if (FAILED(hr))
    {
        // can't get TLS
        return hr;
    }

    if (fRegisteringServerObject)
    {
        tls->cServeDdeObjects++;
    }

    if (tls->hwndDdeServer != NULL  ||
        tls->cOleInits == 0         ||
        tls->cServeDdeObjects == 0)
    {
        // A DdeServer window already exists, or Com has been initialized
        // but Ole has not, or there are currently no objects using Dde.
        // We dont create a window, we just return NOERROR.
        // This way, COM-only servers dont start serving OLE1 clients.
        return S_OK;
    }

    if (tls->dwFlags & OLETLS_DISABLE_OLE1DDE )
    {
        // DDE use is disabled.
        return CO_E_OLE1DDE_DISABLED;
    }

    {
        // ensure one thread does this at a time
        COleStaticLock lck(g_mxsSingleThreadOle);
        if (!gfDdeInitialized)
        {
            // register the DDE atoms and the Dde
            // window class in this process.
            if (!DDELibMain(NULL, 0, 0, NULL))
            {
                return E_OUTOFMEMORY;
            }

            gfDdeInitialized = TRUE;
        }
    }

    // create the common dde window for this thread
    return CreateCommonDdeWindow();
}

void CheckUninitDde(BOOL fLastUninit)
{
    DestroyCommonDdeWindow();

    if (fLastUninit)
    {
        COleStaticLock lck(g_mxsSingleThreadOle);
        if (gfDdeInitialized)
        {
            DDEWEP(WEP_FREE_DLL);
            gfDdeInitialized = FALSE;
        }
    }
}


INTERNAL_(BOOL) DDELibMain (
    HANDLE  hInst,
    WORD    wDataSeg,
    WORD    cbHeapSize,
    LPOLESTR   lpszCmdLine
)
{
    BOOLEAN fRetVal = TRUE;

    intrDebugOut((DEB_ITRACE,
                  "%p _IN DDELibMain hInst=%x\n",
                  0,
                  hInst));

    if( !aStdExit )
    {
        // On NT3.51, user preregisters all of these formats for us,
        // thus giving us a big speed improvement during startup (because
        // these atoms never change).
        // Chicago and Cairo do not yet have this functionality.

        aStdExit = GlobalFindAtom(OLESTR("StdExit"));

        aStdCreate = aStdExit + 1;
        Assert(aStdCreate  == GlobalFindAtom (OLESTR("StdNewDocument")));

        aStdOpen = aStdExit + 2;
        Assert(aStdOpen == GlobalFindAtom (OLESTR("StdOpenDocument")));

        aStdEdit = aStdExit + 3;
        Assert(aStdEdit == GlobalFindAtom (OLESTR("StdEditDocument")));

        aStdCreateFromTemplate = aStdExit + 4;
        Assert(aStdCreateFromTemplate ==
                GlobalFindAtom(OLESTR("StdNewfromTemplate")));

        aStdClose = aStdExit + 5;
        Assert(aStdClose == GlobalFindAtom (OLESTR("StdCloseDocument")));

        aStdShowItem = aStdExit + 6;
        Assert(aStdShowItem == GlobalFindAtom (OLESTR("StdShowItem")));

        aStdDoVerbItem = aStdExit + 7;
        Assert(aStdDoVerbItem == GlobalFindAtom (OLESTR("StdDoVerbItem")));

        aSysTopic = aStdExit + 8;
        Assert(aSysTopic == GlobalFindAtom (OLESTR("System")));

        aOLE = aStdExit + 9;
        Assert(aOLE == GlobalFindAtom (OLESTR("OLEsystem")));

        aStdDocName = aStdExit + 10;
        Assert(aStdDocName == GlobalFindAtom (OLESTR("StdDocumentName")));

        aProtocols = aStdExit + 11;
        Assert(aProtocols == GlobalFindAtom (OLESTR("Protocols")));

        aTopics = aStdExit + 12;
        Assert(aTopics == GlobalFindAtom (OLESTR("Topics")));

        aFormats = aStdExit + 13;
        Assert(aFormats == GlobalFindAtom (OLESTR("Formats")));

        aStatus = aStdExit + 14;
        Assert(aStatus == GlobalFindAtom (OLESTR("Status")));

        aEditItems = aStdExit + 15;
        Assert(aEditItems == GlobalFindAtom (OLESTR("EditEnvItems")));

        aTrue = aStdExit + 16;
        Assert(aTrue == GlobalFindAtom (OLESTR("True")));

        aFalse = aStdExit + 17;
        Assert(aFalse == GlobalFindAtom (OLESTR("False")));

        aChange = aStdExit + 18;
        Assert(aChange == GlobalFindAtom (OLESTR("Change")));

        aSave = aStdExit + 19;
        Assert(aSave == GlobalFindAtom (OLESTR("Save")));

        aClose = aStdExit + 20;
        Assert(aClose == GlobalFindAtom (OLESTR("Close")));

        aMSDraw = aStdExit + 21;
        Assert(aMSDraw == GlobalFindAtom (OLESTR("MSDraw")));
    }

    // On Win95, we cannot use OleMainThreadWnd to receive DDE broadcasts (as USER
    // checks and will not forward DDE broadcasts to the OleMainThreadWnd class).  So
    // we need a different window class.  We do the same on NT for consistency.
    // Register DDE windows class.

    if (gOleDdeWindowClass == 0)
    {
        WNDCLASST        xClass;

        xClass.style         = 0;
        xClass.lpfnWndProc   = DdeCommonWndProc;
        xClass.cbClsExtra    = 0;

        // DDE needs some extra space in the window
        xClass.cbWndExtra    = sizeof(LPVOID) + sizeof(ULONG) + sizeof(HANDLE);
        xClass.hInstance     = g_hinst;
        xClass.hIcon         = NULL;
        xClass.hCursor       = NULL;
        xClass.hbrBackground = (HBRUSH) (COLOR_BACKGROUND + 1);
        xClass.lpszMenuName  = NULL;
        xClass.lpszClassName = ptszOleDdeWndClass;

        gOleDdeWindowClass = (LPTSTR) RegisterClassT( &xClass );
        if (gOleDdeWindowClass == 0)
        {
            // it is possible the dll got unloaded without us having called
            // unregister so we call it here and try again.

            UnregisterClassT(ptszOleDdeWndClass, g_hinst);
            gOleDdeWindowClass = (LPTSTR) RegisterClassT(&xClass);

            if (gOleDdeWindowClass == 0)
            {
                intrDebugOut((DEB_ERROR, "RegisterClass failed in DDELibMain\n"));
                fRetVal = FALSE;
            }
        }
    }

    return(fRetVal);
}


INTERNAL_(void) DDEWEP (
    BOOL fSystemExit
)
{
#if DBG==1
    Puts("DdeWep\r\n");

    if (fSystemExit != WEP_FREE_DLL)
    {
        AssertSz (0, "Bad parm to Wep");
        return;
    }
#endif  // DBG==1
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\com\dde\server\srvr.cxx ===
/****************************** Module Header ******************************\
* Module Name: Srvr.c Server Main module
*
* Purpose: Includes All the server communication related routines.
*
* Created: Oct 1990.
*
* Copyright (c) 1985, 1986, 1987, 1988, 1989  Microsoft Corporation
*
* History:
*    Raor:   Wrote the original version.
*
*
\***************************************************************************/

#include "ole2int.h"
//#include <shellapi.h>
// #include "cmacs.h"
#include <dde.h>

// for RemDdeRevokeClassFactory and HDDESRVR
#include <olerem.h>

#include "srvr.h"
#include "ddedebug.h"
#include "ddesrvr.h"
ASSERTDATA

#define WM_DONOTDESTROY WM_USER+1

#ifdef FIREWALLS
BOOL    bShowed = FALSE;
void    ShowVersion (void);
#endif

#define DdeCHAR WCHAR
#define Ddelstrcmp lstrcmpW
#define DdeGetClassName GetClassName
#define szCDDEServer OLESTR("CDDEServer")

//+---------------------------------------------------------------------------
//
//  Method:     CDDEServer::Create
//
//  Synopsis:   Create a server window to service a particular class
//
//  Effects:    Using lpclass, and the information in lpDdeInfo, create
//              a server window that is ready to respond to initiate
//              messages from this class.
//
//  Arguments:  [lpclass] --    Class name
//              [rclsid] -- Class ID
//              [lpDdeInfo] --  Class Object information
//              [phwnd] --      Out pointer for new window
//              [aOriginalClass] -- For TreatAs/Convert to case
//              [cnvtyp] --         Conversion type
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:
//
//  History:    5-28-94   kevinro Commented/cleaned
//
//  Notes:
//
//----------------------------------------------------------------------------
INTERNAL CDDEServer::Create
    (LPOLESTR          lpclass,
     REFCLSID          rclsid,
     LPDDECLASSINFO    lpDdeInfo,
     HWND FAR *        phwnd,
     ATOM              aOriginalClass,
     CNVTYP            cnvtyp)
{
    // REVIEW   what happens if we have two MDI servers register the
    //          same class factory?.

    LPSRVR  lpDDEsrvr   = NULL;
    ATOM    aExe        = NULL;

    intrDebugOut((DEB_DDE_INIT,
                  "0 _IN CDDEServer::Create(lpclass=%ws)\n",
                  lpclass));

    // add the app atom to global list
    if (!ValidateSrvrClass (lpclass, &aExe))
    {
        intrDebugOut((DEB_IWARN,
                      "CDDEServer::Create(%ws) Invalid Class\n",
                      lpclass));

        return OLE_E_CLSID;
    }

    lpDDEsrvr =  new CDDEServer;
    RetZS (lpDDEsrvr, E_OUTOFMEMORY);

    // set the signature handle and the app atom.
    lpDDEsrvr->m_chk         = chkDdeSrvr;
    lpDDEsrvr->m_aClass      = wGlobalAddAtom (lpclass);
    lpDDEsrvr->m_clsid       = rclsid; // Class ID (already TreatAs'd)
    lpDDEsrvr->m_aOriginalClass = wDupAtom (aOriginalClass);
    lpDDEsrvr->m_pClassFactory  = NULL;
    lpDDEsrvr->m_dwClassFactoryKey = lpDdeInfo->dwRegistrationKey;
    lpDDEsrvr->m_aExe        = aExe;
    lpDDEsrvr->m_cnvtyp      = cnvtyp;
    lpDDEsrvr->m_fcfFlags    = lpDdeInfo->dwFlags;

    lpDDEsrvr->m_bTerminate  = FALSE;        // Set if we are terminating.
    lpDDEsrvr->m_hcli        = NULL;         // handle to the first block of clients list
    lpDDEsrvr->m_termNo      = 0;            // termination count
    lpDDEsrvr->m_cSrvrClients= 0;            // no of clients;
    lpDDEsrvr->m_fDoNotDestroyWindow= 0;





#ifdef   FIREWALLS
    AssertSz(lpDdeInfo.dwFlags <= REGCLS_MULTI_SEPARATE, "invalid server options");
#endif

    // Create the server window and do not show it.
    //
    // We are explicitly calling CreateWindowA here.
    // The DDE tracking layer will attempt to convert hCommands to UNICODE
    // if the two windows in the conversation are both UNICODE.
    // This window is created as a child of the common server window for this
    // thread. When this thread dies, the common server window is destroyed if
    // it exists, which will cause all of the child windows to be destroyed also.
    //
    //
    if (!(lpDDEsrvr->m_hwnd = DdeCreateWindowEx (0, gOleDdeWindowClass,
                                            szCDDEServer,
                                            WS_OVERLAPPED | WS_CHILD,
                                            0,0,0,0,
                                            (HWND)TLSGetDdeServer(),
                                            NULL,
                                            g_hinst, NULL)))
    {
        goto errReturn;
    }

    // fix up the WindowProc entry point.
    SetWindowLongPtr(lpDDEsrvr->m_hwnd, GWLP_WNDPROC, (LONG_PTR)SrvrWndProc);

    //
    // The following will inform the class object in the class registration table
    // that this window should be notified when the class object is revoked. This
    // enables the window to shutdown properly.
    //
    // If there isn't a class factory, which happens for single instance servers
    // which were launched with a filename, then m_dwClassFactory will be 0,
    // in which case we don't make the set call.
    //
    if(lpDDEsrvr->m_dwClassFactoryKey != 0)
    {
        if(!CCSetDdeServerWindow(lpDDEsrvr->m_dwClassFactoryKey,lpDDEsrvr->m_hwnd))
        {
            intrDebugOut((DEB_IERROR,
                          "0 CDDEServer::Create unable to SetDdeServerWindow\n"));
            goto errReturn;
        }
    }

    intrDebugOut((DEB_DDE_INIT,
                  "DDE Server window for %ws created in task %x\n",
                  lpclass,GetCurrentThreadId()));

    // save the ptr to the server struct in the window.
    SetWindowLongPtr (lpDDEsrvr->m_hwnd, 0, (LONG_PTR)lpDDEsrvr);

    // Set the signature.
    SetWindowWord (lpDDEsrvr->m_hwnd, WW_LE, WC_LE);

    *phwnd = lpDDEsrvr->m_hwnd;


    intrDebugOut((DEB_DDE_INIT,
                  "0 _OUT CDDEServer::Create returns %x\n",
                  NOERROR));
    return NOERROR;

errReturn:
    AssertSz (0, "CDDEServer::Create errReturn");
    if (lpDDEsrvr)
    {
        if (lpDDEsrvr->m_hwnd)
            SSDestroyWindow (lpDDEsrvr->m_hwnd);

        if (lpDDEsrvr->m_aClass)
            GlobalDeleteAtom (lpDDEsrvr->m_aClass);

        if (lpDDEsrvr->m_aExe)
            GlobalDeleteAtom (lpDDEsrvr->m_aExe);
        delete lpDDEsrvr;
    }

    intrDebugOut((DEB_IERROR,
                  "0 _OUT CDDEServer::Create returns %x\n",
                  E_OUTOFMEMORY));

    return E_OUTOFMEMORY;
}



// ValidateSrvrClass checks whether the given server class is valid by
// looking in the registration database.

INTERNAL_(BOOL)    ValidateSrvrClass (
LPOLESTR       lpclass,
ATOM FAR *  lpAtom
)
{
    WCHAR    buf[MAX_STR];
    LONG    cb = MAX_STR;
    WCHAR    key[MAX_STR];
    LPOLESTR   lptmp;
    LPOLESTR   lpbuf;
    WCHAR    ch;
    CLSID    clsid;

    if (CLSIDFromProgID (lpclass, &clsid) != NOERROR)
    {
        // ProgId is not correctly registered in reg db
        return FALSE;
    }

    lstrcpyW (key, lpclass);
    lstrcatW (key, OLESTR("\\protocol\\StdFileEditing\\server"));

    if (QueryClassesRootValue (key, buf, &cb))
        return TRUE;

    if (!buf[0])
    {
        AssertSz (0, "ValidateSrvrClass failed.");
        return FALSE;
    }

    // Get exe name without path and then get an atom for that
    lptmp = lpbuf = buf;
    while (ch = *lptmp)
    {
        lptmp++;
        if (ch == '\\' || ch == ':')
            lpbuf = lptmp;
    }
    *lpAtom =  wGlobalAddAtom (lpbuf);

    return TRUE;
}



INTERNAL RemDdeRevokeClassFactory
    (LPSRVR lpsrvr)
{
    HRESULT hr;
    intrDebugOut((DEB_ITRACE,
                  "0 _IN RemDdeRevokeClassFactory(%x)\n",
                  lpsrvr));

    ChkS(lpsrvr);
    hr = lpsrvr->Revoke();
    intrDebugOut((DEB_ITRACE,
                  "0 OUT RemDdeRevokeClassFactory(%x) %x\n",
                  lpsrvr,hr));
    return(hr);
}



INTERNAL CDDEServer::Revoke ()
{
    intrDebugOut((DEB_ITRACE,
                  "%x _IN CDDEServer::Revoke() m_cSrvrClients=%x\n",
                  this,
                  m_cSrvrClients));
    HRESULT hr;

    ChkS(this);

    //
    // Can't revoke if there are still clients. QueryRevokeCLassFactory
    // determines if there are still clients attached.
    //
    if (!QueryRevokeClassFactory ())
    {
        intrDebugOut((DEB_IERROR,
                      "QueryRevokeClassFactory failed!"));
        hr = RPC_E_DDE_REVOKE;
        goto exitRtn;
    }

    if (m_cSrvrClients)
    {
        m_bTerminate = TRUE;
        // if there are any clients connected to this classfactory,
        // send terminates.
        SendServerTerminateMsg ();
        m_bTerminate = FALSE;
    }

    hr = FreeSrvrMem ();

exitRtn:
    intrDebugOut((DEB_ITRACE,
                  "%x OUT CDDEServer::Revoke(%x) hr = %x\n",
                  this, hr));
    return hr;
}

INTERNAL_(void)  CDDEServer::SendServerTerminateMsg ()
{

    HANDLE          hcliPrev = NULL;
    PCLILIST        pcli;
    HANDLE          *phandle;
    HANDLE          hcli;

    intrDebugOut((DEB_ITRACE,
                  "%x _IN CDDEServer::SendServerTerminateMsg\n",
                  this));

    hcli = m_hcli;
    while (hcli) {
        if ((pcli = (PCLILIST) LocalLock (hcli)) == NULL)
        {
            Assert(0);
            goto exitRtn;
        }

        phandle = (HANDLE *) (pcli->info);
        while (phandle < (HANDLE *)(pcli + 1)) {
            if (*phandle)
            {
                PostMessageToClientWithReply ((HWND)(*phandle), WM_DDE_TERMINATE,
                    (WPARAM) m_hwnd, NULL, WM_DDE_TERMINATE);
                Assert (m_cSrvrClients);
                m_cSrvrClients--;
            }
            phandle++;
            phandle++;
        }

        hcliPrev = hcli;
        hcli = pcli->hcliNext;
        LocalUnlock (hcliPrev);
    }

exitRtn:
    intrDebugOut((DEB_ITRACE,
                  "%x OUT CDDEServer::SendServerTerminateMsg\n",
                  this));

}

//+---------------------------------------------------------------------------
//
//  Method:     CDDEServer::FreeSrvrMem
//
//  Synopsis:   Free's up a CDDEServer.
//
//  Effects:
//
//  Arguments:  [void] --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:
//
//  History:    6-26-94   kevinro   Commented
//
//  Notes:
//
//----------------------------------------------------------------------------
INTERNAL CDDEServer::FreeSrvrMem
    (void)
{
    HRESULT hr;
    // REVIEW: Not clear how this works in the synchronous mode
    // Release for class factory is called only when everything is
    // cleaned and srvr app can post WM_QUIT at this stage

    intrDebugOut((DEB_ITRACE,
                  "%x _IN CDDEServer::FreeSrvrMem\n",
                  this));

    PCLILIST pcliPrev;
    HANDLE hcli, hcliPrev;

    if (m_bTerminate)
    {
        AssertSz (0, "terminate flag is not FALSE");
    }


    if (m_aExe)
    {
        GlobalDeleteAtom (m_aExe);
    }


    // We deliberately do not call this->Lock (FALSE)
    // If the server has revoked his class object without
    // waiting for his Lock count to go to zero, then
    // presumably he doesn't need us to unlock him.  In fact,
    // doing such an unlock might confuse a server who then
    // tries to call CoRevokeClassObject recursively.
    if (m_pClassFactory)
    {
        m_pClassFactory->Release();
        m_pClassFactory = NULL;
    }

    hcli = m_hcli;
    while (hcli)
    {
        hcliPrev = hcli;
        if (pcliPrev = (PCLILIST) LocalLock (hcliPrev))
        {
            hcli = pcliPrev->hcliNext;
        }
        else
        {
            AssertSz (0, "Corrupt internal data structure or out-of-memory");
            hcli = NULL;
        }
        Verify (0==LocalUnlock (hcliPrev));
        Verify (NULL==LocalFree (hcliPrev));
    }

    hr = DestroyDdeSrvrWindow(m_hwnd,m_aClass);
    if (hr != NOERROR)
    {
        //
        // Well now, if DestroyWindow fails, there isn't a whole heck of
        // alot we can do about it. It could mean that the window was
        // destroyed previously, or the parent window was destroyed during
        // thread shutdown. We should still continue to cleanup
        //
        intrDebugOut((DEB_IERROR,
                      "%x CDDEServer::FreeSrvrMem DestroyDdeSrvrWindow failed %x\n",
                      this,
                      hr));
    }

    if (m_aClass)
    {
        GlobalDeleteAtom (m_aClass);
    }

    delete this;

    intrDebugOut((DEB_ITRACE,
                  "%x _OUT CDDEServer::FreeSrvrMem\n",
                  this));
    return NOERROR;
}

//+---------------------------------------------------------------------------
//
//  Function:   SrvrHandleIncomingCall
//
//  Synopsis:   Setup and call the CallControl to dispatch a call to the server
//
//  Effects:    A call has been made from the client that requires us to call
//              into our server. This must be routed through the call control.
//              This routine sets up the appropriate data structures, and
//              calls into the CallControl. The CallControl will in turn
//              call SrvrDispatchIncomingCall to actuall process the call.
//
//              This routine should only be called by the SrvrWndProc
//
//
//  Arguments:  [lpsrvr] -- Points to the server
//              [hwnd] -- hwnd of server
//              [hdata] -- Handle to data
//              [wParam] -- hwnd of client
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    6-05-94   kevinro Commented/cleaned
//
//  Notes:
//
//----------------------------------------------------------------------------
INTERNAL SrvrHandleIncomingCall(LPSRVR lpsrvr,
                                HWND hwnd,
                                HANDLE hdata,
                                HWND wParam)
{
    VDATEHEAP();
    HRESULT hresult = NOERROR;
    SRVRDISPATCHDATA srvrdispdata;
    DISPATCHDATA     dispatchdata;

    intrDebugOut((DEB_ITRACE,
                  "0 _IN SrvrHandleIncomingCall lpsrvr=%x hwnd=%x hdata=%x wParam=%x\n",
                  lpsrvr,
                  hwnd,
                  hdata,
                  wParam));

    srvrdispdata.wDispFunc = DDE_DISP_SRVRWNDPROC;
    srvrdispdata.hwnd = hwnd;
    srvrdispdata.hData = hdata;
    srvrdispdata.wParam = wParam;
    srvrdispdata.lpsrvr = lpsrvr;

    dispatchdata.pData = &srvrdispdata;

    RPCOLEMESSAGE        rpcMsg = {0};
    RPC_SERVER_INTERFACE RpcInterfaceInfo;
    DWORD                dwFault;

    rpcMsg.iMethod = 0;
    rpcMsg.Buffer  = &dispatchdata;
    rpcMsg.cbBuffer = sizeof(dispatchdata);
    rpcMsg.reserved2[1] = &RpcInterfaceInfo;
    *MSG_TO_IIDPTR(&rpcMsg) = GUID_NULL;


    IRpcStubBuffer * pStub = &(lpsrvr->m_pCallMgr);
    IInternalChannelBuffer * pChannel = &(lpsrvr->m_pCallMgr);
    hresult = STAInvoke(&rpcMsg, CALLCAT_SYNCHRONOUS, pStub, pChannel,
                        NULL, NULL, &dwFault);

    intrDebugOut((DEB_ITRACE,
                  "0 _OUT SrvrHandleIncomingCall hresult=%x\n",
                  hresult));

    return(hresult);
}

//+---------------------------------------------------------------------------
//
//  Function:   SrvrDispatchIncomingCall
//
//  Synopsis:   Dispatch a call into the server.
//
//  Effects:    At the moment, the only incoming call that requires handling
//              by the server window is Execute. This routine dispatchs to it,
//              and returns.
//
//  Arguments:  [psdd] --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    6-05-94   kevinro Commented/cleaned
//
//  Notes:
//
//----------------------------------------------------------------------------
INTERNAL SrvrDispatchIncomingCall(PSRVRDISPATCHDATA psdd)
{
    VDATEHEAP();
    HRESULT hr;
    intrDebugOut((DEB_ITRACE,
                  "0 _IN SrvrDispatchIncomingCall psdd(%x)\n",psdd));

    hr = psdd->lpsrvr->SrvrExecute (psdd->hwnd,
                                    psdd->hData,
                             (HWND)(psdd->wParam));

    intrDebugOut((DEB_ITRACE,
                  "0 _OUT SrvrDispatchIncomingCall psdd(%x) hr =%x\n",
                  psdd,
                  hr));

    return(hr);
}


// REVIEW: Revoking Class Factory will not be successful if
//         any clients are either connected to the classfactory
//         or to the object instances.



//+---------------------------------------------------------------------------
//
//  Function:   SrvrWndProc
//
//  Synopsis:   This is the server window procedure.
//
//  Effects:
//
//  Arguments:  [hwndIn] -- Window handle (may not be full. See note)
//              [msg] --
//              [wParam] --
//              [lParam] --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    8-03-94   kevinro   Created
//
//  Notes:
//
//  When running in a VDM, it is possible that this window was dispatched
//  without having a full window handle. This happens when the getmessage
//  was dispatched from 16-bit. Therefore, we need to convert the hwnd to
//  a full hwnd before doing any comparision functions.
//
//----------------------------------------------------------------------------
STDAPI_(LRESULT) SrvrWndProc (
HWND            hwndIn,
UINT            msg,
WPARAM          wParam,
LPARAM          lParam
)
{
    BOOL        fRevoke=FALSE;
    LPSRVR      lpsrvr;
    WORD        status = NULL;
    HANDLE      hdata;
    ATOM        aItem;
    HRESULT   retval;

    //
    // The following hwnd variable is used to determine the full HWND, in the
    // event we were dispatched in a 16 bit process.
    //
    HWND        hwnd;

#ifdef  FIREWALLS
    HWND        hwndClient;
#endif


    switch (msg){

       case WM_DDE_INITIATE:
            VDATEHEAP();
#ifdef  FIREWALLS
    AssertSz (lpsrvr, "No server window handle in server window");
#endif
            hwnd = ConvertToFullHWND(hwndIn);

            lpsrvr = (LPSRVR)GetWindowLongPtr (hwnd, 0);
            if (lpsrvr->m_bTerminate){
                // we are terminating, no more connections
                break;
            }

            // class is not matching, so it is not definitely for us.
            // for apps sending the EXE for initiate, do not allow if the app
            // is mutiple instance (Bug fix for winworks).

            if (!(lpsrvr->m_aClass == (ATOM)(LOWORD(lParam)) ||
                 (NOERROR==wCompatibleClasses (LOWORD(lParam), lpsrvr->m_aClass)) ||
                 (lpsrvr->m_aExe == (ATOM)(LOWORD(lParam)) && IsSingleServerInstance() )))
            {
                break;
            }

            intrDebugOut((DEB_DDE_INIT,"::SrvrWndProc INITIATE\n"));


            if (!lpsrvr->HandleInitMsg (lParam))
            {
                if (!(aSysTopic == (ATOM)(HIWORD(lParam))))
                {
                    //
                    // If this isn't a sys topic, then it must be a request for
                    // a specific document. Send a message to the
                    // children windows, asking for the document. If one of them
                    // may send an ACK to the client.
                    //

                    // if the server window is not the right window for
                    // DDE conversation, then try with the doc windows.
                    BOOL fAckSent = SendInitMsgToChildren (hwnd, msg, wParam, lParam);

#ifdef KEVINRO_OLDCODE
 The following code was removed, because I don't belive it is required
 any longer. I am not 100% sure yet, so I have left it in. If you find it,
 you can probably remove it.
 It appears to be trying to claim the SINGLE_USE class factory from the class
 factory table. It does this when a child document window sends an ACK to the
 client, claiming to support the document being asked for. It really doesn't
 make too much sense here, since a single use server would have already removed
 its class factory if there was an open document.

 Anyway, the 16-bit version had a direct hack into the class factory table. We
 don't have that anymore, so this code wouldn't work anyway.

                    if (lpsrvr->m_fcfFlags==REGCLS_SINGLEUSE)
                    {
                        if (lpsrvr->m_pfAvail)
                        {
                            // Hide the entry in the class factory table so that no 2.0
                            // client can connect to the same server.
                            Assert (IsValidPtrOut (lpsrvr->m_pfAvail, sizeof(BOOL)));
                            *(lpsrvr->m_pfAvail) = FALSE;
                        }
                    }
#endif // KEVINRO_OLDCODE
                    intrDebugOut((DEB_DDE_INIT,"SrvrWndProc Child Init\n"));
                    return fAckSent;
                }
                break;
            }

            // We can enterain this client. Put him in our client list
            // and acknowledge the initiate.

            if (!AddClient ((LPHANDLE)&lpsrvr->m_hcli, (HWND)wParam,(HWND)/*fLocked*/FALSE))
            {
                break;
            }

            //
            // Now its time to grab up the class factory from the class
            // factory table. When this window was created, the class factory
            // was available. However, it is possible that it has already
            // been claimed by someone else. So, we try grabbing it (which
            // normally should succeed). If it fails, then delete the client
            // and don't acknowledge.
            //

            if (lpsrvr->m_pClassFactory == NULL)
            {
                DdeClassInfo ddeInfo;
                ddeInfo.dwContextMask = CLSCTX_LOCAL_SERVER |
                                        CLSCTX_INPROC_SERVER;
                intrDebugOut((DEB_DDE_INIT,"SrvrWndProc getting class factory\n"));
                //
                // The following asks for control of the class
                // factory in the case of a single use class
                //
                ddeInfo.fClaimFactory = TRUE;
                ddeInfo.dwRegistrationKey = lpsrvr->m_dwClassFactoryKey;

                if (CCGetClassInformationFromKey(&ddeInfo) == FALSE)
                {
                    intrDebugOut((DEB_IERROR,"SrvrWndProc failed to get class factory\n"));
                    //
                    // Whoops, we were not able to grab the class factory
                    // Cleanup and hop out
                    if (!FindClient ((LPHANDLE)lpsrvr->m_hcli,(HWND)wParam, TRUE))
                    {
                        intrAssert(!"FindClient failed\n");
                    }
                    return(0);
                }
                lpsrvr->m_pClassFactory = (IClassFactory *)ddeInfo.punk;
                lpsrvr->m_fcfFlags = ddeInfo.dwFlags;
            }

            intrAssert(lpsrvr->m_pClassFactory != NULL);

            lpsrvr->m_cSrvrClients++;

            lpsrvr->Lock (TRUE, (HWND)wParam);

            // Post acknowledge
            DuplicateAtom (LOWORD(lParam));
            DuplicateAtom (HIWORD(lParam));
            SSSendMessage ((HWND)wParam, WM_DDE_ACK, (WPARAM)hwnd, lParam);


            return 1L; // fAckSent==TRUE
            VDATEHEAP();
            break;


    case WM_DDE_EXECUTE:
            VDATEHEAP();
            hwnd = ConvertToFullHWND(hwndIn);

            lpsrvr = (LPSRVR)GetWindowLongPtr (hwnd, 0);

            hdata = GET_WM_DDE_EXECUTE_HDATA(wParam,lParam);

#ifdef  FIREWALLS
            AssertSz (lpsrvr, "No server  handle in server window");
#endif

            intrDebugOut((DEB_ITRACE,"SrvrWndProc WM_DDE_EXECUTE\n"));

#ifdef  FIREWALLS
            // find the client in the client list.
            hwndClient = FindClient (lpsrvr->m_hcli, (HWND)wParam, FALSE);
            AssertSz (hwndClient, "Client is missing from the server")
#endif
            // Are we terminating
            if (lpsrvr->m_bTerminate) {
                intrDebugOut((DEB_ITRACE,
                              "SrvrWndProc WM_DDE_EXECUTE ignored for TERMINATE\n"));
                // !!! are we supposed to free the data
                GlobalFree (hdata);
                break;
            }

            retval = SrvrHandleIncomingCall(lpsrvr,hwnd,hdata,(HWND)wParam);

            if (NOERROR!=retval)
            {
                intrDebugOut((DEB_IERROR,
                              "SrvrWndProc SrvrHandleIncomingCall fail %x\n",
                              retval));
            }
            SET_MSG_STATUS (retval, status)

            if (!lpsrvr->m_bTerminate)
            {
                // REVIEW: We are making an assumption that, we will not be posting
                // any DDE messages because of calling the SrvrExecute.
                // If we post any messages, before we post the acknowledge
                // we will be in trouble.

                lParam = MAKE_DDE_LPARAM(WM_DDE_ACK,status, hdata);

                intrDebugOut((DEB_ITRACE,
                              "SrvrWndProc WM_DDE_EXECUTE sending %x for ack\n",status));

                // Post the acknowledge to the client
                if (!PostMessageToClient ((HWND) wParam,
                                          WM_DDE_ACK, (WPARAM) hwnd, lParam)) {
                    // if the window died or post failed, delete the atom.
                    GlobalFree (hdata);
                    DDEFREE(WM_DDE_ACK,lParam);
                }
            }
            VDATEHEAP();
            break;



    case WM_DDE_TERMINATE:
            intrDebugOut((DEB_ITRACE,
                          "SrvrWndProc WM_DDE_TERMINATE\n"));

            hwnd = ConvertToFullHWND(hwndIn);

            lpsrvr = (LPSRVR)GetWindowLongPtr (hwnd, 0);

#ifdef  FIREWALLS
            // find the client in the client list.
            hwndClient = FindClient (lpsrvr->m_hcli, (HWND)wParam, FALSE);
            AssertSz (hwndClient, "Client is missing from the server")
#endif
            Putsi (lpsrvr->m_bTerminate);
            if (lpsrvr->m_bTerminate)
            {
                AssertSz (0, "Unexpected code path");
            }
            else
            {
                // If client initiated the terminate. post matching terminate
                PostMessageToClient ((HWND)wParam,
                                      WM_DDE_TERMINATE,
                                      (WPARAM) hwnd,
                                      NULL);
                --lpsrvr->m_cSrvrClients;
                if (0==lpsrvr->m_cSrvrClients
                    && lpsrvr->QueryRevokeClassFactory())
                {
#ifdef KEVINRO_OLD_CODE
                    if (lpsrvr->m_phwndDde)
                    {
                        // Remove from class factory table
                        *(lpsrvr->m_phwndDde) = (HWND)0;
                    }
#endif // KEVINRO_OLD_CODE
                    fRevoke = TRUE;
                }

                lpsrvr->Lock (FALSE, (HWND)wParam); // Unlock server
                FindClient (lpsrvr->m_hcli, (HWND)wParam, /*fDelete*/TRUE);

                if (fRevoke)
                {
                    lpsrvr->Revoke();
                }
            }
            break;


       case WM_DDE_REQUEST:
            aItem = GET_WM_DDE_REQUEST_ITEM(wParam,lParam);

            hwnd = ConvertToFullHWND(hwndIn);

            lpsrvr = (LPSRVR)GetWindowLongPtr (hwnd, 0);

            intrDebugOut((DEB_ITRACE,
                          "SrvrWndProc WM_DDE_REQUEST(aItem=%x)\n",aItem));

            if (lpsrvr->m_bTerminate || !IsWindowValid ((HWND) wParam))
            {
                goto RequestErr;
            }

            if(RequestDataStd (aItem, (HANDLE FAR *)&hdata) != NOERROR)
            {

                lParam = MAKE_DDE_LPARAM(WM_DDE_ACK,0x8000,aItem);

                // if request failed, then acknowledge with error.
                if (!PostMessageToClient ((HWND)wParam, WM_DDE_ACK,
                                                        (WPARAM) hwnd, lParam))
                {
                    DDEFREE(WM_DDE_ACK,lParam);
RequestErr:
                    if (aItem)
                    {
                        GlobalDeleteAtom (aItem);
                    }

                }
            }
            else
            {
                lParam = MAKE_DDE_LPARAM(WM_DDE_REQUEST, hdata, aItem);

                // post the data message and we are not asking for any
                // acknowledge.

                if (!PostMessageToClient ((HWND)wParam, WM_DDE_DATA,
                                                        (WPARAM) hwnd, lParam))
                {
                    GlobalFree (hdata);
                    DDEFREE(WM_DDE_REQUEST,lParam);
                    goto RequestErr;
                }
            }
            break;

    case WM_DONOTDESTROY:
            intrDebugOut((DEB_ITRACE,
                          "SrvrWndProc WM_DONOTDESTROY %x\n",
                          wParam));

            //
            // This message is only sent by 32-bit code that has been
            // given our full handle
            //

            lpsrvr = (LPSRVR)GetWindowLongPtr (hwndIn, 0);

            //
            // The WM_DONOTDESTROY message tells the server how to
            // handle the following WM_USER message. If wParam is set,
            // then the m_fDoNotDestroyWindow flag will be set, which
            // keeps us from destroying the server window. If cleared,
            // it will enable the destruction. This message is sent
            // from the MaybeCreateDocWindow routine
            //

            lpsrvr->m_fDoNotDestroyWindow = (BOOL) wParam;
            return 0;
            break;

    case WM_USER:
            intrDebugOut((DEB_ITRACE,
                          "SrvrWndProc WM_USER\n"));
            //
            // This message is only sent by 32-bit code that has been
            // given our full handle
            //

            lpsrvr = (LPSRVR)GetWindowLongPtr (hwndIn, 0);

            // cftable.cpp sends a WM_USER message to destory the DDE
            // server window when a 2.0 client has connected to a
            // SDI 2.0 server (and no 1.0 client should be allowed to also
            // connect.
            // cftable.cpp cannot call RemDdeRevokeClassFactory directly
            // becuase they may be in different processes.
            //
            // The m_fDoNotDestroyWindow flag is used by
            // MaybeCreateDocWindow in the case that the server is a
            // single use server, and revokes its class factory when
            // an object is created. MaybeCreateDocWindow will set this
            // flag, telling us to ignore the message.
            //
            // returning 0 means we did destroy, 1 means we did not.

            if (!lpsrvr->m_fDoNotDestroyWindow)
            {
                RemDdeRevokeClassFactory(lpsrvr);
                return(0);
            }
            return 1;
            break;

    default:
            return SSDefWindowProc (hwndIn, msg, wParam, lParam);
    }

    return 0L;
}

//+---------------------------------------------------------------------------
//
//  Method:     CDDEServer::HandleInitMsg
//
//  Synopsis:   Determine if we are going to handle the INITIATE message.
//
//  Effects:
//
//  Arguments:  [lParam] --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:
//
//  History:    5-28-94   kevinro Commented/cleaned
//
//  Notes:
//
//----------------------------------------------------------------------------
INTERNAL_(BOOL) CDDEServer::HandleInitMsg(LPARAM    lParam)
{

    // If it is not system or Ole, this is not the server.
    if (!((aSysTopic == (ATOM)(HIWORD(lParam))) || (aOLE == (ATOM)(HIWORD(lParam)))))
    {
        return FALSE;
    }
    Assert (m_fcfFlags<=REGCLS_MULTI_SEPARATE);

    // single instance MDI accept
    if (m_fcfFlags != REGCLS_SINGLEUSE)
    {
        return TRUE;
    }

    // this server is multiple instance. So, check for any clients or docs.
    if (!GetWindow (m_hwnd, GW_CHILD) && 0==m_cSrvrClients)
        return TRUE;

    return FALSE;
}



// AddClient: Adds  a  client entry to the list.
// Each client entry is a pair of handles; key handle
// and data handle.  Ecah list entry contains space for
// MAX_LIST of pairs of handles.

INTERNAL_(BOOL)   AddClient
(
LPHANDLE    lphead,         // ptr to loc which contains the head handle
HANDLE      hkey,           // key
HANDLE      hdata           // hdata
)
{

    HANDLE          hcli = NULL;
    HANDLE          hcliPrev = NULL;
    PCLILIST        pcli;
    HANDLE          *phandle;


    hcli = *lphead;

    // if the entry is already present, return error.
    if (hcli && FindClient (hcli, hkey, FALSE))
        return FALSE;

    while (hcli) {
        if (hcliPrev)
            LocalUnlock (hcliPrev);

        if ((pcli = (PCLILIST) LocalLock (hcli)) == NULL)
            return FALSE;

        phandle = (HANDLE *) pcli->info;
        while (phandle < (HANDLE *)(pcli + 1)) {
            if (*phandle == NULL) {
                *phandle++ = hkey;
                *phandle++ = hdata;
                LocalUnlock (hcli);
                return TRUE;
            }
            phandle++;
            phandle++;
        }
        hcliPrev = hcli;
        hcli = pcli->hcliNext;
        lphead = (LPHANDLE)&pcli->hcliNext;
    }

    // not in the list.
    hcli = LocalAlloc (LMEM_MOVEABLE | LMEM_ZEROINIT, sizeof (CLILIST));
    if (hcli == NULL)
        goto  errRtn;

    if ((pcli = (PCLILIST) LocalLock (hcli)) == NULL)
        goto errRtn;

    // set the link to this handle in the previous entry
    *lphead = hcli;
    if (hcliPrev)
        LocalUnlock (hcliPrev);

    phandle = (HANDLE *) pcli->info;
    *phandle++ = hkey;
    *phandle++ = hdata;
    LocalUnlock (hcli);
    return TRUE;

errRtn:

    if (hcliPrev)
        LocalUnlock (hcliPrev);

    if (hcli)
        LocalFree (hcli);

    return FALSE;

}


// FindClient: finds a client and deletes the client if necessary.
INTERNAL_(HANDLE) FindClient
(
HANDLE      hcli,
HANDLE      hkey,
BOOL        bDelete
)
{
    HANDLE        hcliPrev = NULL;
    PCLILIST      pcli;
    HANDLE        *phandle;
    HANDLE        hdata;

    while (hcli) {
        if ((pcli = (PCLILIST) LocalLock (hcli)) == NULL)
            return FALSE;

        phandle = (HANDLE *) pcli->info;
        while (phandle < (HANDLE *)(pcli + 1)) {
            if (*phandle == hkey) {
                if (bDelete)
                    *phandle = NULL;

                hdata = *++phandle;
                LocalUnlock (hcli);
                return hdata;
            }
            phandle++;
            phandle++;
        }
        hcliPrev = hcli;
        hcli = pcli->hcliNext;
        LocalUnlock (hcliPrev);

    }
    return NULL;
}


//+---------------------------------------------------------------------------
//
//  Method:     CDDEServer::SrvrExecute
//
//  Synopsis:   takes care of the WM_DDE_EXECUTE for the server.
//
//  Effects:    Parses the EXECUTE string, and determines what it should be
//              done.
//
//  Arguments:  [hwnd] --   Server window
//              [hdata] --  Handle to EXECUTE string
//              [hwndClient] -- Client window
//
//  Requires:
//      hdata is an ANSI string. It was passed to us by a DDE client.
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:
//
//  History:    6-05-94   kevinro Commented/cleaned
//
//  Notes:
//
//----------------------------------------------------------------------------
INTERNAL CDDEServer::SrvrExecute
(
HWND        hwnd,
HANDLE      hdata,
HWND        hwndClient
)
{
    intrDebugOut((DEB_ITRACE,
                  "%x _IN CDDESrvr::SrvrExecute(hwnd=%x,hdata=%x,hwndClient=%x)\n",
                  this,
                  hwnd,
                  hdata,
                  hwndClient));

    ATOM            aCmd;
    BOOL            fActivate;

    LPSTR           lpdata = NULL;
    HANDLE          hdup   = NULL;
    HRESULT         hresult = E_UNEXPECTED;

    LPSTR           lpdocname;
    LPSTR           lptemplate;
    LPCLIENT        lpdocClient = NULL;
    LPSTR           lpnextarg;
    LPSTR           lpclassname;
    LPSTR           lpitemname;
    LPSTR           lpopt;
    CLSID           clsid;
    WORD            wCmdType;
    BOOL            bCreateInst = FALSE;
        LPUNKNOWN               pUnk = NULL;

    LPPERSISTSTORAGE pPersistStg=NULL;

    // REVIEW: if any methods called on the objects genarate DDE messages
    // before we return from Execute, we will be in trouble.


    // REVIEW: this code can be lot simplified if we do the argument scanning
    // seperately and return the ptrs to the args. Rewrite later on.

    ErrZS (hdup = UtDupGlobal (hdata,GMEM_MOVEABLE), E_OUTOFMEMORY);

    ErrZS (lpdata  = (LPSTR)GlobalLock (hdup), E_OUTOFMEMORY);

    intrDebugOut((DEB_ITRACE,
                  "CDDESrvr::SrvrExecute(lpdata = %s)\n",lpdata));

    if (*lpdata++ != '[') // commands start with the left sqaure bracket
    {
        hresult = ResultFromScode (RPC_E_DDE_SYNTAX_EXECUTE);
        goto  errRtn;
    }

    hresult = ReportResult(0, RPC_E_DDE_SYNTAX_EXECUTE, 0, 0);
    // scan upto the first arg
    if (!(wCmdType = ScanCommand (lpdata, WT_SRVR, &lpdocname, &aCmd)))
        goto  errRtn;

    if (wCmdType == NON_OLE_COMMAND)
    {
        if (!UtilQueryProtocol (m_aClass, PROTOCOL_EXECUTE))
            hresult = ReportResult(0, RPC_E_DDE_PROTOCOL, 0, 0);
        else {
            // REVIEW: StdExecute has to be mapped on to the StdCommandProtocol
            // What command do we map on to?

            AssertSz (0, "StdExecute is being called for server");
        }

        goto errRtn1;
    }

    if (aCmd == aStdExit)
    {
        if (*lpdocname)
            goto errRtn1;

        hresult = NOERROR;
        // REVIEW: Do we have to initiate any terminations from the
        // the servr side? Check how this works with excel.
        goto end2;
    }

    // scan the next argument.
    if (!(lpnextarg = ScanArg(lpdocname)))
        goto errRtn;

    //////////////////////////////////////////////////////////////////////////
    //
    // [StdShowItem("docname", "itemname"[, "true"])]
    //
    //////////////////////////////////////////////////////////////////////////

    if (aCmd == aStdShowItem) {

        // first find the documnet. If the doc does not exist, then
        // blow it off.

        if (!(lpdocClient = FindDocObj (lpdocname)))
            goto errRtn1;

        lpitemname = lpnextarg;

        if( !(lpopt = ScanArg(lpitemname)))
            goto errRtn1;

        // scan for the optional parameter
        // Optional can be only TRUE or FALSE.

        fActivate = FALSE;
        if (*lpopt) {

            if( !(lpnextarg = ScanBoolArg (lpopt, (BOOL FAR *)&fActivate)))
                goto errRtn1;

            if (*lpnextarg)
                goto errRtn1;

        }


        // scan it. But, igonre the arg.
        hresult = lpdocClient->DocShowItem (lpitemname, !fActivate);
        goto end2;



    }

    //////////////////////////////////////////////////////////////////////////
    //
    // [StdCloseDocument ("docname")]
    //
    //////////////////////////////////////////////////////////////////////////

    if (aCmd == aStdClose) {
        if (!(lpdocClient = FindDocObj (lpdocname)))
            goto errRtn1;

        if (*lpnextarg)
            goto errRtn1;

        // REVIEW: Do we have to do anything for shutting down the
        // the app? Is the client going to initiate the terminate?.
        // if we need to initiate the terminates, make sure we post
        // the ACK  first.

        lpdocClient->Revoke();
        goto end2;
    }


    if (aCmd == aStdOpen)
    {
        // find if any doc level object is already registerd.
        // if the object is registerd, then no need to call srvr app.
        if (FindDocObj (lpdocname))
        {
            // A client has already opened the document or user opened the
            // doc. We should do an addref to the docobj

#ifdef TRY
            if (m_cSrvrClients == 0)
                // Why are we doing this?
                hresult = lpdocClient->m_lpoleObj->AddRef();
            else
#endif
                hresult = NOERROR;
            goto end1;
        }
    }

    if (aCmd == aStdCreate || aCmd == aStdCreateFromTemplate) {
        lpclassname = lpdocname;
        lpdocname   = lpnextarg;
        if( !(lpnextarg = ScanArg(lpdocname)))
            goto errRtn1;

    }

    // check whether we can create/open more than one doc.

    if ((m_fcfFlags == REGCLS_SINGLEUSE) &&
            GetWindow (m_hwnd, GW_CHILD))
            goto errRtn;


    ErrZ (CLSIDFromAtom(m_aClass, &clsid));


    //
    // Generate a wide version of the name
    //

    WCHAR       awcWideDocName[MAX_STR];

    if (MultiByteToWideChar(CP_ACP,0,lpdocname,-1,awcWideDocName,MAX_STR) == FALSE)
    {
        Assert(!"Unable to convert characters");
        hresult = E_UNEXPECTED;
        goto errRtn;
    }

    //////////////////////////////////////////////////////////////////////////
    //
    // [StdOpenDocument ("docname")]
    //
    //////////////////////////////////////////////////////////////////////////

    // Document does not exist.
    if (aCmd == aStdOpen)
    {
        ErrRtnH (wClassesMatch (clsid, awcWideDocName));
        ErrRtnH (wFileBind (awcWideDocName, &pUnk));
    }


    ErrRtnH (CreateInstance (clsid, awcWideDocName, lpdocname, pUnk, &lpdocClient, hwndClient));
    bCreateInst = TRUE;

    if (aCmd == aStdOpen)
    {
        // Temporary flag to indicate someone will INITIATE on this doc.
        // The flag is reset after the INITITATE.
        // This is Yet-Another-Excel-Hack.  See ::QueryRevokeClassFactory
        lpdocClient->m_fCreatedNotConnected = TRUE;
    }
    else
    {
        lpdocClient->m_fEmbed = TRUE;
    }

    //////////////////////////////////////////////////////////////////////////
    //
    // [StdNewDocument ("classname", "docname")]
    //
    //////////////////////////////////////////////////////////////////////////

    if (aCmd == aStdCreate)
    {
        hresult = lpdocClient->DoInitNew();
        lpdocClient->m_fCreatedNotConnected = TRUE;
        goto end;
    }


    //////////////////////////////////////////////////////////////////////////
    //
    // [StdNewFormTemplate ("classname", "docname". "templatename)]
    //
    //////////////////////////////////////////////////////////////////////////
    if (aCmd == aStdCreateFromTemplate)
    {
        ErrRtnH (lpdocClient->DoInitNew());
        lpdocClient->m_fCreatedNotConnected = TRUE;
        IPersistFile FAR * lpPF;
        lptemplate = lpnextarg;

        if(!(lpnextarg = ScanArg(lpnextarg)))
        {
            goto errRtn;
        }


        hresult = lpdocClient->m_lpoleObj->QueryInterface(IID_IPersistFile,(LPLPVOID)&lpPF);
        if (hresult == NOERROR)
        {
            WCHAR awcWideTemplate[MAX_STR];

            if (MultiByteToWideChar(CP_ACP,0,lpdocname,-1,awcWideTemplate,MAX_STR) != FALSE)
            {
                hresult = lpPF->Load(awcWideTemplate, 0);
            }
            else
            {
                Assert(!"Unable to convert characters");
                lpPF->Release();
                hresult = E_UNEXPECTED;
                goto end;
            }

            lpPF->Release();
            lpdocClient->m_fEmbed = TRUE;
        }
        else
        {
            goto end;
        }
    }
    //////////////////////////////////////////////////////////////////////////
    //
    // [StdEditDocument ("docname")]
    //
    //////////////////////////////////////////////////////////////////////////
    // REVIEW: Do we have to call InitNew for editing an embedded object

    if (aCmd == aStdEdit)
    {
        lpdocClient->m_fEmbed = TRUE;
        lpdocClient->m_fGotEditNoPokeNativeYet = TRUE;
        lpdocClient->m_fCreatedNotConnected = TRUE;
        goto end;
    }

    intrDebugOut((DEB_IERROR,
                  "%x CDDESrvr::SrvrExecute Unknown command\n",
                  this));

end:

    if (hresult != NOERROR)
        goto errRtn;
end1:
    // make sure that the srg string is indeed terminated by
    // NULL.
    if (*lpnextarg)
    {
        hresult = RPC_E_DDE_SYNTAX_EXECUTE;
    }
errRtn:

   if ( hresult != NOERROR)
   {
        if (bCreateInst && lpdocClient)
        {
            lpdocClient->DestroyInstance ();
            lpdocClient = NULL;  //DestroyInstance invalidates the pointer
        }
   }

end2:
errRtn1:

   if (lpdata)
        GlobalUnlock (hdup);

   if (hdup)
        GlobalFree (hdup);
   if (pUnk)
                pUnk->Release();

   if (pPersistStg)
        pPersistStg->Release();

   Assert (GetScode(hresult) != E_UNEXPECTED);

   intrDebugOut((DEB_ITRACE,
                  "%x _OUT CDDESrvr::SrvrExecute hresult=%x\n",
                  this,
                  hresult));

   return hresult;
}




// Maybe CreateDocWindow
//
// Return NOERROR only if a doc window was created and it sent an ACK.
//


//+---------------------------------------------------------------------------
//
//  Function:   MaybeCreateDocWindow
//
//  Synopsis:   Determine if a DocWindow should be created
//
//  Effects:    Given a class, and a filename atom, determine if this thread
//              should be the server for this request.
//
//  Arguments:  [aClass] -- Class of object (PROGID)
//              [aFile] -- Filename (ATOM)
//              [hwndDdeServer] -- HWND of CDDEServer
//              [hwndSender] -- HWND of new requesting client
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    6-29-94   kevinro   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
 INTERNAL MaybeCreateDocWindow
    (ATOM aClass,
    ATOM aFile,
    HWND hwndDdeServer,
    HWND hwndSender)
{
    CLSID       clsid       = CLSID_NULL;
    LPUNKNOWN   pUnk        = NULL;
    HWND        hwndClient  = NULL;
    ULONG       fAckSent    = FALSE;
    LPSRVR      pDdeSrvr    = NULL;
    WCHAR       szFile [MAX_STR];
    BOOL        fTrue       = TRUE;
    BOOL        fRunningInSDI   = FALSE;
    HRESULT     hresult = NOERROR;
    IClassFactory *pcf = NULL;
    IPersistFile *ppf = NULL;
    DdeClassInfo        ddeClassInfo;

    intrDebugOut((DEB_DDE_INIT,
                  "MaybeCreateDocWindow(aClass=%x(%ws),aFile=%x,"
                  "hwndDdeServer=%x,hwndSender=%x\n",
                  aClass,wAtomName(aClass),aFile,hwndDdeServer,hwndSender));

    //
    // If the window isn't valid, it would be very bad.
    //
    if (!IsWindowValid(hwndDdeServer))
    {
        intrDebugOut((DEB_DDE_INIT,
                      "MaybeCreateDocWindow: hwndDdeServer is invalid\n"));
        hresult = E_UNEXPECTED;
        goto exitRtn;
    }

    //
    // We need the filename, which is passed in an Atom
    //
    Assert (IsFile (aFile));
    if (GlobalGetAtomName(aFile,szFile,MAX_STR) == 0)
    {
        //
        // The filename was not valid
        //
        hresult = S_FALSE;
        intrDebugOut((DEB_IERROR,
                      "MaybeCreateDocWindow Invalid file atom\n"));
        goto exitRtn;
    }

    intrDebugOut((DEB_DDE_INIT,
                  "MaybeCreateDocWindow File=(%ws)\n",
                  WIDECHECK(szFile)));

    //
    // Get the class of the object. The class was passed as an atom
    // in the INITIATE message.
    //
    if (CLSIDFromAtomWithTreatAs (&aClass, &clsid, NULL))
    {
        intrDebugOut((DEB_IERROR,
                      "MaybeCreateDocWindow CLSIDFromAtom failed\n"));

        hresult = S_FALSE;
        goto exitRtn;
    }

    if (CoIsOle1Class(clsid))
    {
        // we shouldn't even be looking at this INIT message
        hresult = S_FALSE;
        intrDebugOut((DEB_DDE_INIT,
                      "MaybeCreateDocWindow Its an OLE 1.0 class\n"));
        goto exitRtn;
    }

    //
    // First of three cases is to see if the object is running in our
    // local apartment. If it is, then this is the object we need to create
    // a DDEServer for.
    //
    // Otherwise, We are going to try and load this file.
    // Therefore, we need the class factory from the CFT.
    //
    // GetClassInformationForDde won't find a match if the class factory was
    // single use, and is now hidden or invalid.
    //
    // If there was no class information available, then we are going to
    // check to see if the object is in the local ROT. If it is in the
    // local ROT, then we will use it, since it is registered and
    // available for use by others
    //

    ddeClassInfo.dwContextMask = CLSCTX_LOCAL_SERVER | CLSCTX_INPROC_SERVER;
    ddeClassInfo.fClaimFactory = TRUE;

    if ( GetLocalRunningObjectForDde(szFile, &pUnk) == NOERROR)
    {
        intrDebugOut((DEB_DDE_INIT,
                      "Found %ws in ROT\n",WIDECHECK(szFile)));
        //
        // Elsewhere in the code, we need to know if this is an SDI server.
        // The old code determined this by detecting that there is a running
        // object, and there was no class factory registered.
        // This is sick, and obscene. Compatibilities says we need to get the
        // class info anyway. However, we don't want to claim it.
        //

        ddeClassInfo.fClaimFactory = FALSE;
        fRunningInSDI = !CCGetClassInformationForDde(clsid,&ddeClassInfo);
    }
    else if (!CCGetClassInformationForDde(clsid,&ddeClassInfo))
    {
        intrDebugOut((DEB_IERROR,
                      "No class registered for %ws\n",WIDECHECK(szFile)));

        hresult = S_FALSE;
        goto exitRtn;
    }
    else
    {
        //
        // Otherwise, we are registered as the server for this class. This
        // means we can create this object.
        //
        // A 1.0 client will have launched the server with a command line
        // like server.exe -Embedding filename The server ignored the filename
        // so now we must make it load the file by binding the moniker.
        //
        // KevinRo: The old code did a bind moniker here, on the filename,
        // which went through the ROT, didn't find the object, so went for
        // a server. This isn't terribly safe, since we could end up binding
        // out of process when we really didn't mean to. So, I have made this
        // routine just use the ClassFactory we retrieve from the
        // local class factory table.
        //

        intrDebugOut((DEB_DDE_INIT,
                      "Found classinfo: Loading %ws\n",WIDECHECK(szFile)));


        //
        // Need to insure that the server doesn't go away on us. The following
        // tells the server not to destroy itself.
        //
        SSSendMessage(hwndDdeServer,WM_DONOTDESTROY,TRUE,0);

        intrAssert(ddeClassInfo.punk != NULL);
        pcf = (IClassFactory *) ddeClassInfo.punk;

        hresult = pcf->CreateInstance(NULL,IID_IUnknown,(void **)&pUnk);

        if (hresult != NOERROR)
        {
            intrDebugOut((DEB_IERROR,
                      "MaybeCreateDocWindow CreateInstancefailed File=(%ws)\n",
                          WIDECHECK(szFile)));
            goto sndMsg;
        }

        //
        // Get the IPersistFile interface, and ask the object to load
        // itself.
        //
        hresult = pUnk->QueryInterface(IID_IPersistFile,(void **)&ppf);
        if (hresult != NOERROR)
        {
            intrDebugOut((DEB_IERROR,
                          "MaybeCreateDocWindow QI IPF failed File=(%ws)\n",
                          WIDECHECK(szFile)));
            goto sndMsg;
        }
        //
        // Attempt to load the object. The flags STGM_READWRITE are the
        // same default values used by a standard bind context.
        //
        hresult = ppf->Load(szFile,STGM_READWRITE);
        if (hresult != NOERROR)
        {
            intrDebugOut((DEB_IERROR,
                          "MaybeCreateDocWindow ppf->Load(%ws) failed %x\n",
                          WIDECHECK(szFile),
                          hresult));
            goto sndMsg;
        }
sndMsg:
        SSSendMessage(hwndDdeServer,WM_DONOTDESTROY,FALSE,0);
        if (hresult != NOERROR)
        {
            goto exitRtn;

        }
        intrDebugOut((DEB_DDE_INIT,
                      "Loading %ws complete\n",WIDECHECK(szFile)));

    }


    intrAssert(IsWindowValid(hwndDdeServer));
    intrAssert (pUnk);

    pDdeSrvr = (LPSRVR) GetWindowLongPtr (hwndDdeServer, 0);
    if (pDdeSrvr == NULL)
    {
        intrAssert(pDdeSrvr != NULL);
        hresult = E_UNEXPECTED;
        goto exitRtn;
    }

    // This actually creates the doc window as a child of the server window
    // Do not set the client site becuase this is a link.
    hresult = CDefClient::Create (pDdeSrvr,
                                  pUnk,
                                  szFile,
                                  /*fSetClientSite*/FALSE,
                                  /*fDoAdvise*/TRUE,
                                  fRunningInSDI,
                                  &hwndClient);

    if (hresult != NOERROR)
    {
        intrDebugOut((DEB_IERROR,
                      "MaybeCreateDocWindow CDefClient::Create failed %x\n",
                      hresult));
        goto exitRtn;
    }

    Assert (IsWindowValid (hwndClient));

    //
    // Pass along the original DDE_INIT to the newly created window.
    // That window should respond by sending an ACK to the 1.0 client.
    //
    fAckSent = (ULONG) SSSendMessage (hwndClient,
                            WM_DDE_INITIATE,
                            (WPARAM) hwndSender,
                            MAKELONG(aClass, aFile));
    if (!fAckSent)
    {
        intrDebugOut((DEB_IERROR,
                      "MaybeCreateDocWindow !fAckSent\n"));
        hresult = CO_E_APPDIDNTREG;
    }

exitRtn:

    if (ppf)
    {
        ppf->Release();
    }
    if (pUnk)
    {
        pUnk->Release();
    }
    if (pcf)
    {
        pcf->Release();
    }

    intrDebugOut((DEB_DDE_INIT,
                  "MaybeCreateDocWindow returns %x\n",
                  hresult));
    return hresult;
}


//+---------------------------------------------------------------------------
//
//  Function:   SendMsgToChildren
//
//  Synopsis:   This routine sends the msg to all child windows.
//
//  Arguments:  [hwnd] -- Hwnd of parent window
//              [msg] --  Message and parameters to send
//              [wParam] --
//              [lParam] --
//
//  Notes: This routine will stop on the first non-zero return code.
//
//----------------------------------------------------------------------------
BOOL SendMsgToChildren (HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    intrDebugOut((DEB_ITRACE,
                  "0 _IN SendMsgToChildren(hwnd=%x,msg=%x,wParam=%x,lParam=%x)\n",
                  hwnd,msg,wParam,lParam));

    BOOL fAckSent = FALSE;

    hwnd = GetWindow(hwnd, GW_CHILD);

    //
    // This routine is to be called only from one place, which is
    // in the handling of WM_DDE_INITIATE. Because of that, we will terminate
    // the loop on the first non-zero return code.
    //
    Assert (msg == WM_DDE_INITIATE);

    while (hwnd)
    {
        intrDebugOut((DEB_ITRACE,"   SendMsgToChildren send to hwnd=%x\n",hwnd));

        if (fAckSent = (1L==SSSendMessage (hwnd, msg, wParam, lParam)))
        {
            break;
        }

        hwnd = GetWindow (hwnd, GW_HWNDNEXT);
    }

    intrDebugOut((DEB_ITRACE,"0 OUT SendMsgToChildren returns %x\n",fAckSent));
    return(fAckSent);
}


//+---------------------------------------------------------------------------
//
//  Function:   SendInitMsgToChildren
//
//  Synopsis:   Sends an init message to all child windows of the hwnd
//
//  Effects:    This routine will send an init message to all children
//              of the given window. It is assuming that the lParam is
//              the atom that contains the topic (ie filename) of the
//              object being looked for.
//
//  Arguments:  [hwnd] -- hwnd of server window
//              [msg] -- MSG to send
//              [wParam] -- hwnd of client window
//              [lParam] -- HIWORD(lParam) is atom of filename
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    6-28-94   kevinro   Commented
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOL SendInitMsgToChildren (HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    intrDebugOut((DEB_DDE_INIT,
                  "0 _IN SendInitMsgToChildren(hwnd=%x,msg=%x,wParam=%x,lParam=%x)\n",
                  hwnd,msg,wParam,lParam));

    BOOL fAckSent = FALSE;

    fAckSent = SendMsgToChildren(hwnd,msg,wParam,lParam);

    //
    // If no windows acknowledged, then we might need to create a doc window
    //
    if (!fAckSent)
    {
        ATOM aTopic = HIWORD(lParam);
        Assert (IsAtom(aTopic));

        // if someone's trying to initiate on a filename, i.e., for a link
        // then create the doc window on demand because 2.0 servers do not
        // register doc windows.  They don't even accept "-Embedding filename"
        // on the command line
        if (aTopic != aOLE && aTopic != aSysTopic && IsFile (aTopic))
        {
            intrDebugOut((DEB_DDE_INIT,"   Initiate for link %ws\n",wAtomName(aTopic)));
            HRESULT hresult = MaybeCreateDocWindow (LOWORD(lParam), aTopic,
                                                    hwnd, (HWND)wParam);

            fAckSent = (NOERROR==hresult);
        }
    }
    intrDebugOut((DEB_DDE_INIT,
                  "0 _OUT SendInitMsgToChildren fAckSent=%x\n",fAckSent));
    return fAckSent;
}



INTERNAL_(HRESULT)   RequestDataStd
(
ATOM        aItem,
LPHANDLE    lphdde
)
{


    HANDLE  hnew = NULL;

    if (!aItem)
        goto errRtn;

    if (aItem == aEditItems){
        hnew = MakeGlobal ("StdHostNames\tStdDocDimensions\tStdTargetDevice");
        goto   PostData;

    }

    if (aItem == aProtocols) {
        hnew = MakeGlobal ("Embedding\tStdFileEditing");
        goto   PostData;
    }

    if (aItem == aTopics) {
        hnew = MakeGlobal ("Doc");
        goto   PostData;
    }

    if (aItem == aFormats) {
        hnew = MakeGlobal ("Picture\tBitmap");
        goto   PostData;
    }

    if (aItem == aStatus) {
        hnew = MakeGlobal ("Ready");
        goto   PostData;
    }

    // format we do not understand.
    goto errRtn;

PostData:

    // Duplicate the DDE data
    if (MakeDDEData (hnew, CF_TEXT, lphdde, TRUE)){
        // !!! why are we duplicating the atom.
        DuplicateAtom (aItem);
        return NOERROR;
    }
errRtn:
    return ReportResult(0, S_FALSE, 0, 0);
}


//IsSingleServerInstance: returns true if the app is single server app else
//false.

INTERNAL_(BOOL)  IsSingleServerInstance ()
{
    HWND    hwnd;
    WORD    cnt = 0;
    HTASK   hTask;
    DdeCHAR    buf[MAX_STR];

    hwnd  = GetWindow (GetDesktopWindow(), GW_CHILD);
    hTask = GetCurrentThreadId();

    while (hwnd) {
        if (hTask == ((HTASK) GetWindowThreadProcessId (hwnd,NULL))) {
            DdeGetClassName (hwnd, buf, MAX_STR);
            if (Ddelstrcmp (buf, SRVR_CLASS) == 0)
                cnt++;
        }
        hwnd = GetWindow (hwnd, GW_HWNDNEXT);
    }
#ifdef  FIREWALLS
     AssertSz (cnt > 0, "srvr window instance count is zero");
#endif
    if (cnt == 1)
        return TRUE;
    else
        return FALSE;

}


// QueryRevokeClassFactory: returns FALSE if there are clients
// connected tothis class factory;
INTERNAL_(BOOL)        CDDEServer::QueryRevokeClassFactory ()
{

    HWND        hwnd;
    LPCLIENT    lpclient;

    Assert (IsWindow (m_hwnd));
    hwnd = GetWindow (m_hwnd, GW_CHILD);
    while (hwnd)
    {
        Assert (IsWindow (hwnd));
        lpclient = (LPCLIENT)GetWindowLongPtr (hwnd, 0);
        if (lpclient->m_cClients != 0 || lpclient->m_fCreatedNotConnected)
            return FALSE;
        hwnd = GetWindow (hwnd, GW_HWNDNEXT);
    }
    return TRUE;
}



//+---------------------------------------------------------------------------
//
//  Method:     CDDEServer::CreateInstance
//
//  Synopsis:   Create an instance of a document
//
//  Effects:
//
//  Arguments:  [lpclassName] --
//              [lpWidedocName] --
//              [lpdocName] --
//              [pUnk] --
//              [lplpdocClient] --
//              [hwndClient] --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:
//
//  History:    5-30-94   kevinro Commented/cleaned
//
//  Notes:
//
//----------------------------------------------------------------------------
INTERNAL CDDEServer::CreateInstance
(
REFCLSID        lpclassName,
LPOLESTR        lpWidedocName,
LPSTR           lpdocName,
LPUNKNOWN       pUnk,
LPCLIENT FAR*   lplpdocClient,
HWND            hwndClient)
{
    intrDebugOut((DEB_ITRACE,
                  "%p _IN CDDEServer::CreateInstance(lpWidedocName=%ws,hwndClient=%x)\n",
                  this,
                  WIDECHECK(lpWidedocName),
                  hwndClient));


    LPUNKNOWN           pUnk2=NULL;
    LPOLEOBJECT     lpoleObj= NULL;       // unknown object
    HRESULT         hresult;

    ChkS(this);

    if (NULL==pUnk)
    {
        Assert (m_pClassFactory);
        hresult = m_pClassFactory->CreateInstance (NULL, IID_IUnknown, (LPLPVOID)&pUnk2);

        if (hresult != NOERROR)
        {
            return hresult;
        }

        // Now that we have *used* the DDE server window, we can unlock
        // the server.
        // The OLE1 OleLockServer API opens a dummy DDE system channel
        // and just leaves it open until OleunlockServer is called.
        // Since we have now used this channel, we know it was not created
        // for the purpose of locking the server.
        this->Lock (FALSE, hwndClient);

        // if it is an SDI app, we must revoke the ClassFactory after using it
        // it is only good for "one-shot" createinstance call.
        if (m_fcfFlags == REGCLS_SINGLEUSE)
        {
            m_pClassFactory->Release();         // done with the ClassFactory
            Puts ("NULLing m_pCF\r\n");
            m_pClassFactory = NULL;
        }
    }
    else
    {
        pUnk2 = pUnk;
        pUnk->AddRef();
    }

    hresult = CDefClient::Create ((LPSRVR)this,
                                  pUnk2,
                                  lpWidedocName,
                                  /*fSetClientSite*/FALSE,
                                  /*fDoAdvise*/pUnk!=NULL);

    intrAssert (pUnk2 != NULL);
    if (pUnk2 != NULL)
    {
        pUnk2->Release();
    }

    pUnk2 = NULL;

    // REVIEW: error recovery
    if (!(*lplpdocClient = FindDocObj (lpdocName)))
    {
        intrAssert(!"Document created but not found");
    }
    else
    {
        // set the server instance flag so that WM_DDE_INITIATE will not icrement
        // the ref count. (EXCEL BUG)
        (*lplpdocClient)->m_bCreateInst = TRUE;
    }
    intrDebugOut((DEB_ITRACE,
                  "%p _OUT CDDEServer::CreateInstance hresult=%x\n",
                  this,hresult));
    return hresult;
}


INTERNAL_(void) CDDEServer::Lock
        (BOOL fLock,      // lock or unlock?
        HWND hwndClient)  // on behalf of which window?
{
    intrDebugOut((DEB_ITRACE,
                  "%p _IN CDDEServer::Lock(fLock=%x,hwndCient=%x)\n",
                  this,
                  fLock,
                  hwndClient));

    VDATEHEAP();
    BOOL fIsLocked = FindClient (m_hcli, hwndClient, /*fDelete*/FALSE) != NULL;

    if (fLock && !fIsLocked)
    {
        if (m_pClassFactory)
        {
            intrDebugOut((DEB_ITRACE,
                          "%p ::Locking %x\n",
                          this,
                          m_pClassFactory));

            m_pClassFactory->LockServer (TRUE);
            // Only way to change the data associated with a client window
            // is to delete it and re-add it with the new data.
            FindClient (m_hcli, hwndClient, /*fDelete*/ TRUE);
            AddClient (&m_hcli, hwndClient, (HANDLE) TRUE); // mark as locked
        }
    }
    else if (!fLock && fIsLocked)
    {
        if (m_pClassFactory)
        {
            intrDebugOut((DEB_ITRACE,
                          "%p ::UnLocking %x\n",
                          this,
                          m_pClassFactory));
            m_pClassFactory->LockServer (FALSE);
            FindClient (m_hcli, hwndClient, /*fDelete*/ TRUE);
            AddClient (&m_hcli, hwndClient, (HANDLE) FALSE); //mark as unlocked
        }
    }
    VDATEHEAP();
    intrDebugOut((DEB_ITRACE,
                  "%p _OUT CDDEServer::Lock(fLock=%x,hwndCient=%x)\n",
                  this,
                  fLock,
                  hwndClient));
}





INTERNAL CDefClient::DestroyInstance
    (void)
{
    Puts ("DestroyInstance\r\n");
    // We just created the instance. we ran into error.
    // just call Release.
    m_pUnkOuter->AddRef();
    ReleaseObjPtrs();
    Verify (0==m_pUnkOuter->Release());
    //  "this" should be deleted now
    return NOERROR;
}



INTERNAL CDefClient::SetClientSite
 (void)
{
    HRESULT hresult = m_lpoleObj->SetClientSite (&m_OleClientSite);
    if (hresult==NOERROR)
    {
        m_fDidSetClientSite = TRUE;
    }
    else
    {
        Warn ("SetClientSite failed");
    }
    return hresult;
}


// implementations of IRpcStubBuffer methods
STDMETHODIMP CDdeServerCallMgr::QueryInterface
    ( REFIID iid, LPVOID * ppvObj )
{
    return S_OK;
}

STDMETHODIMP_(ULONG)CDdeServerCallMgr::AddRef ()
{
    return 1;
}

STDMETHODIMP_(ULONG)CDdeServerCallMgr::Release ()
{
    return 1;
}


STDMETHODIMP CDdeServerCallMgr::Connect
    (IUnknown * pUnkServer )
{
    // do nothing
    return S_OK;
}

STDMETHODIMP_(void) CDdeServerCallMgr::Disconnect
    ()
{
    // do nothing
}

STDMETHODIMP_(IRpcStubBuffer*) CDdeServerCallMgr::IsIIDSupported
    (REFIID riid)
{
    // do nothing
    return NULL;
}


STDMETHODIMP_(ULONG) CDdeServerCallMgr::CountRefs
    ()
{
    // do nothing
    return 1;
}

STDMETHODIMP CDdeServerCallMgr::DebugServerQueryInterface
    (void ** ppv )
{
    // do nothing
    *ppv = NULL;
    return S_OK;
}


STDMETHODIMP_(void) CDdeServerCallMgr::DebugServerRelease
    (void * pv)
{
    // do nothing
}

STDMETHODIMP CDdeServerCallMgr::Invoke
    (RPCOLEMESSAGE *_prpcmsg, IRpcChannelBuffer *_pRpcChannelBuffer)
{
    DISPATCHDATA *pdispdata = (PDISPATCHDATA) _prpcmsg->Buffer;
    return DispatchCall( pdispdata );
}


// Provided IRpcChannelBuffer methods (for callback methods side)
STDMETHODIMP CDdeServerCallMgr::GetBuffer(
/* [in] */ RPCOLEMESSAGE __RPC_FAR *pMessage,
/* [in] */ REFIID riid)
{
    return S_OK;
}

STDMETHODIMP CDdeServerCallMgr::SendReceive(
/* [out][in] */ RPCOLEMESSAGE __RPC_FAR *pMessage,
/* [out] */ ULONG __RPC_FAR *pStatus)
{
    return S_OK;
}

STDMETHODIMP CDdeServerCallMgr::FreeBuffer(
/* [in] */ RPCOLEMESSAGE __RPC_FAR *pMessage)
{
    return S_OK;
}

STDMETHODIMP CDdeServerCallMgr::GetDestCtx(
/* [out] */ DWORD __RPC_FAR *pdwDestContext,
/* [out] */ void __RPC_FAR *__RPC_FAR *ppvDestContext)
{
    return S_OK;
}

STDMETHODIMP CDdeServerCallMgr::IsConnected( void)
{
    return S_OK;
}

STDMETHODIMP CDdeServerCallMgr::GetProtocolVersion(
/* [out] */ DWORD __RPC_FAR *pdwVersion)
{
    return S_OK;
}

STDMETHODIMP CDdeServerCallMgr::SendReceive2(
/* [out][in] */ RPCOLEMESSAGE __RPC_FAR *pMessage,
/* [out] */ ULONG __RPC_FAR *pStatus)
{
    intrDebugOut((DEB_ITRACE,
                  "%p _IN CDdeServerCallMgr::SendReceive2(pMessage=%x,pStatus=%x)\n",
                  this,
                  pMessage,
                  pStatus));

    DDECALLDATA *pCD = ((DDECALLDATA *) pMessage->Buffer);

    if(!PostMessageToClient(pCD->hwndSvr,
                            pCD->wMsg,
                            pCD->wParam,
                            pCD->lParam))
    {
        intrDebugOut((DEB_ITRACE, "SendRecieve2(%x)PostMessageToClient failed", this));
        return RPC_E_SERVER_DIED;
    }


    CAptCallCtrl *pCallCtrl = GetAptCallCtrl();

    CCliModalLoop *pCML = pCallCtrl->GetTopCML();

    HRESULT hres = S_OK;
    BOOL fWait = !(m_pDefClient->m_CallState == SERVERCALLEX_ISHANDLED);

    while (fWait)
    {
        HRESULT hr = OleModalLoopBlockFn(NULL, pCML, NULL);

        if (m_pDefClient->m_CallState == SERVERCALLEX_ISHANDLED)
        {
            fWait = FALSE;
        }
        else if (hr != RPC_S_CALLPENDING)
        {
            fWait = FALSE;
            hres = hr;          // return result from OleModalLoopBlockFn()
        }
    }

    if (FAILED(hres))
    {
        intrDebugOut((DEB_ITRACE, "**** CDdeServerCallMgr::SendReceive2 OleModalLoopBlockFn returned %x ***\n", hres));
    }

    intrDebugOut((DEB_ITRACE,
                  "%p _OUT CDdeServerCallMgr::SendReceive2(pMessage=%x,pStatus=%x)\n",
                  this,
                  pMessage,
                  pStatus));

    return hres;
}


STDMETHODIMP CDdeServerCallMgr::ContextInvoke(
/* [out][in] */ RPCOLEMESSAGE *pMessage,
/* [in] */ IRpcStubBuffer *pStub,
/* [in] */ IPIDEntry *pIPIDEntry,
/* [out] */ DWORD *pdwFault)
{
    intrDebugOut((DEB_ITRACE,
                  "%p _IN CDdeServerCallMgr::ContextInvoke(pMessage=%x,pStub=%x,pdwFault=%x)\n",
                  this,
                  pMessage,
                  pStub,
                  pdwFault));

    HRESULT hr = StubInvoke(pMessage, NULL, pStub, (IRpcChannelBuffer3 *)this, pIPIDEntry, pdwFault);
    
    intrDebugOut((DEB_ITRACE,
                  "%p _OUT CDdeServerCallMgr::ContextInvoke returning hr=0x%x\n",
                  this,
                  hr));
    return(hr);
}


STDMETHODIMP CDdeServerCallMgr::GetBuffer2(
/* [in] */ RPCOLEMESSAGE __RPC_FAR *pMessage,
/* [in] */ REFIID riid)
{
    return GetBuffer(pMessage, riid);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\com\dde\server\srvr.h ===
/****************************** Module Header ******************************\
* Module Name: srvr.h
*
* PURPOSE: Private definitions file for server code
*
* Created: 1990
*
* Copyright (c) 1990, 1991  Microsoft Corporation
*
* History:
*  Raor (../../90,91)  Original
*
\***************************************************************************/
//
// One of the oleint.h routines redefines GlobalAlloc and friends
// to perform some memory tracking functions.
//
// This doesn't work in these files, since the tracking functions
// add tail checking, and size to the data structures. GlobalSize
// is a common function to use to determine how much data to
// serialize, plus it turns out that the other side of a DDE
// connection will often be the caller to free the memory.
//
// Therefore, OLE_DDE_NO_GLOBAL_TRACKING is used to disable this in the
// global header file ih\memapi.hxx. Check to insure this
// flag is set on the compile line
//
#if !defined(OLE_DDE_NO_GLOBAL_TRACKING)
error OLE_DDE_OLE_DDE_NO_GLOBAL_TRACKING must be defined to build this directory
#endif

#include <dde.h>
#include <ddeerr.h>
#include "ddeatoms.h"
#include "ddepack.h"
#include <callctrl.hxx>
#include <ddeint.h>
#include <ddechc.hxx>

//#define UPDATE
/*
 if UPDATE is defined it means:
 If a 1.0 client advises on save, also do a data advise.
 This way the client will always
 have an up-to-date picture (and native data) with respect to a
 2.0 server, like 2.0 clients do.
 If a 1.0 client is prepared to accept data at save time
 it should be able to handle data on each change: it is exactly
 as if the user chose File.Update after each change.
 In fact the item atom is appended with /Save, (see SendDataMsg1)
 which is sort of a lie, but is what a 1.0 client expects for an
 embedded object.
 This is a UI issue.
*/

#define DEFSTD_ITEM_INDEX   0
#define STDTARGETDEVICE     1
#define STDDOCDIMENSIONS    2
#define STDCOLORSCHEME      3
#define STDHOSTNAMES        4


#define PROTOCOL_EDIT       (OLESTR("StdFileEditing"))
#define PROTOCOL_EXECUTE    (OLESTR("StdExecute"))

#define   ISATOM(a)     ((a >= 0xC000) && (a <= 0xFFFF))

// same limit as in OLE 1.0
#define   MAX_STR       124

#define   WW_LPTR       0       // ptr tosrvr/doc/item
#define   WW_HANDLE     4       // instance handle
#define   WW_LE         8       // signature


#define   WC_LE         0x4c45  // LE chars


// Signatures for validity checking
typedef enum
{
        chkDdeSrvr   = 0x1234,
        chkDefClient = 0x5678
} CHK;


const DWORD grfCreateStg =      STGM_READWRITE | STGM_SHARE_EXCLUSIVE
                                                                        | STGM_DIRECT | STGM_CREATE ;


// If we running under WLO, the HIGHWORD of version number will be >= 0x0A00
#define VER_WLO     0x0A00

extern  "C" WORD CheckPointer (LPVOID, int);

#define READ_ACCESS     0
#define WRITE_ACCESS    1

#define PROBE_READ(lp){\
        if (!CheckPointer(lp, READ_ACCESS))\
            return ReportResult(0, E_INVALIDARG, 0, 0);  \
}

#define PROBE_WRITE(lp){\
        if (!CheckPointer(lp, WRITE_ACCESS))\
            return ReportResult(0, E_INVALIDARG, 0, 0);  \
}

#define   OLE_COMMAND       1
#define   NON_OLE_COMMAND   2


#define   WT_SRVR           0       // server window
#define   WT_DOC            1       // document window

#define   PROBE_BLOCK(lpsrvr) {             \
    if (lpsrvr->bBlock)                     \
        return ReportResult(0, S_SERVER_BLOCKED, 0, 0);    \
}


#define   SET_MSG_STATUS(retval, status) { \
    if (!FAILED (GetScode (retval)))     \
        status |= 0x8000;                  \
    if (GetScode(retval) == RPC_E_SERVERCALL_RETRYLATER)\
        status |= 0x4000;                  \
}


/* Codes for CallBack events */
typedef enum {
    OLE_CHANGED,            /* 0                                             */
    OLE_SAVED,              /* 1                                             */
    OLE_CLOSED,             /* 2                                             */
    OLE_RENAMED,            /* 3                                             */
} OLE_NOTIFICATION;

typedef enum { cnvtypNone, cnvtypConvertTo, cnvtypTreatAs } CNVTYP;

typedef struct _QUE : public CPrivAlloc {   // nodes in Block/Unblock queue
    HWND        hwnd;       //***
    UINT                msg;        //      window
    WPARAM      wParam;     //      procedure parameters
    LPARAM      lParam;     //***
    HANDLE      hqNext;     // handle to next node
} QUE;

typedef QUE NEAR *  PQUE;
typedef QUE FAR *   LPQUE;

// structure for maintaining the client info.
#define         LIST_SIZE       10
typedef  struct _CLILIST : public CPrivAlloc {
    HANDLE                 hcliNext;
    HANDLE                 info[LIST_SIZE * 2];
}CLILIST;

typedef     CLILIST FAR *LPCLILIST;
typedef     CLILIST     *PCLILIST;


// this is an object to be embedded in both CDefClient and CDDEServer to glue
// to the new(est) call control interface
class CDdeServerCallMgr : public IRpcStubBuffer, public IInternalChannelBuffer
{
   private:
        CDefClient * m_pDefClient;      // our embeddor (either a CDefClient or a CDDEServer)
        CDDEServer * m_pDDEServer;      // one of these is NULL;

   public:
        CDdeServerCallMgr (CDefClient * pDefClient)
           { m_pDefClient       = pDefClient;
             m_pDDEServer       = NULL;}

        CDdeServerCallMgr (CDDEServer * pDefClient)
           { m_pDefClient       = NULL;
             m_pDDEServer       = pDefClient;}

        STDMETHOD(QueryInterface) ( REFIID iid, LPVOID * ppvObj);
        STDMETHOD_(ULONG,AddRef) ();
        STDMETHOD_(ULONG,Release) ();

        // IRpcStubBuffer methods
        STDMETHOD(Connect)(
            /* [in] */ IUnknown *pUnkServer);

        STDMETHOD_(void,Disconnect)( void);

        STDMETHOD(Invoke)(
            /* [in] */ RPCOLEMESSAGE *_prpcmsg,
            /* [in] */ IRpcChannelBuffer *_pRpcChannelBuffer);

        STDMETHOD_(IRpcStubBuffer *,IsIIDSupported)(
            /* [in] */ REFIID riid);

        STDMETHOD_(ULONG,CountRefs)( void);

        STDMETHOD(DebugServerQueryInterface)(
            void * *ppv);

        STDMETHOD_(void,DebugServerRelease)(
            void  *pv);



         // IRpcChannelBuffer methods
        STDMETHOD(GetBuffer) (
            /* [in] */ RPCOLEMESSAGE __RPC_FAR *pMessage,
            /* [in] */ REFIID riid);

        STDMETHOD(SendReceive) (
            /* [out][in] */ RPCOLEMESSAGE __RPC_FAR *pMessage,
            /* [out] */ ULONG __RPC_FAR *pStatus);

        STDMETHOD(FreeBuffer) (
            /* [in] */ RPCOLEMESSAGE __RPC_FAR *pMessage);

        STDMETHOD(GetDestCtx) (
            /* [out] */ DWORD __RPC_FAR *pdwDestContext,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvDestContext);

        STDMETHOD(IsConnected) ( void);

        // IRpcChannelBuffer2 methods
        STDMETHOD(GetProtocolVersion) (DWORD *pdwVersion);

        // IRpcChannelBuffer3 methods (not implemented)
        STDMETHOD(Send)     (RPCOLEMESSAGE *pMsg, ULONG *pulStatus)
        {
            Win4Assert(FALSE);
            return E_NOTIMPL;
        }

        STDMETHOD(Receive)  (RPCOLEMESSAGE *pMsg, ULONG uSize, ULONG *pulStatus)
        {
            Win4Assert(FALSE);
            return E_NOTIMPL;
        }

        // IInternalChannelBuffer methods (not implemented
        STDMETHOD(Send2)     (RPCOLEMESSAGE *pMsg, ULONG *pulStatus)
        {
            Win4Assert(FALSE);
            return E_NOTIMPL;
        }

        STDMETHOD(Receive2)(RPCOLEMESSAGE *pMsg, ULONG uSize, ULONG *pulStatus)
        {
            Win4Assert(FALSE);
            return E_NOTIMPL;
        }

        STDMETHOD(SendReceive2) (
            /* [out][in] */ RPCOLEMESSAGE __RPC_FAR *pMessage,
            /* [out] */ ULONG __RPC_FAR *pStatus);

        STDMETHODIMP Cancel        ( RPCOLEMESSAGE *pMsg )
                                                      { return E_NOTIMPL; }
        STDMETHODIMP GetCallContext( RPCOLEMESSAGE *pMsg,
                                     REFIID riid,
                                     void **pInterface )
                                                      { return E_NOTIMPL; }
        STDMETHODIMP GetDestCtxEx  ( RPCOLEMESSAGE *pMsg,
                                     DWORD *pdwDestContext,
                                     void **ppvDestContext )
                                                      { return E_NOTIMPL; }
        STDMETHODIMP GetState      ( RPCOLEMESSAGE *pMsg,
                                     DWORD *pState )
                                                      { return E_NOTIMPL; }
        STDMETHODIMP RegisterAsync ( RPCOLEMESSAGE *pMsg,
                                     IAsyncManager *pComplete )
                                                      { return E_NOTIMPL; }

        // Provided IAsyncRpcChannelBuffer methods (not implemented)
        STDMETHODIMP Send(RPCOLEMESSAGE *pMsg, ISynchronize*, ULONG *pulStatus)
        {
          Win4Assert(FALSE);
          return E_NOTIMPL;
        }
        STDMETHOD(Receive)  (RPCOLEMESSAGE *pMsg, ULONG *pulStatus)
        {
            Win4Assert(FALSE);
            return E_NOTIMPL;
        }

        STDMETHOD(ContextInvoke)(
            /* [out][in] */ RPCOLEMESSAGE *pMessage,
            /* [in] */ IRpcStubBuffer *pStub,
            /* [in] */ IPIDEntry *pIPIDEntry,
            /* [out] */ DWORD *pdwFault);

        STDMETHOD(GetBuffer2) (
            /* [in] */ RPCOLEMESSAGE __RPC_FAR *pMessage,
            /* [in] */ REFIID riid);
};


class FAR CDDEServer
{
  public:
    static HRESULT      Create (LPOLESTR lpclass,
                                REFCLSID rclsid,
                                LPDDECLASSINFO lpDdeInfo,
                                HWND FAR * phwnd,
                                ATOM aOriginalClass,
                                CNVTYP cnvtyp);

    INTERNAL_(BOOL)     HandleInitMsg (LPARAM);
    INTERNAL            SrvrExecute (HWND, HANDLE, HWND);
    INTERNAL            Revoke (void);
    INTERNAL_(BOOL)     QueryRevokeClassFactory (void);
    INTERNAL_(LPCLIENT) FindDocObj (LPSTR lpDoc);
    INTERNAL_(void)     Lock (BOOL fLock, HWND hwndClient);


    CLSID           m_clsid;              // Class ID
    DWORD           m_dwClassFactoryKey;  // Class factory reg key
    LPCLASSFACTORY  m_pClassFactory;      // class factory
    CDdeServerCallMgr m_pCallMgr;         // call management interfaces
    BOOL            m_bTerminate;         // Set if we are terminating.
    HWND            m_hwnd;               // corresponding window
    HANDLE          m_hcli;               // handle to the first block of clients list
    int             m_termNo;             // termination count
    int             m_cSrvrClients;       // no of clients;
    DWORD           m_fcfFlags;           // Class factory instance usage flags
    CNVTYP          m_cnvtyp;
    CHK             m_chk;

    ATOM            m_aClass;             // class atom
    ATOM            m_aOriginalClass;     // for TreatAs/ConvertTo case
    ATOM            m_aExe;

    BOOL            m_fDoNotDestroyWindow; // When set, server wnd ingores WM_USER

  private:
    INTERNAL_(void)     SendServerTerminateMsg (void);
    INTERNAL            RevokeAllDocObjs (void);
    INTERNAL            FreeSrvrMem (void);
    INTERNAL            CreateInstance (REFCLSID clsid, LPOLESTR lpWidedocName, LPSTR lpdocName,
                                        LPUNKNOWN pUnk, LPCLIENT FAR* lplpdocClient,
                                        HWND hwndClient);

public:
    //ctor
    CDDEServer()
                : m_pCallMgr( this )
        {
        }


};




BOOL              SendInitMsgToChildren (HWND, UINT msg, WPARAM wParam, LPARAM lParam);

INTERNAL          RequestDataStd (ATOM, HANDLE FAR *);
INTERNAL_(BOOL)   ValidateSrvrClass (LPOLESTR, ATOM FAR *);
INTERNAL_(ATOM)   GetExeAtom (LPOLESTR);
INTERNAL_(BOOL)   AddClient (LPHANDLE, HANDLE, HANDLE);
INTERNAL_(HANDLE) FindClient (HANDLE hCli, HANDLE hkey, BOOL fDelete);

INTERNAL_(BOOL)   IsSingleServerInstance (void);

INTERNAL_(void)   UtilMemCpy (LPSTR, LPSTR, DWORD);
INTERNAL_(HANDLE) DuplicateData (HANDLE);
INTERNAL_(LPSTR)  ScanBoolArg (LPSTR, BOOL FAR *);
INTERNAL_(LPSTR)  ScanNumArg (LPSTR, LPINT);
INTERNAL_(LPSTR)  ScanArg(LPSTR);
INTERNAL_(ATOM)   MakeDataAtom (ATOM, int);
INTERNAL_(ATOM)   DuplicateAtom (ATOM);
INTERNAL_(BOOL)   CLSIDFromAtom(ATOM aClass, LPCLSID lpclsid);
INTERNAL          CLSIDFromAtomWithTreatAs (ATOM FAR* paClass, LPCLSID lpclsid,
                                            CNVTYP FAR* pcnvtyp);
INTERNAL          wFileIsRunning (LPOLESTR szFile);
INTERNAL          wFileBind (LPOLESTR szFile, LPUNKNOWN FAR* ppUnk);
INTERNAL          wCreateStgAroundNative (HANDLE hNative,
                                        ATOM aClassOld,
                                        ATOM aClassNew,
                                        CNVTYP cnvtyp,
                                        ATOM aItem,
                                        LPSTORAGE FAR* ppstg,
                                        LPLOCKBYTES FAR* pplkbyt);
INTERNAL          wCompatibleClasses (ATOM aClient, ATOM aSrvr);




typedef struct FARSTRUCT : public CPrivAlloc {
        BOOL    f;          // do we need to send an ack?
                            // If this is FALSE, other fields don't matter
        HGLOBAL hdata;
        HWND    hwndFrom;   // who sent the execute?
        HWND    hwndTo;
} EXECUTEACK;


// client struct definitions.



class FAR CDefClient : public CPrivAlloc
{
  public:
        static INTERNAL Create
                               (LPSRVR      pDdeSrvr,
                                LPUNKNOWN   lpunkObj,
                                LPOLESTR    lpdocName,
                                const BOOL  fSetClientSite,
                                const BOOL  fDoAdvise,
                                const BOOL  fRunningInSDI = FALSE,
                                HWND FAR*   phwnd = NULL);

   INTERNAL         DocExecute (HANDLE);
   INTERNAL         DocDoVerbItem (LPSTR, WORD, BOOL, BOOL);
   INTERNAL         DocShowItem (LPSTR, BOOL);
   INTERNAL         DestroyInstance ();
   INTERNAL_(void)  DeleteFromItemsList (HWND h);
   INTERNAL_(void)  RemoveItemFromItemList (void);
   INTERNAL_(void)  ReleasePseudoItems (void);
   INTERNAL_(void)  ReleaseAllItems ();
   INTERNAL         PokeStdItems (HWND, ATOM, HANDLE,int);
   INTERNAL         PokeData (HWND, ATOM, HANDLE);
   INTERNAL         AdviseData (HWND, ATOM, HANDLE, BOOL FAR *);
   INTERNAL         AdviseStdItems (HWND, ATOM, HANDLE, BOOL FAR *);
   INTERNAL         UnAdviseData (HWND, ATOM);
   INTERNAL         RequestData (HWND, ATOM, USHORT, HANDLE FAR *);
   INTERNAL         Revoke (BOOL fRelease=TRUE);
   INTERNAL         ReleaseObjPtrs (void);
   INTERNAL_(void)  DeleteAdviseInfo ();
   INTERNAL         DoOle20Advise (OLE_NOTIFICATION, CLIPFORMAT);
   INTERNAL         DoOle20UnAdviseAll (void);
   INTERNAL         SetClientSite (void);
   INTERNAL         NoItemConnections (void);
   INTERNAL_(void)  SendExecuteAck (HRESULT hresult);
   INTERNAL         DoInitNew(void);
   INTERNAL         Terminate(HWND, HWND);
   INTERNAL_(void)  SetCallState (SERVERCALLEX State)
                    {
                        m_CallState = State;
                    }

        CHK               m_chk;       // signature
        CDdeServerCallMgr m_pCallMgr;  // call management interfaces
        SERVERCALLEX      m_CallState;

        IUnknown FAR*   m_pUnkOuter;
        LPOLEOBJECT     m_lpoleObj;    // corresponding oleobj
        LPDATAOBJECT    m_lpdataObj;   // corresponding dataobj
        BOOL            m_bCreateInst; // instance is just created.
        BOOL            m_bTerminate;  // REVIEW: The next two fields may not be necessary.
        int             m_termNo;
        ATOM            m_aItem;       // item atom or index for some std items
        HANDLE          m_hcli;        // handle to the first block of clients list (Document only)
        CDefClient FAR *m_lpNextItem;  // ptr to the next item.
        BOOL            m_bContainer;  // Is document?
        BOOL            m_cRef;
        HWND            m_hwnd;        // doc window (only needed in document)
        HANDLE          m_hdevInfo;    // latest printer dev info sent
        HANDLE          m_hcliInfo;    // advise info for each of the clients
        BOOL            m_fDidRealSetHostNames;
        BOOL            m_fDidSetClientSite;
        BOOL            m_fGotDdeAdvise;
        BOOL            m_fCreatedNotConnected;
        BOOL            m_fInOnClose;
        BOOL            m_fInOleSave;
        EXECUTEACK      m_ExecuteAck;
        DWORD           m_dwConnectionOleObj;
        DWORD           m_dwConnectionDataObj;
        LPLOCKBYTES     m_plkbytNative; // These two fields always refer to
        LPSTORAGE       m_pstgNative;   //   to the same bits:
                                        // The server's persistent storage is
                                        // used as its native data.
        BOOL            m_fRunningInSDI;// Link case: file was already open in
                                        // an SDI app which does not register a
                                        // class factory.
        LPSRVR          m_psrvrParent;  // (Document only)
        DVTARGETDEVICE FAR* m_ptd;
        BOOL            m_fGotStdCloseDoc;
        BOOL            m_fGotEditNoPokeNativeYet;
        BOOL            m_fLocked; // locked by CoLockObjectExternal ?

        // If not FALSE, then we are waiting for a matching TERMINATE

        BOOL            m_fCallData;





        // REVIEW: These fields might be necssary for doc (old) level object
        BOOL            m_fEmbed;       // embedded object (Document only)
        int             m_cClients;     // (Document only)
        LPCLIENT        m_pdoc;         // containing document (for items) or self (for docs)


implementations:

        STDUNKDECL (CDefClient,DefClient);

        /*** IOleClientSite ***/
        implement COleClientSiteImpl : IOleClientSite
        {
                public:
                // Constructor
                COleClientSiteImpl (CDefClient FAR* pDefClient)
                {       m_pDefClient = pDefClient;
                }
                STDMETHOD(QueryInterface) (REFIID, LPVOID FAR *);
                STDMETHOD_(ULONG,AddRef) (void);
                STDMETHOD_(ULONG,Release) (void);

                /*** IOleClientSite methods ***/
                STDMETHOD(SaveObject) (THIS);
                STDMETHOD(GetMoniker) (THIS_ DWORD dwAssign, DWORD dwWhichMoniker,
                                        LPMONIKER FAR* ppmk);
                STDMETHOD(GetContainer) (THIS_ LPOLECONTAINER FAR* ppContainer);
                STDMETHOD(ShowObject) (THIS);
                STDMETHOD(OnShowWindow) (THIS_ BOOL fShow);
                STDMETHOD(RequestNewObjectLayout) (THIS);

                private:
                CDefClient FAR* m_pDefClient;
        };

        DECLARE_NC (CDefClient, COleClientSiteImpl)
        COleClientSiteImpl m_OleClientSite;



        /*** IAdviseSink ***/
        implement CAdviseSinkImpl : IAdviseSink
        {
                public:
                // Constructor
                CAdviseSinkImpl (CDefClient FAR* pDefClient)
                {       m_pDefClient = pDefClient;
                }

                STDMETHOD(QueryInterface) (REFIID, LPVOID FAR *);
                STDMETHOD_(ULONG,AddRef) (void);
                STDMETHOD_(ULONG,Release) (void);

                /**** IAdviseSink methods ****/
                STDMETHOD_(void,OnDataChange)(THIS_ FORMATETC FAR* pFormatetc,
                                                                                                STGMEDIUM FAR* pStgmed) ;
                STDMETHOD_(void,OnViewChange)(THIS_ DWORD aspects, LONG lindex) ;
                STDMETHOD_(void,OnExtentChange)(DWORD dwAspect, LPSIZEL lpsizel) {}
                STDMETHOD_(void,OnRename)(THIS_ LPMONIKER pmk) ;
                STDMETHOD_(void,OnSave)(THIS) ;
                STDMETHOD_(void,OnClose)(THIS) ;

                private:
                CDefClient FAR* m_pDefClient;
        };


        DECLARE_NC (CDefClient, CAdviseSinkImpl)

        CAdviseSinkImpl m_AdviseSink;
ctor_dtor:
        CDefClient (LPUNKNOWN pUnkOuter);
        ~CDefClient (void);

private:
        INTERNAL            ItemCallBack (int msg, LPOLESTR szNewName = NULL);
        INTERNAL_(void)     SendTerminateMsg ();
        INTERNAL_(BOOL)     SendDataMsg1 (HANDLE, WORD);
        INTERNAL_(BOOL)     SendDataMsg (WORD);
        INTERNAL_(void)     TerminateNonRenameClients (LPCLIENT);
        INTERNAL_(void)     SendRenameMsgs (HANDLE);
        INTERNAL            RegisterItem (LPOLESTR, LPCLIENT FAR *, BOOL);
        INTERNAL            FindItem (LPOLESTR, LPCLIENT FAR *);
        INTERNAL_(LPCLIENT) SearchItem (LPOLESTR);
        INTERNAL_(void)     DeleteAllItems ();
        INTERNAL            SetStdInfo (HWND, LPOLESTR, HANDLE);
        INTERNAL_(void)     SendDevInfo (HWND);
        INTERNAL_(BOOL)     IsFormatAvailable (CLIPFORMAT);
        INTERNAL            GetData (LPFORMATETC, LPSTGMEDIUM);
};




typedef struct _CLINFO : public CPrivAlloc { /*clInfo*/ // client transaction info
    HWND        hwnd;               // client window handle
    BOOL        bnative;            // doe sthis client require native
    int         format;             // dusplay format
    int         options;            // transaction advise time otipns
    BOOL        bdata;              // need wdat with advise?
    HANDLE      hdevInfo;           // device info handle
    BOOL        bnewDevInfo;        // new device info
} CLINFO;

typedef  CLINFO  *PCLINFO;



INTERNAL_(BOOL)   MakeDDEData (HANDLE, int, LPHANDLE, BOOL);
INTERNAL_(HANDLE) MakeGlobal (LPSTR);
INTERNAL          ScanItemOptions (LPOLESTR, int far *);
INTERNAL_(int)    GetStdItemIndex (ATOM);
INTERNAL_(BOOL)   IsAdviseStdItems (ATOM);
INTERNAL_(HANDLE) MakeItemData (DDEPOKE FAR *, HANDLE, CLIPFORMAT);
INTERNAL_(BOOL)   AddMessage (HWND, unsigned, WORD, LONG, int);



#define     ITEM_FIND          1      // find the item
#define     ITEM_DELETECLIENT  2      // delete the client from item clients
#define     ITEM_DELETE        3      // delete th item window itself
#define     ITEM_SAVED         4      // item saved

// host names data structcure
typedef struct _HOSTNAMES : public CPrivAlloc {
    WORD    clientNameOffset;
    WORD    documentNameOffset;
    BYTE    data[1];
} HOSTNAMES;

typedef HOSTNAMES FAR * LPHOSTNAMES;


// routines in UTILS.C
LPOLESTR CreateUnicodeFromAnsi( LPCSTR lpAnsi);
LPSTR CreateAnsiFromUnicode( LPCOLESTR lpAnsi);
INTERNAL_(HANDLE) DuplicateData (HANDLE);
INTERNAL_(LPSTR)  ScanLastBoolArg (LPSTR);
INTERNAL_(LPSTR)  ScanArg(LPSTR);
INTERNAL_(WORD)   ScanCommand(LPSTR, WORD, LPSTR FAR *, ATOM FAR *);
INTERNAL_(ATOM)   MakeDataAtom (ATOM, int);
INTERNAL_(ATOM)   DuplicateAtom (ATOM);
INTERNAL_(WORD)   StrToInt (LPOLESTR);
INTERNAL_(BOOL)   PostMessageToClientWithReply (HWND, UINT, WPARAM, LPARAM, UINT);
INTERNAL_(BOOL)   PostMessageToClient (HWND, UINT, WPARAM, LPARAM);
INTERNAL_(BOOL)   IsWindowValid (HWND);
INTERNAL_(BOOL)   IsOleCommand (ATOM, WORD);
INTERNAL_(BOOL)   UtilQueryProtocol (ATOM, LPOLESTR);
INTERNAL          SynchronousPostMessage (HWND, UINT, WPARAM, LPARAM);
INTERNAL_(BOOL)   IsAtom (ATOM);
INTERNAL_(BOOL)   IsFile (ATOM a, BOOL FAR* pfUnsavedDoc = NULL);


// routines for queueing messages and posting them
INTERNAL_(BOOL)        UnblockPostMsgs(HWND, BOOL);
INTERNAL_(BOOL)        BlockPostMsg (HWND, WORD, WORD, LONG);
INTERNAL_(BOOL)        IsBlockQueueEmpty (HWND);

// routine in GIVE2GDI.ASM
extern "C" HANDLE  FAR PASCAL  GiveToGDI (HANDLE);


// routine in item.c
INTERNAL_(HBITMAP)     DuplicateBitmap (HBITMAP);
INTERNAL_(HANDLE)      DuplicateMetaFile (HANDLE);
INTERNAL_(BOOL) AreNoClients (HANDLE hcli);
#ifdef _DEBUG
INTERNAL_(LPOLESTR) a2s (ATOM);
#endif

// routines in doc.c
INTERNAL_(void)        FreePokeData (HANDLE);
INTERNAL_(BOOL)        FreeGDIdata (HANDLE, CLIPFORMAT);
INTERNAL DdeHandleIncomingCall(HWND hwndCli, WORD wCallType);


// in ddeworkr.cpp
INTERNAL_(HANDLE) wNewHandle (LPSTR lpstr, DWORD cb);
INTERNAL wTimedGetMessage (LPMSG pmsg, HWND hwnd, WORD wFirst, WORD wLast);
INTERNAL_(ATOM) wGlobalAddAtom (LPCOLESTR sz);

//+---------------------------------------------------------------------------
//
//  Function:   TLSSetDdeServer
//
//  Synopsis:   Sets hwnd to CommonDdeServer window
//
//  Arguments:  [hwndDdeServer] --
//
//  History:    5-13-94   kevinro   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
inline BOOL TLSSetDdeServer(HWND hwndDdeServer)
{
    HRESULT hr;
    COleTls tls(hr);

    if (SUCCEEDED(hr))
    {
        tls->hwndDdeServer = hwndDdeServer;
        return TRUE;
    }

    return FALSE;
}

//+---------------------------------------------------------------------------
//
//  Function:   TLSGetDdeServer
//
//  Synopsis:   Returns a handle to the per thread DdeServer window
//
//  Returns:    hwndDdeServer for thread
//
//  History:    5-13-94   kevinro   Created
//
//  Notes:
//----------------------------------------------------------------------------
inline HWND TLSGetDdeServer()
{
    HRESULT hr;
    COleTls tls(hr);

    if (SUCCEEDED(hr))
    {
        return tls->hwndDdeServer;
    }

    return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\com\debug\assert.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       assert.cxx
//
//  Functions:  FnAssert
//              DbgDllSetSiftObject
//
//  History:     4-Jan-94   CraigWi     Created
//              16-Jun-94   t-ChriPi    Added DbgDllSetSiftObject
//
//----------------------------------------------------------------------------



#include <ole2int.h>

//+-------------------------------------------------------------------
//
//  Function:	FnAssert, public
//
//  Synopsis:	Prints a message and optionally stops the program
//
//  Effects:	Simply maps to Win4AssertEx for now.
//
//  History:	 4-Jan-94   CraigWi	Created for Win32 OLE2.
//
//--------------------------------------------------------------------

STDAPI FnAssert( LPSTR lpstrExpr, LPSTR lpstrMsg, LPSTR lpstrFileName, UINT iLine )
{
#if DBG == 1
    char szMessage[1024];
    
    if (lpstrMsg == NULL)
        lstrcpynA(szMessage, lpstrExpr, sizeof(szMessage));
    else
    {
        _snprintf(szMessage, sizeof(szMessage), "%s; %s", lpstrExpr, lpstrMsg);
        szMessage[sizeof(szMessage)-1] = '\0';
    }
    
    Win4AssertEx(lpstrFileName, iLine, szMessage);
#endif
    return NOERROR;
}

#if DBG==1

#include <osift.hxx>

ISift *g_psftSiftObject = NULL;

//+---------------------------------------------------------------------------
//
//  Function:   DbgDllSetSiftObject
//
//  Arguments:  [psftSiftImpl] -- pointer to a new sift implementation
//
//  Synopsis:   Sets global sift object pointer to a new implementation
//
//  Returns:    S_OK if successful
//
//  History:    6-14-94   t-chripi   Created
//
//  Notes:      Passing NULL to this function will release the global
//              pointer's reference and then set it to NULL.
//
//----------------------------------------------------------------------------

STDAPI DbgDllSetSiftObject(ISift *psftSiftImpl)
{
    //  Passing a non-NULL invalid pointer will cause an error
    if ((NULL != psftSiftImpl) &&
        (!IsValidReadPtrIn(psftSiftImpl, sizeof(ISift*))))
    {
        CairoleDebugOut((DEB_ERROR,
                         "DbgDllSetSiftObject was passed an invalid ptr.\n"));
        return(E_FAIL);
    }
    else
    {
        if (NULL != g_psftSiftObject)
        {
            g_psftSiftObject->Release();
        }
        g_psftSiftObject = psftSiftImpl;
        
        if (NULL != g_psftSiftObject)
        {
            g_psftSiftObject->AddRef();
        }
    }
    return(S_OK);
}

#endif  //  DBG==1
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\com\debug\valid.cxx ===
#include <ole2int.h>

#include "valid.h"

#if 1
// we cannot turn this off until we remove from the export list!
#undef IsValidPtrIn
#undef IsValidPtrOut

//////////////////////////////////////////////////////////////////
// This comment used to be marked with a blugblug; however
// we canot change this since these functions are exported from
// ole32.dll and at one point they were doc'd.   So, for 
// backward compatibility we must leave things as they are.
//
// The following two functions are MACRO's in 2.01 code
// but we need them for now because we only run with a storage
// that uses ole232.dll. When we get rid of this these may die.
//

#pragma SEG(IsValidPtrIn)
STDAPI_(BOOL) IsValidPtrIn( const void FAR* pv, UINT cb )
{												//	NULL is acceptable
	if (pv && ValidateInPointers() && IsBadReadPtr(pv,cb))
	{
//		AssertSz(FALSE, "Invalid in pointer");
		return FALSE;
	}
	return TRUE;
}



#pragma SEG(IsValidPtrOut)
STDAPI_(BOOL) IsValidPtrOut( void FAR* pv, UINT cb )
										//	NULL is not acceptable
{
	if ((cb > 0 && !pv) || (ValidateOutPointers() && IsBadWritePtr(pv,cb)))
	{
//		AssertSz(FALSE, "Invalid out pointer");
		return FALSE;
	}
	return TRUE;
}
#endif


#pragma SEG(IsValidInterface)
STDAPI_(BOOL) IsValidInterface( void FAR* pv )
{
	ULONG_PTR FAR*		pVtbl;
	BYTE      FAR*		pFcn;
	volatile BYTE	        bInstr;
	int			i;

    if (!pv)
        return FALSE;

	if (ValidateInterfaces())
	{
    	__try {
    		pVtbl = *(ULONG_PTR FAR* FAR*) pv;                 // pVtbl now points to beginning of vtable

#if DBG==1
    		for (i=0 ; i<3; ++i)                               // loop through qi,addref,rel
#else
    		i=1;                                               // in retail, just do AddRef
#endif
    		{
    			pFcn = *(BYTE FAR* FAR*) &pVtbl[i];        // pFcn now points to beginning of QI, Addref, or Release
#if DBG==1
    			if (IsBadCodePtr((FARPROC FAR)pFcn)) {
    				return FALSE;
    			}
#endif
    			bInstr = *(BYTE FAR*) pFcn;                // get 1st byte of 1st instruction
    		}

    	} 
    	__except(EXCEPTION_EXECUTE_HANDLER) 
    	{
    		return FALSE;
    	}
	}

	return TRUE;
}


// #if DBG==1
// we cannot remove IsValidIID fcn until we remove from export list!

// This function is NOT called in retail builds.
// Its former implementation always returned TRUE thus doing NO validation.
// It now validates in debug build and is not called in retail build

#if DBG==0
#ifdef IsValidIid
#undef IsValidIid
STDAPI_(BOOL) IsValidIid( REFIID iid );
#endif
#endif

STDAPI_(BOOL) IsValidIid( REFIID iid )
{
#if DBG==1
	if (ValidateIIDs() && !IsValidReadPtrIn((void*) &iid, 16)) {
		AssertSz(FALSE, "Invalid iid");
		return FALSE;
	}
#endif
	return TRUE;
}
// #endif // DBG==1
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\com\debug\sources.inc ===
!IF 0

Copyright (c) 1998  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.

!ENDIF

TARGETNAME=   debug
TARGETPATH=   obj
TARGETTYPE=   LIBRARY

INCLUDES=     ..;..\..\..\common\$(DEST_TREE);..\..\..\ih;..\..\inc
INCLUDES=     $(INCLUDES);..\..\..\..\inc
INCLUDES=     $(INCLUDES);..\..\..\idl\public\$(DEST_TREE)\obj
INCLUDES=     $(INCLUDES);..\..\..\idl\internal\$(DEST_TREE)\obj
INCLUDES=     $(INCLUDES);..\..\..\idl\private\$(DEST_TREE)\obj

SOURCES=      \
              ..\assert.cxx   \
              ..\valid.cxx

UMTYPE=       windows

!include ..\..\precomp2.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\com\inc\array_fv.h ===
#ifndef __ARRAY_FV_H__
#define __ARRAY_FV_H__

////////////////////////////////////////////////////////////////////////////
// class CArrayFValue - an array containing fixed size elements,
//
////////////////////////////////////////////////////////////////////////////


class FAR CArrayFValue
{
public:

// Construction
        CArrayFValue(UINT cbValue);
        ~CArrayFValue();

// Attributes
        int     GetSize() const
                                { return m_nSize; }
        int     GetUpperBound() const
                                { return m_nSize-1; }
        BOOL    SetSize(int nNewSize, int nGrowBy = -1);
        int             GetSizeValue() const
                                { return m_cbValue; }

// Operations
        // Clean up
        void    FreeExtra();
        void    RemoveAll()
                                { SetSize(0); }

        // return pointer to element; index must be in range
#ifdef _DEBUG
        // with debug checks
        LPVOID   GetAt(int nIndex) const
                                { return _GetAt(nIndex); }
#else
        // no debug checks
        LPVOID   GetAt(int nIndex) const
                                { return &m_pData[nIndex * m_cbValue]; }
#endif
        LPVOID   _GetAt(int nIndex) const;

        // set element; index must be in range
        void    SetAt(int nIndex, LPVOID pValue);

        // find element given part of one; offset is offset into value; returns
        // -1 if element not found; use IndexOf(NULL, cb, offset) to find zeros;
        // will be optimized for appropriate value size and param combinations
        int             IndexOf(LPVOID pData, UINT cbData, UINT offset);

        // set/add element; Potentially growing the array; return FALSE/-1 if
        // not possible (due to OOM)
        BOOL    SetAtGrow(int nIndex, LPVOID pValue);

        // Operations that move elements around
        BOOL    InsertAt(int nIndex, LPVOID pValue, int nCount = 1);
        void    RemoveAt(int nIndex, int nCount = 1);

        void    AssertValid() const;

// Implementation
private:
        BYTE FAR*   m_pData;    // the actual array of data
        UINT    m_cbValue;              // size of each value (in bytes)
        int     m_nSize;        // current # of elements (m_cbValue bytes in length)
        int     m_nMaxSize;     // max # of elements (m_cbValue bytes in length)
        int     m_nGrowBy;      // grow amount (in # elements)
};


#endif // !__ARRAY_FV_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\com\inc\assrtdlg.h ===
#define AssertFail                  5100
#define Expr                        5101
#define Location                    5102
#define ASSRT_ID_BREAK                     5103
#define ASSRT_ID_EXIT                      5104
#define ASSRT_ID_IGNORE                    5105
#define ASSRT_ID_LOC                       5106
#define ASSRT_ID_EXPR                      5107
#define ASSRT_ID_MSG                5108
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\com\inc\clskey.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:	clskey.cxx
//
//  Contents:	Variable definitions used by class key search and
//		definitions used for exception handling for class key
//		classes.
//
//  History:	21-Apr-93 Ricksa    Created
//
//--------------------------------------------------------------------------
#include    <ole2int.h>
#include    <clskey.hxx>

GUID guidCidMax =
  {0xFFFFFFFF,0xFFFF,0xFFFF,{0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF}};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\com\inc\callinfo.h ===
#ifndef _CALLINFO_H
#define _CALLINFO_H

//
// Shared information between DDE and LRPC
//
typedef ULONG TIMERID;
typedef ULONG CALLID, FAR * LPCALLID;
//
// the call info holds all information for one particular outgoing call
//
typedef struct tagCallInfo CallInfo, CALLINFO, FAR* LPCALLINFO;

struct tagCallInfo {
	UINT	m_id;			// this is the callinfo id for the table lookup
	HWND 	m_hwndSvr;		// window of callee
	HWND 	m_hwndCli;		// window of caller
	BOOL 	m_fWait;       	// wait for acknowledge
	BOOL 	m_fRejected;   	// call was rejected
	DWORD 	m_dwServerCall; // set by HIC, passed to RetryRejectedCall (ack/busyack/nak/error)
	HRESULT m_hresult;		// the return value of this loop	
	
	// info to retry the call
	WORD  	m_wMsg;			
	WPARAM 	m_wParam;		
	LPARAM 	m_lParam;    	
	
	// timer status for this callinfo
	WORD 	m_wTimer;
	
	// Note: Call State
	// here we remember the current call state we are in
	// if the call was at the 'root' level the call state is 0
	// REVIEW: this is not ready yet and used to detect if we call
	// 	out on an external call.
	DWORD 	m_dwCallState;

	//
	// internaly used to manage multiple
 	LONG		m_lid;
	LPVOID		m_pData;
	LPCALLINFO	m_pCINext;
};

//
// The origin of RunModalLoop is needed for the priority of message.
// If call by LRPC, lrpc messages are peeked first.
//
typedef enum tagCALLORIGIN {
	CALLORIGIN_LRPC = 1,
	CALLORIGIN_DDE  = 2,
} CALLORIGIN;

// function used by DDE and LRPC
STDAPI CoRunModalLoop (LPCALLINFO pCI, WORD wOrigin);
STDAPI_(DWORD) CoHandleIncomingCall( HWND hwndCaller, WORD wCallType, LPINTERFACEINFO lpIfInfo = NULL);
STDAPI_(DWORD) CoSetAckState(LPCALLINFO pCI, BOOL fWait, BOOL fRejected = FALSE, DWORD dwServerCall = 0);

#endif // _CALLINFO_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\com\inc\array_id.h ===
////////////////////////////////////////////////////////////////////////////



class FAR CIDArray
{
public:

// Construction
	CIDArray() : m_afv(sizeof(IDENTRY)) { }
	~CIDArray() { }

// Attributes
	int     GetSize() const
				{ return m_afv.GetSize(); }
	int     GetUpperBound() const
				{ return m_afv.GetSize()-1; }
	BOOL    SetSize(int nNewSize, int nGrowBy = -1)
				{ return m_afv.SetSize(nNewSize, nGrowBy); }
	int		GetSizeValue() const
				{ return m_afv.GetSizeValue(); }

// Operations
	// Clean up
	void    FreeExtra()
				{ m_afv.FreeExtra(); }

	void    RemoveAll()
				{ m_afv.SetSize(0); }

	// return pointer to element; index must be in range
	IDENTRY	GetAt(int nIndex) const
				{ return *(IDENTRY FAR*)m_afv.GetAt(nIndex); }
	IDENTRY FAR&   ElementAt(int nIndex)
				{ return (IDENTRY FAR&)*(IDENTRY FAR*)m_afv.GetAt(nIndex); }

	// overloaded operator helpers
	IDENTRY    operator[](int nIndex) const
				{ return GetAt(nIndex); }
	IDENTRY FAR&   operator[](int nIndex)
				{ return ElementAt(nIndex); }

	// get address of first element efficiently
	operator IDENTRY *()	{ return (IDENTRY FAR*)m_afv.GetAt(0); }

	// set element; index must be in range
	void    SetAt(int nIndex, IDENTRY& value)
				{ m_afv.SetAt(nIndex, (LPVOID)&value); }

	// find element given part of one; offset is offset into value; returns
	// -1 if element not found; use IndexOf(NULL, cb, offset) to find zeros;
	// will be optimized for appropriate value size and param combinations
	int		IndexOf(LPVOID pData, UINT cbData, UINT offset)
				{ return m_afv.IndexOf(pData, cbData, offset); }

	// set/add element; Potentially growing the array; return FALSE/-1 if
	// not possible (due to OOM)
	BOOL    SetAtGrow(int nIndex, IDENTRY& value)
				{ return m_afv.SetAtGrow(nIndex, (LPVOID)&value); }
	int     Add(IDENTRY& value)
				{ int nIndex = GetSize();
				  return SetAtGrow(nIndex, value) ? nIndex : -1;
				}

	// Operations that move elements around
	BOOL    InsertAt(int nIndex, IDENTRY& value, int nCount = 1)
				{ return m_afv.InsertAt(nIndex, (LPVOID)&value, nCount); }
	void    RemoveAt(int nIndex, int nCount = 1)
				{ m_afv.RemoveAt(nIndex, nCount); }

	void    AssertValid() const
				{ m_afv.AssertValid(); }

// Implementation
private:
	CArrayFValue m_afv;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\com\inc\map_sp.h ===
////////////////////////////////////////////////////////////////////////////



class FAR CMapStringToPtr : public CPrivAlloc
{
public:
	// Construction
	CMapStringToPtr(UINT nBlockSize=10)
		: m_mkv(sizeof(void FAR*), 0, nBlockSize) { }

	// Attributes
	// number of elements
	int     GetCount() const
				{ return m_mkv.GetCount(); }
	BOOL    IsEmpty() const
				{ return GetCount() == 0; }

	// Lookup
	BOOL	Lookup(LPWSTR pKey, void FAR* FAR& value) const
				{ return m_mkv.Lookup(pKey, lstrlenW(pKey)*sizeof(WCHAR), &value); }

	BOOL    LookupHKey(HMAPKEY hKey, void FAR* FAR& value) const
				{ return m_mkv.LookupHKey(hKey, &value); }

	BOOL	LookupAdd(LPWSTR pKey, void FAR* FAR& value) const
				{ return m_mkv.LookupAdd(pKey, lstrlenW(pKey)*sizeof(WCHAR), &value); }


	// Add/Delete
	// add a new (key, value) pair
	BOOL	SetAt(LPWSTR pKey, void FAR* value)
				{ return m_mkv.SetAt(pKey, lstrlenW(pKey)*sizeof(WCHAR), (LPVOID)&value); }
	BOOL    SetAtHKey(HMAPKEY hKey, void FAR* value)
				{ return m_mkv.SetAtHKey(hKey, (LPVOID)&value); }

	// removing existing (key, ?) pair
	BOOL	RemoveKey(LPWSTR pKey)
				{ return m_mkv.RemoveKey(pKey, lstrlenW(pKey)*sizeof(WCHAR)); }

	BOOL    RemoveHKey(HMAPKEY hKey)
				{ return m_mkv.RemoveHKey(hKey); }

	void    RemoveAll()
				{ m_mkv.RemoveAll(); }


	// iterating all (key, value) pairs
	POSITION GetStartPosition() const
				{ return m_mkv.GetStartPosition(); }

	void	GetNextAssoc(POSITION FAR& rNextPosition, LPWSTR FAR& pKey, void FAR* FAR& rValue) const
				{ m_mkv.GetNextAssoc(&rNextPosition, (LPVOID)&pKey, NULL, (LPVOID)&rValue); }

	HMAPKEY GetHKey(LPWSTR pKey) const
				{ return m_mkv.GetHKey(pKey, lstrlenW(pKey)*sizeof(WCHAR)); }

#ifdef _DEBUG
	void    AssertValid() const
				{ m_mkv.AssertValid(); }
#endif

private:
	CMapKeyToValue m_mkv;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\com\inc\olecom.h ===
//+-------------------------------------------------------------------
//
//  File:	olecom.hxx
//
//  Contents:	General includes for common library in ole\src project
//
//  Classes:	None
//
//  Functions:	None.
//
//  History:	06-Jan-92   Rickhi	Created
//
//--------------------------------------------------------------------
#ifndef __OLECOM_H__
#define __OLECOM_H__

// Need for debugging headers
#include    <except.hxx>
#pragma warning (disable: 4509)

#if DBG==1
extern "C" void brkpt(void);
#endif

#if DBG==1
DECLARE_DEBUG(ClsCache)

#define ClsCacheDebugOut(x) ClsCacheInlineDebugOut x
#define ClsCacheAssert(x) Win4Assert(x)
#define ClsCacheVerify(x) Win4Assert(x)

#else

#define ClsCacheDebugOut(x)
#define ClsCacheAssert(x)
#define ClsCacheVerify(x) (x)

#endif // DBG

#if DBG==1
DECLARE_DEBUG(RefCache)

#define RefCacheDebugOut(x) RefCacheInlineDebugOut x
#define RefCacheAssert(x) Win4Assert(x)
#define RefCacheVerify(x) Win4Assert(x)

#else

#define RefCacheDebugOut(x)
#define RefCacheAssert(x)
#define RefCacheVerify(x) (x)

#endif // DBG

#if DBG==1
DECLARE_DEBUG(Call)

#define CallDebugOut(x) CallInlineDebugOut x
#define CallAssert(x) Win4Assert(x)
#define CallVerify(x) Win4Assert(x)

#else

#define CallDebugOut(x)
#define CallAssert(x)
#define CallVerify(x) (x)

#endif // DBG

#if DBG==1
DECLARE_DEBUG(Cairole)

#define CairoleDebugOut(x) CairoleInlineDebugOut x
#define CairoleAssert(x) Win4Assert(x)
#define CairoleVerify(x) Win4Assert(x)

#else

#define CairoleDebugOut(x)  { }
#define CairoleAssert(x)
#define CairoleVerify(x) (x)

#endif // DBG

#if DBG==1
DECLARE_DEBUG(intr)

#define intrDebugOut(x) intrInlineDebugOut x
#define intrAssert(x) Win4Assert(x)
#define intrVerify(x) Win4Assert(x)

#else

#define intrDebugOut(x)
#define intrAssert(x)
#define intrVerify(x) (x)

#endif // DBG

#if DBG==1
DECLARE_DEBUG(Context)

#define ContextDebugOut(x) ContextInlineDebugOut x
#define ContextAssert(x) Win4Assert(x)
#define ContextVerify(x) Win4Assert(x)

extern "C" void brkpt(void);

#else

#define ContextDebugOut(x) { }
#define ContextAssert(x)
#define ContextVerify(x) (x)

#endif // DBG

#endif // __OLECOM_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\com\inc\olereg.h ===
/*	olereg.h

	Registration database helper functions
   Jason Fuller (jasonful)  16-November-1992

   These functions are candidates for export

*/

FARINTERNAL OleRegGetUserType
	(REFCLSID 	clsid,
	DWORD		 	dwFormOfType,
	LPWSTR FAR*	pszUserType)
;


FARINTERNAL OleRegGetMiscStatus
	(REFCLSID	clsid,
	DWORD			dwAspect,
	DWORD FAR*	pdwStatus)
;

FARINTERNAL OleRegEnumFormatEtc
	(REFCLSID clsid,
	DWORD 	  dwDirection,
	LPENUMFORMATETC FAR* ppenum)
;

FARINTERNAL OleRegEnumVerbs
	(REFCLSID clsid,
	LPENUMOLEVERB FAR* ppenum)
;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\com\inc\ole2int.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1993 - 1993.
//
//  File:       ole2int.h
//
//  Contents:   internal ole2 header
//
//  Notes:      This is the internal ole2 header, which means it contains those
//              interfaces which might eventually be exposed to the outside
//              and which will be exposed to our implementations. We don't want
//              to expose these now, so I have put them in a separate file.
//
//  History:    12-27-93   ErikGav   Include uniwrap.h for Chicago builds
//
//----------------------------------------------------------------------------

#if !defined( _OLE2INT_H_ )
#define _OLE2INT_H_

// -----------------------------------------------------------------------
// System Includes
// -----------------------------------------------------------------------
//
//  Prevent lego errors under Chicago.
//
// For TLS on Nt we use a reserved DWORD in the TEB directly. We need these
// include files to get the macro NtCurrentTeb(). They must be included
// before windows.h
extern "C"
{
#include <nt.h>         // NT_PRODUCT_TYPE
#include <ntdef.h>      // NT_PRODUCT_TYPE
#include <ntrtl.h>      // NT_PRODUCT_TYPE
#include <nturtl.h>     // NT_PRODUCT_TYPE
#include <windef.h>     // NT_PRODUCT_TYPE
#include <winbase.h>    // NT_PRODUCT_TYPE
}

#include <wchar.h>
#include <StdLib.h>
#include <stddef.h>
#include <stdio.h>
#include <string.h>
#include <limits.h>

// Cairo builds use DBG==1; old OLE2 code used _DEBUG
#if DBG == 1
#define _DEBUG
#endif


// Guarantee that WIN32 is defined.
#ifndef WIN32
#define WIN32 100
#endif


#ifdef WIN32
#include <pcrt32.h>
#endif // WIN32

#include <windows.h>
#include <olecom.h>
#include <malloc.h>
#include <shellapi.h>


// -----------------------------------------------------------------------
// Debug Aids
// -----------------------------------------------------------------------

#define ComDebOut   CairoleDebugOut

#if DBG==1

#include    <debnot.h>

//  recast the user mode debug flags to meaningfull names. These are
//  used in xDebugOut calls.
#define DEB_DLL         0x0008          // DLL Load/Unload
#define DEB_CHANNEL     DEB_USER1       // rpc channel
#define DEB_DDE         DEB_USER2       // dde
#define DEB_CALLCONT    DEB_USER3       // call control & msg filter
#define DEB_MARSHAL     DEB_USER4       // interface marshalling
#define DEB_SCM         DEB_USER5       // rpc calls to the SCM
#define DEB_ROT         DEB_USER6       // running object table
#define DEB_ACTIVATE    DEB_USER7       // object activation
#define DEB_OXID        DEB_USER8       // OXID stuff
#define DEB_REG         DEB_USER9       // registry calls
#define DEB_COMPOBJ     DEB_USER10      // misc compobj
#define DEB_MEMORY      DEB_USER11      // memory allocations
#define DEB_RPCSPY      DEB_USER12      // rpc spy to debug output
#define DEB_MFILTER     DEB_USER13      // message filter
#define DEB_ENDPNT      DEB_USER13      // endpoint stuff
#define DEB_PAGE        DEB_USER14      // page allocator
#define DEB_APT         DEB_USER15      // neutral apartment

#define ComDebErr(failed, msg)  if (failed) { ComDebOut((DEB_ERROR, msg)); }

#else   // DBG

#define ComDebErr(failed, msg)

#endif  // DBG


#ifdef DCOM
//-------------------------------------------------------------------
//
//  class:      CDbgGuidStr
//
//  Synopsis:   Class to convert guids to strings in debug builds for
//              debug outs
//
//--------------------------------------------------------------------
class CDbgGuidStr
{
public:
    ~CDbgGuidStr() {}
#if DBG==1
    CDbgGuidStr(REFGUID rguid) { StringFromGUID2(rguid, _wszGuid, 40); }
    WCHAR _wszGuid[40];
#else
    CDbgGuidStr(REFGUID rguid) {}
#endif
};
#endif


// -----------------------------------------------------------------------
// Public Includes
// -----------------------------------------------------------------------
#include <ole2.h>
#include <ole2sp.h>
#include <ole2com.h>


// -----------------------------------------------------------------------
// Apartment Activator Handle
// -----------------------------------------------------------------------

typedef DWORD HActivator;

// -----------------------------------------------------------------------
// Internal Includes
// -----------------------------------------------------------------------
#include <utils.h>
#include <olecoll.h>
#include <valid.h>
#include <array_fv.h>
#include <map_kv.h>
#include <privguid.h>
#include <tls.h>
#include <memapi.hxx>
#include <ccapi.hxx>
#include <verify.hxx>

// Macros for character string pointer manipulation

#ifdef _MAC
#define IncLpch IncLpch
#define DecLpch DecLpch
#else
// Beware of double evaluation
// Some components are not UNICODE enabled.
#define IncLpch(sz)          ((sz)=CharNextW ((sz)))
#define DecLpch(szStart, sz) ((sz)=CharPrevW ((szStart),(sz)))
#endif



//
// This function is shared between the DDE layer and the ROT
//

HRESULT GetLocalRunningObjectForDde(LPOLESTR    lpstrPath,
                                    LPUNKNOWN * ppunkObject);



// -----------------------------------------------------------------------
// Activation Externs
// -----------------------------------------------------------------------

#include <olerem.h>
#include <iface.h>

// Internal COM Init/Uninit routines
INTERNAL wCoInitializeEx(COleTls &Tls, DWORD flags);
INTERNAL InitializeNTA();
INTERNAL_(void) wCoUninitialize(COleTls &Tls, BOOL fHostThread);

// Main thread Init/Uninit routines
HRESULT InitMainThreadWnd(void);
void UninitMainThreadWnd(void);

// Process uninit routine
HRESULT RegisterOleWndClass(void);
void UnRegisterOleWndClass(void);

// Main thread window handle and TID
extern HWND  ghwndOleMainThread;
extern DWORD gdwMainThreadId;

// called by marshaling code on first marshal/last release of ICF interface
INTERNAL_(BOOL) NotifyActivation(BOOL fLock, IUnknown *pUnk);

// flag value used by the Activation ObjServer in ServerGetClassObject
const DWORD MSHLFLAGS_NOTIFYACTIVATION = 0x80000000;


// global count of per-process COM initializations
extern DWORD g_cProcessInits;


// Messages on OLE windows. RPC MSWMSG uses other values too.
// Messages Sent/Posted by OLE should have the magic value in WPARAM as this
// is used by USER32 to enable/diable SetForegroundWindow. The magic value is
// also in  ntuser\kernel\userk.h.
const DWORD WMSG_MAGIC_VALUE      = 0x0000babe;

const UINT WM_OLE_ORPC_POST      = (WM_USER + 0);
const UINT WM_OLE_ORPC_SEND      = (WM_USER + 1);
const UINT WM_OLE_ORPC_DONE      = (WM_USER + 2);
const UINT WM_OLE_ORPC_RELRIFREF = (WM_USER + 3);
const UINT WM_OLE_ORPC_NOTIFY    = (WM_USER + 4);
const UINT WM_OLE_GETCLASS       = (WM_USER + 5);
const UINT WM_OLE_GIP_REVOKE     = (WM_USER + 6);
const UINT WM_OLE_SIGNAL         = (WM_USER + 7);
const UINT WM_OLE_LAST           = (WM_USER + 8);

const UINT OLE_MESSAGE_COUNT     = (WM_OLE_LAST - WM_USER);

LRESULT OleMainThreadWndProc(HWND hWnd, UINT message,
                             WPARAM wParam, LPARAM lParam);

extern DWORD gdwScmProcessID;

// -----------------------------------------------------------------------
// ORPC Externs
// -----------------------------------------------------------------------

#include <sem.hxx>
#pragma warning (disable: 4509)
#include <olesem.hxx>

// functions for thread-safe Release
const DWORD CINDESTRUCTOR = 0x80000000;
INTERNAL_(BOOL) InterlockedDecRefCnt(ULONG *pcRefs, ULONG *pcNewRefs);
INTERNAL_(BOOL) InterlockedRestoreRefCnt(ULONG *pcRefs, ULONG *pcNewRefs);


extern COleStaticMutexSem g_mxsSingleThreadOle;

STDAPI_(BOOL) ThreadNotification(HINSTANCE, DWORD, LPVOID);
STDAPI        ChannelRegisterProtseq(WCHAR *pwszProtseq);

STDAPI        ChannelProcessInitialize  ();
STDAPI        ChannelThreadInitialize   ();
STDAPI_(void) ChannelProcessUninitialize( void );
STDAPI_(void) ChannelThreadUninitialize ( void );
STDAPI_(BOOL) ThreadStop                ( BOOL fHostThread );

STDAPI_(void) ObjactThreadUninitialize(void);

INTERNAL_(void) CleanupThreadCallObjects(SOleTlsData *pTls);
INTERNAL_(void) IDTableThreadUninitialize(void);
INTERNAL_(void) IDTableProcessUninitialize(void);

#ifdef DCOM
extern BOOL gSpeedOverMem;
#else
STDAPI_(void) ChannelStopListening(void);
STDAPI        ChannelControlProcessInitialize(void);
STDAPI_(void) ChannelControlThreadUninitialize(void);
STDAPI_(void) ChannelControlProcessUninitialize(void);
#endif

HRESULT CacheCreateThread( LPTHREAD_START_ROUTINE fn, void *param );

#ifdef DCOM
// -----------------------------------------------------------------------
// Marshalling Externs
// -----------------------------------------------------------------------

// internal subroutines used by COXIDTable ResolveOXID and GetLocalEntry.
INTERNAL MarshalInternalObjRef  (OBJREF &objref, REFIID riid, void *pv,
                                 DWORD mshlflags, void **ppStdId);
INTERNAL MarshalObjRef          (OBJREF &objref, REFIID riid, LPVOID pv,
                                 DWORD mshlflags, DWORD dwDestCtx, void *pvDestCtx);
INTERNAL UnmarshalInternalObjRef(OBJREF &objref, void **ppv);
INTERNAL UnmarshalObjRef        (OBJREF &objref, void **ppv, BOOL fBypassActLock = FALSE);
INTERNAL ReleaseMarshalObjRef   (OBJREF &objref);

// internal routines used by Drag & Drop
INTERNAL_(void) FreeObjRef       (OBJREF &objref);
INTERNAL        CompleteObjRef   (OBJREF &objref, OXID_INFO &oxidInfo, REFIID riid, BOOL *pfLocal);
INTERNAL        FillLocalOXIDInfo(OBJREF &objref, OXID_INFO &oxidInfo);

// internal subroutine used by CRpcResolver
INTERNAL InitChannelIfNecessary();

// Internal routines used by objact
BOOL     CheckObjactAccess();
INTERNAL HandleIncomingCall(REFIID riid, WORD iMethod, DWORD CallCatIn, void *pv);
INTERNAL NTAChannelInitialize();

// Internal routines used by ComDllGetClassObject
INTERNAL GetGIPTblCF(REFIID riid, void **ppv);


#endif  // DCOM

// -----------------------------------------------------------------------
// Access Control Externs
// -----------------------------------------------------------------------

HRESULT ComDllGetClassObject     ( REFCLSID clsid, REFIID riid, void **ppv );
HRESULT InitializeAccessControl  ();
void    UninitializeAccessControl();

// -----------------------------------------------------------------------
// Neutral Apartment
// -----------------------------------------------------------------------
INTERNAL_(void) CleanUpApartmentObject();

// Cached exe file name and length
extern WCHAR gawszImagePath[];
extern DWORD gcImagePath;

//
// Definitions used in Win64 to fix up SECURITY_DESCRIPTOR problems
//
#ifdef _WIN64
#define OLE2INT_ROUND_UP( x, y )  ((size_t)(x) + ((y)-1) & ~((y)-1))
#endif

#include <secret.hxx>

#endif  // _OLE2INT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\com\inc\pathkey.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:	pathkey.cxx
//
//  Contents:	static definitions used by string key class
//
//  History:	09-May-93 Ricksa    Created
//
//--------------------------------------------------------------------------
#include    <ole2int.h>
#include    "pathkey.hxx"

//+-------------------------------------------------------------------------
//
//  Member:	CPathBaseKey::CPathBaseKey
//
//  Synopsis:	Construct key from path
//
//  Arguments:	[pwszPath] - path to use for the key
//
//  History:	09-May-93 Ricksa    Created
//
//--------------------------------------------------------------------------

CPathBaseKey::CPathBaseKey(const WCHAR *pwszPath)
{
    _cPath = (lstrlenW(pwszPath) + 1) * sizeof(WCHAR);
    _pwszPath = (WCHAR *) PrivMemAlloc(_cPath);

    // Check for out of memory
    if (_pwszPath != NULL)
    {
        // Copy in path
        memcpy(_pwszPath, pwszPath, _cPath);
    }
    else
    {
	CairoleDebugOut((DEB_ERROR,
		     "CPathBaseKey::CPathBaseKey Alloc of path failed\n"));
	_cPath = 0;
    }
#if DBG==1
    _ulSig = PATHBASEKEYSIG;
#endif
}

//+-------------------------------------------------------------------------
//
//  Member:	CPathBaseKey::CPathBaseKey
//
//  Synopsis:	Construct key from another key
//
//  Arguments:	[pwszPath] - path to use for the key
//
//  History:	09-May-93 Ricksa    Created
//
//  Notes:	We must explicitly define the copy constructor
//		because of the current implementation of exception
//		handling.
//
//--------------------------------------------------------------------------

CPathBaseKey::CPathBaseKey(const CPathBaseKey& cpthbky)
{
    _cPath = cpthbky._cPath;
    _pwszPath = (WCHAR *) PrivMemAlloc(_cPath);

    // Check for out of memory
    if (_pwszPath != NULL)
    {
        memcpy(_pwszPath, cpthbky._pwszPath, cpthbky._cPath);
    }
    else
    {
	CairoleDebugOut((DEB_ERROR,
		    "CPathBaseKey::CPathBaseKey Alloc of path failed\n"));
	_cPath = 0;
    }
#if DBG==1
    _ulSig = PATHBASEKEYSIG;
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\com\inc\map_gp.h ===
////////////////////////////////////////////////////////////////////////////



class FAR CMapGUIDToPtr
{
public:
	// Construction
	CMapGUIDToPtr(DWORD memctx = MEMCTX_SAME, UINT nBlockSize=10) 
		: m_mkv(memctx, sizeof(void FAR*), sizeof(GUID), nBlockSize) { }

	// Attributes
	// number of elements
	int     GetCount() const
				{ return m_mkv.GetCount(); }
	BOOL    IsEmpty() const
				{ return GetCount() == 0; }

	// Lookup
	BOOL    Lookup(REFGUID key, void FAR* FAR& value) const
				{ return m_mkv.Lookup((LPVOID)&key, sizeof(GUID), (LPVOID)&value); }

	BOOL    LookupHKey(HMAPKEY hKey, void FAR* FAR& value) const
				{ return m_mkv.LookupHKey(hKey, (LPVOID)&value); }

	BOOL    LookupAdd(REFGUID key, void FAR* FAR& value) const
				{ return m_mkv.LookupAdd((LPVOID)&key, sizeof(GUID), (LPVOID)&value); }

	// Add/Delete
	// add a new (key, value) pair
	BOOL    SetAt(REFGUID key, void FAR* value)
				{ return m_mkv.SetAt((LPVOID)&key, sizeof(GUID), (LPVOID)&value); }
	BOOL    SetAtHKey(HMAPKEY hKey, void FAR* value)
				{ return m_mkv.SetAtHKey(hKey, (LPVOID)&value); }

	// removing existing (key, ?) pair
	BOOL    RemoveKey(REFGUID key)
				{ return m_mkv.RemoveKey((LPVOID)&key, sizeof(GUID)); }

	BOOL    RemoveHKey(HMAPKEY hKey)
				{ return m_mkv.RemoveHKey(hKey); }

	void    RemoveAll()
				{ m_mkv.RemoveAll(); }


	// iterating all (key, value) pairs
	POSITION GetStartPosition() const
				{ return m_mkv.GetStartPosition(); }

	void    GetNextAssoc(POSITION FAR& rNextPosition, GUID FAR& rKey, void FAR* FAR& rValue) const
				{ m_mkv.GetNextAssoc(&rNextPosition, (LPVOID)&rKey, NULL, (LPVOID)&rValue); }

	HMAPKEY GetHKey(REFGUID key) const
				{ return m_mkv.GetHKey((LPVOID)&key, sizeof(GUID)); }

#ifdef _DEBUG
	void    AssertValid() const
				{ m_mkv.AssertValid(); }
#endif

private:
	CMapKeyToValue m_mkv;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\com\inc\map_dwp.h ===
////////////////////////////////////////////////////////////////////////////



class FAR CMapDwordPtr : public CPrivAlloc
{
public:
	// Construction
	CMapDwordPtr(UINT nBlockSize=10)
		: m_mkv(sizeof(void FAR*), sizeof(DWORD), nBlockSize) { }

	// Attributes
	// number of elements
	int     GetCount() const
				{ return m_mkv.GetCount(); }
	BOOL    IsEmpty() const
				{ return GetCount() == 0; }

	// Lookup
	BOOL    Lookup(DWORD key, void FAR* FAR& value) const
				{ return m_mkv.Lookup((LPVOID)&key, sizeof(DWORD), (LPVOID)&value); }

	BOOL    LookupHKey(HMAPKEY hKey, void FAR* FAR& value) const
				{ return m_mkv.LookupHKey(hKey, (LPVOID)&value); }

	BOOL    LookupAdd(DWORD key, void FAR* FAR& value) const
				{ return m_mkv.LookupAdd((LPVOID)&key, sizeof(DWORD), (LPVOID)&value); }

	// Add/Delete
	// add a new (key, value) pair
	BOOL    SetAt(DWORD key, void FAR* value)
				{ return m_mkv.SetAt((LPVOID)&key, sizeof(DWORD), (LPVOID)&value); }
	BOOL    SetAtHKey(HMAPKEY hKey, void FAR* value)
				{ return m_mkv.SetAtHKey(hKey, (LPVOID)&value); }

	// removing existing (key, ?) pair
	BOOL    RemoveKey(DWORD key)
				{ return m_mkv.RemoveKey((LPVOID)&key, sizeof(DWORD)); }

	BOOL    RemoveHKey(HMAPKEY hKey)
				{ return m_mkv.RemoveHKey(hKey); }

	void    RemoveAll()
				{ m_mkv.RemoveAll(); }


	// iterating all (key, value) pairs
	POSITION GetStartPosition() const
				{ return m_mkv.GetStartPosition(); }

	void    GetNextAssoc(POSITION FAR& rNextPosition, DWORD FAR& rKey, void FAR* FAR& rValue) const
				{ m_mkv.GetNextAssoc(&rNextPosition, (LPVOID)&rKey, NULL, (LPVOID)&rValue); }

	HMAPKEY GetHKey(DWORD key) const
				{ return m_mkv.GetHKey((LPVOID)&key, sizeof(DWORD)); }

#ifdef _DEBUG
	void    AssertValid() const
				{ m_mkv.AssertValid(); }
#endif

private:
	CMapKeyToValue m_mkv;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\com\inc\pattbl.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1993 - 1993.
//
//  File:	pattbl.cxx
//
//  Contents:	File pattern to clsid table.
//
//  Classes:	CPatternTbl
//		CScmPatternTbl
//              CProcessPatternTbl
//
//  Functions:	none
//
//  History:	20-May-94   Rickhi	Created
//              12-Dec-94   BruceMa     Support pattern table on Chicago
//              20-Feb-95   BruceMa     Don't pick up file patterns for
//                                      invalid CLSID's
//		26-Sep-96   t-KevinH	Per process pattern table
//
//  CODEWORK:	Should add Docfile pattern in here and create a private
//		storage API that accepts a file handle and returns the
//		clsid so we minimize the Opens in all cases.
//
//----------------------------------------------------------------------------
#include    <ole2int.h>
#include    <pattbl.hxx>
#include    <reghelp.hxx>


//+-------------------------------------------------------------------------
//
//  function:	Matches
//
//  Synopsis:	checks if the bytes in the buffer match the given pattern
//
//  Arguments:	[pFileBuf] - buffer containing the file data
//		[pEntry]   -
//
//  Returns:	pEntry if found, NULL otherwise.
//
//--------------------------------------------------------------------------
static BOOL Matches(BYTE *pFileBuf, SPatternEntry *pEntry)
{
    //	the pattern bytes follow the mask bytes. they are the same size.
    BYTE *pbMask    = pEntry->abData;
    BYTE *pbPattern = pbMask + pEntry->ulCb;

    for (ULONG iCtr = 0; iCtr < pEntry->ulCb; iCtr++)
    {
	if ((BYTE)(*(pFileBuf + iCtr) & *pbMask) != *pbPattern)
	{
	    return FALSE;
	}

	//  update the mask & pattern bytes
	pbMask++;
	pbPattern++;
    }

    return TRUE;
}

//+-------------------------------------------------------------------------
//
//  function:	MatchOneEntry
//
//  Synopsis:	Try to match a pattern in a file.
//
//  Arguments:	[hFile] - handle to the file to look in
//		[pBuf] - file buffer
//		[pEntry] - the pattern to match
//		[pfLook] - a flag used by SearchForPattern
//		[plLastOffset] - keeps the last read offset
//		[pulLastCb] - keeps the last read byte count
//
//  Returns:	S_OK if successfull
//
//--------------------------------------------------------------------------
static BOOL MatchOneEntry(HANDLE hFile, BYTE *pBuf, SPatternEntry *pEntry,
			  BOOL *pfLook, LONG *plLastOffset, ULONG *pulLastCb)
{
    if (pEntry->lFileOffset != *plLastOffset ||
	pEntry->ulCb > *pulLastCb)
    {
	// must read part of the file

	DWORD   cbRead = 0;
	DWORD   dwMethod;
	LONG    cbMove;

	if (pEntry->lFileOffset < 0)
	{
	    cbMove = -1;
	    dwMethod = FILE_END;
	}
	else
	{
	    cbMove = 0;
	    dwMethod = FILE_BEGIN;
	}

	*pfLook = FALSE; // assume failure

	if (SetFilePointer(hFile, pEntry->lFileOffset, &cbMove, dwMethod)
	     != 0xffffffff)
	{
	    if (ReadFile(hFile, pBuf, pEntry->ulCb, &cbRead, NULL))
	    {
		//	remember the last read positions
		*plLastOffset = pEntry->lFileOffset;
		*pulLastCb = pEntry->ulCb;
		*pfLook = TRUE;
	    }
	}
    }

    //  compare the patterns
    return *pfLook && Matches(pBuf, pEntry);
}

//+-------------------------------------------------------------------------
//
//  function:	IsValidPattern
//
//  Synopsis:	determines if the pattern entry read from the registry is of
//		a valid format. See ParseEntry for the format.
//
//  Arguments:	[psz] - pattern buffer
//		[cb]  - size of buffer read
//
//  Returns:	TRUE if pattern is valid, FALSE otherwise
//
//--------------------------------------------------------------------------
static BOOL IsValidPattern(LPWSTR psz, LONG cb)
{
    // we must find exactly 3 commas before the end of the string
    // in order for the entry to be of a parseable format.

    ULONG  cCommas = 0;
    LPWSTR pszEnd = psz + (cb / sizeof(WCHAR));

    while (psz < pszEnd && *psz)
    {
	if (*psz == ',')
	    cCommas++;

	psz++;
    }

    return (cCommas == 3) ? TRUE : FALSE;
}

//+-------------------------------------------------------------------------
//
//  function:	SkipToNext
//
//  Synopsis:	skips missing entries in the list and whitespaces
//
//  Arguments:	[sz] - ptr to string
//
//  Returns:	ptr to next entry in the list
//
//--------------------------------------------------------------------------
static LPWSTR SkipToNext(LPWSTR sz)
{
    while (*sz && *sz != ',')
    {
	sz++;
    }

    Assert(*sz == ',');
    sz++;

    while (*sz)
    {
        USHORT CharType[1];

        GetStringTypeW (CT_CTYPE1, sz, 1, CharType);
        if ((CharType[0] & C1_SPACE) == 0) 
        {
            break;
        }
	sz++;
    }

    return sz;
}

//+-------------------------------------------------------------------------
//
//  function:	ToHex
//
//  Synopsis:	converts two characters to a hex byte
//
//  Arguments:	[psz] - ptr to string
//
//  Returns:	the value of the string in hex
//
//--------------------------------------------------------------------------
static BYTE ToHex(LPWSTR psz)
{
    BYTE bMask = 0xFF;
    USHORT CharTypes[2] = {0, 0}; // Init the variable

	//
	// GetStringTypeW can only return failure for invalid args.
	// The only variable argument here is the incoming psz, so
	// we should be OK.  Assert that this thing succeeded.
	//
    BOOL bStatus = GetStringTypeW (CT_CTYPE1, psz, 2, CharTypes);
	Win4Assert(bStatus && "GetStringTypeW failed in ToHex()");

    if (CharTypes[0] & C1_XDIGIT)
    {
		bMask = (BYTE) (CharTypes[0] & C1_DIGIT ? *psz - '0' : (BYTE)CharUpperW((LPWSTR)*psz) - 'A' + 10);

		psz++;
		if (CharTypes[1] & C1_XDIGIT)
		{
			bMask *= 16;
			bMask = bMask + (BYTE) (CharTypes[1] & C1_DIGIT ? *psz - '0' : (BYTE)CharUpperW((LPWSTR)*psz) - 'A' + 10);
			psz++;
		}
    }

    return bMask;
}

//+-------------------------------------------------------------------------
//
//  function:	ParseEntry
//
//  Synopsis:	takes the registry string and parses it into a table entry.
//
//  Arguments:	[psz] - ptr to string from registry
//		[cb]  - size of psz
//		[pEntry] - ptr to pattern table entry
//		[rclsid] - clsid the pattern maps to
//
//  Returns:	TRUE for sucessful parse, FALSE OTHERWISE - pEntry updated
//
//  Notes:	the format of the registry string is...
//		<offset>,<cb>,<mask>,<pattern>
//		where...
//		<offset> and <cb> are decimal unless preceeded by 0x
//		<mask> is optional (not there means use all 1's
//
//--------------------------------------------------------------------------
static BOOL ParseEntry(LPWSTR psz, LONG cb, SPatternEntry *pEntry, REFCLSID rclsid)
{
    // validate the pattern before we attempt to parse it, simplifies
    // error handling in the rest of the routine.
    if	(!IsValidPattern(psz, cb))
	return FALSE;

    //	copy in the clsid
    memcpy(&pEntry->clsid, &rclsid, sizeof(CLSID));

    //	get the file offset
    pEntry->lFileOffset = wcstol(psz, NULL, 0);
    psz = SkipToNext(psz);

    //	get the byte count
    pEntry->ulCb = wcstol(psz, NULL, 0);
    Assert(pEntry->ulCb > 0);

    //	get the mask ptrs
    LPWSTR pszMask = SkipToNext(psz);
    BYTE  *pbMask = pEntry->abData;

    //	get the pattern ptrs
    LPWSTR pszPattern = SkipToNext(pszMask);
    BYTE  *pbPattern = pbMask + pEntry->ulCb;

    //	convert and copy the mask & pattern bytes into the pEntry
    for (ULONG ulCb = pEntry->ulCb; (ulCb > 0 && *pszMask && *pszPattern); ulCb--)
    {
	if (*pszMask == ',')
	{
	    // missing mask means use 0xff
	    *pbMask = 0xff;
	}
	else
	{
	    //	convert the mask string to a byte
	    *pbMask = ToHex(pszMask);

		// Move past the 2-digit hex number.
		// But be careful not to step over the NULL terminator
		pszMask++;
		if(*pszMask)
			pszMask++;
	}
	pbMask++;

	//  convert the pattern string to a byte
	*pbPattern = ToHex(pszPattern);
	pbPattern++;
	pszPattern++;
	if(*pszPattern)
		pszPattern++;
    }
	// If we didn't consume all the bytes (i.e. We hit the end of the string too soon), then
	// we have a bad pattern.
	if(ulCb > 0)
		return FALSE;
	
    //	compute this entry size, rounded to 8 byte alignment.
    //	Note: the struct has 4 bytes in abData, so the sizeof
    //	returns 4 more than we need.
    pEntry->ulEntryLen = ((sizeof(SPatternEntry) - 4 +
			  (2 * pEntry->ulCb)  + 7) & 0xfff8);

    return TRUE;
}

//+-------------------------------------------------------------------------
//
//  member:	CPatternTbl::FindPattern
//
//  Synopsis:	Finds a pattern in a file.
//
//  Arguments:	[hFile] - handle to the file to look in
//		[pclsid] - where to return the clsid
//
//  Returns:	S_OK if successfull
//
//--------------------------------------------------------------------------
HRESULT CPatternTbl::FindPattern(HANDLE hFile, CLSID *pClsid)
{
    if (!IsEmpty())
    {
	return SearchForPattern(hFile, pClsid);
    }
    else
    {
	//  no entry found, and the cache is not full, so return an error.
	return REGDB_E_CLASSNOTREG;
    }
}

//+-------------------------------------------------------------------------
//
//  member:	CPatternTbl::SearchForPattern
//
//  Synopsis:	searches in the file for a know pattern, and returns the
//		CLSID index if found.
//
//  Arguments:	[hFile] - handle to the file to look in
//		[pclsid] - where to return the clsid
//
//  Returns:	pEntry if found, NULL otherwise.
//
//--------------------------------------------------------------------------
HRESULT CPatternTbl::SearchForPattern(HANDLE hFile, CLSID *pClsid)
{
    HRESULT hr = REGDB_E_CLASSNOTREG;
    LONG    lLastOffset = 0;
    ULONG   ulLastCb = 0;
    BYTE    bStackBuf[256];
    BYTE   *pBuf = bStackBuf;

    if (_pTblHdr->cbLargest > sizeof(bStackBuf))
    {
	//  allocate a buffer big enough for largest pattern
	pBuf = (BYTE *) PrivMemAlloc(_pTblHdr->cbLargest);
	if(pBuf == NULL)
		return E_OUTOFMEMORY;
    }

    //	now grovel through the file looking for a pattern match

    BYTE *pCurr = _pStart;
    BYTE *pEnd	= _pStart + (_pTblHdr->OffsEnd - _pTblHdr->OffsStart);

    while (pCurr < pEnd)
    {
	SPatternEntry *pEntry = (SPatternEntry *)pCurr;
	BOOL fLook = TRUE;

	if (MatchOneEntry(hFile, pBuf, pEntry, &fLook, &lLastOffset, &ulLastCb))
	{
	    //	found a match, return the index of the CLSID
	    memcpy(pClsid, &pEntry->clsid, sizeof(CLSID));
	    hr = S_OK;

	    break;
	}

	//  get the next entry
	pCurr = pCurr + pEntry->ulEntryLen;
    }

    //	free the buffer if we need to
    if (pBuf != bStackBuf)
    {
	PrivMemFree(pBuf);
    }

    return hr;
}


//+-------------------------------------------------------------------------
//
//  member:	CScmPatternTbl::InitTbl
//
//  Synopsis:	reads the registry entries and converts them to a shared
//		memory table format
//
//  Returns:	S_OK if successfull.
//		E_OUTOFMEMORY
//
//--------------------------------------------------------------------------
HRESULT CScmPatternTbl::InitTbl()
{
    //	allocate local memory in which to build the table
    _pLocTbl = (BYTE *) PrivMemAlloc(PATTBL_GROW_SIZE);
    if (!_pLocTbl)
    {
	    return E_OUTOFMEMORY;
    }

    //	cast for simplicity
    STblHdr *pLocTbl = (STblHdr *) _pLocTbl;

    //	initialize the table header
    pLocTbl->ulSize = PATTBL_GROW_SIZE;
    pLocTbl->OffsStart = sizeof(STblHdr);
    pLocTbl->OffsEnd = sizeof(STblHdr);
    pLocTbl->cbLargest = 0;


    //	build the table from the data in the registry
    HKEY hkFileType;

    if (OpenClassesRootKey(L"FileType",&hkFileType)== ERROR_SUCCESS)
    {
    	//  enumerate the clsid's under this key
    	WCHAR	szBuf[40];
    	DWORD	iClsid = 0;

    	while (RegEnumKey(hkFileType, iClsid, szBuf, sizeof(szBuf) / sizeof(WCHAR)) == ERROR_SUCCESS)
    	{
    		// Make sure it's null-terminated
    		szBuf[sizeof(szBuf) / sizeof(WCHAR) - 1] = L'\0';
    	    // ensure this is a valid clsid
    	    WCHAR szTemp[MAX_PATH];
    	    LONG  cbTemp = sizeof(szTemp);

    	    WCHAR szClsid[80];
    	    lstrcpyW(szClsid, L"Clsid\\");
    	    lstrcatW(szClsid, szBuf);

    	    if (QueryClassesRootValue(szClsid, szTemp, &cbTemp)
    		    == ERROR_SUCCESS)
    	    {
    		// clsid exist, open the key and enumerate the entries.
    		HKEY    hkClsid;
            CLSID	clsid;
            BOOL    fValid;

                    // Fetch asociated file patterns only if CLSID is valid
    		if (GUIDFromString(szBuf, &clsid)  &&
                        RegOpenKeyEx(hkFileType, szBuf, 0, KEY_READ, &hkClsid) == ERROR_SUCCESS)
    		{

    		    //	enumerate the patterns under this clsid
    		    WCHAR	szNum[10];
    		    DWORD	iPattern = 0;

    		    while (RegEnumKey(hkClsid, iPattern, szNum, sizeof(szNum) / sizeof(WCHAR))
                               == ERROR_SUCCESS)
    		    {
    			// read the registry value and parse the string to
    			// create a table entry

    			WCHAR szPattern[513];
    			LONG cb = sizeof(szPattern) - 2;
    			BOOL fSkip = FALSE;

    			if (RegQueryValue(hkClsid, szNum, szPattern, &cb) ==
                                ERROR_SUCCESS)
    			{
    				// Make sure we null-terminate this at the end of the data.
    				szPattern[cb / sizeof(WCHAR)] = L'\0';
    			
    				// Make sure we have enough space available.  We only need as many bytes as we have
    				// characters (cb/2), because the string has hex characters and one character can never map
    				// to more than 1 byte.
    				ULONG ulNewSize = sizeof(SPatternEntry) + pLocTbl->OffsEnd + (cb+1)/2;
    				if(ulNewSize > pLocTbl->ulSize)
    				{
    					ulNewSize = MAX(ulNewSize,pLocTbl->ulSize + PATTBL_GROW_SIZE);
    					void *pNewBlock = PrivMemAlloc(ulNewSize);
    					if(pNewBlock != NULL)
    					{
    						memcpy(pNewBlock,pLocTbl,pLocTbl->OffsEnd);
    						PrivMemFree(pLocTbl);
    						_pLocTbl = (BYTE *) pNewBlock;
    						pLocTbl = (STblHdr *) _pLocTbl;
    						pLocTbl->ulSize = ulNewSize;
    					}
    					else
    					{
    						// If we are out of memory, just skip this entry and move on to the next one.
    						// Not all entries will necessarily require so much memory.
    						fSkip = TRUE;
    					}
    				}
    					
    				if(!fSkip)
    				{
    				    SPatternEntry *pEntry = (SPatternEntry *)
    						((BYTE *)_pLocTbl + pLocTbl->OffsEnd);

    				    if (ParseEntry(szPattern, cb, pEntry, clsid))
    				    {
    					// update the table header
    					pLocTbl->cbLargest = MAX(pLocTbl->cbLargest,
    							     pEntry->ulCb);

    					pLocTbl->OffsEnd += pEntry->ulEntryLen;
    				    }
    				}
    			}

    			++iPattern;
    		    }

    		    RegCloseKey(hkClsid);
    		}
	    }

	    ++iClsid;
	}

	RegCloseKey(hkFileType);
    }

    //	update the table size to something reasonable. Use the combined size
    //	of all the entries we generated above, plus some padding for
    //	expansion.  We return this size to the caller.

    pLocTbl->ulSize = sizeof(STblHdr) + pLocTbl->OffsEnd;

    return S_OK;
}



//+-------------------------------------------------------------------------
//
//  Member:	CProcessPatternTbl::CProcessPatternTbl
//
//  Synopsis:	Constructor
//
//  Arguments:	fOk     -       FALSE is initialization failed
//
//  Returns:	-
//
//--------------------------------------------------------------------------
CProcessPatternTbl::CProcessPatternTbl(HRESULT &hr)
{
    // Allocate internal structures
    m_pPatTbl = new CPatternTbl();
    m_pScmPatTbl = new CScmPatternTbl();
    if (m_pPatTbl == NULL  ||  m_pScmPatTbl == NULL)
    {
        hr = E_OUTOFMEMORY;
        return;
    }

    // Read the patterns from the registry
    if (FAILED(hr = m_pScmPatTbl->InitTbl()))
    {
        return;
    }

    // So CPatternTbl can use them
    m_pPatTbl->Initialize(m_pScmPatTbl->GetTbl());

    //Good return
    hr = S_OK;
    return;
}

//+-------------------------------------------------------------------------
//
//  Member:	CProcessPatternTbl::~CProcessPatternTbl
//
//  Synopsis:	Destructor
//
//  Arguments:	-
//
//  Returns:	-
//
//--------------------------------------------------------------------------
CProcessPatternTbl::~CProcessPatternTbl(void)
{
    delete m_pPatTbl;
    delete m_pScmPatTbl;
}

//+-------------------------------------------------------------------------
//
//  Member:	CProcessPatternTbl::IsEmpty
//
//  Synopsis:	Determines if the pattern table is empty
//
//  Arguments:	-
//
//  Returns:	TRUE if table is empty; FALSE otherwise
//
//--------------------------------------------------------------------------
BOOL CProcessPatternTbl::IsEmpty(void)
{
    return m_pPatTbl->IsEmpty();;
}

//+-------------------------------------------------------------------------
//
//  Member:	CProcessPatternTbl::FindPattern
//
//  Synopsis:	Search for byte patterns in the specified file
//
//  Arguments:	hFile   -       Handle of file to search
//              pClsid  -       Where to store the returned CLSID
//
//  Returns:	HRESULT
//
//--------------------------------------------------------------------------
HRESULT CProcessPatternTbl::FindPattern(HANDLE hFile, CLSID *pClsid)
{
    return m_pPatTbl->FindPattern(hFile, pClsid);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\com\inc\rotdata.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1993 - 1993.
//
//  File:       rotdata.cxx
//
//  Contents:   Functions supporting building ROT data comparison buffers
//
//  Functions:
//
//  History:    03-Feb-95   Ricksa  Created
//
//----------------------------------------------------------------------------
#include    <ole2int.h>
#include    <rotdata.hxx>




//+---------------------------------------------------------------------------
//
//  Function:   BuildRotDataFromDisplayName
//
//  Synopsis:   Build ROT comparison data from display name
//
//  Arguments:  [pbc] - bind context (optional)
//              [pmk] - moniker to use for display name
//              [pbData] - buffer to put the data in.
//              [cbMax] - size of the buffer
//              [pcbData] - count of bytes used in the buffer
//
//  Returns:    NOERROR
//              E_OUTOFMEMORY
//
//  Algorithm:  Build the bind context if necessary. Get the display name.
//              See if there is enough room in the buffer for the display
//              name and the clsid. If there is copy it in.
//
//  History:    03-Feb-95   ricksa  Created
//
// Note:
//
//----------------------------------------------------------------------------
HRESULT BuildRotDataFromDisplayName(
    LPBC pbc,
    IMoniker *pmk,
    BYTE *pbData,
    DWORD cbData,
    DWORD *pcbUsed)
{
    CairoleDebugOut((DEB_ROT, "%p _IN BuildRotDataFromDisplayName"
       "( %p , %p , %p , %lx , %p )\n", NULL, pbc, pmk, pbData, cbData,
           pcbUsed));

    HRESULT hr;
    BOOL fCreatedBindCtx = FALSE;
    WCHAR *pwszDisplayName = NULL;

    do {

        // Do we have a bind context to work with?
        if (pbc == NULL)
        {
            // Get the display name
            if ((hr = CreateBindCtx(0, &pbc)) != NOERROR)
            {
	        CairoleDebugOut((DEB_ERROR,
                    "BuildRotDataFromDisplayName CreateBindCtx Failed %lx\n",
                        hr));

                break;
            }

            fCreatedBindCtx = TRUE;
        }

        if ((hr = pmk->GetDisplayName(pbc, NULL, &pwszDisplayName)) != NOERROR)
        {
            CairoleDebugOut((DEB_ERROR,
                "BuildRotDataFromDisplayName IMoniker::GetDisplayName "
                    "failed %lx\n", hr));
            break;
        }

        DWORD dwLen = (lstrlenW(pwszDisplayName) + 1) * sizeof(WCHAR)
            + sizeof(CLSID);

        CLSID clsid;

        // Get the class id if we can
        if ((hr = pmk->GetClassID(&clsid)) == NOERROR)
        {
            // Assume that it is too big
            hr = E_OUTOFMEMORY;

            // Can the buffer hold all the data?
            if (dwLen <= cbData)
            {
                // Yes, so copy it in

                // First the CLSID
                memcpy(pbData, &clsid, sizeof(CLSID));

                // Uppercase the display name
                CharUpperW(pwszDisplayName);

                // Then the string for the display name
                lstrcpyW((WCHAR *) (pbData + sizeof(CLSID)), pwszDisplayName);

                *pcbUsed = dwLen;

                hr = S_OK;
            }
#if DBG == 1
            else
            {
                CairoleDebugOut((DEB_ERROR,
                    "BuildRotDataFromDisplayName Comparison buffer too bing\n"));
            }
#endif // DBG == 1
        }
#if DBG == 1
        else
        {
            CairoleDebugOut((DEB_ERROR,
                "BuildRotDataFromDisplayName IMoniker::GetClassID failed %lX\n",
                    hr));
        }
#endif // DBG == 1


    } while(FALSE);

    if (pwszDisplayName != NULL)
    {
        CoTaskMemFree(pwszDisplayName);
    }

    if (fCreatedBindCtx)
    {
        pbc->Release();
    }

    CairoleDebugOut((DEB_ROT, "%p OUT BuildRotDataFromDisplayName"
       "( %lx ) [ %lx ]\n", NULL, hr, *pcbUsed));

    return hr;
}




//+---------------------------------------------------------------------------
//
//  Function:   BuildRotData
//
//  Synopsis:   Build ROT comparison data from a moniker
//
//  Arguments:  [pmk] - moniker to use for display name
//              [pbData] - buffer to put the data in.
//              [cbMax] - size of the buffer
//              [pcbData] - count of bytes used in the buffer
//
//  Returns:    NOERROR
//              E_OUTOFMEMORY
//
//  Algorithm:  See if the moniker supports IROT data. If it does, then
//              use the result from that otherwise call through to
//              BuildRotDataFromDisplayName to build the data from the
//              display name if possible.
//
//  History:    03-Feb-95   ricksa  Created
//
// Note:
//
//----------------------------------------------------------------------------
HRESULT BuildRotData(
    LPBC pbc,
    IMoniker *pmk,
    BYTE *pbData,
    DWORD cbData,
    DWORD *pcbUsed)
{
    CairoleDebugOut((DEB_ROT, "%p _IN BuildRotData"
       "( %p , %p , %p , %lx , %p )\n", NULL, pbc, pmk, pbData, cbData,
           pcbUsed));

    HRESULT hr;
    IROTData *protdata = NULL;

    do {

        // Does the moniker support the new interface for registering
        // in the ROT?
        if (pmk->QueryInterface(IID_IROTData, (void **) &protdata)
            == NOERROR)
        {
            hr = protdata->GetComparisonData(
                pbData,
                cbData,
                pcbUsed);

#if DBG == 1
            if (FAILED(hr))
            {
                CairoleDebugOut((DEB_ERROR,
                    "BuildRotData IROTData::GetComparisonData failed %lX\n",
                        hr));
            }
#endif // DBG == 1

            if (SUCCEEDED(hr) && (hr != NOERROR))
            {
                // We got a success code that was not NOERROR. This makes
                // no sense since the only thing that can happen is the
                // buffer is filled with data. Therefore, we remap this to
                // an error.
                CairoleDebugOut((DEB_ERROR,
                    "BuildRotData IROTData::GetComparisonData return bad"
                        " success %lX\n", hr));

                hr = E_UNEXPECTED;
            }

            break;
        }

        hr = BuildRotDataFromDisplayName(NULL, pmk, pbData, cbData, pcbUsed);

    } while(FALSE);

    if (protdata != NULL)
    {
        protdata->Release();
    }

    CairoleDebugOut((DEB_ROT, "%p OUT BuildRotData"
       "( %lx ) [ %lx ]\n", NULL, hr, *pcbUsed));

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\com\inc\rothelp.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:	rothelp.cxx
//
//  Contents:   Implementation of helpers used by SCM and OLE32
//
//  Functions:  CreateFileMonikerComparisonBuffer
//
//  History:	30-Jan-95 Ricksa    Created
//
//--------------------------------------------------------------------------
#include    <ole2int.h>
#include    <rothint.hxx>
#include    <rothelp.hxx>



//+-------------------------------------------------------------------------
//
//  Function:   ScmRotHash
//
//  Synopsis:   Calculate hash value of comparison buffer in the SCM.
//
//  Arguments:  [pbKey] - pointer to buffer
//              [cdwKey] - size of buffer
//              [dwInitHash] - Initial hash value
//
//  Returns:    Hash value for SCM ROT entry.
//
//  History:	30-Jan-95 Ricksa    Created
//              30-Nov-95 BruceMa   Don't let the hash value overflow
//
//  Note:       The 3rd parameter is used only by RunningMoniker which
//              needs to compute partial hashes by path components
//
//--------------------------------------------------------------------------
DWORD ScmRotHash(BYTE *pbKey, DWORD cdwKey, DWORD dwInitHash)
{
    CairoleDebugOut((DEB_ROT, "%p _IN ScmRotHash"
       "( %p , %lx )\n", NULL, pbKey, cdwKey));

    DWORD   dwResult = dwInitHash;

    for (DWORD i = 0; i < cdwKey; i++)
    {
        dwResult *= 3;
        dwResult ^= *pbKey;
        dwResult %= SCM_HASH_SIZE;
        pbKey++;
    }

    CairoleDebugOut((DEB_ROT, "%p OUT ScmRotHash"
       "( %lx )\n", NULL, dwResult % SCM_HASH_SIZE));

    return dwResult;
}







//+-------------------------------------------------------------------------
//
//  Function:   CreateFileMonikerComparisonBuffer
//
//  Synopsis:   Convert a file path to a moniker comparison buffer
//
//  Arguments:  [pwszPath] - path
//              [pbBuffer] - comparison buffer
//              [cdwMaxSize] - maximum size of the comparison buffer
//              [cdwUsed] - number of bytes used in the comparison buffer
//
//  Returns:    NOERROR - comparison buffer successfully created
//              E_OUTOFMEMORY - The buffer was not big enough to hold the data.
//
//  History:	30-Jan-95 Ricksa    Created
//
//--------------------------------------------------------------------------
HRESULT CreateFileMonikerComparisonBuffer(
    WCHAR *pwszPath,
    BYTE *pbBuffer,
    DWORD cdwMaxSize,
    DWORD *pcdwUsed)
{
    CairoleDebugOut((DEB_ROT, "%p _IN CreateFileMonikerComparisonBuffer"
       "( %p , %p , %lx , %p )\n", NULL, pwszPath, pbBuffer, cdwMaxSize,
           pcdwUsed));

    // Assume there will be an error
    HRESULT hr = E_OUTOFMEMORY;
    *pcdwUsed = 0;

    // Cache size needed for path locally. Of course, the "+1" is required
    // for the terminating NUL in the string.
    DWORD cdwPath = (lstrlenW(pwszPath) + 1) * sizeof(WCHAR);

    // Figure out if the buffer is being enough to hold the data.
    DWORD cdwSizeNeeded = sizeof(CLSID) + cdwPath;

    if (cdwSizeNeeded <= cdwMaxSize)
    {
        // Copy in the CLSID for a file moniker
        memcpy(pbBuffer, &CLSID_FileMoniker, sizeof(CLSID_FileMoniker));

        // Copy in the path
        memcpy(pbBuffer + sizeof(CLSID_FileMoniker), pwszPath, cdwPath);

        // Uppercase the path in the comparison buffer
        CharUpperW((WCHAR *) (pbBuffer + sizeof(CLSID_FileMoniker)));

        *pcdwUsed = cdwSizeNeeded;

        hr = NOERROR;
    }

    CairoleDebugOut((DEB_ROT, "%p OUT CreateFileMonikerComparisonBuffer"
       "( %lx ) [ %lx ]\n", NULL, hr, *pcdwUsed));

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\com\inc\smblock.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1994.
//
//  File:	smblock.cxx
//
//  Contents:	Shared memory block code
//
//  Classes:	
//
//  Functions:	
//
//  History:	24-Mar-94	PhilipLa	Created
//
//----------------------------------------------------------------------------

#include <ole2int.h>
#include <smblock.hxx>
#include <smcreate.hxx>

#if DBG == 1
DECLARE_INFOLEVEL(mem);
#endif


//+---------------------------------------------------------------------------
//
//  Member:	CSharedMemoryBlock::~CSharedMemoryBlock, public
//
//  Synopsis:	Destructor
//
//  Returns:	Appropriate status code
//
//  History:	25-Apr-94	PhilipLa	Created
//
//----------------------------------------------------------------------------

CSharedMemoryBlock::~CSharedMemoryBlock()
{
    CloseSharedFileMapping(_hMem, _pbBase);
}

//+-------------------------------------------------------------------------
//
//  Member:	CSharedMemoryBlock::Init
//
//  Synopsis:	Create/get address of shared memory block.
//
//  Arguments:	[pszName] - name of block to allocate
//		[culSize] - size of block to allocate
//
//  Algorithm:	Attempts to open the block first. If this fails then
//		this creates the block of memory. It then puts the
//		address of the block as the first bytes of the block.
//		If the block already exists, the memory is mapped
//		and then the address is read. The memory is then mapped
//		to the address.
//
//  History:	03-Nov-93 Ricksa    Created
//              07-Jan-94 AlexT     No security for CHICAGO
//
//  Notes:	Counts on some outside synchronization to prevent
//		a race in the creation of the memory.
//
//--------------------------------------------------------------------------
SCODE CSharedMemoryBlock::Init(
        LPWSTR pszName,
	ULONG  culSize,
	ULONG  culCommitSize,
	void   *pvBase,
	PSECURITY_DESCRIPTOR lpSecDes,
	BOOL   fOKToCreate)
{
    SCODE sc = S_OK;

    memAssert((_hMem == NULL) &&
                  "Attempt to Init CSharedMemoryBlock twice.");

    //We store a header on the shared memory - this should be
    //    transparent to clients.
    culSize = culSize + sizeof(CSharedMemHeader);


    if (fOKToCreate)
    {
	//  try to create the shared file mapping
	//  creates or opens it for Read/Write access.

	_fReadWrite = TRUE;

	_hMem = CreateSharedFileMapping(pszName,
				    culSize,	    // size of shared mem
				    0,		    // map size
				    pvBase,	    // base addr
				    lpSecDes,	    // security desc
				    PAGE_READWRITE | SEC_RESERVE,
				    (void **)&_pbBase,	// returned base ptr
				    &_fCreated);    // created or not
    }
    else
    {
	//  try to open the shared file mapping.
	//  opens it for read only access, base address unspecified.

	_fReadWrite = FALSE;
	_fCreated = FALSE;

	_hMem = OpenSharedFileMapping(pszName,
			      0,		    // map size
			      (void **)&_pbBase);   // returned base ptr
    }

    if (_hMem == NULL)
    {
	return HRESULT_FROM_WIN32(GetLastError());
    }


#if DBG == 1
    MEMORY_BASIC_INFORMATION meminf;
    SIZE_T cbReal;

    cbReal = VirtualQuery(_pbBase, &meminf, sizeof(MEMORY_BASIC_INFORMATION));

    memDebugOut((DEB_ITRACE, "cbReal == %lu, Mem Info:  Base Address %p, Allocation Base %p, AllocationProtect %lx, Region Size %lu, State %lx, Protect %lx, Type %lx\n",
		 cbReal, meminf.BaseAddress, meminf.AllocationBase, meminf.AllocationProtect,
		 meminf.RegionSize, meminf.State, meminf.Protect, meminf.Type));
#endif

    // Commit the first page
    void *pvResult;
    pvResult = VirtualAlloc(_pbBase, culCommitSize, MEM_COMMIT,
                            (_fReadWrite) ? PAGE_READWRITE : PAGE_READONLY);
    if (pvResult == NULL)
    {
        sc = GetScode(HRESULT_FROM_WIN32(GetLastError()));
        memDebugOut((DEB_ERROR, "CSharedMemoryBlock::Commit of %lu bytes"
            " failed with %lx\n", culCommitSize, sc));
        CloseHandle(_hMem);
        _hMem = NULL;
        return sc;
    }

#if DBG == 1
    cbReal = VirtualQuery(_pbBase, &meminf, sizeof(MEMORY_BASIC_INFORMATION));

    memDebugOut((DEB_ITRACE, "cbReal == %lu, Mem Info:  Base Address %p, Allocation Base %p, AllocationProtect %lx, Region Size %lu, State %lx, Protect %lx, Type %lx\n",
		cbReal, meminf.BaseAddress, meminf.AllocationBase, meminf.AllocationProtect,
		meminf.RegionSize, meminf.State, meminf.Protect, meminf.Type));
#endif

    _culCommitSize = culCommitSize;
    _culInitCommitSize = culCommitSize;

    //If we created the block, mark the size in the header.
    if (_fCreated)
    {
        ((CSharedMemHeader *)_pbBase)->SetSize(_culCommitSize);
    }
    else
    {
        sc = Sync();
    }

    return sc;
}

#ifdef RESETOK
//+---------------------------------------------------------------------------
//
//  Member:	CSharedMemoryBlock::Reset, public
//
//  Synopsis:	Reset the shared memory block to its original empty state
//
//  Arguments:	None.
//
//  Returns:	Appropriate status code
//
//  History:	04-Apr-94	PhilipLa	Created
//
//----------------------------------------------------------------------------

SCODE CSharedMemoryBlock::Reset(void)
{
#if DBG == 1
    BOOL b;
#endif
    void *pv;

    memDebugOut((DEB_ITRACE, "In  CSharedMemoryBlock::Reset:%p()\n", this));

#if DBG == 1
    b =
#endif
        VirtualFree(_pbBase, _culCommitSize, MEM_DECOMMIT);
    memAssert(b && "VirtualFree failed.");

#if DBG == 1
    if (b == NULL)
    {
        memDebugOut((DEB_ERROR, "VirtualFree failed with %lx\n", GetLastError()));
    }
#endif

    pv = VirtualAlloc(_pbBase, , _culInitCommitSize, MEM_COMMIT,
		     (_fReadWrite) ? PAGE_READWRITE : PAGE_READONLY);
    if (pv == NULL)
    {
        SCODE sc = GetScode(HRESULT_FROM_WIN32(GetLastError()));
        memDebugOut((DEB_ERROR, "CSharedMemoryBlock::Commit of %lu bytes"
            " failed with %lx\n", _culInitCommitSize, sc));
        return sc;
    }

    _culCommitSize = _culInitCommitSize;
    ((CSharedMemHeader *)_pbBase)->SetSize(_culCommitSize);

    memDebugOut((DEB_ITRACE, "Out CSharedMemoryBlock::Reset\n"));
    return S_OK;
}
#endif //RESETOK

//+---------------------------------------------------------------------------
//
//  Member:	CSharedMemoryBlock::Commit, public
//
//  Synopsis:	Commit the given number of bytes within the block
//
//  Arguments:	[culNewSize] -- Number of bytes to commit
//
//  Returns:	Appropriate status code
//
//  History:	29-Mar-94	PhilipLa	Created
//
//----------------------------------------------------------------------------

SCODE CSharedMemoryBlock::Commit(ULONG culNewSize)
{
    SCODE sc = S_OK;
    culNewSize = culNewSize + sizeof(CSharedMemHeader);

    memAssert((culNewSize >= _culCommitSize) &&
               "Attempted to shrink shared memory heap.");

    if (culNewSize == _culCommitSize)
    {
        return sc;
    }

    void *pb;

    pb = VirtualAlloc(_pbBase,
                      culNewSize,
                      MEM_COMMIT,
		      (_fReadWrite) ? PAGE_READWRITE : PAGE_READONLY);

    if (pb == NULL)
    {
        sc = GetScode(HRESULT_FROM_WIN32(GetLastError()));
        memDebugOut((DEB_ERROR,
                     "CSharedMemoryBlock::Commit of %lu bytes failed with %lx\n", culNewSize, sc));
    }
    else
    {
        _culCommitSize = culNewSize;

        //If the new size is greater than the maximum committed size,
        //   update the maximum committed size.
        CSharedMemHeader *psmh = (CSharedMemHeader *)_pbBase;
        if (_culCommitSize > psmh->GetSize())
        {
            psmh->SetSize(_culCommitSize);
        }
    }

#if DBG == 1
    MEMORY_BASIC_INFORMATION meminf;
    SIZE_T cbReal;

    cbReal = VirtualQuery(_pbBase, &meminf, sizeof(MEMORY_BASIC_INFORMATION));

    memDebugOut((DEB_ITRACE, "Commit size == %lu, cbReal == %lu, Mem Info:  Base Address %p, Allocation Base %p, AllocationProtect %lx, Region Size %lu, State %lx, Protect %lx, Type %lx\n",
		 _culCommitSize, cbReal, meminf.BaseAddress, meminf.AllocationBase, meminf.AllocationProtect,
		 meminf.RegionSize, meminf.State, meminf.Protect, meminf.Type));

    if (cbReal != sizeof(MEMORY_BASIC_INFORMATION))
    {
        memDebugOut((DEB_ERROR, "Virtual Query error: %lx\n", GetLastError()));
    }

#endif

    return sc;
}


//+---------------------------------------------------------------------------
//
//  Member:	CSharedMemoryBlock::Sync, public
//
//  Synopsis:	Match committed view to largest committed view
//
//  Arguments:	None.
//
//  Returns:	Appropriate status code
//
//  History:	29-Mar-94	PhilipLa	Created
//
//----------------------------------------------------------------------------

SCODE CSharedMemoryBlock::Sync(void)
{
    CSharedMemHeader *psmh = (CSharedMemHeader *)_pbBase;

    ULONG culSize = psmh->GetSize();

    if (culSize != _culCommitSize)
    {
        return Commit(culSize - sizeof(CSharedMemHeader));
    }
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\com\inc\refcnt.cxx ===
//+-----------------------------------------------------------------------
//
//  File:       refcnt.cxx
//
//  Contents:   Helper functions for thread-safe destruction of objects
//              placed in global tables that may hand out references.
//
//  Functions:  InterlockedDecRefCnt, InterlockedRestoreRefCnt
//
//  History:    14-Dec-98   GopalK/RickHi   Created
//
//  Notes:      These functions are to be used if you place a refcnt'd object
//              in a global table, but do not want to take a lock around all
//              Release calls. This is used, for example, in the CStdIdentity
//              objects which are placed in the OID tables. Note that if the
//              objects are page-table allocated (see pgalloc.cxx) then there
//              is a simpler mechanism that can be used.
//
//              Use InterlockedIncrement in the AddRef method.
//              Use these functions in the Release method as follows:
//
//
//      ULONG CSomeClass::Release()
//      {
//          ULONG cNewRefs;
//          BOOL fTryToDelete = InterlockedDecRefCnt(&_cRefs, &cNewRefs);
//
//          while (fTryToDelete)
//          {
//              // refcnt went to zero, try to delete this entry
//              BOOL fActuallyDeleted = FALSE;
//
//              // acquire the same lock that the table uses when it
//              // gives out references.
//              ASSERT_LOCK_NOT_HELD(gTableLock);
//              LOCK(gTableLock);
//
//              if (_cRefs == CINDESTRUCTOR)
//              {
//                  // the refcnt did not change while we acquired the lock.
//                  // OK to delete.
//                  delete this;
//                  fActuallyDeleted = TRUE;
//              }
//
//              UNLOCK(gTableLock);
//              ASSERT_LOCK_NOT_HELD(gTableLock);
//
//              if (fActuallyDeleted == TRUE)
//                  break;  // all done. the entry has been deleted.
//
//              // the entry was not deleted because some other thread changed
//              // the refcnt while we acquired the lock. Try to restore the refcnt
//              // to turn off the CINDESTRUCTOR bit. Note that this may race with
//              // another thread changing the refcnt, in which case we may decide to
//              // try to loop around and delete the object once again.
//              fTryToDelete = InterlockedRestoreRefCnt(&_cRefs, &cNewRefs);
//          }
//
//          return (cNewRefs & ~CINDESTRUCTOR);
//      }
//
//-------------------------------------------------------------------------
#include    <ole2int.h>

//+------------------------------------------------------------------------
//
//  Function:   InterlockedDecRefCnt, public
//
//  Synopsis:   Decement the number of references. Returnes TRUE if the object
//              is a candidate for deletion.
//
//  History:    14-Dec-98   GopalK/RickHi   Created
//
//-------------------------------------------------------------------------
INTERNAL_(BOOL) InterlockedDecRefCnt(ULONG *pcRefs, ULONG *pcNewRefs)
{
    BOOL fDelete;

    ULONG cKnownRefs, cCurrentRefs = *pcRefs;
    do
    {
        cKnownRefs = cCurrentRefs;

        if (cKnownRefs == 1)
        {
            // last reference, try to delete
            *pcNewRefs = CINDESTRUCTOR;
            fDelete = TRUE;
        }
        else
        {
            // not last reference, do not delete
            *pcNewRefs = (cKnownRefs & CINDESTRUCTOR) |
                         ((cKnownRefs & ~CINDESTRUCTOR)- 1);
            fDelete = FALSE;
        }

        // Attempt to set the new value
        cCurrentRefs = InterlockedCompareExchange((long *) pcRefs,
                                                  *pcNewRefs, cKnownRefs);
    } while (cCurrentRefs != cKnownRefs);

    return fDelete;
}

//+------------------------------------------------------------------------
//
//  Function:   InterlockedRestoreRefCnt, public
//
//  Synopsis:   If an object was not deleted after InterlockedDecRefCnt
//              returned TRUE, then this function is called to restore the
//              the refcnt.
//
//  History:    14-Dec-98   GopalK/RickHi   Created
//
//-------------------------------------------------------------------------
INTERNAL_(BOOL) InterlockedRestoreRefCnt(ULONG *pcRefs, ULONG *pcNewRefs)
{
    DWORD cKnownRefs, cCurrentRefs = *pcRefs;

    do
    {
        cKnownRefs = cCurrentRefs;
        Win4Assert(cKnownRefs & CINDESTRUCTOR);
        *pcNewRefs = cKnownRefs & ~CINDESTRUCTOR;   // turn off the bit

        if (cKnownRefs == CINDESTRUCTOR)
        {
            // refcount went back to zero, try once again to delete
            // the object.
            return TRUE;
        }

        cCurrentRefs = InterlockedCompareExchange((long *) pcRefs,
                                                  *pcNewRefs, cKnownRefs);
    } while (cCurrentRefs != cKnownRefs);

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\com\inc\xmit.cxx ===
//+-------------------------------------------------------------------
//
//  File:       xmit.cxx
//
//  Contents:   code for converting interfaces to Rpc'able constructs.
//
//  Classes:    CXmitRpcStream
//
//  Functions:  None.
//
//  Macros:     DEFINE_INTERFACE_XMIT_ROUTINES
//
//  History:    30-Jan-93   Ricksa      Created
//
//  Notes:      Since cairo interfaces cant be Rpc'd, they get converted
//              into an InterfaceReferenceData structure via the Rpc
//              [transmit_as] attribute.  The <IFace>_to_xmit function
//              and <IFace>_from_xmit function call CoMarshalInterface
//              and CoUnmarshalInterface respectively.  These APIs expect
//              a stream interface as input.  The CXmitRpcStream is a
//              stream wrapper for the InterfaceReferenceData structure.
//
//  CODEWORK:	since this is used only internally, we want it to be
//		screaming fast.  check parameters only in DBG builds.
//		and ignore thread safety on AddRef/Release.
//
//--------------------------------------------------------------------

#include    <ole2int.h>
#include    <xmit.hxx>




STDMETHODIMP CXmitRpcStream::QueryInterface(
    REFIID iidInterface,
    void FAR* FAR* ppvObj)
{
    HRESULT hresult = S_OK;

    // We only support IUnknown and IStream
    if (IsEqualIID(iidInterface, IID_IUnknown) ||
	IsEqualIID(iidInterface, IID_IStream))
    {
        *ppvObj = this;
        AddRef();
    }
    else
    {
	*ppvObj = NULL;
	hresult = E_NOINTERFACE;
    }

    return hresult;
}

STDMETHODIMP_(ULONG) CXmitRpcStream::AddRef(void)
{
    Win4Assert((_clRefs != 0) && "CXmitRpcStream::AddRef");
    return InterlockedIncrement(&_clRefs);
}

STDMETHODIMP_(ULONG) CXmitRpcStream::Release(void)
{
    Win4Assert((_clRefs != 0) && "CXmitRpcStream::Release");

    LONG lRefs = InterlockedDecrement(&_clRefs);
    if (lRefs == 0)
    {
        delete this;
    }
    return lRefs;
}

STDMETHODIMP CXmitRpcStream::Read(
    VOID HUGEP* pv,
    ULONG cb,
    ULONG FAR* pcbRead)
{
    HRESULT hresult = S_OK;

    if (pcbRead)
    {
        *pcbRead = 0L;
    }

    if (cb + _lOffset > _cbData)
    {
	cb = _cbData - _lOffset;
	CairoleDebugOut((DEB_ERROR, "CXmitRpcStream read past end of stream %x\n", cb+_lOffset));
        hresult = STG_E_READFAULT;
    }

    memcpy(pv,_pifData->abData + _lOffset, (size_t) cb);
    _lOffset += cb;

    if (pcbRead != NULL)
    {
        *pcbRead = cb;
    }

    return hresult;
}

STDMETHODIMP CXmitRpcStream::Write(
    VOID  const HUGEP* pv,
    ULONG cbToWrite,
    ULONG FAR* pcbWritten)
{
    HRESULT hresult = S_OK;

    if (pcbWritten)
    {
        *pcbWritten = 0L;
    }

    if (cbToWrite + _lOffset > _cbData)
    {
	// the current stream is too small, try to grow it.

	if (!_fFree)
	{
	    // The stream doesn't own the buffer so it can't reallocate it
	    CairoleDebugOut((DEB_ERROR, "CXmitRpcStream write past end of stream %x\n",
		cbToWrite + _lOffset));
	    return STG_E_WRITEFAULT;
	}

	// Reallocate the size of the buffer
	// Review: The constant added to the size allocated is a number
	// designed simply to try and decrease the number of follow on
	// allocations. In other words it needs to be tuned (or dropped!).

	BYTE *pbNewBuf = (BYTE *) MIDL_user_allocate(sizeof(DWORD) +
						     cbToWrite +
                                                     _lOffset + 64);

	if (pbNewBuf == NULL)
	{
	    CairoleDebugOut((DEB_ERROR, "CXmitRpcStream cant grow stream\n"));
	    return E_OUTOFMEMORY;
	}

	if (_pifData)
	{
	    // we had a buffer from before, copy that in, and free the old one.
	    memcpy(pbNewBuf, _pifData, sizeof(DWORD) + _cbData);
	    MIDL_user_free(_pifData);
	}

	_cbData = cbToWrite + _lOffset + 64;
	_pifData = (InterfaceData *)pbNewBuf;
    }


    // copy in the new data
    memcpy(_pifData->abData + _lOffset, pv, (size_t) cbToWrite);
    _lOffset += cbToWrite;

    if (pcbWritten != NULL)
    {
	*pcbWritten = cbToWrite;
    }

    // We assume maxium size of buffer is the size to send on the network.
    if (_cSize < _lOffset)
    {
	_cSize = _lOffset;
    }

    return hresult;
}

STDMETHODIMP CXmitRpcStream::Seek(
    LARGE_INTEGER dlibMoveIN,
    DWORD dwOrigin,
    ULARGE_INTEGER FAR* plibNewPosition)
{
    HRESULT hresult = S_OK;

    LONG dlibMove = dlibMoveIN.LowPart;
    ULONG cbNewPos = dlibMove;

    switch(dwOrigin)
    {
    case STREAM_SEEK_SET:

        if (dlibMove >= 0)
        {
            _lOffset = dlibMove;
        }
        else
        {
            hresult = STG_E_SEEKERROR;
        }
        break;

    case STREAM_SEEK_CUR:

        if (!(dlibMove < 0 && (-dlibMove > _lOffset)))
        {
            _lOffset += (ULONG) dlibMove;
        }
        else
        {
            hresult = STG_E_SEEKERROR;
        }
        break;

    case STREAM_SEEK_END:

	if (!(dlibMove < 0 && ((ULONG) -dlibMove) > _cbData))
        {
	    _lOffset = _cbData + dlibMove;
        }
	else
        {
            hresult = STG_E_SEEKERROR;
        }
        break;

    default:

        hresult = STG_E_SEEKERROR;
    }

    if (plibNewPosition != NULL)
    {
        ULISet32(*plibNewPosition, _lOffset);
    }

    return hresult;
}

STDMETHODIMP CXmitRpcStream::SetSize(ULARGE_INTEGER cb)
{
    return E_NOTIMPL;
}

STDMETHODIMP CXmitRpcStream::CopyTo(
    IStream FAR* pstm,
    ULARGE_INTEGER cb,
    ULARGE_INTEGER FAR* pcbRead,
    ULARGE_INTEGER FAR* pcbWritten)
{
    return E_NOTIMPL;
}

STDMETHODIMP CXmitRpcStream::Commit(DWORD grfCommitFlags)
{
    return NOERROR;
}

STDMETHODIMP CXmitRpcStream::Revert(void)
{
    return NOERROR;
}

STDMETHODIMP CXmitRpcStream::LockRegion(
    ULARGE_INTEGER libOffset,
    ULARGE_INTEGER cb,
    DWORD dwLockType)
{
    return STG_E_INVALIDFUNCTION;
}

STDMETHODIMP CXmitRpcStream::UnlockRegion(
    ULARGE_INTEGER libOffset,
    ULARGE_INTEGER cb,
    DWORD dwLockType)
{
    return STG_E_INVALIDFUNCTION;
}

STDMETHODIMP CXmitRpcStream::Stat(
    STATSTG FAR* pstatstg,
    DWORD statflag)
{
    memset(pstatstg, 0, sizeof(STATSTG));
    return E_NOTIMPL;
}

STDMETHODIMP CXmitRpcStream::Clone(IStream FAR * FAR *ppstm)
{
    return E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\com\inc\sources.inc ===
!IF 0

Copyright (c) 1998  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.

!ENDIF

TARGETNAME=   inc
TARGETPATH=   obj
TARGETTYPE=   LIBRARY

INCLUDES =    ..\..\..\common\$(DEST_TREE);..\..\..\ih;..\..\inc
INCLUDES =    $(INCLUDES);..\..\objact;..\..\dcomrem;..\..\..\dcomss\olescm
INCLUDES =    $(INCLUDES);..\..\..\idl\public\$(DEST_TREE)\$(O)
INCLUDES=     $(INCLUDES);..\..\..\idl\internal\$(DEST_TREE)\$(O)
INCLUDES=     $(INCLUDES);..\..\..\idl\private\$(DEST_TREE)\$(O)
INCLUDES=     $(INCLUDES);$(BASE_INC_PATH)

SOURCES=      \
              ..\clskey.cxx   \
              ..\pathkey.cxx  \
              ..\pattbl.cxx   \
              ..\refcnt.cxx   \
              ..\rotdata.cxx  \
              ..\rothelp.cxx  \
              ..\smblock.cxx  \
              ..\smcreate.cxx \
              ..\xmit.cxx


UMTYPE=       windows

!include ..\..\precomp2.inc

SYNCHRONIZE_BLOCK=1
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\com\moniker2\cantimon.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1993 - 1993.
//
//  File:       cantimon.cxx
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    12-27-93   ErikGav   Did not write this code
//		02-04-94   KevinRo   Gag'd on it, then rewrote it
//		06-14-94   Rickhi    Fix type casting
//
//  An Anti moniker is intended to be the inverse of any moniker, such as
//  an Item Moniker. When another moniker composes itself with an Anti moniker
//  on the right, it is supposed to remove itself from the result.
//
//  The original implementation of Anti monikers attempted to be optimal by
//  collapsing itself when composed with another Anti moniker. This was an
//  unfortunate decision, since other monikers decide to eliminate themselves
//  (and the Anti moniker) based on whether the moniker type to the right is
//  an Anti moniker.
//
//  For example, File moniker (F) composed with an Anti moniker (A) should
//  result in nothing. F o A == (). The previous implementation was in error
//  because a composite of two anti-monikers was treated as a single anti
//  moniker with a count of two, denoted A(2).
//  Therefore, when the file moniker looked at the anti moniker using the
//  interface, it saw only one Anti moniker, instead of a composite.
//  ( F o A(2)) == (). It should have been ( F o (A o A) ) == ( A )
//
//  To fix this, when we compose Anti monikers, we will always use a
//  composite. We need to be careful when loading old serialized Anti
//  monikers, and convert them as we see them.
//
//  This actually makes this a problem, since old monikers have a
//  funny behaviour if loaded from stream. The way the Load() interface
//  works, the client has a pointer to the Anti moniker before it is loaded.
//  Therefore, we can't just magically make this work.
//
//  However, we can fix this up as soon as we can during the first Reduce or
//  Compose with that is called. You will find this code in the Compose
//  with methods, plus in the Create(count) methods.
//
//  Save() is also a problem, since the caller has already written out our
//  class ID. Therefore, we can't just sneak in a composite, since it will
//  break the old fellows.
//
//
//  History
//  ??/??/??    unknown     Created
//  03/21/97    ronans      Changed creation code to use initial ref count of 1
//----------------------------------------------------------------------------

#include <ole2int.h>

#include "cbasemon.hxx"
#include "cantimon.hxx"
#include "mnk.h"



INTERNAL_(CAntiMoniker *) IsAntiMoniker( LPMONIKER pmk )
{
    CAntiMoniker *pCAM;

    if ((pmk->QueryInterface(CLSID_AntiMoniker, (void **)&pCAM)) == S_OK)
    {
	// we release the AddRef from QI but stll return the pointer.
	pCAM->Release();
	return pCAM;
    }

    // dont rely on user implementations to return NULL on failed QI
    return NULL;
}


//+---------------------------------------------------------------------------
//
//  Method:     CAntiMoniker::Create
//
//  Synopsis:   Create a single AntiMoniker
//
//  Effects:
//
//  Arguments:  (none)
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:
//
//  History:    2-04-94   kevinro   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
CAntiMoniker FAR *CAntiMoniker::Create()
{
    CAntiMoniker FAR * pCAM = new CAntiMoniker();
    return pCAM;
}


//+---------------------------------------------------------------------------
//
//  Method:     CAntiMoniker::Create
//
//  Synopsis:   Create a composite anti moniker.
//
//  Effects:    This function supports the 'old' way of creating Anti
//		monikers, by creating [count] Anti monikers, and composing
//		them together.
//
//  Arguments:  [count] -- Number of Anti monikers
//
//  Requires:
//
//  Returns:
//	if count == 1, this routine will return an CAntiMoniker.
// 	if count > 1, this routine will create a composite moniker made up
//	of Anti monikers.
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:
//
//  History:    2-04-94   kevinro   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

IMoniker * CAntiMoniker::Create(ULONG count)
{
    mnkDebugOut((DEB_ITRACE,
	    	 "CAntiMoniker::Create(0x%x))\n",
		 count));


    HRESULT hr;
    IMoniker *pmkComposite = NULL;

    while(count--)
    {
	IMoniker *pmkNew;

	CAntiMoniker FAR * pCAM = new CAntiMoniker();

	//
	// If there was failure, then releasing the old composite is
	// required.
	//

	if (pCAM == NULL)
	{
	    if (pmkComposite != NULL)
	    {
		pmkComposite->Release();
	    }
	    return(NULL);
	}

	//
	// Create a generic composite using the existing and new
	// monikers. If this succeededs, then pmkNew will increment
	// both reference counts.
	//
	//
	// If there was a failure, then calling Release() on the new and
	// old sections of the composite will cause both of them to be
	// released, thus releasing the entire tree of monikers.
	//
	// If it succeeds, pmkNew will hold references to both of the
	// old monikers, and life will be good.
	//
	// Note: First time around, pmkComposite == NULL, and
	// CreateGenericComposite() will just return pCAM. It works.
	//

	hr = CreateGenericComposite(pmkComposite,pCAM,&pmkNew);

	pCAM->Release();

	//
	// Watch out for the first time around the loop. This will
	// cause pmkComposite to be NULL
	//
	if (pmkComposite != NULL)
	{
	    pmkComposite->Release();
	}

	//
	// If failed, then the last two releases cleaned up for us.
	//
	if (FAILED(hr))
	{
	    return(NULL);
	}

	pmkComposite = pmkNew;
    }

    return pmkComposite;
}


STDMETHODIMP CAntiMoniker::QueryInterface(THIS_ REFIID riid,
	LPVOID FAR* ppvObj)
{
	M_PROLOG(this);
	VDATEIID (riid);
	VDATEPTROUT(ppvObj, LPVOID);

	*ppvObj = NULL;

#ifdef _DEBUG
	if (riid == IID_IDebug)
	{
	    *ppvObj = &(m_Debug);
	    return NOERROR;
	}
#endif

	if (IsEqualIID(riid, CLSID_AntiMoniker))
	{
	    //	called by IsAntiMoniker.
	    AddRef();
	    *ppvObj = this;
	    return S_OK;
	}

	return CBaseMoniker::QueryInterface(riid, ppvObj);
}

STDMETHODIMP CAntiMoniker::GetClassID(LPCLSID lpClassId)
{
	M_PROLOG(this);
	VDATEPTROUT(lpClassId, CLSID);

	*lpClassId = CLSID_AntiMoniker;
	return NOERROR;
}


STDMETHODIMP CAntiMoniker::Load(LPSTREAM pStm)
{
    mnkDebugOut((DEB_ITRACE,
	    	 "CAntiMoniker::Load(%x)\n",
		 this));

    M_PROLOG(this);
    VDATEIFACE(pStm);

    HRESULT hresult;
    ULONG count;

    hresult = StRead(pStm, &count, sizeof(ULONG));

    if (SUCCEEDED(hresult))
    {
        m_count = count;
    }
    return hresult;
}


STDMETHODIMP CAntiMoniker::Save(LPSTREAM pStm, BOOL fClearDirty)
{
    mnkDebugOut((DEB_ITRACE,
	    	 "CAntiMoniker::Save(%x)\n",
		 this));

	M_PROLOG(this);
	VDATEIFACE(pStm);

	UNREFERENCED(fClearDirty);
	ULONG cbWritten;

	return pStm->Write(&m_count, sizeof(ULONG), &cbWritten);
	//	REVIEW:  what is proper error handling?  Should we restore the seek
	//	pointer?
}


STDMETHODIMP CAntiMoniker::GetSizeMax(ULARGE_INTEGER FAR* pcbSize)
{
    mnkDebugOut((DEB_ITRACE,
	    	 "CAntiMoniker::GetSizeMax(%x)\n",
		 this));

	M_PROLOG(this);
	VDATEPTROUT(pcbSize, ULONG);

 	ULISet32(*pcbSize, sizeof(CLSID) + sizeof(ULONG));
	noError;
}




//+---------------------------------------------------------------------------
//
//  Method:     CAntiMoniker::ComposeWith
//
//  Synopsis:   Compose this moniker with another moniker.
//
//  Effects:
//
//  Arguments:  [pmkRight] --
//		[fOnlyIfNotGeneric] --
//		[ppmkComposite] --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:
//
//  History:    2-04-94   kevinro   Created
//
//  Notes:
//
//  In the event that m_count > 1, we can use this opportunity to fixup the
//  anti moniker into a composite of single anti monikers. This will help make
//  the monikers work correctly.
//
//----------------------------------------------------------------------------
STDMETHODIMP CAntiMoniker::ComposeWith( LPMONIKER pmkRight,
	BOOL fOnlyIfNotGeneric, LPMONIKER FAR* ppmkComposite)
{
    mnkDebugOut((DEB_ITRACE,
	    	 "CAntiMoniker::ComposeWith(%x,pmkRight(%x))\n",
		 this,
		 pmkRight));

	VDATEPTROUT(ppmkComposite,LPMONIKER);
	*ppmkComposite = NULL;
	VDATEIFACE(pmkRight);

	HRESULT hresult = NOERROR;
	IMoniker *pmkThis = NULL;
	IMoniker *pmkRightComposite = NULL;


	//
	// The only way CAntiMonikers can compose is generically
	//
	if (fOnlyIfNotGeneric)
	{
	    hresult = MK_E_NEEDGENERIC;
	    *ppmkComposite = NULL;
	    return hresult;
	}

	//
	// Now, we are going to make a generic composite. This is a
	// good time to determine if we need to convert this
	// anti moniker into a composite
	//
	// If m_count > 1, create an equivalent composite moniker
	//

	if (m_count > 1)
	{
	    pmkThis = Create(m_count);
	}

	//
	// Regardless of the outcome, be sure pmkThis == a moniker to
	// compose with.
	//

	if (pmkThis == NULL)
	{
	    pmkThis = this;
	}

	//
	// If the right side is an anti moniker also, then we need to
	// concatenate the two Anti monikers into a composite.
	//

	CAntiMoniker *pmkRightAnti = IsAntiMoniker(pmkRight);
	if (pmkRightAnti)
	{
	    mnkDebugOut((DEB_ITRACE,
			 "::ComposeWith(%x) CAntiMoniker(%x)\n",
			 this,
			 pmkRight));

	    //
	    // The right side is also an Anti moniker. Does it need fixing
	    // as well? If so, then fix it up, and assign it to pmkRight
	    //

	    if (pmkRightAnti->m_count > 1 )
	    {
		pmkRightComposite = CAntiMoniker::Create(m_count);

		if (pmkRightComposite != NULL)
		{
		    pmkRight = pmkRightComposite;
		}
	    }

	    hresult = Concatenate(pmkThis,pmkRight,ppmkComposite);
	}
	else
        {
	    //
	    // Anti monikers can only be composed using generic composites
	    // when they are on the left.
	    //

	    hresult = CreateGenericComposite( pmkThis,
					      pmkRight,
					      ppmkComposite );
	}

	//
	// Clean up after possible conversions
	//

	if (pmkThis != this)
	{
	    pmkThis->Release();
	}

	if (pmkRightComposite != NULL)
	{
	    pmkRightComposite->Release();
	}

	return hresult;
}

STDMETHODIMP CAntiMoniker::Enum (THIS_ BOOL fForward, LPENUMMONIKER FAR* ppenumMoniker)
{
	VDATEPTROUT(ppenumMoniker,LPENUMMONIKER);
	*ppenumMoniker = NULL;
	noError;
}

//+---------------------------------------------------------------------------
//
//  Method:     CAntiMoniker::GetComparisonData
//
//  Synopsis:   Get comparison data for registration in the ROT
//
//  Arguments:  [pbData] - buffer to put the data in.
//              [cbMax] - size of the buffer
//              [pcbData] - count of bytes used in the buffer
//
//  Returns:    NOERROR
//              E_OUTOFMEMORY
//
//  Algorithm:  Build ROT data for anti moniker.
//
//  History:    03-Feb-95   kevinro  Created
//
// Note:        Validating the arguments is skipped intentionally because this
//              will typically be called internally by OLE with valid buffers.
//
//----------------------------------------------------------------------------
STDMETHODIMP CAntiMoniker::GetComparisonData(
    byte *pbData,
    ULONG cbMax,
    DWORD *pcbData)
{
    ULONG ulLength = sizeof(CLSID_AntiMoniker) + sizeof(m_count);

    Assert(pcbData != NULL);
    Assert(pbData != NULL);

    if (cbMax < ulLength)
    {
	return(E_OUTOFMEMORY);
    }

    memcpy(pbData,&CLSID_AntiMoniker,sizeof(CLSID_AntiMoniker));
    memcpy(pbData+sizeof(CLSID_AntiMoniker),&m_count,sizeof(m_count));

    *pcbData = ulLength;

    return NOERROR;
}

STDMETHODIMP CAntiMoniker::IsEqual (THIS_ LPMONIKER pmkOtherMoniker)
{
    mnkDebugOut((DEB_ITRACE,
	    	 "CAntiMoniker::IsEqual(%x,pmkOther(%x))\n",
		 this,
		 pmkOtherMoniker));

	VDATEIFACE(pmkOtherMoniker);

	CAntiMoniker *pCAM = IsAntiMoniker(pmkOtherMoniker);

	if (pCAM)
	{
	    //	the other moniker is an anti moniker.
	    if (m_count == pCAM->m_count)
	    {
		return NOERROR;	
	    }
	}

	return ResultFromScode(S_FALSE);
}



STDMETHODIMP CAntiMoniker::Hash (THIS_ LPDWORD pdwHash)
{
	VDATEPTROUT(pdwHash, DWORD);
	*pdwHash = 0x80000000 + m_count;
	noError;
}



STDMETHODIMP CAntiMoniker::CommonPrefixWith (LPMONIKER pmkOther, LPMONIKER FAR*
	ppmkPrefix)
{
    mnkDebugOut((DEB_ITRACE,
	    	 "CAntiMoniker::CommonPrefixWith(%x,pmkOther(%x))\n",
		 this,
		 pmkOther));

	M_PROLOG(this);
	VDATEPTROUT(ppmkPrefix,LPMONIKER);
	*ppmkPrefix = NULL;
	VDATEIFACE(pmkOther);

	CAntiMoniker *pAntiMoniker = IsAntiMoniker(pmkOther);
	if (pAntiMoniker)
	{
		if (m_count <= pAntiMoniker->m_count)
		{
			*ppmkPrefix = this;
			AddRef();
			if (m_count == pAntiMoniker->m_count)
			    return ResultFromScode(MK_S_US);
			return ResultFromScode(MK_S_ME);
		}
		*ppmkPrefix = pmkOther;
		pmkOther->AddRef();
		return ResultFromScode(MK_S_HIM);
	}
	return MonikerCommonPrefixWith(this, pmkOther, ppmkPrefix);
    //  this handles the case where pmkOther is composite, as well as
    //  all other cases.
}



STDMETHODIMP CAntiMoniker::RelativePathTo (THIS_ LPMONIKER pmkOther, LPMONIKER FAR*
	ppmkRelPath)
{
    mnkDebugOut((DEB_ITRACE,
	    	 "CAntiMoniker::RelativePathTo(%x,pmkOther(%x))\n",
		 this,
		 pmkOther));

	VDATEPTROUT(ppmkRelPath,LPMONIKER);
	VDATEIFACE(pmkOther);

	*ppmkRelPath = NULL;

	*ppmkRelPath = pmkOther;
	pmkOther->AddRef();

	return MK_S_HIM;
}



STDMETHODIMP CAntiMoniker::GetDisplayName( LPBC pbc, LPMONIKER
	pmkToLeft, LPWSTR FAR * lplpszDisplayName )
	//	return "\..\..\.. "
{
    mnkDebugOut((DEB_ITRACE,
	    	 "CAntiMoniker::GetDisplayName(%x,pmkLeft(%x))\n",
		 this,
		 pmkToLeft));

	M_PROLOG(this);

	VDATEPTROUT(lplpszDisplayName, LPWSTR);

	*lplpszDisplayName = NULL;

	VDATEIFACE(pbc);

	if (pmkToLeft) VDATEIFACE(pmkToLeft);

	WCHAR FAR * lpch;
	ULONG i;
	ULONG ccDisplayName;

	//
	// ccDisplayName is the number of characters to allocate
	//
	// For each anti moniker, return one instance of '\..', which
	// is 3 characters long. Also, add 1 for the terminating NULL
	//

	ccDisplayName = 1 + ( 3 * m_count );

	*lplpszDisplayName = (WCHAR *)
	    CoTaskMemAlloc(sizeof(WCHAR) * ccDisplayName);

	lpch = *lplpszDisplayName;

	if (lpch == NULL)
	{
	    return E_OUTOFMEMORY;
	}

	//
	// Concat a whole bunch of strings forming the display name for
	// the anti moniker
	//
	for (i = m_count; i > 0; i-- , lpch += 3)
	{
	    memcpy(lpch, L"\\..", 3 * sizeof(WCHAR));	
	}

	*lpch = '\0';

	return NOERROR;
}



STDMETHODIMP CAntiMoniker::ParseDisplayName( LPBC pbc,
	LPMONIKER pmkToLeft, LPWSTR lpszDisplayName, ULONG FAR* pchEaten,
	LPMONIKER FAR* ppmkOut)
{
    mnkDebugOut((DEB_ITRACE,
	    	 "CAntiMoniker::ParseDisplayName(%x,pmkLeft(%x)lpszName(%ws))\n",
		 this,
		 pmkToLeft,
		 WIDECHECK(lpszDisplayName)));

	M_PROLOG(this);
	VDATEPTROUT(ppmkOut,LPMONIKER);
	*ppmkOut = NULL;
	VDATEIFACE(pbc);
	if (pmkToLeft) VDATEIFACE(pmkToLeft);
	VDATEPTRIN(lpszDisplayName, WCHAR);
	VDATEPTROUT(pchEaten,ULONG);

	return ResultFromScode(E_NOTIMPL);	//	ParseDisplayName not implemented for AntiMonikers
}



STDMETHODIMP CAntiMoniker::IsSystemMoniker (THIS_ LPDWORD pdwType)
{
	M_PROLOG(this);
	*pdwType = MKSYS_ANTIMONIKER;
	return NOERROR;		
}

//+---------------------------------------------------------------------------
//
//  Method:     CAntiMoniker::EatOne
//
//  Synopsis:   This function creates an appropriate Anti moniker
//
//  Effects:
//
//  Arguments:  [ppmk] --
//
//  Requires:
//
//  Returns:
//	if m_count == 1, returns NULL
//	if m_count == 2, returns a CAntiMoniker
//	if m_count > 2, returns a composite made up of anti monikers.
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:
//
//  History:    2-04-94   kevinro   Created
//
//  Notes:
//
//  Back in the days when monikers collapsed themselves, this routine was
//  called in order to eat one of the counts. Now, it is used as a good place
//  to throw in a conversion for composite anti-monikers.
//
//----------------------------------------------------------------------------
void CAntiMoniker::EatOne(LPMONIKER *ppmk)
{
    mnkDebugOut((DEB_ITRACE,
	    	 "CAntiMoniker::EatOne(%x)\n",
		 this));

    *ppmk = CAntiMoniker::Create(m_count - 1);
}


#ifdef _DEBUG

STDMETHODIMP_(void) NC(CAntiMoniker,CDebug)::Dump( IDebugStream FAR * pdbstm)
{
	VOID_VDATEIFACE(pdbstm);
	
	*pdbstm << "CAntiMoniker @" << (VOID FAR *)m_pAntiMoniker;
	*pdbstm << '\n';
	pdbstm->Indent();
	*pdbstm << "Refcount is " << (int)(m_pAntiMoniker->m_refs) << '\n';
	*pdbstm << "Anti count is " << (int)(m_pAntiMoniker->m_count) << '\n';
	pdbstm->UnIndent();
}

STDMETHODIMP_(BOOL) NC(CAntiMoniker,CDebug)::IsValid( BOOL fSuspicious )
{
	return ((LONG)(m_pAntiMoniker->m_refs) > 0);
	//	add more later, maybe
}			

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\com\inc\smcreate.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1992.
//
//  File:	smcreate.cxx
//
//  Contents:	Routines for Creating or Opening memory mapped files.
//
//  Functions:	CreateSharedFileMapping
//		OpenSharedFileMapping
//		CloseSharedFileMapping
//
//  History:	03-Nov-93 Ricksa    Created
//		07-Apr-94 Rickhi    Seperated into APIs
//
//  Notes:	These APIs are used by dirrot.cxx, dirrot2.cxx, smblock.cxx,
//		(both ole32.dll and scm.exe), that is why they are in the
//		the directory.
//
//--------------------------------------------------------------------------
#include    <ole2int.h>
#include    <secdes.hxx>
#include    <smcreate.hxx>

//+-------------------------------------------------------------------------
//
//  Function:	CreateSharedFileMapping
//
//  Synopsis:	Creates or gets access to memory mapped file.
//
//  Arguments:	[pszName]   - name of file
//		[ulSize]    - size of shared memory
//		[ulMapSize] - size of shared memory to map right now
//		[pvBase]    - base address to request
//		[lpSecDes]  - security descriptor
//		[dwAccess]  - access wanted
//		[ppv]	    - return address for memory ptr
//		[pfCreated] - returns TRUE if memory was created
//
//  Algorithm:	Creates a file mapping of the requested name and size
//		and maps it into memory with READ and WRITE access.
//
//  Returns:	HANDLE of file or NULL if failed.
//		[ppv]	    - base address of shared memory
//		[fCreated]  - TRUE if the file was created.
//
//  Notes:
//
//--------------------------------------------------------------------------

HANDLE CreateSharedFileMapping(WCHAR *pszName,
	  ULONG ulSize,
	  ULONG ulMapSize,
	  void *pvBase,
	  PSECURITY_DESCRIPTOR lpSecDes,
	  DWORD dwAccess,
	  void **ppv,
	  BOOL *pfCreated)
{
    CairoleDebugOut((DEB_MEMORY,
		    "CreateSharedFileMapping name:%ws size:%x base:%x\n",
		    pszName, ulSize, pvBase));

    BOOL fCreated = TRUE;

    CWorldSecurityDescriptor wsd;
    if (lpSecDes == NULL)
    {
        lpSecDes = &wsd;
    }

    // Holder for attributes to pass in on create.
    SECURITY_ATTRIBUTES secattr;

    secattr.nLength = sizeof(SECURITY_ATTRIBUTES);
    secattr.lpSecurityDescriptor = lpSecDes;
    secattr.bInheritHandle = FALSE;

    // Create the shared memory object
    HANDLE hMem = CreateFileMappingW(INVALID_HANDLE_VALUE, &secattr,
				    dwAccess, 0, ulSize, pszName);

#if DBG==1
    if (hMem == NULL)
    {
        CairoleDebugOut((DEB_ERROR,
            "CreateSharedFileMapping create of memory failed %d\n",
                GetLastError()));
    }

#endif

    void *pvAddr = NULL;

    if (hMem != NULL)
    {
	if (GetLastError() != ERROR_SUCCESS)
        {
            // If memory existed before our call then GetLastError returns
	    // ERROR_ALREADY_EXISTS, so we can tell whether we were the first
	    // one in or not.

#if DBG==1
            if (GetLastError() != ERROR_ALREADY_EXISTS)
            {
                CairoleDebugOut((DEB_WARN,
               "CreateFileMapping - expected ERROR_ALREADY_EXISTS, got %lx\n",
                                GetLastError()));
            }
#endif  //  DBG==1

	    CairoleDebugOut((DEB_MEMORY ,"SharedMem File Existed\n"));
	    fCreated = FALSE;
        }

	// Map the shared memory we have created into our process space
	pvAddr = MapViewOfFileEx(hMem, FILE_MAP_WRITE,
				 0, 0, ulMapSize, pvBase);

#if DBG==1
        if (pvAddr == NULL)
        {
            CairoleDebugOut((DEB_ERROR, "MapViewOfFile failed!! with %d\n",
                             GetLastError()));
        }
#endif // DBG==1

	if (pvAddr == NULL)
	{
	    DWORD err = GetLastError(); // successful CloseHandle sets last err to 0
	    CloseHandle(hMem); //ignore error
	    SetLastError(err);
	    hMem = NULL;
	}
    }

    if (pfCreated)
    {
	*pfCreated = fCreated;
    }

    *ppv = pvAddr;
    return hMem;
}



//+-------------------------------------------------------------------------
//
//  Function:	OpenSharedFileMapping
//
//  Synopsis:	opens a memory mapped file.
//
//  Arguments:	[pszName]   - name of file
//		[ulMapSize] - size of shared memory to map right now
//		[ppv]	    - return address for memory ptr
//
//  Algorithm:	Does an OpenFileMapping on the requested filename,
//		then a MapViewOfFile.  ReadOnly access is granted.
//
//  Returns:	HANDLE of the file or NULL if failed.
//		[ppv]	    - base address of the shared memory.
//
//  Notes:
//
//--------------------------------------------------------------------------

HANDLE OpenSharedFileMapping(WCHAR *pszName,
			     ULONG ulMapSize,
			     void **ppv)
{
    CairoleDebugOut((DEB_MEMORY, "OpenSharedFileMapping name:%ws size:%x\n",
		    pszName, ulMapSize));

    // Create the shared memory object
    HANDLE hMem = OpenFileMappingW(FILE_MAP_READ, FALSE, pszName);

    void *pvAddr = NULL;

    if (hMem != NULL)
    {
	// Map the shared memory we have created into our process space
	pvAddr = MapViewOfFile(hMem, FILE_MAP_READ, 0, 0, ulMapSize);

	Win4Assert(pvAddr && "MapViewOfFile failed!!");

	if (pvAddr == NULL)
	{
	    DWORD err = GetLastError(); // successful CloseHandle sets last err to 0
	    CloseHandle(hMem); //ignore error
	    SetLastError(err);
	    hMem = NULL;
	}
    }
    else
    {
	CairoleDebugOut((DEB_MEMORY, "OpenFileMapping failed.\n"));
    }

    *ppv = pvAddr;
    return hMem;
}



//+-------------------------------------------------------------------------
//
//  Function:	CloseSharedFileMapping
//
//  Synopsis:	closes a memory mapped file.
//
//  Arguments:	[hMem]	- shared memory handle
//		[pv]	- base address of shared memory pointer
//
//  Algorithm:	Unmaps the view of the file and closes the file handle.
//
//  Notes:
//
//--------------------------------------------------------------------------

void CloseSharedFileMapping(HANDLE hMem, void *pv)
{
    if (pv != NULL)
    {
	// release the shared memory. carefull not to release NULL.
	UnmapViewOfFile(pv);
    }
    if (hMem != NULL)
    {
	CloseHandle(hMem);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\com\moniker2\cbindctx.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1993 - 1993.
//
//  File:       cbindctx.cxx
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:
//		12-27-93   ErikGav   Created
//              10-05-95   MikeHill  Added 'dwRestricted' field to BIND_OPTS.
//              11-14-95   MikeHill  Removed previous change (to BIND_OPTS).
//              12-06-95   MikeHill  Fixed Get/SetBindOptions so they don't corrupt
//                                   the cbStruct field.
//
//----------------------------------------------------------------------------

#include <ole2int.h>

#include "cbindctx.hxx"
#include "mnk.h"


/*
 *	Implementation of CBindCtx
 *	
 *	
 *	
 *	
 */


NAME_SEG(CBindCtx)


CBindCtx::CBindCtx()
#ifdef _DEBUG
	: m_Debug(this)
#endif
{
    GET_A5();
    m_refs = 1;
    m_pFirstObj = NULL;

    m_bindopts.cbStruct = sizeof(m_bindopts);
    m_bindopts.grfFlags = 0;
    m_bindopts.grfMode =  STGM_READWRITE;
    m_bindopts.dwTickCountDeadline = 0;
    m_bindopts.dwTrackFlags = 0;

    m_bindopts.dwClassContext = CLSCTX_SERVER;

    m_bindopts.locale = GetThreadLocale();
    m_bindopts.pServerInfo = 0;

    m_pMap = NULL;
}


CBindCtx::~CBindCtx( void )
{
	LPWSTR lpszKey;
	LPVOID lpvoid;
	M_PROLOG(this);

	ReleaseBoundObjects();

    if (m_pMap)
    {
    	POSITION pos = m_pMap->GetStartPosition();
    	while (pos != NULL)
    	{
    		m_pMap->GetNextAssoc(pos, lpszKey, lpvoid);
            if (lpvoid) ((LPUNKNOWN)lpvoid)->Release();
    	}
        delete m_pMap;
    }
}



NC(CBindCtx,CObjList)::~CObjList(void)
{
	if (m_punk) m_punk->Release();
}


IBindCtx FAR *CBindCtx::Create()
{
	return new FAR CBindCtx();
}


STDMETHODIMP CBindCtx::QueryInterface(REFIID iidInterface, void FAR* FAR* ppv)
{
    HRESULT hr;

    __try
    {
        //Parameter validation.
        //An invalid parameter will throw an exception.
        *ppv = 0;

        if (IsEqualIID(iidInterface, IID_IUnknown)
            || IsEqualIID(iidInterface, IID_IBindCtx))
        {
            AddRef();
            *ppv = this;
            hr = S_OK;
        }
#ifdef _DEBUG
        else if(IsEqualIID(iidInterface,IID_IDebug))
        {
            *ppv = (void FAR *)&m_Debug;
            hr = S_OK;
	}
#endif
        else
        {
            hr = E_NOINTERFACE;
	}
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        //An exception occurred, probably because of a bad parameter.
        hr = E_INVALIDARG;
    }
    return hr;
}



STDMETHODIMP_(ULONG) CBindCtx::AddRef( void )
{
    InterlockedIncrement((long *)&m_refs);
    return m_refs;
}


STDMETHODIMP_(ULONG) CBindCtx::Release( void )
{
    ULONG count = m_refs - 1;

    if(InterlockedDecrement((long *)&m_refs) == 0)
    {
        delete this;
        count = 0;
    }

    return count;
}


STDMETHODIMP	CBindCtx::RegisterObjectBound( LPUNKNOWN punk )
{
	M_PROLOG(this);
	if (punk == NULL) noError;
	VDATEIFACE(punk);
	CObjList FAR* pCOL = new CObjList( punk );
	if (pCOL)
	{
		punk->AddRef();
		AddToList(pCOL);
		noError;
	}
	return ResultFromScode(S_OOM);
}



STDMETHODIMP	CBindCtx::RevokeObjectBound
	( LPUNKNOWN punk )
{
	M_PROLOG(this);
	VDATEIFACE(punk);
	CObjList FAR * pCOL = m_pFirstObj;
	CObjList FAR * pCOLPrev = NULL;

	// look for entry which matches punk given
	for (; pCOL && (pCOL->m_punk != punk);
	    pCOLPrev = pCOL, pCOL = pCOL->m_pNext)
	{
	    // empty
	}

	//	pCOL is null or pCOL->m_punk = punk
	if (pCOL != NULL)
	{
		if (pCOLPrev == NULL) m_pFirstObj = pCOL->m_pNext;
		else pCOLPrev->m_pNext = pCOL->m_pNext;
		delete pCOL;
		noError;
	}
	return ResultFromScode(MK_E_NOTBOUND);
}




STDMETHODIMP CBindCtx::ReleaseBoundObjects(THIS)
{
	M_PROLOG(this);
	CObjList FAR * pCOL = m_pFirstObj;
	CObjList FAR * pCOLNext = NULL;
	m_pFirstObj = NULL;
	while (pCOL != NULL)
	{
		pCOLNext = pCOL->m_pNext;
		delete pCOL;		//	calls Release on the object
		pCOL = pCOLNext;
	}
	noError;
}

STDMETHODIMP CBindCtx::SetBindOptions (LPBIND_OPTS pbindopts)
{
    HRESULT hr;

    __try
    {
	if (pbindopts->cbStruct <= sizeof(m_bindopts))
	{
            //Set the bind options.
	    memcpy(&m_bindopts, pbindopts, (size_t)(pbindopts->cbStruct));
            hr = S_OK;
        }
        else
        {
            //pbindopts is too large.
            hr = E_INVALIDARG;
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        //An exception occurred, probably because of a bad parameter.
        hr = E_INVALIDARG;
    }

    Assert(m_bindopts.cbStruct <= sizeof(m_bindopts));
    return hr;
}


STDMETHODIMP CBindCtx::GetBindOptions (LPBIND_OPTS pbindopts)
{
    HRESULT hr;
    ULONG cbDest;

    Assert(m_bindopts.cbStruct <= sizeof(m_bindopts));

    __try
    {
        cbDest = pbindopts->cbStruct;
	if(m_bindopts.cbStruct <= cbDest)
        {
            memcpy(pbindopts, &m_bindopts, m_bindopts.cbStruct);
        }
        else
        {
            BIND_OPTS2 bindopts = m_bindopts;
            bindopts.cbStruct = cbDest;
            memcpy(pbindopts, &bindopts, cbDest);
        }
        hr = S_OK;
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        //An exception occurred, probably because of a bad parameter.
        hr = E_INVALIDARG;
    }

    return hr;
}



STDMETHODIMP CBindCtx::GetRunningObjectTable (THIS_ LPRUNNINGOBJECTTABLE  FAR*
	pprot)
{
	M_PROLOG(this);
	VDATEPTROUT(pprot, LPRUNNINGOBJECTTABLE);
	return ::GetRunningObjectTable(0, pprot);
}

//+-------------------------------------------------------------------------
//
//  Member:     CBindCtx::RegisterObjectParam
//
//  Synopsis:   Registers object with key
//
//  Effects:    Adds object to bind context
//
//  Arguments:  [lpszKey] -- registration key
//              [punk]    -- object
//
//  Returns:    HRESULT
//
//  Modifies:
//
//  Derivation: IBindContext
//
//  Algorithm:
//
//  History:    03-Jun-94 AlexT     Added header block;  release previous
//                                  object (if it exists)
//
//  Notes:      This function is not multithread safe!
//
//--------------------------------------------------------------------------

STDMETHODIMP CBindCtx::RegisterObjectParam (THIS_ LPWSTR lpszKey, LPUNKNOWN punk)
{
    M_PROLOG(this);
    VDATEPTRIN(lpszKey, WCHAR);
    VDATEIFACE(punk);

    if (m_pMap == NULL)
    {
        //  We don't have a map yet;  allocate one
        m_pMap = new CMapStringToPtr();
        if (NULL == m_pMap)
        {
            return ResultFromScode(E_OUTOFMEMORY);
        }
    }
    else
    {
        LPVOID pv = NULL;

        //  We already have a map;  if we have an existing entry for this
        //  key we release it here (we don't remove the key because we're
        //  about to assign a new value with the same key below

        if (m_pMap->Lookup(lpszKey, pv))
        {
    		if(pv)
    		    ((LPUNKNOWN)pv)->Release();
        }
    }

    //  SetAt is guaranteed not to fail if lpszKey is already in the map

    if (m_pMap->SetAt(lpszKey, (LPVOID&)punk))
    {
        punk->AddRef();
        return NOERROR;
    }

    return ResultFromScode(E_OUTOFMEMORY);
}


STDMETHODIMP CBindCtx::GetObjectParam (THIS_ LPWSTR lpszKey, LPUNKNOWN FAR* ppunk)
{
	M_PROLOG(this);
	VDATEPTROUT(ppunk, LPUNKNOWN);
	*ppunk = NULL;
	VDATEPTRIN(lpszKey, WCHAR);

	LPVOID pNewValue = (LPVOID)(*ppunk);
	
	if (m_pMap != NULL && m_pMap->Lookup(lpszKey, pNewValue))
	{
		*ppunk = (LPUNKNOWN)pNewValue;
        (*ppunk)->AddRef();
		return NOERROR;
	}

	return ResultFromScode(E_FAIL);
}


STDMETHODIMP CBindCtx::EnumObjectParam
(THIS_ LPENUMSTRING FAR* ppenum)
{
	M_PROLOG(this);
	VDATEPTROUT(ppenum, LPENUMSTRING);

#ifdef NOTYET
	*ppenum = new CEnumStringImpl( m_pMap );
	if (*ppenum == NULL) return ResultFromScode(E_OUTOFMEMORY);
		return NOERROR;
#else
	*ppenum = NULL;
	return ResultFromScode(E_NOTIMPL);
#endif
}


STDMETHODIMP CBindCtx::RevokeObjectParam
(THIS_ LPWSTR lpszKey)
{
	M_PROLOG(this);
	VDATEPTRIN(lpszKey, WCHAR);
    LPVOID lpvoid = NULL;

	if (m_pMap != NULL
        && (m_pMap->Lookup(lpszKey, lpvoid))
        && m_pMap->RemoveKey(lpszKey))
        {
    		if(lpvoid)
                ((LPUNKNOWN)lpvoid)->Release();
    		return NOERROR;
        }

	return ResultFromScode(E_FAIL);
}





#ifdef _DEBUG
STDMETHODIMP_(void) NC(CBindCtx,CDebug)::Dump( IDebugStream FAR * pdbstm)
{
	VOID_VDATEIFACE(pdbstm);
	
	NC(CBindCtx,CObjList) FAR * pCOL;

	*pdbstm << "CBindCtx @" << (VOID FAR *)m_pBindCtx <<'\n';
	pdbstm->Indent();
	*pdbstm << "m_BindCtx is " << (VOID FAR *)&(m_pBindCtx)<<'\n';
	*pdbstm << "Refcount is " << (int)(m_pBindCtx->m_refs) << '\n';
	*pdbstm << "Registered objects: \n";
	pdbstm->Indent();
	for (pCOL = m_pBindCtx->m_pFirstObj; pCOL; pCOL = pCOL->m_pNext )
		*pdbstm << (pCOL->m_punk);

	pdbstm->UnIndent();
	*pdbstm<<"End of registered objects \n";
	pdbstm->UnIndent();
}


STDMETHODIMP_(BOOL) NC(CBindCtx,CDebug)::IsValid( BOOL fSuspicious )
{
	return ((LONG)(m_pBindCtx->m_refs) > 0);
	//	add more later, maybe
}
#endif // _DEBUG


#ifdef NOTYET

NOTE: this code has to be fixed before used again: the ctor should
really fail if not enough memory is available and the next function
should copy the strings.  An alternative implementation might be wise.

#pragma SEG(CEnumStringImpl_ctor)
CEnumStringImpl::CEnumStringImpl( CMapStringToPtr FAR * pMap )
{
	LPWSTR lpsz;
	LPWSTR lpszKey;
	LPVOID lpvoid;
	size_t n;
	LI FAR * pli;

	POSITION pos = pMap->GetStartPosition();
	pliHead = NULL;
	while (pos != NULL)
	{
		pMap->GetNextAssoc(pos, lpszKey, lpvoid );
		lpsz = new FAR WCHAR[n = (1+_fstrlen(lpszKey))];
		if (lpsz == NULL)
			continue;

		memcpy(lpsz, lpszKey, n * sizeof(WCHAR));
		pli = new LI( lpsz );
		if (pli)
		{
			pli->pliNext = pliHead;
			pliHead = pli;
		}
	}
	pliCurrent = pliHead;
    m_refs = 1;
}



#pragma SEG(CEnumStringImpl_dtor)
CEnumStringImpl::~CEnumStringImpl( void )
{
	LI FAR * pli = pliHead;
	while (pli)
	{
		pliHead = pli->pliNext;
		delete pli->lpszKey;
		delete pli;
		pli = pliHead;
	}
}

#pragma SEG(CEnumStringImpl_Next)
STDMETHODIMP CEnumStringImpl::Next (ULONG celt,
		       LPWSTR FAR* reelt,
                       ULONG FAR* pceltFetched)
{
	ULONG celtTemp = 0;
	while (celtTemp < celt && pliCurrent)
	{
		reelt[celtTemp++] = pliCurrent->lpszKey;
		pliCurrent = pliCurrent->pliNext;
	}
	if (pceltFetched) *pceltFetched = celtTemp;
	return celtTemp == celt ? NOERROR : ResultFromScode(S_FALSE);
}


#pragma SEG(CEnumStringImpl_Skip)
STDMETHODIMP CEnumStringImpl::Skip (ULONG celt)
{
	ULONG celtTemp = 0;
	while (celtTemp < celt && pliCurrent)
		pliCurrent = pliCurrent->pliNext;
	return celtTemp == celt ? NOERROR : ResultFromScode(S_FALSE);
}


#pragma SEG(CEnumStringImpl_Reset)
STDMETHODIMP CEnumStringImpl::Reset (void)
{
	pliCurrent = pliHead;
	return NOERROR;
}


#pragma SEG(CEnumStringImpl_Clone)
STDMETHODIMP CEnumStringImpl::Clone (LPENUMSTRING FAR* ppenm)
{
	//	REVIEW :  to be implemented
	VDATEPTROUT(ppenm, LPENUMSTRING);
	*ppenm = NULL;
	return ResultFromScode(E_NOTIMPL);
}
#endif // NOTYET
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\com\moniker2\cbasemon.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1993 - 1993.
//
//  File:       cbasemon.cxx
//
//  Contents:   Implementation of CBaseMoniker
//
//  Classes:
//
//  Functions:
//
//  History:    12-27-93    ErikGav     Commented
//
//              03-??-97    Ronans      Changes for Objref moniker support
//              06-25-97    Ronans      Enum should return S_OK by default;
//
//----------------------------------------------------------------------------

#include <ole2int.h>

#include "cbasemon.hxx"
#include "mnk.h"

inline  HRESULT DerivedMustImplement( void )
{
    return ResultFromScode(E_NOTIMPL);  //  The derived class must implement this method
}
inline
HRESULT InappropriateMemberFunction( void )
{
    return ResultFromScode(E_NOTIMPL);  //  Member function inappropriate for moniker class
}

CBaseMoniker::~CBaseMoniker()
{
    // do nothing at present - just a place holder for virtual destructor if
    // needed
}


STDMETHODIMP CBaseMoniker::QueryInterface
    (REFIID riid, LPVOID FAR* ppvObj)
{
    M_PROLOG(this);

    // Do not validate input as it has already been validated
    // by derived classes.

    if (IsEqualIID(riid, IID_IROTData))
    {
        *ppvObj = (IROTData *) this;
    }
    else if (IsEqualIID(riid, IID_IMoniker)
	|| IsEqualIID(riid, IID_IUnknown)
	|| IsEqualIID(riid, IID_IInternalMoniker))
    {
	*ppvObj = this;
    }
	else if (IsEqualIID(riid, IID_IPersistStream))
	{
	*ppvObj = (IPersistStream *)this;
	}
    else if (IsEqualIID(riid, IID_IMarshal))
    {
	*ppvObj = &m_marshal;
    }
    else
    {
	*ppvObj = NULL;
	return E_NOINTERFACE;
    }

    InterlockedIncrement((long *)&m_refs);
    return NOERROR;
}


STDMETHODIMP_(ULONG) CBaseMoniker::AddRef ()
{
    mnkDebugOut((DEB_TRACE, "%p CBaseMoniker::AddRef(%ld)\n",
                 this, m_refs + 1));

    return InterlockedIncrement((long *)&m_refs);
}

STDMETHODIMP_(ULONG) CBaseMoniker::Release(void)
{
    mnkDebugOut((DEB_TRACE, "%p CBaseMoniker::Release(%ld)\n",
                 this, m_refs - 1));

    ULONG ul = m_refs;

    if (InterlockedDecrement((long *)&m_refs) == 0)
    {
    	delete this;
    	return 0;
    }
    return ul - 1;
}


STDMETHODIMP CBaseMoniker::IsDirty (THIS)
{
    M_PROLOG(this);
    return ResultFromScode(S_FALSE);
    //  monikers are immutable so they are either always dirty or never dirty.
    //
}

STDMETHODIMP CBaseMoniker::Load (THIS_ LPSTREAM pStm)
{
    M_PROLOG(this);
    return InappropriateMemberFunction();
}


STDMETHODIMP CBaseMoniker::Save (THIS_ LPSTREAM pStm,
	    BOOL fClearDirty)
{
    M_PROLOG(this);
    return InappropriateMemberFunction();
}


STDMETHODIMP CBaseMoniker::GetSizeMax (THIS_ ULARGE_INTEGER FAR * pcbSize)
{
    M_PROLOG(this);
    return InappropriateMemberFunction();
}

    // *** IMoniker methods ***
STDMETHODIMP CBaseMoniker::BindToObject (THIS_ LPBC pbc, LPMONIKER pmkToLeft,
    REFIID riidResult, LPVOID FAR* ppvResult)
{
    M_PROLOG(this);
    return InappropriateMemberFunction();
}

STDMETHODIMP CBaseMoniker::BindToStorage (THIS_ LPBC pbc, LPMONIKER pmkToLeft,
    REFIID riid, LPVOID FAR* ppvObj)
{
    M_PROLOG(this);
    return InappropriateMemberFunction();
}

STDMETHODIMP CBaseMoniker::Reduce (THIS_ LPBC pbc, DWORD dwReduceHowFar, LPMONIKER FAR*
    ppmkToLeft, LPMONIKER FAR * ppmkReduced)
{
    M_PROLOG(this);
    *ppmkReduced = this;
    AddRef();
    return ResultFromScode(MK_S_REDUCED_TO_SELF);
}

STDMETHODIMP CBaseMoniker::ComposeWith (THIS_ LPMONIKER pmkRight, BOOL fOnlyIfNotGeneric,
    LPMONIKER FAR* ppmkComposite)
{
    M_PROLOG(this);
    return InappropriateMemberFunction();
}

STDMETHODIMP CBaseMoniker::Enum (THIS_ BOOL fForward, LPENUMMONIKER FAR* ppenumMoniker)
{
    M_PROLOG(this);
 	VDATEPTROUT(ppenumMoniker,LPENUMMONIKER);
    if (ppenumMoniker)
    {
    	*ppenumMoniker = NULL;
    	return S_OK;
    }

    return E_INVALIDARG;
}

STDMETHODIMP CBaseMoniker::IsEqual (THIS_ LPMONIKER pmkOtherMoniker)
{
    M_PROLOG(this);
    return InappropriateMemberFunction();
}

STDMETHODIMP CBaseMoniker::Hash (THIS_ LPDWORD pdwHash)
{
    M_PROLOG(this);
    return InappropriateMemberFunction();
}

STDMETHODIMP CBaseMoniker::GetTimeOfLastChange (THIS_ LPBC pbc, LPMONIKER pmkToLeft,
    FILETIME FAR* pfiletime)
{
    M_PROLOG(this);
    return InappropriateMemberFunction();
}

STDMETHODIMP CBaseMoniker::Inverse (THIS_ LPMONIKER FAR* ppmk)
{
    M_PROLOG(this);
    *ppmk = NULL;
    return ResultFromScode(MK_E_NOINVERSE);
}

STDMETHODIMP CBaseMoniker::CommonPrefixWith (LPMONIKER pmkOther, LPMONIKER FAR*
    ppmkPrefix)
{
    // use default behavior for most cases
    return MonikerCommonPrefixWith(this, pmkOther, ppmkPrefix);
}

STDMETHODIMP CBaseMoniker::RelativePathTo (THIS_ LPMONIKER pmkOther, LPMONIKER FAR*
    ppmkRelPath)
{
    // use default behavior for most cases
    return MonikerRelativePathTo(this, pmkOther, ppmkRelPath, TRUE);
}

STDMETHODIMP CBaseMoniker::GetDisplayName (THIS_ LPBC pbc, LPMONIKER pmkToLeft,
    LPWSTR FAR* lplpszDisplayName)
{
    M_PROLOG(this);
    return InappropriateMemberFunction();
}

STDMETHODIMP CBaseMoniker::ParseDisplayName (THIS_ LPBC pbc, LPMONIKER pmkToLeft,
    LPWSTR lpszDisplayName, ULONG FAR* pchEaten,
    LPMONIKER FAR* ppmkOut)
{
    M_PROLOG(this);
    return InappropriateMemberFunction();
}


STDMETHODIMP CBaseMoniker::IsSystemMoniker (THIS_ LPDWORD pdwMksys)
{
    M_PROLOG(this);
  VDATEPTROUT (pdwMksys, DWORD);

  *pdwMksys = 0;
  return NOERROR;
}


STDMETHODIMP CBaseMoniker::IsRunning (THIS_ LPBC pbc, LPMONIKER pmkToLeft,
	      LPMONIKER pmkNewlyRunning)
{
    M_PROLOG(this);
  VDATEIFACE (pbc);
  LPRUNNINGOBJECTTABLE pROT;
  HRESULT hresult;


  if (pmkToLeft)
    VDATEIFACE (pmkToLeft);
  if (pmkNewlyRunning)
    VDATEIFACE (pmkNewlyRunning);

  if (pmkToLeft == NULL)
  {
      if (pmkNewlyRunning != NULL)
      {
      return pmkNewlyRunning->IsEqual (this);
      }
      else
      {
      hresult = pbc->GetRunningObjectTable (&pROT);
      if (hresult == NOERROR)
      {
	  hresult = pROT->IsRunning (this);
	  pROT->Release ();
      }
      return hresult;
      }
  }
  else
  {
      return ResultFromScode(S_FALSE);
  }

}


STDMETHODIMP CBaseMoniker::GetComparisonData(
    byte *pbData,
    ULONG cbMax,
    ULONG *pcbData)
{
    return InappropriateMemberFunction();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\com\moniker2\ccompmon.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1993 - 1993.
//
//  File:       ccompmon.cxx
//
//  Contents:   Generic Composite Monikers
//
//  Classes:
//
//  Functions:
//
//  History:    12-27-93   ErikGav   Commented
//              02-01-94   KevinRo      Gagged on it, then tried to explain
//              06-14-94   Rickhi    Fix type casting
//              08-08-94   BruceMa   Memory sift fix
//              10-Jan-95  BruceMa   Conform MonikerRelativePathTo to spec
//              03-Apr-96  BruceMa   Fix ::IsEqual
//              22-May-96  BruceMa   Re fix ::IsEqual
//
//
//  Composite monikers are implemented here. A composite moniker is created
//  as a binary tree of monikers, with the leaf nodes of the tree being
//  non-composite monikers.
//
//  Every composite moniker has a left and a right part (otherwise it
//  wouldn't be a composite moniker).  The composition of two monikers
//  involves creating a new composite, and pointing left and right at
//  the two parts of the composite. This is how the binary tree is
//  built.
//
//  (Note: This may not be the most efficient way of implementing this,
//   but it is legacy code we are going to adopt. Sorry!)
//
//  The ordering in the tree is left most. Therefore, there are many
//  possible tree configurations, as long as the leaf nodes evaluate
//  to the same order when done left to right. This is an important point
//  to keep in mind when you are looking at some of the functions, such
//  as AllButFirst, which creates a new composite tree. At first, it doesn't
//  appear to do the correct thing, until you draw it out on paper, and
//  realize that the nodes are still visited in the same order.
//
//----------------------------------------------------------------------------

#include <ole2int.h>

#include "cbasemon.hxx"
#include "ccompmon.hxx"
#include "cfilemon.hxx"
#include "mnk.h"
#include <rotdata.hxx>

#include <olepfn.hxx>

INTERNAL_(CCompositeMoniker *) IsCompositeMoniker ( LPMONIKER pmk )
{
    CCompositeMoniker *pCMk;

    if ((pmk->QueryInterface(CLSID_CompositeMoniker, (void **)&pCMk)) == S_OK)
    {
        //  the Release the AddRef done by QI, but still return the ptr
        pCMk->Release();
        return pCMk;
    }

    //  dont rely on user implementations to set pCMk to NULL on failed QI
    return NULL;
}

CCompositeMoniker::CCompositeMoniker( void ) CONSTR_DEBUG
{
    m_pmkLeft = NULL;
    m_pmkRight = NULL;
    m_fReduced = FALSE;

#ifdef _TRACKLINK_
    _tcm.SetParent(this);
    m_fReduceForced = FALSE;
#endif

    //
    // CoQueryReleaseObject needs to have the address of the this objects
    // query interface routine.
    //
    if (adwQueryInterfaceTable[QI_TABLE_CCompositeMoniker] == 0)
    {
        adwQueryInterfaceTable[QI_TABLE_CCompositeMoniker] =
            **(ULONG_PTR **)((IMoniker *)this);
    }

}

/*
 *      Implementation of CCompositeMoniker
 */

CCompositeMoniker::~CCompositeMoniker( void )
{
    mnkDebugOut((DEB_ITRACE,
                 "CCompositeMoniker::~CCompositeMoniker(%x)\n",
                 this));

        //      REVIEW: this is recursive deletion of what is essentially a linked
        //      list.  A rewrite could save stack space.
        if (m_pmkLeft)
        {
             m_pmkLeft->Release();
        }

        if (m_pmkRight)
        {
            m_pmkRight->Release();
        }
}

//
// Turns out that the classfactory for this moniker will create an empty
// instance by called ::Create(NULL,NULL). The create function has been
// changed to special case this condition, and NOT call initialize.
//

INTERNAL_(BOOL) CCompositeMoniker::Initialize( LPMONIKER pmkFirst,
        LPMONIKER pmkRest)
{
    mnkDebugOut((DEB_ITRACE,
                 "CCompositeMoniker::Initialize(%x)\n",
                 this));
    //
    // Neither moniker can be NULL
    //
    if ((pmkFirst == NULL) || (pmkRest == NULL))
    {
        return(FALSE);
    }

    GEN_VDATEIFACE(pmkFirst, FALSE);
    GEN_VDATEIFACE(pmkRest, FALSE);

    m_pmkLeft = pmkFirst;

    pmkFirst->AddRef(); 

    m_pmkRight = pmkRest;

    pmkRest->AddRef();  

    m_fReduced = IsReduced(pmkFirst) && IsReduced(pmkRest);     

    return TRUE;
}



//+---------------------------------------------------------------------------
//
//  Method:     CCompositeMoniker::Create
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:  [pmkFirst] --
//              [pmkRest] --
//              [memLoc] --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:
//
//  History:    2-03-94   kevinro   Commented
//
//  Notes:
//
//      We assume that *pmkFirst is not capable of collapsing with *pmkRest;
//      otherwise, this would not have been called.
//
//----------------------------------------------------------------------------
CCompositeMoniker FAR *
CCompositeMoniker::Create( LPMONIKER pmkFirst, LPMONIKER pmkRest)
{
    mnkDebugOut((DEB_ITRACE,
                 "CCompositeMoniker::Create()\n"));

    //
    // Create can be called with both pointers being NULL, in which
    // case the Initialize function need not be called. This is the
    // case when a CompositeMoniker is being loaded from stream.
    //
    // Either both are NULL, or neither is NULL
    //

    if ((pmkFirst == NULL) || (pmkRest == NULL))
    {
        //
        // One of them is NULL. If the other isn't NULL, return an error
        //

        if (pmkFirst != pmkRest)
        {
            return NULL;
        }
    }

    //
    // Both pointers are not NULL, initialize the moniker
    //

    CCompositeMoniker FAR * pCM = new CCompositeMoniker();

    if (pCM != NULL)
    {
            if (pmkFirst != NULL || pmkRest != NULL)
            {
                if (!pCM->Initialize( pmkFirst, pmkRest ))
                {
                    delete pCM;
                    return NULL;
                }
            }
    }

    CALLHOOKOBJECTCREATE(S_OK,CLSID_NULL,IID_IMoniker,(IUnknown **)&pCM);
    return pCM;
}


STDMETHODIMP CCompositeMoniker::QueryInterface(THIS_ REFIID riid,
        LPVOID FAR* ppvObj)
{
    VDATEIID (riid);
    VDATEPTROUT(ppvObj, LPVOID);

	*ppvObj = NULL;

#ifdef _DEBUG
    if (riid == IID_IDebug)
    {
        *ppvObj = &(m_Debug);
        return NOERROR;
    }
#endif
#ifdef _TRACKLINK_
    if (IsEqualIID(riid, IID_ITrackingMoniker))
    {
        AddRef();
        *ppvObj = (ITrackingMoniker *) & _tcm;
        return(S_OK);
    }
#endif
    if (IsEqualIID(riid, CLSID_CompositeMoniker))
    {
        //  called by IsCompositeMoniker.
        AddRef();
        *ppvObj = this;
        return S_OK;
    }

    return CBaseMoniker::QueryInterface(riid, ppvObj);
}


STDMETHODIMP CCompositeMoniker::GetClassID (THIS_ LPCLSID lpClassID)
{
        VDATEPTROUT(lpClassID, CLSID);
        *lpClassID = CLSID_CompositeMoniker;
        return NOERROR;
}


//+---------------------------------------------------------------------------
//
//  Method:     CCompositeMoniker::Load
//
//  Synopsis:   Loads a composite moniker from stream
//
//  Effects:
//
//  Arguments:  [pStm] --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:
//
//  History:    2-03-94   kevinro   Commented
//
//  Notes:
//      The serialized form of a composite moniker is a ULONG count of
//      monikers, followed by each non-composite moniker written
//      left to right.
//
//  WARNING: Be very careful with the refernce counting in this routine.
//
//----------------------------------------------------------------------------
STDMETHODIMP CCompositeMoniker::Load (THIS_ LPSTREAM pStm)
{
    mnkDebugOut((DEB_ITRACE,
                 "CCompositeMoniker::Load(%x)\n",this));

        VDATEIFACE(pStm);

        ULONG cMonikers = 0;
        ULONG n;
        LPMONIKER pmk     = NULL;
        LPMONIKER pmkPrev = NULL;
        HRESULT hresult;

        //
        //      Monikers are immutable, so this is called only when creating a
        //      moniker, and so we assert if this moniker is not newly created.
        //

        Assert(m_pmkLeft == NULL && m_pmkRight == NULL);

        if ((m_pmkLeft != NULL) || (m_pmkRight != NULL ))
        {
            return(E_UNEXPECTED);
        }


        //      There is no collapsing of successive pieces of the moniker, since
        //      this was once written to disk, and the collapsing would have happened
        //      before that.

        hresult = StRead(pStm, (LPVOID)&cMonikers, sizeof(ULONG));

        if (FAILED(hresult))
        {
            goto errRet;
        }

        //      some plausibility checking on cMonikers might be appropriate
        //      if there is only one, we shouldn't have had a composite moniker

        Assert( cMonikers >= 2 );


        if (cMonikers < 2)
        {
            hresult = E_UNEXPECTED;
            goto errRet;
        }

        //
        // Note: n is used 1 based, since this loop does something special on the
        // last moniker.
        //

        for (n = 1; n <= cMonikers; n++ )
        {

            //
            // After loading the reference count for the new moniker will == 1
            //
            hresult = OleLoadFromStream(pStm, IID_IMoniker, (LPVOID FAR*)&pmk);

            if (FAILED(hresult))
            {
                goto errRet;            
            }

            //
            // If this is the last moniker, then it will be the right moniker
            // to 'this' composite moniker.
            //
            if (n == cMonikers)         //      this is the last moniker read
            {
                //
                // Save away the pointer into the right moniker for this instance
                // of the composite.
                // The reference count is OK, since it was set to 1 on creation,
                // and we are saving it
                //
                m_pmkRight = pmk;

                //
                // AddRef not needed, its already 1, and we are supposed to
                // exit the loop
                //

                m_pmkLeft = pmkPrev;

                Assert( pmkPrev != NULL );

            }
            else if (pmkPrev == NULL)
            {
                pmkPrev = pmk;
            }
            else
            {
                LPMONIKER pmkTemp;

                //
                // Warning: Here is some tricky stuff. pmkPrev has a reference
                // of 1 at the moment, because thats how we created it.
                //
                // pmk also has a refcount == 1
                //
                // We are going to create another composite, of which they will
                // become members. The Create function is going to increment
                // both (making them 2).
                //

                pmkTemp = CCompositeMoniker::Create(pmkPrev,
                                                    pmk);

                if (pmkTemp == NULL)
                {
                    hresult = E_OUTOFMEMORY;
                    goto errRet;
                }

                //
                // The new moniker is holding refcounts to both monikers that
                // are not needed. Releasing these two sets the refcounts
                // back to 1 like they should be.
                //

                pmkPrev->Release();
                pmk->Release();

                //
                // Now, pmkPrev gets the new composite.
                //

                pmkPrev = pmkTemp;
            }

            //
            // pmk has been given to another pointer. NULL it out in case
            // there is an error later, so we don't try to release it too
            // many times.
            //

            pmk = NULL;
        }

        //
        // Exiting at this point leaves the moniker pointed to by pmkPrev
        //

        return(NOERROR);

errRet:
        if (pmkPrev != NULL)
        {
            pmkPrev->Release(); 
        }
        if (pmk != NULL)
        {
            pmk->Release();
        }

        return hresult;
}

INTERNAL_(ULONG) CCompositeMoniker::Count(void)
{
        M_PROLOG(this);

        CCompositeMoniker *pCMk = IsCompositeMoniker(m_pmkLeft);
        ULONG cMk = (pCMk) ? pCMk->Count() : 1;

        Assert(m_pmkLeft != NULL);

        pCMk = IsCompositeMoniker(m_pmkRight);
        cMk += (pCMk) ? pCMk->Count() : 1;

        Assert(cMk >= 2);
        return cMk;
}




//+---------------------------------------------------------------------------
//
//  Method:     CCompositeMoniker::Save
//
//  Synopsis:   Save the composite to a stream
//
//  Effects:
//
//  Arguments:  [pStm] --
//              [fClearDirty] --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:
//
//  History:    2-03-94   kevinro   Commented
//
//  Notes:
//
//      The serialized form of a composite moniker is a ULONG count of
//      monikers, followed by each non-composite moniker written
//      left to right.
//
//----------------------------------------------------------------------------
STDMETHODIMP CCompositeMoniker::Save (THIS_ LPSTREAM pStm, BOOL fClearDirty)
{
    mnkDebugOut((DEB_ITRACE,
                 "CCompositeMoniker::Save(%x)\n",this));

    VDATEIFACE(pStm);
    ULONG cMonikers;            //      count of monikers in this composite.
    HRESULT hresult;
    LPENUMMONIKER pEnum;
    LPMONIKER pmk;
    ULONG i;

    cMonikers = Count();

    hresult = pStm->Write(&cMonikers, sizeof(ULONG), NULL);

    if (FAILED(hresult))
    {
        goto errRet;
    }

    //
    //  Write out left to right using enumerator.
    //

    hresult = Enum(TRUE, &pEnum);

    if (hresult != NOERROR)
    {
        goto errRet;    
    }

    if (pEnum != NULL)
    {
        for( i = 0; i < cMonikers; i++)
        {
            hresult = pEnum->Next(1, &pmk, NULL);

            if (hresult != NOERROR)
            {
                if (S_FALSE == hresult)
                {
                    //
                    // If the enumerator returns S_FALSE, then it has no more
                    // monikers to hand out. This is bad, since we haven't
                    // written out the number of monikers we were supposed to.
                    // Therefore, it is an E_UNEXPECTED error
                    //
                    hresult = E_UNEXPECTED;
                
                }
                goto errRet;
            }

            //
            // If pmk is NULL, something seriously wrong happened.
            //

            if (pmk == NULL)
            {
                hresult = E_UNEXPECTED;
                goto errRet;
            }

            hresult = OleSaveToStream( pmk, pStm );

            pmk->Release();

            if (hresult != NOERROR)
            {
                goto errRet;
            }
        }

        pEnum->Release();
    }
    else
    {
        //
        // If we get here, and cMonikers isn't 0, something else happened
        //
        if (cMonikers != 0)
        {
            hresult = E_UNEXPECTED;
        }
    }

errRet:
        return hresult;
}



//+---------------------------------------------------------------------------
//
//  Method:     CCompositeMoniker::GetSizeMax
//
//  Synopsis:   Return the maximum size required to marshal this composite
//
//  Effects:
//
//  Arguments:  [pcbSize] --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:
//
//  History:    2-03-94   kevinro   Commented
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CCompositeMoniker::GetSizeMax (ULARGE_INTEGER FAR * pcbSize)
{
    mnkDebugOut((DEB_ITRACE,
                 "CCompositeMoniker::GetSizeMax(%x)\n",this));

        VDATEPTROUT(pcbSize, ULARGE_INTEGER);

        LPENUMMONIKER pEnum = NULL;
        LPMONIKER pmk = NULL;
        HRESULT hresult;
        ULARGE_INTEGER cbSize2;


        //
        // The composite itself writes out a CLSID and a count of monikers
        //
        ULONG cbSize = sizeof(CLSID) + sizeof(ULONG);

        //
        // Use an enumerator to walk the list of monikers
        //
        hresult = Enum(TRUE, &pEnum);

        if (hresult != NOERROR)
        {
            goto errRet;        
        }

        Assert(pEnum != NULL);

        while (TRUE)
        {
            hresult = pEnum->Next(1, &pmk, NULL);
            if (hresult != NOERROR)
            {
                if (hresult == S_FALSE)
                {
                    //
                    // S_FALSE is the 'done' code
                    //

                    hresult = NOERROR;                  
                }

                goto errRet;
            }
            Assert(pmk != NULL);

            cbSize2.LowPart = cbSize2.HighPart = 0;

            hresult = pmk->GetSizeMax(&cbSize2);

            pmk->Release();

            if (hresult)
            {
                goto errRet;            
            }

            //
            // The sub-GetSizeMax's don't account for the GUID
            // that OleSaveToStream writes on the monikers behalf.
            // Therefore, we will add it in on our own.
            //

            cbSize += cbSize2.LowPart + sizeof(GUID);
        }
errRet:
        if (pEnum)
        {
            pEnum->Release();   
        }

        ULISet32(*pcbSize,cbSize);
        RESTORE_A5();
        return hresult;
}



//+---------------------------------------------------------------------------
//
//  Method:     CCompositeMoniker::AllButLast
//
//  Synopsis:
//              
//      returns a moniker that consists of all but the last moniker of this
//      composite.  Since a composite must have at least two pieces, this will
//      never be zero, but it may not be a composite.
//
//  Effects:
//
//  Arguments:  [void] --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:
//
//  History:    2-03-94   kevinro   Commented
//              17-May-94 AlexT     Plug memory leak, check for error
//
//  Notes:
//
//----------------------------------------------------------------------------
INTERNAL_(LPMONIKER)
CCompositeMoniker::AllButLast(void)
{
    mnkDebugOut((DEB_ITRACE,
                 "CCompositeMoniker::AllButLast(%x)\n",this));

    LPMONIKER pmk;

    Assert(m_pmkRight != NULL );

    //
    // Recurse down the right branch of the tree until a non composite moniker
    // is found. When a non-composite right most moniker is found, return the
    // left part of the tree. As the recurse unwinds, a new composite is
    // formed from each intermediate node.
    //
    // Yeah, I know, its seems expensive. However, composite monikers are
    // fairly cheap to allocate (no strings or stuff). The average
    // composite moniker only has one or two nodes, so this isn't as bad
    // as you might think. In theory, there are only LOG2(n) nodes created,
    // where n == number of parts in the composite.
    //

    CCompositeMoniker *pCMk = IsCompositeMoniker(m_pmkRight);
    if (pCMk)
    {
        LPMONIKER pmkRight;

        pmkRight = pCMk->AllButLast();
        if (NULL == pmkRight)
        {
            //  We didn't get back a moniker from AllButLast, even though
            //  pmkRight is a composite moniker.  Probably out of memory...
            mnkDebugOut((DEB_WARN,
                         "CCompositeMoniker::AllButLast recursive call "
                         "returned NULL\n"));

            pmk = NULL;
        }
        else
        {
            pmk = CCompositeMoniker::Create(m_pmkLeft, pmkRight);
            pmkRight->Release();
        }
    }
    else
    {
        Assert(m_pmkLeft != NULL && "Bad composite moniker");
        pmk = m_pmkLeft;
        pmk->AddRef();
    }
    return pmk;
}



//+---------------------------------------------------------------------------
//
//  Method:     CCompositeMoniker::Last
//
//  Synopsis:
//      return the last moniker in the composite list.  It is guaranteed to be
//      non-null and non-composite
//
//  Effects:
//
//  Arguments:  [void] --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:
//
//  History:    2-03-94   kevinro   Commented
//
//  Notes:
//
//----------------------------------------------------------------------------
INTERNAL_(LPMONIKER)
CCompositeMoniker::Last(void)
{
    mnkDebugOut((DEB_ITRACE,
                 "CCompositeMoniker::Last(%x)\n",this));

    CCompositeMoniker FAR * pCM = this;
    CCompositeMoniker FAR * pCMNext;

    //
    // Run down the right side of the tree, looking for a non-composite
    // right moniker (the leaf node).
    //

    while ((pCMNext = IsCompositeMoniker(pCM->m_pmkRight)) != NULL)
    {
        pCM = pCMNext;
    }

    IMoniker *pmk = pCM->m_pmkRight;

    Assert(pmk != NULL && (!IsCompositeMoniker(pmk)));

    pmk->AddRef();

    return pmk;
}



//+---------------------------------------------------------------------------
//
//  Method:     CCompositeMoniker::AllButFirst
//
//  Synopsis:
//      returns a moniker that consists of all but the first moniker of this
//      composite.  Since a composite must have at least two pieces, this will
//      never be zero, but it may not be a composite.
//
//  Effects:
//
//  Arguments:  [void] --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:
//
//  History:    2-03-94   kevinro   Commented
//
//  Notes:
//
//----------------------------------------------------------------------------
INTERNAL_(LPMONIKER)
CCompositeMoniker::AllButFirst(void)
{
    mnkDebugOut((DEB_ITRACE,
                 "CCompositeMoniker::AllButFirst(%x)\n",this));

    LPMONIKER pmk;

    //
    // Run down the left side of the tree, creating a composite moniker with
    // everything but the first moniker. See AllButLast for a pithy quote
    // about the efficiency
    //

    CCompositeMoniker *pCM = IsCompositeMoniker(m_pmkLeft);
    if (pCM)
    {
        LPMONIKER pmkABF = pCM->AllButFirst();

        pmk = CCompositeMoniker::Create(pmkABF, m_pmkRight);

        pmkABF->Release();
    }
    else
    {
        pmk = m_pmkRight;
        pmk->AddRef();
    }
    return pmk;
}

//+---------------------------------------------------------------------------
//
//  Method:     CCompositeMoniker::First
//
//  Synopsis:
//      return the first moniker in the composite list.  It is guaranteed to be
//      non-null and non-composite
//
//  Effects:
//
//  Arguments:  [void] --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:
//
//  History:    2-03-94   kevinro   Commented
//
//  Notes:
//
//----------------------------------------------------------------------------
INTERNAL_(LPMONIKER)
CCompositeMoniker::First(void)
{
    mnkDebugOut((DEB_ITRACE,
                 "CCompositeMoniker::First(%x)\n",this));

    CCompositeMoniker *pCM = this;
    CCompositeMoniker *pCMNext;

    while ((pCMNext = IsCompositeMoniker(pCM->m_pmkLeft)) != NULL)
    {
        pCM = pCMNext;
    }

    IMoniker *pmk = pCM->m_pmkLeft;

    Assert(pmk != NULL && (!IsCompositeMoniker(pmk)));

    pmk->AddRef();

    return pmk;
}


STDMETHODIMP CCompositeMoniker::BindToObject (LPBC pbc,
        LPMONIKER pmkToLeft, REFIID riidResult, LPVOID FAR* ppvResult)
{
    mnkDebugOut((DEB_ITRACE,
                 "CCompositeMoniker::BindToObject(%x)\n",this));

        VDATEPTROUT(ppvResult, LPVOID);
        VDATEIFACE(pbc);
        VDATEIID(riidResult);

        *ppvResult = NULL;

        if (pmkToLeft)
        {
            VDATEIFACE(pmkToLeft);      
        }

        HRESULT hresult = NOERROR;
        LPRUNNINGOBJECTTABLE prot;
        *ppvResult = NULL;

        LPMONIKER pmkAllButLast = NULL;
        LPMONIKER pmkLast = NULL;
        LPMONIKER pmkNewLeft = NULL;

        //      Look for moniker in running objects table if there is nothing to the
        //      left

        if (pmkToLeft == NULL)
        {
                hresult = pbc->GetRunningObjectTable( &prot );
                if (hresult == NOERROR)
                {
                        LPUNKNOWN pUnk;
                        hresult = prot->GetObject(this, &pUnk);
                        prot->Release();
                        if ((hresult == NOERROR) && (pUnk != NULL))
                        {
                                hresult = pUnk->QueryInterface(riidResult, ppvResult);
                                pUnk->Release();
                                goto errRet;
                        }
                }
                else
                {
                        goto errRet;            
                }
        }


        pmkAllButLast = AllButLast();

        if (pmkAllButLast == NULL)
        {
            // The creation must have failed. The only reason we could think of was
            // out of memory.
            hresult = E_OUTOFMEMORY;
            goto errRet;
        }

        pmkLast = Last();
        if (pmkLast == NULL)
        {
            // The creation must have failed. The only reason we could think of was
            // out of memory.
            hresult = E_OUTOFMEMORY;
            goto errRet1;
        }

        Assert((pmkLast != NULL) && (pmkAllButLast != NULL));

        if (pmkToLeft != NULL)
        {
        //      REVIEW: check for error from ComposeWith
            hresult = pmkToLeft->ComposeWith(pmkAllButLast, FALSE, &pmkNewLeft);
            if (FAILED(hresult))
            {
                goto errRet2;
            }
        }
        else
        {
            pmkNewLeft = pmkAllButLast;
            pmkNewLeft->AddRef();
        }

        hresult = pmkLast->BindToObject(pbc, pmkNewLeft, riidResult, ppvResult);

errRet2:
        pmkLast->Release();
errRet1:
        pmkAllButLast->Release();

        if (pmkNewLeft != NULL)
        {
             pmkNewLeft->Release();     
        }

errRet:

        return hresult;
}


STDMETHODIMP CCompositeMoniker::BindToStorage (LPBC pbc, LPMONIKER pmkToLeft,
        REFIID riid, LPVOID FAR* ppvObj)
{
    mnkDebugOut((DEB_ITRACE,
                 "CCompositeMoniker::BindToStorage(%x)\n",this));

        M_PROLOG(this);
        VDATEPTROUT(ppvObj,LPVOID);
        *ppvObj = NULL;
        VDATEIFACE(pbc);
        if (pmkToLeft) VDATEIFACE(pmkToLeft);
        VDATEIID(riid);

        HRESULT hresult = NOERROR;

        LPMONIKER pmkAllButLast = AllButLast();
        LPMONIKER pmkLast = Last();
        LPMONIKER pmkNewLeft = NULL ;

        if (pmkToLeft)
        {
                hresult = pmkToLeft->ComposeWith(pmkAllButLast, FALSE, &pmkNewLeft);
                if (hresult) goto errRet;
        }
        else
        {
                pmkNewLeft = pmkAllButLast;
                pmkNewLeft->AddRef();
        }

        hresult = pmkLast->BindToStorage(pbc, pmkNewLeft, riid, ppvObj);

errRet:
        if (pmkAllButLast) pmkAllButLast->Release();
        if (pmkLast) pmkLast->Release();
        if (pmkNewLeft) pmkNewLeft->Release();

        return hresult;
}




STDMETHODIMP CCompositeMoniker::Reduce (LPBC pbc,
        DWORD dwReduceHowFar,
        LPMONIKER FAR* ppmkToLeft,
        LPMONIKER FAR * ppmkReduced)
{
        mnkDebugOut((DEB_ITRACE,
                 "CCompositeMoniker::Reduce(%x)\n",this));

        M_PROLOG(this);
        VDATEPTROUT(ppmkReduced,LPMONIKER);
        *ppmkReduced = NULL;
        VDATEIFACE(pbc);
        if (ppmkToLeft)
        {
                VDATEPTROUT(ppmkToLeft,LPMONIKER);
                if (*ppmkToLeft) VDATEIFACE(*ppmkToLeft);
        }

        LPMONIKER pmkLeftReduced = NULL;
        LPMONIKER pmkRightReduced = NULL;
        CCompositeMoniker FAR * pmkCompositeReduced;
        SCODE scode1 = S_OK;
        SCODE scode2 = S_OK;

#ifdef _TRACKLINK_
        if (!m_fReduceForced && m_fReduced)     //      already reduced maximally
#else
        if (m_fReduced) //      already reduced maximally
#endif
        {
                AddRef();
                *ppmkReduced = this;
                return ResultFromScode(MK_S_REDUCED_TO_SELF);
        }

        if (m_pmkLeft)
        {
                scode1 = GetScode( m_pmkLeft->Reduce(pbc,
                    dwReduceHowFar,
                    NULL,
                    &pmkLeftReduced));
                // AssertOutPtrIface(scode1, pmkLeftReduced);
                if (scode1 != S_OK && scode1 != MK_S_REDUCED_TO_SELF)
                        return ResultFromScode(scode1);
        }
        
        if (m_pmkRight)
        {
                // SPEC:

                /*

                ppmkToLeft

                [out] On entry, ppmkToLeft points to the moniker that 
                prefixes this one within the composite, that is, the 
                moniker to the left of the current moniker.  On exit, the 
                pointer will be NULL or non-NULL.  Non-NULL indicates that 
                the previous prefix should be disregarded and the moniker 
                returned through ppmkToLeft should be used as the prefix 
                in its place (this is not usual).  NULL indicates that the 
                prefix should not be replaced.  Most monikers will NULL 
                out this parameter before returning.  The ppmkToLeft 
                parameter is an [in,out] parameter and it must be released 
                before NULLing out.  If an error is returned, this 
                parameter must be set to NULL.  For more information on 
                [in,out] parameters, see the discussion of parameter types 
                in the section on Memory Management.  

                */ 

                IMoniker *pmkLeftReducedTmp = pmkLeftReduced;
                pmkLeftReducedTmp->AddRef();

                scode2 = GetScode( m_pmkRight->Reduce(pbc,
                    dwReduceHowFar,
                    &pmkLeftReducedTmp,
                    &pmkRightReduced));
                // AssertOutPtrIface(scode2, pmkRightReduced);

                if (pmkLeftReducedTmp == NULL)
                {
                    // prefix should not be replaced
                    // we still have original ref
                }
                else
                {
                    // use pmkLeftReducedTmp as the new left piece
                    pmkLeftReduced->Release(); // the original ref
                    pmkLeftReduced = pmkLeftReducedTmp;
                }

                if (scode2 != S_OK && scode2 != MK_S_REDUCED_TO_SELF)
                {
                        if (pmkLeftReduced)
                            pmkLeftReduced->Release();
                        return ResultFromScode(scode2);
                }
        }
        if (scode1 == MK_S_REDUCED_TO_SELF && scode2 == MK_S_REDUCED_TO_SELF)
        {
                pmkLeftReduced->Release();
                pmkRightReduced->Release();
                AddRef();
                m_fReduced = TRUE;
                *ppmkReduced = this;
                return ResultFromScode(MK_S_REDUCED_TO_SELF);
        }
        //      No error, and one of the two pieces actually reduced.
        pmkCompositeReduced = CCompositeMoniker::Create(pmkLeftReduced,
                pmkRightReduced );
        pmkLeftReduced->Release();
        pmkRightReduced->Release();
        if (pmkCompositeReduced != NULL)
            pmkCompositeReduced->m_fReduced = TRUE;
        *ppmkReduced = pmkCompositeReduced;
        return pmkCompositeReduced == NULL ? E_OUTOFMEMORY : NOERROR;   
}




STDMETHODIMP CCompositeMoniker::ComposeWith (LPMONIKER pmkRight,
        BOOL fOnlyIfNotGeneric, LPMONIKER FAR* ppmkComposite)
{
    mnkDebugOut((DEB_ITRACE,
                 "CCompositeMoniker::ComposeWith(%x)\n",this));

    M_PROLOG(this);

    if (fOnlyIfNotGeneric)
    {
        return(MK_E_NEEDGENERIC);
    }

    return CreateGenericComposite( this, pmkRight, ppmkComposite );
}


STDMETHODIMP CCompositeMoniker::Enum (BOOL fForward, LPENUMMONIKER FAR* ppenumMoniker)
{
    mnkDebugOut((DEB_ITRACE,
                 "CCompositeMoniker::Enum(%x)\n",this));

        M_PROLOG(this);
        VDATEPTROUT(ppenumMoniker,LPENUMMONIKER);
        *ppenumMoniker = NULL;
        *ppenumMoniker = CCompositeMonikerEnum::Create(fForward, this);
        if (*ppenumMoniker) return NOERROR;
        return ResultFromScode(E_OUTOFMEMORY);
}


STDMETHODIMP CCompositeMoniker::IsEqual (LPMONIKER pmkOtherMoniker)
{
    mnkDebugOut((DEB_ITRACE,
                 "CCompositeMoniker::IsEqual(%x)\n",this));
    
    M_PROLOG(this);
    VDATEIFACE(pmkOtherMoniker);
    
    HRESULT       hr = S_FALSE;
    HRESULT       hr2;
    LPENUMMONIKER pEnumMe;
    LPENUMMONIKER pEnumOther;
    LPMONIKER     pMkMe;
    LPMONIKER     pMkOther;
    
    // REVIEW:  do we call Reduce first?  No: spec isssue 330
    
    CCompositeMoniker *pCMk = IsCompositeMoniker(pmkOtherMoniker);
    if (pCMk)
    {
        hr = Enum(TRUE, &pEnumMe);
        if (SUCCEEDED(hr))
        {
            hr = pmkOtherMoniker->Enum(TRUE, &pEnumOther);
            if (SUCCEEDED(hr))
            {
                // Initialize
                pEnumMe->Reset();
                pEnumOther->Reset();
                
                // Compare successive elements
                for (;;)
                {
                    // Fetch the next two elements
                    hr = pEnumMe->Next(1, &pMkMe, NULL);
                    hr2 = pEnumOther->Next(1, &pMkOther, NULL);

                    // Compare them
                    if (hr == S_OK  &&  hr2 == S_OK)
                    {
                        if (pMkMe->IsEqual(pMkOther) == S_FALSE)
                        {
                            pMkMe->Release();
                            pMkOther->Release();
                            hr = S_FALSE;
                            break;
                        }
                    }

                    // Release the individual monikers
                    if (hr == S_OK)
                    {
                        pMkMe->Release();
                    }
                    if (hr2 == S_OK)
                    {
                        pMkOther->Release();
                    }

                    // All elements exhausted
                    if (hr == S_FALSE  &&  hr2 == S_FALSE)
                    {
                        hr = S_OK;
                        break;
                    }

                    // One contained fewer elements than the other
                    else if (hr == S_FALSE  ||  hr2 == S_FALSE)
                    {
                        hr = S_FALSE;
                        break;
                    }
                }
                pEnumOther->Release();
            }
            pEnumMe->Release();
        }
    }
    
    return hr;
}


STDMETHODIMP CCompositeMoniker::Hash (LPDWORD pdwHash)
{
    mnkDebugOut((DEB_ITRACE,
                 "CCompositeMoniker::Hash(%x)\n",this));

        M_PROLOG(this);
        VDATEPTROUT(pdwHash, DWORD);

		if(!m_pmkLeft || !m_pmkRight)
			return E_UNEXPECTED;

        DWORD dwHashLeft;
        DWORD dwHashRight;
        m_pmkLeft->Hash(&dwHashLeft);
        //      check for errors
        m_pmkRight->Hash(&dwHashRight);
        *pdwHash = dwHashLeft^dwHashRight;
        return NOERROR;
}



STDMETHODIMP CCompositeMoniker::IsRunning
        (LPBC pbc,
        LPMONIKER pmkToLeft,
        LPMONIKER pmkNewlyRunning)
{
    mnkDebugOut((DEB_ITRACE,
                 "CCompositeMoniker::IsRunning(%x)\n",this));

        VDATEIFACE(pbc);
        if (pmkToLeft) VDATEIFACE(pmkToLeft);
        if (pmkNewlyRunning) VDATEIFACE(pmkNewlyRunning);

        LPMONIKER pmkFirst = First();
        HRESULT hresult;
        LPMONIKER pmk = NULL;
        LPMONIKER pmkLast = NULL;
        LPRUNNINGOBJECTTABLE prot = NULL;

        CFileMoniker FAR * pCFM = IsFileMoniker(pmkFirst);
        if (pCFM)
        {
                CLSID clsid;
                if (pCFM->IsOle1Class(&clsid))
                {

                    hresult = DdeIsRunning(clsid, pCFM->m_szPath, pbc,
                                           pmkToLeft, pmkNewlyRunning);
                    goto errRet;
                }
        }

        if (pmkToLeft != NULL)
        {
                hresult = pmkToLeft->ComposeWith(this, FALSE, &pmk);
                if (hresult)
                    goto errRet;
                hresult = pmk->IsRunning(pbc, NULL, pmkNewlyRunning);
        }
        else if (pmkNewlyRunning != NULL)
        {
                hresult = pmkNewlyRunning->IsEqual(this);
        }
        else
        {
                hresult = pbc->GetRunningObjectTable(&prot);
                if (hresult != NOERROR)
                    goto errRet;
                hresult = prot->IsRunning(this);
                if (hresult == NOERROR)
                    goto errRet;
                pmk = AllButLast();
                pmkLast = Last();
                hresult = pmkLast->IsRunning(pbc, pmk, pmkNewlyRunning);
        }
errRet:
    if (pmk) pmk->Release();
    if (pmkLast) pmkLast->Release();
    if (prot) prot->Release();
    if (pmkFirst) pmkFirst->Release();

    return hresult;
}


STDMETHODIMP CCompositeMoniker::GetTimeOfLastChange (LPBC pbc, LPMONIKER pmkToLeft, FILETIME FAR* pfiletime)
{
    mnkDebugOut((DEB_ITRACE,
                 "CCompositeMoniker::GetTimeOfLastChange(%x)\n",this));

        M_PROLOG(this);
        VDATEIFACE(pbc);
        if (pmkToLeft) VDATEIFACE(pmkToLeft);
        VDATEPTROUT(pfiletime, FILETIME);

        HRESULT hresult;
        LPMONIKER pmkTemp = NULL;
        LPMONIKER pmkABL = NULL;
        LPMONIKER pmkL = NULL;
        LPRUNNINGOBJECTTABLE prot = NULL;

        if (pmkToLeft == NULL)
        {
                pmkTemp = this;
                AddRef();
        }
        else
        {
                hresult = CreateGenericComposite( pmkToLeft, this, &pmkTemp );
                if (hresult != NOERROR) goto errRet;
        }
        hresult = pbc->GetRunningObjectTable(& prot);
        if (hresult != NOERROR) goto errRet;
        hresult = prot->GetTimeOfLastChange( pmkTemp, pfiletime);
        if (hresult != MK_E_UNAVAILABLE) goto errRet;

        pmkTemp->Release(); pmkTemp = NULL;

        pmkABL = AllButLast();
        pmkL = Last();
        Assert(pmkABL != NULL);
        if (pmkToLeft == NULL)
        {
                pmkTemp = pmkABL;
                pmkABL->AddRef();
        }
        else
        {
                hresult = CreateGenericComposite(pmkToLeft, pmkABL, &pmkTemp);
                if (hresult != NOERROR) goto errRet;
        }
        hresult = pmkL->GetTimeOfLastChange(pbc, pmkTemp, pfiletime);
errRet:
        if (pmkTemp) pmkTemp->Release();
        if (pmkABL) pmkABL->Release();
        if (pmkL) pmkL->Release();
        if (prot) prot->Release();
        return hresult;
}


STDMETHODIMP CCompositeMoniker::Inverse (LPMONIKER FAR* ppmk)
{
    mnkDebugOut((DEB_ITRACE,
                 "CCompositeMoniker::Inverse(%x)\n",this));

        M_PROLOG(this);
        VDATEPTROUT(ppmk, LPMONIKER);
        *ppmk = NULL;

        HRESULT hresult;
        LPMONIKER pmkLeftInverse;
        LPMONIKER pmkRightInverse;

        hresult = m_pmkLeft->Inverse(&pmkLeftInverse);
        // AssertOutPtrIface(hresult, pmkLeftInverse);
        if (hresult != NOERROR) return hresult;
        hresult = m_pmkRight->Inverse(&pmkRightInverse);
        // AssertOutPtrIface(hresult, pmkRightInverse);
        if (hresult != NOERROR)
        {
                pmkLeftInverse->Release();
                return hresult;
        }
        hresult = CreateGenericComposite( pmkRightInverse, pmkLeftInverse, ppmk);
        pmkRightInverse->Release();
        pmkLeftInverse->Release();
        return hresult;
}


//+---------------------------------------------------------------------------
//
//  Method:     CCompositeMoniker::CommonPrefixWith
//
//  Synopsis:   This method determines the common prefix between this moniker
//              and the provided moniker
//
//  Effects:
//
//  Arguments:  [pmkOther] --   Moniker to determine common prefix with
//              [ppmkPrefix] -- Outputs moniker with common prefix
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:
//
//  History:    2-03-94   kevinro   Commented
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CCompositeMoniker::CommonPrefixWith (LPMONIKER pmkOther,
        LPMONIKER FAR* ppmkPrefix)
{
    mnkDebugOut((DEB_ITRACE,
                 "CCompositeMoniker::CommonPrefixWith(%x)\n",this));

    VDATEPTROUT(ppmkPrefix,LPMONIKER);
    VDATEIFACE(pmkOther);

    CCompositeMoniker FAR * pCCMOther;
    LPMONIKER pmkFirst = NULL;
    LPMONIKER pmkRest = NULL;
    LPMONIKER pmkOtherFirst = NULL;
    LPMONIKER pmkOtherRest = NULL;
    LPMONIKER pmkResult = NULL;
    LPMONIKER pmkResult2 = NULL;
    HRESULT hresult = E_UNEXPECTED;
    HRESULT hresult2;

    *ppmkPrefix = NULL;

    pmkFirst = First();

    if (pmkFirst == NULL)
    {
        goto errRet;
    }

    //
    // If the other moniker is also a composite, then we need to recurse
    // down both lists to find the common prefix
    //

    pCCMOther = IsCompositeMoniker(pmkOther);

    if (pCCMOther)
    {
        mnkDebugOut((DEB_ITRACE,
                     "::CommonPrefixWith C(%x) and C(%x)\n",
                     this,
                     pmkOther));

        //
        // For each element of the composite, get the common prefix
        //

        pmkOtherFirst = pCCMOther->First();

        if(pmkOtherFirst == NULL)
        {
            goto errRet;
        }

        //
        // We have both 'first' monikers from the composite.
        //
        hresult = pmkFirst->CommonPrefixWith(pmkOtherFirst, &pmkResult);

        if (FAILED(hresult))
        {
            goto errRet;
        }

        //
        // If the monikers are the same, then recurse to get the common
        // prefix of the rest.
        // It is possible that the rest won't be common, in which case we need
        // to return just pmkResult.
        //

        if (MK_S_US == hresult)
        {
            pmkOtherRest = pCCMOther->AllButFirst();

            if (pmkOtherRest == NULL)
            {
                goto errRet;
            }

            pmkRest = AllButFirst();

            if (pmkRest == NULL)
            {
                goto errRet;
            }

            hresult = pmkRest->CommonPrefixWith(pmkOtherRest, &pmkResult2);

            //
            // If hresult == MK_E_NOPREFIX, then pmkResult holds the entire
            // prefix. In this case, we need to convert the hresult into
            // another error code.
            //
            // If hresult == MK_S_US, MK_S_HIM, or MK_S_ME, then composing
            // to the end of pmkResult and returning hresult will do the
            // correct thing.
            //

            if (hresult == MK_E_NOPREFIX)
            {
                //
                // There was no additional prefix match, return the
                // current result
                //

                *ppmkPrefix = pmkResult;
                pmkResult->AddRef();

                hresult = NOERROR;

                goto errRet;

            } else if (FAILED(hresult))
            {
                goto errRet;
            }


            //
            // Since MK_E_NOPREFIX was not the return error, and
            // the call didn't fail, then the other moniker must have returned
            // a prefix. Compose it with the existing result
            //
            // If the compose succeeds, then return the existing hresult.
            // We are either going to return MK_S_HIM, MK_S_US, MK_S_ME, or
            // NOERROR (or some other error we don't know.
            //

            hresult2 = pmkResult->ComposeWith(pmkResult2, FALSE, ppmkPrefix);

            if (FAILED(hresult2))
            {
                //
                // Compose with failed. Convert hresult, which is the return
                // value, into hresult2
                //

                hresult = hresult2;
            }

            goto errRet;
        }
        else if ((hresult == MK_S_HIM) || (hresult == MK_S_ME))
        {
            //
            // The common prefix was either him or me, therefore the
            // proper thing to do is to return the result. However, we
            // need to change the hresult, since the result is a prefix
            // of one of the composites. (Try that 3 times fast)
            //
            *ppmkPrefix = pmkResult;

            pmkResult->AddRef();

            hresult = NOERROR;
        }
        goto errRet;
    }
    else
    {
        hresult = pmkFirst->CommonPrefixWith(pmkOther, ppmkPrefix);

        // if the first part of me is the common prefix, then the prefix
        // is a subpart of me since I am composite. The actual prefix is
        // NOT me, since only the first moniker was prefix

        if (MK_S_ME == hresult)
        {
            hresult = NOERROR;  
        }
        else if (hresult == MK_S_US)
        {
            //
            // If the First moniker returned MK_S_US, then the actual
            // return should be MK_S_HIM, since this composite has additional
            // parts that weren't considered by the call.
            //
            hresult = MK_S_HIM; 
        }
    }
errRet:
    if (pmkFirst) pmkFirst->Release();
    if (pmkRest) pmkRest->Release();
    if (pmkOtherFirst) pmkOtherFirst->Release();
    if (pmkOtherRest) pmkOtherRest->Release();
    if (pmkResult) pmkResult->Release();
    if (pmkResult2) pmkResult2->Release();
    return hresult;
}



HRESULT ComposeWithEnum( LPMONIKER pmkLeft, LPENUMMONIKER penum,
        LPMONIKER FAR * ppmkComposite )
{
    mnkDebugOut((DEB_ITRACE,
                 "CCompositeMoniker::ComposeWithEnum(pmkLeft=%x,penum=%x)\n",
                 pmkLeft,
                 penum));

        LPMONIKER pmk = NULL;
        LPMONIKER pmkTempLeft = pmkLeft;
        LPMONIKER pmkTempComp = NULL;
        HRESULT hresult;

        *ppmkComposite = NULL;
        pmkTempLeft->AddRef();
        while ((hresult = penum->Next(1, &pmk, NULL)) == NOERROR)
        {
                hresult = pmkTempLeft->ComposeWith(pmk, FALSE, &pmkTempComp);
                pmk->Release();
                pmkTempLeft->Release();
                pmkTempLeft=pmkTempComp;                // no need to release pmkTempComp
                if (hresult != NOERROR)  goto errRet;
        }
errRet:
        if (GetScode(hresult) == S_FALSE) hresult = NOERROR;
        if (hresult == NOERROR) *ppmkComposite = pmkTempLeft;
        else pmkTempLeft->Release();
        return hresult;
}



HRESULT InverseFromEnum( LPENUMMONIKER penum, LPMONIKER FAR * ppmkInverse)
{
    mnkDebugOut((DEB_ITRACE,
                 "CCompositeMoniker::InverseFromEnum(%x)\n",penum));

        LPMONIKER pmk = NULL;
        LPMONIKER pmkInverse = NULL;
        LPMONIKER pmkTailInverse = NULL;
        HRESULT hresult;

        *ppmkInverse = NULL;

        hresult = penum->Next(1, &pmk, NULL );
        if (hresult == NOERROR)
        {
                hresult = InverseFromEnum( penum, &pmkTailInverse);
                if (hresult != NOERROR)
                        goto errRet;
                hresult = pmk->Inverse(&pmkInverse);
                // AssertOutPtrIface(hresult, pmkInverse);
                if (hresult != NOERROR) goto errRet;
                if (pmkTailInverse)
                        hresult = pmkTailInverse->ComposeWith( pmkInverse, FALSE, ppmkInverse );
                else
                        *ppmkInverse = pmkInverse;
        }
errRet:
        if (GetScode(hresult) == S_FALSE) hresult = NOERROR;
        if (pmk) pmk->Release();
        if (pmkTailInverse) pmkTailInverse->Release();
        return hresult;
}

//+---------------------------------------------------------------------------
//
//  Method:     CCompositeMoniker::RelativePathTo
//
//  Synopsis:   Determines the relative path to pmkOther
//
//  Effects:
//
//  Arguments:  [pmkOther]    -- moniker to which to find relative path
//              [ppmkRelPath] -- placeholder for returned moniker
//
//  Requires:
//
//  Returns:    HRESULT
//
//  Derivation: IMoniker
//
//  Algorithm:  There are two major cases - B is or is not a composite moniker.
//
//              * * *
//
//              If both monikers are composite monikers, we compare their
//              component monikers.  Using the following notation for the
//              monikers A and B:
//
//              (a[0], a[1], a[2], ... a[m]) and (b[0], b[1], b[2], ... b[n])
//
//              We find the first pair (a[i], b[i]) such that a[i] != b[i].
//
//              Case 1:
//              If i == 0, then no component monikers match.
//                  Case 1A:
//                  If we can form a relative path between a[0] and b[0], we
//                   can construct a correct relative path between A and B by
//                   combining (in order):
//
//                   !(a[1], ... a[m]) - inverse of the remaining elements of A
//                                       (can be NULL)
//                   (!a[0], b[0])     - relative path between a[0] and b[0]
//                   (b[1], ... b[n])  - remaining elements of B
//
//                  Case 1B:
//                  Else there is no relative path and we just return B as the
//                   relative path and MK_S_HIM as the HRESULT
//
//              Case 2:
//              Else if (a[i] != NULL) && (b[i] != NULL) then both monikers
//               have leftover pieces.  We can construct a correct relative
//               path by combining (in order):
//
//                !(a[i+1], ... a[m]) - inverse of remaining elements of A
//                !a[i]
//                b[i]
//                (b[i+1], ... b[n])  - remaining elements of B
//
//              Case 3:
//              Else if (a[i] != NULL) && (b[i] == NULL) then B is a prefix
//               of A.  We can construct a correct relative path by combining:
//
//                !(a[i+1], ... a[m]) - inverse of remaining elements of A
//                !a[i]
//
//                Note that this is just the first two steps of the previous
//                case.
//
//              Case 4:
//              Else if (a[i] == NULL) && (b[i] != NULL) then A is a prefix
//               of B.  We can construct a correct relative path by combining:
//
//                b[i]
//                (b[i+1], ... b[n])  - remaining elements of B
//
//              Case 5:
//              Else if (a[i] == NULL) && (b[i] == NULL) then A == B.  We
//               return B as the relative moniker and MK_S_HIM as the HRESULT.
//
//              * * *
//
//              If B is not a composite moniker, we compare the first
//              component of A to B.  Using the following notation:
//
//              (a[0], a[1], a[2], ... a[m]) and B (not a composite)
//
//              Case 6:
//              If a[0] == B, then B is a prefix of A.  We can construct the
//               correct relative path as:
//
//                !(a[1], ... a[m]) - inverse of remaining elements of A
//
//              Case 7:
//              Else if we can form a relative path between a[0] and B, we
//               can construct a relative path between A and B by combining
//               (in order):
//
//                !(a[1], ... a[m]) - inverse of remaining elements of A
//                (!a[0], B)     - relative path between a[0] and B
//
//              Case 8:
//              Else there is no relative path between a[0] and B so we just
//               return B as the relative moniker and MK_S_HIM as the HRESULT
//
//  History:    2-03-94   kevinro   Commented
//              07/10/94  AlexT     Handle pmkOther == this case
//              10/21/94  AlexT     Rewrite, plug leaks, add Algorithm
//
//  Notes:      InverseFromEnum can return S_OK with an out moniker of NULL
//              (if there are no more elements to enumerate)
//
//----------------------------------------------------------------------------

STDMETHODIMP CCompositeMoniker::RelativePathTo (LPMONIKER pmkOther,
                                                LPMONIKER FAR* ppmkRelPath)
{
    mnkDebugOut((DEB_TRACE,
                 "%p _IN CCompositeMoniker::RelativePathTo (%p, %p)\n",
                 this, pmkOther, ppmkRelPath));
    VDATEPTROUT(ppmkRelPath,LPMONIKER);
    VDATEIFACE(pmkOther);

    *ppmkRelPath = NULL;

    LPENUMMONIKER pEnumThis;    //  Enumerator for this moniker's components
    HRESULT hr;
    hr = Enum(TRUE, &pEnumThis);

    if (NOERROR == hr)
    {
        LPMONIKER pmkThisElement;   //  Next element of this moniker

        hr = pEnumThis->Next(1, &pmkThisElement, NULL);
        Assert(NOERROR == hr && "Moniker enumeration failure");

        if (IsCompositeMoniker(pmkOther))
        {
            LPENUMMONIKER pEnumOther;   //  Enumerator for other moniker's
                                        //  components
            hr = pmkOther->Enum(TRUE, &pEnumOther);
            if (NOERROR == hr)
            {
                LPMONIKER pmkOtherElement;  //  Next element of other moniker
                BOOL fMatch = FALSE;        //  Did any components match?

                //  we now have enumerators for both this and pmkOther
                Assert(pEnumThis && pEnumOther && "Bad return values");

                hr = pEnumOther->Next(1, &pmkOtherElement, NULL);
                Assert(NOERROR == hr && "Moniker enumeration failure");

                //  find the first element pair that aren't equal
                do
                {
                    if (pmkThisElement->IsEqual(pmkOtherElement) != NOERROR)
                    {
                        //  moniker elements aren't equal
                        break;
                    }

                    fMatch = TRUE;  //  at least one element pair matched
                    pmkThisElement->Release();
                    pmkOtherElement->Release();

                    pEnumThis->Next(1, &pmkThisElement, NULL);
                    pEnumOther->Next(1, &pmkOtherElement, NULL);
                } while (pmkThisElement != NULL && pmkOtherElement != NULL);

                if (!fMatch)
                {
                    //  Case 1:  No component monikers matched
                    LPMONIKER pmkBetween;  // Relative path between this
                                           // element and other element

                    hr = pmkThisElement->RelativePathTo(pmkOtherElement,
                                                        &pmkBetween);
                    if (NOERROR == hr)
                    {
                        //  Case 1A:  There is a relative path from first
                        //  element of this to first element of pmkOther
                        LPMONIKER pmkInverse;  // Inverse of remaining elements
                                               // of this moniker
                        hr = InverseFromEnum(pEnumThis, &pmkInverse);

                        if (SUCCEEDED(hr))
                        {
                            if (NULL == pmkInverse)
                            {
                                //  There were no remaining elements
                                hr = ComposeWithEnum(pmkBetween, pEnumOther,
                                                     ppmkRelPath);
                            }
                            else
                            {
                                LPMONIKER pmkTemp;  //  Inverse + Between

                                //  + relative path from this element to
                                //  Other element
                                hr = pmkInverse->ComposeWith(pmkBetween,
                                                             FALSE,
                                                             &pmkTemp);
                                if (SUCCEEDED(hr))
                                {
                                    //  + remaining elements of Other
                                    hr = ComposeWithEnum(pmkTemp,
                                                         pEnumOther,
                                                         ppmkRelPath);
                                    pmkTemp->Release();
                                }
                                pmkInverse->Release();
                            }
                        }
                        pmkBetween->Release();
                    }
                    else if (MK_S_HIM == hr)
                    {
                        //  Case 1B:  There is no relative path between the
                        //  elements - return pmkOther and MK_S_HIM
                        pmkBetween->Release();

                        pmkOther->AddRef();
                        *ppmkRelPath = pmkOther;
                        Assert(MK_S_HIM == hr && "Bad logic");
                    }
                    else
                    {
                        //  error case;  nothing to do
                        Assert(FAILED(hr) && "Unexpected success!");
                    }
                }
                else if (pmkThisElement != NULL)
                {
                    //  Case 2 and 3:  Both monikers have remaining pieces or
                    //  pmkOther is a prefix of this
                    LPMONIKER pmkInverse;   //  Inverse of remaining elements
                                            //  of this moniker
                    hr = InverseFromEnum(pEnumThis, &pmkInverse);

                    if (SUCCEEDED(hr))
                    {
                        LPMONIKER pmkElementInverse;  // Inverse of current
                                                      // element of this
                        hr = pmkThisElement->Inverse(&pmkElementInverse);
                        if (SUCCEEDED(hr))
                        {
                            LPMONIKER pmkTemp;  // partial result

                            if (NULL == pmkInverse)
                            {
                                //  There were no remaining elements of this
                                //  moniker - we begin with the element inverse
                                pmkTemp = pmkElementInverse;
                            }
                            else
                            {
                                hr = pmkInverse->ComposeWith(
                                                        pmkElementInverse,
                                                        FALSE, &pmkTemp);
                                pmkElementInverse->Release();
                            }

                            if (NULL == pmkOtherElement)
                            {
                                //  Case 3:  pmkOther is a prefix of this
                                *ppmkRelPath = pmkTemp;
                            }
                            else if (SUCCEEDED(hr))
                            {
                                //  Case 2:  both monikers had remaining pieces
                                LPMONIKER pmkTemp2;  // partial result

                                //  + other element
                                hr = pmkTemp->ComposeWith(pmkOtherElement,
                                                          FALSE,
                                                          &pmkTemp2);
                                if (SUCCEEDED(hr))
                                {
                                    //  + remaining other elements
                                    hr = ComposeWithEnum(pmkTemp2, pEnumOther,
                                                         ppmkRelPath);

                                    pmkTemp2->Release();
                                }
                                pmkTemp->Release();
                            }
                        }

                        if (NULL != pmkInverse)
                        {
                            pmkInverse->Release();
                        }
                    }
                }
                else if (pmkOtherElement != NULL)
                {
                    //  Case 4:  this is a prefix of pmkOther
                    hr = ComposeWithEnum(pmkOtherElement, pEnumOther,
                                         ppmkRelPath);
                }
                else
                {
                    //  Case 5:  this and pmkOther are equal
                    pmkOther->AddRef();
                    *ppmkRelPath = pmkOther;
                    hr = MK_S_HIM;
                }

                if (NULL != pmkOtherElement)
                {
                    pmkOtherElement->Release();
                }
                pEnumOther->Release();
            }
        }
        else
        {
            //  pmkrOther is not a composite moniker
            hr = pmkThisElement->IsEqual(pmkOther);
            if (NOERROR == hr)
            {
                //  Case 6:  first element of this equals pmkOther;  pmkOther
                //  is a prefix of this

                hr = InverseFromEnum(pEnumThis, ppmkRelPath);
                if (SUCCEEDED(hr) && (NULL == *ppmkRelPath))
                {
                    //  There were no more elements to enumerate;  return
                    //  pmkOther as the relative path
                    pmkOther->AddRef();
                    *ppmkRelPath = pmkOther;
                    hr = MK_S_HIM;
                }
            }
            else
            {
                LPMONIKER pmkBetween;
                hr = pmkThisElement->RelativePathTo(pmkOther, &pmkBetween);
                if (NOERROR == hr)
                {
                    //  Case 7:  There is a relative path between first element
                    //  of this and pmkOther
                    LPMONIKER pmkInverse;   //  Inverse of remaining elements
                                            //  of this moniker
                    hr = InverseFromEnum(pEnumThis, &pmkInverse);
                    if (SUCCEEDED(hr))
                    {
                        if (NULL == pmkInverse)
                        {
                            *ppmkRelPath = pmkBetween;
                            pmkBetween = NULL;
                        }
                        else
                        {
                            hr = pmkInverse->ComposeWith(pmkBetween, FALSE,
                                                        ppmkRelPath);
                            pmkInverse->Release();
                        }
                    }
                }
                else if (MK_S_HIM == hr)
                {
                    //  Case 8:  There is no relative path between first
                    //  element of this and pmkOther (which is pmkBetween),
                    //  return pmkOther and MK_S_HIM
                    *ppmkRelPath = pmkBetween;
                    pmkBetween = NULL;
                    Assert(NOERROR == pmkOther->IsEqual(*ppmkRelPath) &&
                           "Bad logic");
                    Assert(MK_S_HIM == hr && "Bad logic");
                }
                else
                {
                    //  error case;  nothing to do
                    Assert(FAILED(hr) && "Unexpected success!");
                }

                if (NULL != pmkBetween)
                {
                    pmkBetween->Release();
                }
            }
        }

        if (NULL != pmkThisElement)
        {
            pmkThisElement->Release();
        }

        pEnumThis->Release();
    }

    mnkDebugOut((DEB_TRACE,
                 "%p OUT CCompositeMoniker::RelativePathTo(%lx) [%p]\n",
                 this, hr, *ppmkRelPath));
    return(hr);
}

STDMETHODIMP CCompositeMoniker::GetDisplayName (LPBC pbc,
        LPMONIKER pmkToLeft, LPWSTR FAR* lplpszDisplayName)
{
    mnkDebugOut((DEB_ITRACE,
                 "CCompositeMoniker::GetDisplayName(%x)\n",this));

        M_PROLOG(this);
        VDATEPTROUT(lplpszDisplayName, LPWSTR);
        *lplpszDisplayName = NULL;
        //REVIEW MM3 Find out who is calling this with pbc  == NULL and get them
        //      to stop it.
        VDATEIFACE(pbc);
        if (pmkToLeft) VDATEIFACE(pmkToLeft);

        LPWSTR lpszToLeft = NULL;
        LPWSTR lpszLeft = NULL;
        LPWSTR lpszRight = NULL;
        LPWSTR lpsz;
        HRESULT hresult;

        int n1, n2, n3;

        //      No error checking yet

        if (pmkToLeft)
        {
                hresult = pmkToLeft->GetDisplayName( pbc, NULL, &lpszToLeft );
                // AssertOutPtrParam(hresult, lpszToLeft);
                if (hresult != NOERROR)
                        goto errRtn;
        }
        hresult = m_pmkLeft->GetDisplayName(pbc, NULL, &lpszLeft);
        // AssertOutPtrParam(hresult, lpszLeft);
        if (hresult != NOERROR)
                goto errRtn;
        hresult = m_pmkRight->GetDisplayName(pbc, NULL, &lpszRight);
        // AssertOutPtrParam(hresult, lpszRight);
        if (hresult != NOERROR)
                goto errRtn;

        if (lpszToLeft) n1 = lstrlenW(lpszToLeft);
        else n1 = 0;
        n2 = lstrlenW(lpszLeft);
        n3 = lstrlenW(lpszRight);

        lpsz = (WCHAR *)
            CoTaskMemAlloc(sizeof(WCHAR) * (n1 + n2 + n3 + 1));

        if (lpsz == NULL)
        {
            hresult = E_OUTOFMEMORY;
            goto errRtn;
        }
        *lplpszDisplayName = lpsz;

        if (n1) _fmemmove( lpsz, lpszToLeft, n1 * sizeof(WCHAR));

        lpsz += n1;

        _fmemmove( lpsz, lpszLeft, n2 * sizeof(WCHAR));

        lpsz += n2;

        _fmemmove( lpsz, lpszRight, (n3 + 1)  * sizeof(WCHAR));

errRtn:

        CoTaskMemFree(lpszToLeft);
        CoTaskMemFree(lpszLeft);
        CoTaskMemFree(lpszRight);
        return hresult;
}


STDMETHODIMP CCompositeMoniker::ParseDisplayName (LPBC pbc, LPMONIKER pmkToLeft,
        LPWSTR lpszDisplayName, ULONG FAR* pchEaten, LPMONIKER FAR* ppmkOut)
{
    mnkDebugOut((DEB_ITRACE,
                 "CCompositeMoniker::ParseDisplayName(%x)\n",this));

        M_PROLOG(this);
        VDATEPTROUT(ppmkOut,LPMONIKER);
        *ppmkOut = NULL;
        VDATEIFACE(pbc);
        if (pmkToLeft) VDATEIFACE(pmkToLeft);
        VDATEPTRIN(lpszDisplayName, WCHAR);
        VDATEPTROUT(pchEaten,ULONG);

        HRESULT hresult = NOERROR;

        LPMONIKER pmkAllButLast = AllButLast();
        LPMONIKER pmkLast = Last();
        LPMONIKER pmkNewLeft = NULL ;

        Assert((pmkLast != NULL) && (pmkAllButLast != NULL));
        if (pmkToLeft) 
		{
			hresult = pmkToLeft->ComposeWith(pmkAllButLast, FALSE, &pmkNewLeft);

		    if(FAILED(hresult))
				goto ErrRtn;
		}        
        else
        {
                pmkNewLeft = pmkAllButLast;
                pmkNewLeft->AddRef();
        }

        hresult = pmkLast->ParseDisplayName(pbc, pmkNewLeft, lpszDisplayName,
                pchEaten, ppmkOut);
        // AssertOutPtrIface(hresult, *ppmkOut);

ErrRtn:
        pmkAllButLast->Release();
        pmkLast->Release();
        if (pmkNewLeft)
            pmkNewLeft->Release();

        return hresult;
}


STDMETHODIMP CCompositeMoniker::IsSystemMoniker (THIS_ LPDWORD pdwType)
{
    mnkDebugOut((DEB_ITRACE,
                 "CCompositeMoniker::IsSystemMoniker(%x)\n",this));

        M_PROLOG(this);
        VDATEPTROUT(pdwType,DWORD);

        *pdwType = MKSYS_GENERICCOMPOSITE;
        return NOERROR;
}




//+---------------------------------------------------------------------------
//
//  Method:     CCompositeMoniker::GetComparisonData
//
//  Synopsis:   Get comparison data for registration in the ROT
//
//  Arguments:  [pbData] - buffer to put the data in.
//              [cbMax] - size of the buffer
//              [pcbData] - count of bytes used in the buffer
//
//  Returns:    NOERROR
//              E_OUTOFMEMORY
//
//  Algorithm:  First verify buffer is big enough for the composite moniker
//              class id. Put that into the buffer. Then put the left part
//              into the buffer. Finally put the right part into the buffer.
//
//  History:    03-Feb-95   ricksa  Created
//
// Note:        Validating the arguments is skipped intentionally because this
//              will typically be called internally by OLE with valid buffers.
//
//----------------------------------------------------------------------------
STDMETHODIMP CCompositeMoniker::GetComparisonData(
    byte *pbData,
    ULONG cbMax,
    ULONG *pcbData)
{
    HRESULT hr = E_OUTOFMEMORY;
    ULONG cOrigMax = cbMax;
    ULONG cSizeHolder;

    do {

        // Can buffer hold the clsid?
        if (cbMax < sizeof(CLSID))
        {
            // No - so we are out of here;
            mnkDebugOut((DEB_ERROR,
                "CCompositeMoniker::GetComparisonData buffer not big enough"
                    " for CLSID\n"));
            break;
        }

        cbMax -= sizeof(CLSID);

        memcpy(pbData, &CLSID_CompositeMoniker, sizeof(CLSID));

        pbData += sizeof(CLSID);

        hr = BuildRotData(NULL, m_pmkLeft, pbData, cbMax, &cSizeHolder);

        if (FAILED(hr))
        {
            // No - so we are out of here;
            mnkDebugOut((DEB_ERROR,
                "CCompositeMoniker::GetComparisonData BuildRotData of left"
                    " failed %lx\n", hr));
            break;
        }

        cbMax -= cSizeHolder;
        pbData += cSizeHolder;

        hr = BuildRotData(NULL, m_pmkRight, pbData, cbMax, &cSizeHolder);

#if DBG == 1
        if (FAILED(hr))
        {
            mnkDebugOut((DEB_ERROR,
                "CCompositeMoniker::GetComparisonData BuildRotData of right"
                    " failed %lx\n", hr));
        }
#endif // DBG == 1

        cbMax -= cSizeHolder;

    } while(FALSE);

    *pcbData = (SUCCEEDED(hr)) ? cOrigMax - cbMax : 0;

    return hr;
}




/*
 *      Concatenate makes a composite moniker without ever calling
 *      ComposeWith on the individual pieces.
 */

STDAPI  Concatenate( LPMONIKER pmkFirst, LPMONIKER pmkRest,
        LPMONIKER FAR* ppmkComposite )
{
    mnkDebugOut((DEB_ITRACE,
                 "CCompositeMoniker::Concatentate(pmkFirst=%x,pmkRest%x)\n",
                 pmkFirst,
                 pmkRest));

        LPMONIKER pmkConcat = CCompositeMoniker::Create( pmkFirst, pmkRest);
        *ppmkComposite = pmkConcat;

        if (pmkConcat == NULL)
        {
            return ResultFromScode(S_OOM);      
        }
        //      Create did the AddRef

        return NOERROR;
}


//+---------------------------------------------------------------------------
//
//  Function:   CCompositeMonierCF_CreateInstance
//
//  Synopsis:   Creates a generic composite.
//
//+---------------------------------------------------------------------------
HRESULT CCompositeMonikerCF_CreateInstance(IUnknown *pUnkOuter, REFIID riid, void** ppv)
{
    Win4Assert(pUnkOuter == NULL);
    Win4Assert(*ppv == NULL);
    return Concatenate(NULL, NULL, (IMoniker **)ppv);
}

//+---------------------------------------------------------------------------
//
//  Function:   CreateGenericComposite
//
//  Synopsis:   Creates a generic composite from two other monikers
//
//  Effects:
//
//  Arguments:  [pmkFirst] --
//              [pmkRest] --
//              [ppmkComposite] --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    2-03-94   kevinro   Commented
//
//  Notes:
//
//----------------------------------------------------------------------------
STDAPI  CreateGenericComposite( LPMONIKER pmkFirst, LPMONIKER pmkRest,
        LPMONIKER FAR * ppmkComposite )
{
    OLETRACEIN((API_CreateGenericComposite, PARAMFMT("pmkFirst = %p, pmkRest= %p, ppmkComposite= %p"),
                        pmkFirst, pmkRest, ppmkComposite));
    mnkDebugOut((DEB_ITRACE,
                 "CCompositeMoniker::CreateGenericComposite(First=%x,Rest=%x)\n",
                 pmkFirst,
                 pmkRest));

    LPMONIKER pmkAllButFirstOfRest = NULL;
    LPMONIKER pmkFirstOfRest = NULL;
    LPMONIKER pmkAllButLastOfFirst = NULL;
    LPMONIKER pmkLastOfFirst = NULL;
    LPMONIKER pmk = NULL;
    LPMONIKER pmk2 = NULL;

    CCompositeMoniker *pCMk = NULL;
    CCompositeMoniker *pCMkRest = NULL;

    HRESULT hresult;

    CALLHOOKOBJECT(S_OK,CLSID_NULL,IID_IMoniker,(IUnknown **)&pmkFirst);
    CALLHOOKOBJECT(S_OK,CLSID_NULL,IID_IMoniker,(IUnknown **)&pmkRest);

    //
    // Initialize ppmkComposite. Might return in the middle of this
    // routine, so be sure its NULL in the error case
    //

    *ppmkComposite = NULL;


    //
    // If both pointers are NULL, return a NULL composite
    //
    if ((pmkFirst == NULL) && (pmkRest == NULL))
    {
        hresult = NOERROR;
        goto errRtn;
    }

    //
    // Otherwise, if one pointer is NULL, return the other as the
    // composite.
    //
    if (pmkFirst == NULL)
    {
        *ppmkComposite = pmkRest;
        pmkRest->AddRef();
        hresult = NOERROR;
        goto errRtn;
    }

    if (pmkRest == NULL)
    {
        *ppmkComposite = pmkFirst;
        pmkFirst->AddRef();
        hresult = NOERROR;
        goto errRtn;
    }


    //
    // Handle the two cases where pmkFirst is NOT a composite
    //

    pCMk = IsCompositeMoniker( pmkFirst );
    if (!pCMk)
    {
        //
        // If pmkRest is not a composite, then we have two
        // monikers that are considered 'simple' monikers.
        //

        pCMk = IsCompositeMoniker( pmkRest );
        if (!pCMk)
        {
            mnkDebugOut((DEB_ITRACE,
                         "::CreateGenericComposite( S(%x) o S(%x) )\n",
                         pmkFirst,
                         pmkRest));

            //  Case 1:  two simple monikers
        
            hresult = pmkFirst->ComposeWith(pmkRest, TRUE, ppmkComposite);
        
            if (hresult == MK_E_NEEDGENERIC)
            {
                Assert(*ppmkComposite == NULL);
                hresult = Concatenate(pmkFirst, pmkRest, ppmkComposite);
                goto errRtn;
            }
        }
        else
        {

            //
            //  Case 2:  S o C(b1, b2, b3).
            //
            //  Compose S with b1,
            //  then
            //  Compose ( S o b1 ) with C( b2, b3, ...)
            //
            //


            mnkDebugOut((DEB_ITRACE,
                         "::CreateGenericComposite( S(%x) o C(%x) )\n",
                         pmkFirst,
                         pmkRest));

            //
            // Since the right side is a composite, the following should
            // always exist. It would be a severe suprise if it didn't.
            //

            pmkFirstOfRest = pCMk->First();

            //
            // However, the AllButFirst function needs to allocate memory,
            // which might fail.
            //

            pmkAllButFirstOfRest = pCMk->AllButFirst();

            if (pmkAllButFirstOfRest == NULL)
            {
                hresult = E_OUTOFMEMORY;
                goto exitRet;
            }

            hresult = pmkFirst->ComposeWith(pmkFirstOfRest, TRUE, &pmk);                

            if ( hresult == MK_E_NEEDGENERIC)
            {
                Assert(pmk == NULL);
                hresult = Concatenate(pmkFirst, pmkRest, ppmkComposite);
            }
            else if (SUCCEEDED(hresult))
            {
                //
                // pmkFirst->ComposeWith can succeed, but return NULL.
                // If it doesn't return NULL, then ( a o b1 ) is a
                // moniker of some ilk. Create a generic composite with
                // this result, and the rest of the moniker
                //
                if (pmk != NULL)
                {
                    hresult = CreateGenericComposite(pmk,
                                                     pmkAllButFirstOfRest,
                                                     ppmkComposite);
                }
                else
                {
                    //
                    //  pmkFirst and pmkFirstOfRest annihilated each other.
                    //  This is indicated by a success code, and a pmk == NULL,
                    //  which is how we got here.
                    //

                    *ppmkComposite = pmkAllButFirstOfRest;

                    //
                    // pmkAllButFirstOfRest is the moniker we want to
                    // return.
                    //

                    pmkAllButFirstOfRest->AddRef();

                    hresult = NOERROR;
                }
            }
        }

        //
        // We are done, goto exit routine
        //
        goto exitRet;

    }

    //
    // We have determined that pmkFirst is a Composite Moniker
    //

    pmkAllButLastOfFirst = pCMk->AllButLast();

    if (pmkAllButLastOfFirst == NULL)
    {
        hresult = E_OUTOFMEMORY;
        goto exitRet;
    }

    pmkLastOfFirst = pCMk->Last();

    if (pmkLastOfFirst == NULL)
    {
        hresult = E_OUTOFMEMORY;
        goto exitRet;
    }

    //
    // Determine if pmkRest is a composite. If not, then just
    // compose the last of pmkFirst with pmkRest
    //

    pCMkRest = IsCompositeMoniker(pmkRest);
    if (!pCMkRest)
    {
        //      case 3:  (a1 a2 a3...) o b

        mnkDebugOut((DEB_ITRACE,
                    "::CreateGenericComposite( C(%x) o S(%x) )\n",
                    pmkFirst,
                    pmkRest));

        hresult = pmkLastOfFirst->ComposeWith(pmkRest, TRUE, &pmk);

        if (MK_E_NEEDGENERIC == GetScode(hresult))
        {
            Assert(pmk==NULL);
            hresult = Concatenate(pmkFirst, pmkRest, ppmkComposite);
        }
        else if (SUCCEEDED(hresult))
        {
            //
            // If pmk != NULL, create a generic composite out of
            // of the results
            if (pmk != NULL)
            {
                hresult = CreateGenericComposite(pmkAllButLastOfFirst,
                                                 pmk,
                                                 ppmkComposite);                
            }
            else
            {
                //
                // a3 o b resulted in NULL. Therefore, the result
                // of the composition is pmkAllButLastOfFirst
                //
                *ppmkComposite = pmkAllButLastOfFirst;
                pmkAllButLastOfFirst->AddRef();
                hresult = NOERROR;
            }
        }

        goto exitRet;
    }

    //
    //  case 4:  (a1 a2 ... aN) o (b1 b2 .. bN )
    //
    //  Compose two composite monikers. In order to compose them, we need
    //  to compose ( A ) with b1, then recurse to do ( A b1 ) with b2, etc
    //
    //
    mnkDebugOut((DEB_ITRACE,
                 "::CreateGenericComposite( C(%x) o C(%x) )\n",
                 pmkFirst,
                 pmkRest));

    pmkFirstOfRest = pCMkRest->First();

    if (pmkFirstOfRest == NULL)
    {
        hresult = E_OUTOFMEMORY;
        goto exitRet;
        
    }

    pmkAllButFirstOfRest = pCMkRest->AllButFirst();

    if (pmkAllButFirstOfRest == NULL)
    {
        hresult = E_OUTOFMEMORY;
        goto exitRet;
    }

    hresult = pmkLastOfFirst->ComposeWith(pmkFirstOfRest, TRUE, &pmk);

    if (hresult == MK_E_NEEDGENERIC)
    {
        //
        // In this case, aN didn't know how to compose with b1, other than
        // to do it generically. The best we can do is to generically
        // compose the two halves.
        //

        Assert(pmk == NULL);

        hresult = Concatenate(pmkFirst, pmkRest, ppmkComposite);
    }
    else if (SUCCEEDED(hresult))
    {
        //
        // If pmk is not NULL, then there was a result of the composition.
        // Create a new composite with the first part, then compose it with
        // whats left of the second part.
        //
        if (pmk != NULL)
        {
            hresult = CreateGenericComposite(pmkAllButLastOfFirst, pmk, &pmk2);

            if (FAILED(hresult))
            {
                goto exitRet;
            }

            hresult = CreateGenericComposite(pmk2, pmkAllButFirstOfRest, ppmkComposite);
        }
        else
        {
            //
            //  pmkLastOfFirst annihilated pmkFirstOfRest
            //
            //  Thats OK. Compose the remaining parts.
            //
            hresult = CreateGenericComposite(pmkAllButLastOfFirst,
                                             pmkAllButFirstOfRest,
                                             ppmkComposite);
        }
    }

exitRet:

    if (pmkFirstOfRest) pmkFirstOfRest->Release();
    if (pmkAllButFirstOfRest) pmkAllButFirstOfRest->Release();
    if (pmkAllButLastOfFirst) pmkAllButLastOfFirst->Release();
    if (pmkLastOfFirst) pmkLastOfFirst->Release();
    if (pmk) pmk->Release();
    if (pmk2) pmk2->Release();

    CALLHOOKOBJECTCREATE(hresult, CLSID_CompositeMoniker, IID_IMoniker, (IUnknown **)ppmkComposite);

errRtn:
    OLETRACEOUT((API_CreateGenericComposite, hresult));

    return hresult;
}



//------------------------------------------------


//      Implementation of CCompositeMonikerEnum

CCompositeMonikerEnum::CCompositeMonikerEnum( BOOL fForward,
        CCompositeMoniker FAR* pCM)
{
        GET_A5();
        Assert(pCM != NULL);
        m_refs = 0;
        m_pCM = pCM;
        pCM -> AddRef();
        m_fForward = fForward;
        m_pBase = NULL;
        m_pTop = NULL;
        m_pNext = GetNext(pCM); //      m_pNext points to the next moniker to return
}



CCompositeMonikerEnum::~CCompositeMonikerEnum(void)
{
        M_PROLOG(this);
        se FAR* pse;
        se FAR* pse2;
        if (m_pCM)
                m_pCM->Release();
        for (pse = m_pBase; pse != NULL; pse = pse2)
        {
                pse2 = pse->m_pseNext;
                pse->m_pseNext = NULL; // workaround for compiler optimization bug
                delete pse;
        }
}


BOOL CCompositeMonikerEnum::Push( CCompositeMoniker FAR* pCM)
//      push the composite moniker onto our stack
{
    M_PROLOG(this);
    se FAR * pse;

    pse = new se(pCM);
    if (pse == NULL)
    {
        return FALSE;
    }
    pse->m_psePrev = m_pTop;
    if (m_pTop) m_pTop->m_pseNext = pse;
    m_pTop = pse;
    if (m_pBase == NULL) m_pBase = pse;
    return TRUE;
}


LPMONIKER CCompositeMonikerEnum::GetNext( LPMONIKER pmk )
{
    M_PROLOG(this);
    LPMONIKER pmkRover = pmk;
    Assert(pmk != NULL);
    if (pmk == NULL) return NULL;

    CCompositeMoniker *pCMk; ;
    while ((pCMk = IsCompositeMoniker(pmkRover)) != NULL)
    {
        if (!Push(pCMk))
        {
            return NULL;
        }
        pmkRover = (m_fForward ? pCMk->m_pmkLeft : pCMk->m_pmkRight);
    }
    return pmkRover;
}


LPMONIKER CCompositeMonikerEnum::Pop( void )
{
        M_PROLOG(this);
        CCompositeMoniker FAR* pCM;
        se FAR * pse;

        if (m_pTop == NULL) return NULL;
        pCM = m_pTop->m_pCM;
        if ((pse = m_pTop->m_psePrev) != NULL)
        {
                pse->m_pseNext = NULL;
        }
        else m_pBase = NULL;
        delete m_pTop;
        m_pTop = pse;
        Assert(pCM->m_pmkRight != NULL);
        Assert(pCM->m_pmkLeft != NULL);
        return GetNext(m_fForward ? pCM->m_pmkRight : pCM->m_pmkLeft);
}


STDMETHODIMP CCompositeMonikerEnum::QueryInterface (THIS_ REFIID riid, LPVOID FAR* ppvObj)
{
        M_PROLOG(this);
        VDATEPTROUT(ppvObj, LPVOID);
        *ppvObj = NULL;
        VDATEIID(riid);

        if (IsEqualIID(riid, IID_IEnumMoniker)
            || IsEqualIID(riid, IID_IUnknown))
        {
                *ppvObj = this;
                AddRef();
                return NOERROR;
        }
        *ppvObj = NULL;
        return ResultFromScode(E_NOINTERFACE);
}




STDMETHODIMP_(ULONG) CCompositeMonikerEnum::AddRef (THIS)
{
        M_PROLOG(this);
        InterlockedIncrement((long *)&m_refs);
        return m_refs;
}



STDMETHODIMP_(ULONG) CCompositeMonikerEnum::Release (THIS)
{
    M_PROLOG(this);
    Assert(m_refs != 0);

    ULONG ul = m_refs;

    if (InterlockedDecrement((long *)&m_refs) == 0)
    {
        delete this;
        return 0;
    }
    return ul - 1;
}



STDMETHODIMP CCompositeMonikerEnum::Next (THIS_ ULONG celt, LPMONIKER FAR* reelt, ULONG FAR* pceltFetched)
{
        A5_PROLOG(this);
        VDATEPTROUT(reelt, LPMONIKER);
        *reelt = NULL;
        if (pceltFetched) VDATEPTROUT(pceltFetched, ULONG);

        ULONG count = 0;
        while (count < celt)
        {
                if (m_pNext)
                {
                        *reelt = m_pNext;
                        m_pNext->AddRef();
                        count++;
                        reelt++;
                        m_pNext = Pop();
                }
                else goto ret;
        }
ret:
        if (pceltFetched) *pceltFetched = count;
        if (count == celt){
                RESTORE_A5();
                return NOERROR;
        }
        RESTORE_A5();
        return ResultFromScode(S_FALSE);
}



STDMETHODIMP CCompositeMonikerEnum::Skip (THIS_ ULONG celt)
{
        M_PROLOG(this);
        ULONG count = 0;
        while (count < celt)
        {
                if (m_pNext)
                {
                        count++;
                        m_pNext = Pop();
                }
                else return ResultFromScode(S_FALSE);
        }
        return NOERROR;
}



STDMETHODIMP CCompositeMonikerEnum::Reset (THIS)
{
        M_PROLOG(this);
        se FAR* pse;
        se FAR* pse2;
        for (pse=m_pBase; pse != NULL; pse = pse2)
        {
                pse2 = pse->m_pseNext;
                pse->m_pseNext = NULL; // workaround for compiler optimization bug
                delete pse;
        }
        m_pBase = NULL;
        m_pTop = NULL;
        m_pNext = GetNext(m_pCM);
        if (m_pNext) return NOERROR;
        return ResultFromScode(S_FALSE);
}



STDMETHODIMP CCompositeMonikerEnum::Clone (THIS_ LPENUMMONIKER FAR* ppenm)
{
        M_PROLOG(this);
        VDATEPTROUT(ppenm, LPENUMMONIKER);
        *ppenm = NULL;

        CairoleAssert(FALSE && "Clone not implemented for composite moniker enums");
        return ResultFromScode(E_NOTIMPL);      //      Clone not implemented for composite moniker enums
}


LPENUMMONIKER CCompositeMonikerEnum::Create
        (BOOL fForward, CCompositeMoniker FAR* pCM)
{
    CCompositeMonikerEnum FAR* pCME =
        new CCompositeMonikerEnum(fForward, pCM);
    if (pCME  &&  pCME->m_pNext)
    {
        pCME->AddRef();
        return pCME;
    }
    else
    {
        delete pCME;
        return NULL;
    }
}



STDAPI  MonikerCommonPrefixWith( LPMONIKER pmkThis, LPMONIKER pmkOther,
    LPMONIKER FAR * ppmkPrefix)
{
    OLETRACEIN((API_MonikerCommonPrefixWith, PARAMFMT("pmkThis= %p, pmkOther= %p, ppmkPrefix= %p"),
                pmkThis, pmkOther, ppmkPrefix));

    mnkDebugOut((DEB_ITRACE,
                 "CCompositeMoniker::CommonPrefixWith(pmkThis=%x,pmkOther=%x)\n",
                 pmkThis,
                 pmkOther));

    HRESULT hresult;

    CALLHOOKOBJECT(S_OK,CLSID_NULL,IID_IMoniker,(IUnknown **)&pmkThis);
    CALLHOOKOBJECT(S_OK,CLSID_NULL,IID_IMoniker,(IUnknown **)&pmkOther);

    if (IsCompositeMoniker(pmkThis))
    {
        hresult = pmkThis->CommonPrefixWith(pmkOther, ppmkPrefix);
                // AssertOutPtrIface(hresult, *ppmkPrefix);
        goto errRtn;
    }

    if (IsCompositeMoniker(pmkOther))
    {
        hresult = pmkOther->CommonPrefixWith(pmkThis, ppmkPrefix);
                // AssertOutPtrIface(hresult, *ppmkPrefix);
        if (MK_S_HIM == GetScode(hresult))
            hresult = ResultFromScode(MK_S_ME);
        else if (MK_S_ME == GetScode(hresult))
            hresult = ResultFromScode(MK_S_HIM);
        goto errRtn;
    }
    //  This doesn't get called unless the monikers are atomic and unrelated
    *ppmkPrefix = NULL;

    hresult = ResultFromScode(MK_E_NOPREFIX);

errRtn:    
   OLETRACEOUT((API_MonikerCommonPrefixWith, hresult));

   return hresult;
}



STDAPI  MonikerRelativePathTo(LPMONIKER pmkSrc, LPMONIKER pmkDest, LPMONIKER
                                FAR* ppmkRelPath, BOOL dwReserved)
{
    //  An implementation of RelativePathTo should check to see if the
    //  other moniker is a type that it recognizes and handles specially.
    //  If not, it should call MonikerRelativePathTo, which will handle
    //  the generic composite cases correctly.  Note that this cannot be
    //  done entirely in the CCompositeMoniker implementation because if the
    //  first moniker is not a generic composite and the second is, then
    //  this code is required.

    //  CODEWORK:  This comment is obsolete.  fCalledFromMethod has changed
    //  to dwReserved wich must always be TRUE
    //
    //  If fCalledFromMethod is false, and if neither moniker is a generic
    //  composite, then this function will call pmkSrc->RelativePathTo.  If
    //  fCalledFromMethod is true, it will not call pmkSrc->RelativePathTo,
    //  since the assumption is that pmkSrc->RelativePathTo has called
    //  MonikerRelativePathTo after determining that pmkDest is not of a type
    //  that it recognizes.
    
    OLETRACEIN((API_MonikerRelativePathTo, 
                PARAMFMT("pmkSrc= %p, pmkDest= %p, ppmkRelPath= %p, dwReserved= %B"),
                pmkSrc, pmkDest, ppmkRelPath, dwReserved));

    mnkDebugOut((DEB_ITRACE,
                 "CCompositeMoniker::MonikerRelativePathTo(pmkSrc=%x,pmkDest=%x)\n",
                 pmkSrc,
                 pmkDest));
    
    HRESULT hresult;
    int caseId = 0;
    LPMONIKER pmkFirst = NULL;
    LPMONIKER pmkRest = NULL;
    LPMONIKER pmkPartialRelPath = NULL;
    CCompositeMoniker FAR* pccmDest;

    //  Check the reserved parameter, which must be TRUE
    if (dwReserved != TRUE)
    {
        *ppmkRelPath = NULL;
        hresult = E_INVALIDARG;
        goto errRtn;
    }
    
    CALLHOOKOBJECT(S_OK,CLSID_NULL,IID_IMoniker,(IUnknown **)&pmkSrc);
    CALLHOOKOBJECT(S_OK,CLSID_NULL,IID_IMoniker,(IUnknown **)&pmkDest);
    
    VDATEPTROUT_LABEL(ppmkRelPath,LPMONIKER, errRtn, hresult);
    *ppmkRelPath = NULL;
    VDATEIFACE_LABEL(pmkSrc, errRtn, hresult);
    VDATEIFACE_LABEL(pmkDest, errRtn, hresult);
    
    
    
    pccmDest = IsCompositeMoniker(pmkDest);
    
    if (IsCompositeMoniker(pmkSrc)) caseId++;
    if (pccmDest) caseId += 2;
    
    switch (caseId)
    {
    case 0:     //      neither moniker is composite
        if (dwReserved)
        {
            *ppmkRelPath = pmkDest;
            pmkDest->AddRef();
            hresult = ResultFromScode(MK_S_HIM);
            goto errRtn;
        }
        // fall-through to the next case if !dwReserved is
        // deliberate
    case 3:
    case 1:     // Src is composite, other might be.  Let CCompositeMoniker
        // implementation handle it.
        hresult = pmkSrc->RelativePathTo(pmkDest, ppmkRelPath);
        // AssertOutPtrIface(hresult, *ppmkRelPath);
        goto errRtn;
        
    case 2:     // Src is not composite, Dest is.
        pmkFirst = pccmDest->First();
        pmkRest = pccmDest->AllButFirst();
        if (NOERROR == pmkSrc->IsEqual(pmkFirst))
        {
            *ppmkRelPath = pmkRest;
            pmkRest->AddRef();
            hresult = NOERROR;
        }
        else
        {
            hresult = pmkSrc->RelativePathTo(pmkFirst, &pmkPartialRelPath);
            // AssertOutPtrIface(hresult, pmkPartialRelPath);
            if (NOERROR == hresult)
            {
                hresult = CreateGenericComposite(pmkPartialRelPath, pmkRest,
                                                 ppmkRelPath);
            }
            else
            {
                *ppmkRelPath = pmkDest;
                pmkDest->AddRef();
                hresult = ResultFromScode(MK_S_HIM);
            }
        }
        
        if (pmkFirst) pmkFirst->Release();
        if (pmkRest) pmkRest->Release();
        if (pmkPartialRelPath) pmkPartialRelPath->Release();
        break;

    default:
        Win4Assert (!"Should never reach here");
        hresult = E_UNEXPECTED;
    }
    
errRtn:
    OLETRACEOUT((API_MonikerRelativePathTo, hresult));

    return hresult;
}


//+-------------------------------------------------------------------------
//
//  Class:      CTrackingCompositeMoniker
//
//  Purpose:    Provide implementation of ITrackingMoniker for composite
//              monikers.
//
//  Notes:      This object responds to ITrackingMoniker and forwards other
//              QI's to the composite moniker.
//
//              EnableTracking currently only enables tracking on the moniker to
//              left.  When we expose this functionality, we will need to
//              try QI to ITrackingMoniker on the right moniker and pass the
//              moniker to left (as all other moniker fns do.)
//
//--------------------------------------------------------------------------


#ifdef _TRACKLINK_
VOID
CTrackingCompositeMoniker::SetParent(CCompositeMoniker *pCCM)
{
    _pCCM = pCCM;
}

STDMETHODIMP CTrackingCompositeMoniker::QueryInterface(REFIID riid, void **ppv)
{
    if (IsEqualIID(IID_ITrackingMoniker, riid))
    {
        *ppv = (ITrackingMoniker*) this;
        _pCCM->AddRef();
        return(S_OK);
    }
    else
        return(_pCCM->QueryInterface(riid, ppv));
}

STDMETHODIMP_(ULONG) CTrackingCompositeMoniker::AddRef()
{
    return(_pCCM->AddRef());
}

STDMETHODIMP_(ULONG) CTrackingCompositeMoniker::Release()
{
    return(_pCCM->Release());
}

STDMETHODIMP CTrackingCompositeMoniker::EnableTracking( IMoniker *pmkToLeft, ULONG ulFlags )
{
    ITrackingMoniker *ptm=NULL;
    HRESULT hr;

    hr = _pCCM->m_pmkLeft->QueryInterface(IID_ITrackingMoniker, (void**) &ptm);
    if (hr == S_OK)
    {
        hr = ptm->EnableTracking(NULL, ulFlags);

        if (hr == S_OK)
        {
            if (ulFlags & OT_ENABLEREDUCE)
            {
                _pCCM->m_fReduceForced = TRUE;
            }
    
            if (ulFlags & OT_DISABLEREDUCE)
            {
                _pCCM->m_fReduceForced = FALSE;
            }
        }

        ptm->Release();
    }
    return(hr);
}
#endif





#ifdef _DEBUG

STDMETHODIMP_(void) NC(CCompositeMoniker,CDebug)::Dump( IDebugStream FAR * pdbstm)
{
        VOID_VDATEIFACE(pdbstm);

        *pdbstm << "CCompositeMoniker @" << (VOID FAR *)m_pCompositeMoniker;
        *pdbstm << '\n';
        pdbstm->Indent();
        *pdbstm << "Refcount is " << (int)(m_pCompositeMoniker->m_refs) << '\n';
        pdbstm->Indent();

        *pdbstm << m_pCompositeMoniker->m_pmkLeft;
        *pdbstm << m_pCompositeMoniker->m_pmkRight;

        pdbstm->UnIndent();
        pdbstm->UnIndent();
}

STDMETHODIMP_(BOOL) NC(CCompositeMoniker,CDebug)::IsValid( BOOL fSuspicious )
{
        return ((LONG)(m_pCompositeMoniker->m_refs) > 0);
        //      add more later, maybe
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\com\moniker2\cdialog.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1994.
//
//  File:       dialog.cxx
//
//  Contents:
//
//  Classes:    CHlprDialog
//
//  Functions:  DialogProc
//
//  History:    4-12-94   stevebl   Created
//
//----------------------------------------------------------------------------

#include <ole2int.h>
#include "cdialog.h"

//+---------------------------------------------------------------------------
//
//  Member:     CHlprDialog::ShowDialog
//
//  Synopsis:   Creates a MODAL dialog so that its DialogProc member
//              function can be invoked.
//
//  Arguments:  [hinst]        - handle of the application instance
//              [lpszTemplate] - identifies the dialog box template
//              [hwndOwner]    - handle of the owner window
//
//  Returns:    return value from the dialog box
//
//  History:    4-12-94   stevebl   Created
//
//  Notes:      The dialog box object exists until deleted by the caller.
//              It can be shown any number of times.
//
//              This function is analgous to Windows' DialogBox function.  The
//              main difference being that you don't specify a DialogProc;
//              you override the pure virtal function CHlprDialog::DialogProc.
//
//----------------------------------------------------------------------------

INT_PTR CHlprDialog::ShowDialog(HINSTANCE hinst, LPCTSTR lpszTemplate, HWND hwndOwner)
{
    m_hInstance = hinst;
    return(DialogBoxParam(hinst, lpszTemplate, hwndOwner, ::DialogProc, (LPARAM)this));
}

//+--------------------------------------------------------------------------
//
//  Member:     CHlprDialog::CreateDlg
//
//  Synopsis:   Creates the dialog so that its DialogProc member function
//              can be invoked.
//
//  Arguments:  [hinst]        - handle of the application instance
//              [lpszTemplate] - identifies the dialog box template
//              [hwndOwner]    - handle of the owner window
//
//  Returns:    handle to the dialog box
//
//  History:    7-02-1997   stevebl   Created
//
//  Notes:      The dialog box object exists until deleted by the caller.
//              It can be shown any number of times.
//
//              This function is analgous to Windows' CreateDialog function.
//              The main difference being that you don't specify a
//              DialogProc; you override the pure virtal function
//              CHlprDialog::DialogProc.
//
//              This is an alternate method of initializing the dialog box
//              and should not be used if ShowDialog is used.
//
//---------------------------------------------------------------------------

HWND CHlprDialog::CreateDlg(HINSTANCE hinst, LPCTSTR lpszTemplate, HWND hwndOwner)
{
    m_hInstance = hinst;
    return(CreateDialogParam(hinst, lpszTemplate, hwndOwner, ::DialogProc, (LPARAM)this));
}

//+---------------------------------------------------------------------------
//
//  Function:   DialogProc
//
//  Synopsis:   Common DialogProc used by all CHlprDialog class objects.
//
//  Arguments:  [hwndDlg] - handle of dialog box
//              [uMsg]    - message
//              [wParam]  - first message parameter
//              [lParam]  - second message parameter
//
//  Returns:    response from the CHlprDialog::DialogProc method
//
//  History:    4-12-94   stevebl   Created
//
//  Notes:      This procedure is the DialogProc registered for all dialogs
//              created with the CHlprDialog class.  It uses the parameter
//              passed with the WM_INITDIALOG message to identify the dialog
//              classes' "this" pointer which it then stores in the window
//              structure's GWL_USERDATA field.  All subsequent messages
//              can then be forwarded on to the correct dialog class's
//              DialogProc method by using the pointer stored in the
//              GWL_USERDATA field.
//
//----------------------------------------------------------------------------

INT_PTR CALLBACK DialogProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    CHlprDialog * pdlg;
    switch (uMsg)
    {
    case WM_INITDIALOG:
        // This message is how we identify the dialog object.

        // get a pointer to the window class object
        pdlg = (CHlprDialog *) lParam;
        // set its USERDATA word to point to the class object
        SetWindowLongPtr(hwndDlg, GWLP_USERDATA, (LONG_PTR) pdlg);
        break;
    default:
        // get a pointer to the window class object
        pdlg = (CHlprDialog *) GetWindowLongPtr(hwndDlg, GWLP_USERDATA);
        break;
    }
    // and call its message proc method
    if (pdlg != (CHlprDialog *) 0)
    {
        return(pdlg->DialogProc(hwndDlg, uMsg, wParam, lParam));
    }
    else
    {
        return(FALSE);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\com\moniker2\cdialog.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1994.
//
//  File:       cdialog.h
//
//  Contents:   definition for common dialog functionality
//
//  Classes:    CHlprDialog (pure virtual class)
//
//  Functions:  DialogProc
//
//  History:    4-12-94   stevebl   Created
//
//----------------------------------------------------------------------------

#ifndef __CDIALOG_H__
#define __CDIALOG_H__

#ifdef __cplusplus
extern "C" {
#endif

INT_PTR CALLBACK DialogProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);

#ifdef __cplusplus
}

//+---------------------------------------------------------------------------
//
//  Class:      CHlprDialog
//
//  Purpose:    virtual base class for wrapping Windows' dialog functionality
//
//  Interface:  ShowDialog -- analagous to the Windows DialogBox function
//              DialogProc -- pure virtual DialogProc for the dialog box
//              ~CHlprDialog   -- destructor
//
//  History:    4-12-94   stevebl   Created
//              7-02-1997   stevebl   added CreateDlg
//
//  Notes:      This class allows a dialog box to be cleanly wrapped in
//              a c++ class.  Specifically, it provides a way for a c++ class
//              to use one of its methods as a DialogProc, giving it a "this"
//              pointer and allowing it to have direct access to all of its
//              private members.
//
//----------------------------------------------------------------------------

class CHlprDialog
{
public:
    virtual INT_PTR ShowDialog(HINSTANCE hinst, LPCTSTR lpszTemplate, HWND hwndOwner);
    virtual HWND    CreateDlg(HINSTANCE hinst, LPCTSTR lpszTemplate, HWND hwndOwner);
    virtual INT_PTR DialogProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam) = 0;
    virtual ~CHlprDialog(){};
protected:
    HINSTANCE m_hInstance;
};

#endif //__cplusplus

#endif //__CDIALOG_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\com\moniker2\cfilemon.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1993 - 1993.
//
//  File:       cfilemon.cxx
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    12-27-93   ErikGav   Commented
//                      01-04-94   KevinRo   Serious modifications
//                                                   UNC paths are used directly
//                                                   Added UNICODE extents
//              03-18-94   BruceMa   #5345 Fixed Matches to parse
//                                    offset correctly
//              03-18-94   BruceMa   #5346 Fixed error return on invalid CLSID
//                                    string
//              05-10-94   KevinRo   Added Long Filename/8.3 support so
//                                                   downlevel guys can see new files
//                      06-14-94   Rickhi    Fix type casting
//              22-Feb-95  BruceMa   Account for OEM vs. ANSI code pages
//              01-15-95   BillMo    Add tracking on x86 Windows.
//              19-Sep-95  BruceMa   Change ::ParseDisplayName to try the
//                                    object first and then the class
//              10-13-95   stevebl   threadsafety
//              10-20-95   MikeHill  Updated to support new CreateFileMonikerEx API.
//              11-15-95   MikeHill  Use BIND_OPTS2 when Resolving a ShellLink object.
//              11-22-95   MikeHill  - In ResolveShellLink, always check for a null path
//                                     returned from IShellLink::Resolve.
//                                   - Also changed m_fPathSetInShellLink to
//                                     m_fShellLinkInitialized.
//                                   - In RestoreShellLink & SetPathShellLink,
//                                     only early-exit if m_fShellLinkInitialized.
//              12-01-95   MikeHill  - Validate bind_opts2.dwTrackFlags before using it.
//                                   - For Cairo, do an unconditional ResolveShellLink
//                                     for BindToObject/Storage
//                                   - Don't do a Resolve in GetTimeOfLastChange.
//
//----------------------------------------------------------------------------

#include <ole2int.h>

#include "cbasemon.hxx"
#include "extents.hxx"
#include "cfilemon.hxx"
#include "ccompmon.hxx"
#include "cantimon.hxx"
#include "mnk.h"
#include <olepfn.hxx>
#include <rotdata.hxx>

#ifdef _TRACKLINK_
#include <itrkmnk.hxx>
#endif

#define LPSTGSECURITY LPSECURITY_ATTRIBUTES
#include "..\..\..\stg\h\dfentry.hxx"


DECLARE_INFOLEVEL(mnk)

//
// The following value is used to determine the average string size for use
// in optimizations, such as copying strings to the stack.
//

#define AVERAGE_STR_SIZE (MAX_PATH)

//
// Determine an upper limit on the length of a path. This is a sanity check
// so that we don't end up reading in megabyte long paths. The 16 bit code
// used to use INT_MAX, which is 32767. That is reasonable, plus old code
// will still work.
//

#define MAX_MBS_PATH (32767)

// function prototype

// Special function from ROT
HRESULT GetObjectFromLocalRot(
    IMoniker *pmk,
    IUnknown **ppvUnk);

//+---------------------------------------------------------------------------
//
//  Function:   ReadAnsiStringStream
//
//  Synopsis:   Reads a counted ANSI string from the stream.
//
//  Effects:    Old monikers store paths in ANSI characters. This routine
//              reads ANSI strings.
//
//
//  Arguments:  [pStm] --    Stream to read from
//              [pszAnsiPath] -- Reference to the path variable.
//              [cbAnsiPath] -- Reference to number of bytes read
//
//  Requires:
//
//  Returns:
//              pszAnsiPath was allocated using PrivMemAlloc. May return NULL
//              if there were zero bytes written.
//
//              cbAnsiPath is the total size of the buffer allocated
//
//              This routine treats the string as a blob. There may be more
//              than one NULL character (ItemMonikers, for example, append
//              UNICODE strings to the end of existing strings.
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    1-08-94   kevinro   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT ReadAnsiStringStream( IStream *pStm,
                              LPSTR & pszAnsiPath,
                              USHORT &cbAnsiPath)
{
    HRESULT hresult;

    pszAnsiPath = NULL;
    ULONG cbAnsiPathTmp;

    cbAnsiPath = 0;

    hresult = StRead(pStm, &cbAnsiPathTmp, sizeof(ULONG));

    if (FAILED(hresult))
    {
        return hresult;
    }

    //
    // If no bytes exist in the stream, thats OK.
    //
    if (cbAnsiPathTmp == 0)
    {
        return NOERROR;
    }

    //
    // Quick sanity check against the size of the string
    //
    if (cbAnsiPathTmp > MAX_MBS_PATH)
    {
        //
        // String length didn't make sense.
        //
        return E_UNSPEC;
    }

    cbAnsiPath = (USHORT) cbAnsiPathTmp;

    //
    // This string is read in as char's.
    //
    // NOTE: cb includes the null terminator. Therefore, we don't add
    // extra room. Also, the read in string is complete. No additional
    // work needed.
    //

    pszAnsiPath = (char *)PrivMemAlloc(cbAnsiPath);

    if (pszAnsiPath == NULL)
    {
        return(E_OUTOFMEMORY);
    }

    hresult = StRead(pStm, pszAnsiPath, cbAnsiPath);

	pszAnsiPath[cbAnsiPath - 1] = 0;

    if (FAILED(hresult))
    {
        goto errRtn;
    }

    return NOERROR;

errRtn:
    if (pszAnsiPath != NULL)
    {
        PrivMemFree( pszAnsiPath);
        pszAnsiPath = NULL;
    }
    cbAnsiPath = 0;

    return hresult;
}

//+---------------------------------------------------------------------------
//
//  Function:   WriteAnsiStringStream
//
//  Synopsis:   Writes a counted ANSI string to the stream.
//
//  Effects:    Old monikers store paths in ANSI characters. This routine
//              writes ANSI strings.
//
//  Arguments:  [pStm] --       Stream to serialize to
//              [pszAnsiPath] --        AnsiPath to serialize
//              [cbAnsiPath] -- Count of bytes in ANSI path
//
//  Requires:
//
//      cbAnsiPath is the length of the cbAnsiPath buffer, INCLUDING the
//      terminating NULL.
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    1-08-94   kevinro   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT WriteAnsiStringStream( IStream *pStm, LPSTR pszAnsiPath ,ULONG cbAnsiPath)
{
    HRESULT hr;
    ULONG cb = 0;

    // The >= is because there may be an appended unicode string
    Assert( (pszAnsiPath == NULL) || (cbAnsiPath >= strlen(pszAnsiPath)+1) );

    if (pszAnsiPath != NULL)
    {
        cb = cbAnsiPath;

        //
        // We don't allow the write of arbitrary length strings, since
        // we won't be able to read them back in.
        //

        if (cb > MAX_MBS_PATH)
        {
            Assert(!"Attempt to write cbAnsiPath > MAX_MBS_PATH" );
            return(E_UNSPEC);
        }

        //
        // Optimization for the write
        // if possible, do a single write instead of two by using a temp
        // buffer.

        if (cb <= AVERAGE_STR_SIZE-4)
        {
            char szBuf[AVERAGE_STR_SIZE];

            *((ULONG FAR*) szBuf) = cb;

            //
            // cb is the string length including the NULL. A memcpy is
            // used instead of a strcpy
            //

            memcpy(szBuf+sizeof(ULONG), pszAnsiPath, cb);

            hr = pStm->Write((VOID FAR *)szBuf, cb+sizeof(ULONG), NULL);

            return hr;
        }
    }

    if (hr = pStm->Write((VOID FAR *)&cb, sizeof(ULONG), NULL))
    {
        return hr;
    }

    if (pszAnsiPath == NULL)
    {
        hr =  NOERROR;
    }
    else
    {
        hr = pStm->Write((VOID FAR *)pszAnsiPath, cb, NULL);
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   CopyPathFromUnicodeExtent
//
//  Synopsis:   Given a path to a UNICODE moniker extent, return the path and
//              its length.
//
//  Effects:
//
//  Arguments:  [pExtent] --
//              [ppPath] --
//              [cbPath] --
//
//  Requires:
//
//  Returns:    ppPath is a copy of the string (NULL terminated)
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    1-08-94   kevinro   Created
//
//  Notes:
//
//  m_szPath should be freed using PrivMemFree();
//
//----------------------------------------------------------------------------
HRESULT
CopyPathFromUnicodeExtent(MONIKEREXTENT UNALIGNED *pExtent,
                          LPWSTR & pwcsPath,
                          USHORT & ccPath)
{

    //
    // The path isn't NULL terminated in the serialized format. Add enough
    // to have NULL termination.
    //

    pwcsPath =(WCHAR *)PrivMemAlloc(pExtent->cbExtentBytes + sizeof(WCHAR));

    if (pwcsPath == NULL)
    {
        return(E_OUTOFMEMORY);
    }

    memcpy(pwcsPath,pExtent->achExtentBytes,pExtent->cbExtentBytes);

    //
    // The length divided by the size of the character yields the count
    // of characters.
    //

    ccPath = ((USHORT)(pExtent->cbExtentBytes)) / sizeof(WCHAR);

    //
    // NULL terminate the string.
    //

    pwcsPath[ccPath] = 0;

    return(NOERROR);

}

//+---------------------------------------------------------------------------
//
//  Function:   CopyPathToUnicodeExtent
//
//  Synopsis:   Given a UNICODE path and a length, return a MONIKEREXTENT
//
//  Effects:
//
//  Arguments:  [pwcsPath] --   UNICODE string to put in extent
//              [ccPath] --     Count of unicode characters
//              [pExtent] --    Pointer reference to recieve buffer
//
//  Requires:
//
//  Returns:
//              pExtent allocated using PrivMemAlloc
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    1-09-94   kevinro   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT CopyPathToUnicodeExtent(LPWSTR pwcsPath,ULONG ccPath,LPMONIKEREXTENT &pExtent)
{
    pExtent = (LPMONIKEREXTENT)PrivMemAlloc(MONIKEREXTENT_HEADERSIZE +
                                            (ccPath * sizeof(WCHAR)));

    if (pExtent == NULL)
    {
        return(E_OUTOFMEMORY);
    }

    pExtent->cbExtentBytes = ccPath * sizeof(WCHAR);
    pExtent->usKeyValue = mnk_UNICODE;
    memcpy(pExtent->achExtentBytes,pwcsPath,ccPath*sizeof(WCHAR));

    return(NOERROR);
}


INTERNAL_(DWORD) GetMonikerType ( LPMONIKER pmk )
{
    GEN_VDATEIFACE (pmk, 0);

    DWORD dw;

    CBaseMoniker FAR* pbasemk;

    if (NOERROR == pmk->QueryInterface(IID_IInternalMoniker,(LPVOID FAR*)&pbasemk))
    {
        pbasemk->IsSystemMoniker(&dw);
        ((IMoniker *) pbasemk)->Release();
        return dw;
    }

    return 0;
}


INTERNAL_(BOOL) IsReduced ( LPMONIKER pmk )
{
    DWORD dw = GetMonikerType(pmk);
    if (dw != 0)
    {
        CCompositeMoniker *pCMk;
        if ((pCMk = IsCompositeMoniker(pmk)) != NULL)
        {
            return pCMk->m_fReduced;
        }
        else
        {
            return TRUE;
        }
    }
    return FALSE;
}


INTERNAL_(CFileMoniker *) IsFileMoniker ( LPMONIKER pmk )
{
    CFileMoniker *pCFM;

    if ((pmk->QueryInterface(CLSID_FileMoniker, (void **)&pCFM)) == S_OK)
    {
        // we release the AddRef done by QI, but still return the ptr.
        pCFM->Release();
        return pCFM;
    }

    //  dont rely on user implementations to set pCFM NULL on failed QI
    return NULL;
}

/*
 *  Implementation of CFileMoniker
 *
 *
 *
 *
 */



//+---------------------------------------------------------------------------
//
//  Method:     CFileMoniker::CFileMoniker
//
//  Synopsis:   Constructor for CFileMoniker
//
//  Effects:
//
//  Arguments:  [void] --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:
//
//  History:    1-09-94   kevinro   Modified
//
//  Notes:
//
//----------------------------------------------------------------------------
CFileMoniker::CFileMoniker( void ) CONSTR_DEBUG
{
#ifdef _TRACKLINK_
    _tfm.SetParent(this);
#endif

    mnkDebugOut((DEB_ITRACE,
                 "CFileMoniker::CFileMoniker(%x)\n",this));

    m_szPath = NULL;
    m_ccPath = 0;
    m_pszAnsiPath = NULL;
    m_cbAnsiPath = 0;
    m_cAnti = 0;

    m_ole1 = undetermined;
    m_clsid = CLSID_NULL;

    m_fClassVerified = FALSE;
    m_fUnicodeExtent = FALSE;
    m_fHashValueValid = FALSE;
    m_dwHashValue = 0x12345678;

    m_endServer = DEF_ENDSERVER;

#ifdef _TRACKLINK_
    m_pShellLink = NULL;
    m_fTrackingEnabled = FALSE;
    m_fSaveShellLink = FALSE;
    m_fReduceEnabled = FALSE;
    m_fDirty = FALSE;
    m_fShellLinkInitialized = FALSE;  // Has IShellLink->SetPath been called?
#ifdef _CAIRO_
    m_pShellLinkTracker = NULL;
#endif // _CAIRO_
#endif // _TRACKLINK_

    //
    // CoQueryReleaseObject needs to have the address of the this objects
    // query interface routine.
    //
    if (adwQueryInterfaceTable[QI_TABLE_CFileMoniker] == 0)
    {
        adwQueryInterfaceTable[QI_TABLE_CFileMoniker] =
            **(ULONG_PTR **)((IMoniker *)this);
    }

    wValidateMoniker();
}

//+---------------------------------------------------------------------------
//
//  Method:     CFileMoniker::ValidateMoniker
//
//  Synopsis:   As a debugging routine, this will validate the contents
//              as VALID
//
//  Effects:
//
//  Arguments:  (none)
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:
//
//  History:    1-12-94   kevinro   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
#if DBG == 1

void 
CFileMoniker::ValidateMoniker()
{
    CLock2 lck(m_mxs);   // protect all internal state
    wValidateMoniker();
}

void
CFileMoniker::wValidateMoniker()
{
    //
    // A valid moniker should have character counts set correctly
    // m_ccPath holds the number of characters in m_szPath
    //
    if (m_szPath != NULL)
    {
        Assert(m_ccPath == lstrlenW(m_szPath));

        Assert((m_endServer == DEF_ENDSERVER) || (m_endServer <= m_ccPath));
    }
    else
    {
        Assert(m_ccPath == 0);
        Assert(m_endServer == DEF_ENDSERVER);
    }

    //
    // If the ANSI version of the path already exists, then validate that
    // its buffer length is the same as its strlen
    //
    if (m_pszAnsiPath != NULL)
    {
        Assert(m_cbAnsiPath == strlen(m_pszAnsiPath) + 1);
    }
    else
    {
        Assert(m_cbAnsiPath == 0);
    }

    //
    // There is a very very remote chance that this might fail when it
    // shouldn't. If it happens, congratulations, you win!
    //
    if (!m_fHashValueValid)
    {
        Assert(m_dwHashValue == 0x12345678);
    }

    //
    // If there is an extent, then we would be very surprised to see it
    // have a zero size.
    //
    if (m_fUnicodeExtent)
    {
        Assert(m_ExtentList.GetSize() >= sizeof(ULONG));
    }

}

#endif




//+---------------------------------------------------------------------------
//
//  Method:     CFileMoniker::~CFileMoniker
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:  [void] --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:
//
//  History:    1-09-94   kevinro   Modified
//
//  Notes:
//
//----------------------------------------------------------------------------
CFileMoniker::~CFileMoniker( void )
{
    // no locking needed here, since we are going away, and nobody should
    // have any references to us.
    wValidateMoniker();

    mnkDebugOut((DEB_ITRACE,
                 "CFileMoniker::~CFileMoniker(%x) m_szPath(%ws)\n",
                 this,
                 m_szPath?m_szPath:L"<No Path>"));

    if( m_szPath != NULL)
    {
        PrivMemFree(m_szPath);
    }
    if (m_pszAnsiPath != NULL)
    {
        PrivMemFree(m_pszAnsiPath);
    }
#ifdef _TRACKLINK_
    if (m_pShellLink != NULL)
    {
        m_pShellLink->Release();
    }
#ifdef _CAIRO_
    if (m_pShellLinkTracker != NULL)
    {
        m_pShellLinkTracker->Release();
    }
#endif // _CAIRO_
#endif // _TRACKLINK_
}


void UpdateClsid (LPCLSID pclsid)
{

        CLSID clsidNew = CLSID_NULL;

        // If a class has been upgraded, we want to use
        // the new class as the server for the link.
        // The old class's server may no longer exist on
        // the machine.  See Bug 4147.

        if (NOERROR == OleGetAutoConvert (*pclsid, &clsidNew))
        {
                *pclsid = clsidNew;
        }
        else if (NOERROR == CoGetTreatAsClass (*pclsid, &clsidNew))
        {
                *pclsid = clsidNew;
        }
}

/*
When IsOle1Class determines that the moniker should now be an OLE2 moniker
and sets m_ole1 = ole2, it does NOT set m_clsid to CLSID_NULL.
This is intentional.  This ensures that when GetClassFileEx is called, it
will be called with this CLSID.  This allows BindToObject, after calling
GetClassFileEx,  to map the 1.0 CLSID, via UpdateClsid(), to the correct
2.0 CLSID.  If m_clsid was NULLed, GetClassFileEx would have no
way to determine the 1.0 CLSID (unless pattern matching worked).

Note that this means that the moniker may have m_ole1==ole2 and
m_clsid!=CLSID_NULL.  This may seem a little strange but is intentional.
The moniker is persistently saved this way, which is also intentional.
*/


INTERNAL_(BOOL) CFileMoniker::IsOle1Class ( LPCLSID pclsid )
{
    wValidateMoniker();
    {
        if (m_fClassVerified)
        {
            if (m_ole1 == ole1)
            {
                *pclsid = m_clsid;
                return TRUE;
            }
            if (m_ole1 == ole2)
            {
                return FALSE;
            }
        }
        //
        // If GetClassFileEx fails, then we have not really
        // verified the class. m_ole1 remains 'undetermined'
        //

        m_fClassVerified = TRUE;

        HRESULT hr = GetClassFileEx (m_szPath, pclsid, m_clsid);

        if (NOERROR== hr)
        {
                UpdateClsid (pclsid);
                if (CoIsOle1Class(*pclsid))
                {
                    m_clsid = *pclsid;
                    m_ole1 = ole1;
                    return TRUE;
                }
                else
                {
                    m_ole1 = ole2;
                    // Do not set m_clsid to CLSID_NULL.  See note above.
                }
        }
        return m_ole1==ole1;
    }

}

//+---------------------------------------------------------------------------
//
//  Method:     CFileMoniker::GetShellLink, private
//
//  Synopsis:   Ensure that m_pShellLink is valid, or return error.
//
//  Arguments:  [void]
//
//  Notes:
//
//----------------------------------------------------------------------------

#ifdef _TRACKLINK_

HINSTANCE g_hShell32ForShellLink = NULL;
IClassFactory* g_pcfShellLink = NULL;

INTERNAL CFileMoniker::GetShellLink()
{
    if (m_pShellLink == NULL)
    {
        // It would be nice to use CoCreateInstance here,
        // but we cannot because it would fail when 
        // running on WOW threads.  There are other - more 
        // complicated - possible fixes, but there's not much 
        // need to optimize this path.
        if (!g_pcfShellLink)
        {
            LPFNGETCLASSOBJECT pfn = NULL;
            if (LoadSystemProc("shell32.dll",
                                "DllGetClassObject",
                                &g_hShell32ForShellLink,
                                (FARPROC*)&pfn) != 0)
            {
                return E_FAIL;
            }

            Win4Assert(pfn);
            
            HRESULT hr = (*pfn)(CLSID_ShellLink, IID_IClassFactory, (void**)&g_pcfShellLink);                                
            if (FAILED(hr))
                return hr;
        }

        g_pcfShellLink->CreateInstance(NULL, IID_IShellLinkW, (void**)&m_pShellLink);
    }

    return(m_pShellLink != NULL ? S_OK : E_FAIL);    
}

#endif




//+-------------------------------------------------------------------
//
//  Member:     CFileMoniker::EnableTracking
//
//  Synopsis:   Creates/destroys the information neccessary to
//              track objects on BindToObject calls.
//
//  Arguments:  [pmkToLeft] -- moniker to left.
//
//              [ulFlags] -- flags to control behaviour of tracking
//                           extensions.
//
//              Combination of:
//                  OT_READTRACKINGINFO -- get id from source
//                  OT_ENABLESAVE -- enable tracker to be saved in
//                                   extents.
//                  OT_DISABLESAVE -- disable tracker to be saved.
//                  OT_DISABLETRACKING -- destroy any tracking info
//                                    and prevent tracking and save of
//                                    tracking info.
//
//                  OT_DISABLESAVE takes priority of OT_ENABLESAVE
//                  OT_READTRACKINGINFO takes priority over
//                          OT_DISABLETRACKING
//
//                  OT_ENABLEREDUCE -- enable new reduce functionality
//                  OT_DISABLEREDUCE -- disable new reduce functionality
//
//                  OT_MAKETRACKING -- make the moniker inherently tracking;
//                          then tracking need not be enabled, and cannot be disabled.
//
//  Returns:    HResult
//              Success is SUCCEEDED(hr)
//
//  Modifies:
//
//--------------------------------------------------------------------

#ifdef _TRACKLINK_
STDMETHODIMP CFileMoniker::EnableTracking(IMoniker *pmkToLeft, ULONG ulFlags)
{

    //
    // - if the shellink does not exist, and shellink creation has not
    //   been disabled by the OLELINK (using private i/f ITrackingMoniker)
    //   then create one and save in extent list.  (The EnabledTracking(FALSE)
    //   call prevents the file moniker from creating the shellink on save.)
    // - if the shellink exists, update the ShellLink in the extent list
    //

    CLock2 lck(m_mxs);   // protect all internal state

    //
    // create an in memory shell link object if needed.
    //

    HRESULT hr = S_OK;


    if (ulFlags & OT_ENABLESAVE)
    {
        mnkDebugOut((DEB_TRACK,
                     "CFileMoniker(%x)::EnableTracking() -- enable save\n",
                     this));

        m_fSaveShellLink = TRUE;
    }

    if (ulFlags & OT_DISABLESAVE)
    {
        mnkDebugOut((DEB_TRACK,
                     "CFileMoniker(%x)::EnableTracking() -- disable save\n",
                     this));

        m_fSaveShellLink = FALSE;
    }

    if (ulFlags & OT_ENABLEREDUCE)
    {
        mnkDebugOut((DEB_TRACK,
                     "CFileMoniker(%x)::EnableTracking() -- enable reduce\n",
                     this));

        m_fReduceEnabled = TRUE;
    }

    if (ulFlags & OT_DISABLEREDUCE)
    {
        mnkDebugOut((DEB_TRACK,
                     "CFileMoniker(%x)::EnableTracking() -- disable reduce\n",
                     this));

        m_fReduceEnabled = FALSE;
    }


    if (ulFlags & OT_READTRACKINGINFO)
    {
        BOOL fExtentNotFound = FALSE;

        // Load the shell link, if it's not already.

        hr = RestoreShellLink( &fExtentNotFound );

        if( SUCCEEDED(hr) || fExtentNotFound )
        {
            // Either the shell link was successfully restored, or
            // it failed because we didn't have it saved away in the
            // extent.  In either case we can create/update the shell link.
            // 
            // If we've ever gotten the shell link set up in the past, do
            // a refresh-type resolve on it.  Otherwise, do a SetPath.

            if( m_fShellLinkInitialized )
                hr = ResolveShellLink( TRUE ); // fRefreshOnly
            else
                hr = SetPathShellLink();
        }

        if( FAILED( hr ))
        {
            if( m_pShellLink )
            {
                m_pShellLink->Release();
                m_pShellLink = NULL;
                m_fShellLinkInitialized = FALSE;
            }

            mnkDebugOut((DEB_TRACK,
                 "CFileMoniker(%x)::EnableTracking(%ls) -- m_pShellLink->SetPath failed %08X.\n",
                     this,
                     m_szPath,
                     hr));

        }   // ShellLink->SetPath ... if (FAILED(hr))
        else
        {
            m_fTrackingEnabled = TRUE;
            hr = S_OK;
        }
    }   // if (ulFlags & OT_READTRACKINGINFO)

    else
    if (ulFlags & OT_DISABLETRACKING)
    {
        mnkDebugOut((DEB_TRACK,
                     "CFileMoniker(%x)::EnableTracking() -- disabletracking\n",
                     this));

        // If this is a tracking moniker, the Shell Link cannot
        // be deleted.

        if (m_pShellLink != NULL)
            m_pShellLink->Release();
        m_pShellLink = NULL;
        m_fShellLinkInitialized = FALSE;
        
        m_ExtentList.DeleteExtent(mnk_ShellLink);

        m_fSaveShellLink = FALSE;
        m_fTrackingEnabled = FALSE;
    }   // else if (ulFlags & OT_DISABLETRACKING)


    return(hr);
}

#endif

/*
 *  Storage of paths in file monikers:
 *
 *  A separate unsigned integer holds the count of .. at the
 *  beginning of the path, so the canononical form of a file
 *  moniker contains this count and the "path" described above,
 *  which will not contain "..\" or ".\".
 *
 *  It is considered an error for a path to contain ..\ anywhere
 *  but at the beginning.  I assume that these will be taken out by
 *  ParseUserName.
 */



inline BOOL IsSeparator( WCHAR ch )
{
    return (ch == L'\\' || ch == L'/' || ch == L':');
}

#ifdef MAC_REVIEW
Needs to be mac'ifyed
#endif


//+---------------------------------------------------------------------------
//
//  Function:   EatDotDDots
//
//  Synopsis:   Remove directory prefixes
//
//  Effects:
//      Removes and counts the number of 'dot dots' on a path. It also
//      removes the case where the leading characters are '.\', which
//      is the 'current' directory.
//
//  Arguments:  [pch] --
//              [cDoubleDots] --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    3-02-94   kevinro   Commented
//              3-21-95   kevinro   Fixed case where path is ..foo
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOL EatDotDots ( LPCWSTR *ppch, USHORT FAR *pcDoubleDots )
{
    //  passes over ..'s (or ..\'s at the beginning of paths, and returns
    //  an integer counting the ..

    LPWSTR pch = (LPWSTR) *ppch;

    if (pch == NULL)
    {
        //
        // NULL paths are alright
        //
        return(TRUE);
    }

    while (pch[0] == L'.')
    {
        //
        // If the next character is a dot, the consume both, plus any
        // seperator
        //

        if (pch[1] == L'.')
        {

            //
            // If the next character is a seperator, then remove it also
            // This handles the '..\' case.
            //

            if (IsSeparator(pch[2]))
            {
                pch += 3;
                (*pcDoubleDots)++;
            }
            //
            // If the next char is a NULL, then eat it and count a dotdot.
            // This handles the '..' case where we want the parent directory
            //
            else if(pch[2] == 0)
            {
                pch += 2;
                (*pcDoubleDots)++;
            }
            //
            // Otherwise, we just found a '..foobar', which is a valid name.
            // We can stop processing the string all together and be done.
            //
            else
            {
                break;
            }

        }
        else if (IsSeparator(pch[1]))
        {
            //
            // Found a .\ construct, eat the dot and the seperator
            //
            pch += 2;
        }
        else
        {
            //
            // There is a dot at the start of the name. This is valid,
            // since many file systems allow names to start with dots
            //
            break;
        }
    }

    *ppch = pch;
    return TRUE;
}



int CountSegments ( LPWSTR pch )
{
    //  counts the number of pieces in a path, after the first colon, if
    //  there is one

    int n = 0;
    LPWSTR pch1;
    pch1 = pch;
    while (*pch1 != L'\0' && *pch1 != L':') IncLpch(pch1);
    if (*pch1 == ':') pch = ++pch1;
    while (*pch != '\0')
    {
        while (*pch && IsSeparator(*pch)) pch++;
        if (*pch) n++;
        while (*pch && (!IsSeparator(*pch))) IncLpch(pch);
    }
    return n;
}

//+---------------------------------------------------------------------------
//
//  Method:     CFileMoniker::Initialize
//
//  Synopsis:  Initializes data members.
//
//  Effects:    This one stores the path, its length, and the AntiMoniker
//              count.
//
//  Arguments:  [cAnti] --
//              [pszAnsiPath] -- Ansi version of path. May be NULL
//              [cbAnsiPath] --  Number of bytes in pszAnsiPath buffer
//              [szPathName] --  Path. Takes control of memory
//              [ccPathName] --  Number of characters in Wide Path
//              [usEndServer] -- Offset to end of server section
//
//  Requires:
//      szPathName must be allocated by PrivMemAlloc();
//      This routine doesn't call EatDotDots. Therefore, the path should
//      not include any leading DotDots.
//
//  Returns:
//              TRUE    success
//              FALSE   failure
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:
//
//  History:    1-08-94   kevinro   Modified
//
//  Notes:
//
//      There is at least one case where Initialize is called with a pre
//      allocated string. This routine is called rather than the other.
//      Removes an extra memory allocation, and the extra string scan
//
//----------------------------------------------------------------------------
INTERNAL_(BOOL)
CFileMoniker::Initialize ( USHORT cAnti,
                           LPSTR  pszAnsiPath,
                           USHORT cbAnsiPath,
                           LPWSTR szPathName,
                           USHORT ccPathName,
                           USHORT usEndServer )


{
    wValidateMoniker();          // Be sure we started with something
                                // we expected

    mnkDebugOut((DEB_ITRACE,
                 "CFileMoniker::Initialize(%x) szPathName(%ws)cAnti(%u) ccPathName(0x%x)\n",
                 this,
                 szPathName?szPathName:L"<NULL>",
                 cAnti,
                 ccPathName));

    mnkDebugOut((DEB_ITRACE,
                 "\tpszAnsiPath(%s) cbAnsiPath(0x%x) usEndServer(0x%x)\n",
                 pszAnsiPath?pszAnsiPath:"<NULL>",
                 cbAnsiPath,
                 usEndServer));

    Assert( (szPathName == NULL) || ccPathName == lstrlenW(szPathName) );
    Assert( (pszAnsiPath == NULL) || cbAnsiPath == strlen(pszAnsiPath) + 1);

    Assert( (usEndServer <= ccPathName) || (usEndServer == DEF_ENDSERVER) );


    if (m_mxs.FInit() == FALSE)
    	{
    	return FALSE;
    	}

    //
    // It is possible to get Initialized twice.
    // Be careful not to leak
    //

    if (m_szPath != NULL)
    {
        PrivMemFree(m_szPath); // OleLoadFromStream causes two inits
    }

    if (m_pszAnsiPath != NULL)
    {
        PrivMemFree(m_pszAnsiPath);
    }

    m_cAnti = cAnti;
    m_pszAnsiPath = pszAnsiPath;
    m_cbAnsiPath = cbAnsiPath;

    m_szPath = szPathName;
    m_ccPath = (USHORT)ccPathName;
    m_endServer = usEndServer;

    //
    // m_ole1 and m_clsid where loaded in 'Load'. Really should get moved
    // into here.
    //

    m_fClassVerified = FALSE;

    // m_fUnicodeExtent gets set in DetermineUnicodePath() routine, so
    // leave it alone here.

    //
    // We just loaded new strings. Hash value is no longer valid.
    //

    m_fHashValueValid = FALSE;
    m_dwHashValue = 0x12345678;

    //
    // Notice that the extents are not initialized.
    //
    // The two cases are:
    //  1) This is called as result of CreateFileMoniker, in which case
    //     no extents are created. The default constructor suffices.
    //
    //  2) This is called as result of ::Load(), in which case the extents
    //     have already been loaded.
    //

    wValidateMoniker();

    return(TRUE);

}
//+---------------------------------------------------------------------------
//
//  Method:     CFileMoniker::Initialize
//
//  Synopsis:   This version of Initialize is called by CreateFileMoniker
//
//  Effects:
//
//  Arguments:  [cAnti] -- Anti moniker count
//              [szPathName] -- Unicode path name
//              [usEndServer] -- End of server section of UNC path
//
//  Requires:
//
//  Returns:
//              TRUE    success
//              FALSE   failure
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:
//
//  History:    1-08-94   kevinro   Modified
//
//  Notes:
//
//      Preprocesses the path, makes a copy of it, then calls the other
//      version of Initialize.
//
//----------------------------------------------------------------------------
INTERNAL_(BOOL)
CFileMoniker::Initialize ( USHORT cAnti,
                           LPCWSTR szPathName,
                           USHORT usEndServer )
{

    WCHAR const *pchSrc = szPathName;
    WCHAR *pwcsPath = NULL;
    USHORT ccPath;

    
    if (m_mxs.FInit() == FALSE) // If we can't init the critsec, bail
    	{
    	return FALSE;
    	}

    //
    // Adjust for leading '..'s
    //
    if (EatDotDots(&pchSrc, &cAnti) == FALSE)
    {
        return FALSE;
    }

    if (FAILED(DupWCHARString(pchSrc,pwcsPath,ccPath)))
    {
        return(FALSE);
    }

    //
    // Be sure we are creating a valid Win32 path. ccPath is the count of
    // characters. It needs to fit into a MAX_PATH buffer
    //

    if (ccPath >= MAX_PATH)
    {
        goto errRet;
    }

    if (Initialize(cAnti, NULL, 0, pwcsPath, ccPath, usEndServer) == FALSE)
    {
        goto errRet;
    }

    return(TRUE);

errRet:
    if (pwcsPath != NULL)
    {
        PrivMemFree(pwcsPath);
    }
    return(FALSE);
}


//+---------------------------------------------------------------------------
//
//  Method:     CFileMoniker::Create
//
//  Synopsis:   Create function for file moniker
//
//  Effects:
//
//  Arguments:  [szPathName] -- Path to create with
//              [cbPathName] -- Count of characters in path
//              [memLoc] -- Memory context
//              [usEndServer] -- Offset to end of server name in path
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:
//
//  History:    1-11-94   kevinro   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
CFileMoniker FAR *
CFileMoniker::Create ( LPCWSTR          szPathName,
                       USHORT           cAnti ,
                       USHORT           usEndServer)

{

    mnkDebugOut((DEB_ITRACE,
                 "CFileMoniker::Create szPath(%ws)\n",
                 szPathName?szPathName:L"<NULL PATH>"));

    CFileMoniker FAR * pCFM = new CFileMoniker();

    if (pCFM != NULL)
    {
        if (pCFM->Initialize( cAnti,
                              szPathName,
                              usEndServer))
        {
            return pCFM;
        }

        delete pCFM;
    }
    return NULL;
}


//+---------------------------------------------------------------------------
//
//  Function:   FindExt
//
//  Synopsis:
//
//  Effects:
//      returns a pointer into szPath which points to the period (.) of the
//      extension; returns NULL if no such point exists.
//
//  Arguments:  [szPath] --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    1-16-94   kevinro   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
LPCWSTR FindExt ( LPCWSTR szPath )
{
    LPCWSTR sz = szPath;

    if (!sz)
    {
        return NULL;
    }

    sz += lstrlenW(szPath); // sz now points to the null at the end

    Assert(*sz == '\0');

    DecLpch(szPath, sz);

    while (*sz != '.' && *sz != '\\' && *sz != '/' && sz > szPath )
    {
        DecLpch(szPath, sz);
    }
    if (*sz != '.') return NULL;

    return sz;
}





STDMETHODIMP CFileMoniker::QueryInterface (THIS_ REFIID riid,
    LPVOID FAR* ppvObj)
{
    VDATEIID (riid);
    VDATEPTROUT(ppvObj, LPVOID);

    *ppvObj = NULL;

#ifdef _DEBUG
    if (riid == IID_IDebug)
    {
        *ppvObj = &(m_Debug);
        return NOERROR;
    }
#endif

#ifdef _TRACKLINK_
    if (IsEqualIID(riid, IID_ITrackingMoniker))
    {
        AddRef();
        *ppvObj = (ITrackingMoniker *) &_tfm;
        return(S_OK);
    }
#endif
    if (IsEqualIID(riid, CLSID_FileMoniker))
    {
        //  called by IsFileMoniker.
        AddRef();
        *ppvObj = this;
        return S_OK;
    }

    return CBaseMoniker::QueryInterface(riid, ppvObj);
}


STDMETHODIMP CFileMoniker::GetClassID (LPCLSID lpClassId)
{
    VDATEPTROUT (lpClassId, CLSID);

    *lpClassId = CLSID_FileMoniker;

    return NOERROR;
}



//+---------------------------------------------------------------------------
//
//  Method:     CFileMoniker::Load
//
//  Synopsis:   Loads a moniker from a stream
//
//  Effects:
//
//  Arguments:  [pStm] -- Stream to load from
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:
//
//  History:    1-07-94   kevinro   Modified
//
//  Notes:
//
//  We have some unfortunate legacy code to deal with here. Previous monikers
//  saved their paths in ANSI instead of UNICODE. This was a very unfortunate
//  decision, since we now are forced to pull some tricks to support UNICODE
//  paths.
//
//  Specifically, there isn't always a translation between UNICODE and ANSI
//  characters. This means we may need to save a seperate copy of the UNCODE
//  string, if the mapping to ASCII fails.
//
//  The basic idea is the following:
//
//  The in memory representation is always UNICODE. The serialized form
//  will always attempt to be ANSI. If, while seralizing, the UNICODE path
//  to ANSI path conversion fails, then we will create an extent to save the
//  UNICODE version of the path. We will use whatever the ANSI path conversion
//  ended up with to store in the ANSI part of the stream, though it will not
//  be a good value. We will replace the non-converted characters with the
//  systems 'default' mapping character, as defined by WideCharToMultiByte()
//
//
//----------------------------------------------------------------------------
STDMETHODIMP CFileMoniker::Load (LPSTREAM pStm)
{
    CLock2 lck(m_mxs);   // protect all internal state during load operation

    wValidateMoniker();

    mnkDebugOut((DEB_ITRACE,
                 "CFileMoniker::Load(%x)\n",
                 this));

    VDATEIFACE (pStm);

    HRESULT hresult;
    LPSTR szAnsiPath = NULL;
    USHORT cAnti;
    USHORT usEndServer;

    WCHAR *pwcsWidePath = NULL;
    USHORT ccWidePath = 0;      // Number of characters in UNICODE path

    ULONG cbExtents = 0;
    USHORT cbAnsiPath = 0;      // Number of bytes in path including NULL

#ifdef _CAIRO_

    //
    // If we're about to load from a stream, then our existing
    // state is now invalid.  There's no need to explicitely
    // re-initialize our persistent state, except for the
    // Shell Link object.  An existing ShellLink should be
    // deleted.
    //

    if( m_pShellLink )
        m_pShellLink->Release();
    m_pShellLink = NULL;
    m_fShellLinkInitialized = FALSE;

#endif // _CAIRO_


    //
    // The cAnti field was written out as a UINT in the original 16-bit code.
    // This has been changed to a USHORT, to preserve its 16 bit size.
    //

    hresult = StRead(pStm, &cAnti, sizeof(USHORT));

    if (hresult != NOERROR)
    {
        goto errRet;
    }

    //
    // The path string is stored in ANSI format.
    //

    hresult = ReadAnsiStringStream( pStm, szAnsiPath , cbAnsiPath );

    if (hresult != NOERROR)
    {
        goto errRet;
    }

    //
    // The first version of the moniker code only had a MAC alias field.
    // The second version used a cookie in m_cbMacAlias field to determine
    // if the moniker is a newer version.
    //

    hresult = StRead(pStm, &cbExtents, sizeof(DWORD));

    if (hresult != NOERROR)
    {
        goto errRet;
    }

    usEndServer = LOWORD(cbExtents);

    if (usEndServer== 0xBEEF) usEndServer = DEF_ENDSERVER;

    if (HIWORD(cbExtents) == 0xDEAD)
    {
        MonikerReadStruct ioStruct;

        hresult = StRead(pStm, &ioStruct, sizeof(ioStruct));

        if (hresult != NOERROR)
        {
            goto errRet;
        }

        m_clsid = ioStruct.m_clsid;
        m_ole1 = (enum CFileMoniker::olever) ioStruct.m_ole1;
        cbExtents = ioStruct.m_cbExtents;
    }
    //
    // If cbExtents is != 0, then there are extents to be read. Call
    // the member function of CExtentList to load them from stream.
    //
    // Having to pass cbExtents from this routine is ugly. But, we have
    // to since it is read in as part of the cookie check above.
    //
    if (cbExtents != 0)
    {
        hresult = m_ExtentList.Load(pStm,cbExtents);

#ifdef _TRACKLINK_

        if (hresult == S_OK)
        {
                m_fTrackingEnabled =
                    NULL != m_ExtentList.FindExtent(mnk_ShellLink);
                mnkDebugOut((DEB_TRACK,
                         "CFileMoniker(%x)::Load did%s find mnk_ShellLink extent, m_fTrackingEnabled=%d.\n",
                     this,
                     m_fTrackingEnabled ? "" : " not",
                     m_fTrackingEnabled));

#ifdef _CAIRO_
            }   // if( ... FindExtent( mnk_TrackingInformation )) ... else
#endif
        }   // hresult = m_ExtentList.Load(pStm,cbExtents) ... if (hresult == S_OK)

#endif  // _TRACKLINK_
    }   // if (cbExtents != 0)

    //
    // DetermineUnicodePath will handle the mbs to UNICODE conversions, and
    // will also check the Extents to determine if there is a
    // stored UNICODE path.
    //

    hresult = DetermineUnicodePath(szAnsiPath,pwcsWidePath,ccWidePath);

    if (FAILED(hresult))
    {
        goto errRet;
    }

    //
    // Initialize will take control of all path memory
    //

    if (Initialize( cAnti,
                    szAnsiPath,
                    cbAnsiPath,
                    pwcsWidePath,
                    ccWidePath,
                    usEndServer) == FALSE)
    {
        hresult = ResultFromScode(E_OUTOFMEMORY);
        goto errRet;
    }

errRet:

    if (FAILED(hresult))
    {
        mnkDebugOut((DEB_ITRACE,
                     "::Load(%x) failed hr(%x)\n",
                     this,
                     hresult));

    }
    else
    {
        mnkDebugOut((DEB_ITRACE,
                     "::Load(%x) cAnti(%x) m_szPath(%ws) m_pszAnsiPath(%s)\n",
                     this,
                     cAnti,
                     m_szPath,
                     m_pszAnsiPath));
    }

    wValidateMoniker();

    return hresult;
}

//+---------------------------------------------------------------------------
//
//  Method:     CFileMoniker::Save
//
//  Synopsis:   Save this moniker to stream.
//
//  Effects:
//
//  Arguments:  [pStm] -- Stream to save to
//              [fClearDirty] -- Dirty flag
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:
//
//  History:    1-07-94   kevinro   Modified
//
//  Notes:
//
//  It is unfortunate, but we may need to save two sets of paths in the
//  moniker. The shipped version of monikers saved paths as ASCII strings.
//
//  See the notes found in ::Load for more details
//
//
//----------------------------------------------------------------------------
STDMETHODIMP CFileMoniker::Save (LPSTREAM pStm, BOOL fClearDirty)
{
    CLock2 lck(m_mxs);   // protect all internal state during save operation

    wValidateMoniker();
    mnkDebugOut((DEB_ITRACE,
                 "CFileMoniker::Save(%x)m_szPath(%ws)\n",
                 this,
                 m_szPath?m_szPath:L"<Null Path>"));

    M_PROLOG(this);

    VDATEIFACE (pStm);

    HRESULT hresult;
    UNREFERENCED(fClearDirty);
    ULONG cbWritten;

    //
    // We currently have a UNICODE string. Need to write out an
    // Ansi version.
    //

    hresult = ValidateAnsiPath();

    if (hresult != NOERROR) goto errRet;

    hresult = pStm->Write(&m_cAnti, sizeof(USHORT), &cbWritten);
    if (hresult != NOERROR) goto errRet;

    //
    // Write the ANSI version of the path.
    //

    hresult = WriteAnsiStringStream( pStm, m_pszAnsiPath, m_cbAnsiPath );
    if (hresult != NOERROR) goto errRet;

    //
    // Here we write out everything in a single blob
    //

    MonikerWriteStruct ioStruct;

    ioStruct.m_endServer = m_endServer;
    ioStruct.m_w = 0xDEAD;
    ioStruct.m_clsid = m_clsid;
    ioStruct.m_ole1 = m_ole1;


    hresult = pStm->Write(&ioStruct, sizeof(ioStruct), &cbWritten);

    if (hresult != NOERROR) goto errRet;

    Assert(cbWritten == sizeof(ioStruct));


#ifdef _TRACKLINK_

    mnkDebugOut((DEB_TRACK,
             "CFileMoniker(%x)::Save m_fSaveShellLink = %s, m_pShellLink=%08X.\n",
         this,
         m_fSaveShellLink ? "TRUE" : "FALSE",
         m_pShellLink));


    // If we have a ShellLink object, and either this is a tracking moniker
    // or we've been asked to save the ShellLink, then save it in a
    // Moniker Extent.

    if ( m_fSaveShellLink && m_pShellLink != NULL )
    {
        //
        // Here we are saving the shell link to a MONIKEREXTENT.
        // The basic idea here is to save the shell link to an in memory
        // stream (using CreateStreamOnHGlobal).  The format of the stream
        // is the same as a MONIKEREXTENT (i.e. has a MONIKEREXTENT at the
        // front of the stream.)
        //

        IPersistStream *pps = NULL;
        IStream * pstm = NULL;
        BOOL fOk;
        HRESULT hr;

        Verify(S_OK == m_pShellLink->QueryInterface(IID_IPersistStream, (void **) & pps));

        hr = CreateStreamOnHGlobal(NULL, // auto alloc
                TRUE, // delete on release
                &pstm);

        if (hr != S_OK)
        {
            mnkDebugOut((DEB_TRACK,
                     "CFileMoniker(%x)::Save CreateStreamOnHGlobal failed %08X",
                 this,
                 hr));
            goto ExitShellLink;
        }

        //
        // We write out the MONIKEREXTENT header to the stream ...
        //

        MONIKEREXTENT me;
        MONIKEREXTENT *pExtent;

        me.cbExtentBytes = 0;
        me.usKeyValue = mnk_ShellLink;

        hr = pstm->Write(&me, MONIKEREXTENT_HEADERSIZE, NULL);
        if (hr != S_OK)
            goto ExitShellLink;

        // ... and then save the shell link
        hr = pps->Save(pstm, FALSE);

        if (hr != S_OK)
            goto ExitShellLink;

        // We then seek back and write the cbExtentList value.
        LARGE_INTEGER li0;
        ULARGE_INTEGER uli;

        memset(&li0, 0, sizeof(li0));

        Verify(S_OK == pstm->Seek(li0, STREAM_SEEK_END, &uli));

        me.cbExtentBytes = uli.LowPart - MONIKEREXTENT_HEADERSIZE;
        Verify(S_OK == pstm->Seek(li0, STREAM_SEEK_SET, &uli));
        Assert(uli.LowPart == 0 && uli.HighPart == 0);

        Verify(S_OK == pstm->Write(&me.cbExtentBytes, sizeof(me.cbExtentBytes), NULL));


        // Finally, we get access to the memory of the stream and
        // cast it to a MONIKEREXTENT to pass to PutExtent.

        HGLOBAL hGlobal;

        Verify(S_OK == GetHGlobalFromStream(pstm, &hGlobal));

        pExtent = (MONIKEREXTENT *) GlobalLock(hGlobal);
        Assert(pExtent != NULL);

        // this overwrites the existing mnk_ShellLink extent if any.
        hr = m_ExtentList.PutExtent(pExtent);

        fOk = GlobalUnlock(hGlobal);

        mnkDebugOut((DEB_TRACK,
                     "CFileMoniker(%x)::Save serialized shell link to extent=%08X\n",
                 this,
                 hr));

        // If this is a Tracking Moniker, then we additionally write
        // out the fShellLinkInitialized flag.  Not only does this make the
        // flag persistent, but the existence of this Extent indicates
        // that this is a Tracking Moniker (put another way, it makes the
        // fIsTracking member persistent).


ExitShellLink:

        if (pstm != NULL)
            pstm->Release(); // releases the hGlobal.

        if (pps != NULL)
            pps->Release();

    }   // if ( ( m_fSaveShellLink ...
#endif // _TRACKLINK_

    //
    // A UNICODE version may exist in the ExtentList. Write that out.
    //

    hresult = m_ExtentList.Save(pStm);

errRet:

#ifdef _TRACKLINK_
    if (SUCCEEDED(hresult) && fClearDirty)
    {
        mnkDebugOut((DEB_TRACK,
                     "CFileMoniker(%x)::Save clearing dirty flag\n",
                 this));
        m_fDirty = FALSE;
    }
#endif

    wValidateMoniker();

    return hresult;
}

//+---------------------------------------------------------------------------
//
//  Method:     CFileMoniker::IsDirty
//
//  Synopsis:   Return the dirty flag
//
//  Notes:
//
//----------------------------------------------------------------------------
#ifdef _TRACKLINK_
STDMETHODIMP CFileMoniker::IsDirty (VOID)
{
    mnkDebugOut((DEB_TRACK,
                     "CFileMoniker(%x)::IsDirty returning%s dirty\n",
                 this,
                 m_fDirty ? "" : " not"));
    return(m_fDirty ? S_OK : S_FALSE);
}
#endif

//+---------------------------------------------------------------------------
//
//  Method:     CFileMoniker::GetSizeMax
//
//  Synopsis:   Return the current max size for a serialized moniker
//
//  Effects:
//
//  Arguments:  [pcbSize] --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:
//
//  History:    1-09-94   kevinro   Modified
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CFileMoniker::GetSizeMax (ULARGE_INTEGER FAR* pcbSize)
{
    CLock2 lck(m_mxs);   // protect all internal state during this call
    wValidateMoniker();

    M_PROLOG(this);
    VDATEPTROUT (pcbSize, ULONG);

    //
    // Total the string lengths. If the Ansi string doesn't exist yet, then
    // assume the maximum length will be 2 bytes times the number of
    // characters. 2 bytes is the maximum length of a DBCS character.
    //


    ULONG ulStringLengths = (m_cbAnsiPath?m_cbAnsiPath:m_ccPath*2);


    //
    // Now add in the size of the UNICODE string, if we haven't seen
    // a UNICODE extent yet.
    //

    if (!m_fUnicodeExtent )
    {
        ulStringLengths += (m_ccPath * sizeof(WCHAR));
    }

    //
    // The original code had added 10 bytes to the size, apparently just
    // for kicks. I have left it here, since it doesn't actually hurt
    //

    ULONG cbSize;

    cbSize = ulStringLengths +
             sizeof(CLSID) +            // The monikers class ID
             sizeof(CLSID) +            // OLE 1 classID
             sizeof(ULONG) +
             sizeof(USHORT) +
             sizeof(DWORD) +
             m_ExtentList.GetSize()
             + 10;

    ULISet32(*pcbSize,cbSize);

    mnkDebugOut((DEB_ITRACE,
                 "CFileMoniker::GetSizeMax(%x)m_szPath(%ws) Size(0x%x)\n",
                 this,
                 m_szPath?m_szPath:L"<Null Path>",
                 cbSize));

    return NOERROR;
}



//+---------------------------------------------------------------------------
//
//  Function:   GetClassFileEx
//
//  Synopsis:   returns the classid associated with a file
//
//  Arguments:  [lpszFileName] -- name of the file
//              [pcid]         -- where to return the clsid
//              [clsidOle1]    -- ole1 clsid to use (or CLSID_NULL)
//
//  Returns:    S_OK if clisd determined
//
//  Algorithm:
//
//  History:    1-16-94   kevinro   Created
//
//  Notes:  On Cairo, STGFMT_FILE will try to read the clsid from a file,
//          then do pattern matching, and then do extension matching.
//          For all other storage formats, pattern matching is skipped.
//          If at any point along the way we find a clsid, exit
//
//----------------------------------------------------------------------------
STDAPI GetClassFileEx( LPCWSTR lpszFileName, CLSID FAR *pcid,
                                             REFCLSID clsidOle1)
{
    VDATEPTRIN (lpszFileName, WCHAR);
    VDATEPTROUT (pcid, CLSID);


    LPCWSTR   szExt = NULL;
    HRESULT   hresult;
    HANDLE    hFile = INVALID_HANDLE_VALUE;
    BOOL      fRWFile = TRUE;
    DWORD     dwFileAttributes;
    DWORD     dwFlagsAndAttributes;

    //
    //  Don't crash when provided a bogus file path.
    //
    if (lpszFileName == NULL)
    {
        hresult =  MK_E_CANTOPENFILE;
        goto errRet;
    }

#ifdef _CAIRO_

    hresult = StgGetClassFile (NULL, lpszFileName, pcid, &hFile);

    if (hresult == NOERROR && !IsEqualIID(*pcid, CLSID_NULL))
    {
        //  we have a class id from the file
        goto errRet;
    }

    // In certain cases, StgGetClassFile (NtCreateFile) will fail
    // but CreateFile will successfully open a docfile or OFS storage.
    // In the docfile case, DfGetClass returns lock violation
    //    but Daytona ignores it, and checks the pattern & extensions
    // In the OFS case, GetNtHandle returns share violation
    //    but CreateFile will work, skip the pattern & check extensions
    // This is intended to emulate this odd behavior

    if (hresult != STG_E_LOCKVIOLATION &&
        hresult != STG_E_SHAREVIOLATION &&
        !SUCCEEDED(hresult))               // emulate CreateFile error
    {
            hresult = MK_E_CANTOPENFILE;
        goto errRet;
    }
#endif  // _CAIRO_

#ifndef _CAIRO_

    // open the file once, then pass the file handle to the various
    // subsystems (storage, pattern matching) to do the work.


    dwFlagsAndAttributes = 0;
    dwFileAttributes = GetFileAttributes(lpszFileName);
    if (dwFileAttributes != 0xFFFFFFFF) 
    {
        if (dwFileAttributes & FILE_ATTRIBUTE_REPARSE_POINT)
            dwFlagsAndAttributes |= FILE_FLAG_OPEN_NO_RECALL;
    }

    hFile = CreateFile(lpszFileName,    // file name
                      GENERIC_READ | FILE_WRITE_ATTRIBUTES,  // read/write access
                      FILE_SHARE_READ | FILE_SHARE_WRITE, // allow any other access
                      NULL,             // no sec descriptor
                      OPEN_EXISTING,    // fail if file doesn't exist
                      dwFlagsAndAttributes, // flags & attributes
                      NULL);            // no template

    if (INVALID_HANDLE_VALUE == hFile)
    {
        fRWFile = FALSE;
        hFile = CreateFile(lpszFileName,    // file name
                           GENERIC_READ,     // read only access
                           FILE_SHARE_READ | FILE_SHARE_WRITE, // allow any other access
                           NULL,             // no sec descriptor
                           OPEN_EXISTING,    // fail if file doesn't exist
                           dwFlagsAndAttributes,  // flags & attributes
                           NULL);            // no template

        if (INVALID_HANDLE_VALUE == hFile)
        {
            hresult = MK_E_CANTOPENFILE;
            goto errRet;
        }
    }

    if (fRWFile)
    {
        // Prevent modification of file times
        // NT System Call - set file information

        FILE_BASIC_INFORMATION basicInformation;
        basicInformation.CreationTime.QuadPart   = -1;
        basicInformation.LastAccessTime.QuadPart = -1;
        basicInformation.LastWriteTime.QuadPart  = -1;
        basicInformation.ChangeTime.QuadPart     = -1;
        basicInformation.FileAttributes          = 0;

        IO_STATUS_BLOCK IoStatusBlock;
        NTSTATUS Status = NtSetInformationFile(hFile, &IoStatusBlock,
                                               (PVOID)&basicInformation,
                                               sizeof(basicInformation),
                                               FileBasicInformation);
    }

    // First, check with storage to see if this a docfile. if it is,
    // storage will return us the clsid.

    hresult = DfGetClass(hFile, pcid);

    if (hresult == NOERROR && !IsEqualIID(*pcid, CLSID_NULL))
    {
        goto errRet;
    }

#endif // _CAIRO_

    // If this is an OLE1 file moniker, then use the CLSID given
    // to the moniker at creation time instead of using the
    // file extension.  Bug 3948.

    if (!IsEqualCLSID(clsidOle1,CLSID_NULL))
    {
        *pcid = clsidOle1;

        hresult = NOERROR;
        goto errRet;
    }

#ifdef _CAIRO_
    if (hFile != INVALID_HANDLE_VALUE)
    {
#endif

    // Attempt to find the class by matching byte patterns in
    // the file with patterns stored in the registry.

    hresult = wCoGetClassPattern(hFile, pcid);

    if (hresult != REGDB_E_CLASSNOTREG)
    {
        // either a match was found, or the file does not exist.
        goto errRet;
    }
#ifdef _CAIRO_
    }       // end if (hFile != INVALID_HANDLE_VALUE)
#endif


    //  The file is not a storage, there was no pattern matching, and
    //  the file exists. Look up the class for this extension.
    //  Find the extension by scanning backward from the end for ".\/!"
    //  There is an extension only if we find "."

    hresult = NOERROR;
    szExt = FindExt(lpszFileName);

    if (!szExt)
    {
        //  no file extension
        hresult = ResultFromScode(MK_E_INVALIDEXTENSION);
        goto errRet;
    }

    if (wCoGetClassExt(szExt, pcid) != 0)
    {
        hresult = ResultFromScode(MK_E_INVALIDEXTENSION);
    }


errRet:

    if (INVALID_HANDLE_VALUE != hFile)
    {
        CloseHandle(hFile);
    }

    if (hresult != NOERROR)
    {
        *pcid = CLSID_NULL;
    }

    return hresult;
}


//+---------------------------------------------------------------------------
//
//  Function:   GetClassFile
//
//  Synopsis:   returns the classid associated with a file
//
//  Arguments:  [lpszFileName] -- name of the file
//              [pcid]         -- where to return the clsid
//
//  Returns:    S_OK if clisd determined
//
//  Algorithm:  just calls GetClassFileEx
//
//  History:    1-16-94   kevinro   Created
//
//----------------------------------------------------------------------------
STDAPI GetClassFile( LPCWSTR lpszFileName, CLSID FAR *pcid )
{
    OLETRACEIN((API_GetClassFile, PARAMFMT("lpszFileName= %ws, pcid= %p"),
                                lpszFileName, pcid));

    HRESULT hr;

    hr = GetClassFileEx (lpszFileName, pcid, CLSID_NULL);

    OLETRACEOUT((API_GetClassFile, hr));

    return hr;
}


#ifdef _TRACKLINK_
STDMETHODIMP CFileMoniker::Reduce (LPBC pbc,
        DWORD dwReduceHowFar,
        LPMONIKER FAR* ppmkToLeft,
        LPMONIKER FAR * ppmkReduced)
{
        mnkDebugOut((DEB_ITRACE,
                 "CFileMoniker::Reduce(%x)\n",this));

        M_PROLOG(this);


        CLock2 lck(m_mxs);   // protect all internal state


        VDATEPTROUT(ppmkReduced,LPMONIKER);

        VDATEIFACE(pbc);
        if (ppmkToLeft)
        {
                VDATEPTROUT(ppmkToLeft,LPMONIKER);
                if (*ppmkToLeft) VDATEIFACE(*ppmkToLeft);
        }

        HRESULT hr=E_FAIL;
        IMoniker *pmkNew=NULL;
        BOOL fReduceToSelf = TRUE;

        *ppmkReduced = NULL;

        //
        // search for the file
        //

        if ( m_fTrackingEnabled && m_fReduceEnabled )
        {
            // Resolve the ShellLink object.

            hr = ResolveShellLink( FALSE  ); // fRefreshOnly
            if( S_OK == hr )
            {
                Assert(m_szPath != NULL);

                // Use the path that we now know is up-to-date, to create
                // a default (i.e., non-tracking) File Moniker.

                hr = CreateFileMoniker(m_szPath, ppmkReduced); // expensive

                if (hr == S_OK)
                    fReduceToSelf = FALSE;

            }   // if( SUCCEEDED( ResolveShellLink( FALSE )))
        }   // if ( m_fTrackingEnabled && m_fReduceEnabled )


        if (fReduceToSelf)
        {
            *ppmkReduced = this;
            AddRef();
            hr = MK_S_REDUCED_TO_SELF;
        }

        mnkDebugOut((DEB_TRACK,
                     "CFileMoniker(%x)::Reduce exit with hr=%08X.\n",
                     this,
                     hr));
        return(hr);
}
#endif


//+---------------------------------------------------------------------------
//
//  Function:   FileBindToObject
//
//  Synopsis:   Given a filename, and some other information, bind to the
//              file and load it.
//
//  Effects:    This routine is used to load an object when the caller to
//              CFileMoniker::BindToObject had provided its own bind context.

                //If pmkToLeft != 0, then we have a moniker on the left of the
                //file moniker. The file moniker will use pmkToLeft to bind to
                //either the IClassFactory or the IClassActivator interface.
                //
                //If protSystem != prot, then the bind context has supplied a
                //non-standard ROT.  CoGetInstanceFromFile and CoGetPersistentInstance
                //only search the standard ROT.  Therefore we cannot call
                //CoGetInstanceFromFile or CoGetPersistentInstance in this case.

//
//  Arguments:  [pmkThis] -- Moniker being bound
//              [pwzPath] -- Path to bind
//              [clsid] -- CLSID for path
//              [pbc] -- The bind context - Not ours! Make no assumptions
//              [pmkToLeft] -- Moniker to left
//              [riidResult] -- IID being requested
//              [ppvResult] -- punk for result
//
//----------------------------------------------------------------------------
INTERNAL FileBindToObject
    (LPMONIKER pmkThis,
    LPWSTR pwzPath,
    REFCLSID clsid,
    LPBC pbc,
    BIND_OPTS2 *pBindOptions,
    LPMONIKER pmkToLeft,
    REFIID riidResult,
    LPVOID FAR* ppvResult)
{
    HRESULT hr;
    LPPERSISTFILE pPF = NULL;

    *ppvResult = NULL;

    //Get an IPersistFile interface pointer.
    if(0 == pmkToLeft)
    {
        if ( pBindOptions->pServerInfo )
        {
            MULTI_QI    MultiQi;

            MultiQi.pIID = &IID_IPersistFile;
            MultiQi.pItf = 0;

            hr = CoCreateInstanceEx(clsid, NULL,
                                    pBindOptions->dwClassContext | CLSCTX_NO_CODE_DOWNLOAD,
                                    pBindOptions->pServerInfo,
                                    1, &MultiQi );

            pPF = (IPersistFile *) MultiQi.pItf;
        }
        else
        {
            hr = CoCreateInstance(clsid, NULL,
                                    pBindOptions->dwClassContext | CLSCTX_NO_CODE_DOWNLOAD,
                                    IID_IPersistFile,
                                    (void **) &pPF);
        }
    }
    else
    {
        IClassActivator *pActivator;
        IClassFactory *pFactory = 0;

        //Bind to IClassActivator interface.
        hr = pmkToLeft->BindToObject(pbc,
                                     0,
                                     IID_IClassActivator,
                                     (void **) &pActivator);

        if(SUCCEEDED(hr))
        {
            hr = pActivator->GetClassObject(clsid,
                                            pBindOptions->dwClassContext,
                                            pBindOptions->locale,
                                            IID_IClassFactory,
                                            (void **) &pFactory);
            pActivator->Release();
        }
        else
        {
            //Bind to the IClassFactory interface.
            hr = pmkToLeft->BindToObject(pbc,
                                         0,
                                         IID_IClassFactory,
                                         (void **) &pFactory);
        }

        if(SUCCEEDED(hr) && pFactory != 0)
        {
            //Create an instance and get the IPersistFile interface.
            hr = pFactory->CreateInstance(0,
                                          IID_IPersistFile,
                                          (void **) &pPF);
            pFactory->Release();
        }
    }

    //Load the instance from the file.
    if(SUCCEEDED(hr))
    {
        hr = pPF->Load(pwzPath, pBindOptions->grfMode);
        if (SUCCEEDED(hr))
        {
            hr = pPF->QueryInterface(riidResult, ppvResult);
        }
        pPF->Release();
    }
    else if(E_NOINTERFACE == hr)
    {
        hr = MK_E_INTERMEDIATEINTERFACENOTSUPPORTED;
    }

    return hr;
}


/*
BindToObject takes into account AutoConvert and TreatAs keys when
determining which class to use to bind.  It does not blindly use the
CLSID returned by GetClassFileEx.  This is to allow a new OLE2
server to service links (files) created with its previous OLE1 or OLE2
version.

This can produce some strange behavior in the follwoing (rare) case.
Suppose you have both an OLE1 version (App1) and an OLE2 version
(App2) of a server app on your machine, and the AutoConvert key is
present.  Paste link from App1 to an OLE2 container. The link will
not be connected because BindToObject will try to bind
using 2.0 behavior (because the class has been upgraded) rather than 1.0
behavior (DDE).  Ideally, we would call DdeIsRunning before doing 2.0
binding.  If you shut down App1, then you will be able to bind to
App2 correctly.
*/

STDMETHODIMP CFileMoniker::BindToObject ( LPBC pbc,
    LPMONIKER pmkToLeft, REFIID riidResult, LPVOID FAR* ppvResult)
{
    mnkDebugOut((DEB_ITRACE,"CFileMoniker(%x)::BindToObject\n",this));

    m_mxs.Request();
    BOOL    bGotLock = TRUE;

    wValidateMoniker();


    A5_PROLOG(this);
    VDATEPTROUT (ppvResult, LPVOID);
    *ppvResult = NULL;
    VDATEIFACE (pbc);
    if (pmkToLeft)
    {
        VDATEIFACE (pmkToLeft);
    }
    VDATEIID (riidResult);
    HRESULT hr;
    CLSID clsid;
    LPRUNNINGOBJECTTABLE prot = NULL;
    LPRUNNINGOBJECTTABLE protSystem = NULL;
    LPUNKNOWN pUnk = NULL;
    BIND_OPTS2 bindopts;
    BOOL fOle1Loaded;

    //Get the bind options from the bind context.
    bindopts.cbStruct = sizeof(bindopts);
    hr = pbc->GetBindOptions(&bindopts);

    if(FAILED(hr))
    {
        //Try the smaller BIND_OPTS size.
        bindopts.cbStruct = sizeof(BIND_OPTS);
        hr = pbc->GetBindOptions(&bindopts);
        if(FAILED(hr))
        {
            goto exitRtn;
        }
    }

    if(bindopts.cbStruct < sizeof(BIND_OPTS2))
    {
       //Initialize the new BIND_OPTS2 fields
       bindopts.dwTrackFlags = 0;
       bindopts.locale = GetThreadLocale();
       bindopts.pServerInfo = 0;

       bindopts.dwClassContext = CLSCTX_SERVER;
    }


    hr = GetRunningObjectTable(0,&protSystem);
    if(SUCCEEDED(hr))
    {
        // Get the Bind Contexts version of the ROT
        hr = pbc->GetRunningObjectTable( &prot );
        if(SUCCEEDED(hr))
        {

            // first snapshot some member data and unlock
            CLSID   TempClsid = m_clsid;
            LPWSTR  TempPath = (LPWSTR) alloca((m_ccPath + 1) * sizeof(WCHAR));
            olever  NewOleVer = m_ole1;
            BOOL    fUpdated = FALSE;


            lstrcpyW(TempPath, m_szPath);
            bGotLock = FALSE;
            m_mxs.Release();


            if((prot == protSystem)  && (0 == pmkToLeft))
            {
                //This is the normal case.
                //Bind to the object.
#ifdef DCOM
               MULTI_QI   QI_Block;
               QI_Block.pItf = NULL;
               QI_Block.pIID = &riidResult;
               CLSID * pClsid = &TempClsid;

               if ( IsEqualGUID( GUID_NULL, m_clsid ) )
                   pClsid = NULL;

               hr = CoGetInstanceFromFile(bindopts.pServerInfo,
                                         pClsid,
                                         NULL,
                                         bindopts.dwClassContext | CLSCTX_NO_CODE_DOWNLOAD,
                                         bindopts.grfMode,
                                         TempPath,
                                         1,
                                         &QI_Block);
               *ppvResult = (LPVOID) QI_Block.pItf;
#else // !DCOM
               hr = CoGetPersistentInstance(riidResult,
                                            bindopts.dwClassContext,
                                            bindopts.grfMode,
                                            TempPath,
                                            NULL,
                                            TempClsid,
                                            &fOle1Loaded,
                                            ppvResult);
#endif // !DCOM
            }
            else  // prot != protSystem or pmkToLeft exists
            {

                mnkDebugOut((DEB_ITRACE,"::BindToObject using non-standard ROT\n"));

                //Search the ROT for the object.
                hr = prot->GetObject(this, &pUnk);
                if (SUCCEEDED(hr))
                {
                    // Found in the ROT. Try and get the interface and return
                    mnkDebugOut((DEB_ITRACE,"::BindToObject Found object in ROT\n"));
                    hr = pUnk->QueryInterface(riidResult, ppvResult);
                    pUnk->Release();
                }
                else
                {
                    //Object was not found in the ROT.  Get the class ID,
                    //then load the object from the file.
                    mnkDebugOut((DEB_ITRACE,"::BindToObject doing old style bind\n"));

                    hr = GetClassFileEx (TempPath, &clsid,TempClsid);

                    if (hr == NOERROR)
                    {
                        UpdateClsid (&clsid); // See note above                        
                        if (CoIsOle1Class (clsid))
                        {
                            mnkDebugOut((DEB_ITRACE,
                                 "::BindToObject found OLE1.0 class\n"));

                            COleTls Tls;
                            if( Tls->dwFlags & OLETLS_DISABLE_OLE1DDE )
                            {
                                // If this app doesn't want or can tolerate having a DDE
                                // window then currently it can't use OLE1 classes because
                                // they are implemented using DDE windows.
                                //
                                hr = CO_E_OLE1DDE_DISABLED;
                            }
                            else  // DDE not disabled
                            {
                                hr = DdeBindToObject (TempPath,
                                                      clsid,
                                                      FALSE,
                                                      riidResult,
                                                      ppvResult);
                                {
                                    NewOleVer = ole1;
                                    TempClsid = clsid;
                                    m_fClassVerified = TRUE;
                                    fUpdated = TRUE;
                                }
                            }

                        }
                        else  // Not OLE 1 class
                        {
                            mnkDebugOut((DEB_ITRACE,
                                 "::BindToObject found OLE2.0 class\n"));
                            hr = FileBindToObject (this,
                                                TempPath,
                                                clsid,
                                                pbc,
                                                &bindopts,
                                                pmkToLeft,
                                                riidResult,
                                                ppvResult);
                            {
                                NewOleVer = ole2;
                                TempClsid = clsid;
                                m_fClassVerified = TRUE;
                                fUpdated = TRUE;
                            }
                        }
                    }
                    else
                    {
                        mnkDebugOut((DEB_ITRACE,
                                    "::BindToObject failed GetClassFileEx %x\n",
                                    hr));
                    }
                }
            }
            prot->Release();
            if (fUpdated)
            {
                // note that the lock is never held at this point...
                CLock2 lck(m_mxs);
                m_ole1 = NewOleVer;
                m_clsid = TempClsid;
            }
        }
        else
        {
            mnkDebugOut((DEB_ITRACE,
                         "::BindToObject failed pbc->GetRunningObjectTable() %x\n",
                         hr));
        }
        protSystem->Release();
    }
    else
    {
        mnkDebugOut((DEB_ITRACE,
                     "::BindToObject failed GetRunningObjectTable() %x\n",
                     hr));
    }


exitRtn:
    mnkDebugOut((DEB_ITRACE,
                 "CFileMoniker(%x)::BindToObject returns %x\n",
                 this,
                 hr));

    // make sure we exit with the lock clear in case of errors.
    if ( bGotLock )
        m_mxs.Release();

    return hr;
}


BOOL Peel( LPWSTR lpszPath, USHORT endServer, LPWSTR FAR * lplpszNewPath, ULONG n )
//  peels off the last n components of the path, leaving a delimiter at the
//  end.  Returns the address of the new path via *lplpszNewPath.  Returns
//  false if an error occurred -- e.g., n too large, trying to peel off a
//  volume name, etc.
{
WCHAR FAR* lpch;
ULONG i = 0;
ULONG j;
WCHAR FAR* lpszRemainingPath; // ptr to beginning of path name minus the share name

    if (*lpszPath == '\0') return FALSE;

    //
    // Find the end of the string and determine the string length.
    //

    for (lpch=lpszPath; *lpch; lpch++);

    DecLpch (lpszPath, lpch);   // lpch now points to the last real character

//  if n == 0, we dup the string, possibly adding a delimiter at the end.

    if (n == 0)
    {
        i = lstrlenW(lpszPath);

        if (!IsSeparator(*lpch))
        {
            j = 1;
        }
        else
        {
            j = 0;
        }

        *lplpszNewPath = (WCHAR *) PrivMemAlloc((i + j + 1) * sizeof(WCHAR));

        if (*lplpszNewPath == NULL)
        {
            return FALSE;
        }

        memcpy(*lplpszNewPath, lpszPath, i * sizeof(WCHAR));

        if (j == 1)
        {
            *(*lplpszNewPath + i) = '\\';
        }

        *(*lplpszNewPath + i + j)  = '\0';

        return TRUE;
    }


        if (DEF_ENDSERVER == endServer)
                        endServer = 0;

        lpszRemainingPath = lpszPath + endServer; // if endServer > 0 the remaining path will be in the form of \dir\file


#ifdef _DEBUG
        if (endServer)
        {
                Assert(lpszRemainingPath[0] == '\\');
        }
#endif // _DEBUG

        if (lpch < lpszRemainingPath)
        {
                AssertSz(0,"endServer Value is larger than Path");
                return FALSE;
        }

        for (i = 0; i < n; i++)
    {
        if (IsSeparator(*lpch))
        {
            DecLpch(lpszPath, lpch);
        }
        if ((lpch < lpszRemainingPath) || (*lpch == ':') || (IsSeparator(*lpch)))
        {
            return FALSE;
        }

        //  n is too large, or we hit two delimiters in a row, or a volume name.

        while( !IsSeparator(*lpch) && (lpch > lpszRemainingPath) )
        {
            DecLpch(lpszPath, lpch);
        }
    }

    //  lpch points to the last delimiter we will leave or lpch == lpszPath
    //  REVIEW:  make sure we haven't eaten into the volume name

    if (lpch == lpszPath)
    {
        *lplpszNewPath = (WCHAR *) PrivMemAlloc(1 * sizeof(WCHAR));

        if (*lplpszNewPath == NULL)
        {
            return FALSE;
        }

        **lplpszNewPath = '\0';
    }
    else
    {
        *lplpszNewPath = (WCHAR *) PrivMemAlloc(
            (ULONG) (lpch - lpszPath + 2) * sizeof(WCHAR));

        if (*lplpszNewPath == NULL) return FALSE;

        memcpy(*lplpszNewPath,lpszPath,(ULONG) (lpch - lpszPath + 1) * sizeof(WCHAR));
        *(*lplpszNewPath + (lpch - lpszPath) + 1) = '\0';
    }


    return TRUE;
}



STDMETHODIMP CFileMoniker::BindToStorage (LPBC pbc, LPMONIKER
    pmkToLeft, REFIID riid, LPVOID FAR* ppvObj)
{
    M_PROLOG(this);

    CLock2 lck(m_mxs);   // protect all internal state
    wValidateMoniker();

    VDATEPTROUT (ppvObj, LPVOID);
    *ppvObj = NULL;
    VDATEIFACE (pbc);

    if (pmkToLeft)
    {
        VDATEIFACE (pmkToLeft);
    }
    VDATEIID (riid);

    *ppvObj = NULL;
    HRESULT hresult = NOERROR;

    BIND_OPTS bindopts;
    bindopts.cbStruct = sizeof(BIND_OPTS);


    hresult = pbc->GetBindOptions(&bindopts);
    if FAILED(hresult)
        goto errRet;


    // Bind to the storage.

    if (IsEqualIID(riid, IID_IStorage))
    {
        hresult = StgOpenStorage( m_szPath, NULL, bindopts.grfMode, NULL, 0, (LPSTORAGE FAR*)ppvObj );
    }
    else if (IsEqualIID(riid, IID_IStream))
    {
        hresult = ResultFromScode(E_UNSPEC);  // unimplemented until CreateStreamOnFile is implemented

    }
    else if (IsEqualIID(riid, IID_ILockBytes))
    {
        hresult = ResultFromScode(E_UNSPEC);    //  unimplemented until CreateILockBytesOnFile is implemented
    }
    else
    {
        //  CFileMoniker:BindToStorage called for unsupported interface
        hresult = ResultFromScode(E_NOINTERFACE);
    }


    //  REVIEW:  CFileMoniker:BindToStorage being called for unsupported interface

errRet:
    return hresult;
}


//+---------------------------------------------------------------------------
//
//  Method:     CFileMoniker::ComposeWith
//
//  Synopsis:   Compose another moniker to the end of this
//
//  Effects:    Given another moniker, create a composite between this
//              moniker and the other. If the other is also a CFileMoniker,
//              then collapse the two monikers into a single one by doing a
//              concatenate on the two paths.
//
//  Arguments:  [pmkRight] --
//              [fOnlyIfNotGeneric] --
//              [ppmkComposite] --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:
//
//  History:    3-03-94   kevinro   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CFileMoniker::ComposeWith ( LPMONIKER pmkRight,
    BOOL fOnlyIfNotGeneric, LPMONIKER FAR* ppmkComposite)
{
    CLock2 lck(m_mxs);   // protect all internal state

    wValidateMoniker();
    M_PROLOG(this);
    VDATEPTROUT (ppmkComposite, LPMONIKER);
    *ppmkComposite = NULL;
    VDATEIFACE (pmkRight);

    HRESULT hresult = NOERROR;
    CFileMoniker FAR* pcfmRight;
    LPWSTR lpszLeft = NULL;
    LPWSTR lpszRight;
    LPWSTR lpszComposite;
    CFileMoniker FAR* pcfmComposite;
    int n1;
    int n2;

    *ppmkComposite = NULL;

    //
    // If we are being composed with an Anti-Moniker, then return
    // the resulting composition. The EatOne routine will take care
    // of returning the correct composite of Anti monikers (or NULL)
    //

    CAntiMoniker *pCAM = IsAntiMoniker(pmkRight);
    if(pCAM)
    {
        pCAM->EatOne(ppmkComposite);
        return(NOERROR);
    }

    //
    // If the moniker is a CFileMoniker, then collapse the two monikers
    // into one by doing a concate of the two strings.
    //

    if ((pcfmRight = IsFileMoniker(pmkRight)) != NULL)
    {
        lpszRight = pcfmRight->m_szPath;

        //  lpszRight may be NULL

        if (NULL == lpszRight)
            lpszRight = L"";

        if (( *lpszRight == 0) &&
            pcfmRight->m_cAnti == 0)
        {
            //  Second moniker is "".  Simply return the first.
            *ppmkComposite = this;
            AddRef();
            return NOERROR;
        }

        //
        // If the path on the right is absolute, then there is a
        // syntax error. The path is invalid, since you can't
        // concat d:\foo and d:\bar to get d:\foo\d:\bar and
        // expect it to work.
        //
        if (IsAbsolutePath(lpszRight))
        {
            return(MK_E_SYNTAX);
        }

        //
        // If the right moniker has m_cAnti != 0, then peel back
        // the path
        //

        if (Peel(m_szPath,m_endServer, &lpszLeft, pcfmRight->m_cAnti))
        {
            //  REVIEW:  check that there is no volume name at the start
            //  skip over separator

            while (IsSeparator(*lpszRight)) lpszRight++;

            n1 = lstrlenW(lpszLeft);

            n2 = lstrlenW(lpszRight);

            lpszComposite = (WCHAR *) PrivMemAlloc((n1 + n2 + 1)*sizeof(WCHAR));

            if (!lpszComposite)
            {
                hresult = E_OUTOFMEMORY;
            }
            else
            {
                memcpy(lpszComposite, lpszLeft, n1 * sizeof(WCHAR));
                memcpy(lpszComposite + n1, lpszRight, n2 * sizeof(WCHAR));

                lpszComposite[n1 + n2] = '\0';

                pcfmComposite = CFileMoniker::Create(lpszComposite,
                                         m_cAnti,m_endServer);

                if (pcfmComposite == NULL)
                {
                    hresult = E_OUTOFMEMORY;
                }

                else
                {
                    // Is tracking moniker?

                    {
                        *ppmkComposite = pcfmComposite;
                        pcfmComposite = NULL;
                    }

                }   // if (pcfmComposite == NULL) ... else


                PrivMemFree(lpszComposite);
            }   // if (!lpszComposite) ... else

            if ( lpszLeft != NULL)
            {
                PrivMemFree(lpszLeft);
            }
        }   // if (Peel(m_szPath, &lpszLeft, pcfmRight->m_cAnti))
        else
        {
            //  Peel failed, which means the caller attempted an
            //  invalid composition of file paths. There is apparently
            //  a syntax error in the names.
            //
            hresult = MK_E_SYNTAX;
        }   // if (Peel(m_szPath, &lpszLeft, pcfmRight->m_cAnti)) ... else
    }   // if ((pcfmRight = IsFileMoniker(pmkRight)) != NULL)
    else
    {
        if (!fOnlyIfNotGeneric)
        {
            hresult = CreateGenericComposite( this, pmkRight, ppmkComposite );
        }
        else
        {
            hresult = MK_E_NEEDGENERIC;
            *ppmkComposite = NULL;
        }
    }   // if ((pcfmRight = IsFileMoniker(pmkRight)) != NULL) ... else

    return hresult;
}


STDMETHODIMP CFileMoniker::Enum (THIS_ BOOL fForward, LPENUMMONIKER FAR* ppenumMoniker)
{
    M_PROLOG(this);
    VDATEPTROUT (ppenumMoniker, LPENUMMONIKER);
    *ppenumMoniker = NULL;
    //  REVIEW:  this says files monikers are not enumerable.
    return NOERROR;
}



STDMETHODIMP CFileMoniker::IsEqual (THIS_ LPMONIKER pmkOtherMoniker)
{
    HRESULT  hr = S_FALSE;

    mnkDebugOut((DEB_ITRACE,
                 "CFileMoniker::IsEqual(%x) m_szPath(%ws)\n",
                 this,
                 WIDECHECK(m_szPath)));

    ValidateMoniker();
    
    M_PROLOG(this);
    VDATEIFACE (pmkOtherMoniker);

    CFileMoniker FAR* pCFM = IsFileMoniker(pmkOtherMoniker);
    if (!pCFM)
    {
        return S_FALSE;
    }

    //Protect the internal state of both monikers.
    //To prevent deadlock, we must take the locks in a consistent order.
    if(this == pCFM)
    {
        return S_OK;
    }
    else if(this < pCFM)
    {
        m_mxs.Request();
        pCFM->m_mxs.Request();
    }
    else
    {
        pCFM->m_mxs.Request();
        m_mxs.Request();
    }

    if (pCFM->m_cAnti == m_cAnti)
    {
        mnkDebugOut((DEB_ITRACE,
                     "::IsEqual(%x) m_szPath(%ws) pOther(%ws)\n",
                     this,
                     WIDECHECK(m_szPath),
                     WIDECHECK(pCFM->m_szPath)));

        //  for the paths, we just do a case-insensitive compare.
        if (lstrcmpiW(pCFM->m_szPath, m_szPath) == 0)
        {
            hr = S_OK;
        }
    }

    m_mxs.Release();
    pCFM->m_mxs.Release();

    return hr;
}



//+---------------------------------------------------------------------------
//
//  Function:   CalcFileMonikerHash
//
//  Synopsis:   Given a LPWSTR, calculate the hash value for the string.
//
//  Effects:
//
//  Arguments:  [lp] -- String to compute has value for
//
//  Returns:
//      DWORD hash value for string.
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    1-15-94   kevinro   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
DWORD CalcFileMonikerHash(LPWSTR lp, ULONG cch)
{
    DWORD   dwTemp = 0;
    WCHAR   ch;
    ULONG   cbTempPath = (cch + 1) * sizeof(WCHAR);
    LPWSTR  pszTempPath = (LPWSTR) alloca(cbTempPath);


    if (lp == NULL || pszTempPath == NULL)
    {
        return 0;
    }

    //
    // toupper turns out to be expensive, since it takes a
    // critical section each and every time. It turns out to be
    // much cheaper to make a local copy of the string, then upper the
    // whole thing.
    //

    if (!cbTempPath)
        return 0;

    memcpy(pszTempPath, lp, cbTempPath);

    CharUpperW(pszTempPath);

    while (*pszTempPath)
    {
        dwTemp *= 3;
        ch = *pszTempPath;
        dwTemp ^= ch;
        pszTempPath++;
    }

    return dwTemp;
}

//+---------------------------------------------------------------------------
//
//  Method:     CFileMoniker::Hash
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:  [pdwHash] -- Output pointer for hash value
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:
//
//  History:    1-09-94   kevinro   Modified
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CFileMoniker::Hash (THIS_ LPDWORD pdwHash)
{
    CLock2 lck(m_mxs);   // protect m_fHashValueValid and m_dwHashValue
    wValidateMoniker();

    M_PROLOG(this);
    VDATEPTROUT (pdwHash, DWORD);

    //
    // Calculating the hash value is expensive. Cache it.
    //
    if (!m_fHashValueValid)
    {
        m_dwHashValue = m_cAnti + CalcFileMonikerHash(m_szPath, m_ccPath);

        m_fHashValueValid = TRUE;
    }

    *pdwHash = m_dwHashValue;

    wValidateMoniker();

    return(NOERROR);
}


//+---------------------------------------------------------------------------
//
//  Method:     CFileMoniker::IsRunning
//
//  Synopsis:   Determine if the object pointed to by the moniker is listed
//              as currently running.
//
//  Effects:
//
//  Arguments:  [pbc] --
//              [pmkToLeft] --
//              [pmkNewlyRunning] --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:
//
//  History:    3-03-94   kevinro   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CFileMoniker::IsRunning  (THIS_ LPBC pbc,
    LPMONIKER pmkToLeft,
    LPMONIKER pmkNewlyRunning)
{
    M_PROLOG(this);

    CLock2 lck(m_mxs);   // protect all internal state

    VDATEIFACE (pbc);
    LPRUNNINGOBJECTTABLE pROT;
    HRESULT hresult;

    //
    // According to the spec, CFileMoniker ignores the
    // moniker to the left.
    //
    if (pmkToLeft)
    {
        VDATEIFACE (pmkToLeft);
    }

    if (pmkNewlyRunning)
    {
        VDATEIFACE (pmkNewlyRunning);
    }


    CLSID clsid;

    if (IsOle1Class(&clsid))
    {
        return DdeIsRunning (clsid, m_szPath, pbc, pmkToLeft, pmkNewlyRunning);
    }



    if (pmkNewlyRunning != NULL)
    {
        return pmkNewlyRunning->IsEqual (this);
    }
    hresult = pbc->GetRunningObjectTable (&pROT);
    if (hresult == NOERROR)
    {
        hresult = pROT->IsRunning (this);
        pROT->Release ();
    }
    return hresult;
}



STDMETHODIMP CFileMoniker::GetTimeOfLastChange (THIS_ LPBC pbc, LPMONIKER pmkToLeft,
    FILETIME FAR* pfiletime)
{
    M_PROLOG(this);

    CLock2 lck(m_mxs);   // protect all internal state

    VDATEIFACE (pbc);
    if (pmkToLeft) VDATEIFACE (pmkToLeft);
    VDATEPTROUT (pfiletime, FILETIME);

    HRESULT hresult;

    LPMONIKER pmkTemp = NULL;
    LPRUNNINGOBJECTTABLE prot = NULL;
    LPWSTR lpszName = NULL;

    if (pmkToLeft == NULL)
    {
        pmkTemp = this;
        AddRef();
    }
    else
    {
        hresult = CreateGenericComposite(pmkToLeft, this, &pmkTemp );
        if (hresult != NOERROR)
        {
             goto errRet;
        }
    }

    hresult = pbc->GetRunningObjectTable(&prot);

    if (hresult != NOERROR)
    {
         goto errRet;
    }

    // Attempt to get the time-of-last-change from the ROT.  Note that
    // if there is a File Moniker in 'pmkTemp', the ROT will Reduce it.
    // Thus, if it is a *Tracking* File Moniker, it will be updated to reflect
    // any changes to the file (such as location, timestamp, etc.)

    hresult = prot->GetTimeOfLastChange(pmkTemp, pfiletime);

    if (hresult != MK_E_UNAVAILABLE)
    {
        goto errRet;
    }

    //
    // Why aren't we just looking in the file moniker to the left.
    // Is it possible to have another MKSYS_FILEMONIKER implementation?
    // [Just a suggestion; not a bug]
    //

    if (IsFileMoniker(pmkTemp))
    {
        hresult = pmkTemp->GetDisplayName(pbc, NULL, &lpszName);

        if (hresult != NOERROR)
        {
            goto errRet;
        }

        // Attempt to get the file's attributes.  If the file exists,
        // give the modify time to the caller.
        WIN32_FILE_ATTRIBUTE_DATA fad;

        if( GetFileAttributesEx( lpszName, GetFileExInfoStandard, &fad ))
        {
            memcpy(pfiletime, &fad.ftLastWriteTime, sizeof(FILETIME));
            hresult = S_OK;
        }
        else
        {
            hresult = ResultFromScode(MK_E_NOOBJECT);
        }
    }
    else
    {
        hresult = ResultFromScode(E_UNSPEC);
    }


errRet:

    if (prot != NULL)
    {
        prot->Release();
    }

    if (pmkTemp != NULL)
    {
        pmkTemp->Release();
    }

    if (lpszName != NULL)
    {
        CoTaskMemFree(lpszName);
    }

    return hresult;
}



STDMETHODIMP CFileMoniker::Inverse (THIS_ LPMONIKER FAR* ppmk)
{
    CLock2 lck(m_mxs);   // protect all internal state

    wValidateMoniker();

    M_PROLOG(this);
    VDATEPTROUT (ppmk, LPMONIKER);
    return CreateAntiMoniker(ppmk);
}



//+---------------------------------------------------------------------------
//
//  Function:   CompareNCharacters
//
//  Synopsis:   Compare N characters, ignoring case and sort order
//
//  Effects:    We are interested only in whether the strings are the same.
//              Unlike wcscmp, which determines the sort order of the strings.
//              This routine should save us some cycles
//
//  Arguments:  [pwcThis] --
//              [pwcOther] --
//              [n] --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    2-14-94   kevinro   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOL CompareNCharacters( LPWSTR pwcThis, LPWSTR pwcOther, ULONG n)
{
    while(n--)
    {
        if (CharUpperW((LPWSTR)*pwcThis) != CharUpperW((LPWSTR)*pwcOther))
        {
            return(FALSE);
        }
        pwcThis++;
        pwcOther++;
    }
    return(TRUE);
}

//+---------------------------------------------------------------------------
//
//  Function:   CopyNCharacters
//
//  Synopsis:   Copy N characters from lpSrc to lpDest
//
//  Effects:
//
//  Arguments:  [lpDest] -- Reference to lpDest
//              [lpSrc] -- Pointer to source characters
//              [n] --
//
//  Requires:
//
//  Returns:
//
//  Returns with lpDest pointing to the end of the string. The string will
//  be NULL terminated
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    2-14-94   kevinro   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
inline
void CopyNCharacters( LPWSTR &lpDest, LPWSTR lpSrc, ULONG n)
{
    memcpy(lpDest,lpSrc,sizeof(WCHAR)*n);
    lpDest += n;
    *lpDest = 0;
}


//+---------------------------------------------------------------------------
//
//  Function:   DetermineLongestString
//
//  Synopsis:   Used by CommonPrefixWith to handle case where one string may
//              be longer than the other.
//  Effects:
//
//  Arguments:  [pwcBase] --
//              [pwcPrefix] --
//              [pwcLonger] --
//
//  Requires:
//
//  Returns:    TRUE if all of pwcBase is a prefix of what pwcLonger is the
//              end of, or if tail of pwcBase is a separator.
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    2-14-94   kevinro   Created
//             03-27-94   darryla   Added special case where pwcPrefix is
//                                  pointing at terminator and previous char
//                                  is a separator.
//
//  Notes:
//
//  See CommonPrefixWith. This code isn't a general purpose routine, and is
//  fairly intimate with CommonPrefixWith.
//
//
//----------------------------------------------------------------------------
BOOL DetermineLongestString(    LPWSTR pwcBase,
                                LPWSTR &pwcPrefix,
                                LPWSTR pwcLonger)

{
    //
    // pwcPrefix is the end of the string that so far matches pwcLonger
    // as a prefix.
    //
    // If the next character in pwcLonger is a seperator, then pwcPrefix
    // is a complete prefix. Otherwise, we need to back pwcPrefix to the
    // next prevous seperator character
    //
    if (IsSeparator(*pwcLonger))
    {
        //
        // pwcPrefix is a true prefix
        //
        return TRUE;
    }

    // One more special case. If pwcPrefix is pointing at a terminator and
    // the previous char is a separator, then this, too, is a valid prefix.
    // It is easier to catch this here than to try to walk back to the
    // separator and then determine if it was at the end.
    if (*pwcPrefix == '\0' && IsSeparator(*(pwcPrefix - 1)))
    {
        //
        // pwcPrefix is a true prefix ending with a separator
        //
        return TRUE;
    }

    //
    // We now have a situtation where pwcPrefix holds a string that is
    // might not be a prefix of pwcLonger. We need to start backing up
    // until we find a seperator character.
    //

    LPWSTR pStart = pwcPrefix;

    while (pwcPrefix > pwcBase)
    {
        if (IsSeparator(*pwcPrefix))
        {
            break;
        }
        pwcPrefix--;
    }

    //
    // NULL terminate the output string.
    //

    *pwcPrefix = 0;

    //
    // If pStart == pwcPrefix, then we didn't actually back up anything, or
    // we just removed a trailing backslash. If so, return TRUE, since the
    // pwcPrefix is a prefix of pwcLonger
    //
    if (pStart == pwcPrefix)
    {
        return(TRUE);
    }

    return(FALSE);
}

//+---------------------------------------------------------------------------
//
//  Function:   IsEmptyString
//
//  Synopsis:   Determine if a string is 'Empty', which means either NULL
//              or zero length
//
//  Effects:
//
//  Arguments:  [lpStr] --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    2-25-94   kevinro   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
inline
BOOL IsEmptyString(LPWSTR lpStr)
{
    if ((lpStr == NULL) || (*lpStr == 0))
    {
        return(TRUE);
    }
    return(FALSE);
}


//+---------------------------------------------------------------------------
//
//  Method:     CFileMoniker::CommonPrefixWith
//
//  Synopsis:   Given two file monikers, determine the common prefix for
//              the two monikers.
//
//  Effects:    Computes a path that is the common prefix between the two
//              paths. It does this by string comparision, taking into
//              account the m_cAnti member, which counts the number of
//              preceeding dot dots constructs for each moniker.
//
//  Arguments:  [pmkOther] --
//              [ppmkPrefix] --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:
//
//  History:    2-10-94   kevinro   Created
//
//  Notes:
//
// Welcome to some rather hairy code. Actually, it isn't all that bad,
// there are just quite a few boundary cases that you will have to
// contend with. I am sure if I thought about it long enough, there is
// a better way to implement this routine. However, it really isn't
// worth the effort, given the frequency at which this API is called.
//
// I have approached this in a very straightforward way. There is
// room for optimization, but it currently isn't high enough on
// the priority list.
//
// File monikers need to treat the end server with care. We actually
// consider the \\server\share as a single component. Therefore, if
// the two monikers are \\savik\win40\foo and \\savik\cairo\foo,
// then \\savik is NOT a common prefix.
//
// Same holds true with the <drive>: case, where we need to treat
// the drive as a unit
//
// To determine if two monikers have a common prefix, we look
// down both paths watching for the first non-matching
// character. When we find it, we need determine the correct
// action to take.
//
// \\foo\bar and foo\bar shouldn't match
// c:\foo\bar and c:\foo should return c:\foo
// c:\foo\bar and c:\foobar should return c:\                               .
//
// Be careful to handle the server case.
//
// \\savik\win40 and
// \\savik\win40\src\foo\bar should return \\savik\win40
// while \\savik\cairo should return MK_E_NOPREFIX
//
//
//----------------------------------------------------------------------------
STDMETHODIMP CFileMoniker::CommonPrefixWith (LPMONIKER pmkOther, LPMONIKER FAR*
    ppmkPrefix)
{
    CLock2 lck(m_mxs);   // protect all internal state
    return wCommonPrefixWith( pmkOther, ppmkPrefix );
}

STDMETHODIMP CFileMoniker::wCommonPrefixWith (LPMONIKER pmkOther, LPMONIKER FAR*
    ppmkPrefix)
{
    wValidateMoniker();

    VDATEPTROUT (ppmkPrefix, LPMONIKER);
    *ppmkPrefix = NULL;
    VDATEIFACE (pmkOther);

    CFileMoniker FAR* pcfmOther = NULL;
    CFileMoniker FAR* pcfmPrefix = NULL;

    HRESULT hresult = NOERROR;
    USHORT cAnti;

    //
    // The following buffer will contain the matching prefix. We should
    // be safe in MAX_PATH, since neither path can be longer than that.
    // This was verified when the moniker was created, so no explicit
    // checking is done in this routine
    //

    WCHAR awcMatchingPrefix[MAX_PATH + 1];
    WCHAR *pwcPrefix = awcMatchingPrefix;

    //
    // Each subsection of the path will be parsed into the following
    // buffer. This allows us to match each section of the path
    // independently
    //

    WCHAR awcComponent[MAX_PATH + 1];
    WCHAR *pwcComponent = awcComponent;


    *pwcPrefix = 0;     // Null terminate the empty string
    *pwcComponent = 0;  // Null terminate the empty string

    //
    // A couple temporaries to walk the paths.
    //

    LPWSTR pwcThis = NULL;
    LPWSTR pwcOther = NULL;

    HRESULT hrPrefixType = S_OK;

    //
    // If the other moniker isn't 'one of us', then get the generic system
    // provided routine to handle the rest of this call.
    //

    if ((pcfmOther = IsFileMoniker(pmkOther)) == NULL)
    {
        return MonikerCommonPrefixWith(this, pmkOther, ppmkPrefix);
    }

    //
    // If the m_cAnti fields are different, then match the minimum number of
    // dotdots.
    //
    //
    if (pcfmOther->m_cAnti != m_cAnti)
    {
        //  differing numbers of ..\ at the beginning
        cAnti = (m_cAnti > pcfmOther->m_cAnti ? pcfmOther->m_cAnti :m_cAnti );

        if (cAnti == 0)
        {
            hresult = ResultFromScode(MK_E_NOPREFIX);
        }
        //  pcfmPrefix is NULL
        else
        {
            pcfmPrefix = CFileMoniker::Create(L"",
                                      cAnti);
            if (pcfmPrefix == NULL)
            {
                hresult = E_OUTOFMEMORY;
                goto exitRoutine;

            }

            //  we must check to see if the final result is that same as
            //  this or pmkOther

            hresult = NOERROR;

            if (cAnti == m_cAnti)
            {
                if ((m_szPath==NULL)||(*m_szPath == '\0'))
                {
                    hresult = MK_S_ME;
                }
            }
            else
            {
                if ((pcfmOther->m_szPath == NULL ) ||
                        (*(pcfmOther->m_szPath) == '\0') )
                {
                    hresult = MK_S_HIM;
                }
            }
        }

        goto exitRoutine;
    }

    //
    // The number of leading dot-dots match. Therefore, we need to
    // compare the paths also. If no path exists, then the common prefix
    // is going to be the 'dot-dots'
    //
    cAnti = m_cAnti;

    pwcThis = m_szPath;
    pwcOther = pcfmOther->m_szPath;


    //
    // If either pointer is empty, then only the dotdots make for a prefix
    //
    if (IsEmptyString(pwcThis) || IsEmptyString(pwcOther))
    {
        //
        // At least one of the strings was empty, therefore the common
        // prefix is only the dotdots. Determine if its US, ME, or HIM
        //

        if (IsEmptyString(pwcThis) && IsEmptyString(pwcOther))
        {
            hrPrefixType = MK_S_US;
        }
        else if (IsEmptyString(pwcThis))
        {
            hrPrefixType = MK_S_ME;
        }
        else
        {
            hrPrefixType = MK_S_HIM;
        }
        goto onlyDotDots;
    }

    //
    // The strings may be prefaced by either a UNC name, or a 'drive:'
    // We treat both of these as a unit, and will only match prefixes
    // on paths that match UNC servers, or match drives.
    //
    // If it is a UNC name, then m_endServer will be set to point at
    // the end of the UNC name.
    //
    // First part of the match is to determine if the end servers are even
    // close. If the offsets are different, the answer is no.
    //

    //
    // The assertion at this point is that neither string is 'empty'
    //
    Assert( !IsEmptyString(pwcThis));
    Assert( !IsEmptyString(pwcOther));

    if (m_endServer != pcfmOther->m_endServer)
    {
        //
        // End servers are different, match only the dotdots. Neither
        // string is a complete
        //

        hrPrefixType = S_OK;

        goto onlyDotDots;
    }

    //
    // If the end servers are the default value, then look to see if
    // this is an absolute path. Otherwise, copy over the server section
    //

    if (m_endServer == DEF_ENDSERVER)
    {
        BOOL fThisAbsolute = IsAbsoluteNonUNCPath(pwcThis);
        BOOL fOtherAbsolute = IsAbsoluteNonUNCPath(pwcOther);
        //
        // If both paths are absolute, check for matching characters.
        // If only one is absolute, then match the dot dots.
        //
        if (fThisAbsolute && fOtherAbsolute)
        {
            //
            // Both absolute paths (ie 'c:' at the front)
            // If not the same, only dotdots
            //
            if (CharUpperW((LPWSTR)*pwcThis) != CharUpperW((LPWSTR)*pwcOther))
            {
                //
                // The paths don't match
                //
                hrPrefixType = S_OK;
                goto onlyDotDots;
            }

            //
            // The <drive>: matched. Copy it over
            //
            CopyNCharacters(pwcPrefix,pwcThis,2);
            pwcThis += 2;
            pwcOther += 2;
        }
        else if (fThisAbsolute || fOtherAbsolute)
        {
            //
            // One path is absolute, the other isn't.
            // Match only the dots
            //
            hrPrefixType = S_OK;
            goto onlyDotDots;
        }

        //
        // The fall through case does more path processing
        //
    }
    else
    {
        //
        // m_endServer is a non default value. Check to see if the
        // first N characters match. If they don't, then only match
        // the dotdots. If they do, copy them to the prefix buffer
        //

        if (!CompareNCharacters(pwcThis,pwcOther,m_endServer))
        {
            //
            // The servers didn't match.
            //
            hrPrefixType = S_OK;
            goto onlyDotDots;
        }

        //
        // The UNC paths matched, copy them over
        //

        CopyNCharacters(pwcPrefix,pwcThis,m_endServer);

        pwcThis += m_endServer;
        pwcOther += m_endServer;
    }

    //
    // Handle the root directory case. If BOTH monikers start
    // with a backslash, then copy this to the prefix section.
    // This allows for having '\foo' and '\bar' have the common
    // prefix of '\'. The code below this section will remove
    // any trailing backslashes.
    //
    // This also takes care of the case where you have a
    // drive: or \\server\share, followed by a root dir.
    // In either of these cases, we should return
    // drive:\ or \\server\share\ respectively
    //

    if ((*pwcThis == '\\') && (*pwcOther == '\\'))
    {
        *pwcPrefix = '\\';
        pwcThis++;
        pwcOther++;
        pwcPrefix++;
        *pwcPrefix = 0;
    }



    //
    // At this point, we have either matched the drive/server section,
    // or have an empty string. Time to start copying over the rest
    // of the data.
    //

    //
    // Walk down the strings, looking for the first non-matching
    // character
    //

    while (1)
    {
        if ((*pwcThis == 0) || (*pwcOther == 0))
        {
            //
            // We have hit the end of one or both strings.
            // awcComponent holds all of the matching
            // characters so far. Break out of the loop
            //
            break;
        }
        if (CharUpperW((LPWSTR)*pwcThis) != CharUpperW((LPWSTR)*pwcOther))
        {
            //
            // This is the first non-matching character.
            // We should break out here.
            //
            break;
        }

        //
        // At this point, the characters match, and are part
        // of the common prefix. Copy it to the string, and move on
        //

        *pwcComponent = *pwcThis;
        pwcThis++;
        pwcOther++;
        pwcComponent++;

        //
        // NULL terminate the current version of the component string
        //
        *pwcComponent = '\0';
    }

    //
    // If both strings are at the end, then we have a
    // complete match.
    //

    if ((*pwcThis == 0) && (*pwcOther == 0))
    {
        //
        // Ah, this feels good. The strings ended up being
        // the same length, with all matching characters.
        //
        // Therefore, we can just return one of us as the
        // result.
        //
        pcfmPrefix = this;
        AddRef();
        hresult = MK_S_US;
        goto exitRoutine;
    }

    //
    // If one of the strings is longer than the other...
    //
    if ((*pwcThis == 0) || (*pwcOther == 0))
    {
        //
        // Test to see if the next character in the longer string is a
        // seperator character. If it isn't, then back up the string to
        // the character before the previous seperator character.
        //
        // If TRUE then the shorter of the strings ends up being the
        // entire prefix.
        //
        //
        if( DetermineLongestString( awcComponent,
                                    pwcComponent,
                                    (*pwcThis == 0)?pwcOther:pwcThis) == TRUE)
        {
            if (*pwcThis == 0)
            {
                //
                // This is the entire prefix
                //
                pcfmPrefix = this;
                hresult = MK_S_ME;
            }
            else
            {
                //
                // The other guy is the entire prefix
                //
                pcfmPrefix = pcfmOther;
                hresult = MK_S_HIM;
            }
            pcfmPrefix->AddRef();
            goto exitRoutine;
        }
    }
    else
    {
        //
        // Right now, pwcThis and pwcOther point at non-matching characters.
        // Given the above tests, we know that neither character is
        // == 0.
        //
        // Backup the string to the previous seperator. To do this, we
        // will use DetermineLongestString, and pass it the string that
        // doesn't have a seperator
        //

        DetermineLongestString( awcComponent,
                                pwcComponent,
                                IsSeparator(*pwcThis)?pwcOther:pwcThis);
    }


    //
    // At this point, awcsComponent holds the second part of the string,
    // while awcsPrefix holds the server or UNC prefix. Either of these
    // may be NULL. Append awcComponent to the end of awcPrefix.
    //

    CopyNCharacters( pwcPrefix, awcComponent, (ULONG) (pwcComponent - awcComponent));


    //
    // Check to see if anything matched.
    //

    if (pwcPrefix == awcMatchingPrefix)
    {
        //
        // The only matching part is the dotdot count.
        // This is easy, since we can just create a new
        // moniker consisting only of dotdots.
        //
        // However, if there are no preceeding dotdots,
        // then there was absolutely no prefix, which means
        // we return MK_E_NOPREFIX
        //
        if (cAnti == 0)
        {
            hresult = MK_E_NOPREFIX;
            goto exitRoutine;

        }

        //
        // Nothing special about the moniker, so just return S_OK
        //

        hrPrefixType = S_OK;
        goto onlyDotDots;

    }

    //
    // Create a new file moniker using the awcMatchingPrefix
    //

    pcfmPrefix = CFileMoniker::Create(awcMatchingPrefix,0,cAnti);

    if (pcfmPrefix == NULL)
    {
        hresult = E_OUTOFMEMORY;
        goto exitRoutine;
    }
    hresult = S_OK;

exitRoutine:
    *ppmkPrefix = pcfmPrefix;   //  null, or a file moniker
    return hresult;


onlyDotDots:
    //
    // We have determined that only the dotdot's match, so create a
    // new moniker with the appropriate number of them.
    //
    // If there are no dotdots, then return NULL
    //

    if (cAnti == 0)
    {
        hresult = MK_E_NOPREFIX;
        goto exitRoutine;
    }

    pcfmPrefix = CFileMoniker::Create(L"",0,cAnti);

    if (pcfmPrefix == NULL)
    {
        hresult = E_OUTOFMEMORY;
    }
    else
    {
        hresult = hrPrefixType;
    }

    goto exitRoutine;
}



//+---------------------------------------------------------------------------
//
//  Method:     CFileMoniker::RelativePathTo
//
//  Synopsis:   Compute a relative path to the other moniker
//
//  Effects:
//
//  Arguments:  [pmkOther] --
//              [ppmkRelPath] --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:
//
//  History:    2-24-94   kevinro   Created
//
//  Notes:
//
//  (KevinRo)
//  This routine was really bad, and didn't generate correct results (aside
//  from the fact that it faulted). I replaced it with a slightly less
//  effiecient, but correct implementation.
//
//  This can be improved on, but I currently have time restraints, so I am
//  not spending the needed amount of time. What really needs to happen is
//  the code that determines the common path prefix string from
//  CommonPrefixWith() should be broken out so this routine can share it.
//
//  Thats more work that I can do right now, so we will just call CPW,
//  and use its result to compute the relative path. This results in an
//  extra moniker creation (allocate and construct only), but will work
//
//----------------------------------------------------------------------------
STDMETHODIMP CFileMoniker::RelativePathTo (THIS_ LPMONIKER pmkOther,
                                           LPMONIKER FAR*
                                           ppmkRelPath)
{
    CLock2 lck(m_mxs);   // protect all internal state

    wValidateMoniker();

    M_PROLOG(this);
    VDATEPTROUT (ppmkRelPath, LPMONIKER);
    *ppmkRelPath = NULL;
    VDATEIFACE (pmkOther);

    HRESULT hr;
    CFileMoniker FAR* pcfmPrefix;
    LPWSTR lpszSuffix;
    LPWSTR lpszOther;

    CFileMoniker FAR* pcfmRelPath = NULL;
    CFileMoniker FAR* pcfmOther = IsFileMoniker(pmkOther);

    if (!pcfmOther)
    {
        return MonikerRelativePathTo(this, pmkOther, ppmkRelPath, TRUE);
    }

    //
    // Determine the common prefix between the two monikers. This generates
    // a moniker which has a path that is the prefix between the two
    // monikers
    //

    hr = CommonPrefixWith(pmkOther,(IMoniker **)&pcfmPrefix);

    //
    // If there was no common prefix, then the relative path is 'him'
    //
    if (hr == MK_E_NOPREFIX)
    {
        *ppmkRelPath = pmkOther;
        pmkOther->AddRef();

        return MK_S_HIM;
    }

    if (FAILED(hr))
    {
        *ppmkRelPath = NULL;
        return(hr);
    }

    //
    // At this point, the common prefix to the two monikers is in pcfmPrefix
    // Since pcfmPrefix is a file moniker, we know that m_ccPath is the
    // number of characters that matched in both moniker paths. To
    // compute the relative part, we use the path from pmkOther, minus the
    // first pcfmPrefix->m_ccPath characters.
    //
    // We don't want to start with a seperator. Therefore, skip over the
    // first set of seperator characters. (Most likely, there aren't any).
    //

    lpszOther = pcfmOther->m_szPath + pcfmPrefix->m_ccPath;
    lpszSuffix = m_szPath + pcfmPrefix->m_ccPath;

    while ((*lpszSuffix != 0) && IsSeparator(*lpszSuffix))
    {
         lpszSuffix++;
    }

    //
    // Create new file moniker that holds the prefix.
    //

    pcfmRelPath = CFileMoniker::Create(lpszOther,
                                       (USHORT) CountSegments(lpszSuffix));

    //
    // At this point, we are all done with the prefix
    //

    pcfmPrefix->Release();

    if (pcfmRelPath == NULL)
    {
        *ppmkRelPath = NULL;
        return ResultFromScode(S_OOM);
    }

    *ppmkRelPath = pcfmRelPath;
    return NOERROR;

}

//+---------------------------------------------------------------------------
//
//  Method:     CFileMoniker::GetDisplayNameLength
//
//  Synopsis:   Returns the length of the display name if GenerateDisplayName
//              was called
//
//  Effects:
//
//  Returns:    Length of display name in bytes
//
//  Algorithm:
//
//  History:    3-16-95   kevinro   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
ULONG
CFileMoniker::GetDisplayNameLength()
{
    CLock2 lck(m_mxs);   // protect all internal state

    // Number of characters in path plus number of anti components plus NULL
    // All times the size of WCHAR
    //
    // Anti components look like '..\' in the string. 3 characters
    ULONG ulLength = (m_ccPath + (3 * m_cAnti) + 1) * sizeof(WCHAR);

    return(ulLength);
}

//+---------------------------------------------------------------------------
//
//  Method:     CFileMoniker::GenerateDisplayName, private
//
//  Synopsis:   Generates a display name for this moniker.
//
//  Effects:
//
//  Arguments:  [pwcDisplayName] -- A buffer that is at least as long as
//                                  GetDisplayNameLength
//
//  Returns:    void
//
//  Algorithm:
//
//  History:    3-16-95   kevinro   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
void
CFileMoniker::GenerateDisplayName(LPWSTR pwcDisplayName)
{
    Assert(pwcDisplayName != NULL);

    //
    // The display name may need 'dotdots' at the front
    //
    for (USHORT i = 0; i < m_cAnti; i++)
    {
        memcpy(pwcDisplayName, L"..\\", 3 * sizeof(WCHAR));
        pwcDisplayName += 3;
    }

    //
    //  don't duplicate '\' since the anti monikers may
    //  have already appended one. Copy rest of string
    //  over, including the NULL
    //

    if (m_cAnti > 0 && *m_szPath == '\\')
    {
        memcpy(pwcDisplayName, m_szPath + 1, m_ccPath * sizeof(WCHAR));
    }
    else
    {
        memcpy(pwcDisplayName, m_szPath, (m_ccPath + 1) * sizeof(WCHAR));
    }
}

STDMETHODIMP CFileMoniker::GetDisplayName ( LPBC pbc, LPMONIKER
    pmkToLeft, LPWSTR FAR * lplpszDisplayName )
{

    HRESULT         hr  = E_FAIL;

    CLock2 lck(m_mxs);   // protect all internal state

    wValidateMoniker();
    M_PROLOG(this);
    VDATEPTROUT (lplpszDisplayName, LPWSTR);
    *lplpszDisplayName = NULL;
    VDATEIFACE (pbc);
    if (pmkToLeft)
    {
        VDATEIFACE (pmkToLeft);
    }

    int n;
    LPWSTR pch;
    LPWSTR pchSrc;
    DWORD cchSrc;
    DWORD ulLen;


    ulLen = GetDisplayNameLength();

    //
    // cchSrc is the number of characters including the NULL. This will
    // always be half the number of bytes.
    //

    cchSrc = ulLen >> 1;

    (*lplpszDisplayName) = (WCHAR *) CoTaskMemAlloc(ulLen);

    pch = *lplpszDisplayName;

    if (!pch)
    {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    //
    // Call a common routine to generate the initial display name
    //
    GenerateDisplayName(pch);

    // If we're in WOW, return short path names so that 16-bit apps
    // don't see names they're not equipped to handle.  This also
    // affects 32-bit inproc DLLs in WOW; they'll need to be written
    // to handle it
    if (IsWOWProcess())
    {
        DWORD cchShort, cchDone;
        LPOLESTR posCur;

        posCur = *lplpszDisplayName;

        // GetShortPathName only works on files that exist.  Monikers
        // don't have to refer to files that exist, so if GetShortPathName
        // fails we just return whatever the moniker has as a path

        // Special case zero-length paths since the length returns from
        // GetShortPathName become ambiguous when zero characters are processed
        cchShort = lstrlenW(posCur);
        if (cchShort > 0)
        {
            cchShort = GetShortPathName(posCur, NULL, 0);
        }

        if (cchShort != 0)
        {
            LPOLESTR posShort;

            // GetShortPathName can convert in place so if our source
            // string is long enough, don't allocate a new string
            if (cchShort <= cchSrc)
            {
                posShort = posCur;
                cchShort = cchSrc;
            }
            else
            {
                posShort = (LPOLESTR)CoTaskMemAlloc(cchShort*sizeof(WCHAR));
                if (posShort == NULL)
                {
                    CoTaskMemFree(posCur);
                    *lplpszDisplayName = NULL;
                    hr = E_OUTOFMEMORY;
                    goto Exit;
                }
            }
            cchDone = GetShortPathName(posCur, posShort, cchShort);

            // For both success and failure cases we're done with posCur,
            // so get rid of it (unless we've reused it for the short name)
            if (posShort != posCur)
            {
                CoTaskMemFree(posCur);
            }

            if (cchDone == 0 || cchDone > cchShort)
            {
                CoTaskMemFree(posShort);
                *lplpszDisplayName = NULL;
                hr = E_OUTOFMEMORY;
                goto Exit;
            }

            *lplpszDisplayName = posShort;
        }
    }

    hr = NOERROR;

Exit:

    return( hr );

}



//+---------------------------------------------------------------------------
//
//  Method:     CFileMoniker::ParseDisplayName
//
//  Synopsis:   Bind to object, and ask it to parse the display name given.
//
//  Effects:
//
//  Arguments:  [pbc] --        Bind context
//              [pmkToLeft] --  Moniker to the left
//              [lpszDisplayName] -- Display name to be parsed
//              [pchEaten] --   Outputs the number of characters parsed
//              [ppmkOut] --    Output moniker
//
//  Requires:
//      File-monikers never have monikers to their left
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:
//
//  History:    2-02-94   kevinro   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CFileMoniker::ParseDisplayName ( LPBC pbc,
                                              LPMONIKER pmkToLeft,
                                              LPWSTR lpszDisplayName,
                                              ULONG FAR* pchEaten,
                                              LPMONIKER FAR* ppmkOut)
{

    HRESULT hresult;
    IParseDisplayName * pPDN = NULL;
    CLSID cid;

    VDATEPTROUT (ppmkOut, LPMONIKER);

    *ppmkOut = NULL;

    VDATEIFACE (pbc);

    if (pmkToLeft)
    {
        VDATEIFACE (pmkToLeft);
    }

    VDATEPTRIN (lpszDisplayName, WCHAR);
    VDATEPTROUT (pchEaten, ULONG);

    //
    // Since this is the most frequent case, try binding to the object
    // itself first
    //

    hresult = BindToObject( pbc,
                            pmkToLeft,
                            IID_IParseDisplayName,
                            (VOID FAR * FAR *)&pPDN );

    // we deferred doing this lock until after the BindToObject, in case the
    // BindToObject is very slow.  It manages locking internally to itself.
    CLock2 lck(m_mxs);   // protect all internal state


    // If binding to the object failed, then try binding to the class object
    // asking for the IParseDisplayName interface
    if (FAILED(hresult))
    {
        hresult = GetClassFile(m_szPath, &cid);

        if (SUCCEEDED(hresult))
        {
            hresult = CoGetClassObject(cid,
                                       CLSCTX_INPROC | CLSCTX_NO_CODE_DOWNLOAD,
                                       NULL,
                                       IID_IParseDisplayName,
                                       (LPVOID FAR*)&pPDN);
        }
        if (FAILED(hresult))
        {
            goto errRet;
        }
    }

    //
    // Now that we have bound this object, we register it with the bind
    // context. It will be released with the bind context release.
    //

    hresult = pbc->RegisterObjectBound(pPDN);

    if (FAILED(hresult))
    {
        goto errRet;
    }

    //
    // As the class code to parse the rest of the display name for us.
    //

    hresult = pPDN->ParseDisplayName(pbc,
                                     lpszDisplayName,
                                     pchEaten,
                                     ppmkOut);
errRet:
    if (pPDN) pPDN->Release();
    return hresult;
}


STDMETHODIMP CFileMoniker::IsSystemMoniker (THIS_ LPDWORD pdwType)
{
    M_PROLOG(this);
    VDATEPTROUT (pdwType, DWORD);
    *pdwType = MKSYS_FILEMONIKER;
    return NOERROR;
}

//+---------------------------------------------------------------------------
//
//  Method:     CFileMoniker::ValidateAnsiPath
//
//  Synopsis:   This function validates the ANSI version of the path. Intended
//              to be used to get the serialized Ansi version of the path.
//
//              This function also detects when a Long File Name exists, and
//              must be dealt with.
//
//  Effects:
//
//      This routine will set the Ansi path suitable for serializing
//      into the stream. This path may just use the stored ANSI path,
//      or may be a path that was created from the UNICODE version.
//
//      If the ANSI version of the path doesn't exist, then the UNICODE
//      version of the path is converted to ANSI. There are several possible
//      conversions.
//
//      First, if the path uses a format that is > 8.3, then the path to
//      be serialized needs to be the alternate name. This allows the
//      downlevel systems to access the file using the short name. This step
//
//      If the UNICODE path is all ANSI characters already (no DBCSLeadBytes),
//      then the path is converted by doing a simple truncation algorithm.
//
//      If the UNICODE path contains large characters, or DBCSLeadBytes,
//      then the routine will create a UNICODE extent, then try to convert
//      the UNICODE string into a ANSI path. If some of the characters
//      won't convert, then those characters are represented by an ANSI
//      character constant defined in the registry.
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//              m_pszAnsiPath
//              m_cbAnsiPath
//
//  Derivation:
//
//  Algorithm:
//
//  History:    1-09-94   kevinro   Created
//              05-24-94    AlexT   Use GetShortPathNameW
//
//  Notes:
//
//      The path created may not actually be useful. It is quite possible
//      for there to be a path that will not convert correctly from UNICODE
//      to Ansi. In these cases, this routine will create a UNICODE extent.
//
//----------------------------------------------------------------------------

HRESULT CFileMoniker::ValidateAnsiPath(void)
{
    HRESULT hr = NOERROR;
    CLock2 lck(m_mxs);   // protect m_pszAnsiPath, and m_cbAnsiPath
                       // also AddExtent (needed since mutext was removed from CExtentList).

    wValidateMoniker();

    mnkDebugOut((DEB_ITRACE,
                 "GetAnsiPath(%x) m_szPath(%ws)\n",
                 this,
                 m_szPath?m_szPath:L"<NULL>"));



    BOOL  fFastConvert = FALSE;

    //
    // If there is no path, return NULL
    //
    if (m_szPath == NULL)
    {
        goto NoError;
    }

    //
    // If there is already an ANSI path, return, we are OK.
    //

    if (m_pszAnsiPath != NULL)
    {
        goto NoError;
    }

    //  We can't call GetShortPathName with a NULL string.  m_szPath can
    //  be "" as the result of CoCreateInstance of a file moniker or as
    //  the result of RelativePathTo being called on an identical file moniker
    if ('\0' != *m_szPath)
    {
        OLECHAR szShortPath[MAX_PATH];
        DWORD dwBytesCopied;

        dwBytesCopied = GetShortPathName(m_szPath, szShortPath, MAX_PATH);

        if (dwBytesCopied > 0 && dwBytesCopied <= MAX_PATH)
        {
            hr = MnkUnicodeToMulti(szShortPath,
                                   (USHORT) lstrlenW(szShortPath),
                                   m_pszAnsiPath,
                                   m_cbAnsiPath,
                                   fFastConvert);
            if (FAILED(hr))
            {
                mnkDebugOut((DEB_ITRACE,
                            "MnkUnicodeToMulti failed (%x) on %ws\n",
                            WIDECHECK(szShortPath)));
                goto ErrRet;
            }
        }

#if DBG==1
        if (0 == dwBytesCopied)
        {
            mnkDebugOut((DEB_ITRACE,
                        "GetShortPathName failed (%x) on %ws\n",
                         GetLastError(),
                         WIDECHECK(szShortPath)));

            //  let code below handle the path
        }
        else if (dwBytesCopied > MAX_PATH)
        {
            mnkDebugOut((DEB_ITRACE,
                        "GetShortPathName buffer not large enough (%ld, %ld)\n",
                         MAX_PATH, dwBytesCopied,
                         WIDECHECK(szShortPath)));

            //  let code below handle the path
        }
#endif  //  DBG==1
    }

    //
    // If there is no m_pszAnsiPath yet, then just convert
    // the UNICODE path to the ANSI path
    //
    if (m_pszAnsiPath == NULL)
    {
        //
        // There was no alternate file name
        //
        hr = MnkUnicodeToMulti(  m_szPath,
                                 m_ccPath,
                                 m_pszAnsiPath,
                                 m_cbAnsiPath,
                                 fFastConvert);
        if (FAILED(hr))
        {
            goto ErrRet;
        }
    }
    else
    {
        //
        // We have an alternate name. By setting
        // fFastConvert to be FALSE, we force the
        // following code to add a UNICODE extent
        // if one doesn't exist.
        //
        fFastConvert = FALSE;
    }

    //
    // If an extent doesn't already exist, and it wasn't a fast
    // conversion, create a UNICODE extent.
    //
    if ( !m_fUnicodeExtent && !fFastConvert)
    {
        LPMONIKEREXTENT pExtent = NULL;

        hr = CopyPathToUnicodeExtent(m_szPath,m_ccPath,pExtent);

        if (FAILED(hr))
        {
            goto ErrRet;
        }

        hr = m_ExtentList.AddExtent(pExtent);

        PrivMemFree(pExtent);

        if (FAILED(hr))
        {
            goto ErrRet;
        }
    }

NoError:

    mnkDebugOut((DEB_ITRACE,
                 "GetAnsiPath(%x) m_pszAnsiPath(%s) m_cbAnsiPath(0x%x)\n",
                 this,
                 m_pszAnsiPath?m_pszAnsiPath:"<NULL>",
                 m_cbAnsiPath));
    return(NOERROR);

ErrRet:
        mnkDebugOut((DEB_IERROR,
                 "GetAnsiPath(%x) Returning error hr(%x)\n",
                 this,
                 hr));

        if (m_pszAnsiPath != NULL)
        {
        PrivMemFree(m_pszAnsiPath);

        m_pszAnsiPath = NULL;
        m_cbAnsiPath = 0;

    }
    wValidateMoniker();

    return(hr);
}

//+---------------------------------------------------------------------------
//
//  Function:   MnkUnicodeToMulti
//
//  Synopsis:   Convert a Unicode path to an Ansi path.
//
//  Effects:
//
//  Arguments:  [pwcsWidePath] --  Unicode path
//              [ccWidePath] --    Wide character count
//              [pszAnsiPath] --   Reference
//              [cbAnsiPath] --    ref number of bytes in ANSI path incl NULL
//              [fFastConvert] --  Returns TRUE if fast conversion
//
//  Requires:
//
//  Returns:
//
//      pszAnsiPath was allocated using PrivMemAlloc
//
//      fFastConvert means that the ANSI and UNICODE paths were converted
//      by WCHAR->CHAR truncation.
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    1-16-94   kevinro   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT
MnkUnicodeToMulti(LPWSTR        pwcsWidePath,
                  USHORT        ccWidePath,
                  LPSTR &       pszAnsiPath,
                  USHORT &      cbAnsiPath,
                  BOOL &        fFastConvert)
{

    HRESULT hr = NOERROR;
    ULONG cb;
    BOOL  fUsedDefaultChar = FALSE;

    WCHAR *lp = pwcsWidePath;

    fFastConvert = TRUE;

    if (pwcsWidePath == NULL)
    {
        cbAnsiPath = 0;
        pszAnsiPath = 0;
        return(NOERROR);
    }

    //
    // Lets hope for the best. If we can run the length of the
    // unicode string, and all the characters are 1 byte long, and
    // there are no conflicts with DBCSLeadBytes, then we
    // can cheat and just do a truncation copy
    //


    while ( (*lp != 0) && (*lp == (*lp & 0xff)) && !IsDBCSLeadByte((BYTE) (*lp & 0xff)))
    {
        lp++;
    }
    if (*lp == 0)
    {
        //
        // We are at the end of the string, and we are safe to do our
        // simple copy. We will assume the ANSI version of the path is
        // going to have the same number of characters as the wide path
        //
        pszAnsiPath = (char *)PrivMemAlloc(ccWidePath + 1);

        if (pszAnsiPath == NULL)
        {
            hr = E_OUTOFMEMORY;
            goto ErrRet;
        }

        USHORT i;

        //
        // By doing i <= m_ccPath, we pick up the NULL
        //

        for (i = 0 ; i <= ccWidePath ; i++ )
        {
            pszAnsiPath[i] = (CHAR) (pwcsWidePath[i] & 0xff);
        }

        //
        // We just converted to a single byte path. The cb is the
        // count of WideChar + 1 for the NULL
        //
        cbAnsiPath = ccWidePath + 1;

        goto NoError;
    }

    //
    // At this point, all of the easy out options have expired. We
    // must convert the path the hard way.
    //

    fFastConvert = FALSE;

    mnkDebugOut((DEB_ITRACE,
                 "MnkUnicodeToMulti(%ws) doing path conversions\n",
                 pwcsWidePath?pwcsWidePath:L"<NULL>"));

    //
    // We haven't a clue how large this path may be in bytes, other
    // than some really large number. So, we need to call and find
    // out the correct size to allocate for the path.
    //
    cb = WideCharToMultiByte(AreFileApisANSI() ? CP_ACP : CP_OEMCP,
                             WC_COMPOSITECHECK | WC_DEFAULTCHAR,
                             pwcsWidePath,
                             ccWidePath + 1,    // Convert the NULL
                             NULL,
                             0,
                             NULL,
                             &fUsedDefaultChar);

    if (cb == 0)
    {
        //
        // Hmmm... Can't convert anything. Sounds like the downlevel
        // guys are flat out of luck. This really isn't a hard error, its
        // just an unfortunate fact of life. This is going to be a very
        // rare situation, but one we need to handle gracefully
        //

        pszAnsiPath = NULL;
        cbAnsiPath = 0;
    }
    else
    {
        //
        // cb holds the number of bytes required for the output path
        //
        pszAnsiPath = (char *)PrivMemAlloc(cb + 1);

        if (pszAnsiPath == NULL)
        {
            hr = E_OUTOFMEMORY;
            goto ErrRet;
        }
        cbAnsiPath = (USHORT)cb;

        cb = WideCharToMultiByte(AreFileApisANSI() ? CP_ACP : CP_OEMCP,
                                 WC_COMPOSITECHECK | WC_DEFAULTCHAR,
                                 pwcsWidePath,
                                 ccWidePath + 1, // Convert the NULL
                                 pszAnsiPath,
                                 cbAnsiPath,
                                 NULL,
                                 &fUsedDefaultChar);
        //
        // Again, if there was an error, its just unfortunate
        //
        if (cb == 0)
        {
            PrivMemFree(pszAnsiPath);
            pszAnsiPath = NULL;
            cbAnsiPath = 0;
        }
    }

NoError:

    return(NOERROR);

ErrRet:

    if (pszAnsiPath != NULL)
    {
        PrivMemFree(pszAnsiPath);

        pszAnsiPath = NULL;

        cbAnsiPath = 0;
    }

    return(hr);
}

//+---------------------------------------------------------------------------
//
//  Function:   MnkMultiToUnicode
//
//  Synopsis:   Converts a MultiByte string to a Unicode string
//
//  Effects:
//
//  Arguments:  [pszAnsiPath] --        Path to convert
//              [pWidePath] --          Output path
//              [ccWidePath] --         Size of output path
//              [ccNewString] --        Reference characters in new path
//                                      including the NULL
//              [nCodePage] --          Must be CP_ACP || CP_OEMCP.  This is
//                                      the first code page to be used in
//                                      the attempted conversion.  If the
//                                      conversion fails, the other CP is
//                                      tried.
//
//  Requires:
//
//      if pWidePath != NULL, then this routine uses pWidePath as the return
//      buffer, which should be ccWidePath in length.
//
//      Otherwise, it will allocate a buffer on your behalf.
//
//  Returns:
//
//      pWidePath != NULL
//              ccNewString == number of characters in new path include NULL
//
//      pWidePath == NULL (NULL string)
//
//      if ccNewString returns 0, then pWidePath may not be valid. In this
//      case, there are no valid characters in pWidePath.
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    1-16-94   kevinro   Created
//              2-3-95    scottsk   Added nCodePage param
//
//  Notes:
//
//  Why so complex you ask? In the file moniker case, we want know that the
//  buffer can be MAX_PATH in length, so we pass a stack buffer in to handle
//  it. In the CItemMoniker case, the limit jumps to 32767 bytes, which is
//  too big to declare on the stack. I wanted to use the same routine for
//  both, since we may end up changing this later.
//
//  Passing in your own buffer is best for this routine.
//
//----------------------------------------------------------------------------
HRESULT MnkMultiToUnicode(LPSTR         pszAnsiPath,
                          LPWSTR &      pWidePath,
                          ULONG         ccWidePath,
                          USHORT &      ccNewString,
                          UINT          nCodePage)
{
        LPWSTR  pwcsTempPath = NULL;
        HRESULT hr;

        Assert(nCodePage == CP_ACP || nCodePage == CP_OEMCP);

        //
        // If the pszAnsiPath is NULL, then so should be the UNICODE one
        //
        if (pszAnsiPath == NULL)
        {
            ccNewString = 0;
            return(NOERROR);
        }

        Assert( (pWidePath == NULL) || (ccWidePath > 0));

        //
        // If the buffer is NULL, be sure that ccWide is zero
        //
        if (pWidePath == NULL)
        {
            ccWidePath = 0;
        }


ConvertAfterAllocate:
        ccNewString = (USHORT) MultiByteToWideChar(nCodePage,
                                         MB_PRECOMPOSED,
                                         pszAnsiPath,
                                         -1,
                                         pWidePath,
                                         ccWidePath);
        if (ccNewString == FALSE)
        {
            mnkDebugOut((DEB_IERROR,
                         "::MnkMultiToUnicode failed on (%s) err (%x)\n",
                         pszAnsiPath,
                         GetLastError()));
            //
            // We were not able to convert to UNICODE.
            //
                hr = E_UNEXPECTED;
                goto errRet;
        }


        //
        // ccNewString holds the total string length, including the terminating
        // NULL.
        //

        if (pWidePath == NULL)
        {
            //
            // The first time through did no allocations. Allocate the
            // correct buffer, and actually do the conversion
            //

            pWidePath = (WCHAR *)PrivMemAlloc(sizeof(WCHAR)*ccNewString);

            if (pWidePath == NULL)
            {
                hr = E_OUTOFMEMORY;
                goto errRet;
            }

            pwcsTempPath = pWidePath;
            ccWidePath = ccNewString;
            goto ConvertAfterAllocate;
        }

        //
        // ccNewString holds the total number of characters converted,
        // including the NULL. We really want it to have the count of
        // characeters
        //

        Assert (ccNewString != 0);

        ccNewString--;

        hr = NOERROR;
        return(hr);

errRet:
        mnkDebugOut((DEB_IERROR,
                 "::MnkMultiToUnicode failed on (%s) err (%x)\n",
                 pszAnsiPath,
                 GetLastError()));

        PrivMemFree(pwcsTempPath);
        return(hr);

}
//+---------------------------------------------------------------------------
//
//  Method:     CFileMoniker::DetermineUnicodePath
//
//  Synopsis:   Given the input path, determine the path to store and use
//              as the initialized path.
//
//  Effects:
//
//      When loading or creating a CFileMoniker, its possible that the 'path'
//      that was serialized is not valid. This occurs when the original
//      UNICODE path could not be translated into ANSI. In this case, there
//      will be a MONIKEREXTENT that holds the original UNICODE based path.
//
//      If a UNICODE extent exists, then the path will be ignored, and the
//      path in the extent will be used.
//
//      If a UNICODE extent doesn't exist, then the path will be translated
//      into UNICODE. In theory, this will not fail, since there is supposed
//      to always be a mapping from ANSI to UNICODE (but not the inverse).
//      However, it is possible that the conversion will fail because the
//      codepage needed to translate the ANSI path to UNICODE may not be
//      loaded.
//
//      In either case, the CFileMoniker::m_szPath should return set
//      with some UNICODE path set. If not, then an error is returned
//
//  Arguments:  [pszPath] --    The ANSI version of the path.
//              [pWidePath] --  Reference to pointer recieving new path
//              [cbWidePath]--  Length of new path
//
//  Requires:
//
//  Returns:
//              pWidePath is returned, as allocated from PrivMemAlloc
//              cbWidePath holds length of new path
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:
//
//  History:    1-08-94   kevinro   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT
CFileMoniker::DetermineUnicodePath(LPSTR pszAnsiPath,
                                   LPWSTR & pWidePath,
                                   USHORT &ccWidePath)
{

    wValidateMoniker();

    mnkDebugOut((DEB_ITRACE,
                 "DetermineUnicodePath(%x) pszAnsiPath(%s)\n",
                 this,
                 pszAnsiPath));

    HRESULT hr = NOERROR;

    //
    // Check to see if a MONIKEREXTENT exists with mnk_UNICODE
    //

    MONIKEREXTENT UNALIGNED *pExtent = m_ExtentList.FindExtent(mnk_UNICODE);

    //
    // Normal fall through case is no UNICODE path, which means that there
    // was a conversion between mbs and unicode in the original save.
    //
    if (pExtent == NULL)
    {
        m_fUnicodeExtent = FALSE;

        //
        // If the pszAnsiPath is NULL, then so should be the UNICODE one
        //
        if (pszAnsiPath == NULL)
        {
            pWidePath = NULL;
            ccWidePath = 0;
            return(NOERROR);
        }

        //
        // It turns out to be cheaper to just assume a MAX_PATH size
        // buffer, and to copy the resulting string. We use MAX_PATH + 1
        // so we always have room for the terminating NULL
        //

        WCHAR awcTempPath[MAX_PATH+1];
        WCHAR *pwcsTempPath = awcTempPath;

        hr = MnkMultiToUnicode( pszAnsiPath,
                                pwcsTempPath,
                                MAX_PATH+1,
                                ccWidePath,
                                AreFileApisANSI() ? CP_ACP : CP_OEMCP);


        if (FAILED(hr))
        {
            goto errRet;
        }

        pWidePath = (WCHAR *)PrivMemAlloc(sizeof(WCHAR)*(ccWidePath+1));

        if (pWidePath == NULL)
        {
            hr = E_OUTOFMEMORY;
            goto errRet;
        }

        memcpy(pWidePath,pwcsTempPath,(ccWidePath+1)*sizeof(WCHAR));

        hr = NOERROR;

    }
    else
    {
        //
        // Get the UNICODE path from the extent.
        //

        mnkDebugOut((DEB_ITRACE,
                     "DeterminePath(%x) Found UNICODE extent\n",
                     this));

        m_fUnicodeExtent = TRUE;

        hr = CopyPathFromUnicodeExtent(pExtent,pWidePath,ccWidePath);
    }


errRet:


    if (FAILED(hr))
    {
        if (pWidePath != NULL)
        {
            PrivMemFree(pWidePath);
        }

        mnkDebugOut((DEB_IERROR,
                     "DeterminePath(%x) ERROR: Returning %x\n",
                     this,
                     hr));
    }
    else
    {
        mnkDebugOut((DEB_ITRACE,
                     "DeterminePath(%x) pWidePath(%ws) ccWidePath(0x%x)\n",
                     this,
                     pWidePath?pWidePath:L"<NULL PATH>",
                     ccWidePath));

    }

    return(hr);
}

//+---------------------------------------------------------------------------
//
//  Method:     CFileMoniker::GetComparisonData
//
//  Synopsis:   Get comparison data for registration in the ROT
//
//  Arguments:  [pbData] - buffer to put the data in.
//              [cbMax] - size of the buffer
//              [pcbData] - count of bytes used in the buffer
//
//  Returns:    NOERROR
//              E_OUTOFMEMORY
//
//  Algorithm:  Build ROT data for file moniker. This puts the classid
//              followed by the display name.
//
//  History:    03-Feb-95   ricksa  Created
//
// Note:        Validating the arguments is skipped intentionally because this
//              will typically be called internally by OLE with valid buffers.
//
//----------------------------------------------------------------------------
STDMETHODIMP CFileMoniker::GetComparisonData(
    byte *pbData,
    ULONG cbMax,
    DWORD *pcbData)
{
    mnkDebugOut((DEB_ITRACE,
                 "_IN GetComparisionData(%x,%x,%x) for CFileMoniker(%ws)\n",
                 pbData,
                 cbMax,
                 *pcbData,
                 m_szPath));

    CLock2 lck(m_mxs);   // protect all internal state

    ULONG ulLength = sizeof(CLSID_FileMoniker) + GetDisplayNameLength();

    Assert(pcbData != NULL);
    Assert(pbData != NULL);

    if (cbMax < ulLength)
    {
        mnkDebugOut((DEB_ITRACE,
                     "OUT GetComparisionData() Buffer Too Small!\n"));

        return(E_OUTOFMEMORY);
    }

    memcpy(pbData,&CLSID_FileMoniker,sizeof(CLSID_FileMoniker));

    GenerateDisplayName((WCHAR *)(pbData+sizeof(CLSID_FileMoniker)));

    //
    // Insure this is an upper case string.
    //
    CharUpperW((WCHAR *)(pbData+sizeof(CLSID_FileMoniker)));

    *pcbData = ulLength;

    mnkDebugOut((DEB_ITRACE,
                 "OUT GetComparisionData() *pcbData == 0x%x\n",
                 *pcbData));

    return NOERROR;
}

//+---------------------------------------------------------------------------
//
//  Method:     CTrackingFileMoniker::*
//
//  Synopsis:   These members implement ITrackingMoniker on behalf of
//              the file moniker.
//
//  Algorithm:  The CTrackingFileMoniker object has a pointer to
//              the CFileMoniker object and forwards any QI's (other than
//              ITrackingMoniker) and AddRefs/Releases to the CFileMoniker.
//
//----------------------------------------------------------------------------

#ifdef _TRACKLINK_
VOID
CTrackingFileMoniker::SetParent(CFileMoniker *pCFM)
{
    _pCFM = pCFM;
}

STDMETHODIMP CTrackingFileMoniker::QueryInterface(REFIID riid, void **ppv)
{
    if (IsEqualIID(IID_ITrackingMoniker, riid))
    {
        *ppv = (ITrackingMoniker*) this;
        _pCFM->AddRef();
        return(S_OK);
    }
    else
        return(_pCFM->QueryInterface(riid, ppv));
}

STDMETHODIMP_(ULONG) CTrackingFileMoniker::AddRef()
{
    return(_pCFM->AddRef());
}

STDMETHODIMP_(ULONG) CTrackingFileMoniker::Release()
{
    return(_pCFM->Release());
}

STDMETHODIMP CTrackingFileMoniker::EnableTracking( IMoniker *pmkToLeft, ULONG ulFlags )
{
    return(_pCFM->EnableTracking(pmkToLeft, ulFlags));
}
#endif

#ifdef _DEBUG
STDMETHODIMP_(void) NC(CFileMoniker,CDebug)::Dump ( IDebugStream FAR * pdbstm)
{
    VOID_VDATEIFACE(pdbstm);

    *pdbstm << "CFileMoniker @" << (VOID FAR *)m_pFileMoniker;
    *pdbstm << '\n';
    pdbstm->Indent();
    *pdbstm << "Refcount is " << (int)(m_pFileMoniker->m_refs) << '\n';
    *pdbstm << "Path is " << m_pFileMoniker->m_szPath << '\n';
    *pdbstm << "Anti count is " << (int)(m_pFileMoniker->m_cAnti) << '\n';
    pdbstm->UnIndent();
}



STDMETHODIMP_(BOOL) NC(CFileMoniker,CDebug)::IsValid ( BOOL fSuspicious )
{
    return ((LONG)(m_pFileMoniker->m_refs) > 0);
    //  add more later, maybe
}
#endif

//+---------------------------------------------------------------------------
//
//  Method:     CFileMoniker::RestoreShellLink, private
//
//  Synopsis:   Restore a ShellLink object by creating it, and
//              loading the object's persistent state from the Extent
//              of this Moniker (where the state was saved by an earlier
//              instantiation).
//
//  Arguments:  pfExtentNotFound (optional)
//                  When this method fails, this argument can be checked
//                  to see if the failure was because the extent
//                  didn't exist.
//
//  Returns:    [HRESULT]
//                  -   S_FALSE:  the shell link had already been restored.
//
//  Algorithm:  If ShellLink object doesn't already exist
//                  GetShellLink()
//                  Load ShellLink object from moniker Extent.
//                  On Error,
//                      Release ShellLink
//
//  Notes:      -   This routine does not restore the information
//                  in mnk_TrackingInformation.  This is restored
//                  in Load().
//
//----------------------------------------------------------------------------

INTERNAL CFileMoniker::RestoreShellLink( BOOL *pfExtentNotFound )
{

    MONIKEREXTENT UNALIGNED *   pExtent;
    LARGE_INTEGER               li0;
    ULARGE_INTEGER              uli;
    HRESULT                     hr = E_FAIL;
    IStream *                   pstm = NULL;
    IPersistStream *            pps = NULL;

    if( NULL != pfExtentNotFound )
        *pfExtentNotFound = FALSE;

    // If we've already, successfully, initialized the shell link object,
    // then we're done.

    if( m_fShellLinkInitialized )
    {
        hr = S_FALSE;
        goto Exit;
    }

    // Create the ShellLink object.

    if( FAILED( hr = GetShellLink() ))
        goto Exit;
    Assert( m_pShellLink != NULL );

    //
    // Load ShellLink from Extent list by
    // writing the MONIKEREXTENT to an in memory stream and then doing
    // IPersistStream::Load.
    //

    pExtent = m_ExtentList.FindExtent(mnk_ShellLink);
    if (pExtent == NULL)    // no extent, exit.
    {
        // Let the caller know that we failed because the extent doesn't exist.
        if( NULL != pfExtentNotFound )
            *pfExtentNotFound = TRUE;

        mnkDebugOut((DEB_TRACK,
                 "CFileMoniker(%x)::RestoreShellLink no shell link in extent.\n",
                     this));
        hr = E_FAIL;
        goto Exit;
    }

    if (S_OK != (hr=CreateStreamOnHGlobal(NULL, TRUE, &pstm)))
    {
        mnkDebugOut((DEB_TRACK,
                 "CFileMoniker(%x)::RestoreShellLink CreateStreamOnHGlobal failed %08X.\n",
                     this,
                     hr));
        goto Exit;
    }

    if (S_OK != (hr=pstm->Write(((char*)pExtent)+MONIKEREXTENT_HEADERSIZE,
        pExtent->cbExtentBytes,
        NULL)))
    {
        mnkDebugOut((DEB_TRACK,
                 "CFileMoniker(%x)::RestoreShellLink pstm->Write failed %08X.\n",
                     this,
                     hr));
        goto Exit;
    }

    // Get the Shell Link's IPersistStream interface, and
    // load it with the data from the Extent.

    Verify(S_OK == m_pShellLink->QueryInterface(IID_IPersistStream,
        (void**)&pps));

    memset(&li0, 0, sizeof(li0));
    Verify(S_OK == pstm->Seek(li0, STREAM_SEEK_SET, &uli));
    Assert(uli.LowPart == 0 && uli.HighPart == 0);

    if (S_OK != (hr=pps->Load(pstm)))
    {
        mnkDebugOut((DEB_TRACK,
                 "CFileMoniker(%x)::RestoreShellLink pps->Load failed %08X.\n",
                     this,
                     hr));
        goto Exit;
    }

    m_fShellLinkInitialized = TRUE;

    mnkDebugOut((DEB_TRACK,
                 "CFileMoniker(%x)::RestoreShellLink successfully loaded shell link (%08X) from extent.\n",
                 this,
                 m_pShellLink));

    //  ----
    //  Exit
    //  ----

Exit:

    if( FAILED( hr ))
    {
        if( m_pShellLink )
        {
            m_pShellLink->Release();
            m_pShellLink = NULL;
        }
    }

    return( hr );

}   // RestoreShellLink()




//+---------------------------------------------------------------------------
//
//  Method:     CFileMoniker::SetPathShellLink, private
//
//  Synopsis:   Set the path in the ShellLink object.
//
//  Arguments:  [void]
//
//  Returns:    [HRESULT]
//                  -   S_OK:  The path is set successfully.
//                  -   S_FALSE:  The path was not set.
//
//  Algorithm:  If a SetPath isn't necessary/valid, exit (S_OK).
//              Get the ShellLink object (create if necessary)
//              Perform IShellLink->SetPath()
//              If this succeeds, set the m_fShellLinkInitialized
//
//  Notes:      Setting the path in the ShellLink object causes it to
//              read data (attributes) from the file.  This data makes that
//              file trackable later on if the file is moved.  This routine
//              can be called any number of times, since it exits early if
//              it has executed sucessfully before.  Success is indicated by
//              the m_fShellLinkInitialized flag.
//
//----------------------------------------------------------------------------


INTERNAL CFileMoniker::SetPathShellLink()
{

    HRESULT          hr = S_FALSE;
    IPersistStream*  pps = NULL;

    //  ----------
    //  Initialize
    //  ----------

    // If the path has already been set, then we needn't do anything.
    if( m_fShellLinkInitialized )
    {
        hr = S_OK;
        goto Exit;
    }

    // If necessary, create the ShellLink object.
    if( FAILED( hr = GetShellLink() ))
        goto Exit;
    Assert( m_pShellLink != NULL );

    //  ------------------------------
    //  Set the path of the shell link
    //  ------------------------------

    hr = m_pShellLink->SetPath( m_szPath );

    // Was the link source missing?
    if (S_FALSE == hr)
    {
        mnkDebugOut((DEB_TRACK,
                 "CFileMoniker(%x)::SetPathShellLink(%ls) -- readtrackinginfo -- NOT FOUND\n",
                 this,
                 m_szPath));
    }

    else if (SUCCEEDED(hr))
    {

        // Remember that we've done this so we won't have to again.

        m_fShellLinkInitialized = TRUE;

        // Set the moniker's dirty bit according to the ShellLink's
        // dirty bit.  (It should be dirty.)

        Verify (S_OK == m_pShellLink->
            QueryInterface(IID_IPersistStream, (void**)&pps));
        if (pps->IsDirty() == S_OK)
        {
            m_fDirty = TRUE;
        }
        else
        {
            mnkDebugOut((DEB_TRACK,
                     "CFileMoniker(%x)::SetPathShellLink(%ls) -- IsDirty not dirty\n",
                     this,
                     m_szPath));

        }

    }   // ShellLink->SetPath ... if (SUCCEEDED(hr))
    else
    {
        mnkDebugOut((DEB_TRACK,
             "CFileMoniker(%x)::SetPathShellLink(%ls) -- m_pShellLink->SetPath failed %08X.\n",
                 this,
                 m_szPath,
                 hr));

    }   // ShellLink->SetPath ... if (SUCCEEDED(hr)) ... else


    //  ----
    //  Exit
    //  ----

Exit:

    if( pps )
        pps->Release();

    return( hr );
}   // CFileMoniker::SetPathShellLink()


//+---------------------------------------------------------------------------
//
//  Method:     CFileMoniker::ResolveShellLink, private
//
//  Synopsis:   Perform an IShellLink->Resolve, and updates the data
//              in this moniker accordingly.
//
//  Arguments:  [IBindCtx*] pbc
//                  -   The caller's bind context.
//
//  Outputs:    [HRESULT]
//                  S_OK if the link is successfully resolved.
//                  S_FALSE if the link is not resolved, but there were no errors.
//
//  Algorithm:  Get the caller's Bind_Opts
//              Get IShellLinkTracker from the ShellLink object.
//              Perform IShellLinkTracker->Resolve
//              Set the dirty flag if necessary.
//              If we found a new path
//                  ReInitialize this moniker with the new path.
//
//  Notes:      This routine does not restore the information in
//              mnk_TrackingInformation.  The information is restored
//              Load().
//
//----------------------------------------------------------------------------

INTERNAL CFileMoniker::ResolveShellLink( BOOL fRefreshOnly )
{

    HRESULT             hr = E_FAIL;
    IPersistStream*     pps = NULL;
    WCHAR*              pwszWidePath = NULL;   // Path in Unicode format
    USHORT              ccNewString = 0;
    DWORD               dwTrackFlags = 0L;
    DWORD               dwTickCountDeadline = 0L;
    USHORT              ccPathBufferSize = 0;
    DWORD               dwResolveFlags = 0;


    // Restore the shell link, if it hasn't been already.

    if( FAILED( hr = RestoreShellLink(NULL) ))
        goto Exit;

    Assert( m_pShellLink != NULL );

    // Figure out the resolve flags.  The 0xFFFF0000
    // is a test hook to indicate that the timeout should
    // be read from the registry.

    dwResolveFlags = 0xFFFF0000 | SLR_ANY_MATCH | SLR_NO_UI;

    if( fRefreshOnly )
    {
        // If the file exists, update the shortcut's cached
        // information (object ID, create date, file size, etc.).
        // If it doesn't exist, don't go looking for it.

        dwResolveFlags |= SLR_NOTRACK | SLR_NOSEARCH | SLR_NOLINKINFO;
    }

    // Finally, resolve the link.


    if (S_OK != (hr = m_pShellLink->Resolve( GetDesktopWindow(), dwResolveFlags )))
    {
        mnkDebugOut((DEB_TRACK,
                 "CFileMoniker(%x)::ResolveShellLink IShellLink->Resolve failed %08X.\n",
                     this,
                     hr));
        goto Exit;
    }


    //
    // The above Resolve may have made the Shell Link object dirty,
    // in which case this FileMoniker should be dirty as well.
    //

    Verify(S_OK == m_pShellLink->QueryInterface(IID_IPersistStream,
                                                (void**)&pps));

    if (pps->IsDirty() == S_OK)
    {
        m_fDirty = TRUE;
    }


    //
    // We appear to have found a matching file.  We will
    // check that we can activate it properly before updating
    // the file moniker's internal path.
    // Before we can attempt activation we might have to get the
    // path into unicode.
    //
    ccPathBufferSize = sizeof( WCHAR ) * MAX_PATH + sizeof( L'\0' );

    pwszWidePath = (WCHAR*)PrivMemAlloc( ccPathBufferSize );
    if (pwszWidePath == NULL)
    {
        hr = E_OUTOFMEMORY;
        mnkDebugOut((DEB_TRACK,
                 "CFileMoniker(%x)::ResolveShellLink PrivMemAlloc failed.\n",
                     this));
        goto Exit;
    }

    WIN32_FIND_DATA fd;
    if (S_OK != (hr=m_pShellLink->GetPath(pwszWidePath,
                MAX_PATH, &fd, IsWOWProcess() ? SLGP_SHORTPATH : 0)))

    {
        mnkDebugOut((DEB_TRACK,
                 "CFileMoniker(%x)::ResolveShellLink m_pShellLink->GetPath failed %08X.\n",
                     this,
                     hr));
        goto Exit;
    }

	pwszWidePath[(ccPathBufferSize / sizeof(WCHAR)) - 1] = 0;

    ccNewString = (USHORT) -1;

    // Verify that we received an actual path from IShellLink::GetPath.
    if (*pwszWidePath == L'\0' || ccNewString == 0)
    {
        mnkDebugOut((DEB_TRACK,
                 "CFileMoniker(%x)::ResolveShellLink MnkUnicodeToMulti failed 2 %08X.\n",
                     this,
                     hr));
        hr = E_FAIL;
        goto Exit;
    }

    //
    // If the path to the linked file has changed, update the internal
    // state of this File Moniker.
    //

    if( lstrcmpW( pwszWidePath, m_szPath )) // Cmp wide path; Ansi may not exist.
    {

        // Re-initialize this moniker with the new
        // path.  We will save and restore the fClassVerified, because
        // if it is set we might avoid a redundant verification.

        BOOL fClassVerified = m_fClassVerified;

        if( !Initialize(m_cAnti,
                        NULL,
                        0,
                        pwszWidePath,
                        (USHORT) lstrlenW( pwszWidePath ),
                        m_endServer )
          )
        {
            mnkDebugOut((DEB_TRACK,
                         "CFileMoniker(%x)::ResolveShellLink Initialize (with new path) failed.\n",
                         this));
            hr = E_OUTOFMEMORY;
            goto Exit;
        }

        // Restore the previous fClassVerified.

        if( !m_fClassVerified )
            m_fClassVerified = fClassVerified;

        // The paths are now the responsibility of the CFileMoniker.
        pwszWidePath = NULL;
    }   // if( !strcmp( pszAnsiPath, m_szPath )

    //  ----
    //  Exit
    //  ----

Exit:

    if( pps )
        pps->Release();

    if (pwszWidePath)
        PrivMemFree(pwszWidePath);

    return( hr );

}   // CFileMoniker::ResolveShellLink()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\com\moniker2\cfactory.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996.
//
//  File:	cfactory.cxx
//
//  Contents:	The class factory implementations for the monikers.
//
//  Classes:	CMonikerFactory
//             CClassMonikerFactory
//             CFileMonikerFactory
//             CObjrefMonikerFactory
//
//  Functions:	MonikerDllGetClassObject
//
//  History:    22-Feb-96 ShannonC  Created
//              24-Apr-97 Ronans        Support for Objref Monikers
//
//--------------------------------------------------------------------------
#include <ole2int.h>
#include "cfactory.hxx"
#include "cbasemon.hxx"
#include "cfilemon.hxx"
#include "classmon.hxx"
#include "cptrmon.hxx"
#include "mnk.h"
#include "cobjrmon.hxx"
#include <dllhost.hxx>

#define SAFEALLOCA_ASSERT Win4Assert
#include <alloca.h>


//Static class factory objects.
static CClassMonikerFactory g_ClassMonikerFactory;
static CFileMonikerFactory  g_FileMonikerFactory;
static CObjrefMonikerFactory g_ObjrefMonikerFactory;

//+-------------------------------------------------------------------------
//
//  Function: 	GetApartmentClass
//
//  Synopsis:   Returns a pointer to the class factory.
//
//  Arguments:  [clsid]	-- the class id desired
//		[iid]	-- the requested interface
//		[ppv]	-- where to put the pointer to the new object
//
//  Returns:    S_OK
//              CLASS_E_CLASSNOTAVAILABLE
//              E_NOINTERFACE
//              E_OUTOFMEMORY
//
//--------------------------------------------------------------------------
#pragma SEG(DllGetClassObject)
HRESULT GetApartmentClass(REFCLSID clsid, REFIID iid, void **ppv)
{
    HRESULT hr;

    mnkDebugOut((DEB_ITRACE,
                "GetApartmentClass(%I,%I,%x)\n",
                &clsid, &iid, ppv));

    *ppv = 0;

    if(IsEqualCLSID(clsid, CLSID_UrlMonWrapper))
    {
        IUnknown *punk;

        punk = new CUrlMonWrapper();
        if(punk != 0)
        {
            hr = punk->QueryInterface(iid, ppv);
            punk->Release();
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }
    else
    {
        hr = CLASS_E_CLASSNOTAVAILABLE;
    }

    return hr;
}

//+-------------------------------------------------------------------------
//
//  Function: 	ApartmentDllGetClassObject
//
//  Synopsis:   Returns a pointer to the moniker class factory.
//              This function provides access to the class factories for
//              apartment model objects.
//
//  Arguments:  [clsid]	-- the class id desired
//		[iid]	-- the requested interface
//		[ppv]	-- where to put the pointer to the new object
//
//  Returns:    S_OK
//              CLASS_E_CLASSNOTAVAILABLE
//              E_INVALIDARG
//              E_NOINTERFACE
//              E_OUTOFMEMORY
//
//  Notes:      This is an internal function called by DllGetClassObject.
//
//--------------------------------------------------------------------------
#pragma SEG(DllGetClassObject)
HRESULT ApartmentDllGetClassObject(REFCLSID clsid, REFIID iid, void **ppv)
{
    HRESULT hr;

    mnkDebugOut((DEB_ITRACE,
                "ApartmentDllGetClassObject(%I,%I,%x)\n",
                &clsid, &iid, ppv));

    if(IsEqualCLSID(clsid, CLSID_UrlMonWrapper))
    {
        COleTls tls;

        if (IsThreadInNTA() || !(tls->dwFlags & OLETLS_APARTMENTTHREADED))
        {
            //We need to switch to a single-threaded apartment.
            hr = DoATClassCreate(GetApartmentClass, clsid, iid, (IUnknown **)ppv);
        }
        else
        {
            //This thread is in a single-threaded apartment.
            hr = GetApartmentClass(clsid, iid, ppv);
        }
    }
    else
    {
        hr = CLASS_E_CLASSNOTAVAILABLE;
    }

    return hr;
}

//+-------------------------------------------------------------------------
//
//  Function: 	MonikerDllGetClassObject
//
//  Synopsis:   Returns a pointer to the moniker class factory.
//              This function provides access to the class factories for
//              the file moniker and the class moniker.
//
//  Arguments:  [clsid]	-- the class id desired
//		[iid]	-- the requested interface
//		[ppv]	-- where to put the pointer to the new object
//
//  Returns:    S_OK
//              CLASS_E_CLASSNOTAVAILABLE
//              E_INVALIDARG
//              E_NOINTERFACE
//              E_OUTOFMEMORY
//
//  Notes:      This is an internal function called by DllGetClassObject.
//
//--------------------------------------------------------------------------
#pragma SEG(DllGetClassObject)
HRESULT MonikerDllGetClassObject(REFCLSID clsid, REFIID iid, void **ppv)
{
    HRESULT hr;

    mnkDebugOut((DEB_ITRACE,
                "MonikerDllGetClassObject(%I,%I,%x)\n",
                &clsid, &iid, ppv));

    if(IsEqualCLSID(clsid, CLSID_FileMoniker))
    {
        hr = g_FileMonikerFactory.QueryInterface(iid, ppv);
    }
    else if(IsEqualCLSID(clsid, CLSID_ClassMoniker))
    {
        hr = g_ClassMonikerFactory.QueryInterface(iid, ppv);
    }
    else if(IsEqualCLSID(clsid, CLSID_ObjrefMoniker))
    {
        hr = g_ObjrefMonikerFactory.QueryInterface(iid, ppv);
    }
    else
    {
        hr = CLASS_E_CLASSNOTAVAILABLE;
    }

    return hr;
}

//+-------------------------------------------------------------------------
//
//  Member:     CMonikerFactory::QueryInterface
//
//  Synopsis:   The moniker factory support IUnknown, IClassFactory,
//              and IParseDisplayName
//
//  Arguments:  [iid]           -- the requested interface
//              [ppvObj]        -- where to put the interface pointer
//
//  Returns:    S_OK
//              E_INVALIDARG
//              E_NOINTERFACE
//
//  Notes:      Bad parameters will raise an exception.  The exception
//              handler catches exceptions and returns E_INVALIDARG.
//
//--------------------------------------------------------------------------
STDMETHODIMP CMonikerFactory::QueryInterface (REFIID iid, void ** ppvObj)
{
    HRESULT hr;

    __try
    {
        mnkDebugOut((DEB_TRACE, 
                    "CMonikerFactory::QueryInterface(%x,%I,%x)\n",
                     this, &iid, ppvObj));

        *ppvObj = NULL;

        if(IsEqualIID(iid,IID_IClassFactory) ||
           IsEqualIID(iid,IID_IUnknown))           
        {
            AddRef();
            *ppvObj = (IClassFactory *) this;
            hr = S_OK;
        }
        else if(IsEqualIID(iid,IID_IParseDisplayName))
        {
            AddRef();
            *ppvObj = (IParseDisplayName *) this;
            hr = S_OK;
        }
        else
        {
            hr = E_NOINTERFACE;
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        hr = E_INVALIDARG;
    }           

    return hr;
}


//+-------------------------------------------------------------------------
//
//  Member:     CMonikerFactory::AddRef
//
//  Synopsis:   Increment the reference count.
//
//  Arguments:  void
//
//  Returns:    ULONG -- the new reference count
//
//  Notes:      This is a static object.  The reference count is always 1.
//
//--------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CMonikerFactory::AddRef(void)
{
    mnkDebugOut((DEB_TRACE, 
                 "CMonikerFactory::AddRef(%x)\n",
                 this));

    return 1;
}

//+-------------------------------------------------------------------------
//
//  Member:     CMonikerFactory::Release
//
//  Synopsis:   Decrements the reference count.
//
//  Arguments:  void
//
//  Returns:    ULONG -- the remaining reference count
//
//  Notes:      This is a static object.  The reference count is always 1.
//
//--------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CMonikerFactory::Release(void)
{
    mnkDebugOut((DEB_TRACE, 
                 "CMonikerFactory::Release(%x)\n",
                 this));
    return 1;
}

//+-------------------------------------------------------------------------
//
//  Member:     CMonikerFactory::LockServer
//
//  Synopsis:   Lock the server. Does nothing.
//
//  Arguments:  fLock
//
//  Returns:    S_OK
//
//--------------------------------------------------------------------------
STDMETHODIMP CMonikerFactory::LockServer(BOOL fLock)
{
    mnkDebugOut((DEB_TRACE, 
                 "CMonikerFactory::LockServer(%x,%x)\n",
                 this, fLock));
    return S_OK;
}

//+-------------------------------------------------------------------------
//
//  Member:     CClassMonikerFactory::CreateInstance
//
//  Synopsis:   Creates a class moniker.
//
//  Arguments:  [pUnkOuter] - The controlling unknown (for aggregation)
//              [iid]       - The requested interface ID.
//              [ppv]       - Returns the pointer to the new object
//
//  Returns:    S_OK
//              CLASS_E_NOAGGREGATION
//              E_NOINTERFACE
//              E_OUTOFMEMORY
//              E_INVALIDARG
//
//--------------------------------------------------------------------------
STDMETHODIMP CClassMonikerFactory::CreateInstance(
    IUnknown * pUnkOuter,
    REFIID     riid, 
    void **    ppv)
{
    HRESULT hr;
    IID     iid;

    __try
    {
        mnkDebugOut((DEB_TRACE, 
                     "CClassMonikerFactory::CreateInstance(%x,%x,%I,%x)\n",
                     this, pUnkOuter, &iid, ppv));

        //Parameter validation.
        *ppv = NULL;
        iid = riid;

        if(NULL == pUnkOuter)
        {
            CClassMoniker *pmk = new CClassMoniker(CLSID_NULL);
            if(pmk != NULL)
            {
                hr = pmk->QueryInterface(iid, ppv);
                pmk->Release();
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
        }
        else
        {
            //Class moniker does not support aggregation.
            hr = CLASS_E_NOAGGREGATION;            
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        hr = E_INVALIDARG;
    }
    
    return hr;
}


//+-------------------------------------------------------------------------
//
//  Function:   ParseClassID
//
//  Synopsis:   Parses a display name containing a class ID.
//
//  Arguments:  pszDisplayName - Supplies display name to be parsed.
//              pchEaten       - Returns the number of characters parsed.
//              pClassID       - Returns the class ID.
//
//  Returns:    S_OK
//              MK_E_SYNTAX
//
//  Notes:      The class ID can have one of the following formats:
//              00000000-0000-0000-0000-000000000000
//              {00000000-0000-0000-0000-000000000000}
//
//--------------------------------------------------------------------------
HRESULT ParseClassID(
    LPCWSTR pszDisplayName,
    ULONG * pchEaten,
    CLSID * pClassID)
{
    HRESULT hr = MK_E_SYNTAX;

    *pchEaten = 0;

    //Parse xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx
    if(wUUIDFromString(pszDisplayName, pClassID) == TRUE)
    {
        //There are 36 characters in xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx
        *pchEaten = 36;
        hr = S_OK;
    }
    //Parse {xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx}
    else if((L'{' == pszDisplayName[0]) &&
            (wUUIDFromString(&pszDisplayName[1], pClassID) == TRUE) &&
            (L'}' == pszDisplayName[37]))
    {
        //There are 38 characters in {xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx}
        *pchEaten = 38;
        hr = S_OK;

    }

    return hr;
}



//+-------------------------------------------------------------------------
//
//  Member:     CClassMonikerFactory::ParseDisplayName
//
//  Synopsis:   Parse a class moniker display name.
//
//  Arguments:  pbc - Supplies bind context.
//              pszDisplayName - Supplies display name to be parsed.
//              pchEaten - Returns the number of characters parsed.
//              ppmkOut - Returns the pointer to the resulting moniker.
//
//  Returns:    S_OK
//              E_INVALIDARG
//              E_OUTOFMEMORY
//              MK_E_SYNTAX
//
//--------------------------------------------------------------------------
STDMETHODIMP CClassMonikerFactory::ParseDisplayName( 
    IBindCtx  * pbc,
    LPOLESTR    pszDisplayName,
    ULONG     * pchEaten,
    IMoniker ** ppmkOut)
{
    HRESULT   hr;
    BIND_OPTS bindopts;
    ULONG     chName;
    ULONG     cbName;
    LPWSTR    pName = NULL;
    CClassMoniker *pmkClass = NULL;
    ULONG     cEaten = 0;
    CLSID     classID;
    LPCWSTR   pszParameters = NULL;
    LPOLESTR  pch = pszDisplayName;

    __try
    {

        mnkDebugOut((DEB_TRACE, 
                     "CClassMonikerFactory::ParseDisplayName(%x,%x,%ws,%x,%x)\n",
                     this, pbc, pszDisplayName, pchEaten, ppmkOut));

        //Validate parameters.
        *pchEaten = 0;
        *ppmkOut = NULL;
        bindopts.cbStruct = sizeof(BIND_OPTS);
        pbc->GetBindOptions(&bindopts);

        // Eat the prefix.
        while (*pch != '\0' && *pch != ':')
        {
            pch++;
        }

        if(':' == *pch)
        {
            pch++;
        }
        else
        {
            return MK_E_SYNTAX;
        }

        //Copy the display name.
        //Note that we allocate memory from the stack so we don't have to free it.
        chName = lstrlenW(pch);
        cbName = chName * sizeof(WCHAR) + sizeof(WCHAR);
        SafeAllocaAllocate(pName, cbName);

        if(pName != NULL)
        {
            memcpy(pName, pch, cbName);
            hr = ParseClassID(pName, &cEaten, &classID);
              
            if(SUCCEEDED(hr))
            {
                //Parse the parameters.
                if(L';' == pName[cEaten])
                {
                    pszParameters = &pName[cEaten];
                    cEaten++;
                }

                //Parse the name up to the :.
                while(cEaten < chName && 
                      pName[cEaten] != L':')
                {
                    cEaten++;
                }

                if(L':' == pName[cEaten])
                {
                    pName[cEaten] = L'\0';

                   //Eat the :
                   cEaten++;
                }

               //Create the class moniker.
               pmkClass = new CClassMoniker(classID);

               if(pmkClass != NULL)
               {
                   //Set the parameters.
                   if(pszParameters != NULL)
                   {
                       hr = pmkClass->SetParameters(pszParameters);
                       if(FAILED(hr))
                       {
                           pmkClass->Release();
                           pmkClass = NULL;
                       }
                   }
                   else
                   {
                       hr = S_OK;
                   }
               }
               else
               {
                   hr = E_OUTOFMEMORY;
               }               
            }
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }

        if(SUCCEEDED(hr))
        {            
            cEaten += (ULONG) (pch - pszDisplayName);
            *pchEaten = cEaten;
            *ppmkOut = pmkClass;
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        hr = E_INVALIDARG;
    }

	SafeAllocaFree(pName);

    return hr;
}

//+-------------------------------------------------------------------------
//
//  Member:     CFileMonikerFactory::CreateInstance
//
//  Synopsis:   Creates a file moniker.
//
//  Arguments:  [pUnkOuter]     -- the controlling unknown (for aggregation)
//              [iid]           -- the requested interface ID
//              [ppv]           -- where to put the pointer to the new object
//
//  Returns:    S_OK
//              CLASS_E_NOAGGREGATION
//              E_NOINTERFACE
//              E_OUTOFMEMORY
//              E_INVALIDARG
//
//--------------------------------------------------------------------------
STDMETHODIMP CFileMonikerFactory::CreateInstance(
    IUnknown * pUnkOuter, 
    REFIID     riid, 
    void    ** ppv)
{
    HRESULT hr;
    IID     iid;

    __try
    {
        mnkDebugOut((DEB_TRACE, 
                     "CFileMonikerFactory::CreateInstance(%x,%x,%I,%x)\n",
                     this, pUnkOuter, &iid, ppv));

        //Parameter validation.
        *ppv = NULL;
        iid = riid;

        if(NULL == pUnkOuter)
        {
            IMoniker *pmk;

            pmk = CFileMoniker::Create(OLESTR(""), 0, DEF_ENDSERVER);

            if(pmk != NULL)
            {
                hr = pmk->QueryInterface(iid, ppv);
                pmk->Release();
            }
            else
            {
                hr = E_OUTOFMEMORY;                
            }
        }
        else
        {
            //File moniker does not support aggregation.
            hr = CLASS_E_NOAGGREGATION;            
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        hr = E_INVALIDARG;
    }
    
        return hr;
}



//+-------------------------------------------------------------------------
//
//  Member:     CFileMonikerFactory::ParseDisplayName
//
//  Synopsis:   Parse a file moniker display name.
//
//  Arguments:  pbc - Supplies bind context.
//              pszDisplayName - Supplies display name to be parsed.
//              pchEaten - Returns the number of characters parsed.
//              ppmkOut - Returns the pointer to the resulting moniker.
//
//  Returns:    S_OK
//              E_INVALIDARG
//              E_OUTOFMEMORY
//              MK_E_SYNTAX
//
//--------------------------------------------------------------------------
STDMETHODIMP CFileMonikerFactory::ParseDisplayName( 
    IBindCtx  * pbc,
    LPOLESTR    pszDisplayName,
    ULONG     * pchEaten,
    IMoniker ** ppmkOut)
{
    HRESULT   hr;
    BIND_OPTS bindopts;
    IMoniker *pmkFile;
    ULONG     cEaten;

    __try
    {
        LPOLESTR  pch = pszDisplayName;

        mnkDebugOut((DEB_TRACE, 
                     "CFileMonikerFactory::ParseDisplayName(%x,%x,%ws,%x,%x)\n",
                     this, pbc, pszDisplayName, pchEaten, ppmkOut));

        //Validate parameters.
        *ppmkOut = NULL;
        *pchEaten = 0;
        bindopts.cbStruct = sizeof(BIND_OPTS);
        pbc->GetBindOptions(&bindopts);

        // Eat the prefix.
        while (*pch != '\0' && *pch != ':')
        {
            pch++;
        }

        if(':' == *pch)
        {
            pch++;
        }
        else
        {
            return MK_E_SYNTAX;
        }

        hr = FindFileMoniker(pbc, pch, &cEaten, &pmkFile);
        if(SUCCEEDED(hr))
        {
            cEaten += (ULONG) (pch - pszDisplayName);           
            *pchEaten = cEaten;
            *ppmkOut = pmkFile;
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        hr = E_INVALIDARG;
    }
    return hr;
}

//+-------------------------------------------------------------------------
//
//  Member:     CObjrefMonikerFactory::CreateInstance
//
//  Synopsis:   Creates a objref moniker.
//
//  Arguments:  [pUnkOuter]     -- the controlling unknown (for aggregation)
//              [iid]           -- the requested interface ID
//              [ppv]           -- where to put the pointer to the new object
//
//  Returns:    S_OK
//              CLASS_E_NOAGGREGATION
//              E_NOINTERFACE
//              E_OUTOFMEMORY
//              E_INVALIDARG
//
//--------------------------------------------------------------------------
STDMETHODIMP CObjrefMonikerFactory::CreateInstance(
    IUnknown * pUnkOuter, 
    REFIID     riid, 
    void    ** ppv)
{
    HRESULT hr;
    IID     iid;

    __try
    {
        mnkDebugOut((DEB_TRACE, 
                     "CObjrefMonikerFactory::CreateInstance(%x,%x,%I,%x)\n",
                     this, pUnkOuter, &iid, ppv));

        //Parameter validation.
        *ppv = NULL;
        iid = riid;

        if(NULL == pUnkOuter)
        {
            IMoniker *pmk;

            pmk = CObjrefMoniker::Create(NULL);

            if(pmk != NULL)
            {
                hr = pmk->QueryInterface(iid, ppv);
                pmk->Release();
            }
            else
            {
                hr = E_OUTOFMEMORY;                
            }
        }
        else
        {
            //Objref moniker does not support aggregation.
            hr = CLASS_E_NOAGGREGATION;            
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        hr = E_INVALIDARG;
    }
        return hr;
}

//+-------------------------------------------------------------------------
//
//  Member:     CObjrefMonikerFactory::ParseDisplayName
//
//  Synopsis:   Parse a objref moniker display name.
//
//  Arguments:  pbc - Supplies bind context.
//              pszDisplayName - Supplies display name to be parsed.
//              pchEaten - Returns the number of characters parsed.
//              ppmkOut - Returns the pointer to the resulting moniker.
//
//  Returns:    S_OK
//              E_INVALIDARG
//              E_OUTOFMEMORY
//              MK_E_SYNTAX
//
// Notes:               Display name is base64 representation of marshal data for moment
//
//--------------------------------------------------------------------------
STDMETHODIMP CObjrefMonikerFactory::ParseDisplayName( 
    IBindCtx  * pbc,
    LPOLESTR    pszDisplayName,
    ULONG     * pchEaten,
    IMoniker ** ppmkOut)
{
    HRESULT   hr;
    BIND_OPTS bindopts;
    ULONG     chName = 0;
    ULONG     cbName;
    LPWSTR    pName = NULL;
    CObjrefMoniker *pmkObjref = NULL;
    LPOLESTR  pch = pszDisplayName, pch2 = NULL;

    __try
    {

        mnkDebugOut((DEB_TRACE, 
                     "CObjrefMonikerFactory::ParseDisplayName(%x,%x,%ws,%x,%x)\n",
                     this, pbc, pszDisplayName, pchEaten, ppmkOut));

        //Validate parameters.
        *pchEaten = 0;
        *ppmkOut = NULL;
        bindopts.cbStruct = sizeof(BIND_OPTS);
        pbc->GetBindOptions(&bindopts);

        // Eat the prefix.
        while (*pch != '\0' && *pch != ':')
        {
            pch++;
        }


        if(':' == *pch)
            pch++;
        else
            return MK_E_SYNTAX;

        // at this point we are at the start of the base64 data for the objref moniker
        pch2 = pch;
        
        // calculate length of base64 data 
        while (*pch2 != '\0' && *pch2 != ':')
        {
            chName++;
            pch2++;
        }
        
        // verify we have a terminating ':'
        if(':' == *pch2)
            pch2++;
        else
            return MK_E_SYNTAX;


        //Copy the display name.
        //Note that we allocate memory from the stack so we don't have to free it.
        cbName = chName * sizeof(WCHAR) ;
        SafeAllocaAllocate(pName, (cbName + sizeof(WCHAR)));
        
        if(pName != NULL)
        {
            memcpy(pName, pch, cbName );
            pName[chName] = L'\0';
            
            
            IStream *pIStream = utBase64ToIStream(pName);
              
            if(pIStream)
            {
                //Create the objref moniker.
                pmkObjref = new CObjrefMoniker(NULL);
                
                if(pmkObjref != NULL)
                {
                    hr = pmkObjref -> Load(pIStream);
                    
                    if(FAILED(hr))
                    {
                        pmkObjref->Release();
                        pmkObjref = NULL;
                    }
                }
                else
                {
                    hr = E_OUTOFMEMORY;
                }               
                pIStream -> Release();
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }

        if(SUCCEEDED(hr))
        {            
            *pchEaten = (ULONG) (pch2 - pszDisplayName);
            *ppmkOut = pmkObjref;
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        hr = E_INVALIDARG;
    }

	SafeAllocaFree(pName);

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\com\moniker2\citemmon.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1993 - 1993.
//
//  File:       citemmon.cxx
//
//  Contents:   Implementation of CItemMoniker
//
//  Classes:
//
//  Functions:
//
//  History:    12-27-93   ErikGav   Created
//		        01-14-94   KevinRo   Updated so it actually works
//		        06-14-94   Rickhi    Fix type casting
//              10-13-95   stevebl   threadsafty
//
//----------------------------------------------------------------------------

#include <ole2int.h>

#include "cbasemon.hxx"
#include "citemmon.hxx"
#include "cantimon.hxx"
#include "mnk.h"

#include <olepfn.hxx>
#include <rotdata.hxx>


INTERNAL RegisterContainerBound(LPBC pbc, LPOLEITEMCONTAINER pOleCont);


INTERNAL_(CItemMoniker *) IsItemMoniker( LPMONIKER pmk )
{
    CItemMoniker *pIMk;

    if ((pmk->QueryInterface(CLSID_ItemMoniker, (void **)&pIMk)) == S_OK)
    {
        // we release the AddRef done by QI, but still return the pointer
        pIMk->Release();
        return pIMk;
    }

    // dont rely on user implementations to set pIMk to NULL on failed QI.
    return pIMk;
}


//+---------------------------------------------------------------------------
//
//  Method:     CItemMoniker::CItemMoniker
//
//  Synopsis:   Constructor
//
//  Effects:
//
//  Arguments:  (none)
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:
//
//  History:    1-17-94   kevinro   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
CItemMoniker::CItemMoniker() CONSTR_DEBUG
{
    mnkDebugOut((DEB_ITRACE,
                 "CItemMoniker::CItemMoniker(%x)\n",
                 this));

    m_lpszItem = NULL;
    m_lpszDelimiter = NULL;
    m_pszAnsiItem = NULL;
    m_pszAnsiDelimiter = NULL;
    m_fHashValueValid = FALSE;
    m_ccItem = 0;
    m_cbAnsiItem = 0;
    m_cbAnsiDelimiter = 0;
    m_ccDelimiter = 0;

    m_dwHashValue = 0x12345678;
    //
    // CoQueryReleaseObject needs to have the address of the this objects
    // query interface routine.
    //
    if (adwQueryInterfaceTable[QI_TABLE_CItemMoniker] == 0)
    {
        adwQueryInterfaceTable[QI_TABLE_CItemMoniker] =
            **(ULONG_PTR **)((IMoniker *)this);
    }

}


//+---------------------------------------------------------------------------
//
//  Method:     CItemMoniker::ValidateMoniker
//
//  Synopsis:   Check the consistency of this moniker
//
//  Effects:    In a DBG build, check to see if the member variables are
//              sane values.
//
//  Arguments:  (none)
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:
//
//  History:    1-17-94   kevinro   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
#if DBG == 1
void CItemMoniker::ValidateMoniker()
{
    Assert( (m_lpszItem == NULL && m_ccItem == 0) ||
            (m_ccItem == lstrlenW(m_lpszItem)));


    Assert( (m_lpszDelimiter == NULL && m_ccDelimiter == 0) ||
            (m_ccDelimiter == lstrlenW(m_lpszDelimiter)));

    //
    // cbAnsi* fields are NOT string lengths. However, the size of the
    // buffer should be at least equal or bigger to the length of the
    // Ansi part.
    //

    Assert( (m_pszAnsiItem == NULL && m_cbAnsiItem == 0) ||
            (m_cbAnsiItem >= strlen(m_pszAnsiItem)+1));


    Assert( (m_pszAnsiDelimiter == NULL && m_cbAnsiDelimiter == 0) ||
            (m_cbAnsiDelimiter >= strlen(m_pszAnsiDelimiter)+1));

    Assert( !m_fHashValueValid || (m_dwHashValue != 0x12345678) );
}
#endif


//+---------------------------------------------------------------------------
//
//  Method:     CItemMoniker::~CItemMoniker
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:  [void] --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:
//
//  History:    1-17-94   kevinro   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
CItemMoniker::~CItemMoniker( void )
{
    mnkDebugOut((DEB_ITRACE,
                 "CItemMoniker::~CItemMoniker(%x)\n",
                 this));
    UnInit();
}

//+---------------------------------------------------------------------------
//
//  Method:     CItemMoniker::UnInit
//
//  Synopsis:   Uninitialize the Item moniker
//
//  Effects:    Free's path memory stored in Item Moniker.
//
//  Arguments:  (none)
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:
//
//  History:    1-16-94   kevinro   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
void
CItemMoniker::UnInit()
{
    mnkDebugOut((DEB_ITRACE,
                 "CItemMoniker::UnInit(%x)\n",
                 this));

    ValidateMoniker();

    if (m_lpszDelimiter != NULL)
    {
        PrivMemFree(m_lpszDelimiter);
        m_lpszDelimiter = NULL;
        m_ccDelimiter = 0;
    }

    if (m_pszAnsiDelimiter != NULL)
    {
        PrivMemFree(m_pszAnsiDelimiter);
        m_pszAnsiDelimiter = NULL;
        m_cbAnsiDelimiter = 0;
    }

    if (m_lpszItem != NULL)
    {
        PrivMemFree(m_lpszItem);
        m_lpszItem = NULL;
        m_ccItem = 0;
    }

    if (m_pszAnsiItem != NULL)
    {
        PrivMemFree(m_pszAnsiItem);
        m_pszAnsiItem = NULL;
        m_cbAnsiItem = 0;
    }

    m_fHashValueValid = FALSE;
    m_dwHashValue = 0x12345678;

    ValidateMoniker();
}

//+---------------------------------------------------------------------------
//
//  Method:     CItemMoniker::Initialize
//
//  Synopsis:   Initilaize an Item Moniker
//
//  Effects:    Clears the current state, then sets new state
//
//  Arguments:  [lpwcsDelimiter] --     Delimiter string
//              [ccDelimiter] --        char count of delimiter
//              [lpszAnsiDelimiter] --  Ansi version of delimiter
//              [cbAnsiDelimiter] --    Count of bytes in AnsiDelimiter
//              [lpwcsItem] --          Item string
//              [ccItem] --             Count of characters in item string
//              [lpszAnsiItem] --       Ansi version of item string
//              [cbAnsiItem] --         Count of bytes in Ansi version
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:
//
//  History:    1-16-94   kevinro   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
void
CItemMoniker::Initialize ( LPWSTR lpwcsDelimiter,
                           USHORT  ccDelimiter,
                           LPSTR  lpszAnsiDelimiter,
                           USHORT  cbAnsiDelimiter,
                           LPWSTR lpwcsItem,
                           USHORT  ccItem,
                           LPSTR  lpszAnsiItem,
                           USHORT  cbAnsiItem )
{
    //
    // OleLoadFromStream causes two inits; the member vars may already be set
    // UnInit() will free existing resources
    //

    UnInit();

    ValidateMoniker();

    m_lpszItem = lpwcsItem;
    m_ccItem = ccItem;

    m_pszAnsiItem = lpszAnsiItem;
    m_cbAnsiItem = cbAnsiItem;

    m_lpszDelimiter = lpwcsDelimiter;
    m_ccDelimiter = ccDelimiter;

    m_pszAnsiDelimiter = lpszAnsiDelimiter;
    m_cbAnsiDelimiter = cbAnsiDelimiter;

    ValidateMoniker();
}


//+---------------------------------------------------------------------------
//
//  Method:     CItemMoniker::Initialize
//
//  Synopsis:   Initialize the contents of this moniker
//
//  Effects:
//      Copies the input parameters using PrivMemAlloc(), then passes them
//      to the other version of Initialize, which takes control of the
//      pointers.
//
//  Arguments:  [lpszDelimiter] --
//              [lpszItemName] --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:
//
//  History:    1-17-94   kevinro   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
INTERNAL_(BOOL)
CItemMoniker::Initialize ( LPCWSTR lpszDelimiter,
                           LPCWSTR lpszItemName )
{
    ValidateMoniker();

    USHORT ccItem;
    USHORT ccDelimiter;

    LPWSTR pwcsDelimiter = NULL;
    LPWSTR pwcsItem = NULL;

    if (m_mxs.FInit() == FALSE)
    {
    	goto errRet;
    }
    
    //VDATEPTRIN rejects NULL
    if( lpszDelimiter )
    {
        GEN_VDATEPTRIN(lpszDelimiter,WCHAR, FALSE);
    }

    if( lpszItemName )
    {
        GEN_VDATEPTRIN(lpszItemName,WCHAR, FALSE);
    }

    if (FAILED(DupWCHARString(lpszDelimiter,
                              pwcsDelimiter,
                              ccDelimiter)))
    {
        goto errRet;
    }

    if (FAILED(DupWCHARString(lpszItemName,pwcsItem,ccItem)))
    {
        goto errRet;
    }
    Initialize(pwcsDelimiter,
               ccDelimiter,
               NULL,
               0,
               pwcsItem,
               ccItem,
               NULL,
               0);

    return TRUE;

errRet:

    if (pwcsDelimiter != NULL)
    {
        PrivMemFree(pwcsDelimiter);
    }
    return(FALSE);
}


CItemMoniker FAR *CItemMoniker::Create (
        LPCWSTR lpszDelimiter, LPCWSTR lpszItemName)
{
    mnkDebugOut((DEB_ITRACE,
                 "CItemMoniker::Create() item(%ws) delim(%ws)\n",
                 lpszItemName,
                 lpszDelimiter));
    //
    // Parameter validation is handled in Initialize
    //
    CItemMoniker FAR * pCIM = new CItemMoniker();

    if (pCIM)
    {
	    if (pCIM->Initialize( lpszDelimiter, lpszItemName ))
	        return pCIM;
	
	    delete pCIM;
    }
    return NULL;
}



STDMETHODIMP CItemMoniker::QueryInterface (THIS_ REFIID riid,
        LPVOID FAR* ppvObj)
{
    VDATEIID (riid);
    VDATEPTROUT(ppvObj, LPVOID);

   	*ppvObj = NULL;

#ifdef _DEBUG
    if (riid == IID_IDebug)
    {
        *ppvObj = &(m_Debug);
        return NOERROR;
    }
#endif

    if (IsEqualIID(riid, CLSID_ItemMoniker))
    {
        // called by IsItemMoniker.
        AddRef();
        *ppvObj = this;
        return S_OK;
    }

    return CBaseMoniker::QueryInterface(riid, ppvObj);
}



STDMETHODIMP CItemMoniker::GetClassID (LPCLSID lpClassId)
{

    VDATEPTROUT(lpClassId, CLSID);

    *lpClassId = CLSID_ItemMoniker;
    return NOERROR;
}


//+---------------------------------------------------------------------------
//
//  Function:   WriteDoubleString
//
//  Synopsis:   Writes a double string to stream. See ExtractUnicodeString
//
//  Effects:
//
//  Arguments:  [pStm] --
//              [pwcsWide] --
//              [ccWide] --
//              [pszAnsi] --
//              [cbAnsi] --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    1-16-94   kevinro   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT
WriteDoubleString( LPSTREAM     pStm,
                   LPWSTR       pwcsWide,
                   USHORT       ccWide,
                   LPSTR        pszAnsi,
                   USHORT       cbAnsi)
{
    mnkDebugOut((DEB_ITRACE,
                 "WriteDoubleString pwcsWide(%ws) cbWide(0x%x) psz(%s) cb(0x%x)\n",
                  pwcsWide?pwcsWide:L"<NULL>",
                  ccWide,
                  pszAnsi?pszAnsi:"<NULL>",
                  cbAnsi));
    HRESULT hr;

    //
    // The string size is always written, but not including the size of the
    // preceding DWORD so we conform to the way WriteAnsiString does it
    //

    ULONG ulTotalSize = 0;

    //
    // The entire reason we are supposed to be in this routine is that the
    // pwcsWide could not be converted to ANSI. Therefore, it had better
    // be valid.
    //

    Assert( (pwcsWide != NULL) && (ccWide == lstrlenW(pwcsWide)));
    Assert( (pszAnsi == NULL) || (cbAnsi == (strlen(pszAnsi) + 1)));

    ulTotalSize += ccWide * sizeof(WCHAR);

    // Lets assume most ItemStrings will fit in this buffer

    BYTE  achQuickBuffer[256];
    BYTE *pcbQuickBuffer = achQuickBuffer;

    //
    // Since we are going to cheat, and write something to the back of the
    // ANSI string, the ANSI string must contain at least a NULL character.
    // If it doesn't, we are going to cheat one in.
    //
    if (pszAnsi == NULL)
    {
        ulTotalSize += sizeof(char);
    }
    else
    {
        ulTotalSize += cbAnsi;
    }

    //
    // If we don't fit in the QuickBuffer, allocate some memory
    //
    // 1996.4.24 v-hidekk
    if ((ulTotalSize + sizeof(ULONG)) > sizeof(achQuickBuffer))
    {
        pcbQuickBuffer = (BYTE *)PrivMemAlloc((ulTotalSize + sizeof(ULONG)));

        if (pcbQuickBuffer == NULL)
        {
            return(E_OUTOFMEMORY);
        }
    }

    //
    // First DWORD in the buffer is the total size of the string. This
    // value includes strlen's of both strings, plus the size of the NULL
    // on the Ansi string.
    //
    // Intrinsics will make this into a move of the correct alignment.
    // Casting pcbQuickBuffer to a ULONG pointer is dangerous, since
    // the alignment may be incorrect. Let the compiler figure out the
    // correct thing to do.
    //

    memcpy(pcbQuickBuffer,&ulTotalSize,sizeof(ulTotalSize));

    //
    // Here, we make sure that pszAnsi ends up writing at least the NULL
    // character
    //

    ULONG ulAnsiWritten;

    memcpy(pcbQuickBuffer + sizeof(ulTotalSize),
           pszAnsi?pszAnsi:"",
           ulAnsiWritten = pszAnsi?cbAnsi:1);

    //
    // At this point, there should be a ULONG followed by at least 1
    // character. The pointer arithmetic below puts us just past the
    // null terminator of the Ansi string
    //

    memcpy(pcbQuickBuffer + sizeof(ulTotalSize) + ulAnsiWritten,
           pwcsWide,
           ccWide * sizeof(WCHAR));

    mnkDebugOut((DEB_ITRACE,
                 "WriteDoubleString ulTotalSize(0x%x)\n",
                 ulTotalSize));

    hr = pStm->Write(pcbQuickBuffer, ulTotalSize + sizeof(ULONG) ,NULL);

    if (pcbQuickBuffer != achQuickBuffer)
    {
        PrivMemFree(pcbQuickBuffer);
    }

    return(hr);

}

//+---------------------------------------------------------------------------
//
//  Function:   ExtractUnicodeString
//
//  Synopsis:   Given an ANSI string buffer, return a UNICODE path
//
//  Effects:
//      If it exists, this routine will extract the UNICODE section
//      of a string written out in the following format:
//
//      <ANSI string><0><UNICODESTRING>
//      ^       cbAnsiString          ^
//
//
//      If the UNICODE string doesn't exist, then the Ansi string is converted
//      to UNICODE and returned
//
//  Arguments:  [pszAnsiString] --      Ansi string with potential UNICODE end
//              [cbAnsiString] --       Total number of bytes in pszAnsiString
//              [pwcsWideString] --     Reference to output string pointer
//              [ccWideString] --       Reference to output cound of characters
//
//  Requires:
//
//  Returns:
//      pwcsWideString will be a PrivMemAlloc()'d UNICODE string
//      ccWideString will be the character count (excluding the NULL)
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    1-16-94   kevinro   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT ExtractUnicodeString(LPSTR pszAnsiString,
                             USHORT cbAnsiString,
                             LPWSTR & pwcsString,
                             USHORT  & ccString)
{
    mnkDebugOut((DEB_ITRACE,
                 "ExtractUnicodeString pszAnsi(%s) cbAnsi(0x%x)\n",
                 ANSICHECK(pszAnsiString),
                 cbAnsiString));


    USHORT cbAnsiStrLen;
    HRESULT hr;


    //
    // If the Ansi string is NULL, then the Wide char will be also
    //

    if (pszAnsiString == NULL)
    {
        pwcsString = NULL;
        ccString = 0;

        return(NOERROR);
    }

    Assert( pwcsString == NULL);

    //
    // If strlen(pszAnsiString)+1 == cbAnsiString, then there is no
    // UNICODE extent.
    //

    cbAnsiStrLen = (USHORT)strlen(pszAnsiString);

    if ((cbAnsiStrLen + 1) == cbAnsiString)
    {
        //
        // There is not a UNICODE extent. Convert from Ansi to UNICODE
        //
        pwcsString = NULL;

        hr= MnkMultiToUnicode(pszAnsiString,
                              pwcsString,
                              0,
                              ccString,
                              CP_ACP);

        mnkDebugOut((DEB_ITRACE,
                     "ExtractUnicodeString converted (%s) to (%ws) ccString(0x%x)\n",
                     ANSICHECK(pszAnsiString),
                     WIDECHECK(pwcsString),
                     ccString));
    }
    else
    {
        mnkDebugOut((DEB_ITRACE,
                     "ExtractUnicodeString found UNICODE extent\n"));

        //
        // There are extra characters following the AnsiString. Make a
        // new buffer to copy them. Don't forget to add an extra WCHAR for
        // the NULL termination
        //
                                            // AnsiStrLen + AnsiNull char
        USHORT cbWideString = cbAnsiString - (cbAnsiStrLen + 1);

        Assert(cbWideString != 0);

        //
        // There had best be an even number of bytes, or else something
        // has gone wrong.
        //

        Assert( ! (cbWideString & 1));
                                            // Strlen + sizeof(1 NULL char)
        pwcsString = (WCHAR *) PrivMemAlloc(cbWideString + sizeof(WCHAR));
        if (pwcsString == NULL)
        {
            hr = E_OUTOFMEMORY;
            goto errRet;
        }

        memcpy(pwcsString,pszAnsiString + cbAnsiStrLen + 1, cbWideString);

        ccString = cbWideString / sizeof(WCHAR);

        pwcsString[ccString] = 0;

        hr = NOERROR;
    }

errRet:
    mnkDebugOut((DEB_ITRACE,
                 "ExtractUnicodeString result hr(%x) pwcsString(%ws) ccString(0x%x)\n",
                 hr,
                 WIDECHECK(pwcsString),
                 ccString));
    return(hr);
}

//+---------------------------------------------------------------------------
//
//  Method:     CItemMoniker::Load
//
//  Synopsis:   Loads an Item moniker from a stream
//
//  Effects:    The first version of CItemMoniker stored two counted strings
//              in the stream. Both were stored in ANSI.
//
//              This version saves a UNICODE string on the end of the ANSI
//              string. Therefore, when it is read back in, the count of
//              bytes read as the ANSI string may include a UNICODE string.
//
//              See ::Save() for more details.
//
//
//  Arguments:  [pStm] --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:
//
//  History:    1-16-94   kevinro   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CItemMoniker::Load (LPSTREAM pStm)
{
    mnkDebugOut((DEB_ITRACE,
                 "CItemMoniker::Load(%x)\n",
                 this));

    VDATEIFACE(pStm);

    ValidateMoniker();

    HRESULT hresult;
    LPSTR pszAnsiItem = NULL;
    LPSTR pszAnsiDelim = NULL;

    LPWSTR pwcsItem = NULL;
    LPWSTR pwcsDelim = NULL;

    USHORT cbAnsiDelim;
    USHORT cbAnsiItem;

    USHORT ccDelim;
    USHORT ccItem;

    //
    // First, read in the two strings into the Ansi versions
    //

    hresult = ReadAnsiStringStream( pStm, pszAnsiDelim,cbAnsiDelim );
    if (hresult != NOERROR)
    {
        goto errRet;
    }

    mnkDebugOut((DEB_ITRACE,
                 "::Load(%x) pszAnsiDelim(%s) cbAnsiDelim(0x%x)\n",
                 this,
                 pszAnsiDelim,
                 cbAnsiDelim));

    hresult = ReadAnsiStringStream( pStm, pszAnsiItem, cbAnsiItem );

    if (hresult != NOERROR)
    {
        goto errRet;
    }

    mnkDebugOut((DEB_ITRACE,
                 "::Load(%x) pszAnsiItem(%s) cbAnsiItem(0x%x)\n",
                 this,
                 pszAnsiItem,
                 cbAnsiItem));
    //
    // Now, determine the UNICODE strings. They may be stashed at the
    // end of the Ansi strings.
    //

    hresult = ExtractUnicodeString(pszAnsiDelim,
                                   cbAnsiDelim,
                                   pwcsDelim,
                                   ccDelim);

    if (FAILED(hresult))
    {
        goto errRet;
    }

    hresult = ExtractUnicodeString(pszAnsiItem,
                                   cbAnsiItem,
                                   pwcsItem,
                                   ccItem);
    if (FAILED(hresult))
    {
        goto errRet;
    }

    Initialize ( pwcsDelim,
                 ccDelim,
                 pszAnsiDelim,
                 cbAnsiDelim,
                 pwcsItem,
                 ccItem,
                 pszAnsiItem,
                 cbAnsiItem );

    ValidateMoniker();
    return(NOERROR);

errRet:
    PrivMemFree(pszAnsiItem);
    PrivMemFree(pszAnsiDelim);
    PrivMemFree(pwcsItem);
    PrivMemFree(pwcsDelim);
    return hresult;
}


//+---------------------------------------------------------------------------
//
//  Function:   SaveUnicodeAsAnsi
//
//  Synopsis:   This function will save a string to the stream
//
//  Effects:
//      This routine always attempts to save the string in Ansi. If it isn't
//      possible to save an Ansi version of the string, it will save an
//      Ansi version (which may be NULL), and a UNICODE version.
//
//  Arguments:  [pStm] --       Stream to write to
//              [pwcsWide] --   Unicode string
//              [ccWide] --     Count of UNICODE characters (EXCL NULL)
//              [pszAnsi] --    Ansi string
//              [cbAnsi] --     Count of bytes (INCL NULL)
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    1-17-94   kevinro   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT SaveUnicodeAsAnsi( LPSTREAM     pStm,
                           LPWSTR       pwcsWide,
                           USHORT       ccWide,
                           LPSTR        pszAnsi,
                           USHORT       cbAnsi)
{
    mnkDebugOut((DEB_ITRACE,
                 "::SaveUnicodeAsAnsi pwcsWide(%ws) ccWide(0x%x) pwsAnsi(%s) cbAnsi(0x%x)\n",
                 WIDECHECK(pwcsWide),
                 ccWide,
                 ANSICHECK(pszAnsi),
                 cbAnsi));
    HRESULT hr;
    BOOL fFastConvert;

    //
    // If the Ansi version exists, or the Unicode string is NULL,
    // write out the Ansi version
    //

    if ((pszAnsi != NULL) || (pwcsWide == NULL))
    {
        mnkDebugOut((DEB_ITRACE,
                     "::SaveUnicodeAsAnsi Ansi Only (%s)\n",
                     ANSICHECK(pszAnsi)));

        hr = WriteAnsiStringStream( pStm,
                                    pszAnsi,
                                    cbAnsi);
    }
    else
    {
        //
        // There isn't an AnsiVersion, and the UNICODE version isn't NULL
        // Try to convert the UNICODE to Ansi
        //

        Assert( (pwcsWide != NULL) &&
                (ccWide == lstrlenW(pwcsWide)));

        mnkDebugOut((DEB_ITRACE,
                     "::SaveUnicodeAsAnsi Unicode string exists(%ws)\n",
                     WIDECHECK(pwcsWide)));

        //
        // We can use the pszAnsi pointer since it is NULL
        //

        Assert( pszAnsi == NULL);

        hr = MnkUnicodeToMulti( pwcsWide,
                                ccWide,
                                pszAnsi,
                                cbAnsi,
                                fFastConvert);

        Assert( (pszAnsi == NULL) || (cbAnsi == strlen(pszAnsi)+1) );

        //
        // A failure would mean out of memory, or some other terrible thing
        // happened.
        //

        if (FAILED(hr))
        {
            goto errRet;
        }

        //
        // If fFastConvert, then the UnicodeString was converted using a
        // truncation algorithm, and the resulting Ansi string can be saved
        // without the Unicode section appended
        //

        if (fFastConvert)
        {
            mnkDebugOut((DEB_ITRACE,
                         "::SaveUnicodeAsAnsi Fast converted wide(%ws) to (%s) cbAnsi(0x%x)\n",
                         WIDECHECK(pwcsWide),
                         ANSICHECK(pszAnsi),
                         cbAnsi));

            hr = WriteAnsiStringStream( pStm,
                                        pszAnsi,
                                        cbAnsi);
        }
        else
        {
            mnkDebugOut((DEB_ITRACE,
                         "::SaveUnicodeAsAnsi Full conversion wide(%ws) to (%s) cbAnsi(0x%x)\n",
                         WIDECHECK(pwcsWide),
                         ANSICHECK(pszAnsi),
                         cbAnsi));

            hr = WriteDoubleString( pStm,
                                    pwcsWide,
                                    ccWide,
                                    pszAnsi,
                                    cbAnsi);
        }

        //
        // We are done with the Ansi string.
        //
        // (KevinRo) It would be nice if we could get the double
        // string back from WriteDoubleString and cache it. Perhaps later
        // this can be done. [Suggestion]
        //

        PrivMemFree(pszAnsi);
    }

errRet:
    return(hr);
}

//+---------------------------------------------------------------------------
//
//  Method:     CItemMoniker::Save
//
//  Synopsis:   Save the moniker to a stream
//
//  Effects:    The first version of CItemMoniker stored two counted strings
//              in the stream. Both were stored in ANSI.
//
//              This version saves a UNICODE string on the end of the ANSI
//              string. Therefore, when it is read back in, the count of
//              bytes read as the ANSI string may include a UNICODE string.
//
//              We don't actually write the UNICODE string unless we have
//              to.
//
//  Arguments:  [pStm] --
//              [fClearDirty] --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:
//
//  History:    1-16-94   kevinro   Created
//
//  Notes:
//
//      There are two ways to create a CItemMoniker. Using CreateItemMoniker(),
//      and Load().
//
//      If we were Load()'d, then it will be the case that we already have an
//      Ansi version of both strings. In this case, we will just save those
//      Ansi strings back out. If they already contain the UNICODE sections,
//      then they are saved as part of the package. Hopefully, this will be
//      the common case.
//
//      Another possibility is the moniker was created using CreateItemMoniker.
//      If this is the case, then there are no Ansi versions of the strings.
//      We need to create Ansi strings, if possible. If we can't convert the
//      string to Ansi cleanly, then we need to save away a UNICODE section
//      of the string.
//
//----------------------------------------------------------------------------
STDMETHODIMP CItemMoniker::Save (LPSTREAM pStm, BOOL fClearDirty)
{
    mnkDebugOut((DEB_ITRACE,
                 "CItemMoniker::Save(%x)\n",
                 this));

    ValidateMoniker();

    VDATEIFACE(pStm);
    UNREFERENCED(fClearDirty);
    HRESULT hr;

    //
    // If a AnsiDelimiter exists, OR the UNICODE version is NULL, then
    // write out the Ansi version
    //

    hr = SaveUnicodeAsAnsi( pStm,
                            m_lpszDelimiter,
                            m_ccDelimiter,
                            m_pszAnsiDelimiter,
                            m_cbAnsiDelimiter);
    if (FAILED(hr))
    {
        mnkDebugOut((DEB_ITRACE,
                     "CItemMoniker::Save(%x) SaveUnicodeAsAnsi Delim failed (%x)\n",
                     this,
                     hr));
        goto errRet;
    }

    hr = SaveUnicodeAsAnsi( pStm,
                            m_lpszItem,
                            m_ccItem,
                            m_pszAnsiItem,
                            m_cbAnsiItem);
    if (FAILED(hr))
    {
        mnkDebugOut((DEB_ITRACE,
                     "CItemMoniker::Save(%x) SaveUnicodeAsAnsi Item failed (%x)\n",
                     this,
                     hr));
        goto errRet;
    }

errRet:

    return hr;
}


//+---------------------------------------------------------------------------
//
//  Method:     CItemMoniker::GetSizeMax
//
//  Synopsis:   Get the maximum size required to serialize this moniker
//
//  Effects:
//
//  Arguments:  [pcbSize] -- Place to return value
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:
//
//  History:    1-17-94   kevinro   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CItemMoniker::GetSizeMax (ULARGE_INTEGER FAR* pcbSize)
{
    ValidateMoniker();
    VDATEPTROUT(pcbSize, ULARGE_INTEGER);
    UINT cb = 0;

    //
    // The largest a UNICODE to MBSTRING should end up being is
    // 2 * character count.
    //
    if (m_lpszItem)
    {
        cb = (m_ccItem + 1) * 2 * sizeof(WCHAR);
    }
    if (m_lpszDelimiter)
    {
        cb += (m_ccDelimiter + 1) * 2 * sizeof(WCHAR);
    }

    //
    // sizeof(CLSID) accounts for the GUID that OleSaveToStream might
    // write on our behalf. The two ULONGs are the string lengths,
    // and cb is the max string sizes.
    //

    ULISet32(*pcbSize, sizeof(CLSID) + 2*(1 + sizeof(ULONG)) + cb);

    return(NOERROR);
}


#define dwModerateTime 2500
//  2.5 seconds divides immediate from moderate.

DWORD BindSpeedFromBindCtx( LPBC pbc )
{
    BIND_OPTS bindopts;
    HRESULT hresult;
    DWORD dwBindSpeed = BINDSPEED_INDEFINITE;

        bindopts.cbStruct = sizeof(bindopts);
    hresult = pbc->GetBindOptions( &bindopts );
    if (hresult != NOERROR) return dwBindSpeed;
    Assert( bindopts.cbStruct >= 16);
    if (bindopts.dwTickCountDeadline != 0)
    {
        if (bindopts.dwTickCountDeadline < dwModerateTime)
            dwBindSpeed = BINDSPEED_IMMEDIATE;
        else dwBindSpeed = BINDSPEED_MODERATE;
    }
    //  else speed = default, BINDSPEED_INDEFINITE
    return dwBindSpeed;
}

STDMETHODIMP CItemMoniker::BindToObject ( LPBC pbc,
        LPMONIKER pmkToLeft, REFIID iidResult,
        VOID FAR * FAR * ppvResult)
{
        M_PROLOG(this);
        VDATEPTROUT(ppvResult, LPVOID);
        *ppvResult = NULL;
        VDATEIFACE(pbc);
        if (pmkToLeft) VDATEIFACE(pmkToLeft);
        VDATEIID(iidResult);

        ValidateMoniker();
        HRESULT hresult;
        LPOLEITEMCONTAINER pOleCont;

        if (pmkToLeft)
        {
                hresult = pmkToLeft->BindToObject( pbc, NULL, IID_IOleItemContainer,
                        (LPVOID FAR*)&pOleCont);
                // AssertOutPtrIface(hresult, pOleCont);
                if (hresult != NOERROR) return hresult;

                hresult = RegisterContainerBound(pbc, pOleCont);
                hresult = pOleCont->GetObject(m_lpszItem, BindSpeedFromBindCtx(pbc),
                        pbc, iidResult, ppvResult);
                // AssertOutPtrIface(hresult, *ppvResult);
                pOleCont->Release();
                return hresult;
        }
        return ResultFromScode(E_INVALIDARG);   //      needs non-null moniker to left.
}


STDMETHODIMP CItemMoniker::BindToStorage (LPBC pbc, LPMONIKER
        pmkToLeft, REFIID riid, LPVOID FAR* ppvObj)
{
        M_PROLOG(this);
        VDATEPTROUT(ppvObj,LPVOID);
        *ppvObj = NULL;
        VDATEIFACE(pbc);
        if (pmkToLeft) VDATEIFACE(pmkToLeft);
        VDATEIID(riid);

        HRESULT hresult;
        LPOLEITEMCONTAINER pOleCont;

        ValidateMoniker();

        if (pmkToLeft)
        {
                hresult = pmkToLeft->BindToObject( pbc, NULL, IID_IOleItemContainer,
                        (LPVOID FAR*)&pOleCont);
                // AssertOutPtrIface(hresult, pOleCont);
                if (hresult != NOERROR) return hresult;
                hresult = RegisterContainerBound(pbc, pOleCont);
                hresult = pOleCont->GetObjectStorage(m_lpszItem, pbc,
                        riid, ppvObj);
                // AssertOutPtrIface(hresult, *ppvObj);
                pOleCont->Release();
                return hresult;
        }
        return ResultFromScode(E_INVALIDARG);   //      needs non-null moniker to left.
}



//+---------------------------------------------------------------------------
//
//  Method:     CItemMoniker::ComposeWith
//
//  Synopsis:   Compose this moniker with another moniker
//
//  Effects:
//
//  Arguments:  [pmkRight] --
//              [fOnlyIfNotGeneric] --
//              [ppmkComposite] --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:
//
//  History:    2-04-94   kevinro   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CItemMoniker::ComposeWith ( LPMONIKER pmkRight,
        BOOL fOnlyIfNotGeneric, LPMONIKER FAR* ppmkComposite)
{

    VDATEPTROUT(ppmkComposite,LPMONIKER);
    *ppmkComposite = NULL;
    VDATEIFACE(pmkRight);

    HRESULT hresult = NOERROR;

    ValidateMoniker();

    //
    // If this is an AntiMoniker, then we are going to ask the AntiMoniker
    // for the composite. This is a backward compatibility problem. Check
    // out the CAntiMoniker::EatOne() routine for details.
    //

    CAntiMoniker *pCAM = IsAntiMoniker(pmkRight);
    if (pCAM)
    {
        pCAM->EatOne(ppmkComposite);
    }
    else
    {
        if (!fOnlyIfNotGeneric)
        {
            hresult = CreateGenericComposite( this, pmkRight, ppmkComposite );
        }
        else
        {
            hresult = ResultFromScode(MK_E_NEEDGENERIC);
            *ppmkComposite = NULL;
        }
    }
    return hresult;
}



STDMETHODIMP CItemMoniker::Enum  (THIS_ BOOL fForward, LPENUMMONIKER FAR* ppenumMoniker)
{
        M_PROLOG(this);
        VDATEPTROUT(ppenumMoniker,LPENUMMONIKER);
        *ppenumMoniker = NULL;
        noError;
}



STDMETHODIMP CItemMoniker::IsEqual  (THIS_ LPMONIKER pmkOtherMoniker)
{
        M_PROLOG(this);
        VDATEIFACE(pmkOtherMoniker);

        ValidateMoniker();

        CItemMoniker FAR* pCIM = IsItemMoniker(pmkOtherMoniker);
        if (!pCIM)
            return ResultFromScode(S_FALSE);

        // the other moniker is a item moniker.
        // for the names, we do a case-insensitive compare.
        if (m_lpszItem && pCIM->m_lpszItem)
        {
            if (0 == lstrcmpiW(pCIM->m_lpszItem, m_lpszItem))
                return NOERROR; // S_TRUE;
        }
        else
            return (m_lpszItem || pCIM->m_lpszItem ? ResultFromScode(S_FALSE ) : NOERROR /*S_TRUE*/);

                return ResultFromScode(S_FALSE);

}



//+---------------------------------------------------------------------------
//
//  Method:     CItemMoniker::Hash
//
//  Synopsis:   Compute a hash value
//
//  Effects:    Computes a hash using the same basic algorithm as the
//              file moniker.
//
//  Arguments:  [pdwHash] --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:
//
//  History:    1-17-94   kevinro   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CItemMoniker::Hash  (THIS_ LPDWORD pdwHash)
{
    CLock2 lck(m_mxs); // protect m_fHashValueValid and m_dwHashValue

    VDATEPTROUT(pdwHash, DWORD);

    ValidateMoniker();
    if (m_fHashValueValid == FALSE)
    {
        m_dwHashValue = CalcFileMonikerHash(m_lpszItem, m_ccItem);
        m_fHashValueValid = TRUE;
    }
    *pdwHash = m_dwHashValue;

    return(NOERROR);
}


STDMETHODIMP CItemMoniker::IsRunning  (THIS_ LPBC pbc, LPMONIKER pmkToLeft,
                                      LPMONIKER pmkNewlyRunning)
{
    VDATEIFACE (pbc);
    HRESULT hresult;

    if (pmkToLeft)
        VDATEIFACE (pmkToLeft);
    if (pmkNewlyRunning)
        VDATEIFACE (pmkNewlyRunning);

    LPMONIKER pmk = NULL;
    LPOLEITEMCONTAINER pCont = NULL;
    LPRUNNINGOBJECTTABLE prot = NULL;

    if (pmkToLeft == NULL)
    {
        if (pmkNewlyRunning != NULL)
        {
            hresult = IsEqual(pmkNewlyRunning);
            if (hresult == NOERROR) goto errRet;
            hresult = IsEqual(pmkNewlyRunning);
            if (hresult != NOERROR)
            {
                hresult = ResultFromScode(S_FALSE);
                goto errRet;
            }
        }
        pbc->GetRunningObjectTable( &prot );
        //  check to see if "this" is in ROT
        hresult = prot->IsRunning(this);
        goto errRet;
    }

    hresult = pmkToLeft->IsRunning(pbc, NULL, NULL);
    if (hresult == NOERROR)
    {
        hresult = pmkToLeft->BindToObject(pbc, NULL, IID_IOleItemContainer,
                                          (LPVOID FAR *)&pCont );
        if (hresult == NOERROR)
        {
            // don't use RegisterContainerBound(pbc, pCont) here since we
            // will lock/unlock the container unecessarily and possibly
            // shut it down.
            hresult = pbc->RegisterObjectBound(pCont);
            if (hresult != NOERROR) goto errRet;
            hresult = pCont->IsRunning(m_lpszItem);
        }
    }
errRet:
    if (pCont) pCont->Release();
    if (prot) prot->Release();
    return hresult;
}



STDMETHODIMP CItemMoniker::GetTimeOfLastChange  (THIS_ LPBC pbc, LPMONIKER pmkToLeft,
        FILETIME FAR* pfiletime)
{
        M_PROLOG(this);
        VDATEIFACE(pbc);
        if (pmkToLeft) VDATEIFACE(pmkToLeft);
        VDATEPTROUT(pfiletime, FILETIME);

        ValidateMoniker();

        HRESULT hresult;
        LPMONIKER pmkTemp = NULL;
        LPRUNNINGOBJECTTABLE prot = NULL;

        if (pmkToLeft == NULL)
                return ResultFromScode(MK_E_NOTBINDABLE);
                        // Getting time of last change
                        // for an orphan item moniker.

        //      Check to see if the composite is in the running object table
        hresult = CreateGenericComposite( pmkToLeft, this, &pmkTemp );
        if (hresult != NOERROR) goto errRet;
        hresult = pbc->GetRunningObjectTable(& prot);
        if (hresult != NOERROR) goto errRet;
        hresult = prot->GetTimeOfLastChange( pmkTemp, pfiletime);
        if (hresult != MK_E_UNAVAILABLE) goto errRet;

        // if not, pass on to the left.
        hresult = pmkToLeft->GetTimeOfLastChange(pbc, NULL, pfiletime);
errRet:
        if (pmkTemp) pmkTemp->Release();
        if (prot) prot->Release();
        return hresult;
}



STDMETHODIMP CItemMoniker::Inverse  (THIS_ LPMONIKER FAR* ppmk)
{
        M_PROLOG(this);
        VDATEPTROUT(ppmk, LPMONIKER);
        return CreateAntiMoniker(ppmk);
}



STDMETHODIMP CItemMoniker::CommonPrefixWith  (LPMONIKER pmkOther, LPMONIKER FAR*
        ppmkPrefix)
{
    ValidateMoniker();
    VDATEPTROUT(ppmkPrefix,LPMONIKER);
    *ppmkPrefix = NULL;
    VDATEIFACE(pmkOther);

    if (!IsItemMoniker(pmkOther))
    {
        return(MonikerCommonPrefixWith(this,pmkOther,ppmkPrefix));
    }

    if (NOERROR == IsEqual(pmkOther))
    {
        *ppmkPrefix = this;
        AddRef();
        return ResultFromScode(MK_S_US);
    }
    return ResultFromScode(MK_E_NOPREFIX);
}



STDMETHODIMP CItemMoniker::RelativePathTo  (THIS_ LPMONIKER pmkOther, LPMONIKER FAR*
        ppmkRelPath)
{
    ValidateMoniker();
    VDATEPTROUT(ppmkRelPath,LPMONIKER);

    *ppmkRelPath = NULL;

    VDATEIFACE(pmkOther);

    return ResultFromScode(MK_E_NOTBINDABLE);
}



STDMETHODIMP CItemMoniker::GetDisplayName ( LPBC pbc, LPMONIKER
        pmkToLeft, LPWSTR FAR * lplpszDisplayName )
{
    mnkDebugOut((DEB_ITRACE,
                 "CItemMoniker::GetDisplayName(%x)\n",
                 this));

    ValidateMoniker();

    VDATEPTROUT(lplpszDisplayName, LPWSTR);
    *lplpszDisplayName = NULL;

    VDATEIFACE(pbc);

    if (pmkToLeft)
    {
        VDATEIFACE(pmkToLeft);
    }

    ULONG cc = m_ccItem + m_ccDelimiter;

    //
    // cc holds the count of characters. Make extra room for the NULL
    //

    *lplpszDisplayName = (LPWSTR) CoTaskMemAlloc(sizeof(WCHAR)*(1 + cc));

    if (*lplpszDisplayName == NULL)
    {
        mnkDebugOut((DEB_ITRACE,
                     "::GetDisplayName(%x) returning out of memory\n",
                     this));

        return E_OUTOFMEMORY;

    }

    //
    // To handle the case where both strings are NULL, we set the first
    // (and perhaps only) character to 0
    //

    *lplpszDisplayName[0] = 0;

    //
    // Concat the two strings. Don't forget the NULL! Thats what the
    // extra character is for.
    //

    if (m_lpszDelimiter != NULL)
    {
        memcpy( *lplpszDisplayName,
                m_lpszDelimiter,
                (m_ccDelimiter + 1) * sizeof(WCHAR));
    }

    //
    // The existing string was NULL terminated to just in case the
    // Item string is NULL.
    //
    // Concat the Item string on the end of the Delimiter Again, don't
    // forget the NULL.
    //

    if (m_lpszItem != NULL)
    {
        memcpy( *lplpszDisplayName + m_ccDelimiter,
                m_lpszItem,
                (m_ccItem + 1) * sizeof(WCHAR));
    }

    mnkDebugOut((DEB_ITRACE,
                 "::GetDisplayName(%x) returning %ws\n",
                 this,
                 *lplpszDisplayName));

    return(NOERROR);
}



//+---------------------------------------------------------------------------
//
//  Method:     CItemMoniker::ParseDisplayName
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:  [pbc] --        Bind Context
//              [pmkToLeft] --  Left moniker
//              [lpszDisplayName] -- String to parse
//              [pchEaten] --  Output number of characters eaten
//              [ppmkOut] -- Output moniker
//
//  Requires:
//      pmkToLeft MUST be valid. NULL is inappropriate
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:
//
//  History:    2-03-94   kevinro   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CItemMoniker::ParseDisplayName ( LPBC pbc,
                                              LPMONIKER pmkToLeft,
                                              LPWSTR lpszDisplayName,
                                              ULONG FAR* pchEaten,
                                              LPMONIKER FAR* ppmkOut)
{
    HRESULT hresult;
    VDATEPTRIN(lpszDisplayName, WCHAR);
    VDATEPTROUT(pchEaten,ULONG);
    VDATEPTROUT(ppmkOut,LPMONIKER);

    IParseDisplayName FAR * pPDN = NULL;
    IOleItemContainer FAR * pOIC = NULL;

    ValidateMoniker();

    *pchEaten = 0;
    *ppmkOut = NULL;

    VDATEIFACE(pbc);

    //
    // Item monikers require the moniker on the left to be non-null, so
    // they can get the container to parse the display name
    //

    if (pmkToLeft != NULL)
    {
        VDATEIFACE(pmkToLeft);
    }
    else
    {
        hresult = MK_E_SYNTAX;
        goto errRet;
    }


    hresult = pmkToLeft->BindToObject( pbc,
                                       NULL,
                                       IID_IOleItemContainer,
                                       (VOID FAR * FAR *)&pOIC );
    if (FAILED(hresult))
    {
        goto errRet;
    }

    hresult = RegisterContainerBound(pbc, pOIC);

    if (FAILED(hresult))
    {
        goto errRet;
    }

    hresult = pOIC->GetObject( m_lpszItem,
                               BindSpeedFromBindCtx(pbc),
                               pbc,
                               IID_IParseDisplayName,
                               (LPVOID FAR*)&pPDN);
    if (FAILED(hresult))
    {
        goto errRet;
    }

    hresult = pPDN->ParseDisplayName(pbc,
                                     lpszDisplayName,
                                     pchEaten,
                                     ppmkOut );
    if (FAILED(hresult))
    {
        goto errRet;
    }

    hresult = pbc->RegisterObjectBound( pPDN );

errRet:
    if (pPDN)
    {
        pPDN->Release();
    }

    if (pOIC)
    {
        pOIC->Release();
    }

    return hresult;
}


STDMETHODIMP CItemMoniker::IsSystemMoniker  (THIS_ LPDWORD pdwType)
{
        M_PROLOG(this);
        VDATEPTROUT(pdwType,DWORD);

        *pdwType = MKSYS_ITEMMONIKER;
        return NOERROR;
}

//+---------------------------------------------------------------------------
//
//  Method:     CItemMoniker::GetComparisonData
//
//  Synopsis:   Get comparison data for registration in the ROT
//
//  Arguments:  [pbData] - buffer to put the data in.
//              [cbMax] - size of the buffer
//              [pcbData] - count of bytes used in the buffer
//
//  Returns:    NOERROR
//              E_OUTOFMEMORY
//
//  Algorithm:  Build the ROT data from internal data of the item moniker.
//
//  History:    03-Feb-95   ricksa  Created
//
// Note:        Validating the arguments is skipped intentionally because this
//              will typically be called internally by OLE with valid buffers.
//
//----------------------------------------------------------------------------
STDMETHODIMP CItemMoniker::GetComparisonData(
    byte *pbData,
    ULONG cbMax,
    DWORD *pcbData)
{
    //
    // CLSID plus delimiter plus item plus one NULL
    //
    ULONG ulLength = sizeof(CLSID_ItemMoniker) +
                     (m_ccItem + m_ccDelimiter + 1) * sizeof(WCHAR);

    Assert(pcbData != NULL);
    Assert(pbData != NULL);

    if (cbMax < ulLength)
    {
        return(E_OUTOFMEMORY);
    }

    //
    // Copy the classID
    //
    memcpy(pbData,&CLSID_ItemMoniker,sizeof(CLSID_FileMoniker));

    //
    // Copy the delimiter WITHOUT the NULL. This saves a little space,
    // and allows us to uppercase them both as a single string
    //
    memcpy(pbData+sizeof(CLSID_FileMoniker),
           m_lpszDelimiter,
           m_ccDelimiter * sizeof(WCHAR));

    //
    // Copy the item plus the NULL
    //
    memcpy(pbData+sizeof(CLSID_FileMoniker)+(m_ccDelimiter * sizeof(WCHAR)),
           m_lpszItem,
           (m_ccItem + 1)*sizeof(WCHAR));

    //
    // Insure entire string is upper case, since the item monikers are spec'd
    // (and already do) case insensitive comparisions
    //
    CharUpperW((WCHAR *)(pbData+sizeof(CLSID_FileMoniker)));

    *pcbData = ulLength;

    return NOERROR;
}

#ifdef _DEBUG

STDMETHODIMP_(void) NC(CItemMoniker,CDebug)::Dump ( IDebugStream FAR * pdbstm)
{
        VOID_VDATEIFACE(pdbstm);

        *pdbstm << "CItemMoniker @" << (VOID FAR *)m_pItemMoniker;
        *pdbstm << '\n';
        pdbstm->Indent();
        *pdbstm << "Refcount is " << (int)(m_pItemMoniker->m_refs) << '\n';
        *pdbstm << "Item string is " << m_pItemMoniker->m_lpszItem << '\n';
        *pdbstm << "Delimiter is " << m_pItemMoniker->m_lpszDelimiter << '\n';
        pdbstm->UnIndent();
}

STDMETHODIMP_(BOOL) NC(CItemMoniker,CDebug)::IsValid ( BOOL fSuspicious )
{
        return ((LONG)(m_pItemMoniker->m_refs) > 0);
        //      add more later, maybe
}

#endif


//
// Unlock Delay object
//
class FAR CDelayUnlockContainer : public CPrivAlloc, public IUnknown
{
public:
        STDMETHOD(QueryInterface) ( REFIID iid, LPVOID FAR* ppvObj);
        STDMETHOD_(ULONG,AddRef) (void);
        STDMETHOD_(ULONG,Release) (void);

    CDelayUnlockContainer();

private:
    ULONG                               m_refs;
        IOleItemContainer FAR * m_pOleCont;

        friend INTERNAL RegisterContainerBound(LPBC pbc, LPOLEITEMCONTAINER pOleCont);
};


CDelayUnlockContainer::CDelayUnlockContainer()
{
        m_pOleCont = NULL;
        m_refs = 1;
}


STDMETHODIMP CDelayUnlockContainer::QueryInterface (REFIID iid, LPLPVOID ppv)
{
        M_PROLOG(this);
        if (IsEqualIID(iid, IID_IUnknown))
        {
                *ppv = this;
                AddRef();
                return NOERROR;
        }
        else {
                *ppv = NULL;
                return ResultFromScode(E_NOINTERFACE);
        }
}


STDMETHODIMP_(ULONG) CDelayUnlockContainer::AddRef ()
{
    return(InterlockedIncrement((long *)&m_refs));

}


STDMETHODIMP_(ULONG) CDelayUnlockContainer::Release ()
{
    if (InterlockedDecrement((long *)&m_refs) == 0)
    {
        if (m_pOleCont != NULL)
        {
            m_pOleCont->LockContainer(FALSE);
            m_pOleCont->Release();
        }
        delete this;
        return 0;
    }

    return 1;
}


INTERNAL RegisterContainerBound (LPBC pbc, LPOLEITEMCONTAINER pOleCont)
{
        // don't give the delay object the pOleCont before we lock it; do in
        // this order so error checking is correct and we don't lock/unlock
        // inappropriately.

        CDelayUnlockContainer FAR* pCDelay = new CDelayUnlockContainer();
        if (pCDelay == NULL)
                return ResultFromScode(E_OUTOFMEMORY);

        HRESULT hresult;
        if ((hresult = pbc->RegisterObjectBound(pCDelay)) != NOERROR)
                goto errRet;

        if ((hresult = pOleCont->LockContainer(TRUE)) != NOERROR) {
                // the delay object is still in the bindctx; no harm
                hresult = E_FAIL;
                goto errRet;
        }


        pCDelay->m_pOleCont = pOleCont;
        pOleCont->AddRef();

errRet:
        pCDelay->Release();
        return hresult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\com\moniker2\cmarshal.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1993 - 1993.
//
//  File:       cmarshal.cxx
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    12-27-93   ErikGav   Commented
//
//----------------------------------------------------------------------------

#include <ole2int.h>

#include "cbasemon.hxx"
#include "ccompmon.hxx"
#include "mnk.h"

CMarshalImplPStream::CMarshalImplPStream( LPPERSISTSTREAM pPS )
{
    GET_A5();
    m_pPS = pPS;
}



STDMETHODIMP CMarshalImplPStream::QueryInterface (THIS_
    REFIID riid, LPVOID FAR* ppvObj)
{
    M_PROLOG(this);
    *ppvObj = NULL;
    VDATEIID (riid);
    VDATEPTROUT (ppvObj, LPVOID);

    return m_pPS->QueryInterface(riid, ppvObj);
}



STDMETHODIMP_(ULONG) CMarshalImplPStream::AddRef (THIS)
{
    M_PROLOG(this);
    return m_pPS->AddRef();
}



STDMETHODIMP_(ULONG) CMarshalImplPStream::Release (THIS)
{
    M_PROLOG(this);
    return m_pPS->Release();
}


    // *** IMarshal methods ***
STDMETHODIMP CMarshalImplPStream::GetUnmarshalClass(REFIID riid, LPVOID pv,
    DWORD dwDestContext, LPVOID pvDestContext, DWORD mshlflags, CLSID FAR* pCid)
{
    M_PROLOG(this);
    VDATEIID (riid);
    VDATEPTROUT (pCid, CLSID);

    return m_pPS->GetClassID(pCid);
}



STDMETHODIMP CMarshalImplPStream::GetMarshalSizeMax (REFIID riid, LPVOID pv,
    DWORD dwDestContext, LPVOID pvDestContext, DWORD mshlflags, DWORD FAR* pSize)
{
    ULARGE_INTEGER ularge_integer;

    M_PROLOG(this);
    VDATEIID (riid);
    VDATEPTROUT (pSize, DWORD);

    LPMONIKER pmk;

    HRESULT hres;

    hres = m_pPS->QueryInterface(IID_IMoniker, (LPVOID FAR*)&pmk);
    if (hres == NOERROR)
    {
	CCompositeMoniker *pmkComp = IsCompositeMoniker(pmk);
	if (pmkComp)
	{
       DWORD size ;

       hres = CoGetMarshalSizeMax(pSize, riid, pmkComp->m_pmkLeft,
                  dwDestContext, pvDestContext, mshlflags) ;

       if (hres != NOERROR)
       {
           goto errRet ;
       }

       hres = CoGetMarshalSizeMax(&size, riid, pmkComp->m_pmkRight,
                  dwDestContext, pvDestContext, mshlflags) ;

       if (hres != NOERROR)
       {
           goto errRet ;
       }

	    *pSize += size + sizeof(CLSID);
	    goto errRet;
	}
	else
	{
	    hres = m_pPS->GetSizeMax( &ularge_integer );
	    if (hres == NOERROR)
	    *pSize = ularge_integer.LowPart;
	}
    }
    else
	hres = ResultFromScode(E_FAIL);
errRet:
    if (pmk) pmk->Release();
    return hres;
}

	
	
STDMETHODIMP CMarshalImplPStream::MarshalInterface (IStream FAR* pStm, REFIID riid,
    void FAR* pv, DWORD dwDestContext, LPVOID pvDestContext, DWORD mshlflags)
{
    M_PROLOG(this);
    VDATEIFACE (pStm);
    VDATEIID (riid);


    LPMONIKER pmk;
    CCompositeMoniker FAR* pmkComp;
    HRESULT hres;

    hres = m_pPS->QueryInterface(IID_IMoniker, (LPVOID FAR*)&pmk);
    if (hres == NOERROR)
    {
    if ((pmkComp = IsCompositeMoniker(pmk)) != NULL)
    {
	//  special code for the composite moniker case
	hres = CoMarshalInterface(pStm, riid, pmkComp->m_pmkLeft, dwDestContext,
	pvDestContext, mshlflags);

	if (hres != NOERROR) goto errRet;

	hres = CoMarshalInterface(pStm, riid, pmkComp->m_pmkRight, dwDestContext,
	pvDestContext, mshlflags);

	if (hres != NOERROR) goto errRet;
    }
    else
	hres = m_pPS->Save(pStm, FALSE);
    }
    else
    hres = ResultFromScode(E_FAIL);
errRet:
    if (pmk) pmk->Release();
    return hres;
}

	
	
STDMETHODIMP CMarshalImplPStream::UnmarshalInterface (IStream FAR* pStm,
    REFIID riid, void FAR* FAR* ppv)
{
    M_PROLOG(this);
    VDATEPTROUT (ppv, LPVOID);
    *ppv = NULL;
    VDATEIFACE (pStm);
    VDATEIID (riid);

    HRESULT hresult;
    LPMONIKER pmk = NULL;
    CCompositeMoniker FAR* pmkComp;

    hresult = m_pPS->QueryInterface(IID_IMoniker, (LPVOID FAR*)&pmk);
    if (hresult == NOERROR)
    {
    if ((pmkComp = IsCompositeMoniker(pmk)) != NULL)
    {
	//  special code for the composite moniker case
	hresult = CoUnmarshalInterface(pStm, IID_IMoniker,
	(LPVOID FAR*)&(pmkComp->m_pmkLeft));
	if (hresult != NOERROR) goto errRet;

	hresult = CoUnmarshalInterface(pStm, IID_IMoniker,
	(LPVOID FAR*)&(pmkComp->m_pmkRight));
	if (hresult != NOERROR) goto errRet;
    }
    else
    {
	hresult = m_pPS->Load(pStm);
    }
    }
    else
    hresult = ResultFromScode(E_FAIL);
    if (hresult == NOERROR)
    {
    hresult = m_pPS->QueryInterface(riid, ppv);
    }
errRet:
    if (pmk)
    pmk->Release();
    return hresult;
}


STDMETHODIMP CMarshalImplPStream::ReleaseMarshalData (IStream FAR* pStm)
{
    M_PROLOG(this);
    return NOERROR;
}


STDMETHODIMP CMarshalImplPStream::DisconnectObject (DWORD dwReserved)
{
    M_PROLOG(this);
    return NOERROR;
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\com\moniker2\classmon.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996.
//
//  File:       classmon.cxx
//
//  Contents:   Implementation of CClassMoniker
//
//  Classes:    CClassMoniker
//
//  Functions:  CreateClassMoniker
//
//  History:    22-Feb-96 ShannonC  Created
//              25-Feb-97 ShannonC  Use AsyncGetClassBits.
//
//----------------------------------------------------------------------------
#include <ole2int.h>
#include <classmon.hxx>
#include <dllhost.hxx>
#include <cfactory.hxx>
#include "mnk.h"

#ifndef OLETRACEIN
#define OLETRACEIN(x)
#endif

#ifndef OLETRACEOUT
#define OLETRACEOUT(x)
#endif

// This needs to be in a public header if it's still used.
// Comes from private\inet\urlmon\download\cdl.h
#define CD_FLAGS_NEED_CLASSFACTORY  0x4

HMODULE                     hUrlMon                       = 0;
ASYNCGETCLASSBITS          *pfnAsyncGetClassBits          = PrivAsyncGetClassBits;
REGISTERBINDSTATUSCALLBACK *pfnRegisterBindStatusCallback = PrivRegisterBindStatusCallback;
REVOKEBINDSTATUSCALLBACK   *pfnRevokeBindStatusCallback   = PrivRevokeBindStatusCallback;

#define REG_BSCB_HOLDER     OLESTR("_BSCB_Holder_")

//+---------------------------------------------------------------------------
//
//  Function:   CreateClassMoniker
//
//  Synopsis:   Creates a class moniker for the specified CLSID.
//
//  Arguments:  [rclsid]  -  Supplies the CLSID of the class.
//              [ppmk]    -  Returns interface pointer of the new moniker.
//
//  Returns:    S_OK
//              E_INVALIDARG
//              E_OUTOFMEMORY
//
//----------------------------------------------------------------------------
STDAPI CreateClassMoniker(
    REFCLSID   rclsid,
    IMoniker **ppmk)
{
    HRESULT   hr;
    CLSID     clsid;
    IMoniker *pmk;

    __try
    {
        OLETRACEIN((API_CreateClassMoniker,
                    PARAMFMT("rclsid= %I, ppmk= %p"),
                    &rclsid, ppmk));

        //Validate parameters.
        *ppmk = NULL;
        clsid = rclsid;

        pmk = new CClassMoniker(clsid);

        if (pmk != NULL)
        {
            *ppmk = pmk;
            hr = S_OK;
            CALLHOOKOBJECTCREATE(hr,
                                 CLSID_ClassMoniker,
                                 IID_IMoniker,
                                 (IUnknown **)ppmk);
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        hr = E_INVALIDARG;

    }

    OLETRACEOUT((API_CreateFileMoniker, hr));
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CClassMoniker::CClassMoniker
//
//  Synopsis:   Constructor for class moniker.
//
//  Arguments:  rclsid - Supplies the CLSID of the class.
//
//----------------------------------------------------------------------------
CClassMoniker::CClassMoniker(REFCLSID rclsid)
: _cRefs(1),
  _pExtra(NULL),
  _pszCodeBase(NULL),
  _dwFileVersionMS(0),
  _dwFileVersionLS(0)
{
    mnkDebugOut((DEB_ITRACE,
                "CClassMoniker::CClassMoniker(%x,%I)\n",
                this, &rclsid));

    _data.clsid = rclsid;
    _data.cbExtra = 0;
}

//+---------------------------------------------------------------------------
//
//  Method:     CClassMoniker::~CClassMoniker
//
//  Synopsis:   Constructor for class moniker.
//
//  Arguments:  rclsid - Supplies the CLSID of the class.
//
//----------------------------------------------------------------------------
CClassMoniker::~CClassMoniker()
{
    mnkDebugOut((DEB_ITRACE,
                "CClassMoniker::~CClassMoniker(%x)\n",
                this));

    if(_pExtra != NULL)
    {
        PrivMemFree(_pExtra);
    }
}


//+---------------------------------------------------------------------------
//
//  Method:     CClassMoniker::SetParameters
//
//  Synopsis:   Set the parameters on the class moniker
//
//  Arguments:  pszName -  Name of the parameter.
//              pszValue - Value of the parameter.
//
//----------------------------------------------------------------------------
HRESULT CClassMoniker::SetParameters(
    LPCWSTR pszParameters)
{
    HRESULT hr = S_OK;

    //Free the old data.
    if(_pExtra != NULL)
    {
        PrivMemFree(_pExtra);
        _pExtra = NULL;
    }

     if(pszParameters != NULL)
     {
        _data.cbExtra = lstrlenW(pszParameters) * sizeof(WCHAR) + sizeof(WCHAR);

        //Allocate memory for the extra bytes.
        _pExtra = PrivMemAlloc(_data.cbExtra);

        if(_pExtra != 0)
        {
            memcpy(_pExtra, pszParameters, _data.cbExtra);
            hr = S_OK;
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }

    return hr;
}


//+---------------------------------------------------------------------------
//
//  Method:     CClassMoniker::QueryInterface
//
//  Synopsis:   Gets a pointer to the specified interface.  The class
//              moniker supports the IMarshal, IMoniker, IPersistStream,
//              IPersist, IROTData, and IUnknown interfaces.  The class
//              moniker also supports CLSID_ClassMoniker so that the
//              IsEqual method can directly access the data members.
//
//  Arguments:  [iid] -- the requested interface
//              [ppv] -- where to put the interface pointer
//
//  Returns:    S_OK
//              E_INVALIDARG
//              E_NOINTERFACE
//
//  Notes:      Bad parameters will raise an exception.  The exception
//              handler catches exceptions and returns E_INVALIDARG.
//
//----------------------------------------------------------------------------
STDMETHODIMP CClassMoniker::QueryInterface(
    REFIID riid,
    void **ppv)
{
    HRESULT hr;

    __try
    {
        mnkDebugOut((DEB_ITRACE,
                    "CClassMoniker::QueryInterface(%x,%I,%x)\n",
                    this, &riid, ppv));

        //Parameter validation.
        *ppv = NULL;

        if (IsEqualIID(riid, IID_IMarshal))
        {
            AddRef();
            *ppv = (IMarshal *) this;
            hr = S_OK;
        }
        else if (IsEqualIID(riid, IID_IUnknown)
                 || IsEqualIID(riid, IID_IMoniker)
                 || IsEqualIID(riid, IID_IPersistStream)
                 || IsEqualIID(riid, IID_IPersist))
        {
            AddRef();
            *ppv = (IMoniker *) this;
            hr = S_OK;
        }
        else if (IsEqualIID(riid, IID_IROTData))
        {
            AddRef();
            *ppv = (IROTData *) this;
            hr =  S_OK;
        }
        else if (IsEqualIID(riid, CLSID_ClassMoniker))
        {
            AddRef();
            *ppv = (CClassMoniker *) this;
            hr =  S_OK;
        }
        else
        {
            hr = E_NOINTERFACE;
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        hr = E_INVALIDARG;
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CClassMoniker::AddRef
//
//  Synopsis:   Increment the reference count.
//
//  Arguments:  void
//
//  Returns:    ULONG -- the new reference count
//
//  Notes:      Use InterlockedIncrement to make it multi-thread safe.
//
//----------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CClassMoniker::AddRef(void)
{
    mnkDebugOut((DEB_ITRACE,
                "CClassMoniker::AddRef(%x)\n",
                this));

    InterlockedIncrement(&_cRefs);
    return _cRefs;
}

//+---------------------------------------------------------------------------
//
//  Method:     CClassMoniker::Release
//
//  Synopsis:   Decrement the reference count.
//
//  Arguments:  void
//
//  Returns:    ULONG -- the remaining reference count
//
//  Notes:      Use InterlockedDecrement to make it multi-thread safe.
//              We use a local variable so that we don't access
//              a data member after decrementing the reference count.
//
//----------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CClassMoniker::Release(void)
{
    ULONG count = _cRefs - 1;

    mnkDebugOut((DEB_ITRACE,
                "CClassMoniker::Release(%x)\n",
                this));

    if(0 == InterlockedDecrement(&_cRefs))
    {
            delete this;
            count = 0;
    }

    return count;
}


//+---------------------------------------------------------------------------
//
//  Method:     CClassMoniker::GetClassID
//
//  Synopsis:   Gets the class ID of the object.
//
//----------------------------------------------------------------------------
STDMETHODIMP CClassMoniker::GetClassID(
    CLSID *pClassID)
{
    HRESULT hr;

    mnkDebugOut((DEB_ITRACE,
                "CClassMoniker::GetClassID(%x,%x)\n",
                this, pClassID));

    __try
    {

        *pClassID = CLSID_ClassMoniker;
        hr = S_OK;
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        hr = E_INVALIDARG;
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CClassMoniker::IsDirty
//
//  Synopsis:   Checks the object for changes since it was last saved.
//
//----------------------------------------------------------------------------
STDMETHODIMP CClassMoniker::IsDirty()
{
    mnkDebugOut((DEB_ITRACE,
                "CClassMoniker::IsDirty(%x)\n",
                this));

    return S_FALSE;
}

//+---------------------------------------------------------------------------
//
//  Method:     CClassMoniker::Load
//
//  Synopsis:   Loads a class moniker from a stream
//
//----------------------------------------------------------------------------
STDMETHODIMP CClassMoniker::Load(
    IStream *pStream)
{
    HRESULT hr;
    ULONG   cbRead;

    mnkDebugOut((DEB_ITRACE,
                "CClassMoniker::Load(%x,%x)\n",
                this, pStream));

    __try
    {
        hr = pStream->Read(&_data, sizeof(_data), &cbRead);

        if(SUCCEEDED(hr))
        {
            if(sizeof(_data) == cbRead)
            {
                if(_data.cbExtra != 0)
                {
                    //Free the old buffer if necessary.
                    if(_pExtra != NULL)
                    {
                        PrivMemFree(_pExtra);
                    }

                    //Allocate buffer and read the extra bytes.
                    _pExtra = PrivMemAlloc(_data.cbExtra);
                    if(_pExtra != NULL)
                    {
                        hr = pStream->Read(_pExtra,
                                           _data.cbExtra,
                                           &cbRead);
                        if(SUCCEEDED(hr))
                        {
                            if(cbRead == _data.cbExtra)
                                hr = S_OK;
                            else
                                hr = STG_E_READFAULT;
                        }
                    }
                    else
                    {
                        hr = E_OUTOFMEMORY;
                    }
                }
                else
                {
                    hr = S_OK;
                }
            }
            else
            {
                hr = STG_E_READFAULT;
            }
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        hr = E_INVALIDARG;
    }

    return hr;
}


//+---------------------------------------------------------------------------
//
//  Method:     CClassMoniker::Save
//
//  Synopsis:   Save the class moniker to a stream
//
//----------------------------------------------------------------------------
STDMETHODIMP CClassMoniker::Save(
    IStream *pStream,
    BOOL     fClearDirty)
{
    HRESULT hr;

    mnkDebugOut((DEB_ITRACE,
                "CClassMoniker::Save(%x,%x,%x)\n",
                this, pStream, fClearDirty));

    __try
    {
        hr = pStream->Write(&_data, sizeof(_data), NULL);
        if(SUCCEEDED(hr) && _pExtra != NULL && _data.cbExtra > 0)
        {
            //Write the extra bytes.
            hr = pStream->Write(_pExtra, _data.cbExtra, NULL);
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        hr = E_INVALIDARG;
    }

    return hr;
}


//+---------------------------------------------------------------------------
//
//  Method:     CClassMoniker::GetSizeMax
//
//  Synopsis:   Get the maximum size required to serialize this moniker
//
//----------------------------------------------------------------------------
STDMETHODIMP CClassMoniker::GetSizeMax(
    ULARGE_INTEGER * pcbSize)
{
    HRESULT hr;

    mnkDebugOut((DEB_ITRACE,
                "CClassMoniker::GetSizeMax(%x,%x)\n",
                this, pcbSize));

    __try
    {
        ULISet32(*pcbSize, sizeof(_data) + _data.cbExtra);
        hr = S_OK;
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        hr = E_INVALIDARG;
    }

    return hr;
}


//+---------------------------------------------------------------------------
//
//  Method:     CClassMoniker::BindToObject
//
//  Synopsis:   Bind to the object named by this moniker.
//
//  Notes:  If pmkToLeft is zero, then the class moniker calls
//          AsyncGetClassBits to get the class object.
//
//          If pmkToLeft is non-zero, then the class moniker binds to the
//          IClassActivator interface and then calls
//          IClassActivator::GetClassObject.
//
//----------------------------------------------------------------------------
STDMETHODIMP CClassMoniker::BindToObject (
    IBindCtx *pbc,
    IMoniker *pmkToLeft,
    REFIID    riid,
    void **   ppv)
{
    HRESULT    hr;
    BIND_OPTS2 bindOpts;

    __try
    {
        mnkDebugOut((DEB_ITRACE,
                    "CClassMoniker::BindToObject(%x,%x,%x,%I,%x)\n",
                    this, pbc, pmkToLeft, &riid, ppv));

        //Validate parameters
        *ppv = NULL;

        bindOpts.cbStruct = sizeof(bindOpts);
        hr = pbc->GetBindOptions(&bindOpts);

        if(SUCCEEDED(hr))
        {
            if(bindOpts.cbStruct < sizeof(BIND_OPTS2))
            {
               //Initialize the new BIND_OPTS2 fields
               bindOpts.dwTrackFlags = 0;
               bindOpts.locale = GetThreadLocale();
               bindOpts.pServerInfo = 0;
               bindOpts.dwClassContext = CLSCTX_SERVER;
            }

            if(NULL == pmkToLeft)
            {
                if(!bindOpts.pServerInfo)
                {
                    IUrlMon *pUrlMon = NULL;

                    hr = ApartmentDllGetClassObject(CLSID_UrlMonWrapper,
                                                    IID_IUrlMon,
                                                    (void **) &pUrlMon);
                    if(SUCCEEDED(hr) && pUrlMon)
                    {
                        hr = pUrlMon->AsyncGetClassBits(_data.clsid,
                                                        NULL,
                                                        NULL,
                                                        _dwFileVersionMS,
                                                        _dwFileVersionLS,
                                                        _pszCodeBase,
                                                        pbc,
                                                        bindOpts.dwClassContext,
                                                        riid,
                                                        CD_FLAGS_NEED_CLASSFACTORY);
                    }

                    if(pUrlMon)
                        pUrlMon->Release();
                }

                if(SUCCEEDED(hr) && (hr != MK_S_ASYNCHRONOUS))
                {
                    hr = CoGetClassObject(_data.clsid,
                                          bindOpts.dwClassContext | CLSCTX_NO_CODE_DOWNLOAD,
                                          bindOpts.pServerInfo,
                                          riid,
                                          ppv);
                }
            }
            else
            {
                IClassActivator *pActivate;

                hr = pmkToLeft->BindToObject(pbc,
                                             NULL,
                                             IID_IClassActivator,
                                             (void **) &pActivate);

                if(SUCCEEDED(hr))
                {
                    hr = pActivate->GetClassObject(_data.clsid,
                                                   bindOpts.dwClassContext,
                                                   bindOpts.locale,
                                                   riid,
                                                   ppv);

                    pActivate->Release();
                }
            }
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        hr = E_INVALIDARG;
    }

    return hr;
}


//+---------------------------------------------------------------------------
//
//  Method:     CClassMoniker::BindToStorage
//
//  Synopsis:   Bind to the storage for the object named by the moniker.
//
//----------------------------------------------------------------------------
STDMETHODIMP CClassMoniker::BindToStorage(
    IBindCtx *pbc,
    IMoniker *pmkToLeft,
    REFIID    riid,
    void **   ppv)
{
    HRESULT hr;

    mnkDebugOut((DEB_ITRACE,
                "CClassMoniker::BindToStorage(%x,%x,%x,%I,%x)\n",
                this, pbc, pmkToLeft, &riid, ppv));

    hr = BindToObject(pbc, pmkToLeft, riid, ppv);

    return hr;
}


//+---------------------------------------------------------------------------
//
//  Method:     CClassMoniker::Reduce
//
//  Synopsis:   Reduce the moniker.
//
//----------------------------------------------------------------------------
STDMETHODIMP CClassMoniker::Reduce(
    IBindCtx *  pbc,
    DWORD       dwReduceHowFar,
    IMoniker ** ppmkToLeft,
    IMoniker ** ppmkReduced)
{
    HRESULT hr;

    mnkDebugOut((DEB_ITRACE,
                "CClassMoniker::Reduce(%x,%x,%x,%x,%x)\n",
                this, pbc, dwReduceHowFar, ppmkToLeft, ppmkReduced));

    __try
    {
        //Validate parameters.
        *ppmkReduced = NULL;

        AddRef();
        *ppmkReduced = (IMoniker *) this;
        hr = MK_S_REDUCED_TO_SELF;
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        hr = E_INVALIDARG;
    }

    return hr;
}


//+---------------------------------------------------------------------------
//
//  Method:     CClassMoniker::ComposeWith
//
//  Synopsis:   Compose another moniker onto the end of this moniker.
//
//----------------------------------------------------------------------------
STDMETHODIMP CClassMoniker::ComposeWith(
    IMoniker * pmkRight,
    BOOL       fOnlyIfNotGeneric,
    IMoniker **ppmkComposite)
{
    HRESULT   hr;
    IMoniker *pmk;

    mnkDebugOut((DEB_ITRACE,
                "CClassMoniker::ComposeWith(%x,%x,%x,%x)\n",
                this, pmkRight, fOnlyIfNotGeneric, ppmkComposite));

    __try
    {
        //Validate parameters.
        *ppmkComposite = NULL;

        //Check for an anti-moniker
        hr = pmkRight->QueryInterface(CLSID_AntiMoniker, (void **)&pmk);

        if(FAILED(hr))
        {
            //pmkRight is not an anti-moniker.
            if (!fOnlyIfNotGeneric)
            {
                hr = CreateGenericComposite(this, pmkRight, ppmkComposite);
            }
            else
            {
                hr = MK_E_NEEDGENERIC;
            }
        }
        else
        {
            //pmkRight is an anti-moniker.
            pmk->Release();
            hr = S_OK;
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        hr = E_INVALIDARG;
    }

    return hr;
}



//+---------------------------------------------------------------------------
//
//  Method:     CClassMoniker::Enum
//
//  Synopsis:   Enumerate the components of this moniker.
//
//----------------------------------------------------------------------------
STDMETHODIMP CClassMoniker::Enum(
    BOOL            fForward,
    IEnumMoniker ** ppenumMoniker)
{
    HRESULT hr;

    mnkDebugOut((DEB_ITRACE,
                "CClassMoniker::Enum(%x,%x,%x)\n",
                this, fForward, ppenumMoniker));

    __try
    {
        *ppenumMoniker = NULL;
        hr = S_OK;
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        hr = E_INVALIDARG;
    }

    return hr;
}



//+---------------------------------------------------------------------------
//
//  Method:     CClassMoniker::IsEqual
//
//  Synopsis:   Compares with another moniker.
//
//----------------------------------------------------------------------------
STDMETHODIMP CClassMoniker::IsEqual(
    IMoniker *pmkOther)
{
    HRESULT        hr;
    CClassMoniker *pClassMoniker;

    mnkDebugOut((DEB_ITRACE,
                "CClassMoniker::IsEqual(%x,%x)\n",
                this, pmkOther));

    __try
    {
        hr = pmkOther->QueryInterface(CLSID_ClassMoniker,
                                      (void **) &pClassMoniker);

        if(SUCCEEDED(hr))
        {
            if(IsEqualCLSID(_data.clsid,
                            pClassMoniker->_data.clsid))
            {
                hr = S_OK;
            }
            else
            {
                hr = S_FALSE;
            }

            pClassMoniker->Release();
        }
        else
        {
            hr = S_FALSE;
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        hr = E_INVALIDARG;
    }

    return hr;
}


//+---------------------------------------------------------------------------
//
//  Method:     CClassMoniker::Hash
//
//  Synopsis:   Compute a hash value
//
//----------------------------------------------------------------------------
STDMETHODIMP CClassMoniker::Hash(
    DWORD * pdwHash)
{
    HRESULT hr;

    mnkDebugOut((DEB_ITRACE,
                "CClassMoniker::Hash(%x,%x)\n",
                this, pdwHash));

    __try
    {
        *pdwHash = _data.clsid.Data1;
        hr = S_OK;
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        hr = E_INVALIDARG;
    }

    return hr;
}


//+---------------------------------------------------------------------------
//
//  Method:     CClassMoniker::IsRunning
//
//  Synopsis:   Determines if the object identified by this moniker is
//              running.  Since we can't search the class table to determine
//              if the object is running, we just return E_NOTIMPL.
//
//----------------------------------------------------------------------------
STDMETHODIMP CClassMoniker::IsRunning(
    IBindCtx * pbc,
    IMoniker * pmkToLeft,
    IMoniker * pmkNewlyRunning)
{
    mnkDebugOut((DEB_ITRACE,
                "CClassMoniker::IsRunning(%x,%x,%x,%x)\n",
                this, pbc, pmkToLeft, pmkNewlyRunning));

    return E_NOTIMPL;
}


//+---------------------------------------------------------------------------
//
//  Method:     CClassMoniker::GetTimeOfLastChange
//
//  Synopsis:  Returns the time when the object identified by this moniker
//             was changed.
//
//----------------------------------------------------------------------------
STDMETHODIMP CClassMoniker::GetTimeOfLastChange (
    IBindCtx * pbc,
    IMoniker * pmkToLeft,
    FILETIME * pFileTime)
{
    mnkDebugOut((DEB_ITRACE,
                "CClassMoniker::GetTimeOfLastChange(%x,%x,%x,%x)\n",
                this, pbc, pmkToLeft, pFileTime));

    return MK_E_UNAVAILABLE;
}



//+---------------------------------------------------------------------------
//
//  Method:     CClassMoniker::Inverse
//
//  Synopsis:  Returns the inverse of this moniker.
//
//----------------------------------------------------------------------------
STDMETHODIMP CClassMoniker::Inverse(
    IMoniker ** ppmk)
{
    mnkDebugOut((DEB_ITRACE,
                "CClassMoniker::Inverse(%x,%x)\n",
                this, ppmk));

    return CreateAntiMoniker(ppmk);
}



//+---------------------------------------------------------------------------
//
//  Method:     CClassMoniker::CommonPrefixWith
//
//  Synopsis:  Returns the common prefix shared by this moniker and the
//             other moniker.
//
//----------------------------------------------------------------------------
STDMETHODIMP CClassMoniker::CommonPrefixWith(
    IMoniker *  pmkOther,
    IMoniker ** ppmkPrefix)
{
    HRESULT        hr;
    CClassMoniker *pClassMoniker;

    mnkDebugOut((DEB_ITRACE,
                "CClassMoniker::CommonPrefixWith(%x,%x,%x)\n",
                this, pmkOther, ppmkPrefix));

    __try
    {
        //Validate parameters.
        *ppmkPrefix = NULL;

        hr = pmkOther->QueryInterface(CLSID_ClassMoniker,
                                      (void **) &pClassMoniker);

        if(SUCCEEDED(hr))
        {
            if(IsEqualCLSID(_data.clsid,
                            pClassMoniker->_data.clsid))
            {
                AddRef();
                *ppmkPrefix = (IMoniker *) this;
                hr = MK_S_US;
            }
            else
            {
                hr = MK_E_NOPREFIX;
            }

            pClassMoniker->Release();
        }
        else
        {
            hr = MonikerCommonPrefixWith(this, pmkOther, ppmkPrefix);
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        hr = E_INVALIDARG;
    }

    return hr;
}



//+---------------------------------------------------------------------------
//
//  Method:     CClassMoniker::RelativePathTo
//
//  Synopsis:  Returns the relative path between this moniker and the
//             other moniker.
//
//----------------------------------------------------------------------------
STDMETHODIMP CClassMoniker::RelativePathTo(
    IMoniker *  pmkOther,
    IMoniker ** ppmkRelPath)
{
    HRESULT hr;

    mnkDebugOut((DEB_ITRACE,
                "CClassMoniker::RelativePathTo(%x,%x,%x)\n",
                this, pmkOther, ppmkRelPath));

    __try
    {
        *ppmkRelPath = NULL;
        hr = MonikerRelativePathTo(this, pmkOther, ppmkRelPath, TRUE);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        hr = E_INVALIDARG;
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CClassMoniker::GetDisplayName
//
//  Synopsis:   Get the display name of this moniker.
//
//  Notes:      Call ProgIDFromClassID to get the ProgID
//              Append a ':' to the end of the string.
//              If no ProgID is available, then use
//              clsid:xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx;parameters:
//
//----------------------------------------------------------------------------
STDMETHODIMP CClassMoniker::GetDisplayName(
    IBindCtx * pbc,
    IMoniker * pmkToLeft,
    LPWSTR   * lplpszDisplayName)
{
    HRESULT hr = E_FAIL;
    LPWSTR pszDisplayName;

    mnkDebugOut((DEB_ITRACE,
                "CClassMoniker::GetDisplayName(%x,%x,%x,%x)\n",
                this, pbc, pmkToLeft, lplpszDisplayName));

    __try
    {
        LPWSTR pszPrefix;
        WCHAR szClassID[37];

        LPWSTR pszParameters = (LPWSTR) _pExtra;

        if((lstrlenW(pszParameters) * sizeof(WCHAR)) > _data.cbExtra)
            return E_INVALIDARG;

        //Validate parameters.
        *lplpszDisplayName = NULL;


        //Create a display name from the class ID.
        //Get the class ID string.
        wStringFromUUID(_data.clsid, szClassID);

        //Get the prefix
        hr = ProgIDFromCLSID(CLSID_ClassMoniker,
                             &pszPrefix);

        if(SUCCEEDED(hr))
        {
            ULONG  cName;
            cName = lstrlenW(pszPrefix) + 1 + lstrlenW(szClassID);
            if(pszParameters != NULL)
            {
                cName += lstrlenW(pszParameters);
            }
            cName += 2;

            pszDisplayName = (LPWSTR) CoTaskMemAlloc(cName * sizeof(wchar_t));
            if(pszDisplayName != NULL)
            {
                lstrcpyW(pszDisplayName, pszPrefix);
                lstrcatW(pszDisplayName, L":");
                lstrcatW(pszDisplayName, szClassID);
                if(pszParameters != NULL)
                {
                    lstrcatW(pszDisplayName, pszParameters);
                }

                lstrcatW(pszDisplayName, L":");
                *lplpszDisplayName = pszDisplayName;
                hr = S_OK;
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
            CoTaskMemFree(pszPrefix);
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        hr = E_INVALIDARG;
    }

    return hr;
}



//+---------------------------------------------------------------------------
//
//  Method:     CClassMoniker::ParseDisplayName
//
//  Synopsis:   Parse the display name.
//
//  Algorithm:  Call BindToObject to get an IParseDisplayName on the class
//              object.  Call IParseDisplayName::ParseDisplayName on the
//              class object.
//
//----------------------------------------------------------------------------
STDMETHODIMP CClassMoniker::ParseDisplayName (
    IBindCtx *  pbc,
    IMoniker *  pmkToLeft,
    LPWSTR      lpszDisplayName,
    ULONG    *  pchEaten,
    IMoniker ** ppmkOut)
{
    HRESULT            hr;
    IParseDisplayName *pPDN;

    mnkDebugOut((DEB_ITRACE,
                "CClassMoniker::ParseDisplayName(%x,%x,%x,%ws,%x,%x)\n",
                this, pbc, pmkToLeft, lpszDisplayName, pchEaten, ppmkOut));

    __try
    {
        //Validate parameters
        *ppmkOut = NULL;
        *pchEaten = 0;

        hr = BindToObject(pbc,
                          pmkToLeft,
                          IID_IParseDisplayName,
                          (void **) &pPDN);

        if(SUCCEEDED(hr))
        {
            //Register the object with the bind context.
            hr = pbc->RegisterObjectBound(pPDN);
            if(SUCCEEDED(hr))
            {
                //Parse the display name.
                hr = pPDN->ParseDisplayName(pbc,
                                            lpszDisplayName,
                                            pchEaten,
                                            ppmkOut);
            }
            pPDN->Release();
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        hr = E_INVALIDARG;
    }

    return hr;
}


//+---------------------------------------------------------------------------
//
//  Method:     CClassMoniker::IsSystemMoniker
//
//  Synopsis:   Determines if this is one of the system supplied monikers.
//
//----------------------------------------------------------------------------
STDMETHODIMP CClassMoniker::IsSystemMoniker(
    DWORD * pdwType)
{
    HRESULT hr;

    mnkDebugOut((DEB_ITRACE,
                "CClassMoniker::IsSystemMoniker(%x,%x)\n",
                this, pdwType));

    __try
    {
        *pdwType = MKSYS_CLASSMONIKER;
        hr = S_OK;
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        hr = E_INVALIDARG;
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CClassMoniker::GetComparisonData
//
//  Synopsis:   Get comparison data for registration in the ROT
//
//----------------------------------------------------------------------------
STDMETHODIMP CClassMoniker::GetComparisonData(
    byte * pbData,
    ULONG  cbMax,
    DWORD *pcbData)
{
    HRESULT hr;

    mnkDebugOut((DEB_ITRACE,
                "CClassMoniker::GetComparisonData(%x,%x,%x,%x)\n",
                this, pbData, cbMax, pcbData));

    __try
    {
        *pcbData = 0;
        if(cbMax >= sizeof(CLSID_ClassMoniker) + sizeof(_data.clsid))
        {
            memcpy(pbData, &CLSID_ClassMoniker, sizeof(CLSID_ClassMoniker));
            pbData += sizeof(CLSID);
            memcpy(pbData, &_data.clsid, sizeof(_data.clsid));
            *pcbData = sizeof(CLSID_ClassMoniker) + sizeof(_data.clsid);
            hr = S_OK;
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        hr = E_INVALIDARG;
    }

    return hr;
}


//+---------------------------------------------------------------------------
//
//  Method:     CClassMoniker::GetUnmarshalClass
//
//  Synopsis:   Get the class ID.
//
//----------------------------------------------------------------------------
STDMETHODIMP CClassMoniker::GetUnmarshalClass(
    REFIID  riid,
    LPVOID  pv,
    DWORD   dwDestContext,
    LPVOID  pvDestContext,
    DWORD   mshlflags,
    CLSID * pClassID)
{
    mnkDebugOut((DEB_ITRACE,
                "CClassMoniker::GetUnmarshalClass(%x,%I,%x,%x,%x,%x,%x)\n",
                this, &riid, pv, dwDestContext, pvDestContext, mshlflags,
                pClassID));

    return GetClassID(pClassID);
}



//+---------------------------------------------------------------------------
//
//  Method:     CClassMoniker::GetMarshalSizeMax
//
//  Synopsis:   Get maximum size of marshalled moniker.
//
//----------------------------------------------------------------------------
STDMETHODIMP CClassMoniker::GetMarshalSizeMax(
    REFIID riid,
    LPVOID pv,
    DWORD  dwDestContext,
    LPVOID pvDestContext,
    DWORD  mshlflags,
    DWORD *pSize)
{
    HRESULT hr;

    mnkDebugOut((DEB_ITRACE,
                "CClassMoniker::GetMarshalSizeMax(%x,%I,%x,%x,%x,%x,%x)\n",
                this, &riid, pv, dwDestContext, pvDestContext, mshlflags,
                pSize));

    __try
    {
        *pSize =  sizeof(_data) + _data.cbExtra;
        hr = S_OK;
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        hr = E_INVALIDARG;
    }

    return hr;
}


//+---------------------------------------------------------------------------
//
//  Method:     CClassMoniker::MarshalInterface
//
//  Synopsis:   Marshal moniker into a stream.
//
//----------------------------------------------------------------------------
STDMETHODIMP CClassMoniker::MarshalInterface(
    IStream * pStream,
    REFIID    riid,
    void    * pv,
    DWORD     dwDestContext,
    LPVOID    pvDestContext,
    DWORD     mshlflags)
{
    mnkDebugOut((DEB_ITRACE,
                "CClassMoniker::MarshalInterface(%x,%x,%I,%x,%x,%x,%x)\n",
                this, pStream, &riid, pv, dwDestContext, pvDestContext,
                mshlflags));

    return Save(pStream, FALSE);
}



//+---------------------------------------------------------------------------
//
//  Method:     CClassMoniker::UnmarshalInterface
//
//  Synopsis:   Unmarshal moniker from a stream.
//
//----------------------------------------------------------------------------
STDMETHODIMP CClassMoniker::UnmarshalInterface(
    IStream * pStream,
    REFIID    riid,
    void   ** ppv)
{
    HRESULT hr;

    mnkDebugOut((DEB_ITRACE,
                "CClassMoniker::UnmarshalInterface(%x,%x,%I,%x)\n",
                this, pStream, &riid, ppv));

    __try
    {
        //Validate parameters.
        *ppv = NULL;

        hr = Load(pStream);

        if(SUCCEEDED(hr))
        {
            hr = QueryInterface(riid, ppv);
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        hr = E_INVALIDARG;
    }

    return hr;
}


//+---------------------------------------------------------------------------
//
//  Method:     CClassMoniker::ReleaseMarshalData
//
//  Synopsis:   Release a marshalled class moniker.
//              Just seek to the end of the marshalled class moniker.
//
//----------------------------------------------------------------------------
STDMETHODIMP CClassMoniker::ReleaseMarshalData(
    IStream * pStream)
{
    HRESULT hr;
    LARGE_INTEGER liSize;

    mnkDebugOut((DEB_ITRACE,
                "CClassMoniker::ReleaseMarshalData(%x,%x)\n",
                this, pStream));

    hr = GetSizeMax((ULARGE_INTEGER *) &liSize);
    if(SUCCEEDED(hr))
    {
        hr = pStream->Seek(liSize, STREAM_SEEK_CUR, NULL);
    }
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Method:     CClassMoniker::DisconnectObject
//
//  Synopsis:   Disconnect the object.
//
//----------------------------------------------------------------------------
STDMETHODIMP CClassMoniker::DisconnectObject(
    DWORD dwReserved)
{
    mnkDebugOut((DEB_ITRACE,
                "CClassMoniker::DisconnectObject(%x,%x)\n",
                this, dwReserved));

    return S_OK;
}



//+-------------------------------------------------------------------------
//
//  Member:     CUrlMonWrapper::QueryInterface
//
//  Synopsis:   The UrlMon wrapper supports IUnknown and IUrlMon.
//
//  Arguments:  [iid]           -- the requested interface
//              [ppvObj]        -- where to put the interface pointer
//
//  Returns:    S_OK
//              E_INVALIDARG
//              E_NOINTERFACE
//
//  Notes:      Bad parameters will raise an exception.  The exception
//              handler catches exceptions and returns E_INVALIDARG.
//
//--------------------------------------------------------------------------
STDMETHODIMP CUrlMonWrapper::QueryInterface (REFIID iid, void ** ppv)
{
    HRESULT hr;

    __try
    {
        mnkDebugOut((DEB_TRACE,
                    "CUrlMonWrapper::QueryInterface(%x,%I,%x)\n",
                     this, &iid, ppv));

        if(IsEqualIID(iid,IID_IUnknown) ||
           IsEqualIID(iid,IID_IUrlMon))
        {
            AddRef();
            *ppv = (IUrlMon *) this;
            hr = S_OK;
        }
        else
        {
            *ppv = NULL;
            hr = E_NOINTERFACE;
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        hr = E_INVALIDARG;
    }

    return hr;
}

//+-------------------------------------------------------------------------
//
//  Member:     CUrlMonWrapper::CUrlMonWrapper
//
//  Synopsis:   Constructor for CUrlMonWrapper.
//
//  Arguments:  void
//
//  Returns:    void
//
//
//--------------------------------------------------------------------------
CUrlMonWrapper::CUrlMonWrapper()
: _cRef(1)
{
    mnkDebugOut((DEB_TRACE,
                 "CUrlMonWrapper::CUrlMonWrapper\n"));
}

//+-------------------------------------------------------------------------
//
//  Member:     CUrlMonWrapper::AddRef
//
//  Synopsis:   Increment the reference count.
//
//  Arguments:  void
//
//  Returns:    ULONG -- the new reference count
//
//
//--------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CUrlMonWrapper::AddRef(void)
{
    mnkDebugOut((DEB_TRACE,
                 "CUrlMonWrapper::AddRef(%x)\n",
                 this));

    InterlockedIncrement(&_cRef);
    return _cRef;
}

//+-------------------------------------------------------------------------
//
//  Member:     CUrlMonWrapper::Release
//
//  Synopsis:   Decrements the reference count.
//
//  Arguments:  void
//
//  Returns:    ULONG -- the remaining reference count
//
//--------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CUrlMonWrapper::Release(void)
{
    ULONG count = _cRef - 1;

    mnkDebugOut((DEB_TRACE,
                 "CUrlMonWrapper::Release(%x)\n",
                 this));

    if(0 == InterlockedDecrement(&_cRef))
    {
        delete this;
        count = 0;
    }
    return count;
}

//+-------------------------------------------------------------------------
//
//  Member:     CUrlMonWrapper::AsyncGetClassBits
//
//  Synopsis:   This wrapper function supports both synchronous and
//              asynchronous operation. In synchronous mode, this
//              function waits in a modal loop for completion of the
//              operation.  In asynchronous mode, the client supplies
//              an IBindStatusCallback.  The function returns
//              immediately with MK_S_ASYNCHRONOUS.  When the operation
//              completes, the client is notified via
//              IBindStatusCallback::OnCompletion.
//
//  Returns:    S_OK
//
//--------------------------------------------------------------------------
STDMETHODIMP CUrlMonWrapper::AsyncGetClassBits(
    REFCLSID  rclsid,
    LPCWSTR   pszMimeType,
    LPCWSTR   pszFileExt,
    DWORD     dwFileVersionMS,
    DWORD     dwFileVersionLS,
    LPCWSTR   pszCodeBase,
    IBindCtx *pBindCtx,
    DWORD     dwClassContext,
    REFIID    riid,
    DWORD     flags)
{
    HRESULT hr;

    mnkDebugOut((DEB_TRACE,
                 "CUrlMonWrapper::AsyncGetClassBits(%I, %s)\n",
                 rclsid, pszCodeBase));

    __try
    {
        if(pBindCtx != NULL)
        {
            IUnknown *punk;

            //Check if an IBindStatusCallback is registered.
            hr = pBindCtx->GetObjectParam(REG_BSCB_HOLDER, &punk);
            if(SUCCEEDED(hr))
            {
                //Asynchronous call with IBindStatusCallback.
                hr = (*pfnAsyncGetClassBits)(rclsid,
                                             pszMimeType,
                                             pszFileExt,
                                             dwFileVersionMS,
                                             dwFileVersionLS,
                                             pszCodeBase,
                                             pBindCtx,
                                             dwClassContext,
                                             NULL,
                                             riid,
                                             flags);
                punk->Release();
            }
            else
            {
                //Synchronous call with bind context.
                CBindStatusCallback *pCallback = new CBindStatusCallback(hr);

                if(pCallback != NULL)
                {
                    if(SUCCEEDED(hr))
                    {
                        IBindStatusCallback * pibsc;
                        // this will give us the progress UI
                        hr = CreateStdProgressIndicator(NULL,
                                                        NULL,
                                                        pCallback,
                                                        &pibsc);
                        if(SUCCEEDED(hr))
                        {
                            hr = (*pfnRegisterBindStatusCallback)(pBindCtx, pibsc, 0, 0);
                            if(SUCCEEDED(hr))
                            {
                                hr = (*pfnAsyncGetClassBits)(rclsid,
                                                             pszMimeType,
                                                             pszFileExt,
                                                             dwFileVersionMS,
                                                             dwFileVersionLS,
                                                             pszCodeBase,
                                                             pBindCtx,
                                                             dwClassContext,
                                                             NULL,
                                                             riid,
                                                             flags);

                                //Wait for completion of the operation.
                                if(hr == MK_S_ASYNCHRONOUS)
                                {
                                    hr = pCallback->Wait(0,30000);
                                }

                                (*pfnRevokeBindStatusCallback)(pBindCtx, pCallback);
                            }
                            pibsc->Release();
                        }
                    }
                    pCallback->Release();
                }
                else
                {
                    hr = E_OUTOFMEMORY;
                }
            }
        }
        else
        {
            //Synchronous call without bind context.
            //Create a bind context and make recursive call.
            IBindCtx *pbc;

            hr = CreateBindCtx(0, &pbc);
            if(SUCCEEDED(hr))
            {
                hr = AsyncGetClassBits(rclsid,
                                       pszMimeType,
                                       pszFileExt,
                                       dwFileVersionMS,
                                       dwFileVersionLS,
                                       pszCodeBase,
                                       pbc,
                                       dwClassContext,
                                       riid,
                                       flags);
                pbc->Release();
            }
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        hr = E_INVALIDARG;
    }

    return hr;
}

//+-------------------------------------------------------------------
//
//  Function:   PrivAsyncGetClassBits
//
//  Synopsis:   Loads urlmon.dll and calls AsyncGetClassBits
//
//  Returns:    S_OK, ERROR_MOD_NOT_FOUND
//
//--------------------------------------------------------------------
STDAPI PrivAsyncGetClassBits(
    REFCLSID rclsid,                    // CLSID
    LPCWSTR szTYPE,
    LPCWSTR szExt,
    DWORD dwFileVersionMS,              // CODE=http://foo#Version=a,b,c,d
    DWORD dwFileVersionLS,              // MAKEDWORD(c,b) of above
    LPCWSTR szURL,                      // CODE= in INSERT tag
    IBindCtx *pbc,                      // bind ctx
    DWORD dwClsContext,                 // CLSCTX flags
    LPVOID pvReserved,                  // Must be NULL
    REFIID riid,                        // Usually IID_IClassFactory
    DWORD flags)
{
    HRESULT hr = E_FAIL;

    if(!hUrlMon)
    {
        hUrlMon = LoadLibraryA("urlmon.dll");
    }

    if(hUrlMon != 0)
    {
        void *pfn = GetProcAddress(hUrlMon, "AsyncGetClassBits");
        if(pfn != NULL)
        {
           pfnAsyncGetClassBits = (ASYNCGETCLASSBITS *) pfn;
           hr = (*pfnAsyncGetClassBits)(rclsid,
                                        szTYPE,
                                        szExt,
                                        dwFileVersionMS,
                                        dwFileVersionLS,
                                        szURL,
                                        pbc,
                                        dwClsContext,
                                        pvReserved,
                                        riid,
                                        flags);
        }
        else
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
        }
    }
    else
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
    }

    return hr;
}


//+-------------------------------------------------------------------
//
//  Function:   PrivRegisterBindStatusCallback
//
//  Synopsis:   Loads urlmon.dll and calls RegisterBindStatusCallback
//
//  Returns:    S_OK, ERROR_MOD_NOT_FOUND
//
//--------------------------------------------------------------------
STDAPI PrivRegisterBindStatusCallback(
    LPBC pBC,
    IBindStatusCallback *pBSCb,
    IBindStatusCallback**  ppBSCBPrev,
    DWORD dwReserved)
{
    HRESULT hr = E_FAIL;

    if(!hUrlMon)
    {
        hUrlMon = LoadLibraryA("urlmon.dll");
    }

    if(hUrlMon != 0)
    {
        void *pfn = GetProcAddress(hUrlMon, "RegisterBindStatusCallback");
        if(pfn != NULL)
        {
           pfnRegisterBindStatusCallback = (REGISTERBINDSTATUSCALLBACK *) pfn;
           hr = (*pfnRegisterBindStatusCallback)(pBC,
                                                 pBSCb,
                                                 ppBSCBPrev,
                                                 dwReserved);
        }
        else
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
        }
    }
    else
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
    }

    return hr;
}


//+-------------------------------------------------------------------
//
//  Function:   PrivRevokeBindStatusCallback
//
//  Synopsis:   Loads urlmon.dll and calls RevokeBindStatusCallback.
//
//  Returns:    S_OK, ERROR_MOD_NOT_FOUND
//
//--------------------------------------------------------------------
STDAPI PrivRevokeBindStatusCallback(
    LPBC pBC,
    IBindStatusCallback *pBSCb)
{
    HRESULT hr = E_FAIL;

    if(!hUrlMon)
    {
        hUrlMon = LoadLibraryA("urlmon.dll");
    }

    if(hUrlMon != 0)
    {
        void *pfn = GetProcAddress(hUrlMon, "RevokeBindStatusCallback");
        if(pfn != NULL)
        {
           pfnRevokeBindStatusCallback = (REVOKEBINDSTATUSCALLBACK *) pfn;
           hr = (*pfnRevokeBindStatusCallback)(pBC, pBSCb);
        }
        else
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
        }
    }
    else
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
    }

    return hr;
}


// ===========================================================================
//                     CBindStatusCallback Implementation
// ===========================================================================

//+---------------------------------------------------------------------------
//
//  Method:     CBindStatusCallback::CBindStatusCallback
//
//  Synopsis:   Creates a bind status callback object.
//
//----------------------------------------------------------------------------
CBindStatusCallback::CBindStatusCallback(HRESULT &hr)
: _cRef(1), _hr(MK_S_ASYNCHRONOUS)
{
    _hEvent = CreateEvent(NULL, TRUE, FALSE, NULL);

    if(_hEvent != NULL)
    {
        hr = S_OK;
    }
    else
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
    }
}

//+---------------------------------------------------------------------------
//
//  Method:     CBindStatusCallback::~CBindStatusCallback
//
//  Synopsis:   Destructor for CBindStatusCallback object.
//
//----------------------------------------------------------------------------
CBindStatusCallback::~CBindStatusCallback()
{
    if(_hEvent != NULL)
    {
        CloseHandle(_hEvent);
    }
}

//+---------------------------------------------------------------------------
//
//  Method:     CBindStatusCallback::QueryInterface
//
//  Synopsis:   Gets an interface pointer to the bind status callback object.
//
//----------------------------------------------------------------------------
STDMETHODIMP
CBindStatusCallback::QueryInterface(REFIID riid, void** ppv)
{
    HRESULT hr = S_OK;

    *ppv = NULL;

    if(IsEqualIID(riid, IID_IUnknown) ||
       IsEqualIID(riid, IID_IBindStatusCallback))
    {
        AddRef();
        *ppv = (IBindStatusCallback *) this;
    }
    else if(IsEqualIID(riid, IID_ISynchronize))
    {
        AddRef();
        *ppv = (ISynchronize *) this;
    }
    else
    {
        hr = E_NOINTERFACE;
    }
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CBindStatusCallback::AddRef
//
//  Synopsis:   Increments the reference count.
//
//----------------------------------------------------------------------------
STDMETHODIMP_(ULONG)
CBindStatusCallback::AddRef()
{
    InterlockedIncrement((long *) &_cRef);
    return _cRef;
}

//+---------------------------------------------------------------------------
//
//  Method:     CBindStatusCallback::Release
//
//  Synopsis:   Decrements the reference count.
//
//----------------------------------------------------------------------------
STDMETHODIMP_(ULONG)
CBindStatusCallback::Release()
{
    LONG count = _cRef - 1;

    if(0 == InterlockedDecrement((long *) &_cRef))
    {
        delete this;
        count = 0;
    }

    return count;
}

// ---------------------------------------------------------------------------
// %%Function: CBindStatusCallback::OnStartBinding
// ---------------------------------------------------------------------------
STDMETHODIMP
CBindStatusCallback::OnStartBinding(DWORD grfBSCOption, IBinding* pbinding)
{
    ComDebOut((DEB_ACTIVATE,"CBindStatusCallback::OnStartBinding\n"));
    return(NOERROR);
}

// ---------------------------------------------------------------------------
// %%Function: CBindStatusCallback::GetPriority
// ---------------------------------------------------------------------------
STDMETHODIMP
CBindStatusCallback::GetPriority(LONG* pnPriority)
{
    ComDebOut((DEB_ACTIVATE,
              "CBindStatusCallback::GetPriority\n"));
    return(NOERROR);
}

// ---------------------------------------------------------------------------
// %%Function: CBindStatusCallback::OnLowResource
// ---------------------------------------------------------------------------
STDMETHODIMP
CBindStatusCallback::OnLowResource(DWORD dwReserved)
{
    ComDebOut((DEB_ACTIVATE,
              "CBindStatusCallback::OnLowResource\n"));
    return(NOERROR);
}

// ---------------------------------------------------------------------------
// %%Function: CBindStatusCallback::OnStopBinding
// ---------------------------------------------------------------------------
STDMETHODIMP
CBindStatusCallback::OnStopBinding(HRESULT hrStatus, LPCWSTR pszError)
{
    ComDebOut((DEB_ACTIVATE,
              "CBindStatusCallback::OnStopBinding hrStatus:%x\n",
              hrStatus));

    _hr = hrStatus;

    Signal();

    return(NOERROR);
}

// ---------------------------------------------------------------------------
// %%Function: CBindStatusCallback::GetBindInfo
// ---------------------------------------------------------------------------
STDMETHODIMP
CBindStatusCallback::GetBindInfo(DWORD* pgrfBINDF, BINDINFO* pbindInfo)
{
    ComDebOut((DEB_ACTIVATE,
              "CBindStatusCallback::GetBindInfo\n"));
    return (NOERROR);
}

// ---------------------------------------------------------------------------
// %%Function: CBindStatusCallback::OnDataAvailable
// This function is called whenever data starts arriving. When the file download is
// complete then the BSCF_LASTDATANOTIFICATION comes and you can get the local cached
// File Name.
// ---------------------------------------------------------------------------
STDMETHODIMP
CBindStatusCallback::OnDataAvailable(
    DWORD grfBSCF,
    DWORD dwSize,
    FORMATETC* pfmtetc,
    STGMEDIUM* pstgmed)
 {
    ComDebOut((DEB_ACTIVATE,
              "CBindStatusCallback::OnDataAvailable\n"));
    return(NOERROR);
 }


// ---------------------------------------------------------------------------
// %%Function: CBindStatusCallback::OnObjectAvailable
// ---------------------------------------------------------------------------
STDMETHODIMP
CBindStatusCallback::OnObjectAvailable(REFIID riid, IUnknown* punk)
{
    ComDebOut((DEB_ACTIVATE,
              "CBindStatusCallback::OnObjectAvailable\n"));
    return(NOERROR);
}

// ---------------------------------------------------------------------------
// %%Function: CBindStatusCallback::OnProgress
// ---------------------------------------------------------------------------
STDMETHODIMP
CBindStatusCallback::OnProgress
(
     ULONG ulProgress,
     ULONG ulProgressMax,
     ULONG ulStatusCode,
     LPCWSTR pwzStatusText
)
{
    ComDebOut((DEB_ACTIVATE,
              "CBindStatusCallback::OnProgress %d of %d\n",
              ulProgress,
              (ulProgress > ulProgressMax) ? ulProgress : ulProgressMax));
#if DBG==1
    if(pwzStatusText != NULL)
    {
        int cb = lstrlenW(pwzStatusText) * 2 + 1;
        char *psz = (char *) alloca(cb);
        if(psz != NULL)
        {
            WideCharToMultiByte(CP_ACP, 0, pwzStatusText,-1, psz, cb, 0,0);
            ComDebOut((DEB_ACTIVATE, "%s\n", psz));
        }
    }
#endif
    return(NOERROR);
}

//+---------------------------------------------------------------------------
//
//  Method:     CBindStatusCallback::Wait
//
//  Synopsis:   Waits in a message loop for completion of an operation.
//              The message loop dispatches the timer messages required
//              by the urlmon state machine.
//
//----------------------------------------------------------------------------
STDMETHODIMP
CBindStatusCallback::Wait(DWORD dwFlags, DWORD dwMilliseconds)
{
    HRESULT hr;
    DWORD dwWakeReason = WAIT_OBJECT_0 + 1;
    MSG msg;

    while(WAIT_OBJECT_0 + 1 == dwWakeReason)
    {
        //Process the incoming Windows messages.
        while(SSPeekMessage(&msg, NULL, 0, 0, PM_REMOVE) != 0)
        {
            TranslateMessage(&msg);
            SSDispatchMessage(&msg);
        }

        dwWakeReason = MsgWaitForMultipleObjects(1,
                                                 &_hEvent,
                                                 FALSE,
                                                 dwMilliseconds,
                                                 QS_ALLINPUT);
    }

    switch(dwWakeReason)
    {
    case WAIT_OBJECT_0:
        hr = _hr;
        break;

    case WAIT_TIMEOUT:
        hr = RPC_E_TIMEOUT;
        break;

    case 0xFFFFFFFF:
        hr = HRESULT_FROM_WIN32(GetLastError());
        break;

    default:
        hr = E_FAIL;
        break;
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CBindStatusCallback::Signal
//
//  Synopsis:   Signal the event.
//
//----------------------------------------------------------------------------
STDMETHODIMP
CBindStatusCallback::Signal()
{
    HRESULT hr = S_OK;

    if(!SetEvent(_hEvent))
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
    }
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CBindStatusCallback::Reset
//
//  Synopsis:   Reset the event.
//
//----------------------------------------------------------------------------
STDMETHODIMP
CBindStatusCallback::Reset()
{
    HRESULT hr = S_OK;

    if(!ResetEvent(_hEvent))
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\com\moniker2\cmonimp.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1993 - 1993.
//
//  File:       cmonimp.cxx
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    12-27-93   ErikGav   Created
//              16-May-94   AlexT   Removed reference variables
//                                  Added support for '!' in paths
//              21-Jun-94  KentCe   Corrected string dup routine.
//              11-Nov-94  BruceMa  Make use of GetLongPathName more efficient
//                                   and enable its use for Chicago
//              20-Jul-95  BruceMa  Rewrote MkParseDisplayName
//                                  Rewrote FindMaximalFileName
//                                  General cleanup
//              22-Sep-95  MikeHill Added CreateFileMonikerEx
//              29-Nov-95  MikeHill Added ValidateBindOpts().
//
//----------------------------------------------------------------------------

#include <ole2int.h>

#include <io.h>

#include "cbasemon.hxx"
#include "citemmon.hxx"
#include "cfilemon.hxx"
#include "cantimon.hxx"
#include "cbindctx.hxx"
#include "cptrmon.hxx"
#include "mnk.h"
#include "rothint.hxx"
#include "crot.hxx"
#include "classmon.hxx"
#include "cobjrmon.hxx"
#include "csessmon.hxx"

#define SAFEALLOCA_ASSERT Win4Assert
#include <alloca.h>

#define IsFileSystemSeparator(ch)   ('\\' == (ch) || '/' == (ch) || ':' == (ch))
#define IsItemMonikerSeparator(ch)  ('!' == (ch) || '/' == (ch) || '[' == (ch) || '#' == (ch))
#define IsDriveLetter(ch) ( ( (ch) >= L'A' && (ch) <= L'Z') ||  ( (ch) >= L'a' && (ch) <= L'z'))





//+---------------------------------------------------------------------------
//
//  Function:   DupWCHARString
//
//  Synopsis:   Duplicate a WCHAR string
//
//  Effects:
//              lpwcsOutput is allocated via PrivMemAlloc(), and lpwcsString
//              is copied into it.
//
//  Arguments:  [lpwcsString] -- String to dup
//              [lpwcsOutput] -- Reference to new string pointer
//              [ccOutput] -- Reference to character count in string
//
//  Requires:
//
//  Returns:
//              If lpwcsString == NULL, then lpwcsOutput == NULL, and
//              ccOutput == 0.
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    1-16-94   kevinro   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT DupWCHARString(LPCWSTR lpwcsString,
                        LPWSTR & lpwcsOutput,
                        USHORT & ccOutput)
{
    if (lpwcsString != NULL)
    {
        ccOutput = (USHORT) lstrlenW(lpwcsString);

        lpwcsOutput = (WCHAR *)PrivMemAlloc(sizeof(WCHAR)*(1+ccOutput));

        if (lpwcsOutput != NULL)
        {
            memcpy(lpwcsOutput, lpwcsString, (ccOutput + 1) * sizeof(WCHAR));

            return(NOERROR);
        }
        else
        {
            return(E_OUTOFMEMORY);
        }

    }
    lpwcsOutput = NULL;
    ccOutput = 0;
    return(NOERROR);
}

HRESULT CItemMonikerCF_CreateInstance(IUnknown *pUnkOuter, REFIID riid, void** ppv)
{
    // validated by the standard class factory
    Win4Assert(pUnkOuter == NULL);
    return CreateItemMoniker(OLESTR(""), OLESTR(""), (IMoniker **)ppv);
}

STDAPI CreateItemMoniker ( LPCWSTR lpszDelim, LPCWSTR lpszItem,
    LPMONIKER FAR * ppmk )
{
    OLETRACEIN((API_CreateItemMoniker, PARAMFMT("lpszDelim= %ws, lpszItem= %ws, ppmk= %p"),
                lpszDelim, lpszItem, ppmk));

    mnkDebugOut((DEB_ITRACE,
                 "CreateItemMoniker lpszDelim(%ws) lpszItem(%ws)\n",
                 lpszDelim?lpszDelim:L"<NULL>",
                 lpszItem?lpszItem:L"<NULL>"));

    CItemMoniker FAR * pCIM;
    HRESULT hresult;

    VDATEPTROUT_LABEL(ppmk,LPMONIKER, errRtn, hresult);
    VDATEPTRIN_LABEL(lpszDelim,WCHAR, errRtn, hresult);

    *ppmk = NULL;

    //VDATEPTRIN rejects NULL
    if( lpszItem )
        VDATEPTRIN_LABEL(lpszItem,WCHAR, errRtn, hresult);

    pCIM = CItemMoniker::Create(lpszDelim, lpszItem);

    if (pCIM)
    {
        *ppmk = (LPMONIKER)pCIM;
        CALLHOOKOBJECTCREATE(S_OK,CLSID_ItemMoniker,IID_IMoniker,(IUnknown **)ppmk);
        hresult = NOERROR;
    }
    else
    {
        hresult = ResultFromScode(E_OUTOFMEMORY);
    }

errRtn:
    OLETRACEOUT((API_CreateItemMoniker, hresult));

    return hresult;
}

//+---------------------------------------------------------------------------
//
//  Function:   IsAbsolutePath
//
//  Synopsis:   Returns true if the path starts with a drive letter, or
//              with a UNC delimiter ('\\')
//
//  Effects:
//
//  Arguments:  [szPath] --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    3-03-94   kevinro   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOL IsAbsolutePath (LPCWSTR szPath)
{
    if (NULL==szPath || *szPath == '\0')
    {
        return FALSE;
    }

    if (*szPath == '\\')
    {
        //  return TRUE if UNC path
        return (szPath[1] == '\\');
    }

    //
    // If the second character is a ':', then
    // it could very well be a drive letter and a ':'
    //
    // We could test for valid drive letters, but we don't have a really
    // compelling reason to do so. It will either work or fail later
    //
    return (szPath[1] == ':');
}

//+---------------------------------------------------------------------------
//
//  Function:   IsAbsoluteNonUNCPath
//
//  Synopsis:   Returns true if the path is an absolute, non UNC path
//
//  Effects:
//
//  Arguments:  [szPath] --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    3-03-94   kevinro   Created
//             04-27-94   darryla   changed to return FALSE if first char
//                                  a \ since either relative or UNC
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOL IsAbsoluteNonUNCPath (LPCWSTR szPath)
{
    if (NULL==szPath || *szPath == '\0')
    {
        return FALSE;
    }

    if (*szPath == '\\' || *szPath == '/')
    {
        //  return FALSE since it is either a UNC path or a relative
        //  path like \foo or /foo.
        return FALSE;
    }

    //
    // If the second character is a ':', then
    // it could very well be a drive letter and a ':'
    //
    // We could test for valid drive letters, but we don't have a really
    // compelling reason to do so. It will either work or fail later
    //

    return (szPath[1] == ':');
}

//+---------------------------------------------------------------------------
//
//  Function:   FindUNCEndServer
//
//  Synopsis:   Finds the end of the server section of a UNC path
//
//  Effects:
//
//  Arguments:  [lpszPathName] -- Path to search for UNC prefix
//              [endServer] -- Returned offset to end of UNC name
//
//  Requires:
//
//  Returns:
//      If the path is a UNC name, then endServer will point to the first
//      character of the 'path' section.
//
//      For example, \\server\share\path would return with endServer = 14
//      or \\server\share would also return with endServer = 14.
//
//      If the path isn't of this form, endServer == DEF_ENDSERVER on return.
//      Also, we need to make sure that if the form is ill-formed, we
//      mislead later steps into thinking this is a real UNC name. For
//      example, \\server\ is ill-formed and would later be treated as a
//      real UNC name.
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    1-11-94   kevinro   Created
//             03-27-94   darryla   Changed to catch \\server\share legal
//                                  form and illegal \\server\.
//
//  Notes:
//
//----------------------------------------------------------------------------
void FindUNCEndServer(LPCWSTR lpszPathName, USHORT *pendServer)
{
    if (lpszPathName[0] == '\\' && lpszPathName[1] == '\\')
    {
        //
        // Need to find the second slash following the UNC delimiter
        //
        ULONG ulCountDown = 2;

        //
        // Found UNC prefix. Now find the second backslash
        //
        for(*pendServer = 2 ; lpszPathName[*pendServer] != 0 ; (*pendServer)++)
        {
            if (lpszPathName[*pendServer] == '\\')
            {
                if( --ulCountDown == 0)
                {
                    return;
                }
            }
        }

        // If we reached the end of the string and found one \, then we
        // have the form \\server\share and the *pendServer is the terminator
        // as long as we aren't looking at \\server\.
        if(lpszPathName[*pendServer] == '\0' &&
           ulCountDown == 1 &&
           lpszPathName[*pendServer - 1] != '\\')
        {
            return;
        }
    }

    *pendServer = DEF_ENDSERVER;
}



//+---------------------------------------------------------------------------
//
//  Function:   ExpandUNCName
//
//  Synopsis:   Given a path, determine a UNC share to it
//
//  Effects:
//
//  Arguments:  [lpszIn] --     Path to determine UNC name of
//              [lplpszOut] --  Output UNC name, allocated using new
//              [pEndServer] -- Output USHORT offset to start of actual path
//
//  Requires:
//      lpszIn should be of the form 'A:\<path>'
//
//  Returns:
//
//      lplpszOut can return as NULL if there was no UNC path available. In
//      this case, the caller should just use the normal string
//
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    1-11-94   kevinro   Created
//              05-25-94  AlexT     Use WNetGetUniversalName for non-Chicago
//              06-15-94  AlexT     Only call WNetGetUniversalName for remote
//
//  Notes:
//
//----------------------------------------------------------------------------

//  We need to pass a buffer to WNetGetUniversalName which will get filled in
//  with a REMOTE_NAME_INFO structure add three strings - a universal path
//  (can be up to MAX_PATH long) and a remote connection and remaing path
//  (these last two will be at most MAX_PATH + 1 characters).


#define REMOTE_NAME_BUFFER_SIZE (sizeof(REMOTE_NAME_INFO) +         \
                                 MAX_PATH * sizeof(WCHAR) +         \
                                 (MAX_PATH + 1) * sizeof(WCHAR))

INTERNAL ExpandUNCName ( LPWSTR lpszIn, LPWSTR FAR * lplpszOut, USHORT FAR* pEndServer )
{
    mnkDebugOut((DEB_ITRACE,
                 "%p _IN ExpandUNCName (%ws, %p, %p)\n",
                 NULL, lpszIn, lplpszOut, pEndServer));

    WCHAR szDevice[] = L"A:\\";
    ULONG ulDriveType;

    *pEndServer = DEF_ENDSERVER;

    *szDevice = *lpszIn;
    Assert(lpszIn[1] == ':');
    ulDriveType = GetDriveType(szDevice);

    mnkDebugOut((DEB_ITRACE,
                 "ExpandUNCName: GetDriveType(%ws) says %s (%x)\n",
                 szDevice,
                 ulDriveType==DRIVE_REMOTE?"DRIVE_REMOTE":"not remote",
                 ulDriveType));

    //
    // If this is a remote drive, attempt to get the UNC path that maps
    // to it.
    //
    HRESULT hr = NOERROR;

    BYTE abInfoBuffer[REMOTE_NAME_BUFFER_SIZE];
    LPREMOTE_NAME_INFO pRemoteNameInfo;
    DWORD dwBufferSize;
    int cchConnectionName;
    int cchRemainingPath;

    //
    // If this is a remote drive, attempt to get the UNC path that maps
    // to it.
    //

    pRemoteNameInfo = (LPREMOTE_NAME_INFO) abInfoBuffer;
    dwBufferSize = REMOTE_NAME_BUFFER_SIZE;

    if ((DRIVE_REMOTE == ulDriveType) &&
        (WN_SUCCESS == WNetGetUniversalName(lpszIn, REMOTE_NAME_INFO_LEVEL,
                                            pRemoteNameInfo, &dwBufferSize)))
    {
        //  Got it
        cchConnectionName = lstrlenW(pRemoteNameInfo->lpConnectionName);
        cchRemainingPath = lstrlenW(pRemoteNameInfo->lpRemainingPath);

        //
        // Make sure we aren't about to create a path that is too large.
        //

        if ((cchConnectionName + cchRemainingPath + 1) > MAX_PATH)
        {
            hr = MK_E_SYNTAX;
            goto errRet;
        }

        // Allocate room for the concatenated string. The length of the
        // buffer is the length of the remote name, plus the length of the
        // remaining path, plus room for a terminating NULL.

        *lplpszOut = (WCHAR *)
            PrivMemAlloc(sizeof(WCHAR) * (cchConnectionName + cchRemainingPath + 1));

        if( !*lplpszOut )
        {
            hr = ResultFromScode(E_OUTOFMEMORY);
            goto errRet;
        }

        memcpy(*lplpszOut, pRemoteNameInfo->lpConnectionName,
               cchConnectionName * sizeof(WCHAR));
        memcpy(*lplpszOut + cchConnectionName, pRemoteNameInfo->lpRemainingPath,
               (cchRemainingPath + 1) * sizeof(WCHAR));

        //
        // EndServer is the offset to the start of the 'path'. It should point at the
        // first backslash
        //

        *pEndServer = (USHORT) cchConnectionName;
    }
    else
    {
#if DBG==1
        if (DRIVE_REMOTE == ulDriveType)
        {
            mnkDebugOut((DEB_ITRACE,
                        "Local drive or WNetGetUniversalName failed - %ld\n",
                        GetLastError()));
        }
#endif

        //
        // There was no UNC form of this path. Set the output pointer to be
        // NULL
        //

        // NOTE:
        //
        // This would be a very good place to determine if the given path
        // has a UNC equivalent, even if it is a local drive.
        //

        *lplpszOut = NULL;
        *pEndServer = DEF_ENDSERVER;
    }
errRet:

    mnkDebugOut((DEB_ITRACE,
                 "%p OUT ExpandUNCName (%lx) [%ws, %d]\n",
                 NULL, hr, *lplpszOut ? *lplpszOut : L"<NULL>",
                 *pEndServer));
    return hr;
}




//+---------------------------------------------------------------------------
//
//  Function:   CreateFileMoniker
//
//  Synopsis:   Creates a FileMoniker
//
//  Effects:
//
//  Arguments:  [lpszPathName] -- Path to create moniker to
//              [ppmk] --         Output moniker interface pointer
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    1-11-94   kevinro   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDAPI CreateFileMoniker ( LPCWSTR lpszPathName, LPMONIKER FAR * ppmk )
{
    OLETRACEIN((API_CreateFileMoniker, PARAMFMT("lpszPathName= %ws, ppmk= %p"),
                        lpszPathName, ppmk));

    mnkDebugOut((DEB_TRACE,
                 "CreateFileMoniker(%ws)\n",
                 lpszPathName?lpszPathName:L"<NULL PATH>"));

    HRESULT hresult = NOERROR;
    CFileMoniker FAR * pCFM = NULL;

    USHORT endServer = DEF_ENDSERVER;
    *ppmk = NULL;
    LPWSTR lpsz = NULL;
    WCHAR szBuffer[MAX_PATH];
    LPWSTR pszBuffer = szBuffer;
    ULONG  bufferLength = MAX_PATH;
    ULONG  pathLength;
    LPOLESTR posPath;

    if (NULL == lpszPathName)
    {
        return MK_E_SYNTAX;
    }

    VDATEPTROUT_LABEL(ppmk,LPMONIKER, errNoHookRet, hresult);
    VDATEPTRIN_LABEL(lpszPathName,WCHAR, errNoHookRet, hresult);


    //
    // If this is an absolute path, then create as strong of a link to it
    // that we can. If not, then its relative, just use the name.
    //

    if ( IsAbsoluteNonUNCPath(lpszPathName))
    {
        mnkDebugOut((DEB_ITRACE,
                     "CreateFileMoniker(%ws) Is absolute path\n",
                     lpszPathName?lpszPathName:L"<NULL PATH>"));

        //
        // GetFullPathName resolves, using the current directory and drive,
        // the path into as much of a normal form as possible
        //

        LPWSTR pszFilePart;

        pathLength = GetFullPathName(lpszPathName, bufferLength, pszBuffer, &pszFilePart);
        if(pathLength > bufferLength)
        {
            //The buffer is too small.  Allocate a new buffer.
            SafeAllocaAllocate(pszBuffer, pathLength * sizeof(WCHAR));

            if(pszBuffer)
            {
                bufferLength = pathLength;
                pathLength = GetFullPathName(lpszPathName, bufferLength, pszBuffer, &pszFilePart);
            }
            else
            {
                hresult = E_OUTOFMEMORY;
                goto errRet;
            }
        }

        if (0 == pathLength || pathLength > bufferLength)
        {
            hresult = MK_E_SYNTAX;
            goto errRet;
        }

        //
        // We now demand to have a drive based path.
        //

        if (*(pszBuffer + 1) != ':')
        {
            hresult = MK_E_SYNTAX;
            goto errRet;
        }

        Assert(*(pszBuffer + 1) == ':');

        hresult = ExpandUNCName(pszBuffer, &lpsz, &endServer);


        mnkDebugOut((DEB_ITRACE,
                     "CreateFileMoniker(%ws) Expanded name (%ws)\n",
                     lpszPathName?lpszPathName:L"<NULL PATH>",
                     lpsz?lpsz:pszBuffer));

        if (hresult != NOERROR)
        {
            goto errRet;
        }

        posPath = lpsz ? lpsz : pszBuffer;
    }
    else
    {
        //
        // If this is a UNC path, then we need to set the
        // m_endServer variable. Otherwise, it defaults to DEF_ENDSERVER
        //
        mnkDebugOut((DEB_ITRACE,
                     "CreateFileMoniker(%ws) Is relative path\n",
                     lpszPathName?lpszPathName:L"<NULL PATH>"));


        FindUNCEndServer(lpszPathName, &endServer);
        posPath = (LPOLESTR)lpszPathName;
    }


    // Now that we have a path, expand each component into its long
    // form so that monikers create with short names equal their
    // long name equivalents
    // This only works for files that exist, so if it fails
    // simply use the given path

    // Special case zero-length paths since the length returns from
    // GetLongPathName become ambiguous when zero characters are processed
    if (posPath[0])
    {
        // Attempt to build the long path on the stack
        pathLength = GetLongPathNameW(posPath, pszBuffer, bufferLength);

        if(pathLength > bufferLength)
        {
			if(pszBuffer != szBuffer)
				SafeAllocaFree(pszBuffer);

            //The buffer is too small.  Allocate a new buffer.
            SafeAllocaAllocate(pszBuffer, pathLength * sizeof(WCHAR));

            if(pszBuffer)
            {
                bufferLength = pathLength;
                pathLength = GetLongPathNameW(posPath, pszBuffer, bufferLength);
            }
            else
            {
                hresult = E_OUTOFMEMORY;
                goto errRet;
            }
        }

        if (pathLength > 0 && pathLength < bufferLength)
        {
            mnkDebugOut((DEB_ITRACE, "CreateFileMoniker: "
                         "Lengthened '%ws' to '%ws'\n",
                         posPath, pszBuffer));
            posPath = pszBuffer;
        }
    }
    else
    {
        mnkDebugOut((DEB_ITRACE, "CreateFileMoniker: No long path for '%ws'\n",
                     posPath));
    }

    pCFM = CFileMoniker::Create(posPath,
                                0,
                                endServer);

    if (lpsz != NULL)
    {
        PrivMemFree(lpsz);
    }

    if (!pCFM)
    {
        hresult = E_OUTOFMEMORY;
        goto errRet;
    }

    *ppmk = (LPMONIKER)pCFM;

errRet:

	if(pszBuffer != szBuffer)
		SafeAllocaFree(pszBuffer);

    CALLHOOKOBJECTCREATE(hresult, CLSID_FileMoniker, IID_IMoniker, (IUnknown **)ppmk);  //  HOOKOLE

errNoHookRet:
    OLETRACEOUT((API_CreateFileMoniker, hresult));

    return hresult;
}







//+---------------------------------------------------------------------------
//
//  Function:   CreateOle1FileMoniker
//
//  Synopsis:   Creates a FileMoniker
//
//  Effects:
//
//  Arguments:  [lpszPathName] -  Path to create moniker to
//              [rclsidOle1]   -  Ole1 clsid
//              [ppmk]         -  Output moniker interface pointer
//
//  Returns:    HRESULT
//
//
//  Algorithm:
//
//  History:    01-Aug-95  BruceMa  Added this header
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT
STDAPICALLTYPE
CreateOle1FileMoniker ( LPWSTR lpszPathName,
                        REFCLSID rclsidOle1,
                        LPMONIKER FAR * ppmk)
{
    CFileMoniker FAR * pCFM;
    HRESULT hr;

    hr = CreateFileMoniker( lpszPathName, (LPMONIKER FAR *)&pCFM);

    *ppmk = pCFM;           // this nulls *ppmk in case of error

    if (hr == NOERROR)
    {
        pCFM->m_ole1 = CFileMoniker::ole1;
            pCFM->m_clsid = rclsidOle1;
        pCFM->m_fClassVerified = TRUE;

    }

    return hr;
}




//+---------------------------------------------------------------------------
//
//  Function:   CreateAntiMoniker
//
//  Synopsis:   Creates a anti moniker
//
//  Effects:
//
//  Arguments:  [ppmk] -  Path to create moniker to
//
//  Returns:    HRESULT
//
//
//  Algorithm:
//
//  History:    01-Aug-95  BruceMa  Added this header
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT CAntiMonikerCF_CreateInstance(IUnknown *pUnkOuter, REFIID riid, void** ppv)
{
    // validated by the standard class factory
    Win4Assert(pUnkOuter == NULL);
    return CreateAntiMoniker((IMoniker **)ppv);
}

STDAPI CreateAntiMoniker (LPMONIKER FAR* ppmk)
{
    CAntiMoniker FAR* pCAM;
    HRESULT hr;

    OLETRACEIN((API_CreateAntiMoniker, PARAMFMT("ppmk= %p"), ppmk));

    VDATEPTROUT_LABEL(ppmk, LPMONIKER, errRtn, hr);

    *ppmk = NULL;
    pCAM = CAntiMoniker::Create();

    if (pCAM != NULL)
    {
        *ppmk = pCAM;
        CALLHOOKOBJECTCREATE(S_OK,CLSID_AntiMoniker,IID_IMoniker,(IUnknown **)ppmk);
        hr = NOERROR;
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

errRtn:
    OLETRACEOUT((API_CreateAntiMoniker, hr));

    return hr;
}








//+---------------------------------------------------------------------------
//
//  Function:   CreateBindCtx
//
//  Synopsis:   Creates a bind context
//
//  Effects:
//
//  Arguments:  [reserved] -  Reserved for future expansion
//              [ppbc]     -  Where to place the created bnind context
//
//  Returns:    HRESULT
//
//
//  Algorithm:
//
//  History:    01-Aug-95  BruceMa  Added this header
//
//  Notes:
//
//----------------------------------------------------------------------------
STDAPI CreateBindCtx ( DWORD reserved, LPBC FAR * ppbc )
{
    HRESULT hr;

    OLETRACEIN((API_CreateBindCtx, PARAMFMT("reserved= %x, ppbc= %p"), reserved, ppbc));

    VDATEPTROUT_LABEL(ppbc, LPBC, errRtn, hr);

    if(reserved != 0)
    {
        return E_INVALIDARG;
    }

    *ppbc = CBindCtx::Create();

    if (*ppbc == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto errRtn;
    }

    CALLHOOKOBJECTCREATE(S_OK,CLSID_PSBindCtx,IID_IBindCtx,(IUnknown **)ppbc);
    hr = NOERROR;

errRtn:
    OLETRACEOUT((API_CreateBindCtx, hr));

    return hr;
}






//+---------------------------------------------------------------------------
//
//  Function:   CreatePointerMoniker
//
//  Synopsis:   Creates a pointer moniker
//
//  Effects:
//
//  Arguments:  [punk]         -  Pointer being wrappaed
//              [ppmk]         -  Output moniker interface pointer
//
//  Returns:    HRESULT
//
//
//  Algorithm:
//
//  History:    01-Aug-95  BruceMa  Added this header
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT CPointerMonikerCF_CreateInstance(IUnknown *pUnkOuter, REFIID riid, void** ppv)
{
    // validated by the standard class factory
    Win4Assert(pUnkOuter == NULL);
    return CreatePointerMoniker(NULL, (IMoniker **)ppv);
}

STDAPI CreatePointerMoniker (LPUNKNOWN punk, LPMONIKER FAR* ppmk)
{
    OLETRACEIN((API_CreatePointerMoniker, PARAMFMT("punk= %p, ppmk= %p"),
                        punk, ppmk));

    HRESULT hresult;
    CPointerMoniker FAR* pCPM;

    VDATEPTROUT_LABEL(ppmk, LPMONIKER, errRtn, hresult);
    *ppmk = NULL;

    // When unmarshaling a remoted pointer moniker punk is initially NULL
    if (punk)
    {
        VDATEIFACE_LABEL(punk, errRtn, hresult);
    }

    pCPM = CPointerMoniker::Create(punk);
    if (pCPM)
    {
        *ppmk = pCPM;
        CALLHOOKOBJECTCREATE(S_OK,CLSID_PointerMoniker,IID_IMoniker,(IUnknown **)ppmk);
        hresult = NOERROR;
    }
    else
    {
        hresult = E_OUTOFMEMORY;
    }

errRtn:
    OLETRACEOUT((API_CreatePointerMoniker, hresult));

    return hresult;
}


//+---------------------------------------------------------------------------
//
//  Function:   CreateObjrefMoniker
//
//  Synopsis:   Creates an objref moniker
//
//  Effects:
//
//  Arguments:  [punk]         -  object being referenced
//              [ppmk]         -  Output moniker interface pointer
//
//  Returns:    HRESULT
//
//
//  Algorithm:
//
//  History:    04-Apr-97  ronans Added objref moniker support
//
//  Notes:
//
//----------------------------------------------------------------------------

STDAPI CreateObjrefMoniker (LPUNKNOWN punk, LPMONIKER FAR* ppmk)
{
//    OLETRACEIN((API_CreateObjrefMoniker, PARAMFMT("punk= %p, ppmk= %p"),
//                       punk, ppmk));

    HRESULT hresult;
    CObjrefMoniker FAR* pCORM;

    VDATEPTROUT_LABEL(ppmk, LPMONIKER, errRtn, hresult);
    *ppmk = NULL;

    // When unmarshaling a remoted objref moniker punk is initially NULL
    if (punk)
    {
        VDATEIFACE_LABEL(punk, errRtn, hresult);
    }

    pCORM = CObjrefMoniker::Create(punk);
    if (pCORM )
    {
        *ppmk = pCORM ;
        CALLHOOKOBJECTCREATE(S_OK,CLSID_ObjrefMoniker,IID_IMoniker,(IUnknown **)ppmk);
        hresult = NOERROR;
    }
    else
    {
        hresult = E_OUTOFMEMORY;
    }

errRtn:
    //OLETRACEOUT((API_CreateObjrefMoniker, hresult));

    return hresult;
}




//+---------------------------------------------------------------------------
//
//  Function:   OleLoadFromStream
//
//  Synopsis:   Load a moniker from a stream and QI for the
//              requested interface
//
//  Effects:
//
//  Arguments:  [pStm]         -  The stream to load from
//              [iidInterface] -  The requested interface
//              [ppvObj]       -  Output moniker interface pointer
//
//  Returns:    HRESULT
//
//
//  Algorithm:
//
//  History:    01-Aug-95  BruceMa  Added this header
//
//  Notes:
//
//----------------------------------------------------------------------------
STDAPI OleLoadFromStream ( LPSTREAM pStm, REFIID iidInterface,
    LPVOID FAR* ppvObj)
{
    OLETRACEIN((API_OleLoadFromStream, PARAMFMT("pStm= %p, iidInterface= %I"),
                pStm, &iidInterface));

    //  Assumptions:  The name of the object class is in the stream,
    //  as a length-prefixed string.
    HRESULT         hresult = NOERROR;
    CLSID               cid;
    LPPERSISTSTREAM pPS;
    LPUNKNOWN       pUnk;

    VDATEPTROUT_LABEL(ppvObj,LPVOID, errRtn, hresult);
    *ppvObj = NULL;
    VDATEIID_LABEL(iidInterface, errRtn, hresult);
    VDATEIFACE_LABEL(pStm, errRtn, hresult);


    if ((hresult = ReadClassStm(pStm, &cid)) != NOERROR)
        goto errRtn;

    hresult = CoCreateInstance(cid, NULL,
        CLSCTX_SERVER | CLSCTX_NO_CODE_DOWNLOAD,
        iidInterface,
        (LPVOID FAR *) &pUnk);
    if (hresult)
        goto errRtn;
    hresult = pUnk->QueryInterface(IID_IPersistStream,
        (LPVOID FAR*) &pPS);
    if (!hresult)
    {
        hresult = pPS->Load( pStm );
        pPS->Release();
    }
    if (!hresult)
        hresult = pUnk->QueryInterface(iidInterface, ppvObj );
    pUnk->Release();

errRtn:
    OLETRACEOUT((API_OleLoadFromStream, hresult));

    return hresult;
}








//+---------------------------------------------------------------------------
//
//  Function:   OleSaveToStream
//
//  Synopsis:   Given an IPersistStream on a moniker, save that moniker
//              to a stream
//
//  Effects:
//
//  Arguments:  [pPStm]        -  IPersistStream pointer
//              [pStm]         -  Stream to save the moniker to
//
//  Returns:    HRESULT
//
//
//  Algorithm:
//
//  History:    01-Aug-95  BruceMa  Added this header
//
//  Notes:
//
//----------------------------------------------------------------------------
STDAPI OleSaveToStream ( LPPERSISTSTREAM pPStm, LPSTREAM pStm)
{
    OLETRACEIN((API_OleSaveToStream, PARAMFMT("pPStm= %p, pStm= %p"),
                pPStm, pStm));

    HRESULT hresult = 0;
    CLSID   clsid;

    VDATEIFACE_LABEL(pPStm, errRtn, hresult);
    VDATEIFACE_LABEL(pStm, errRtn, hresult);


    CALLHOOKOBJECT(S_OK,CLSID_NULL,IID_IPersistStream,(IUnknown **)&pPStm);
    CALLHOOKOBJECT(S_OK,CLSID_NULL,IID_IStream,(IUnknown **)&pStm);


    if (!pPStm)
    {
        hresult = ResultFromScode(OLE_E_BLANK);
        goto errRtn;
    }

    if (hresult = pPStm->GetClassID(&clsid))
        goto errRtn;

    if ((hresult = WriteClassStm(pStm, clsid)) != NOERROR)
        goto errRtn;

    hresult = pPStm->Save(pStm, TRUE);

errRtn:
    OLETRACEOUT((API_OleSaveToStream, hresult));

    return hresult;
}

//+---------------------------------------------------------------------------
//
//  Function:   Parse10DisplayName    private
//
//  Synopsis:   Parse a ProgId string as an ole 1.0 file moniker
//
//  Arguments:  [pbc]                   -       Bind context
//              [pszDisplayName]        -       Display name
//              [pcchEaten]             -       Number of characters eaten
//              [ppmk]                  -       Moniker of running object
//                                              if successful, otherwise NULL
//
//  Returns:
//
//  Algorithm:  This routine is being rewritten for performance, hence the
//
//  History:    20-Jul-95 BruceMa   Added this header and cleaned up
//
//----------------------------------------------------------------------------
STDAPI Parse10DisplayName(REFCLSID   clsid,
                          LPCWSTR    szDisplayName,
                          ULONG     *pcchEaten,
                          ULONG      cchEatenSoFar,
                          LPMONIKER *ppmk)
{
    LPCWSTR   pch     = szDisplayName;
    LPMONIKER pmkFile = NULL;
    LPMONIKER pmkItem = NULL;
    HRESULT   hres    = NOERROR;
    size_t    cbFile;

    // Skip past the "file" name, looking for first delimiter character
    // Note: strtok is not DBCS-friendly.
    while (*pch  &&  !wcschr (L"!\"'*+,/;<=>?@[]`|" , *pch))
    {
        IncLpch(pch);
    }

    if (*pch)
    {
        // We hit a delimiter, so there is an item moniker.
        CreateItemMoniker (L"!", (LPWSTR)pch+1, &pmkItem);

        // Copy the "file" part
        LPWSTR szFile = (WCHAR *)
            PrivMemAlloc(sizeof(WCHAR) * (cbFile = (ULONG)(pch - szDisplayName + 1)));
        if (NULL==szFile)
        {
            hres = ResultFromScode (E_OUTOFMEMORY);
            goto errRtn;
        }
        _fmemcpy (szFile, szDisplayName, (cbFile - 1) * sizeof(WCHAR));
        szFile [cbFile - 1] = '\0';

        hres = CreateOle1FileMoniker (szFile, clsid, &pmkFile);
        PrivMemFree(szFile);
        if (hres != NOERROR)
        {
            goto errRtn;
        }
        hres = CreateGenericComposite (pmkFile, pmkItem, ppmk);
    }
    else
    {
        // no Item moniker, just a file
        hres = CreateOle1FileMoniker ((LPWSTR)szDisplayName, clsid, ppmk);
    }

  errRtn:
    if (pmkFile)
    {
        pmkFile->Release();
    }
    if (pmkItem)
    {
        pmkItem->Release();
    }
    *pcchEaten = ((hres==NOERROR) ? lstrlenW (szDisplayName) + cchEatenSoFar : 0);
    return hres;

}
//+---------------------------------------------------------------------------
//
//  Function:   FindProgIdMoniker    private
//
//  Synopsis:   Interpreting a display name as a ProgID, derive a
//              moniker from it
//
//  Arguments:  [pbc]                   -       Bind context
//              [pszDisplayName]        -       Display name to parse
//              [pcchEaten]             -       Number of characters eaten
//              [ppmk]                  -       Moniker of running object
//
//  Returns:    S_OK if successful
//              Another HRESULT otherwise
//
//  Algorithm:  Find largest left-bounded name that corresponds to a
//              valid initial moniker, either of an object currently running
//              and registered in the ROT or of an extant file.  Call
//              IParseDisplayName::ParseDisplayName on the right-part of the
//              display name not yet consumed.
//
//  History:    20-Jul-95 BruceMa   Added this header and cleaned up
//
//----------------------------------------------------------------------------
STDAPI  FindProgIdMoniker(LPBC       pbc,
                          LPCWSTR    pszDisplayName,
                          ULONG     *pcchEaten,
                          LPMONIKER *ppmk)
{
    int                cbProgId;
    LPWSTR             sz = NULL;
    WCHAR const       *pch;
    HRESULT            hres;
    CLSID              cid;
    IParseDisplayName *pPDN = NULL;


    // Initialize
    *pcchEaten = 0;
    *ppmk      = NULL;

    //  find the prog id
    pch = pszDisplayName;
    Assert(*pch == '@');
    pch++;
    if (*pch >= '0' && *pch <= '9')
    {
        return ResultFromScode(MK_E_SYNTAX);
    }
    while ((*pch >= '0' && *pch <= '9') || (*pch >= 'a' && *pch <= 'z') ||
           (*pch >= 'A' && *pch <= 'Z') || (*pch == '.'))
    {
        pch++;
    }
    cbProgId = (ULONG) (pch - pszDisplayName);

    sz = (WCHAR *) PrivMemAlloc(sizeof(WCHAR) * cbProgId);
    if (sz == NULL)
    {
        return E_OUTOFMEMORY;
    }
    _fmemcpy(sz, pszDisplayName + 1, (cbProgId - 1) * sizeof(WCHAR));
    sz[cbProgId - 1] = '\0';

    //  prog id string is now in sz
    hres = CLSIDFromProgID(sz, &cid);
    if (hres == NOERROR)
    {
        if (CoIsOle1Class (cid))
        {
            hres = Parse10DisplayName (cid, pch + 1, pcchEaten, cbProgId + 1,
                                       ppmk);
            CairoleAssert(hres!=NOERROR  ||
                          *pcchEaten == (ULONG)lstrlenW(pszDisplayName));
            goto errRet;
        }

        hres = CoGetClassObject(cid,
                                CLSCTX_ALL | CLSCTX_NO_CODE_DOWNLOAD,
                                NULL, IID_IParseDisplayName,
                                (LPVOID *) &pPDN);
        if (hres != NOERROR)
        {
            hres = CoCreateInstance(cid, NULL,
                                    CLSCTX_INPROC | CLSCTX_NO_CODE_DOWNLOAD,
                                    IID_IParseDisplayName,
                                    (LPVOID *) &pPDN);
        }
    }

    if (hres == NOERROR)
    {
        //  Unfortunately, IParseDisplayName's 2nd parameter is
        //  LPOLESTR instead of LPCOLESTR
        hres = pPDN->ParseDisplayName(pbc,
                                      (LPOLESTR) pszDisplayName,
                                      pcchEaten,
                                      ppmk);
        // AssertOutPtrIface(hres, *ppmk);

        pPDN->Release();
    }


errRet:

    if (sz)
    {

        PrivMemFree(sz);
    }

    return hres;
}


//+---------------------------------------------------------------------------
//
//  Function:   MkParseDisplayName    public
//
//  Synopsis:   Attempts to parse the given file moniker "display name" and
//              return the corresponding moniker
//
//  Arguments:  [pbc]                   -       Bind context
//              [pszDisplayName]        -       Display name to parse
//              [pcchEaten]             -       Number of characters eaten
//              [ppmk]                  -       Moniker of running object
//
//  Returns:    S_OK if successful
//              Another HRESULT otherwise
//
//  Algorithm:  Find the largest left-bounded name that corresponds to a
//              valid initial moniker, either of an object currently running
//              and registered in the ROT or of an extant file.  Then call
//              IParseDisplayName::ParseDisplayName on this moniker
//              inductively with the right-part of the display name not
//              yet consumed, composing the current moniker with the result to
//              form the next moniker in the induction
//
//  History:    20-Jul-95 BruceMa   Rewrote
//              22-Feb-96 ShannonC  Added class moniker support.
//
//----------------------------------------------------------------------------
STDAPI  MkParseDisplayName(LPBC       pbc,
                           LPCWSTR    pwszDisplayName,
                           ULONG     *pchEaten,
                           LPMONIKER *ppmk)
{
    HRESULT     hr = MK_E_SYNTAX;
    LPCWSTR     pszRemainder = pwszDisplayName;
    ULONG       cchEaten = 0;
    LONG        cbUneaten = 0;
    LPMONIKER   pmk;
    LPMONIKER   pmkNext;
    LPMONIKER   pmkTemp;

    // Some simple checks
    if (pwszDisplayName == NULL  ||  pwszDisplayName[0] == L'\0')
    {
        return E_INVALIDARG;
    }

    OLETRACEIN((API_MkParseDisplayName,
         PARAMFMT("pbc= %p, pszDisplayName= %ws, pchEaten= %p, ppmk= %p"),
         pbc, pwszDisplayName, pchEaten, ppmk));

    // Trace
    mnkDebugOut((DEB_ITRACE, "In MkParseDisplayName \"%ws\"\n",
                 pwszDisplayName));

    // Validate parameters
    VDATEPTRIN_LABEL(pwszDisplayName, WCHAR, errRet, hr);
    VDATEIFACE_LABEL(pbc, errRet, hr);
    VDATEPTROUT_LABEL(pchEaten, ULONG, errRet, hr);
    VDATEPTROUT_LABEL(ppmk, LPMONIKER, errRet, hr);

    // Call hook ole
    CALLHOOKOBJECT(S_OK,CLSID_NULL,IID_IBindCtx,(IUnknown **)&pbc);

    // Initialize
    *ppmk     = NULL;
    *pchEaten = 0;


    //Find the initial moniker.

    //Parse a session moniker
    hr = FindSessionMoniker(pbc, pwszDisplayName, &cchEaten, &pmk);

    if(MK_E_UNAVAILABLE == hr)
    {
        //Parse a class moniker display name.
        hr = FindClassMoniker(pbc, pwszDisplayName, &cchEaten, &pmk);
    }

    if(MK_E_UNAVAILABLE == hr)
    {
        //Parse a file moniker display name.
        hr = FindFileMoniker(pbc, pwszDisplayName, &cchEaten, &pmk);
    }

    if(FAILED(hr) && (L'@' == pwszDisplayName[0]))
    {
        //Parse the leftmost part of the display name as a ProgID.
        hr = FindProgIdMoniker(pbc, pwszDisplayName, &cchEaten, &pmk);
    }



    // Inductively consume the remainder of the display name.

    // Initialize to loop
    if(SUCCEEDED(hr))
    {
        pszRemainder  += cchEaten;
        cbUneaten     = lstrlenW(pszRemainder);
    }

    // While more display name remains, successively pass the remainder to the
    // current moniker for it to parse
    while (SUCCEEDED(hr) && cbUneaten > 0)
    {
        cchEaten = 0;
        hr = pmk->ParseDisplayName(pbc,
                                   NULL,
                                   (LPOLESTR) pszRemainder,
                                   &cchEaten,
                                   &pmkNext);

        if (SUCCEEDED(hr) && pmkNext != 0)
        {
            hr = pmk->ComposeWith(pmkNext, FALSE, &pmkTemp);
            if(SUCCEEDED(hr))
            {
                pmk->Release();
                pmk = pmkTemp;

                // Update the amount consumed so far
                pszRemainder += cchEaten;
                cbUneaten    -= cchEaten;
            }
            pmkNext->Release();
        }
    }

    *ppmk = pmk;
    *pchEaten = (ULONG) (pszRemainder - pwszDisplayName);

errRet:
   // Trace
    mnkDebugOut((DEB_ITRACE, "Out MkParseDisplayName: %ws",
                 pwszDisplayName));
    OLETRACEOUT((API_MkParseDisplayName, hr));

    return hr;
}


//+---------------------------------------------------------------------------
//
//  Function:   BindMoniker    public
//
//  Synopsis:   Given a moniker, bind to the object it names and
//              QI for the requested interface.
//
//  Arguments:  [pmk]                   -       The moniker
//              [grfOpt]                -       RESERVED (0l)
//              [iidResult]             -       Interface requested
//              [ppvResult]             -       Where to store interface
//
//  Returns:    S_OK if successful
//              Another HRESULT otherwise
//
//  Algorithm:  Create a bind context and call BindToObject on the moniker
//              within that bind context
//
//  History:    20-Jul-95 BruceMa   Rewrote
//
//  Note:       This is simply a convenience function
//
//----------------------------------------------------------------------------
STDAPI BindMoniker (LPMONIKER pmk,
                    DWORD     grfOpt,
                    REFIID    iidResult,
                    LPVOID   *ppvResult)
{
    LPBC    pbc = NULL;
    HRESULT hr;

    OLETRACEIN((API_BindMoniker, PARAMFMT("pmk= %p, grfOpt= %x, iidResult= %I, ppvResult= %p"),
                        pmk, grfOpt, &iidResult, ppvResult));

    // Validate parameters
    VDATEPTROUT_LABEL(ppvResult,LPVOID, errSafeRtn, hr);
    *ppvResult = NULL;
    VDATEIFACE_LABEL(pmk, errSafeRtn, hr);
    VDATEIID_LABEL(iidResult, errSafeRtn, hr);

    CALLHOOKOBJECT(S_OK,CLSID_NULL,IID_IMoniker,(IUnknown **)&pmk);

    if (grfOpt != 0)
    {
        hr = E_INVALIDARG;
        goto errSafeRtn;
    }

    // Initialize
    *ppvResult = NULL;

    // Create a bind context
    if (FAILED(hr = CreateBindCtx( 0, &pbc)))
    {
        goto errRtn;
    }

    // Bind to the object
    hr = pmk->BindToObject(pbc, NULL, iidResult, ppvResult);

errRtn:
    if (pbc)
    {
        pbc->Release();
    }

    // An ole spy hook
    CALLHOOKOBJECT(hr,CLSID_NULL,iidResult,(IUnknown **)ppvResult);

errSafeRtn:
    OLETRACEOUT((API_BindMoniker, hr));
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Function:   CoGetObject    public
//
//  Synopsis:   Get the object identified by the display name.
//
//  Arguments:  [pszName]      - Supplies the display name of the object.
//              [pBindOptions] - Supplies the bind options.  May be NULL.
//              [riid]         - Supplies the IID of the requested interface.
//              [ppv]          - Returns interface pointer to the object.
//
//  Returns:    S_OK if successful
//              Another HRESULT otherwise
//
//  Algorithm:  Create a bind context, parse the display name, then bind to
//              the object.
//
//  Note:       This is simply a convenience function.
//
//  History:    22-Feb-96 ShannonC  Created
//
//----------------------------------------------------------------------------
STDAPI CoGetObject(
    LPCWSTR     pszName,
    BIND_OPTS * pBindOptions,
    REFIID      riid,
    void     ** ppv)
{
    HRESULT    hr;
    IBindCtx * pbc;
    IID        iid;

    OLETRACEIN((API_CoGetObject,
               PARAMFMT("%ws, %p, %I, %p"),
               pszName, pBindOptions, &riid, ppv));

    __try
    {
        //Validate parameters.
        *ppv = 0;
        iid = riid;

        //Create a bind context.
        hr = CreateBindCtx(0, &pbc);

        if(SUCCEEDED(hr))
        {
            //Set the bind options.
            if(pBindOptions != 0)
            {
                hr = pbc->SetBindOptions(pBindOptions);
            }

            if(SUCCEEDED(hr))
            {
                IMoniker * pmk = 0;
                ULONG      chEaten = 0;

                //Parse the display name.
                hr = MkParseDisplayName(pbc, pszName, &chEaten, &pmk);
                if(SUCCEEDED(hr))
                {
                    //Bind to the object.
                    hr = pmk->BindToObject(pbc, 0, iid, ppv);
                }
                // MkParseDisplayName can return a partially constructed moniker
                // even if the function fails
                if(pmk)
                {
                    pmk->Release();
                }
            }
            pbc->Release();
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        hr = E_INVALIDARG;
    }

    CALLHOOKOBJECT(hr, CLSID_NULL, iid, (IUnknown **)ppv);
    OLETRACEOUT((API_CoGetObject, hr));
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   FindClassID    private
//
//  Synopsis:   Parse a display name to get a CLSID.
//
//  Arguments:  [pszDisplayName]        -       Display name to parse
//              [pcchEaten]             -       Number of characters eaten
//              [pClassID]              -       returns the CLSID
//
//  Returns:    S_OK if successful
//              MK_E_SYNTAX
//              E_OUTOFMEMORY
//
//  History:    22-Feb-96 ShannonC  Created
//
//----------------------------------------------------------------------------
STDAPI FindClassID(
    LPCWSTR pszDisplayName,
    ULONG * pcchEaten,
    CLSID * pClassID)
{
    HRESULT            hr = MK_E_SYNTAX;
    WCHAR const       *pch = pszDisplayName;
    ULONG              cchProgID = 0;

    mnkDebugOut((DEB_ITRACE,
                "FindClassID(%ws,%x,%x)\n",
                pszDisplayName, pcchEaten, pClassID));

    *pcchEaten = 0;

    //Check if display name contains ProgID:
    //or {xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx}:
    while (*pch != '\0' && *pch != ':')
    {
        pch++;
    }

    if(':' == *pch)
    {
        cchProgID = (ULONG) (pch - pszDisplayName);
        pch++;
    }

    //cchProgID has the number of characters in the ProgID or CLSID.
    //pch points to the next character to be parsed.
    if(cchProgID > 1)
    {
        LPWSTR psz;

        //Allocate memory from the stack.
        //This memory is freed automatically on function return.
        psz = (WCHAR *) alloca(sizeof(WCHAR) * cchProgID + sizeof(WCHAR));

        if (psz != 0)
        {
            //Copy the ProgID string.
            memcpy(psz, pszDisplayName, cchProgID * sizeof(WCHAR));

            //Add a zero terminator.
            psz[cchProgID] = '\0';

            //Convert the string to a CLSID.  Note that CLSIDFromString will
            //parse both ProgID strings and {CLSID} strings.
            hr = CLSIDFromString(psz, pClassID);

            if(SUCCEEDED(hr))
            {
                //Calculate the number of characters parsed.
                *pcchEaten = (ULONG) (pch - pszDisplayName);
            }

       }
       else
       {
           hr = E_OUTOFMEMORY;
       }
    }

    return hr;
}


//+---------------------------------------------------------------------------
//
//  Function:   FindClassMoniker    private
//
//  Synopsis:   Interpreting a display name as a ProgID, derive a
//              moniker from it.
//
//  Arguments:  [pbc]                   -       Bind context
//              [pszDisplayName]        -       Display name to parse
//              [pcchEaten]             -       Number of characters eaten
//              [ppmk]                  -       Moniker of running object
//
//  Returns:    S_OK if successful
//              MK_E_UNAVAILABLE or the return value from ParseDisplayName.
//
//  Algorithm:  Parse the first part of the display name to get a CLSID.
//              Use the CLSID to create a class moniker.
//
//  History:    22-Feb-96 ShannonC  Created
//
//----------------------------------------------------------------------------
STDAPI FindClassMoniker(
    IBindCtx * pbc,
    LPCWSTR    pszDisplayName,
    ULONG    * pcchEaten,
    IMoniker **ppmk)
{
    HRESULT hr;
    CLSID   classID;
    ULONG   cEaten = 0;

    *ppmk = 0;
    *pcchEaten = 0;

    mnkDebugOut((DEB_ITRACE,
                "FindClassMoniker(%x,%ws,%x,%x)\n",
                pbc, pszDisplayName, pcchEaten, ppmk));

    hr =  FindClassID(pszDisplayName, &cEaten, &classID);

    if(SUCCEEDED(hr))
    {
        IParseDisplayName *pPDN = NULL;
        DWORD dwClassContext;

        dwClassContext = CLSCTX_ALL;

        hr = CoGetClassObject(classID,
                              dwClassContext | CLSCTX_NO_CODE_DOWNLOAD,
                              NULL,
                              IID_IParseDisplayName,
                              (LPVOID *) &pPDN);
        if (FAILED(hr))
        {
            hr = CoCreateInstance(classID,
                                  NULL,
                                  dwClassContext | CLSCTX_NO_CODE_DOWNLOAD,
                                  IID_IParseDisplayName,
                                  (LPVOID *) &pPDN);
        }

        if(SUCCEEDED(hr))
        {
            hr = pPDN->ParseDisplayName(pbc,
                                        (LPOLESTR) pszDisplayName,
                                        pcchEaten,
                                        ppmk);
            pPDN->Release();
            return hr;
        }
    }
    return MK_E_UNAVAILABLE;
}


INTERNAL_(BOOL) RunningMoniker ( LPBINDCTX pbc,
                                 LPWSTR pszFullPath,
                                 USHORT ccFullPath,
                                 ULONG FAR *pcchEaten,
                                 LPMONIKER FAR * ppmk)
{

    mnkDebugOut((DEB_ITRACE,
                 "RunningMoniker szDisplayName(%ws)",
                 WIDECHECK(pszFullPath)));

    WCHAR ch;
    LPWSTR pch;
    HRESULT hresult;
    CFileMoniker FAR * pCFM = NULL;
    LPRUNNINGOBJECTTABLE pRot = NULL;
    BOOL retVal = FALSE;
    *pcchEaten = 0;

    pch = pszFullPath + ccFullPath;

    hresult = pbc->GetRunningObjectTable(&pRot);

    if (hresult != NOERROR) goto errRet;

    while (pch > pszFullPath)
    {
        if (IsFileSystemSeparator(*pch)  ||
            IsItemMonikerSeparator(*pch) ||
            ('\0' == *pch))
        {
            ch = *pch;
            *pch = '\0';
            hresult = CreateFileMoniker( pszFullPath, (LPMONIKER FAR *)&pCFM );
            *pch = ch;

            if(SUCCEEDED(hresult))
            {
                hresult = pRot->IsRunning(pCFM);

                //
                // If found, then pCFM is our return moniker
                //
                if (hresult == S_OK)
                {
                    *ppmk = pCFM;
                    *pcchEaten = (ULONG) (pch - pszFullPath);
                    retVal = TRUE;
                    break;
                }
                else
                {
                    //
                    // This one isn't a match. Release it and try the next smaller
                    // path
                    //

                    pCFM->Release();
                    pCFM = NULL;
                }
            }
        }
        pch--;
    }


errRet:
    if (pRot) pRot->Release();

    return retVal;
}

INTERNAL FindMaximalFileMoniker(LPWSTR pszFullPath,
                                USHORT ccFullPath,
                                ULONG FAR *pcchEaten,
                                LPMONIKER FAR * ppmk)
{
    HRESULT hr = MK_E_SYNTAX;
    WCHAR ch;
    LPWSTR pch;
    DWORD dwAttr;

    *pcchEaten = 0;
    *ppmk = 0;

    pch = pszFullPath + ccFullPath;

    while((pch > pszFullPath) &&
          (MK_E_SYNTAX == hr))
    {
        if (IsFileSystemSeparator(*pch)  ||
            IsItemMonikerSeparator(*pch) ||
            ('\0' == *pch))
        {
            ch = *pch;
            *pch = '\0';

            // Check if this path exists
            dwAttr = GetFileAttributes(pszFullPath);

            // The file exists
            if (dwAttr != 0xffffffff)
            {
                // We fail if we found a directory
                // but not a file.
                if (dwAttr & FILE_ATTRIBUTE_DIRECTORY)
                {
                    hr = MK_E_CANTOPENFILE;
                }
                else
                {
                    hr = CreateFileMoniker(pszFullPath, ppmk);
                    if(SUCCEEDED(hr))
                    {
                        *pcchEaten = (ULONG) (pch - pszFullPath);
                    }
                }
            }

            *pch = ch;
        }
        pch--;
    }

    return hr;
}


//+---------------------------------------------------------------------------
//
//  Function:   FindFileMoniker
//
//  Synopsis:   Parse a file moniker display name.
//
//  Arguments:  [pbc]                   -       Bind context
//              [pszDisplayName]        -       Display name to parse
//              [pcchEaten]             -       Number of characters eaten
//              [ppmk]                  -       Moniker of running object
//
//  Returns:    S_OK if successful
//              Another HRESULT otherwise
//
//  Algorithm:  Find the largest left-bounded name that corresponds to a
//              valid initial moniker, either of an object currently running
//              and registered in the ROT or of an extant file.
//
//  History:    22-Feb-96 ShannonC  Moved code from MkParseDisplayName.
//
//----------------------------------------------------------------------------
STDAPI  FindFileMoniker(
    LPBC       pbc,
    LPCWSTR    pszDisplayName,
    ULONG     *pcchEaten,
    LPMONIKER *ppmk)
{
    HRESULT hr = E_OUTOFMEMORY;
    USHORT ccPath;
    LPWSTR pszPath;

    ccPath = (USHORT) lstrlenW(pszDisplayName);

    pszPath = (WCHAR *) alloca((ccPath + 1) * sizeof(WCHAR));
    if(pszPath != NULL)
    {
        memcpy(pszPath, pszDisplayName, (ccPath + 1) * sizeof(WCHAR));

        if (RunningMoniker(pbc, pszPath, ccPath, pcchEaten, ppmk))
        {
            hr = S_OK;
        }
        else
        {
            hr = FindMaximalFileMoniker(pszPath, ccPath, pcchEaten, ppmk);
        }
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\ole32\com\moniker2\cobjrmon.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997 - 1997.
//
//  File:       cobjrmon.cxx
//
//  Contents:   Base64 conversion routines
//                              CObjref Moniker class and routines
//
//  Classes:
//
//  Functions:
//
//  History:    04-16-97   ronans   Created
//
//----------------------------------------------------------------------------
#include <ole2int.h>
#include "cbasemon.hxx"
#include "cptrmon.hxx"
#include "cantimon.hxx"
#include "mnk.h"
#include "cobjrmon.hxx"

// CODEWORK - ronans - this is the official base64 alphabet but it may make
// sense to substitute the '+' and '/' characters as they may not be suitable for
// internet URL usage. If we choose substitutions it is worth noting that the existing
// base64 alphabet is guarenteed have the same ASCII values across all (according to BASE64 specs)
// ISO standard character sets.

static WCHAR szBase64Alphabet[] =
{
    L'A', L'B', L'C', L'D', L'E', L'F', L'G', L'H', L'I', L'J', L'K',
    L'L', L'M', L'N', L'O', L'P', L'Q', L'R', L'S', L'T', L'U', L'V',
    L'W', L'X', L'Y', L'Z', L'a', L'b', L'c', L'd', L'e', L'f', L'g',
    L'h', L'i', L'j', L'k', L'l', L'm', L'n', L'o', L'p', L'q', L'r',
    L's', L't', L'u', L'v', L'w', L'x', L'y', L'z', L'0', L'1', L'2',
    L'3', L'4', L'5', L'6', L'7', L'8', L'9', L'+', L'/'
};

const WCHAR cPadding = L'=';    // padding character used in base 64
const BYTE  bytPadValue = 64;
//+-------------------------------------------------------------------
//
//  Function:   utByteToBase64
//
//  Synopsis:   convert a 6 bit value to the corresponding base 64 char
//
//--------------------------------------------------------------------
inline WCHAR utByteToBase64 (BYTE aByte)
{
    ASSERT(aByte < 64);
    return szBase64Alphabet[aByte];
}

//+-------------------------------------------------------------------
//
//  Function:   utBase64ToByte
//
//  Synopsis:   convert a base64 char to corresponding value
//
//  Notes: The value 64 represents a padding value
//
//--------------------------------------------------------------------
BYTE utBase64ToByte (WCHAR wch)
{
    BYTE value;

    if ((wch >= L'A') && (wch <= L'Z'))
        value = (BYTE) (wch - L'A');
    else if ((wch >= L'a') && (wch <= L'z'))
        value = 26+(BYTE) (wch - L'a');
    else if ((wch >= L'0') && (wch <= L'9'))
        value = 52+(BYTE) (wch - L'0');
    else if (wch == L'+')
        value = 62;
    else if (wch == L'/')
        value = 63;
    else
        value = bytPadValue;

	return value;
}

//+-------------------------------------------------------------------
//
//  Function:   utQuantumToBase64
//
//  Synopsis:   convert a quantum to 4 base64 chars
//
//  Notes:      nBytes is the number of bytes in the quantum - it should be less than
//              or equal three
//
//--------------------------------------------------------------------
short utQuantumToBase64(BYTE * pbByteStream, short nBytes, WCHAR *lpszOutputStream)
{
    // get quantum
    DWORD dwQuantum = 0;
    short nIndex;

    ASSERT((nBytes > 0) && (nBytes <= 3));

    // build each set of three bytes into a 24 bit quantum zero padding if necessary
    for (nIndex = 0; nIndex < 3; nIndex ++)
    {
        dwQuantum = dwQuantum << 8;
        if (nIndex < nBytes)
            dwQuantum += pbByteStream[nIndex];
    }

    // convert quantum to chars for each 6 bits of quantum
    for (nIndex = 0; nIndex < 4; nIndex ++)
    {
        BYTE bytChar = (BYTE)(dwQuantum & 0x3F);
        WCHAR wch;

        // check for padding cases - essentially if we have 2 bytes in our quantum we will add one
        // padding char. If we have one byte in our quantum we will add 2 padding chars
        if (!bytChar)
        {
            if ((nBytes == 2) && (nIndex == 0))
                wch = cPadding;
            else if ((nBytes == 1) && (nIndex <= 1))
                wch = cPadding;
            else
                wch = L'A'; // base 64 representation of 0
        }
        else
            wch = utByteToBase64(bytChar);

        lpszOutputStream[3 - nIndex] = wch;
        dwQuantum = dwQuantum >> 6;
    }

    // return number of non pad chars
    return nBytes+1;
}


//+-------------------------------------------------------------------
//
//  Function:   utByteStreamToBase64
//
//  Synopsis:   convert a bytestream to a base64 stream
//
//  returns:    Size of output stream in characters
//
//	Note:		not true Base64 as no line breaks are embedded
//
//--------------------------------------------------------------------
long utByteStreamToBase64(BYTE * pbByteStream, long nBytes, WCHAR *lpszOutputStream)
{
    int nIndexOut = 0;
    int nIndexIn = 0;

    // write out data - processing in quantums of up to three bytes

    for (nIndexIn = 0; nIndexIn < nBytes; nIndexIn += 3)
    {
        utQuantumToBase64(&pbByteStream[nIndexIn],
                          (short) (((nBytes - nIndexIn)  < 3) ? (short)(nBytes - nIndexIn)  : 3),
                          &lpszOutputStream[nIndexOut]);
        nIndexOut += 4;
    }
    // write out terminating null
    lpszOutputStream[nIndexOut++] = L'\0';

    /// return total chars written.
    return nIndexOut;
}

//+-------------------------------------------------------------------
//
//  Function:   utBase64ToQuantum
//
//  Synopsis:   convert 4 base64 chars to quantum of 1 to 3 bytes
//
//  Returns:    Number of bytes translated into quantum
//
//--------------------------------------------------------------------
short utBase64ToQuantum(WCHAR *lpszInputStream, BYTE * pbByteStream)
{
    // get quantum
    DWORD dwQuantum = 0;
    short nPadChars = 0;
    short nIndex;
    short nBytes;

    ASSERT(lpszInputStream );
    ASSERT(lstrlenW(lpszInputStream) >= 4 );
    ASSERT(pbByteStream);

    // build each set of four characters into a 24 bit quantum
    for (nIndex = 0; nIndex < 4; nIndex ++)
    {
        dwQuantum = dwQuantum << 6;

        BYTE bytChar = utBase64ToByte(lpszInputStream[nIndex]);

        if (bytChar == bytPadValue )
            nPadChars++;
        else
            dwQuantum += bytChar;
    }

    // calculate number of bytes
    nBytes = 3 - nPadChars;

    // convert quantum to bytes for each 8 bits of quantum
    for (nIndex = 0; nIndex < 3; nIndex ++)
    {
        BYTE bytChar = (BYTE)(dwQuantum & 0xFF);
        WCHAR wch;

        // check for padding cases
        if (nIndex >= nPadChars)
            pbByteStream[2 - nIndex] = bytChar;
        dwQuantum = dwQuantum >> 8;
    }

    // return number of bytes written
    return nBytes;
}

//+-------------------------------------------------------------------
//
//  Function:   utBase64ToByteStream
//
//  Synopsis:   convert a base64 stream to a byte stream
//
//  returns:    Size of output stream in characters
//
//	Note:		not true Base64 as no line breaks are embedded
//
//--------------------------------------------------------------------
long utBase64ToByteStream(WCHAR *lpszInputStream, BYTE * pbByteStream)
{
    ASSERT(lpszInputStream);
    ASSERT(pbByteStream);
    long nBase64len = lstrlenW(lpszInputStream);

    // the input stream should be an exact multiple of 4.
    ASSERT(nBase64len % 4 == 0);

    int nIndexOut = 0;
    int nIndexIn = 0;

    for (nIndexIn = 0; nIndexIn < nBase64len; nIndexIn += 4)
    {
        nIndexOut += utBase64ToQuantum(&lpszInputStream[nIndexIn],
                                        &pbByteStream[nIndexOut]);
    }

    /// return total bytes written.
    return nIndexOut;
}

//+-------------------------------------------------------------------
//
//  Function:   utBase64ToIStream
//
//  Synopsis:   convert a base64 stream to an IStream containing the binary data
//
//  returns:    The allocated stream
//
//      Note:
//
//--------------------------------------------------------------------
IStream * utBase64ToIStream(WCHAR *pszBase64)
{
	int cChars = lstrlenW(pszBase64);

	// verify the string length is a multiple of 4
	//
	if((cChars % 4) != 0)
		return NULL;

    // calculate stream size
    ULONG strSize = (cChars / 4) * 3;

    IStream *pIStream = NULL;
    HRESULT hr = CreateStreamOnHGlobal(NULL, TRUE, &pIStream);

    if (SUCCEEDED(hr))
    {
        HGLOBAL hgl;
        ULARGE_INTEGER uli;

        ULISet32(uli, strSize);
        pIStream -> SetSize(uli);
        hr = GetHGlobalFromStream(pIStream, &hgl);

        if (SUCCEEDED(hr))
        {
            BYTE * pbStream = (BYTE*)GlobalLock(hgl);
            if (pbStream)
            {
                utBase64ToByteStream(pszBase64, pbStream);
                GlobalUnlock(hgl);
            }
        }
        else
        {
            pIStream -> Release();
            return NULL;
        }

        return pIStream;
    }

    return NULL;
}

//+-------------------------------------------------------------------
//
//  Function:   utIStreamToBase64
//
//  Synopsis:   convert a stream containing binary data to a base64 string
//
//  returns:    The success code
//
//      Note:
//
//--------------------------------------------------------------------
HRESULT utIStreamToBase64(IStream* pIStream, WCHAR * pszOutStream, ULONG cbOutStreamSize)
{
    ASSERT(pIStream != NULL);
    ASSERT(pszOutStream != NULL);

	if(!pszOutStream || !pIStream)
		return E_INVALIDARG;
	
    // calculate size needed for buffer;
    STATSTG strmStat;
    HRESULT hr = pIStream -> Stat(&strmStat, STATFLAG_NONAME);

    if (SUCCEEDED(hr))
    {
        ULONG strmSize;
        ULIGet32(strmStat. cbSize, strmSize);

        // allocate buffer for stream
        BYTE *pbStream = (BYTE*)CoTaskMemAlloc( strmSize);
        if (pbStream)
        {
            ULONG cbBytesRead = 0;
            hr = pIStream -> Read((void*)pbStream, strmSize, &cbBytesRead);
            if (SUCCEEDED(hr) && cbBytesRead)
            {
                // allocate WCHAR buffer for base64 data if needed
                ULONG cbOutStream = ((ULONG)((cbBytesRead+2) / 3)) * 4;

                // check that output stream is of sufficient size
                if (pszOutStream && (cbOutStreamSize >= ((cbOutStream + 1) *sizeof(WCHAR))))
                    utByteStreamToBase64(pbStream, cbBytesRead, pszOutStream);
                else
                    hr = E_OUTOFMEMORY;
            }
            CoTaskMemFree(pbStream);
        }
        else
            hr = E_OUTOFMEMORY;
    }

    return hr;
}




//+---------------------------------------------------------------------------
//
//  Method:     CObjrefMoniker::CObjrefMoniker
//
//  Synopsis:   Constructor
//
//  Arguments:  [pUnk] --
//
//  Returns:    -
//
//  Algorithm:
//
//  History:    04-Apr 97   Ronans
//
//----------------------------------------------------------------------------
CObjrefMoniker::CObjrefMoniker( LPUNKNOWN pUnk )
: CPointerMoniker(pUnk)
{
	// no special behavior - just want to distinguish for debugging at present
    mnkDebugOut((DEB_ITRACE,
                "CObjrefMoniker::constructor(%x,%x)\n",
                this, pUnk));

    m_lpszDisplayName = NULL;
}


//+---------------------------------------------------------------------------
//
//  Method:     CObjrefMoniker::~CObjrefMoniker
//
//  Synopsis:   Destructor
//
//  Arguments:  -
//
//  Returns:    -
//
//  Algorithm:
//
//  History:    04-Apr 97   Ronans
//
//----------------------------------------------------------------------------
CObjrefMoniker::~CObjrefMoniker( void )
{
	// no special behavior - just want to distinguish for debugging at present
    mnkDebugOut((DEB_ITRACE,
                "CObjrefMoniker::destructor(%x,%x)\n",
                this, m_pUnk));

    if (m_lpszDisplayName)
    {
        CoTaskMemFree(m_lpszDisplayName);
    }
}


//+---------------------------------------------------------------------------
//
//  Function:   IsObjrefMoniker : Private
//
//  Synopsis:   Constructor
//
//  Arguments:  [pmk] --
//
//  Returns:    pmk if it supprts CLSID_ObjrefMoniker
//              NULL otherwise
//
//  Algorithm:
//
//  History:    04-Apr-97  ronans       Created
//
//----------------------------------------------------------------------------
INTERNAL_(CObjrefMoniker *) IsObjrefMoniker ( LPMONIKER pmk )
{
    CObjrefMoniker *pCORM;

    if ((pmk->QueryInterface(CLSID_ObjrefMoniker, (void **)&pCORM)) == S_OK)
    {
        // we release the AddRef done by QI but return the pointer
        pCORM->Release();
        return pCORM;
    }

    // dont rely on user implementations to set pCORM to NULL on failed QI
    return NULL;
}

//+---------------------------------------------------------------------------
//
//  Method:     CObjrefMoniker::Create
//
//  Synopsis:   Create a new objref moniker
//
//  Arguments:  [pmk] --
//
//  Returns:    pmk if it supprts CLSID_ObjrefMoniker
//              NULL otherwise
//
//  Algorithm:
//
//  History:    04-Apr-97  ronans       Created
//
//----------------------------------------------------------------------------
CObjrefMoniker *CObjrefMoniker::Create(LPUNKNOWN pUnk )
{
    mnkDebugOut((DEB_ITRACE, "CObjrefMoniker::Create(%x)\n", pUnk ));
    CObjrefMoniker *pCORM = new CObjrefMoniker(pUnk);

    return pCORM;
}


//+---------------------------------------------------------------------------
//
//  Method:     CObjrefMoniker::QueryInterface
//
//  Synopsis:
//
//  Arguments:  [riid]
//              [ppvObj]
//
//  Returns:
//
//  Algorithm:
//
//  History:    04-Apr-97  ronans       Created
//
//----------------------------------------------------------------------------
STDMETHODIMP CObjrefMoniker::QueryInterface (THIS_ REFIID riid, LPVOID *ppvObj)
{
    M_PROLOG(this);
    VDATEIID (riid);
    VDATEPTROUT(ppvObj, LPVOID);

#ifdef _DEBUG
    if (riid == IID_IDebug)
    {
	*ppvObj = &(m_Debug);
	return NOERROR;
    }
#endif

    if (IsEqualIID(riid, CLSID_ObjrefMoniker))
    {
        //  called by IsObjrefMoniker.
        AddRef();
        *ppvObj = this;
        return S_OK;
    }

    return CPointerMoniker::QueryInterface(riid, ppvObj);
}

//+---------------------------------------------------------------------------
//
//  Method:     CObjrefMoniker::GetClassId
//
//  Synopsis:
//
//  Arguments:  [riid]
//              [ppvObj]
//
//  Returns:
//
//  Algorithm:
//
//  History:    04-Apr-97  ronans       Created
//
//----------------------------------------------------------------------------
STDMETHODIMP CObjrefMoniker::GetClassID (LPCLSID lpClassId)
{
    M_PROLOG(this);
    VDATEPTROUT(lpClassId, CLSID);

    *lpClassId = CLSID_ObjrefMoniker;
    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Method:     CObjrefMoniker::IsEqual
//
//  Synopsis:
//
//  Arguments:  [pmkOtherMoniker]
//
//  Returns:
//
//  Algorithm:
//
//  History:    04-Apr-97  ronans       Created
//
//----------------------------------------------------------------------------
STDMETHODIMP CObjrefMoniker::IsEqual  (THIS_ LPMONIKER pmkOtherMoniker)
{
    M_PROLOG(this);
    VDATEIFACE(pmkOtherMoniker);

    CObjrefMoniker FAR* pCIM = IsObjrefMoniker(pmkOtherMoniker);
    if (pCIM)
    {
        // the other moniker is an objref moniker.
        //for the names, we do a case-insensitive compare.
        if (m_pUnk == pCIM->m_pUnk)
        {
            return